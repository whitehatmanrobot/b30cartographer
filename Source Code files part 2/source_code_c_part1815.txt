/  TmReg.cpp - theme manager registry access routines
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "TmReg.h"
#include "Utils.h"
//---------------------------------------------------------------------------

//  --------------------------------------------------------------------------
//  CCurrentUser::CCurrentUser
//
//  Arguments:  samDesired  =   Desired access to the HKEY.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CCurrentUser. This class transparently allows
//              access to HKEY_CURRENT_USER while impersonating a user.
//
//  History:    2000-08-11  vtan        created
//  --------------------------------------------------------------------------

CCurrentUser::CCurrentUser (REGSAM samDesired) :
    _hKeyCurrentUser(NULL)

{
    (BOOL)RegOpenCurrentUser(samDesired, &_hKeyCurrentUser);
}

//  --------------------------------------------------------------------------
//  CCurrentUser::~CCurrentUser
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CCurrentUser. Close opened resources.
//
//  History:    2000-08-11  vtan        created
//  --------------------------------------------------------------------------

CCurrentUser::~CCurrentUser (void)

{
    if (_hKeyCurrentUser != NULL)
    {
        (LONG)RegCloseKey(_hKeyCurrentUser);
        _hKeyCurrentUser = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CCurrentUser::operator HKEY
//
//  Arguments:  <none>
//
//  Returns:    HKEY
//
//  Purpose:    Magical C++ operator to convert object to HKEY.
//
//  History:    2000-08-11  vtan        created
//  --------------------------------------------------------------------------

CCurrentUser::operator HKEY (void)  const

{
    return(_hKeyCurrentUser);
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
HRESULT SetCurrentUserThemeString(LPCWSTR pszValueName, LPCWSTR pszValue)
{
    return SetCurrentUserString(THEMEMGR_REGKEY, pszValueName, pszValue);
}

//---------------------------------------------------------------------------
HRESULT SetCurrentUserThemeStringExpand(LPCWSTR pszValueName, LPCWSTR pszValue)
{
    WCHAR szResult[_MAX_PATH + 1];
    LPCWSTR pszPath = pszValue;

    if (UnExpandEnvironmentString(pszValue, L"%SystemRoot%", szResult, ARRAYSIZE(szResult)))
        pszPath = szResult;
    return SetCurrentUserThemeString(pszValueName, pszPath);
}

//---------------------------------------------------------------------------
HRESULT GetCurrentUserThemeString(LPCWSTR pszValueName, LPCWSTR pszDefaultValue,
    LPWSTR pszBuff, DWORD dwMaxBuffChars)
{
    return GetCurrentUserString(THEMEMGR_REGKEY, pszValueName, pszDefaultValue, pszBuff, dwMaxBuffChars);
}

//---------------------------------------------------------------------------
HRESULT SetCurrentUserString(LPCWSTR pszKeyName, LPCWSTR pszValueName, LPCWSTR pszValue)
{
    CCurrentUser    hKeyCurrentUser(KEY_READ | KEY_WRITE);

    RESOURCE HKEY tmkey = NULL;
    LONG code32;
    HRESULT hr = S_OK;

    if (! pszValue)
        pszValue = L"";

    //---- create or open existing key ----
    code32 = RegCreateKeyEx(hKeyCurrentUser, pszKeyName, NULL, NULL, 
        REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &tmkey, NULL);
    WIN32_EXIT(code32);

    //---- write key value ----
    DWORD len;
    len = sizeof(WCHAR)*(1+lstrlen(pszValue));

    DWORD dwValType;
    dwValType = REG_SZ;
    if (wcschr(pszValue, '%'))
        dwValType = REG_EXPAND_SZ;

    code32 = RegSetValueEx(tmkey, pszValueName, NULL, dwValType, (BYTE *)pszValue, len);
    WIN32_EXIT(code32);

exit:
    RegCloseKey(tmkey);
    return hr;
}

//---------------------------------------------------------------------------
BOOL IsRemoteThemeDisabled()
{
    //---- has Terminal Server written a special key to turn themes off ----
    //---- for this session? ----

    CCurrentUser hKeyCurrentUser(KEY_READ | KEY_WRITE);
    BOOL fDisabled = FALSE;

    BOOL fRemote = GetSystemMetrics(SM_REMOTESESSION);
    if (fRemote)        // running TS remote session
    {
        //---- build the remote key name ----
        WCHAR szKeyName[MAX_PATH];

        wsprintf(szKeyName, L"%s\\Remote\\%d", THEMEMGR_REGKEY, NtCurrentPeb()->SessionId);

        //---- see if the root key exists ----
        HKEY tmkey;
        LONG code32 = RegOpenKeyEx(hKeyCurrentUser, szKeyName, NULL, KEY_QUERY_VALUE,
            &tmkey);
        if (code32 == ERROR_SUCCESS)
        {
            fDisabled = TRUE;     // key itself is sufficient
            RegCloseKey(tmkey);
        }
    }

    return fDisabled;
}
//---------------------------------------------------------------------------
HRESULT GetCurrentUserString(LPCWSTR pszKeyName, LPCWSTR pszValueName, LPCWSTR pszDefaultValue,
    LPWSTR pszBuff, DWORD dwMaxBuffChars)
{
    CCurrentUser    hKeyCurrentUser(KEY_READ | KEY_WRITE);

    HRESULT hr = S_OK;
    LONG code32;
    RESOURCE HKEY tmkey = NULL;

    if (! pszBuff)
        return MakeError32(E_INVALIDARG);

    DWORD dwByteSize = dwMaxBuffChars * sizeof(WCHAR);      
    DWORD dwValType = 0;

    code32 = RegOpenKeyEx(hKeyCurrentUser, pszKeyName, NULL, KEY_QUERY_VALUE,
        &tmkey);
    if (code32 == ERROR_SUCCESS)
    {
        code32 = RegQueryValueEx(tmkey, pszValueName, NULL, &dwValType, (BYTE *)pszBuff, 
            &dwByteSize);
    }

    if (code32 != ERROR_SUCCESS)        // error - use default value
    {
        hr = hr_lstrcpy(pszBuff, pszDefaultValue, dwMaxBuffChars);
        if (FAILED(hr))
            goto exit;
    }

    if (dwValType == REG_EXPAND_SZ || wcschr(pszBuff, L'%'))
    {
        int len = sizeof(WCHAR) * (1 + lstrlen(pszBuff));
        LPWSTR szTempBuff = (LPWSTR)alloca(len);
        if (szTempBuff)
        {
            lstrcpy(szTempBuff, pszBuff);

            DWORD dwChars = ExpandEnvironmentStrings(szTempBuff, pszBuff, dwMaxBuffChars);
            if (dwChars > dwMaxBuffChars)           // caller's buffer too small
            {
                hr = MakeError32(ERROR_INSUFFICIENT_BUFFER);
                goto exit;
            }
        }
    }

exit:
    RegCloseKey(tmkey);

    return hr;
}

//---------------------------------------------------------------------------
HRESULT GetCurrentUserThemeInt(LPCWSTR pszValueName, int iDefaultValue, int *piValue)
{
    CCurrentUser    hKeyCurrentUser(KEY_READ | KEY_WRITE);

    LONG code32;

    if (! piValue)
        return MakeError32(E_INVALIDARG);

    TCHAR valbuff[_MAX_PATH+1];
    DWORD dwByteSize = sizeof(valbuff);
    RESOURCE HKEY tmkey = NULL;

    code32 = RegOpenKeyEx(hKeyCurrentUser, THEMEMGR_REGKEY, NULL, KEY_QUERY_VALUE,
        &tmkey);
    if (code32 == ERROR_SUCCESS)
    {
        DWORD dwValType;
        code32 = RegQueryValueEx(tmkey, pszValueName, NULL, &dwValType, 
            (BYTE *)valbuff, &dwByteSize);
    }

    if (code32 != ERROR_SUCCESS)        // call failed - use default value
        *piValue = iDefaultValue;
    else
    {
        *piValue = string2number(valbuff);
    }

    RegCloseKey(tmkey);

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT SetCurrentUserThemeInt(LPCWSTR pszValueName, int iValue)
{
    CCurrentUser    hKeyCurrentUser(KEY_READ | KEY_WRITE);

    TCHAR valbuff[_MAX_PATH+1];
    RESOURCE HKEY tmkey = NULL;
    LONG code32;
    HRESULT hr = S_OK;

    //---- create or open existing key ----
    code32 = RegCreateKeyEx(hKeyCurrentUser, THEMEMGR_REGKEY, NULL, NULL, 
        REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &tmkey, NULL);
    WIN32_EXIT(code32);

    //---- write key value ----
    wsprintf(valbuff, L"%d", iValue);
    DWORD len;
    len = sizeof(TCHAR)*(1+lstrlen(valbuff));

    code32 = RegSetValueEx(tmkey, pszValueName, NULL, REG_SZ, 
        (BYTE *)valbuff, len);
    WIN32_EXIT(code32);

exit:
    RegCloseKey(tmkey);
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT DeleteCurrentUserThemeValue(LPCWSTR pszKeyName)
{
    CCurrentUser    hKeyCurrentUser(KEY_WRITE);

    RESOURCE HKEY tmkey = NULL;
    LONG code32;
    HRESULT hr = S_OK;

    //---- create or open existing key ----
    code32 = RegCreateKeyEx(hKeyCurrentUser, THEMEMGR_REGKEY, NULL, NULL, 
        REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &tmkey, NULL);
    WIN32_EXIT(code32);
    
    code32 = RegDeleteValue(tmkey, pszKeyName);
    WIN32_EXIT(code32);

exit:
    RegCloseKey(tmkey);
    return hr;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themesel\pch.cpp ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themesel\pch.h ===
// pch.h

#ifndef __PCH_H__
#define __PCH_H__

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

//  CRT headers
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//#include <crtdbg.h>
#include <stdlib.h>
#include <stddef.h>
//#include <tchar.h>

// Windows Header Files:
#include <windows.h>
#include <winuser.h>
#include <winnls.h>

#include <psapi.h>
#include <commctrl.h>
#include <prsht.h>
//#include <ole2.h>
#include <port32.h>

//  UxTheme proj common headers
#include "autos.h"
#include "log.h"
#include "errors.h"
#include "utils.h"
#include "tmreg.h"

#include <uxthemep.h>
#include <atlbase.h>

//---- keep this for a while (allows building on win2000 for home development) ----
#ifndef SPI_GETDROPSHADOW
#define SPI_GETDROPSHADOW                   0x1024
#define SPI_SETDROPSHADOW                   0x1025
#endif

extern HINSTANCE      g_hInst;
extern HWND           g_hwndMain;
extern TCHAR          g_szAppTitle[];
extern UINT           WM_THEMESEL_COMMUNICATION;

void _ShutDown( BOOL bQuit );
void _RestoreSystemSettings( HWND hwndGeneralPage, BOOL fUnloadOneOnly );
void _SaveSystemSettings( );

#endif // __PCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themesel\pageinfo.h ===
#ifndef __PAGEINFO_H__
#define __PAGEINFO_H__

typedef HWND (CALLBACK *PAGECREATEINSTANCEPROC)(HWND hwndParent); 
//-------------------------------------------------------------------------//
typedef struct
{
    PAGECREATEINSTANCEPROC pfnCreateInstance;
    UINT                   nIDSTitle;

} PAGEINFO;

extern const int        g_cPageInfo;
extern const PAGEINFO   g_rgPageInfo[];

#endif __PAGEINFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themesel\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ThemeSel.rc
//
#define IDC_MYICON                      2
#define IDD_PAGE_GENERAL                101
#define IDD_THEMESEL_DIALOG             102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDS_PAGE_GENERAL                104
#define IDD_SYNTAX                      104
#define IDM_EXIT                        105
#define IDS_PAGE_SAMPLE                 105
#define IDS_PAGE_STYLES                 105
#define IDM_APPLY                       106
#define IDS_HELLO                       106
#define IDS_PAGE_SCROLLBARS             106
#define IDM_REMOVE                      107
#define IDI_THEMESEL                    107
#define IDI_SMALL                       108
#define IDC_THEMESEL                    109
#define IDS_PAGE_STATICS                110
#define IDS_PAGE_BUTTONS                111
#define IDS_PAGE_EDIT                   112
#define IDS_PAGE_LISTS                  113
#define IDS_PAGE_MOVERS                 114
#define IDS_PAGE_LISTVIEW               115
#define IDS_PAGE_TREEVIEW               116
#define IDS_PAGE_PICKERS                117
#define IDS_PAGE_BARS                   118
#define IDR_MAINFRAME                   128
#define IDD_SCROLLBARS                  129
#define IDD_EDIT                        130
#define IDD_PICKERS                     131
#define IDD_LISTVIEW                    132
#define IDD_BUTTONS                     133
#define IDD_TREEVIEW                    134
#define IDD_LISTS                       136
#define IDD_MOVERS                      138
#define IDD_STATICS                     139
#define IDD_BARS                        140
#define IDR_TOOLBAR1                    141
#define IDD_PAGE_STYLES                 142
#define IDB_BACKGROUND                  143
#define IDC_TESTBUTTON                  1000
#define IDC_WS_MINIMIZEBOX              1000
#define IDC_SBHORZ                      1000
#define IDC_MSGBOXBUTTON                1001
#define IDC_CLEARBUTTON                 1001
#define IDC_WS_MAXIMIZEBOX              1001
#define IDC_VERTICAL                    1001
#define IDC_EDIT3                       1001
#define IDC_EDITTHEME                   1002
#define IDC_WS_CAPTION                  1002
#define IDC_EDIT_THEME                  1002
#define IDC_HORIZONTAL                  1002
#define IDC_WS_BORDER                   1003
#define IDC_WS_DLGFRAME                 1004
#define IDC_THEME_ALL                   1004
#define IDC_WS_VSCROLL                  1005
#define IDC_SBCTL_PORT                  1005
#define IDC_WS_HSCROLL                  1006
#define IDC_THEME_PROCESS               1006
#define IDC_WINDOW_SB                   1006
#define IDC_WS_SYSMENU                  1007
#define IDC_TARGET                      1007
#define IDC_SBCTL_PORT2                 1007
#define IDC_SBCTL_STANDARD              1007
#define IDC_WS_THICKFRAME               1008
#define IDC_ENABLEHOOK                  1008
#define IDC_ENABLE_TEMPCTL              1008
#define IDC_WS_OVERLAPPEDWINDOW         1009
#define IDC_ENABLE_FRAME                1009
#define IDC_WS_MINIMIZEBOX2             1009
#define IDC_WS_POPUPWINDOW              1010
#define IDC_ENABLE_DLG                  1010
#define IDC_MIN                         1010
#define IDC_WS_MAXIMIZEBOX2             1010
#define IDC_THEME_EXEMPT                1011
#define IDC_MAX                         1011
#define IDC_WS_CAPTION2                 1011
#define IDC_UNTARGET                    1012
#define IDC_PAGE                        1012
#define IDC_WS_BORDER2                  1012
#define IDC_POS                         1013
#define IDC_WS_DLGFRAME2                1013
#define IDC_THEME_EXEMPT2               1013
#define IDC_USERSWITCH                  1013
#define IDC_TRACKPOS                    1014
#define IDC_WS_VSCROLL2                 1014
#define IDC_WS_HSCROLL2                 1015
#define IDC_WS_SYSMENU2                 1016
#define IDC_MSGLIST                     1017
#define IDC_WS_THICKFRAME2              1017
#define IDC_SBVERT                      1019
#define IDC_EDIT1                       1024
#define IDC_BUTTON1                     1025
#define IDC_EDIT2                       1026
#define IDC_CHECK1                      1027
#define IDC_RADIO1                      1028
#define IDC_BUTTON4                     1029
#define IDC_COMBO1                      1030
#define IDC_LIST1                       1031
#define IDC_BUTTON5                     1032
#define IDC_LIST2                       1033
#define IDC_RADIO2                      1034
#define IDC_COMBO2                      1035
#define IDC_SPIN1                       1036
#define IDC_RADIO3                      1037
#define IDC_COMBO3                      1038
#define IDC_WS_EX_DLGMODALFRAME         1050
#define IDC_SBVERTP                     1051
#define IDC_WS_EX_DLGMODALFRAME2        1051
#define IDC_CHECK2                      1052
#define IDC_PROGRESS1                   1053
#define IDC_WS_EX_TOOLWINDOW            1060
#define IDC_SBHORZP                     1061
#define IDC_WS_EX_TOOLWINDOW2           1061
#define IDC_CHECK3                      1062
#define IDC_PROGRESS2                   1063
#define IDC_HOTKEY1                     1064
#define IDC_WS_EX_WINDOWEDGE            1065
#define IDC_SLIDER1                     1066
#define IDC_WS_EX_WINDOWEDGE2           1066
#define IDC_WS_EX_CLIENTEDGE            1067
#define IDC_TAB1                        1068
#define IDC_WS_EX_CLIENTEDGE2           1068
#define IDC_SLIDER2                     1069
#define IDC_ANIMATE1                    1080
#define IDC_WS_EX_CONTEXTHELP           1081
#define IDC_BUTTON2                     1082
#define IDC_WS_EX_CONTEXTHELP2          1082
#define IDC_SPIN3                       1083
#define IDC_TAB2                        1084
#define IDC_WS_EX_RIGHT                 1085
#define IDC_RICHEDIT2                   1086
#define IDC_WS_EX_RIGHT2                1086
#define IDC_BUTTON6                     1087
#define IDC_WS_EX_LEFT                  1088
#define IDC_DATETIMEPICKER1             1089
#define IDC_WS_EX_LEFT2                 1089
#define IDC_BUTTON3                     1100
#define IDC_WS_EX_RTLREADING            1101
#define IDC_MONTHCALENDAR1              1102
#define IDC_WS_EX_RTLREADING2           1102
#define IDC_BUTTON7                     1103
#define IDC_WS_EX_LEFTSCROLLBAR         1104
#define IDC_BUTTON8                     1105
#define IDC_WS_EX_LEFTSCROLLBAR2        1105
#define IDC_IPADDRESS1                  1106
#define IDC_WS_EX_RIGHTSCROLLBAR        1107
#define IDC_COMBOBOXEX1                 1108
#define IDC_WS_EX_RIGHTSCROLLBAR2       1108
#define IDC_WS_EX_STATICEDGE            1109
#define IDC_WS_EX_STATICEDGE2           1110
#define IDC_TREE1                       1120
#define IDC_COMBOBOXEX2                 1121
#define IDC_WS_EX_APPWINDOW             1122
#define IDC_TREE2                       1123
#define IDC_WS_EX_APPWINDOW2            1123
#define IDC_COMBOBOXEX3                 1124
#define IDC_WS_EX_OVERLAPPEDWINDOW      1125
#define IDC_SCROLLBAR1                  1126
#define IDC_WS_EX_OVERLAPPEDWINDOW2     1126
#define IDC_WS_EX_PALETTEWINDOW         1127
#define IDC_SCROLLBAR2                  1128
#define IDC_WS_EX_PALETTEWINDOW2        1128
#define IDC_RICHEDIT3                   1129
#define IDC_TOOLBAR1                    1140
#define IDC_WS_EX_LAYOUTRTL             1141
#define IDC_REBAR1                      1142
#define IDC_WS_EX_LAYOUTRTL2            1142
#define IDC_HEADER1                     1143
#define IDC_SPIN4                       1144
#define IDC_CUSTOM5                     1145
#define IDC_STATUS1                     1146
#define IDC_THEME_PREVIEW               1147
#define IDC_TARGETGROUP                 1148
#define IDC_TEST_WINDOW                 1200
#define IDC_PREVIEW                     1200
#define IDC_TEST_DIALOG                 1201
#define IDC_DISPLAYNAME                 1201
#define IDC_CLOSE_TEST_WINDOW           1202
#define IDC_TOOLTIP                     1202
#define IDC_WS_OVERLAPPED2              1203
#define IDC_AUTHOR                      1203
#define IDC_WS_POPUP2                   1205
#define IDC_WS_CHILD2                   1206
#define ID_BUTTON32774                  32774
#define ID_BUTTON32775                  32775
#define ID_BUTTON32776                  32776
#define ID_BUTTON32777                  32777
#define IDM_DUMP                        32778
#define IDC_DIRPROMPT                   35001
#define IDC_DIRNAME                     35002
#define IDC_COLORCOMBO                  35005
#define IDC_FONTCOMBO                   35006
#define IDC_SIZECOMBO                   35007
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        250
#define _APS_NEXT_COMMAND_VALUE         32779
#define _APS_NEXT_CONTROL_VALUE         1204
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themesel\sample.h ===
//---------------------------------------------------------------------------
//  Sample.h - dialog for sampling the active theme
//---------------------------------------------------------------------------
#pragma once
#include "resource.h"
//---------------------------------------------------------------------------
class CSample : public CDialogImpl<CSample>
{
public:
    CSample();

BEGIN_MSG_MAP(CSample)
    COMMAND_HANDLER(IDC_MSGBOXBUTTON, BN_CLICKED, OnMsgBox)
    COMMAND_HANDLER(IDC_EDITTHEME, BN_CLICKED, OnEditTheme)

    MESSAGE_HANDLER(WM_CLOSE, OnClose);
END_MSG_MAP()

enum {IDD = THEME_SAMPLE};

protected:
    //---- helpers ----
    LRESULT OnMsgBox(UINT, UINT, HWND, BOOL&);
    LRESULT OnEditTheme(UINT, UINT, HWND, BOOL&);

    LRESULT OnClose(UINT, WPARAM, LPARAM, BOOL&);
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themesel\samples.cpp ===
#include "pch.h"
#include "resource.h"
#include "main.h"

//-------------------------------------------------------------------------//
//  impl for all Samples pages
//-------------------------------------------------------------------------//

INT_PTR CALLBACK Shared_DlgProc( HWND hwndPage, UINT, WPARAM , LPARAM );

INT_PTR CALLBACK Pickers_DlgProc( HWND hwndPage, UINT, WPARAM , LPARAM );
INT_PTR CALLBACK Movers_DlgProc( HWND hwndPage, UINT, WPARAM , LPARAM );
INT_PTR CALLBACK Lists_DlgProc( HWND hwndPage, UINT, WPARAM , LPARAM );
INT_PTR CALLBACK ListView_DlgProc( HWND hwndPage, UINT, WPARAM , LPARAM );
INT_PTR CALLBACK TreeView_DlgProc( HWND hwndPage, UINT, WPARAM , LPARAM );
INT_PTR CALLBACK Bars_DlgProc( HWND hwndPage, UINT, WPARAM , LPARAM );

void Pickers_Init(HWND hwndPage);
void Movers_Init(HWND hwndPage);
void Lists_Init(HWND hwndPage);
void ListView_Init(HWND hwndPage, int iControlId);
void TreeView_Init(HWND hwndPage, int iControlId);

//---- init routines for "bars" dialog ----
void Header_Init(HWND hwndPage, int iControlId);
void Status_Init(HWND hwndPage, int iControlId);
void Toolbar_Init(HWND hwndPage, int iControlId, int iMaxButtons);
void Rebar_Init(HWND hwndPage, int iControlId);
//-------------------------------------------------------------------------//
// shared sample data

static WCHAR *Names[] = {L"One", L"Two", L"Three", L"Four", L"Five", L"Six",
    L"Seven", L"Eight", L"Nine", L"Ten", L"Eleven", L"Twelve", 
    L"Thirteen", L"Fourteen", L"Fifteen", L"Sixteen"};

static WCHAR *Buttons[] = {L"New", L"Open", L"Save", L"Cut",  L"Copy", L"Delete", 
    L"Undo", L"Redo", L"Print", L"Help\0"};

static int ButtonIndexes[] = {STD_FILENEW, STD_FILEOPEN, STD_FILESAVE, 
    STD_CUT, STD_COPY, STD_DELETE, STD_UNDO, STD_REDOW, STD_PRINT, STD_HELP};

static WCHAR *Columns[] = {L"Name", L"Phone", L"City", L"State"};

static WCHAR *Col1Items[] = {L"Chris", L"Lou", L"Richard", L"Mark", L"Roland", L"Paul",
    L"Scott", L"Aaron", L"Greg", L"Ken"};

static WCHAR *Col2Items[] = {L"555-1212", L"567-3434", L"656-4432", L"343-7788", L"706-0225", L"828-3043",
    L"706-4433", L"882-8080", L"334-3434", L"333-5430"};

static WCHAR *Col3Items[] = {L"Seattle", L"Redmond", L"Bellevue", L"Seattle", L"Woodinville", L"Kirkland",
    L"Kirkland", L"Woodinville", L"Redmond", L"Redmond"};
//-------------------------------------------------------------------------//
INT_PTR CALLBACK Shared_DlgProc( HWND hwndPage, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    BOOL    bHandled = TRUE;
    LRESULT lRet = 0L; 
    switch( uMsg )
    {
        case WM_INITDIALOG:
            //Log(LOG_TMCHANGE, L"Creating hwnd=0x%x", hwndPage);
            break;

        case WM_DESTROY:
            break;

        default:
            bHandled = FALSE;
            break;
    }
    return bHandled;
}
//-------------------------------------------------------------------------//
INT_PTR CALLBACK Pickers_DlgProc( HWND hwndPage, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    BOOL    bHandled = TRUE;
    LRESULT lRet = 0L; 
    switch( uMsg )
    {
        case WM_INITDIALOG:
            Pickers_Init(hwndPage);
            break;

        case WM_DESTROY:
            break;

        default:
            bHandled = FALSE;
            break;
    }
    return bHandled;
}

//-------------------------------------------------------------------------//
INT_PTR CALLBACK Movers_DlgProc( HWND hwndPage, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    BOOL    bHandled = TRUE;
    LRESULT lRet = 0L; 
    switch( uMsg )
    {
        case WM_INITDIALOG:
            Movers_Init(hwndPage);
            break;

        case WM_DESTROY:
            break;

        default:
            bHandled = FALSE;
            break;
    }
    return bHandled;
}

//-------------------------------------------------------------------------//
INT_PTR CALLBACK Lists_DlgProc( HWND hwndPage, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    BOOL    bHandled = TRUE;
    LRESULT lRet = 0L; 
    switch( uMsg )
    {
        case WM_INITDIALOG:
            Lists_Init(hwndPage);
            break;

        case WM_DESTROY:
            break;

        default:
            bHandled = FALSE;
            break;
    }
    return bHandled;
}
//-------------------------------------------------------------------------//
INT_PTR CALLBACK ListView_DlgProc( HWND hwndPage, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    BOOL    bHandled = TRUE;
    LRESULT lRet = 0L; 
    switch( uMsg )
    {
        case WM_INITDIALOG:
            ListView_Init(hwndPage, IDC_LIST1);
            ListView_Init(hwndPage, IDC_LIST2);
            break;

        case WM_DESTROY:
            break;

        default:
            bHandled = FALSE;
            break;
    }
    return bHandled;
}
//-------------------------------------------------------------------------//
INT_PTR CALLBACK TreeView_DlgProc( HWND hwndPage, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    BOOL    bHandled = TRUE;
    LRESULT lRet = 0L; 
    switch( uMsg )
    {
        case WM_INITDIALOG:
            TreeView_Init(hwndPage, IDC_TREE1);
            TreeView_Init(hwndPage, IDC_TREE2);
            break;

        case WM_DESTROY:
            break;

        default:
            bHandled = FALSE;
            break;
    }
    return bHandled;
}

//-------------------------------------------------------------------------//
INT_PTR CALLBACK Bars_DlgProc( HWND hwndPage, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    BOOL    bHandled = TRUE;
    LRESULT lRet = 0L; 
    switch( uMsg )
    {
        case WM_INITDIALOG:
            Header_Init(hwndPage, IDC_HEADER1);
            Status_Init(hwndPage, IDC_STATUS1);
            // Toolbar_Init(hwndPage, IDC_TOOLBAR1);
            Rebar_Init(hwndPage, IDC_REBAR1);
            break;

        case WM_DESTROY:
            break;

        default:
            bHandled = FALSE;
            break;
    }
    return bHandled;
}

//-------------------------------------------------------------------------//
void Pickers_Init(HWND hwndPage)
{
    HWND hwnd1 = GetDlgItem(hwndPage, IDC_TAB1);
    HWND hwnd2 = GetDlgItem(hwndPage, IDC_TAB2);
    TCITEM item;
    item.mask = TCIF_TEXT;

    for (int i=0; i < 4; i++)
    {
        item.pszText = Names[i];
        SendMessage(hwnd1, TCM_INSERTITEM, i, (LPARAM)&item);
        SendMessage(hwnd2, TCM_INSERTITEM, i, (LPARAM)&item);
    }
}

//-------------------------------------------------------------------------//
void Movers_Init(HWND hwndPage)
{
    HWND hwnd1 = GetDlgItem(hwndPage, IDC_PROGRESS1);
    HWND hwnd2 = GetDlgItem(hwndPage, IDC_PROGRESS2);
 
    SendMessage(hwnd1, PBM_SETRANGE, 0, MAKELPARAM(0, 100));
    SendMessage(hwnd2, PBM_SETRANGE, 0, MAKELPARAM(0, 100));

    SendMessage(hwnd1, PBM_SETPOS, 33, 0);
    SendMessage(hwnd2, PBM_SETPOS, 33, 0);
}
//-------------------------------------------------------------------------//
void Lists_Init(HWND hwndPage)
{
    HWND hwnds[7];

    hwnds[0] = GetDlgItem(hwndPage, IDC_LIST1);
    hwnds[1] = GetDlgItem(hwndPage, IDC_COMBO1);
    hwnds[2] = GetDlgItem(hwndPage, IDC_COMBO2);
    hwnds[3] = GetDlgItem(hwndPage, IDC_COMBO3);
    hwnds[4] = GetDlgItem(hwndPage, IDC_COMBOBOXEX1);
    hwnds[5] = GetDlgItem(hwndPage, IDC_COMBOBOXEX2);
    hwnds[6] = GetDlgItem(hwndPage, IDC_COMBOBOXEX3);

    //---- listbox ----
    SendMessage(hwnds[0], LB_RESETCONTENT, 0, 0);
    for (int j=0; j < ARRAYSIZE(Names); j++)
        SendMessage(hwnds[0], LB_ADDSTRING, 0, (LPARAM)Names[j]);
    SendMessage(hwnds[0], LB_SETCURSEL, 0, 0);

    //---- comboboxes ----
    for (int i=1; i < 4; i++)
    {
        SendMessage(hwnds[i], CB_RESETCONTENT, 0, 0);

        for (int j=0; j < ARRAYSIZE(Names); j++)
            SendMessage(hwnds[i], CB_ADDSTRING, 0, (LPARAM)Names[j]);

        SendMessage(hwnds[i], CB_SETCURSEL, 0, 0);
    }

    //---- combo EX boxes ----
    COMBOBOXEXITEM exitem;
    exitem.mask = CBEIF_TEXT ;

    for (i=4; i < 7; i++)
    {
        SendMessage(hwnds[i], CB_RESETCONTENT, 0, 0);

        for (int j=0; j < ARRAYSIZE(Names); j++)
        {
            exitem.iItem = j;
            exitem.pszText = Names[j];
            SendMessage(hwnds[i], CBEM_INSERTITEM, 0, (LPARAM)&exitem);
        }

        SendMessage(hwnds[i], CB_SETCURSEL, 0, 0);
    }

}
//-------------------------------------------------------------------------//
void ListView_Init(HWND hwndPage, int iControlId) 
{
    HWND hwnd = GetDlgItem(hwndPage, iControlId);
    if (! hwnd)
        return;

    //---- initialize the colums ----
    LVCOLUMN lvc; 
    memset(&lvc, 0, sizeof(lvc));
 
    lvc.mask = LVCF_TEXT | LVCF_SUBITEM | LVCF_FMT | LVCF_WIDTH; 
    lvc.fmt = LVCFMT_LEFT; 
    lvc.cx = 100; 
 
    // Add the columns. 
    for (int c=0; c < ARRAYSIZE(Columns); c++)
    {
        lvc.iSubItem = c;
        lvc.pszText = Columns[c];
        SendMessage(hwnd, LVM_INSERTCOLUMN, c, (LPARAM)&lvc);
    } 

    //---- initialize the items ----
    LVITEM item;
    memset(&item, 0, sizeof(item));
    item.mask = LVIF_TEXT;

    //---- add the items ----
    for (int i=0; i < ARRAYSIZE(Col1Items); i++)  
    {
        item.pszText = Col1Items[i];
        item.iItem = i;
        item.iSubItem = 0;
        SendMessage(hwnd, LVM_INSERTITEM, 0, (LPARAM)&item);

        item.iSubItem = 1;
        item.pszText = Col2Items[i];
        SendMessage(hwnd, LVM_SETITEM, 0, (LPARAM)&item);

        item.iSubItem = 2;
        item.pszText = Col3Items[i];
        SendMessage(hwnd, LVM_SETITEM, 0, (LPARAM)&item);
    }
}
//-------------------------------------------------------------------------//
void TreeView_Init(HWND hwndPage, int iControlId)
{
    HWND hwnd = GetDlgItem(hwndPage, iControlId);
    if (! hwnd)
        return;

    //---- initialize the item ----
    TVINSERTSTRUCT tvs;
    memset(&tvs, 0, sizeof(tvs));
    tvs.itemex.mask = TVIF_TEXT;
    tvs.hInsertAfter = TVI_LAST;    

    tvs.itemex.pszText = L"Root";
    HTREEITEM hRoot = (HTREEITEM) SendMessage(hwnd, TVM_INSERTITEM, 0, (LPARAM)&tvs);

    //---- add the items ----
    for (int i=0; i < ARRAYSIZE(Col1Items); i++)  
    {
        tvs.itemex.pszText = Col1Items[i];
        tvs.hParent = hRoot;
        HTREEITEM hItem = (HTREEITEM) SendMessage(hwnd, TVM_INSERTITEM, 0, (LPARAM)&tvs);

        if (hItem)
        {
            TVINSERTSTRUCT tvchild;
            memset(&tvchild, 0, sizeof(tvchild));
            tvchild.itemex.mask = TVIF_TEXT;
            tvchild.hInsertAfter = TVI_LAST;    
            tvchild.hParent = hItem;

            tvchild.itemex.pszText = Col2Items[i];
            SendMessage(hwnd, TVM_INSERTITEM, 0, (LPARAM)&tvchild);

            tvchild.itemex.pszText = Col3Items[i];
            SendMessage(hwnd, TVM_INSERTITEM, 0, (LPARAM)&tvchild);
        }
    }
}
//-------------------------------------------------------------------------//
void Header_Init(HWND hwndPage, int iControlId)
{
    HWND hwnd = GetDlgItem(hwndPage, iControlId);
    if (! hwnd)
        return;

    //---- initialize the item ----
    HDITEM item;
    memset(&item, 0, sizeof(item));
    item.mask = HDI_WIDTH | HDI_TEXT;
    item.cxy = 60;

    //---- add the items ----
    for (int i=0; i < ARRAYSIZE(Columns); i++)  
    {
        item.pszText = Columns[i];
        HTREEITEM hItem = (HTREEITEM) SendMessage(hwnd, HDM_INSERTITEM, i, (LPARAM)&item);
    }
}

//-------------------------------------------------------------------------//
void Status_Init(HWND hwndPage, int iControlId)
{
    HWND hwnd = GetDlgItem(hwndPage, iControlId);
    if (! hwnd)
        return;

    //---- setup the different sections ----
    int Widths[] = {200, 400, 600};
    SendMessage(hwnd, SB_SETPARTS, ARRAYSIZE(Widths), (LPARAM)Widths);

    //---- write some text ----
    SendMessage(hwnd, SB_SETTEXT, 0, (LPARAM)L"First Section");
    SendMessage(hwnd, SB_SETTEXT, 1, (LPARAM)L"Second Section");
    SendMessage(hwnd, SB_SETTEXT, 2, (LPARAM)L"Third Section");
}
//-------------------------------------------------------------------------//
void Toolbar_Init(HWND hwndPage, int iControlId, int iMaxButtons)
{
    HWND hwnd = GetDlgItem(hwndPage, iControlId);
    if (! hwnd)
        return;

    //---- send require toolbar init msg ----
    SendMessage(hwnd, TB_BUTTONSTRUCTSIZE, (WPARAM)sizeof(TBBUTTON), 0); 

    //---- setup the bitmap images for buttons ----
    TBADDBITMAP abm = {HINST_COMMCTRL, IDB_STD_LARGE_COLOR};
    SendMessage(hwnd, TB_ADDBITMAP, 15, (LPARAM)&abm);

    TBBUTTON button;
    memset(&button, 0, sizeof(button));
    button.fsState = TBSTATE_ENABLED; 
    
    //int index = (int)SendMessage(hwnd, TB_ADDSTRING, NULL, (LPARAM)Buttons);

    int cnt = (int)min(iMaxButtons, ARRAYSIZE(Buttons));

    for (int i=0; i < cnt; i++)
    {
        button.fsStyle = TBSTYLE_BUTTON; 
        button.iBitmap = ButtonIndexes[i];
        button.idCommand = i;
        button.iString = 0; // index + i;
        SendMessage(hwnd, TB_ADDBUTTONS, 1, LPARAM(&button));

        if ((i == 2) || (i == 5) || (i == 7) || (i == 9))
        {
            button.fsStyle = BTNS_SEP;
            SendMessage(hwnd, TB_ADDBUTTONS, 1, LPARAM(&button));
        }
    }

    SendMessage(hwnd, TB_AUTOSIZE, 0, 0); 
    ShowWindow(hwnd, SW_SHOW); 
}
//-------------------------------------------------------------------------//
void Rebar_Init(HWND hwndPage, int iControlId)
{
    HWND hwndRB = GetDlgItem(hwndPage, iControlId);
    if (! hwndRB)
        return;
 
   //---- initialize the rebar ----
   REBARINFO rbi;
   rbi.cbSize = sizeof(rbi); 
   rbi.fMask  = 0;
   rbi.himl   = (HIMAGELIST)NULL;
   SendMessage(hwndRB, RB_SETBARINFO, 0, (LPARAM)&rbi);
   
   //---- initialize the band ----
   REBARBANDINFO rbBand;   
   rbBand.cbSize = sizeof(REBARBANDINFO);  
   rbBand.fMask  = RBBIM_TEXT | RBBIM_STYLE | RBBIM_CHILD  | RBBIM_CHILDSIZE | RBBIM_SIZE;
   rbBand.fStyle = RBBS_GRIPPERALWAYS | RBBS_BREAK;
   // rbBand.hbmBack= LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BACKGROUND));   
   
   RECT rc;
   HWND hwndCB, hwndTB;

   // Create the combo box control to be added.
   hwndCB = CreateWindowEx(0, L"Combobox", L"Combo Text", WS_VISIBLE | WS_CHILD | WS_BORDER,
       0, 0, 100, 30, hwndRB, (HMENU)51, g_hInst, 0);
   
   // Set values unique to the band with the combo box.
   GetWindowRect(hwndCB, &rc);
   rbBand.lpText     = L"Combo Box";
   rbBand.hwndChild  = hwndCB;
   rbBand.cxMinChild = 20;
   rbBand.cyMinChild = HEIGHT(rc);
   rbBand.cx         = 120; // WIDTH(rc) + 20;

   // Add the band that has the combo box.
   LRESULT val = SendMessage(hwndRB, RB_INSERTBAND, (WPARAM)-1, (LPARAM)&rbBand);

#if 1
   // Create the toolbar control to be added.
   hwndTB = CreateWindowEx(0, L"SysToolBar32", L"", WS_VISIBLE | WS_CHILD | WS_BORDER,
       0, 0, 500, 30, hwndRB, (HMENU)52, g_hInst, 0);
   Toolbar_Init(hwndRB, 52, 3);

   // Set values unique to the band with the toolbar.
   rbBand.lpText     = L"Tool Bar";
   rbBand.hwndChild  = hwndTB;
   rbBand.cxMinChild = 20;

   DWORD dwBtnSize = (DWORD) SendMessage(hwndTB, TB_GETBUTTONSIZE, 0,0);
   rbBand.cyMinChild = HIWORD(dwBtnSize);
   
   GetWindowRect(hwndTB, &rc);
   rbBand.cx         = 450;     // WIDTH(rc) + 20;

   // Add the band that has the toolbar.
   val = SendMessage(hwndRB, RB_INSERTBAND, (WPARAM)-1, (LPARAM)&rbBand);
#endif
}

//-------------------------------------------------------------------------//
HWND CALLBACK StaticsPage_CreateInstance( HWND hwndParent )
{
    return CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_STATICS),
                         hwndParent,  Shared_DlgProc );
}

//---------------------------------------------------------------------------
HWND CALLBACK ButtonsPage_CreateInstance( HWND hwndParent )
{
    return CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_BUTTONS),
                         hwndParent,  Shared_DlgProc );
}

//-------------------------------------------------------------------------//
HWND CALLBACK EditPage_CreateInstance( HWND hwndParent )
{
    return CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_EDIT),
                         hwndParent,  Shared_DlgProc );
}

//-------------------------------------------------------------------------//
HWND CALLBACK TreeViewPage_CreateInstance( HWND hwndParent )
{
    return CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_TREEVIEW),
                         hwndParent,  TreeView_DlgProc );
}

//-------------------------------------------------------------------------//
HWND CALLBACK ListViewPage_CreateInstance( HWND hwndParent )
{
    return CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_LISTVIEW),
                         hwndParent,  ListView_DlgProc );
}

//-------------------------------------------------------------------------//
HWND CALLBACK PickersPage_CreateInstance( HWND hwndParent )
{
    return CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_PICKERS),
                         hwndParent,  Pickers_DlgProc );
}

//-------------------------------------------------------------------------//
HWND CALLBACK MoversPage_CreateInstance( HWND hwndParent )
{
    return CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_MOVERS),
                         hwndParent,  Movers_DlgProc );
}

//-------------------------------------------------------------------------//
HWND CALLBACK ListsPage_CreateInstance( HWND hwndParent )
{
    return CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_LISTS),
                         hwndParent,  Lists_DlgProc );
}

//---------------------------------------------------------------------------
HWND CALLBACK BarsPage_CreateInstance( HWND hwndParent )
{
    return CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_BARS),
                         hwndParent,  Bars_DlgProc );
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themesel\sbpage.cpp ===
#include "pch.h"
#include "resource.h"
#include "main.h"

LRESULT CALLBACK SBPage_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
UINT SBPage_GetScrollBarID();
void SBPage_UpdateControls( HWND hwnd );
void SBPage_UpdateStyle( HWND hwnd, DWORD dw, BOOL bRemove );
BOOL SBPage_OnInitDlg( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
void SBPage_Scroll( HWND hwnd, WPARAM wParam );
void SBPage_AddMessage( HWND hwnd, LPCTSTR pszMsg );
void SBPage_AddScrollMessage( HWND hwnd, LPCTSTR pszMsg, WPARAM wParam, LPARAM lParam );
void SBPage_UpdateStyle( HWND hwnd, DWORD dw, BOOL bRemove );

//-------------------------------------------------------------------------//
//  'ScrollBars' page impl
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
HWND CALLBACK SBPage_CreateInstance( HWND hwndParent )
{
    return CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_SCROLLBARS),
                         hwndParent,  (DLGPROC)SBPage_DlgProc );
}

//-------------------------------------------------------------------------//
static BOOL       s_fVert = TRUE;
static BOOL       s_fPort = TRUE;
static SCROLLINFO s_siVert = {0};
static SCROLLINFO s_siHorz = {0};
static SCROLLINFO s_siVertP = {0};
static SCROLLINFO s_siHorzP = {0};

//-------------------------------------------------------------------------//
LRESULT CALLBACK SBPage_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
        case WM_CREATE:
            Log(LOG_TM, L"WM_CREATE\n");
            break;

		case WM_INITDIALOG:
            return SBPage_OnInitDlg( hwnd, uMsg, wParam, lParam );

		case WM_COMMAND:
            switch( LOWORD(wParam) )
            {
                case IDC_VERTICAL:
                    s_fVert = TRUE;
                    SBPage_UpdateControls( hwnd );
                    break;
                
                case IDC_HORIZONTAL:
                    s_fVert = FALSE;
                    SBPage_UpdateControls( hwnd );
                    break;

                case IDC_SBCTL_PORT:
                    s_fPort = TRUE;
                    SBPage_UpdateControls( hwnd );
                    break;

                case IDC_SBCTL_STANDARD:
                    s_fPort = FALSE;
                    SBPage_UpdateControls( hwnd );
                    break;

                default:
                    break;
            }
			break;

        case WM_HSCROLL:
            s_fVert = FALSE;
            SBPage_Scroll( hwnd, wParam );
            SBPage_AddScrollMessage( hwnd, TEXT("WM_HSCROLL"), wParam, lParam );
            SBPage_UpdateControls( hwnd );
            break;

        case WM_VSCROLL:
            s_fVert = TRUE;
            SBPage_Scroll( hwnd, wParam );
            SBPage_AddScrollMessage( hwnd, TEXT("WM_VSCROLL"), wParam, lParam );
            SBPage_UpdateControls( hwnd );
            break;

	}
    return FALSE;
}

UINT SBPage_GetScrollBarID()
{
    if( s_fPort )
        return s_fVert ? IDC_SBVERTP : IDC_SBHORZP;
    return s_fVert ? IDC_SBVERT : IDC_SBHORZ;
}

void SBPage_UpdateControls( HWND hwnd )
{
    UINT nPortShow = s_fPort ? SW_SHOW : SW_HIDE;
    UINT nUserShow = s_fPort ? SW_HIDE : SW_SHOW;

    ShowWindow( GetDlgItem( hwnd, IDC_SBHORZ ),  nUserShow );
    ShowWindow( GetDlgItem( hwnd, IDC_SBVERT ),  nUserShow );
    ShowWindow( GetDlgItem( hwnd, IDC_SBHORZP ), nPortShow );
    ShowWindow( GetDlgItem( hwnd, IDC_SBVERTP ), nPortShow );

    HWND  hwndSB  = GetDlgItem( hwnd, SBPage_GetScrollBarID() );
    DWORD dwStyle = GetWindowLong( hwndSB, GWL_STYLE );
    DWORD dwExStyle = GetWindowLong( hwndSB, GWL_EXSTYLE );

    CheckDlgButton( hwnd, IDC_VERTICAL,         s_fVert );
    CheckDlgButton( hwnd, IDC_HORIZONTAL,       !s_fVert );
    CheckDlgButton( hwnd, IDC_SBCTL_PORT,       s_fPort );
    CheckDlgButton( hwnd, IDC_SBCTL_STANDARD,   !s_fPort );

    SCROLLINFO* psi = s_fPort ? (s_fVert ? &s_siVertP : &s_siHorzP) :
                                (s_fVert ? &s_siVert : &s_siHorz);
    psi->fMask = -1;

    if( SendMessage( hwndSB, SBM_GETSCROLLINFO, 0, (LPARAM)psi ) )
    {
        SetDlgItemInt( hwnd, IDC_MIN,      psi->nMin, TRUE );
        SetDlgItemInt( hwnd, IDC_MAX,      psi->nMax, TRUE );
        SetDlgItemInt( hwnd, IDC_PAGE,     psi->nPage, FALSE );
        SetDlgItemInt( hwnd, IDC_POS,      psi->nPos, TRUE );
        SetDlgItemInt( hwnd, IDC_TRACKPOS, psi->nTrackPos, TRUE );
    }
    else
    {
        SetDlgItemText( hwnd, IDC_MIN,      NULL );
        SetDlgItemText( hwnd, IDC_MAX,      NULL );
        SetDlgItemText( hwnd, IDC_PAGE,     NULL );
        SetDlgItemText( hwnd, IDC_POS,      NULL );
        SetDlgItemText( hwnd, IDC_TRACKPOS, NULL );
    }
}

BOOL SBPage_OnInitDlg( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    DWORD dwStyleV   = GetWindowLong( GetDlgItem( hwnd, IDC_SBVERTP ), GWL_STYLE );
    DWORD dwExStyleV = GetWindowLong( GetDlgItem( hwnd, IDC_SBVERTP ), GWL_EXSTYLE );
    DWORD dwStyleH   = GetWindowLong( GetDlgItem( hwnd, IDC_SBHORZP ), GWL_STYLE );
    DWORD dwExStyleH = GetWindowLong( GetDlgItem( hwnd, IDC_SBHORZP ), GWL_EXSTYLE );

    s_fVert = TRUE;
    s_siVert.cbSize = sizeof(s_siVert);
    s_siVert.fMask     = -1;
    s_siVert.nMin      = 0;
    s_siVert.nMax      = 300;
    s_siVert.nPage     = 60;
    s_siVert.nPos      = 0;
    s_siVert.nTrackPos = 0;
    s_siVertP = s_siHorzP = s_siHorz = s_siVert;

    SetScrollInfo( GetDlgItem( hwnd, IDC_SBVERT ), SB_CTL,  &s_siVert, FALSE );
    SetScrollInfo( GetDlgItem( hwnd, IDC_SBHORZ ), SB_CTL,  &s_siHorz, FALSE );
    SetScrollInfo( GetDlgItem( hwnd, IDC_SBVERTP ), SB_CTL, &s_siVertP, FALSE );
    SetScrollInfo( GetDlgItem( hwnd, IDC_SBHORZP ), SB_CTL, &s_siHorzP, FALSE );

    SBPage_UpdateControls( hwnd );

    return TRUE;
}

void SBPage_Scroll( HWND hwnd, WPARAM wParam )
{
    HWND hwndSB = GetDlgItem( hwnd, SBPage_GetScrollBarID() );
    SCROLLINFO* psi = s_fVert ? &s_siVert : &s_siHorz;
    const LONG  nLine = 15;
    UINT        uSBCode = LOWORD(wParam);
    int         nNewPos = HIWORD(wParam);
    
    int nDeltaMax = (s_siVert.nMax - s_siVert.nPage) + 1;
    
    switch( uSBCode )
    {
        case SB_LEFT:
            psi->nPos--;
            break;
        case SB_RIGHT:
            psi->nPos++;
            break;
        case SB_LINELEFT:
            psi->nPos = max( psi->nPos - nLine, 0 );
            break;
        case SB_LINERIGHT:
            psi->nPos = min( psi->nPos + nLine, nDeltaMax );
            break;
        case SB_PAGELEFT:
            psi->nPos = max( psi->nPos - (int)psi->nPage, 0 );
            break;
        case SB_PAGERIGHT:
            psi->nPos = min( psi->nPos + (int)psi->nPage, nDeltaMax );
            break;
        case SB_THUMBTRACK:
            psi->nPos = nNewPos;
            break;
        case SB_THUMBPOSITION:
            psi->nPos = nNewPos;
            break;
        case SB_ENDSCROLL:
            return;
    }
    psi->fMask = SIF_POS;
    SetScrollInfo( hwndSB, SB_CTL, psi, TRUE );
}

void SBPage_AddMessage( HWND hwnd, LPCTSTR pszMsg )
{
    INT_PTR i = SendDlgItemMessage( hwnd, IDC_MSGLIST, LB_ADDSTRING, 0, (LPARAM)pszMsg );
    SendDlgItemMessage( hwnd, IDC_MSGLIST, LB_SETCURSEL, i, 0 );
}

void SBPage_AddScrollMessage( HWND hwnd, LPCTSTR pszMsg, WPARAM wParam, LPARAM lParam )
{
    TCHAR szMsg[MAX_PATH];
    LPCTSTR pszWparam = NULL;
    LPCTSTR pszLparam = NULL;

    switch( LOWORD(wParam) )
    {
        #define ASL_ASSIGN_WPARAM(m)    case m: pszWparam = TEXT(#m); break
        ASL_ASSIGN_WPARAM(SB_ENDSCROLL);
        ASL_ASSIGN_WPARAM(SB_LEFT);
        ASL_ASSIGN_WPARAM(SB_RIGHT);
        ASL_ASSIGN_WPARAM(SB_LINELEFT);
        ASL_ASSIGN_WPARAM(SB_LINERIGHT);
        ASL_ASSIGN_WPARAM(SB_PAGELEFT);
        ASL_ASSIGN_WPARAM(SB_PAGERIGHT);
        ASL_ASSIGN_WPARAM(SB_THUMBPOSITION);
        ASL_ASSIGN_WPARAM(SB_THUMBTRACK);
        default:
            pszWparam = TEXT("");
            break;
    }

    wsprintf( szMsg, TEXT("%s [%s]"), pszMsg, pszWparam );
    SBPage_AddMessage( hwnd, szMsg );
}

void SBPage_UpdateStyle( HWND hwnd, DWORD dw, BOOL bRemove )
{
    HWND hwndSB = GetDlgItem( hwnd, SBPage_GetScrollBarID() );
    DWORD dwStyle, dwStyleOld;
    dwStyle = dwStyleOld = GetWindowLong( hwndSB, GWL_STYLE );
    if( bRemove )
        dwStyle &= ~dw;
    else
        dwStyle |= dw;

    if( dwStyle != dwStyleOld )
    {
        SetWindowLong( hwndSB, GWL_STYLE, dwStyle );
        InvalidateRect( hwndSB, NULL, TRUE );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themesel\sample.cpp ===
//---------------------------------------------------------------------------
//  Sample.cpp - dialog for sampling the active theme
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "Sample.h"
//---------------------------------------------------------------------------
CSample::CSample()
{
}
//---------------------------------------------------------------------------
LRESULT CSample::OnMsgBox(UINT, UINT, HWND, BOOL&)
{
    MessageBox(L"This is what a Themed MessageBox() window looks like", 
        L"A message!", MB_OK);

    return 1;
}
//---------------------------------------------------------------------------
LRESULT CSample::OnEditTheme(UINT, UINT, HWND, BOOL&)
{
    WCHAR name[_MAX_PATH+1];
    WCHAR params[_MAX_PATH+1];

    *name = 0;

    HRESULT hr = GetCurrentThemeName(name, ARRAYSIZE(name));
    if ((FAILED(hr)) || (! *name))
    {
        GetDlgItemText(IDC_DIRNAME, name, ARRAYSIZE(name));
        if (! *name)
        {
            MessageBox(L"No theme selected", L"Error", MB_OK);
            return 0;
        }

        wsprintf(params, L"%s\\%s", name, CONTAINER_NAME);
    }
    else
        wsprintf(params, L"%s", name);

    InternalRun(L"notepad.exe", params);

    return 1;
}
//---------------------------------------------------------------------------
LRESULT CSample::OnClose(UINT, WPARAM wid, LPARAM, BOOL&)
{
    EndDialog(IDOK);
    return 0;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themesel\stylespage.cpp ===
#include "pch.h"
#include "resource.h"

//-------------------------------------------------------------------------//
//  'Styles' page impl
//-------------------------------------------------------------------------//
//
//  CreateIntance, DlgProc
HWND    CALLBACK StylesPage_CreateInstance( HWND hwndParent );
INT_PTR CALLBACK StylesPage_DlgProc( HWND hwndPage, UINT, WPARAM , LPARAM );
//
//  Message handlers
LRESULT CALLBACK StylesPage_OnInitDialog( HWND hwndPage, UINT, WPARAM, LPARAM );
void    CALLBACK StylesPage_OnCommand( HWND, UINT uCtlID, UINT uCode, HWND hwndCtl );

//  Utility methods
void StylesPage_AddRemoveStyle( HWND hwnd, BOOL bAdd, DWORD dwStyle );
void StylesPage_AddRemoveExStyle( HWND hwnd, BOOL bAdd, DWORD dwStyle );
void StylesPage_CreateTestWindow( HWND hwndParent );
void StylesPage_CreateTestDialog( HWND hwndParent );
void StylesPage_SetTestStyles( HWND hwndPage );

#define WMU_TESTWINDOWDIED  (WM_USER + 0x301) // arbitrary.

HWND _hwndTest = NULL;
HWND _hwndPage = NULL;


//-------------------------------------------------------------------------//
INT_PTR CALLBACK StylesPage_DlgProc( HWND hwndPage, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    BOOL    bHandled = TRUE;
    LRESULT lRet = 0L;
    _hwndPage = hwndPage;

    switch( uMsg )
    {
        case WM_INITDIALOG:
            lRet = StylesPage_OnInitDialog( hwndPage, uMsg, wParam, lParam );
            break;

        case WM_COMMAND:
            StylesPage_OnCommand( hwndPage, LOWORD(wParam), HIWORD(wParam), (HWND)lParam );
            break;

        case WM_NCDESTROY:
            _hwndPage = NULL;
            break;

        case WMU_TESTWINDOWDIED:
            StylesPage_OnCommand( hwndPage, 0, 0, NULL );
            break;

        default: 
            bHandled = FALSE;
            break;
    }
    return bHandled;
}

//-------------------------------------------------------------------------//
HWND CALLBACK StylesPage_CreateInstance( HWND hwndParent )
{
    return CreateDialog( g_hInst, MAKEINTRESOURCE(IDD_PAGE_STYLES),
                         hwndParent,  StylesPage_DlgProc );
}

//-------------------------------------------------------------------------//
LRESULT CALLBACK StylesPage_OnInitDialog(
    HWND hwndPage, UINT, WPARAM, LPARAM )
{
    DWORD dwStyle = GetWindowLong( g_hwndMain, GWL_STYLE );
    DWORD dwExStyle = GetWindowLong( g_hwndMain, GWL_EXSTYLE );

    CheckDlgButton( hwndPage, IDC_WS_MINIMIZEBOX, (dwStyle & WS_MINIMIZEBOX) != 0 );
    CheckDlgButton( hwndPage, IDC_WS_MAXIMIZEBOX, (dwStyle & WS_MAXIMIZEBOX) != 0 );
    CheckDlgButton( hwndPage, IDC_WS_CAPTION, (dwStyle & WS_CAPTION) != 0 );
    CheckDlgButton( hwndPage, IDC_WS_BORDER, (dwStyle & WS_BORDER) != 0 );
    CheckDlgButton( hwndPage, IDC_WS_DLGFRAME, (dwStyle & WS_DLGFRAME) != 0 );
    CheckDlgButton( hwndPage, IDC_WS_VSCROLL, (dwStyle & WS_VSCROLL) != 0 );
    CheckDlgButton( hwndPage, IDC_WS_HSCROLL, (dwStyle & WS_HSCROLL) != 0 );
    CheckDlgButton( hwndPage, IDC_WS_SYSMENU, (dwStyle & WS_SYSMENU) != 0 );
    CheckDlgButton( hwndPage, IDC_WS_THICKFRAME, (dwStyle & WS_THICKFRAME) != 0 );


    CheckDlgButton( hwndPage, IDC_WS_EX_DLGMODALFRAME, (dwExStyle & WS_EX_DLGMODALFRAME) );
    CheckDlgButton( hwndPage, IDC_WS_EX_TOOLWINDOW, (dwExStyle & WS_EX_TOOLWINDOW) );
    CheckDlgButton( hwndPage, IDC_WS_EX_WINDOWEDGE, (dwExStyle & WS_EX_WINDOWEDGE) );
    CheckDlgButton( hwndPage, IDC_WS_EX_CLIENTEDGE, (dwExStyle & WS_EX_CLIENTEDGE) );
    CheckDlgButton( hwndPage, IDC_WS_EX_CONTEXTHELP, (dwExStyle & WS_EX_CONTEXTHELP) );
    CheckDlgButton( hwndPage, IDC_WS_EX_RIGHT, (dwExStyle & WS_EX_RIGHT) );
    CheckDlgButton( hwndPage, IDC_WS_EX_LEFT, (dwExStyle & WS_EX_LEFT) );
    CheckDlgButton( hwndPage, IDC_WS_EX_RTLREADING, (dwExStyle & WS_EX_RTLREADING) );
    CheckDlgButton( hwndPage, IDC_WS_EX_LEFTSCROLLBAR, (dwExStyle & WS_EX_LEFTSCROLLBAR) );
    CheckDlgButton( hwndPage, IDC_WS_EX_RIGHTSCROLLBAR, (dwExStyle & WS_EX_RIGHTSCROLLBAR) );
    CheckDlgButton( hwndPage, IDC_WS_EX_STATICEDGE, (dwExStyle & WS_EX_STATICEDGE) );
    CheckDlgButton( hwndPage, IDC_WS_EX_APPWINDOW, (dwExStyle & WS_EX_APPWINDOW) );
#ifdef WS_EX_LAYOUTRTL
    CheckDlgButton( hwndPage, IDC_WS_EX_LAYOUTRTL, (dwExStyle & WS_EX_LAYOUTRTL) );
#endif WS_EX_LAYOUTRTL

    CheckDlgButton( hwndPage, IDC_WS_OVERLAPPED2, TRUE );
    StylesPage_SetTestStyles( hwndPage );

    return TRUE;
}

//-------------------------------------------------------------------------//
void CALLBACK StylesPage_OnCommand( 
    HWND hwndPage, UINT uCtlID, UINT uCode, HWND hwndCtl )
{
    BOOL bChecked = IsDlgButtonChecked( hwndPage, uCtlID );

    switch( uCtlID )
    {
        case IDC_WS_MINIMIZEBOX:
            StylesPage_AddRemoveStyle( g_hwndMain, bChecked, WS_MINIMIZEBOX );
            break;

        case IDC_WS_MAXIMIZEBOX:
            StylesPage_AddRemoveStyle( g_hwndMain, bChecked, WS_MAXIMIZEBOX );
            break;

        case IDC_WS_CAPTION:
            StylesPage_AddRemoveStyle( g_hwndMain, bChecked, WS_CAPTION );
            break;

        case IDC_WS_BORDER:
            StylesPage_AddRemoveStyle( g_hwndMain, bChecked, WS_BORDER );
            break;

        case IDC_WS_DLGFRAME:
            StylesPage_AddRemoveStyle( g_hwndMain, bChecked, WS_DLGFRAME );
            break;

        case IDC_WS_VSCROLL:
            StylesPage_AddRemoveStyle( g_hwndMain, bChecked, WS_VSCROLL );
            break;

        case IDC_WS_HSCROLL:
            StylesPage_AddRemoveStyle( g_hwndMain, bChecked, WS_HSCROLL );
            break;

        case IDC_WS_SYSMENU:
            StylesPage_AddRemoveStyle( g_hwndMain, bChecked, WS_SYSMENU );
            break;

        case IDC_WS_THICKFRAME:
            StylesPage_AddRemoveStyle( g_hwndMain, bChecked, WS_THICKFRAME );
            break;

        case IDC_TEST_WINDOW:
            StylesPage_CreateTestWindow( hwndPage );
            break;

        case IDC_TEST_DIALOG:
            StylesPage_CreateTestDialog( hwndPage );
            break;

        case IDC_CLOSE_TEST_WINDOW:
            if( IsWindow( _hwndTest ) )
            {
                DestroyWindow( _hwndTest );
                _hwndTest = NULL;
            }
            break;

        case IDC_WS_OVERLAPPED2:
        case IDC_WS_POPUP2:
        case IDC_WS_CHILD2:
            StylesPage_SetTestStyles( hwndPage );
            break;
    }

    EnableWindow( GetDlgItem( hwndPage, IDC_TEST_WINDOW ), !IsWindow( _hwndTest ) );
    EnableWindow( GetDlgItem( hwndPage, IDC_TEST_DIALOG ), !IsWindow( _hwndTest ) );
    EnableWindow( GetDlgItem( hwndPage, IDC_CLOSE_TEST_WINDOW ), IsWindow( _hwndTest ) );
}

//  Utility methods
void StylesPage_AddRemoveStyle( HWND hwnd, BOOL bAdd, DWORD dwStyle )
{
    DWORD style = GetWindowLong( hwnd, GWL_STYLE );
    if( bAdd )
        SetWindowLong( hwnd, GWL_STYLE, style | dwStyle );
    else
        SetWindowLong( hwnd, GWL_STYLE, style & ~dwStyle );
    SetWindowPos( hwnd, NULL, 0, 0, 0, 0, 
        SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE|SWP_DRAWFRAME );
}

void StylesPage_AddRemoveExStyle( HWND hwnd, BOOL bAdd, DWORD dwStyle )
{
    DWORD style = GetWindowLong( hwnd, GWL_EXSTYLE );
    if( bAdd )
        SetWindowLong( hwnd, GWL_EXSTYLE, style | dwStyle );
    else
        SetWindowLong( hwnd, GWL_EXSTYLE, style & ~dwStyle );

    SetWindowPos( hwnd, NULL, 0, 0, 0, 0, 
        SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE|SWP_DRAWFRAME );
}

void StylesPage_ClearTestStyles( HWND hwndPage )
{
    CheckDlgButton( hwndPage, IDC_WS_MINIMIZEBOX2, 0 );
    CheckDlgButton( hwndPage, IDC_WS_MAXIMIZEBOX2, 0 );
    CheckDlgButton( hwndPage, IDC_WS_CAPTION2, 0 );
    CheckDlgButton( hwndPage, IDC_WS_BORDER2, 0 );
    CheckDlgButton( hwndPage, IDC_WS_DLGFRAME2, 0 );
    CheckDlgButton( hwndPage, IDC_WS_VSCROLL2, 0 );
    CheckDlgButton( hwndPage, IDC_WS_HSCROLL2, 0 );
    CheckDlgButton( hwndPage, IDC_WS_SYSMENU2, 0 );
    CheckDlgButton( hwndPage, IDC_WS_THICKFRAME2, 0 );
}

void StylesPage_SetTestStyles( HWND hwndPage )
{
    StylesPage_ClearTestStyles( hwndPage );
    if( IsDlgButtonChecked( hwndPage, IDC_WS_OVERLAPPED2 ) )
    {
        CheckDlgButton( hwndPage, IDC_WS_CAPTION2, TRUE );
        CheckDlgButton( hwndPage, IDC_WS_SYSMENU2, TRUE );
        CheckDlgButton( hwndPage, IDC_WS_THICKFRAME2, TRUE );
        CheckDlgButton( hwndPage, IDC_WS_CAPTION2, TRUE );
        CheckDlgButton( hwndPage, IDC_WS_MINIMIZEBOX2, TRUE );
        CheckDlgButton( hwndPage, IDC_WS_MAXIMIZEBOX2, TRUE );
    }
    else if ( IsDlgButtonChecked( hwndPage, IDC_WS_POPUP2 ) )
    {
        CheckDlgButton( hwndPage, IDC_WS_BORDER2, TRUE );
        CheckDlgButton( hwndPage, IDC_WS_SYSMENU2, TRUE );
    }
}


BOOL StylesPage_GetTestStyles( 
    HWND hwndPage, 
    OUT LPDWORD pdwStyle, 
    OUT LPDWORD pdwExStyle )
{
    *pdwStyle = *pdwExStyle = 0;
    #define ASSIGN_TEST_STYLE(uID, dwStyle) if( IsDlgButtonChecked(hwndPage, uID) ) {(*pdwStyle) |= dwStyle;}
    #define ASSIGN_TEST_EXSTYLE(uID, dwStyle) if( IsDlgButtonChecked(hwndPage, uID) ) {(*pdwExStyle) |= dwStyle;}

    ASSIGN_TEST_STYLE( IDC_WS_OVERLAPPED2, WS_OVERLAPPED );
    ASSIGN_TEST_STYLE( IDC_WS_POPUP2, WS_POPUP );
    ASSIGN_TEST_STYLE( IDC_WS_CHILD2,  WS_CHILD );

    ASSIGN_TEST_STYLE( IDC_WS_MINIMIZEBOX2, WS_MINIMIZEBOX );
    ASSIGN_TEST_STYLE( IDC_WS_MAXIMIZEBOX2, WS_MAXIMIZEBOX );
    ASSIGN_TEST_STYLE( IDC_WS_CAPTION2, WS_CAPTION );
    ASSIGN_TEST_STYLE( IDC_WS_BORDER2, WS_BORDER );
    ASSIGN_TEST_STYLE( IDC_WS_DLGFRAME2, WS_DLGFRAME );
    ASSIGN_TEST_STYLE( IDC_WS_VSCROLL2, WS_VSCROLL );
    ASSIGN_TEST_STYLE( IDC_WS_HSCROLL2, WS_HSCROLL );
    ASSIGN_TEST_STYLE( IDC_WS_SYSMENU2, WS_SYSMENU );
    ASSIGN_TEST_STYLE( IDC_WS_THICKFRAME2, WS_THICKFRAME );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_DLGMODALFRAME2, WS_EX_DLGMODALFRAME );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_TOOLWINDOW2, WS_EX_TOOLWINDOW );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_WINDOWEDGE2, WS_EX_WINDOWEDGE );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_CLIENTEDGE2, WS_EX_CLIENTEDGE );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_CONTEXTHELP2, WS_EX_CONTEXTHELP );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_RIGHT2, WS_EX_RIGHT );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_LEFT2, WS_EX_LEFT );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_RTLREADING2, WS_EX_RTLREADING );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_LEFTSCROLLBAR2, WS_EX_LEFTSCROLLBAR );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_RIGHTSCROLLBAR2, WS_EX_RIGHTSCROLLBAR );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_STATICEDGE2, WS_EX_STATICEDGE );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_APPWINDOW2, WS_EX_APPWINDOW );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_OVERLAPPEDWINDOW2, WS_EX_OVERLAPPEDWINDOW );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_PALETTEWINDOW2, WS_EX_PALETTEWINDOW );
    ASSIGN_TEST_EXSTYLE( IDC_WS_EX_LAYOUTRTL2, WS_EX_LAYOUTRTL );
    return TRUE;
}

LRESULT CALLBACK StylesPage_TestWndProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch(uMsg)
    {
        case WM_NCDESTROY:
            PostMessage( _hwndPage, WMU_TESTWINDOWDIED, 0, 0 );
            break;
    }
    return DefWindowProc( hwnd, uMsg, wParam, lParam );
}

void StylesPage_CreateTestWindow( HWND hwndParent )
{
    DWORD dwStyle, dwExStyle;

    WNDCLASSEX wc;
    ZeroMemory( &wc, sizeof(wc) );
    wc.cbSize        = sizeof(wc);
    wc.style         = CS_HREDRAW|CS_VREDRAW;
    wc.lpfnWndProc   = StylesPage_TestWndProc;
    wc.hInstance     = g_hInst;
    wc.hIcon         = NULL;
    wc.hCursor       = NULL;
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wc.lpszMenuName  = 0; //MAKEINTRESOURCE(pszTestMenu)
    wc.lpszClassName = TEXT("ThemeSelTestWindow");
    wc.hIconSm       = NULL;

    RegisterClassEx( &wc );

    StylesPage_GetTestStyles( hwndParent, &dwStyle, &dwExStyle );

    int x = CW_USEDEFAULT, y = CW_USEDEFAULT, cx = CW_USEDEFAULT, cy = CW_USEDEFAULT;
    
    if( dwStyle & WS_CHILD|WS_POPUP )
    {
        x = y = 25;
        cx = cy = 250;
    }

    _hwndTest = CreateWindowEx( dwExStyle, wc.lpszClassName, TEXT("Theme Test Window"), 
                                dwStyle|WS_VISIBLE,
                                x, y, cx, cy, hwndParent, 0, g_hInst, NULL );

    if( IsWindow( _hwndTest ) )
    {
        if( dwStyle & WS_CHILD )
        {
            //SetWindowPos( _hwndTest, HWND_TOP, 0, 0, 0, 0,
            //              SWP_NOSIZE|SWP_NOMOVE|SWP_NOACTIVATE );
            //InvalidateRect( _hwndTest, NULL, TRUE );
        }
    }
}

void StylesPage_CreateTestDialog( HWND hwndParent )
{
    StylesPage_CreateTestWindow( hwndParent );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\advappearpg.h ===
/*****************************************************************************\
    FILE: AdvAppearPg.h

    DESCRIPTION:
        This code will display a "Advanced Appearances" tab in the
    "Advanced Display Properties" dialog.

    ??????? ?/??/1993    Created
    BryanSt 3/23/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 1993-2000. All rights reserved.
\*****************************************************************************/

#ifndef _ADVAPPEAR_H
#define _ADVAPPEAR_H


// Public
HRESULT CAdvAppearancePage_CreateInstance(OUT IAdvancedDialog ** ppAdvDialog, IN const SYSTEMMETRICSALL * pState);

class CAdvAppearancePage;

typedef struct  {
    HWND    hwndFontName;
    HDC     hdc;
    CAdvAppearancePage * pThis;
}  ENUMFONTPARAM;


#define MAX_CHARSETS    4



//============================================================================================================
// Class
//============================================================================================================
class CAdvAppearancePage        : public CObjectWithSite
                                , public CObjectWindow
                                , public CObjectCLSID
                                , public IAdvancedDialog
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IAdvancedDialog ***
    virtual STDMETHODIMP DisplayAdvancedDialog(IN HWND hwndParent, IN IPropertyBag * pBasePage, IN BOOL * pfEnableApply);


    HRESULT Draw(HDC hdc, LPRECT prc, BOOL fOnlyShowActiveWindow, BOOL fRTL);
    int _EnumSizes(LPENUMLOGFONT lpelf, LPNEWTEXTMETRIC lpntm, int Type);

    CAdvAppearancePage(IN const SYSTEMMETRICSALL * pState);
    virtual ~CAdvAppearancePage(void);

private:
    // Private Member Variables
    long                    m_cRef;

    // Members for State
    BOOL                    m_fDirty;
    DWORD                   m_dwChanged;                        // These are the categories of state that are dirty. (SCHEME_CHANGE, DPI_CHANGE, COLOR_CHANGE, METRIC_CHANGE)

    // Members for UI Controls
    int                     m_iCurElement;                      // start off as not even "not set"
    LOOK_SIZE               m_elCurrentSize;                    // this one kept separately for range purposes
    int                     m_iPrevSize;

    BOOL                    m_bPalette;                         // is this a palette device?
    BOOL                    m_fInUserEditMode;                  // Are refreshes coming from the user edits?
    BOOL                    m_fProprtySheetExiting;             // See _PropagateMessage for description

    int                     m_nCachedNewDPI;                    // Cached DPI for scaling
    int                     m_i3DShadowAdj;
    int                     m_i3DHilightAdj;
    int                     m_iWatermarkAdj;
    BOOL                    m_fScale3DShadowAdj;
    BOOL                    m_fScale3DHilightAdj;
    BOOL                    m_fScaleWatermarkAdj;
    BOOL                    m_fModifiedScheme;

    int                     m_cyBorderSM;                       // Cached SystemMetrics
    int                     m_cxBorderSM;                       // Cached SystemMetrics
    int                     m_cxEdgeSM;                         // Cached SystemMetrics
    int                     m_cyEdgeSM;                         // Cached SystemMetrics
    float                   m_fCaptionRatio;                    // Save the ratio

    LOOK_SIZE               m_sizes[NUM_SIZES];                 // These are the sizes
    LOOK_FONT               m_fonts[NUM_FONTS];                 // These are the fonts installed that the user can choose from.
    COLORREF                m_rgb[COLOR_MAX];                   // These are the colors the user can choose from.
    HBRUSH                  m_brushes[COLOR_MAX];               // These are created from m_rgb and used when painting the UI.
    HPALETTE                m_hpal3D;                           // only exist if palette device
    HPALETTE                m_hpalVGA;                          // only exist if palette device

    HBRUSH                  m_hbrMainColor;
    HBRUSH                  m_hbrTextColor;
    HBRUSH                  m_hbrGradientColor;

    HTHEME                  m_hTheme;                           // theme the ownerdrawn color picker button

    // The following array will hold the "unique" Charsets corresponding to System Locale, 
    // User Locale, System UI lang and User UI Lang. Note: Only unique charsets are kept
    // here. So, the variable g_iCountCharsets contains the number of valid items in this array.
    UINT    m_uiUniqueCharsets[MAX_CHARSETS];
    int     m_iCountCharsets; // number of charsets stored in m_uiUniqueCharsets.  Minimum value is 1; Maximum is 4

    // Private Member Functions
    // Init/Destroy/State functions
    INT_PTR _AdvAppearDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    INT_PTR _OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    HRESULT _OnDestroy(HWND hDlg);
    HRESULT _OnSetActive(HWND hDlg);
    HRESULT _OnApply(HWND hDlg, LPARAM lParam);
    HRESULT _OnInitAdvAppearanceDlg(HWND hDlg);
    HRESULT _InitSysStuff(void);
    HRESULT _InitColorAndPalette(void);
    HRESULT _LoadState(IN const SYSTEMMETRICSALL * pState);
    HRESULT _IsDirty(IN BOOL * pIsDirty);

    // On User Action
    HRESULT _OnFontNameChanged(HWND hDlg);
    HRESULT _OnSizeChange(HWND hDlg, WORD wEvent);
    void _SelectName(HWND hDlg, int iSel);

    HRESULT _InitFonts(void);
    HRESULT _FreeFonts(void);

    // Classic Look_ functions
    HRESULT _SelectElement(HWND hDlg, int iElement, DWORD dwFlags);
    COLORREF _NearestColor(int iColor, COLORREF rgb);
    int _EnumFontNames(LPENUMLOGFONTEX lpelf, LPNEWTEXTMETRIC lpntm, DWORD Type, ENUMFONTPARAM * pEnumFontParam);
    BOOL _ChangeColor(HWND hDlg, int iColor, COLORREF rgb);
    void _Recalc(LPRECT prc);
    void _Repaint(HWND hDlg, BOOL bRecalc);
    void _RebuildCurFont(HWND hDlg);
    void _ChangeFontSize(HWND hDlg, int Points);
    void _ChangeFontBI(HWND hDlg, int id, BOOL bCheck);
    void _ChangeFontName(HWND hDlg, LPCTSTR szBuf, INT iCharSet);
    void _ChangeSize(HWND hDlg, int NewSize, BOOL bRepaint);
    void _PickAColor(HWND hDlg, int CtlID);
    void _DrawPreview(HDC hdc, LPRECT prc, BOOL fOnlyShowActiveWindow, BOOL fShowBack);
    void _DrawButton(HWND hDlg, LPDRAWITEMSTRUCT lpdis);
    void _RebuildSysStuff(BOOL fInit);
    void _Set3DPaletteColor(COLORREF rgb, int iColor);
    void _InitUniqueCharsetArray(void);
    void _DestroySysStuff(void);
    void _InitFontList(HWND hDlg);
    void _NewFont(HWND hDlg, int iFont);
    void _SetColor(HWND hDlg, int id, HBRUSH hbrColor);
    void _DrawDownArrow(HDC hdc, LPRECT lprc, BOOL bDisabled);
    void _SetCurSizeAndRange(HWND hDlg);
    void _DoSizeStuff(HWND hDlg, BOOL fCanSuggest);
    void _UpdateSizeBasedOnFont(HWND hDlg, BOOL fComputeIdeal);
    void _SyncSize(HWND hDlg);
    void _Changed(HWND hDlg, DWORD dwChange);
    void _SetSysStuff(UINT nChanged);
    void _GetMyNonClientMetrics(LPNONCLIENTMETRICS lpncm);
    void _SetMyNonClientMetrics(const LPNONCLIENTMETRICS lpncm);
    void _UpdateGradientButton(HWND hDlg);
    void _PropagateMessage(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);

    int _PointToHeight(int Points);
    int _HeightToPoint(int Height);

    static INT_PTR CALLBACK AdvAppearDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
    friend int CALLBACK Font_EnumNames(LPENUMLOGFONTEX lpelf, LPNEWTEXTMETRIC lpntm, DWORD dwType, LPARAM lData);

    // Preview Methods
    // Classic LookPrev_ functions
    void _RepaintPreview(HWND hwnd);
    void _MyDrawBorderBelow(HDC hdc, LPRECT prc);
    void _ShowBitmap(HWND hWnd, HDC hdc);
    HRESULT _OnReCreateBitmap(HWND hWnd);
    HRESULT _OnButtonDownOrDblClick(HWND hWnd, int nCoordX, int nCoordY);
    HRESULT _OnCreatePreviewSMDlg(LPRECT prc, BOOL fRTL);
    HRESULT _OnNCCreate(HWND hWnd);
    HRESULT _OnDestroyPreview(HWND hWnd);
    HRESULT _OnPaintPreview(HWND hWnd);
    void _InitPreview(LPRECT prc, BOOL fRTL);
    void DrawFullCaption(HDC hdc, LPRECT prc, LPTSTR lpszTitle, UINT flags);

    LRESULT _PreviewSystemMetricsWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK PreviewSystemMetricsWndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    friend BOOL RegisterPreviewSystemMetricClass(HINSTANCE hInst);
};


extern CAdvAppearancePage * g_pAdvAppearancePage;




// Shared between AdvAppearPg & BaseAppearPage

extern BOOL g_fProprtySheetExiting;


// a new element has been chosen.
//
// iElement - index into g_elements of the chosen one
// bSetCur - if TRUE, need to find element in elements combobox, too
#define LSE_NONE   0x0000
#define LSE_SETCUR 0x0001
#define LSE_ALWAYS 0x0002

#define EnableApplyButton(hdlg) PropSheet_Changed(GetParent(hdlg), hdlg)

#endif // _ADVAPPEAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\advdlg.cpp ===
/*****************************************************************************\
    FILE: AdvDlg.cpp

    DESCRIPTION:
        This code will display the "Advanced Display Properties" dialog.

    BryanSt 3/23/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "BaseAppearPg.h"
#include "ThemePg.h"
#include "EnumUnknown.h"
#include "AdvDlg.h"
#include "AdvAppearPg.h"
#include "ThSettingsPg.h"
#include "ScreenSaverPg.h"
#include "fontfix.h"









//===========================
// *** Class Internals & Helpers ***
//===========================
HRESULT CThemeManager::_Initialize(void)
{
    HRESULT hr = E_OUTOFMEMORY;

    CThemePage * pThemesPage = new CThemePage();
    if (pThemesPage)
    {
        CBaseAppearancePage * pAppearancePage = new CBaseAppearancePage();
        if (pAppearancePage)
        {
            hr = pThemesPage->QueryInterface(IID_PPV_ARG(IBasePropPage, &(m_pBasePages[PAGE_DISPLAY_THEMES])));
            if (SUCCEEDED(hr))
            {
                IUnknown_SetSite(m_pBasePages[PAGE_DISPLAY_THEMES], SAFECAST(this, IThemeUIPages *));
                hr = pAppearancePage->QueryInterface(IID_PPV_ARG(IBasePropPage, &(m_pBasePages[PAGE_DISPLAY_APPEARANCE])));
                if (SUCCEEDED(hr))
                {
                    IUnknown_SetSite(m_pBasePages[PAGE_DISPLAY_APPEARANCE], SAFECAST(this, IThemeUIPages *));
                    hr = CoCreateInstance(CLSID_SettingsPage, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IBasePropPage, &(m_pBasePages[PAGE_DISPLAY_SETTINGS])));
                    if (SUCCEEDED(hr))
                    {
                        IUnknown_SetSite(m_pBasePages[PAGE_DISPLAY_SETTINGS], SAFECAST(this, IThemeUIPages *));
                    }
                }
            }
            pAppearancePage->Release();
        }
        pThemesPage->Release();
    }

    return hr;
}



//===========================
// *** IThemeUIPages Interface ***
//===========================
HRESULT CThemeManager::AddPage(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam, IN long nPageID)
{
    HRESULT hr = E_INVALIDARG;
    IShellPropSheetExt * pspse = NULL;

    RegisterPreviewSystemMetricClass(HINST_THISDLL);
    if ((PAGE_DISPLAY_THEMES <= nPageID) && (PAGE_DISPLAY_SETTINGS >= nPageID))
    {
        if (m_pBasePages[nPageID])
        {
            hr = m_pBasePages[nPageID]->QueryInterface(IID_PPV_ARG(IShellPropSheetExt, &pspse));
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = pspse->AddPages(pfnAddPage, lParam);
        if (SUCCEEDED(hr))
        {
            // We give the page a pointer back to use so they can call
            // IThemeUIPages::DisplayAdvancedDialog() in order to display
            // the Advanced Dlg.
            hr = IUnknown_SetSite(pspse, (IThemeUIPages *)this);
        }
    }

    ATOMICRELEASE(pspse);
    return hr;
}


HRESULT CThemeManager::AddBasePage(IN IBasePropPage * pBasePage)
{
    int nIndex;

    for (nIndex = (PAGE_DISPLAY_APPEARANCE + 1); nIndex < ARRAYSIZE(m_pBasePages); nIndex++)
    {
        if (NULL == m_pBasePages[nIndex])   // Did we find an empty spot?
        {
            // Yes, so look no longer.
            IUnknown_Set((IUnknown **)&(m_pBasePages[nIndex]), (IUnknown *)pBasePage);
            if (m_pBasePages[nIndex])
            {
                // We give the page a pointer back to use so they can call
                // IThemeUIPages::DisplayAdvancedDialog() in order to display
                // the Advanced Dlg.
                IUnknown_SetSite(m_pBasePages[nIndex], (IThemeUIPages *)this);
            }
            break;
        }
    }

    return S_OK;
}


HRESULT CThemeManager::ApplyPressed(IN DWORD dwFlags)
{
    // We need to set the base pages' site pointers to NULL
    // in order to break the ref-count cycle.
    if (m_pBasePages[PAGE_DISPLAY_SETTINGS])
    {
        m_pBasePages[PAGE_DISPLAY_SETTINGS]->OnApply(PPOAACTION_APPLY);
    }

    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pBasePages); nIndex++)
    {
        if ((nIndex != PAGE_DISPLAY_SETTINGS) && m_pBasePages[nIndex])
        {
            m_pBasePages[nIndex]->OnApply(PPOAACTION_APPLY);
        }
    }

    if (TUIAP_WAITFORAPPLY & dwFlags)
    {
        m_fForceTimeout = TRUE;
    }

    // If nobody sent the message to the HWND to simulate an apply,
    // do so now.
    if (TUIAP_CLOSE_DIALOG & dwFlags)
    {
        HWND hwndBasePropDlg = GetParent(m_hwndParent);

        PropSheet_PressButton(hwndBasePropDlg, PSBTN_OK);
    }

    return S_OK;
}


HRESULT CThemeManager::GetBasePagesEnum(OUT IEnumUnknown ** ppEnumUnknown)
{
    return CEnumUnknown_CreateInstance(SAFECAST(this, IThemeUIPages *), (IUnknown **)m_pBasePages, ARRAYSIZE(m_pBasePages), 0, ppEnumUnknown);
}


HRESULT CThemeManager::UpdatePreview(IN DWORD dwFlags)
{
    HRESULT hr = S_OK;

    if (m_pPreview1)  // It's okay if this is NULL because it will update when it's created.
    {
        hr = m_pPreview1->UpdatePreview(SAFECAST(this, IPropertyBag *));
    }

    if (m_pPreview2)
    {
        HRESULT hr2 = m_pPreview2->UpdatePreview(SAFECAST(this, IPropertyBag *));

        if (FAILED(hr)) // return the best error
        {
            hr = hr2;
        }
    }

    if (m_pPreview3)
    {
        HRESULT hr2 = m_pPreview3->UpdatePreview(SAFECAST(this, IPropertyBag *));

        if (FAILED(hr)) // return the best error
        {
            hr = hr2;
        }
    }

    return hr;
}


HRESULT CThemeManager::AddFakeSettingsPage(IN LPVOID pVoid)
{
    if (pVoid)
    {
        ::AddFakeSettingsPage(this, (PROPSHEETHEADER *)pVoid);
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

HRESULT CThemeManager::SetExecMode(IN DWORD dwEM)
{
    _dwEM = dwEM;
    return S_OK;
}

HRESULT CThemeManager::GetExecMode(OUT DWORD* pdwEM)
{
    if (pdwEM)
    {
        *pdwEM = _dwEM;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

HRESULT CThemeManager::LoadMonitorBitmap(IN BOOL fFillDesktop, OUT HBITMAP* phbmMon)
{
    if (phbmMon)
    {
        *phbmMon = ::LoadMonitorBitmap(fFillDesktop);
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

HRESULT CThemeManager::DisplaySaveSettings(IN PVOID pContext, IN HWND hwnd, OUT int* piRet)
{
    if (piRet)
    {
        *piRet = ::DisplaySaveSettings(pContext, hwnd);
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

//===========================
// *** IPreviewSystemMetrics Interface ***
//===========================
HRESULT CThemeManager::RefreshColors(void)
{
    HRESULT hr = S_OK;

    // We should tell the base pages that they should reload the colors.
    // They are welcome to ignore the event if they don't use the system
    // colors.
    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pBasePages); nIndex++)
    {
        if (m_pBasePages[nIndex])
        {
            IPreviewSystemMetrics * ppsm;

            hr = m_pBasePages[nIndex]->QueryInterface(IID_PPV_ARG(IPreviewSystemMetrics, &ppsm));
            if (SUCCEEDED(hr))
            {
                hr = ppsm->RefreshColors();
                ppsm->Release();
            }
        }
    }

    return S_OK;
}


HRESULT CThemeManager::UpdateDPIchange(void)
{
    HRESULT hr = S_OK;

    LogStatus("DPI: CALLED asking to SCALE DPI");

    // We should tell the base pages that they should reload the colors.
    // They are welcome to ignore the event if they don't use the system
    // colors.
    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pBasePages); nIndex++)
    {
        if (m_pBasePages[nIndex])
        {
            IPreviewSystemMetrics * ppsm;

            hr = m_pBasePages[nIndex]->QueryInterface(IID_PPV_ARG(IPreviewSystemMetrics, &ppsm));
            if (SUCCEEDED(hr))
            {
                hr = ppsm->UpdateDPIchange();
                ppsm->Release();
            }
        }
    }

    return S_OK;
}


HRESULT CThemeManager::UpdateCharsetChanges(void)
{
    // CHARSET: In Win2k, fontfix.cpp was used as a hack to change the CHARSET from one language to another.
    // That doesn't work for many reasons: a) not called on roaming, b) not called for OS lang changes, 
    // c) won't fix the problem for strings with multiple languages, d) etc.
    // Therefore, the SHELL team (BryanSt) had the NTUSER team (MSadek) agree to use DEFAULT_CHARSET all the time.
    // If some app has bad logic testing the charset parameter, then the NTUSER team will shim that app to fix it.
    // The shim would be really simple, on the return from a SystemParametersInfo(SPI_GETNONCLIENTMETRICS or ICONFONTS)
    // just patch the lfCharSet param to the current charset.

    return S_OK;
}


HRESULT CThemeManager::DeskSetCurrentScheme(IN LPCWSTR pwzSchemeName)
{
    HRESULT hr = S_OK;

    // We should tell the base pages that they should reload the colors.
    // They are welcome to ignore the event if they don't use the system
    // colors.
    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pBasePages); nIndex++)
    {
        if (m_pBasePages[nIndex])
        {
            IPreviewSystemMetrics * ppsm;

            hr = m_pBasePages[nIndex]->QueryInterface(IID_PPV_ARG(IPreviewSystemMetrics, &ppsm));
            if (SUCCEEDED(hr))
            {
                hr = ppsm->DeskSetCurrentScheme(pwzSchemeName);
                ppsm->Release();
            }
        }
    }

    return S_OK;
}




HRESULT CThemeManager::_GetPropertyBagByCLSID(IN const GUID * pClsid, IN IPropertyBag ** ppPropertyBag)
{
    HRESULT hr = E_INVALIDARG;

    if (pClsid && ppPropertyBag)
    {
        IEnumUnknown * pEnumUnknown;

        hr = GetBasePagesEnum(&pEnumUnknown);
        if (SUCCEEDED(hr))
        {
            IUnknown * punk;

            hr = IEnumUnknown_FindCLSID(pEnumUnknown, *pClsid, &punk);
            if (SUCCEEDED(hr))
            {
                hr = punk->QueryInterface(IID_PPV_ARG(IPropertyBag, ppPropertyBag));
                punk->Release();
            }

            pEnumUnknown->Release();
        }
    }

    return hr;
}


HRESULT CThemeManager::_SaveCustomValues(void)
{
    HRESULT hr = E_FAIL;

    if (m_pBasePages[0])
    {
        TCHAR szDisplayName[MAX_PATH];

        hr = GetCurrentUserCustomName(szDisplayName, ARRAYSIZE(szDisplayName));
        if (SUCCEEDED(hr))
        {
            IPropertyBag * pPropertyBag = NULL;

            hr = QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
            if (SUCCEEDED(hr))
            {
                TCHAR szPath[MAX_PATH];

                if (SHGetSpecialFolderPath(NULL, szPath, CSIDL_APPDATA, TRUE))
                {
                    ITheme * pTheme;

                    PathAppend(szPath, TEXT("Microsoft\\Windows\\Themes\\Custom.theme"));
                    hr = SnapShotLiveSettingsToTheme(pPropertyBag, szPath, &pTheme);
                    if (SUCCEEDED(hr))
                    {
                        CComBSTR bstrDisplayName(szDisplayName);

                        hr = pTheme->put_DisplayName(bstrDisplayName);
                        pTheme->Release();
                    }
                }

                pPropertyBag->Release();
            }
        }
    }

    return hr;
}


//===========================
// *** IObjectWithSite Interface ***
//===========================
HRESULT CThemeManager::SetSite(IN IUnknown *punkSite)
{
    if (!punkSite)
    {
        // This is a hint from up the chain that we are shutting down.
        // We need to use this cue to release my children objects so
        // they release me and we don't all leak.
        for (int nIndex = 0; nIndex < ARRAYSIZE(m_pBasePages); nIndex++)
        {
            if (m_pBasePages[nIndex])
            {
                IUnknown_SetSite(m_pBasePages[nIndex], NULL);
            }
        }
    }

    return CObjectWithSite::SetSite(punkSite);
}


//===========================
// *** IPropertyBag Interface ***
//===========================
#define SZ_PROPERTY_ICONHEADER          L"CLSID\\{"

HRESULT CThemeManager::Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog)
{
    HRESULT hr = E_INVALIDARG;

    // We don't contain any settings our self, but we need to reflect down into our pages to get
    // the correct settings.
    if (pszPropName && pVar)
    {
        IPropertyBag * pPropertyBag = NULL;

        if (!StrCmpIW(pszPropName, SZ_PBPROP_BACKGROUND_PATH) ||
            !StrCmpIW(pszPropName, SZ_PBPROP_BACKGROUNDSRC_PATH) ||
            !StrCmpIW(pszPropName, SZ_PBPROP_BACKGROUND_TILE) ||
            !StrCmpNIW(pszPropName, SZ_PROPERTY_ICONHEADER, ARRAYSIZE(SZ_PROPERTY_ICONHEADER) - 1))
        {
            hr = _GetPropertyBagByCLSID(&PPID_Background, &pPropertyBag);
            if (SUCCEEDED(hr))
            {
                hr = pPropertyBag->Read(pszPropName, pVar, pErrorLog);
            }
        }
        else if (!StrCmpIW(pszPropName, SZ_PBPROP_SCREENSAVER_PATH))
        {
            hr = _GetPropertyBagByCLSID(&PPID_ScreenSaver, &pPropertyBag);
            if (SUCCEEDED(hr))
            {
                hr = pPropertyBag->Read(pszPropName, pVar, pErrorLog);
            }
        }
        else if (!StrCmpIW(pszPropName, SZ_PBPROP_VISUALSTYLE_PATH) ||
                 !StrCmpIW(pszPropName, SZ_PBPROP_VISUALSTYLE_COLOR) ||
                 !StrCmpIW(pszPropName, SZ_PBPROP_VISUALSTYLE_SIZE) ||
                 !StrCmpIW(pszPropName, SZ_PBPROP_SYSTEM_METRICS) ||
                 !StrCmpIW(pszPropName, SZ_PBPROP_BACKGROUND_COLOR) ||
                 !StrCmpIW(pszPropName, SZ_PBPROP_DPI_MODIFIED_VALUE) ||
                 !StrCmpIW(pszPropName, SZ_PBPROP_DPI_APPLIED_VALUE))
        {
            hr = _GetPropertyBagByCLSID(&PPID_BaseAppearance, &pPropertyBag);
            if (SUCCEEDED(hr))
            {
                hr = pPropertyBag->Read(pszPropName, pVar, pErrorLog);
            }
        }
        else if (!StrCmpNIW(pszPropName, SZ_PBPROP_THEME_FILTER, SIZE_THEME_FILTER_STR))
        {
            hr = _GetPropertyBagByCLSID(&PPID_Theme, &pPropertyBag);
            if (SUCCEEDED(hr))
            {
                hr = pPropertyBag->Read(pszPropName, pVar, pErrorLog);
            }
        }

        ATOMICRELEASE(pPropertyBag);
    }

    return hr;
}


HRESULT CThemeManager::Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName)
    {
        if (pVar)
        {
            if ((VT_UNKNOWN == pVar->vt))
            {
                if (!StrCmpW(pszPropName, SZ_PBPROP_PREVIEW1))
                {
                    IUnknown_Set((IUnknown **)&m_pPreview1, pVar->punkVal);
                    hr = S_OK;
                }
                else if (!StrCmpW(pszPropName, SZ_PBPROP_PREVIEW2))
                {
                    IUnknown_Set((IUnknown **)&m_pPreview2, pVar->punkVal);
                    hr = S_OK;
                }
                else if (!StrCmpW(pszPropName, SZ_PBPROP_PREVIEW3))
                {
                    IUnknown_Set((IUnknown **)&m_pPreview3, pVar->punkVal);
                    hr = S_OK;
                }
            }
            else if (!StrCmpIW(pszPropName, SZ_PBPROP_CUSTOMIZE_THEME) ||
                     !StrCmpIW(pszPropName, SZ_PBPROP_THEME_LAUNCHTHEME))
            {
                IPropertyBag * pPropertyBag = NULL;

                hr = _GetPropertyBagByCLSID(&PPID_Theme, &pPropertyBag);
                if (SUCCEEDED(hr))
                {
                    hr = pPropertyBag->Write(pszPropName, pVar);
                    pPropertyBag->Release();
                }
            }
            else if (!StrCmpIW(pszPropName, SZ_PBPROP_APPEARANCE_LAUNCHMSTHEME) ||
                     !StrCmpIW(pszPropName, SZ_PBPROP_VISUALSTYLE_PATH) ||
                     !StrCmpIW(pszPropName, SZ_PBPROP_VISUALSTYLE_COLOR) ||
                     !StrCmpIW(pszPropName, SZ_PBPROP_VISUALSTYLE_SIZE) ||
                     !StrCmpIW(pszPropName, SZ_PBPROP_DPI_MODIFIED_VALUE) ||
                     !StrCmpIW(pszPropName, SZ_PBPROP_DPI_APPLIED_VALUE))
            {
                IPropertyBag * pPropertyBag = NULL;

                hr = _GetPropertyBagByCLSID(&PPID_BaseAppearance, &pPropertyBag);
                if (SUCCEEDED(hr))
                {
                    hr = pPropertyBag->Write(pszPropName, pVar);
                    pPropertyBag->Release();
                }
            }
            else if (!StrCmpIW(pszPropName, SZ_PBPROP_BACKGROUND_COLOR))
            {
                IPropertyBag * pPropertyBag = NULL;

                hr = _GetPropertyBagByCLSID(&PPID_BaseAppearance, &pPropertyBag);
                if (SUCCEEDED(hr))
                {
                    hr = pPropertyBag->Write(pszPropName, pVar);
                    pPropertyBag->Release();
                }
            }
            else if (!StrCmpIW(pszPropName, SZ_PBPROP_THEME_SETSELECTION) &&
                (VT_BSTR == pVar->vt))
            {
                hr = _SetSelectedThemeEntree(pVar->bstrVal);
            }
        }
        else
        {
            if (!StrCmpW(pszPropName, SZ_PBPROP_PREOPEN))
            {
                hr = _SaveCustomValues();
            }
        }
    }

    return hr;
}




//===========================
// *** IUnknown Interface ***
//===========================
ULONG CThemeManager::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CThemeManager::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CThemeManager::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CThemeManager, IObjectWithSite),
        QITABENT(CThemeManager, IThemeUIPages),
        QITABENT(CThemeManager, IPropertyBag),
        QITABENT(CThemeManager, IPreviewSystemMetrics),
        QITABENT(CThemeManager, IThemeManager),
        QITABENT(CThemeManager, IObjectSafety),
        QITABENT(CThemeManager, IDispatch),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CThemeManager::CThemeManager() : CImpIDispatch(LIBID_Theme, 1, 0, IID_IThemeManager), m_cRef(1)
{
    DllAddRef();

    _dwEM = EM_NORMAL;
    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pBasePages[0]);
    ASSERT(!m_pPreview1);
    ASSERT(!m_pPreview2);
    ASSERT(!m_pPreview3);
    ASSERT(!m_hdpaThemeDirs);
    ASSERT(!m_hdpaSkinDirs);
    ASSERT(!_pThemeSchemeSelected);
    ASSERT(!m_fForceTimeout);
    ASSERT(!m_cSpiThreads);
    
    SPISetThreadCounter(&m_cSpiThreads);

    _InitComCtl32();
}


int CALLBACK DPALocalFree_Callback(LPVOID p, LPVOID pData)
{
    LocalFree(p);       // NULLs will be ignored.
    return 1;
}


CThemeManager::~CThemeManager()
{
    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pBasePages); nIndex++)
    {
        if (m_pBasePages[nIndex])
        {
            IUnknown_SetSite(m_pBasePages[nIndex], NULL);
        }

        ATOMICRELEASE(m_pBasePages[nIndex]);
    }

    if (m_hdpaThemeDirs)
    {
        DPA_DestroyCallback(m_hdpaThemeDirs, DPALocalFree_Callback, NULL);
    }

    if (m_hdpaSkinDirs)
    {
        DPA_DestroyCallback(m_hdpaSkinDirs, DPALocalFree_Callback, NULL);
    }

    Str_SetPtr(&_pszSelectTheme, NULL);

    ATOMICRELEASE(_pThemeSchemeSelected);
    ATOMICRELEASE(m_pPreview1);
    ATOMICRELEASE(m_pPreview2);
    ATOMICRELEASE(m_pPreview3);

    if (m_fForceTimeout)
    {
        LONG lWait = 30 * 1000;
        LONG lEnd = (LONG) GetTickCount() + lWait;
        //  this will wait until all SPICreateThreads() have returned
        while (m_cSpiThreads && lWait > 0)
        {
            DWORD dwReturn = MsgWaitForMultipleObjects(0, NULL, FALSE, lWait, QS_ALLINPUT);
            if (dwReturn == -1 || dwReturn == WAIT_TIMEOUT)
                break;

            MSG msg;
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
            lWait = lEnd - GetTickCount();
        }
    }
    SPISetThreadCounter(NULL);
    DllRelease();
}


/*****************************************************************************\
    DESCRIPTION:
        When the object is created this way, it's used privately by the Display
    Control Panel.  The CLSID is private so we don't need to worry about external
    components using it this way.
\*****************************************************************************/
HRESULT CThemeUIPages_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj)
{
    if (punkOuter)
    {
        return CLASS_E_NOAGGREGATION;
    }

    HRESULT hr = E_INVALIDARG;

    if (ppvObj)
    {
        CThemeManager * pObject = new CThemeManager();

        *ppvObj = NULL;
        if (pObject)
        {
            hr = pObject->_Initialize();
            if (SUCCEEDED(hr))
            {
                hr = pObject->QueryInterface(riid, ppvObj);
            }
            else
            {
                IUnknown_SetSite(SAFECAST(pObject, IThemeManager *), NULL);

                // HACK: The display CPL is opening so see if the language changed
                // and the fonts need to be "fixed".
                FixFontsOnLanguageChange();
            }

            pObject->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


/*****************************************************************************\
    DESCRIPTION:
        External components can create the ThemeManager object this way.  In this
    case we need to add the pages ourselves.
\*****************************************************************************/
HRESULT CThemeManager_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj)
{
    IThemeUIPages * pThemeUIPages;
    HRESULT hr = CThemeUIPages_CreateInstance(NULL, IID_PPV_ARG(IThemeUIPages, &pThemeUIPages));

    if (SUCCEEDED(hr))
    {
        IBasePropPage * pBasePage;

        hr = CoCreateInstance(CLSID_CDeskHtmlProp, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IBasePropPage, &pBasePage));
        if (SUCCEEDED(hr))
        {
            hr = pThemeUIPages->AddBasePage(pBasePage);
            pBasePage->Release();
        }

        if (SUCCEEDED(hr))
        {
            hr = CScreenSaverPage_CreateInstance(NULL, IID_PPV_ARG(IBasePropPage, &pBasePage));
            if (SUCCEEDED(hr))
            {
                hr = pThemeUIPages->AddBasePage(pBasePage);
                pBasePage->Release();
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = pThemeUIPages->QueryInterface(riid, ppvObj);
        }
        else
        {
            IUnknown_SetSite(pThemeUIPages, NULL);
        }

        pThemeUIPages->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\advdlg.h ===
/*****************************************************************************\
    FILE: AdvDlg.h

    DESCRIPTION:
        This code will display the "Advanced Display Properties" dialog.

    BryanSt 3/23/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _ADVDLG_H
#define _ADVDLG_H


#define MAX_ADVDLG_PAGES            10

HRESULT CThemeManager_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);
HRESULT CThemeUIPages_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);

class CThemeManager             : public IThemeUIPages
                                , public CImpIDispatch
                                , public CAutomationSecurity
                                , public IThemeManager
                                , public IPropertyBag
                                , public IPreviewSystemMetrics
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IThemeManager ***
    virtual STDMETHODIMP get_SelectedTheme(OUT ITheme ** ppTheme);
    virtual STDMETHODIMP put_SelectedTheme(IN ITheme * pTheme);
    virtual STDMETHODIMP get_SelectedScheme(OUT IThemeScheme ** ppThemeScheme);
    virtual STDMETHODIMP put_SelectedScheme(IN IThemeScheme * pThemeStyle);
    virtual STDMETHODIMP get_WebviewCSS(OUT BSTR * pbstrPath);
    virtual STDMETHODIMP get_length(OUT long * pnLength);
    virtual STDMETHODIMP get_item(IN VARIANT varIndex, OUT ITheme ** ppTheme);
    virtual STDMETHODIMP get_schemeLength(OUT long * pnLength);
    virtual STDMETHODIMP get_schemeItem(IN VARIANT varIndex, OUT IThemeScheme ** ppThemeScheme);

    virtual STDMETHODIMP GetSelectedSchemeProperty(IN BSTR bstrName, OUT BSTR * pbstrValue);
    virtual STDMETHODIMP GetSpecialTheme(IN BSTR bstrName, OUT ITheme ** ppTheme);
    virtual STDMETHODIMP SetSpecialTheme(IN BSTR bstrName, IN ITheme * pTheme);
    virtual STDMETHODIMP GetSpecialScheme(IN BSTR bstrName, OUT IThemeScheme ** ppThemeScheme, OUT IThemeStyle ** ppThemeStyle, OUT IThemeSize ** ppThemeSize);
    virtual STDMETHODIMP SetSpecialScheme(IN BSTR bstrName, IN IThemeScheme * pThemeScheme, IThemeStyle * pThemeStyle, IThemeSize * pThemeSize);
    virtual STDMETHODIMP ApplyNow(void);

    // *** IThemeUIPages ***
    virtual STDMETHODIMP AddPage(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam, IN long nPageID);
    virtual STDMETHODIMP AddBasePage(IN IBasePropPage * pBasePage);
    virtual STDMETHODIMP ApplyPressed(IN DWORD dwFlags);
    virtual STDMETHODIMP GetBasePagesEnum(OUT IEnumUnknown ** ppEnumUnknown);
    virtual STDMETHODIMP UpdatePreview(IN DWORD dwFlags);
    virtual STDMETHODIMP AddFakeSettingsPage(IN LPVOID pVoid);
    virtual STDMETHODIMP SetExecMode(IN DWORD dwEM);
    virtual STDMETHODIMP GetExecMode(OUT DWORD* pdwEM);
    virtual STDMETHODIMP LoadMonitorBitmap(IN BOOL fFillDesktop, OUT HBITMAP* phbmMon);
    virtual STDMETHODIMP DisplaySaveSettings(IN PVOID pContext, IN HWND hwnd, OUT int* piRet);

    // *** IObjectWithSite ***
    virtual STDMETHODIMP SetSite(IUnknown *punkSite);

    // *** IPropertyBag ***
    virtual STDMETHODIMP Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog);
    virtual STDMETHODIMP Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar);

    // *** IPreviewSystemMetrics ***
    virtual STDMETHODIMP RefreshColors(void);
    virtual STDMETHODIMP UpdateDPIchange(void);
    virtual STDMETHODIMP UpdateCharsetChanges(void);
    virtual STDMETHODIMP DeskSetCurrentScheme(IN LPCWSTR pwzSchemeName);

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

protected:
    HRESULT _Initialize(void);

private:
    CThemeManager();
    virtual ~CThemeManager(void);

    // Private Member Variables
    long                    m_cRef;

    HWND                    m_hwndParent;                               // hwnd of parent.
    IBasePropPage *         m_pBasePages[MAX_ADVDLG_PAGES];             // These are the tabs on the Base dlg that want to add tabs to the Adv dlg.
    IThemePreview *         m_pPreview1;                                // 
    IThemePreview *         m_pPreview2;                                // 
    IThemePreview *         m_pPreview3;                                // 
    DWORD                   _dwEM;                                      // Stores the Execution mode in a center location
    LPWSTR                  _pszSelectTheme;                            // This is the selected .Theme file.
    IThemeScheme *          _pThemeSchemeSelected;                      // This is the selected .msstyles file.
    LONG                    m_cSpiThreads;
    BOOL                    m_fForceTimeout;

    HDPA                    m_hdpaThemeDirs;        // This contains LPWSTRs that contain theme (*.theme) files.
    HDPA                    m_hdpaSkinDirs;         // This contains LPWSTRs that contain skins (*.msstyles) files.

    // Private Member Functions
    HRESULT _GetPropertyBagByCLSID(IN const GUID * pClsid, IN IPropertyBag ** ppPropertyBag);
    HRESULT _SaveCustomValues(void);

    HRESULT _InitThemeDirs(void);
    HRESULT _AddThemesFromDir(LPCTSTR pszPath, BOOL fFirstLevel, int nInsertLoc);
    HRESULT _saveGetSelectedScheme(OUT IThemeScheme ** ppThemeScheme);

    HRESULT _InitSkinDirs(void);
    HRESULT _EnumSkinCB(THEMECALLBACK tcbType, LPCWSTR pszFileName, OPTIONAL LPCWSTR pszDisplayName, OPTIONAL LPCWSTR pszToolTip, OPTIONAL int iIndex);
    HRESULT _EnumSkinsFromKey(HKEY hKey);

    HRESULT _InitSelectedThemeFile(void);
    HRESULT _SetSelectedThemeEntree(LPCWSTR pszPath);

    // Friend Functions
    friend HRESULT CThemeManager_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);
    friend HRESULT CThemeUIPages_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);
    static BOOL EnumSkinCB(THEMECALLBACK tcbType, LPCWSTR pszFileName, OPTIONAL LPCWSTR pszDisplayName, OPTIONAL LPCWSTR pszToolTip, OPTIONAL int iIndex, LPARAM lParam);
};



#endif // _ADVDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\advappearpg.cpp ===
/*****************************************************************************\
    FILE: AdvAppearPg.cpp

    DESCRIPTION:
        This code will display a "Advanced Appearances" tab in the
    "Advanced Display Properties" dialog.

    ??????? ?/??/1993    Created
    BryanSt 3/23/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 1993-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "PreviewSM.h"
#include "AdvAppearPg.h"
#include "BaseAppearPg.h"
#include "regutil.h"
#include "CoverWnd.h"
#include "fontfix.h"





// The following are the indices into the above array.
#define COLORFLAG_SOLID 0x0001
#define COLOR_MAX_400       (COLOR_INFOBK + 1)
#define CURRENT_ELEMENT_NONE            -2          // This means that no element is selected.





// used by ChooseColor dialog
COLORREF g_CustomColors[16];    // This is the user customized palette.  We could put this into the class.

CAdvAppearancePage * g_pAdvAppearancePage = NULL;


//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//this order has to match the enum order in look.h
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
LOOK_ELEMENT g_elements[] = {
/* ELEMENT_APPSPACE        */   {COLOR_APPWORKSPACE,    SIZE_NONE,      FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_APPSPACE, -1,       COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_DESKTOP         */   {COLOR_BACKGROUND,      SIZE_NONE,      FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_DESKTOP, -1,        COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_INACTIVEBORDER  */   {COLOR_INACTIVEBORDER,  SIZE_FRAME,     FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_INACTIVEBORDER, -1, COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_ACTIVEBORDER    */   {COLOR_ACTIVEBORDER,    SIZE_FRAME,     FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_ACTIVEBORDER, -1,   COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_INACTIVECAPTION */   {COLOR_INACTIVECAPTION, SIZE_CAPTION,   TRUE,    COLOR_INACTIVECAPTIONTEXT,FONT_CAPTION,ELNAME_INACTIVECAPTION, -1,COLOR_GRADIENTINACTIVECAPTION, {-1,-1,-1,-1}},
/* ELEMENT_INACTIVESYSBUT1 */   {COLOR_NONE,            SIZE_CAPTION,   FALSE,   COLOR_NONE,             FONT_NONE,     -1, ELEMENT_ACTIVESYSBUT1, COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_INACTIVESYSBUT2 */   {COLOR_NONE,            SIZE_CAPTION,   FALSE,   COLOR_NONE,             FONT_NONE,     -1, ELEMENT_ACTIVESYSBUT1, COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_ACTIVECAPTION   */   {COLOR_ACTIVECAPTION,   SIZE_CAPTION,   TRUE,    COLOR_CAPTIONTEXT,      FONT_CAPTION,  ELNAME_ACTIVECAPTION, -1,  COLOR_GRADIENTACTIVECAPTION, {-1,-1,-1,-1}},
/* ELEMENT_ACTIVESYSBUT1   */   {COLOR_NONE,            SIZE_CAPTION,   FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_CAPTIONBUTTON, -1,  COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_ACTIVESYSBUT2   */   {COLOR_NONE,            SIZE_CAPTION,   FALSE,   COLOR_NONE,             FONT_NONE,     -1, ELEMENT_ACTIVESYSBUT1, COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_MENUNORMAL      */   {COLOR_MENU,            SIZE_MENU,      TRUE,    COLOR_MENUTEXT,         FONT_MENU,     ELNAME_MENU, -1,           COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_MENUSELECTED    */   {COLOR_HIGHLIGHT,       SIZE_MENU,      TRUE,    COLOR_HIGHLIGHTTEXT,    FONT_MENU,     ELNAME_MENUSELECTED, -1,   COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_MENUDISABLED    */   {COLOR_MENU,            SIZE_MENU,      TRUE,    COLOR_NONE,             FONT_MENU,     -1, ELEMENT_MENUNORMAL,    COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_WINDOW          */   {COLOR_WINDOW,          SIZE_NONE,      FALSE,   COLOR_WINDOWTEXT,       FONT_NONE,     ELNAME_WINDOW, -1,         COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_MSGBOX          */   {COLOR_NONE,            SIZE_NONE,      TRUE,    COLOR_WINDOWTEXT,       FONT_MSGBOX,   ELNAME_MSGBOX, -1,         COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_MSGBOXCAPTION   */   {COLOR_ACTIVECAPTION,   SIZE_CAPTION,   TRUE,    COLOR_CAPTIONTEXT,      FONT_CAPTION,  -1, ELEMENT_ACTIVECAPTION, COLOR_GRADIENTACTIVECAPTION, {-1,-1,-1,-1}},
/* ELEMENT_MSGBOXSYSBUT    */   {COLOR_3DFACE,          SIZE_CAPTION,   TRUE,    COLOR_BTNTEXT,          FONT_CAPTION,  -1, ELEMENT_ACTIVESYSBUT1, COLOR_NONE, {-1,-1,-1,-1}},
// do not even try to set a scrollbar color the system will ignore you
/* ELEMENT_SCROLLBAR       */   {COLOR_NONE,            SIZE_SCROLL,    FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_SCROLLBAR, -1,      COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_SCROLLUP        */   {COLOR_NONE,            SIZE_SCROLL,    FALSE,   COLOR_NONE,             FONT_NONE,     -1, ELEMENT_SCROLLBAR,     COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_SCROLLDOWN      */   {COLOR_NONE,            SIZE_SCROLL,    FALSE,   COLOR_NONE,             FONT_NONE,     -1, ELEMENT_SCROLLBAR,     COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_BUTTON          */   {COLOR_3DFACE,          SIZE_NONE,      FALSE,   COLOR_BTNTEXT,          FONT_NONE,     ELNAME_BUTTON, -1,         COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_SMCAPTION       */   {COLOR_NONE,            SIZE_SMCAPTION, TRUE,    COLOR_NONE,             FONT_SMCAPTION,ELNAME_SMALLCAPTION, -1,   COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_ICON            */   {COLOR_NONE,            SIZE_ICON,      FALSE,   COLOR_NONE,             FONT_ICONTITLE,ELNAME_ICON, -1,           COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_ICONHORZSPACING */   {COLOR_NONE,            SIZE_DXICON,    FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_DXICON, -1,         COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_ICONVERTSPACING */   {COLOR_NONE,            SIZE_DYICON,    FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_DYICON, -1,         COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_INFO            */   {COLOR_INFOBK,          SIZE_NONE,      TRUE,    COLOR_INFOTEXT,         FONT_STATUS,   ELNAME_INFO, -1,           COLOR_NONE, {-1,-1,-1,-1}},
/* ELEMENT_HOTTRACKAREA    */   {COLOR_HOTLIGHT,        SIZE_NONE,      FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_HOTTRACKAREA, -1,   COLOR_NONE, {-1,-1,-1,-1}}
};
#if 0
// go fix look.h if you decide to add this back in
/* ELEMENT_SMICON          */   {COLOR_NONE,            SIZE_SMICON,    FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_SMICON, -1,         COLOR_NONE, {-1,-1,-1,-1}},
#endif

#define ELCUR           (g_elements[m_iCurElement])
#define ELCURFONT       (m_fonts[ELCUR.iFont])



void LoadCustomColors(void);
BOOL Font_GetNameFromList(HWND hwndList, INT iItem, LPTSTR pszFace, INT cchFaceMax, LPTSTR pszScript, INT cchScriptMax);
void Font_AddSize(HWND hwndPoints, int iNewPoint, BOOL bSort);
int CALLBACK Font_EnumSizes(LPENUMLOGFONT lpelf, LPNEWTEXTMETRIC lpntm, int Type, LPARAM lData);











//============================================================================================================
// *** Globals ***
//============================================================================================================
const static DWORD aAdvAppearanceHelpIds[] = {
    IDC_ADVAP_LOOKPREV,             IDH_DISPLAY_APPEARANCE_GRAPHIC,
    IDC_ADVAP_ELEMENTSLABEL,        IDH_DISPLAY_APPEARANCE_ITEM_LIST,
    IDC_ADVAP_ELEMENTS,             IDH_DISPLAY_APPEARANCE_ITEM_LIST,
    IDC_ADVAP_MAINSIZE,             IDH_DISPLAY_APPEARANCE_ITEM_SIZE,
    IDC_ADVAP_SIZELABEL,            IDH_DISPLAY_APPEARANCE_ITEM_SIZE,
    IDC_ADVAP_SIZEARROWS,           IDH_DISPLAY_APPEARANCE_ITEM_SIZE,
    IDC_ADVAP_COLORLABEL,           IDH_DISPLAY_APPEARANCE_ITEM_COLOR,
    IDC_ADVAP_MAINCOLOR,            IDH_DISPLAY_APPEARANCE_ITEM_COLOR,
    IDC_ADVAP_GRADIENTLABEL,        IDH_DISPLAY_APPEARANCE_ITEM_COLOR2,
    IDC_ADVAP_GRADIENT,             IDH_DISPLAY_APPEARANCE_ITEM_COLOR2,
    IDC_ADVAP_FONTLABEL,            IDH_DISPLAY_APPEARANCE_FONT_LIST,
    IDC_ADVAP_FONTNAME,             IDH_DISPLAY_APPEARANCE_FONT_LIST,
    IDC_ADVAP_FONTSIZELABEL,        IDH_DISPLAY_APPEARANCE_FONT_SIZE,
    IDC_ADVAP_FONTSIZE,             IDH_DISPLAY_APPEARANCE_FONT_SIZE,
    IDC_ADVAP_FNCOLORLABEL,         IDH_DISPLAY_APPEARANCE_FONT_COLOR,
    IDC_ADVAP_TEXTCOLOR,            IDH_DISPLAY_APPEARANCE_FONT_COLOR,
    IDC_ADVAP_FONTBOLD,             IDH_DISPLAY_APPEARANCE_FONT_BOLD,
    IDC_ADVAP_FONTITAL,             IDH_DISPLAY_APPEARANCE_FONT_ITALIC,
    0, 0
};

#define SZ_HELPFILE_ADVAPPEARANCE           TEXT("display.hlp")


//===========================
// *** Class Internals & Helpers ***
//===========================
// a new font name was chosen.  build a new point size list.
void CAdvAppearancePage::_SelectName(HWND hDlg, int iSel)
{
    INT dwItemData;
    HWND hwndFontSize = GetDlgItem(hDlg, IDC_ADVAP_FONTSIZE);
    HDC hdc;

    // build the approriate point size list
    SendMessage(hwndFontSize, CB_RESETCONTENT, 0, 0L);
    dwItemData = LOWORD(SendDlgItemMessage(hDlg, IDC_ADVAP_FONTNAME, CB_GETITEMDATA, (WPARAM)iSel, 0L));
    if (LOWORD(dwItemData) == TRUETYPE_FONTTYPE)
    {
        INT i;
        for (i = 6; i <= 24; i++)
            Font_AddSize(hwndFontSize, i, FALSE);
    }
    else
    {
        LOGFONT lf;

        Font_GetNameFromList(GetDlgItem(hDlg, IDC_ADVAP_FONTNAME),
                             iSel,
                             lf.lfFaceName,
                             ARRAYSIZE(lf.lfFaceName),
                             NULL,
                             0);
        hdc = GetDC(NULL);
        lf.lfCharSet = (BYTE)(HIWORD(dwItemData));
#ifdef WINDOWS_ME
        lf.lfPitchAndFamily = MONO_FONT;
#else
        lf.lfPitchAndFamily = 0;
#endif
        EnumFontFamiliesEx(hdc, &lf, (FONTENUMPROC)Font_EnumSizes, (LPARAM)this, 0);
        ReleaseDC(NULL, hdc);
    }
}


// new font was chosen.  select the proper point size
// return: actual point size chosen
int Font_SelectSize(HWND hDlg, int iCurPoint)
{
    int i, iPoint = 0;
    HWND hwndFontSize = GetDlgItem(hDlg, IDC_ADVAP_FONTSIZE);

    i = (int)SendMessage(hwndFontSize, CB_GETCOUNT, 0, 0L);

    // the loop stops with i=0, so we get some selection for sure
    for (i--; i > 0; i--)
    {
        iPoint = LOWORD(SendMessage(hwndFontSize, CB_GETITEMDATA, (WPARAM)i, 0L));
        // walking backwards through list, find equal or next smallest
        if (iCurPoint >= iPoint)
            break;
    }
    SendMessage(hwndFontSize, CB_SETCURSEL, (WPARAM)i, 0L);

    return iPoint;
}


int CAdvAppearancePage::_HeightToPoint(int nHeight)
{
    if (nHeight < 0)
    {
        nHeight = -nHeight;
    }

    return MulDiv(nHeight, 72, m_nCachedNewDPI);
}


int CAdvAppearancePage::_PointToHeight(int nPoints)
{
    if (nPoints > 0)
    {
        nPoints = -nPoints;
    }

    // Heights must always be negative.  NTUSER is full of bugs when
    // the values are positive.
    return MulDiv(nPoints, m_nCachedNewDPI, 72);
}


/*
** initialize the constant dialog components
**
** initialize the list of element names.  this stays constant with the
** possible exception that some items might be added/removed depending
** on some special case conditions.
*/
void Look_InitDialog(HWND hDlg)
{
    int iEl, iName;
    TCHAR szName[CCH_MAX_STRING];
    HWND hwndElements;
    LOGFONT lf;
    HFONT hfont;
    int oldWeight;

    LoadCustomColors();

    hwndElements = GetDlgItem(hDlg, IDC_ADVAP_ELEMENTS);
    for (iEl = 0; iEl < ARRAYSIZE(g_elements); iEl++)
    {
        if ((g_elements[iEl].iResId != -1) &&
                LoadString(HINST_THISDLL, g_elements[iEl].iResId, szName, ARRAYSIZE(szName)))
        {
            iName = (int)SendMessage(hwndElements, CB_FINDSTRINGEXACT, 0, (LPARAM)szName);

            if (iName == CB_ERR)
                iName = (int)SendMessage(hwndElements, CB_ADDSTRING, 0, (LPARAM)szName);

            // reference back to item in array
            if (iName != CB_ERR)
                SendMessage(hwndElements, CB_SETITEMDATA, (WPARAM)iName, (LPARAM)iEl);
        }
    }

    // make bold button have bold text
    hfont = (HFONT)SendDlgItemMessage(hDlg, IDC_ADVAP_FONTBOLD, WM_GETFONT, 0, 0L);
    GetObject(hfont, sizeof(lf), &lf);
    oldWeight = lf.lfWeight;
    lf.lfWeight = FW_BOLD;
    hfont = CreateFontIndirect(&lf);
    if (hfont)
        SendDlgItemMessage(hDlg, IDC_ADVAP_FONTBOLD, WM_SETFONT, (WPARAM)hfont, 0L);

    // make italic button have italic text
    lf.lfWeight = oldWeight;
    lf.lfItalic = TRUE;
    hfont = CreateFontIndirect(&lf);
    if (hfont)
    {
        SendDlgItemMessage(hDlg, IDC_ADVAP_FONTITAL, WM_SETFONT, (WPARAM)hfont, 0L);
    }
}


HRESULT CAdvAppearancePage::_OnFontNameChanged(HWND hDlg)
{
    HRESULT hr = E_NOTIMPL;
    TCHAR szBuf[MAX_PATH];

    int nIndex = (int)SendDlgItemMessage(hDlg, IDC_ADVAP_FONTNAME, CB_GETCURSEL,0,0L);
    DWORD dwItemData = (DWORD)SendDlgItemMessage(hDlg, IDC_ADVAP_FONTNAME, CB_GETITEMDATA, (WPARAM)nIndex, 0);

    _SelectName(hDlg, nIndex);
    Font_SelectSize(hDlg, _HeightToPoint(ELCURFONT.lf.lfHeight));
    Font_GetNameFromList(GetDlgItem(hDlg, IDC_ADVAP_FONTNAME), nIndex, szBuf, ARRAYSIZE(szBuf), NULL, 0);

    // Change font to currently selected name and charset.
    _ChangeFontName(hDlg, szBuf, HIWORD(dwItemData));

    return hr;
}


HRESULT CAdvAppearancePage::_OnSizeChange(HWND hDlg, WORD wEvent)
{
    HRESULT hr = E_NOTIMPL;
    int nIndex;

    if ((wEvent == EN_CHANGE) && (m_iCurElement >= 0) && (ELCUR.iSize >= 0))
    {
        nIndex = (int)LOWORD(SendDlgItemMessage(hDlg, IDC_ADVAP_SIZEARROWS, UDM_GETPOS,0,0L));
        _ChangeSize(hDlg, nIndex, TRUE);
    }
    else if (wEvent == EN_KILLFOCUS)
    {
        nIndex = (int)SendDlgItemMessage(hDlg, IDC_ADVAP_SIZEARROWS, UDM_GETPOS,0,0L);
        if (HIWORD(nIndex) != 0)
        {
            SetDlgItemInt(hDlg, IDC_ADVAP_MAINSIZE, (UINT)LOWORD(nIndex), FALSE);
        }
    }

    return hr;
}


HRESULT CAdvAppearancePage::_OnInitAdvAppearanceDlg(HWND hDlg)
{
    m_fInUserEditMode = FALSE;

    // initialize some globals
    _hwnd = hDlg;

    m_cyBorderSM = ClassicGetSystemMetrics(SM_CYBORDER);
    m_cxBorderSM = ClassicGetSystemMetrics(SM_CXBORDER);
    m_cxEdgeSM = ClassicGetSystemMetrics(SM_CXEDGE);
    m_cyEdgeSM = ClassicGetSystemMetrics(SM_CYEDGE);

    Look_InitDialog(hDlg);
    _InitSysStuff();
    _InitFontList(hDlg);

    // paint the preview
    _Repaint(hDlg, TRUE);
    _SelectElement(hDlg, ELEMENT_DESKTOP, LSE_SETCUR);

    m_fInUserEditMode = TRUE;

    // theme ownerdrawn color picker button
    m_hTheme = OpenThemeData(GetDlgItem(hDlg, IDC_ADVAP_MAINCOLOR), WC_BUTTON);
    return S_OK;
}


HRESULT CAdvAppearancePage::_LoadState(IN const SYSTEMMETRICSALL * pState)
{
    HRESULT hr = E_INVALIDARG;

    if (pState)
    {
        _SetMyNonClientMetrics((const LPNONCLIENTMETRICS)&(pState->schemeData.ncm));
        m_dwChanged = pState->dwChanged;

        // Set Sizes
        m_sizes[SIZE_DXICON].CurSize = pState->nDXIcon;
        m_sizes[SIZE_DYICON].CurSize = pState->nDYIcon;
        m_sizes[SIZE_ICON].CurSize = pState->nIcon;
        m_sizes[SIZE_SMICON].CurSize = pState->nSmallIcon;
        
        // Set Fonts
        m_fonts[FONT_ICONTITLE].lf = pState->schemeData.lfIconTitle;
        m_fModifiedScheme = pState->fModifiedScheme;

        for (int nIndex = 0; nIndex < ARRAYSIZE(m_rgb); nIndex++)
        {
            m_rgb[nIndex] = pState->schemeData.rgb[nIndex];
        }

        hr = S_OK;
    }

    return hr;
}


HRESULT CAdvAppearancePage::_OnDestroy(HWND hDlg)
{
    _DestroySysStuff();
    HFONT hfont, hfontOther;

    hfontOther = (HFONT)SendDlgItemMessage(hDlg, IDC_ADVAP_MAINSIZE, WM_GETFONT, 0, 0L);
    hfont = (HFONT)SendDlgItemMessage(hDlg, IDC_ADVAP_FONTBOLD, WM_GETFONT, 0, 0L);
    if (hfont && (hfont != hfontOther))
    {
        DeleteObject(hfont);
    }

    hfont = (HFONT)SendDlgItemMessage(hDlg, IDC_ADVAP_FONTITAL, WM_GETFONT, 0, 0L);
    if (hfont && (hfont != hfontOther))
    {
        DeleteObject(hfont);
    }

    if (m_hTheme)
    {
        CloseThemeData(m_hTheme);
        m_hTheme = NULL;
    }

    _hwnd = NULL;

    return S_OK;
}


INT_PTR CAdvAppearancePage::_OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = 1;   // Not handled (WM_COMMAND seems to be different)
    WORD idCtrl = GET_WM_COMMAND_ID(wParam, lParam);
    WORD wEvent = GET_WM_COMMAND_CMD(wParam, lParam);
    int nIndex;
    TCHAR szBuf[100];

    switch (idCtrl)
    {
    case IDOK:
        EndDialog(hDlg, IDOK);
        break;

    case IDCANCEL:
        EndDialog(hDlg, IDCANCEL);
        break;

    case IDC_ADVAP_ELEMENTS:
        if(wEvent == CBN_SELCHANGE)
        {
            nIndex = (int)SendDlgItemMessage(hDlg, IDC_ADVAP_ELEMENTS, CB_GETCURSEL,0,0L);
            nIndex = LOWORD(SendDlgItemMessage(hDlg, IDC_ADVAP_ELEMENTS, CB_GETITEMDATA, (WPARAM)nIndex, 0L));
            _SelectElement(hDlg, nIndex, LSE_NONE);
        }

        break;
    case IDC_ADVAP_FONTNAME:
        if(wEvent == CBN_SELCHANGE)
        {
            _OnFontNameChanged(hDlg);
        }
        break;


    case IDC_ADVAP_FONTSIZE:
        switch (wEvent)
        {
            case CBN_SELCHANGE:
                nIndex = (int)SendDlgItemMessage(hDlg, IDC_ADVAP_FONTSIZE, CB_GETCURSEL,0,0L);
                nIndex = LOWORD(SendDlgItemMessage(hDlg, IDC_ADVAP_FONTSIZE, CB_GETITEMDATA, (WPARAM)nIndex, 0L));
                _ChangeFontSize(hDlg, nIndex);
                break;

            case CBN_EDITCHANGE:
                GetWindowText(GetDlgItem(hDlg, IDC_ADVAP_FONTSIZE), szBuf, ARRAYSIZE(szBuf));
                _ChangeFontSize(hDlg, StrToInt(szBuf));
                break;
        }
        break;

    case IDC_ADVAP_FONTBOLD:
    case IDC_ADVAP_FONTITAL:
        if (wEvent == BN_CLICKED)
        {
            BOOL fCheck = !IsDlgButtonChecked(hDlg, LOWORD(wParam));
            CheckDlgButton(hDlg, LOWORD(wParam), fCheck);
            _ChangeFontBI(hDlg, LOWORD(wParam), fCheck);
        }
        break;

    case IDC_ADVAP_MAINSIZE:
        _OnSizeChange(hDlg, wEvent);
        break;

    case IDC_ADVAP_GRADIENT:
    case IDC_ADVAP_MAINCOLOR:
    case IDC_ADVAP_TEXTCOLOR:
        if (wEvent == BN_CLICKED)
            _PickAColor(hDlg, idCtrl);
        break;

    default:
        //TraceMsg(TF_ALWAYS, "in CMailBoxProcess::_OnCommand() wEvent=%#08lx, idCtrl=%#08lx", wEvent, idCtrl);
        break;
    }

    return fHandled;
}


INT_PTR CALLBACK CAdvAppearancePage::AdvAppearDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CAdvAppearancePage * pThis = (CAdvAppearancePage *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        pThis = (CAdvAppearancePage *) lParam;

        if (pThis)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        }
    }

    if (pThis)
        return pThis->_AdvAppearDlgProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}


// This Property Sheet appear in the top level of the "Display Control Panel".
INT_PTR CAdvAppearancePage::_AdvAppearDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
    case WM_NOTIFY:
        break;

    case WM_INITDIALOG:
        _OnInitAdvAppearanceDlg(hDlg);
        break;

    case WM_DESTROY:
        _OnDestroy(hDlg);
        break;

    case WM_DRAWITEM:
        switch (wParam)
        {
            case IDC_ADVAP_GRADIENT:
            case IDC_ADVAP_MAINCOLOR:
            case IDC_ADVAP_TEXTCOLOR:
                _DrawButton(hDlg, (LPDRAWITEMSTRUCT)lParam);
                return TRUE;
        }
        break;

    case WM_SETTINGCHANGE:
    case WM_SYSCOLORCHANGE:
    case WM_DISPLAYCHANGE:
        _PropagateMessage(hDlg, message, wParam, lParam);
        break;

    case WM_QUERYNEWPALETTE:
    case WM_PALETTECHANGED:
        SendDlgItemMessage(hDlg, IDC_ADVAP_LOOKPREV, message, wParam, lParam);
        return TRUE;

    case WM_HELP:
        WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, SZ_HELPFILE_ADVAPPEARANCE, HELP_WM_HELP, (DWORD_PTR)  aAdvAppearanceHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, SZ_HELPFILE_ADVAPPEARANCE, HELP_CONTEXTMENU, (DWORD_PTR)  aAdvAppearanceHelpIds);
        break;

    case WM_COMMAND:
        _OnCommand(hDlg, message, wParam, lParam);
        break;

    case WM_THEMECHANGED:
        if (m_hTheme)
        {
            CloseThemeData(m_hTheme);
        }

        m_hTheme = OpenThemeData(GetDlgItem(hDlg, IDC_ADVAP_MAINCOLOR), WC_BUTTON);
        break;
    }

    return FALSE;
}


const UINT g_colorFlags[COLOR_MAX] = {
/* COLOR_SCROLLBAR           */ 0,
/* COLOR_DESKTOP             */ 0,
/* COLOR_ACTIVECAPTION       */ COLORFLAG_SOLID,
/* COLOR_INACTIVECAPTION     */ COLORFLAG_SOLID,
/* COLOR_MENU                */ COLORFLAG_SOLID,
/* COLOR_WINDOW              */ COLORFLAG_SOLID,
/* COLOR_WINDOWFRAME         */ COLORFLAG_SOLID,
/* COLOR_MENUTEXT            */ COLORFLAG_SOLID,
/* COLOR_WINDOWTEXT          */ COLORFLAG_SOLID,
/* COLOR_CAPTIONTEXT         */ COLORFLAG_SOLID,
/* COLOR_ACTIVEBORDER        */ 0,
/* COLOR_INACTIVEBORDER      */ 0,
/* COLOR_APPWORKSPACE        */ 0,
/* COLOR_HIGHLIGHT           */ COLORFLAG_SOLID,
/* COLOR_HIGHLIGHTTEXT       */ COLORFLAG_SOLID,
/* COLOR_3DFACE              */ COLORFLAG_SOLID,
/* COLOR_3DSHADOW            */ COLORFLAG_SOLID,
/* COLOR_GRAYTEXT            */ COLORFLAG_SOLID,
/* COLOR_BTNTEXT             */ COLORFLAG_SOLID,
/* COLOR_INACTIVECAPTIONTEXT */ COLORFLAG_SOLID,
/* COLOR_3DHILIGHT           */ COLORFLAG_SOLID,
/* COLOR_3DDKSHADOW          */ COLORFLAG_SOLID,
/* COLOR_3DLIGHT             */ COLORFLAG_SOLID,
/* COLOR_INFOTEXT            */ COLORFLAG_SOLID,
/* COLOR_INFOBK              */ 0,
/* COLOR_3DALTFACE           */ 0,
/* COLOR_HOTLIGHT            */ COLORFLAG_SOLID,
/* COLOR_GRADIENTACTIVECAPTION   */ COLORFLAG_SOLID,
/* COLOR_GRADIENTINACTIVECAPTION */ COLORFLAG_SOLID,
/* COLOR_MENUHILIGHT         */ 0,
/* COLOR_MENUBAR             */ 0
};


#define RGB_PALETTE 0x02000000

//  make the color a solid color if it needs to be.
//  on a palette device make is a palette relative color, if we need to.
COLORREF CAdvAppearancePage::_NearestColor(int iColor, COLORREF rgb)
{
    rgb &= 0x00FFFFFF;

    // if we are on a palette device, we need to do special stuff...
    if (m_bPalette)
    {
        if (g_colorFlags[iColor] & COLORFLAG_SOLID)
        {
            if (IsPaletteColor(m_hpal3D, rgb))
                rgb |= RGB_PALETTE;
            else
                rgb = GetNearestPaletteColor(m_hpalVGA, rgb);
        }
        else
        {
            if (IsPaletteColor(m_hpal3D, rgb))
                rgb |= RGB_PALETTE;

            else if (IsPaletteColor((HPALETTE)GetStockObject(DEFAULT_PALETTE), rgb))
                rgb ^= 0x000001;    // force a dither
        }
    }
    else
    {
        // map color to nearest color if we need to for this UI element.
        if (g_colorFlags[iColor] & COLORFLAG_SOLID)
        {
            HDC hdc = GetDC(NULL);
            rgb = GetNearestColor(hdc, rgb);
            ReleaseDC(NULL, hdc);
        }
    }

    return rgb;
}


void CAdvAppearancePage::_PickAColor(HWND hDlg, int CtlID)
{
    COLORPICK_INFO cpi;
    int iColor;

    switch (CtlID)
    {
        case IDC_ADVAP_GRADIENT:
            iColor = ELCUR.iGradientColor;
            break;

        case IDC_ADVAP_MAINCOLOR:
            iColor = ELCUR.iMainColor;
            break;

        case IDC_ADVAP_TEXTCOLOR:
            iColor = ELCUR.iTextColor;
            break;

        default:
            return;

    }

    cpi.hwndParent = GetDlgItem(hDlg, CtlID);       
    cpi.hwndOwner = GetDlgItem(hDlg, CtlID);        // Color button
    cpi.hpal = m_hpal3D;
    cpi.rgb = m_rgb[iColor];
    cpi.flags = CC_RGBINIT | CC_FULLOPEN;

    if ((iColor == COLOR_3DFACE) && m_bPalette)
    {
        cpi.flags |= CC_ANYCOLOR;
    }
    else if (g_colorFlags[iColor] & COLORFLAG_SOLID)
    {
        cpi.flags |= CC_SOLIDCOLOR;
    }

    if (ChooseColorMini(&cpi) && _ChangeColor(hDlg, iColor, cpi.rgb))
    {
        _SetColor(hDlg, CtlID, m_brushes[iColor]);
        _Repaint(hDlg, FALSE);
    }
}


// ------------------------ magic color utilities --------------------------
/*
** set a color in the 3D palette.
*/
void CAdvAppearancePage::_Set3DPaletteColor(COLORREF rgb, int iColor)
{
    int iPalette;
    PALETTEENTRY pe;

    if (!m_hpal3D)
        return;

    switch (iColor)
    {
        case COLOR_3DFACE:
            iPalette = 16;
            break;
        case COLOR_3DSHADOW:
            iPalette = 17;
            break;
        case COLOR_3DHILIGHT:
            iPalette = 18;
            break;
        default:
            return;
    }

    pe.peRed    = GetRValue(rgb);
    pe.peGreen  = GetGValue(rgb);
    pe.peBlue   = GetBValue(rgb);
    pe.peFlags  = 0;
    SetPaletteEntries(m_hpal3D, iPalette, 1, (LPPALETTEENTRY)&pe);
}
// ------------end--------- magic color utilities --------------------------


void CAdvAppearancePage::_InitUniqueCharsetArray(void)
{
    UINT    uiCharsets[MAX_CHARSETS];

    Font_GetCurrentCharsets(uiCharsets, ARRAYSIZE(uiCharsets));
    // Find the unique Charsets and save that in a global array.
    Font_GetUniqueCharsets(uiCharsets, m_uiUniqueCharsets, MAX_CHARSETS, &m_iCountCharsets);    
}


HRESULT CAdvAppearancePage::_InitFonts(void)
{
    for (int nIndex = 0; nIndex < ARRAYSIZE(m_fonts); nIndex++)
    {
        if (m_fonts[nIndex].hfont)
        {
            DeleteObject(m_fonts[nIndex].hfont);
            m_fonts[nIndex].hfont = NULL;
        }
        m_fonts[nIndex].hfont = CreateFontIndirect(&m_fonts[nIndex].lf);
    }

    return S_OK;
}


HRESULT CAdvAppearancePage::_FreeFonts(void)
{
    for (int nIndex = 0; nIndex < ARRAYSIZE(m_fonts); nIndex++)
    {
        if (m_fonts[nIndex].hfont)
        {
            DeleteObject(m_fonts[nIndex].hfont);
            m_fonts[nIndex].hfont = NULL;
        }
    }

    return S_OK;
}


// new data has been set.  flush out current objects and rebuild
void CAdvAppearancePage::_RebuildSysStuff(BOOL fInit)
{
    int i;

    SelectObject(g_hdcMem, GetStockObject(BLACK_BRUSH));
    SelectObject(g_hdcMem, GetStockObject(SYSTEM_FONT));

    _InitFonts();
    if (fInit)
    {
        HPALETTE hpal = (HPALETTE) GetStockObject(DEFAULT_PALETTE);

        if (hpal)
        {
            PALETTEENTRY pal[4];

            // get current magic colors
            pal[0].peFlags = 0;
            pal[1].peFlags = 0;
            pal[2].peFlags = 0;
            pal[3].peFlags = 0;
            if (GetPaletteEntries(hpal, 8,  4, pal))
            {
                SetPaletteEntries(m_hpal3D, 16,  4, pal);

                // set up magic colors in the 3d palette
                if (!IsPaletteColor(hpal, m_rgb[COLOR_3DFACE]))
                    _Set3DPaletteColor(m_rgb[COLOR_3DFACE], COLOR_3DFACE);

                if (!IsPaletteColor(hpal, m_rgb[COLOR_3DSHADOW]))
                    _Set3DPaletteColor(m_rgb[COLOR_3DSHADOW],  COLOR_3DSHADOW);

                if (!IsPaletteColor(hpal, m_rgb[COLOR_3DHILIGHT]))
                    _Set3DPaletteColor(m_rgb[COLOR_3DHILIGHT], COLOR_3DHILIGHT);
            }
        }
    }

    for (i = 0; i < COLOR_MAX; i++)
    {
        if (m_brushes[i])
            DeleteObject(m_brushes[i]);

        m_brushes[i] = CreateSolidBrush(_NearestColor(i, m_rgb[i]));
    }

    if (m_iCurElement >= 0)
    {
        // we changed the brushes out from under the buttons...
        _SetColor(NULL, IDC_ADVAP_MAINCOLOR, ((ELCUR.iMainColor != COLOR_NONE) ? m_brushes[ELCUR.iMainColor] : NULL));
        _SetColor(NULL, IDC_ADVAP_GRADIENT, ((ELCUR.iGradientColor != COLOR_NONE) ? m_brushes[ELCUR.iGradientColor] : NULL));
        _SetColor(NULL, IDC_ADVAP_TEXTCOLOR, ((ELCUR.iTextColor != COLOR_NONE) ? m_brushes[ELCUR.iTextColor] : NULL));
    }
}


//
//  simple form of Shell message box, does not handle param replacment
//  just calls LoadString and MessageBox
//
int WINAPI DeskShellMessageBox(HINSTANCE hAppInst, HWND hWnd, LPCTSTR lpcText, LPCTSTR lpcTitle, UINT fuStyle)
{
    TCHAR    achText[CCH_MAX_STRING];
    TCHAR    achTitle[CCH_MAX_STRING];

    if (HIWORD(lpcText) == 0)
    {
        LoadString(hAppInst, LOWORD(lpcText), achText, ARRAYSIZE(achText));
        lpcText = (LPCTSTR)achText;
    }

    if (HIWORD(lpcTitle) == 0)
    {
        if (LOWORD(lpcTitle) == 0)
            GetWindowText(hWnd, achTitle, ARRAYSIZE(achTitle));
        else
            LoadString(hAppInst, LOWORD(lpcTitle), achTitle, ARRAYSIZE(achTitle));

        lpcTitle = (LPCTSTR)achTitle;
    }

    return MessageBox(hWnd, lpcText, lpcTitle, fuStyle);
}


HRESULT CAdvAppearancePage::_InitColorAndPalette(void)
{
    m_bPalette = FALSE;
    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        m_bPalette = GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE;
        ReleaseDC(NULL, hdc);
    }

    DWORD pal[21];
    HPALETTE hpal = (HPALETTE) GetStockObject(DEFAULT_PALETTE);

    pal[1]  = RGB(255, 255, 255);
    pal[2]  = RGB(0,   0,   0  );
    pal[3]  = RGB(192, 192, 192);
    pal[4]  = RGB(128, 128, 128);
    pal[5]  = RGB(255, 0,   0  );
    pal[6]  = RGB(128, 0,   0  );
    pal[7]  = RGB(255, 255, 0  );
    pal[8]  = RGB(128, 128, 0  );
    pal[9]  = RGB(0  , 255, 0  );
    pal[10] = RGB(0  , 128, 0  );
    pal[11] = RGB(0  , 255, 255);
    pal[12] = RGB(0  , 128, 128);
    pal[13] = RGB(0  , 0,   255);
    pal[14] = RGB(0  , 0,   128);
    pal[15] = RGB(255, 0,   255);
    pal[16] = RGB(128, 0,   128);

    if (GetPaletteEntries(hpal, 11, 1, (LPPALETTEENTRY)&pal[17]))
    {
        pal[0]  = MAKELONG(0x300, 17);
        m_hpalVGA = CreatePalette((LPLOGPALETTE)pal);

        // get magic colors
        if (GetPaletteEntries(hpal, 8,  4, (LPPALETTEENTRY)&pal[17]))
        {
            pal[0]  = MAKELONG(0x300, 20);
            m_hpal3D = CreatePalette((LPLOGPALETTE)pal);
        }
    }

    return S_OK;
}


// get all of the interesting system information and put it in the tables
HRESULT CAdvAppearancePage::_InitSysStuff(void)
{
    int nIndex;

    _InitColorAndPalette();

    // clean out the memory
    for (nIndex = 0; nIndex < ARRAYSIZE(m_fonts); nIndex++)
    {
        m_fonts[nIndex].hfont = NULL;
    }

    // build all the brushes/fonts we need
    _RebuildSysStuff(TRUE);

    // Get the current System and User charsets based on locales and UI languages.
    _InitUniqueCharsetArray();

    return S_OK;
}

/*
** clean up any mess made in maintaining system information
** also, write out any global changes in our setup.
*/
void CAdvAppearancePage::_DestroySysStuff(void)
{
    int i;
    HKEY hkAppear;

    SelectObject(g_hdcMem, GetStockObject(BLACK_BRUSH));
    SelectObject(g_hdcMem, GetStockObject(SYSTEM_FONT));

    _FreeFonts();
    for (i = 0; i < COLOR_MAX; i++)
    {
        if (m_brushes[i])
        {
            DeleteObject(m_brushes[i]);
            m_brushes[i] = NULL;
        }
    }

    m_hbrGradientColor = m_hbrMainColor = m_hbrTextColor = NULL;
    // save out possible changes to custom color table
    if (RegOpenKey(HKEY_CURRENT_USER, REGSTR_PATH_APPEARANCE, &hkAppear) == ERROR_SUCCESS)
    {
        RegSetValueEx(hkAppear, REGSTR_VAL_CUSTOMCOLORS, 0L, REG_BINARY,
                                (LPBYTE)g_CustomColors, sizeof(g_CustomColors));
        RegCloseKey(hkAppear);
    }

    // reset these so they init properly
    m_iCurElement = CURRENT_ELEMENT_NONE;
    m_iPrevSize = SIZE_NONE;
    m_bPalette = FALSE;
    m_fInUserEditMode = FALSE;
}



//------------------------ mini font picker controls --------------------------
// Add a facename/script combination to the font dropdown combo list.
//
// The strings are formatted as "FaceName (ScriptName)"
INT Font_AddNameToList(HWND hwndList, LPTSTR pszFace, LPTSTR pszScript)
{
    // Create temp buffer to hold a face name, a script name, one space
    // two parens and a NUL char.
    // 
    //  i.e.: "Arial (Western)"
#ifdef DEBUG
    TCHAR szFaceAndScript[LF_FACESIZE + LF_FACESIZE + 4];
#endif //DEBUG
    LPTSTR pszDisplayName = pszFace;
    INT iItem;

// We decided not to show the scriptnames; Only facenames will be shown.
// For the purpose of debugging, I leave the script name in debug versions only.
#ifdef DEBUG
    if (NULL != pszScript && TEXT('\0') != *pszScript)
    {
        //
        // Font has a script name.  Append it to the facename in parens.
        // This format string controls the appearance of the font names
        // in the list.  If you change this, you must also change the
        // extraction logic in Font_GetNameFromList().
        //
        wsprintf(szFaceAndScript, TEXT("%s(%s)"), pszFace, pszScript);
    
        pszDisplayName = szFaceAndScript;
    }
#endif //DEBUG

    //
    // Add the display name string to the listbox.
    //
    iItem = (INT)SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM)pszDisplayName);
    if (CB_ERR != iItem)
    {
        //
        // Ensure the drop-down combo list will show the entire string.
        //
        HDC hdc = GetDC(hwndList);
        if (NULL != hdc)
        {
            SIZE sizeItem;
            //
            // Make sure the list's font is selected into the DC before
            // calculating the text extent.
            //
            HFONT hfontList = (HFONT)SendMessage(hwndList, WM_GETFONT, 0, 0);
            HFONT hfontOld  = (HFONT)SelectObject(hdc, hfontList);

            if (GetTextExtentPoint32(hdc, pszDisplayName, lstrlen(pszDisplayName), &sizeItem))
            {
                //
                // Get the current width of the dropped list.
                //
                INT cxList = (int)SendMessage(hwndList, CB_GETDROPPEDWIDTH, 0, 0);
                //
                // We need the length of this string plus two
                // widths of a vertical scroll bar.
                //
                sizeItem.cx += (ClassicGetSystemMetrics(SM_CXVSCROLL) * 2);
                if (sizeItem.cx > cxList)
                {
                    //
                    // List is not wide enough.  Increase the width.
                    //
                    SendMessage(hwndList, CB_SETDROPPEDWIDTH, (WPARAM)sizeItem.cx, 0);
                }
            }
            SelectObject(hdc, hfontOld);
            ReleaseDC(hwndList, hdc);
        }
    }
    return iItem;
}


// Retrieve a font name from the font dropdown combo list.
// Optionally, retrieve the script name string.
BOOL Font_GetNameFromList(
    HWND hwndList,      // HWND of combo.
    INT iItem,          // Index of item in list.
    LPTSTR pszFace,     // Destination for face name.
    INT cchFaceMax,     // Chars in face name buffer.
    LPTSTR pszScript,   // Optional. Can be NULL
    INT cchScriptMax    // Optional. Ignored if pszScript is NULL
    )
{
    BOOL bResult = FALSE;
    TCHAR szItemText[LF_FACESIZE + LF_FACESIZE + 4];

    if (pszScript)
    {
        StrCpyN(pszScript, TEXT(""), cchScriptMax);
    }

    if (CB_ERR != SendMessage(hwndList, CB_GETLBTEXT, (WPARAM)iItem, (LPARAM)szItemText))
    {
        LPTSTR pszEnd, pszParen;                            // Lookahead pointer
        LPCTSTR pszStart = pszEnd = pszParen = szItemText;  // "Start" anchor pointer.

        //
        // Find the left paren.
        //
        for ( ; *pszEnd; pszEnd++) {
             if (TEXT('(') == *pszEnd)
                 pszParen = pszEnd;
        }
        
        if(pszParen > pszStart) //Did we find a parenthis?
            pszEnd = pszParen;  // Then that is the end of the facename.

        if (pszEnd > pszStart)
        {
            // Found it.  Copy face name.
            INT cchCopy = (int)(pszEnd - pszStart) + 1; //Add one for the null terminator
            if (cchCopy > cchFaceMax)
                cchCopy = cchFaceMax;

            lstrcpyn(pszFace, pszStart, cchCopy); //(cchCopy-1) bytes are copies followed by a null
            bResult = TRUE;

            if (*pszEnd && (NULL != pszScript))
            {
                // Caller wants the script part also.
                pszStart = ++pszEnd;
                
                // Find the right paren.
                while(*pszEnd && TEXT(')') != *pszEnd)
                    pszEnd++;

                if (*pszEnd && pszEnd > pszStart)
                {
                    // Found it.  Copy script name.
                    cchCopy = (int)(pszEnd - pszStart) + 1;
                    if (cchCopy > cchScriptMax)
                        cchCopy = cchScriptMax;

                    lstrcpyn(pszScript, pszStart, cchCopy);
                }
            }
        }
    }
    return bResult;
}


// Locate a facename/charset pair in the font list.
INT Font_FindInList(HWND hwndList, LPCTSTR pszFaceName)
{
    INT cItems = (int)SendMessage(hwndList, CB_GETCOUNT, 0, 0);
    INT i;

    for (i = 0; i < cItems; i++)
    {
        // All items in the fontlist have the same charset (SYSTEM_LOCALE_CHARSET).So, no point
        // in checking for the charset.
        //
        // Let's just get the facename and see if it matches.
        TCHAR szFaceName[LF_FACESIZE + 1];
        
        Font_GetNameFromList(hwndList, i, szFaceName, ARRAYSIZE(szFaceName), NULL, 0);

        if (0 == lstrcmpi(szFaceName, pszFaceName))
        {
            //
            // Face name matches.
            //
            return i;
        }
    }

    // No match found.
    return -1;
}


// Determine if a given font should be included in the font list.
// 
// dwType arg is DEVICE_FONTTYPE, RASTER_FONTTYPE, TRUETYPE_FONTTYPE.
//               EXTERNAL_FONTTYPE is a private code.  These are the
//               values returned to the enumproc from GDI.
BOOL Font_IncludeInList(
    LPENUMLOGFONTEX lpelf,
    DWORD dwType
    )
{
    BOOL bResult   = TRUE; // Assume it's OK to include.
    BYTE lfCharSet = lpelf->elfLogFont.lfCharSet;

#define EXTERNAL_FONTTYPE 8

    // Exclusions:
    //
    // 1. Don't display WIFE font for appearance because WIFE fonts are not 
    //    allowed to be any system use font such as menu/caption as it 
    //    realizes the font before WIFE gets initialized. B#5427
    //
    // 2. Exclude SYMBOL fonts.
    //
    // 3. Exclude OEM fonts.
    //
    // 4. Exclude vertical fonts.
    if (EXTERNAL_FONTTYPE & dwType ||
        lfCharSet == SYMBOL_CHARSET ||
        lfCharSet == OEM_CHARSET ||
        TEXT('@') == lpelf->elfLogFont.lfFaceName[0])
    {
        bResult = FALSE;
    }
    return bResult;
}


int CALLBACK Font_EnumNames(LPENUMLOGFONTEX lpelf, LPNEWTEXTMETRIC lpntm, DWORD dwType, LPARAM lData)
{
    ENUMFONTPARAM * pEnumFontParam = (ENUMFONTPARAM *)lData;
    return pEnumFontParam->pThis->_EnumFontNames(lpelf, lpntm, dwType, pEnumFontParam);
}


int CAdvAppearancePage::_EnumFontNames(LPENUMLOGFONTEX lpelf, LPNEWTEXTMETRIC lpntm, DWORD Type, ENUMFONTPARAM * pEnumFontParam)
{
    // Should font be included in the "Font" list?
    if (Font_IncludeInList(lpelf, Type))
    {
        int j;
        LOGFONT lf = lpelf->elfLogFont;             //Make a local copy of the given font
        BYTE    bSysCharset = lf.lfCharSet;         //Preserve the system charset we got.
        BOOL    fSupportsAllCharsets = TRUE;
        
        //The given font supports the system charset; Let's check if it supports the other charsets
        for(j = 1; j < m_iCountCharsets; j++)
        {
            lf.lfCharSet = (BYTE)m_uiUniqueCharsets[j];  //Let's try the next charset in the array.
            if(EnumFontFamiliesEx(pEnumFontParam->hdc, &lf, (FONTENUMPROC)Font_EnumValidCharsets, (LPARAM)0, 0) != 0)
            {
                // EnumFontFamiliesEx would have returned a zero if Font_EnumValidCharsets was called
                // even once. In other words, it returned a non-zero because not even a single font existed
                // that supported the given charset. Therefore, we need to skip this font.
                fSupportsAllCharsets = FALSE;
                break;
            }
        }

        if(fSupportsAllCharsets)
        {
            int i;

            // Yep. Add it to the list.
            i = Font_AddNameToList(pEnumFontParam->hwndFontName, lpelf->elfLogFont.lfFaceName, lpelf->elfScript);
            if (i != CB_ERR)
            {
                // Remember the font type and charset in the itemdata.
                //
                // LOWORD = Type
                // HIWORD = System Charset
                SendMessage(pEnumFontParam->hwndFontName, CB_SETITEMDATA, (WPARAM)i, MAKELPARAM(Type, bSysCharset));
            }
        }
    }
    return 1;
}


void CAdvAppearancePage::_InitFontList(HWND hDlg)
{
    LOGFONT lf;
    ENUMFONTPARAM EnumFontParam;

    // Enumerate all fonts on the system.
    // _EnumFontNames will filter out ones we don't want to show.
    lf.lfFaceName[0] = TEXT('\0') ;
    lf.lfCharSet     = (BYTE)m_uiUniqueCharsets[SYSTEM_LOCALE_CHARSET]; //Use charset from the System Locale.
#ifdef WINDOWS_ME
    lf.lfPitchAndFamily = MONO_FONT;
#else
    lf.lfPitchAndFamily = 0;
#endif
    EnumFontParam.hwndFontName = GetDlgItem(hDlg, IDC_ADVAP_FONTNAME);
    EnumFontParam.hdc = GetDC(NULL);
    EnumFontParam.pThis = this;
    EnumFontFamiliesEx(EnumFontParam.hdc, &lf, (FONTENUMPROC)Font_EnumNames, (LPARAM)&EnumFontParam, 0);

    ReleaseDC(NULL, EnumFontParam.hdc);
}


void Font_AddSize(HWND hwndPoints, int iNewPoint, BOOL bSort)
{
    TCHAR szBuf[10];
    int i, iPoint, count;

    // find the sorted place for this point size
    if (bSort)
    {
        count = (int)SendMessage(hwndPoints, CB_GETCOUNT, 0, 0L);
        for (i=0; i < count; i++)
        {
            iPoint = LOWORD(SendMessage(hwndPoints, CB_GETITEMDATA, (WPARAM)i, 0L));

            // don't add duplicates
            if (iPoint == iNewPoint)
                return;

            // belongs before this one
            if (iPoint > iNewPoint)
                break;
        }
    }
    else
        i = -1;

    wsprintf(szBuf, TEXT("%d"), iNewPoint);
    i = (int)SendMessage(hwndPoints, CB_INSERTSTRING, (WPARAM)i, (LPARAM)szBuf);
    if (i != CB_ERR)
        SendMessage(hwndPoints, CB_SETITEMDATA, (WPARAM)i, (LPARAM)iNewPoint);
}


// enumerate sizes for a non-TrueType font
int CALLBACK Font_EnumSizes(LPENUMLOGFONT lpelf, LPNEWTEXTMETRIC lpntm, int Type, LPARAM lData)
{
    CAdvAppearancePage * pThis = (CAdvAppearancePage *) lData;

    if (pThis)
    {
        return pThis->_EnumSizes(lpelf, lpntm, Type);
    }

    return 1;
}


int CAdvAppearancePage::_EnumSizes(LPENUMLOGFONT lpelf, LPNEWTEXTMETRIC lpntm, int Type)
{
    if (lpntm && _hwnd)
    {
        HWND hwndFontSize = GetDlgItem(_hwnd, IDC_ADVAP_FONTSIZE);

        Font_AddSize(hwndFontSize, _HeightToPoint(lpntm->tmHeight - lpntm->tmInternalLeading), TRUE);
    }

    return 1;
}


// a new element was picked, resulting in needing to set up a new font.
void CAdvAppearancePage::_NewFont(HWND hDlg, int iFont)
{
    int iSel;
    BOOL bBold;

    // find the name in the list and select it
    iSel = Font_FindInList(GetDlgItem(hDlg, IDC_ADVAP_FONTNAME), m_fonts[iFont].lf.lfFaceName);

    SendDlgItemMessage(hDlg, IDC_ADVAP_FONTNAME, CB_SETCURSEL, (WPARAM)iSel, 0L);
    _SelectName(hDlg, iSel);

    Font_SelectSize(hDlg, _HeightToPoint(m_fonts[iFont].lf.lfHeight));

    // REVIEW: should new size (returned above) be set in logfont?
    CheckDlgButton(hDlg, IDC_ADVAP_FONTITAL, m_fonts[iFont].lf.lfItalic);

    if (m_fonts[iFont].lf.lfWeight > FW_MEDIUM)
        bBold = TRUE;
    else
        bBold = FALSE;
    CheckDlgButton(hDlg, IDC_ADVAP_FONTBOLD, bBold);
}


// enable/disable the font selection controls.
// also involves blanking out anything meaningful if disabling.
void Font_EnableControls(HWND hDlg, BOOL bEnable)
{
    if (!bEnable)
    {
        SendDlgItemMessage(hDlg, IDC_ADVAP_FONTNAME, CB_SETCURSEL, (WPARAM)-1, 0L);
        SendDlgItemMessage(hDlg, IDC_ADVAP_FONTSIZE, CB_SETCURSEL, (WPARAM)-1, 0L);
        CheckDlgButton(hDlg, IDC_ADVAP_FONTITAL, 0);
        CheckDlgButton(hDlg, IDC_ADVAP_FONTBOLD, 0);
    }

    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_FONTNAME), bEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_FONTSIZE), bEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_FONTSIZELABEL), bEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_FONTLABEL), bEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_FONTBOLD), bEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_FONTITAL), bEnable);
}
//--------end------------- mini font picker controls --------------------------


void CAdvAppearancePage::_SetColor(HWND hDlg, int id, HBRUSH hbrColor)
{
    HWND hwndItem;
    switch (id)
    {
        case IDC_ADVAP_GRADIENT:
            m_hbrGradientColor = hbrColor;
            break;

        case IDC_ADVAP_MAINCOLOR:
            m_hbrMainColor = hbrColor;
            break;

        case IDC_ADVAP_TEXTCOLOR:
            m_hbrTextColor = hbrColor;
            break;

        default:
            return;

    }

    hwndItem = GetDlgItem(hDlg, id);
    if (hwndItem)
    {
        InvalidateRect(hwndItem, NULL, FALSE);
        UpdateWindow(hwndItem);
    }
}


void CAdvAppearancePage::_DrawDownArrow(HDC hdc, LPRECT lprc, BOOL bDisabled)
{
    HBRUSH hbr;
    int x, y;

    x = lprc->right - m_cxEdgeSM - 5;
    y = lprc->top + ((lprc->bottom - lprc->top)/2 - 1);

    if (bDisabled)
    {
        hbr = GetSysColorBrush(COLOR_3DHILIGHT);
        hbr = (HBRUSH) SelectObject(hdc, hbr);

        x++;
        y++;
        PatBlt(hdc, x, y, 5, 1, PATCOPY);
        PatBlt(hdc, x+1, y+1, 3, 1, PATCOPY);
        PatBlt(hdc, x+2, y+2, 1, 1, PATCOPY);

        SelectObject(hdc, hbr);
        x--;
        y--;
    }
    hbr = GetSysColorBrush(bDisabled ? COLOR_3DSHADOW : COLOR_BTNTEXT);
    hbr = (HBRUSH) SelectObject(hdc, hbr);

    PatBlt(hdc, x, y, 5, 1, PATCOPY);
    PatBlt(hdc, x+1, y+1, 3, 1, PATCOPY);
    PatBlt(hdc, x+2, y+2, 1, 1, PATCOPY);

    SelectObject(hdc, hbr);
    lprc->right = x;
}


// draw the color combobox thing
//
// also, if button was depressed, popup the color picker
//
void CAdvAppearancePage::_DrawButton(HWND hDlg, LPDRAWITEMSTRUCT lpdis)
{
    SIZE thin = { m_cxEdgeSM / 2, m_cyEdgeSM / 2 };
    RECT rc = lpdis->rcItem;
    HDC hdc = lpdis->hDC;
    BOOL bFocus = ((lpdis->itemState & ODS_FOCUS) &&
        !(lpdis->itemState & ODS_DISABLED));

    if (!thin.cx) thin.cx = 1;
    if (!thin.cy) thin.cy = 1;

    if (!m_hTheme)
    {
        if (lpdis->itemState & ODS_SELECTED)
        {
            DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
            OffsetRect(&rc, 1, 1);
        }
        else
        {
            DrawEdge(hdc, &rc, EDGE_RAISED, BF_RECT | BF_ADJUST);
        }

        FillRect(hdc, &rc, GetSysColorBrush(COLOR_3DFACE));
    }
    else
    {
        int iStateId;

        if (lpdis->itemState & ODS_SELECTED)
        {
            iStateId = PBS_PRESSED;
        }
        else if (lpdis->itemState & ODS_HOTLIGHT)
        {
            iStateId = PBS_HOT;
        }
        else if (lpdis->itemState & ODS_DISABLED)
        {
            iStateId = PBS_DISABLED;
        }
        else if (lpdis->itemState & ODS_FOCUS)
        {
            iStateId = PBS_DEFAULTED;
        }
        else
        {
            iStateId = PBS_NORMAL;
        }

        DrawThemeBackground(m_hTheme, hdc, BP_PUSHBUTTON, iStateId, &rc, 0);
        GetThemeBackgroundContentRect(m_hTheme, hdc, BP_PUSHBUTTON, iStateId, &rc, &rc);
    }

    if (bFocus)
    {
        InflateRect(&rc, -thin.cx, -thin.cy);
        DrawFocusRect(hdc, &rc);
        InflateRect(&rc, thin.cx, thin.cy);
    }

    InflateRect(&rc, 1-thin.cx, -m_cyEdgeSM);

    rc.left += m_cxEdgeSM;
    _DrawDownArrow(hdc, &rc, lpdis->itemState & ODS_DISABLED);

    InflateRect(&rc, -thin.cx, 0);
    DrawEdge(hdc, &rc, EDGE_ETCHED, BF_RIGHT);

    rc.right -= ( 2 * m_cxEdgeSM ) + thin.cx;

    // color sample
    if ( !(lpdis->itemState & ODS_DISABLED) )
    {
        HPALETTE hpalOld = NULL;
        HBRUSH hbr = 0;

        switch (lpdis->CtlID)
        {
            case IDC_ADVAP_GRADIENT:
                hbr = m_hbrGradientColor;
                break;

            case IDC_ADVAP_MAINCOLOR:
                hbr = m_hbrMainColor;
                break;

            case IDC_ADVAP_TEXTCOLOR:
                hbr = m_hbrTextColor;
                break;

        }

        FrameRect(hdc, &rc, GetSysColorBrush(COLOR_BTNTEXT));
        InflateRect(&rc, -thin.cx, -thin.cy);

        if (m_hpal3D)
        {
            hpalOld = SelectPalette(hdc, m_hpal3D, FALSE);
            RealizePalette(hdc);
        }

        if (hbr)
        {
            hbr = (HBRUSH) SelectObject(hdc, hbr);
            PatBlt(hdc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, PATCOPY);
            SelectObject(hdc, hbr);
        }
        
        if (hpalOld)
        {
            SelectPalette(hdc, hpalOld, TRUE);
            RealizePalette(hdc);
        }
    }
}


//--------end------------- color stuff --------------------------------------
void LoadCustomColors(void)
{
    HKEY hkSchemes;
    DWORD dwType, dwSize;

    // if no colors are there, initialize to all white
    for (int nIndex = 0; nIndex < ARRAYSIZE(g_CustomColors); nIndex++)
    {
        g_CustomColors[nIndex] = RGB(255, 255, 255);
    }

    // select the current scheme
    if (RegOpenKey(HKEY_CURRENT_USER, REGSTR_PATH_APPEARANCE, &hkSchemes) == ERROR_SUCCESS)
    {
        // also, since this key is already open, get the custom colors
        dwSize = sizeof(g_CustomColors);
        dwType = REG_BINARY;

        // It's okay if this call fails.  We handle the case where the user
        // didn't create custom colors.
        RegQueryValueEx(hkSchemes, REGSTR_VAL_CUSTOMCOLORS, NULL, &dwType, (LPBYTE)g_CustomColors, &dwSize);

        RegCloseKey(hkSchemes);
    }
}


static void RemoveBlanks(LPTSTR lpszString)
{
    LPTSTR lpszPosn;

    /* strip leading blanks */
    lpszPosn = lpszString;
    while(*lpszPosn == TEXT(' ')) {
        lpszPosn++;
    }
    if (lpszPosn != lpszString)
        lstrcpy(lpszString, lpszPosn);

    /* strip trailing blanks */
    if ((lpszPosn=lpszString+lstrlen(lpszString)) != lpszString) {
        lpszPosn = CharPrev(lpszString, lpszPosn);
        while(*lpszPosn == TEXT(' '))
           lpszPosn = CharPrev(lpszString, lpszPosn);
        lpszPosn = CharNext(lpszPosn);
        *lpszPosn = TEXT('\0');
    }

}


HRESULT CAdvAppearancePage::_SelectElement(HWND hDlg, int iElement, DWORD dwFlags)
{
    BOOL bEnable;
    int i;
    BOOL bEnableGradient;
    BOOL bGradient = FALSE;

    if ((iElement == m_iCurElement) && !(dwFlags & LSE_ALWAYS))
    {
        return S_OK;
    }

    ClassicSystemParametersInfo(SPI_GETGRADIENTCAPTIONS, 0, (PVOID)&bGradient, 0);

    m_iCurElement = iElement;

    // if needed, find this element in the combobox and select it
    if (dwFlags & LSE_SETCUR)
    {
        i = (int)SendDlgItemMessage(hDlg, IDC_ADVAP_ELEMENTS, CB_GETCOUNT,0,0L);
        for (i--; i >=0 ; i--)
        {
            // if this is the one that references our element, stop
            if (iElement == (int)LOWORD(SendDlgItemMessage(hDlg, IDC_ADVAP_ELEMENTS, CB_GETITEMDATA, (WPARAM)i, 0L)))
                break;
        }
        SendDlgItemMessage(hDlg, IDC_ADVAP_ELEMENTS, CB_SETCURSEL, (WPARAM)i,0L);
    }

    bEnable = (ELCUR.iMainColor != COLOR_NONE);
    if (bEnable)
        _SetColor(hDlg, IDC_ADVAP_MAINCOLOR, m_brushes[ELCUR.iMainColor]);
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_MAINCOLOR), bEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_COLORLABEL), bEnable);

    bEnableGradient = ((ELCUR.iGradientColor != COLOR_NONE));

    if (bEnableGradient)
        _SetColor(hDlg, IDC_ADVAP_GRADIENT, m_brushes[ELCUR.iGradientColor]);
   
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_GRADIENT), (bEnableGradient && bGradient));
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_GRADIENTLABEL), (bEnableGradient && bGradient));

    bEnable = (ELCUR.iFont != FONT_NONE);
    if (bEnable)
    {
        _NewFont(hDlg, ELCUR.iFont);
    }
    Font_EnableControls(hDlg, bEnable);

    // size may be based on font
    _DoSizeStuff(hDlg, FALSE);

    bEnable = (ELCUR.iSize != SIZE_NONE);
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_MAINSIZE), bEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_SIZEARROWS), bEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_SIZELABEL), bEnable);

    bEnable = (ELCUR.iTextColor != COLOR_NONE);
    if (bEnable)
        _SetColor(hDlg, IDC_ADVAP_TEXTCOLOR, m_brushes[ELCUR.iTextColor]);
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_TEXTCOLOR), bEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_FNCOLORLABEL), bEnable);

    return S_OK;
}


void CAdvAppearancePage::_Repaint(HWND hDlg, BOOL bRecalc)
{
    HWND hwndLookPrev;

    hwndLookPrev = GetDlgItem(hDlg, IDC_ADVAP_LOOKPREV);
    if (bRecalc)
    {
        _SyncSize(hDlg);
        RECT rc;
        GetClientRect(hwndLookPrev, &rc);
        _Recalc(&rc);
    }

    _RepaintPreview(hwndLookPrev);
}


void CAdvAppearancePage::_SetCurSizeAndRange(HWND hDlg)
{
    if (ELCUR.iSize == SIZE_NONE)
        SetDlgItemText(hDlg, IDC_ADVAP_MAINSIZE, TEXT(""));
    else
    {
        SendDlgItemMessage(hDlg, IDC_ADVAP_SIZEARROWS, UDM_SETRANGE, 0,
            MAKELPARAM(m_elCurrentSize.MaxSize, m_elCurrentSize.MinSize));
        SetDlgItemInt(hDlg, IDC_ADVAP_MAINSIZE, m_elCurrentSize.CurSize, TRUE);
    }
}


void CAdvAppearancePage::_SyncSize(HWND hDlg)
{
    if (m_iPrevSize != SIZE_NONE)
        m_sizes[m_iPrevSize].CurSize = m_elCurrentSize.CurSize;

    if (m_iCurElement >= 0)
        m_iPrevSize = ELCUR.iSize;
}


void CAdvAppearancePage::_UpdateSizeBasedOnFont(HWND hDlg, BOOL fComputeIdeal)
{
    if ((ELCUR.iSize != SIZE_NONE) && (ELCUR.iFont != FONT_NONE))
    {
        TEXTMETRIC tm;
        HFONT hfontOld = (HFONT) SelectObject(g_hdcMem, ELCURFONT.hfont);

        GetTextMetrics(g_hdcMem, &tm);
        if (ELCUR.iSize == SIZE_MENU)
        {
            // Include external leading for menus
            tm.tmHeight += tm.tmExternalLeading;
        }

        if (hfontOld)
        {
            SelectObject(g_hdcMem, hfontOld);
        }

        m_elCurrentSize.MinSize = tm.tmHeight + 2 * m_cyBorderSM;
        if (fComputeIdeal)
        {
            if ((ELCUR.iSize == SIZE_CAPTION || ELCUR.iSize == SIZE_MENU) &&
                (m_elCurrentSize.MinSize < (ClassicGetSystemMetrics(SM_CYICON)/2 + 2 * m_cyBorderSM)))
            {
                m_elCurrentSize.CurSize = ClassicGetSystemMetrics(SM_CYICON)/2 + 2 * m_cyBorderSM;
            }
            else        // if (m_elCurrentSize.CurSize < m_elCurrentSize.MinSize)
            {
                m_elCurrentSize.CurSize = m_elCurrentSize.MinSize;
            }
        }
        else if (m_elCurrentSize.CurSize < m_elCurrentSize.MinSize)
        {
            m_elCurrentSize.CurSize = m_elCurrentSize.MinSize;
        }
    }
}


void CAdvAppearancePage::_DoSizeStuff(HWND hDlg, BOOL fCanSuggest)
{
    _SyncSize(hDlg);

    if (ELCUR.iSize != SIZE_NONE)
    {
        m_elCurrentSize = m_sizes[ELCUR.iSize];

        if (ELCUR.fLinkSizeToFont)
        {
            _UpdateSizeBasedOnFont(hDlg, fCanSuggest);
        }

        if (m_elCurrentSize.CurSize < m_elCurrentSize.MinSize)
        {
            m_elCurrentSize.CurSize = m_elCurrentSize.MinSize;
        }
        else if (m_elCurrentSize.CurSize > m_elCurrentSize.MaxSize)
        {
            m_elCurrentSize.CurSize = m_elCurrentSize.MaxSize;
        }
    }

    _SetCurSizeAndRange(hDlg);
}


void CAdvAppearancePage::_RebuildCurFont(HWND hDlg)
{
     if (ELCURFONT.hfont)
        DeleteObject(ELCURFONT.hfont);
    ELCURFONT.hfont = CreateFontIndirect(&ELCURFONT.lf);

    _DoSizeStuff(hDlg, TRUE);
    _Repaint(hDlg, TRUE);
}


void CAdvAppearancePage::_Changed(HWND hDlg, DWORD dwChange)
{
    if (m_fInUserEditMode)
    {
        if ((dwChange != SCHEME_CHANGE) && (dwChange != DPI_CHANGE))
        {
            // We keep track if we have customized settings from the stock Scheme.
            m_fModifiedScheme = TRUE;
        }
        else
        {
            dwChange = METRIC_CHANGE | COLOR_CHANGE;
        }

        m_dwChanged |= dwChange;
    }
}


void CAdvAppearancePage::_ChangeFontName(HWND hDlg, LPCTSTR szBuf, INT iCharSet)
{
    if (lstrcmpi(ELCURFONT.lf.lfFaceName, szBuf) == 0 &&
        ELCURFONT.lf.lfCharSet == iCharSet)
    {
        return;
    }

    lstrcpy(ELCURFONT.lf.lfFaceName, szBuf);
    ELCURFONT.lf.lfCharSet = (BYTE)iCharSet;

    _RebuildCurFont(hDlg);
    _Changed(hDlg, METRIC_CHANGE);
}


void CAdvAppearancePage::_ChangeFontSize(HWND hDlg, int Points)
{
    if (ELCURFONT.lf.lfHeight != _PointToHeight(Points))
    {
        ELCURFONT.lf.lfHeight = _PointToHeight(Points);
        _RebuildCurFont(hDlg);
        _Changed(hDlg, METRIC_CHANGE);
    }
}


void CAdvAppearancePage::_ChangeFontBI(HWND hDlg, int id, BOOL bCheck)
{
    if (id == IDC_ADVAP_FONTBOLD) // bold
    {
        if (bCheck)
            ELCURFONT.lf.lfWeight = FW_BOLD;
        else
            ELCURFONT.lf.lfWeight = FW_NORMAL;
    }
    else   // italic
    {
        ELCURFONT.lf.lfItalic = (BYTE)bCheck;
    }

    _RebuildCurFont(hDlg);
    _Changed(hDlg, METRIC_CHANGE);
}


void CAdvAppearancePage::_ChangeSize(HWND hDlg, int NewSize, BOOL bRepaint)
{
    if (m_elCurrentSize.CurSize != NewSize)
    {
        m_elCurrentSize.CurSize = NewSize;
        if (bRepaint)
        {
            _Repaint(hDlg, TRUE);
        }

        _Changed(hDlg, METRIC_CHANGE);
    }
}


BOOL CAdvAppearancePage::_ChangeColor(HWND hDlg, int iColor, COLORREF rgb)
{
    COLORREF rgbShadow, rgbHilight, rgbWatermark;

    if ((rgb & 0x00FFFFFF) == (m_rgb[iColor] & 0x00FFFFFF))
        return FALSE;

    if (iColor == COLOR_3DFACE)
    {
        rgbShadow    = AdjustLuma(rgb, m_i3DShadowAdj,  m_fScale3DShadowAdj);
        rgbHilight   = AdjustLuma(rgb, m_i3DHilightAdj, m_fScale3DHilightAdj);
        rgbWatermark = AdjustLuma(rgb, m_iWatermarkAdj, m_fScaleWatermarkAdj);


        _Set3DPaletteColor(rgb, COLOR_3DFACE);
        _Set3DPaletteColor(rgbShadow, COLOR_3DSHADOW);
        _Set3DPaletteColor(rgbHilight, COLOR_3DHILIGHT);

        // update colors tagged to 3DFACE
        m_rgb[COLOR_3DFACE] = rgb;
        m_rgb[COLOR_3DLIGHT] =  rgb; // BOGUS TEMPORARY
        m_rgb[COLOR_ACTIVEBORDER] =  rgb;
        m_rgb[COLOR_INACTIVEBORDER] =  rgb;
        m_rgb[COLOR_MENU] =  rgb;

        // update colors tagged to 3DSHADOW
        m_rgb[COLOR_GRAYTEXT] = rgbShadow;
        m_rgb[COLOR_APPWORKSPACE] = rgbShadow;
        m_rgb[COLOR_3DSHADOW] = rgbShadow;
        m_rgb[COLOR_INACTIVECAPTION] = rgbShadow;

        // update colors tagged to 3DHIGHLIGHT
        m_rgb[COLOR_3DHILIGHT] = rgbHilight;
        m_rgb[COLOR_SCROLLBAR] = rgbHilight;

        if ((m_rgb[COLOR_SCROLLBAR] & 0x00FFFFFF) ==
            (m_rgb[COLOR_WINDOW] & 0x00FFFFFF))
        {
            m_rgb[COLOR_SCROLLBAR] = RGB( 192, 192, 192 );
        }
    }
    else
    {
        m_rgb[iColor] = rgb;
    }

    _RebuildSysStuff(FALSE);
    _Changed(hDlg, COLOR_CHANGE);
    return TRUE;
}


void CAdvAppearancePage::_PropagateMessage(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    HWND hwndChild;

    // Don't propagate during exit since this is only for good looks, and the Up/Down's
    // get confused if they get a WM_SETTINGSHCANGED while they are getting destroyed
    if (m_fProprtySheetExiting)
        return;

    for (hwndChild = ::GetWindow(hwnd, GW_CHILD); hwndChild != NULL;
        hwndChild = ::GetWindow(hwndChild, GW_HWNDNEXT))
    {
#ifdef DBG_PRINT
        TCHAR szTmp[256];
        GetClassName(hwndChild, szTmp, 256);

        TraceMsg(TF_GENERAL, "desk (PropagateMessage): SendingMessage( 0x%08lX cls:%s, 0x%08X, 0x%08lX, 0x%08lX )\n", hwndChild, szTmp, uMessage, wParam, lParam ));
#endif
        SendMessage(hwndChild, uMessage, wParam, lParam);
        TraceMsg(TF_GENERAL,"desk (PropagateMessage): back from SendingMessage\n");
    }
}


void CAdvAppearancePage::_UpdateGradientButton(HWND hDlg)
{
    BOOL bEnableGradient = FALSE;
    BOOL bGradient = FALSE;

    ClassicSystemParametersInfo(SPI_GETGRADIENTCAPTIONS, 0, (PVOID)&bGradient, 0);

    if (m_iCurElement >= 0)
    {
        bEnableGradient = ((ELCUR.iGradientColor != COLOR_NONE));
    }

    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_GRADIENT), (bEnableGradient && bGradient));
    EnableWindow(GetDlgItem(hDlg, IDC_ADVAP_GRADIENTLABEL), (bEnableGradient && bGradient));
}


//--------end------------- manage system settings --------------------------




// Fill in a NONCLIENTMETRICS structure with latest preview stuff
void CAdvAppearancePage::_GetMyNonClientMetrics(LPNONCLIENTMETRICS lpncm)
{
    lpncm->iBorderWidth = (LONG)m_sizes[SIZE_FRAME].CurSize;
    lpncm->iScrollWidth = lpncm->iScrollHeight = (LONG)m_sizes[SIZE_SCROLL].CurSize;
    lpncm->iSmCaptionWidth = lpncm->iSmCaptionHeight = (LONG)m_sizes[SIZE_SMCAPTION].CurSize;
    lpncm->iMenuWidth = lpncm->iMenuHeight = (LONG)m_sizes[SIZE_MENU].CurSize;

    // #355378: 
    // PRE-WHISTLER: Caption Height always matched Width.  They were authored this way and
    // the UI forced them to be the same.  I don't know if apps rely on this behavior but they
    // could have.  The Status Bar icon is equal to the min(CaptionWidth, CaptionHeight).
    // The user really wants their caption buttons to be square, so that also wants
    // them to be equal.  A caption width of 18 makes the icon be 16, anything else causes
    // icon stretch and looks really bad.
    // 
    // WHISTLER: In Whistler, our designers want a height of 25 so it looks nicer.  They
    // want the width to remain 18 so the icon is 16 pixels (inctlpan.c) in each direction.  This means that
    // this code can no longer force them to be even.  ScottHan forces the captionbar buttons to
    // be square solving that problem.  I will now keep the aspect ratio so I scale them correctly.
    // If we are close, I will snap to 18 to fix rounding errors.
    lpncm->iCaptionHeight = (LONG)m_sizes[SIZE_CAPTION].CurSize;
    lpncm->iCaptionWidth = (int) (m_fCaptionRatio * lpncm->iCaptionHeight);

    // Don't shrink the caption width below 18 point until the caption height also gets below 18.
    if (lpncm->iCaptionWidth < 18 && lpncm->iCaptionHeight >= 18)
    {
        lpncm->iCaptionWidth = 18;
    }

    if ((lpncm->iCaptionWidth <= 19) && (lpncm->iCaptionWidth >= 17) &&
        (1.0f != m_fCaptionRatio))
    {
        // Icons only really look good at 16 pixels, so we need to set lpncm->iCaptionWidth to make the
        // Caption bar icon 16 pixels. (#355378)
        lpncm->iCaptionWidth = 18;
    }

    LFtoLF32(&(m_fonts[FONT_CAPTION].lf), &(lpncm->lfCaptionFont));
    LFtoLF32(&(m_fonts[FONT_SMCAPTION].lf), &(lpncm->lfSmCaptionFont));
    LFtoLF32(&(m_fonts[FONT_MENU].lf), &(lpncm->lfMenuFont));
    LFtoLF32(&(m_fonts[FONT_STATUS].lf), &(lpncm->lfStatusFont));
    LFtoLF32(&(m_fonts[FONT_MSGBOX].lf), &(lpncm->lfMessageFont));
}


// given a NONCLIENTMETRICS structure, make it preview's current setting
void CAdvAppearancePage::_SetMyNonClientMetrics(const LPNONCLIENTMETRICS lpncm)
{
    m_sizes[SIZE_FRAME].CurSize = (int)lpncm->iBorderWidth;
    m_sizes[SIZE_SCROLL].CurSize = (int)lpncm->iScrollWidth;
    m_sizes[SIZE_SMCAPTION].CurSize = (int)lpncm->iSmCaptionHeight;
    m_sizes[SIZE_MENU].CurSize = (int)lpncm->iMenuHeight;

    m_sizes[SIZE_CAPTION].CurSize = (int)lpncm->iCaptionHeight;
    m_fCaptionRatio = ((float) lpncm->iCaptionWidth / (float) lpncm->iCaptionHeight);

    LF32toLF(&(lpncm->lfCaptionFont), &(m_fonts[FONT_CAPTION].lf));
    LF32toLF(&(lpncm->lfSmCaptionFont), &(m_fonts[FONT_SMCAPTION].lf));
    LF32toLF(&(lpncm->lfMenuFont), &(m_fonts[FONT_MENU].lf));
    LF32toLF(&(lpncm->lfStatusFont), &(m_fonts[FONT_STATUS].lf));
    LF32toLF(&(lpncm->lfMessageFont), &(m_fonts[FONT_MSGBOX].lf));
}

//--------end------------- scheme stuff --------------------------------------


HRESULT CAdvAppearancePage::_IsDirty(IN BOOL * pIsDirty)
{
    HRESULT hr = E_INVALIDARG;

    if (pIsDirty)
    {
        *pIsDirty = (NO_CHANGE != m_dwChanged);
        hr = S_OK;
    }

    return hr;
}





//===========================
// *** IAdvancedDialog Interface ***
//===========================
HRESULT CAdvAppearancePage::DisplayAdvancedDialog(IN HWND hwndParent, IN IPropertyBag * pBasePage, IN BOOL * pfEnableApply)
{
    HRESULT hr = E_INVALIDARG;

    if (hwndParent && pBasePage && pfEnableApply)
    {
        // Load State Into Advanced Dialog 
        ATOMICRELEASE(g_pAdvAppearancePage);
        g_pAdvAppearancePage = this;
        AddRef();
        *pfEnableApply = FALSE;

        if (FAILED(SHPropertyBag_ReadInt(pBasePage, SZ_PBPROP_DPI_MODIFIED_VALUE, &m_nCachedNewDPI)))
        {
            m_nCachedNewDPI = DPI_PERSISTED;    // Default to the default DPI.
        }

        // Display Advanced Dialog
        if (IDOK == DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_APPEARANCE_ADVANCEDPG), hwndParent, CAdvAppearancePage::AdvAppearDlgProc, (LPARAM)this))
        {
            // The user clicked OK, so merge modified state back into base dialog
            _IsDirty(pfEnableApply);

            // The user clicked Okay in the dialog so merge the dirty state from the
            // advanced dialog into the base dialog.
            int nIndex;
            SYSTEMMETRICSALL state = {0};

            state.dwChanged = m_dwChanged;
            state.schemeData.version = SCHEME_VERSION;
            state.schemeData.wDummy = 0;
            state.schemeData.ncm.cbSize = sizeof(state.schemeData.ncm);

            for (nIndex = 0; nIndex < ARRAYSIZE(m_rgb); nIndex++)
            {
                state.schemeData.rgb[nIndex] = m_rgb[nIndex];
            }

            _GetMyNonClientMetrics(&state.schemeData.ncm);

            // Set Sizes
            state.nDXIcon = m_sizes[SIZE_DXICON].CurSize;
            state.nDYIcon = m_sizes[SIZE_DYICON].CurSize;
            state.nIcon = m_sizes[SIZE_ICON].CurSize;
            state.nSmallIcon = m_sizes[SIZE_SMICON].CurSize;
            state.fModifiedScheme = m_fModifiedScheme;

            // Set Fonts
            state.schemeData.lfIconTitle = m_fonts[FONT_ICONTITLE].lf;

            VARIANT var = {0};
            hr = pBasePage->Read(SZ_PBPROP_SYSTEM_METRICS, &var, NULL);
            if (SUCCEEDED(hr) && (VT_BYREF == var.vt) && var.byref)
            {
                SYSTEMMETRICSALL * pCurrent = (SYSTEMMETRICSALL *) var.byref;
                state.fFlatMenus = pCurrent->fFlatMenus;        // Maintain this value.
                state.fHighContrast = pCurrent->fHighContrast;        // Maintain this value.
            }

            hr = SHPropertyBag_WriteByRef(pBasePage, SZ_PBPROP_SYSTEM_METRICS, (void *)&state);
        }

        ATOMICRELEASE(g_pAdvAppearancePage);
    }

    return hr;
}




//===========================
// *** IUnknown Interface ***
//===========================
ULONG CAdvAppearancePage::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CAdvAppearancePage::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CAdvAppearancePage::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CAdvAppearancePage, IPersist),
        QITABENT(CAdvAppearancePage, IObjectWithSite),
        QITABENT(CAdvAppearancePage, IAdvancedDialog),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}



int g_nSizeInitArray[9][3] = 
{
    {0, 0, 50},         // SIZE_FRAME
    {0, 8, 100},        // SIZE_SCROLL
    {0, 8, 100},        // SIZE_CAPTION
    {0, 4, 100},        // SIZE_SMCAPTION
    {0, 8, 100},        // SIZE_MENU
    {0, 0, 150},        // SIZE_DXICON - x spacing
    {0, 0, 150},        // SIZE_DYICON - y spacing
    {0, 16, 72},        // SIZE_ICON - shell icon size
    {0, 8, 36},
};

//===========================
// *** Class Methods ***
//===========================
CAdvAppearancePage::CAdvAppearancePage(IN const SYSTEMMETRICSALL * pState) : CObjectCLSID(&PPID_AdvAppearance), m_cRef(1)
{
    int nIndex;
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_hpal3D);
    ASSERT(!m_hpalVGA);
    ASSERT(!m_hbrMainColor);
    ASSERT(!m_hbrTextColor);
    ASSERT(!m_hbrGradientColor);

    m_dwChanged = NO_CHANGE;
    m_iCurElement = CURRENT_ELEMENT_NONE;         // start off as not even "not set"
    m_iPrevSize = SIZE_NONE;

    m_bPalette = FALSE;
    m_fInUserEditMode = FALSE;
    m_fProprtySheetExiting = FALSE;

    m_i3DShadowAdj = -333;
    m_i3DHilightAdj = 500;
    m_iWatermarkAdj = -50;

    m_fScale3DShadowAdj  = TRUE;
    m_fScale3DHilightAdj = TRUE;
    m_fScaleWatermarkAdj = TRUE;

    m_hTheme = NULL;

    m_iCountCharsets = 0;
    for (nIndex = 0; nIndex < ARRAYSIZE(m_uiUniqueCharsets); nIndex++)
    {
        m_uiUniqueCharsets[nIndex] = DEFAULT_CHARSET;
    }

    for (int nIndex1 = 0; nIndex1 < ARRAYSIZE(g_nSizeInitArray); nIndex1++)
    {
        m_sizes[nIndex1].CurSize = g_nSizeInitArray[nIndex1][0];
        m_sizes[nIndex1].MinSize = g_nSizeInitArray[nIndex1][1];
        m_sizes[nIndex1].MaxSize = g_nSizeInitArray[nIndex1][2];
    }

    CreateGlobals();

    _LoadState(pState);
}


CAdvAppearancePage::~CAdvAppearancePage()
{
    if (m_hpal3D)
    {
        DeleteObject(m_hpal3D);
        m_hpal3D = NULL;
    }

    if (m_hpalVGA)
    {
        DeleteObject(m_hpalVGA);
        m_hpalVGA = NULL;
    }

    if (g_hdcMem)
    {
        DeleteDC(g_hdcMem);
        g_hdcMem = NULL;
    }

    DllRelease();
}




HRESULT CAdvAppearancePage_CreateInstance(OUT IAdvancedDialog ** ppAdvDialog, IN const SYSTEMMETRICSALL * pState)
{
    HRESULT hr = E_INVALIDARG;

    if (ppAdvDialog)
    {
        CAdvAppearancePage * ptsp = new CAdvAppearancePage(pState);

        if (ptsp)
        {
            hr = ptsp->QueryInterface(IID_PPV_ARG(IAdvancedDialog, ppAdvDialog));
            ptsp->Release();
        }
        else
        {
            *ppAdvDialog = NULL;
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\appscheme.h ===
/*****************************************************************************\
    FILE: appScheme.h

    DESCRIPTION:
        This is the Autmation Object to theme scheme object.

    BryanSt 4/3/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _FILE_H_APPSCHEME
#define _FILE_H_APPSCHEME

#include <cowsite.h>
#include <atlbase.h>


static const GUID CLSID_LegacyAppearanceScheme = { 0xb41910f6, 0xab9f, 0x4768, { 0x94, 0x5c, 0x3c, 0x42, 0x37, 0xf2, 0xe2, 0x5c } };// {B41910F6-AB9F-4768-945C-3C4237F2E25C}
HRESULT CAppearanceScheme_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);

HRESULT LoadConversionMappings(void);
HRESULT MapLegacyAppearanceSchemeToIndex(LPCTSTR pszOldSchemeName, int * pnIndex);

typedef struct
{
    TCHAR szLegacyName[MAX_PATH];
    TCHAR szNewColorSchemeName[MAX_PATH];
    TCHAR szNewSizeName[MAX_PATH];
    enumThemeContrastLevels ContrastLevel;
} APPEARANCESCHEME_UPGRADE_MAPPINGS;

extern APPEARANCESCHEME_UPGRADE_MAPPINGS g_UpgradeMapping[MAX_LEGACY_UPGRADE_SCENARIOS];


class CAppearanceScheme         : public CImpIDispatch
                                , public CObjectCLSID
                                , public IThemeScheme
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IThemeScheme ***
    virtual STDMETHODIMP get_DisplayName(OUT BSTR * pbstrDisplayName);
    virtual STDMETHODIMP put_DisplayName(IN BSTR bstrDisplayName) {return E_NOTIMPL;}
    virtual STDMETHODIMP get_Path(OUT BSTR * pbstrPath) { if (pbstrPath) {*pbstrPath = NULL;} return E_NOTIMPL;}
    virtual STDMETHODIMP put_Path(IN BSTR bstrPath) {return E_NOTIMPL;}
    virtual STDMETHODIMP get_length(OUT long * pnLength);
    virtual STDMETHODIMP get_item(IN VARIANT varIndex, OUT IThemeStyle ** ppThemeStyle);
    virtual STDMETHODIMP get_SelectedStyle(OUT IThemeStyle ** ppThemeStyle);
    virtual STDMETHODIMP put_SelectedStyle(IN IThemeStyle * pThemeStyle);
    virtual STDMETHODIMP AddStyle(OUT IThemeStyle ** ppThemeStyle) {return _AddStyle(NULL, ppThemeStyle);};

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

private:
    CAppearanceScheme(void);
    virtual ~CAppearanceScheme(void);


    // Private Member Variables
    long                    m_cRef;

    HKEY                    m_hKeyScheme;

    // Private Member Functions
    HRESULT _InitReg(void);
    HRESULT _ConvertScheme(LPCTSTR pszLegacyName, LPCTSTR pszStyleName, LPCTSTR pszSizeName, SYSTEMMETRICSALL * pState, IN enumThemeContrastLevels ContrastLevel, IN BOOL fSetAsDefault, IN BOOL fSetRegKeyTitle);
    HRESULT _LoadConversionMappings(void);
    HRESULT _CustomConvert(LPCTSTR pszSchemeName, SYSTEMMETRICSALL * pState, IN BOOL fSetAsDefault, IN BOOL fSetRegKeyTitle);
    HRESULT _IsLegacyUpgradeConvert(LPCTSTR pszSchemeName, SYSTEMMETRICSALL * pState, IN BOOL fSetAsDefault);
    HRESULT _getStyleByIndex(IN long nIndex, OUT IThemeStyle ** ppThemeStyle);
    HRESULT _getCurrentSettings(IN LPCWSTR pszSettings, OUT IThemeStyle ** ppThemeStyle);
    HRESULT _AddStyle(IN LPCWSTR pszTitle, OUT IThemeStyle ** ppThemeStyle);

    HRESULT _getIndex(IN IThemeStyle * pThemeStyle, IN BSTR bstrStyleDisplayName, IN long * pnStyleIndex, IN IThemeSize * pThemeSize, IN BSTR bstrSizeDisplayName, IN long * pnSizeIndex);
    HRESULT _getSizeIndex(IN IThemeStyle * pThemeStyle, IN IThemeSize * pThemeSize, IN BSTR bstrSizeDisplayName, IN long * pnSizeIndex);

    // Friend Functions
    friend HRESULT CAppearanceScheme_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);
};


#endif // _FILE_H_APPSCHEME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\appsize.cpp ===
/*****************************************************************************\
    FILE: appSize.cpp

    DESCRIPTION:
        This is the Autmation Object to theme scheme object.

    BryanSt 4/3/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <cowsite.h>
#include <atlbase.h>
#include "util.h"
#include "theme.h"
#include "appsize.h"
#include "stgtheme.h"




//===========================
// *** Class Internals & Helpers ***
//===========================


//===========================
// *** IThemeSize Interface ***
//===========================
HRESULT CAppearanceSize::get_DisplayName(OUT BSTR * pbstrDisplayName)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrDisplayName)
    {
        CComBSTR bstrDisplayName;

        *pbstrDisplayName = NULL;
        hr = HrBStrRegQueryValue(m_hkeySize, SZ_REGVALUE_DISPLAYNAME, &bstrDisplayName);
        if (SUCCEEDED(hr))
        {
            WCHAR szDisplayName[MAX_PATH];
            if (SUCCEEDED(SHLoadIndirectString(bstrDisplayName, szDisplayName, ARRAYSIZE(szDisplayName), NULL)))
            {
                hr = HrSysAllocStringW(szDisplayName, pbstrDisplayName);
            }
            else
            {
                hr = HrSysAllocStringW(bstrDisplayName, pbstrDisplayName);
            }
        }
    }


    return hr;
}


HRESULT CAppearanceSize::put_DisplayName(IN BSTR bstrDisplayName)
{
    return HrRegSetValueString(m_hkeySize, NULL, SZ_REGVALUE_DISPLAYNAME, bstrDisplayName);
}


HRESULT CAppearanceSize::get_Name(OUT BSTR * pbstrName)
{
    return HrBStrRegQueryValue(m_hkeySize, SZ_REGVALUE_DISPLAYNAME, pbstrName);
}


HRESULT CAppearanceSize::put_Name(IN BSTR bstrName)
{
    return HrRegSetValueString(m_hkeySize, NULL, SZ_REGVALUE_DISPLAYNAME, bstrName);
}


HRESULT CAppearanceSize::get_SystemMetricColor(IN int nSysColorIndex, OUT COLORREF * pColorRef)
{
    HRESULT hr = E_INVALIDARG;

    if (pColorRef)
    {
        TCHAR szFontRegValue[MAXIMUM_SUB_KEY_LENGTH];
        DWORD dwType;
        DWORD cbSize = sizeof(*pColorRef);

        wnsprintf(szFontRegValue, ARRAYSIZE(szFontRegValue), TEXT("Color #%d"), nSysColorIndex);
        hr = HrRegQueryValueEx(m_hkeySize, szFontRegValue, 0, &dwType, (BYTE *)pColorRef, &cbSize);
        if (SUCCEEDED(hr))
        {
            if (cbSize != sizeof(*pColorRef))
            {
                hr = E_FAIL;
            }
        }
    }

    return hr;
}


HRESULT CAppearanceSize::put_SystemMetricColor(IN int nSysColorIndex, IN COLORREF ColorRef)
{
    HRESULT hr = E_INVALIDARG;

    TCHAR szFontRegValue[MAXIMUM_SUB_KEY_LENGTH];

    wnsprintf(szFontRegValue, ARRAYSIZE(szFontRegValue), TEXT("Color #%d"), nSysColorIndex);
    hr = HrRegSetValueEx(m_hkeySize, szFontRegValue, 0, REG_DWORD, (BYTE *)&ColorRef, sizeof(ColorRef));

    return hr;
}


HRESULT CAppearanceSize::GetSystemMetricFont(IN enumSystemMetricFont nFontIndex, IN LOGFONTW * pLogFontW)
{
    HRESULT hr = E_INVALIDARG;

    if (pLogFontW)
    {
        TCHAR szFontRegValue[MAXIMUM_SUB_KEY_LENGTH];
        DWORD dwType;
        DWORD cbSize = sizeof(*pLogFontW);

        wnsprintf(szFontRegValue, ARRAYSIZE(szFontRegValue), TEXT("Font #%d"), nFontIndex);
        hr = HrRegQueryValueEx(m_hkeySize, szFontRegValue, 0, &dwType, (BYTE *)pLogFontW, &cbSize);
        if (SUCCEEDED(hr))
        {
            if (cbSize != sizeof(*pLogFontW))
            {
                hr = E_FAIL;
            }
            else
            {
                // CHARSET: In Win2k, fontfix.cpp was used as a hack to change the CHARSET from one language to another.
                // That doesn't work for many reasons: a) not called on roaming, b) not called for OS lang changes, 
                // c) won't fix the problem for strings with multiple languages, d) etc.
                // Therefore, the SHELL team (BryanSt) had the NTUSER team (MSadek) agree to use DEFAULT_CHARSET all the time.
                // If some app has bad logic testing the charset parameter, then the NTUSER team will shim that app to fix it.
                // The shim would be really simple, on the return from a SystemParametersInfo(SPI_GETNONCLIENTMETRICS or ICONFONTS)
                // just patch the lfCharSet param to the current charset.

                // For all CHARSETs to DEFAULT_CHARSET
                pLogFontW->lfCharSet = DEFAULT_CHARSET;
            }
        }
    }

    return hr;
}


HRESULT CAppearanceSize::PutSystemMetricFont(IN enumSystemMetricFont nFontIndex, IN LOGFONTW * pLogFontW)
{
    HRESULT hr = E_INVALIDARG;

    if (pLogFontW)
    {
        TCHAR szFontRegValue[MAXIMUM_SUB_KEY_LENGTH];

        wnsprintf(szFontRegValue, ARRAYSIZE(szFontRegValue), TEXT("Font #%d"), nFontIndex);
        hr = HrRegSetValueEx(m_hkeySize, szFontRegValue, 0, REG_BINARY, (BYTE *)pLogFontW, sizeof(*pLogFontW));
    }

    return hr;
}


HRESULT CAppearanceSize::get_SystemMetricSize(IN enumSystemMetricSize nSystemMetricIndex, OUT int * pnSize)
{
    HRESULT hr = E_INVALIDARG;

    if (pnSize)
    {
        TCHAR szFontRegValue[MAXIMUM_SUB_KEY_LENGTH];
        DWORD dwType;
        INT64 nSize64;
        DWORD cbSize = sizeof(nSize64);

        *pnSize = 0;
        wnsprintf(szFontRegValue, ARRAYSIZE(szFontRegValue), TEXT("Size #%d"), nSystemMetricIndex);
        hr = HrRegQueryValueEx(m_hkeySize, szFontRegValue, 0, &dwType, (BYTE *)&nSize64, &cbSize);
        if (SUCCEEDED(hr))
        {
            if (cbSize != sizeof(nSize64))
            {
                hr = E_FAIL;
            }
            else
            {
                *pnSize = (int)nSize64;
            }
        }
    }

    return hr;
}


HRESULT CAppearanceSize::put_SystemMetricSize(IN enumSystemMetricSize nSystemMetricIndex, IN int nSize)
{
    HRESULT hr = E_INVALIDARG;
    TCHAR szFontRegValue[MAXIMUM_SUB_KEY_LENGTH];
    INT64 nSize64 = (INT64)nSize;

    wnsprintf(szFontRegValue, ARRAYSIZE(szFontRegValue), TEXT("Size #%d"), nSystemMetricIndex);
    hr = HrRegSetValueEx(m_hkeySize, szFontRegValue, 0, REG_QWORD, (BYTE *)&nSize64, sizeof(nSize64));

    return hr;
}


#define SZ_WEBVW_NOSKIN_NORMAL_DIR           L"NormalContrast"
#define SZ_WEBVW_NOSKIN_HIBLACK_DIR          L"HighContrastBlack"
#define SZ_WEBVW_NOSKIN_HIWHITE_DIR          L"HighContrastWhite"
#define SZ_DIR_RESOURCES_THEMES              L"Themes"

HRESULT CAppearanceSize::get_WebviewCSS(OUT BSTR * pbstrPath)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrPath)
    {
        WCHAR szPath[MAX_PATH];

        *pbstrPath = NULL;
        hr = SHGetResourcePath(TRUE, szPath, ARRAYSIZE(szPath));
        if (SUCCEEDED(hr))
        {
            PathAppend(szPath, SZ_DIR_RESOURCES_THEMES);

            enumThemeContrastLevels ContrastLevel = CONTRAST_NORMAL;
            get_ContrastLevel(&ContrastLevel);

            switch (ContrastLevel)
            {
            case CONTRAST_HIGHBLACK:
                PathAppend(szPath, SZ_WEBVW_NOSKIN_HIBLACK_DIR);
                break;
            case CONTRAST_HIGHWHITE:
                PathAppend(szPath, SZ_WEBVW_NOSKIN_HIWHITE_DIR);
                break;
            default:
            case CONTRAST_NORMAL:
                PathAppend(szPath, SZ_WEBVW_NOSKIN_NORMAL_DIR);
                break;
            }

            PathAppend(szPath, SZ_WEBVW_SKIN_FILE);
            hr = HrSysAllocString(szPath, pbstrPath);
        }
    }

    return hr;
}


HRESULT CAppearanceSize::get_ContrastLevel(OUT enumThemeContrastLevels * pContrastLevel)
{
    HRESULT hr = E_INVALIDARG;

    if (pContrastLevel)
    {
        DWORD dwType;
        DWORD cbSize = sizeof(*pContrastLevel);

        *pContrastLevel = CONTRAST_NORMAL;
        hr = HrRegQueryValueEx(m_hkeySize, SZ_REGVALUE_CONTRASTLEVEL, 0, &dwType, (BYTE *)pContrastLevel, &cbSize);
        if (SUCCEEDED(hr))
        {
            if (REG_DWORD != dwType)
            {
                *pContrastLevel = CONTRAST_NORMAL;
                hr = E_FAIL;
            }
        }
    }

    return hr;
}


HRESULT CAppearanceSize::put_ContrastLevel(IN enumThemeContrastLevels ContrastLevel)
{
    return HrRegSetValueEx(m_hkeySize, SZ_REGVALUE_CONTRASTLEVEL, 0, REG_DWORD, (BYTE *)&ContrastLevel, sizeof(ContrastLevel));
}






//===========================
// *** IPropertyBag Interface ***
//===========================
HRESULT CAppearanceSize::Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        if (!StrCmpW(pszPropName, SZ_PBPROP_VSBEHAVIOR_FLATMENUS))
        {
            pVar->vt = VT_BOOL;
            hr = S_OK;
            // We default to zero because that's what non-visual styles will have.
            pVar->boolVal = (HrRegGetDWORD(m_hkeySize, NULL, SZ_REGVALUE_FLATMENUS, 0x00000001) ? VARIANT_TRUE : VARIANT_FALSE);
        }
        else if (!StrCmpW(pszPropName, SZ_PBPROP_COLORSCHEME_LEGACYNAME))
        {
            TCHAR szLegacyName[MAX_PATH];

            hr = HrRegGetValueString(m_hkeySize, NULL, SZ_REGVALUE_LEGACYNAME, szLegacyName, ARRAYSIZE(szLegacyName));
            if (SUCCEEDED(hr))
            {
                pVar->vt = VT_BSTR;
                hr = HrSysAllocString(szLegacyName, &pVar->bstrVal);
            }
        }
    }

    return hr;
}


HRESULT CAppearanceSize::Write(IN LPCOLESTR pszPropName, IN VARIANT * pVar)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        if (!StrCmpW(pszPropName, SZ_PBPROP_VSBEHAVIOR_FLATMENUS) &&
            (VT_BOOL == pVar->vt))
        {
            DWORD dwData = ((VARIANT_TRUE == pVar->boolVal) ? 0x00000001 : 0x000000);

            hr = HrRegSetDWORD(m_hkeySize, NULL, SZ_REGVALUE_FLATMENUS, dwData);
        }
        else if (!StrCmpW(pszPropName, SZ_PBPROP_COLORSCHEME_LEGACYNAME) &&
            (VT_BSTR == pVar->vt))
        {
            hr = HrRegSetValueString(m_hkeySize, NULL, SZ_REGVALUE_LEGACYNAME, pVar->bstrVal);
        }
    }

    return hr;
}






//===========================
// *** IUnknown Interface ***
//===========================
ULONG CAppearanceSize::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CAppearanceSize::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


//===========================
// *** Class Methods ***
//===========================
HRESULT CAppearanceSize::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CAppearanceSize, IThemeSize),
        QITABENT(CAppearanceSize, IDispatch),
        QITABENT(CAppearanceSize, IPropertyBag),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


CAppearanceSize::CAppearanceSize(IN HKEY hkeyStyle, IN HKEY hkeySize) : CImpIDispatch(LIBID_Theme, 1, 0, IID_IThemeSize), m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    m_hkeyStyle = hkeyStyle;
    m_hkeySize = hkeySize;
}


CAppearanceSize::~CAppearanceSize()
{
    if (m_hkeyStyle)
    {
        RegCloseKey(m_hkeyStyle);
    }

    if (m_hkeySize)
    {
        RegCloseKey(m_hkeySize);
    }

    DllRelease();
}



HRESULT CAppearanceSize_CreateInstance(IN HKEY hkeyStyle, IN HKEY hkeySize, OUT IThemeSize ** ppThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeSize)
    {
        CAppearanceSize * pObject = new CAppearanceSize(hkeyStyle, hkeySize);

        *ppThemeSize = NULL;
        if (pObject)
        {
            hr = pObject->QueryInterface(IID_PPV_ARG(IThemeSize, ppThemeSize));
            pObject->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\appscheme.cpp ===
/*****************************************************************************\
    FILE: appScheme.cpp

    DESCRIPTION:
        This is the Autmation Object to theme scheme object.

    BryanSt 4/3/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <cowsite.h>
#include <atlbase.h>
#include "util.h"
#include "theme.h"
#include "appstyle.h"
#include "appscheme.h"



//===========================
// *** Class Internals & Helpers ***
//===========================

APPEARANCESCHEME_UPGRADE_MAPPINGS g_UpgradeMapping[MAX_LEGACY_UPGRADE_SCENARIOS] = {0};


HRESULT LoadConversionMappings(void)
{
    if (0 == g_UpgradeMapping[0].szLegacyName[0])   // Only set the settings if it's the first time.
    {
        // This is custom user created scheme.
        TCHAR szTempState[10];

        for (int nIndex = 0; nIndex < ARRAYSIZE(g_UpgradeMapping); nIndex++)
        {
            LoadString(HINST_THISDLL, IDS_LEGACYSCHEME_NAME + nIndex, g_UpgradeMapping[nIndex].szLegacyName, ARRAYSIZE(g_UpgradeMapping[nIndex].szLegacyName));
            LoadString(HINST_THISDLL, IDS_LOCALIZATIONPOINTER + nIndex, g_UpgradeMapping[nIndex].szNewColorSchemeName, ARRAYSIZE(g_UpgradeMapping[nIndex].szNewColorSchemeName));
            LoadString(HINST_THISDLL, IDS_NEWSIZE_NAME + nIndex, g_UpgradeMapping[nIndex].szNewSizeName, ARRAYSIZE(g_UpgradeMapping[nIndex].szNewSizeName));
            LoadString(HINST_THISDLL, IDS_NEWCONTRASTFLAGS + nIndex, szTempState, ARRAYSIZE(szTempState));

            g_UpgradeMapping[nIndex].ContrastLevel = (enumThemeContrastLevels) StrToInt(szTempState);
        }
    }

    return S_OK;
}


HRESULT MapLegacyAppearanceSchemeToIndex(LPCTSTR pszOldSchemeName, int * pnIndex)
{
    HRESULT hr = E_FAIL;        // Failure means, FALSE, we didn't convert.

    *pnIndex = 0;
    for (int nIndex = 0; nIndex < ARRAYSIZE(g_UpgradeMapping); nIndex++)
    {
        // Did we find that pszSchemeName is one of the legacy settings?
        if (!StrCmpI(pszOldSchemeName, g_UpgradeMapping[nIndex].szLegacyName))
        {
            hr = S_OK;
            *pnIndex = nIndex;
            break;
        }
    }

    return hr;
}


HRESULT CAppearanceScheme::_IsLegacyUpgradeConvert(LPCTSTR pszSchemeName, SYSTEMMETRICSALL * pState, IN BOOL fSetAsDefault)
{
    int nIndex = 0;
    HRESULT hr = MapLegacyAppearanceSchemeToIndex(pszSchemeName, &nIndex);

    if (SUCCEEDED(hr))
    {
        hr = _ConvertScheme(pszSchemeName, g_UpgradeMapping[nIndex].szNewColorSchemeName, g_UpgradeMapping[nIndex].szNewSizeName, pState, g_UpgradeMapping[nIndex].ContrastLevel, fSetAsDefault, FALSE);
    }

    return hr;
}


HRESULT CAppearanceScheme::_CustomConvert(LPCTSTR pszSchemeName, SYSTEMMETRICSALL * pState, IN BOOL fSetAsDefault, IN BOOL fSetRegKeyTitle)
{
    // This is custom user created scheme.
    TCHAR szSizeName[MAX_PATH];

    LoadString(HINST_THISDLL, IDS_SIZE_NORMAL, szSizeName, ARRAYSIZE(szSizeName));
    return _ConvertScheme(pszSchemeName, pszSchemeName, szSizeName, pState, CONTRAST_NORMAL, fSetAsDefault, fSetRegKeyTitle);
}


HRESULT CAppearanceScheme::_getSizeIndex(IN IThemeStyle * pThemeStyle, IN IThemeSize * pThemeSize, IN BSTR bstrSizeDisplayName, IN long * pnSizeIndex)
{
    // This is horrible from a perf perspective, but we only do it once on upgrade.
    long nCount;
    HRESULT hr = E_FAIL;

    *pnSizeIndex = 0;
    if (SUCCEEDED(pThemeStyle->get_length(&nCount)))
    {
        IThemeSize * pThemeSize2;

        for (long nIndex = 0; nIndex < nCount; nIndex++)
        {
            VARIANT var;
            
            var.vt = VT_I4;
            var.lVal = nIndex;
            if (SUCCEEDED(pThemeStyle->get_item(var, &pThemeSize2)))
            {
                CComBSTR bstrSize2;

                if (SUCCEEDED(pThemeSize2->get_DisplayName(&bstrSize2)))
                {
                    CComBSTR bstrName;

                    if (!StrCmpIW(bstrSizeDisplayName, bstrSize2) ||
                        (SUCCEEDED(pThemeSize2->get_Name(&bstrName)) &&
                        !StrCmpIW(bstrSizeDisplayName, bstrName)))
                    {
                        hr = S_OK;
                        *pnSizeIndex = nIndex;
                        nIndex = nCount;        // End looping now.
                    }
                }

                pThemeSize2->Release();
            }
        }
    }

    return hr;
}


HRESULT CAppearanceScheme::_getIndex(IN IThemeStyle * pThemeStyle, IN BSTR bstrStyleDisplayName, IN long * pnStyleIndex, IN IThemeSize * pThemeSize, IN BSTR bstrSizeDisplayName, IN long * pnSizeIndex)
{
    // This is horrible from a perf perspective, but we only do it once on upgrade.
    long nCount;
    HRESULT hr = E_FAIL;

    *pnStyleIndex = 0;
    *pnSizeIndex = 0;
    if (SUCCEEDED(get_length(&nCount)))
    {
        IThemeStyle * pThemeStyle2;

        for (long nIndex = 0; nIndex < nCount; nIndex++)
        {
            VARIANT var;
            
            var.vt = VT_I4;
            var.lVal = nIndex;
            if (SUCCEEDED(get_item(var, &pThemeStyle2)))
            {
                CComBSTR bstrStyle2;

                if (SUCCEEDED(pThemeStyle2->get_DisplayName(&bstrStyle2)))
                {
                    CComBSTR bstrName;

                    if (!StrCmpIW(bstrStyleDisplayName, bstrStyle2) ||
                        (SUCCEEDED(pThemeStyle2->get_Name(&bstrName)) &&
                        !StrCmpIW(bstrStyleDisplayName, bstrName)))
                    {
                        *pnStyleIndex = nIndex;
                        hr = _getSizeIndex(pThemeStyle, pThemeSize, bstrSizeDisplayName, pnSizeIndex);
                        nIndex = nCount;        // End the search.
                    }
                }

                pThemeStyle2->Release();
            }
        }
    }

    return hr;
}


HRESULT CAppearanceScheme::_ConvertScheme(LPCTSTR pszLegacyName,        // This is the Legacy Name
                                          LPCTSTR pszStyleName, LPCTSTR pszSizeName, SYSTEMMETRICSALL * pState,
                                          IN enumThemeContrastLevels ContrastLevel, IN BOOL fSetAsDefault, IN BOOL fSetRegKeyTitle)
{
    // This is custom user created scheme.
    IThemeStyle * pThemeStyle;
    CComVariant varDisplayNameBSTR(pszStyleName);
    HRESULT hr = get_item(varDisplayNameBSTR, &pThemeStyle);

    if (FAILED(hr))
    {
        // If it doesn't exist, create one.
        hr = _AddStyle((fSetRegKeyTitle ? pszStyleName : NULL), &pThemeStyle);
    }

    if (SUCCEEDED(hr))
    {
        CComBSTR bstrStyleDisplayName(pszStyleName);

        hr = pThemeStyle->put_DisplayName(bstrStyleDisplayName);
        if (SUCCEEDED(hr))
        {
            IThemeSize * pThemeSize;

            hr = pThemeStyle->AddSize(&pThemeSize);
            if (SUCCEEDED(hr))
            {
                CComBSTR bstrSizeDisplayName(pszSizeName);

                hr = pThemeSize->put_DisplayName(bstrSizeDisplayName);
                if (SUCCEEDED(hr))
                {
                    hr = SystemMetricsAll_Save(pState, pThemeSize, FALSE);

                    if (SUCCEEDED(hr))
                    {
                        // Set the contrast level.
                        hr = pThemeSize->put_ContrastLevel(ContrastLevel);
                        if (SUCCEEDED(hr))
                        {
                            IPropertyBag * pPropertyBag;

                            hr = pThemeSize->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
                            if (SUCCEEDED(hr))
                            {
                                hr = SHPropertyBag_WriteStr(pPropertyBag, SZ_PBPROP_COLORSCHEME_LEGACYNAME, pszLegacyName);
                                pPropertyBag->Release();
                            }
                        }
                    }
                }

                if (fSetAsDefault && SUCCEEDED(hr))
                {
                    long nStyleIndex;
                    long nSizeIndex;

                    hr = _getIndex(pThemeStyle, bstrStyleDisplayName, &nStyleIndex, pThemeSize, bstrSizeDisplayName, &nSizeIndex);
                    if (SUCCEEDED(hr))
                    {
                        TCHAR szData[10];

                        wnsprintf(szData, ARRAYSIZE(szData), TEXT("%d"), nStyleIndex);

                        DWORD cbSize = ((lstrlen(szData) + 1) * sizeof(szData[0]));
                        hr = HrSHSetValue(m_hKeyScheme, NULL, SZ_REGVALUE_SELECTEDSTYLE, REG_SZ, (LPVOID) szData, cbSize);
                        if (SUCCEEDED(hr))
                        {
                            TCHAR szData2[10];

                            wnsprintf(szData2, ARRAYSIZE(szData2), TEXT("%d"), nSizeIndex);
                            DWORD cbSize = ((lstrlen(szData2) + 1) * sizeof(szData2[0]));
                            hr = HrSHSetValue(m_hKeyScheme, szData, SZ_REGVALUE_SELECTEDSIZE, REG_SZ, (LPVOID) szData2, cbSize);
                        }
                    }
                }

                pThemeSize->Release();
            }
        }

        pThemeStyle->Release();
    }

    return hr;
}


HRESULT LoadCurrentStyle(LPTSTR pszCurrentStyle, int cchSize)
{
    HKEY hkey;
    HRESULT hr = HrRegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_APPEARANCE, 0, KEY_READ, &hkey);

    if (SUCCEEDED(hr))
    {
        DWORD dwSize = (DWORD)(cchSize * sizeof(pszCurrentStyle[0]));

        hr = HrRegQueryValueEx(hkey, REGSTR_KEY_CURRENT, NULL, NULL, (LPBYTE)pszCurrentStyle, &dwSize);
        RegCloseKey(hkey);
    }

    return hr;
}


// This function will do nothing if an upgrade isn't needed.
HRESULT CAppearanceScheme::_InitReg(void)
{
    HRESULT hr = S_OK;

    if (!m_hKeyScheme)
    {
        hr = HrRegOpenKeyEx(HKEY_CURRENT_USER, SZ_APPEARANCE_NEWSCHEMES, 0, (KEY_WRITE | KEY_READ),  &m_hKeyScheme);
        if (SUCCEEDED(hr))
        {
            // We don't need to upgrade.
        }
        else
        {
            // Here is where we need to do the upgrade.
            hr = HrRegCreateKeyEx(HKEY_CURRENT_USER, SZ_APPEARANCE_NEWSCHEMES, 0, NULL, REG_OPTION_NON_VOLATILE, 
                        (KEY_WRITE | KEY_READ), NULL, &m_hKeyScheme, 0);
            if (SUCCEEDED(hr))
            {
                HKEY hKeyOld;

                hr = HrRegCreateKeyEx(HKEY_CURRENT_USER, SZ_APPEARANCE_SCHEMES, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ, NULL, &hKeyOld, 0);
                if (SUCCEEDED(hr))
                {
                    TCHAR szCurrentStyle[MAX_PATH];
                    TCHAR szSchemeName[MAX_PATH];
                    TCHAR szDefaultScheme[MAX_PATH];
                    DWORD dwIndex = 0;

                    // Load in the upgrade mappings.
                    hr = LoadConversionMappings();

                    LoadString(HINST_THISDLL, IDS_DEFAULT_APPEARANCES_SCHEME, szDefaultScheme, ARRAYSIZE(szDefaultScheme));
                    hr = LoadCurrentStyle(szCurrentStyle, ARRAYSIZE(szCurrentStyle));
                    if (FAILED(hr))
                    {
                        // This will fail if the user never changed the legacy "Appearance Scheme".
                        LoadString(HINST_THISDLL, IDS_DEFAULT_APPEARANCES_SCHEME, szCurrentStyle, ARRAYSIZE(szCurrentStyle));
                        hr = S_OK;
                    }

                    // Now let's walk thru each one and convert it.
                    while (SUCCEEDED(hr))
                    {
                        DWORD dwType;
                        DWORD cbSize = sizeof(szSchemeName);

                        hr = HrRegEnumValue(hKeyOld, dwIndex, szSchemeName, &cbSize, NULL, &dwType, NULL, NULL);
                        if (SUCCEEDED(hr) && (REG_BINARY == dwType))
                        {
                            BOOL fSetAsDefault = !StrCmpI(szCurrentStyle, szSchemeName);
                            SYSTEMMETRICSALL state = {0};

                            hr = Look_GetSchemeData(hKeyOld, szSchemeName, &state.schemeData);
                            if (SUCCEEDED(hr))
                            {
                                state.schemeData.rgb[COLOR_MENUBAR] = state.schemeData.rgb[COLOR_MENU];
                                state.schemeData.rgb[COLOR_MENUHILIGHT] = state.schemeData.rgb[COLOR_MENUTEXT];
                                // See if this is one of the shipping Appearance Schemes, so we want to create it
                                // special.
                                hr = _IsLegacyUpgradeConvert(szSchemeName, &state, fSetAsDefault);
                                if (FAILED(hr))
                                {
                                    // No, so we will upgrade it as a custom item.
                                    hr = _CustomConvert(szSchemeName, &state, fSetAsDefault, FALSE);
                                }

                                // On Upgrade, we need to copy "Windows Standard" to "Current Settings SaveNoVisualStyle".
                                // That way, when the user toggles from "Professional VS" to "Windows Classic VS", we
                                // load those colors as the first alternative to visual styles off.  Win #151831
                                if (!StrCmpI(szDefaultScheme, szSchemeName))
                                {
                                    hr = _CustomConvert(SZ_SAVEGROUP_NOSKIN_TITLE, &state, FALSE, TRUE);
                                }
                            }
                        }

                        dwIndex++;
                    }

                    hr = S_OK;
                    RegCloseKey(hKeyOld);
                }
            }
        }
    }

    return hr;
}


HRESULT CAppearanceScheme::_getStyleByIndex(IN long nIndex, OUT IThemeStyle ** ppThemeStyle)
{
    HRESULT hr = _InitReg();

    if (SUCCEEDED(hr))
    {
        HKEY hKeyStyle;
        TCHAR szKeyName[MAXIMUM_SUB_KEY_LENGTH];

        wnsprintf(szKeyName, ARRAYSIZE(szKeyName), TEXT("%d"), nIndex);

        hr = HrRegOpenKeyEx(m_hKeyScheme, szKeyName, 0, (KEY_WRITE | KEY_READ), &hKeyStyle);
        if (SUCCEEDED(hr))
        {
            hr = CAppearanceStyle_CreateInstance(hKeyStyle, ppThemeStyle);  // This function takes ownership of hKey
            if (FAILED(hr))
            {
                RegCloseKey(hKeyStyle);
            }
        }
    }
 
    return hr;
}


HRESULT CAppearanceScheme::_getCurrentSettings(IN LPCWSTR pszSettings, OUT IThemeStyle ** ppThemeStyle)
{
    HRESULT hr = _InitReg();

    if (SUCCEEDED(hr))
    {
        WCHAR szRegValue[MAXIMUM_VALUE_NAME_LENGTH];
        HKEY hKeyStyle;

        StrCpyNW(szRegValue, SZ_REGVALUE_CURRENT_SETTINGS, ARRAYSIZE(szRegValue));
        StrCatBuffW(szRegValue, &pszSettings[2], ARRAYSIZE(szRegValue));

        hr = HrRegCreateKeyEx(m_hKeyScheme, szRegValue, 0, NULL, REG_OPTION_NON_VOLATILE, (KEY_WRITE | KEY_READ), NULL, &hKeyStyle, NULL);
        if (SUCCEEDED(hr))
        {
            hr = CAppearanceStyle_CreateInstance(hKeyStyle, ppThemeStyle);  // This function takes ownership of hKey
            if (FAILED(hr))
            {
                RegCloseKey(hKeyStyle);
            }
        }
    }
 
    return hr;
}






//===========================
// *** ITheme Interface ***
//===========================
HRESULT CAppearanceScheme::get_DisplayName(OUT BSTR * pbstrDisplayName)
{
    WCHAR szDisplayName[MAX_PATH];

    LoadString(HINST_THISDLL, IDS_NO_SKIN_DISPLAYNAME, szDisplayName, ARRAYSIZE(szDisplayName));
    return HrSysAllocStringW(szDisplayName, pbstrDisplayName);
}


HRESULT CAppearanceScheme::get_length(OUT long * pnLength)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pnLength)
    {
        *pnLength = 0;
        hr = _InitReg();
        if (SUCCEEDED(hr))
        {
            DWORD dwValues = 0;

            hr = HrRegQueryInfoKey(m_hKeyScheme, NULL, NULL, NULL, &dwValues, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            if (SUCCEEDED(hr))
            {
                HKEY hKeyTemp;

                if (SUCCEEDED(HrRegOpenKeyEx(m_hKeyScheme, SZ_REGVALUE_CURRENT_SETTINGS, 0, KEY_READ, &hKeyTemp)))
                {
                    dwValues--; // We want to subtract one for the "Current Settings" key.
                    RegCloseKey(hKeyTemp);
                }
            }

            *pnLength = (long) dwValues;
        }
    }

    return hr;
}


HRESULT CAppearanceScheme::get_item(IN VARIANT varIndex, OUT IThemeStyle ** ppThemeStyle)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeStyle)
    {
        long nCount = 0;

        get_length(&nCount);
        *ppThemeStyle = NULL;

        // This is sortof gross, but if we are passed a pointer to another variant, simply
        // update our copy here...
        if (varIndex.vt == (VT_BYREF | VT_VARIANT) && varIndex.pvarVal)
            varIndex = *(varIndex.pvarVal);

        switch (varIndex.vt)
        {
        case VT_I2:
            varIndex.lVal = (long)varIndex.iVal;
            // And fall through...

        case VT_I4:
        if ((varIndex.lVal >= 0) && (varIndex.lVal < nCount))
        {
            hr = _getStyleByIndex(varIndex.lVal, ppThemeStyle);
        }
        break;
        case VT_BSTR:
        if (varIndex.bstrVal)
        {
            if ((L':' == varIndex.bstrVal[0]) && (L':' == varIndex.bstrVal[1]))
            {
                // This is a "Custom" settings so look in that key.
                hr = _getCurrentSettings(varIndex.bstrVal, ppThemeStyle);
            }
            else
            {
                for (int nIndex = 0; FAILED(hr) && (nIndex < nCount); nIndex++)
                {
                    IThemeStyle * pThemeStyle;

                    if (SUCCEEDED(_getStyleByIndex(nIndex, &pThemeStyle)))
                    {
                        CComBSTR bstrDisplayName;

                        if (SUCCEEDED(pThemeStyle->get_DisplayName(&bstrDisplayName)))
                        {
                            if (!StrCmpIW(bstrDisplayName, varIndex.bstrVal))
                            {
                                // They match, so this is the one.
                                *ppThemeStyle = pThemeStyle;
                                pThemeStyle = NULL;
                                hr = S_OK;
                            }
                        }

                        if (FAILED(hr))
                        {
                            if (bstrDisplayName)
                            {
                                bstrDisplayName.Empty();
                            }

                            if (SUCCEEDED(pThemeStyle->get_Name(&bstrDisplayName)))
                            {
                                if (!StrCmpIW(bstrDisplayName, varIndex.bstrVal))
                                {
                                    // They match, so this is the one.
                                    *ppThemeStyle = pThemeStyle;
                                    pThemeStyle = NULL;
                                    hr = S_OK;
                                }
                            }
                        }

                        ATOMICRELEASE(pThemeStyle);
                    }
                }
            }
        }
        break;

        default:
            hr = E_NOTIMPL;
        }
    }

    return hr;
}


HRESULT CAppearanceScheme::get_SelectedStyle(OUT IThemeStyle ** ppThemeStyle)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeStyle)
    {
        hr = _InitReg();
        if (SUCCEEDED(hr))
        {
            TCHAR szKeyName[MAXIMUM_SUB_KEY_LENGTH];
            DWORD cbSize = sizeof(szKeyName);

            *ppThemeStyle = NULL;
            hr = HrSHGetValue(m_hKeyScheme, NULL, SZ_REGVALUE_SELECTEDSTYLE, NULL, szKeyName, &cbSize);
            if (FAILED(hr))
            {
                // "21" is the Appearance Scheme of "Windows Classic".
                StrCpyN(szKeyName, TEXT("21"), ARRAYSIZE(szKeyName));
                hr = S_OK;
            }

            if (SUCCEEDED(hr))
            {
                HKEY hKeyStyle;

                // Let's find the next empty slot
                hr = HrRegOpenKeyEx(m_hKeyScheme, szKeyName, 0, (KEY_WRITE | KEY_READ), &hKeyStyle);
                if (SUCCEEDED(hr))
                {
                    hr = CAppearanceStyle_CreateInstance(hKeyStyle, ppThemeStyle);  // This function takes ownership of hKeyStyle
                    if (FAILED(hr))
                    {
                        RegCloseKey(hKeyStyle);
                    }
                }
            }
        }
    }

    return hr;
}


HRESULT CAppearanceScheme::put_SelectedStyle(IN IThemeStyle * pThemeStyle)
{
    HRESULT hr = E_INVALIDARG;

    if (pThemeStyle)
    {
        hr = _InitReg();
        if (SUCCEEDED(hr))
        {
            TCHAR szKeyName[MAXIMUM_SUB_KEY_LENGTH];
            CComBSTR bstrDisplayNameSource;

            hr = pThemeStyle->get_DisplayName(&bstrDisplayNameSource);
            if (SUCCEEDED(hr))
            {
                for (int nIndex = 0; SUCCEEDED(hr); nIndex++)
                {
                    IThemeStyle * pThemeStyleInList;

                    hr = _getStyleByIndex(nIndex, &pThemeStyleInList);
                    if (SUCCEEDED(hr))
                    {
                        CComBSTR bstrDisplayName;

                        hr = pThemeStyleInList->get_DisplayName(&bstrDisplayName);
                        ATOMICRELEASE(pThemeStyleInList);
                        if (SUCCEEDED(hr))
                        {
                            if (!StrCmpIW(bstrDisplayName, bstrDisplayNameSource))
                            {
                                // They match, so this is the one.
                                wnsprintf(szKeyName, ARRAYSIZE(szKeyName), TEXT("%d"), nIndex);
                                break;
                            }
                        }
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                DWORD cbSize = ((lstrlen(szKeyName) + 1) * sizeof(szKeyName[0]));

                hr = HrSHSetValue(m_hKeyScheme, NULL, SZ_REGVALUE_SELECTEDSTYLE, REG_SZ, szKeyName, cbSize);
            }
        }
    }

    return hr;
}


HRESULT CAppearanceScheme::_AddStyle(IN LPCWSTR pszTitle, OUT IThemeStyle ** ppThemeStyle)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeStyle)
    {
        *ppThemeStyle = NULL;

        hr = _InitReg();
        if (SUCCEEDED(hr))
        {
            if (pszTitle)
            {
                HKEY hKeyStyle;

                hr = HrRegCreateKeyEx(m_hKeyScheme, pszTitle, 0, NULL, REG_OPTION_NON_VOLATILE, (KEY_WRITE | KEY_READ), NULL, &hKeyStyle, NULL);
                if (SUCCEEDED(hr))
                {
                    hr = CAppearanceStyle_CreateInstance(hKeyStyle, ppThemeStyle);  // This function takes ownership of hKey
                    if (FAILED(hr))
                    {
                        RegCloseKey(hKeyStyle);
                    }
                }
            }
            else
            {
                // Find an empty Scheme Name.
                for (int nIndex = 0; nIndex < 10000; nIndex++)
                {
                    HKEY hKeyStyle;
                    TCHAR szKeyName[MAXIMUM_SUB_KEY_LENGTH];

                    wnsprintf(szKeyName, ARRAYSIZE(szKeyName), TEXT("%d"), nIndex);

                    // Let's find the next empty spot
                    hr = HrRegOpenKeyEx(m_hKeyScheme, szKeyName, 0, KEY_READ, &hKeyStyle);
                    if (SUCCEEDED(hr))
                    {
                        RegCloseKey(hKeyStyle);
                    }
                    else
                    {
                        hr = HrRegCreateKeyEx(m_hKeyScheme, szKeyName, 0, NULL, REG_OPTION_NON_VOLATILE, (KEY_WRITE | KEY_READ), NULL, &hKeyStyle, NULL);
                        if (SUCCEEDED(hr))
                        {
                            hr = CAppearanceStyle_CreateInstance(hKeyStyle, ppThemeStyle);  // This function takes ownership of hKey
                            if (FAILED(hr))
                            {
                                RegCloseKey(hKeyStyle);
                            }
                        }

                        break;
                    }
                }
            }
        }
    }

    return hr;
}





//===========================
// *** IUnknown Interface ***
//===========================
ULONG CAppearanceScheme::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CAppearanceScheme::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


//===========================
// *** Class Methods ***
//===========================
HRESULT CAppearanceScheme::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CAppearanceScheme, IPersist),
        QITABENT(CAppearanceScheme, IThemeScheme),
        QITABENT(CAppearanceScheme, IDispatch),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


CAppearanceScheme::CAppearanceScheme(void) : CImpIDispatch(LIBID_Theme, 1, 0, IID_IThemeScheme), CObjectCLSID(&CLSID_LegacyAppearanceScheme), m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_hKeyScheme);
}


CAppearanceScheme::~CAppearanceScheme()
{
    if (m_hKeyScheme)
    {
        RegCloseKey(m_hKeyScheme);
    }

    DllRelease();
}



HRESULT CAppearanceScheme_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj)
{
    HRESULT hr = E_INVALIDARG;

    if (punkOuter)
    {
        return CLASS_E_NOAGGREGATION;
    }

    if (ppvObj)
    {
        CAppearanceScheme * pObject = new CAppearanceScheme();

        *ppvObj = NULL;
        if (pObject)
        {
            hr = pObject->QueryInterface(riid, ppvObj);
            pObject->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\appstyle.cpp ===
/*****************************************************************************\
    FILE: appStyle.cpp

    DESCRIPTION:
        This is the Autmation Object to theme scheme object.

    BryanSt 4/3/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <cowsite.h>
#include <atlbase.h>
#include "util.h"
#include "theme.h"
#include "appsize.h"
#include "appstyle.h"




//===========================
// *** Class Internals & Helpers ***
//===========================
HRESULT CAppearanceStyle::_getSizeByIndex(IN long nIndex, OUT IThemeSize ** ppThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeSize)
    {
        HKEY hKeyStyle;

        *ppThemeSize = NULL;
        hr = HrRegOpenKeyEx(m_hKeyStyle, NULL, 0, (KEY_WRITE | KEY_READ), &hKeyStyle);      // Clone the key.
        if (SUCCEEDED(hr))
        {
            HKEY kKeySizes;

            hr = HrRegCreateKeyEx(m_hKeyStyle, SZ_REGKEY_SIZES, 0, NULL, REG_OPTION_NON_VOLATILE, (KEY_WRITE | KEY_READ), NULL, &kKeySizes, NULL);
            if (SUCCEEDED(hr))
            {
                HKEY kKeyTheSize;
                TCHAR szKeyName[MAXIMUM_SUB_KEY_LENGTH];

                wnsprintf(szKeyName, ARRAYSIZE(szKeyName), TEXT("%d"), nIndex);
                hr = HrRegOpenKeyEx(kKeySizes, szKeyName, 0, (KEY_WRITE | KEY_READ), &kKeyTheSize);
                if (SUCCEEDED(hr))
                {
                   hr = CAppearanceSize_CreateInstance(hKeyStyle, kKeyTheSize, ppThemeSize);  // This function takes ownership of hKeyStyle and kKeyTheSize
                }

                RegCloseKey(kKeySizes);
            }

            if (FAILED(hr))
            {
                RegCloseKey(hKeyStyle);
            }
        }
    }

    return hr;
}




#define SZ_APPEARANCE_SCHEME_NAME         L"NoVisualStyle"

//===========================
// *** ITheme Interface ***
//===========================
HRESULT CAppearanceStyle::get_DisplayName(OUT BSTR * pbstrDisplayName)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrDisplayName)
    {
        CComBSTR bstrDisplayName;

        *pbstrDisplayName = NULL;
        hr = HrBStrRegQueryValue(m_hKeyStyle, SZ_REGVALUE_DISPLAYNAME, &bstrDisplayName);
        if (SUCCEEDED(hr))
        {
            WCHAR szDisplayName[MAX_PATH];
            if (SUCCEEDED(SHLoadIndirectString(bstrDisplayName, szDisplayName, ARRAYSIZE(szDisplayName), NULL)))
            {
                hr = HrSysAllocStringW(szDisplayName, pbstrDisplayName);
            }
            else
            {
                hr = HrSysAllocStringW(bstrDisplayName, pbstrDisplayName);
            }
        }
    }


    return hr;
}


HRESULT CAppearanceStyle::put_DisplayName(IN BSTR bstrDisplayName)
{
    return HrRegSetValueString(m_hKeyStyle, NULL, SZ_REGVALUE_DISPLAYNAME, bstrDisplayName);
}


HRESULT CAppearanceStyle::get_Name(OUT BSTR * pbstrName)
{
    // This will be connonical.  And it will be language independent if it is one that
    // we could upgrade to MUI compat strings.
    return HrBStrRegQueryValue(m_hKeyStyle, SZ_REGVALUE_DISPLAYNAME, pbstrName);
}


HRESULT CAppearanceStyle::put_Name(IN BSTR bstrName)
{
    return E_NOTIMPL;
}


HRESULT CAppearanceStyle::get_length(OUT long * pnLength)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pnLength)
    {
        HKEY hKeyStyle;

        *pnLength = 0;

        hr = HrRegOpenKeyEx(m_hKeyStyle, SZ_REGKEY_SIZES, 0, KEY_READ, &hKeyStyle);
        if (SUCCEEDED(hr))
        {
            DWORD dwValues = 0;

            hr = HrRegQueryInfoKey(hKeyStyle, NULL, NULL, NULL, &dwValues, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            *pnLength = (long) dwValues;

            RegCloseKey(hKeyStyle);
        }
    }

    return hr;
}


HRESULT CAppearanceStyle::get_item(IN VARIANT varIndex, OUT IThemeSize ** ppThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeSize)
    {
        long nCount = 0;

        get_length(&nCount);
        *ppThemeSize = NULL;

        // This is sortof gross, but if we are passed a pointer to another variant, simply
        // update our copy here...
        if (varIndex.vt == (VT_BYREF | VT_VARIANT) && varIndex.pvarVal)
            varIndex = *(varIndex.pvarVal);

        switch (varIndex.vt)
        {
        case VT_I2:
            varIndex.lVal = (long)varIndex.iVal;
            // And fall through...

        case VT_I4:
            if ((varIndex.lVal >= 0) && (varIndex.lVal < nCount))
            {
                hr = _getSizeByIndex(varIndex.lVal, ppThemeSize);
            }
        break;
        case VT_BSTR:
        if (varIndex.bstrVal)
        {
            for (int nIndex = 0; FAILED(hr) && (nIndex < nCount); nIndex++)
            {
                IThemeSize * pThemeSize;

                if (SUCCEEDED(_getSizeByIndex(nIndex, &pThemeSize)))
                {
                    CComBSTR bstrDisplayName;

                    if (SUCCEEDED(pThemeSize->get_DisplayName(&bstrDisplayName)))
                    {
                        if (!StrCmpIW(bstrDisplayName, varIndex.bstrVal))
                        {
                            // They match, so this is the one.
                            *ppThemeSize = pThemeSize;
                            pThemeSize = NULL;
                            hr = S_OK;
                        }
                    }

                    if (FAILED(hr))
                    {
                        if (bstrDisplayName)
                        {
                            bstrDisplayName.Empty();
                        }

                        if (SUCCEEDED(pThemeSize->get_Name(&bstrDisplayName)))
                        {
                            if (!StrCmpIW(bstrDisplayName, varIndex.bstrVal))
                            {
                                // They match, so this is the one.
                                *ppThemeSize = pThemeSize;
                                pThemeSize = NULL;
                                hr = S_OK;
                            }
                        }
                    }

                    ATOMICRELEASE(pThemeSize);
                }
            }
        }
        break;

        default:
            hr = E_NOTIMPL;
        }
    }

    return hr;
}


HRESULT CAppearanceStyle::get_SelectedSize(OUT IThemeSize ** ppThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeSize)
    {
        HKEY hKeyStyle;

        *ppThemeSize = NULL;
        AssertMsg((NULL != m_hKeyStyle), TEXT("If this isn't set, then someone didn't construct us correctly"));
        hr = HrRegOpenKeyEx(m_hKeyStyle, NULL, 0, (KEY_WRITE | KEY_READ), &hKeyStyle);      // Clone the key.
        if (SUCCEEDED(hr))
        {
            TCHAR szSelectedSize[MAXIMUM_SUB_KEY_LENGTH];
            DWORD cbSize = sizeof(szSelectedSize);

            hr = HrSHGetValue(m_hKeyStyle, NULL, SZ_REGVALUE_SELECTEDSIZE, NULL, szSelectedSize, &cbSize);
            if (FAILED(hr))
            {
                StrCpyN(szSelectedSize, TEXT("0"), ARRAYSIZE(szSelectedSize));  // Select the first one in the list when in doubt.
                hr = S_OK;
            }

            if (SUCCEEDED(hr))
            {
                TCHAR szKeyName[MAXIMUM_SUB_KEY_LENGTH];
                HKEY hKeyTheSize;

                wnsprintf(szKeyName, ARRAYSIZE(szKeyName), TEXT("%s\\%s"), SZ_REGKEY_SIZES, szSelectedSize);

                // Let's find the next empty slot
                hr = HrRegOpenKeyEx(m_hKeyStyle, szKeyName, 0, (KEY_WRITE | KEY_READ), &hKeyTheSize);
                if (SUCCEEDED(hr))
                {
                    hr = CAppearanceSize_CreateInstance(hKeyStyle, hKeyTheSize, ppThemeSize);  // This function takes ownership of hKeyStyle and kKeySizes
                    if (FAILED(hr))
                    {
                        RegCloseKey(hKeyTheSize);
                    }
                }
            }

            if (FAILED(hr))
            {
                RegCloseKey(hKeyStyle);
            }
        }
    }

    return hr;
}


HRESULT CAppearanceStyle::put_SelectedSize(IN IThemeSize * pThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (pThemeSize)
    {
        TCHAR szKeyName[MAXIMUM_SUB_KEY_LENGTH];
        CComBSTR bstrDisplayNameSource;

        szKeyName[0] = 0;
        hr = pThemeSize->get_DisplayName(&bstrDisplayNameSource);
        if (SUCCEEDED(hr))
        {
            for (int nIndex = 0; SUCCEEDED(hr); nIndex++)
            {
                IThemeSize * pThemeSizeInList;

                hr = _getSizeByIndex(nIndex, &pThemeSizeInList);
                if (SUCCEEDED(hr))
                {
                    CComBSTR bstrDisplayName;

                    hr = pThemeSizeInList->get_DisplayName(&bstrDisplayName);
                    if (SUCCEEDED(hr))
                    {
                        ATOMICRELEASE(pThemeSizeInList);
                        if (!StrCmpIW(bstrDisplayName, bstrDisplayNameSource))
                        {
                            // They match, so this is the one.
                            wnsprintf(szKeyName, ARRAYSIZE(szKeyName), TEXT("%d"), nIndex);
                            break;
                        }
                    }
                }
            }
        }

        if (SUCCEEDED(hr) && szKeyName[0])
        {
            DWORD cbSize = ((lstrlen(szKeyName) + 1) * sizeof(szKeyName[0]));

            hr = HrSHSetValue(m_hKeyStyle, NULL, SZ_REGVALUE_SELECTEDSIZE, REG_SZ, szKeyName, cbSize);
        }
    }

    return hr;
}


HRESULT CAppearanceStyle::AddSize(OUT IThemeSize ** ppThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeSize)
    {
        HKEY kKeySizes;
        *ppThemeSize = NULL;

        hr = HrRegCreateKeyEx(m_hKeyStyle, SZ_REGKEY_SIZES, 0, NULL, REG_OPTION_NON_VOLATILE, (KEY_WRITE | KEY_READ), NULL, &kKeySizes, NULL);
        if (SUCCEEDED(hr))
        {
            for (int nIndex = 0; nIndex < 10000; nIndex++)
            {
                HKEY hKeyTheSize;
                TCHAR szKeyName[MAXIMUM_SUB_KEY_LENGTH];

                wnsprintf(szKeyName, ARRAYSIZE(szKeyName), TEXT("%d"), nIndex);

                // Let's find the next empty slot
                hr = HrRegOpenKeyEx(kKeySizes, szKeyName, 0, (KEY_WRITE | KEY_READ), &hKeyTheSize);
                if (SUCCEEDED(hr))
                {
                    RegCloseKey(hKeyTheSize);
                }
                else
                {
                    hr = HrRegCreateKeyEx(kKeySizes, szKeyName, 0, NULL, REG_OPTION_NON_VOLATILE, (KEY_WRITE | KEY_READ), NULL, &hKeyTheSize, NULL);
                    if (SUCCEEDED(hr))
                    {
                        HKEY hKeyStyle;

                        hr = HrRegOpenKeyEx(m_hKeyStyle, NULL, 0, (KEY_WRITE | KEY_READ), &hKeyStyle);      // Clone the key.
                        if (SUCCEEDED(hr))
                        {
                            hr = CAppearanceSize_CreateInstance(hKeyStyle, hKeyTheSize, ppThemeSize);  // This function takes ownership of hKeyStyle and kKeySizes
                            if (FAILED(hr))
                            {
                                RegCloseKey(hKeyStyle);
                            }
                        }

                        if (FAILED(hr))
                        {
                            RegCloseKey(hKeyTheSize);
                        }
                    }

                    break;
                }
            }

            RegCloseKey(kKeySizes);
        }
    }

    return hr;
}





//===========================
// *** IUnknown Interface ***
//===========================
ULONG CAppearanceStyle::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CAppearanceStyle::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


//===========================
// *** Class Methods ***
//===========================
HRESULT CAppearanceStyle::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CAppearanceStyle, IThemeStyle),
        QITABENT(CAppearanceStyle, IDispatch),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


CAppearanceStyle::CAppearanceStyle(IN HKEY hkeyStyle) : CImpIDispatch(LIBID_Theme, 1, 0, IID_IThemeStyle), m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    m_hKeyStyle = hkeyStyle;
}


CAppearanceStyle::~CAppearanceStyle()
{
    if (m_hKeyStyle)
    {
        RegCloseKey(m_hKeyStyle);
    }

    DllRelease();
}



HRESULT CAppearanceStyle_CreateInstance(IN HKEY hkeyStyle, OUT IThemeStyle ** ppThemeStyle)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeStyle)
    {
        CAppearanceStyle * pObject = new CAppearanceStyle(hkeyStyle);

        *ppThemeStyle = NULL;
        if (pObject)
        {
            hr = pObject->QueryInterface(IID_PPV_ARG(IThemeStyle, ppThemeStyle));
            pObject->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\baseappearpg.cpp ===
/*****************************************************************************\
    FILE: BaseAppearPg.cpp

    DESCRIPTION:
        This code will display a "Appearances" tab in the
    "Display Properties" dialog (the base dialog, not the advanced dlg).

    ??????? ?/??/1993    Created
    BryanSt 3/23/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 1993-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "BaseAppearPg.h"
#include "AdvAppearPg.h"
#include "CoverWnd.h"
#include "AppScheme.h"
#include "AdvDlg.h"
#include "fontfix.h"

//============================================================================================================
// *** Globals ***
//============================================================================================================
const static DWORD FAR aBaseAppearanceHelpIds[] =
{
        IDC_APPG_APPEARPREVIEW,         IDH_DISPLAY_APPEARANCE_PREVIEW,
        IDC_APPG_LOOKFEEL,              IDH_DISPLAY_APPEARANCE_LOOKFEEL,
        IDC_APPG_LOOKFEEL_LABLE,        IDH_DISPLAY_APPEARANCE_LOOKFEEL,
        IDC_APPG_COLORSCHEME_LABLE,     IDH_DISPLAY_APPEARANCE_COLORSCHEME,
        IDC_APPG_COLORSCHEME,           IDH_DISPLAY_APPEARANCE_COLORSCHEME,
        IDC_APPG_WNDSIZE_LABLE,         IDH_DISPLAY_APPEARANCE_WNDSIZE,
        IDC_APPG_WNDSIZE,               IDH_DISPLAY_APPEARANCE_WNDSIZE,
        IDC_APPG_EFFECTS,               IDH_DISPLAY_APPEARANCE_EFFECTS,
        IDC_APPG_ADVANCED,              IDH_DISPLAY_APPEARANCE_ADVANCED,
        0, 0
};

#define SZ_HELPFILE_BASEAPPEARANCE      TEXT("display.hlp")

// EnableApplyButton() fails in WM_INITDIALOG so we need to do it later.
#define WMUSER_DELAYENABLEAPPLY            (WM_USER + 1)
#define DelayEnableApplyButton(hDlg)    PostMessage(hDlg, WMUSER_DELAYENABLEAPPLY, 0, 0)




//===========================
// *** Class Internals & Helpers ***
//===========================
#ifdef DEBUG
void _TestFault(void)
{
    DWORD dwTemp = 3;
    DWORD * pdwDummy = NULL;        // This is NULL in order that it causes a fault.

    for (int nIndex = 0; nIndex < 1000000; nIndex++)
    {
        // This will definitely fault sooner or later.
        dwTemp += pdwDummy[nIndex];
    }
}
#endif // DEBUG


BOOL CBaseAppearancePage::_IsDirty(void)
{
    BOOL fIsDirty = m_advDlgState.dwChanged;

    if (m_fIsDirty ||   // We need to check this because we may have gotten dirty from another page before our UI was displayed.
        (ComboBox_GetCurSel(m_hwndSchemeDropDown) != m_nSelectedScheme) ||
        (ComboBox_GetCurSel(m_hwndStyleDropDown) != m_nSelectedStyle) ||
        (ComboBox_GetCurSel(m_hwndSizeDropDown) != m_nSelectedSize) ||
        (m_nNewDPI != m_nAppliedDPI))
    {
        fIsDirty = TRUE;
    }

    return fIsDirty;
}


INT_PTR CALLBACK CBaseAppearancePage::BaseAppearanceDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CBaseAppearancePage * pThis = (CBaseAppearancePage *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        PROPSHEETPAGE * pPropSheetPage = (PROPSHEETPAGE *) lParam;

        if (pPropSheetPage)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, pPropSheetPage->lParam);
            pThis = (CBaseAppearancePage *)pPropSheetPage->lParam;
        }
    }

    if (pThis)
        return pThis->_BaseAppearanceDlgProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}


BOOL DisplayAdvAppearancePage(IN IThemeScheme * pSelectedThemeScheme)
{
    BOOL fDisplayAdvanced = TRUE;

    if (pSelectedThemeScheme)
    {
        fDisplayAdvanced = IUnknown_CompareCLSID(pSelectedThemeScheme, CLSID_LegacyAppearanceScheme);
    }

    return fDisplayAdvanced;
}



//============================================================================================================
// *** Dialog Functions ***
//============================================================================================================
HRESULT CBaseAppearancePage::_OnAdvancedOptions(HWND hDlg)
{
    HRESULT hr = E_FAIL;
    IAdvancedDialog * pAdvAppearDialog;

    hr = GetAdvancedDialog(&pAdvAppearDialog);
    if (SUCCEEDED(hr))
    {
        BOOL fEnableApply = FALSE;

        IUnknown_SetSite(pAdvAppearDialog, SAFECAST(this, IObjectWithSite *));
        hr = pAdvAppearDialog->DisplayAdvancedDialog(hDlg, SAFECAST(this, IPropertyBag *), &fEnableApply);
        IUnknown_SetSite(pAdvAppearDialog, NULL);
        if (SUCCEEDED(hr) && fEnableApply)
        {
            EnableApplyButton(hDlg);

            // We pass TRUE because we want to switch to Custom if:
            // 1) visual styles are off, and 2) some of the system metrics changed.  Then we need to update the previews.
            _UpdatePreview(TRUE);
        }

        pAdvAppearDialog->Release();
    }

    return hr;
}


HRESULT CBaseAppearancePage::_OnEffectsOptions(HWND hDlg)
{
    HRESULT hr = E_FAIL;

    if (_punkSite)
    {
        IThemeUIPages * pThemesUIPages;

        // Let's get the Effects base page.
        hr = _punkSite->QueryInterface(IID_PPV_ARG(IThemeUIPages, &pThemesUIPages));
        if (SUCCEEDED(hr))
        {
            IEnumUnknown * pEnumUnknown;

            hr = pThemesUIPages->GetBasePagesEnum(&pEnumUnknown);
            if (SUCCEEDED(hr))
            {
                IUnknown * punk;

                hr = IEnumUnknown_FindCLSID(pEnumUnknown, PPID_Effects, &punk);
                if (SUCCEEDED(hr))
                {
                    IBasePropPage * pEffects;

                    hr = punk->QueryInterface(IID_PPV_ARG(IBasePropPage, &pEffects));
                    if (SUCCEEDED(hr))
                    {
                        IAdvancedDialog * pEffectsDialog;

                        hr = pEffects->GetAdvancedDialog(&pEffectsDialog);
                        if (SUCCEEDED(hr))
                        {
                            IPropertyBag * pEffectsBag;

                            hr = punk->QueryInterface(IID_PPV_ARG(IPropertyBag, &pEffectsBag));
                            if (SUCCEEDED(hr))
                            {
                                BOOL fEnableApply = FALSE;

                                IUnknown_SetSite(pEffectsDialog, SAFECAST(this, IObjectWithSite *));
                                hr = pEffectsDialog->DisplayAdvancedDialog(hDlg, pEffectsBag, &fEnableApply);
                                IUnknown_SetSite(pEffectsDialog, NULL);
                                if (SUCCEEDED(hr) && fEnableApply)
                                {
                                    EnableApplyButton(hDlg);

                                    // We pass TRUE because we want to switch to Custom if:
                                    // 1) visual styles are off, and 2) some of the system metrics changed.  Then we need to update the previews.
                                    _UpdatePreview(TRUE);
                                }

                                pEffectsBag->Release();
                            }

                            pEffectsDialog->Release();
                        }

                        pEffects->Release();
                    }

                    punk->Release();
                }

                pEnumUnknown->Release();
            }

            pThemesUIPages->Release();
        }
    }

    return hr;
}


HRESULT CBaseAppearancePage::_PopulateSchemeDropdown(void)
{
    HRESULT hr = E_FAIL;

    _FreeSchemeDropdown();    // Purge any existing items.
    if (m_pThemeManager && m_pSelectedThemeScheme)
    {
        CComBSTR bstrSelectedName;

        m_nSelectedStyle = -1;
        // This will fail if someone deleted the .msstyles file.
        if (FAILED(m_pSelectedThemeScheme->get_DisplayName(&bstrSelectedName)))
        {
            bstrSelectedName = (BSTR)NULL;
        }

        VARIANT varIndex;
#ifndef ENABLE_IA64_VISUALSTYLES
        // We use a different regkey for 64bit because we need to leave it off until the pre-Whistler
        // 64-bit release forks from the Whistler code base.
        BOOL fSkinsFeatureEnabled = SHRegGetBoolUSValue(SZ_REGKEY_APPEARANCE, SZ_REGVALUE_DISPLAYSCHEMES64, FALSE, FALSE);
#else // ENABLE_IA64_VISUALSTYLES
        BOOL fSkinsFeatureEnabled = SHRegGetBoolUSValue(SZ_REGKEY_APPEARANCE, SZ_REGVALUE_DISPLAYSCHEMES, FALSE, TRUE);
#endif // ENABLE_IA64_VISUALSTYLES

        varIndex.vt = VT_I4;
        varIndex.lVal = 0;
        do
        {
            hr = E_FAIL;

            // Only add the Skins if the policy doesn't lock it.
            if ((0 == varIndex.lVal) || fSkinsFeatureEnabled)
            {
                // Only add the Skins if the policy doesn't lock it.
                IThemeScheme * pThemeScheme;
                VARIANT varIndex2;

                varIndex2.vt = VT_I4;
                varIndex2.lVal = 0;

                // If a Theme can have more than one Scheme (Skin), then we should enum.
                hr = m_pThemeManager->get_schemeItem(varIndex, &pThemeScheme);
                if (SUCCEEDED(hr))
                {
                    CComBSTR bstrDisplayName;

                    hr = pThemeScheme->get_DisplayName(&bstrDisplayName);
                    if (SUCCEEDED(hr) && m_hwndSchemeDropDown)
                    {
                        int nAddIndex = ComboBox_AddString(m_hwndSchemeDropDown, bstrDisplayName);

                        if (-1 != nAddIndex)
                        {
                            ComboBox_SetItemData(m_hwndSchemeDropDown, nAddIndex, pThemeScheme);
                            pThemeScheme = NULL;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    ATOMICRELEASE(pThemeScheme);
                }
            }

            varIndex.lVal++;
        }
        while (SUCCEEDED(hr));

        //---- now that sorted list is built, find index of "bstrSelectedName" ----
        if (bstrSelectedName)
        {
            int nIndex = (int)ComboBox_FindStringExact(m_hwndSchemeDropDown, 0, bstrSelectedName);
            if (nIndex != -1)       // got a match
            {
                ComboBox_SetCurSel(m_hwndSchemeDropDown, nIndex);
                m_nSelectedScheme = nIndex;
            }
        }

        hr = S_OK;
    }

    if (-1 == m_nSelectedScheme)
    {
        m_nSelectedScheme = 0;
        ComboBox_SetCurSel(m_hwndSchemeDropDown, m_nSelectedScheme);
    }

    return hr;
}


HRESULT CBaseAppearancePage::_FreeSchemeDropdown(void)
{
    HRESULT hr = S_OK;
    LPARAM lParam;

    if (m_hwndSchemeDropDown)
    {
        do
        {
            lParam = ComboBox_GetItemData(m_hwndSchemeDropDown, 0);

            if (CB_ERR != lParam)
            {
                IThemeScheme * pThemeScheme = (IThemeScheme *) lParam;

                ATOMICRELEASE(pThemeScheme);
                ComboBox_DeleteString(m_hwndSchemeDropDown, 0);
            }
        }
        while (CB_ERR != lParam);
    }

    return hr;
}


HRESULT CBaseAppearancePage::_PopulateStyleDropdown(void)
{
    HRESULT hr = E_FAIL;

    _FreeStyleDropdown();    // Purge any existing items.
    if (m_pSelectedStyle)
    {
        CComBSTR bstrSelectedName;

        m_nSelectedStyle = -1;
        hr = m_pSelectedStyle->get_DisplayName(&bstrSelectedName);
        if (SUCCEEDED(hr))
        {
            VARIANT varIndex;

            varIndex.vt = VT_I4;
            varIndex.lVal = 0;
            do
            {
                // Only add the Skins if the policy doesn't lock it.
                IThemeStyle * pThemeStyle;

                hr = m_pSelectedThemeScheme->get_item(varIndex, &pThemeStyle);
                if (SUCCEEDED(hr))
                {
                    CComBSTR bstrDisplayName;

                    hr = pThemeStyle->get_DisplayName(&bstrDisplayName);
                    if (SUCCEEDED(hr) && m_hwndSchemeDropDown)
                    {
                        int nAddIndex = ComboBox_AddString(m_hwndStyleDropDown, bstrDisplayName);

                        if (-1 != nAddIndex)
                        {
                            ComboBox_SetItemData(m_hwndStyleDropDown, nAddIndex, pThemeStyle);
                            pThemeStyle = NULL;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    ATOMICRELEASE(pThemeStyle);
                }

                varIndex.lVal++;
            }
            while (SUCCEEDED(hr));
            
            //---- now that sorted list is built, find index of "bstrSelectedName" ----
            if (bstrSelectedName)
            {
                int nIndex = (int)ComboBox_FindStringExact(m_hwndStyleDropDown, 0, bstrSelectedName);
                if (nIndex != -1)       // got a match
                {
                    ComboBox_SetCurSel(m_hwndStyleDropDown, nIndex);
                    m_nSelectedStyle = nIndex;
                }
            }

            hr = S_OK;
        }
    }

    if (-1 == m_nSelectedStyle)
    {
        m_nSelectedStyle = 0;
        ComboBox_SetCurSel(m_hwndStyleDropDown, m_nSelectedStyle);
    }

    return hr;
}


HRESULT CBaseAppearancePage::_FreeStyleDropdown(void)
{
    HRESULT hr = S_OK;
    LPARAM lParam;

    if (m_hwndStyleDropDown)
    {
        do
        {
            lParam = ComboBox_GetItemData(m_hwndStyleDropDown, 0);

            if (CB_ERR != lParam)
            {
                IThemeStyle * pThemeStyle = (IThemeStyle *) lParam;

                ATOMICRELEASE(pThemeStyle);
                ComboBox_DeleteString(m_hwndStyleDropDown, 0);
            }
        }
        while (CB_ERR != lParam);
    }

    return hr;
}


HRESULT CBaseAppearancePage::_PopulateSizeDropdown(void)
{
    HRESULT hr = E_FAIL;

    _FreeSizeDropdown();    // Purge any existing items.
    if (m_pSelectedSize)
    {
        CComBSTR bstrSelectedName;

        m_nSelectedSize = -1;
        hr = m_pSelectedSize->get_DisplayName(&bstrSelectedName);
        if (SUCCEEDED(hr))
        {
            VARIANT varIndex;

            varIndex.vt = VT_I4;
            varIndex.lVal = 0;
            do
            {
                // Only add the Skins if the policy doesn't lock it.
                IThemeSize * pThemeSize;

                hr = m_pSelectedStyle->get_item(varIndex, &pThemeSize);
                if (SUCCEEDED(hr))
                {
                    CComBSTR bstrDisplayName;

                    hr = pThemeSize->get_DisplayName(&bstrDisplayName);
                    if (SUCCEEDED(hr) && m_hwndSchemeDropDown)
                    {
                        int nAddIndex = ComboBox_AddString(m_hwndSizeDropDown, bstrDisplayName);

                        if (-1 != nAddIndex)
                        {
                            ComboBox_SetItemData(m_hwndSizeDropDown, nAddIndex, pThemeSize);
                            pThemeSize = NULL;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    ATOMICRELEASE(pThemeSize);
                }

                varIndex.lVal++;
            }
            while (SUCCEEDED(hr));
            
            //---- now that sorted list is built, find index of "bstrSelectedName" ----
            if (bstrSelectedName)
            {
                int nIndex = (int)ComboBox_FindStringExact(m_hwndSizeDropDown, 0, bstrSelectedName);
                if (nIndex != -1)       // got a match
                {
                    ComboBox_SetCurSel(m_hwndSizeDropDown, nIndex);
                    m_nSelectedSize = nIndex;
                }
            }

            hr = S_OK;
        }
    }

    if (-1 == m_nSelectedSize)
    {
        m_nSelectedSize = 0;
        ComboBox_SetCurSel(m_hwndSizeDropDown, m_nSelectedSize);
    }

    return hr;
}


HRESULT CBaseAppearancePage::_FreeSizeDropdown(void)
{
    HRESULT hr = S_OK;
    LPARAM lParam;

    if (m_hwndSizeDropDown)
    {
        do
        {
            lParam = ComboBox_GetItemData(m_hwndSizeDropDown, 0);

            if (CB_ERR != lParam)
            {
                IThemeSize * pThemeSize = (IThemeSize *) lParam;

                ATOMICRELEASE(pThemeSize);
                ComboBox_DeleteString(m_hwndSizeDropDown, 0);
            }
        }
        while (CB_ERR != lParam);
    }

    return hr;
}


HRESULT CBaseAppearancePage::_OnInitAppearanceDlg(HWND hDlg)
{
    HRESULT hr = S_OK;

    _OnInitData();
    _hwnd = hDlg;

#ifdef DEBUG
    if (!SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\TaskManager"), TEXT("Enable Test Faults"), FALSE, FALSE))
    {
        // Disable the feature.
        DestroyWindow(GetDlgItem(hDlg, IDC_APPG_TESTFAULT));
    }
#endif // DEBUG

    m_hwndSchemeDropDown = GetDlgItem(hDlg, IDC_APPG_LOOKFEEL);
    m_hwndStyleDropDown = GetDlgItem(hDlg, IDC_APPG_COLORSCHEME);
    m_hwndSizeDropDown = GetDlgItem(hDlg, IDC_APPG_WNDSIZE);

    hr = _OnInitData();
    if (SUCCEEDED(hr))
    {
        hr = _PopulateSchemeDropdown();
        if (SUCCEEDED(hr))
        {
            hr = _PopulateStyleDropdown();
            if (SUCCEEDED(hr))
            {
                hr = _PopulateSizeDropdown();
                if (SUCCEEDED(hr))
                {
                    hr = _UpdatePreview(FALSE);
                }
            }
        }
    }

    TCHAR szTemp[MAX_PATH];
    DWORD dwType;
    DWORD cbSize = sizeof(szTemp);

    if (SHRestricted(REST_NOVISUALSTYLECHOICE) ||
        (ERROR_SUCCESS == SHRegGetUSValue(SZ_REGKEY_POLICIES_SYSTEM, SZ_REGVALUE_POLICY_SETVISUALSTYLE, &dwType, (void *) szTemp, &cbSize, FALSE, NULL, 0)))
    {
        EnableWindow(GetDlgItem(hDlg, IDC_APPG_LOOKFEEL_LABLE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_APPG_LOOKFEEL), FALSE);
        m_fLockVisualStylePolicyEnabled = TRUE;
        LogStatus("POLICY ENABLED: Either NoVisualChoice or SetVisualStyle policy is set, locking the visual style selection.");
    }

    if (SHRestricted(REST_NOCOLORCHOICE))
    {
        EnableWindow(GetDlgItem(hDlg, IDC_APPG_COLORSCHEME_LABLE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_APPG_COLORSCHEME), FALSE);
    }

    if (SHRestricted(REST_NOSIZECHOICE))
    {
        EnableWindow(GetDlgItem(hDlg, IDC_APPG_WNDSIZE_LABLE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_APPG_WNDSIZE), FALSE);
    }

    if (m_pszLoadMSTheme)
    {
        hr = _LoadVisaulStyleFile(m_pszLoadMSTheme);
    }

    _EnableAdvancedButton();

    return S_OK;
}


HRESULT CBaseAppearancePage::_OnInitData(void)
{
    HRESULT hr = S_OK;

    if (!m_fInitialized)
    {
        // Load DPI Value
        HDC hdc = GetDC(NULL);
        int nDefault = GetDeviceCaps(hdc, LOGPIXELSY);          // Get the default value;
        ReleaseDC(NULL, hdc);

        m_nAppliedDPI = HrRegGetDWORD(HKEY_CURRENT_USER, SZ_WINDOWMETRICS, SZ_APPLIEDDPI, DPI_PERSISTED);
        if (!m_nAppliedDPI)
        {
            m_nAppliedDPI = nDefault;
        }
        m_nNewDPI = m_nAppliedDPI;
        LogStatus("DPI: SYSTEMMETRICS currently at %d DPI  CBaseAppearancePage::_OnInitData\r\n", m_nAppliedDPI);

        // Load everything else.
        AssertMsg((NULL != _punkSite), TEXT("I need my punkSite!!!"));
        if (!m_pThemeManager && _punkSite)
        {
            hr = _punkSite->QueryInterface(IID_PPV_ARG(IThemeManager, &m_pThemeManager));
        }

        if (SUCCEEDED(hr) && !m_pSelectedThemeScheme)
        {
            hr = m_pThemeManager->get_SelectedScheme(&m_pSelectedThemeScheme);
            if (SUCCEEDED(hr) && !m_pSelectedStyle)
            {
                hr = m_pSelectedThemeScheme->get_SelectedStyle(&m_pSelectedStyle);
                if (SUCCEEDED(hr) && !m_pSelectedSize)
                {
                    hr = m_pSelectedStyle->get_SelectedSize(&m_pSelectedSize);
                    if (SUCCEEDED(hr))
                    {
                        // We want to load whatever system metrics the users have now.
                        hr = _LoadLiveSettings(SZ_SAVEGROUP_ALL);
                    }
                }
            }
        }
        m_fInitialized = TRUE;
    }

    return hr;
}


HRESULT CBaseAppearancePage::_OnDestroy(HWND hDlg)
{
    _FreeSchemeDropdown();
    _FreeStyleDropdown();
    _FreeSizeDropdown();

    return S_OK;
}


HRESULT CBaseAppearancePage::_EnableAdvancedButton(void)
{
    HRESULT hr = S_OK;
#ifdef FEATURE_ENABLE_ADVANCED_WITH_SKINSON
    BOOL fTurnOn = TRUE;
#else // FEATURE_ENABLE_ADVANCED_WITH_SKINSON
    BOOL fTurnOn = (m_pSelectedThemeScheme ? IUnknown_CompareCLSID(m_pSelectedThemeScheme, CLSID_LegacyAppearanceScheme) : FALSE);

    if (SHRegGetBoolUSValue(SZ_REGKEY_APPEARANCE, L"AlwaysAllowAdvanced", FALSE, FALSE))
    {
        fTurnOn = TRUE;
    }

#endif // FEATURE_ENABLE_ADVANCED_WITH_SKINSON
    EnableWindow(GetDlgItem(_hwnd, IDC_APPG_ADVANCED), fTurnOn);

    return hr;
}


HRESULT CBaseAppearancePage::_UpdatePreview(IN BOOL fUpdateThemePage)
{
    HRESULT hr = S_OK;

    if (!m_pThemePreview)
    {
        // We won't execute the following code if our dialog hasn't
        // been created yet.  That's fine because the preview will
        // obtain the correct state when we first initialize.
        if (_punkSite && m_hwndSchemeDropDown)
        {
            hr = CThemePreview_CreateInstance(NULL, IID_PPV_ARG(IThemePreview, &m_pThemePreview));

            if (SUCCEEDED(hr))
            {
                IPropertyBag * pPropertyBag;

                hr = _punkSite->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
                if (SUCCEEDED(hr))
                {
                    HWND hwndParent = GetParent(m_hwndSchemeDropDown);
                    HWND hwndPlaceHolder = GetDlgItem(hwndParent, IDC_APPG_APPEARPREVIEW);
                    RECT rcPreview;

                    AssertMsg((NULL != m_hwndSchemeDropDown), TEXT("We should have this window at this point.  -BryanSt"));
                    GetClientRect(hwndPlaceHolder, &rcPreview);
                    MapWindowPoints(hwndPlaceHolder, hwndParent, (LPPOINT)&rcPreview, 2);

                    if (SUCCEEDED(m_pThemePreview->CreatePreview(hwndParent, TMPREV_SHOWVS, WS_VISIBLE | WS_CHILDWINDOW | WS_BORDER | WS_OVERLAPPED, WS_EX_CLIENTEDGE, rcPreview.left, rcPreview.top, RECTWIDTH(rcPreview), RECTHEIGHT(rcPreview), pPropertyBag, IDC_APPG_APPEARPREVIEW)))
                    {
                        // If we succeeded, remove the dummy window.
                        DestroyWindow(hwndPlaceHolder);
                        hr = SHPropertyBag_WritePunk(pPropertyBag, SZ_PBPROP_PREVIEW3, m_pThemePreview);
                        if (SUCCEEDED(hr) && fUpdateThemePage)
                        {
                            // Tell the theme that we have customized the values.
                            hr = SHPropertyBag_WriteInt(pPropertyBag, SZ_PBPROP_CUSTOMIZE_THEME, 0);
                        }
                    }

                    pPropertyBag->Release();
                }
            }
        }
    }
    else if (_punkSite)
    {
        IThemeUIPages * pThemeUIPages;

        hr = _punkSite->QueryInterface(IID_PPV_ARG(IThemeUIPages, &pThemeUIPages));
        if (SUCCEEDED(hr))
        {
            hr = pThemeUIPages->UpdatePreview(0);
        }
        pThemeUIPages->Release();
    }

    if (_punkSite && fUpdateThemePage)
    {
        IPropertyBag * pPropertyBag;

        hr = _punkSite->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
        if (SUCCEEDED(hr))
        {
            // Tell the theme that we have customized the values.
            hr = SHPropertyBag_WriteInt(pPropertyBag, SZ_PBPROP_CUSTOMIZE_THEME, 0);
            pPropertyBag->Release();
        }
    }

    return hr;
}


INT_PTR CBaseAppearancePage::_OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = 1;   // Not handled (WM_COMMAND seems to be different)
    WORD idCtrl = GET_WM_COMMAND_ID(wParam, lParam);

    switch (idCtrl)
    {
        case IDC_APPG_COLORSCHEME:
            if(HIWORD(wParam) == CBN_SELCHANGE)
            {
                _OnStyleChange(hDlg);
            }
            break;

        case IDC_APPG_WNDSIZE:
            if(HIWORD(wParam) == CBN_SELCHANGE)
            {
                _OnSizeChange(hDlg);
            }
            break;

        case IDC_APPG_LOOKFEEL:
            if(HIWORD(wParam) == CBN_SELCHANGE)
            {
                _OnSchemeChange(hDlg, TRUE);    // Display Error dialogs since the user is picking the visual style.
            }
            break;

        case IDC_APPG_EFFECTS:     // This is the Effects button.
            _OnEffectsOptions(hDlg);
            break;

        case IDC_APPG_ADVANCED:     // This is the Advanced button.
            _OnAdvancedOptions(hDlg);
            break;

#ifdef DEBUG
        case IDC_APPG_TESTFAULT:
            _TestFault();
            break;
#endif // DEBUG

        default:
            break;
    }

    return fHandled;
}


HRESULT CBaseAppearancePage::_OnSchemeChange(HWND hDlg, BOOL fDisplayErrors)
{
    HRESULT hr = E_FAIL;
    int nIndex = ComboBox_GetCurSel(m_hwndSchemeDropDown);
    BOOL fPreviousSelectionIsVS = (!IUnknown_CompareCLSID(m_pSelectedThemeScheme, CLSID_LegacyAppearanceScheme));

    if (-1 == nIndex)
    {
        nIndex = 0; // The caller may NOT select nothing.
    }

    IThemeScheme * pThemeScheme = (IThemeScheme *) ComboBox_GetItemData(m_hwndSchemeDropDown, nIndex);
    m_fLoadedAdvState = FALSE;       // Forget the state we previously loaded.
    m_advDlgState.dwChanged = (METRIC_CHANGE | COLOR_CHANGE | SCHEME_CHANGE);
    PropSheet_Changed(GetParent(hDlg), hDlg);

    if (pThemeScheme)
    {
        IUnknown_Set((IUnknown **)&m_pSelectedThemeScheme, pThemeScheme);
    }

    hr = _SetScheme(TRUE, TRUE, fPreviousSelectionIsVS);
    if (FAILED(hr))
    {
        if (fDisplayErrors)
        {
            // Displaying an error dialog when the visual style is selected is very important because
            // this is where we catch parse errors in the visual style.
            hr = DisplayThemeErrorDialog(hDlg, hr, IDS_ERROR_TITLE_LOAD_MSSTYLES_FAIL, IDS_ERROR_LOAD_MSSTYLES_FAIL);
        }
    }

    _EnableAdvancedButton();

    return hr;
}


HRESULT CBaseAppearancePage::_OutsideSetScheme(BSTR bstrScheme)
{
    HRESULT hr = E_ACCESSDENIED;
 
    if (!m_fLockVisualStylePolicyEnabled)
    {
        hr = E_FAIL;
        BOOL fPreviousSelectionIsVS = !IUnknown_CompareCLSID(m_pSelectedThemeScheme, CLSID_LegacyAppearanceScheme);

        ATOMICRELEASE(m_pSelectedThemeScheme);
        if (bstrScheme && bstrScheme[0])
        {
            BOOL fVisualStylesSupported = (QueryThemeServicesWrap() & QTS_AVAILABLE);

            LogStatus("QueryThemeServices() returned %hs.  In CBaseAppearancePage::_OutsideSetScheme\r\n", (fVisualStylesSupported ? "TRUE" : "FALSE"));

            // Do not load a visual style of themes do not work.
            if (fVisualStylesSupported)
            {
                if (PathFileExists(bstrScheme))
                {
                    hr = CSkinScheme_CreateInstance(bstrScheme, &m_pSelectedThemeScheme);
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);    // Them the caller that the theme service was not running.
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE);    // Them the caller that the theme service was not running.
            }
        }
        else
        {
            hr = CAppearanceScheme_CreateInstance(NULL, IID_PPV_ARG(IThemeScheme, &m_pSelectedThemeScheme));
        }

        if (SUCCEEDED(hr))
        {
            // If we are displaying UI, update it.
            if (m_hwndSchemeDropDown)
            {
                CComBSTR bstrSelectedName;

                m_fIsDirty = TRUE;
                hr = m_pSelectedThemeScheme->get_DisplayName(&bstrSelectedName);
                if (SUCCEEDED(hr))
                {
                    int nIndex = ComboBox_FindString(m_hwndSchemeDropDown, 0, bstrSelectedName);

                    ComboBox_SetCurSel(m_hwndSchemeDropDown, nIndex);
                }
            }

            if (SUCCEEDED(hr))
            {
                hr = _SetScheme(FALSE, FALSE, fPreviousSelectionIsVS);
            }
        }
    }

    return hr;
}



/*****************************************************************************\
    DESCRIPTION:
        The caller just loaded a new value into m_pSelectedThemeScheme.  Now
    load good default values into m_pSelectedStyle and m_pSelectedSize.

      Then this is called, the UI may or may not be displayed.  Either the user made a change in
    the dropdown in this tab or the Theme page is setting our values.

    PARAMETERS:
        fLoadSystemMetrics: If true, we load the system metrics from the scheme. If false,
                we simply select that as the name for the drop down when we let the caller
                push the system metrics into us.
        fLoadLiveSettings: When the user switches from Skin->NoSkin, do we want to
                load custom settings they had before they switched?
\*****************************************************************************/
HRESULT CBaseAppearancePage::_SetScheme(IN BOOL fLoadSystemMetrics, IN BOOL fLoadLiveSettings, IN BOOL fPreviousSelectionIsVS)
{
    HRESULT hr = E_FAIL;

    if (m_pSelectedThemeScheme)
    {
        // Now that they choose a different VisualStyle (Scheme), we want to select the new Color Style
        // and Size in that Scheme.

        // will fall back to the first ColorStyle.
        CComBSTR bstrSelectedStyle;
        CComBSTR bstrSelectedSize;

        if (m_pSelectedStyle)   // This will be empty if someone deletes the current .msstyles file.
        {
            hr = m_pSelectedStyle->get_DisplayName(&bstrSelectedStyle);
        }
        if (m_pSelectedSize)
        {
            hr = m_pSelectedSize->get_DisplayName(&bstrSelectedSize);
        }

        ATOMICRELEASE(m_pSelectedStyle);
        ATOMICRELEASE(m_pSelectedSize);

        CComVariant varNameBSTR(bstrSelectedStyle);

        // We prefer to get the ColorStyle with the same name as the previously selected one.
        hr = m_pSelectedThemeScheme->get_item(varNameBSTR, &m_pSelectedStyle);
        if (FAILED(hr))
        {
            // If that failed to return a value, then we will try to get the default ColorStyle.
            hr = m_pSelectedThemeScheme->get_SelectedStyle(&m_pSelectedStyle);
            if (FAILED(hr))
            {
                // If that failed then we will just pick the first ColorStyles.  (Beggers can't be choosers)
                VARIANT varIndex;

                varIndex.vt = VT_I4;
                varIndex.lVal = 0;
                hr = m_pSelectedThemeScheme->get_item(varIndex, &m_pSelectedStyle);
            }
        }

        if (m_pSelectedStyle)
        {
            varNameBSTR = bstrSelectedSize;

            // Now we want to repeat this process with the size.
            // We prefer to get the ColorStyle with the same name as the previously selected one.
            hr = m_pSelectedStyle->get_item(varNameBSTR, &m_pSelectedSize);
            if (FAILED(hr))
            {
                // If that failed to return a value, then we will try to get the default ColorStyle.
                hr = m_pSelectedStyle->get_SelectedSize(&m_pSelectedSize);
                if (FAILED(hr))
                {
                    // If that failed then we will just pick the first ColorStyles.  (Beggers can't be choosers)
                    VARIANT varIndex;

                    varIndex.vt = VT_I4;
                    varIndex.lVal = 0;
                    hr = m_pSelectedStyle->get_item(varIndex, &m_pSelectedSize);
                }
            }
        }

        hr = _PopulateStyleDropdown();
        hr = _PopulateSizeDropdown();

        BOOL fStateLoaded = FALSE;
        BOOL fIsThemeActive = IsThemeActive();
        LogStatus("IsThemeActive() returned %hs.  In CBaseAppearancePage::_SetScheme\r\n", (fIsThemeActive ? "TRUE" : "FALSE"));

        // If the user switched from a skin to "NoSkin", then we want to load the settings from the settings
        // chosen before the user chose the skin.
        if (fIsThemeActive &&                                       // Was a skin last applied?
            fLoadLiveSettings &&                                    // Do we want to load live settings?
            IUnknown_CompareCLSID(m_pSelectedThemeScheme, CLSID_LegacyAppearanceScheme) &&  // Is the new selection a "No Skin"?
            !m_fLoadedAdvState)                                     // Have we not yet loaded these setting?
        {
            // We want to load the last set of customized settings....
            if (SUCCEEDED(_LoadLiveSettings(SZ_SAVEGROUP_NOSKIN)))
            {
                fStateLoaded = TRUE;
            }
        }

        // We don't want to load the state if the change came from the outside
        // because they will load the state themselves.
        if (fLoadSystemMetrics && !fStateLoaded)
        {
            hr = SystemMetricsAll_Load(m_pSelectedSize, &m_advDlgState, &m_nNewDPI);
            if (SUCCEEDED(hr))
            {
                m_fLoadedAdvState = TRUE;
            }
        }
        m_advDlgState.dwChanged = (METRIC_CHANGE | COLOR_CHANGE | SCHEME_CHANGE);

        if (SUCCEEDED(hr))
        {
            hr = _UpdatePreview(fLoadSystemMetrics);

            if (!fPreviousSelectionIsVS && 
                !IUnknown_CompareCLSID(m_pSelectedThemeScheme, CLSID_LegacyAppearanceScheme))
            {
                IPropertyBag * pEffectsBag;

                // Whenever we turn on a visual style and a visual style was previously off,
                // turn on "Menu Drop Shadows".
                if (SUCCEEDED(_GetPageByCLSID(&PPID_Effects, &pEffectsBag)))
                {
                    SHPropertyBag_WriteBOOL(pEffectsBag, SZ_PBPROP_EFFECTS_MENUDROPSHADOWS, VARIANT_TRUE);
                    pEffectsBag->Release();
                }
            }
        }
    }

    return hr;
}


HRESULT CBaseAppearancePage::_OnStyleChange(HWND hDlg)
{
    int nIndex = ComboBox_GetCurSel(m_hwndStyleDropDown);

    m_fLoadedAdvState = FALSE;       // Forget the state we previously loaded.
    m_advDlgState.dwChanged = (METRIC_CHANGE | COLOR_CHANGE | SCHEME_CHANGE);
    PropSheet_Changed(GetParent(hDlg), hDlg);
    if (-1 == nIndex)
    {
        nIndex = 0; // The caller may NOT select nothing.
    }

    IThemeStyle * pThemeStyle = (IThemeStyle *) ComboBox_GetItemData(m_hwndStyleDropDown, nIndex);
    AssertMsg((NULL != pThemeStyle), TEXT("We need pThemeStyle"));
    if (pThemeStyle)
    {
        IUnknown_Set((IUnknown **)&m_pSelectedStyle, pThemeStyle);
    }

    return _SetStyle(TRUE);
}


HRESULT CBaseAppearancePage::_OutsideSetStyle(BSTR bstrStyle)
{
    HRESULT hr = E_FAIL;

    AssertMsg((NULL != m_pSelectedThemeScheme), TEXT("We need m_pSelectedThemeScheme"));
    if (m_pSelectedThemeScheme)
    {
        IThemeStyle * pSelectedStyle;
        CComVariant varNameBSTR(bstrStyle);

        m_fIsDirty = TRUE;
        hr = m_pSelectedThemeScheme->get_item(varNameBSTR, &pSelectedStyle);
        if (SUCCEEDED(hr))
        {
            ATOMICRELEASE(m_pSelectedStyle);
            m_pSelectedStyle = pSelectedStyle;

            // If we are displaying UI, update it.
            if (m_hwndStyleDropDown)
            {
                CComBSTR bstrSelectedName;

                hr = m_pSelectedStyle->get_DisplayName(&bstrSelectedName);
                if (SUCCEEDED(hr))
                {
                    int nIndex = ComboBox_FindString(m_hwndStyleDropDown, 0, bstrSelectedName);

                    ComboBox_SetCurSel(m_hwndStyleDropDown, nIndex);
                }
            }

            hr = _SetStyle(FALSE);
        }
    }

    return hr;
}


HRESULT CBaseAppearancePage::_SetStyle(IN BOOL fUpdateThemePage)
{
    HRESULT hr = E_FAIL;

    AssertMsg((m_pSelectedSize && m_pSelectedSize), TEXT("We need m_pSelectedSize && m_pSelectedSize"));
    if (m_pSelectedSize && m_pSelectedSize)
    {
        // Now that they choose a different style, we want to select the new size
        // in that style.  We prefer to get the size with the same name but will
        // will fall back to the first style.
        CComBSTR bstrSelectedSize;
        hr = m_pSelectedSize->get_DisplayName(&bstrSelectedSize);
        ATOMICRELEASE(m_pSelectedSize);

        CComVariant varNameBSTR(bstrSelectedSize);
        hr = m_pSelectedStyle->get_item(varNameBSTR, &m_pSelectedSize);
        if (FAILED(hr))
        {
            VARIANT varIndex;

            varIndex.vt = VT_I4;
            varIndex.lVal = 0;
            hr = m_pSelectedStyle->get_item(varIndex, &m_pSelectedSize);
        }

        hr = _PopulateSizeDropdown();
        if (fUpdateThemePage && SUCCEEDED(SystemMetricsAll_Load(m_pSelectedSize, &m_advDlgState, &m_nNewDPI)))
        {
            m_fLoadedAdvState = TRUE;
            m_advDlgState.dwChanged = (METRIC_CHANGE | COLOR_CHANGE | SCHEME_CHANGE);
        }

        if (SUCCEEDED(hr))
        {
            hr = _UpdatePreview(fUpdateThemePage);
        }
    }

    return hr;
}




HRESULT CBaseAppearancePage::_OnSizeChange(HWND hDlg)
{
    int nIndex = ComboBox_GetCurSel(m_hwndSizeDropDown);

    PropSheet_Changed(GetParent(hDlg), hDlg);
    if (-1 == nIndex)
    {
        nIndex = 0; // The caller may NOT select nothing.
    }

    IThemeSize * pThemeSize = (IThemeSize *) ComboBox_GetItemData(m_hwndSizeDropDown, nIndex);
    AssertMsg((NULL != pThemeSize), TEXT("We need pThemeSize"));
    if (pThemeSize)
    {
        IUnknown_Set((IUnknown **)&m_pSelectedSize, pThemeSize);
    }

    return _SetSize(TRUE, TRUE);
}


HRESULT CBaseAppearancePage::_OutsideSetSize(BSTR bstrSize)
{
    HRESULT hr = E_FAIL;

    AssertMsg((m_pSelectedThemeScheme && m_pSelectedStyle), TEXT("We need m_pSelectedThemeScheme && m_pSelectedStyle"));
    if (m_pSelectedThemeScheme && m_pSelectedStyle)
    {
        IThemeSize * pSelectedSize;
        CComVariant varNameBSTR(bstrSize);

        m_fIsDirty = TRUE;
        hr = m_pSelectedStyle->get_item(varNameBSTR, &pSelectedSize);
        if (SUCCEEDED(hr))
        {
            ATOMICRELEASE(m_pSelectedSize);
            m_pSelectedSize = pSelectedSize;

            // If we are displaying UI, update it.
            if (m_hwndSizeDropDown)
            {
                CComBSTR bstrSelectedName;

                hr = m_pSelectedSize->get_DisplayName(&bstrSelectedName);
                if (SUCCEEDED(hr))
                {
                    int nIndex = ComboBox_FindString(m_hwndSizeDropDown, 0, bstrSelectedName);

                    ComboBox_SetCurSel(m_hwndSizeDropDown, nIndex);
                }
            }

            hr = _SetSize(TRUE, FALSE);
        }
    }

    return hr;
}


HRESULT CBaseAppearancePage::_SetSize(IN BOOL fLoadSystemMetrics, IN BOOL fUpdateThemePage)
{
    HRESULT hr = E_FAIL;

    AssertMsg((NULL != m_pSelectedSize), TEXT("We need m_pSelectedSize"));
    if (m_pSelectedSize)
    {
        hr = S_OK;
        
        // SystemMetricsAll_Load() will fail if m_pSelectedSize is a .msstyles file.
        if (fLoadSystemMetrics)
        {
            if (SUCCEEDED(SystemMetricsAll_Load(m_pSelectedSize, &m_advDlgState, &m_nNewDPI)))
            {
                m_fLoadedAdvState = TRUE;
                m_advDlgState.dwChanged = (METRIC_CHANGE | COLOR_CHANGE | SCHEME_CHANGE);
            }
            else
            {
                m_fLoadedAdvState = FALSE;
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = _UpdatePreview(fUpdateThemePage);
        }
    }

    return hr;
}


HRESULT CBaseAppearancePage::_GetPageByCLSID(const GUID * pClsid, IPropertyBag ** ppPropertyBag)
{
    HRESULT hr = E_FAIL;

    *ppPropertyBag = NULL;
    if (_punkSite)
    {
        IThemeUIPages * pThemeUI;

        hr = _punkSite->QueryInterface(IID_PPV_ARG(IThemeUIPages, &pThemeUI));
        if (SUCCEEDED(hr))
        {
            IEnumUnknown * pEnumUnknown;

            hr = pThemeUI->GetBasePagesEnum(&pEnumUnknown);
            if (SUCCEEDED(hr))
            {
                IUnknown * punk;

                // This may not exit due to policy
                hr = IEnumUnknown_FindCLSID(pEnumUnknown, *pClsid, &punk);
                if (SUCCEEDED(hr))
                {
                    hr = punk->QueryInterface(IID_PPV_ARG(IPropertyBag, ppPropertyBag));
                    punk->Release();
                }

                pEnumUnknown->Release();
            }

            pThemeUI->Release();
        }
    }

    return hr;
}


HRESULT CBaseAppearancePage::_OnSetActive(HWND hDlg)
{
#ifdef READ_3D_RULES_FROM_REGISTRY
    Look_Reset3DRatios();
#endif
    _LoadState();

    _EnableAdvancedButton();

    _ScaleSizesSinceDPIChanged();  // We want to update our settings if someone changed the DPI
    return S_OK;
}


HRESULT CBaseAppearancePage::_OnApply(HWND hDlg, LPARAM lParam)
{
    // Our parent dialog will be notified of the Apply event and will call our
    // IBasePropPage::OnApply() to do the real work.
    return S_OK;
}


// This Property Sheet appear in the top level of the "Display Control Panel".
INT_PTR CBaseAppearancePage::_BaseAppearanceDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;

    switch(message)
    {
    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
        {
            case PSN_SETACTIVE:
                _OnSetActive(hDlg);
                break;
            case PSN_APPLY:
                _OnApply(hDlg, lParam);
                break;

            case PSN_RESET:
                break;
        }
        break;

    case WM_INITDIALOG:
        _OnInitAppearanceDlg(hDlg);
        break;

    case WM_DESTROY:
        _OnDestroy(hDlg);
        break;

    case WM_HELP:
        WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, SZ_HELPFILE_BASEAPPEARANCE, HELP_WM_HELP, (DWORD_PTR) aBaseAppearanceHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, SZ_HELPFILE_BASEAPPEARANCE, HELP_CONTEXTMENU, (DWORD_PTR) aBaseAppearanceHelpIds);
        break;

    case WM_COMMAND:
        _OnCommand(hDlg, message, wParam, lParam);
        break;

    case WMUSER_DELAYENABLEAPPLY:
        EnableApplyButton(hDlg);
        break;
    }

    return FALSE;
}


HRESULT CBaseAppearancePage::_LoadState(void)
{
    HRESULT hr = S_OK;

    if (!m_fLoadedAdvState)
    {
        m_advDlgState.dwChanged = NO_CHANGE;

        if (m_pSelectedThemeScheme && m_pSelectedStyle && m_pSelectedSize)
        {
            hr = SystemMetricsAll_Load(m_pSelectedSize, &m_advDlgState, &m_nNewDPI);
            if (SUCCEEDED(hr))
            {
                m_fLoadedAdvState = TRUE;
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}


BOOL IsSkinScheme(IN IThemeScheme * pThemeScheme)
{
    BOOL fIsSkin = !IUnknown_CompareCLSID(pThemeScheme, CLSID_LegacyAppearanceScheme);
    return fIsSkin;
}


/*****************************************************************************\
    DESCRIPTION:
        This method will turn on or off the visual style.
\*****************************************************************************/
HRESULT CBaseAppearancePage::_ApplyScheme(IThemeScheme * pThemeScheme, IThemeStyle * pColorStyle, IThemeSize * pThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (pThemeScheme && pColorStyle && pThemeSize)
    {
        hr = pColorStyle->put_SelectedSize(pThemeSize);
        if (SUCCEEDED(hr))
        {
            hr = pThemeScheme->put_SelectedStyle(pColorStyle);
            if (SUCCEEDED(hr))
            {
                CComBSTR bstrPath;

                if (IsSkinScheme(pThemeScheme) &&
                    SUCCEEDED(hr = pThemeScheme->get_Path(&bstrPath)) &&
                    SUCCEEDED(CheckThemeSignature(bstrPath)))
                {
                    CComBSTR bstrStyle;

                    hr  = pColorStyle->get_Name(&bstrStyle);
                    if (SUCCEEDED(hr))
                    {
                        CComBSTR bstrSize;

                        hr = pThemeSize->get_Name(&bstrSize);
                        if (SUCCEEDED(hr))
                        {
                            hr = ApplyVisualStyle(bstrPath, bstrStyle, bstrSize);

                            if (FAILED(hr))
                            {
                                HWND hwndParent = NULL;

                                // We want to display UI if an error occured here.  We want to do
                                // it instead of our parent because THEMELOADPARAMS contains
                                // extra error information that we can't pass back to the caller.
                                // However, we will only display error UI if our caller wants us
                                // to.  We determine that by the fact that they make an hwnd available
                                // to us.  We get the hwnd by getting our site pointer and getting
                                // the hwnd via ::GetWindow().
                                if (_punkSite && SUCCEEDED(IUnknown_GetWindow(_punkSite, &hwndParent)))
                                {
                                    hr = DisplayThemeErrorDialog(hwndParent, hr, IDS_ERROR_TITLE_APPLYBASEAPPEARANCE, IDS_ERROR_APPLYBASEAPPEARANCE_LOADTHEME);
                                }
                            }
                        }
                    }
                }
                else
                {
                    // Unload any existing skin.
                    hr = ApplyVisualStyle(NULL, NULL, NULL);

#ifndef ENABLE_IA64_VISUALSTYLES
                    // We don't support themes on non-x86 don't ignore the error value.
                    hr = S_OK;
#endif // ENABLE_IA64_VISUALSTYLES
                }

                IPropertyBag * pPropertyBag;

                if (SUCCEEDED(pThemeSize->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag))))
                {
                    TCHAR szLegacyName[MAX_PATH];

                    // Here, we need to update a regkey with the selected legacy name. That way we can tell if
                    // 3rd party UI or downlevel OSs change the Win2k "Appearance Scheme".  If they do, uxtheme (LMouton)
                    // will disable visual styles on the next login.  This will make sure we don't get someone else's
                    // NONCLIENTMETRICS and our visual style.
                    if (FAILED(SHPropertyBag_ReadStr(pPropertyBag, SZ_PBPROP_COLORSCHEME_LEGACYNAME, szLegacyName, ARRAYSIZE(szLegacyName))))
                    {
                        szLegacyName[0] = 0;
                    }

                    HrRegSetValueString(HKEY_CURRENT_USER, SZ_REGKEY_APPEARANCE, THEMEPROP_NEWCURRSCHEME, szLegacyName);
                    HrRegSetValueString(HKEY_CURRENT_USER, SZ_REGKEY_APPEARANCE, SZ_REGVALUE_CURRENT, szLegacyName);
                    pPropertyBag->Release();
                }
            }
        }
    }

    return hr;
}



HRESULT CBaseAppearancePage::_SaveState(CDimmedWindow* pDimmedWindow)
{
    HRESULT hr = S_OK;

    BOOL fIsSkinApplied = IsThemeActive();      // This will keep track if a skin was applied before this apply action.
    LogStatus("IsThemeActive() returned %hs in CBaseAppearancePage::_SaveState.\r\n", (fIsSkinApplied ? "TRUE" : "FALSE"));

    // If we are switching from NoSkin->Skin, we want to save the live settings before
    // we turn on the skin (now & here).  We do this so we can reload these settings
    // if the user turns Skins off later.  This acts like a "Custom" settings option.
    if (!fIsSkinApplied && !IUnknown_CompareCLSID(m_pSelectedThemeScheme, CLSID_LegacyAppearanceScheme))
    {
        hr = _SaveLiveSettings(SZ_SAVEGROUP_NOSKIN);        // If we are switching from "NoSkin" to "Skin", we want to save the custom settings now.
    }

    hr = _ApplyScheme(m_pSelectedThemeScheme, m_pSelectedStyle, m_pSelectedSize);
    if (SUCCEEDED(hr))
    {
        m_nSelectedScheme = ComboBox_GetCurSel(m_hwndSchemeDropDown);
        m_nSelectedStyle = ComboBox_GetCurSel(m_hwndStyleDropDown);
        m_nSelectedSize = ComboBox_GetCurSel(m_hwndSizeDropDown);
    }

    if (SUCCEEDED(hr))
    {
        // Here we save the settings no matter which direction we are going.  These
        // settings will be loaded when the Display Control Panel is opened next time.
        hr = _SaveLiveSettings(SZ_SAVEGROUP_ALL);
    }

    // We normally want the call to IThemeManager->put_SelectedScheme() to not only 
    // store the selection but to also update the live system metrics.  We special case
    // the Legacy "Appearance Schemes" because the user could have customized the
    // settings in the Advanced Appearance dialog.  If they did, then m_advDlgState.dwChanged
    // will have dirty bits set and we need to apply that state ourselves.
    if (m_advDlgState.dwChanged)
    {
        hr = SystemMetricsAll_Set(&m_advDlgState, pDimmedWindow);
        LogSystemMetrics("CBaseAppearancePage::_SaveState() pushing to live", &m_advDlgState);
    }

    if (SUCCEEDED(hr))
    {
        m_advDlgState.dwChanged = NO_CHANGE;
        m_fIsDirty = FALSE;
    }

    return hr;
}


// If we are switching from "NoSkin" to "Skin", we want to save the custom settings now.
HRESULT CBaseAppearancePage::_LoadLiveSettings(IN LPCWSTR pszSaveGroup)
{
    HRESULT hr = S_OK;

    if (!m_fLoadedAdvState)
    {
#ifndef FEATURE_SAVECUSTOM_APPEARANCE
        if (!StrCmpI(pszSaveGroup, SZ_SAVEGROUP_ALL))
        {
            SystemMetricsAll_Get(&m_advDlgState);
            LogSystemMetrics("LOADING SYSMETRICS: ", &m_advDlgState);
            m_fLoadedAdvState = TRUE;
        }
        else
        {
            hr = E_FAIL;        // The caller needs to get their own system metrics.
        }

#else // FEATURE_SAVECUSTOM_APPEARANCE
        AssertMsg((NULL != m_pSelectedThemeScheme), TEXT("_LoadLiveSettings() can't get it's job done without m_pSelectedThemeScheme"));
        if (m_pSelectedThemeScheme)
        {
            IThemeScheme * pThemeScheme;

            hr = CAppearanceScheme_CreateInstance(NULL, IID_PPV_ARG(IThemeScheme, &pThemeScheme));
            if (SUCCEEDED(hr))
            {
                CComVariant varCurrentNameBSTR(pszSaveGroup);
                IThemeStyle * pSelectedStyle;

                // The next call may fail because we may have never saved the settings yet.
                hr = pThemeScheme->get_item(varCurrentNameBSTR, &pSelectedStyle);
                if (FAILED(hr))
                {
                    // So, let's save the settings now.
                    hr = _SaveLiveSettings(pszSaveGroup);
                    if (SUCCEEDED(hr))
                    {
                        hr = m_pSelectedThemeScheme->get_item(varCurrentNameBSTR, &pSelectedStyle);
                    }
                }

                if (SUCCEEDED(hr))
                {
                    IThemeSize * pSelectedSize;
                    VARIANT varIndex;

                    varIndex.vt = VT_I4;
                    varIndex.lVal = 0;
                    hr = pSelectedStyle->get_item(varIndex, &pSelectedSize);

                    if (FAILED(hr))
                    {
                        HKEY hKeyTemp;

                        if (SUCCEEDED(HrRegOpenKeyEx(HKEY_CURRENT_USER, SZ_REGKEY_UPGRADE_KEY, 0, KEY_READ, &hKeyTemp)))
                        {
                            RegCloseKey(hKeyTemp);
                        }
                        else
                        {
                            // If this happens, we may not have saved the previous settings.  So do that now
                            // and retry.
                            _SaveLiveSettings(pszSaveGroup);
                            hr = pSelectedStyle->get_item(varIndex, &pSelectedSize);
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        if (SUCCEEDED(SystemMetricsAll_Load(pSelectedSize, &m_advDlgState, &m_nNewDPI)))
                        {
                            LogSystemMetrics("LOADING SYSMETRICS: ", &m_advDlgState);
                            m_fLoadedAdvState = TRUE;
                        }

                        pSelectedSize->Release();
                    }

                    pSelectedStyle->Release();
                }

                pThemeScheme->Release();
            }
        }
        else
        {
            hr = E_FAIL;
        }
#endif // FEATURE_SAVECUSTOM_APPEARANCE
    }

    return hr;
}


HRESULT CBaseAppearancePage::_SaveLiveSettings(IN LPCWSTR pszSaveGroup)
{
    HRESULT hr = S_OK;

    // Now, get the current (possibly custom) settings and save them.
    SYSTEMMETRICSALL state = {0};

    hr = SystemMetricsAll_Get(&state);
    if (SUCCEEDED(hr))
    {
        IThemeScheme * pThemeScheme;

        LogSystemMetrics("CBaseAppearancePage::_SaveLiveSettings() getting live", &state);
        hr = CAppearanceScheme_CreateInstance(NULL, IID_PPV_ARG(IThemeScheme, &pThemeScheme));
        if (SUCCEEDED(hr))
        {
            CComVariant varCurrentNameBSTR(pszSaveGroup);        // The "Customized Live" item
            IThemeStyle * pSelectedStyle;

            hr = pThemeScheme->get_item(varCurrentNameBSTR, &pSelectedStyle);
            if (SUCCEEDED(hr))
            {
                IThemeSize * pSelectedSize;
                VARIANT varIndex;

                varIndex.vt = VT_I4;
                varIndex.lVal = 0;
                hr = pSelectedStyle->get_item(varIndex, &pSelectedSize);
                if (FAILED(hr))
                {
                    hr = pSelectedStyle->AddSize(&pSelectedSize);
                }

                if (SUCCEEDED(hr))
                {
                    hr = SystemMetricsAll_Save(&state, pSelectedSize, &m_nNewDPI);
                    
                    CHAR szTemp[MAX_PATH];
                    wnsprintfA(szTemp, ARRAYSIZE(szTemp), "CBaseAppearancePage::_SaveLiveSettings() Grp=\"%ls\", new DPI=%d", pszSaveGroup, m_nNewDPI);
                    LogSystemMetrics(szTemp, &state);

                    pSelectedSize->Release();
                }

                pSelectedStyle->Release();
            }

            pThemeScheme->Release();
        }
    }

    return hr;
}


HRESULT CBaseAppearancePage::_LoadVisaulStyleFile(IN LPCWSTR pszPath)
{
    HRESULT hr = E_FAIL;

    if (SUCCEEDED(CheckThemeSignature(pszPath)))
    {
        // Now we want to:
        int nSlot = -1;
        int nCount = ComboBox_GetCount(m_hwndSchemeDropDown);

        hr = S_OK;

        // 1. Is it in the list already?
        for (int nIndex = 0; nIndex < nCount; nIndex++)
        {
            IThemeScheme * pThemeScheme = (IThemeScheme *) ComboBox_GetItemData(m_hwndSchemeDropDown, nIndex);

            if (pThemeScheme)
            {
                CComBSTR bstrPath;

                hr = pThemeScheme->get_Path(&bstrPath);
                if (SUCCEEDED(hr))
                {
                    if (!StrCmpIW(bstrPath, pszPath))
                    {
                        bstrPath.Empty();
                        // We found it, so stop looking.
                        nSlot = nIndex;
                        break;
                    }
                }
            }
        }

        // 2. If it is not in the list, add it.  We put it on the bottom, right above "Other...".
        if (-1 == nSlot)
        {
            IThemeScheme * pThemeSchemeNew;

            hr = CSkinScheme_CreateInstance(pszPath, &pThemeSchemeNew);
            if (SUCCEEDED(hr))
            {
                CComBSTR bstrDisplayName;

                hr = pThemeSchemeNew->get_DisplayName(&bstrDisplayName);
                if (SUCCEEDED(hr))
                {
                    nIndex = ComboBox_GetCount(m_hwndSchemeDropDown);

                    if (nIndex > 1)
                    {
                        nIndex -= 1;
                    }

                    nSlot = nIndex = ComboBox_InsertString(m_hwndSchemeDropDown, nIndex, bstrDisplayName);
                    if ((CB_ERR != nIndex) && (CB_ERRSPACE != nIndex))
                    {
                        if (CB_ERR == ComboBox_SetItemData(m_hwndSchemeDropDown, nIndex, pThemeSchemeNew))
                        {
                            hr = E_FAIL;
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }

                if (FAILED(hr))
                {
                    pThemeSchemeNew->Release();
                }
            }
        }

        if (-1 != nSlot)
        {
            ComboBox_SetCurSel(m_hwndSchemeDropDown, nIndex);

            // 3. Select the theme from the list.
            if (CB_ERR != ComboBox_GetItemData(m_hwndSchemeDropDown, ComboBox_GetCurSel(m_hwndSchemeDropDown)))
            {
                // Okay, we now know we won't recurse infinitely, so let's recurse.
                hr = _OnSchemeChange(_hwnd, FALSE);     // FALSE means don't display error dialogs
                if (SUCCEEDED(hr))
                {
                    // Since this happens during WM_INITDIALOG, we need to delay enabling the Apply button.
                    DelayEnableApplyButton(_hwnd);
                }
            }
            else
            {
                hr = E_FAIL;
                AssertMsg(0, TEXT("We should have correctly selected the item.  Please investiate.  -BryanSt"));
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}



//===========================
// *** IObjectWithSite Interface ***
//===========================
HRESULT CBaseAppearancePage::SetSite(IN IUnknown *punkSite)
{
    if (!punkSite)
    {
        ATOMICRELEASE(m_pThemeManager);     // This is a copy of our _punkSite and we need to break the cycle.
    }

    HRESULT hr = CObjectWithSite::SetSite(punkSite);
    if (punkSite)
    {
        // Load the defaults so we will have them if another base tab opens the advanced dlg.
        _OnInitData();
    }
    return hr;
}



//===========================
// *** IPreviewSystemMetrics Interface ***
//===========================
HRESULT CBaseAppearancePage::RefreshColors(void)
{
    UINT i;
    HKEY hk;
    TCHAR szColor[15];
    DWORD dwSize, dwType;
    int iColors[COLOR_MAX];
    COLORREF rgbColors[COLOR_MAX];

    // Open the Colors key in the registry
    if (RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_COLORS, 0, KEY_READ, &hk) != ERROR_SUCCESS)
    {
       return S_OK;
    }

    // Query for the color information
    for (i = 0; i < ARRAYSIZE(s_pszColorNames); i++)
    {
        dwSize = 15 * sizeof(TCHAR);

        if ((RegQueryValueEx(hk, s_pszColorNames[i], NULL, &dwType, (LPBYTE) szColor, &dwSize) == ERROR_SUCCESS) &&
            (REG_SZ == dwType))
        {
            m_advDlgState.schemeData.rgb[i] = ConvertColor(szColor);
        }
        else
        {
            m_advDlgState.schemeData.rgb[i] = GetSysColor(i);
        }
    }

    RegCloseKey(hk);

    // This call causes user to send a WM_SYSCOLORCHANGE
    for (i=0; i < ARRAYSIZE(rgbColors); i++)
    {
        iColors[i] = i;
        rgbColors[i] = m_advDlgState.schemeData.rgb[i] & 0x00FFFFFF;
    }

    SetSysColors(ARRAYSIZE(rgbColors), iColors, rgbColors);
    return S_OK;
}


// When another tab in the Display Control Panel changes the DPI, this tab needs
// to update any state that was based on the old DPI.  For us, this could be
// the cached data in m_advDlgState.
HRESULT CBaseAppearancePage::_ScaleSizesSinceDPIChanged(void)
{
    HRESULT hr = _LoadState();

    //Check if the DPI value has really changed since the last time we applied a DPI change.
    if (SUCCEEDED(hr) && (m_nNewDPI != m_nAppliedDPI))
    {
        CHAR szTemp[MAX_PATH];

        wnsprintfA(szTemp, ARRAYSIZE(szTemp), "CBaseAppear::_ScaleSizesSinceDPIChanged() BEFORE Apply(%d)->New(%d) on DPI chang", m_nAppliedDPI, m_nNewDPI);
        LogSystemMetrics(szTemp, &m_advDlgState);

        // Cycle through all the UI fonts and change their sizes.
        DPIConvert_SystemMetricsAll(FALSE, &m_advDlgState, m_nAppliedDPI, m_nNewDPI);

        wnsprintfA(szTemp, ARRAYSIZE(szTemp), "CBaseAppear::_ScaleSizesSinceDPIChanged() AFTER Apply(%d)->New(%d) on DPI chang", m_nAppliedDPI, m_nNewDPI);
        LogSystemMetrics(szTemp, &m_advDlgState);

        m_nAppliedDPI = m_nNewDPI;
        m_fIsDirty = TRUE;
        m_advDlgState.dwChanged = (METRIC_CHANGE | COLOR_CHANGE | SCHEME_CHANGE);
        _UpdatePreview(FALSE);
    }

    return hr;
}


HRESULT CBaseAppearancePage::UpdateCharsetChanges(void)
{
    return FixFontsOnLanguageChange();
}


/**************************************************************\
    DESCRIPTION:
        We shipped this API long ago.  The goal is to:
    1. Set the current "Appearance Scheme".
    2. If the UI is displayed, update the UI.
    3. Apply the changes.
\**************************************************************/
HRESULT CBaseAppearancePage::DeskSetCurrentScheme(IN LPCWSTR pwzSchemeName)
{
    int nIndex;
    HRESULT hr = E_INVALIDARG;

    if (pwzSchemeName)
    {
        TCHAR szTemp[MAX_PATH];

        if (!pwzSchemeName[0])
        {
            if (LoadString(HINST_THISDLL, IDS_DEFAULT_APPEARANCES_SCHEME, szTemp, ARRAYSIZE(szTemp)))
            {
                pwzSchemeName = szTemp;
            }
        }

        LoadConversionMappings();   // Load theme if needed.
        hr = MapLegacyAppearanceSchemeToIndex(pwzSchemeName, &nIndex);        // Failure means, FALSE, we didn't convert.
        if (SUCCEEDED(hr) && _punkSite)
        {
            IThemeManager * pThemeManager;

            hr = _punkSite->QueryInterface(IID_PPV_ARG(IThemeManager, &pThemeManager));
            if (SUCCEEDED(hr))
            {
                hr = InstallVisualStyle(pThemeManager, L"", g_UpgradeMapping[nIndex].szNewColorSchemeName, g_UpgradeMapping[nIndex].szNewSizeName);
                if (SUCCEEDED(hr))
                {
                    // This ApplyNow() call will take a little while in normal situation (~10-20 seconds) in order
                    // to broadcast the message to all open apps.  If a top level window is hung, it may take the
                    // full 30 seconds to timeout.
                    hr = pThemeManager->ApplyNow();

                    // We need to delete the "Live settings" because they are no longer valid.
                    SHDeleteKey(HKEY_CURRENT_USER, SZ_SAVEGROUP_NOSKIN_KEY);
                    SHDeleteKey(HKEY_CURRENT_USER, SZ_SAVEGROUP_ALL_KEY);
                }

                IUnknown_SetSite(pThemeManager, NULL);      // Break the ref-count cycle.
                pThemeManager->Release();
            }
        }
    }

    LogStatus("DeskSetCurrentScheme(\"%ls\") returned hr=%#08lx.\r\n", pwzSchemeName, hr);
    return hr;
}





//===========================
// *** IPropertyBag Interface ***
//===========================
HRESULT CBaseAppearancePage::Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog)
{
    HRESULT hr = E_INVALIDARG;

    _OnInitData();
    if (pszPropName && pVar)
    {
        if (!StrCmpW(pszPropName, SZ_PBPROP_VISUALSTYLE_PATH) && m_pSelectedThemeScheme)
        {
            CComBSTR bstrPath;

            hr = m_pSelectedThemeScheme->get_Path(&bstrPath);
            if (FAILED(hr))
            {
                bstrPath = L"";
                hr = S_OK;          // We return an empty string for "Windows Classic" since they ask for the path.
            }

            pVar->vt = VT_BSTR;
            hr = HrSysAllocString(bstrPath, &pVar->bstrVal);
        }
        else if (!StrCmpW(pszPropName, SZ_PBPROP_VISUALSTYLE_COLOR) && m_pSelectedStyle)
        {
            CComBSTR bstrName;

            hr = m_pSelectedStyle->get_Name(&bstrName);
            if (SUCCEEDED(hr))
            {
                pVar->vt = VT_BSTR;
                hr = HrSysAllocString(bstrName, &pVar->bstrVal);
            }
        }
        else if (!StrCmpW(pszPropName, SZ_PBPROP_VISUALSTYLE_SIZE) && m_pSelectedSize)
        {
            CComBSTR bstrName;

            hr = m_pSelectedSize->get_Name(&bstrName);
            if (SUCCEEDED(hr))
            {
                pVar->vt = VT_BSTR;
                hr = HrSysAllocString(bstrName, &pVar->bstrVal);
            }
        }
        else if (!StrCmpW(pszPropName, SZ_PBPROP_SYSTEM_METRICS))
        {
            hr = _LoadState();

            // This is pretty ugly.
            pVar->vt = VT_BYREF;
            pVar->byref = &m_advDlgState;
        }
        else if (!StrCmpW(pszPropName, SZ_PBPROP_BACKGROUND_COLOR))
        {
            hr = _LoadState();

            // This is pretty ugly.
            pVar->vt = VT_UI4;
            pVar->ulVal = m_advDlgState.schemeData.rgb[COLOR_BACKGROUND];
        }
        else if (!StrCmpW(pszPropName, SZ_PBPROP_DPI_MODIFIED_VALUE))
        {
            pVar->vt = VT_I4;
            pVar->lVal = m_nNewDPI;
            hr = S_OK;
        }
        else if (!StrCmpW(pszPropName, SZ_PBPROP_DPI_APPLIED_VALUE))
        {
            pVar->vt = VT_I4;
            pVar->lVal = m_nAppliedDPI;
            hr = S_OK;
        }
    }

    return hr;
}


HRESULT CBaseAppearancePage::Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar)
{
    HRESULT hr = E_INVALIDARG;

    _OnInitData();
    if (pszPropName && pVar)
    {
        if (VT_BSTR == pVar->vt)
        {
            if (!StrCmpW(pszPropName, SZ_PBPROP_VISUALSTYLE_PATH))
            {
                hr = _OutsideSetScheme(pVar->bstrVal);
            }
            else if (!StrCmpW(pszPropName, SZ_PBPROP_VISUALSTYLE_COLOR))
            {
                hr = _OutsideSetStyle(pVar->bstrVal);
            }
            else if (!StrCmpW(pszPropName, SZ_PBPROP_VISUALSTYLE_SIZE))
            {
                hr = _OutsideSetSize(pVar->bstrVal);
            }
        }
        else if ((VT_BYREF == pVar->vt) && pVar->byref)
        {
            if (!StrCmpW(pszPropName, SZ_PBPROP_SYSTEM_METRICS))
            {
                hr = S_OK;
                if (!m_fLoadedAdvState)
                {
                    AssertMsg((NULL != m_pSelectedSize), TEXT("m_pSelectedSize should have already been loaded by now or we shouldn't be showing the Adv Appearance page. -BryanSt"));
                    hr = SystemMetricsAll_Load(m_pSelectedSize, &m_advDlgState, &m_nNewDPI);
                    if (SUCCEEDED(hr))
                    {
                        m_fLoadedAdvState = TRUE;
                    }
                }

                SystemMetricsAll_Copy((SYSTEMMETRICSALL *) pVar->byref, &m_advDlgState);
                m_fIsDirty = TRUE;
                m_advDlgState.dwChanged = (METRIC_CHANGE | COLOR_CHANGE | SCHEME_CHANGE);
            }
        }
        else if ((VT_UI4 == pVar->vt) &&
            !StrCmpW(pszPropName, SZ_PBPROP_BACKGROUND_COLOR))
        {
            hr = S_OK;
            if (!m_fLoadedAdvState)
            {
                AssertMsg((NULL != m_pSelectedSize), TEXT("m_pSelectedSize should have already been loaded by now or we shouldn't be showing the Adv Appearance page. -BryanSt"));
                hr = SystemMetricsAll_Load(m_pSelectedSize, &m_advDlgState, &m_nNewDPI);
                if (SUCCEEDED(hr))
                {
                    m_fLoadedAdvState = TRUE;
                }
            }

            // This is pretty ugly.
            m_advDlgState.schemeData.rgb[COLOR_BACKGROUND] = pVar->ulVal;
            m_fIsDirty = TRUE;
            m_advDlgState.dwChanged = (METRIC_CHANGE | COLOR_CHANGE | SCHEME_CHANGE);
        }
        else if ((VT_LPWSTR == pVar->vt) &&
            !StrCmpW(pszPropName, SZ_PBPROP_APPEARANCE_LAUNCHMSTHEME))
        {
            Str_SetPtrW(&m_pszLoadMSTheme, pVar->bstrVal);
            hr = S_OK;
        }
        else if (VT_I4 == pVar->vt)
        {
            if (!StrCmpW(pszPropName, SZ_PBPROP_DPI_MODIFIED_VALUE))
            {
                m_nNewDPI = pVar->lVal;
                hr = _ScaleSizesSinceDPIChanged(); // Scale all the values.
            }
            else if (!StrCmpW(pszPropName, SZ_PBPROP_DPI_APPLIED_VALUE))
            {
                m_nAppliedDPI = pVar->lVal;
                hr = S_OK;
            }
        }
    }

    return hr;
}


//===========================
// *** IBasePropPage Interface ***
//===========================
HRESULT CBaseAppearancePage::GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog)
{
    HRESULT hr = E_INVALIDARG;

    if (ppAdvDialog)
    {
        *ppAdvDialog = NULL;
        hr = _LoadState();
        if (SUCCEEDED(hr))
        {
            _ScaleSizesSinceDPIChanged();  // We want to update our settings if someone changed the DPI
            hr = CAdvAppearancePage_CreateInstance(ppAdvDialog, &m_advDlgState);
        }
    }

    return hr;
}


HRESULT CBaseAppearancePage::OnApply(IN PROPPAGEONAPPLY oaAction)
{
    HRESULT hr = S_OK;

    if (PPOAACTION_CANCEL != oaAction)
    {
        HCURSOR old = SetCursor(LoadCursor(NULL, IDC_WAIT));

        if (_IsDirty())
        {
            //Check to see if there is a change in the DPI value due to "Advanced->General" tab.
            _ScaleSizesSinceDPIChanged();
            // Update the "AppliedDPI" value in the registry.
            HrRegSetDWORD(HKEY_CURRENT_USER, SZ_WINDOWMETRICS, SZ_APPLIEDDPI, m_nNewDPI);
            LogStatus("DPI: SYSTEMMETRICS saved at %d DPI  CBaseAppearancePage::OnApply\r\n", m_nNewDPI);

            CDimmedWindow* pDimmedWindow = NULL;
            if (!g_fInSetup)
            {
                pDimmedWindow = new CDimmedWindow(HINST_THISDLL);
                if (pDimmedWindow)
                {
                    pDimmedWindow->Create(30000);
                }
            }

            hr = _SaveState(pDimmedWindow);

            if (pDimmedWindow)
            {
                pDimmedWindow->Release();
            }

            if (FAILED(hr) && !g_fInSetup && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr))
            {
                // We want to display UI here.  Especially if we fail.
                HWND hwndParent = GetParent(m_hwndSchemeDropDown);
                WCHAR szTitle[MAX_PATH];

                LoadString(HINST_THISDLL, IDS_ERROR_TITLE_APPLYBASEAPPEARANCE2, szTitle, ARRAYSIZE(szTitle));
                ErrorMessageBox(hwndParent, szTitle, IDS_ERROR_APPLYBASEAPPEARANCE, hr, NULL, (MB_OK | MB_ICONEXCLAMATION));

                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            }
        }

        SetCursor(old);
    }

    if (PPOAACTION_OK == oaAction)
    {
    }
    
    return hr;
}




//===========================
// *** IShellPropSheetExt Interface ***
//===========================
HRESULT CBaseAppearancePage::AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam)
{
    HRESULT hr = E_INVALIDARG;
    PROPSHEETPAGE psp = {0};

    psp.dwSize = sizeof(psp);
    psp.hInstance = HINST_THISDLL;
    psp.dwFlags = PSP_DEFAULT;
    psp.lParam = (LPARAM) this;

    psp.pszTemplate = MAKEINTRESOURCE(DLG_APPEARANCEPG);
    psp.pfnDlgProc = CBaseAppearancePage::BaseAppearanceDlgProc;

    HPROPSHEETPAGE hpsp = CreatePropertySheetPage(&psp);
    if (hpsp)
    {
        if (pfnAddPage(hpsp, lParam))
        {
            hr = S_OK;
        }
        else
        {
            DestroyPropertySheetPage(hpsp);
            hr = E_FAIL;
        }
    }

    return hr;
}




//===========================
// *** IUnknown Interface ***
//===========================
ULONG CBaseAppearancePage::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CBaseAppearancePage::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CBaseAppearancePage::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CBaseAppearancePage, IObjectWithSite),
        QITABENT(CBaseAppearancePage, IOleWindow),
        QITABENT(CBaseAppearancePage, IPersist),
        QITABENT(CBaseAppearancePage, IPropertyBag),
        QITABENT(CBaseAppearancePage, IPreviewSystemMetrics),
        QITABENT(CBaseAppearancePage, IBasePropPage),
        QITABENTMULTI(CBaseAppearancePage, IShellPropSheetExt, IBasePropPage),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CBaseAppearancePage::CBaseAppearancePage() : m_cRef(1), CObjectCLSID(&PPID_BaseAppearance)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pThemeManager);
    ASSERT(!m_pSelectedThemeScheme);
    ASSERT(!m_pSelectedStyle);
    ASSERT(!m_pSelectedSize);
    ASSERT(!m_hwndSchemeDropDown);
    ASSERT(!m_hwndStyleDropDown);
    ASSERT(!m_hwndSizeDropDown);
    ASSERT(!m_pThemePreview);
    ASSERT(!m_fIsDirty);

    m_fInitialized = FALSE;
}


CBaseAppearancePage::~CBaseAppearancePage()
{
    Str_SetPtrW(&m_pszLoadMSTheme, NULL);

    ATOMICRELEASE(m_pThemeManager);
    ATOMICRELEASE(m_pSelectedThemeScheme);
    ATOMICRELEASE(m_pSelectedStyle);
    ATOMICRELEASE(m_pSelectedSize);
    ATOMICRELEASE(m_pThemePreview);

    DllRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\appsize.h ===
/*****************************************************************************\
    FILE: appSize.h

    DESCRIPTION:
        This is the Autmation Object to theme scheme object.

    BryanSt 4/3/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _FILE_H_APPSIZE
#define _FILE_H_APPSIZE

#include <cowsite.h>
#include <atlbase.h>
#include <theme.h>



HRESULT CAppearanceSize_CreateInstance(IN HKEY hkeyStyle, IN HKEY hkeySize, OUT IThemeSize ** ppThemeSize);


class CAppearanceSize           : public CImpIDispatch
                                , public IThemeSize
                                , public IPropertyBag
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IThemeSize ***
    virtual STDMETHODIMP get_DisplayName(OUT BSTR * pbstrDisplayName);
    virtual STDMETHODIMP put_DisplayName(IN BSTR bstrDisplayName);
    virtual STDMETHODIMP get_Name(OUT BSTR * pbstrName);
    virtual STDMETHODIMP put_Name(IN BSTR bstrName);
    virtual STDMETHODIMP get_SystemMetricColor(IN int nSysColorIndex, OUT COLORREF * pColorRef);
    virtual STDMETHODIMP put_SystemMetricColor(IN int nSysColorIndex, IN COLORREF ColorRef);
    virtual STDMETHODIMP get_SystemMetricSize(IN enumSystemMetricSize nSystemMetricIndex, OUT int * pnSize);
    virtual STDMETHODIMP put_SystemMetricSize(IN enumSystemMetricSize nSystemMetricIndex, IN int nSize);
    virtual STDMETHODIMP get_WebviewCSS(OUT BSTR * pbstrPath);
    virtual STDMETHODIMP get_ContrastLevel(OUT enumThemeContrastLevels * pContrastLevel);
    virtual STDMETHODIMP put_ContrastLevel(IN enumThemeContrastLevels ContrastLevel);
    virtual STDMETHODIMP GetSystemMetricFont(IN enumSystemMetricFont nSPIFontIndex, IN LOGFONTW * pParamW);
    virtual STDMETHODIMP PutSystemMetricFont(IN enumSystemMetricFont nSPIFontIndex, IN LOGFONTW * pParamW);

    // *** IPropertyBag ***
    virtual STDMETHODIMP Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog);
    virtual STDMETHODIMP Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar);

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

private:
    CAppearanceSize(IN HKEY hkeyStyle, IN HKEY hkeySize);
    virtual ~CAppearanceSize(void);


    // Private Member Variables
    long                    m_cRef;

    HKEY                    m_hkeyStyle;
    HKEY                    m_hkeySize;


    // Private Methods

    // Friend Functions
    friend HRESULT CAppearanceSize_CreateInstance(IN HKEY hkeyStyle, IN HKEY hkeySize, OUT IThemeSize ** ppThemeSize);
};


#endif // _FILE_H_APPSIZE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\appstyle.h ===
/*****************************************************************************\
    FILE: appStyle.h

    DESCRIPTION:
        This is the Autmation Object to theme scheme object.

    BryanSt 4/3/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _FILE_H_APPSTYLE
#define _FILE_H_APPSTYLE

#include <cowsite.h>
#include <atlbase.h>



HRESULT CAppearanceStyle_CreateInstance(IN HKEY hkeyStyle, OUT IThemeStyle ** ppThemeStyle);


class CAppearanceStyle          : public CImpIDispatch
                                , public IThemeStyle
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IThemeStyle ***
    virtual STDMETHODIMP get_DisplayName(OUT BSTR * pbstrDisplayName);
    virtual STDMETHODIMP put_DisplayName(IN BSTR bstrDisplayName);
    virtual STDMETHODIMP get_Name(OUT BSTR * pbstrName);
    virtual STDMETHODIMP put_Name(IN BSTR bstrName);
    virtual STDMETHODIMP get_length(OUT long * pnLength);
    virtual STDMETHODIMP get_item(IN VARIANT varIndex, OUT IThemeSize ** ppThemeSize);
    virtual STDMETHODIMP get_SelectedSize(OUT IThemeSize ** ppThemeSize);
    virtual STDMETHODIMP put_SelectedSize(IN IThemeSize * pThemeSize);
    virtual STDMETHODIMP AddSize(OUT IThemeSize ** ppThemeSize);

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

private:
    CAppearanceStyle(IN HKEY hkeyStyle);
    virtual ~CAppearanceStyle(void);


    // Private Member Variables
    long                    m_cRef;

    HKEY                    m_hKeyStyle;


    // Private Member Functions
    HRESULT _getSizeByIndex(IN long nIndex, OUT IThemeSize ** ppThemeSize);

    // Friend Functions
    friend HRESULT CAppearanceStyle_CreateInstance(IN HKEY hkeyStyle, OUT IThemeStyle ** ppThemeStyle);
};


#endif // _FILE_H_APPSTYLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\baseappearpg.h ===
/*****************************************************************************\
    FILE: BaseAppearPg.h

    DESCRIPTION:
        This code will display a "Appearances" tab in the
    "Display Properties" dialog (the base dialog, not the advanced dlg).

    ??????? ?/??/1993    Created
    BryanSt 3/23/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 1993-2000. All rights reserved.
\*****************************************************************************/

#ifndef _BASEAPPEAR_H
#define _BASEAPPEAR_H

#include <cowsite.h>
#include "PreviewTh.h"


class CBaseAppearancePage       : public CObjectWithSite
                                , public CObjectWindow
                                , public CObjectCLSID
                                , public IPropertyBag
                                , public IPreviewSystemMetrics
                                , public IBasePropPage
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IBasePropPage ***
    virtual STDMETHODIMP GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog);
    virtual STDMETHODIMP OnApply(IN PROPPAGEONAPPLY oaAction);

    // *** IShellPropSheetExt ***
    virtual STDMETHODIMP AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam);
    virtual STDMETHODIMP ReplacePage(IN EXPPS uPageID, IN LPFNSVADDPROPSHEETPAGE pfnReplaceWith, IN LPARAM lParam) {return E_NOTIMPL;}

    // *** IPropertyBag ***
    virtual STDMETHODIMP Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog);
    virtual STDMETHODIMP Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar);

    // *** IObjectWithSite ***
    virtual STDMETHODIMP SetSite(IUnknown *punkSite);

    // *** IPreviewSystemMetrics ***
    virtual STDMETHODIMP RefreshColors(void);
    virtual STDMETHODIMP UpdateDPIchange(void) {return E_NOTIMPL;}
    virtual STDMETHODIMP UpdateCharsetChanges(void);
    virtual STDMETHODIMP DeskSetCurrentScheme(IN LPCWSTR pwzSchemeName);

    CBaseAppearancePage();
protected:

private:
    virtual ~CBaseAppearancePage(void);

    // Private Member Variables
    long                    m_cRef;

    BOOL                    m_fIsDirty;                         // We need to keep track of this in case another tab dirties out bit.
    BOOL                    m_fInitialized;                     // Have we been initialized yet?
    BOOL                    m_fLockVisualStylePolicyEnabled;    // Do we lock visual styles because of a policy?
    int                     m_nSelectedScheme;
    int                     m_nSelectedStyle;
    int                     m_nSelectedSize;
    HWND                    m_hwndSchemeDropDown;
    HWND                    m_hwndStyleDropDown;
    HWND                    m_hwndSizeDropDown;
    IThemeManager *         m_pThemeManager;
    IThemeScheme *          m_pSelectedThemeScheme;
    IThemeStyle *           m_pSelectedStyle;
    IThemeSize *            m_pSelectedSize;
    IThemePreview *         m_pThemePreview;
    LPWSTR                  m_pszLoadMSTheme;                   // When we open up, load this theme.

    SYSTEMMETRICSALL        m_advDlgState;                      // This is the state we modify in the Advanced Appearance page.
    BOOL                    m_fLoadedAdvState;                  // Has the state been loaded?

    int                     m_nNewDPI;                          // This is the dirty DPI.  It equals m_nAppliedDPI if it isn't dirty.
    int                     m_nAppliedDPI;                      // This is the currently active DPI (last applied).

    // Private Member Functions
    INT_PTR _BaseAppearanceDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    HRESULT _OnInitAppearanceDlg(HWND hDlg);
    HRESULT _OnInitData(void);
    HRESULT _OnDestroy(HWND hDlg);
    INT_PTR _OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    HRESULT _OnSetActive(HWND hDlg);
    HRESULT _OnApply(HWND hDlg, LPARAM lParam);
    HRESULT _UpdatePreview(IN BOOL fUpdateThemePage);
    HRESULT _EnableAdvancedButton(void);                    // See if we want the Advanced button enabled.

    HRESULT _LoadState(void);
    HRESULT _SaveState(CDimmedWindow* pDimmedWindow);
    HRESULT _LoadLiveSettings(IN LPCWSTR pszSaveGroup);
    HRESULT _SaveLiveSettings(IN LPCWSTR pszSaveGroup);

    HRESULT _OnSchemeChange(HWND hDlg, BOOL fDisplayErrors);
    HRESULT _OnStyleChange(HWND hDlg);
    HRESULT _OnSizeChange(HWND hDlg);
    HRESULT _OnAdvancedOptions(HWND hDlg);
    HRESULT _OnEffectsOptions(HWND hDlg);

    HRESULT _PopulateSchemeDropdown(void);
    HRESULT _PopulateStyleDropdown(void);
    HRESULT _PopulateSizeDropdown(void);
    HRESULT _FreeSchemeDropdown(void);
    HRESULT _FreeStyleDropdown(void);
    HRESULT _FreeSizeDropdown(void);

    BOOL _IsDirty(void);
    HRESULT _SetScheme(IN BOOL fLoadSystemMetrics, IN BOOL fLoadLiveSettings, IN BOOL fPreviousSelectionIsVS);
    HRESULT _OutsideSetScheme(BSTR bstrScheme);
    HRESULT _SetStyle(IN BOOL fUpdateThemePage);
    HRESULT _OutsideSetStyle(BSTR bstrStyle);
    HRESULT _SetSize(IN BOOL fLoadSystemMetrics, IN BOOL fUpdateThemePage);
    HRESULT _OutsideSetSize(BSTR bstrSize);
    HRESULT _LoadVisaulStyleFile(IN LPCWSTR pszPath);
    HRESULT _ApplyScheme(IThemeScheme * pThemeScheme, IThemeStyle * pColorStyle, IThemeSize * pThemeSize);
    HRESULT _GetPageByCLSID(const GUID * pClsid, IPropertyBag ** ppPropertyBag);
    HRESULT _ScaleSizesSinceDPIChanged(void);

    static INT_PTR CALLBACK BaseAppearanceDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);
};




#endif // _BASEAPPEAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\classfactory.cpp ===
/*****************************************************************************\
    FILE: classfactory.cpp

    DESCRIPTION:
       This file will be the Class Factory.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "classfactory.h"
#include "EffectsBasePg.h"
#include "ScreenSaverPg.h"
#include "store.h"


/*****************************************************************************
 *
 *  CClassFactory
 *
 *
 *****************************************************************************/

HRESULT CSettingsPage_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);
HRESULT CDisplaySettings_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);
HRESULT CScreenResFixer_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);

class CClassFactory       : public IClassFactory
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IClassFactory ***
    virtual STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject);
    virtual STDMETHODIMP LockServer(BOOL fLock);

public:
    CClassFactory(REFCLSID rclsid);
    ~CClassFactory(void);

    // Friend Functions
    friend HRESULT CClassFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj);

protected:
    long                    m_cRef;
    CLSID                   m_rclsid;
};



/*****************************************************************************
 *  IClassFactory::CreateInstance
 *****************************************************************************/

HRESULT CClassFactory::CreateInstance(IUnknown * punkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = E_INVALIDARG;

    if (NULL != ppvObj)
    {
        if (!punkOuter)
        {
            if (IsEqualCLSID(m_rclsid, CLSID_ThemeManager))
            {
                hr = CThemeManager_CreateInstance(punkOuter, riid, ppvObj);
            }
            else if (IsEqualCLSID(m_rclsid, CLSID_ThemeUIPages))
            {
                hr = CThemeUIPages_CreateInstance(punkOuter, riid, ppvObj);
            }
            else if (IsEqualCLSID(m_rclsid, CLSID_ThemePreview))
            {
                hr = CThemePreview_CreateInstance(punkOuter, riid, ppvObj);
            }
            else if (IsEqualCLSID(m_rclsid, CLSID_EffectsPage))
            {
                hr = CEffectsBasePage_CreateInstance(punkOuter, riid, ppvObj);
            }
            else if (IsEqualCLSID(m_rclsid, CLSID_SettingsPage))
            {
                hr = CSettingsPage_CreateInstance(punkOuter, riid, ppvObj);
            }
            else if (IsEqualCLSID(m_rclsid, CLSID_DisplaySettings))
            {
                hr = CDisplaySettings_CreateInstance(punkOuter, riid, ppvObj);
            }
            else if (IsEqualCLSID(m_rclsid, CLSID_ScreenResFixer))
            {
                hr = CScreenResFixer_CreateInstance(punkOuter, riid, ppvObj);
            }
            else if (IsEqualCLSID(m_rclsid, CLSID_ScreenSaverPage))
            {
                hr = CScreenSaverPage_CreateInstance(punkOuter, riid, ppvObj);
            }
            else
            {
                TCHAR szGuid[GUIDSTR_MAX];

                SHStringFromGUID(m_rclsid, szGuid, ARRAYSIZE(szGuid));
                AssertMsg(0, TEXT("CClassFactory::CreateInstance(%s) failed because we don't support that CLSID.  This is because someone made a registration bug."), szGuid);  // What are you looking for?
                hr = E_NOINTERFACE;
            }
        }
        else
        {   // Does anybody support aggregation any more?
            hr = ResultFromScode(CLASS_E_NOAGGREGATION);
        }
    }

    return hr;
}

/*****************************************************************************
 *
 *  IClassFactory::LockServer
 *
 *  What a poor function.  Locking the server is identical to
 *  creating an object and not releasing it until you want to unlock
 *  the server.
 *
 *****************************************************************************/

HRESULT CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();

    return S_OK;
}

/*****************************************************************************
 *
 *  CClassFactory_Create
 *
 *****************************************************************************/

/****************************************************\
    Constructor
\****************************************************/
CClassFactory::CClassFactory(REFCLSID rclsid) : m_cRef(1)
{
    m_rclsid = rclsid;
    DllAddRef();
}


/****************************************************\
    Destructor
\****************************************************/
CClassFactory::~CClassFactory()
{
    DllRelease();
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CClassFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CClassFactory::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualCLSID(riid, IID_IUnknown) || IsEqualCLSID(riid, IID_IClassFactory))
    {
        *ppvObj = SAFECAST(this, IClassFactory *);
    }
    else
    {
        TraceMsg(TF_WMTHEME, "CClassFactory::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}



HRESULT CClassFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres;

    if (IsEqualCLSID(riid, IID_IClassFactory))
    {
        *ppvObj = (LPVOID) new CClassFactory(rclsid);
        hres = (*ppvObj) ? S_OK : E_OUTOFMEMORY;
    }
    else
        hres = ResultFromScode(E_NOINTERFACE);

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\classfactory.h ===
/*****************************************************************************\
    FILE: classfactory.h

    DESCRIPTION:
       This file will be the Class Factory.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/


HRESULT CThemeManager_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);
HRESULT CThemePreview_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\color2.cpp ===
/*  COLOR2.C
**
**  Copyright (C) Microsoft, 1993, All Rights Reserved.
**
**
**  History:
**
*/

#include "priv.h"

int H,L,S;                         /* Hue, Lightness, Saturation */
#define  RANGE   240                 /* range of values for HLS scrollbars */
                                     /* HLS-RGB conversions work best when
                                        RANGE is divisible by 6 */
#define  HLSMAX   RANGE
#define  RGBMAX   255
#define MIN(a, b) ((a) < (b) ? (a) : (b))

/* Color conversion routines --

   RGBtoHLS() takes a DWORD RGB value, translates it to HLS, and stores the
   results in the global vars H, L, and S.  HLStoRGB takes the current values
   of H, L, and S and returns the equivalent value in an RGB DWORD.  The vars
   H, L and S are written to only by 1) RGBtoHLS (initialization) or 2) the
   scrollbar handlers.

   A point of reference for the algorithms is Foley and Van Dam, pp. 618-19.
   Their algorithm is in floating point.  CHART implements a less general
   (hardwired ranges) integral algorithm.

*/

/* There are potential roundoff errors lurking throughout here.
   (0.5 + x/y) without floating point,
      (x/y) phrased ((x + (y/2))/y)
   yields very small roundoff error.
   This makes many of the following divisions look funny.
*/

                        /* H,L, and S vary over 0-HLSMAX */
                        /* R,G, and B vary over 0-RGBMAX */
                        /* HLSMAX BEST IF DIVISIBLE BY 6 */
                        /* RGBMAX, HLSMAX must each fit in a byte. */

#define UNDEFINED (HLSMAX*2/3)/* Hue is undefined if Saturation is 0 (grey-scale) */
                           /* This value determines where the Hue scrollbar is */
                           /* initially set for achromatic colors */

static  void   RGBtoHLS(DWORD lRGBColor)
{
   int R,G,B;                /* input RGB values */
   WORD cMax,cMin;        /* max and min RGB values */
   WORD cSum,cDif;
   int  Rdelta,Gdelta,Bdelta;  /* intermediate value: % of spread from max */

   /* get R, G, and B out of DWORD */
   R = GetRValue(lRGBColor);
   G = GetGValue(lRGBColor);
   B = GetBValue(lRGBColor);

   /* calculate lightness */
   cMax = (WORD)max( max(R,G), B);
   cMin = (WORD)min( min(R,G), B);
   cSum = cMax + cMin;
   L = (WORD)(((cSum * (DWORD)HLSMAX) + RGBMAX )/(2*RGBMAX));

   cDif = cMax - cMin;
   if (!cDif)       /* r=g=b --> achromatic case */
     {
       S = 0;                         /* saturation */
       H = UNDEFINED;                 /* hue */
     }
   else                           /* chromatic case */
     {
       /* saturation */
       if (L <= (HLSMAX/2))
           S = (WORD) (((cDif * (DWORD) HLSMAX) + (cSum / 2) ) / cSum);
       else
           S = (WORD) ((DWORD) ((cDif * (DWORD) HLSMAX) + (DWORD)((2*RGBMAX-cSum)/2) )
                                                 / (2*RGBMAX-cSum));
      /* hue */
      Rdelta = (int) (( ((cMax-R)*(DWORD)(HLSMAX/6)) + (cDif / 2) ) / cDif);
      Gdelta = (int) (( ((cMax-G)*(DWORD)(HLSMAX/6)) + (cDif / 2) ) / cDif);
      Bdelta = (int) (( ((cMax-B)*(DWORD)(HLSMAX/6)) + (cDif / 2) ) / cDif);

      if ((WORD) R == cMax)
         H = Bdelta - Gdelta;
      else if ((WORD) G == cMax)
         H = (HLSMAX/3) + Rdelta - Bdelta;
      else /* B == cMax */
         H = ((2*HLSMAX)/3) + Gdelta - Rdelta;

      if (H < 0)
         H += HLSMAX;
      if (H > HLSMAX)
         H -= HLSMAX;
   }
}

/* utility routine for HLStoRGB */
static  WORD NEAR PASCAL HueToRGB(WORD n1, WORD n2, WORD hue)
{

   /* range check: note values passed add/subtract thirds of range */

   /* The following is redundant for WORD (unsigned int) */

#if 0
   if (hue < 0)
      hue += HLSMAX;
#endif

   if (hue > HLSMAX)
      hue -= HLSMAX;

   /* return r,g, or b value from this tridrant */
   if (hue < (HLSMAX/6))
      return ( n1 + (((n2-n1)*hue+(HLSMAX/12))/(HLSMAX/6)) );
   if (hue < (HLSMAX/2))
      return ( n2 );
   if (hue < ((HLSMAX*2)/3))
      return ( n1 + (((n2-n1)*(((HLSMAX*2)/3)-hue)+(HLSMAX/12)) / (HLSMAX/6)) );
   else
      return ( n1 );
}


static  DWORD NEAR PASCAL HLStoRGB(WORD hue, WORD lum, WORD sat)
{
  WORD R,G,B;                      /* RGB component values */
  WORD  Magic1,Magic2;       /* calculated magic numbers (really!) */

  if (sat == 0)                /* achromatic case */
    {
      R = G = B = (lum * RGBMAX) / HLSMAX;
      if (hue != UNDEFINED)
        {
         /* ERROR */
        }
    }
  else                         /* chromatic case */
    {
      /* set up magic numbers */
      if (lum <= (HLSMAX/2))
          Magic2 = (WORD)((lum * ((DWORD)HLSMAX + sat) + (HLSMAX/2))/HLSMAX);
      else
          Magic2 = lum + sat - (WORD)(((lum*sat) + (DWORD)(HLSMAX/2))/HLSMAX);
      Magic1 = 2*lum-Magic2;

      /* get RGB, change units from HLSMAX to RGBMAX */
      R = (WORD)((HueToRGB(Magic1,Magic2,(WORD)(hue+(WORD)(HLSMAX/3)))*(DWORD)RGBMAX + (HLSMAX/2))) / (WORD)HLSMAX;
      G = (WORD)((HueToRGB(Magic1,Magic2,hue)*(DWORD)RGBMAX + (HLSMAX/2))) / HLSMAX;
      B = (WORD)((HueToRGB(Magic1,Magic2,(WORD)(hue-(WORD)(HLSMAX/3)))*(DWORD)RGBMAX + (HLSMAX/2))) / (WORD)HLSMAX;
    }
  return(RGB(R,G,B));
}


DWORD  DarkenColor(DWORD rgb, int n)
{
    RGBtoHLS(rgb);
    return HLStoRGB((WORD)H, (WORD)((long)L * n / 1000), (WORD)S);
}

DWORD  BrightenColor(DWORD rgb, int n)
{
    RGBtoHLS(rgb);
    return HLStoRGB((WORD)H, (WORD)(((long)L * (1000-n) + (RANGE+1l)*n) / 1000), (WORD)S);
}

#ifdef OLDCODE
void  Get3DColors(DWORD rgbFace, LPDWORD lprgbShadow, LPDWORD lprgbHilight)
{
    RGBtoHLS(rgbFace);

    // colors are half way between the face and the min/max values

    *lprgbShadow  = HLStoRGB(H, L * 2 / 3, S);
    *lprgbHilight = HLStoRGB(H, (L + RANGE + 1) / 2, S);
    *lprgbHilight = HLStoRGB(H, (L + RANGE + 1) / 2, S);

//    *lprgbHilight = HLStoRGB(H, MIN(RANGE, L * 7 / 6), S);
}
#endif

DWORD FAR PASCAL AdjustLuma(DWORD rgb, int n, BOOL fScale)
{
    if (n == 0)
        return rgb;

    RGBtoHLS(rgb);

    if (fScale)
    {
        if (n > 0)
        {
            return HLStoRGB((WORD)H, (WORD)(((long)L * (1000 - n) + (RANGE + 1l) * n) / 1000), (WORD)S);
        }
        else
        {
            return HLStoRGB((WORD)H, (WORD)(((long)L * (n + 1000)) / 1000), (WORD)S);
        }
    }

    L += (int)((long)n * RANGE / 1000);

    if (L < 0)
        L = 0;
    if (L > HLSMAX)
        L = HLSMAX;

    return HLStoRGB((WORD)H, (WORD)L, (WORD)S);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\coverwnd.h ===
//  --------------------------------------------------------------------------
//  Module Name: DimmedWindow.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class that implements the dimmed window when displaying logoff / shut down
//  dialog.
//
//  History:    2000-05-18  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _DimmedWindow_
#define     _DimmedWindow_

class CDimmedWindow
{
public:
    explicit CDimmedWindow (HINSTANCE hInstance);
    ~CDimmedWindow (void);
    
    //  IUnknown methods
    ULONG STDMETHODCALLTYPE   AddRef (void);
    ULONG STDMETHODCALLTYPE   Release (void);
    
    HRESULT Create (UINT ulKillTimer);

private:
    static LRESULT CALLBACK WndProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static DWORD WorkerThread(IN void *pv);

    LONG            _lReferenceCount;
    const HINSTANCE _hInstance;
    ATOM            _atom;
    ATOM            _atomPleaseWait;
    HWND            _hwnd;
    ULONG           _ulKillTimer;
};

#endif  /*  _DimmedWindow_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\colorpic.cpp ===
/*****************************************************************************\
    FILE: colorpic.cpp

    DESCRIPTION:
        This code will display a color picker UI.

    ??????? ?/??/1993    Created
    BryanSt 3/23/2000    Updated and Converted to C++ (Bryan Starbuck)

    Copyright (C) Microsoft Corp 1993-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "AdvAppearPg.h"
#include "PreviewSM.h"

#define NUM_COLORSMAX    64
#define NUM_COLORSPERROW 4

typedef struct {
    LPCOLORPICK_INFO lpcpi;
    int dxColor;
    int dyColor;
    int iCurColor;
    int iNumColors;
    BOOL capturing;
    BOOL justdropped;
    COLORREF Colors[NUM_COLORSMAX];
} MYDATA, * PMYDATA, FAR * LPMYDATA;

BOOL g_bCursorHidden;

INT_PTR CALLBACK  ColorPickDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);

BOOL NEAR PASCAL UseColorPicker( LPCOLORPICK_INFO lpcpi )
{
    CHOOSECOLOR cc;
    extern COLORREF g_CustomColors[16];

    cc.lStructSize = sizeof(cc);
    cc.hwndOwner = lpcpi->hwndParent; // NOT lpcpi->hwndOwner
    cc.hInstance = NULL;
    cc.rgbResult = lpcpi->rgb;
    cc.lpCustColors = g_CustomColors;
    cc.Flags = CC_RGBINIT | lpcpi->flags;
    cc.lCustData = 0L;
    cc.lpfnHook = NULL;
    cc.lpTemplateName = NULL;

    if (ChooseColor(&cc))
    {
        lpcpi->rgb = cc.rgbResult;
        return TRUE;
    }

    return FALSE;
}

void NEAR PASCAL DrawColorSquare(HDC hdc, int iColor, PMYDATA pmd)
{
    RECT rc;
    COLORREF rgb;
    HPALETTE hpalOld = NULL;
    HBRUSH hbr;

    // custom color
    if (iColor == pmd->iNumColors)
    {
        rc.left = 0;
        rc.top = 0;
        rgb = pmd->lpcpi->rgb;
    }
    else
    {
        rc.left = (iColor % NUM_COLORSPERROW) * pmd->dxColor;
        rc.top = (iColor / NUM_COLORSPERROW) * pmd->dyColor;
        rgb = pmd->Colors[iColor];
    }
    rc.right = rc.left + pmd->dxColor;
    rc.bottom = rc.top + pmd->dyColor;

    // focused one
    if (iColor == pmd->iCurColor)
    {
        PatBlt(hdc, rc.left, rc.top, pmd->dxColor, 3, BLACKNESS);
        PatBlt(hdc, rc.left, rc.bottom - 3, pmd->dxColor, 3, BLACKNESS);
        PatBlt(hdc, rc.left, rc.top + 3, 3, pmd->dyColor - 6, BLACKNESS);
        PatBlt(hdc, rc.right - 3, rc.top + 3, 3, pmd->dyColor - 6, BLACKNESS);
        InflateRect(&rc, -1, -1);
        HBRUSH hBrushWhite = (HBRUSH) GetStockObject(WHITE_BRUSH);
        if (hBrushWhite)
        {
            FrameRect(hdc, &rc, hBrushWhite);
        }
        InflateRect(&rc, -2, -2);
    }
    else
    {
        // clean up possible focus thing from above
        FrameRect(hdc, &rc, GetSysColorBrush(COLOR_3DFACE));

        InflateRect(&rc, -cxBorder, -cyBorder);
        DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
    }

    if ((pmd->lpcpi->flags & CC_SOLIDCOLOR) && !(rgb & 0xFF000000))
        rgb = GetNearestColor(hdc, rgb);

    hbr = CreateSolidBrush(rgb);
    if (pmd->lpcpi->hpal)
    {
        hpalOld = SelectPalette(hdc, pmd->lpcpi->hpal, FALSE);
        RealizePalette(hdc);
    }
    hbr = (HBRUSH) SelectObject(hdc, hbr);
    PatBlt(hdc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, PATCOPY);
    hbr = (HBRUSH) SelectObject(hdc, hbr);

    if (hpalOld)
    {
        hpalOld = SelectPalette(hdc, hpalOld, TRUE);
        RealizePalette(hdc);
    }

    if (hbr)
    {
        DeleteObject(hbr);
    }
}

/*
** set the focus to the given color.
**
** in the process, also take the focus off of the old focus color.
*/
void NEAR PASCAL FocusColor(HWND hDlg, int iNewColor, PMYDATA pmd)
{
    int i;
    HDC hdc = NULL;
    HWND hwnd;

    if (iNewColor == pmd->iCurColor)
        return;

    i = pmd->iCurColor;
    pmd->iCurColor = iNewColor;

    // unfocus the old one
    if( i >= 0 )
    {
        if (i == pmd->iNumColors)
            hwnd = GetDlgItem(hDlg, IDC_CPDLG_COLORCUST);
        else
            hwnd = GetDlgItem(hDlg, IDC_CPDLG_16COLORS);
        hdc = GetDC(hwnd);
        DrawColorSquare(hdc, i, pmd);
        ReleaseDC(hwnd, hdc);
    }

    // focus the new one
    if( iNewColor >= 0 )
    {
        if (iNewColor == pmd->iNumColors)
            hwnd = GetDlgItem(hDlg, IDC_CPDLG_COLORCUST);
        else
            hwnd = GetDlgItem(hDlg, IDC_CPDLG_16COLORS);
        hdc = GetDC(hwnd);
        DrawColorSquare(hdc, iNewColor, pmd);
        ReleaseDC(hwnd, hdc);
    }
}

void NEAR PASCAL Color_TrackMouse(HWND hDlg, POINT pt, PMYDATA pmd)
{
    HWND hwndKid;
    int id;

    hwndKid = ChildWindowFromPoint(hDlg, pt);
    if (hwndKid == NULL || hwndKid == hDlg)
        return;

    id = GetWindowLong(hwndKid, GWL_ID);
    switch (id)
    {
        case IDC_CPDLG_16COLORS:
            MapWindowPoints(hDlg, GetDlgItem(hDlg, IDC_CPDLG_16COLORS), &pt, 1);
            pt.x /= pmd->dxColor;
            pt.y /= pmd->dyColor;
            FocusColor(hDlg, pt.x + (pt.y * NUM_COLORSPERROW), pmd);
            break;

        case IDC_CPDLG_COLORCUST:
            if (IsWindowVisible(hwndKid))
                FocusColor(hDlg, pmd->iNumColors, pmd);
            break;

        case IDC_CPDLG_COLOROTHER:
            FocusColor(hDlg, -1, pmd);
            break;
    }
}

void NEAR PASCAL Color_DrawItem(HWND hDlg, LPDRAWITEMSTRUCT lpdis, PMYDATA pmd)
{
    int i;

    if (lpdis->CtlID == IDC_CPDLG_COLORCUST)
    {
        DrawColorSquare(lpdis->hDC, pmd->iNumColors, pmd);
    }
    else
    {
        for (i = 0; i < pmd->iNumColors; i++)
            DrawColorSquare(lpdis->hDC, i, pmd);
    }
}

/*
** init the mini-color-picker
**
** the dialog is pretending to be a menu, so figure out where to pop
** it up so that it is visible all around.
**
** also because this dialog is pretty darn concerned with its look,
** hand-align the components in pixel units.  THIS IS GROSS!
*/
void NEAR PASCAL Color_InitDialog(HWND hDlg, PMYDATA pmd)
{
    RECT rcOwner;
    RECT rc, rc2;
    int dx, dy;
    int x, y;
    int i;
    HWND hwndColors, hwnd;
    HWND hwndEtch, hwndCust;
    int  width, widthCust, widthEtch;
    int cyEdge = ClassicGetSystemMetrics(SM_CYEDGE);
    HPALETTE hpal = pmd->lpcpi->hpal;
    MONITORINFO mi;
    TCHAR szBuf[50];
    LONG cbBuf = ARRAYSIZE( szBuf );
    HDC hDC;
    SIZE size;

    if (hpal == NULL)
        hpal = (HPALETTE) GetStockObject(DEFAULT_PALETTE);

    pmd->iNumColors = 0;
    GetObject(hpal, sizeof(int), &pmd->iNumColors);

    if (pmd->iNumColors > NUM_COLORSMAX)
        pmd->iNumColors = NUM_COLORSMAX;

    if (GetPaletteEntries(hpal,0, pmd->iNumColors, (LPPALETTEENTRY)pmd->Colors))
    {
        for (i = 0; i < pmd->iNumColors; i++)
        {
            pmd->Colors[i] &= 0x00FFFFFF;
            pmd->Colors[i] |= 0x02000000;
        }

        for (i = 0; i < pmd->iNumColors; i++)
        {
            if ((pmd->Colors[i] & 0x00FFFFFF) == (pmd->lpcpi->rgb & 0x00FFFFFF))
            {
                ShowWindow(GetDlgItem(hDlg, IDC_CPDLG_COLORCUST), SW_HIDE);
                break;
            }
        }
        // current is either one of 16 or the custom color (== pmd->iNumColors
        pmd->iCurColor = i;

        // size the 16 colors to be square
        hwndColors = GetDlgItem(hDlg, IDC_CPDLG_16COLORS);
        GetClientRect(hwndColors, &rc);

        // To make localization easy..
        //
        hwndEtch=GetDlgItem(hDlg, IDC_CPDLG_COLORETCH);
        GetClientRect(hwndEtch, &rc2);
        widthEtch = rc2.right-rc2.left;

        hwndCust=GetDlgItem(hDlg, IDC_CPDLG_COLORCUST);
        GetClientRect(hwndCust, &rc2);
        widthCust = rc2.right-rc2.left;

        hwnd = GetDlgItem(hDlg, IDC_CPDLG_COLOROTHER);
        GetWindowRect(hwnd, &rc2); // we must initialize rc2 with this control.

        // Make sure the button is big enough to contain its text
        width = rc.right - rc.left;
        if( GetDlgItemText( hDlg, IDC_CPDLG_COLOROTHER, szBuf, cbBuf ) )
        {
            RECT rcTemp;
            int iRet;
            HFONT hfont, hfontOld;  

            // Get the font for the button
            hDC = GetDC( hwnd );
            if( hDC )
            {
                hfont = (HFONT)SendMessage( hwnd, WM_GETFONT, 0, 0 );
                ASSERT(hfont);
                hfontOld = (HFONT) SelectObject( hDC, hfont );

                // Get the size of the text
                iRet = DrawTextEx( hDC, szBuf, lstrlen(szBuf), &rcTemp, DT_CALCRECT | DT_SINGLELINE, NULL );
                ASSERT( iRet );
                size.cx = rcTemp.right - rcTemp.left + 7;  //account for the button border
                size.cy = rcTemp.bottom - rcTemp.top;

                // Adjust the button size if the text needs more space
                if( size.cx > width )
                {              
                    rc2.right = rc2.left + size.cx;
                    rc2.bottom = rc2.top + size.cy;
                    MoveWindow( hwnd, rc2.left, rc2.top, rc2.right - rc2.left, rc2.bottom - rc2.top, FALSE );
                }
                SelectObject( hDC, hfontOld );
                ReleaseDC( hwnd, hDC );
            }
        }

        // Take possible biggest width to calculate sels
        //
        width = (widthEtch > widthCust+(rc2.right-rc2.left)) ? widthEtch : widthCust+(rc2.right-rc2.left);
        width = (width > rc.right-rc.left) ? width: rc.right-rc.left;

    #define NUM_COLORSPERCOL (pmd->iNumColors / NUM_COLORSPERROW)

        pmd->dxColor = pmd->dyColor
        = ((rc.bottom - rc.top) / NUM_COLORSPERCOL > width / NUM_COLORSPERROW )
          ?  (rc.bottom - rc.top) / NUM_COLORSPERCOL : width / NUM_COLORSPERROW;

        // Make sure custum color can fit
        //
        if (pmd->dxColor*(NUM_COLORSPERROW-1) < rc2.right-rc2.left )
            pmd->dxColor = pmd->dyColor = (rc2.right-rc2.left)/(NUM_COLORSPERROW-1);

        // make each color square's width the same as the height
        SetWindowPos(hwndColors, NULL, 0, 0, pmd->dxColor * NUM_COLORSPERROW,
                     pmd->dyColor * NUM_COLORSPERCOL,
                     SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER |  SWP_NOREDRAW);
        rc.right = rc.left + pmd->dxColor * NUM_COLORSPERROW;
        rc.bottom = rc.top + pmd->dyColor * NUM_COLORSPERCOL;

        MapWindowPoints(hwndColors, hDlg, (LPPOINT)(LPRECT)&rc, 2);

        // move/size the etch to the right place
        // (compensate for the colors being "inset" by one)
        MoveWindow(hwndEtch, rc.left + 1, rc.bottom + cyEdge,
                                    rc.right - rc.left - 2, cyEdge, FALSE);

        y = rc.bottom + 3 * cyEdge;

        // size the custom color to the same square and right-align
        MoveWindow(hwndCust, rc.right - pmd->dxColor, y,
                                    pmd->dxColor, pmd->dyColor, FALSE);

        // do same for button
        MapWindowPoints(NULL, hDlg, (LPPOINT)(LPRECT)&rc2, 2);
        // base the width of the custom button on the remaining space to 
        // the left of the custom color.  Also move the custom button one pix right
        // of the left edge.  This only is done if a custom color is selected...
        if (pmd->iCurColor != pmd->iNumColors) {
            // no custom color
            MoveWindow(hwnd, rc2.left, y, rc2.right-rc2.left, pmd->dyColor, FALSE);
        }
        else {
            // custom color, adjust the Other... button
            dx = rc2.right - rc2.left++;
            if (rc2.left + dx >= rc.right - pmd->dxColor - 2) 
                MoveWindow(hwnd, rc2.left, y, rc.right - pmd->dxColor - 2 , pmd->dyColor, FALSE);
            else 
                MoveWindow(hwnd, rc2.left, y, dx, pmd->dyColor, FALSE);
        }

        // now figure out the size for the dialog itself
        rc.left = rc.top = 0;
        rc.right = rc.left + pmd->dxColor * NUM_COLORSPERROW;
        // (compensate for the colors being "inset" by one)
        rc.bottom = y + pmd->dyColor + 1;

        AdjustWindowRect(&rc, GetWindowLong(hDlg, GWL_STYLE), FALSE);
        dx = rc.right - rc.left;
        dy = rc.bottom - rc.top;

        GetWindowRect(pmd->lpcpi->hwndOwner, &rcOwner);

        // Make sure the window is entirely on the monitor
        mi.cbSize = sizeof(mi);
        GetMonitorInfo(MonitorFromRect(&rcOwner, MONITOR_DEFAULTTONEAREST), &mi);

        if (rcOwner.left < mi.rcMonitor.left) { // overlap left side
            x = mi.rcMonitor.left;
        }
        else if (rcOwner.left + dx >= mi.rcMonitor.right) { // overlap right side
            x = mi.rcMonitor.right  - dx - 1;
        }
        else {                                  // no overlap
            x = rcOwner.left;
        }

        if (rcOwner.top < mi.rcMonitor.top) {   // overlap top side
            y = rcOwner.bottom;
        }
        else if (rcOwner.bottom + dy >= mi.rcMonitor.bottom) {// overlap bottom side
            y = rcOwner.top  - dy;
        }
        else {                                  // no overlap
            y = rcOwner.bottom;
        }
        MoveWindow(hDlg, x, y, dx, dy, FALSE);
    }
}

INT_PTR CALLBACK  ColorPickDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    PMYDATA pmd = (PMYDATA)GetWindowLongPtr(hDlg, DWLP_USER);
    HWND hwndKid;
    int wRet;
    int id;
    POINT pt;
    BOOL fEnd = FALSE;

    if (!pmd && (WM_INITDIALOG != message))
    {
        return FALSE;
    }

    switch(message)
    {
        case WM_INITDIALOG:
            pmd = (PMYDATA)LocalAlloc(LPTR, sizeof(MYDATA));
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pmd);
            if (pmd)
            {
                pmd->lpcpi = (LPCOLORPICK_INFO)lParam;
                pmd->capturing = FALSE;
                pmd->justdropped = TRUE;

                Color_InitDialog(hDlg, pmd);
                SetFocus(GetDlgItem(hDlg, IDC_CPDLG_16COLORS));

                // post self a message to setcapture after painting
                PostMessage(hDlg, WM_APP+1, 0, 0L);
            }
            else
            {
                EndDialog(hDlg, IDCANCEL);
            }

            return FALSE;

        case WM_APP+1:
            if (g_bCursorHidden)
            {
                ShowCursor(TRUE);
                g_bCursorHidden = FALSE;
            }
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            pmd->capturing = TRUE;
            SetCapture(hDlg);
            pmd->capturing = FALSE;
            break;

        case WM_DESTROY:
            LocalFree((HLOCAL)pmd);
            break;

        case WM_CAPTURECHANGED:
            if( pmd->capturing )
                return TRUE;   // ignore if we're doing this on purpose

            // if this wasn't a button in the dialog, dismiss ourselves
            if( !pmd->justdropped || (HWND)lParam == NULL || GetParent((HWND)lParam) != hDlg)
            {
                EndDialog(hDlg, IDCANCEL);
                return TRUE;
            }
            break;

        case WM_MOUSEMOVE:
            LPARAM2POINT(lParam, &pt );

            Color_TrackMouse(hDlg, pt, pmd);
            break;

        // if button up is on the parent, leave picker up and untrammeled.
        // otherwise, we must have "menu-tracked" to get here, so select.
        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
            LPARAM2POINT(lParam, &pt);
            MapWindowPoints(hDlg, pmd->lpcpi->hwndOwner, &pt, 1);
            if (ChildWindowFromPoint(pmd->lpcpi->hwndOwner, pt))
                return 0;
            pmd->capturing = TRUE;
            pmd->justdropped = FALSE;  // user could not be dragging from owner
            ReleaseCapture();
            pmd->capturing = FALSE;
            fEnd = TRUE;
        // || fall    ||
        // || through ||
        // \/         \/
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
            LPARAM2POINT(lParam, &pt);
            hwndKid = ChildWindowFromPoint(hDlg, pt);
            // assume it's a dismissal if we're going to close...
            wRet = IDCANCEL;

            // if not on parent, dismiss picker
            if (hwndKid != NULL && hwndKid != hDlg)
            {
                id = GetWindowLong(hwndKid, GWL_ID);
                switch (id)
                {
                    case IDC_CPDLG_16COLORS:
                        // make sure that iCurColor is valid
                        Color_TrackMouse(hDlg, pt, pmd);
                        pmd->lpcpi->rgb = pmd->Colors[pmd->iCurColor] & 0x00FFFFFF;

                        //BOGUS
                        //if (pmd->iCurColor >= 16)
                        //    pmd->lpcpi->rgb |= 0x02000000;

                        wRet = IDOK;
                        break;

                    case IDC_CPDLG_COLOROTHER:
                        FocusColor(hDlg, -1, pmd);
                        wRet = id;   // this will fall thru to use the picker
                        fEnd = TRUE; // we have capture, the button won't click
                        break;

                    default:
                        // if this is a down, we will track until the up
                        // if this is an up, we will close with no change
                        break;
                }
            }

            if( fEnd )
            {
                EndDialog(hDlg, wRet);
                return TRUE;
            }

            // make sure we have the capture again since we didn't close
            pmd->capturing = TRUE;
            SetCapture(hDlg);
            pmd->capturing = FALSE;
            break;

        case WM_DRAWITEM:
            Color_DrawItem(hDlg, (LPDRAWITEMSTRUCT)lParam, pmd);
            break;

        case WM_COMMAND:
            // all commands close the dialog
            // note IDC_CPDLG_COLOROTHER will fall through to the caller...
            // cannot pass ok with no color selected
            if( LOWORD(wParam) == IDOK && pmd->iCurColor < 0 )
                *((WORD *)(&wParam)) = IDCANCEL;

            EndDialog( hDlg, LOWORD(wParam) );
            break;
    }
    return FALSE;
}

BOOL WINAPI ChooseColorMini(LPCOLORPICK_INFO lpcpi)
{
    INT_PTR iAnswer;

    ShowCursor(FALSE);
    g_bCursorHidden = TRUE;

    iAnswer = DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_COLORPICK),
                        lpcpi->hwndOwner, ColorPickDlgProc, (LPARAM)lpcpi);

    if (g_bCursorHidden)
    {
        ShowCursor(TRUE);
        g_bCursorHidden = FALSE;
    }

    switch( iAnswer )
    {
        case IDC_CPDLG_COLOROTHER:  // the user picked the "Other..." button
            return UseColorPicker( lpcpi );

        case IDOK:            // the user picked a color in our little window
            return TRUE;

        default:
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\deskcmmn.h ===
#ifndef _DESKCMMN_H
#define _DESKCMMN_H


//==========================================================================
//                              Guids
//==========================================================================

DEFINE_GUID(GUID_DISPLAY_ADAPTER_INTERFACE, 
            0x5b45201d, 
            0xf2f2, 0x4f3b, 
            0x85, 0xbb, 0x30, 0xff, 0x1f, 0x95, 0x35, 0x99);

#define SZ_DISPLAY_ADAPTER_INTERFACE_NAME TEXT("{5b45201d-f2f2-4f3b-85bb-30ff1f953599}")

//==========================================================================
//                              Macros
//==========================================================================

#define SZ_REGISTRYMACHINE  TEXT("\\REGISTRY\\MACHINE\\")
#define SZ_PRUNNING_MODE    TEXT("PruningMode")

#define SZ_GUID                TEXT("VideoID")
#define SZ_VIDEO_DEVICES       TEXT("System\\CurrentControlSet\\Control\\Video\\")
#define SZ_COMMON_SUBKEY       TEXT("\\Video")
#define SZ_SERVICES_PATH       TEXT("System\\CurrentControlSet\\Services\\")
#define SZ_SERVICE             TEXT("Service")

#define DCDSF_DYNA (0x0001)
#define DCDSF_ASK  (0x0002)

#define DCDSF_PROBABLY      (DCDSF_ASK  | DCDSF_DYNA)
#define DCDSF_PROBABLY_NOT  (DCDSF_ASK  |          0)
#define DCDSF_YES           (0          | DCDSF_DYNA)
#define DCDSF_NO            (0          |          0)


#define REGSTR_VAL_DYNASETTINGSCHANGE    TEXT("DynaSettingsChange")
#define SZ_UPGRADE_FROM_PLATFORM         TEXT("PlatformId")
#define SZ_UPGRADE_FROM_MAJOR_VERSION    TEXT("MajorVersion")
#define SZ_UPGRADE_FROM_MINOR_VERSION    TEXT("MinorVersion")
#define SZ_UPGRADE_FROM_BUILD_NUMBER     TEXT("BuildNumber")
#define SZ_UPGRADE_FROM_VERSION_DESC     TEXT("CSDVersion")
#define SZ_UPGRADE_FROM_PELS_WIDTH       TEXT("PelsWidth")
#define SZ_UPGRADE_FROM_PELS_HEIGHT      TEXT("PelsHeight")
#define SZ_UPGRADE_FROM_BITS_PER_PEL     TEXT("BPP")
#define SZ_UPGRADE_FROM_PLANES           TEXT("Planes")
#define SZ_UPGRADE_FROM_DISPLAY_FREQ     TEXT("VRefresh")
#define SZ_UPGRADE_FAILED_ALLOW_INSTALL  TEXT("FailedAllowInstall")
#define SZ_VIDEOMAP                      TEXT("HARDWARE\\DEVICEMAP\\VIDEO")
#define SZ_DEVICE                        TEXT("\\Device")
#define SZ_ENUM                          TEXT("Enum")

#define SZ_UPDATE_SETTINGS               TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\VideoUpgradeDisplaySettings")
#define SZ_UPDATE_SETTINGS_PATH          TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion")
#define SZ_UPDATE_SETTINGS_KEY           TEXT("VideoUpgradeDisplaySettings")

#define SZ_VU_COUNT                      TEXT("Count")
#define SZ_VU_PHYSICAL                   TEXT("Physical")
#define SZ_VU_LOGICAL                    TEXT("Logical")
#define SZ_VU_BUS_NUMBER                 TEXT("BusNumber")
#define SZ_VU_ADDRESS                    TEXT("Address")
#define SZ_VU_PREFERRED_MODE             TEXT("UsePreferredMode")
#define SZ_VU_ATTACHED_TO_DESKTOP        TEXT("Attach.ToDesktop")
#define SZ_VU_RELATIVE_X                 TEXT("Attach.RelativeX")
#define SZ_VU_RELATIVE_Y                 TEXT("Attach.RelativeY")
#define SZ_VU_BITS_PER_PEL               TEXT("DefaultSettings.BitsPerPel")
#define SZ_VU_X_RESOLUTION               TEXT("DefaultSettings.XResolution")
#define SZ_VU_Y_RESOLUTION               TEXT("DefaultSettings.YResolution")
#define SZ_VU_VREFRESH                   TEXT("DefaultSettings.VRefresh")
#define SZ_VU_FLAGS                      TEXT("DefaultSettings.Flags")

#define SZ_HW_ACCELERATION               TEXT("Acceleration.Level")


#define SZ_VOLATILE_SETTINGS             TEXT("VolatileSettings")

#define SZ_DETECT_DISPLAY                TEXT("System\\CurrentControlSet\\Control\\GraphicsDrivers\\DetectDisplay")
#define SZ_NEW_DISPLAY                   TEXT("System\\CurrentControlSet\\Control\\GraphicsDrivers\\NewDisplay")

//==========================================================================
//                              Functions
//==========================================================================

// LPTSTR SubStrEnd(LPTSTR pszTarget, LPTSTR pszScan )
//
// If pszScan starts with pszTarget, then the function returns the first
// char of pszScan that follows the pszTarget; other wise it returns pszScan.
//
// eg: SubStrEnd("abc", "abcdefg" ) ==> "defg"
//     SubStrEnd("abc", "abZQRT" ) ==> "abZQRT"
LPTSTR SubStrEnd(LPTSTR pszTarget, LPTSTR pszScan);


BOOL GetDeviceRegKey(LPCTSTR pstrDeviceKey, HKEY* phKey, BOOL* pbReadOnly);


int GetDisplayCPLPreference(LPCTSTR szRegVal);


int GetDynaCDSPreference();


void SetDisplayCPLPreference(LPCTSTR szRegVal, int val);


LONG WINAPI MyStrToLong(LPCTSTR sz);

BOOL 
AllocAndReadInterfaceName(
    IN  LPTSTR pDeviceKey,
    OUT LPWSTR* ppInterfaceName
    );

BOOL 
AllocAndReadInstanceID(
    IN  LPTSTR pDeviceKey,
    OUT LPWSTR* ppInstanceID
    );

BOOL 
AllocAndReadValue(
    IN  HKEY hkKey,
    IN  LPTSTR pValueName,
    OUT LPWSTR* ppwValueData
    );

BOOL
DeleteKeyAndSubkeys(
    HKEY hKey,
    LPCTSTR lpSubKey
    );

#endif // _DESKCMMN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\custfont.cpp ===
/*  CUSTFONT.C
**
**  Copyright (C) Microsoft, 1993, All Rights Reserved.
**
**  History:
**
*/

#include "priv.h"
#pragma hdrstop

static struct
{
        UINT wWidth;
        UINT wHeight;
        UINT wSizeFontId;

        UINT wStartPos;
        UINT wStartPix;
} g;

static UINT g_iCurPercent;
static RECT g_rcRuler;
static TCHAR g_szRulerDirections[200];
static TCHAR g_szSample[100];
static TCHAR g_szSampleFace[32];

static int g_cxRulerDirections;

static BOOL g_bTypeTimer = FALSE;

static TCHAR szPctD[] = TEXT("%d");
static TCHAR szPercentNum[] = TEXT("%d%%");

#define NUM_DEFPERCENTS 5
static UINT g_DefaultPercents[NUM_DEFPERCENTS] = {75, 100, 125, 150, 200};

#define MAX_PERCENT     500
#define MIN_PERCENT     20

#define GETPERCENT(dpi) ((dpi * 100 + 50) / 96)
#define GETDPI(percent) ((percent * 96 + 48) /100)

#define UPDATE_CURPER   0x0001
#define UPDATE_COMBO    0x0002
#define UPDATE_SAMPLE   0x0004
#define UPDATE_RULER    0x0008
#define UPDATE_ALL      0x000F

void NEAR PASCAL DrawRuler(HWND hDlg, LPDRAWITEMSTRUCT lpdis)
{
    int nFact;
    RECT rc;
    HDC hdc;
    int nPixInch;
    int i, j;
    TCHAR szTemp[10];
    int nOldMode;

    hdc = lpdis->hDC;
    nOldMode = SetBkMode(hdc, TRANSPARENT);
    // use g_rcRuler to draw the ruler.  it's already been spaced
    rc = g_rcRuler;

    // first, draw the directions
    i = rc.left + ((rc.right - rc.left) - g_cxRulerDirections)/2;

    nPixInch = GETDPI(g_iCurPercent);

    // draw the top and left edge of the ruler
    DrawEdge(hdc, &rc, EDGE_ETCHED, BF_TOPLEFT);
    // rest of drawing happens just below the top
    rc.top += ClassicGetSystemMetrics(SM_CYEDGE);

    nFact = 1;
    // draw one of the etch heights (1", 1/2", 1/4") per iteration
    for (j=0; j<3; ++j)
    {
        for (i=0; ; ++i)
        {
            rc.left = g_rcRuler.left + (j==0 ? i*nPixInch : (2*i+1)*nPixInch/nFact);
            if (rc.left >= g_rcRuler.right)
            {
                break;
            }
            DrawEdge(hdc, &rc, EDGE_ETCHED, BF_LEFT | BF_ADJUST);

            // dominant etch deserves a number
            if (j == 0)
            {
                TextOut(hdc, rc.left+1, rc.bottom-g.wHeight,
                                        szTemp, wsprintf(szTemp, szPctD, i));
            }
        }

        rc.bottom -= (rc.bottom - rc.top)/2;
        nFact *= 2;
    }

    SetBkMode(hdc, nOldMode);
}

void NEAR PASCAL CF_UpdateRuler(HWND hDlg)
{
    RECT rc;
    HWND hwnd;

    /* Don't do this stuff if the dialog is not
    ** visible yet, or other windows will flash.
    */
    if (IsWindowVisible(hDlg))
    {
        // don't invalidate top and left because they never change.
        rc = g_rcRuler;
        rc.left += ClassicGetSystemMetrics(SM_CXEDGE);
        rc.top += ClassicGetSystemMetrics(SM_CYEDGE);

        hwnd = GetDlgItem(hDlg, IDC_CUSTOMRULER);
        InvalidateRect(hwnd, &rc, TRUE);
        UpdateWindow(hwnd);
    }
}
void NEAR PASCAL CF_ShowNewPercent(HWND hDlg, UINT uPer)
{
    TCHAR szBuf[10];

    g_iCurPercent = uPer;

    wsprintf(szBuf, szPercentNum, uPer);
    SetWindowText(GetDlgItem(hDlg, IDC_CUSTOMCOMBO), szBuf);
    UpdateWindow(GetDlgItem(hDlg, IDC_CUSTOMCOMBO));
}

// Build lf with given face and height
//
int CALLBACK EnumProc(CONST LOGFONT *lplf, CONST TEXTMETRIC *lptm, DWORD nType, LPARAM lpData )
{
    *(LPLOGFONT)lpData = *lplf;
    return FALSE;
}

HFONT CreateFontWithFace(HWND hwnd, int nHeight, LPCTSTR lpszFace)
{
    LOGFONT lf;
    HDC     hdc;

    hdc = GetDC(hwnd);
    if(hdc)
    {
        EnumFontFamilies(hdc, lpszFace, EnumProc, (LPARAM)&lf);
        ReleaseDC(hwnd,hdc);
    }

    lf.lfHeight = nHeight;
    lf.lfWidth = lf. lfEscapement = lf.lfOrientation = 0;

    return CreateFontIndirect(&lf);
}

void NEAR PASCAL CF_UpdateData(HWND hDlg, UINT uPer, UINT flags)
{
    TCHAR szBuf[100];
    HFONT hfont;
    int i;
    HWND hwnd;
    int iDPI;

    if (flags & UPDATE_CURPER)
    {
        if (uPer == g_iCurPercent)
            return;

        if (uPer < MIN_PERCENT)
            uPer = MIN_PERCENT;
        else if (uPer > MAX_PERCENT)
            uPer = MAX_PERCENT;

        g_iCurPercent = uPer;
    }
    if (flags & UPDATE_COMBO)
    {
        hwnd = GetDlgItem(hDlg, IDC_CUSTOMCOMBO);
        wsprintf(szBuf, szPercentNum, g_iCurPercent);
        i = (int)SendMessage(hwnd, CB_FINDSTRINGEXACT, 0, (LPARAM)szBuf);
        SendMessage(hwnd, CB_SETCURSEL, (WPARAM)i, 0L);
        if (i == -1)
        {
            SetWindowText(hwnd, szBuf);
            UpdateWindow(hwnd);
        }
    }
    if (flags & UPDATE_RULER)
        CF_UpdateRuler(hDlg);

    if (flags & UPDATE_SAMPLE)
    {
        iDPI = GETDPI(g_iCurPercent);

        // build and set string with DPI info
        hwnd = GetDlgItem(hDlg, IDC_CUSTOMSAMPLE);
        wsprintf(szBuf, g_szSample, (LPTSTR)g_szSampleFace, iDPI);
        SetWindowText(hwnd, szBuf);

        hfont = CreateFontWithFace(hwnd, -10 * iDPI / 72, g_szSampleFace);
        if (hfont)
        {
            hfont = (HFONT)SendMessage(hwnd, WM_SETFONT, (WPARAM)hfont, 1L);
            if (hfont)
                DeleteObject(hfont);
        }
    }
}

void NEAR PASCAL CF_ReadNewPercent(HWND hDlg)
{
    TCHAR szBuf[10];
    LPTSTR pstr;
    UINT uPer = 0;

    GetWindowText(GetDlgItem(hDlg, IDC_CUSTOMCOMBO), szBuf, ARRAYSIZE(szBuf));

    pstr = szBuf;
    while (*pstr && (*pstr != TEXT('%')))
    {
        if (*pstr >= TEXT('0') && *pstr <= TEXT('9'))
            uPer = uPer * 10 + (*pstr - TEXT('0'));

        pstr++;
    }

    CF_UpdateData(hDlg, uPer, UPDATE_ALL);
}

void NEAR PASCAL CF_InitDialog(HWND hDlg, UINT uDPI)
{
    HWND hwnd;
    HDC hdc;
    HFONT hfont;
    SIZE  szSize;
    int i;
    TCHAR szBuf[10];
    int iCurSel;

    g_iCurPercent = GETPERCENT(uDPI);

    hwnd = GetDlgItem(hDlg, IDC_CUSTOMCOMBO);
    iCurSel = -1;               // assume not in list
    for (i = 0; i < NUM_DEFPERCENTS; i++)
    {
        wsprintf(szBuf, szPercentNum, g_DefaultPercents[i]);
        SendMessage(hwnd, CB_INSERTSTRING, (WPARAM)i, (LPARAM)szBuf);
        SendMessage(hwnd, CB_SETITEMDATA, (WPARAM)i, g_DefaultPercents[i]);

        if (g_iCurPercent == g_DefaultPercents[i])
            iCurSel = i;
    }
    SendMessage(hwnd, CB_SETCURSEL, (WPARAM)iCurSel, 0L);
    if (iCurSel == -1)
    {
        wsprintf(szBuf, szPercentNum, g_iCurPercent);
        SetWindowText(hwnd, szBuf);
    }

    hdc = GetDC(hDlg);
    hfont = (HFONT)SendMessage(hDlg, WM_GETFONT, 0, 0L);
    if (hfont)
        hfont = (HFONT) SelectObject(hdc, hfont);

    //dwSize = GetTextExtentPoint32(hdc, TEXT("0"), 1);
    GetTextExtentPoint32(hdc, TEXT("0"), 1, &szSize);

    g.wWidth = szSize.cx;
    g.wHeight = szSize.cy;

    LoadString(HINST_THISDLL, IDS_RULERDIRECTION, g_szRulerDirections, ARRAYSIZE(g_szRulerDirections));

    //g_cxRulerDirections = LOWORD(GetTextExtent(hdc, g_szRulerDirections, lstrlen(g_szRulerDirections)));
    GetTextExtentPoint32(hdc, g_szRulerDirections, lstrlen(g_szRulerDirections), &szSize);
    g_cxRulerDirections = szSize.cx;

    if (hfont)
        SelectObject(hdc, hfont);
    ReleaseDC(hDlg, hdc);

    // calculate the rectangle for the actual ruler drawing in relation
    // to its window
    GetClientRect(GetDlgItem(hDlg, IDC_CUSTOMRULER), &g_rcRuler);
    g_rcRuler.left += g.wWidth;
    g_rcRuler.right -= g.wWidth;

    // bottom offset like the sides
    g_rcRuler.bottom -= g.wWidth;

    LoadString(HINST_THISDLL, IDS_10PTSAMPLE, g_szSample, ARRAYSIZE(g_szSample));
    LoadString(HINST_THISDLL, IDS_10PTSAMPLEFACENAME, g_szSampleFace, ARRAYSIZE(g_szSampleFace));
    CF_UpdateData(hDlg, 0, UPDATE_SAMPLE);
}

/////////////////////////////////////////////////////////////////////////////

const static DWORD FAR aCustFontHelpIds[] = {
        // IDC_NO_HELP_1,      IDH_COMM_GROUPBOX,
        IDC_CUSTOMCOMBO, IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_CUSTOMFONT_LISTBOX,
        IDC_CUSTOMRULER, IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_CUSTOMFONT_RULER,
        IDC_CUSTOMSAMPLE,IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_CUSTOMFONT_SAMPLE,

        0, 0
};


INT_PTR CALLBACK CustomFontDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    HFONT hfont;
    int i;

    switch (uMessage)
    {
        case WM_CREATE:
            break;

        case WM_INITDIALOG:
            CF_InitDialog(hDlg, (UINT)lParam);
            break;

        case WM_DESTROY:
            hfont = (HFONT)SendDlgItemMessage(hDlg, IDC_CUSTOMSAMPLE, WM_GETFONT, 0, 0L);
            if (hfont)
                DeleteObject(hfont);
            break;

        case WM_DRAWITEM:
            if (wParam == IDC_CUSTOMRULER)
                DrawRuler(hDlg, (LPDRAWITEMSTRUCT)lParam);
            break;

        case WM_TIMER:
            if (g_bTypeTimer)
            {
                KillTimer(hDlg, 13);
                g_bTypeTimer = FALSE;
                CF_ReadNewPercent(hDlg);
            }
            break;

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, TEXT("display.hlp"), HELP_WM_HELP,
                (DWORD_PTR)(LPTSTR)aCustFontHelpIds);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, TEXT("display.hlp"), HELP_CONTEXTMENU,
                (DWORD_PTR)(LPTSTR)aCustFontHelpIds);
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    EndDialog(hDlg, GETDPI(g_iCurPercent));
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, 0);
                    break;

                case IDC_CUSTOMRULER:
                    switch (HIWORD(wParam))
                    {
                        case DSN_NCCREATE:
                            SetWindowLong((HWND)lParam, GWL_EXSTYLE,
                                    GetWindowLong((HWND)lParam, GWL_EXSTYLE) | WS_EX_WINDOWEDGE);
                            break;

                        case DSN_BEGINDRAG:
                            // Set the focus to the corresponding edit ctl
                            SendMessage(hDlg, WM_NEXTDLGCTL,
                                        (WPARAM)GetDlgItem(hDlg, IDC_CUSTOMCOMBO), 1L);

                            SendMessage((HWND)lParam, DSM_DRAGPOS, 0, (LPARAM)&(g.wStartPos));

                            if ((int)g.wStartPos < g_rcRuler.left)
                            {
                                g.wStartPos = g_rcRuler.left;
                            }
                            g.wStartPix = g_iCurPercent;
                            break;

                        case DSN_DRAGGING:
                        {
                            UINT wNow, wPix;
                            POINT pt;

                            //wNow = LOWORD(SendMessage((HWND)lParam, DSM_DRAGPOS, 0, 0L));
                            SendMessage((HWND)lParam, DSM_DRAGPOS, 0, (LPARAM)&pt);
                            wNow = pt.x;

                            if ((int)wNow < g_rcRuler.left)
                            {
                                wNow = g_rcRuler.left;
                            }

                            wPix = LOWORD((DWORD)wNow*g.wStartPix/g.wStartPos);
                            if (wPix < MIN_PERCENT)
                            {
                                wPix = MIN_PERCENT;
                            }
                            if (wPix > MAX_PERCENT)
                            {
                                wPix = MAX_PERCENT;
                            }

                            if (wPix != g_iCurPercent)
                            {
                                CF_ShowNewPercent(hDlg, wPix);
                                CF_UpdateRuler(hDlg);
                            }
                            break;
                        }

                        case DSN_ENDDRAG:
                            CF_UpdateData(hDlg, 0, UPDATE_COMBO | UPDATE_SAMPLE);
                            break;

                        default:
                            break;
                        }
                    break;

                case IDC_CUSTOMCOMBO:
                    switch(HIWORD(wParam))
                    {
                        case CBN_SELCHANGE:
                            i = (int)SendDlgItemMessage(hDlg, IDC_CUSTOMCOMBO, CB_GETCURSEL, 0, 0L);
                            if (i != CB_ERR)
                            {
                                i = LOWORD(SendDlgItemMessage(hDlg, IDC_CUSTOMCOMBO, CB_GETITEMDATA, (WPARAM)i, 0L));
                                CF_UpdateData(hDlg, (UINT)i, UPDATE_CURPER | UPDATE_SAMPLE | UPDATE_RULER);
                            }
                            break;

                        case CBN_EDITCHANGE:
                            if (g_bTypeTimer)
                            {
                                KillTimer(hDlg, 13);
                            }
                            g_bTypeTimer = TRUE;
                            SetTimer(hDlg, 13, 500, NULL);
                            break;
                    }
                    break;

                default:
                        return(FALSE);
            }
            break;

        default:
            return(FALSE);
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\debug.cpp ===
/*****************************************************************************\
    FILE: debug.cpp

    DESCRIPTION:
       Debug information.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "priv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "THEMEUI"
#define SZ_MODULE           "THEMEUI"
#define DECLARE_DEBUG

#include <ccstock.h>
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\coverwnd.cpp ===
#include "priv.h"
#include "CoverWnd.h"
#include <ginarcid.h>

#undef IDB_BACKGROUND_24
#define IDB_BACKGROUND_24                 0x3812
#undef IDB_FLAG_24
#define IDB_FLAG_24                       0x3813

const TCHAR g_szWindowClassName[] = TEXT("CoverWindowClass");
const TCHAR g_szPleaseWaitName[] = TEXT("PleaseWaitWindowClass");

#define CHUNK_SIZE           20
#define IDT_KILLYOURSELF     1
#define IDT_UPDATE           2
#define WM_DESTORYYOURSELF      (WM_USER + 0)

void DimPixels(ULONG* pulSrc, int cLen, int Amount)
{
    for (int i = cLen - 1; i >= 0; i--)
    {
        ULONG ulR = GetRValue(*pulSrc);
        ULONG ulG = GetGValue(*pulSrc);
        ULONG ulB = GetBValue(*pulSrc);
        ULONG ulGray = (54 * ulR + 183 * ulG + 19 * ulB) >> 8;
        ULONG ulTemp = ulGray * (0xff - Amount);
        ulR = (ulR * Amount + ulTemp) >> 8;
        ulG = (ulG * Amount + ulTemp) >> 8;
        ulB = (ulB * Amount + ulTemp) >> 8;
        *pulSrc = (*pulSrc & 0xff000000) | RGB(ulR, ulG, ulB);

        pulSrc++;
    }
}

LRESULT CALLBACK PleaseWaitWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lParam)
{
    switch ( msg )
    {
    case WM_CREATE:
        {
            CREATESTRUCT* pCS = (CREATESTRUCT*)lParam;
            SetWindowLongPtr( hwnd, GWLP_USERDATA, (LPARAM) pCS->lpCreateParams );
            HBITMAP hbmBackground = (HBITMAP) pCS->lpCreateParams;
            BITMAP bm;
            if ( GetObject( hbmBackground, sizeof(bm), &bm ) )
            {
                RECT rc;
                HWND hwndParent = GetParent( hwnd );
                GetClientRect( hwndParent, &rc );

                POINT pt = {0,0};
                HMONITOR hmon = MonitorFromPoint(pt, MONITOR_DEFAULTTOPRIMARY);
                if (hmon)
                {
                    MONITORINFO mi = {sizeof(mi)};
                    GetMonitorInfo(hmon, &mi);
                    rc = mi.rcMonitor;
                    MapWindowPoints(HWND_DESKTOP, hwndParent, (LPPOINT)&rc, 2);
                }

                // Center dialog in the center of the virtual screen
                int x = ( rc.right - rc.left - bm.bmWidth ) / 2;
                int y = ( rc.bottom - rc.top - bm.bmHeight ) / 2;

                SetWindowPos( hwnd, NULL, x, y, bm.bmWidth, bm.bmHeight, SWP_NOZORDER | SWP_NOACTIVATE );
            }
        }
        return TRUE;

    case WM_PAINT:
        {
            HBITMAP hbmBackground = (HBITMAP) GetWindowLongPtr( hwnd, GWLP_USERDATA );

            PAINTSTRUCT ps;
            HDC hdc = BeginPaint( hwnd, &ps );

            BITMAP bm;

            if ( hbmBackground )
            {
                DWORD dwLayout = SetLayout(hdc, LAYOUT_BITMAPORIENTATIONPRESERVED);
                if ( GetObject( hbmBackground, sizeof(bm), &bm ) )
                {
                    HDC hdcBackground = CreateCompatibleDC( hdc );
                    if (hdcBackground)
                    {
                        HBITMAP hbmOld = (HBITMAP) SelectObject( hdcBackground, hbmBackground );
                        BitBlt(hdc, 0, 0, bm.bmWidth, bm.bmHeight, hdcBackground, 0, 0, SRCCOPY);
                        SelectObject( hdcBackground, hbmOld );
                        DeleteDC( hdcBackground );
                    }
                }
                SetLayout(hdc, dwLayout);

                // Don't draw more the once, no one will be on top of us
                DeleteObject(hbmBackground);
                SetWindowLongPtr( hwnd, GWLP_USERDATA, NULL );

                HFONT hfntSelected = NULL;
                HFONT hfntButton = NULL;
                HINSTANCE hMsGina = LoadLibrary( L"msgina.dll" );
                if ( hMsGina )
                {
                    CHAR szPixelSize[ 32 ];
                    if (LoadStringA(hMsGina,
                                    IDS_TURNOFF_TITLE_FACESIZE,
                                    szPixelSize,
                                    ARRAYSIZE(szPixelSize)) != 0)
                    {
                        LOGFONT logFont = { 0 };
                        logFont.lfHeight = -MulDiv(atoi(szPixelSize), GetDeviceCaps(hdc, LOGPIXELSY), 72);

                        if (LoadString(hMsGina,
                                       IDS_TURNOFF_TITLE_FACENAME,
                                       logFont.lfFaceName,
                                       LF_FACESIZE) != 0)
                        {
                            logFont.lfWeight = FW_BOLD;
                            logFont.lfQuality = DEFAULT_QUALITY;
                            hfntButton = CreateFontIndirect(&logFont);

                            hfntSelected = static_cast<HFONT>(SelectObject(hdc, hfntButton));
                        }
                    }                
                }

                COLORREF colorButtonText = RGB(255, 255, 255);
                COLORREF colorText = SetTextColor(hdc, colorButtonText);
                int iBkMode = SetBkMode(hdc, TRANSPARENT);

                WCHAR szText[MAX_PATH];
                szText[0] = 0;
                LoadString((HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE), IDS_PLEASEWAIT, szText, ARRAYSIZE(szText));
                RECT  rcText;
                RECT  rcClient;
                RECT  rc;

                TBOOL(GetClientRect( hwnd, &rcClient ));
                TBOOL(CopyRect(&rcText, &rcClient));
                DWORD dwFlags = DT_HIDEPREFIX | (IS_MIRRORING_ENABLED() ? DT_RTLREADING : 0);
                int iPixelHeight = DrawText( hdc, szText, -1, &rcText, DT_CALCRECT | dwFlags);
                TBOOL(CopyRect(&rc, &rcClient));
                TBOOL(InflateRect(&rc, -((rc.right - rc.left - (rcText.right - rcText.left)) / 2), -((rc.bottom - rc.top - iPixelHeight) / 2)));
                (int)DrawText(hdc, szText, -1, &rc, dwFlags );
                (int)SetBkMode(hdc, iBkMode);
                (COLORREF)SetTextColor(hdc, colorText);

                if ( hfntButton )
                {
                    (HGDIOBJ)SelectObject(hdc, hfntSelected);
                    DeleteObject( hfntButton  );
                }
            }

            EndPaint( hwnd, &ps );
        }
        break;

    case WM_ERASEBKGND:
        return TRUE;

    default:
        return DefWindowProc( hwnd, msg, wp, lParam );
        break;
    }

    return 0;
}


CDimmedWindow::CDimmedWindow (HINSTANCE hInstance) :
    _lReferenceCount(1),
    _hInstance(hInstance)
{
    WNDCLASSEX  wndClassEx;

    ZeroMemory(&wndClassEx, sizeof(wndClassEx));
    wndClassEx.cbSize = sizeof(wndClassEx);
    wndClassEx.lpfnWndProc = WndProc;
    wndClassEx.hInstance = hInstance;
    wndClassEx.lpszClassName = g_szWindowClassName;
    wndClassEx.hCursor = LoadCursor(NULL, IDC_WAIT);
    _atom = RegisterClassEx(&wndClassEx);

    wndClassEx.lpszClassName = g_szPleaseWaitName;
    wndClassEx.lpfnWndProc = PleaseWaitWndProc;
    _atomPleaseWait = RegisterClassEx(&wndClassEx);
}

CDimmedWindow::~CDimmedWindow (void)
{
    if (_hwnd)
    {
        PostMessage(_hwnd, WM_DESTORYYOURSELF, 0, 0);
    }

    if (_atom != 0)
    {
        TBOOL(UnregisterClass(MAKEINTRESOURCE(_atom), _hInstance));
    }

    if (_atomPleaseWait != 0 )
    {
        TBOOL(UnregisterClass(MAKEINTRESOURCE(_atomPleaseWait), _hInstance));
    }
}

ULONG CDimmedWindow::AddRef (void)
{
    return(InterlockedIncrement(&_lReferenceCount));
}

ULONG CDimmedWindow::Release (void)
{
    LONG    lReferenceCount;

    lReferenceCount = InterlockedDecrement(&_lReferenceCount);

    ASSERTMSG(lReferenceCount >= 0, "Reference count negative or zero in CDimmedWindow::Release");

    if (lReferenceCount == 0)
    {
        delete this;
    }

    return(lReferenceCount);
}

DWORD CDimmedWindow::WorkerThread(IN void *pv)
{
    ASSERT(pv);
    HWND hwnd = NULL;
    CDimmedWindow* pDimmedWindow = (CDimmedWindow*)pv;
    BOOL    fScreenReader;
    bool    fNoDebuggerPresent, fNoScreenReaderPresent;
    BOOL fUserTurnedOffWindow = SHRegGetBoolUSValue(SZ_THEMES, L"NoCoverWindow", FALSE, FALSE);     // Needed for perf testing

    fNoDebuggerPresent = !IsDebuggerPresent();
    fNoScreenReaderPresent = ((SystemParametersInfo(SPI_GETSCREENREADER, 0, &fScreenReader, 0) == FALSE) || (fScreenReader == FALSE));
    if (fNoDebuggerPresent &&
        fNoScreenReaderPresent &&
        !fUserTurnedOffWindow)
    {
        int xVirtualScreen = GetSystemMetrics(SM_XVIRTUALSCREEN);
        int yVirtualScreen = GetSystemMetrics(SM_YVIRTUALSCREEN);
        int cxVirtualScreen = GetSystemMetrics(SM_CXVIRTUALSCREEN);
        int cyVirtualScreen = GetSystemMetrics(SM_CYVIRTUALSCREEN);
        HWND hwnd = CreateWindowEx(WS_EX_TOPMOST,
                               g_szWindowClassName,
                               NULL,
                               WS_POPUP | WS_CLIPCHILDREN,
                               xVirtualScreen, yVirtualScreen,
                               cxVirtualScreen, cyVirtualScreen,
                               NULL, NULL, pDimmedWindow->_hInstance, NULL);
        if (hwnd != NULL)
        {
            bool    fDimmed;
            HBITMAP hbmBackground = NULL;

            fDimmed = false;
            (BOOL)ShowWindow(hwnd, SW_SHOW);
            TBOOL(SetForegroundWindow(hwnd));

            (BOOL)EnableWindow(hwnd, FALSE);

            SetTimer(hwnd, IDT_KILLYOURSELF, pDimmedWindow->_ulKillTimer, NULL);

            // Now create bitmap with background image and the windows flag
            HINSTANCE hShell32 = LoadLibrary( L"shell32.dll" );
            if ( NULL != hShell32 )
            {
                hbmBackground = (HBITMAP) LoadImage( hShell32, MAKEINTRESOURCE( IDB_BACKGROUND_24 ), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION | LR_DEFAULTSIZE );

                if (hbmBackground)
                {
                    HDC hdcMem1 = CreateCompatibleDC(NULL);
                    if (hdcMem1)
                    {
                        HDC hdcMem2 = CreateCompatibleDC(NULL);
                        if (hdcMem2)
                        {
                            HBITMAP hbmFlag = (HBITMAP) LoadImage( hShell32, MAKEINTRESOURCE( IDB_FLAG_24 ), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION | LR_DEFAULTSIZE );
                            if (hbmFlag)
                            {
                                HBITMAP hbmOld1 = (HBITMAP)SelectObject(hdcMem1, hbmBackground);
                                HBITMAP hbmOld2 = (HBITMAP)SelectObject(hdcMem2, hbmFlag);

                                BITMAP bm1;
                                if (GetObject(hbmBackground, sizeof(bm1), &bm1))
                                {
                                    BITMAP bm2;
                                    if (GetObject(hbmFlag, sizeof(bm2), &bm2))
                                    {
                                        BitBlt(hdcMem1, bm1.bmWidth - bm2.bmWidth - 8, 0, bm2.bmWidth, bm2.bmHeight, hdcMem2, 0, 0, SRCCOPY);
                                    }
                                }

                                SelectObject(hdcMem1, hbmOld1);
                                SelectObject(hdcMem2, hbmOld2);
                                DeleteObject(hbmFlag);
                            }
                            DeleteDC(hdcMem2);
                        }
                        DeleteDC(hdcMem1);
                    }
                }

                FreeLibrary( hShell32 );
            }

            HWND hwndPleaseWait = CreateWindowEx( 0
                                                , g_szPleaseWaitName
                                                , NULL
                                                , WS_CHILD | WS_VISIBLE | WS_BORDER
                                                , 0
                                                , 0
                                                , 100
                                                , 100
                                                , hwnd
                                                , NULL
                                                , pDimmedWindow->_hInstance
                                                , hbmBackground   // the window is responsible for freeing it.
                                                );
            if ( NULL == hwndPleaseWait )
            {
                DeleteObject( hbmBackground );
            }

            pDimmedWindow->_hwnd = hwnd;
            // This Release matches the addref during ::Create to guarantee that the object does not die before the HWND
            // is created.
            pDimmedWindow->Release();

            MSG msg;
            while (GetMessage(&msg, NULL, 0, 0))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
                if ((msg.message == WM_DESTORYYOURSELF) && (msg.hwnd == hwnd))
                {
                    break;
                }
            }
        }
    }

    return (hwnd == NULL ? E_FAIL : S_OK);
}

HRESULT CDimmedWindow::Create (UINT ulKillTimer)
{
    BOOL fSucceeded = FALSE;
    
    if (!_hwnd)
    {
        _ulKillTimer = ulKillTimer;
        AddRef();
        fSucceeded = SHCreateThread(CDimmedWindow::WorkerThread, (void *)this, CTF_INSIST, NULL);
        if (!fSucceeded)
        {
            Release();
        }
    }

    return fSucceeded ? S_OK : E_FAIL;
}

typedef struct
{
    HDC     hdcDimmed;
    HBITMAP hbmDimmed;
    HBITMAP hbmOldDimmed;
    HDC     hdcTemp;
    HBITMAP hbmTemp;
    HBITMAP hbmOldTemp;
    ULONG*  pulSrc;
    int     idxSaturation;
    int     idxChunk;
    int     idxProgress;
} DIMMEDWINDOWDATA;

LRESULT     CALLBACK    CDimmedWindow::WndProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT           lResult = 0;
    DIMMEDWINDOWDATA *pData;

    pData = (DIMMEDWINDOWDATA *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (uMsg)
    {
        case WM_CREATE:
        {
            CREATESTRUCT* pCS = (CREATESTRUCT*)lParam;
            if (pCS)
            {
                pData = new DIMMEDWINDOWDATA;
                if (pData)
                {
                    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pData);
                    // On remote session we don't gray out the screen, yeah :-)
                    if (!GetSystemMetrics(SM_REMOTESESSION))
                    {
                        HDC hdcWindow = GetDC(hwnd);
                        if (hdcWindow != NULL )
                        {
                            pData->hdcDimmed = CreateCompatibleDC(hdcWindow);
                            if (pData->hdcDimmed)
                            {
                                BITMAPINFO  bmi;

                                ZeroMemory(&bmi, sizeof(bmi));
                                bmi.bmiHeader.biSize = sizeof(bmi);
                                bmi.bmiHeader.biWidth =  pCS->cx;
                                bmi.bmiHeader.biHeight = pCS->cy;
                                bmi.bmiHeader.biPlanes = 1;
                                bmi.bmiHeader.biBitCount = 32;
                                bmi.bmiHeader.biCompression = BI_RGB;
                                bmi.bmiHeader.biSizeImage = 0;

                                pData->hbmDimmed = CreateDIBSection(pData->hdcDimmed, &bmi, DIB_RGB_COLORS, (LPVOID*)&pData->pulSrc, NULL, 0);
                                if (pData->hbmDimmed != NULL)
                                {
                                    pData->hbmOldDimmed = (HBITMAP) SelectObject(pData->hdcDimmed, pData->hbmDimmed);
                                    pData->idxSaturation = 8;
                                    pData->idxChunk = pCS->cy / CHUNK_SIZE;
                                }
                                else
                                {
                                    DeleteDC(pData->hdcDimmed);
                                    pData->hdcDimmed = NULL;
                                }
                            }

                            pData->hdcTemp = CreateCompatibleDC(hdcWindow);
                            if (pData->hdcTemp)
                            {
                                pData->hbmTemp = CreateCompatibleBitmap(hdcWindow, pCS->cx, pCS->cy);
                                if (pData->hbmTemp)
                                {
                                    pData->hbmOldTemp = (HBITMAP) SelectObject(pData->hdcTemp, pData->hbmTemp);
                                }
                                else
                                {
                                    DeleteDC(pData->hdcTemp);
                                    pData->hdcTemp = NULL;
                                }
                            }

                            ReleaseDC(hwnd, hdcWindow);
                        }
                    }

                    if (pData->hdcDimmed)
                    {
                        SetTimer(hwnd, IDT_UPDATE, 30, NULL);
                    }
                }
            }
            break;
        }

        case WM_DESTORYYOURSELF:
        {
            DestroyWindow(hwnd);
            break;
        }

        case WM_DESTROY:
        {
            if (pData)
            {
                SetWindowLongPtr(hwnd, GWLP_USERDATA, NULL);
                KillTimer(hwnd, IDT_UPDATE);
                KillTimer(hwnd, IDT_KILLYOURSELF);

                if (pData->hdcDimmed)
                {
                    SelectObject(pData->hdcDimmed, pData->hbmOldDimmed);
                    DeleteDC(pData->hdcDimmed);
                    pData->hdcDimmed = NULL;
                }

                if (pData->hbmDimmed)
                {
                    DeleteObject(pData->hbmDimmed);
                    pData->hbmDimmed = NULL;
                }

                if (pData->hdcTemp)
                {
                    SelectObject(pData->hdcTemp, pData->hbmOldTemp);
                    DeleteDC(pData->hdcTemp);
                    pData->hdcTemp = NULL;
                }

                if (pData->hbmTemp)
                {
                    DeleteObject(pData->hbmTemp);
                    pData->hbmTemp = NULL;
                }

                delete pData;
            }
            break;
        }

        case WM_TIMER:
            if (pData)
            {
                BOOL fDestroyBitmaps = FALSE;

                if (wParam == IDT_KILLYOURSELF)
                {
                    ShowWindow(hwnd, SW_HIDE);

                    fDestroyBitmaps = TRUE;
                }
                else if (pData->hdcDimmed && pData->hbmDimmed)
                {
                    HDC hdcWindow = GetDC(hwnd);

                    BITMAP bm;
                    GetObject(pData->hbmDimmed, sizeof(BITMAP), &bm);

                    if (pData->idxChunk >= 0 )
                    {
                        //
                        //  In the first couple of passes, we slowly collect the screen 
                        //  into our bitmap. We do this because Blt-ing the whole thing
                        //  causes the system to hang. By doing it this way, we continue
                        //  to pump messages, the UI stays responsive and it keeps the 
                        //  mouse alive.
                        //

                        int y  = pData->idxChunk * CHUNK_SIZE;
                        if (pData->hdcTemp)
                        {
                            BitBlt(pData->hdcTemp, 0, y, bm.bmWidth, CHUNK_SIZE, hdcWindow, 0, y, SRCCOPY);
                            BitBlt(pData->hdcDimmed, 0, y, bm.bmWidth, CHUNK_SIZE, pData->hdcTemp, 0, y, SRCCOPY);
                        }
                        else
                        {
                            BitBlt(pData->hdcDimmed, 0, y, bm.bmWidth, CHUNK_SIZE, hdcWindow, 0, y, SRCCOPY);
                        }

                        pData->idxChunk--;
                        if (pData->idxChunk < 0)
                        {
                            //
                            //  We're done getting the bitmap, now reset the timer
                            //  so we slowly fade to grey.
                            //

                            SetTimer(hwnd, IDT_UPDATE, 250, NULL);
                            pData->idxSaturation = 16;
                        }
                    }
                    else
                    {
                        //
                        //  In these passes, we are making the image more and more grey and
                        //  then Blt-ing the result to the screen.
                        //

                        DimPixels(pData->pulSrc, bm.bmWidth * bm.bmHeight, 0xd5);
                        BitBlt(hdcWindow, 0, 0, bm.bmWidth, bm.bmHeight, pData->hdcDimmed, 0, 0, SRCCOPY);

                        pData->idxSaturation--;

                        if (pData->idxSaturation <= 0) // when we hit zero, kill the timer.
                        {
                            KillTimer(hwnd, IDT_UPDATE);
                            fDestroyBitmaps = TRUE;
                        }
                    }
                }

                if (fDestroyBitmaps)
                {
                    if (pData->hdcDimmed)
                    {
                        SelectObject(pData->hdcDimmed, pData->hbmOldDimmed);
                        DeleteDC(pData->hdcDimmed);
                        pData->hdcDimmed = NULL;
                    }

                    if (pData->hbmDimmed)
                    {
                        DeleteObject(pData->hbmDimmed);
                        pData->hbmDimmed = NULL;
                    }

                    if (pData->hdcTemp)
                    {
                        SelectObject(pData->hdcTemp, pData->hbmOldTemp);
                        DeleteDC(pData->hdcTemp);
                        pData->hdcTemp = NULL;
                    }

                    if (pData->hbmTemp)
                    {
                        DeleteObject(pData->hbmTemp);
                        pData->hbmTemp = NULL;
                    }
                }
            }
            break;

        case WM_WINDOWPOSCHANGING:
            {
                LPWINDOWPOS pwp = (LPWINDOWPOS) lParam;
                pwp->flags |= SWP_NOSIZE | SWP_NOMOVE;
            }
            break;

        case WM_PAINT:
        {
            HDC             hdcPaint;
            PAINTSTRUCT     ps;

            hdcPaint = BeginPaint(hwnd, &ps);
            TBOOL(EndPaint(hwnd, &ps));
            lResult = 0;
            break;
        }
        default:
            lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);
            break;
    }

    return(lResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\deskcmmn.cpp ===
#include "priv.h"
#include "deskcmmn.h"
#include <regstr.h>
#include <ccstock.h>


static const TCHAR sc_szDeskAppletSoftwareKey[] = REGSTR_PATH_CONTROLSFOLDER TEXT("\\Display");

LPTSTR SubStrEnd(LPTSTR pszTarget, LPTSTR pszScan)
    {
    int i;
    for (i = 0; pszScan[i] != TEXT('\0') && pszTarget[i] != TEXT('\0') &&
            CharUpperChar(pszScan[i]) == CharUpperChar(pszTarget[i]); i++);

    if (pszTarget[i] == TEXT('\0'))
        {
        // we found the substring
        return pszScan + i;
        }

    return pszScan;
    }


BOOL GetDeviceRegKey(LPCTSTR pstrDeviceKey, HKEY* phKey, BOOL* pbReadOnly)
    {
    //ASSERT(lstrlen(pstrDeviceKey) < MAX_PATH);

    if(lstrlen(pstrDeviceKey) >= MAX_PATH)
        return FALSE;

    BOOL bRet = FALSE;

    // copy to local string
    TCHAR szBuffer[MAX_PATH];
    lstrcpy(szBuffer, pstrDeviceKey);

    //
    // At this point, szBuffer has something like:
    //  \REGISTRY\Machine\System\ControlSet001\Services\Jazzg300\Device0
    //
    // To use the Win32 registry calls, we have to strip off the \REGISTRY
    // and convert \Machine to HKEY_LOCAL_MACHINE
    //

    LPTSTR pszRegistryPath = SubStrEnd(SZ_REGISTRYMACHINE, szBuffer);

    if(pszRegistryPath)
        {
        // Open the registry key
        bRet = (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             pszRegistryPath,
                             0,
                             KEY_ALL_ACCESS,
                             phKey) == ERROR_SUCCESS);
        if(bRet)
            {
            *pbReadOnly = FALSE;
            }
        else
            {
            bRet = (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 pszRegistryPath,
                                 0,
                                 KEY_READ,
                                 phKey) == ERROR_SUCCESS);
            if (bRet)
                {
                *pbReadOnly = TRUE;
                }
            }
        }

    return bRet;
    }


int GetDisplayCPLPreference(LPCTSTR szRegVal)
{
    int val = -1;
    HKEY hk;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, sc_szDeskAppletSoftwareKey, 0, KEY_READ, &hk) == ERROR_SUCCESS)
    {
        TCHAR sz[64];
        DWORD cb = sizeof(sz);

        *sz = 0;
        if ((RegQueryValueEx(hk, szRegVal, NULL, NULL,
            (LPBYTE)sz, &cb) == ERROR_SUCCESS) && *sz)
        {
            val = StrToInt(sz);
        }

        RegCloseKey(hk);
    }

    if (val == -1 && RegOpenKeyEx(HKEY_LOCAL_MACHINE, sc_szDeskAppletSoftwareKey, 0, KEY_READ, &hk) == ERROR_SUCCESS)
    {
        TCHAR sz[64];
        DWORD cb = sizeof(sz);

        *sz = 0;
        if ((RegQueryValueEx(hk, szRegVal, NULL, NULL,
            (LPBYTE)sz, &cb) == ERROR_SUCCESS) && *sz)
        {
            val = StrToInt(sz);
        }

        RegCloseKey(hk);
    }

    return val;
}


int GetDynaCDSPreference()
{
//DLI: until we figure out if this command line stuff is still needed.
//    if (g_fCommandLineModeSet)
//        return DCDSF_YES;

    int iRegVal = GetDisplayCPLPreference(REGSTR_VAL_DYNASETTINGSCHANGE);
    if (iRegVal == -1)
        iRegVal = DCDSF_DYNA; // Apply dynamically
    return iRegVal;
}


void SetDisplayCPLPreference(LPCTSTR szRegVal, int val)
{
    HKEY hk;

    if (RegCreateKeyEx(HKEY_CURRENT_USER, sc_szDeskAppletSoftwareKey, 0, TEXT(""), 0, KEY_WRITE, NULL, &hk, NULL) ==
        ERROR_SUCCESS)
    {
        TCHAR sz[64];

        wsprintf(sz, TEXT("%d"), val);
        RegSetValueEx(hk, szRegVal, NULL, REG_SZ,
            (LPBYTE)sz, lstrlen(sz) + 1);

        RegCloseKey(hk);
    }
}


BOOL
AllocAndReadInterfaceName(
    IN  LPTSTR pDeviceKey,
    OUT LPWSTR* ppInterfaceName
    )

/*

    Note: If this function retuns success, the caller is responsible
          to free the memory pointed by *ppInterfaceName

*/

{
    BOOL bSuccess = FALSE;
    LPTSTR pszPath = NULL;
    HKEY hkDevice = 0;
    HKEY hkVolatileSettings = 0;

    //ASSERT (pDeviceKey != NULL);

    pszPath = SubStrEnd(SZ_REGISTRYMACHINE, pDeviceKey);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     pszPath,
                     0,
                     KEY_READ,
                     &hkDevice) != ERROR_SUCCESS) {

        hkDevice = 0;
        goto Cleanup;
    }

    if (RegOpenKeyEx(hkDevice,
                     SZ_VOLATILE_SETTINGS,
                     0,
                     KEY_READ,
                     &hkVolatileSettings) != ERROR_SUCCESS) {

        hkVolatileSettings = 0;
        goto Cleanup;
    }

    bSuccess = AllocAndReadValue(hkVolatileSettings,
                                 SZ_DISPLAY_ADAPTER_INTERFACE_NAME,
                                 ppInterfaceName);

Cleanup:

    if (hkVolatileSettings) {
        RegCloseKey(hkVolatileSettings);
    }

    if (hkDevice) {
        RegCloseKey(hkDevice);
    }

    return bSuccess;
}


BOOL
AllocAndReadInstanceID(
    IN  LPTSTR pDeviceKey,
    OUT LPWSTR* ppInstanceID
    )

/*

    Note: If this function retuns success, the caller is responsible
          to free the memory pointed by *ppInstanceID

*/

{
    LPTSTR pDeviceKeyCopy = NULL, pDeviceKeyCopy2 = NULL;
    LPTSTR pTemp = NULL, pX = NULL;
    BOOL bSuccess = FALSE;
    HKEY hkEnum = 0;
    HKEY hkService = 0;
    HKEY hkCommon = 0;
    DWORD Count = 0;
    DWORD cb = 0, len = 0;

    //ASSERT (pDeviceKey != NULL);

    //
    // Make a copy of pDeviceKey
    //

    len = (DWORD)max (256, (lstrlen(pDeviceKey) + 6) * sizeof(TCHAR));
    pDeviceKeyCopy2 = pDeviceKeyCopy = (LPTSTR)LocalAlloc(LPTR, len);

    if (pDeviceKeyCopy == NULL) {
        goto Cleanup;
    }

    lstrcpy(pDeviceKeyCopy, pDeviceKey);
    pTemp = SubStrEnd(SZ_REGISTRYMACHINE, pDeviceKeyCopy);
    pDeviceKeyCopy = pTemp;

    //
    // Open the service key
    //

    pTemp = pDeviceKeyCopy + lstrlen(pDeviceKeyCopy);

    while ((pTemp != pDeviceKeyCopy) && (*pTemp != TEXT('\\'))) {
        pTemp--;
    }

    if (pTemp == pDeviceKeyCopy) {
        goto Cleanup;
    }

    pX = SubStrEnd(SZ_DEVICE, pTemp);

    if (pX == pTemp) {

        //
        // The new key is used: CCS\Control\Video\[GUID]\000X
        //

        *pTemp = UNICODE_NULL;

        lstrcat(pDeviceKeyCopy, SZ_COMMON_SUBKEY);

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         pDeviceKeyCopy,
                         0,
                         KEY_READ,
                         &hkCommon) != ERROR_SUCCESS) {
            
            hkCommon = 0;
            goto Cleanup;
        }
    
        pDeviceKeyCopy = pDeviceKeyCopy2;

        ZeroMemory(pDeviceKeyCopy, len);
        
        lstrcpy(pDeviceKeyCopy, SZ_SERVICES_PATH);

        cb = len - (lstrlen(pDeviceKeyCopy) + 1) * sizeof(TCHAR);

        if (RegQueryValueEx(hkCommon,
                            SZ_SERVICE,
                            NULL,
                            NULL,
                            (LPBYTE)(pDeviceKeyCopy + lstrlen(pDeviceKeyCopy)),
                            &cb) != ERROR_SUCCESS) {
            
            goto Cleanup;
        }

    } else {

        //
        // The old key is used: CCS\Services\[SrvName]\DeviceX
        //

        *pTemp = UNICODE_NULL;
    }

    //
    // Open the ServiceName key
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     pDeviceKeyCopy,
                     0,
                     KEY_READ,
                     &hkService) != ERROR_SUCCESS) {

        hkService = 0;
        goto Cleanup;
    }
    
    //
    // Open the "Enum" key under the devicename
    //

    if (RegOpenKeyEx(hkService,
                     SZ_ENUM,
                     0,
                     KEY_READ,
                     &hkEnum) != ERROR_SUCCESS) {
        hkEnum = 0;
        goto Cleanup;
    }

    cb = sizeof(Count);
    if ((RegQueryValueEx(hkEnum,
                         SZ_VU_COUNT,
                         NULL,
                         NULL,
                         (LPBYTE)&Count,
                         &cb) != ERROR_SUCCESS) ||
        (Count != 1)) {

        //
        // Igonore the case when there are at least 2 devices.
        //

        goto Cleanup;
    }

    bSuccess = AllocAndReadValue(hkEnum, TEXT("0"), ppInstanceID);

Cleanup:

    if (hkEnum != 0) {
        RegCloseKey(hkEnum);
    }

    if (hkService != 0) {
        RegCloseKey(hkService);
    }

    if (hkCommon != 0) {
        RegCloseKey(hkCommon);
    }
    
    if (pDeviceKeyCopy2 != NULL) {
        LocalFree(pDeviceKeyCopy2);
    }

    return bSuccess;
}


BOOL
AllocAndReadValue(
    IN  HKEY hkKey,
    IN  LPTSTR pValueName,
    OUT LPWSTR* ppwValueData
    )

/*

    Note: If this function retuns success, the caller is responsible
          to free the memory pointed by *ppwValueData

*/

{
    LPWSTR pwValueData = NULL;
    DWORD AllocUnit = 64;
    DWORD cBytes = 0;
    BOOL bSuccess = FALSE;
    LONG Error = ERROR_SUCCESS;

    while (!bSuccess) {

        AllocUnit *= 2;
        cBytes = AllocUnit * sizeof(WCHAR);

        pwValueData = (LPWSTR)(LocalAlloc(LPTR, cBytes));
        if (pwValueData == NULL)
            break;

        Error = RegQueryValueEx(hkKey,
                                pValueName,
                                NULL,
                                NULL,
                                (LPBYTE)pwValueData,
                                &cBytes);

        bSuccess = (Error == ERROR_SUCCESS);

        if (!bSuccess) {

            LocalFree(pwValueData);
            pwValueData = NULL;

            if (Error != ERROR_MORE_DATA)
                break;
        }
    }

    if (bSuccess) {
        *ppwValueData = pwValueData;
    }

    return bSuccess;
}


BOOL
DeleteKeyAndSubkeys(
    HKEY hKey,
    LPCTSTR lpSubKey
    )
{
    HKEY hkDeleteKey;
    TCHAR szChild[MAX_PATH + 1];
    BOOL bReturn = FALSE;

    if (RegOpenKey(hKey, lpSubKey, &hkDeleteKey) == ERROR_SUCCESS) {

        bReturn = TRUE;
        while (RegEnumKey(hkDeleteKey, 0, szChild, MAX_PATH) ==
               ERROR_SUCCESS) {
            if (!DeleteKeyAndSubkeys(hkDeleteKey, szChild)) {
                bReturn = FALSE;
                break;
            }
        }

        RegCloseKey(hkDeleteKey);

        if (bReturn)
            bReturn = (RegDeleteKey(hKey, lpSubKey) == ERROR_SUCCESS);
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\deskcplext.h ===
#define DESKCPLEXT_DISPLAY_DEVICE       TEXT("Display Device")  // "\DisplayX"
#define DESKCPLEXT_DISPLAY_NAME         TEXT("Display Name")    // " ATI Mach64 Turbo 3 "
#define DESKCPLEXT_MONITOR_DEVICE       TEXT("Monitor Device")  // " \DisplayX\MonitorX "
#define DESKCPLEXT_MONITOR_NAME         TEXT("Monitor Name")    // " NEC Multi-sync II "
#define DESKCPLEXT_PRUNING_MODE         TEXT("Pruning Mode")    // 1 = on (default value), 0 = off

#define DESKCPLEXT_DISPLAY_DEVICE_KEY   TEXT("Display Key")     // "\REGISTRY\MACHINE\SYSTEM\ControlSet00X\Services\<driver>\DeviceY"
#define DESKCPLEXT_DISPLAY_ID           TEXT("Display ID")      // "ROOT\*PNP0F03\1-0-21-0-31-0"
#define DESKCPLEXT_DISPLAY_STATE_FLAGS  TEXT("Display State Flags")
#define DESKCPLEXT_MONITOR_ID           TEXT("Monitor ID")      // "ROOT\*PNP0F04\1-0-21-0-31-0"
#define DESKCPLEXT_INTERFACE            TEXT("Desk.cpl extension interface")

typedef
LPDEVMODEW
(*LPDESKCPLEXT_ENUM_ALL_MODES) (
    LPVOID pContext,
    DWORD iMode
    );

typedef
LPDEVMODEW
(*LPDESKCPLEXT_GET_SELECTED_MODE) (
    LPVOID pContext
    );

typedef
BOOL
(*LPDESKCPLEXT_SET_SELECTED_MODE) (
    LPVOID pContext,
    LPDEVMODEW lpdm
    );

typedef
VOID 
(*LPDESKCPLEXT_GET_PRUNING_MODE) (
    LPVOID pContext,
    BOOL*  pbCanBePruned,
    BOOL*  pbIsReadOnly,
    BOOL*  pbIsPruningOn
    );
    
typedef
VOID 
(*LPDESKCPLEXT_SET_PRUNING_MODE) (
    LPVOID pContext,
    BOOL   bIsPruningOn
    );


typedef struct _DISPLAY_REGISTRY_HARDWARE_INFO {

    WCHAR MemSize[128];
    WCHAR ChipType[128];
    WCHAR DACType[128];
    WCHAR AdapString[128];
    WCHAR BiosString[128];

} DISPLAY_REGISTRY_HARDWARE_INFO, *PDISPLAY_REGISTRY_HARDWARE_INFO;




typedef struct _DESK_EXTENSION_INTERFACE {

    DWORD   cbSize;
    LPVOID  pContext;

    LPDESKCPLEXT_ENUM_ALL_MODES    lpfnEnumAllModes;
    LPDESKCPLEXT_SET_SELECTED_MODE lpfnSetSelectedMode;
    LPDESKCPLEXT_GET_SELECTED_MODE lpfnGetSelectedMode;
    LPDESKCPLEXT_SET_PRUNING_MODE  lpfnSetPruningMode;
    LPDESKCPLEXT_GET_PRUNING_MODE  lpfnGetPruningMode;
    
    DISPLAY_REGISTRY_HARDWARE_INFO Info;

} DESK_EXTENSION_INTERFACE, *PDESK_EXTENSION_INTERFACE;

#define NORMAL_TIMEOUT  7000
#define SLOW_TIMEOUT   12000

typedef
int
(*LPDISPLAY_SAVE_SETTINGS)   (
    LPVOID pContext,
    HWND   hwnd
    );

typedef
DWORD
(*LPDISPLAY_TEST_SETTINGS) (
    LPDEVMODEW lpDevMode,
    LPWSTR     pwszDevice,
    DWORD      dwTimeout
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\displaysettings.h ===
/**************************************************************************\
* Module Name: settings.hxx
*
* CDeviceSettings class
*
*  This class is in charge of all the settings specific to one display
*  device. Including Screen Size, Color Depth, Font size.  
*
* Copyright (c) Microsoft Corp.  1992-1998 All Rights Reserved
*
\**************************************************************************/


#ifndef SETTINGS_HXX
#define SETTINGS_HXX

#define MAKEXYRES(p,xval,yval)  ((p)->x = xval, (p)->y = yval)

#define _CURXRES  ((_pCurDevmode != NULL) ? (int)_pCurDevmode->dmPelsWidth : -1)
#define _CURYRES  ((_pCurDevmode != NULL) ? (int)_pCurDevmode->dmPelsHeight : -1)
#define _ORGXRES  ((_pOrgDevmode != NULL) ? (int)_pOrgDevmode->dmPelsWidth : -1)
#define _ORGYRES  ((_pOrgDevmode != NULL) ? (int)_pOrgDevmode->dmPelsHeight : -1)

#define _CURCOLOR ((_pCurDevmode != NULL) ? (int)_pCurDevmode->dmBitsPerPel : -1)
#define _ORGCOLOR ((_pOrgDevmode != NULL) ? (int)_pOrgDevmode->dmBitsPerPel : -1)

#define _CURFREQ  ((_pCurDevmode != NULL) ? (int)_pCurDevmode->dmDisplayFrequency : -1)
#define _ORGFREQ  ((_pOrgDevmode != NULL) ? (int)_pOrgDevmode->dmDisplayFrequency : -1)

#define MODE_INVALID    0x00000001
#define MODE_RAW        0x00000002

typedef struct _MODEARRAY {

    DWORD     dwFlags;
    LPDEVMODE lpdm;

} MODEARRAY, *PMODEARRAY;

HRESULT CDisplaySettings_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);

class CDisplaySettings :    public IDataObject, 
                            public IDisplaySettings
{
public:

    CDisplaySettings();
    ~CDisplaySettings();

    // General Settings support
    BOOL InitSettings(LPDISPLAY_DEVICE pDisplay);
    int  SaveSettings(DWORD dwSet);
    int  RestoreSettings();
    BOOL ConfirmChangeSettings();
    BOOL IsKnownSafe();
    BOOL bIsModeChanged()               {return _pCurDevmode != _pOrgDevmode;}

    // Device Settings
    void SetPrimary(BOOL fPrimary)      { _fPrimary     = fPrimary; };
    void SetAttached(BOOL fAttached)    { _fCurAttached = fAttached; };
    BOOL IsPrimary()                    { return _fPrimary; };
    BOOL IsAttached()                   { return _fCurAttached; };
    BOOL IsOrgAttached()                { return _fOrgAttached; };
    BOOL IsSmallFontNecessary();
    
    BOOL IsRemovable() 
    { 
        return ((_pDisplayDevice->StateFlags & DISPLAY_DEVICE_REMOVABLE) != 0);
    }

    LPDEVMODE GetCurrentDevMode(void); 

    // Color information
    int  GetColorList(LPPOINT Res, PLONGLONG *ppColor);
    void SetCurColor(int Color)         { _BestMatch(NULL, Color, FALSE); }
    int  GetCurColor()                  { return _CURCOLOR;}
    BOOL IsColorChanged()
    {
        return (_ORGCOLOR == -1) ? FALSE : (_CURCOLOR != _ORGCOLOR);
    }

    // Resolution information
    int  GetResolutionList(int Color, PPOINT *ppRes);
    void SetCurResolution(LPPOINT ppt, IN BOOL fAutoSetColorDepth)  { _BestMatch(ppt, -1, fAutoSetColorDepth); }
    void GetCurResolution(LPPOINT ppt)  
    { 
        ppt->x = _CURXRES;
        ppt->y = _CURYRES; 
    }
    BOOL IsResolutionChanged()
    {
        if (_ORGXRES == -1)
            return FALSE;
        else
            return ((_CURXRES != _ORGXRES) && (_CURYRES != _ORGYRES));
    }

    int  GetFrequencyList(int Color, LPPOINT Res, PLONGLONG *ppFreq);
    void SetCurFrequency(int Frequency);
    int  GetCurFrequency()              { return _CURFREQ; }
    BOOL IsFrequencyChanged()
    {
        return (_ORGFREQ == -1) ? FALSE : (_CURFREQ != _ORGFREQ);
    }

    // Position information
    void SetCurPosition(LPPOINT ppt) {_ptCurPos = *ppt;}
    void SetOrgPosition(LPPOINT ppt) {_ptOrgPos = *ppt;}
    void GetCurPosition(PRECT prc)
    {
        prc->left   = _ptCurPos.x;
        prc->top    = _ptCurPos.y;
        prc->right  = _ptCurPos.x + _CURXRES;
        prc->bottom = _ptCurPos.y + _CURYRES;
    }
    void GetOrgPosition(PRECT prc)
    {
        prc->left   = _ptOrgPos.x;
        prc->top    = _ptOrgPos.y;
        prc->right  = _ptOrgPos.x + _ORGXRES;
        prc->bottom = _ptOrgPos.y + _ORGYRES;
    }

    void GetPreviewPosition(PRECT prc)
    {
        *prc = _rcPreview;
    }

    void SetPreviewPosition(PRECT prc)
    {
        _rcPreview = *prc;
    }

    // Adapter & Monitor information
    BOOL GetMonitorName(LPTSTR pszName, DWORD cchSize);
    BOOL GetMonitorDevice(LPTSTR pszDevice);
    HRESULT GetDevInstID(LPTSTR lpszDeviceKey, STGMEDIUM *pstgmed);

    // *** IUnknown methods
    STDMETHODIMP  QueryInterface(REFIID riid, PVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // *** IDataObject methods
    STDMETHODIMP GetData(FORMATETC *pfmtetcIn, STGMEDIUM *pstgmed);
    STDMETHODIMP GetDataHere(FORMATETC *pfmtetc, STGMEDIUM *pstgpmed);
    STDMETHODIMP QueryGetData(FORMATETC *pfmtetc);
    STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pfmtetcIn, FORMATETC *pfmtetcOut);
    STDMETHODIMP SetData(FORMATETC *pfmtetc, STGMEDIUM *pstgmed, BOOL bRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppienumFormatEtc);
    STDMETHODIMP DAdvise(FORMATETC *pfmtetc, DWORD dwAdviseFlags, IAdviseSink * piadvsink, PDWORD pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA **ppienumStatData);

    // Helper functions
    STDMETHODIMP CopyDataToStorage(STGMEDIUM *pstgmed, LPTSTR pszOut);

    // *** IDisplaySettings methods
    STDMETHODIMP SetMonitor(DWORD dwMonitor);
    STDMETHODIMP GetModeCount(DWORD* pdwCount, BOOL fOnlyPreferredModes);
    STDMETHODIMP GetMode(DWORD dwMode, BOOL fOnlyPreferredModes, DWORD* pdwWidth, DWORD* pdwHeight, DWORD* pdwColor);
    STDMETHODIMP SetSelectedMode(HWND hwnd, DWORD dwWidth, DWORD dwHeight, DWORD dwColor, BOOL* pfApplied, DWORD dwFlags);
    STDMETHODIMP GetSelectedMode(DWORD* pdwWidth, DWORD* pdwHeight, DWORD* pdwColor);
    STDMETHODIMP GetAttached(BOOL* pfAttached);
    STDMETHODIMP SetPruningMode(BOOL fIsPruningOn);
    STDMETHODIMP GetPruningMode(BOOL* pfCanBePruned, BOOL* pfIsPruningReadOnly, BOOL* pfIsPruningOn);

protected:
    // The Display Device we are currently working with.

    LPDISPLAY_DEVICE _pDisplayDevice;

    ULONG       _cpdm;
    PMODEARRAY  _apdm;

    // The current system settings
    POINT       _ptOrgPos;
    LPDEVMODE   _pOrgDevmode;
    BOOL        _fOrgAttached;

    // The current CPL settings.
    POINT       _ptCurPos;
    LPDEVMODE   _pCurDevmode;
    BOOL        _fCurAttached;
    RECT        _rcPreview;

    // If the current device is attached to the desktop
    BOOL        _fUsingDefault;
    BOOL        _fPrimary;

    // Pruning 
    BOOL        _bCanBePruned;       // true if raw mode list != pruned mode list
    BOOL        _bIsPruningReadOnly; // true if can be pruned and pruning mode can be written
    BOOL        _bIsPruningOn;       // true if can be pruned and pruning mode is on
    HKEY        _hPruningRegKey;

    // Orientation
    BOOL        _bFilterOrientation;
    DWORD       _dwOrientation;
    BOOL        _bFilterFixedOutput;
    DWORD       _dwFixedOutput;
        
    // Ref count for IDataObject
    LONG       _cRef;

    // Private functions
    void _Dump_CDisplaySettings(BOOL bAll);
    void _Dump_CDevmodeList(VOID);
    void _Dump_CDevmode(LPDEVMODE pdm);
    int  _InsertSortedDwords(int val1, int val2, int cval, int **ppval);
    BOOL _AddDevMode(LPDEVMODE lpdm);
    void _BestMatch(LPPOINT Res, int Color, IN BOOL fAutoSetColorDepth);
    BOOL _ExactMatch(LPDEVMODE lpdm, BOOL bForceVisible);
    BOOL _PerfectMatch(LPDEVMODE lpdm);
    void _SetCurrentValues(LPDEVMODE lpdm);
    int  _GetCurrentModeFrequencyList(int Color, LPPOINT Res, PLONGLONG *ppFrequency);
    BOOL _MarkMode(LPDEVMODE lpdm);
    BOOL _IsCurDevmodeRaw();
    BOOL _IsModeVisible(int i);
    BOOL _IsModePreferred(int i);
    static BOOL _IsModeVisible(CDisplaySettings* pSettings, int i);

    // OLE support for extensibility.
    void _InitClipboardFormats();
    void _FilterModes();
    void _SetFilterOptions(LPCTSTR pszDeviceName, LPDEVMODEW lpdm);

    static LPDEVMODEW _lpfnEnumAllModes(LPVOID pContext, DWORD iMode);
    static BOOL       _lpfnSetSelectedMode(LPVOID pContext, LPDEVMODEW lpdm);
    static LPDEVMODEW _lpfnGetSelectedMode(LPVOID pContext);
    static VOID       _lpfnSetPruningMode(LPVOID pContext, BOOL bIsPruningOn);
    static VOID       _lpfnGetPruningMode(LPVOID pContext, 
                                          BOOL* pbCanBePruned,
                                          BOOL* pbIsPruningReadOnly,
                                          BOOL* pbIsPruningOn);

private:
    HRESULT _GetRegKey(LPDEVMODE pDevmode, int * pnIndex, LPTSTR pszRegKey, DWORD cchSize, LPTSTR pszRegValue, DWORD cchValueSize);
};

#endif // SETTINGS_HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\dllmain.cpp ===
/*****************************************************************************\
    FILE: dllmain.cpp

    DESCRIPTION:
       This file will take care of the DLL lifetime.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"

extern HANDLE g_hLogFile;

/*****************************************************************************
 *
 *  Dynamic Globals.  There should be as few of these as possible.
 *
 *  All access to dynamic globals must be thread-safe.
 *
 *****************************************************************************/

ULONG g_cRef = 0;           // Global reference count
CRITICAL_SECTION g_csDll;   // The shared critical section


#ifdef DEBUG
DWORD g_TlsMem = 0xffffffff;
#endif // DEBUG

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
//OBJECT_ENTRY(CLSID_MsgListView, CMsgListView)
END_OBJECT_MAP()

/*****************************************************************************
 *
 *  DllAddRef / DllRelease
 *
 *  Maintain the DLL reference count.
 *
 *****************************************************************************/

void DllAddRef(void)
{
    InterlockedIncrement((LPLONG)&g_cRef);
}

void DllRelease(void)
{
    InterlockedDecrement((LPLONG)&g_cRef);
}

/*****************************************************************************
 *
 *  DllGetClassObject
 *
 *  OLE entry point.  Produces an IClassFactory for the indicated GUID.
 *
 *  The artificial refcount inside DllGetClassObject helps to
 *  avoid the race condition described in DllCanUnloadNow.  It's
 *  not perfect, but it makes the race window much smaller.
 *
 *****************************************************************************/

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres;

    DllAddRef();
    
    hres = CClassFactory_Create(rclsid, riid, ppvObj);
    
    DllRelease();
    return hres;
}

/*****************************************************************************
 *
 *  DllCanUnloadNow
 *
 *  OLE entry point.  Fail iff there are outstanding refs.
 *
 *  There is an unavoidable race condition between DllCanUnloadNow
 *  and the creation of a new IClassFactory:  Between the time we
 *  return from DllCanUnloadNow() and the caller inspects the value,
 *  another thread in the same process may decide to call
 *  DllGetClassObject, thus suddenly creating an object in this DLL
 *  when there previously was none.
 *
 *  It is the caller's responsibility to prepare for this possibility;
 *  there is nothing we can do about it.
 *
 *****************************************************************************/

STDMETHODIMP DllCanUnloadNow(void)
{
    HRESULT hres;

    ENTERCRITICAL;

    hres = g_cRef ? S_FALSE : S_OK;

    if (S_OK == hres)
    {
        hres = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
    }

    TraceMsg(TF_WMTHEME, "DllCanUnloadNow() returning hres=%#08lx. (S_OK means yes)", hres);

    LEAVECRITICAL;

    return hres;
}

/*
//  Table of all window classes we register so we can unregister them
//  at DLL unload.
const LPCTSTR c_rgszClasses[] = {
//    g_cszPopServiceWndClass
};

//  Since we are single-binary, we have to play it safe and do
//  this cleanup (needed only on NT, but harmless on Win95).
#define UnregisterWindowClasses() \
    SHUnregisterClasses(HINST_THISDLL, c_rgszClasses, ARRAYSIZE(c_rgszClasses))
*/

/*****************************************************************************
 *
 *  Entry32
 *
 *  DLL entry point.
 *
 *****************************************************************************/
STDAPI_(BOOL) DllEntry(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    static s_hresOle = E_FAIL;

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
#ifdef DEBUG
            CcshellGetDebugFlags();
#endif

            InitializeCriticalSection(&g_csDll);

            g_hinst = hinst;
            DisableThreadLibraryCalls(hinst);

            SHFusionInitializeFromModuleID(hinst, 124);
            break;
        }

        case DLL_PROCESS_DETACH:
        {
            DeleteCriticalSection(&g_csDll);
            if (INVALID_HANDLE_VALUE != g_hLogFile)
            {
                CloseHandle(g_hLogFile);
            }

            SHFusionUninitialize();

            break;
        }
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\dragsize.h ===
#define SETWINDOWPOINTER(hwnd, name, p) SetWindowLongPtr(hwnd, 0, (LONG_PTR)p)
#define GETWINDOWPOINTER(hwnd, name)	((name)GetWindowLongPtr(hwnd, 0))

#define ALLOCWINDOWPOINTER(name, size)	((name)LocalAlloc(LPTR, size))
#define FREEWINDOWPOINTER(p)		LocalFree((HLOCAL)p)

#define GETWINDOWID(hwnd)               GetWindowLong(hwnd, GWLP_ID)

#define DRAGSIZECLASSNAME               TEXT("DragSizeWindow")

HWND WINAPI CreateDragSizeWindow(LONG style, int x, int y, int wid, int hgt, HWND hwndParent, LONG wID);

BOOL FAR PASCAL InitDragSizeClass(void);

#define DSM_DRAGPOS	(WM_USER)

#define DSN_BEGINDRAG	(0)
#define DSN_DRAGGING	(1)
#define DSN_ENDDRAG	(2)
#define DSN_NCCREATE	(3)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\displaysettings.cpp ===
/**************************************************************************\
* Module Name: settings.cpp
*
* Contains Implementation of the CDisplaySettings class who is in charge of
* the settings of a single display. This is the data base class who does the
* real change display settings work
*
* Copyright (c) Microsoft Corp.  1992-1998 All Rights Reserved
*
\**************************************************************************/


#include "priv.h"

#include "DisplaySettings.h"
#include "ntreg.hxx"

extern int AskDynaCDS(HWND hDlg);
INT_PTR CALLBACK KeepNewDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam);

UINT g_cfDisplayDevice = 0;
UINT g_cfDisplayName = 0;
UINT g_cfDisplayDeviceID = 0;
UINT g_cfMonitorDevice = 0;
UINT g_cfMonitorName = 0;
UINT g_cfMonitorDeviceID = 0;
UINT g_cfExtensionInterface = 0;
UINT g_cfDisplayDeviceKey = 0;
UINT g_cfDisplayStateFlags = 0;
UINT g_cfDisplayPruningMode = 0;

#define TF_DISPLAYSETTINGS      0

/*****************************************************************\
*
* helper routine
*
\*****************************************************************/

int CDisplaySettings::_InsertSortedDwords(
    int val1,
    int val2,
    int cval,
    int **ppval)
{
    int *oldpval = *ppval;
    int *tmppval;
    int  i;

    for (i=0; i<cval; i++)
    {
        tmppval = (*ppval) + (i * 2);

        if (*tmppval == val1)
        {
            if (*(tmppval + 1) == val2)
            {
                return cval;
            }
            else if (*(tmppval + 1) > val2)
            {
                break;
            }
        }
        else if (*tmppval > val1)
        {
            break;
        }
    }

    TraceMsg(TF_FUNC,"_InsertSortedDword, vals = %d %d, cval = %d, index = %d", val1, val2, cval, i);

    *ppval = (int *) LocalAlloc(LPTR, (cval + 1) * 2 * sizeof(DWORD));

    if (*ppval)
    {
        //
        // Insert the items at the right location in the array
        //
        if (oldpval) {
            CopyMemory(*ppval,
                       oldpval,
                       i * 2 * sizeof(DWORD));
        }

        *(*ppval + (i * 2))     = val1;
        *(*ppval + (i * 2) + 1) = val2;

        if (oldpval) {
            CopyMemory((*ppval) + 2 * (i + 1),
                        oldpval+ (i * 2),
                        (cval-i) * 2 * sizeof(DWORD));

            LocalFree(oldpval);
        }

        return (cval + 1);
    }

    return 0;
}

/*****************************************************************\
*
* debug routine
*
\*****************************************************************/


void CDisplaySettings::_Dump_CDisplaySettings(BOOL bAll)
{
    TraceMsg(TF_DUMP_CSETTINGS,"Dump of CDisplaySettings structure");
    TraceMsg(TF_DUMP_CSETTINGS,"\t _DisplayDevice  = %s",     _pDisplayDevice->DeviceName);
    TraceMsg(TF_DUMP_CSETTINGS,"\t _cpdm           = %d",     _cpdm     );
    TraceMsg(TF_DUMP_CSETTINGS,"\t _apdm           = %08lx",  _apdm     );

    TraceMsg(TF_DUMP_CSETTINGS,"\t OrgResolution   = %d, %d", _ORGXRES, _ORGYRES    );
    TraceMsg(TF_DUMP_CSETTINGS,"\t _ptOrgPos       = %d, %d", _ptOrgPos.x ,_ptOrgPos.y);
    TraceMsg(TF_DUMP_CSETTINGS,"\t OrgColor        = %d",     _ORGCOLOR      );
    TraceMsg(TF_DUMP_CSETTINGS,"\t OrgFrequency    = %d",     _ORGFREQ  );
    TraceMsg(TF_DUMP_CSETTINGS,"\t _pOrgDevmode    = %08lx",  _pOrgDevmode   );
    TraceMsg(TF_DUMP_CSETTINGS,"\t _fOrgAttached   = %d",     _fOrgAttached  );

    TraceMsg(TF_DUMP_CSETTINGS,"\t CurResolution   = %d, %d", _CURXRES, _CURYRES     );
    TraceMsg(TF_DUMP_CSETTINGS,"\t _ptCurPos       = %d, %d", _ptCurPos.x ,_ptCurPos.y);
    TraceMsg(TF_DUMP_CSETTINGS,"\t CurColor        = %d",     _CURCOLOR      );
    TraceMsg(TF_DUMP_CSETTINGS,"\t CurFrequency    = %d",     _CURFREQ  );
    TraceMsg(TF_DUMP_CSETTINGS,"\t _pCurDevmode    = %08lx",  _pCurDevmode   );
    TraceMsg(TF_DUMP_CSETTINGS,"\t _fCurAttached   = %d",     _fCurAttached  );

    TraceMsg(TF_DUMP_CSETTINGS,"\t _fUsingDefault  = %d",     _fUsingDefault );
    TraceMsg(TF_DUMP_CSETTINGS,"\t _fPrimary       = %d",     _fPrimary      );
    TraceMsg(TF_DUMP_CSETTINGS,"\t _cRef           = %d",     _cRef          );

    if (bAll)
    {
        _Dump_CDevmodeList();
    }
}

void CDisplaySettings::_Dump_CDevmodeList(VOID)
{
    ULONG i;

    for (i=0; _apdm && (i<_cpdm); i++)
    {
        LPDEVMODE lpdm = (_apdm + i)->lpdm;

        TraceMsg(TF_DUMP_CSETTINGS,"\t\t mode %d, %08lx, Flags %08lx, X=%d Y=%d C=%d F=%d O=%d FO=%d",
                 i, lpdm, (_apdm + i)->dwFlags, 
                 lpdm->dmPelsWidth, lpdm->dmPelsHeight, lpdm->dmBitsPerPel, lpdm->dmDisplayFrequency,
                 lpdm->dmDisplayOrientation, lpdm->dmDisplayFixedOutput);
    }
}

void CDisplaySettings::_Dump_CDevmode(LPDEVMODE pdm)
{
    TraceMsg(TF_DUMP_DEVMODE,"  Size        = %d",    pdm->dmSize);
    TraceMsg(TF_DUMP_DEVMODE,"  Fields      = %08lx", pdm->dmFields);
    TraceMsg(TF_DUMP_DEVMODE,"  XPosition   = %d",    pdm->dmPosition.x);
    TraceMsg(TF_DUMP_DEVMODE,"  YPosition   = %d",    pdm->dmPosition.y);
    TraceMsg(TF_DUMP_DEVMODE,"  XResolution = %d",    pdm->dmPelsWidth);
    TraceMsg(TF_DUMP_DEVMODE,"  YResolution = %d",    pdm->dmPelsHeight);
    TraceMsg(TF_DUMP_DEVMODE,"  Bpp         = %d",    pdm->dmBitsPerPel);
    TraceMsg(TF_DUMP_DEVMODE,"  Frequency   = %d",    pdm->dmDisplayFrequency);
    TraceMsg(TF_DUMP_DEVMODE,"  Flags       = %d",    pdm->dmDisplayFlags);
    TraceMsg(TF_DUMP_DEVMODE,"  XPanning    = %d",    pdm->dmPanningWidth);
    TraceMsg(TF_DUMP_DEVMODE,"  YPanning    = %d",    pdm->dmPanningHeight);
    TraceMsg(TF_DUMP_DEVMODE,"  DPI         = %d",    pdm->dmLogPixels);
    TraceMsg(TF_DUMP_DEVMODE,"  DriverExtra = %d",    pdm->dmDriverExtra);
    TraceMsg(TF_DUMP_DEVMODE,"  Orientation = %d",    pdm->dmDisplayOrientation);
    TraceMsg(TF_DUMP_DEVMODE,"  FixedOutput = %d",    pdm->dmDisplayFixedOutput);
    if (pdm->dmDriverExtra)
    {
        TraceMsg(TF_DUMP_CSETTINGS,"\t - %08lx %08lx",
        *(PULONG)(((PUCHAR)pdm)+pdm->dmSize),
        *(PULONG)(((PUCHAR)pdm)+pdm->dmSize + 4));
    }
}

//
// Lets perform the following operations on the list
//
// (1) Remove identical modes
// (2) Remove 16 color modes for which there is a 256
//     color equivalent.
// (3) Remove modes with any dimension less than 640x480
//

void CDisplaySettings::_FilterModes()
{
    DWORD      i, j;
    LPDEVMODE  pdm, pdm2;
    PMODEARRAY pMode, pMode2;

    for (i = 0; _apdm && i < _cpdm; i++)
    {
        pMode = _apdm + i;
        pdm = pMode->lpdm;

        // Skip any invalid modes
        if (pMode->dwFlags & MODE_INVALID)
        {
            continue;
        }

        //
        // If any of the following conditions are true, then we want to
        // remove the current mode.
        //

        // Remove any modes that are too small
        if (pdm->dmPelsHeight < 480 || pdm->dmPelsWidth < 640)
        {
            TraceMsg(TF_DUMP_CSETTINGS,"_FilterModes: Mode %d - resolution too small", i);
            pMode->dwFlags |= MODE_INVALID;
            continue;
        }

        // Remove any modes that would change the orientation
        if (_bFilterOrientation)
        {
            if (pdm->dmFields & DM_DISPLAYORIENTATION && 
                pdm->dmDisplayOrientation != _dwOrientation)
            {
                pMode->dwFlags |= MODE_INVALID;
                TraceMsg(TF_DUMP_CSETTINGS,"_FilterModes: Mode %d - Wrong Orientation", i);
                continue;
            }
        }

        // Remove any modes that would change fixed output unless our current mode is 
        // native resolution
        if (_bFilterFixedOutput && _dwFixedOutput != DMDFO_DEFAULT)
        {
            if (pdm->dmFields & DM_DISPLAYFIXEDOUTPUT &&
                pdm->dmDisplayFixedOutput != _dwFixedOutput)
            {
                pMode->dwFlags |= MODE_INVALID;
                TraceMsg(TF_DUMP_CSETTINGS,"_FilterModes: Mode %d - Wrong FixedOutput", i);
                continue;
            }
        }
                
        // Remove any duplicate modes
        for (j = i + 1; j < _cpdm; j++)
        {
            pMode2 = _apdm + j;
            pdm2 = pMode2->lpdm;

            if (!(pMode2->dwFlags & MODE_INVALID) &&
                pdm2->dmBitsPerPel == pdm->dmBitsPerPel &&
                pdm2->dmPelsWidth == pdm->dmPelsWidth &&
                pdm2->dmPelsHeight == pdm->dmPelsHeight &&
                pdm2->dmDisplayFrequency == pdm->dmDisplayFrequency)
            {
                TraceMsg(TF_DUMP_CSETTINGS,"_FilterModes: Mode %d - Duplicate Mode", i);
                pMode2->dwFlags |= MODE_INVALID;
            }
        }
    }
}


//
// _AddDevMode method
//
//  This method builds the index lists for the matrix.  There is one
//  index list for each axes of the three dimemsional matrix of device
//  modes.
//
// The entry is also automatically added to the linked list of modes if
// it is not alreay present in the list.
//

BOOL CDisplaySettings::_AddDevMode(LPDEVMODE lpdm)
{
    if (lpdm)
    {
        PMODEARRAY newapdm, tempapdm;

        //
        // Set the height for the test of the 1152 mode
        //

        if (lpdm->dmPelsWidth == 1152) {

            // Set1152Mode(lpdm->dmPelsHeight);
        }

        newapdm = (PMODEARRAY) LocalAlloc(LPTR, (_cpdm + 1) * sizeof(MODEARRAY));
        if (newapdm)
        {
            CopyMemory(newapdm, _apdm, _cpdm * sizeof(MODEARRAY));

            (newapdm + _cpdm)->dwFlags &= ~MODE_INVALID;
            (newapdm + _cpdm)->dwFlags |= MODE_RAW;
            (newapdm + _cpdm)->lpdm     = lpdm;

        }

        tempapdm = _apdm;
        _apdm = newapdm;
        _cpdm++;

        if (tempapdm)
        {
            LocalFree(tempapdm);
        }
    }

    return TRUE;
}

//
// Return a list of Resolutions supported, given a color depth
//

int CDisplaySettings::GetResolutionList(
    int Color,
    PPOINT *ppRes)
{
    DWORD      i;
    int        cRes = 0;
    int       *pResTmp = NULL;
    LPDEVMODE  pdm;

    *ppRes = NULL;

    for (i = 0; _apdm && (i < _cpdm); i++)
    {
        if(!_IsModeVisible(i))
        {
            continue;
        }

        if(!_IsModePreferred(i))
        {
            continue;
        }

        pdm = (_apdm + i)->lpdm;

        if ((Color == -1) ||
            (Color == (int)pdm->dmBitsPerPel))
        {
            cRes = _InsertSortedDwords(pdm->dmPelsWidth,
                                       pdm->dmPelsHeight,
                                       cRes,
                                       &pResTmp);
        }
    }

    *ppRes = (PPOINT) pResTmp;

    return cRes;
}

//
//
// Return a list of color depths supported
//

int CDisplaySettings::GetColorList(
    LPPOINT Res,
    PLONGLONG *ppColor)
{
    DWORD      i;
    int        cColor = 0;
    int       *pColorTmp = NULL;
    LPDEVMODE  pdm;

    for (i = 0; _apdm && (i < _cpdm); i++)
    {
        if(!_IsModeVisible(i))
        {
            continue;
        }

        if(!_IsModePreferred(i))
        {
            continue;
        }

        pdm = (_apdm + i)->lpdm;

        if ((Res == NULL) ||
            (Res->x == -1)                    ||
            (Res->y == -1)                    ||
            (Res->x == (int)pdm->dmPelsWidth) ||
            (Res->y == (int)pdm->dmPelsHeight))
        {
            cColor = _InsertSortedDwords(pdm->dmBitsPerPel,
                                         0,
                                         cColor,
                                         &pColorTmp);
        }
    }

    *ppColor = (PLONGLONG) pColorTmp;

    return cColor;
}

int CDisplaySettings::GetFrequencyList(int Color, LPPOINT Res, PLONGLONG *ppFreq)
{
    DWORD      i;
    int        cFreq = 0;
    int       *pFreqTmp = NULL;
    LPDEVMODE  pdm;
    POINT      res;

    if (Color == -1) {
        Color = _CURCOLOR;
    }

    if (Res == NULL) 
    {
        MAKEXYRES(&res, _CURXRES, _CURYRES);
    }
    else
    {
        res = *Res;
    }

    for (i = 0; _apdm && (i < _cpdm); i++)
    {
        if(!_IsModeVisible(i))
        {
            continue;
        }

        pdm = (_apdm + i)->lpdm;

        if (res.x == (int)pdm->dmPelsWidth  &&
            res.y == (int)pdm->dmPelsHeight &&
            Color == (int)pdm->dmBitsPerPel) 
        {
            cFreq = _InsertSortedDwords(pdm->dmDisplayFrequency,
                                         0,
                                         cFreq,
                                         &pFreqTmp);
        }
    }

    *ppFreq = (PLONGLONG) pFreqTmp;

    return cFreq;
}

void CDisplaySettings::SetCurFrequency(int Frequency)
{
    LPDEVMODE pdm;
    LPDEVMODE pdmMatch = NULL;
    ULONG i;

    for (i = 0; _apdm && (i < _cpdm); i++)
    {
        if(!_IsModeVisible(i))
        {
            continue;
        }

        pdm = (_apdm + i)->lpdm;

        //
        // Find the exact match. 
        //
        if (_CURCOLOR == (int) pdm->dmBitsPerPel &&
            _CURXRES == (int) pdm->dmPelsWidth      &&
            _CURYRES == (int) pdm->dmPelsHeight     &&
            Frequency        == (int) pdm->dmDisplayFrequency)
        {
            pdmMatch = pdm;
            break;
        }
    }

    //
    // We should always make a match because the list of frequencies shown to
    // the user is only for the current color & resolution
    //
    ASSERT(pdmMatch);
    if (pdmMatch) {
        _SetCurrentValues(pdmMatch);
    }
}

LPDEVMODE CDisplaySettings::GetCurrentDevMode(void)
{
    ULONG dmSize = _pCurDevmode->dmSize + _pCurDevmode->dmDriverExtra;
    PDEVMODE pdevmode  = (LPDEVMODE) LocalAlloc(LPTR, dmSize);

    if (pdevmode) {
        CopyMemory(pdevmode, _pCurDevmode, dmSize);
    }

    return pdevmode;
}

void CDisplaySettings::_SetCurrentValues(LPDEVMODE lpdm)
{
    _pCurDevmode = lpdm;

    //
    // Don't save the other fields (like position) as they are programmed by
    // the UI separately.
    //
    // This should only save hardware specific fields.
    //

    TraceMsg(TF_DUMP_CSETTINGS,"");
    TraceMsg(TF_DUMP_CSETTINGS,"_SetCurrentValues complete");
    _Dump_CDisplaySettings(FALSE);
}


BOOL CDisplaySettings::_PerfectMatch(LPDEVMODE lpdm)
{
    for (DWORD i = 0; _apdm && (i < _cpdm); i++)
    {
        if(!_IsModeVisible(i))
        {
            continue;
        }

        if ((_apdm + i)->lpdm == lpdm)
        {
            _SetCurrentValues((_apdm + i)->lpdm);

            TraceMsg(TF_DISPLAYSETTINGS, "_PerfectMatch -- return TRUE");

            return TRUE;
        }
    }

    TraceMsg(TF_DISPLAYSETTINGS, "_PerfectMatch -- return FALSE");

    return FALSE;
}

BOOL CDisplaySettings::_ExactMatch(LPDEVMODE lpdm, BOOL bForceVisible)
{
    LPDEVMODE pdm;
    ULONG i;

    for (i = 0; _apdm && (i < _cpdm); i++)
    {
        pdm = (_apdm + i)->lpdm;

        if (
            ((lpdm->dmFields & DM_BITSPERPEL) &&
             (pdm->dmBitsPerPel != lpdm->dmBitsPerPel))

            ||

            ((lpdm->dmFields & DM_PELSWIDTH) &&
             (pdm->dmPelsWidth != lpdm->dmPelsWidth))

            ||

            ((lpdm->dmFields & DM_PELSHEIGHT) &&
             (pdm->dmPelsHeight != lpdm->dmPelsHeight))

            ||

            ((lpdm->dmFields & DM_DISPLAYFREQUENCY) &&
             (pdm->dmDisplayFrequency != lpdm->dmDisplayFrequency))
           )
        {
           continue;
        }

        if (!_IsModeVisible(i))
        {
            if (bForceVisible &&
                ((((_apdm + i)->dwFlags) & MODE_INVALID) == 0) &&
                _bIsPruningOn &&
                ((((_apdm + i)->dwFlags) & MODE_RAW) == MODE_RAW))
            {
                (_apdm + i)->dwFlags &= ~MODE_RAW;
            }
            else
            {
                continue;
            }
        }

        _SetCurrentValues(pdm);

        TraceMsg(TF_DISPLAYSETTINGS, "_ExactMatch -- return TRUE");

        return TRUE;
    }

    TraceMsg(TF_DISPLAYSETTINGS, "_ExactMatch -- return FALSE");

    return FALSE;
}


// JoelGros defined a feature where we prefer to give the user
// a color depth of at least 32-bit, or as close to that as the
// display supports.  Bryan Starbuck (BryanSt) 3/9/2000
#define MAX_PREFERED_COLOR_DEPTH        32

void CDisplaySettings::_BestMatch(LPPOINT Res, int Color, IN BOOL fAutoSetColorDepth)
{
    // -1 means match loosely, based on current _xxx value
    LPDEVMODE pdm;
    LPDEVMODE pdmMatch = NULL;
    ULONG i;

    for (i = 0; _apdm && (i < _cpdm); i++)
    {
        if(!_IsModeVisible(i))
        {
            continue;
        }

        pdm = (_apdm + i)->lpdm;

        // Take care of exact matches
        if ((Color != -1) &&
            (Color != (int)pdm->dmBitsPerPel))
        {
            continue;
        }

        if ((Res != NULL)  &&
            (Res->x != -1) &&
            ( (Res->x != (int)pdm->dmPelsWidth) ||
              (Res->y != (int)pdm->dmPelsHeight)) )
        {
            continue;
        }

        // Find Best Match
        if (pdmMatch == NULL)
        {
            pdmMatch = pdm;
        }

        // Find best Color.
        if (Color == -1)        // Do they want best color matching?
        {
            if (fAutoSetColorDepth)
            {
                // This will use the "auto-set a good color depth" feature.

                // The best match color depth will not equal the current color depth if
                // we are going to need to work closer and closer to our desired color depth.
                // (We may never reach it because the user may just have increased the resolution
                //  so the current color depth isn't supported)

                // We prefer keep increasing the color depth to at least the current color depth.
                // That may not be possible if that depth isn't supported at this resolution. 
                // We also would like to keep increasing it until we hit MAX_PREFERED_COLOR_DEPTH
                // because colors of at least that deep benefit users.

                // Do we need to decrease the color depth?  Yes if
                if (((int)pdmMatch->dmBitsPerPel > _CURCOLOR) &&               // the match is more than the current, and
                    ((int)pdmMatch->dmBitsPerPel > MAX_PREFERED_COLOR_DEPTH))   // the match is more than the prefered max
                {
                    // We will want to decrease it if this entry is smaller than our match.
                    if ((int)pdm->dmBitsPerPel < (int)pdmMatch->dmBitsPerPel)
                    {
                        pdmMatch = pdm;
                    }
                }
                else
                {
                    // We want to increase it if:
                    if (((int)pdm->dmBitsPerPel > (int)pdmMatch->dmBitsPerPel) &&   // this entry is larger than our match, and
                        ((int)pdm->dmBitsPerPel <= max(_CURCOLOR, MAX_PREFERED_COLOR_DEPTH))) // this doesn't take us over our prefered max or current depth (which ever is higher).
                    {
                        pdmMatch = pdm;
                    }
                }
            }
            else
            {
                // This falls back to the old behavior.
                if ((int)pdmMatch->dmBitsPerPel > _CURCOLOR)
                {
                    if ((int)pdm->dmBitsPerPel < (int)pdmMatch->dmBitsPerPel)
                    {
                        pdmMatch = pdm;
                    }
                }
                else
                {
                    if (((int)pdm->dmBitsPerPel > (int)pdmMatch->dmBitsPerPel) &&
                        ((int)pdm->dmBitsPerPel <= _CURCOLOR))
                    {
                        pdmMatch = pdm;
                    }
                }
            }
        }

        // Find best Resolution.
        if (((Res == NULL) || (Res->x == -1)) &&
            (((int)pdmMatch->dmPelsWidth  != _CURXRES) ||
             ((int)pdmMatch->dmPelsHeight != _CURYRES)))
        {
            if (((int)pdmMatch->dmPelsWidth   >  _CURXRES) ||
                (((int)pdmMatch->dmPelsWidth  == _CURXRES) &&
                 ((int)pdmMatch->dmPelsHeight >  _CURYRES)))
            {
                if (((int)pdm->dmPelsWidth  <  (int)pdmMatch->dmPelsWidth) ||
                    (((int)pdm->dmPelsWidth  == (int)pdmMatch->dmPelsWidth) &&
                     ((int)pdm->dmPelsHeight <  (int)pdmMatch->dmPelsHeight)))
                {
                    pdmMatch = pdm;
                }
            }
            else
            {
                if (((int)pdm->dmPelsWidth  >  (int)pdmMatch->dmPelsWidth) ||
                    (((int)pdm->dmPelsWidth  == (int)pdmMatch->dmPelsWidth) &&
                     ((int)pdm->dmPelsHeight >  (int)pdmMatch->dmPelsHeight)))
                {
                    if (((int)pdm->dmPelsWidth  <= _CURXRES) ||
                        (((int)pdm->dmPelsWidth  == _CURXRES) &&
                         ((int)pdm->dmPelsHeight <= _CURYRES)))
                    {
                        pdmMatch = pdm;
                    }
                }
            }
        }

        // Find best Frequency.
        if (((int)pdmMatch->dmDisplayFrequency != _CURFREQ) &&
            (!((Res == NULL) && 
               ((int)pdmMatch->dmPelsWidth  == _CURXRES) &&
               ((int)pdmMatch->dmPelsHeight == _CURYRES) &&
               (((int)pdm->dmPelsWidth  != _CURXRES) ||
                ((int)pdm->dmPelsHeight != _CURYRES)))) &&
            (!((Color == -1) && 
               ((int)pdmMatch->dmBitsPerPel == _CURCOLOR) &&
               ((int)pdm->dmBitsPerPel != _CURCOLOR))))
        {
            if ((int)pdmMatch->dmDisplayFrequency > _CURFREQ)
            {
                if ((int)pdm->dmDisplayFrequency < (int)pdmMatch->dmDisplayFrequency)
                {
                    pdmMatch = pdm;
                }
            }
            else
            {
                if (((int)pdm->dmDisplayFrequency > (int)pdmMatch->dmDisplayFrequency) &&
                    ((int)pdm->dmDisplayFrequency <= _CURFREQ))
                {
                    pdmMatch = pdm;
                }
            }
        }
    }

    _SetCurrentValues(pdmMatch);
}


BOOL CDisplaySettings::GetMonitorName(LPTSTR pszName, DWORD cchSize)
{
    DISPLAY_DEVICE ddTmp;
    DWORD cAttachedMonitors = 0, nMonitor = 0;

    ZeroMemory(&ddTmp, sizeof(ddTmp));
    ddTmp.cb = sizeof(DISPLAY_DEVICE);

    while (EnumDisplayDevices(_pDisplayDevice->DeviceName, nMonitor, &ddTmp, 0))
    {
        if (ddTmp.StateFlags & DISPLAY_DEVICE_ATTACHED) 
        {
            ++cAttachedMonitors;
            if (cAttachedMonitors > 1)
                break;

            // Single monitor
            StrCpyN(pszName, (LPTSTR)ddTmp.DeviceString, cchSize);
        }
        
        ++nMonitor;

        ZeroMemory(&ddTmp, sizeof(ddTmp));
        ddTmp.cb = sizeof(DISPLAY_DEVICE);
    }

    if (cAttachedMonitors == 0) 
    {
        // No monitors
        LoadString(HINST_THISDLL, IDS_UNKNOWNMONITOR, pszName, cchSize);
    }
    else if (cAttachedMonitors > 1) 
    {
        // Multiple monitors
        LoadString(HINST_THISDLL, IDS_MULTIPLEMONITORS, pszName, cchSize);
    }

    return (cAttachedMonitors != 0);
}

BOOL CDisplaySettings::GetMonitorDevice(LPTSTR pszDevice)
{
    DISPLAY_DEVICE ddTmp;

    ZeroMemory(&ddTmp, sizeof(ddTmp));
    ddTmp.cb = sizeof(DISPLAY_DEVICE);

    if (EnumDisplayDevices(_pDisplayDevice->DeviceName, 0, &ddTmp, 0))
    {
        lstrcpy(pszDevice, (LPTSTR)ddTmp.DeviceName);

        return TRUE;
    }

    return FALSE;
}

STDMETHODIMP CDisplaySettings::GetData(FORMATETC *pfmtetc, STGMEDIUM *pstgmed)
{
    HRESULT hr;

    ASSERT(this);
    ASSERT(pfmtetc);
    ASSERT(pstgmed);

    // Ignore pfmtetc.ptd.  All supported data formats are device-independent.

    ZeroMemory(pstgmed, SIZEOF(*pstgmed));

    if ((hr = QueryGetData(pfmtetc)) == S_OK)
    {
        LPTSTR pszOut = NULL;
        TCHAR szMonitorName[130];
        TCHAR szMonitorDevice[40];

        if (pfmtetc->cfFormat == g_cfExtensionInterface)
        {
            //
            // Get the array of information back to the device
            //
            // Allocate a buffer large enough to store all of the information
            //

            PDESK_EXTENSION_INTERFACE pInterface;

            pInterface = (PDESK_EXTENSION_INTERFACE)
                GlobalAlloc(GPTR, sizeof(DESK_EXTENSION_INTERFACE));

            if (pInterface)
            {
                CRegistrySettings * RegSettings = new CRegistrySettings(_pDisplayDevice->DeviceKey);

                if (RegSettings)
                {
                    pInterface->cbSize    = sizeof(DESK_EXTENSION_INTERFACE);
                    pInterface->pContext  = this;

                    pInterface->lpfnEnumAllModes    = CDisplaySettings::_lpfnEnumAllModes;
                    pInterface->lpfnSetSelectedMode = CDisplaySettings::_lpfnSetSelectedMode;
                    pInterface->lpfnGetSelectedMode = CDisplaySettings::_lpfnGetSelectedMode;
                    pInterface->lpfnSetPruningMode = CDisplaySettings::_lpfnSetPruningMode;
                    pInterface->lpfnGetPruningMode = CDisplaySettings::_lpfnGetPruningMode;

                    RegSettings->GetHardwareInformation(&pInterface->Info);

                    pstgmed->tymed = TYMED_HGLOBAL;
                    pstgmed->hGlobal = pInterface;
                    pstgmed->pUnkForRelease = NULL;

                    hr = S_OK;

                    delete RegSettings;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else if (pfmtetc->cfFormat == g_cfMonitorDeviceID)
        {
            //
            //! This code is broken. It must be removed.
            //

            /*
            DISPLAY_DEVICE ddTmp;
            BOOL    fKnownMonitor;

            ZeroMemory(&ddTmp, sizeof(ddTmp));
            ddTmp.cb = sizeof(DISPLAY_DEVICE);

            fKnownMonitor = EnumDisplayDevices(_pDisplayDevice->DeviceName, 0, &ddTmp, 0);
            hr = GetDevInstID((LPTSTR)(fKnownMonitor ? ddTmp.DeviceKey : TEXT("")), pstgmed);
            */

            hr = E_UNEXPECTED;

        }
        else if (pfmtetc->cfFormat == g_cfDisplayStateFlags)
        {
            DWORD* pdwStateFlags = (DWORD*)GlobalAlloc(GPTR, sizeof(DWORD));
            if (pdwStateFlags)
            {
                *pdwStateFlags = _pDisplayDevice->StateFlags;
                pstgmed->tymed = TYMED_HGLOBAL;
                pstgmed->hGlobal = pdwStateFlags;
                pstgmed->pUnkForRelease = NULL;
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else if (pfmtetc->cfFormat == g_cfDisplayPruningMode)
        {
            BYTE* pPruningMode = (BYTE*)GlobalAlloc(GPTR, sizeof(BYTE));
            if (pPruningMode)
            {
                *pPruningMode = (BYTE)(_bCanBePruned && _bIsPruningOn ? 1 : 0);
                pstgmed->tymed = TYMED_HGLOBAL;
                pstgmed->hGlobal = pPruningMode;
                pstgmed->pUnkForRelease = NULL;
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else if (pfmtetc->cfFormat == g_cfDisplayDeviceID)
        {
            {
                CRegistrySettings *pRegSettings = new CRegistrySettings(_pDisplayDevice->DeviceKey);
                if (pRegSettings)
                {
                    pszOut = pRegSettings->GetDeviceInstanceId();
                    hr = CopyDataToStorage(pstgmed, pszOut);
                    delete pRegSettings;
                }
                else 
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            
        }
        else
        {
            if (pfmtetc->cfFormat == g_cfMonitorName)
            {
                GetMonitorName(szMonitorName, ARRAYSIZE(szMonitorName));
                pszOut = szMonitorName;
            }
            else if (pfmtetc->cfFormat == g_cfMonitorDevice)
            {
                GetMonitorDevice(szMonitorDevice);
                pszOut = szMonitorDevice;
            }
            else if (pfmtetc->cfFormat == g_cfDisplayDevice)
            {
                pszOut = (LPTSTR)_pDisplayDevice->DeviceName;
            }
            else if (pfmtetc->cfFormat == g_cfDisplayDeviceKey)
            {
                pszOut = (LPTSTR)_pDisplayDevice->DeviceKey;
            }
            else 
            {
                ASSERT(pfmtetc->cfFormat == g_cfDisplayName);
                
                pszOut = (LPTSTR)_pDisplayDevice->DeviceString;
            }

            hr = CopyDataToStorage(pstgmed, pszOut);
        }
    }

    return(hr);
}

STDMETHODIMP CDisplaySettings::CopyDataToStorage(STGMEDIUM *pstgmed, LPTSTR pszOut)
{
    HRESULT hr = E_UNEXPECTED;
    int cch;

    if (NULL != pszOut) 
    {
        cch = lstrlen(pszOut) + 1;

        LPWSTR pwszDevice = (LPWSTR)GlobalAlloc(GPTR, cch * SIZEOF(WCHAR));
        if (pwszDevice)
        {
            //
            // We always return UNICODE string
            //

#ifdef UNICODE
            lstrcpy(pwszDevice, pszOut);
#else
            int cchConverted = MultiByteToWideChar(CP_ACP, 0, pszOut , -1, pwszDevice, cch);
            ASSERT(cchConverted == cch);
#endif
            pstgmed->tymed = TYMED_HGLOBAL;
            pstgmed->hGlobal = pwszDevice;
            pstgmed->pUnkForRelease = NULL;

            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


STDMETHODIMP CDisplaySettings::GetDataHere(FORMATETC *pfmtetc, STGMEDIUM *pstgpmed)
{
    ZeroMemory(pfmtetc, SIZEOF(pfmtetc));
    return E_NOTIMPL;
}

//
// Check that all the parameters to the interface are appropriately
//

STDMETHODIMP CDisplaySettings::QueryGetData(FORMATETC *pfmtetc)
{
    CLIPFORMAT cfFormat;

    if (pfmtetc->dwAspect != DVASPECT_CONTENT)
    {
        return DV_E_DVASPECT;
    }

    if ((pfmtetc->tymed & TYMED_HGLOBAL) == 0)
    {
        return  DV_E_TYMED;
    }

    cfFormat = pfmtetc->cfFormat;

    if ((cfFormat != g_cfDisplayDevice) &&
        (cfFormat != g_cfDisplayName)   &&
        (cfFormat != g_cfDisplayDeviceID)   &&
        (cfFormat != g_cfMonitorDevice) &&
        (cfFormat != g_cfMonitorName)   &&
        (cfFormat != g_cfMonitorDeviceID)   &&
        (cfFormat != g_cfExtensionInterface) &&
        (cfFormat != g_cfDisplayDeviceKey) &&
        (cfFormat != g_cfDisplayStateFlags) &&
        (cfFormat != g_cfDisplayPruningMode))
    {
        return DV_E_FORMATETC;
    }

    if (pfmtetc->lindex != -1)
    {
        return DV_E_LINDEX;
    }

    return S_OK;
}

STDMETHODIMP CDisplaySettings::GetCanonicalFormatEtc(FORMATETC *pfmtetcIn, FORMATETC *pfmtetcOut)
{
    HRESULT hr;
    ASSERT(pfmtetcIn);
    ASSERT(pfmtetcOut);

    hr = QueryGetData(pfmtetcIn);

    if (hr == S_OK)
    {
        *pfmtetcOut = *pfmtetcIn;

        if (pfmtetcIn->ptd == NULL)
            hr = DATA_S_SAMEFORMATETC;
        else
        {
            pfmtetcIn->ptd = NULL;
            ASSERT(hr == S_OK);
        }
    }
    else
        ZeroMemory(pfmtetcOut, SIZEOF(*pfmtetcOut));
    return(hr);
}


STDMETHODIMP CDisplaySettings::SetData(FORMATETC *pfmtetc, STGMEDIUM *pstgmed, BOOL bRelease)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDisplaySettings::EnumFormatEtc(DWORD dwDirFlags, IEnumFORMATETC ** ppiefe)
{
    HRESULT hr;

    ASSERT(ppiefe);
    *ppiefe = NULL;

    if (dwDirFlags == DATADIR_GET)
    {
        FORMATETC rgfmtetc[] =
        {
            { (CLIPFORMAT)g_cfDisplayDevice,      NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { (CLIPFORMAT)g_cfDisplayName,        NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { (CLIPFORMAT)g_cfMonitorDevice,      NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { (CLIPFORMAT)g_cfMonitorName,        NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { (CLIPFORMAT)g_cfExtensionInterface, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { (CLIPFORMAT)g_cfDisplayDeviceID,    NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { (CLIPFORMAT)g_cfMonitorDeviceID,    NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { (CLIPFORMAT)g_cfDisplayDeviceKey,   NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { (CLIPFORMAT)g_cfDisplayStateFlags,  NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { (CLIPFORMAT)g_cfDisplayPruningMode, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        };

        hr = SHCreateStdEnumFmtEtc(ARRAYSIZE(rgfmtetc), rgfmtetc, ppiefe);
    }
    else
        hr = E_NOTIMPL;

    return(hr);
}

STDMETHODIMP CDisplaySettings::DAdvise(FORMATETC *pfmtetc, DWORD dwAdviseFlags, IAdviseSink * piadvsink, DWORD * pdwConnection)
{
    ASSERT(pfmtetc);
    ASSERT(pdwConnection);

    *pdwConnection = 0;
    return OLE_E_ADVISENOTSUPPORTED;
}

STDMETHODIMP CDisplaySettings::DUnadvise(DWORD dwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

STDMETHODIMP CDisplaySettings::EnumDAdvise(IEnumSTATDATA ** ppiesd)
{
    ASSERT(ppiesd);
    *ppiesd = NULL;
    return OLE_E_ADVISENOTSUPPORTED;
}


void CDisplaySettings::_InitClipboardFormats()
{
    if (g_cfDisplayDevice == 0)
        g_cfDisplayDevice = RegisterClipboardFormat(DESKCPLEXT_DISPLAY_DEVICE);

    if (g_cfDisplayDeviceID == 0)
        g_cfDisplayDeviceID = RegisterClipboardFormat(DESKCPLEXT_DISPLAY_ID);
        
    if (g_cfDisplayName == 0)
        g_cfDisplayName = RegisterClipboardFormat(DESKCPLEXT_DISPLAY_NAME);

    if (g_cfMonitorDevice == 0)
        g_cfMonitorDevice = RegisterClipboardFormat(DESKCPLEXT_MONITOR_DEVICE);

    if (g_cfMonitorDeviceID == 0)
        g_cfMonitorDeviceID = RegisterClipboardFormat(DESKCPLEXT_MONITOR_ID);
        
    if (g_cfMonitorName == 0)
        g_cfMonitorName = RegisterClipboardFormat(DESKCPLEXT_MONITOR_NAME);

    if (g_cfExtensionInterface == 0)
        g_cfExtensionInterface = RegisterClipboardFormat(DESKCPLEXT_INTERFACE);

    if (g_cfDisplayDeviceKey == 0)
        g_cfDisplayDeviceKey = RegisterClipboardFormat(DESKCPLEXT_DISPLAY_DEVICE_KEY);

    if (g_cfDisplayStateFlags == 0)
        g_cfDisplayStateFlags = RegisterClipboardFormat(DESKCPLEXT_DISPLAY_STATE_FLAGS);
    
    if (g_cfDisplayPruningMode == 0)
        g_cfDisplayPruningMode = RegisterClipboardFormat(DESKCPLEXT_PRUNING_MODE);
}

HRESULT CDisplaySettings::QueryInterface(REFIID riid, LPVOID * ppvObj)
{ 
    static const QITAB qit[] = {
        QITABENT(CDisplaySettings, IDataObject),
        QITABENT(CDisplaySettings, IDisplaySettings),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


ULONG CDisplaySettings::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDisplaySettings::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}


STDMETHODIMP_(LPDEVMODEW)
CDisplaySettings::_lpfnEnumAllModes(
    LPVOID pContext,
    DWORD iMode)
{
    DWORD cCount = 0;
    DWORD i;

    CDisplaySettings *pSettings = (CDisplaySettings *) pContext;

    for (i = 0; pSettings->_apdm && (i < pSettings->_cpdm); i++)
    {
        // Don't show invalid modes or raw modes if pruning is on;

        if(!_IsModeVisible(pSettings, i))
        {
            continue;
        }

        if (cCount == iMode)
        {
            return (pSettings->_apdm + i)->lpdm;
        }

        cCount++;
    }

    return NULL;
}

STDMETHODIMP_(BOOL)
CDisplaySettings::_lpfnSetSelectedMode(
    LPVOID pContext,
    LPDEVMODEW lpdm)
{
    CDisplaySettings *pSettings = (CDisplaySettings *) pContext;

    return pSettings->_PerfectMatch(lpdm);
}

STDMETHODIMP_(LPDEVMODEW)
CDisplaySettings::_lpfnGetSelectedMode(
    LPVOID pContext
    )
{
    CDisplaySettings *pSettings = (CDisplaySettings *) pContext;

    return pSettings->_pCurDevmode;
}

STDMETHODIMP_(VOID)
CDisplaySettings::_lpfnSetPruningMode(
    LPVOID pContext,
    BOOL bIsPruningOn)
{
    CDisplaySettings *pSettings = (CDisplaySettings *) pContext;
    pSettings->SetPruningMode(bIsPruningOn);
}

STDMETHODIMP_(VOID)
CDisplaySettings::_lpfnGetPruningMode(
    LPVOID pContext,
    BOOL* pbCanBePruned,
    BOOL* pbIsPruningReadOnly,
    BOOL* pbIsPruningOn)
{
    CDisplaySettings *pSettings = (CDisplaySettings *) pContext;
    pSettings->GetPruningMode(pbCanBePruned, 
                              pbIsPruningReadOnly, 
                              pbIsPruningOn);
}

// If any attached device is at 640x480, we want to force small font
BOOL CDisplaySettings::IsSmallFontNecessary()
{
    if (_fOrgAttached || _fCurAttached)
    {
        //
        // Force Small fonts at 640x480
        //
        if (_CURXRES < 800 || _CURYRES < 600)
            return TRUE;
    }
    return FALSE;
}

// Constructor for CDisplaySettings
//
//  (gets called when ever a CDisplaySettings object is created)
//

CDisplaySettings::CDisplaySettings() 
    : _cRef(1)
    , _cpdm(0) 
    , _apdm(0)
    , _hPruningRegKey(NULL)
    , _bCanBePruned(FALSE)
    , _bIsPruningReadOnly(TRUE)
    , _bIsPruningOn(FALSE)
    , _pOrgDevmode(NULL)
    , _pCurDevmode(NULL)
    , _fOrgAttached(FALSE)
    , _fCurAttached(FALSE)
    , _bFilterOrientation(FALSE)
    , _bFilterFixedOutput(FALSE)
{
    SetRectEmpty(&_rcPreview);
}

//
// Destructor
//
CDisplaySettings::~CDisplaySettings() {

    TraceMsg(TF_DISPLAYSETTINGS, "**** Destructing %s", _pDisplayDevice->DeviceName);

    if (_apdm)
    {
        while(_cpdm--)
        {
            LocalFree((_apdm + _cpdm)->lpdm);
        }
        LocalFree(_apdm);
        _apdm = NULL;
    }

    _cpdm = 0;

    if(NULL != _hPruningRegKey)
        RegCloseKey(_hPruningRegKey);
}


//
// _SetFilterOptions -- determine if display modes should be filtered
//                      by orientation and/or fixed output (centered/stretched)
//

void CDisplaySettings::_SetFilterOptions(LPCTSTR pszDeviceName, LPDEVMODEW pdevmode)
{
    BOOL bCurrent = FALSE;
    BOOL bRegistry = FALSE;
    
    // See if we need to filter modes by orientation and/or stretched/centered
    ZeroMemory(pdevmode, sizeof(DEVMODE));
    pdevmode->dmSize = sizeof(DEVMODE);

    bCurrent = EnumDisplaySettingsExWrap(pszDeviceName,
                                         ENUM_CURRENT_SETTINGS,
                                         pdevmode,
                                         0);
    if (!bCurrent)
    {
        TraceMsg(TF_DUMP_CSETTINGS, "_SetFilterOptions -- No Current Mode. Try to use registry settings.");
        bRegistry = EnumDisplaySettingsExWrap(pszDeviceName,
                                              ENUM_REGISTRY_SETTINGS,
                                              pdevmode,
                                              0);
    }

    if (bCurrent || bRegistry)
    {
        if (pdevmode->dmFields & DM_DISPLAYORIENTATION)
        {
            _bFilterOrientation = TRUE;
            _dwOrientation = pdevmode->dmDisplayOrientation;
            TraceMsg(TF_DUMP_CSETTINGS, "Filtering modes on orientation %d", _dwOrientation);
        }
        if (pdevmode->dmFields & DM_DISPLAYFIXEDOUTPUT)
        {
            _bFilterFixedOutput = TRUE;
            _dwFixedOutput = pdevmode->dmDisplayFixedOutput;
            TraceMsg(TF_DUMP_CSETTINGS, "Filtering modes on fixed output %d", _dwFixedOutput);
        }
    }
    else
    {
        TraceMsg(TF_DUMP_CSETTINGS, "_SetFilterOptions -- No settings, forcing default");
        _bFilterOrientation = TRUE;
        _dwOrientation = DMDO_DEFAULT;
    }

    TraceMsg(TF_DUMP_CSETTINGS, "Filter mode settings for: %s", pszDeviceName);
    TraceMsg(TF_DUMP_CSETTINGS, "  _bFilterOrientation: %d, _dwOrientation: %d", _bFilterOrientation, _dwOrientation);
    TraceMsg(TF_DUMP_CSETTINGS, "  _bFilterFixedOutput: %d, _dwFixedOutput: %d", _bFilterFixedOutput, _dwFixedOutput);
}


//
// InitSettings -- Enumerate the settings, and build the mode list when
//

BOOL CDisplaySettings::InitSettings(LPDISPLAY_DEVICE pDisplay)
{
    BOOL fReturn = FALSE;
    LPDEVMODE pdevmode = (LPDEVMODE) LocalAlloc(LPTR, (sizeof(DEVMODE) + 0xFFFF));

    if (pdevmode)
    {
        ULONG  i = 0;
        BOOL   bCurrent = FALSE;
        BOOL   bRegistry = FALSE;
        BOOL   bExact = FALSE;

        fReturn = TRUE;

        // Set the cached values for modes.
        MAKEXYRES(&_ptCurPos, 0, 0);
        _fCurAttached  = FALSE;
        _pCurDevmode   = NULL;

        // Save the display name
        ASSERT(pDisplay);

        _pDisplayDevice = pDisplay;

        TraceMsg(TF_GENERAL, "Initializing CDisplaySettings for %s", _pDisplayDevice->DeviceName);

        // Pruning Mode
        _bCanBePruned = ((_pDisplayDevice->StateFlags & DISPLAY_DEVICE_MODESPRUNED) != 0);
        _bIsPruningReadOnly = TRUE;
        _bIsPruningOn = FALSE;
        if (_bCanBePruned)
        {
            _bIsPruningOn = TRUE; // if can be pruned, by default pruning is on 
            GetDeviceRegKey(_pDisplayDevice->DeviceKey, &_hPruningRegKey, &_bIsPruningReadOnly);
            if (_hPruningRegKey)
            {
                DWORD dwIsPruningOn = 1;
                DWORD cb = sizeof(dwIsPruningOn);
                RegQueryValueEx(_hPruningRegKey, 
                                SZ_PRUNNING_MODE,
                                NULL, 
                                NULL, 
                                (LPBYTE)&dwIsPruningOn, 
                                &cb);
                _bIsPruningOn = (dwIsPruningOn != 0);
            }
        }

        // See if we need to filter modes by orientation and/or stretched/centered
        _SetFilterOptions(_pDisplayDevice->DeviceName, pdevmode);
        
        // Lets generate a list with all the possible modes.
        ZeroMemory(pdevmode, sizeof(DEVMODE));
        pdevmode->dmSize = sizeof(DEVMODE);

        // Enum the raw list of modes
        while (EnumDisplaySettingsExWrap(_pDisplayDevice->DeviceName, i++, pdevmode, EDS_RAWMODE))
        {
            WORD      dmsize = pdevmode->dmSize + pdevmode->dmDriverExtra;
            LPDEVMODE lpdm = (LPDEVMODE) LocalAlloc(LPTR, dmsize);

            if (lpdm)
            {
                CopyMemory(lpdm, pdevmode, dmsize);
                _AddDevMode(lpdm);
            }

            pdevmode->dmDriverExtra = 0;
        }

        // Filter the list of modes

        _FilterModes();
        if(_bCanBePruned)
        {
            // Enum pruned list of modes
            i = 0;
            _bCanBePruned = FALSE;
        
            while (EnumDisplaySettingsExWrap(_pDisplayDevice->DeviceName, i++, pdevmode, 0))
            {
                if(_MarkMode(pdevmode))
                    _bCanBePruned = TRUE; // at least one non-raw mode  
                pdevmode->dmDriverExtra = 0;
            }

            if(!_bCanBePruned)
            {
                _bIsPruningReadOnly = TRUE;
                _bIsPruningOn = FALSE;
            }
        }

        // Debug
        _Dump_CDisplaySettings(TRUE);

        // Get the current mode
        ZeroMemory(pdevmode,sizeof(DEVMODE));
        pdevmode->dmSize = sizeof(DEVMODE);

        bCurrent = EnumDisplaySettingsExWrap(_pDisplayDevice->DeviceName,
                                         ENUM_CURRENT_SETTINGS,
                                         pdevmode,
                                         0);

        if (!bCurrent)
        {
            TraceMsg(TF_DISPLAYSETTINGS, "InitSettings -- No Current Mode. Try to use registry settings.");
        
            ZeroMemory(pdevmode,sizeof(DEVMODE));
            pdevmode->dmSize = sizeof(DEVMODE);

            bRegistry = EnumDisplaySettingsExWrap(_pDisplayDevice->DeviceName,
                                              ENUM_REGISTRY_SETTINGS,
                                              pdevmode,
                                              0);
        }

        // Set the default values based on registry or current settings.
        if (bCurrent || bRegistry)
        {
            // Check if this DEVMODE is in the list
            TraceMsg(TF_FUNC, "Devmode for Exact Matching");
            _Dump_CDevmode(pdevmode);
            TraceMsg(TF_FUNC, "");

            // If the current mode is not in the list of modes supported by 
            // the monitor, we want to show it anyway.
            // 
            // Consider the following scenario: the user sets the display 
            // to 1024x768 and after that it goes to DevManager and selects 
            // a monitor type that can not do that mode. When the user 
            // reopens the applet the current mode will be pruned out. 
            // In such a case we want the current mode to be visible.
            bExact = _ExactMatch(pdevmode, TRUE);

            if (!bExact && bCurrent)
            {
                // If the current mode is not in the list, we may have a problem.
            }
            
            // Is attached?
            if(bCurrent)
            {
                _fOrgAttached = _fCurAttached = ((pdevmode->dmFields & DM_POSITION) ? 1 : 0);
            }
        
            // Set the original values
            if (bExact == TRUE)
            {
                MAKEXYRES(&_ptCurPos, pdevmode->dmPosition.x, pdevmode->dmPosition.y);
                ConfirmChangeSettings();
            }
        }

        // If we have no modes, return FALSE.
        if (_cpdm == 0)
        {
            FmtMessageBox(ghwndPropSheet,
                          MB_ICONEXCLAMATION,
                          MSG_CONFIGURATION_PROBLEM,
                          MSG_INVALID_OLD_DISPLAY_DRIVER);

            fReturn = FALSE;
        }
        else
        {
            // If there were no current values, set some now
            // But don't confirm them ...
            if (bExact == FALSE)
            {
                TraceMsg(TF_DISPLAYSETTINGS, "InitSettings -- No Current OR Registry Mode");

                i = 0;
                // Try setting any mode as the current.
                while (_apdm && (_PerfectMatch((_apdm + i++)->lpdm) == FALSE))
                {
                    if (i > _cpdm)
                    {
                        FmtMessageBox(ghwndPropSheet,
                                      MB_ICONEXCLAMATION,
                                      MSG_CONFIGURATION_PROBLEM,
                                      MSG_INVALID_OLD_DISPLAY_DRIVER);

                        fReturn = FALSE;
                        break;
                    }
                }
        
                if (fReturn && _fCurAttached)
                {
                    MAKEXYRES(&_ptCurPos, _pCurDevmode->dmPosition.x, _pCurDevmode->dmPosition.y);
                }
            }

            if (fReturn)
            {
                // Export our interfaces for extended properly pages.
                _InitClipboardFormats();

                // Final debug output
                TraceMsg(TF_DUMP_CSETTINGS," InitSettings successful - current values :");
                _Dump_CDisplaySettings(FALSE);
            }
        }

        LocalFree(pdevmode);
    }

    return TRUE;
}


// SaveSettings
//
//  Writes the new display parameters to the proper place in the
//  registry.
int CDisplaySettings::SaveSettings(DWORD dwSet)
{
    int iResult = 0;

    if (_pCurDevmode)
    {
        // Make a copy of the current devmode
        ULONG dmSize = _pCurDevmode->dmSize + _pCurDevmode->dmDriverExtra;
        PDEVMODE pdevmode  = (LPDEVMODE) LocalAlloc(LPTR, dmSize);

        if (pdevmode)
        {
            CopyMemory(pdevmode, _pCurDevmode, dmSize);

            // Save all of the new values out to the registry
            // Resolution color bits and frequency
            //
            // We always have to set DM_POSITION when calling the API.
            // In order to remove a device from the desktop, what actually needs
            // to be done is provide an empty rectangle.
            pdevmode->dmFields |= DM_POSITION;

            if (!_fCurAttached)
            {
                pdevmode->dmPelsWidth = 0;
                pdevmode->dmPelsHeight = 0;
            }
            else
            {
                pdevmode->dmPosition.x = _ptCurPos.x;
                pdevmode->dmPosition.y = _ptCurPos.y;
            }

            TraceMsg(TF_GENERAL, "SaveSettings:: Display: %s", _pDisplayDevice->DeviceName);
            _Dump_CDevmode(pdevmode);

            // These calls have NORESET flag set so that it only goes to
            // change the registry settings, it does not refresh the display

            // If EnumDisplaySettings was called with EDS_RAWMODE, we need CDS_RAWMODE below.
            // Otherwise, it's harmless.
            iResult = ChangeDisplaySettingsEx(_pDisplayDevice->DeviceName,
                                              pdevmode,
                                              NULL,
                                              CDS_RAWMODE | dwSet | ( _fPrimary ? CDS_SET_PRIMARY : 0),
                                              NULL);

            if (iResult < 0)
            {
                TraceMsg(TF_DISPLAYSETTINGS, "**** SaveSettings:: ChangeDisplaySettingsEx not successful on %s", _pDisplayDevice->DeviceName);
            }

            LocalFree(pdevmode);
        }
    }

    return iResult;
}


HRESULT CDisplaySettings::GetDevInstID(LPTSTR lpszDeviceKey, STGMEDIUM *pstgmed)
{
    HRESULT hr = E_FAIL;
    return hr;
}


void ConvertStrToToken(LPTSTR pszString, DWORD cchSize)
{
    while (pszString[0])
    {
        if (TEXT('\\') == pszString[0])
        {
            pszString[0] = TEXT(':');
        }

        pszString++;
    }
}


HRESULT CDisplaySettings::_GetRegKey(LPDEVMODE pDevmode, int * pnIndex, LPTSTR pszRegKey, DWORD cchSize,
                                     LPTSTR pszRegValue, DWORD cchValueSize)
{
    HRESULT hr = E_FAIL;
    DISPLAY_DEVICE ddMonitor = {0};

    ddMonitor.cb = sizeof(ddMonitor);
    if (pDevmode && pDevmode->dmDeviceName && _pDisplayDevice &&
        EnumDisplayDevices(_pDisplayDevice->DeviceName, *pnIndex, &ddMonitor, 0))
    {
        TCHAR szMonitor[MAX_PATH];
        TCHAR szVideoAdapter[MAX_PATH];

        StrCpyN(szMonitor, ddMonitor.DeviceID, ARRAYSIZE(szMonitor));
        StrCpyN(szVideoAdapter, _pDisplayDevice->DeviceID, ARRAYSIZE(szVideoAdapter));
        ConvertStrToToken(szMonitor, ARRAYSIZE(szMonitor));
        ConvertStrToToken(szVideoAdapter, ARRAYSIZE(szVideoAdapter));

        wnsprintf(pszRegKey, cchSize, TEXT("%s\\%s\\%s,%d\\%dx%d x %dHz"), SZ_CP_SETTINGS_VIDEO, 
                szVideoAdapter, szMonitor, *pnIndex, pDevmode->dmPelsWidth, pDevmode->dmPelsHeight, 
                pDevmode->dmDisplayFrequency);

        wnsprintf(pszRegValue, cchValueSize, TEXT("%d bpp"), pDevmode->dmBitsPerPel);
        hr = S_OK;
    }

    return hr;
}


BOOL CDisplaySettings::ConfirmChangeSettings()
{
    // Succeeded, so, reset the original settings
    _ptOrgPos      = _ptCurPos;
    _pOrgDevmode   = _pCurDevmode;
    _fOrgAttached  = _fCurAttached;

    // Now write the results to the registry so we know this is safe and can use it later.
    TCHAR szRegKey[2*MAX_PATH];
    TCHAR szRegValue[20];
    int nIndex = 0;

    while (SUCCEEDED(_GetRegKey(_pCurDevmode, &nIndex, szRegKey, ARRAYSIZE(szRegKey), szRegValue, ARRAYSIZE(szRegValue))))
    {
        HKEY hKey;

        if (SUCCEEDED(HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegKey, 0, NULL,
            REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, NULL)))
        {
            RegCloseKey(hKey);
        }
        HrRegSetDWORD(HKEY_LOCAL_MACHINE, szRegKey, szRegValue, 1);
        nIndex++;
    }

    return TRUE;
}


BOOL CDisplaySettings::IsKnownSafe(void)
{
    TCHAR szRegKey[2*MAX_PATH];
    TCHAR szRegValue[20];
    BOOL fIsSafe = FALSE;
    int nIndex = 0;

    while (SUCCEEDED(_GetRegKey(_pCurDevmode, &nIndex, szRegKey, ARRAYSIZE(szRegKey), szRegValue, ARRAYSIZE(szRegValue))))
    {
        fIsSafe = HrRegGetDWORD(HKEY_LOCAL_MACHINE, szRegKey, szRegValue, 0);
        if (!fIsSafe)
        {
            break;
        }

        nIndex++;
    }

    // TODO: In blackcomb, just return TRUE as long as long as we were able to prune the list.  If we could prune the list,
    // then the driver dudes where able to get PnP IDs from the video cards (adapters) and monitors, so the list of
    // supported modes should be accurate.  If not, the drivers guys (ErickS) will fix.  -BryanSt
    return fIsSafe;
}


int CDisplaySettings::RestoreSettings()
{
    //
    // Test failed, so restore the old settings, only restore the color and resolution
    // information, and do restore the monitor position and its attached status
    // Although this function is currently only called when restoring resolution
    // the user could have changed position, then resolution and then clicked 'Apply,'
    // in which case we want to revert position as well.
    //

    int iResult = DISP_CHANGE_SUCCESSFUL;
    PDEVMODE pdevmode;

    //
    // If this display was originally turned off, don't bother
    //

    if ((_pOrgDevmode != NULL) &&
        //(_pOrgDevmode != _pCurDevmode))
        ((_pOrgDevmode != _pCurDevmode) || (_ptOrgPos.x != _ptCurPos.x) || (_ptOrgPos.y != _ptCurPos.y) ))
    {
        iResult = DISP_CHANGE_NOTUPDATED;
        
        // Make a copy of the original devmode
        ULONG dmSize = _pOrgDevmode->dmSize + _pOrgDevmode->dmDriverExtra;
        pdevmode  = (LPDEVMODE) LocalAlloc(LPTR, dmSize);

        if (pdevmode)
        {
            CopyMemory(pdevmode, _pOrgDevmode, dmSize);

            pdevmode->dmFields |= DM_POSITION;
            pdevmode->dmPosition.x = _ptOrgPos.x;
            pdevmode->dmPosition.y = _ptOrgPos.y;
    
            if (!_fOrgAttached)
            {
                pdevmode->dmPelsWidth = 0;
                pdevmode->dmPelsHeight = 0;
            }
    
            TraceMsg(TF_GENERAL, "RestoreSettings:: Display: %s", _pDisplayDevice->DeviceName);
            _Dump_CDevmode(pdevmode);

            // If EnumDisplaySettings was called with EDS_RAWMODE, we need CDS_RAWMODE below.
            // Otherwise, it's harmless.
            iResult = ChangeDisplaySettingsEx(_pDisplayDevice->DeviceName,
                                              pdevmode,
                                              NULL,
                                              CDS_RAWMODE | CDS_UPDATEREGISTRY | CDS_NORESET | ( _fPrimary ? CDS_SET_PRIMARY : 0),
                                              NULL);
            if (iResult  < 0 )
            {
                TraceMsg(TF_DISPLAYSETTINGS, "**** RestoreSettings:: ChangeDisplaySettingsEx not successful on %s", _pDisplayDevice->DeviceName);
                ASSERT(FALSE);
                LocalFree(pdevmode);
                return iResult;
            }
            else
            {
                // Succeeded, so, reset the original settings
                _ptCurPos      = _ptOrgPos;
                _pCurDevmode   = _pOrgDevmode;
                _fCurAttached  = _fOrgAttached;
                
                if(_bCanBePruned && !_bIsPruningReadOnly && _bIsPruningOn && _IsCurDevmodeRaw())
                    SetPruningMode(FALSE);
            }

            LocalFree(pdevmode);
        }
    }

    return iResult;
}

    


BOOL CDisplaySettings::_IsModeVisible(int i)
{
    return _IsModeVisible(this, i);
}


BOOL CDisplaySettings::_IsModeVisible(CDisplaySettings* pSettings, int i)
{
    ASSERT(pSettings);

    if (!pSettings->_apdm)
    {
        return FALSE;
    }

    // (the mode is valid) AND
    // ((pruning mode is off) OR (mode is not raw))
    return ((!((pSettings->_apdm + i)->dwFlags & MODE_INVALID)) &&
            ((!pSettings->_bIsPruningOn) || 
             (!((pSettings->_apdm + i)->dwFlags & MODE_RAW))
            )
           );
}


BOOL CDisplaySettings::_IsModePreferred(int i)
{
    LPDEVMODE pDevMode = ((PMODEARRAY)(_apdm + i))->lpdm;

    if (_pCurDevmode == pDevMode)
        return TRUE;

    BOOL bLandscape = (pDevMode->dmPelsWidth >= pDevMode->dmPelsHeight);

    TraceMsg(TF_DUMP_CSETTINGS, "_IsModePreferred: %d x %d - landscape mode: %d", 
             pDevMode->dmPelsWidth, pDevMode->dmPelsHeight, bLandscape);

    // (the mode is valid) AND
    // ((pruning mode is off) OR (mode is not raw))
    return (pDevMode->dmBitsPerPel >= 15 &&
            ((bLandscape && pDevMode->dmPelsWidth >= 800 && pDevMode->dmPelsHeight >= 600) || 
             (!bLandscape && pDevMode->dmPelsWidth >= 600 && pDevMode->dmPelsHeight >= 800)));
}


BOOL CDisplaySettings::_MarkMode(LPDEVMODE lpdm)
{
    LPDEVMODE pdm;
    ULONG i;
    BOOL bMark = FALSE;

    for (i = 0; _apdm && (i < _cpdm); i++)
    {
        if (!((_apdm + i)->dwFlags & MODE_INVALID))
        {
            pdm = (_apdm + i)->lpdm;

            if (
                ((lpdm->dmFields & DM_BITSPERPEL) &&
                 (pdm->dmBitsPerPel == lpdm->dmBitsPerPel))

                &&

                ((lpdm->dmFields & DM_PELSWIDTH) &&
                 (pdm->dmPelsWidth == lpdm->dmPelsWidth))

                &&

                ((lpdm->dmFields & DM_PELSHEIGHT) &&
                 (pdm->dmPelsHeight == lpdm->dmPelsHeight))

                &&

                ((lpdm->dmFields & DM_DISPLAYFREQUENCY) &&
                 (pdm->dmDisplayFrequency == lpdm->dmDisplayFrequency))
               )
            {
               (_apdm + i)->dwFlags &= ~MODE_RAW;
               bMark = TRUE;
            }
        }
    }

    return bMark;
}


BOOL CDisplaySettings::_IsCurDevmodeRaw()
{
    LPDEVMODE pdm;
    ULONG i;
    BOOL bCurrentAndPruned = FALSE;

    for (i = 0; _apdm && (i < _cpdm); i++)
    {
        if (!((_apdm + i)->dwFlags & MODE_INVALID) &&
            ((_apdm + i)->dwFlags & MODE_RAW))
        {
            pdm = (_apdm + i)->lpdm;

            if (
                ((_pCurDevmode->dmFields & DM_BITSPERPEL) &&
                 (pdm->dmBitsPerPel == _pCurDevmode->dmBitsPerPel))

                &&

                ((_pCurDevmode->dmFields & DM_PELSWIDTH) &&
                 (pdm->dmPelsWidth == _pCurDevmode->dmPelsWidth))

                &&

                ((_pCurDevmode->dmFields & DM_PELSHEIGHT) &&
                 (pdm->dmPelsHeight == _pCurDevmode->dmPelsHeight))

                &&

                ((_pCurDevmode->dmFields & DM_DISPLAYFREQUENCY) &&
                 (pdm->dmDisplayFrequency == _pCurDevmode->dmDisplayFrequency))
               )
            {
                bCurrentAndPruned = TRUE;
                break;
            }
        }
    }

    return bCurrentAndPruned;     
}

DISPLAY_DEVICE dd;

HRESULT CDisplaySettings::SetMonitor(DWORD dwMonitor)
{
    ZeroMemory(&dd, sizeof(DISPLAY_DEVICE));
    dd.cb = sizeof(DISPLAY_DEVICE);

    DWORD dwMon = 0;
    for (DWORD dwCount = 0; EnumDisplayDevices(NULL, dwCount, &dd, 0); dwCount++)
    {
        if (!(dd.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER))
        {
            if (dwMon == dwMonitor)
            {
                InitSettings(&dd);
                _fPrimary = (dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE);
                return S_OK;
            }
            dwMon++;
        }
    }

    return E_INVALIDARG;
}

HRESULT CDisplaySettings::GetModeCount(DWORD* pdwCount, BOOL fOnlyPreferredModes)
{
    DWORD cCount = 0;

    for (DWORD i = 0; _apdm && (i < _cpdm); i++)
    {
        // Don't show invalid modes or raw modes if pruning is on;

        if(!_IsModeVisible(i))
        {
            continue;
        }

        if(fOnlyPreferredModes && (!_IsModePreferred(i)))
        {
            continue;
        }

        cCount++;
    }

    *pdwCount = cCount;

    return S_OK;
}

HRESULT CDisplaySettings::GetMode(DWORD dwMode, BOOL fOnlyPreferredModes, DWORD* pdwWidth, DWORD* pdwHeight, DWORD* pdwColor)
{
    DWORD cCount = 0;

    for (DWORD i = 0; _apdm && (i < _cpdm); i++)
    {
        // Don't show invalid modes or raw modes if pruning is on;

        if(!_IsModeVisible(i))
        {
            continue;
        }

        if(fOnlyPreferredModes && (!_IsModePreferred(i)))
        {
            continue;
        }

        if (cCount == dwMode)
        {
            LPDEVMODE lpdm = (_apdm + i)->lpdm;
            *pdwWidth = lpdm->dmPelsWidth;
            *pdwHeight = lpdm->dmPelsHeight;
            *pdwColor = lpdm->dmBitsPerPel;

            return S_OK;
        }

        cCount++;
    }

    return E_INVALIDARG;
}

DEVMODE dm;

HRESULT CDisplaySettings::SetSelectedMode(HWND hwnd, DWORD dwWidth, DWORD dwHeight, DWORD dwColor, BOOL* pfApplied, DWORD dwFlags)
{
    dm.dmBitsPerPel = dwColor;
    dm.dmPelsWidth = dwWidth;
    dm.dmPelsHeight = dwHeight;
    dm.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;
    
    *pfApplied = FALSE;
    
    POINT res = {dwWidth, dwHeight};
    PLONGLONG freq = NULL;
    int cFreq = GetFrequencyList(dwColor, &res, &freq);
    if (cFreq)
    {
        dm.dmFields |= DM_DISPLAYFREQUENCY;
        // Default to lowest frequency
        dm.dmDisplayFrequency = (DWORD)freq[0];

        // Try to find a good frequency
        for (int i = cFreq - 1; i >= 0; i--)
        {
            if ((freq[i] >= 60) && (freq[i] <= 72))
            {
                dm.dmDisplayFrequency = (DWORD)freq[i];
            }
        }
    }
    LocalFree(freq);

    ULONG dmSize = _pCurDevmode->dmSize + _pCurDevmode->dmDriverExtra;
    PDEVMODE pOldDevMode = (LPDEVMODE) LocalAlloc(LPTR, dmSize);

    if (pOldDevMode)
    {
        CopyMemory(pOldDevMode, _pCurDevmode, dmSize);

        if (_ExactMatch(&dm, FALSE))
        {
            // Verify that the mode actually works
            if (SaveSettings(CDS_TEST) == DISP_CHANGE_SUCCESSFUL)
            {
                // Update the registry to specify the new display settings
                if (SaveSettings(CDS_UPDATEREGISTRY | CDS_NORESET) == DISP_CHANGE_SUCCESSFUL)
                {
                    // Refresh the display info from the registry, if you update directly ChangeDisplaySettings will do weird things in the fringe cases
                    if (ChangeDisplaySettings(NULL, CDS_RAWMODE) == DISP_CHANGE_SUCCESSFUL)
                    {
                        if (IsKnownSafe())
                        {
                            // No need to warn, this is known to be a good value.
                            *pfApplied = TRUE;
                        }
                        else
                        {
                            INT_PTR iRet = DialogBoxParam(HINST_THISDLL,
                                          MAKEINTRESOURCE((dwFlags & DS_BACKUPDISPLAYCPL) ? DLG_KEEPNEW2 : DLG_KEEPNEW3),
                                          hwnd,
                                          KeepNewDlgProc,
                                          (dwFlags & DS_BACKUPDISPLAYCPL) ? 15 : 30);
    
                            if ((IDYES == iRet) || (IDOK == iRet))
                            {
                                *pfApplied = TRUE;
                            }
                            else
                            {
                                if (_ExactMatch(pOldDevMode, FALSE))
                                {
                                    SaveSettings(CDS_UPDATEREGISTRY | CDS_NORESET);
                                    ChangeDisplaySettings(NULL, CDS_RAWMODE);
                                }
        
                                if (dwFlags & DS_BACKUPDISPLAYCPL)
                                {
                                    // Use shellexecuteex to run the display CPL
                                    SHELLEXECUTEINFO shexinfo = {0};
                                    shexinfo.cbSize = sizeof (shexinfo);
                                    shexinfo.fMask = SEE_MASK_FLAG_NO_UI;
                                    shexinfo.nShow = SW_SHOWNORMAL;
                                    shexinfo.lpFile = L"desk.cpl";
    
                                    ShellExecuteEx(&shexinfo);
                                }
                            }
                        }
                    }
                }
            }
        }

        LocalFree(pOldDevMode);
    }

    return S_OK;
}

HRESULT CDisplaySettings::GetSelectedMode(DWORD* pdwWidth, DWORD* pdwHeight, DWORD* pdwColor)
{
    if (pdwWidth && pdwHeight && pdwColor)
    {
        if (_pCurDevmode)
        {
            *pdwWidth = _pCurDevmode->dmPelsWidth;
            *pdwHeight = _pCurDevmode->dmPelsHeight;
            *pdwColor = _pCurDevmode->dmBitsPerPel;
            return S_OK;
        }
        else
        {
            return E_FAIL;
        }
    }
    else
    {
        return E_INVALIDARG;
    }
}

HRESULT CDisplaySettings::GetAttached(BOOL* pfAttached)
{
    if (pfAttached)
    {
        *pfAttached = _fCurAttached;
        return S_OK;
    }
    else
        return E_INVALIDARG;
}

HRESULT CDisplaySettings::SetPruningMode(BOOL fIsPruningOn)
{
    ASSERT (_bCanBePruned && !_bIsPruningReadOnly);
    
    if (_bCanBePruned && 
        !_bIsPruningReadOnly &&
        ((fIsPruningOn != 0) != _bIsPruningOn))
    {
        _bIsPruningOn = (fIsPruningOn != 0);

        DWORD dwIsPruningOn = (DWORD)_bIsPruningOn;
        RegSetValueEx(_hPruningRegKey, 
                      SZ_PRUNNING_MODE,
                      NULL, 
                      REG_DWORD, 
                      (LPBYTE) &dwIsPruningOn, 
                      sizeof(dwIsPruningOn));

        //
        // handle the special case when we pruned out the current mode
        //
        if(_bIsPruningOn && _IsCurDevmodeRaw())
        {
            //
            // switch to the closest mode
            //
            _BestMatch(NULL, -1, TRUE);
        }
        
    }

    return S_OK;
}

HRESULT CDisplaySettings::GetPruningMode(BOOL* pfCanBePruned, BOOL* pfIsPruningReadOnly, BOOL* pfIsPruningOn)
{
    if (pfCanBePruned && pfIsPruningReadOnly && pfIsPruningOn)
    {
        *pfCanBePruned = _bCanBePruned;
        *pfIsPruningReadOnly = _bIsPruningReadOnly;
        *pfIsPruningOn = _bIsPruningOn;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

HRESULT CDisplaySettings_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj)
{
    HRESULT hr = E_INVALIDARG;

    if (!punkOuter && ppvObj)
    {
        CDisplaySettings * pThis = new CDisplaySettings();

        *ppvObj = NULL;
        if (pThis)
        {
            hr = pThis->QueryInterface(riid, ppvObj);
            pThis->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\dragsize.cpp ===
/*
**  DRAGSIZE.C
**
**  Drag size bar code
**
*/

#include "priv.h"

#pragma hdrstop


typedef struct tagDRAGSIZEINFO
{
    DWORD_PTR lpData;
    BOOL bDragging;
    POINT ptNow;
    HFONT hFont;
} DRAGSIZEINFO, *PDRAGSIZEINFO;

static TCHAR szDragSizeClass[] = DRAGSIZECLASSNAME;

LRESULT NEAR PASCAL InitDragSizeWnd(HWND hWnd, LPCREATESTRUCT lpCreate)
{
    PDRAGSIZEINFO pDragSizeInfo;

    /* Create the status info struct; abort if it does not exist,
    ** otherwise save it in the window structure
    */
    pDragSizeInfo = ALLOCWINDOWPOINTER(PDRAGSIZEINFO, sizeof(DRAGSIZEINFO));
    if (!pDragSizeInfo)
    {
        return(-1);
    }
    SETWINDOWPOINTER(hWnd, PDRAGSIZEINFO, pDragSizeInfo);
    pDragSizeInfo->lpData = (DWORD_PTR)lpCreate->lpCreateParams;
    pDragSizeInfo->bDragging = FALSE;

    return(0);
}


/* Track the mouse and send messages to the parent whenever it moves.
*/
void NEAR PASCAL DragSize(HWND hWnd, PDRAGSIZEINFO pDragSizeInfo, POINT ptStart)
{
    MSG msg;
    HWND hwndParent;
        LONG wID;

    if (!pDragSizeInfo || pDragSizeInfo->bDragging)
    {
        return;
    }

    pDragSizeInfo->bDragging = TRUE;
    pDragSizeInfo->ptNow     = ptStart;

    SetCapture(hWnd);

    hwndParent = GetParent(hWnd);
        wID = GETWINDOWID(hWnd);

        SendMessage(hwndParent, WM_COMMAND, MAKEWPARAM(wID, DSN_BEGINDRAG), (LPARAM)hWnd);

    for ( ; ; )
    {
        if (GetCapture() != hWnd)
        {
EndAbort:
            /* Abort the process.
            */
            pDragSizeInfo->ptNow = ptStart;
                        SendMessage(hwndParent, WM_COMMAND, MAKEWPARAM(wID, DSN_DRAGGING), (LPARAM)hWnd);
            goto EndAdjust;
        }

        if (!PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            continue;
        }

        switch (msg.message)
        {
        case WM_KEYDOWN:
            switch (msg.wParam)
            {
            case VK_ESCAPE:
AbortAdjust:
                SetCapture(NULL);
                goto EndAbort;

            default:
                break;
            }
            break;

        case WM_KEYUP:
        case WM_CHAR:
            break;

        case WM_LBUTTONDOWN:
            /* This shouldn't happen.
            */
            goto AbortAdjust;

        case WM_MOUSEMOVE:
            LPARAM2POINT( msg.lParam, &(pDragSizeInfo->ptNow) );
            
            TraceMsg(TF_GENERAL, "DragSize: ptNow = (%d, %d)\n", pDragSizeInfo->ptNow.x, pDragSizeInfo->ptNow.y);
            
            SendMessage(hwndParent, WM_COMMAND, MAKEWPARAM(wID, DSN_DRAGGING), (LPARAM)hWnd);
            break;

        case WM_LBUTTONUP:
            /* All done.
            */
            SetCapture(NULL);
            goto EndAdjust;

        case WM_RBUTTONDOWN:
            goto AbortAdjust;

        default:
            TranslateMessage(&msg);
            DispatchMessage(&msg);
            break;
        }
    }

EndAdjust:
        SendMessage(hwndParent, WM_COMMAND, MAKEWPARAM(wID, DSN_ENDDRAG), (LPARAM)hWnd);
    pDragSizeInfo->bDragging = FALSE;
}


/* Ask the parent to paint the window.
*/
void NEAR PASCAL PaintDragSizeWnd(HWND hWnd, PDRAGSIZEINFO pDragSizeInfo)
{
    PAINTSTRUCT ps;
    DRAWITEMSTRUCT dis;
    HDC hDC;
    HFONT hOldFont = NULL;

    if (!pDragSizeInfo)
    {
        return;
    }

    hDC = BeginPaint(hWnd, &ps);

    if (pDragSizeInfo->hFont)
    {
        hOldFont = (HFONT) SelectObject(hDC, pDragSizeInfo->hFont);
    }

    /* Fill in the DRAWITEMSTRUCT.  Note that some of the fields are
    ** undefined.
    */
    dis.CtlID    = GetDlgCtrlID(hWnd);
    dis.hwndItem = hWnd;
    dis.hDC      = hDC;
    GetClientRect(hWnd, &dis.rcItem);
    dis.itemData = pDragSizeInfo->lpData;

    SendMessage(GetParent(hWnd), WM_DRAWITEM, GetDlgCtrlID(hWnd),
        (LPARAM)(LPDRAWITEMSTRUCT)&dis);

    if (hOldFont)
    {
        SelectObject(hDC, hOldFont);
    }

    EndPaint(hWnd, &ps);
}


LRESULT CALLBACK DragSizeWndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
#define lpCreate ((LPCREATESTRUCT)lParam)

    PDRAGSIZEINFO pDragSizeInfo;

    pDragSizeInfo = GETWINDOWPOINTER(hWnd, PDRAGSIZEINFO);

    switch (uMessage)
    {
    case WM_NCCREATE:
                SendMessage(lpCreate->hwndParent, WM_COMMAND,
                        MAKEWPARAM((SHORT)(lpCreate->hMenu), DSN_NCCREATE), (LPARAM)hWnd);
        break;

    case WM_CREATE:
        InitDragSizeWnd(hWnd, (LPCREATESTRUCT)lParam);
        break;

    case WM_DESTROY:
        if (pDragSizeInfo)
        {
            FREEWINDOWPOINTER(pDragSizeInfo);
            SETWINDOWPOINTER(hWnd, PDRAGSIZEINFO, NULL);
        }
        break;

        case WM_LBUTTONDOWN: {
                    POINT pt;
                    LPARAM2POINT( lParam, &pt );
                    DragSize(hWnd, pDragSizeInfo, pt);
                }
                break;

    case WM_PAINT:
        PaintDragSizeWnd(hWnd, pDragSizeInfo);
        return(0);

    case WM_SETFONT:
        if (!pDragSizeInfo)
        {
            return(1L);
        }
        pDragSizeInfo->hFont = (HFONT)wParam;

        if (LOWORD(lParam))
        {
            InvalidateRect(hWnd, NULL, TRUE);
            UpdateWindow(hWnd);
        }
        return(0L);

    case WM_GETFONT:
        if (!pDragSizeInfo)
        {
                        return(LRESULT)(NULL);
        }
        return(MAKELRESULT(pDragSizeInfo->hFont, 0));

        case DSM_DRAGPOS: {
                    LPPOINT lppt = (LPPOINT)lParam;

                    if (!pDragSizeInfo || !pDragSizeInfo->bDragging || lppt == NULL)
                    {
                            return(-1L);
                    }

                    *lppt = pDragSizeInfo->ptNow;

                    return(0);
                }
        break;

    default:
        break;
    }

    return(DefWindowProc(hWnd, uMessage, wParam, lParam));
}


BOOL FAR PASCAL InitDragSizeClass(void)
{
    WNDCLASS rClass;

    if (GetClassInfo(HINST_THISDLL, szDragSizeClass, &rClass))
    {
        return(TRUE);
    }

    rClass.style         = 0;
    rClass.lpfnWndProc   = DragSizeWndProc;
    rClass.cbClsExtra    = 0;
    rClass.cbWndExtra    = sizeof(PDRAGSIZEINFO);
    rClass.hInstance     = HINST_THISDLL;
    rClass.hIcon         = NULL;
    rClass.hCursor       = LoadCursor(NULL, IDC_ARROW);
    rClass.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
    rClass.lpszMenuName  = NULL;
    rClass.lpszClassName = szDragSizeClass;

    return(RegisterClass(&rClass));
}


HWND WINAPI CreateDragSizeWindow(LONG style, int x, int y, int wid, int hgt, HWND hwndParent, LONG wID)
{
    /* Create a default window and return
    */
    return(CreateWindow(szDragSizeClass, g_szNULL, style,
        x, y, wid, hgt, hwndParent, (HMENU)IntToPtr(wID), HINST_THISDLL, NULL));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\dllreg.cpp ===
/*****************************************************************************\
    FILE: dllreg.cpp

    DESCRIPTION:
        Register selfreg.inf, which exists in our resource.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"

#include <advpub.h>
#include <comcat.h>
#include <theme.h>       // For LIBID_Theme
#include <userenv.h>     // PT_ROAMING from userenv.dll

#define SZ_MUILANG_CMDLINEARG               L"/RES="
#define SZ_MUILANG_CMDLINEARG_DEFAULT       L"/RES=%04x"

extern CComModule _Module;

BOOL g_fInSetup = FALSE;
BOOL g_fDoNotInstallThemeWallpaper = FALSE;     // This is used to not install wallpaper.

HRESULT InstallVS(LPCWSTR pszCmdLine);

// helper macros

// ADVPACK will return E_UNEXPECTED if you try to uninstall (which does a registry restore)
// on an INF section that was never installed.  We uninstall sections that may never have
// been installed, so this MACRO will quiet these errors.
#define QuietInstallNoOp(hr)   ((E_UNEXPECTED == hr) ? S_OK : hr)


BOOL UnregisterTypeLibrary(const CLSID* piidLibrary)
{
    TCHAR szScratch[GUIDSTR_MAX];
    HKEY hk;
    BOOL fResult = FALSE;

    // convert the libid into a string.
    SHStringFromGUID(*piidLibrary, szScratch, ARRAYSIZE(szScratch));

    if (RegOpenKey(HKEY_CLASSES_ROOT, TEXT("TypeLib"), &hk) == ERROR_SUCCESS)
    {
        fResult = RegDeleteKey(hk, szScratch);
        RegCloseKey(hk);
    }

    return fResult;
}



HRESULT MyRegTypeLib(void)
{
    ITypeLib * pTypeLib;
    WCHAR szTmp[MAX_PATH];

    GetModuleFileName(HINST_THISDLL, szTmp, ARRAYSIZE(szTmp));

    // Load and register our type library.
    HRESULT hr = LoadTypeLib(szTmp, &pTypeLib);
    if (SUCCEEDED(hr))
    {
        // call the unregister type library as we had some old junk that
        // was registered by a previous version of OleAut32, which is now causing
        // the current version to not work on NT...
        UnregisterTypeLibrary(&LIBID_Theme);
        hr = RegisterTypeLib(pTypeLib, szTmp, NULL);
        if (FAILED(hr))
        {
            TraceMsg(TF_WARNING, "RegisterTypeLib failed (%x)", hr);
        }

        pTypeLib->Release();
    }
    else
    {
        TraceMsg(TF_WARNING, "LoadTypeLib failed (%x)", hr);
    }

    return hr;
}



/*----------------------------------------------------------
Purpose: Calls the ADVPACK entry-point which executes an inf
         file section.

Returns: 
Cond:    --
*/
HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            char szIEPath[MAX_PATH];
            STRENTRY seReg[] = {
                { "NO_LONGER_USED", szIEPath },

                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg) - 2, seReg };

            szIEPath[0] = 0;
            hr = pfnri(HINST_THISDLL, szSection, &stReg);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}


enum eThemeToSetup
{
    eThemeNoChange = 0,
    eThemeWindowsClassic,
    eThemeProfessional,
    eThemeConsumer,
};


eThemeToSetup GetVisualStyleToSetup(BOOL fPerUser)
{
    eThemeToSetup eVisualStyle = eThemeNoChange;

#ifndef _WIN64
    if (IsOS(OS_PERSONAL))
    {
#ifdef FEATURE_PERSONAL_SKIN_ENABLED
        eVisualStyle = eThemeConsumer;
#else // FEATURE_PERSONAL_SKIN_ENABLED
        eVisualStyle = eThemeProfessional;        // We don't support Consumer yet.
#endif // FEATURE_PERSONAL_SKIN_ENABLED
    }
    else if (IsOS(OS_PROFESSIONAL))
    {

        eVisualStyle = eThemeProfessional;
    }
#endif

    return eVisualStyle;
}


eThemeToSetup GetThemeToSetup(BOOL fPerUser)
{
    eThemeToSetup eTheme = eThemeNoChange;

    // We want Pro, if:
    // 1. Not IA64
    // 2. Not Server or Personal
    // 3. Not Roaming
#ifndef _WIN64
    if (IsOS(OS_PERSONAL))
    {
#ifdef FEATURE_PERSONAL_SKIN_ENABLED
        eTheme = eThemeConsumer;
#else // FEATURE_PERSONAL_SKIN_ENABLED
        eTheme = eThemeProfessional;        // We don't support Consumer yet.
#endif // FEATURE_PERSONAL_SKIN_ENABLED
    }
    else if (IsOS(OS_PROFESSIONAL))
    {
        eTheme = eThemeProfessional;
    }
#endif

    return eTheme;
}


BOOL IsNewUser(void)
{
    // We know this user is newly created because it has a key that as copied from
    // the ".default" hive.  If it was a upgrade user from pre-whistler, then it
    // would not have this key.
    BOOL fNewUser = FALSE;
    TCHAR szVersion[MAX_PATH];

    if (SUCCEEDED(HrRegGetValueString(HKEY_CURRENT_USER, THEMEMGR_REGKEY, THEMEPROP_WHISTLERBUILD, szVersion, ARRAYSIZE(szVersion))) &&
        szVersion[0])
    {
        fNewUser = TRUE;
    }

    return fNewUser;
}


BOOL IsUserRoaming(void)
{
    BOOL fRoaming = FALSE;
    DWORD dwProfile;

    if (GetProfileType(&dwProfile))
    {
        fRoaming = ((dwProfile & (PT_ROAMING | PT_MANDATORY)) ? TRUE : FALSE);
    }

    return fRoaming;
}


BOOL IsUserHighContrastUser(void)
{
    BOOL fHighContrast = FALSE;
    HIGHCONTRAST hc;

    hc.cbSize = sizeof(hc);
    if (ClassicSystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof(hc), &hc, 0) &&
        (hc.dwFlags & HCF_HIGHCONTRASTON))
    {
        fHighContrast = TRUE;
    }

    return fHighContrast;
}


SIZE_T GetMachinePhysicalRAMSize(void)
{
    MEMORYSTATUS ms = {0};

    GlobalMemoryStatus(&ms);
    SIZE_T nMegabytes = (ms.dwTotalPhys / (1024 * 1024));

    return nMegabytes;
}


HRESULT InstallTheme(IThemeManager * pThemeManager, LPCTSTR pszThemePath)
{
    HRESULT hr = E_OUTOFMEMORY;
    CComVariant varTheme(pszThemePath);

    if (varTheme.bstrVal)
    {
        ITheme * pTheme;

        hr = pThemeManager->get_item(varTheme, &pTheme);
        if (SUCCEEDED(hr))
        {
            hr = pThemeManager->put_SelectedTheme(pTheme);
            pTheme->Release();
        }
    }

    return hr;
}


HRESULT InstallThemeAndDoNotStompBackground(int nLastVersion, LPCTSTR pszThemePath, LPCTSTR pszVisualStylePath, LPCTSTR pszVisualStyleColor, LPCTSTR pszVisualStyleSize)
{
    TCHAR szPath[MAX_PATH];
    WALLPAPEROPT wpo = {0};
    HRESULT hr = S_OK;

    wpo.dwSize = sizeof(wpo);
    wpo.dwStyle = WPSTYLE_STRETCH;      // We use stretch in case it fails.
    szPath[0] = 0;

    // This implements Whistler #185935.  We want to set the wallpaper to
    // "%windir%\web\wallpaper\Professional.bmp" if it's a clean install,
    // the wallpaper is blank, or it's set to something we don't like.
    {
        IActiveDesktop * pActiveDesktop = NULL;

        hr = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IActiveDesktop, &pActiveDesktop));
        if (SUCCEEDED(hr))
        {
            // Let's see if this is an upgrade case and they already specified wallpaper.
            hr = pActiveDesktop->GetWallpaper(szPath, ARRAYSIZE(szPath), 0);
            if (SUCCEEDED(hr) && szPath[0])
            {
                TCHAR szNone[MAX_PATH];

                LogStatus("InstallThemeAndDoNotStompBackground() Existing Background=%ls\r\n", szPath);
                if (LoadString(HINST_THISDLL, IDS_NONE, szNone, ARRAYSIZE(szNone)) &&
                    !StrCmpI(szNone, szPath))    // Make sure the wallpaper isn't "(None)".
                {
                    szPath[0] = 0;
                }
                else
                {
                    LPTSTR pszFilename = PathFindFileName(szPath);

                    if (LoadString(HINST_THISDLL, IDS_SETUP_BETA2_UPGRADEWALLPAPER, szNone, ARRAYSIZE(szNone)) &&
                        (3 == nLastVersion) &&
                        !StrCmpI(szNone, pszFilename))
                    {
                        // This is a "Beta2"->RTM upgrade.  We need to move from "Red Moon Desert.bmp" to "Bliss.bmp".
                        szPath[0] = 0;
                    }
                    else
                    {
                        if ((14 == lstrlen(pszFilename)) &&
                            !StrCmpNI(pszFilename, TEXT("Wallpaper"), 9))
                        {
                            // This is the "WallpaperX.bmp" template wallpaper we use.  So find the original.
                            TCHAR szOriginal[MAX_PATH];

                            if (SUCCEEDED(HrRegGetPath(HKEY_CURRENT_USER, SZ_REGKEY_CPDESKTOP, SZ_REGVALUE_CONVERTED_WALLPAPER, szOriginal, ARRAYSIZE(szOriginal))))
                            {
                                StrCpyN(szPath, szOriginal, ARRAYSIZE(szPath));
                            }
                        }

                        hr = pActiveDesktop->GetWallpaperOptions(&wpo, 0);
                    }
                }

                WCHAR szTemp[MAX_PATH];

                // The string may come back with environment variables.
                if (0 == SHExpandEnvironmentStrings(szPath, szTemp, ARRAYSIZE(szTemp)))
                {
                    StrCpyN(szTemp, szPath, ARRAYSIZE(szTemp));  // We failed so use the original.
                }

                StrCpyN(szPath, szTemp, ARRAYSIZE(szPath));  // We failed so use the original.
                LogStatus("InstallThemeAndDoNotStompBackground() Background=%ls\r\n", szPath);

                if (szPath[0])
                {
                    g_fDoNotInstallThemeWallpaper = TRUE;
                }
            }

            ATOMICRELEASE(pActiveDesktop);
        }

        // If the machine has 64MB or less, don't have setup add a wallpaper.  Wallpapers
        // use about 1.5MB of working set and cause super physical memory contention.
        if (!g_fDoNotInstallThemeWallpaper && (70 >= GetMachinePhysicalRAMSize()))
        {
            g_fDoNotInstallThemeWallpaper = TRUE;
        }
    }

    IThemeManager * pThemeManager;

    hr = CThemeManager_CreateInstance(NULL, IID_PPV_ARG(IThemeManager, &pThemeManager));
    if (SUCCEEDED(hr))
    {
        if (pszThemePath && pszThemePath[0])
        {
            LogStatus("InstallThemeAndDoNotStompBackground() Installing Theme=%ls\r\n", pszThemePath);
            hr = InstallTheme(pThemeManager, pszThemePath);
        }

        if (pszVisualStylePath && pszVisualStylePath[0])
        {
            // Otherwise, we install the visual style.
            LogStatus("InstallThemeAndDoNotStompBackground() VS=%ls, Color=%ls, Size=%ls.\r\n", pszVisualStylePath, pszVisualStyleColor, pszVisualStyleSize);
            hr = InstallVisualStyle(pThemeManager, pszVisualStylePath, pszVisualStyleColor, pszVisualStyleSize);
        }

        // This ApplyNow() call will take a little while in normal situation (~10-20 seconds) in order
        // to broadcast the message to all open apps.  If a top level window is hung, it may take the
        // full 30 seconds to timeout.
        hr = pThemeManager->ApplyNow();

        IUnknown_SetSite(pThemeManager, NULL); // Tell him to break the ref-count cycle with his children.
        ATOMICRELEASE(pThemeManager);

        // Now we put the wallpaper back
        if (szPath[0])
        {
            IActiveDesktop * pActiveDesktop2 = NULL;

            // I purposely do not use the same IActiveDesktop object as above.  I do not want them to think
            // this is a no-op because they have stale info.
            hr = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IActiveDesktop, &pActiveDesktop2));
            if (SUCCEEDED(hr))
            {
                // Oh no, we replaced their wallpaper.  Let's set it back to what they like.
                hr = pActiveDesktop2->SetWallpaper(szPath, 0);
                if (SUCCEEDED(hr))
                {
                    LogStatus("InstallThemeAndDoNotStompBackground() Reapplying Wallpaper=%ls.\r\n", szPath);
                    hr = pActiveDesktop2->SetWallpaperOptions(&wpo, 0);
                }

                pActiveDesktop2->ApplyChanges(AD_APPLY_ALL);
                pActiveDesktop2->Release();
            }
        }
    }

    LogStatus("InstallThemeAndDoNotStompBackground() returned hr=%#08lx.\r\n", hr);
    return hr;
}



/*****************************************************************************\
    DESCRIPTION:
        This function will put the defaults for "Visual Styles Off" and "Visual
    Styles on" so the Perf CPL can toggle back and forth.
\*****************************************************************************/
HRESULT SetupPerfDefaultsForUser(void)
{
    HRESULT hr = S_OK;
    TCHAR szThemePath[MAX_PATH];
    TCHAR szVisualStylePath[MAX_PATH];
    TCHAR szVisualStyleColor[MAX_PATH];
    TCHAR szVisualStyleSize[MAX_PATH];

    hr = HrRegGetPath(HKEY_LOCAL_MACHINE, SZ_THEMES, SZ_REGVALUE_INSTALLCUSTOM_THEME, szThemePath, ARRAYSIZE(szThemePath));
    if (FAILED(hr))
    {
        hr = HrRegGetPath(HKEY_LOCAL_MACHINE, SZ_THEMES, SZ_REGVALUE_INSTALL_THEME, szThemePath, ARRAYSIZE(szThemePath));
    }

    if (FAILED(hr) || !szThemePath[0])
    {
        StrCpyN(szThemePath, L"%ResourceDir%\\themes\\Windows Classic.theme", ARRAYSIZE(szThemePath));
    }

    switch (GetVisualStyleToSetup(FALSE))
    {
    case eThemeNoChange:
    case eThemeWindowsClassic:
        StrCpyN(szVisualStylePath, L"", ARRAYSIZE(szVisualStylePath));
        LoadString(HINST_THISDLL, IDS_DEFAULT_APPEARANCES_SCHEME, szVisualStyleColor, ARRAYSIZE(szVisualStyleColor));
        LoadString(HINST_THISDLL, IDS_SCHEME_SIZE_NORMAL_CANONICAL, szVisualStyleSize, ARRAYSIZE(szVisualStyleSize));
        break;
    case eThemeProfessional:
        StrCpyN(szVisualStylePath, L"%ResourceDir%\\themes\\Luna\\Luna.msstyles", ARRAYSIZE(szVisualStylePath));
        LoadString(HINST_THISDLL, IDS_PROMSTHEME_DEFAULTCOLOR, szVisualStyleColor, ARRAYSIZE(szVisualStyleColor));
        LoadString(HINST_THISDLL, IDS_PROMSTHEME_DEFAULTSIZE, szVisualStyleSize, ARRAYSIZE(szVisualStyleSize));
        break;
    case eThemeConsumer:
        StrCpyN(szVisualStylePath, L"%ResourceDir%\\themes\\Consumer\\Consumer.msstyles", ARRAYSIZE(szVisualStylePath));
        LoadString(HINST_THISDLL, IDS_CONMSTHEME_DEFAULTCOLOR, szVisualStyleColor, ARRAYSIZE(szVisualStyleColor));
        LoadString(HINST_THISDLL, IDS_CONMSTHEME_DEFAULTSIZE, szVisualStyleSize, ARRAYSIZE(szVisualStyleSize));
        break;
    }

    // Set the defaults
    hr = HrRegSetPath(HKEY_CURRENT_USER, SZ_THEMES, SZ_REGVALUE_INSTALL_THEME, TRUE, szThemePath);
    hr = HrRegSetPath(HKEY_CURRENT_USER, SZ_THEMES, SZ_REGVALUE_INSTALL_VISUALSTYLE, TRUE, szVisualStylePath);
    hr = HrRegSetValueString(HKEY_CURRENT_USER, SZ_THEMES, SZ_REGVALUE_INSTALL_VSCOLOR, szVisualStyleColor);
    hr = HrRegSetValueString(HKEY_CURRENT_USER, SZ_THEMES, SZ_REGVALUE_INSTALL_VSSIZE, szVisualStyleSize);

    // Set the defaults for the perf CPL to use if forced to "Visual Styles On"
#ifdef FEATURE_PERSONAL_SKIN_ENABLED
    if (IsOS(OS_PERSONAL))
    {
        StrCpyN(szThemePath, L"%ResourceDir%\\themes\\Personal.theme", ARRAYSIZE(szThemePath));
        StrCpyN(szVisualStylePath, L"%ResourceDir%\\themes\\Consumer\\Consumer.msstyles", ARRAYSIZE(szVisualStylePath));
        LoadString(HINST_THISDLL, IDS_CONMSTHEME_DEFAULTCOLOR, szVisualStyleColor, ARRAYSIZE(szVisualStyleColor));
        LoadString(HINST_THISDLL, IDS_CONMSTHEME_DEFAULTSIZE, szVisualStyleSize, ARRAYSIZE(szVisualStyleSize));
    }
    else
#endif // FEATURE_PERSONAL_SKIN_ENABLED
    {
        StrCpyN(szThemePath, L"%ResourceDir%\\themes\\Luna.theme", ARRAYSIZE(szThemePath));
        StrCpyN(szVisualStylePath, L"%ResourceDir%\\themes\\Luna\\Luna.msstyles", ARRAYSIZE(szVisualStylePath));
        LoadString(HINST_THISDLL, IDS_PROMSTHEME_DEFAULTCOLOR, szVisualStyleColor, ARRAYSIZE(szVisualStyleColor));
        LoadString(HINST_THISDLL, IDS_PROMSTHEME_DEFAULTSIZE, szVisualStyleSize, ARRAYSIZE(szVisualStyleSize));
    }
    hr = HrRegSetPath(HKEY_CURRENT_USER, SZ_REGKEY_THEME_DEFVSON, SZ_REGVALUE_INSTALL_VISUALSTYLE, TRUE, szVisualStylePath);
    hr = HrRegSetValueString(HKEY_CURRENT_USER, SZ_REGKEY_THEME_DEFVSON, SZ_REGVALUE_INSTALL_VSCOLOR, szVisualStyleColor);
    hr = HrRegSetValueString(HKEY_CURRENT_USER, SZ_REGKEY_THEME_DEFVSON, SZ_REGVALUE_INSTALL_VSSIZE, szVisualStyleSize);

    // Set the defaults for the perf CPL to use if forced to "Visual Styles Off"
    StrCpyN(szVisualStylePath, L"", ARRAYSIZE(szVisualStylePath));
    LoadString(HINST_THISDLL, IDS_DEFAULT_APPEARANCES_SCHEME, szVisualStyleColor, ARRAYSIZE(szVisualStyleColor));
    LoadString(HINST_THISDLL, IDS_SCHEME_SIZE_NORMAL_CANONICAL, szVisualStyleSize, ARRAYSIZE(szVisualStyleSize));
    hr = HrRegSetPath(HKEY_CURRENT_USER, SZ_REGKEY_THEME_DEFVSOFF, SZ_REGVALUE_INSTALL_VISUALSTYLE, TRUE, szVisualStylePath);
    hr = HrRegSetValueString(HKEY_CURRENT_USER, SZ_REGKEY_THEME_DEFVSOFF, SZ_REGVALUE_INSTALL_VSCOLOR, szVisualStyleColor);
    hr = HrRegSetValueString(HKEY_CURRENT_USER, SZ_REGKEY_THEME_DEFVSOFF, SZ_REGVALUE_INSTALL_VSSIZE, szVisualStyleSize);

    LogStatus("SetupPerfDefaultsForUser() sets:\r\n   Theme=%ls,\r\n   VisualStyle=%ls,\r\n   Color=%ls,\r\n   Size=%ls. returned hr=%#08lx.\r\n", szThemePath, szVisualStylePath, szVisualStyleColor, szVisualStyleSize, hr);
    return hr;
}


#define SZ_THEMESETUP_VERISON               L"1"

/*****************************************************************************\
    DESCRIPTION:
        This function will be called for each user when "theme setup" has not
    yet run for that user.  The machine setup will determine it's prefered
    Theme and VisualStyle.  This code needs to take additional information about
    the user (Accessibilities on?, Policy on?, etc.) into account before finally
    installing the Theme and/or VisualStyle.
\*****************************************************************************/
HRESULT SetupThemeForUser(void)
{
    HRESULT hr = S_OK;
    TCHAR szVersion[MAX_PATH];
    int nVersion;
    int nCurrentVersion = 0;

    if (SUCCEEDED(HrRegGetValueString(HKEY_CURRENT_USER, SZ_THEMES, REGVALUE_THEMESSETUPVER, szVersion, ARRAYSIZE(szVersion))))
    {
        StrToIntEx(szVersion, STIF_DEFAULT, &nCurrentVersion);
    }

    // If we succeeded, mark the registry that we don't need the user setup again.
    if (SUCCEEDED(HrRegGetValueString(HKEY_LOCAL_MACHINE, SZ_THEMES, REGVALUE_THEMESSETUPVER, szVersion, ARRAYSIZE(szVersion))) &&
        StrToIntEx(szVersion, STIF_DEFAULT, &nVersion))
    {
        if (nVersion > nCurrentVersion)
        {
            // We will skip this setup step for Clean boot.  We will get called back during
            // the next logon to do the work then.
            if (!ClassicGetSystemMetrics(SM_CLEANBOOT))
            {
                TCHAR szThemePath[MAX_PATH];
                TCHAR szVisualStylePath[MAX_PATH];
                TCHAR szVisualStyleColor[MAX_PATH];
                TCHAR szVisualStyleSize[MAX_PATH];
                DWORD dwType;
                DWORD cbSize = sizeof(szThemePath);

                szVisualStylePath[0] = szVisualStyleColor[0] = szVisualStyleSize[0] = szThemePath[0] = 0;

                SetupPerfDefaultsForUser();
                SHRegGetUSValue(SZ_REGKEY_POLICIES_SYSTEM, SZ_REGVALUE_POLICY_INSTALLTHEME, &dwType, (void *) szThemePath, &cbSize, FALSE, NULL, 0);

                // First check the policy that admins use to force users to always use a certain visual style.
                // Specifying an empty value will cause no visual style to be setup.
                cbSize = sizeof(szVisualStylePath);
                if (ERROR_SUCCESS != SHRegGetUSValue(SZ_REGKEY_POLICIES_SYSTEM, SZ_REGVALUE_POLICY_SETVISUALSTYLE, &dwType, (void *) szVisualStylePath, &cbSize, FALSE, NULL, 0))
                {
                    cbSize = sizeof(szVisualStylePath);

                    // That was not set, so check for the policy admins want to set the visual style for the first time.
                    if ((ERROR_SUCCESS != SHRegGetUSValue(SZ_REGKEY_POLICIES_SYSTEM, SZ_REGVALUE_POLICY_INSTALLVISUALSTYLE, &dwType, (void *) szVisualStylePath, &cbSize, FALSE, NULL, 0)))
                    {
                        if (!SHRegGetBoolUSValue(SZ_THEMES, SZ_REGVALUE_NO_THEMEINSTALL, FALSE, FALSE))
                        {
                            // If the user is Roaming, we don't setup themes or visual styles in order that their
                            // settings will successfully roam downlevel.
                            // We also do not modify user settings if their high contrast bit is set.  We do this so
                            // their system does not become unreadable.
                            if (!IsUserRoaming() && !IsUserHighContrastUser())
                            {
                                LogStatus("SetupThemeForUser() Not Roaming and Not HighContrast.\r\n");
                                hr = HrRegGetPath(HKEY_CURRENT_USER, SZ_THEMES, SZ_REGVALUE_INSTALL_THEME, szThemePath, ARRAYSIZE(szThemePath));
                                if (FAILED(hr))
                                {
                                   // That was not set, so see what the OS wants as a default.
                                    hr = HrRegGetPath(HKEY_CURRENT_USER, SZ_THEMES, SZ_REGVALUE_INSTALL_VISUALSTYLE, szVisualStylePath, ARRAYSIZE(szVisualStylePath));
                                    hr = HrRegGetPath(HKEY_CURRENT_USER, SZ_THEMES, SZ_REGVALUE_INSTALL_VSCOLOR, szVisualStyleColor, ARRAYSIZE(szVisualStyleColor));
                                    hr = HrRegGetPath(HKEY_CURRENT_USER, SZ_THEMES, SZ_REGVALUE_INSTALL_VSSIZE, szVisualStyleSize, ARRAYSIZE(szVisualStyleSize));
                                }
                            }
                            else
                            {
                                LogStatus("SetupThemeForUser() Roaming or HighContrast is on.\r\n");
                            }
                        }
                    }
                    else
                    {
                        // It's okay if these fail, we will use defaults
                        HrRegGetPath(HKEY_CURRENT_USER, SZ_REGKEY_POLICIES_SYSTEM, SZ_REGVALUE_INSTALL_VSCOLOR, szVisualStyleColor, ARRAYSIZE(szVisualStyleColor));
                        HrRegGetPath(HKEY_CURRENT_USER, SZ_REGKEY_POLICIES_SYSTEM, SZ_REGVALUE_INSTALL_VSSIZE, szVisualStyleSize, ARRAYSIZE(szVisualStyleSize));
                        LogStatus("SetupThemeForUser() SZ_REGVALUE_POLICY_INSTALLVISUALSTYLE policy set.\r\n");
                    }
                }
                else
                {
                    // Someone set the SetVisualStyle policy.  This means that we won't install anything.
                    szThemePath[0] = 0;
                    LogStatus("SetupThemeForUser() SZ_REGVALUE_POLICY_SETVISUALSTYLE policy set.\r\n");

                    if (szVisualStylePath[0] == L'\0') // If the policy is empty
                    {
                        // Install the default theme with no style
                        LogStatus("SetupThemeForUser() Installed Windows Standard as per the SETVISUALSTYLE policy.\r\n");

                        TCHAR szVisualStylePath[MAX_PATH];
                        TCHAR szVisualStyleColor[MAX_PATH];
                        TCHAR szVisualStyleSize[MAX_PATH];

                        StrCpyN(szVisualStylePath, L"", ARRAYSIZE(szVisualStylePath));
                        LoadString(HINST_THISDLL, IDS_DEFAULT_APPEARANCES_SCHEME, szVisualStyleColor, ARRAYSIZE(szVisualStyleColor));
                        LoadString(HINST_THISDLL, IDS_SCHEME_SIZE_NORMAL_CANONICAL, szVisualStyleSize, ARRAYSIZE(szVisualStyleSize));
                        WCHAR szCmdLine[MAX_PATH * 3];

                        StrCpyN(szCmdLine, SZ_INSTALL_VS, ARRAYSIZE(szCmdLine));
                        StrCatBuff(szCmdLine, szVisualStylePath, ARRAYSIZE(szCmdLine));
                        StrCatBuff(szCmdLine, L"','", ARRAYSIZE(szCmdLine));
                        StrCatBuff(szCmdLine, szVisualStyleColor, ARRAYSIZE(szCmdLine));
                        StrCatBuff(szCmdLine, L"','", ARRAYSIZE(szCmdLine));
                        StrCatBuff(szCmdLine, szVisualStyleSize, ARRAYSIZE(szCmdLine));
                        StrCatBuff(szCmdLine, L"'", ARRAYSIZE(szCmdLine));
                        InstallVS(szCmdLine);
                    }
                }
                ExpandResourceDir(szThemePath, ARRAYSIZE(szThemePath));
                ExpandResourceDir(szVisualStylePath, ARRAYSIZE(szVisualStylePath));

                // Specifying a Theme is specified, we install that.  In that case, the visual style comes from there.
                if (szThemePath[0] || szVisualStylePath[0])
                {
                    hr = InstallThemeAndDoNotStompBackground(nCurrentVersion, szThemePath, szVisualStylePath, szVisualStyleColor, szVisualStyleSize);
                }

                if (SUCCEEDED(hr))
                {
                    // If we succeeded, mark the registry that we don't need the user setup again.
                    hr = HrRegSetValueString(HKEY_CURRENT_USER, SZ_THEMES, REGVALUE_THEMESSETUPVER, szVersion);
                }
                LogStatus("SetupThemeForUser() sets:\r\n   Theme=%ls,\r\n   VisualStyle=%ls,\r\n   Color=%ls,\r\n   Size=%ls. returned hr=%#08lx.\r\n", szThemePath, szVisualStylePath, szVisualStyleColor, szVisualStyleSize, hr);
            }
        }
    }


    return hr;
}


HRESULT SetupThemeForMachine(void)
{
    HRESULT hr = S_OK;
    eThemeToSetup eTheme = GetThemeToSetup(FALSE);
    eThemeToSetup eVisualStyle = GetVisualStyleToSetup(FALSE);
    WCHAR szVisualStyleName[MAX_PATH];
    WCHAR szThemeName[MAX_PATH];
    WCHAR szTemp[MAX_PATH];

    switch (eTheme)
    {
    case eThemeNoChange:
        szThemeName[0] = 0;
        break;
    case eThemeWindowsClassic:
        StrCpyN(szThemeName, L"%ResourceDir%\\themes\\Windows Classic.theme", ARRAYSIZE(szThemeName));
        break;
    case eThemeProfessional:
        StrCpyN(szThemeName, L"%ResourceDir%\\themes\\Luna.theme", ARRAYSIZE(szThemeName));
        break;
    case eThemeConsumer:
        StrCpyN(szThemeName, L"%ResourceDir%\\themes\\Personal.theme", ARRAYSIZE(szThemeName));
        break;
    }

    if (SUCCEEDED(HrRegGetValueString(HKEY_LOCAL_MACHINE, SZ_THEMES, SZ_REGVALUE_INSTALLCUSTOM_THEME, szTemp, ARRAYSIZE(szTemp))) &&
        (!szTemp[0] || PathFileExists(szTemp)))
    {
        // The admin or OEM wanted this custom theme installed instead.
        StrCpyN(szThemeName, szTemp, ARRAYSIZE(szThemeName));
    }

    if (szThemeName[0])
    {
        DWORD cbSize = (sizeof(szThemeName[0]) * (lstrlen(szThemeName) + 1));
        SHSetValue(HKEY_LOCAL_MACHINE, SZ_THEMES, SZ_REGVALUE_INSTALL_THEME, REG_SZ, (LPCVOID) szThemeName, cbSize);
    }

    switch (eVisualStyle)
    {
    case eThemeNoChange:
        szVisualStyleName[0] = 0;
        break;
    case eThemeWindowsClassic:
        szVisualStyleName[0] = 0;
        break;
    case eThemeProfessional:
        StrCpyN(szVisualStyleName, L"%SystemRoot%\\Resources\\themes\\Luna\\Luna.msstyles", ARRAYSIZE(szVisualStyleName));
        break;
    case eThemeConsumer:
        StrCpyN(szVisualStyleName, L"%SystemRoot%\\Resources\\themes\\Personal\\Personal.msstyles", ARRAYSIZE(szVisualStyleName));
        break;
    }

    if (szVisualStyleName[0])
    {
        DWORD cbSize = (sizeof(szVisualStyleName[0]) * (lstrlen(szVisualStyleName) + 1));
        SHSetValue(HKEY_LOCAL_MACHINE, SZ_THEMES, SZ_REGVALUE_INSTALL_VISUALSTYLE, REG_SZ, (LPCVOID) szVisualStyleName, cbSize);

        ExpandResourceDir(szVisualStyleName, ARRAYSIZE(szVisualStyleName));
        hr = ExpandThemeTokens(NULL, szVisualStyleName, ARRAYSIZE(szVisualStyleName));      // Expand %ThemeDir% or %WinDir%
        hr = RegisterDefaultTheme(szVisualStyleName, TRUE);
    }

    LogStatus("SetupThemeForMachine() T=%ls, VS=%ls. returned hr=%#08lx.\r\n", szThemeName, szVisualStyleName, hr);
    return hr;
}

STDAPI DllRegisterServer(void)
{
    HRESULT hr;

    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    hr = CallRegInstall("DLL_RegInstall");

    //---- do this even if error occured ----
    MyRegTypeLib();
    if (hinstAdvPack)
        FreeLibrary(hinstAdvPack);

    return hr;
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    // UnInstall the registry values
    hr = CallRegInstall("DLL_RegUnInstall");
    UnregisterTypeLibrary(&LIBID_Theme);

    return hr;
}


HRESULT GetLanguageIDFromCmdLine(LPCWSTR pszCmdLine, LPWSTR pszLangID, DWORD cchSize)
{
    HRESULT hr = E_FAIL;

    if (pszCmdLine && pszCmdLine[0])
    {
        LPWSTR pszStart = StrStrIW(pszCmdLine, SZ_MUILANG_CMDLINEARG);

        if (pszStart)
        {
            pszStart += ARRAYSIZE(SZ_MUILANG_CMDLINEARG)-1;

            StrCpyN(pszLangID, pszStart, cchSize);

            LPWSTR pszEnd = StrStrIW(pszLangID, L" ");
            if (pszEnd)
            {
                pszEnd[0] = 0x00;
            }
            hr = S_OK;
        }
    }

    if (FAILED(hr))
    {
        LANGID nLangID = GetUserDefaultLangID();

        if (!nLangID)
        {
            nLangID = GetSystemDefaultLangID();
        }

        wnsprintf(pszLangID, cchSize, L"%04x", nLangID);
    }
    
    return S_OK;
}



HRESULT VSParseCmdLine(LPCWSTR pszCmdLine, LPWSTR pszPath, int cchPath, LPWSTR pszColor, int cchColor, LPWSTR pszSize, int cchSize)
{
    HRESULT hr = E_FAIL;

    pszPath[0] = pszColor[0] = pszSize[0] = 0;

    pszCmdLine = StrStrW(pszCmdLine, SZ_INSTALL_VS);
    pszCmdLine += (ARRAYSIZE(SZ_INSTALL_VS) - 1);
    
    LPWSTR pszEndOfVS = StrStrW(pszCmdLine, L"','");
    if (pszEndOfVS)
    {
        LPWSTR pszStartOfColor = (pszEndOfVS + 3);
        LPWSTR pszEndOfColor = StrStrW(pszStartOfColor, L"','");

        if (pszEndOfColor)
        {
            LPWSTR pszStartOfSize = (pszEndOfColor + 3);
            LPWSTR pszEndOfSize = StrStrW(pszStartOfSize, L"'");

            if (pszEndOfSize)
            {
                StrCpyN(pszPath, pszCmdLine, (int)min(cchPath, (pszEndOfVS - pszCmdLine + 1)));
                StrCpyN(pszColor, pszStartOfColor, (int)min(cchColor, (pszEndOfColor - pszStartOfColor + 1)));
                StrCpyN(pszSize, pszStartOfSize, (int)min(cchSize, (pszEndOfSize - pszStartOfSize + 1)));
                hr = S_OK;
            }
        }
    }

    return hr;
}


HRESULT InstallVS(LPCWSTR pszCmdLine)
{
    TCHAR szVisualStylePath[MAX_PATH];
    TCHAR szVisualStyleColor[MAX_PATH];
    TCHAR szVisualStyleSize[MAX_PATH];
    HRESULT hr = VSParseCmdLine(pszCmdLine, szVisualStylePath, ARRAYSIZE(szVisualStylePath), szVisualStyleColor, ARRAYSIZE(szVisualStyleColor), szVisualStyleSize, ARRAYSIZE(szVisualStyleSize));

    if (SUCCEEDED(hr))
    {
        IThemeManager * pThemeManager;

        hr = CThemeManager_CreateInstance(NULL, IID_PPV_ARG(IThemeManager, &pThemeManager));
        if (SUCCEEDED(hr))
        {
            // Otherwise, we install the visual style.
            LogStatus("InstallVS() VS=%ls, Color=%ls, Size=%ls.\r\n", szVisualStylePath, szVisualStyleColor, szVisualStyleSize);
            hr = InstallVisualStyle(pThemeManager, szVisualStylePath, szVisualStyleColor, szVisualStyleSize);

            if (SUCCEEDED(hr))
            {
                // This ApplyNow() call will take a little while in normal situation (~10-20 seconds) in order
                // to broadcast the message to all open apps.  If a top level window is hung, it may take the
                // full 30 seconds to timeout.
                hr = pThemeManager->ApplyNow();
            }

            IUnknown_SetSite(pThemeManager, NULL); // Tell him to break the ref-count cycle with his children.
            pThemeManager->Release();
        }
    }

    return hr;
}


void HandleBeta2Upgrade(void)
{
    TCHAR szPath[MAX_PATH];
    TCHAR szTemp[MAX_PATH];

    SHExpandEnvironmentStringsW(L"%SystemRoot%\\web\\wallpaper\\", szPath, ARRAYSIZE(szPath));
    LoadString(HINST_THISDLL, IDS_SETUP_BETA2_UPGRADEWALLPAPER, szTemp, ARRAYSIZE(szTemp));
    PathAppend(szPath, szTemp);

    if (PathFileExists(szPath))
    {
        // We no longer use "Red Moon Desert.bmp", now the default is "Bliss.bmp".
        DeleteFile(szPath);
    }
}


/*****************************************************************************\
    DESCRIPTION:
        This function will be called in the following situations:
    1. GUI Mode Setup:  In this case the cmdline is "regsvr32.exe /i themeui.dll".
            In that case, we install the machine settings.
    2. Per User Login: ActiveSetup will call us with "regsvr32.exe /n /i:/UserInstall themeui.dll"
            per user and only once.
    3. External Callers to Set Visual Style: External Callers will call us with:
            "regsvr32.exe /n /i:"/InstallVS:'<VisualStyle>','<ColorScheme>','<Size>'" themeui.dll"
            This will install that visual style.  <VisualStyle> can be an empty string
            to install "Windows Classic".

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

STDAPI DllInstall(BOOL fInstall, LPCWSTR pszCmdLine)
{
    HRESULT hr = S_OK;
    BOOL fUserSetup = (pszCmdLine && StrStrW(pszCmdLine, SZ_USER_INSTALL) ? TRUE : FALSE);
    BOOL fInstallVS = (pszCmdLine && StrStrW(pszCmdLine, SZ_INSTALL_VS) ? TRUE : FALSE);

    g_fInSetup = TRUE;
    if (fUserSetup)
    {
        if (fInstall)
        {
            hr = CoInitialize(0);
            if (SUCCEEDED(hr))
            {
                hr = SetupThemeForUser();
                CoUninitialize();
            }
        }
    }
    else if (fInstallVS)
    {
        if (fInstall)
        {
            hr = CoInitialize(0);
            if (SUCCEEDED(hr))
            {
                hr = InstallVS(pszCmdLine);
                CoUninitialize();
            }
        }
    }
    else
    {
        if (fInstall)
        {
            // Ignore errors from theme manager here
            SetupThemeForMachine();
            HandleBeta2Upgrade();
        }
    }
    g_fInSetup = FALSE;

    LogStatus("DllInstall(%hs, \"%ls\") returned hr=%#08lx.\r\n", (fInstall ? "TRUE" : "FALSE"), (pszCmdLine ? pszCmdLine : L""), hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\effectsadvpg.cpp ===
/*****************************************************************************\
    FILE: EffectsAdvPg.cpp

    DESCRIPTION:
        This code will display the Effect tab in the Advanced Display Control
    panel.

    BryanSt 4/13/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "EffectsAdvPg.h"
#include "regutil.h"

//#undef _SHSEMIP_H_
//#include <shsemip.h>



typedef struct
{
    DWORD dwControlID;
    DWORD dwHelpContextID;
}POPUP_HELP_ARRAY;

POPUP_HELP_ARRAY phaMainDisplay[] = {
   { IDC_LARGEICONS,         IDH_DISPLAY_EFFECTS_LARGE_ICONS_CHECKBOX },
   { IDC_ICONHIGHCOLOR,      IDH_DISPLAY_EFFECTS_ALL_COLORS_CHECKBOX  },
   { IDC_MENUANIMATION,      IDH_DISPLAY_EFFECTS_ANIMATE_WINDOWS },
   { IDC_FONTSMOOTH,         IDH_DISPLAY_EFFECTS_SMOOTH_FONTS_CHECKBOX },
   { IDC_SHOWDRAG,           IDH_DISPLAY_EFFECTS_DRAG_WINDOW_CHECKBOX },
   { IDC_KEYBOARDINDICATORS, IDH_DISPLAY_EFFECTS_HIDE_KEYBOARD_INDICATORS },
   { IDC_GRPBOX_2,           IDH_COMM_GROUPBOX                 },
   { IDC_COMBOEFFECT,        IDH_DISPLAY_EFFECTS_ANIMATE_LISTBOX },
   { IDC_COMBOFSMOOTH,       IDH_DISPLAY_EFFECTS_SMOOTH_FONTS_LISTBOX },
   { IDC_MENUSHADOWS,        IDH_DISPLAY_EFFECTS_MENUSHADOWS},
   { 0, 0 },
   { 0, 0 },          // double-null terminator NECESSARY!
};

#define SZ_HELPFILE_DISPLAY             TEXT("DISPLAY.HLP")
#define SZ_HELPFILE_WINDOWS             TEXT("WINDOWS.HLP")

ULONG   g_ulFontInformation, g_ulNewFontInformation;






//===========================
// *** Class Internals & Helpers ***
//===========================
int FontSmoothingTypeToListIndex(DWORD dwFontSmoothingType)
{
    // We OR dwSmoothingType with 0x3 because USER may add other high bits that we don't care about.
    return ((0x3 & dwFontSmoothingType) - 1);
}


DWORD ListIndexToFontSmoothingType(int nIndex, DWORD dwPreviousType)
{
    // We want to keep the high bits in dwPreviousType because we are only replacing
    // the lower bits.
    return ((0xFFFFFFF0 & dwPreviousType) | (nIndex + 1));
}


void HideComboEffectsWindow(HWND hDlg)
{
    TCHAR szText[MAX_PATH];

    // We change the text so it doesn't have a reference to the drop down.
    LoadString(HINST_THISDLL, IDS_COMBO_EFFECTS_NOLIST, szText, ARRAYSIZE(szText));
    SetWindowText(GetDlgItem(hDlg, IDC_MENUANIMATION), szText);
    ShowWindow(GetDlgItem(hDlg, IDC_COMBOEFFECT), SW_HIDE);
}


BOOL FadeEffectAvailable()
{
    BOOL fFade = FALSE, fTestFade = FALSE;
    
    ClassicSystemParametersInfo( SPI_GETMENUFADE, 0, (PVOID)&fFade, 0 );
    if (fFade) 
        return TRUE;

    ClassicSystemParametersInfo( SPI_SETMENUFADE, 0, (PVOID)1, 0);
    ClassicSystemParametersInfo( SPI_GETMENUFADE, 0, (PVOID)&fTestFade, 0 );
    ClassicSystemParametersInfo( SPI_SETMENUFADE, 0, IntToPtr(fFade), 0);

    return (fTestFade);
}


HRESULT CEffectsPage::_OnApply(HWND hDlg)
{
    HRESULT hr = S_OK;

    // Full Color Icons
    if (m_pEffectsState && (m_pEffectsState->_nOldHighIconColor != m_pEffectsState->_nHighIconColor))
    {
        if ((GetBitsPerPixel() < 16) && (m_pEffectsState->_nHighIconColor == 16)) // Display mode won't support icon high colors
        {
            TCHAR szTemp1[512];
            TCHAR szTemp2[256];

            LoadString(HINST_THISDLL, IDS_256COLORPROBLEM, szTemp1, ARRAYSIZE(szTemp1));
            LoadString(HINST_THISDLL, IDS_ICONCOLORWONTWORK, szTemp2, ARRAYSIZE(szTemp2));
            StrCatBuff(szTemp1, szTemp2, ARRAYSIZE(szTemp1));
            LoadString(HINST_THISDLL, IDS_EFFECTS, szTemp2, ARRAYSIZE(szTemp2));

            MessageBox(hDlg, szTemp1, szTemp2, MB_OK|MB_ICONINFORMATION);
        }
    }

    return hr;
}


HRESULT CEffectsPage::_OnInit(HWND hDlg)
{
    HRESULT hr = S_OK;
    TCHAR szRes[100];

    if (!m_pEffectsState)
    {
        return E_INVALIDARG;
    }

    //////////////////////////////////////////////////////////////////////////
    // Load the state from persisted form (registry) to the state struct
    //////////////////////////////////////////////////////////////////////////
    g_bMirroredOS = IS_MIRRORING_ENABLED();

    //////////////////////////////////////////////////////////////////////////
    // Update UI based on the state struct
    //////////////////////////////////////////////////////////////////////////
    if (m_pEffectsState->_nLargeIcon == ICON_INDETERMINATE)
    {
        HWND hItem = GetDlgItem(hDlg, IDC_LARGEICONS);
        SendMessage(hItem, BM_SETSTYLE, (WPARAM)LOWORD(BS_AUTO3STATE), MAKELPARAM(FALSE,0));
    }

    // Set CheckBoxes
    SendMessage((HWND)GetDlgItem(hDlg, IDC_LARGEICONS), BM_SETCHECK, (WPARAM)m_pEffectsState->_nLargeIcon, 0);
    SendMessage((HWND)GetDlgItem(hDlg, IDC_MENUSHADOWS), BM_SETCHECK, (WPARAM)m_pEffectsState->_fMenuShadows, 0);
    SendMessage((HWND)GetDlgItem(hDlg, IDC_ICONHIGHCOLOR ), BM_SETCHECK, (WPARAM)(BOOL)(m_pEffectsState->_nHighIconColor == 16), 0);
    SendMessage((HWND)GetDlgItem(hDlg, IDC_MENUANIMATION), BM_SETCHECK, (WPARAM)m_pEffectsState->_wpMenuAnimation, 0);
    SendMessage((HWND)GetDlgItem(hDlg, IDC_FONTSMOOTH), BM_SETCHECK, (WPARAM)m_pEffectsState->_fFontSmoothing, 0);
    SendMessage((HWND)GetDlgItem(hDlg, IDC_SHOWDRAG), BM_SETCHECK, (WPARAM)m_pEffectsState->_fDragWindow, 0);
    SendMessage((HWND)GetDlgItem(hDlg, IDC_KEYBOARDINDICATORS), BM_SETCHECK, (WPARAM)(m_pEffectsState->_fKeyboardIndicators ? BST_UNCHECKED : BST_CHECKED), 0);


    // Set Effects Drop Down
    HWND hwndCombo = GetDlgItem(hDlg,IDC_COMBOEFFECT);
    ComboBox_ResetContent(hwndCombo);
    LoadString(HINST_THISDLL, IDS_FADEEFFECT, szRes, ARRAYSIZE(szRes) );
    ComboBox_AddString(hwndCombo, szRes);
    LoadString(HINST_THISDLL, IDS_SCROLLEFFECT, szRes, ARRAYSIZE(szRes) );
    ComboBox_AddString(hwndCombo, szRes);
    ComboBox_SetCurSel(hwndCombo, (MENU_EFFECT_FADE == m_pEffectsState->_dwAnimationEffect) ? 0 : 1);
    EnableWindow(hwndCombo, (UINT)m_pEffectsState->_wpMenuAnimation);

    if (IsTSPerfFlagEnabled(TSPerFlag_NoAnimation))
    {
        EnableWindow(GetDlgItem(hDlg, IDC_MENUANIMATION), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_COMBOEFFECT), FALSE);
        LogStatus("Animation Forced off because of TS Perf Flags\r\n");
    }

    if (IsTSPerfFlagEnabled(TSPerFlag_NoWindowDrag))
    {
        EnableWindow(GetDlgItem(hDlg, IDC_SHOWDRAG), FALSE);
        LogStatus("FullWindowDrag feature Forced off because of TS Perf Flags\r\n");
    }

    if (!FadeEffectAvailable()) 
    {
        HideComboEffectsWindow(hDlg);
    }

    if (0 != SHGetRestriction(NULL,POLICY_KEY_EXPLORER,POLICY_VALUE_ANIMATION))
    {
        //disable
        //0=     enable
        //non-0= disable
        //relies on the fact that if the key does not exist it returns 0 as well
        EnableWindow((HWND)GetDlgItem(hDlg, IDC_MENUANIMATION), FALSE);
        EnableWindow((HWND)GetDlgItem(hDlg, IDC_COMBOEFFECT), FALSE);
    }

    hwndCombo = GetDlgItem(hDlg,IDC_COMBOFSMOOTH); 
    ComboBox_ResetContent(hwndCombo);
    LoadString(HINST_THISDLL, IDS_STANDARDSMOOTHING, szRes, ARRAYSIZE(szRes));
    ComboBox_AddString(hwndCombo, szRes);
    LoadString(HINST_THISDLL, IDS_CLEARTYPE, szRes, ARRAYSIZE(szRes));
    ComboBox_AddString(hwndCombo, szRes);

    BOOL fTemp;
    ComboBox_SetCurSel(hwndCombo, m_pEffectsState->_dwFontSmoothingType-1);
    if (ClassicSystemParametersInfo(SPI_GETFONTSMOOTHINGTYPE, 0, (PVOID)&fTemp, 0)) 
    {
        EnableWindow((HWND)hwndCombo, m_pEffectsState->_fFontSmoothing);
    }
    else
    {
        ShowWindow(hwndCombo, SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_SHOWME), SW_HIDE);
    }


    if (0 != SHGetRestriction(NULL, POLICY_KEY_EXPLORER, POLICY_VALUE_KEYBOARDNAV))
    {
        //disable, see comment for animation
        EnableWindow((HWND)GetDlgItem(hDlg, IDC_KEYBOARDINDICATORS), FALSE);
    }

    //disable and uncheck things if we are on terminal server
    BOOL bEffectsEnabled;
    if (!ClassicSystemParametersInfo(SPI_GETUIEFFECTS, 0, (PVOID) &bEffectsEnabled, 0))
    {
        // This flag is only available on Win2k and later. We're depending
        // on the call returning false if the flag doesn't exist...
        bEffectsEnabled = TRUE;
    }

    if (!bEffectsEnabled)
    {
        EnableWindow((HWND)GetDlgItem( hDlg, IDC_MENUANIMATION), FALSE);
        EnableWindow((HWND)GetDlgItem(hDlg, IDC_ICONHIGHCOLOR), FALSE);
        EnableWindow((HWND)GetDlgItem(hDlg, IDC_KEYBOARDINDICATORS), FALSE);
        EnableWindow((HWND)GetDlgItem(hDlg, IDC_FONTSMOOTH), FALSE);
        EnableWindow((HWND)GetDlgItem(hDlg, IDC_COMBOFSMOOTH), FALSE);

        HideComboEffectsWindow(hDlg);
        SendDlgItemMessage(hDlg, IDC_MENUANIMATION, BM_SETCHECK, 0, 0);
        SendDlgItemMessage(hDlg, IDC_ICONHIGHCOLOR, BM_SETCHECK, 0, 0);
        SendDlgItemMessage(hDlg, IDC_KEYBOARDINDICATORS, BM_SETCHECK, 0, 0);
        SendDlgItemMessage(hDlg, IDC_FONTSMOOTH, BM_SETCHECK, 0, 0);
    }

    // We remove the Keyboard indicators check box on non-NT platform since User32
    // does not provide the functionality to implement the feature.
    if (!IsOSNT())
    {
        HWND hwndSWC = GetDlgItem(hDlg, IDC_SHOWDRAG);
        HWND hwndKI = GetDlgItem(hDlg, IDC_KEYBOARDINDICATORS);
        HWND hwndGroup = GetDlgItem(hDlg, IDC_GRPBOX_2);

        // Hide the Hide keyboard cues check box on non-NT platform
        ShowWindow(hwndKI, SW_HIDE);

        // Calculate the bottom margin
        RECT rect;
        RECT rectGroup;
        GetWindowRect(hwndKI, &rect);
        GetWindowRect(hwndGroup, &rectGroup);
        int margin = rectGroup.bottom - rect.bottom;

        GetWindowRect(hwndSWC, &rect);
        SetWindowPos(hwndGroup, HWND_TOP, 0, 0, rectGroup.right - rectGroup.left,
            rect.bottom - rectGroup.top + margin, SWP_NOMOVE | SWP_NOZORDER);
    }

    return hr;
}


INT_PTR CEffectsPage::_OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = 1;   // Not handled (WM_COMMAND seems to be different)
    WORD idCtrl = GET_WM_COMMAND_ID(wParam, lParam);
    WORD wEvent = GET_WM_COMMAND_CMD(wParam, lParam);

    switch (idCtrl)
    {
    case IDOK:
        EndDialog(hDlg, IDOK);
        break;

    case IDCANCEL:
        EndDialog(hDlg, IDCANCEL);
        break;

    case IDC_LARGEICONS:
        if (m_pEffectsState)
        {
            m_pEffectsState->_nLargeIcon  = (int)SendMessage ( (HWND)lParam, BM_GETCHECK, 0, 0 );
        }
        break;

    case IDC_MENUSHADOWS:
        if (m_pEffectsState)
        {
            m_pEffectsState->_fMenuShadows  = (int)SendMessage ( (HWND)lParam, BM_GETCHECK, 0, 0 );
        }
        break;

    case IDC_ICONHIGHCOLOR:
        if (m_pEffectsState)
        {
            m_pEffectsState->_nHighIconColor = 4;
            if (SendMessage((HWND)lParam, BM_GETCHECK, 0, 0) == TRUE)
            {
                m_pEffectsState->_nHighIconColor = 16;
            }
        }
        break;

    case IDC_SHOWDRAG:
        if (m_pEffectsState)
        {
            m_pEffectsState->_fDragWindow = (SendMessage( (HWND)lParam, BM_GETCHECK, 0, 0 ) == BST_CHECKED);
        }
        break;

    case IDC_MENUANIMATION:
        if (m_pEffectsState)
        {
            switch (m_pEffectsState->_wpMenuAnimation)
            {
            case BST_UNCHECKED:
                m_pEffectsState->_wpMenuAnimation = BST_CHECKED;
                break;

            case BST_CHECKED:
                m_pEffectsState->_wpMenuAnimation = BST_UNCHECKED;
                break;

            case BST_INDETERMINATE:
                m_pEffectsState->_wpMenuAnimation = BST_UNCHECKED;
                break;
            }
            SendMessage( (HWND)lParam, BM_SETCHECK, (WPARAM)m_pEffectsState->_wpMenuAnimation, 0 );
            EnableWindow((HWND)GetDlgItem( hDlg, IDC_COMBOEFFECT), (BST_CHECKED == m_pEffectsState->_wpMenuAnimation));
        }
        break;

    case IDC_COMBOEFFECT:
        if ((wEvent == CBN_SELCHANGE) && m_pEffectsState)
        {
            m_pEffectsState->_dwAnimationEffect = (DWORD)ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_COMBOEFFECT)) + 1;
        }
        break;

    case IDC_COMBOFSMOOTH:
        if ((wEvent == CBN_SELCHANGE) && m_pEffectsState)
        {
            m_pEffectsState->_dwFontSmoothingType = ListIndexToFontSmoothingType(ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_COMBOFSMOOTH)), m_pEffectsState->_dwFontSmoothingType);
        }
        break;

    case IDC_FONTSMOOTH:
        if (m_pEffectsState)
        {
            m_pEffectsState->_fFontSmoothing = (SendMessage( (HWND)lParam, BM_GETCHECK, 0, 0 ) == BST_CHECKED);
            EnableWindow((HWND)GetDlgItem( hDlg, IDC_COMBOFSMOOTH), m_pEffectsState->_fFontSmoothing);
            if (m_pEffectsState->_fFontSmoothing)
            {
                m_pEffectsState->_dwFontSmoothingType = ListIndexToFontSmoothingType(ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_COMBOFSMOOTH)), m_pEffectsState->_dwFontSmoothingType);
            }
        }
        break;

    case IDC_KEYBOARDINDICATORS:
        if (m_pEffectsState)
        {
            m_pEffectsState->_fKeyboardIndicators = ((SendMessage((HWND)lParam, BM_GETCHECK, 0, 0) == BST_CHECKED) ? FALSE : TRUE);
        }
        break;

    default:
        break;
    }

    return fHandled;
}


INT_PTR CALLBACK PropertySheetDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CEffectsPage * pThis = (CEffectsPage *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        pThis = (CEffectsPage *) lParam;

        if (pThis)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        }
    }

    if (pThis)
        return pThis->_PropertySheetDlgProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}


//---------------------------------------------------------------------------
//
// PropertySheetDlgProc()
//
//  The dialog procedure for the "PlusPack" property sheet page.
//
//---------------------------------------------------------------------------
INT_PTR CEffectsPage::_PropertySheetDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    switch( uMessage )
    {
    case WM_INITDIALOG:
        _OnInit(hDlg);
    break;

    case WM_COMMAND:
        _OnCommand(hDlg, uMessage, wParam, lParam);
        break;

    case WM_HELP:
    {
        LPHELPINFO lphi = (LPHELPINFO)lParam;

        if( lphi->iContextType == HELPINFO_WINDOW )
        {
            LPCWSTR pszHelpFile = ((lphi->hItemHandle == GetDlgItem(hDlg, IDC_GRPBOX_2)) ? SZ_HELPFILE_WINDOWS : SZ_HELPFILE_DISPLAY);
            WinHelp( (HWND)lphi->hItemHandle, pszHelpFile, HELP_WM_HELP, (DWORD_PTR)phaMainDisplay);
        }
    }
        break;

    case WM_CONTEXTMENU:
        // first check for dlg window
        if( (HWND)wParam == hDlg )
        {
            // let the def dlg proc decide whether to respond or ignore;
            // necessary for title bar sys menu on right click
            return FALSE;       // didn't process message EXIT
        }
        else
        {
            // else go for the controls
            LPCWSTR pszHelpFile = (((HWND)wParam == GetDlgItem(hDlg, IDC_GRPBOX_2)) ? SZ_HELPFILE_WINDOWS : SZ_HELPFILE_DISPLAY);
            WinHelp( (HWND)wParam, pszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)phaMainDisplay);
        }
        break;

    default:
        return FALSE;
    }
    return(TRUE);
}


HRESULT CEffectsPage::_IsDirty(IN BOOL * pIsDirty)
{
    HRESULT hr = E_INVALIDARG;

    if (pIsDirty && m_pEffectsState)
    {
        // Ask state if it's dirty
        *pIsDirty = m_pEffectsState->IsDirty();
        hr = S_OK;
    }

    return hr;
}





//===========================
// *** IAdvancedDialog Interface ***
//===========================
HRESULT CEffectsPage::DisplayAdvancedDialog(IN HWND hwndParent, IN IPropertyBag * pBasePage, IN BOOL * pfEnableApply)
{
    HRESULT hr = E_INVALIDARG;

    if (hwndParent && pBasePage && pfEnableApply)
    {
        // Load State Into Advanced Dialog 
        if (m_pEffectsState)
        {
            m_pEffectsState->Release();
            m_pEffectsState = NULL;
        }

        *pfEnableApply = FALSE;
        CEffectState * pEffectClone = NULL;

        hr = SHPropertyBag_ReadByRef(pBasePage, SZ_PBPROP_EFFECTSSTATE, (void *)&pEffectClone, sizeof(pEffectClone));
        if (SUCCEEDED(hr) && pEffectClone)
        {
            // We want a copy of their state
            hr = pEffectClone->Clone(&m_pEffectsState);
            if (SUCCEEDED(hr))
            {
                LinkWindow_RegisterClass();

                // Display Advanced Dialog
                if ((IDOK == DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_EFFECTS), hwndParent, PropertySheetDlgProc, (LPARAM)this)) && m_pEffectsState)
                {
                    // The user clicked OK, so merge modified state back into base dialog
                    _IsDirty(pfEnableApply);

                    // The user clicked Okay in the dialog so merge the dirty state from the
                    // advanced dialog into the base dialog.
                    hr = SHPropertyBag_WriteByRef(pBasePage, SZ_PBPROP_EFFECTSSTATE, (void *)m_pEffectsState);
                    m_pEffectsState->Release();
                    m_pEffectsState = NULL;
                }
            }

            LinkWindow_UnregisterClass(HINST_THISDLL);
            pEffectClone->Release();
        }
    }

    return hr;
}





//===========================
// *** IUnknown Interface ***
//===========================
ULONG CEffectsPage::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CEffectsPage::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CEffectsPage::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CEffectsPage, IObjectWithSite),
        QITABENT(CEffectsPage, IAdvancedDialog),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}




//===========================
// *** Class Methods ***
//===========================
CEffectsPage::CEffectsPage() : m_cRef(1)
{
    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    m_fDirty = FALSE;
}


CEffectsPage::~CEffectsPage()
{
    if (m_pEffectsState)
    {
        m_pEffectsState->Release();
    }
}


HRESULT CEffectsPage_CreateInstance(OUT IAdvancedDialog ** ppAdvDialog)
{
    HRESULT hr = E_INVALIDARG;

    if (ppAdvDialog)
    {
        CEffectsPage * pThis = new CEffectsPage();

        if (pThis)
        {
            hr = pThis->QueryInterface(IID_PPV_ARG(IAdvancedDialog, ppAdvDialog));
            pThis->Release();
        }
        else
        {
            *ppAdvDialog = NULL;
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\effectsbasepg.cpp ===
/*****************************************************************************\
    FILE: EffectsBasePg.cpp

    DESCRIPTION:
        This code will be the base object that won't add any pages to the base
    "Display Properties" dialog.  However, it will request a "Effects" page be
    added to the Advanced.

    BryanSt 4/13/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.

\*****************************************************************************/
#include "priv.h"
#include <shlwapip.h>
#include <shlguidp.h>
#include <shsemip.h>
#pragma hdrstop

#include "EffectsBasePg.h"
#include "EffectsAdvPg.h"
#include <cfgmgr32.h>           // For MAX_GUID_STRING_LEN

//============================================================================================================
// *** Globals ***
//============================================================================================================

//===========================
// *** Class Internals & Helpers ***
//===========================
HRESULT CEffectsBasePage::_InitState(void)
{
    HRESULT hr = S_OK;

    if (!m_pEffectsState)
    {
        m_pEffectsState = new CEffectState();
        if (m_pEffectsState)
        {
            m_pEffectsState->Load();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT CEffectsBasePage::_SaveState(CEffectState * pEffectsState)
{
    HRESULT hr = E_INVALIDARG;

    if (pEffectsState)
    {
        if (m_pEffectsState)
        {
            m_pEffectsState->Release();
        }

        m_pEffectsState = pEffectsState;
        pEffectsState->AddRef();
        hr = S_OK;
    }

    return hr;
}




//===========================
// *** IBasePropPage Interface ***
//===========================
HRESULT CEffectsBasePage::Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        if (!StrCmpW(SZ_PBPROP_EFFECTSSTATE, pszPropName) && m_pEffectsState)
        {
            pVar->vt = VT_BYREF;
            pVar->byref = (void *)&m_pEffectsState;
            
            if (m_pEffectsState)
            {
                m_pEffectsState->AddRef();
            }

            hr = S_OK;
        }
    }

    return hr;
}


HRESULT CEffectsBasePage::Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        if (VT_BYREF == pVar->vt)
        {
            // The caller is passing us a (CEffectState *) object to save.
            if (!StrCmpW(SZ_PBPROP_EFFECTSSTATE, pszPropName))
            {
                hr = _SaveState((CEffectState *) pVar->byref);
            }
        }
        else if (VT_BOOL == pVar->vt)
        {
            // The caller is passing us a (CEffectState *) object to save.
            if (!StrCmpW(SZ_PBPROP_EFFECTS_MENUDROPSHADOWS, pszPropName))
            {
                hr = _InitState();
                if (SUCCEEDED(hr) && m_pEffectsState)
                {
                    m_pEffectsState->_fMenuShadows = (VARIANT_TRUE == pVar->boolVal);
                }
            }
        }
    }

    return hr;
}





//===========================
// *** IBasePropPage Interface ***
//===========================
HRESULT CEffectsBasePage::GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog)
{
    HRESULT hr = E_INVALIDARG;

    if (ppAdvDialog)
    {
        *ppAdvDialog = NULL;
        hr = _InitState();

        if (SUCCEEDED(hr))
        {
            hr = CEffectsPage_CreateInstance(ppAdvDialog);
        }
    }

    return hr;
}


HRESULT CEffectsBasePage::OnApply(IN PROPPAGEONAPPLY oaAction)
{
    HRESULT hr = S_OK;

    if ((PPOAACTION_CANCEL != oaAction) && m_pEffectsState)
    {
        hr = m_pEffectsState->Save();

        // Make sure we reload the state next time we open the dialog.
        m_pEffectsState->Release();
        m_pEffectsState = NULL;
    }

    return hr;
}



//===========================
// *** IShellPropSheetExt Interface ***
//===========================
HRESULT CEffectsBasePage::AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam)
{
    // We don't want to add any pages to the base dialog since we moved the
    // "Effects" tab to the Advanced dlg.
    return S_OK;
}



//===========================
// *** IUnknown Interface ***
//===========================
ULONG CEffectsBasePage::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CEffectsBasePage::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CEffectsBasePage::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CEffectsBasePage, IBasePropPage),
        QITABENT(CEffectsBasePage, IPropertyBag),
        QITABENT(CEffectsBasePage, IPersist),
        QITABENT(CEffectsBasePage, IObjectWithSite),
        QITABENTMULTI(CEffectsBasePage, IShellPropSheetExt, IBasePropPage),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CEffectsBasePage::CEffectsBasePage() : CObjectCLSID(&PPID_Effects), m_cRef(1)
{
    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    m_fDirty = FALSE;
}


CEffectsBasePage::~CEffectsBasePage()
{
}



HRESULT CEffectsBasePage_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj)
{
    HRESULT hr = E_INVALIDARG;

    if (!punkOuter && ppvObj)
    {
        CEffectsBasePage * pThis = new CEffectsBasePage();

        *ppvObj = NULL;
        if (pThis)
        {
            hr = pThis->QueryInterface(riid, ppvObj);
            pThis->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\effectsadvpg.h ===
/*****************************************************************************\
    FILE: EffectsAdvPg.h

    DESCRIPTION:
        This code will display the Effect tab in the Advanced Display Control
    panel.

    BryanSt 4/13/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _EFFECTSADVPG_H
#define _EFFECTSADVPG_H

#include "store.h"
#include <cowsite.h>            // for CObjectWithSite
#include <shpriv.h>

class CEffectsPage;

#include "EffectsBasePg.h"

static const GUID IID_CEffectsPage_THIS = { 0xef2b6246, 0x6c1b, 0x44fd, { 0x87, 0xea, 0xb3, 0xc5, 0xd, 0x47, 0x8b, 0x8e } };// {EF2B6246-6C1B-44fd-87EA-B3C50D478B8E}



#define PROPSHEET_CLASS             CEffectsBasePage
class CPropSheetExt;

HRESULT CEffectsPage_CreateInstance(OUT IAdvancedDialog ** ppAdvDialog);


class CEffectsPage              : public CObjectWithSite
                                , public IAdvancedDialog
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IAdvancedDialog ***
    virtual STDMETHODIMP DisplayAdvancedDialog(IN HWND hwndParent, IN IPropertyBag * pBasePage, IN BOOL * pfEnableApply);


private:
    CEffectsPage(void);
    virtual ~CEffectsPage(void);

    // Private Member Variables
    long                    m_cRef;
    BOOL                    m_fDirty;
    CEffectState *          m_pEffectsState;

    // Private Member Functions
    HRESULT _OnInit(HWND hDlg);
    HRESULT _OnApply(HWND hDlg);            // The user clicked apply
    HRESULT _IsDirty(IN BOOL * pIsDirty);
    INT_PTR _OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

    INT_PTR _PropertySheetDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
    friend INT_PTR CALLBACK PropertySheetDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);

    friend HRESULT CEffectsPage_CreateInstance(OUT IAdvancedDialog ** ppAdvDialog);
};




#endif // _EFFECTSADVPG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\enumunknown.cpp ===
/*****************************************************************************\
    FILE: EnumUnknown.cpp

    DESCRIPTION:
        This code will implement IEnumUnknown for an HDPA.

    BryanSt 5/30/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "EnumUnknown.h"


class CEnumUnknown      : public IEnumUnknown
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IEnumUnknown ***
    virtual STDMETHODIMP Next(IN ULONG celt, IN IUnknown ** rgelt, IN ULONG * pceltFetched);
    virtual STDMETHODIMP Skip(IN ULONG celt);
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Clone(OUT IEnumUnknown ** ppenum);

protected:
    HRESULT _Initialize(void);

private:
    CEnumUnknown(IN IUnknown * punkOwner, IN IUnknown ** ppArray, IN int nArraySize, IN int nIndex);
    virtual ~CEnumUnknown(void);

    // Private Member Variables
    long                    m_cRef;

    IUnknown *              m_punkOwner;                        // The owner of m_pUnknownArray.  We hold a ref on this guy to keep m_pUnknownArray valid.
    IUnknown **             m_pUnknownArray;                    // The array of IUnknowns
    int                     m_nArraySize;                       // The size of m_pUnknownArray 
    int                     m_nIndex;                           // The current index during enum.


    // Private Member Functions


    // Friend Functions
    friend HRESULT CEnumUnknown_CreateInstance(IN IUnknown * punkOwner, IN IUnknown ** ppArray, IN int nArraySize, IN int nIndex, OUT IEnumUnknown ** ppEnumUnknown);
};




//===========================
// *** Class Internals & Helpers ***
//===========================



//===========================
// *** IEnumUnknown Interface ***
//===========================
HRESULT CEnumUnknown::Next(IN ULONG celt, IN IUnknown ** rgelt, IN ULONG * pceltFetched)
{
    HRESULT hr = E_INVALIDARG;

    if (rgelt && pceltFetched)
    {
        ULONG nIndex;

        hr = S_OK;

        *pceltFetched = 0;
        for (nIndex = 0; nIndex < celt; nIndex++,m_nIndex++)
        {
            if ((m_nIndex < m_nArraySize) && m_pUnknownArray[m_nIndex])
            {
                rgelt[nIndex] = NULL;

                IUnknown_Set(&(rgelt[nIndex]), m_pUnknownArray[m_nIndex]);
                (*pceltFetched)++;
            }
            else
            {
                rgelt[nIndex] = NULL;
            }
        }
    }

    return hr;
}


HRESULT CEnumUnknown::Skip(IN ULONG celt)
{
    m_nIndex += celt;
    return S_OK;
}


HRESULT CEnumUnknown::Reset(void)
{
    m_nIndex = 0;
    return S_OK;
}


HRESULT CEnumUnknown::Clone(OUT IEnumUnknown ** ppenum)
{
    HRESULT hr = E_INVALIDARG;

    if (ppenum)
    {
        hr = CEnumUnknown_CreateInstance(SAFECAST(this, IEnumUnknown *), m_pUnknownArray, m_nArraySize, m_nIndex, ppenum);
    }

    return hr;
}




//===========================
// *** IUnknown Interface ***
//===========================
ULONG CEnumUnknown::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CEnumUnknown::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CEnumUnknown::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CEnumUnknown, IEnumUnknown),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CEnumUnknown::CEnumUnknown(IN IUnknown * punkOwner, IN IUnknown ** ppArray, IN int nArraySize, IN int nIndex) : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_punkOwner);

    IUnknown_Set(&m_punkOwner, punkOwner);
    m_pUnknownArray = ppArray;
    m_nArraySize = nArraySize;
    m_nIndex = nIndex;
}


CEnumUnknown::~CEnumUnknown()
{
    IUnknown_Set(&m_punkOwner, NULL);

    DllRelease();
}


HRESULT CEnumUnknown_CreateInstance(IN IUnknown * punkOwner, IN IUnknown ** ppArray, IN int nArraySize, IN int nIndex, OUT IEnumUnknown ** ppEnumUnknown)
{
    HRESULT hr = E_INVALIDARG;

    if (punkOwner && ppArray && ppEnumUnknown)
    {
        CEnumUnknown * pObject = new CEnumUnknown(punkOwner, ppArray, nArraySize, nIndex);

        *ppEnumUnknown = NULL;
        if (pObject)
        {
            hr = pObject->QueryInterface(IID_PPV_ARG(IEnumUnknown, ppEnumUnknown));
            pObject->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\exe.cpp ===
/*
 *  exe.c   Get info from a EXEHDR
 *
 *  Modification History:
 *
 *  4/03/89  ToddLa Wrote it
 *  4/09/90  T-JackD modification such that the type of error is reflected...
 *  4/17/90  t-jackd modification such that notification of error can be set...
 *  4/20/2001 BryanSt improved the error checking to bring the code into the 21st centry.
 */

#include "priv.h"
#pragma hdrstop

#include <newexe.h>
#include "exe.h"

static DWORD dwDummy;
#define FOPEN(sz)                CreateFile(sz, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL )
#define FCLOSE(fh)               CloseHandle(fh)
#define FREAD(fh,buf,len)        (ReadFile(fh,buf,len, &dwDummy, NULL) ? dwDummy : HFILE_ERROR)
#define FSEEK(fh,off,i)          SetFilePointer(fh,(DWORD)off, NULL, i)
#define F_SEEK_SET                    FILE_BEGIN

BOOL NEAR PASCAL IsFAPI(int fh, struct new_exe FAR *pne, long off);

/*
 *  Function will return a specific piece of information from a new EXEHDR
 *
 *      szFile      - Path Name a new exe
 *      pBuf        - Buffer to place returned info
 *      nBuf        - Size of buffer in BYTES
 *      fInfo       - What info to get?
 *
 *          GEI_MODNAME         - Get module name
 *          GEI_DESCRIPTION     - Get description
 *          GEI_FLAGS           - Get EXEHDR flags
 *
 *  returns:  LOWORD = ne_magic, HIWORD = ne_exever
 *            0 if error
 */

DWORD FAR PASCAL GetExeInfo(LPTSTR szFile, void FAR *pBuf, int nBuf, UINT fInfo)
{
    HANDLE      fh;
    DWORD       off;
    DWORD       dw;
    BYTE        len;
    struct exe_hdr exehdr;
    struct new_exe newexe;

    fh = FOPEN(szFile);

    if (fh == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    if (FREAD(fh, &exehdr, sizeof(exehdr)) != sizeof(exehdr) ||
        exehdr.e_magic != EMAGIC ||
        exehdr.e_lfanew == 0L)
    {
            goto error;        /* Abort("Not an exe",h); */
    }

    FSEEK(fh, exehdr.e_lfanew, F_SEEK_SET);

    if (FREAD(fh, &newexe, sizeof(newexe)) != sizeof(newexe))
    {
            goto error;      // Read error
    }

    if (newexe.ne_magic == PEMAGIC)
    {
            if (fInfo != GEI_DESCRIPTION &&
                fInfo != GEI_EXPVER)
                    goto error;

            // make the file name the description
            lstrcpy((LPTSTR) pBuf, szFile);

            // read the SubsystemVersion

            FSEEK(fh,exehdr.e_lfanew+18*4,F_SEEK_SET);
            FREAD(fh,&dw,4);

            newexe.ne_expver = LOBYTE(LOWORD(dw)) << 8 | LOBYTE(HIWORD(dw));
            goto exit;
    }

    if (newexe.ne_magic != NEMAGIC)
    {
            goto error;      // Invalid NEWEXE
    }

    switch (fInfo)
    {
        case GEI_EXEHDR:
            *(struct new_exe FAR *)pBuf = newexe;
            break;

        case GEI_FLAGS:
            *(WORD FAR *)pBuf = newexe.ne_flags;
            break;

        /* module name is the first entry in the medident name table */
        case GEI_MODNAME:
            off = exehdr.e_lfanew + newexe.ne_restab;
            goto readstr;
            break;

        /* module name is the first entry in the non-medident name table */
        case GEI_DESCRIPTION:
            off = newexe.ne_nrestab;
readstr:
            FSEEK(fh, off, F_SEEK_SET);
            FREAD(fh, &len, sizeof(BYTE));

            nBuf--;         // leave room for a \0

            if (len > (BYTE)nBuf)
                len = (BYTE)nBuf;

            {
                LPSTR pbTmp;
                pbTmp = (LPSTR) LocalAlloc(LMEM_FIXED, len);

                if (pbTmp)
                {
                    FREAD(fh, pbTmp, len);

                    len = (BYTE)MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pbTmp, len,
                            (LPWSTR)pBuf, nBuf / SIZEOF(WCHAR));

                    LocalFree(pbTmp);
                }
            }
            ((LPTSTR)pBuf)[len] = 0;
            break;

        case GEI_EXPVER:
            break;

        default:
            goto error;
            break;
    }

exit:
    FCLOSE(fh);
    return MAKELONG(newexe.ne_magic, newexe.ne_expver);

error:
    FCLOSE(fh);
    return 0;
}

// Code taken from kernel32.dll
#define DEFAULT_WAIT_FOR_INPUT_IDLE_TIMEOUT 30000

UINT WinExecN(LPCTSTR pszPath, LPTSTR pszPathAndArgs, UINT uCmdShow)
{
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    BOOL CreateProcessStatus;
    DWORD ErrorCode;

    ZeroMemory(&StartupInfo,sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    StartupInfo.dwFlags = STARTF_USESHOWWINDOW;
    StartupInfo.wShowWindow = (WORD)uCmdShow;
    CreateProcessStatus = CreateProcess(
                            pszPath,
                            pszPathAndArgs,
                            NULL,
                            NULL,
                            FALSE,
                            0,
                            NULL,
                            NULL,
                            &StartupInfo,
                            &ProcessInformation
                            );

    if ( CreateProcessStatus )
    {
        // Wait for the started process to go idle. If it doesn't go idle in
        // 10 seconds, return anyway.
        WaitForInputIdle(ProcessInformation.hProcess, DEFAULT_WAIT_FOR_INPUT_IDLE_TIMEOUT);
        CloseHandle(ProcessInformation.hProcess);
        CloseHandle(ProcessInformation.hThread);
        return 33;
    }
    else
    {
        // If CreateProcess failed, then look at GetLastError to determine
        // appropriate return code.
        ErrorCode = GetLastError();
        switch ( ErrorCode )
        {
            case ERROR_FILE_NOT_FOUND:
                return 2;

            case ERROR_PATH_NOT_FOUND:
                return 3;

            case ERROR_BAD_EXE_FORMAT:
                return 11;

            default:
                return 0;
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\exe.h ===
// EXE.H - read windows exe headers

/* Attempt to get information of type fInfo on the file szFile, depositing
    the information (to a maximum of nBuf characters) in pBuf.  If BOOL fError
    is set, then display error messages when something goes wrong... */

DWORD FAR PASCAL GetExeInfo(LPTSTR szFile, void FAR *pBuf, int cbBuf, UINT fInfo);

#define GEI_MODNAME         0x01
#define GEI_DESCRIPTION     0x02
#define GEI_FLAGS           0x03
#define GEI_EXEHDR          0x04
#define GEI_FAPI            0x05
#define GEI_EXPVER          0x06

#define PEMAGIC         0x4550  /* 'PE' */
#define NEMAGIC         0x454E  /* 'NE' */


// Second parameter must be writeable because that's how Kernel32 likes it...
UINT WinExecN(LPCTSTR pszPath, LPTSTR pszPathAndArgs, UINT uCmdShow);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\enumunknown.h ===
/*****************************************************************************\
    FILE: EnumUnknown.h

    DESCRIPTION:
        This code will implement IEnumUnknown for an HDPA.

    BryanSt 5/30/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _ENUMUNKNOWN_H
#define _ENUMUNKNOWN_H

HRESULT CEnumUnknown_CreateInstance(IN IUnknown * punkOwner, IN IUnknown ** ppArray, IN int nArraySize, IN int nIndex, OUT IEnumUnknown ** ppEnumUnknown);

#endif // _ENUMUNKNOWN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\effectsbasepg.h ===
/*****************************************************************************\
    FILE: EffectsBasePg.h

    DESCRIPTION:
        This code will be the base object that won't add any pages to the base
    "Display Properties" dialog.  However, it will request a "Effects" page be
    added to the Advanced.

    BryanSt 4/13/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _EFFECTSBASEPG_H
#define _EFFECTSBASEPG_H

#include "store.h"
#include <cowsite.h>
#include <objclsid.h>
#include <shpriv.h>


#define SZ_PBPROP_EFFECTSSTATE               TEXT("EffectsState") // VT_BYREF (void *) to CEffectState class



HRESULT CEffectsBasePage_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);


class CEffectsBasePage          : public CObjectCLSID
                                , public CObjectWithSite
                                , public IPropertyBag
                                , public IBasePropPage
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IShellPropSheetExt ***
    virtual STDMETHODIMP AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam);
    virtual STDMETHODIMP ReplacePage(IN EXPPS uPageID, IN LPFNSVADDPROPSHEETPAGE pfnReplaceWith, IN LPARAM lParam) {return E_NOTIMPL;}

    // *** IPropertyBag ***
    virtual STDMETHODIMP Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog);
    virtual STDMETHODIMP Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar);

    // *** IBasePropPage ***
    virtual STDMETHODIMP GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog);
    virtual STDMETHODIMP OnApply(IN PROPPAGEONAPPLY oaAction);



    CEffectsBasePage();
    virtual ~CEffectsBasePage(void);
protected:

private:

    // Private Member Variables
    long                    m_cRef;

    BOOL                    m_fDirty;
    CEffectState *          m_pEffectsState;

    // Private Member Functions
    HRESULT _InitState(void);
    HRESULT _SaveState(CEffectState * pEffectsState);
};


#endif // _EFFECTSBASEPG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\fake.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Fake.c
//
// this code gives OEMs a bogus Settings page to patch/modify
//
// OEM display pages patch the snot out of the Settings page
// the problem is that we have changed the setting page, and
// even if the OEM code could deal with our changes, the
// settings page is not even on the same property sheet
// as the extensions.
//
// some OEMs hook the setting page by hooking the TabContol and
// watching for a mouse click to activate the Settings page
// then they modify the page.  NOTE they dont patch the page
// if it is activated via the keyboard only the mouse!
//
// some OEM pages find the Setting page by name.
// we have named the real settings page "Settings " and
// the fake page is "Settings"
//
// some OEM pages assume the last page is the Settings page.
// we make sure the fake settings is always last.
//
///////////////////////////////////////////////////////////////////////////////
#include "priv.h"
#include "winuser.h"
#pragma hdrstop
#include "cplext.h"

#ifndef TCIS_HIDDEN
#define TCIS_HIDDEN 0x0004
#pragma message("using local version of TCIS_HIDDEN")
#endif

#undef MATROX_HACK

/*
 * Global stuff
 */
static LONG_PTR TabWndProc;             // SysTabControl WndProc
static LONG_PTR DlgWndProc;             // Dialog WndProc

#ifdef MATROX_HACK
static PROPSHEETHEADER psh;             // saved prop sheet header
#endif

/*
 * Local Constant Declarations
 */
int CALLBACK DeskPropSheetCallback(HWND hDlg, UINT code, LPARAM lParam);
INT_PTR CALLBACK FakeSettingsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

IThemeUIPages *g_pThemeUI;
///////////////////////////////////////////////////////////////////////////////
// AddFakeSettingsPage
///////////////////////////////////////////////////////////////////////////////
void AddFakeSettingsPage(IThemeUIPages *pThemeUI, PROPSHEETHEADER * ppsh)
{
    g_pThemeUI = pThemeUI;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpsp;

    ZeroMemory(&psp, sizeof(psp));

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = HINST_THISDLL;
    psp.pszTemplate = MAKEINTRESOURCE(DLG_FAKE_SETTINGS);
    psp.pfnDlgProc  = FakeSettingsDlgProc;
    psp.lParam      = 0L;

    //
    // some OEMs find the Property sheet by window title
    // so make sure we have the title they expect.
    //
#ifdef MATROX_HACK
    if (ppsh->hwndParent && IsWindowVisible(ppsh->hwndParent))
    {
        psh = *ppsh;
        ppsh->pszCaption = MAKEINTRESOURCE(IDS_DISPLAY_TITLE);
        psp.dwFlags |= PSP_PREMATURE;
    }
#endif

    hpsp = CreatePropertySheetPage(&psp);
    if (hpsp)
    {
        ppsh->phpage[ppsh->nPages++] = hpsp;

        ppsh->pfnCallback = DeskPropSheetCallback;
        ppsh->dwFlags    |= PSH_USECALLBACK;
    }
}

///////////////////////////////////////////////////////////////////////////////
// FakeSettingsDlgProc
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK FakeSettingsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    if (hDlg && DlgWndProc)
    {
        if (GetWindowLongPtr(hDlg, GWLP_WNDPROC) != DlgWndProc)
        {
            SetWindowLongPtr(hDlg, GWLP_WNDPROC, DlgWndProc);
        }

        if (GetWindowLongPtr(hDlg, DWLP_DLGPROC) != (LONG_PTR)FakeSettingsDlgProc)
        {
            SetWindowLongPtr(hDlg, DWLP_DLGPROC, (LONG_PTR)FakeSettingsDlgProc);
        }
    }

    switch (message)
    {
        case WM_INITDIALOG:
            return TRUE;

        case WM_DESTROY:
            break;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDC_CHANGEDRV)
            {
            }
            break;
    }

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// HideFakeSettingsPage
//
// hide the bogus settings page from view so the user cant see it.
//
// this code uses a new TabCtrl item style TCIS_HIDDEN that is only
// in the Win98/NT5/IE4.01 COMMCTRL
//
///////////////////////////////////////////////////////////////////////////////
void HideFakeSettingsPage(HWND hDlg)
{
    HWND hwnd = PropSheet_GetTabControl(hDlg);
    if (hwnd)
    {
        TCITEM tci;
        tci.mask = TCIF_STATE;
        tci.dwStateMask = TCIS_HIDDEN;
        tci.dwState = TCIS_HIDDEN;
        TabCtrl_SetItem(hwnd, TabCtrl_GetItemCount(hwnd)-1, &tci);
    }
}

///////////////////////////////////////////////////////////////////////////////
// DeskPropSheetCallback
//
// what this callback does is look for someone subclassing the
// tab control, if we detect this we put the correct WndProc
// back.
//
// we also hide the fake settings page after all the entensions
// have initialized
//
///////////////////////////////////////////////////////////////////////////////
int CALLBACK DeskPropSheetCallback(HWND hDlg, UINT code, LPARAM lParam)
{
    HWND hwnd;

    WNDCLASS wc;

    switch (code)
    {
        case PSCB_INITIALIZED:
            TraceMsg(TF_GENERAL, "DeskPropSheetCallback: PSCB_INITIALIZED");

            hwnd = PropSheet_GetTabControl(hDlg);
            if (hwnd && TabWndProc)
            {
                if (GetWindowLongPtr(hwnd, GWLP_WNDPROC) != TabWndProc)
                {
                    SetWindowLongPtr(hwnd, GWLP_WNDPROC, TabWndProc);
                }
            }

            if (hDlg && DlgWndProc)
            {
                if (GetWindowLongPtr(hDlg, GWLP_WNDPROC) != DlgWndProc)
                {
                    SetWindowLongPtr(hDlg, GWLP_WNDPROC, DlgWndProc);
                }
            }

#ifdef MATROX_HACK
            //
            // restore the caption
            //
            if (psh.pszCaption)
            {
                ShowWindow(hDlg, SW_SHOW);
                Sleep(10);
                PropSheet_SetTitle(hDlg, psh.dwFlags, psh.pszCaption);
                PropSheet_SetTitle(GetParent(psh.hwndParent),
                    PSH_PROPTITLE, MAKEINTRESOURCE(IDS_DISPLAY_TITLE));
                psh.pszCaption = 0;
            }
#endif
            //
            // hide the settings page so the user cant see it.
            //
            HideFakeSettingsPage(hDlg);
            break;

        case PSCB_PRECREATE:
            TraceMsg(TF_GENERAL, "DeskPropSheetCallback: PSCB_PRECREATE");

            ZeroMemory(&wc, sizeof(wc));
            SHFusionGetClassInfo(NULL, WC_DIALOG, &wc);
            DlgWndProc = (LONG_PTR)wc.lpfnWndProc;

            ZeroMemory(&wc, sizeof(wc));
            SHFusionGetClassInfo(NULL, WC_TABCONTROL, &wc);
            TabWndProc = (LONG_PTR)wc.lpfnWndProc;
            break;

        case PSCB_BUTTONPRESSED:
            if ((PSBTN_OK == lParam) || (PSBTN_APPLYNOW == lParam))
            {
                DWORD dwFlags = ((PSBTN_OK == lParam) ? (TUIAP_WAITFORAPPLY | TUIAP_NONE) : TUIAP_NONE);
                if (g_pThemeUI)
                {
                    g_pThemeUI->ApplyPressed(dwFlags);
                }
            }
            break;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\fontfix.h ===
/*****************************************************************************\
    FILE: fontfix.h

    DESCRIPTION:
        This file will implement an API: FixFontsOnLanguageChange().
    The USER32 or Regional Settings code should own this API.  The fact that it's
    in the shell is a hack and it should be moved to USER32.  This font will
    be called when the MUI language changes so the fonts in the system metrics
    can be changed to valid values for the language.

    This API should be called in three cases:
    a. When the user changes the language via the Regional Settings CPL UI.
    b. During a user login, USER32 should see if the language changed and
       call this API.  This will handle the case where admins change the
       language via login screens and reboot.  This is not currently implemented.
    c. The language is changed via some other method (admin login scripts most likely)
       and the user opens the display CPL.  This method is a hack, especially
       since (b) isn't implemented.

    Contacts: EdwardP - International Font PM.

    Sankar  ?/??/???? - Created for Win2k or before in desk.cpl.
    BryanSt 3/24/2000 - Make to be modular so it can be moved back into USER32.
                        Made the code more robust.  Removed creating custom appearance
                        schemes in order to be compatible with new .theme and
                        .msstyles support.

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _FONTFIX_H
#define _FONTFIX_H



/////////////////////////////////////////////////////////////////////
// String Constants
/////////////////////////////////////////////////////////////////////
#define SYSTEM_LOCALE_CHARSET  0  //The first item in the array is always system locale charset.




/////////////////////////////////////////////////////////////////////
// Data Structures
/////////////////////////////////////////////////////////////////////




/////////////////////////////////////////////////////////////////////
// Public Function
/////////////////////////////////////////////////////////////////////

// This API is used to fix fonts in case the language changed and we need to fix the CHARSET.
STDAPI FixFontsOnLanguageChange(void);

// Call this API when loading a set of authored LOGFONTs.  It will change the CHARSET if
// it is not compatible with the currently active LCIDs.
HRESULT FontFix_CheckSchemeCharsets(SYSTEMMETRICSALL * pSystemMetricsAll);

// These are used to filter out fonts not compatible with the current language.
int CALLBACK Font_EnumValidCharsets(LPENUMLOGFONTEX lpelf, LPNEWTEXTMETRIC lpntm, DWORD Type, LPARAM lData);
void Font_GetCurrentCharsets(UINT uiCharsets[], int iCount);
void Font_GetUniqueCharsets(UINT uiCharsets[], UINT uiUniqueCharsets[], int iMaxCount, int *piCountUniqueCharsets);




#endif // _FONTFIX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\fontfix.cpp ===
/*****************************************************************************\
    FILE: fontfix.cpp

    DESCRIPTION:
        This file will implement an API: FixFontsOnLanguageChange().
    The USER32 or Regional Settings code should own this API.  The fact that it's
    in the shell is a hack and it should be moved to USER32.  This font will
    be called when the MUI language changes so the fonts in the system metrics
    can be changed to valid values for the language.

    Contacts: EdwardP - International Font PM.

    Sankar  ?/??/???? - Created for Win2k or before in desk.cpl.
    BryanSt 3/24/2000 - Make to be modular so it can be moved back into USER32.
                        Made the code more robust.  Removed creating custom appearance
                        schemes in order to be compatible with new .theme and
                        .msstyles support.

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "AdvAppearPg.h"
#include "fontfix.h"



#define SZ_DEFAULT_FONT             TEXT("Tahoma")


/////////////////////////////////////////////////////////////////////
// Private Functions
/////////////////////////////////////////////////////////////////////


BOOL FontFix_ReadCharsets(UINT uiCharsets[], int iCount)
{
    HKEY    hkAppearance;
    BOOL    fSuccess = FALSE;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, SZ_REGKEY_APPEARANCE, 0, KEY_READ, &hkAppearance) == ERROR_SUCCESS)
    {
        DWORD dwType = REG_BINARY;
        DWORD dwSize = iCount * sizeof(UINT);

        if (RegQueryValueEx(hkAppearance, SZ_REGVALUE_RECENTFOURCHARSETS, NULL, &dwType, (LPBYTE)uiCharsets, &dwSize) == ERROR_SUCCESS)
            fSuccess = TRUE;

        RegCloseKey(hkAppearance);
    }

    return fSuccess;
}

BOOL FontFix_SaveCharsets(UINT uiCharsets[], int iCount)
{
    HKEY    hkAppearance;
    BOOL    fSuccess = FALSE;
    
    if(RegCreateKeyEx(HKEY_CURRENT_USER, SZ_REGKEY_APPEARANCE, 0, TEXT(""), 0, KEY_WRITE, NULL, &hkAppearance, NULL) == ERROR_SUCCESS)
    {
        if(RegSetValueEx(hkAppearance, SZ_REGVALUE_RECENTFOURCHARSETS, 0, REG_BINARY, (LPBYTE)uiCharsets, iCount * sizeof(UINT)) == ERROR_SUCCESS)
            fSuccess = TRUE;
            
        RegCloseKey(hkAppearance);
    }

    return fSuccess;
}



void FontFix_GetDefaultFontName(LPTSTR pszDefFontName, DWORD cchSize)
{
    HKEY    hkDefFont;

    //Value is not there in the registry; Use "Tahoma" as the default name.
    StrCpyN(pszDefFontName, SZ_DEFAULT_FONT, cchSize);

    // Read the "DefaultFontName" to be used.
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                     SZ_APPEARANCE_SCHEMES,
                                     0,
                                     KEY_READ,
                                     &hkDefFont) == ERROR_SUCCESS) 
    {
        DWORD dwType = REG_SZ;
        DWORD cbSize = (cchSize * sizeof(pszDefFontName[0]));
        
        if (RegQueryValueEx(hkDefFont,
                        SZ_REGVALUE_DEFAULTFONTNAME,
                        NULL,
                        &dwType,
                        (LPBYTE) pszDefFontName,
                        &cbSize) != ERROR_SUCCESS)
        {
            // We already set a fallback value.
        }

        RegCloseKey(hkDefFont);
    }
}


BOOL FontFix_DoesFontSupportAllCharsets(HDC hdc, LPLOGFONT plf, UINT uiUniqueCharsets[], int iCountUniqueCharsets)
{
    int j;
    
    //The given font supports the system charset; Let's check if it supports the other charsets
    for (j = 0; j < iCountUniqueCharsets; j++)
    {
        plf->lfCharSet = (BYTE)uiUniqueCharsets[j];  //Let's try the next charset in the array.
        if (EnumFontFamiliesEx(hdc, plf, (FONTENUMPROC)Font_EnumValidCharsets, (LPARAM)0, 0) != 0)
        {
            // EnumFontFamiliesEx would have returned a zero if Font_EnumValidCharsets was called
            // even once. In other words, it returned a non-zero because not even a single font existed
            // that supported the given charset.
            return FALSE;
        }
    }

    return TRUE; //Yes this font supports all the charsets we are interested in.
}


// Given an array of fonts and an array of unique charsets, this function checks if the fonts 
// support ALL these charsets.
// Returns TRUE if these fonts support all the charsets.
// In all other cases, this function will return TRUE. If the fonts need to be changed to support
// the given charsets, this function does all those changes.
//
//  lpszName is the name of the scheme to be used in the MessageBox that appears if fSilent is FALSE.
BOOL FontFix_CheckFontsCharsets(LOGFONT lfUIFonts[], int iCountFonts, 
                        UINT uiCurUniqueCharsets[], int iCountCurUniqueCharsets, 
                        BOOL *pfDirty, LPCTSTR lpszName)
{
    int i;
    TCHAR   szDefaultFontFaceName[LF_FACESIZE];
    HDC     hdc;

    *pfDirty   = FALSE; //Assume that this scheme does not need to be saved.

    //Read the default font name from the registry (Mostly: Tahoma)
    FontFix_GetDefaultFontName(szDefaultFontFaceName, ARRAYSIZE(szDefaultFontFaceName));

    hdc = GetDC(NULL);

    //Check to see of the fonts support the system charset
    for (i = 0; i < iCountFonts; i++)
    {
        //Save the current charset because FontFix_DoesFontSupportAllCharsets() destroys this field.
        BYTE bCurCharset = lfUIFonts[i].lfCharSet;  

        if (!FontFix_DoesFontSupportAllCharsets(hdc, &lfUIFonts[i], uiCurUniqueCharsets, iCountCurUniqueCharsets))
        {
            //Copy the default fontname to the font.
            lstrcpy(lfUIFonts[i].lfFaceName, szDefaultFontFaceName);
            *pfDirty = TRUE;  //This scheme needs to be saved.
        }

        //Restore the charset because FontFix_DoesFontSupportAllCharsets() destroyed this field.
        lfUIFonts[i].lfCharSet = bCurCharset; // Restore the current charset.

        // Warning #1: The IconTitle font's Charset must always match the System Locale charset.
        // Warning #2: FoxPro's tooltips code expects the Status font's charset to the the System 
        // Locale's charset.
        // As per intl guys, we set the charset of all the UI fonts to SYSTEM_LOCALE_CHARSET.
        if (lfUIFonts[i].lfCharSet != uiCurUniqueCharsets[SYSTEM_LOCALE_CHARSET])
        {
            lfUIFonts[i].lfCharSet = (BYTE)uiCurUniqueCharsets[SYSTEM_LOCALE_CHARSET];
            *pfDirty = TRUE;
        }
    }  //For loop 

    ReleaseDC(NULL, hdc);

    return TRUE;  //The fonts have been modified as required.
}





void FontFix_GetUIFonts(NONCLIENTMETRICS *pncm, LOGFONT lfUIFonts[])
{
    pncm->cbSize = sizeof(NONCLIENTMETRICS);
    ClassicSystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICS),
                                (void far *)(LPNONCLIENTMETRICS)pncm, FALSE);

    // Read the icon title font directly into the font array.
    ClassicSystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT),
                (void far *)(LPLOGFONT)&(lfUIFonts[FONT_ICONTITLE]), FALSE);
                
    //Make a copy of the ncm fonts into fonts array.
    LF32toLF(&(pncm->lfCaptionFont), &(lfUIFonts[FONT_CAPTION]));
    LF32toLF(&(pncm->lfSmCaptionFont), &(lfUIFonts[FONT_SMCAPTION]));
    LF32toLF(&(pncm->lfMenuFont), &(lfUIFonts[FONT_MENU]));
    LF32toLF(&(pncm->lfStatusFont), &(lfUIFonts[FONT_STATUS]));
    LF32toLF(&(pncm->lfMessageFont), &(lfUIFonts[FONT_MSGBOX]));
}


void FontFix_SetUIFonts(NONCLIENTMETRICS *pncm, LOGFONT lfUIFonts[])
{
    //Copy all fonts back into the ncm structure.
    LFtoLF32(&(lfUIFonts[FONT_CAPTION]), &(pncm->lfCaptionFont));
    LFtoLF32(&(lfUIFonts[FONT_SMCAPTION]), &(pncm->lfSmCaptionFont));
    LFtoLF32(&(lfUIFonts[FONT_MENU]), &(pncm->lfMenuFont));
    LFtoLF32(&(lfUIFonts[FONT_STATUS]), &(pncm->lfStatusFont));
    LFtoLF32(&(lfUIFonts[FONT_MSGBOX]), &(pncm->lfMessageFont));

    // FEATURE: Do we want a WININICHANGE HERE?
    // NOTE: We want to set a SPIF_SENDWININICHANGE, because we want to refresh.
    // Note we don't do this async.  This should only happen when the user changes MUI languages,
    // and in that case, perf can suck.
    TraceMsg(TF_GENERAL, "desk.cpl: Calling SPI_SETNONCLIENTMETRICS");
    ClassicSystemParametersInfo(SPI_SETNONCLIENTMETRICS, sizeof(*pncm), (void far *)(LPNONCLIENTMETRICS)pncm, (SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE));

    TraceMsg(TF_GENERAL,"desk.cpl: Calling SPI_SETICONTITLELOGFONT");
    ClassicSystemParametersInfo(SPI_SETICONTITLELOGFONT, sizeof(LOGFONT),
            (void far *)(LPLOGFONT)&lfUIFonts[FONT_ICONTITLE], (SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE));
}


// ------------------------ manage system settings --------------------------

//  Given the Locale ID, this returns the corresponding charset
UINT GetCharsetFromLCID(LCID lcid)
{
    TCHAR szData[6+1]; // 6 chars are max allowed for this lctype
    UINT uiRet;
    DWORD dwError = 0;

    if (GetLocaleInfo(lcid, LOCALE_IDEFAULTANSICODEPAGE, szData, ARRAYSIZE(szData)) > 0)
    {
        UINT uiCp = (UINT)StrToInt(szData);
        CHARSETINFO csinfo = {0};

        if (!TranslateCharsetInfo((DWORD *)IntToPtr(uiCp), &csinfo, TCI_SRCCODEPAGE))
        {
            dwError = GetLastError();
            uiRet = DEFAULT_CHARSET;
        }
        else
        {
            uiRet = csinfo.ciCharset;
        }
    }
    else
    {
        // at worst non penalty for charset
        dwError = GetLastError();
        uiRet = DEFAULT_CHARSET;
    }

    return uiRet;
}


int FontFix_CompareUniqueCharsets(UINT uiCharset1[], int iCount1, UINT uiCharset2[], int iCount2)
{
    if (iCount1 == iCount2)
    {
        int i, j;
        
        // The first items in the array is SYSTEM CHAR SET; It must match because system locale's
        // charset is always used by the Icon Title font; Icon Title font's charset is used by 
        // comctl32 to do A/W conversion. In order that all ANSI applications run correctly, 
        // the icon charset must always match current system locale.
        if (uiCharset1[SYSTEM_LOCALE_CHARSET] != uiCharset2[SYSTEM_LOCALE_CHARSET])
            return -1;

        //Now see if the arrays have the same elements.
        ASSERT(SYSTEM_LOCALE_CHARSET == 0);
        
        for (i = SYSTEM_LOCALE_CHARSET+1; i < iCount1; i++)
        {
            for (j = SYSTEM_LOCALE_CHARSET+1; j < iCount2; j++)
            {
                if(uiCharset1[i] == uiCharset2[j])
                    break;
            }
            if (j == iCount2)
                return -1;   // uiCharset1[i] is not found in the second array.
        }
    }
    
    return (iCount1 - iCount2); // Both the arrays have the same Charsets
}


// Given the Language ID, this gets the charset.
UINT GetCharsetFromLang(LANGID wLang)
{
    return(GetCharsetFromLCID(MAKELCID(wLang, SORT_DEFAULT)));
}







/////////////////////////////////////////////////////////////////////
// Public Functions
/////////////////////////////////////////////////////////////////////
void Font_GetCurrentCharsets(UINT uiCharsets[], int iCount)
{
    LCID lcid;
    LANGID langID;

    ASSERT(iCount == MAX_CHARSETS);

    // Get all the four charsets we are interested in.
    uiCharsets[0] = GetCharsetFromLCID(lcid = GetSystemDefaultLCID());
    AssertMsg(lcid, TEXT("GetSystemDefaultLCID() failed with %d"), GetLastError());

    uiCharsets[1] = GetCharsetFromLCID(lcid = GetUserDefaultLCID());
    AssertMsg(lcid, TEXT("GetUserDefaultLCID() failed with %d"), GetLastError());

    uiCharsets[2] = GetCharsetFromLang(langID = GetSystemDefaultUILanguage());
    AssertMsg(langID, TEXT("GetSystemDefaultUILanguage() failed with %d"), GetLastError());

    uiCharsets[3] = GetCharsetFromLang(langID = GetUserDefaultUILanguage());
    AssertMsg(langID, TEXT("GetUserDefaultUILanguage() failed with %d"), GetLastError());
}


void Font_GetUniqueCharsets(UINT uiCharsets[], UINT uiUniqueCharsets[], int iMaxCount, int *piCountUniqueCharsets)
{
    int i, j;
    
    // Find the unique Charsets;
    *piCountUniqueCharsets = 0;
    for (i = 0; i < iMaxCount; i++)
    {
        uiUniqueCharsets[i] = DEFAULT_CHARSET; //Initialize it to default charset.

        for (j = 0; j < *piCountUniqueCharsets; j++)
        {
            if (uiUniqueCharsets[j] == uiCharsets[i])
                break; // This Charset is already in the array
        }

        if (j == *piCountUniqueCharsets)
        {
            // Yes! It is a unique char set; Save it!
            uiUniqueCharsets[j] = uiCharsets[i];
            (*piCountUniqueCharsets)++; //One more unique char set found.
        }
    }
}



int CALLBACK Font_EnumValidCharsets(LPENUMLOGFONTEX lpelf, LPNEWTEXTMETRIC lpntm, DWORD Type, LPARAM lData)
{
    // The purpose of this function is to determine if a font supports a particular charset;
    // If this callback gets called even once, then that means that this font supports the given
    // charset. There is no need to enumerate all the other styles. We immediately return zero to
    // stop the enumeration. Since we return zero, the EnumFontFamiliesEx() also returns zero in 
    // this case and that return value is used to determine if a given font supports a given
    // charset.


    return 0;
}


HRESULT FontFix_FixNonClientFonts(LOGFONT lfUIFonts[])
{
    UINT    uiCurCharsets[MAX_CHARSETS];
    UINT    uiRegCharsets[MAX_CHARSETS];
    UINT    uiCurUniqueCharsets[MAX_CHARSETS];
    int     iCountCurUniqueCharsets = 0;
    UINT    uiRegUniqueCharsets[MAX_CHARSETS];
    int     iCountRegUniqueCharsets = 0;
    BOOL    fRegCharsetsValid = FALSE;
    HRESULT hr = S_OK;
    
    // Get the current four charsets from system.
    Font_GetCurrentCharsets(uiCurCharsets, MAX_CHARSETS);
    //Get the charsets saved in the registry.
    fRegCharsetsValid = FontFix_ReadCharsets(uiRegCharsets, MAX_CHARSETS);

    // Get rid of the duplicate charsets and get only the unique Charsets from these arrays.
    Font_GetUniqueCharsets(uiCurCharsets, uiCurUniqueCharsets, MAX_CHARSETS, &iCountCurUniqueCharsets);
    if (fRegCharsetsValid)
        Font_GetUniqueCharsets(uiRegCharsets, uiRegUniqueCharsets, MAX_CHARSETS, &iCountRegUniqueCharsets);

    // Check if these two arrays have the same charsets.
    if (!fRegCharsetsValid || !(FontFix_CompareUniqueCharsets(uiCurUniqueCharsets, iCountCurUniqueCharsets, uiRegUniqueCharsets, iCountRegUniqueCharsets) == 0))
    {
        BOOL fDirty = FALSE;

        FontFix_CheckFontsCharsets(lfUIFonts, NUM_FONTS, uiCurUniqueCharsets, iCountCurUniqueCharsets, &fDirty, TEXT(""));

        // Save the cur charsets into the registry.
        FontFix_SaveCharsets(uiCurCharsets, MAX_CHARSETS);

        hr = (fDirty ? S_OK : S_FALSE);
    }
    else
    {
        hr = S_FALSE;  // The charsets are the same; Nothing to do!
    }

    return hr; //Yes! We had to do some updates in connection with charsets and fonts.
}


//------------------------------------------------------------------------------------------------
//
// This is the function that needs to be called everytime a locale changes (or could have changed).
//
// It does the following:
//  1. It checks if any of the four the charset settings has changed.
//  2. If some charset has changed, it makes the corresponding changes in the 6 UI fonts.
//  3. If a scheme is selected, it checks to see if the fonts support the new charsets and if not
//     changes the fonts and/or charsets and saves the scheme under a new name.
//  4. Saves the new charsets in the registry sothat we don't have to do the same everytime this
//     function is called.
//
//  NOTE: This is a private export from desk.cpl. This is called in two places:
//  1. from regional control panel whenever it is run AND whenever it changes some locale.
//  2. from desk.cpl itself whenever "Appearance" tab is created. This is required because it is
// possible that an admin changes a system locale and then someother user logs-in. For this user
// the locale changes will cause font changes only when he runs Regional options or Appearance tab.
// The only other alternative would be to call this entry point whenever a user logs on, which will
// be a boot time perf hit.
//
//-------------------------------------------------------------------------------------------------
STDAPI FixFontsOnLanguageChange(void)
{
    NONCLIENTMETRICS ncm;
    LOGFONT lfUIFonts[NUM_FONTS];
    
    // Get all the 6 UI fonts.
    FontFix_GetUIFonts(&ncm, lfUIFonts);

    if (S_OK == FontFix_FixNonClientFonts(lfUIFonts))
    {
        FontFix_SetUIFonts(&ncm, lfUIFonts);
    }

    return S_OK; //Yes! We had to do some updates in connection with charsets and fonts.
}



HRESULT FontFix_CheckSchemeCharsets(SYSTEMMETRICSALL * pSystemMetricsAll)
{
    LOGFONT     lfUIFonts[NUM_FONTS]; //Make a local copy of the fonts.

    // Make a copy of the ncm fonts into the local array.
    LF32toLF(&(pSystemMetricsAll->schemeData.ncm.lfCaptionFont), &(lfUIFonts[FONT_CAPTION]));
    LF32toLF(&(pSystemMetricsAll->schemeData.ncm.lfSmCaptionFont), &(lfUIFonts[FONT_SMCAPTION]));
    LF32toLF(&(pSystemMetricsAll->schemeData.ncm.lfMenuFont), &(lfUIFonts[FONT_MENU]));
    LF32toLF(&(pSystemMetricsAll->schemeData.ncm.lfStatusFont), &(lfUIFonts[FONT_STATUS]));
    LF32toLF(&(pSystemMetricsAll->schemeData.ncm.lfMessageFont), &(lfUIFonts[FONT_MSGBOX]));
    // Make a copy of the icon title font
    LF32toLF(&(pSystemMetricsAll->schemeData.lfIconTitle), &(lfUIFonts[FONT_ICONTITLE]));

    // Let's copy the data back into the SchemeData structure
    if (S_OK == FontFix_FixNonClientFonts(lfUIFonts))
    {
        LFtoLF32(&(lfUIFonts[FONT_CAPTION]), &(pSystemMetricsAll->schemeData.ncm.lfCaptionFont));
        LFtoLF32(&(lfUIFonts[FONT_SMCAPTION]), &(pSystemMetricsAll->schemeData.ncm.lfSmCaptionFont));
        LFtoLF32(&(lfUIFonts[FONT_MENU]), &(pSystemMetricsAll->schemeData.ncm.lfMenuFont));
        LFtoLF32(&(lfUIFonts[FONT_STATUS]), &(pSystemMetricsAll->schemeData.ncm.lfStatusFont));
        LFtoLF32(&(lfUIFonts[FONT_MSGBOX]), &(pSystemMetricsAll->schemeData.ncm.lfMessageFont));
        // Make a copy of the icon title font
        LFtoLF32(&(lfUIFonts[FONT_ICONTITLE]), &(pSystemMetricsAll->schemeData.lfIconTitle));
    }

    return S_OK; // It is alright to use this scheme stored in *psd. 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\general.cpp ===
/**************************************************************************\
 * Module Name: general.cpp
 *
 * Contains all the code to manage multiple devices
 *
 * Copyright (c) Microsoft Corp.  1995-1996 All Rights Reserved
 *
 * NOTES:
 *
 * History: Create by dli on 7/21/97
 *
 \**************************************************************************/


#include "priv.h"
#include "SettingsPg.h"

extern INT_PTR CALLBACK CustomFontDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);

//FEATURE: (dli) This should be put in regstr.h
static const TCHAR sc_szRegFontSize[]           = REGSTR_PATH_SETUP TEXT("\\") REGSTR_VAL_FONTSIZE;
static const TCHAR sc_szQuickResRegName[]       = TEXT("Taskbar Display Controls");
static const TCHAR sc_szQuickResCommandLine[]  = TEXT("RunDLL deskcp16.dll,QUICKRES_RUNDLLENTRY");
static const TCHAR sc_szQuickResClass[]  = TEXT("SysQuickRes");
static const char c_szQuickResCommandLine[]  = "RunDLL deskcp16.dll,QUICKRES_RUNDLLENTRY";

//-----------------------------------------------------------------------------
static const DWORD sc_GeneralHelpIds[] =
{
    // font size
    IDC_FONTSIZEGRP,   NO_HELP, // IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_FONTSIZE, 
    IDC_FONT_SIZE_STR, IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_FONTSIZE, 
    IDC_FONT_SIZE,     IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_FONTSIZE,    
    IDC_CUSTFONTPER,   IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_FONTSIZE, 

    // group box
    IDC_DYNA,          NO_HELP, // IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_DYNA,     

    // radio buttons
    IDC_DYNA_TEXT,     NO_HELP,
    IDC_NODYNA,        IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_RESTART, 
    IDC_YESDYNA,       IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_DONT_RESTART,
    IDC_SHUTUP,        IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_ASK_ME, 
    IDC_SETTINGS_GEN_COMPATWARNING, (DWORD)-1, 

    0, 0
};

BOOL IsUserAdmin(VOID);


/*--------------------------------------------------------------------------*
 *--------------------------------------------------------------------------*/
class CGeneralDlg {
    private:
        int _idCustomFonts;
        int _iDynaOrg;
        IUnknown * _punkSite;
        HWND _hwndFontList;
        HWND _hDlg;
        //
        // current log pixels of the screen.
        // does not change !
        int _cLogPix;
        BOOL _fForceSmallFont;
        BOOL _InitFontList();
        void _InitDynaCDSPreference();
        LRESULT _OnNotify(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

    public:
        CGeneralDlg(GENERAL_ADVDLG_INITPARAMS * pInitParams);
        void InitGeneralDlg(HWND hDlg);
        void SetFontSizeText( int cdpi );
        BOOL ChangeFontSize();
        void HandleGeneralApply(HWND hDlg);
        void HandleFontSelChange();
        void ForceSmallFont();
        LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

CGeneralDlg::CGeneralDlg(GENERAL_ADVDLG_INITPARAMS * pInitParams) : _fForceSmallFont(pInitParams->fFoceSmallFont), _idCustomFonts(-1)
{
    HKEY hkFont;
    DWORD cb;

    _punkSite = pInitParams->punkSite;

    // For font size just always use the one of the current screen.
    // Whether or not we are testing the current screen.
    _cLogPix = 96;

    // If the size does not match what is in the registry, then install
    // the new one
    if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      SZ_FONTDPI_PROF,
                      0,
                      KEY_READ,
                      &hkFont) == ERROR_SUCCESS) ||
        (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      SZ_FONTDPI,
                      0,
                      KEY_READ,
                      &hkFont) == ERROR_SUCCESS))

    {
        cb = sizeof(DWORD);

        if (RegQueryValueEx(hkFont,
                            SZ_LOGPIXELS,
                            NULL,
                            NULL,
                            (LPBYTE) &_cLogPix,
                            &cb) != ERROR_SUCCESS)
        {
            _cLogPix = 96;
        }

       RegCloseKey(hkFont);
    }
};

//
//  The purpose of this function is to check if the OriginalDPI value was already saved in the 
// per-machine part of the registry. If this is NOT present, then get the system DPI and save it 
// there. We want to do it just once for a machine. When an end-user logsin, we need to detect if
// we need to change the sizes of UI fonts based on DPI change. We use the "AppliedDPI", which is 
// stored on the per-user branch of the registry to determine the dpi change. If this "AppliedDPI"
// is missing, then this OriginalDPI value will be used. If this value is also missing, that 
// implies that nobody has changed the system DPI value.
//
void SaveOriginalDPI()
{
    //See if the "OriginalDPI value is present under HKEY_LOCAL_MACHINE.
    HKEY hk;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                     SZ_CONTROLPANEL,
                                     0,
                                     KEY_READ | KEY_WRITE,
                                     &hk) == ERROR_SUCCESS)
    {
        DWORD dwOriginalDPI;
        DWORD dwDataSize = sizeof(dwOriginalDPI);
        
        if (RegQueryValueEx(hk, SZ_ORIGINALDPI, NULL, NULL,
                            (LPBYTE)&dwOriginalDPI, &dwDataSize) != ERROR_SUCCESS)
        {
            //"OriginalDPI" value is not present in the registry. Now, get the DPI
            // and save it as the "OriginalDPI"
            HDC hdc = GetDC(NULL);
            dwOriginalDPI = GetDeviceCaps(hdc, LOGPIXELSY);
            ReleaseDC(NULL, hdc);
        }
            
        DWORD dwSize = sizeof(dwOriginalDPI);

        //Save the current DPI as the "OriginalDPI" value.
        RegSetValueEx(hk, SZ_ORIGINALDPI, NULL, REG_DWORD, (LPBYTE) &dwOriginalDPI, dwSize);
       
        RegCloseKey(hk);
    }
}

BOOL CGeneralDlg::ChangeFontSize()
{
    int cFontSize = 0;
    int cForcedFontSize;
    int cUIfontSize;

    // Change font size if necessary
    int i = ComboBox_GetCurSel(_hwndFontList);

    if (i != CB_ERR )
    {
        TCHAR awcDesc[10];

        cFontSize = (int)ComboBox_GetItemData(_hwndFontList, i);

        if ( (cFontSize != CB_ERR) &&
             (cFontSize != 0) &&
             (cFontSize != _cLogPix))
        {
            //Save the original DPI before the DPI ever changed.
            SaveOriginalDPI();
            
            cUIfontSize = cForcedFontSize = cFontSize;
            if (_idCustomFonts == i)
            {
                BOOL predefined = FALSE;
                int count = ComboBox_GetCount(_hwndFontList);
                int max = -1, min = 0xffff, dpi;
                for (i = 0; i < count; i++)
                {
                    if (i == _idCustomFonts) 
                        continue;

                    dpi  = (int)ComboBox_GetItemData(_hwndFontList, i);

                    if (dpi == cFontSize) 
                    {
                        predefined = TRUE;
                        break;
                    }

                    if (dpi < min) min = dpi;
                    if (dpi > max) max = dpi;
                }

                if (!predefined) {
                    if ((cFontSize > max) || (cFontSize + (max-min)/2 > max))
                        cForcedFontSize = max;
                    else 
                        cForcedFontSize = min;

                    // Currently our Custom font picker allows end-users to pick upto 500% of 
                    // normal font size; But, when we enlarge the UI fonts to this size, the 
                    // system becomes un-usable after reboot. So, what we do here is to allow
                    // ui font sizes to grow up to 200% and then all further increases are 
                    // proportionally reduced such that the maximum possible ui font size is only
                    // 250%. (i.e the range 200% to 500% is mapped on to a range of 200% to 250%)
                    // In other words, we allow upto 192 dpi (200%) with no modification. For any
                    // DPI greater than 192, we proportionately reduce it such that the highest DPI
                    // is only 240!
                    if(cUIfontSize > 192)
                        cUIfontSize = 192 + ((cUIfontSize - 192)/6);
                }
            }

            // Call setup to change the font size.
            wsprintf(awcDesc, TEXT("%d"), cForcedFontSize);
            if (SetupChangeFontSize(_hDlg, awcDesc) == NO_ERROR)
            {
                IPropertyBag * pPropertyBag;

                // Font change has succeeded; Now there is a new DPI to be applied to UI fonts!
                if (_punkSite && SUCCEEDED(GetPageByCLSID(_punkSite, &PPID_BaseAppearance, &pPropertyBag)))
                {
                    // Use _punkSite to push the DPI back up to the Appearance tab where it's state lives.
                    LogStatus("CGeneralDlg::ChangeFontSize() user changed DPI to %d\r\n", cUIfontSize);
                    SHPropertyBag_WriteInt(pPropertyBag, SZ_PBPROP_DPI_MODIFIED_VALUE, cUIfontSize);
                    pPropertyBag->Release();
                }
                
                // A font size change will require a system reboot.
                PropSheet_RestartWindows(GetParent(_hDlg));

                HrRegSetDWORD(HKEY_LOCAL_MACHINE, SZ_FONTDPI_PROF, SZ_LOGPIXELS, cFontSize);
                HrRegSetDWORD(HKEY_LOCAL_MACHINE, SZ_FONTDPI, SZ_LOGPIXELS, cFontSize);
            }
            else
            {
                // Setup failed.
                FmtMessageBox(_hDlg,
                              MB_ICONSTOP | MB_OK,
                              ID_DSP_TXT_CHANGE_FONT,
                              ID_DSP_TXT_ADMIN_INSTALL);

                return FALSE;
            }
        }
    }

    if (cFontSize == 0)
    {
        // If we could not read the inf, then ignore the font selection
        // and don't force the reboot on account of that.
        cFontSize = _cLogPix;
    }

    return TRUE;
}

void CGeneralDlg::InitGeneralDlg(HWND hDlg)
{
    _hDlg = hDlg;
    _hwndFontList = GetDlgItem(_hDlg, IDC_FONT_SIZE);
    _InitFontList();
    _iDynaOrg = -1;
}

void CGeneralDlg::_InitDynaCDSPreference()
{
    int iDyna = GetDynaCDSPreference();
    if(iDyna != _iDynaOrg)
    {
        _iDynaOrg = iDyna;

        CheckDlgButton(_hDlg, IDC_SHUTUP, FALSE);
        CheckDlgButton(_hDlg, IDC_YESDYNA, FALSE);
        CheckDlgButton(_hDlg, IDC_NODYNA, FALSE);

        if (_iDynaOrg & DCDSF_ASK)
            CheckDlgButton(_hDlg, IDC_SHUTUP, TRUE);
        else if (_iDynaOrg & DCDSF_DYNA)
            CheckDlgButton(_hDlg, IDC_YESDYNA, TRUE);
        else
            CheckDlgButton(_hDlg, IDC_NODYNA, TRUE);
    }
}


static UINT s_DPIDisplayNames[] =
{
    96 /*DPI*/,  IDS_SETTING_GEN_96DPI,
    120 /*DPI*/, IDS_SETTING_GEN_120DPI,
};

HRESULT _LoadDPIDisplayName(int nDPI, LPTSTR pszDisplayName, DWORD cchSize)
{
    HRESULT hr = E_FAIL;
    int nIndex;

    for (nIndex = 0; nIndex < ARRAYSIZE(s_DPIDisplayNames); nIndex += 2)
    {
        if (nDPI == (int)s_DPIDisplayNames[nIndex])
        {
            LoadString(HINST_THISDLL, s_DPIDisplayNames[nIndex + 1], pszDisplayName, cchSize);
            hr = S_OK;
            break;
        }
    }

    return hr;
}


// Init Font sizes 
//
// For NT:
// Read the supported fonts out of the inf file(s)
// Select was the user currently has.
//
// For WIN95:
BOOL CGeneralDlg::_InitFontList() {

    int i;
    ASSERT(_hwndFontList);
    ULONG uCurSel = (ULONG) -1;
    int cPix = 0;
    TCHAR szBuf2[100];

    HINF InfFileHandle;
    INFCONTEXT infoContext;

    //
    // Get all font entries from both inf files
    //

    InfFileHandle = SetupOpenInfFile(TEXT("font.inf"),
                                     NULL,
                                     INF_STYLE_WIN4,
                                     NULL);

    if (InfFileHandle != INVALID_HANDLE_VALUE)
    {
        if (SetupFindFirstLine(InfFileHandle,
                               TEXT("Font Sizes"),
                               NULL,
                               &infoContext))
        {
            for (;;)
            {
                TCHAR awcDesc[LINE_LEN];

                if (SetupGetStringField(&infoContext,
                                        0,
                                        awcDesc,
                                        ARRAYSIZE(awcDesc),
                                        NULL) &&
                    SetupGetIntField(&infoContext,
                                     1,
                                     &cPix))
                {
                    // Add it to the list box
                    _LoadDPIDisplayName(cPix, awcDesc, ARRAYSIZE(awcDesc));

                    i = ComboBox_AddString(_hwndFontList, awcDesc);
                    if (i != CB_ERR)
                    {
                        ComboBox_SetItemData(_hwndFontList, i, cPix);
                        if (_cLogPix == cPix)
                            uCurSel = i;
                    }
                }

                //
                // Try to get the next line.
                //

                if (!SetupFindNextLine(&infoContext,
                                       &infoContext))
                {
                    break;
                }
            }
        }

        SetupCloseInfFile(InfFileHandle);
    }

    //
    // Put in the custom fonts string
    //

    LoadString(HINST_THISDLL, ID_DSP_CUSTOM_FONTS, szBuf2, ARRAYSIZE(szBuf2));
    _idCustomFonts = ComboBox_AddString(_hwndFontList, szBuf2);

    if (_idCustomFonts != CB_ERR)
        ComboBox_SetItemData(_hwndFontList, _idCustomFonts, _cLogPix);
    
    if (uCurSel == (ULONG) -1) {
        uCurSel = _idCustomFonts;
    }


    // NOTE: We currently change the font size by calling SetupChangeFontSize
    // This function will fail if the user is not an administrator.  We would like to
    // disable this functionality but system admins want to be able to allow
    // non-admins to install by turning on a registry flag.  NT4 supports this,
    // so we need to also.  In order for this to work, we need to leave the
    // install button enabled.  This backs out NT #318617.  Contact
    // the following people about this issue: Marius Marin, Tom Politis,
    // Naresh Jivanji.     -BryanSt 3/24/2000
    // EnableWindow(_hwndFontList, IsUserAdmin());
    
    if (_fForceSmallFont && (_cLogPix == 96))
        this->ForceSmallFont();
    else
    {
        //
        // Select the right entry.
        //
        ComboBox_SetCurSel(_hwndFontList, uCurSel);
        this->SetFontSizeText( _cLogPix );
    }

    
    return TRUE;
}


void CGeneralDlg::SetFontSizeText( int cdpi )
{
    HWND hwndCustFontPer;
    TCHAR achStr[80];
    TCHAR achFnt[120];

    if (cdpi == CDPI_NORMAL)
    {
        LoadString(HINST_THISDLL, ID_DSP_NORMAL_FONTSIZE_TEXT, achStr, ARRAYSIZE(achStr));
        wsprintf(achFnt, achStr, cdpi);
    }
    else
    {
        LoadString(HINST_THISDLL, ID_DSP_CUSTOM_FONTSIZE_TEXT, achStr, ARRAYSIZE(achStr));
        wsprintf(achFnt, achStr, (100 * cdpi + 50) / CDPI_NORMAL, cdpi );
    }

    hwndCustFontPer = GetDlgItem(_hDlg, IDC_CUSTFONTPER);
    SendMessage(hwndCustFontPer, WM_SETTEXT, 0, (LPARAM)achFnt);
}


//
// ForceSmallFont method
//
//
void CGeneralDlg::ForceSmallFont() {
    int i, iSmall, dpiSmall, dpi;
    //
    // Set small font size in the listbox.
    //
    iSmall = CB_ERR;
    dpiSmall = 9999;
    for (i=0; i <=1; i++)
    {
        dpi = (int)ComboBox_GetItemData(_hwndFontList, i);
        if (dpi == CB_ERR)
            continue;

        if (dpi < dpiSmall || iSmall < CB_ERR)
        {
            iSmall = i;
            dpiSmall = dpi;
        }
    }

    if (iSmall != -1)
        ComboBox_SetCurSel(_hwndFontList, iSmall);
    this->SetFontSizeText(dpiSmall);
    EnableWindow(_hwndFontList, FALSE);
}

void CGeneralDlg::HandleGeneralApply(HWND hDlg)
{
    int iDynaNew;

    if (IsDlgButtonChecked(hDlg, IDC_YESDYNA))
        iDynaNew= DCDSF_YES;
    else if (IsDlgButtonChecked(hDlg, IDC_NODYNA))
        iDynaNew= DCDSF_NO;
    else
        iDynaNew = DCDSF_PROBABLY;

    if (iDynaNew != _iDynaOrg)
    {
        SetDisplayCPLPreference(REGSTR_VAL_DYNASETTINGSCHANGE, iDynaNew);
        _iDynaOrg = iDynaNew;
    }

    BOOL bSuccess = ChangeFontSize();
    
    long lRet = (bSuccess ? PSNRET_NOERROR: PSNRET_INVALID_NOCHANGEPAGE);
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lRet);
}

void CGeneralDlg::HandleFontSelChange()
{
    //
    // Warn the USER font changes will not be seen until after
    // reboot
    //
    int iCurSel;
    int cdpi;

    iCurSel = ComboBox_GetCurSel(_hwndFontList);
    cdpi = (int)ComboBox_GetItemData(_hwndFontList, iCurSel);
    if (iCurSel == _idCustomFonts) {

        InitDragSizeClass();
        cdpi = (int)DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_CUSTOMFONT),
                              _hDlg, CustomFontDlgProc, cdpi );
        if (cdpi != 0)
            ComboBox_SetItemData(_hwndFontList, _idCustomFonts, cdpi);
        else
            cdpi = (int)ComboBox_GetItemData(_hwndFontList, _idCustomFonts);
    }

    if (cdpi != _cLogPix)
    {
        // Remove in blackcomb.  We need to streamline this process.  That includes verifying that
        // the fonts will always be on disk and there is no need to allow users to get them from
        // the CD.
        FmtMessageBox(_hDlg,
                      MB_ICONINFORMATION,
                      ID_DSP_TXT_CHANGE_FONT,
                      ID_DSP_TXT_FONT_LATER);
        PropSheet_Changed(GetParent(_hDlg), _hDlg);
    }

    this->SetFontSizeText(cdpi);
}

void StartStopQuickRes(HWND hDlg, BOOL fEnable)
{
    HWND hwnd;

TryAgain:
    hwnd = FindWindow(sc_szQuickResClass, NULL);

    if (fEnable)
    {
        if (!hwnd)
            WinExec(c_szQuickResCommandLine, SW_SHOWNORMAL);

        return;
    }

    if (hwnd)
    {
        SendMessage(hwnd, WM_CLOSE, 0, 0L);
        goto TryAgain;
    }
}


LRESULT CGeneralDlg::_OnNotify(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lReturn = TRUE;
    NMHDR *lpnm = (NMHDR *)lParam;

    if (lParam)
    {
        switch (lpnm->code)
        {
        case PSN_SETACTIVE:
            _InitDynaCDSPreference();
            break;
        case PSN_APPLY:
            HandleGeneralApply(hDlg);
            break;
        case NM_RETURN:
        case NM_CLICK:
        {
            PNMLINK pNMLink = (PNMLINK) lpnm;

            if (!StrCmpW(pNMLink->item.szID, L"idGameCompat"))
            {
                TCHAR szHelpURL[MAX_PATH * 2];

                LoadString(HINST_THISDLL, IDS_SETTING_GEN_COMPAT_HELPLINK, szHelpURL, ARRAYSIZE(szHelpURL));
                HrShellExecute(hDlg, NULL, szHelpURL, NULL, NULL, SW_NORMAL);
            }
            break;
        }
        default:
            lReturn = FALSE;
            break;
        }
    }

    return lReturn;
}

LRESULT CALLBACK CGeneralDlg::WndProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lReturn = TRUE;

    switch (message)
    {
    case WM_INITDIALOG:
        InitGeneralDlg(hDlg);
        break;

    case WM_NOTIFY:
        lReturn = _OnNotify(hDlg, message, wParam, lParam);
        break;
        
    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
            case IDC_NODYNA:
            case IDC_YESDYNA:
            case IDC_SHUTUP:
                if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
                    PropSheet_Changed(GetParent(hDlg), hDlg);
                break;
            case IDC_FONT_SIZE:
                switch (GET_WM_COMMAND_CMD(wParam, lParam))
                {
                    case CBN_SELCHANGE:
                        HandleFontSelChange();
                        break;
                    default:
                        break;
                }
                break;

            default:
                break;
        }
        break;
        
    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, TEXT("display.hlp"), HELP_WM_HELP,
            (DWORD_PTR)(LPTSTR)sc_GeneralHelpIds);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, TEXT("display.hlp"), HELP_CONTEXTMENU,
            (DWORD_PTR)(LPTSTR)sc_GeneralHelpIds);
        break;
  
    default:
        return FALSE;
    }

    return lReturn;
}

//-----------------------------------------------------------------------------
//
// Callback functions PropertySheet can use
//
INT_PTR CALLBACK
GeneralPageProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CGeneralDlg * pcgd = (CGeneralDlg * )GetWindowLongPtr(hDlg, DWLP_USER);
    switch (message)
    {
        case WM_INITDIALOG:
            ASSERT(!pcgd);
            ASSERT(lParam);

            if (((LPPROPSHEETPAGE)lParam)->lParam)
            {
                GENERAL_ADVDLG_INITPARAMS * pInitParams = (GENERAL_ADVDLG_INITPARAMS *) ((LPPROPSHEETPAGE)lParam)->lParam;
                pcgd = new CGeneralDlg(pInitParams);
                if(pcgd)
                {
                    // now we need to init
                    pcgd->InitGeneralDlg(hDlg);
                    SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pcgd);
                    return TRUE;
                }
            }

            break;
            
        case WM_DESTROY:
            if (pcgd)
            {
                SetWindowLongPtr(hDlg, DWLP_USER, NULL);
                delete pcgd;
            }
            break;

        default:
            if (pcgd)
                return pcgd->WndProc(hDlg, message, wParam, lParam);
            break;
    }

    return FALSE;
}


/*--------------------------------------------------------------------------*
 *--------------------------------------------------------------------------*/
INT_PTR CALLBACK AskDynaCDSProc(HWND hDlg, UINT msg, WPARAM wp, LPARAM lp)
{
    int *pTemp;

    switch (msg)
    {
    case WM_INITDIALOG:
        if ((pTemp = (int *)lp) != NULL)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pTemp);
            CheckDlgButton(hDlg, (*pTemp & DCDSF_DYNA)?
                IDC_YESDYNA : IDC_NODYNA, BST_CHECKED);
        }
        else
            EndDialog(hDlg, -1);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wp, lp))
        {
        case IDOK:
            if ((pTemp = (int *)GetWindowLongPtr(hDlg, DWLP_USER)) != NULL)
            {
                *pTemp = IsDlgButtonChecked(hDlg, IDC_YESDYNA)? DCDSF_DYNA : 0;

                if (!IsDlgButtonChecked(hDlg, IDC_SHUTUP))
                    *pTemp |= DCDSF_ASK;

                SetDisplayCPLPreference(REGSTR_VAL_DYNASETTINGSCHANGE, *pTemp);
            }

            EndDialog(hDlg, TRUE);
            break;

        case IDCANCEL:

            EndDialog(hDlg, FALSE);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


int  AskDynaCDS(HWND hOwner)
{
    int val = GetDynaCDSPreference();

    if (val & DCDSF_ASK)
    {
        switch (DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_ASKDYNACDS),
            hOwner, AskDynaCDSProc, (LPARAM)(int *)&val))
        {
        case 0:         // user cancelled
            return -1;

        case -1:        // dialog could not be displayed
            val = DCDSF_NO;
            break;
        }
    }

    return ((val & DCDSF_DYNA) == DCDSF_DYNA);
}


BOOL IsUserAdmin(VOID)

/*++

Routine Description:

    This routine returns TRUE if the caller is an administrator.

--*/

{
    BOOL bStatus = FALSE, bIsAdmin = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsSid;

    bStatus = AllocateAndInitializeSid(&NtAuthority,
                                        2,
                                        SECURITY_BUILTIN_DOMAIN_RID,
                                        DOMAIN_ALIAS_RID_ADMINS,
                                        0, 0, 0, 0, 0, 0,
                                        &AdministratorsSid);
    if (bStatus)
    {
        bStatus = CheckTokenMembership(NULL, AdministratorsSid, &bIsAdmin);

        FreeSid(AdministratorsSid);
    }

    return (bStatus && bIsAdmin);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\makefile.inc ===
resource.rc : $(PROJECT_ROOT)\lib\$(O)\Theme.tlb $(SELFREGNAME)

$(SELFREGNAME) : selfreg.inx
        $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS:-DNT =) $** > $*.cln
        $(CLEANINF) $*.cln $@
        del $*.cln
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\guids.cpp ===
/*****************************************************************************\
    FILE: guids.cpp

    DESCRIPTION:
        This file contains GUIDs that we couldn't get from the public headers
    for one reason or another.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/


#define INITGUID
#include "guids.h"

#include "priv.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\guids.h ===
/*****************************************************************************\
    FILE: guids.h

    DESCRIPTION:
        This file contains GUIDs that we couldn't get from the public headers
    for one reason or another.

    BryanSt 8/13/1999
    Copyright (C) Microsoft Corp 1999-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif


#undef MIDL_DEFINE_GUID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\ntreg.cpp ===
/**************************************************************************\
* Module Name: ntreg.cpp
*
* CRegistrySettings class
*
*  This class handles getting registry information for display driver
*  information.
*
* Copyright (c) Microsoft Corp.  1992-1998 All Rights Reserved
*
\**************************************************************************/

#include "priv.h"
#include <tchar.h>
#include "ntreg.hxx"
#include <devguid.h>

//
// CRegistrySettings constructor
//

CRegistrySettings::CRegistrySettings(LPTSTR pstrDeviceKey)
    : _hkVideoReg(NULL)
    , _pszDrvName(NULL)
    , _pszKeyName(NULL)
    , _pszDeviceInstanceId(NULL)
    , _dwDevInst(0)
{
    TCHAR szBuffer[MAX_PATH];
    LPTSTR pszPath;
    HKEY hkeyCommon, hkeyDriver;
    DWORD cb;
    LPTSTR pszName = NULL;
    LPTSTR pszEnd;

    ASSERT(lstrlen(pstrDeviceKey) < MAX_PATH);
    
    //
    // Copy the data to local buffer.
    //

    lstrcpy(szBuffer, pstrDeviceKey);

    //
    // Initialize the device instance id
    // 
    
    InitDeviceInstanceID(szBuffer);

    //
    // At this point, szBuffer has something like:
    //  \REGISTRY\Machine\System\ControlSet001\...
    //
    // To use the Win32 registry calls, we have to strip off the \REGISTRY
    // and convert \Machine to HKEY_LOCAL_MACHINE
    //

    pszPath = SubStrEnd(SZ_REGISTRYMACHINE, szBuffer);

    //
    // Try to open the registry key
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     pszPath,
                     0,
                     KEY_READ,
                     &_hkVideoReg) != ERROR_SUCCESS) {

        _hkVideoReg = 0;
    }

    //
    // Go to the video subkey
    //

    pszEnd = pszPath + lstrlen(pszPath);

    while (pszEnd != pszPath && *pszEnd != TEXT('\\')) {

        pszEnd--;
    }

    *pszEnd = UNICODE_NULL;

    lstrcat(pszPath, SZ_COMMON_SUBKEY);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     pszPath,
                     0,
                     KEY_READ,
                     &hkeyCommon) == ERROR_SUCCESS) {

        cb = sizeof(szBuffer);
        ZeroMemory(szBuffer, cb);

        if (RegQueryValueEx(hkeyCommon,
                            SZ_SERVICE,
                            NULL,
                            NULL,
                            (LPBYTE)szBuffer,
                            &cb) == ERROR_SUCCESS) {

            //
            // Save the key name
            //

            _pszKeyName = (LPTSTR)LocalAlloc(LPTR, 
                                             (lstrlen(szBuffer) + 1) * sizeof(TCHAR));

            if (_pszKeyName != NULL) {

                lstrcpy(_pszKeyName, szBuffer);
            
                lstrcpy(szBuffer, SZ_SERVICES_PATH);
                lstrcat(szBuffer, _pszKeyName);

                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 szBuffer,
                                 0,
                                 KEY_READ,
                                 &hkeyDriver) == ERROR_SUCCESS) {
        
                    cb = sizeof(szBuffer);
                    ZeroMemory(szBuffer, cb);

                    if (RegQueryValueEx(hkeyDriver,
                                        L"ImagePath",
                                        NULL,
                                        NULL,
                                        (LPBYTE)szBuffer,
                                        &cb) == ERROR_SUCCESS) {
        
                        //
                        // This is a binary.
                        // Extract the name, which will be of the form ...\driver.sys
                        //
        
                        LPTSTR pszDriver, pszDriverEnd;
    
                        pszDriver = szBuffer;
                        pszDriverEnd = pszDriver + lstrlen(pszDriver);
    
                        while(pszDriverEnd != pszDriver &&
                              *pszDriverEnd != TEXT('.')) {
                            pszDriverEnd--;
                        }
    
                        *pszDriverEnd = UNICODE_NULL;
    
                        while(pszDriverEnd != pszDriver &&
                              *pszDriverEnd != TEXT('\\')) {
                            pszDriverEnd--;
                        }
    
                        //
                        // If pszDriver and pszDriverEnd are different, we now
                        // have the driver name.
                        //
    
                        if (pszDriverEnd > pszDriver) {
                            
                            pszDriverEnd++;
                            pszName = pszDriverEnd;
    
                        }
                    }
        
                    RegCloseKey(hkeyDriver);
                }
            
                if (!pszName) {

                    //
                    // Something failed trying to get the binary name.just get the device name
                    //

                    _pszDrvName = _pszKeyName;

                } else {

                    _pszDrvName = (LPTSTR)LocalAlloc(LPTR,
                                                     (lstrlen(pszName) + 1) * sizeof(TCHAR));

                    if (_pszDrvName != NULL) {

                        lstrcpy(_pszDrvName, pszName);

                    }
                }
            }
        }

        RegCloseKey(hkeyCommon);
    }
}

//
// CRegistrySettings destructor
//

CRegistrySettings::~CRegistrySettings() 
{
    //
    // Close the registry
    //

    if (_hkVideoReg) {
        RegCloseKey(_hkVideoReg);
    }

    //
    // Free the strings
    //
    if (_pszKeyName) {
        LocalFree(_pszKeyName);
    }

    if ((_pszKeyName != _pszDrvName) && _pszDrvName) {
        LocalFree(_pszDrvName);
    }

    if(_pszDeviceInstanceId) {
        LocalFree(_pszDeviceInstanceId);
    }
}


//
// Method to get the hardware information fields.
//

VOID
CRegistrySettings::GetHardwareInformation(
    PDISPLAY_REGISTRY_HARDWARE_INFO pInfo)
{

    DWORD cb, dwType;
    DWORD i;
    LONG lRet;

    LPWSTR pKeyNames[5] = {
        L"HardwareInformation.MemorySize",
        L"HardwareInformation.ChipType",
        L"HardwareInformation.DacType",
        L"HardwareInformation.AdapterString",
        L"HardwareInformation.BiosString"
    };

    ZeroMemory(pInfo, sizeof(DISPLAY_REGISTRY_HARDWARE_INFO));

    //
    // Query each entry one after the other.
    //

    for (i = 0; i < 5; i++) {

        //
        // query the size of the string
        //

        cb = 256;
        lRet = RegQueryValueExW(_hkVideoReg,
                                pKeyNames[i],
                                NULL,
                                &dwType,
                                NULL,
                                &cb);

        if (lRet == ERROR_SUCCESS) {

            if (i == 0) {

                ULONG mem;

                cb = 4;

                RegQueryValueExW(_hkVideoReg,
                                 pKeyNames[i],
                                 NULL,
                                 &dwType,
                                 (PUCHAR) (&mem),
                                 &cb);

                //
                // If we queried the memory size, we actually have
                // a DWORD.  Transform the DWORD to a string
                //

                // Divide down to Ks

                mem =  mem >> 10;

                // if a MB multiple, divide again.

                if ((mem & 0x3FF) != 0) {

                    wsprintf((LPWSTR)pInfo, L"%d KB", mem );

                } else {

                    wsprintf((LPWSTR)pInfo, L"%d MB", mem >> 10 );

                }

            } else {

                cb = 256;

                //
                // get the string
                //

                RegQueryValueExW(_hkVideoReg,
                                 pKeyNames[i],
                                 NULL,
                                 &dwType,
                                 (LPBYTE) pInfo,
                                 &cb);

            }
        }
        else
        {
            //
            // Put in the default string
            //

            LoadString(HINST_THISDLL,
                       IDS_UNAVAILABLE,
                       (LPWSTR)pInfo,
                       256);
        }

        pInfo = (PDISPLAY_REGISTRY_HARDWARE_INFO)((PUCHAR)pInfo + 256);
    }


    return;
}


VOID CRegistrySettings::InitDeviceInstanceID(
    LPTSTR pstrDeviceKey
    ) 
{
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE ;
    SP_DEVINFO_DATA DevInfoData;
    ULONG InstanceIDSize = 0;
    BOOL bSuccess = FALSE;
    LPWSTR pwInterfaceName = NULL;
    LPWSTR pwInstanceID = NULL;

    ASSERT (pstrDeviceKey != NULL);
    ASSERT (_pszDeviceInstanceId == NULL);

    if (AllocAndReadInterfaceName(pstrDeviceKey, &pwInterfaceName)) {

        bSuccess = GetDevInfoDataFromInterfaceName(pwInterfaceName,
                                                   &hDevInfo,
                                                   &DevInfoData);
        if (bSuccess) {

            InstanceIDSize = 0;

            bSuccess = 

                ((CM_Get_Device_ID_Size(&InstanceIDSize, 
                                        DevInfoData.DevInst, 
                                        0) == CR_SUCCESS) &&

                 ((_pszDeviceInstanceId = (LPTSTR)LocalAlloc(LPTR, 
                     (InstanceIDSize + 1) * sizeof(TCHAR))) != NULL) &&

                 (CM_Get_Device_ID(DevInfoData.DevInst, 
                                   _pszDeviceInstanceId,
                                   InstanceIDSize,
                                   0) == CR_SUCCESS));

            if (bSuccess) {

                _dwDevInst = DevInfoData.DevInst;
            
            } else {

                //
                // Clean-up
                //

                if (NULL != _pszDeviceInstanceId) {
                    LocalFree(_pszDeviceInstanceId);
                    _pszDeviceInstanceId = NULL;
                }
            }

            SetupDiDestroyDeviceInfoList(hDevInfo);
        }

        LocalFree(pwInterfaceName);
    }

    if ((!bSuccess) &&
        AllocAndReadInstanceID(pstrDeviceKey, &pwInstanceID)) {

#ifdef UNICODE
        _pszDeviceInstanceId = pwInstanceID;
#else
        SIZE_T cch = wcslen(pwInstanceID) + 1;
        _pszDeviceInstanceId = LocalAlloc(LPTR, cch);
        if (_pszDeviceInstanceId != NULL) {
            WideCharToMultiByte(CP_ACP, 0, 
                                pwInstanceID, -1, 
                                _pszDeviceInstanceId, 
                                cch, NULL, NULL);
        }

        LocalFree(pwInstanceID);
#endif

    }

} // InitDeviceInstanceID


BOOL
CRegistrySettings::GetDevInfoDataFromInterfaceName(
    IN  LPWSTR pwInterfaceName,
    OUT HDEVINFO* phDevInfo,
    OUT PSP_DEVINFO_DATA pDevInfoData
    )

/*

    Note: If this function retuns success, the caller is responsible
          to destroy the device info list returned in phDevInfo

*/

{
    LPWSTR pwDevicePath = NULL;
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA DevInfoData;
    SP_DEVICE_INTERFACE_DATA InterfaceData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA pInterfaceDetailData = NULL;
    DWORD InterfaceIndex = 0;
    DWORD InterfaceSize = 0;
    BOOL bMatch = FALSE;

    ASSERT (pwInterfaceName != NULL);
    ASSERT (phDevInfo != NULL);
    ASSERT (pDevInfoData != NULL);

    //
    // Enumerate all display adapter interfaces
    //

    hDevInfo = SetupDiGetClassDevs(&GUID_DISPLAY_ADAPTER_INTERFACE,
                                   NULL,
                                   NULL,
                                   DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);

    if (hDevInfo == INVALID_HANDLE_VALUE) {
        goto Cleanup;
    }

    InterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
    while (SetupDiEnumDeviceInterfaces(hDevInfo,
                                       NULL,
                                       &GUID_DISPLAY_ADAPTER_INTERFACE,
                                       InterfaceIndex,
                                       &InterfaceData)) {

        //
        // Get the required size for the interface
        //

        InterfaceSize = 0;
        SetupDiGetDeviceInterfaceDetail(hDevInfo,
                                        &InterfaceData,
                                        NULL,
                                        0,
                                        &InterfaceSize,
                                        NULL);

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto Cleanup;
        }

        //
        // Alloc memory for the interface
        //

        pInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)
            LocalAlloc(LPTR, InterfaceSize);
        if (pInterfaceDetailData == NULL)
            goto Cleanup;

        //
        // Get the interface
        //

        pInterfaceDetailData->cbSize =
            sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
        DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        if (SetupDiGetDeviceInterfaceDetail(hDevInfo,
                                            &InterfaceData,
                                            pInterfaceDetailData,
                                            InterfaceSize,
                                            &InterfaceSize,
                                            &DevInfoData)) {

            //
            // Is the InterfaceName the same as the DevicePath?
            //

#ifdef UNICODE
            pwDevicePath = pInterfaceDetailData->DevicePath;
#else
            {
                SIZE_T cch = strlen(pInterfaceDetailData->DevicePath) + 1;
                pwDevicePath = LocalAlloc(LPTR, cch * sizeof(WCHAR));
                if (pwDevicePath == NULL) {
                    goto Cleanup;
                }
                MultiByteToWideChar(CP_ACP, 0,
                                    pInterfaceDetailData->DevicePath,
                                    -1, pwDevicePath, cch);
            }
#endif

            //
            // The first 4 characters of the interface name are different
            // between user mode and kernel mode (e.g. "\\?\" vs "\\.\")
            // Therefore, ignore them.
            //

            bMatch = (_wcsnicmp(pwInterfaceName + 4,
                                pwDevicePath + 4,
                                wcslen(pwInterfaceName + 4)) == 0);

#ifndef UNICODE
            LocalFree(pwDevicePath);
            pwDevicePath = NULL;
#endif

            if (bMatch) {

                //
                // We found the device
                //

                *phDevInfo = hDevInfo;
                CopyMemory(pDevInfoData, &DevInfoData, sizeof(SP_DEVINFO_DATA));

                break;
            }
        }

        //
        // Clean-up
        //

        LocalFree(pInterfaceDetailData);
        pInterfaceDetailData = NULL;

        //
        // Next interface ...
        //

        InterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
        ++InterfaceIndex;
    }

Cleanup:

    if (pInterfaceDetailData != NULL) {
        LocalFree(pInterfaceDetailData);
    }

    //
    // Upon success, the caller is responsible to destroy the list
    //

    if (!bMatch && (hDevInfo != INVALID_HANDLE_VALUE)) {
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }

    return bMatch;
}


HKEY
CRegistrySettings::OpenDrvRegKey()
{
    HKEY hkDriver = (HKEY)INVALID_HANDLE_VALUE;
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA did;
    DWORD index = 0;

    if (_dwDevInst == 0) {
        goto Fallout;
    }

    hDevInfo = SetupDiGetClassDevs((LPGUID) &GUID_DEVCLASS_DISPLAY,
                                   NULL,
                                   NULL,
                                   0);
    
    if (hDevInfo == INVALID_HANDLE_VALUE) {
        goto Fallout;
    }

    ZeroMemory(&did, sizeof(SP_DEVINFO_DATA));
    did.cbSize = sizeof(SP_DEVINFO_DATA);

    while (SetupDiEnumDeviceInfo(hDevInfo, index, &did)) {
    
        if (did.DevInst == _dwDevInst) {

            hkDriver = SetupDiOpenDevRegKey(hDevInfo,
                                            &did,
                                            DICS_FLAG_GLOBAL,
                                            0,
                                            DIREG_DRV ,
                                            KEY_ALL_ACCESS);
            break;
        }

        did.cbSize = sizeof(SP_DEVINFO_DATA);
        index++;
    }

Fallout:
    
    if (hDevInfo != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }

    return hkDriver;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\previewsm.h ===
/*****************************************************************************\
    FILE: PreviewSM.h

    DESCRIPTION:
        This code will display a preview of system metrics.
    NOTE: This code will >hand< draw all the window controls, so if
    windows changes the way the windows controls are draw, this code
    needs to be manually updated.  This is an issue for skinning.

    BryanSt 4/4/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _PREVIEWSYSTEMMETRICS_H
#define _PREVIEWSYSTEMMETRICS_H

#include "regutil.h"


#define PREVIEWSM_CLASSA        "PreviewSystemMetrics"
#define PREVIEWSM_CLASS         TEXT(PREVIEWSM_CLASSA)



#define FONT_NONE   -1
#define FONT_CAPTION    0
#define FONT_SMCAPTION  1
#define FONT_MENU   2
#define FONT_ICONTITLE  3
#define FONT_STATUS 4
#define FONT_MSGBOX 5

#define NUM_FONTS   6
typedef struct {
    HFONT hfont;
    LOGFONT lf;
} LOOK_FONT;
extern LOOK_FONT g_fonts[];

#define COLOR_NONE  -1
extern COLORREF g_rgb[];extern HBRUSH g_brushes[];
extern HPALETTE g_hpal3D;

#define SIZE_NONE   -1
#define SIZE_FRAME  0
#define SIZE_SCROLL 1
#define SIZE_CAPTION    2
#define SIZE_SMCAPTION  3
#define SIZE_MENU   4
#define SIZE_DXICON     5
#define SIZE_DYICON     6
#define SIZE_ICON       7
#define SIZE_SMICON     8

#define NUM_SIZES   9

typedef struct {
    int CurSize;
    int MinSize;
    int MaxSize;
} LOOK_SIZE;
extern LOOK_SIZE g_sizes[];

typedef struct {
    int iMainColor;
    int iSize;
    BOOL fLinkSizeToFont;
    int iTextColor;
    int iFont;
    int iResId;     // id of name in resource (or -1 if duplicate)
    int iBaseElement;   // index of element that this overlaps (or -1)
    int iGradientColor; // index of element for Gradient Caption Bar (or -1)
    RECT rc;
} LOOK_ELEMENT;

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//this order has to match the array order in lookdlg.c
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
enum _ELEMENTS {
    ELEMENT_APPSPACE = 0,
    ELEMENT_DESKTOP,                // 1
    ELEMENT_INACTIVEBORDER,         // 2
    ELEMENT_ACTIVEBORDER,           // 3
    ELEMENT_INACTIVECAPTION,        // 4
    ELEMENT_INACTIVESYSBUT1,        // 5
    ELEMENT_INACTIVESYSBUT2,        // 6
    ELEMENT_ACTIVECAPTION,          // 7
    ELEMENT_ACTIVESYSBUT1,          // 8
    ELEMENT_ACTIVESYSBUT2,          // 9
    ELEMENT_MENUNORMAL,             // 10
    ELEMENT_MENUSELECTED,           // 11
    ELEMENT_MENUDISABLED,           // 12
    ELEMENT_WINDOW,                 // 13
    ELEMENT_MSGBOX,                 // 14
    ELEMENT_MSGBOXCAPTION,          // 15
    ELEMENT_MSGBOXSYSBUT,           // 16
    ELEMENT_SCROLLBAR,              // 17
    ELEMENT_SCROLLUP,               // 18
    ELEMENT_SCROLLDOWN,             // 19
    ELEMENT_BUTTON,                 // 20
    ELEMENT_SMCAPTION,              // 21
    ELEMENT_ICON,                   // 22
    ELEMENT_ICONHORZSPACING,        // 23
    ELEMENT_ICONVERTSPACING,        // 24
    ELEMENT_INFO                    // 25
};
// BOGUS:  need to get a size from somewhere
#define NUM_ELEMENTS ELEMENT_INFO+1

#if 0
// go fix lookdlg.cpp if you decide to add this back in
    ELEMENT_SMICON,
#endif


#define CPI_VGAONLY 0x0001
#define CPI_PALETTEOK   0x0002

typedef struct {
    HWND hwndParent;    // parent for any modal dialogs (choosecolor et al)
    HWND hwndOwner;     // control that owns mini color picker
    COLORREF rgb;
    UINT flags;
    HPALETTE hpal;
} COLORPICK_INFO, FAR * LPCOLORPICK_INFO;

#define WM_RECREATEBITMAP (WM_USER)
extern int cyBorder;
extern int cxBorder;
extern int cyEdge;
extern int cxEdge;

// NOTE: the order in g_elements must match the enum order above
extern LOOK_ELEMENT g_elements[];

BOOL RegisterPreviewSystemMetricClass(HINSTANCE hInst);
BOOL WINAPI ChooseColorMini(LPCOLORPICK_INFO lpcpi);
DWORD FAR PASCAL AdjustLuma(DWORD rgb, int n, BOOL fScale);
BOOL CreateGlobals(void);

HRESULT DrawAppearance(HDC hdc, LPRECT prc, SYSTEMMETRICSALL* psysMet, BOOL fOnlyShowActiveWindow, BOOL fRTL);

extern HDC g_hdcMem;


// Macro to replace MAKEPOINT() since points now have 32 bit x & y
#define LPARAM2POINT( lp, ppt ) \
    ((ppt)->x = (int)(short)LOWORD(lp), (ppt)->y = (int)(short)HIWORD(lp))

#define CCH_MAX_STRING    256
#define CCH_NONE          20        /* ARRAYSIZE( "(None)" ), big enough for German */



#endif // _PREVIEWSYSTEMMETRICS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\previewsm.cpp ===
/*****************************************************************************\
    FILE: PreviewSM.cpp

    DESCRIPTION:
        This code will display a preview of system metrics.
    NOTE: This code will >hand< draw all the window controls, so if
    windows changes the way the windows controls are draw, this code
    needs to be manually updated.  This is an issue for skinning.

    ??????? ?/??/1993    Created
    BryanSt 3/23/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 1993-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "PreviewSM.h"
#include "AdvAppearPg.h"


#define RCZ(element)         g_elements[element].rc

TCHAR g_szActive[CCH_MAX_STRING];
TCHAR g_szInactive[CCH_MAX_STRING];
TCHAR g_szMinimized[CCH_MAX_STRING];
TCHAR g_szIconTitle[CCH_MAX_STRING];
TCHAR g_szNormal[CCH_MAX_STRING];
TCHAR g_szDisabled[CCH_MAX_STRING];
TCHAR g_szSelected[CCH_MAX_STRING];
TCHAR g_szMsgBox[CCH_MAX_STRING];
TCHAR g_szButton[CCH_MAX_STRING];
//TCHAR g_szSmallCaption[40];
TCHAR g_szWindowText[CCH_MAX_STRING];
TCHAR g_szMsgBoxText[CCH_MAX_STRING];
TCHAR g_szABC[] = TEXT("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");

int cxSize;

HMENU g_hmenuSample;
HBITMAP g_hbmLook = NULL;       // bitmap for the appearance preview
int g_nBitsPixel = 0;   // bits pizel for the appearance preview

HDC g_hdcMem;
HBITMAP g_hbmDefault;
BOOL g_bMirroredOS = FALSE;

int cyBorder;
int cxBorder;
int cyEdge;
int cxEdge;












//===========================
// *** Class Internals & Helpers ***
//===========================
// Note that the rectangles are defined back to front.  So we walk through
// the list backwards, checking PtInRect() until we find a match.
int LookPrev_HitTest(POINT pt)
{
    int i;

    // start with last, don't bother with 0 (desktop)... it's the fallback
    for (i = NUM_ELEMENTS - 1; i > 0; i--)
    {
        if (PtInRect(&RCZ(i), pt))
        {
            break;
        }
    }

    // if the chosen one is really a dupe of another, use the base one
    if (g_elements[i].iBaseElement != -1)
    {
        i = g_elements[i].iBaseElement;
    }

    return i;
}


HRESULT CAdvAppearancePage::_OnNCCreate(HWND hWnd)
{
    DWORD dwWindowStyles = GetWindowLong(hWnd, GWL_STYLE);

    SetWindowLong(hWnd, GWL_STYLE, dwWindowStyles | WS_BORDER);
    dwWindowStyles = GetWindowLong(hWnd,GWL_EXSTYLE);
    SetWindowLong(hWnd, GWL_EXSTYLE, dwWindowStyles | WS_EX_CLIENTEDGE);

    return S_OK;
}


HRESULT CAdvAppearancePage::_OnCreatePreviewSMDlg(LPRECT prc, BOOL fRTL)
{
    cyBorder = ClassicGetSystemMetrics(SM_CYBORDER);
    cxBorder = ClassicGetSystemMetrics(SM_CXBORDER);
    cyEdge = ClassicGetSystemMetrics(SM_CXEDGE);
    cxEdge = ClassicGetSystemMetrics(SM_CYEDGE);

    _InitPreview(prc, fRTL);
    return S_OK;
}


// ----------------------------------------------------------------------------
// create the preview bitmap and collect all of the global, non-changing data
// ----------------------------------------------------------------------------
void CAdvAppearancePage::_InitPreview(LPRECT prc, BOOL fRTL)
{
    RECT rc;
    HDC hdc;

    rc = *prc;
    hdc = GetDC(NULL);
    g_nBitsPixel = GetDeviceCaps(hdc, BITSPIXEL);
    g_hbmLook = CreateCompatibleBitmap(hdc, rc.right - rc.left, rc.bottom - rc.top);
    ReleaseDC(NULL, hdc);

    // Load our display strings.
    LoadString(HINST_THISDLL, IDS_ACTIVE, g_szActive, ARRAYSIZE(g_szActive));
    LoadString(HINST_THISDLL, IDS_INACTIVE, g_szInactive, ARRAYSIZE(g_szInactive));
    LoadString(HINST_THISDLL, IDS_MINIMIZED, g_szMinimized, ARRAYSIZE(g_szMinimized));
    LoadString(HINST_THISDLL, IDS_ICONTITLE, g_szIconTitle, ARRAYSIZE(g_szIconTitle));
    LoadString(HINST_THISDLL, IDS_NORMAL, g_szNormal, ARRAYSIZE(g_szNormal));
    LoadString(HINST_THISDLL, IDS_DISABLED, g_szDisabled, ARRAYSIZE(g_szDisabled));
    LoadString(HINST_THISDLL, IDS_SELECTED, g_szSelected, ARRAYSIZE(g_szSelected));
    LoadString(HINST_THISDLL, IDS_MSGBOX, g_szMsgBox, ARRAYSIZE(g_szMsgBox));
    LoadString(HINST_THISDLL, IDS_BUTTONTEXT, g_szButton, ARRAYSIZE(g_szButton));
//    LoadString(HINST_THISDLL, IDS_SMCAPTION, g_szSmallCaption, ARRAYSIZE(g_szSmallCaption));
    LoadString(HINST_THISDLL, IDS_WINDOWTEXT, g_szWindowText, ARRAYSIZE(g_szWindowText));
    LoadString(HINST_THISDLL, IDS_MSGBOXTEXT, g_szMsgBoxText, ARRAYSIZE(g_szMsgBoxText));

    // load up and
    g_hmenuSample = LoadMenu(HINST_THISDLL, MAKEINTRESOURCE(IDR_MENU));
    EnableMenuItem(g_hmenuSample, IDM_DISABLED, MF_GRAYED | MF_BYCOMMAND);

    // can do this here because hwnd is not yet visible
    // HiliteMenuItem(GetDesktopWindow(), g_hmenuSample, IDM_SELECTED, MF_HILITE | MF_BYCOMMAND);

    if (fRTL) {
        SET_DC_RTL_MIRRORED(g_hdcMem);
    }
}


HRESULT CAdvAppearancePage::_OnDestroyPreview(HWND hWnd)
{
    if (g_hbmLook)
    {
        DeleteObject(g_hbmLook);
        g_hbmLook = NULL;
    }
    if (g_hmenuSample)
    {
        DestroyMenu(g_hmenuSample);
        g_hmenuSample = NULL;
    }

    return S_OK;
}


HRESULT CAdvAppearancePage::_OnPaintPreview(HWND hWnd)
{
    PAINTSTRUCT ps;

    BeginPaint(hWnd, &ps);
    RECT rc;
    GetClientRect(hWnd, &rc);
    if (g_hbmLook)
        _ShowBitmap(hWnd, ps.hdc);
    else
        _DrawPreview(ps.hdc, &rc, FALSE, TRUE);
    EndPaint(hWnd, &ps);

    return S_OK;
}


HRESULT CAdvAppearancePage::_OnReCreateBitmap(HWND hWnd)
{
    if (g_hbmLook)
    {
        HDC hdc = GetDC(NULL);
        if (g_nBitsPixel != GetDeviceCaps(hdc, BITSPIXEL))
        {
            DeleteObject(g_hbmLook);
            g_hbmLook = NULL;

            RECT rc;
            GetClientRect(hWnd, &rc);
            _InitPreview(&rc, IS_WINDOW_RTL_MIRRORED(hWnd));

            // InvalidateRect(hWnd, NULL, FALSE);
            // UpdateWindow(hWnd);

            _RepaintPreview(hWnd);
        }
        ReleaseDC(NULL, hdc);
    }

    return S_OK;
}


HRESULT CAdvAppearancePage::_OnButtonDownOrDblClick(HWND hWnd, int nCoordX, int nCoordY)
{
    POINT pt;
    pt.x = nCoordX;  // horizontal position of cursor
    pt.y = nCoordY;  // vertical position of cursor

    int nElementIndex = LookPrev_HitTest(pt);
    return _SelectElement(hWnd, nElementIndex, LSE_SETCUR);
}


LRESULT CALLBACK CAdvAppearancePage::PreviewSystemMetricsWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CAdvAppearancePage * pThis = (CAdvAppearancePage *)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    if (!pThis && (WM_NCDESTROY != wMsg))
    {
        AssertMsg((NULL != g_pAdvAppearancePage), TEXT("We need this or the dlg doesn't work at all.  -BryanSt"));
        if (g_pAdvAppearancePage)
        {
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)g_pAdvAppearancePage);
            pThis = (CAdvAppearancePage *)g_pAdvAppearancePage;
        }
    }

    if (pThis)
        return pThis->_PreviewSystemMetricsWndProc(hWnd, wMsg, wParam, lParam);

    return DefWindowProc(hWnd, wMsg, wParam, lParam);
}


// This Property Sheet appear in the top level of the "Display Control Panel".
LRESULT CAdvAppearancePage::_PreviewSystemMetricsWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lReturnValue = TRUE;
    BOOL fCallWndProc = TRUE;

    switch(wMsg)
    {
    case WM_NCCREATE:
        _OnNCCreate(hWnd);
        fCallWndProc = FALSE;
        break;

    case WM_CREATE:
        {
            RECT rc;
            GetClientRect(hWnd, &rc);
            _OnCreatePreviewSMDlg(&rc, IS_WINDOW_RTL_MIRRORED(hWnd));
        }
        break;

    case WM_DESTROY:
        _OnDestroyPreview(hWnd);
        break;

    case WM_PALETTECHANGED:
        if ((HWND)wParam == hWnd)
            break;
        //fallthru
    case WM_QUERYNEWPALETTE:
        if (m_hpal3D)
            InvalidateRect(hWnd, NULL, FALSE);
        break;

    case WM_LBUTTONDOWN:
    case WM_LBUTTONDBLCLK:
        _OnButtonDownOrDblClick(GetParent(hWnd), LOWORD(lParam), HIWORD(lParam));
        break;

    case WM_RECREATEBITMAP:
        _OnReCreateBitmap(hWnd);
        break;

    case WM_SIZE:      // right mouse click
        break;

    case WM_PAINT:
        _OnPaintPreview(hWnd);
        break;
    }

    if (fCallWndProc)
    {
        lReturnValue = DefWindowProc(hWnd, wMsg, wParam, lParam);
    }

    return lReturnValue;
}











// ----------------------------------------------------------------------------
// calculate all of the rectangles based on the given window rect
// ----------------------------------------------------------------------------
void CAdvAppearancePage::_Recalc(LPRECT prc)
{
    DWORD cxNormal;
    int cxDisabled, cxSelected;
    int cxAvgCharx2;
    RECT rc;
    HFONT hfontT;
    int cxFrame, cyFrame;
    int cyCaption;
    int i;
    SIZE sizButton;

    rc = *prc;

    // Get our drawing data
    cxSize = ClassicGetSystemMetrics(SM_CXSIZE);
    cxFrame = (m_sizes[SIZE_FRAME].CurSize + 1) * m_cxBorderSM + m_cxEdgeSM;
    cyFrame = (m_sizes[SIZE_FRAME].CurSize + 1) * m_cyBorderSM + m_cyEdgeSM;
    cyCaption = m_sizes[SIZE_CAPTION].CurSize;

    // Get text dimensions, with proper font.
    hfontT = (HFONT) SelectObject(g_hdcMem, m_fonts[FONT_MENU].hfont);

    GetTextExtentPoint32(g_hdcMem, g_szNormal, lstrlen(g_szNormal), &sizButton);
    cxNormal = sizButton.cx;

    GetTextExtentPoint32(g_hdcMem, g_szDisabled, lstrlen(g_szDisabled), &sizButton);
    cxDisabled = sizButton.cx;

    GetTextExtentPoint32(g_hdcMem, g_szSelected, lstrlen(g_szSelected), &sizButton);
    cxSelected = sizButton.cx;

    // get the average width (USER style) of menu font
    GetTextExtentPoint32(g_hdcMem, g_szABC, 52, &sizButton);
    cxAvgCharx2 = 2 * (sizButton.cx / 52);

    // actual menu-handling widths of strings is bigger
    cxDisabled += cxAvgCharx2;
    cxSelected += cxAvgCharx2;
    cxNormal += cxAvgCharx2;

    SelectObject(g_hdcMem, hfontT);

    GetTextExtentPoint32(g_hdcMem, g_szButton, lstrlen(g_szButton), &sizButton);

    // Desktop
    RCZ(ELEMENT_DESKTOP) = rc;

    InflateRect(&rc, -8*m_cxBorderSM, -8*m_cyBorderSM);

    // Windows
    rc.bottom -= cyFrame + cyCaption;
    RCZ(ELEMENT_ACTIVEBORDER) = rc;
    OffsetRect(&RCZ(ELEMENT_ACTIVEBORDER), cxFrame,
                        cyFrame + cyCaption + m_cyBorderSM);
    RCZ(ELEMENT_ACTIVEBORDER).bottom -= cyCaption;

    // Inactive window
    rc.right -= cyCaption;
    RCZ(ELEMENT_INACTIVEBORDER) = rc;

    // Caption
    InflateRect(&rc, -cxFrame, -cyFrame);
    rc.bottom = rc.top + cyCaption + m_cyBorderSM;
    RCZ(ELEMENT_INACTIVECAPTION) = rc;

    // close button
    InflateRect(&rc, -m_cxEdgeSM, -m_cyEdgeSM);
    rc.bottom -= m_cyBorderSM;      // compensate for magic line under caption
    RCZ(ELEMENT_INACTIVESYSBUT1) = rc;
    RCZ(ELEMENT_INACTIVESYSBUT1).left = rc.right - (cyCaption - m_cxEdgeSM);

    // min/max buttons
    RCZ(ELEMENT_INACTIVESYSBUT2) = rc;
    RCZ(ELEMENT_INACTIVESYSBUT2).right = RCZ(ELEMENT_INACTIVESYSBUT1).left - m_cxEdgeSM;
    RCZ(ELEMENT_INACTIVESYSBUT2).left = RCZ(ELEMENT_INACTIVESYSBUT2).right - 
                                                2 * (cyCaption - m_cxEdgeSM);

#if 0
    // small caption window
    RCZ(ELEMENT_SMCAPTION) = RCZ(ELEMENT_ACTIVEBORDER);
    RCZ(ELEMENT_SMCAPTION).bottom = RCZ(ELEMENT_SMCAPTION).top;
    RCZ(ELEMENT_SMCAPTION).top -= m_sizes[SIZE_SMCAPTION].CurSize + m_cyEdgeSM + 2 * m_cyBorderSM;
    RCZ(ELEMENT_SMCAPTION).right -= cxFrame;
    RCZ(ELEMENT_SMCAPTION).left = RCZ(ELEMENT_INACTIVECAPTION).right + 2 * cxFrame;

    RCZ(ELEMENT_SMCAPSYSBUT) = RCZ(ELEMENT_SMCAPTION);
    // deflate inside frame/border to caption and then another edge's worth
    RCZ(ELEMENT_SMCAPSYSBUT).right -= 2 * m_cxEdgeSM + m_cxBorderSM;
    RCZ(ELEMENT_SMCAPSYSBUT).top += 2 * m_cxEdgeSM + m_cxBorderSM;
    RCZ(ELEMENT_SMCAPSYSBUT).bottom -= m_cxEdgeSM + m_cxBorderSM;
    RCZ(ELEMENT_SMCAPSYSBUT).left = RCZ(ELEMENT_SMCAPSYSBUT).right - 
                                        (m_sizes[SIZE_SMCAPTION].CurSize - m_cxEdgeSM);
#endif

    // Active window

    // Caption
    rc = RCZ(ELEMENT_ACTIVEBORDER);
    InflateRect(&rc, -cxFrame, -cyFrame);
    RCZ(ELEMENT_ACTIVECAPTION) = rc;
    RCZ(ELEMENT_ACTIVECAPTION).bottom = 
        RCZ(ELEMENT_ACTIVECAPTION).top + cyCaption + m_cyBorderSM;

    // close button
    RCZ(ELEMENT_ACTIVESYSBUT1) = RCZ(ELEMENT_ACTIVECAPTION);
    InflateRect(&RCZ(ELEMENT_ACTIVESYSBUT1), -m_cxEdgeSM, -m_cyEdgeSM);
    RCZ(ELEMENT_ACTIVESYSBUT1).bottom -= m_cyBorderSM;      // compensate for magic line under caption
    RCZ(ELEMENT_ACTIVESYSBUT1).left = RCZ(ELEMENT_ACTIVESYSBUT1).right - 
                                        (cyCaption - m_cxEdgeSM);

    // min/max buttons
    RCZ(ELEMENT_ACTIVESYSBUT2) = RCZ(ELEMENT_ACTIVESYSBUT1);
    RCZ(ELEMENT_ACTIVESYSBUT2).right = RCZ(ELEMENT_ACTIVESYSBUT1).left - m_cxEdgeSM;
    RCZ(ELEMENT_ACTIVESYSBUT2).left = RCZ(ELEMENT_ACTIVESYSBUT2).right - 
                                                2 * (cyCaption - m_cxEdgeSM);

    // Menu
    rc.top = RCZ(ELEMENT_ACTIVECAPTION).bottom;
    RCZ(ELEMENT_MENUNORMAL) = rc;
    rc.top = RCZ(ELEMENT_MENUNORMAL).bottom = RCZ(ELEMENT_MENUNORMAL).top + m_sizes[SIZE_MENU].CurSize;
    RCZ(ELEMENT_MENUDISABLED) = RCZ(ELEMENT_MENUSELECTED) = RCZ(ELEMENT_MENUNORMAL);

    RCZ(ELEMENT_MENUDISABLED).left = RCZ(ELEMENT_MENUNORMAL).left + cxNormal;
    RCZ(ELEMENT_MENUDISABLED).right = RCZ(ELEMENT_MENUSELECTED).left = 
                        RCZ(ELEMENT_MENUDISABLED).left + cxDisabled;
    RCZ(ELEMENT_MENUSELECTED).right = RCZ(ELEMENT_MENUSELECTED).left + cxSelected;
    
    // Client
    RCZ(ELEMENT_WINDOW) = rc;

    // Scrollbar
    InflateRect(&rc, -m_cxEdgeSM, -m_cyEdgeSM); // take off client edge
    RCZ(ELEMENT_SCROLLBAR) = rc;
    rc.right = RCZ(ELEMENT_SCROLLBAR).left = rc.right - m_sizes[SIZE_SCROLL].CurSize;
    RCZ(ELEMENT_SCROLLUP) = RCZ(ELEMENT_SCROLLBAR);
    RCZ(ELEMENT_SCROLLUP).bottom = RCZ(ELEMENT_SCROLLBAR).top + m_sizes[SIZE_SCROLL].CurSize; 

    RCZ(ELEMENT_SCROLLDOWN) = RCZ(ELEMENT_SCROLLBAR);
    RCZ(ELEMENT_SCROLLDOWN).top = RCZ(ELEMENT_SCROLLBAR).bottom - m_sizes[SIZE_SCROLL].CurSize; 

    // Message Box
    rc.top = RCZ(ELEMENT_WINDOW).top + (RCZ(ELEMENT_WINDOW).bottom - RCZ(ELEMENT_WINDOW).top) / 2;
    rc.bottom = RCZ(ELEMENT_DESKTOP).bottom - 2*m_cyEdgeSM;
    rc.left = RCZ(ELEMENT_WINDOW).left + 2*m_cyEdgeSM;
    rc.right = RCZ(ELEMENT_WINDOW).left + (RCZ(ELEMENT_WINDOW).right - RCZ(ELEMENT_WINDOW).left) / 2 + 3*cyCaption;
    RCZ(ELEMENT_MSGBOX) = rc;

    // Caption
    RCZ(ELEMENT_MSGBOXCAPTION) = rc;
    RCZ(ELEMENT_MSGBOXCAPTION).top += m_cyEdgeSM + m_cyBorderSM;
    RCZ(ELEMENT_MSGBOXCAPTION).bottom = RCZ(ELEMENT_MSGBOXCAPTION).top + cyCaption + m_cyBorderSM;
    RCZ(ELEMENT_MSGBOXCAPTION).left += m_cxEdgeSM + m_cxBorderSM;
    RCZ(ELEMENT_MSGBOXCAPTION).right -= m_cxEdgeSM + m_cxBorderSM;

    RCZ(ELEMENT_MSGBOXSYSBUT) = RCZ(ELEMENT_MSGBOXCAPTION);
    InflateRect(&RCZ(ELEMENT_MSGBOXSYSBUT), -m_cxEdgeSM, -m_cyEdgeSM);
    RCZ(ELEMENT_MSGBOXSYSBUT).left = RCZ(ELEMENT_MSGBOXSYSBUT).right - 
                                        (cyCaption - m_cxEdgeSM);
    RCZ(ELEMENT_MSGBOXSYSBUT).bottom -= m_cyBorderSM;       // line under caption

    // Button
    RCZ(ELEMENT_BUTTON).bottom = RCZ(ELEMENT_MSGBOX).bottom - (4*m_cyBorderSM + m_cyEdgeSM);
    RCZ(ELEMENT_BUTTON).top = RCZ(ELEMENT_BUTTON).bottom - (sizButton.cy + 8 * m_cyBorderSM);

    i = (RCZ(ELEMENT_BUTTON).bottom - RCZ(ELEMENT_BUTTON).top) * 3;
    RCZ(ELEMENT_BUTTON).left = (rc.left + (rc.right - rc.left)/2) - i/2;
    RCZ(ELEMENT_BUTTON).right = RCZ(ELEMENT_BUTTON).left + i;
}

// ----------------------------------------------------------------------------
//
//  MyDrawFrame() -
//
//  Draws bordered frame, border size cl, and adjusts passed in rect.
//
// ----------------------------------------------------------------------------
void MyDrawFrame(HDC hdc, LPRECT prc, HBRUSH hbrColor, int cl)
{
    HBRUSH hbr;
    int cx, cy;
    RECT rcT;

    rcT = *prc;
    cx = cl * cxBorder;
    cy = cl * cyBorder;

    hbr = (HBRUSH) SelectObject(hdc, hbrColor);

    PatBlt(hdc, rcT.left, rcT.top, cx, rcT.bottom - rcT.top, PATCOPY);
    rcT.left += cx;

    PatBlt(hdc, rcT.left, rcT.top, rcT.right - rcT.left, cy, PATCOPY);
    rcT.top += cy;

    rcT.right -= cx;
    PatBlt(hdc, rcT.right, rcT.top, cx, rcT.bottom - rcT.top, PATCOPY);

    rcT.bottom -= cy;
    PatBlt(hdc, rcT.left, rcT.bottom, rcT.right - rcT.left, cy, PATCOPY);

    hbr = (HBRUSH) SelectObject(hdc, hbr);

    *prc = rcT;
}

/*
** draw a m_cyBorderSM band of 3DFACE at the bottom of the given rectangle.
** also, adjust the rectangle accordingly.
*/
void CAdvAppearancePage::_MyDrawBorderBelow(HDC hdc, LPRECT prc)
{
    int i;

    i = prc->top;
    prc->top = prc->bottom - m_cyBorderSM;
    FillRect(hdc, prc, m_brushes[COLOR_3DFACE]);
    prc->top = i;
    prc->bottom -= m_cyBorderSM;
}

/*-------------------------------------------------------------------
** draw a full window caption with system menu, minimize button,
** maximize button, and text.
**-------------------------------------------------------------------*/
void CAdvAppearancePage::DrawFullCaption(HDC hdc, LPRECT prc, LPTSTR lpszTitle, UINT flags)
{
    int iRight;
    int iFont;

    SaveDC(hdc);

    // special case gross for small caption that already drew on bottom
    if (!(flags & DC_SMALLCAP))
        _MyDrawBorderBelow(hdc, prc);

    iRight = prc->right;
    prc->right = prc->left + cxSize;
    DrawFrameControl(hdc, prc, DFC_CAPTION, DFCS_CAPTIONCLOSE);

    prc->left = prc->right;
    prc->right = iRight - 2*cxSize;
    iFont = flags & DC_SMALLCAP ? FONT_SMCAPTION : FONT_CAPTION;
    DrawCaptionTemp(NULL, hdc, prc, m_fonts[iFont].hfont, NULL, lpszTitle, flags | DC_ICON | DC_TEXT);

    prc->left = prc->right;
    prc->right = prc->left + cxSize;
    DrawFrameControl(hdc, prc, DFC_CAPTION, DFCS_CAPTIONMIN);
    prc->left = prc->right;
    prc->right = prc->left + cxSize;
    DrawFrameControl(hdc, prc, DFC_CAPTION, DFCS_CAPTIONMAX);

    RestoreDC(hdc, -1);
}


void CAdvAppearancePage::_ShowBitmap(HWND hWnd, HDC hdc)
{
    RECT rc;
    HBITMAP hbmOld;
    HPALETTE hpalOld = NULL;

    if (m_hpal3D)
    {
        hpalOld = SelectPalette(hdc, m_hpal3D, FALSE);
        RealizePalette(hdc);
    }

    GetClientRect(hWnd, &rc);
    hbmOld = (HBITMAP) SelectObject(g_hdcMem, g_hbmLook);
    BitBlt(hdc, 0, 0, rc.right - rc.left, rc.bottom - rc.top, g_hdcMem, 0, 0, SRCCOPY);
    SelectObject(g_hdcMem, hbmOld);

    if (hpalOld)
    {
        SelectPalette(hdc, hpalOld, FALSE);
        RealizePalette(hdc);
    }
}


// ----------------------------------------------------------------------------
//
//
// ----------------------------------------------------------------------------
void CAdvAppearancePage::_DrawPreview(HDC hdc, LPRECT prc, BOOL fOnlyShowActiveWindow, BOOL fShowBack)
{
    RECT rcT;
    int nMode;
    DWORD rgbBk;
    int cxSize, cySize;
    HANDLE hOldColors;
    HPALETTE hpalOld = NULL;
    HICON hiconLogo;
    HFONT hfontOld;
    BOOL bGradient = FALSE;

    ClassicSystemParametersInfo(SPI_GETGRADIENTCAPTIONS, 0, (PVOID)&bGradient, 0);

    SaveDC(hdc);

    if (m_hpal3D)
    {
        hpalOld = SelectPalette(hdc, m_hpal3D, TRUE);
        RealizePalette(hdc);
    }

    hOldColors = SetSysColorsTemp(m_rgb, m_brushes, COLOR_MAX);

    hiconLogo = (HICON) LoadImage(NULL, IDI_APPLICATION, IMAGE_ICON,
                        m_sizes[SIZE_CAPTION].CurSize - 2*m_cxBorderSM,
                        m_sizes[SIZE_CAPTION].CurSize - 2*m_cyBorderSM, 0);

    // Setup drawing stuff
    nMode = SetBkMode(hdc, TRANSPARENT);
    rgbBk = GetTextColor(hdc);

    cxSize  = ClassicGetSystemMetrics(SM_CXSIZE);
    cySize  = ClassicGetSystemMetrics(SM_CYSIZE);

    // Desktop
    if (fShowBack)
    {
        FillRect(hdc, &RCZ(ELEMENT_DESKTOP), m_brushes[COLOR_BACKGROUND]);
    }

    if (!fOnlyShowActiveWindow)
    {
        // Inactive window

        // Border
        rcT = RCZ(ELEMENT_INACTIVEBORDER);
        DrawEdge(hdc, &rcT, EDGE_RAISED, BF_RECT | BF_ADJUST);
        MyDrawFrame(hdc, &rcT, m_brushes[COLOR_INACTIVEBORDER], m_sizes[SIZE_FRAME].CurSize);
        MyDrawFrame(hdc, &rcT, m_brushes[COLOR_3DFACE], 1);

        // Caption
        rcT = RCZ(ELEMENT_INACTIVECAPTION);
        _MyDrawBorderBelow(hdc, &rcT);

        // NOTE: because USER draws icon stuff using its own DC and subsequently
        // its own palette, we need to make sure to use the inactivecaption
        // brush before USER does so that it will be realized against our palette.
        // this might get fixed in USER by better be safe.  

        // "clip" the caption title under the buttons
        rcT.left = RCZ(ELEMENT_INACTIVESYSBUT2).left - m_cyEdgeSM;
        FillRect(hdc, &rcT, m_brushes[bGradient ? COLOR_GRADIENTINACTIVECAPTION : COLOR_INACTIVECAPTION]);
        rcT.right = rcT.left;
        rcT.left = RCZ(ELEMENT_INACTIVECAPTION).left;
        DrawCaptionTemp(NULL, hdc, &rcT, m_fonts[FONT_CAPTION].hfont, hiconLogo, g_szInactive, DC_ICON | DC_TEXT |
                (bGradient ? DC_GRADIENT : 0));

        DrawFrameControl(hdc, &RCZ(ELEMENT_INACTIVESYSBUT1), DFC_CAPTION, DFCS_CAPTIONCLOSE);
        rcT = RCZ(ELEMENT_INACTIVESYSBUT2);
        rcT.right -= (rcT.right - rcT.left)/2;
        DrawFrameControl(hdc, &rcT, DFC_CAPTION, DFCS_CAPTIONMIN);
        rcT.left = rcT.right;
        rcT.right = RCZ(ELEMENT_INACTIVESYSBUT2).right;
        DrawFrameControl(hdc, &rcT, DFC_CAPTION, DFCS_CAPTIONMAX);
    }
    // Active window

    // Border
    rcT = RCZ(ELEMENT_ACTIVEBORDER);
    DrawEdge(hdc, &rcT, EDGE_RAISED, BF_RECT | BF_ADJUST);
    MyDrawFrame(hdc, &rcT, m_brushes[COLOR_ACTIVEBORDER], m_sizes[SIZE_FRAME].CurSize);
    MyDrawFrame(hdc, &rcT, m_brushes[COLOR_3DFACE], 1);

    // Caption
    rcT = RCZ(ELEMENT_ACTIVECAPTION);
    _MyDrawBorderBelow(hdc, &rcT);
    // "clip" the caption title under the buttons
    rcT.left = RCZ(ELEMENT_ACTIVESYSBUT2).left - m_cxEdgeSM;
    FillRect(hdc, &rcT, m_brushes[bGradient ? COLOR_GRADIENTACTIVECAPTION : COLOR_ACTIVECAPTION]);
    rcT.right = rcT.left;
    rcT.left = RCZ(ELEMENT_ACTIVECAPTION).left;
    DrawCaptionTemp(NULL, hdc, &rcT, m_fonts[FONT_CAPTION].hfont, hiconLogo, g_szActive, DC_ACTIVE | DC_ICON | DC_TEXT |
            (bGradient ? DC_GRADIENT : 0));

    DrawFrameControl(hdc, &RCZ(ELEMENT_ACTIVESYSBUT1), DFC_CAPTION, DFCS_CAPTIONCLOSE);
    rcT = RCZ(ELEMENT_ACTIVESYSBUT2);
    rcT.right -= (rcT.right - rcT.left)/2;
    DrawFrameControl(hdc, &rcT, DFC_CAPTION, DFCS_CAPTIONMIN);
    rcT.left = rcT.right;
    rcT.right = RCZ(ELEMENT_ACTIVESYSBUT2).right;
    DrawFrameControl(hdc, &rcT, DFC_CAPTION, DFCS_CAPTIONMAX);

    // Menu
    rcT = RCZ(ELEMENT_MENUNORMAL);
    DrawMenuBarTemp(GetDesktopWindow(), hdc, &rcT, g_hmenuSample, m_fonts[FONT_MENU].hfont);
    _MyDrawBorderBelow(hdc, &rcT);

    // Client area
    rcT = RCZ(ELEMENT_WINDOW);
    DrawEdge(hdc, &rcT, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
    FillRect(hdc, &rcT, m_brushes[COLOR_WINDOW]);

    // window text
    SetBkMode(hdc, TRANSPARENT);
    SetTextColor(hdc, m_rgb[COLOR_WINDOWTEXT]);

    hfontOld = (HFONT) SelectObject(hdc, m_fonts[FONT_CAPTION].hfont);
    TextOut(hdc, RCZ(ELEMENT_WINDOW).left + 2*m_cxEdgeSM, RCZ(ELEMENT_WINDOW).top + 2*m_cyEdgeSM, g_szWindowText, lstrlen(g_szWindowText));
    if (hfontOld)
        SelectObject(hdc, hfontOld); 

    // scroll bar
    rcT = RCZ(ELEMENT_SCROLLBAR);
    //MyDrawFrame(hdc, &rcT, m_brushes[COLOR_3DSHADOW], 1);
    //m_brushes[COLOR_SCROLLBAR]);
    FillRect(hdc, &rcT, m_brushes[COLOR_SCROLLBAR]);
//    FillRect(hdc, &rcT, (HBRUSH)DefWindowProc(hWnd, WM_CTLCOLOR, (WPARAM)hdc, MAKELONG(hWnd, CTLCOLOR_SCROLLBAR)));

    DrawFrameControl(hdc, &RCZ(ELEMENT_SCROLLUP), DFC_SCROLL, DFCS_SCROLLUP);
    DrawFrameControl(hdc, &RCZ(ELEMENT_SCROLLDOWN), DFC_SCROLL, DFCS_SCROLLDOWN); 

    if (!fOnlyShowActiveWindow)
    {
        // MessageBox
        rcT = RCZ(ELEMENT_MSGBOX);
        DrawEdge(hdc, &rcT, EDGE_RAISED, BF_RECT | BF_ADJUST);
        FillRect(hdc, &rcT, m_brushes[COLOR_3DFACE]);

        rcT = RCZ(ELEMENT_MSGBOXCAPTION);
        _MyDrawBorderBelow(hdc, &rcT);
        // "clip" the caption title under the buttons
        rcT.left = RCZ(ELEMENT_MSGBOXSYSBUT).left - m_cxEdgeSM;
        FillRect(hdc, &rcT, m_brushes[bGradient ? COLOR_GRADIENTACTIVECAPTION : COLOR_ACTIVECAPTION]);
        rcT.right = rcT.left;
        rcT.left = RCZ(ELEMENT_MSGBOXCAPTION).left;
        DrawCaptionTemp(NULL, hdc, &rcT, m_fonts[FONT_CAPTION].hfont, hiconLogo, g_szMsgBox, DC_ACTIVE | DC_ICON | DC_TEXT |
                (bGradient ? DC_GRADIENT : 0));
        DrawFrameControl(hdc, &RCZ(ELEMENT_MSGBOXSYSBUT), DFC_CAPTION, DFCS_CAPTIONCLOSE);

        // message box text
        SetBkMode(hdc, TRANSPARENT);
        SetTextColor(hdc, m_rgb[COLOR_WINDOWTEXT]);
        hfontOld = (HFONT) SelectObject(hdc, m_fonts[FONT_MSGBOX].hfont);
        TextOut(hdc, RCZ(ELEMENT_MSGBOX).left + 3*m_cxEdgeSM, RCZ(ELEMENT_MSGBOXCAPTION).bottom + m_cyEdgeSM,
                            g_szMsgBoxText, lstrlen(g_szMsgBoxText));
        if (hfontOld)
            SelectObject(hdc, hfontOld);

        // Button
        rcT = RCZ(ELEMENT_BUTTON);
        DrawFrameControl(hdc, &rcT, DFC_BUTTON, DFCS_BUTTONPUSH);

    // ?????? what font should this use ??????

        // [msadek]; Pick the same one we use for Messagebox text.(This is what Message Box uses for its buttons)
        // else we will be using the font originally selected in the DC (System font)
        hfontOld = (HFONT) SelectObject(hdc, m_fonts[FONT_MSGBOX].hfont);
  
        SetBkMode(hdc, TRANSPARENT);
        SetTextColor(hdc, m_rgb[COLOR_BTNTEXT]);
        DrawText(hdc, g_szButton, -1, &rcT, DT_CENTER | DT_NOPREFIX |
            DT_SINGLELINE | DT_VCENTER);
        if (hfontOld)
            SelectObject(hdc, hfontOld); 
    }

    SetBkColor(hdc, rgbBk);
    SetBkMode(hdc, nMode);

    if (hiconLogo)
        DestroyIcon(hiconLogo);

    SetSysColorsTemp(NULL, NULL, (UINT_PTR)hOldColors);

    if (hpalOld)
    {
        hpalOld = SelectPalette(hdc, hpalOld, FALSE);
        RealizePalette(hdc);
    }

    RestoreDC(hdc, -1);
}


void CAdvAppearancePage::_RepaintPreview(HWND hwnd)
{
    HBITMAP hbmOld;

    if (g_hbmLook)
    {
        hbmOld = (HBITMAP) SelectObject(g_hdcMem, g_hbmLook);
        RECT rc;
        GetClientRect(hwnd, &rc);
        _DrawPreview(g_hdcMem, &rc, FALSE, TRUE);
        SelectObject(g_hdcMem, hbmOld);
    }
    InvalidateRect(hwnd, NULL, FALSE);
}


BOOL RegisterPreviewSystemMetricClass(HINSTANCE hInst)
{
    WNDCLASS wc;

    if (!GetClassInfo(hInst, PREVIEWSM_CLASS, &wc))
    {
        wc.style = 0;
        wc.lpfnWndProc = CAdvAppearancePage::PreviewSystemMetricsWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = hInst;
        wc.hIcon = NULL;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_3DFACE+1);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = PREVIEWSM_CLASS;

        if (!RegisterClass(&wc))
            return FALSE;
    }

    return TRUE;
}


/*---------------------------------------------------------
**
**---------------------------------------------------------*/
BOOL CreateGlobals(void)
{
    HBITMAP hbm;
    HDC hdc;

    // Check if the mirroring APIs exist on the current
    // platform.
    g_bMirroredOS = IS_MIRRORING_ENABLED();

    if (!g_hdcMem)
    {
        hdc = GetDC(NULL);
        g_hdcMem = CreateCompatibleDC(hdc);
        ReleaseDC(NULL, hdc);
    }

    if (!g_hdcMem)
        return FALSE;

    if (!g_hbmDefault)
    {
        hbm = CreateBitmap(1, 1, 1, 1, NULL);
        if (hbm)
        {
            g_hbmDefault = (HBITMAP) SelectObject(g_hdcMem, hbm);
            SelectObject(g_hdcMem, g_hbmDefault);
            DeleteObject(hbm);
        }
    }

    return TRUE;
}


HRESULT CAdvAppearancePage::Draw(HDC hdc, LPRECT prc, BOOL fOnlyShowActiveWindow, BOOL fRTL)
{
    _OnCreatePreviewSMDlg(prc, fRTL);

    m_cyBorderSM = ClassicGetSystemMetrics(SM_CYBORDER);
    m_cxBorderSM = ClassicGetSystemMetrics(SM_CXBORDER);
    m_cxEdgeSM = ClassicGetSystemMetrics(SM_CXEDGE);
    m_cyEdgeSM = ClassicGetSystemMetrics(SM_CYEDGE);

    _InitSysStuff();
    _Recalc(prc);
    _DrawPreview(hdc, prc, fOnlyShowActiveWindow, FALSE);
    _DestroySysStuff(); 

    if (g_hbmLook)
    {
        DeleteObject(g_hbmLook);
    }

    if (g_hmenuSample)
    {
        DestroyMenu(g_hmenuSample);
    }

    return S_OK;
}
    
HRESULT DrawAppearance(HDC hdc, LPRECT prc, SYSTEMMETRICSALL* psysMet, BOOL fOnlyShowActiveWindow, BOOL fRTL)
{
    HRESULT hr = E_OUTOFMEMORY;
    CAdvAppearancePage* pAdv = new CAdvAppearancePage(psysMet);
    if (pAdv)
    {
        hr = pAdv->Draw(hdc, prc, fOnlyShowActiveWindow, fRTL);
        delete pAdv;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\previewth.cpp ===
/*****************************************************************************\
    FILE: PreviewTh.cpp

    DESCRIPTION:
        This code will display a preview of the currently selected
    visual styles.

    BryanSt 5/5/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "PreviewTh.h"
#include "PreviewSM.h"
#include "classfactory.h"

// Old predef for Patterns
#define CXYDESKPATTERN 8

// Async Bitmap loading
#define PREVIEW_PICTURE_FILENAME      TEXT("PrePict.htm")
#define WM_HTML_BITMAP  (WM_USER + 100)
#define WM_ASYNC_BITMAP (WM_HTML_BITMAP + 1)
typedef struct{
    HWND hwnd;
    HBITMAP hbmp;
    DWORD id;
    WCHAR szFile[MAX_PATH];
} ASYNCWALLPARAM, * PASYNCWALLPARAM;

// Window Class Name
#define THEMEPREV_CLASS TEXT("ThemePreview")

//============================================================================================================
// *** Globals ***
//============================================================================================================


//===========================
// *** Class Internals & Helpers ***
//===========================


//===========================
// *** IThemePreview Interface ***
//===========================
extern LPCWSTR s_Icons[];

HRESULT CPreviewTheme::UpdatePreview(IN IPropertyBag * pPropertyBag)
{
    HRESULT hr = E_INVALIDARG;

    DEBUG_CODE(DebugStartWatch());

    if (pPropertyBag && _hwndPrev)
    {
        SYSTEMMETRICSALL systemMetricsAll = {0};
        hr = SHPropertyBag_ReadByRef(pPropertyBag, SZ_PBPROP_SYSTEM_METRICS, &systemMetricsAll, sizeof(systemMetricsAll));
        BOOL fSysMetDirty = (memcmp(&systemMetricsAll, &_systemMetricsAll, sizeof(SYSTEMMETRICSALL)) != 0);
        if (fSysMetDirty)
            memcpy(&_systemMetricsAll, &systemMetricsAll, sizeof(SYSTEMMETRICSALL));

        _putBackground(NULL, TRUE, 0);

        if (_fShowBack)
        {
            WCHAR szBackgroundPath[MAX_PATH];
            DWORD dwBackgroundTile;

            // See the list of Property Bag names for Themes in shpriv.idl
            hr = SHPropertyBag_ReadStr(pPropertyBag, SZ_PBPROP_BACKGROUND_PATH, szBackgroundPath, ARRAYSIZE(szBackgroundPath));
            hr = SHPropertyBag_ReadDWORD(pPropertyBag, SZ_PBPROP_BACKGROUND_TILE, &dwBackgroundTile);

            if ((lstrcmp(szBackgroundPath, _szBackgroundPath) != 0) || (_iTileMode != (int)dwBackgroundTile))
            {
                lstrcpy(_szBackgroundPath, szBackgroundPath);
                _putBackground(_szBackgroundPath, FALSE, dwBackgroundTile);
            }
        }

        if (_fShowVS)
        {
            WCHAR szVSPath[MAX_PATH];
            WCHAR szVSColor[MAX_PATH];
            WCHAR szVSSize[MAX_PATH];

            hr = SHPropertyBag_ReadStr(pPropertyBag, SZ_PBPROP_VISUALSTYLE_PATH, szVSPath, ARRAYSIZE(szVSPath));
            hr = SHPropertyBag_ReadStr(pPropertyBag, SZ_PBPROP_VISUALSTYLE_COLOR, szVSColor, ARRAYSIZE(szVSColor));
            hr = SHPropertyBag_ReadStr(pPropertyBag, SZ_PBPROP_VISUALSTYLE_SIZE, szVSSize, ARRAYSIZE(szVSSize));

            if ((lstrcmp(szVSPath, _szVSPath) != 0) || 
                (lstrcmp(szVSColor, _szVSColor) != 0) || 
                (lstrcmp(szVSSize, _szVSSize) != 0) || 
                fSysMetDirty)
            {
                lstrcpy(_szVSPath, szVSPath);
                lstrcpy(_szVSColor, szVSColor);
                lstrcpy(_szVSSize, szVSSize);
                _putVisualStyle(_szVSPath, _szVSColor, _szVSSize, &_systemMetricsAll);
            }
        }

        if (_fShowIcons)
        {
            _putIcons(pPropertyBag);
        }
    }

    DEBUG_CODE(TraceMsg(TF_THEMEUI_PERF, "CPreviewTheme::UpdatePreview() returned %#08lx. Time=%lums", hr, DebugStopWatch()));

    return hr;
}


HRESULT CPreviewTheme::CreatePreview(IN HWND hwndParent, IN DWORD dwFlags, IN DWORD dwStyle, IN DWORD dwExStyle, IN int x, IN int y, IN int nWidth, IN int nHeight, IN IPropertyBag * pPropertyBag, IN DWORD dwCtrlID)
{
    HRESULT hr = S_OK;

    DEBUG_CODE(DebugStartWatch());

    g_bMirroredOS = IS_MIRRORING_ENABLED();
    _fRTL = IS_WINDOW_RTL_MIRRORED(hwndParent);
    _hwndPrev = CreateWindowEx(dwExStyle, THEMEPREV_CLASS, L"Preview", dwStyle, x, y, nWidth, nHeight, hwndParent, (HMENU)IntToPtr(dwCtrlID), HINST_THISDLL, NULL);
    
    if (_hwndPrev)
    {
        SetWindowLongPtr(_hwndPrev, GWLP_USERDATA, (LONG_PTR)this);
        if (_pThumb)
            _pThumb->Init(_hwndPrev, WM_HTML_BITMAP);

        GetClientRect(_hwndPrev, &_rcOuter);

        if (dwFlags & TMPREV_SHOWMONITOR)
        {
            _fShowMon = TRUE;

            BITMAP bmMon;
            GetObject(_hbmMon, sizeof(bmMon), &bmMon);

            int ox = (RECTWIDTH(_rcOuter) - bmMon.bmWidth) / 2;
            int oy = (RECTHEIGHT(_rcOuter) - bmMon.bmHeight) / 2;
            RECT rc = { 16 + ox, 17 + oy, 168 + ox, 129 + oy};
            _rcInner = rc;
            _cxMon = ox;
            _cyMon = oy;
        }
        else
        {
            _rcInner = _rcOuter;
        }

        HDC hdcTemp = GetDC(_hwndPrev);
        if (hdcTemp)
        {
            HBITMAP hbmMem = CreateCompatibleBitmap(hdcTemp, RECTWIDTH(_rcOuter), RECTHEIGHT(_rcOuter));
            if (hbmMem)
            {
                HBITMAP hbmOld = (HBITMAP) SelectObject(_hdcMem, hbmMem);
                DeleteObject(hbmOld);
            }
            else
                hr = E_FAIL;
            ReleaseDC(_hwndPrev, hdcTemp);
        }
        else
            hr = E_FAIL;

        if (dwFlags & TMPREV_SHOWBKGND)
        {
            _fShowBack = TRUE;
        }

        _fShowVS = dwFlags & TMPREV_SHOWVS;
        _fOnlyActiveWindow = _fShowIcons = dwFlags & TMPREV_SHOWICONS;

        DEBUG_CODE(TraceMsg(TF_THEMEUI_PERF, "CPreviewTheme::CreatePreview() returned %#08lx. Time=%lums", hr, DebugStopWatch()));

        if (SUCCEEDED(hr))
            hr = UpdatePreview(pPropertyBag);
    }

    return hr;
}

//===========================
// *** IUnknown Interface ***
//===========================
ULONG CPreviewTheme::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CPreviewTheme::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CPreviewTheme::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CPreviewTheme, IObjectWithSite),
        QITABENT(CPreviewTheme, IThemePreview),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CPreviewTheme::CPreviewTheme() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pTheme);
    ASSERT(!m_pScheme);
    ASSERT(!m_pStyle);
    ASSERT(!m_pSize);
    ASSERT(!_hwndPrev);
}

HRESULT CPreviewTheme::_Init(void)
{
    HRESULT hr = S_OK;

    _RegisterThemePreviewClass(HINST_THISDLL);

    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        _hdcMem = CreateCompatibleDC(hdc);
        ReleaseDC(NULL, hdc);
    }
    else
        hr = E_FAIL;

    if (_hdcMem)
    {
        _hbmMon = LoadBitmap(HINST_THISDLL, MAKEINTRESOURCE(IDB_MONITOR));
        if (_hbmMon)
        {
            if (LoadString(HINST_THISDLL, IDS_NONE, _szNone, ARRAYSIZE(_szNone)) == 0)
                hr = E_FAIL;
        }
        else
            hr = E_FAIL;

        if (SUCCEEDED(hr))
            hr = CoCreateInstance(CLSID_Thumbnail, NULL, CLSCTX_INPROC_SERVER, IID_IThumbnail, (void **)&_pThumb);
    }
    else
        hr = E_FAIL;


    if (FAILED(hr))
    {
        if (_hbmMon)
        {
            DeleteObject(_hbmMon);
            _hbmMon = NULL;
        }
        if (_hdcMem)
        {
            DeleteDC(_hdcMem);
            _hdcMem = NULL;
        }
    }

    return hr;
}

CPreviewTheme::~CPreviewTheme()
{
    if (_hwndPrev && IsWindow(_hwndPrev))
    {
        DestroyWindow(_hwndPrev);
        _hwndPrev = NULL;
    }
    if (_hbmMon)
    {
        DeleteObject(_hbmMon);
        _hbmMon = NULL;
    }
    if (_hbmBack)
    {
        DeleteObject(_hbmBack);
        _hbmBack = NULL;
    }
    if (_hbrBack)
    {
        DeleteObject(_hbrBack);
        _hbrBack = NULL;
    }

    if (_hbmVS)
    {
        DeleteObject(_hbmVS);
    }

    if (_hdcMem)
    {
        DeleteDC(_hdcMem);
        _hpalMem = NULL;
        _hdcMem = NULL;
    }

    if (_pActiveDesk)
    {
        _pActiveDesk->Release();
    }

    for (int i = 0; i < MAX_PREVIEW_ICONS; i++)
    {
        if (_iconList[i].hicon)
        {
            DestroyIcon(_iconList[i].hicon);
        }
    }

    ATOMICRELEASE(m_pTheme);
    ATOMICRELEASE(m_pScheme);
    ATOMICRELEASE(m_pStyle);
    ATOMICRELEASE(m_pSize);
    ATOMICRELEASE(_pThumb);

    DllRelease();
}

LRESULT CALLBACK CPreviewTheme::ThemePreviewWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CPreviewTheme * pThis = (CPreviewTheme *)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    if (pThis)
        return pThis->_ThemePreviewWndProc(hWnd, wMsg, wParam, lParam);

    return DefWindowProc(hWnd, wMsg, wParam, lParam);
}

LRESULT CPreviewTheme::_ThemePreviewWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    switch(wMsg)
    {
        case WM_CREATE:
            break;

        case WM_DESTROY:
            {
                MSG msg;
                while (PeekMessage(&msg, hWnd, WM_HTML_BITMAP, WM_ASYNC_BITMAP, PM_REMOVE))
                {
                    if ( msg.lParam )
                    {
                        if (msg.message == WM_ASYNC_BITMAP)
                        {
                            //  clean up this useless crap
                            DeleteObject(((PASYNCWALLPARAM)(msg.lParam))->hbmp);
                            LocalFree((PASYNCWALLPARAM)(msg.lParam));
                        }
                        else // WM_HTML_BITMAP
                            DeleteObject((HBITMAP)msg.lParam);
                    }
                }
            }
            break;

        case WM_PALETTECHANGED:
            break;

        case WM_QUERYNEWPALETTE:
            break;

        case WM_HTML_BITMAP:
            {
                // may come through with NULL if the image extraction failed....
                if (wParam == _dwWallpaperID && lParam)
                {
                    _fHTMLBitmap = TRUE;
                    _iTileMode = _iNewTileMode;
                    _putBackgroundBitmap((HBITMAP)lParam);
                    // Take ownership of bitmap
                    return 1;
                }
                
                // Bitmap for something no longer selected
                return 0;
            }

        case WM_ASYNC_BITMAP:
            if (lParam)
            {
                PASYNCWALLPARAM pawp = (PASYNCWALLPARAM) lParam;
                ASSERT(pawp->hbmp);
                if (pawp->id == _dwWallpaperID)
                {
                    _fHTMLBitmap = FALSE;
                    _iTileMode = _iNewTileMode;
                    _putBackgroundBitmap(pawp->hbmp);
                }
                else
                {
                    //  clean up this useless crap
                    DeleteObject(pawp->hbmp);
                    LocalFree(pawp);
                }
            }
            break;

        case WM_PAINT:
            {
                PAINTSTRUCT ps;
                BeginPaint(hWnd, &ps);
                _Paint(ps.hdc);
                EndPaint(hWnd, &ps);
            }
            return 0;

        case WM_ERASEBKGND:
            _Paint((HDC)wParam);
            return 1;

    }

    return DefWindowProc(hWnd,wMsg,wParam,lParam);
}

BOOL CPreviewTheme::_RegisterThemePreviewClass(HINSTANCE hInst)
{
    WNDCLASS wc;

    if (!GetClassInfo(hInst, THEMEPREV_CLASS, &wc)) {
        wc.style = 0;
        wc.lpfnWndProc = CPreviewTheme::ThemePreviewWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = hInst;
        wc.hIcon = NULL;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_3DFACE+1);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = THEMEPREV_CLASS;

        if (!RegisterClass(&wc))
            return FALSE;
    }

    return TRUE;
}

HRESULT CPreviewTheme::_putIcons(IPropertyBag* pPropertyBag)
{
    HRESULT hr;

    for (int i = 0; i < MAX_PREVIEW_ICONS; i++)
    {
        if (_iconList[i].hicon)
        {
            DestroyIcon(_iconList[i].hicon);
        }

        WCHAR szIcon[MAX_PATH];

        hr = SHPropertyBag_ReadStr(pPropertyBag, s_Icons[i], szIcon, ARRAYSIZE(szIcon));
        if (SUCCEEDED(hr))
        {
            WCHAR szIconModule[MAX_PATH];
            SHExpandEnvironmentStrings(szIcon, szIconModule, ARRAYSIZE(szIconModule));
            int iIndex = PathParseIconLocation(szIconModule);
            ExtractIconEx(szIconModule, iIndex, &_iconList[i].hicon, NULL, 1);
        }
    }

    _fMemIsDirty = TRUE;
    InvalidateRect(_hwndPrev, &_rcInner, FALSE);
    return S_OK;
}

HRESULT CPreviewTheme::_putVisualStyle(LPCWSTR pszVSPath, LPCWSTR pszVSColor, LPCWSTR pszVSSize, SYSTEMMETRICSALL* psysMet)
{
    HRESULT hr = E_FAIL;
    HBITMAP hbmVS = NULL;
    HBITMAP hbmOldVS = NULL;
    HDC hdcVS = NULL;

    if (!pszVSPath || !*pszVSPath)
    {
        HDC hdcTemp = GetDC(_hwndPrev);

        if (hdcTemp)
        {
            hdcVS = CreateCompatibleDC(hdcTemp);
            hbmVS = CreateCompatibleBitmap(hdcTemp, RECTWIDTH(_rcInner), RECTHEIGHT(_rcInner));
            hbmOldVS = (HBITMAP)SelectObject(hdcVS, hbmVS);

            if (hdcVS && hbmVS)
            {
                RECT rcVS;
                rcVS.left   = 0;
                rcVS.right  = RECTWIDTH(_rcInner) - (_fShowIcons ? 100 : 8);
                rcVS.top    = 0;
                rcVS.bottom = RECTHEIGHT(_rcInner) - (_fShowIcons ? 50 : 8);

                // Create everyone including globals
                HDC hdcVStemp = CreateCompatibleDC(hdcTemp);
                HBITMAP hbmVStemp = CreateCompatibleBitmap(hdcTemp, RECTWIDTH(rcVS), RECTHEIGHT(rcVS));
                HBITMAP hbmOldVStemp = (HBITMAP) SelectObject(hdcVStemp, hbmVStemp);

                if (hdcVStemp && hbmVStemp)
                {
                    if (_fRTL)
                    {
                        SetLayout(hdcVStemp, LAYOUT_RTL);
                        SetLayout(hdcVS, LAYOUT_RTL);
                    }

                    HBRUSH hbr = CreateSolidBrush(RGB(255, 255, 0));
                    if (hbr)
                    {
                        FillRect(hdcVStemp, &rcVS, hbr);
                        RECT rcTemp = {0, 0, RECTWIDTH(_rcInner), RECTHEIGHT(_rcInner)};
                        FillRect(hdcVS, &rcTemp, hbr);
                        DeleteObject(hbr);
                    }

                    // Render image at full size
                    hr = DrawAppearance(hdcVStemp, &rcVS, psysMet, _fOnlyActiveWindow, _fRTL); 

                    // Shrink image to fit on "monitor"
                    int iX = _rcInner.left + (_fShowIcons ? 10 : RECTWIDTH(_rcInner) - RECTWIDTH(rcVS));
                    BitBlt(hdcVS, iX, _rcInner.top, RECTWIDTH(rcVS), RECTHEIGHT(rcVS),
                           hdcVStemp, rcVS.left, rcVS.top, SRCCOPY);
                }

                // Free temporary variables and store off globals
                if (hdcVStemp)
                {
                    SelectObject(hdcVStemp, hbmOldVStemp);
                    DeleteDC(hdcVStemp);
                }
                if (hbmVStemp)
                {
                    DeleteObject(hbmVStemp);
                }
            }

            ReleaseDC(_hwndPrev, hdcTemp);
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {
        if (_hbmVS)
        {
            DeleteObject(_hbmVS);
        }
        _hbmVS = hbmVS;
        hbmVS = NULL;

        _fMemIsDirty = TRUE;
        InvalidateRect(_hwndPrev, &_rcInner, FALSE);
    }

    if (hdcVS)
    {
        if (hbmOldVS)
        {
            SelectObject(hdcVS, hbmOldVS);
        }
        DeleteDC(hdcVS);
    }
    if (hbmVS)
    {
        DeleteObject(hbmVS);
    }

    return hr;
}


HRESULT CPreviewTheme::_putBackgroundBitmap(HBITMAP hbm)
{
    if (_hbmBack)
    {
        DeleteObject(_hbmBack);
        _hbmBack = NULL;
    }

    if (_hpalMem)
    {
        DeleteObject(_hpalMem);
        _hpalMem = NULL;
    }

    _hbmBack = hbm;

    if (_hbmBack)
    {
        BITMAP bm;
        GetObject(_hbmBack, sizeof(bm), &bm);

        if (GetDeviceCaps(_hdcMem, RASTERCAPS) & RC_PALETTE)
        {
            if (bm.bmBitsPixel * bm.bmPlanes > 8)
                _hpalMem = CreateHalftonePalette(_hdcMem);
            else if (bm.bmBitsPixel * bm.bmPlanes == 8)
                _PaletteFromDS(_hdcMem, &_hpalMem);
            else
                _hpalMem = NULL;  //!!! assume 1 or 4bpp images dont have palettes
        }
    }

    _fMemIsDirty = TRUE;
    InvalidateRect(_hwndPrev, &_rcInner, FALSE);

    return S_OK;
}

HRESULT CPreviewTheme::_putBackground(BSTR bstrBackground, BOOL fPattern, int iTileMode)
{
    if (fPattern)
    {
        TCHAR szBuf[MAX_PATH];

        // get rid of old brush if there was one
        if (_hbrBack)
            DeleteObject(_hbrBack);

        if (bstrBackground && lstrcmpi(bstrBackground, _szNone))
        {
            WORD patbits[CXYDESKPATTERN] = {0, 0, 0, 0, 0, 0, 0, 0};

            if (GetPrivateProfileString(TEXT("patterns"), bstrBackground, TEXT(""),
                                        szBuf, ARRAYSIZE(szBuf), TEXT("control.ini")))
            {
                _ReadPattern(szBuf, patbits);    
            }

            HBITMAP hbmTemp = CreateBitmap(8, 8, 1, 1, patbits);
            if (hbmTemp)
            {
                _hbrBack = CreatePatternBrush(hbmTemp);
                DeleteObject(hbmTemp);
            }
        }
        else
        {
            _hbrBack = CreateSolidBrush(_systemMetricsAll.schemeData.rgb[COLOR_BACKGROUND]);
        }
        if (!_hbrBack)
            _hbrBack = (HBRUSH) GetStockObject(BLACK_BRUSH);

        _fMemIsDirty = TRUE;
        InvalidateRect(_hwndPrev, &_rcInner, FALSE);
    }
    else
    {
        _iNewTileMode = iTileMode;
        return _GetWallpaperAsync(bstrBackground);
    }
    return S_OK;
}

/*-------------------------------------------------------------
** given a pattern string from an ini file, return the pattern
** in a binary (ie useful) form.
**-------------------------------------------------------------*/
HRESULT CPreviewTheme::_ReadPattern(LPTSTR lpStr, WORD FAR *patbits)
{
    short i, val;

    /* Get eight groups of numbers seprated by non-numeric characters. */
    for (i = 0; i < CXYDESKPATTERN; i++)
    {
        val = 0;
        if (*lpStr != TEXT('\0'))
        {
            /* Skip over any non-numeric characters. */
            while (!(*lpStr >= TEXT('0') && *lpStr <= TEXT('9')))
                lpStr++;

            /* Get the next series of digits. */
            while (*lpStr >= TEXT('0') && *lpStr <= TEXT('9'))
                val = val*10 + *lpStr++ - TEXT('0');
         }

        patbits[i] = val;
    }

    return S_OK;
}


/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/
HRESULT CPreviewTheme::_PaletteFromDS(HDC hdc, HPALETTE* phPalette)
{
    DWORD adw[257];
    int i,n;

    n = GetDIBColorTable(hdc, 0, 256, (LPRGBQUAD)&adw[1]);
    adw[0] = MAKELONG(0x300, n);

    for (i=1; i<=n; i++)
        adw[i] = RGB(GetBValue(adw[i]),GetGValue(adw[i]),GetRValue(adw[i]));

    *phPalette = (n == 0) ? NULL : CreatePalette((LPLOGPALETTE)&adw[0]);

    return S_OK;
}

HRESULT CPreviewTheme::_DrawMonitor(HDC hdc)
{
    HBITMAP hbmT;
    HDC hdcMon;
    BITMAP bmMon;

    if (_hbmMon == NULL)
    {
        return E_OUTOFMEMORY;
    }

    //
    // convert the "base" of the monitor to the right color.
    //
    // the lower left of the bitmap has a transparent color
    // we fixup using FloodFill
    //
    hdcMon = CreateCompatibleDC(NULL);
    if (hdcMon)
    {
        hbmT = (HBITMAP) SelectObject(hdcMon, _hbmMon);

        GetObject(_hbmMon, sizeof(bmMon), &bmMon);

        FillRect(hdc, &_rcOuter, GetSysColorBrush(COLOR_3DFACE));
        DrawThemeParentBackground(_hwndPrev, hdc, NULL);
        TransparentBlt(hdc, _rcOuter.left + _cxMon, _rcOuter.top + _cyMon, bmMon.bmWidth, bmMon.bmHeight,
               hdcMon, 0, 0, bmMon.bmWidth, bmMon.bmHeight, RGB(255, 0, 255));

        // clean up after ourselves
        SelectObject(hdcMon, hbmT);
        DeleteDC(hdcMon);
    }

    return S_OK;
}

HRESULT CPreviewTheme::_DrawBackground(HDC hdc)
{
    // Draw Pattern first
    if (_hbrBack)
    {
        COLORREF clrOldText = SetTextColor(hdc, GetSysColor(COLOR_BACKGROUND));
        COLORREF clrOldBk = SetBkColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
        HBRUSH hbr = (HBRUSH) SelectObject(hdc, _hbrBack);

        PatBlt(hdc, _rcInner.left, _rcInner.top, RECTWIDTH(_rcInner), RECTHEIGHT(_rcInner), PATCOPY);

        SelectObject(hdc, hbr);
        SetTextColor(hdc, clrOldText);
        SetBkColor(hdc, clrOldBk);
    }

    /// Start Draw Wall Paper
    if (_hbmBack && _fShowBack)
    {
        HDC hdcBack = CreateCompatibleDC(hdc);
        if (hdcBack)
        {
            HBITMAP hbmOldBack = (HBITMAP)SelectObject(hdcBack, _hbmBack);
            BITMAP bm;

            GetObject(_hbmBack, sizeof(bm), &bm);

            int dxBack = MulDiv(bm.bmWidth, RECTWIDTH(_rcInner), GetDeviceCaps(hdc, HORZRES));
            int dyBack = MulDiv(bm.bmHeight, RECTHEIGHT(_rcInner), GetDeviceCaps(hdc, VERTRES));

            if (dxBack < 1) dxBack = 1;
            if (dyBack < 1) dyBack = 1;

            if (_hpalMem)
            {
                SelectPalette(hdc, _hpalMem, TRUE);
                RealizePalette(hdc);
            }

            IntersectClipRect(hdc, _rcInner.left, _rcInner.top, _rcInner.right, _rcInner.bottom);
            SetStretchBltMode(hdc, COLORONCOLOR);

            if ((_iTileMode == WPSTYLE_TILE) && (!_fHTMLBitmap))
            {
                int i;
                StretchBlt(hdc, _rcInner.left, _rcInner.top, dxBack, dyBack,
                    hdcBack, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);

                for (i = _rcInner.left+dxBack; i < (_rcInner.left + RECTWIDTH(_rcInner)); i+= dxBack)
                    BitBlt(hdc, i, _rcInner.top, dxBack, dyBack, hdc, _rcInner.left, _rcInner.top, SRCCOPY);

                for (i = _rcInner.top; i < (_rcInner.top + RECTHEIGHT(_rcInner)); i += dyBack)
                    BitBlt(hdc, _rcInner.left, i, RECTWIDTH(_rcInner), dyBack, hdc, _rcInner.left, _rcInner.top, SRCCOPY);
            }
            else
            {
                //We want to stretch the Bitmap to the preview monitor size ONLY for new platforms.
                if ((_iTileMode == WPSTYLE_STRETCH) || (_fHTMLBitmap))
                {
                    //Stretch the bitmap to the whole preview monitor.
                    dxBack = RECTWIDTH(_rcInner);
                    dyBack = RECTHEIGHT(_rcInner);
                }
                //Center the bitmap in the preview monitor
                StretchBlt(hdc, _rcInner.left + (RECTWIDTH(_rcInner) - dxBack)/2, _rcInner.top + (RECTHEIGHT(_rcInner) - dyBack)/2,
                        dxBack, dyBack, hdcBack, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);
            }

            // restore dc
            SelectPalette(hdc, (HPALETTE) GetStockObject(DEFAULT_PALETTE), TRUE);
            SelectClipRgn(hdc, NULL);

            SelectObject(hdcBack, hbmOldBack);
            DeleteDC(hdcBack);
        }
    }

    return S_OK;
}

HRESULT CPreviewTheme::_DrawVisualStyle(HDC hdc)
{
    if (_hbmVS)
    {
        HDC hdcVS = CreateCompatibleDC(hdc);
        if (hdcVS)
        {
            HBITMAP hbmOldVS = (HBITMAP)SelectObject(hdcVS, _hbmVS);

            TransparentBlt(hdc, _rcInner.left, _rcInner.top, RECTWIDTH(_rcInner), RECTHEIGHT(_rcInner), hdcVS, 0, 0, RECTWIDTH(_rcInner), RECTHEIGHT(_rcInner), RGB(255, 255, 0));

            SelectObject(hdcVS, hbmOldVS);
            DeleteDC(hdcVS);
        }
    }
    else
    {
        RECT rc;
        rc.left   = _fShowIcons ? 20 : 8;
        rc.right  = RECTWIDTH(_rcInner) - (_fShowIcons ? 100 : 8);
        rc.top    = _fShowIcons ? 10 : 8;
        rc.bottom = RECTHEIGHT(_rcInner) - (_fShowIcons ? 60 : 20);
        DrawNCPreview(hdc, NCPREV_ACTIVEWINDOW | (_fOnlyActiveWindow ? 0 : NCPREV_MESSAGEBOX | NCPREV_INACTIVEWINDOW) | (_fRTL ? NCPREV_RTL : 0) , &rc, _szVSPath, _szVSColor, _szVSSize, &(_systemMetricsAll.schemeData.ncm), (_systemMetricsAll.schemeData.rgb));
    }

    return S_OK;
}


HRESULT CPreviewTheme::_DrawIcons(HDC hdc)
{
    int y = RECTHEIGHT(_rcInner) - _systemMetricsAll.nIcon - 8;
    int x = RECTWIDTH(_rcInner) - _systemMetricsAll.nIcon - 20;

    DrawIcon(hdc, x, y, _iconList[3].hicon);

    return S_OK;
}

HRESULT CPreviewTheme::_Paint(HDC hdc)
{
    HPALETTE hpalOld = NULL;

    if (_fMemIsDirty)
    {
        if (_fRTL)
        {
            SetLayout(_hdcMem, LAYOUT_RTL);
        }

        // Rebuild Back Buffer
        if (_fShowMon)
            _DrawMonitor(_hdcMem);

        // Always draw the background, the Background switch turns the background
        // image on/off
        _DrawBackground(_hdcMem);

        if (_fShowIcons)
            _DrawIcons(_hdcMem);

        if (_fShowVS)
            _DrawVisualStyle(_hdcMem);

        _fMemIsDirty = FALSE;
    }

    if (_hdcMem)
    {
        if (_hpalMem)
        {
            hpalOld = SelectPalette(hdc, _hpalMem, FALSE);
            RealizePalette(hdc);
        }

        if (_fRTL)
        {
            SetLayout(hdc, LAYOUT_RTL);
        }

        BitBlt(hdc, _rcOuter.left, _rcOuter.top, RECTWIDTH(_rcOuter), RECTHEIGHT(_rcOuter), _hdcMem, 0, 0, SRCCOPY);

        if (_hpalMem)
        {
            SelectPalette(hdc, hpalOld, TRUE);
            RealizePalette(hdc);
        }
    }

    return S_OK;
}


DWORD CALLBACK UpdateWallProc(LPVOID pv)
{
    ASSERT(pv);
    if (pv)
    {
        PASYNCWALLPARAM pawp = (PASYNCWALLPARAM) pv;
        pawp->hbmp = (HBITMAP)LoadImage(NULL, pawp->szFile,
                                          IMAGE_BITMAP, 0, 0,
                                          LR_LOADFROMFILE|LR_CREATEDIBSECTION);

        if (pawp->hbmp)
        {
            // if all is good, then the window will handle cleaning up
            if (IsWindow(pawp->hwnd) && PostMessage(pawp->hwnd, WM_ASYNC_BITMAP, 0, (LPARAM)pawp))
                return TRUE;

            DeleteObject(pawp->hbmp);
        }

        LocalFree(pawp);
    }

    return TRUE;
}

const GUID CLSID_HtmlThumbnailExtractor = {0xeab841a0, 0x9550, 0x11cf, 0x8c, 0x16, 0x0, 0x80, 0x5f, 0x14, 0x8, 0xf3};

DWORD CALLBACK UpdateWallProcHTML(LPVOID pv)
{
    if (SUCCEEDED(CoInitialize(NULL)))
    {
        ASSERT(pv);
        if (pv)
        {
            PASYNCWALLPARAM pawp = (PASYNCWALLPARAM) pv;
            IPersistFile *ppf;
            HRESULT hr = CoCreateInstance(CLSID_HtmlThumbnailExtractor, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPersistFile, &ppf));
            if (SUCCEEDED(hr))
            {
                hr = ppf->Load(pawp->szFile, STGM_READ);
                if (SUCCEEDED(hr))
                {
                    IExtractImage *pei= NULL;
                    hr = ppf->QueryInterface(IID_PPV_ARG(IExtractImage, &pei));
                    if (SUCCEEDED(hr))
                    {
                        DWORD dwPriority = 0;
                        DWORD dwFlags = IEIFLAG_SCREEN | IEIFLAG_OFFLINE;
                        WCHAR szLocation[MAX_PATH];
                        HDC hdc = GetDC(NULL);
                        SIZEL rgSize = {GetDeviceCaps(hdc, HORZRES), GetDeviceCaps(hdc, VERTRES)};
                        ReleaseDC(NULL, hdc);
                        
                        hr = pei->GetLocation(szLocation, ARRAYSIZE(szLocation), &dwPriority, &rgSize, SHGetCurColorRes(), &dwFlags);
                        if (SUCCEEDED(hr))
                        {
                            HBITMAP hbm;
                            hr = pei->Extract(&hbm);
                            if (SUCCEEDED(hr))
                            {
                                if (!SendMessage(pawp->hwnd, WM_HTML_BITMAP, pawp->id, (LPARAM)hbm))
                                {
                                    DeleteObject(hbm);
                                }
                            }
                        }
                        pei->Release();
                    }
                }
                ppf->Release();
            }
     
            LocalFree(pawp);
        }
        CoUninitialize();
    }

    return TRUE;
}

//
// Determines if the wallpaper can be supported in non-active desktop mode.
//
BOOL CPreviewTheme::_IsNormalWallpaper(LPCWSTR pszFileName)
{
    BOOL fRet = TRUE;

    if (pszFileName[0] == TEXT('\0'))
    {
        fRet = TRUE;
    }
    else
    {
        LPTSTR pszExt = PathFindExtension(pszFileName);

        //Check for specific files that can be shown only in ActiveDesktop mode!
        if((lstrcmpi(pszExt, TEXT(".GIF")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".gif")) == 0) ||     // 368690: Strange, but we must compare 'i' in both caps and lower case.
           (lstrcmpi(pszExt, TEXT(".JPG")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".JPE")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".JPEG")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".PNG")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".HTM")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".HTML")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".HTT")) == 0))
           return FALSE;

        //Everything else (including *.BMP files) are "normal" wallpapers
    }
    return fRet;
}

//
// Determines if the wallpaper is a picture (vs. HTML).
//
BOOL CPreviewTheme::_IsWallpaperPicture(LPCWSTR pszWallpaper)
{
    BOOL fRet = TRUE;

    if (pszWallpaper[0] == TEXT('\0'))
    {
        //
        // Empty wallpapers count as empty pictures.
        //
        fRet = TRUE;
    }
    else
    {
        LPTSTR pszExt = PathFindExtension(pszWallpaper);

        if ((lstrcmpi(pszExt, TEXT(".HTM")) == 0) ||
            (lstrcmpi(pszExt, TEXT(".HTML")) == 0) ||
            (lstrcmpi(pszExt, TEXT(".HTT")) == 0))
        {
            fRet = FALSE;
        }
    }

    return fRet;
}

HRESULT CPreviewTheme::_LoadWallpaperAsync(LPCWSTR pszFile, DWORD dwID, BOOL bHTML)
{
    PASYNCWALLPARAM pawp = (PASYNCWALLPARAM) LocalAlloc(LPTR, SIZEOF(ASYNCWALLPARAM));

    if (pawp)
    {
        pawp->hwnd = _hwndPrev;
        pawp->id = dwID;
        StrCpyN(pawp->szFile, pszFile, SIZECHARS(pawp->szFile));

        
        if (bHTML)
        {
            if (!SHQueueUserWorkItem(UpdateWallProcHTML, pawp, 0, (DWORD_PTR)0, (DWORD_PTR *)NULL, NULL, 0))
                LocalFree(pawp);
        }
        else
        {
            if (!SHQueueUserWorkItem(UpdateWallProc, pawp, 0, (DWORD_PTR)0, (DWORD_PTR *)NULL, NULL, 0))
                LocalFree(pawp);
        }
    }

    return S_OK;
}

HRESULT CPreviewTheme::_GetWallpaperAsync(LPWSTR psz)
{
    HRESULT hr = S_OK;
    WCHAR wszWallpaper[INTERNET_MAX_URL_LENGTH];
    LPWSTR pszWallpaper = psz;
    _dwWallpaperID++;

    if (*pszWallpaper && lstrcmpi(pszWallpaper, _szNone))
    {
        if (_IsNormalWallpaper(pszWallpaper))
        {
            _LoadWallpaperAsync(pszWallpaper, _dwWallpaperID, FALSE);
        }
        else
        {
            if(_IsWallpaperPicture(pszWallpaper))
            {
                pszWallpaper = wszWallpaper;
                // This is a picture (GIF, JPG etc.,)
                // We need to generate a small HTML file that has this picture
                // as the background image.
                //
                // Compute the filename for the Temporary HTML file.
                //
                GetTempPath(ARRAYSIZE(wszWallpaper), wszWallpaper);
                lstrcat(wszWallpaper, PREVIEW_PICTURE_FILENAME);
                //
                // Generate the preview picture html file.
                //
                if (!_pActiveDesk)
                {
                    hr = _GetActiveDesktop(&_pActiveDesk);
                }

                if (SUCCEEDED(hr))
                {
                    _pActiveDesk->SetWallpaper(psz, 0);

                    WALLPAPEROPT wpo = { sizeof(WALLPAPEROPT) };
                    wpo.dwStyle = _iNewTileMode;
                    _pActiveDesk->SetWallpaperOptions(&wpo, 0);

                    _pActiveDesk->GenerateDesktopItemHtml(wszWallpaper, NULL, 0);
                }
            }

            _LoadWallpaperAsync(pszWallpaper, _dwWallpaperID, TRUE);
        }
    }
    else
    {
        _putBackgroundBitmap(NULL);
    }

    return hr;
}

HRESULT CPreviewTheme::_GetActiveDesktop(IActiveDesktop ** ppActiveDesktop)
{
    HRESULT hr = S_OK;

    if (!*ppActiveDesktop)
    {
        IActiveDesktopP * piadp;

        if (SUCCEEDED(hr = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IActiveDesktopP, &piadp)) ))
        {
            WCHAR wszScheme[MAX_PATH];
            DWORD dwcch = ARRAYSIZE(wszScheme);

            // Get the global "edit" scheme and set ourselves us to read from and edit that scheme
            if (SUCCEEDED(piadp->GetScheme(wszScheme, &dwcch, SCHEME_GLOBAL | SCHEME_EDIT)))
            {
                piadp->SetScheme(wszScheme, SCHEME_LOCAL);
                
            }
            hr = piadp->QueryInterface(IID_PPV_ARG(IActiveDesktop, ppActiveDesktop));
            piadp->Release();
        }
    }
    else
    {
        (*ppActiveDesktop)->AddRef();
    }

    return hr;
}

HRESULT CThemePreview_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj)
{
    HRESULT hr = E_INVALIDARG;

    if (punkOuter)
    {
        return CLASS_E_NOAGGREGATION;
    }

    if (ppvObj)
    {
        CPreviewTheme * pObject = new CPreviewTheme();

        *ppvObj = NULL;
        if (pObject)
        {
            hr = pObject->_Init();
            if (SUCCEEDED(hr))
            {
                hr = pObject->QueryInterface(riid, ppvObj);
            }
            pObject->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\previewth.h ===
/*****************************************************************************\
    FILE: PreviewTh.h

    DESCRIPTION:
        This code will display a preview of the currently selected
    visual styles.

    BryanSt 5/5/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _PREVIEWTHEME_H
#define _PREVIEWTHEME_H

#include <cowsite.h>
#include "classfactory.h"

#define MAX_PREVIEW_ICONS 4

class CPreviewTheme             : public CObjectWithSite
                                , public IThemePreview
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IThemePreview ***
    virtual STDMETHODIMP UpdatePreview(IN IPropertyBag * pPropertyBag);
    virtual STDMETHODIMP CreatePreview(IN HWND hwndParent, IN DWORD dwFlags, IN DWORD dwStyle, IN DWORD dwExStyle, IN int x, IN int y, IN int nWidth, IN int nHeight, IN IPropertyBag * pPropertyBag, IN DWORD dwCtrlID);

    STDMETHODIMP _Init(void);
    CPreviewTheme();
protected:

private:
    virtual ~CPreviewTheme(void);

    // Private Member Variables
    long                m_cRef;
    ITheme *            m_pTheme;
    IThemeScheme *      m_pScheme;
    IThemeStyle *       m_pStyle;
    IThemeSize *        m_pSize;
    HWND                _hwndPrev;
    TCHAR               _szNone[CCH_NONE];  // this is the '(None)' string
    RECT                _rcOuter;           // Size of double buffer bitmap
    RECT                _rcInner;           // Size of region within the "monitor"

    // Double buffering globals
    HDC                 _hdcMem;            // memory DC
    HPALETTE            _hpalMem;           // palette that goes with hbmBack bitmap
    BOOL                _fMemIsDirty;       // Dirty flag for image cache
    BOOL                _fRTL;

    // Monitor globals 
    BOOL                _fShowMon;
    int                 _cxMon;
    int                 _cyMon;
    HBITMAP             _hbmMon;

    // Background globals
    WCHAR               _szBackgroundPath[MAX_PATH];
    BOOL                _fShowBack;
    int                 _iTileMode;
    BOOL                _fHTMLBitmap;
    int                 _iNewTileMode;      // This is the new value to be used when the images is recieved
    DWORD               _dwWallpaperID;
    HBITMAP             _hbmBack;           // bitmap image of wallpaper
    HBRUSH              _hbrBack;           // brush for the desktop background
    IThumbnail*         _pThumb;
    IActiveDesktop *    _pActiveDesk;

    // Visual Style globals
    WCHAR               _szVSPath[MAX_PATH];
    WCHAR               _szVSColor[MAX_PATH];
    WCHAR               _szVSSize[MAX_PATH];
    SYSTEMMETRICSALL    _systemMetricsAll;
    BOOL                _fShowVS;
    HBITMAP             _hbmVS;             // bitmp for Visual Style
    BOOL                _fOnlyActiveWindow;

    // Icon globals
    BOOL                _fShowIcons;
    typedef struct ICONLISTtag {
        HICON hicon;
        WCHAR szName[MAX_PATH];
    } ICONLIST;
    ICONLIST _iconList[MAX_PREVIEW_ICONS];

    // Taskbar globals
    BOOL                _fShowTaskbar;
    BOOL                _fAutoHide;
    BOOL                _fShowClock;
    BOOL                _fGlomming;
    HWND                _hwndTaskbar;

    // Private Member Functions
    BOOL _RegisterThemePreviewClass(HINSTANCE hInst);
    static LRESULT ThemePreviewWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _ThemePreviewWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
    
    STDMETHODIMP _putBackground(IN BSTR bstrWallpaper, IN BOOL fPattern, IN int iTileMode);
    STDMETHODIMP _putVisualStyle(LPCWSTR pszVSPath, LPCWSTR pszVSColor, LPCWSTR pszVSSize, SYSTEMMETRICSALL* psysMet);
    STDMETHODIMP _putIcons(IPropertyBag* pPropertyBag);

    STDMETHODIMP _ReadPattern(LPTSTR lpStr, WORD FAR *patbits);
    STDMETHODIMP _PaletteFromDS(HDC hdc, HPALETTE* phPalette);

    STDMETHODIMP _DrawMonitor(HDC hdc);
    STDMETHODIMP _DrawBackground(HDC hdc);
    STDMETHODIMP _DrawVisualStyle(HDC hdc);
    STDMETHODIMP _DrawIcons(HDC hdc);
    STDMETHODIMP _DrawTaskbar(HDC hdc);

    STDMETHODIMP _Paint(HDC hdc);

    STDMETHODIMP _putBackgroundBitmap(HBITMAP hbm);

    BOOL         _IsNormalWallpaper(LPCWSTR pszFileName);
    BOOL         _IsWallpaperPicture(LPCWSTR pszWallpaper);
    STDMETHODIMP _LoadWallpaperAsync(LPCWSTR pszFile, DWORD dwID, BOOL bHTML);
    STDMETHODIMP _GetWallpaperAsync(LPWSTR pszWallpaper);
    STDMETHODIMP _GetActiveDesktop(IActiveDesktop ** ppActiveDesktop);
};

#endif // _PREVIEWTHEME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\priv.h ===
/*****************************************************************************\
    FILE: priv.h

    DESCRIPTION:
        This is the precompiled header for themeui.dll.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _PRIV_H_
#define _PRIV_H_


/*****************************************************************************\

      Global Includes
\*****************************************************************************/

#define WIN32_LEAN_AND_MEAN
#define NOIME
#define NOSERVICE

// This stuff must run on Win95
#define _WIN32_WINDOWS      0x0400

#ifndef WINVER
#define WINVER              0x0400
#endif // WINVER


#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_APARTMENT_THREADED
#undef _ATL_DLL
#undef _ATL_DLL_IMPL
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#include <windows.h>

#include <windowsx.h>

#include "resource.h"
#include "coverwnd.h"

#define _FIX_ENABLEMODELESS_CONFLICT  // for shlobj.h
//WinInet need to be included BEFORE ShlObjp.h
#include <wininet.h>
#include <urlmon.h>
#include <shlobj.h>
#include <exdisp.h>
#include <objidl.h>

#include <shellids.h>       // Help IDs
#include <shlwapi.h>
#include <shlwapip.h>

// HACKHACK: For the life of me, I can't get shlwapip.h to include the diffinitions of these.
//    I'm giving up and putting them inline.  __IOleAutomationTypes_INTERFACE_DEFINED__ and
//    __IOleCommandTarget_INTERFACE_DEFINED__ need to be defined, which requires oaidl.h,
//    which requires hlink.h which requires rpcndr.h to come in the right order.  Once I got that
//    far I found it still didn't work and a lot of more stuff is needed.  The problem
//    is that shlwapi (exdisp/dspsprt/expdsprt/cnctnpt) or ATL will provide impls for
//    IConnectionPoint & IConnectionPointContainer, but one will conflict with the other.
LWSTDAPI IConnectionPoint_SimpleInvoke(IConnectionPoint *pcp, DISPID dispidMember, DISPPARAMS * pdispparams);
LWSTDAPI IConnectionPoint_OnChanged(IConnectionPoint *pcp, DISPID dispid);
LWSTDAPIV IUnknown_CPContainerInvokeParam(IUnknown *punk, REFIID riidCP, DISPID dispidMember, VARIANTARG *rgvarg, UINT cArgs, ...);

#include <shellapi.h>

#include <shsemip.h>
#include <crtfree.h>

#include <ole2ver.h>
#include <olectl.h>
#include <shellp.h>
#include <shdocvw.h>
#include <commdlg.h>
#include <shguidp.h>
#include <isguids.h>
#include <shdguid.h>
#include <mimeinfo.h>
#include <hlguids.h>
#include <mshtmdid.h>
#include <msident.h>
#include <msxml.h>
#include <Theme.h>                  // For ITheme interfaces
#include <dispex.h>                 // IDispatchEx
#include <perhist.h>
#include <regapix.h>
#include <shsemip.h>
#include <shfusion.h>               // For SHFusionInitialize()/SHFusionUninitialize()


#include <help.h>
#include <krnlcmn.h>                // GetProcessDword

#define DISALLOW_Assert             // Force to use ASSERT instead of Assert
#define DISALLOW_DebugMsg           // Force to use TraceMsg instead of DebugMsg
#include <debug.h>

#include <urlhist.h>

#include <setupapi.h>
#include <cfgmgr32.h>
#include <syssetup.h>

#include <regstr.h>     // for REGSTR_PATH_EXPLORE

#define USE_SYSTEM_URL_MONIKER
#include <urlmon.h>
#include <inetreg.h>

#define _INTSHCUT_    // get DECLSPEC_IMPORT stuff right for INTSHCUT.h
#include <intshcut.h>

#define HLINK_NO_GUIDS
#include <hlink.h>
#include <hliface.h>
#include <docobj.h>
#include <ccstock.h>
#include <port32.h>

#include <commctrl.h>
#include <shpriv.h>
#include <Prsht.h>


// Include the automation definitions...
#include <exdisp.h>
#include <exdispid.h>
#include <ocmm.h>
#include <mshtmhst.h>
#include <simpdata.h>
#include <htiface.h>
#include <objsafe.h>

#include <dspsprt.h>
#include <cowsite.h>
#include <cobjsafe.h>
#include <objclsid.h>
#include <objwindow.h>
#include <autosecurity.h>

#include <guids.h>
#include <tmschema.h>
#include <uxtheme.h>
#include <uxthemep.h>
#include "deskcmmn.h"

#include <cowsite.h>

/*****************************************************************************\
 *      Local Includes
\*****************************************************************************/
// Include frequently used headers.
#include "util.h"
#include "theme.h"
#include "regutil.h"
#include "themefile.h"
#include <themeldr.h>
#include "themeutils.h"
#include "stgtheme.h"
#include "appScheme.h"
#include "thScheme.h"
#include "PreviewSM.h"
#include "deskcplext.h"
#include "dragsize.h"
#include "coverwnd.h"
#include "settings.h"
#include "advdlg.h"
#include "fontfix.h"
#include <tmreg.h>

// Trace flags
#define TF_WMTHEME          0x00000100      // Themes
#define TF_THEMEUI_PERF     0x00000200      // Perf
#define TF_DUMP_DEVMODE     0x00000400
#define TF_DUMP_CSETTINGS   0x00000800
#define TF_THEMEUI_SYSMETRICS   0x00001000      // Perf

#include <w4warn.h>

/*****************************************************************************\

 *
 *      Global Helper Macros/Typedefs
 *
\*****************************************************************************/

EXTERN_C HINSTANCE g_hinst;   // My instance handle
#define HINST_THISDLL g_hinst


STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);


#define CALLWNDPROC WNDPROC


#define MAX_PAGES               100

// Detect "." or ".." as invalid files
#define IS_VALID_FILE(str)        (!(('.' == str[0]) && (('\0' == str[1]) || (('.' == str[1]) && ('\0' == str[2])))))


/*****************************************************************************\
 *
 *      Global state management.
 *
 *      DLL reference count, DLL critical section.
 *
\*****************************************************************************/

void DllAddRef(void);
void DllRelease(void);


#define NULL_FOR_EMPTYSTR(str)          (((str) && (str)[0]) ? str : NULL)

typedef void (*LISTPROC)(UINT flm, LPVOID pv);

#define RECTWIDTH(rc)  ((rc).right - (rc).left)
#define RECTHEIGHT(rc) ((rc).bottom - (rc).top)

/*****************************************************************************\
 *      Local Includes
\*****************************************************************************/


// This is defined in WININET.CPP
typedef LPVOID HINTERNET;
typedef HGLOBAL HIDA;


#define QW_MAC              0xFFFFFFFFFFFFFFFF

#define INTERNET_MAX_PATH_LENGTH        2048
#define INTERNET_MAX_SCHEME_LENGTH      32          // longest protocol name length
#define MAX_URL_STRING                  (INTERNET_MAX_SCHEME_LENGTH \
                                        + sizeof("://") \
                                        + INTERNET_MAX_PATH_LENGTH)

#define SZ_EMPTY                        TEXT("")
#define EMPTYSTR_FORNULL(str)           ((str) ? (str) : SZ_EMPTY)



//  Features (This is where they are turned on and off)

// With this feature on, we demote the advanced appearances
// options into an "Advanced" subdialog.
#define FEATURE_DEMOTE_ADVANCED_APPEAROPTIONS

// Do we have personal.msstyles in the product yet.
//#define FEATURE_PERSONAL_SKIN_ENABLED

// The uxtheme visual style code has problems with being compatible
// with system metrics.  Apps will get system metric sizes (like captionbar height)
// and paint accordingly.  If uxtheme paints correctly, it will
// use the captionbar height and be compatible with the app.
// If it cannot do this, then the .msstyles file specifies system metrics
// that do work and we try to discourage the user from changing the
// system metrics to other values by disabling the advanced button
// on the Appearance tab.  This is a hack because the user can
// change the values in via USER32 directly.
#define FEATURE_ENABLE_ADVANCED_WITH_SKINSON


// When selecting certain legacy color schemes, like "High Contrast Black", the SPI_SETHIGHCONTRAST
// bit should be set.  This wasn't done in Win2k but should be done.
// This is currently turned off until MicW will implement a flag for SPI_SETHIGHCONTRAST
// that will prevent sethc.exe from running.
//#define FEATURE_SETHIGHCONTRASTSPI


#ifndef _WIN64
#define ENABLE_IA64_VISUALSTYLES
#else // _WIN64
// We don't want to install the theme files that require visual styles since
// they aren't supported on ia64 (yet).  Win #175788
//#define ENABLE_IA64_VISUALSTYLES
#endif // _WIN64



// String Constants
// Registry
#define SZ_WINDOWMETRICS        TEXT("Control Panel\\Desktop\\WindowMetrics")
#define SZ_APPLIEDDPI           TEXT("AppliedDPI")

// PropertyBag Propertyes
#define SZ_PBPROP_APPLY_THEMEFILE           TEXT("Theme_ApplySettings")         // When this is sent to a CThemeFile object, it will apply the settings that haven't been pulled out of it and placed in other Display Control Panel tabs.
#define SZ_PBPROP_THEME_FILTER              TEXT("ThemeFilter:")                // The filter values of what parts of themes to apply.
#define SZ_PBPROP_THEME_DISPLAYNAME         TEXT("Theme_DisplayName")           // Get the Theme display name for the currently selected item.
#define SZ_PBPROP_THEME_SETSELECTION        TEXT("Theme_SetSelectedEntree")     // Set the item in the drop down and persist.  The VT_BSTR
#define SZ_PBPROP_THEME_LOADTHEME           TEXT("Theme_LoadTheme")             // Load the theme specified by the VT_BSTR value
#define SZ_PBPROP_VSBEHAVIOR_FLATMENUS      TEXT("VSBehavior_FlatMenus")        // Does this visual style file want to use Flat menus (SPI_SETFLATMENUS)?
#define SZ_PBPROP_COLORSCHEME_LEGACYNAME    TEXT("ColorScheme_LegacyName")      // VT_BSTR specifying the Legacy name.  Like "Lilac (Large)"
#define SZ_PBPROP_EFFECTS_MENUDROPSHADOWS   TEXT("Effects_MenuDropShadows")     // VT_BOOL specifying if MenuDropShadows in on
#define SZ_PBPROP_HASSYSMETRICS             TEXT("Theme_HasSystemMetrics")      // VT_BOOL specifying if MenuDropShadows in on


#define SIZE_THEME_FILTER_STR               (ARRAYSIZE(SZ_PBPROP_THEME_FILTER) - 1)


// Parsing Characters
#define CH_ADDRESS_SEPARATOR       L';'
#define CH_ADDRESS_QUOTES          L'"'
#define CH_EMAIL_START             L'<'
#define CH_EMAIL_END               L'>'
#define CH_EMAIL_AT                L'@'
#define CH_EMAIL_DOMAIN_SEPARATOR  L'.'
#define CH_HTML_ESCAPE             L'%'
#define CH_COMMA                   L','


#define COLLECTION_SIZE_UNINITIALIZED           -1

/*****************************************************************************\
        Object Constructors
\*****************************************************************************/
HRESULT CClassFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj);
HRESULT CThemeUIPages_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);


#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\regutil.h ===
/*****************************************************************************\
    FILE: regutil.h

    DESCRIPTION:
        This file will contain helper functions to load and save values to the
    registry that are theme related.

    BryanSt 3/24/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _REGUTIL_H
#define _REGUTIL_H

#define MAX_THEME_SIZE          MAX_PATH


/////////////////////////////////////////////////////////////////////
// String Constants
/////////////////////////////////////////////////////////////////////
// Registry Strings
#define SZ_REGKEY_CPDESKTOP             TEXT("Control Panel\\Desktop")
#define SZ_REGKEY_USERMETRICS           TEXT("Control Panel\\Desktop\\WindowMetrics")
#define SZ_REGKEY_APPEARANCE            TEXT("Control Panel\\Appearance")
#define SZ_APPEARANCE_SCHEMES           TEXT("Control Panel\\Appearance\\Schemes")
#define SZ_APPEARANCE_NEWSCHEMES        TEXT("Control Panel\\Appearance\\New Schemes")
#define SZ_REGKEY_UPGRADE_KEY           TEXT("Control Panel\\Appearance\\New Schemes\\Current Settings\\Sizes\\0")
#define SZ_REGKEY_ACCESS_HIGHCONTRAST   TEXT("Control Panel\\Accessibility\\HighContrast")
#define SZ_REGKEY_CP_CURSORS            TEXT("Control Panel\\Cursors")
#define SZ_REGKEY_STYLES                TEXT("Styles")
#define SZ_REGKEY_SIZES                 TEXT("Sizes")
#define SZ_THEMES_MSTHEMEDIRS           SZ_THEMES TEXT("\\VisualStyleDirs")
#define SZ_THEMES_THEMEDIRS             SZ_THEMES TEXT("\\InstalledThemes")
#define SZ_REGKEY_PLUS98DIR             TEXT("Software\\Microsoft\\Plus!98")
#define SZ_REGKEY_CURRENT_THEME         TEXT("Software\\Microsoft\\Plus!\\Themes\\Current")
#define SZ_REGKEY_THEME_FILTERS         TEXT("Software\\Microsoft\\Plus!\\Themes\\Apply")
#define SZ_REGKEY_IE_DOWNLOADDIR        TEXT("Software\\Microsoft\\Internet Explorer")
#define SZ_THEMES                       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Themes")
#define SZ_REGKEY_LASTTHEME             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\LastTheme")
#define SZ_REGKEY_THEME_SITES           TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\DownloadSites")
#define SZ_REGKEY_THEME_DEFVSON         TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\DefaultVisualStyleOn")
#define SZ_REGKEY_THEME_DEFVSOFF        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\DefaultVisualStyleOff")
#define SZ_CP_SETTINGS_VIDEO            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\Settings\\Video")

#define SZ_REGVALUE_PLUS98DIR           TEXT("Path")
#define SZ_REGVALUE_ICONSIZE            TEXT("Shell Icon Size")
#define SZ_REGVALUE_SMALLICONSIZE       TEXT("Shell Small Icon Size")
#define SZ_REGVALUE_DEFAULTFONTNAME     TEXT("DefaultFontName")
#define SZ_REGVALUE_RECENTFOURCHARSETS  TEXT("RecentFourCharsets")
#define SZ_REGVALUE_DISPLAYNAME         TEXT("DisplayName")
#define SZ_REGVALUE_DISPLAYTHEMESPG     TEXT("DisplayThemesPage")
#define SZ_REGVALUE_DISPLAYSCHEMES      TEXT("DisplaySchemes")
#define SZ_REGVALUE_DISPLAYSCHEMES64    TEXT("DisplaySchemes64")
#define SZ_REGVALUE_CURRENT             TEXT("Current")
#define SZ_REGVALUE_CURRENTSCHEME       TEXT("CurrentScheme")
#define SZ_REGVALUE_SELECTEDSIZE        TEXT("SelectedSize")
#define SZ_REGVALUE_SELECTEDSTYLE       TEXT("SelectedStyle")
#define SZ_REGVALUE_CONTRASTLEVEL       TEXT("Contrast")
#define SZ_REGVALUE_DROPSHADOW          TEXT("Drop Shadow")
#define SZ_REGVALUE_FLATMENUS           TEXT("Flat Menus")
#define SZ_REGVALUE_LEGACYNAME          TEXT("LegacyName")
#define SZ_REGVALUE_ENABLEPLUSTHEMES    TEXT("Enable Plus Themes")
#define SZ_REGVALUE_CURRENT_SETTINGS    TEXT("Current Settings ")
#define SZ_REGVALUE_LOGINFO             TEXT("LoggingOn")
#define SZ_REGVALUE_ENABLEPREVIEW       TEXT("Enable Preview")
#define SZ_REGVALUE_ENABLETHEMEINSTALL  TEXT("Enable Theme Install")
#define SZ_REGVALUE_IE_DOWNLOADDIR      TEXT("Download Directory")
#define SZ_REGVALUE_ICONCOLORDEPTH      TEXT("Shell Icon BPP")          // (4 if the checkbox is false, otherwise 16, don't set it to anything else)
#define SZ_REGVALUE_SMOOTHSCROLL        TEXT("SmoothScroll")
#define SZ_REGVALUE_LT_THEMEFILE        TEXT("ThemeFile")
#define SZ_REGVALUE_LT_WALLPAPER        TEXT("Wallpaper")
#define SZ_REGVALUE_INSTALL_THEME       TEXT("InstallTheme")
#define SZ_REGVALUE_INSTALLCUSTOM_THEME TEXT("CustomInstallTheme")
#define SZ_REGVALUE_INSTALL_VISUALSTYLE TEXT("InstallVisualStyle")
#define SZ_REGVALUE_INSTALL_VSCOLOR     TEXT("InstallVisualStyleColor")
#define SZ_REGVALUE_INSTALL_VSSIZE      TEXT("InstallVisualStyleSize")
#define SZ_REGVALUE_MODIFIED_DISPNAME   TEXT("DisplayName of Modified")
#define SZ_REGVALUE_POLICY_SETVISUALSTYLE       TEXT("SetVisualStyle")          // This policy means that this visual style always needs to be set.
#define SZ_REGVALUE_POLICY_INSTALLVISUALSTYLE   TEXT("InstallVisualStyle")      // This policy means that this visual style should be installed the first time whistler is used
#define SZ_REGVALUE_POLICY_INSTALLTHEME         TEXT("InstallTheme")            // This policy indicates the .theme to install
#define SZ_REGVALUE_CONVERTED_WALLPAPER TEXT("ConvertedWallpaper")
#define SZ_REGVALUE_NO_THEMEINSTALL     TEXT("NoThemeInstall")                  // If this is REG_SZ "TRUE" in HKCU or HKLM, then no .Theme or .msstyles will be loaded during setup.
#define SZ_REGVALUE_ACCESS_HCFLAGS      TEXT("Flags")                           // Accessibility High Contrast Flags
#define SZ_REGVALUE_CURSOR_CURRENTSCHEME TEXT("Scheme Source")                   // This is the currently selected cursor color scheme in SZ_REGKEY_CP_CURSORS



#define SZ_REGKEY_POLICIES_SYSTEM       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System")

// System Policies
#define POLICY_KEY_EXPLORER             L"Explorer"
#define POLICY_KEY_SYSTEM               L"System"
#define POLICY_KEY_ACTIVEDESKTOP        L"ActiveDesktop"
#define SZ_REGKEY_POLICIES_DESKTOP      TEXT("Software\\Policies\\Microsoft\\Windows\\Control Panel\\Desktop")


#define SZ_POLICY_NOCHANGEWALLPAPER     TEXT("NoChangingWallpaper")             // Under CU, "ActiveDesktop"
#define SZ_POLICY_NODISPSCREENSAVERPG   TEXT("NoDispScrSavPage")                // Under CU, "System"
#define SZ_POLICY_SCREENSAVEACTIVE      TEXT("ScreenSaveActive")                // Under CU, SZ_REGKEY_POLICIES_DESKTOP
#define POLICY_VALUE_ANIMATION          L"NoChangeAnimation"                    // Under LM|CU, "Explorer"
#define POLICY_VALUE_KEYBOARDNAV        L"NoChangeKeyboardNavigationIndicators" // Under LM|CU, "Explorer"
#define SZ_POLICY_SCREENSAVETIMEOUT     L"ScreenSaveTimeOut"                    




#define SZ_WEBVW_SKIN_FILE              L"visualstyle.css"

#define SZ_SAVEGROUP_NOSKIN_KEY         L"Control Panel\\Appearance\\New Schemes\\Current Settings SaveNoVisualStyle"
#define SZ_SAVEGROUP_ALL_KEY            L"Control Panel\\Appearance\\New Schemes\\Current Settings SaveAll"

#define SZ_SAVEGROUP_NOSKIN_TITLE       L"Current Settings SaveNoVisualStyle"
#define SZ_SAVEGROUP_ALL_TITLE          L"Current Settings SaveAll"

#define SZ_SAVEGROUP_ALL                TEXT("::SaveAll")
#define SZ_SAVEGROUP_NOSKIN             TEXT("::SaveNoVisualStyle")


#ifdef UNICODE
#   define SCHEME_VERSION 2        // Ver 2 == Unicode
#else
#   define SCHEME_VERSION 3        // Ver 3 == Memphis ANSI
#endif

#define SCHEME_VERSION_WIN32 4     // Win32 version of schemes can be loaded from both NT and Win95

#define SCHEME_VERSION_400      1
#define SCHEME_VERSION_NT_400   2

#ifndef COLOR_HOTLIGHT
    #define COLOR_HOTLIGHT              26
    #define COLOR_GRADIENTACTIVECAPTION     27
    #define COLOR_GRADIENTINACTIVECAPTION   28
#endif

#define COLOR_MAX_40                (COLOR_INFOBK+1)
#define COLOR_MAX_41                (COLOR_GRADIENTINACTIVECAPTION+1)

#undef  MAX_SM_COLOR_WIN2k
#define MAX_SM_COLOR_WIN2k COLOR_MAX_41

#define SYSTEM_LOCALE_CHARSET  0  //The first item in the array is always system locale charset.

#define MAXSCHEMENAME 100

#define REG_BAD_DWORD 0xF0F0F0F0




/////////////////////////////////////////////////////////////////////
// Data Structures
/////////////////////////////////////////////////////////////////////
typedef struct
{
    SHORT version;
    // for alignment
    WORD  wDummy;
    NONCLIENTMETRICS ncm;
    LOGFONT lfIconTitle;
    COLORREF rgb[COLOR_MAX];
} SCHEMEDATA;


#define NO_CHANGE     0x0000
#define METRIC_CHANGE 0x0001
#define COLOR_CHANGE  0x0002
#define DPI_CHANGE    0x0004
#define SCHEME_CHANGE 0x8000

typedef struct
{
    DWORD dwChanged;
    SCHEMEDATA schemeData;
    int nDXIcon;
    int nDYIcon;
    int nIcon;
    int nSmallIcon;
    BOOL fModifiedScheme;
    BOOL fFlatMenus;
    BOOL fHighContrast;
}  SYSTEMMETRICSALL;




/////////////////////////////////////////////////////////////////////
// Shared Function
/////////////////////////////////////////////////////////////////////
// Theme Store Functions
HRESULT SystemMetricsAll_Set(IN SYSTEMMETRICSALL * pState, CDimmedWindow* pDimmedWindow);
HRESULT SystemMetricsAll_Get(IN SYSTEMMETRICSALL * pState);
HRESULT SystemMetricsAll_Copy(IN SYSTEMMETRICSALL * pStateSource, IN SYSTEMMETRICSALL * pStateDest);
HRESULT SystemMetricsAll_Load(IN IThemeSize * pSizeToLoad, IN SYSTEMMETRICSALL * pState, IN const int * pnNewDPI);
HRESULT SystemMetricsAll_Save(IN SYSTEMMETRICSALL * pState, IN IThemeSize * pSizeToSaveTo, IN const int * pnNewDPI);



// Misc.
HRESULT Look_GetSchemeData(IN HKEY hkSchemes, IN LPCTSTR pszSchemeName, IN SCHEMEDATA *psd);
HRESULT Look_GetCurSchemeNameAndData(SCHEMEDATA *psd, LPTSTR lpszSchemeName, int cbSize);

#define LF32toLF(lplf32, lplf)  (*(lplf) = *(lplf32))
#define LFtoLF32(lplf, lplf32)  (*(lplf32) = *(lplf))


#define DPI_PERSISTED           96

// PersistToLive: This will convert the size from the stored size (at 96 DPI) to the current DPI.
// PersistToLive: This will convert the size from the current DPI to the stored size (at 96 DPI).
HRESULT DPIConvert_SystemMetricsAll(BOOL fScaleSizes, SYSTEMMETRICSALL * pStateToModify, int nFromDPI, int nToDPI);

extern PTSTR s_pszColorNames[COLOR_MAX];


BOOL GetRegValueInt(HKEY hMainKey, LPCTSTR lpszSubKey, LPCTSTR lpszValName, int* piValue);
BOOL SetRegValueInt( HKEY hMainKey, LPCTSTR lpszSubKey, LPCTSTR lpszValName, int iValue );
BOOL SetRegValueDword( HKEY hk, LPCTSTR pSubKey, LPCTSTR pValue, DWORD dwVal );
DWORD GetRegValueDword( HKEY hk, LPCTSTR pSubKey, LPCTSTR pValue );


#include "PreviewSM.h"

#endif // _REGUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\regutil.cpp ===
/*****************************************************************************\
    FILE: regutil.cpp

    DESCRIPTION:
        This file will contain helper functions to load and save values to the
    registry that are theme related.

    BryanSt 3/24/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "regutil.h"


EXTERN_C void FAR SetMagicColors(HDC, DWORD, WORD);

// strings for color names in "WIN.INI".
PTSTR s_pszColorNames[] = {
/* COLOR_SCROLLBAR           */ TEXT("Scrollbar"),              // 0
/* COLOR_DESKTOP             */ TEXT("Background"),
/* COLOR_ACTIVECAPTION       */ TEXT("ActiveTitle"),
/* COLOR_INACTIVECAPTION     */ TEXT("InactiveTitle"),
/* COLOR_MENU                */ TEXT("Menu"),
/* COLOR_WINDOW              */ TEXT("Window"),                 // 5
/* COLOR_WINDOWFRAME         */ TEXT("WindowFrame"),
/* COLOR_MENUTEXT            */ TEXT("MenuText"),
/* COLOR_WINDOWTEXT          */ TEXT("WindowText"),
/* COLOR_CAPTIONTEXT         */ TEXT("TitleText"),
/* COLOR_ACTIVEBORDER        */ TEXT("ActiveBorder"),           // 10
/* COLOR_INACTIVEBORDER      */ TEXT("InactiveBorder"),
/* COLOR_APPWORKSPACE        */ TEXT("AppWorkspace"),
/* COLOR_HIGHLIGHT           */ TEXT("Hilight"),
/* COLOR_HIGHLIGHTTEXT       */ TEXT("HilightText"),
/* COLOR_3DFACE              */ TEXT("ButtonFace"),             // 15
/* COLOR_3DSHADOW            */ TEXT("ButtonShadow"),
/* COLOR_GRAYTEXT            */ TEXT("GrayText"),
/* COLOR_BTNTEXT             */ TEXT("ButtonText"),
/* COLOR_INACTIVECAPTIONTEXT */ TEXT("InactiveTitleText"),
/* COLOR_3DHILIGHT           */ TEXT("ButtonHilight"),          // 20
/* COLOR_3DDKSHADOW          */ TEXT("ButtonDkShadow"),
/* COLOR_3DLIGHT             */ TEXT("ButtonLight"),
/* COLOR_INFOTEXT            */ TEXT("InfoText"),
/* COLOR_INFOBK              */ TEXT("InfoWindow"),
/* COLOR_3DALTFACE           */ TEXT("ButtonAlternateFace"),    // 25
/* COLOR_HOTLIGHT            */ TEXT("HotTrackingColor"),
/* COLOR_GRADIENTACTIVECAPTION   */ TEXT("GradientActiveTitle"),
/* COLOR_GRADIENTINACTIVECAPTION */ TEXT("GradientInactiveTitle"),
/* COLOR_MENUHILIGHT         */ TEXT("MenuHilight"),            // 29
/* COLOR_MENUBAR             */ TEXT("MenuBar"),                // 30
};

// What about: AppWorkSpace

#define SZ_DEFAULT_FONT             TEXT("Tahoma")


/////////////////////////////////////////////////////////////////////
// Private Functions
/////////////////////////////////////////////////////////////////////
HRESULT DPIConvert_SystemMetricsAll(BOOL fScaleSizes, SYSTEMMETRICSALL * pStateToModify, int nFromDPI, int nToDPI)
{
    pStateToModify->schemeData.ncm.lfCaptionFont.lfHeight = MulDiv(pStateToModify->schemeData.ncm.lfCaptionFont.lfHeight, nToDPI, nFromDPI);
    pStateToModify->schemeData.ncm.lfSmCaptionFont.lfHeight = MulDiv(pStateToModify->schemeData.ncm.lfSmCaptionFont.lfHeight, nToDPI, nFromDPI);
    pStateToModify->schemeData.ncm.lfMenuFont.lfHeight = MulDiv(pStateToModify->schemeData.ncm.lfMenuFont.lfHeight, nToDPI, nFromDPI);
    pStateToModify->schemeData.ncm.lfStatusFont.lfHeight = MulDiv(pStateToModify->schemeData.ncm.lfStatusFont.lfHeight, nToDPI, nFromDPI);
    pStateToModify->schemeData.ncm.lfMessageFont.lfHeight = MulDiv(pStateToModify->schemeData.ncm.lfMessageFont.lfHeight, nToDPI, nFromDPI);
    pStateToModify->schemeData.lfIconTitle.lfHeight = MulDiv(pStateToModify->schemeData.lfIconTitle.lfHeight, nToDPI, nFromDPI);

    // Someone (NTUSER?) scales sizes for us.  So we don't need to do that in some cases.
    if (fScaleSizes)
    {
        pStateToModify->schemeData.ncm.iBorderWidth = MulDiv(pStateToModify->schemeData.ncm.iBorderWidth, nToDPI, nFromDPI);
        pStateToModify->schemeData.ncm.iScrollWidth = MulDiv(pStateToModify->schemeData.ncm.iScrollWidth, nToDPI, nFromDPI);
        pStateToModify->schemeData.ncm.iScrollHeight = MulDiv(pStateToModify->schemeData.ncm.iScrollHeight, nToDPI, nFromDPI);
        pStateToModify->schemeData.ncm.iCaptionWidth = MulDiv(pStateToModify->schemeData.ncm.iCaptionWidth, nToDPI, nFromDPI);
        pStateToModify->schemeData.ncm.iCaptionHeight = MulDiv(pStateToModify->schemeData.ncm.iCaptionHeight, nToDPI, nFromDPI);
        pStateToModify->schemeData.ncm.iSmCaptionWidth = MulDiv(pStateToModify->schemeData.ncm.iSmCaptionWidth, nToDPI, nFromDPI);
        pStateToModify->schemeData.ncm.iSmCaptionHeight = MulDiv(pStateToModify->schemeData.ncm.iSmCaptionHeight, nToDPI, nFromDPI);
        pStateToModify->schemeData.ncm.iMenuWidth = MulDiv(pStateToModify->schemeData.ncm.iMenuWidth, nToDPI, nFromDPI);
        pStateToModify->schemeData.ncm.iMenuHeight = MulDiv(pStateToModify->schemeData.ncm.iMenuHeight, nToDPI, nFromDPI);
    }

    return S_OK;
}


HRESULT DPIConvert_SystemMetricsAll_PersistToLive(BOOL fScaleSizes, SYSTEMMETRICSALL * pStateToModify, int nNewDPI)
{
    return DPIConvert_SystemMetricsAll(fScaleSizes, pStateToModify, DPI_PERSISTED, nNewDPI);
}


HRESULT DPIConvert_SystemMetricsAll_LiveToPersist(BOOL fScaleSizes, SYSTEMMETRICSALL * pStateToModify, int nNewDPI)
{
    return DPIConvert_SystemMetricsAll(fScaleSizes, pStateToModify, nNewDPI, DPI_PERSISTED);
}


HRESULT Look_GetSchemeData(IN HKEY hkSchemes, IN LPCTSTR pszSchemeName, IN SCHEMEDATA *psd)
{
    HRESULT hr;
    
    DWORD dwType = REG_BINARY;
    DWORD dwSize = sizeof(*psd);
    hr = HrRegQueryValueEx(hkSchemes, pszSchemeName, NULL, &dwType, (LPBYTE)psd, &dwSize);
    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
        if (psd->version == SCHEME_VERSION)
        {
            hr = S_OK;
        }
    }

    return hr; //Yes there is a current scheme and there is valid data! 
}


//  This function reads the current scheme's name and associated scheme data from registry.
//
//  This function returns FALSE, if there is no current scheme.
HRESULT Look_GetCurSchemeNameAndData(IN SCHEMEDATA *psd, IN LPTSTR lpszSchemeName, IN int cbSize)
{
    HKEY hkAppearance;
    HRESULT hr;
    
    //Get the current scheme.
    hr = HrRegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_APPEARANCE, 0, KEY_READ, &hkAppearance);
    if (SUCCEEDED(hr))
    {
        DWORD   dwSize;
        
        dwSize = cbSize;
        hr = HrRegQueryValueEx(hkAppearance, REGSTR_KEY_CURRENT, NULL, NULL, (LPBYTE)lpszSchemeName, &dwSize);
        if (SUCCEEDED(hr))
        {
            HKEY    hkSchemes;
            //Open the schemes key!
            hr = HrRegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_LOOKSCHEMES, 0, KEY_READ, &hkSchemes);
            if (SUCCEEDED(hr))
            {
                hr = Look_GetSchemeData(hkSchemes, lpszSchemeName, psd);
                RegCloseKey(hkSchemes);
            }
        }

        RegCloseKey(hkAppearance);
    }

    return hr; //Yes there is a current scheme and there is valid data! 
}




/////////////////////////////////////////////////////////////////////
// Public Functions
/////////////////////////////////////////////////////////////////////
HRESULT IconSize_Load(IN int * pnDXIcon, IN int * pnDYIcon, IN int * pnIcon, IN int * pnSmallIcon)
{
    TCHAR szSize[8];
    DWORD cbSize = sizeof(szSize);

    // default shell icon sizes
    *pnIcon = ClassicGetSystemMetrics(SM_CXICON);
    *pnSmallIcon = ((*pnIcon) / 2);

    HRESULT hr = HrSHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_USERMETRICS, SZ_REGVALUE_ICONSIZE, NULL, (LPBYTE)szSize, &cbSize);
    if (SUCCEEDED(hr))
    {
        *pnIcon = StrToInt(szSize);
    }

    cbSize = sizeof(szSize);
    hr = HrSHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_USERMETRICS, SZ_REGVALUE_SMALLICONSIZE, NULL, (LPBYTE)szSize, &cbSize);
    if (SUCCEEDED(hr))
    {
        *pnSmallIcon = StrToInt(szSize);
    }

    *pnDXIcon = (ClassicGetSystemMetrics(SM_CXICONSPACING) - *pnIcon);
    if (*pnDXIcon < 0)
    {
        *pnDXIcon = 0;
    }

    *pnDYIcon = (ClassicGetSystemMetrics(SM_CYICONSPACING) - *pnIcon);
    if (*pnDYIcon < 0)
    {
        *pnDYIcon = 0;
    }

    return S_OK;
}


HRESULT IconSize_Save(IN int nDXIcon, IN int nDYIcon, IN int nIcon, IN int nSmallIcon)
{
    HRESULT hr = E_INVALIDARG;

    AssertMsg((0 != nIcon), TEXT("We should never save an icon size of zero."));
    AssertMsg((0 != nSmallIcon), TEXT("We should never save an small icon size of zero."));

    if (nIcon && nSmallIcon)
    {
        TCHAR szSize[8];

        wnsprintf(szSize, ARRAYSIZE(szSize), TEXT("%d"), nIcon);
        hr = HrSHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_USERMETRICS, SZ_REGVALUE_ICONSIZE, 
            REG_SZ, (LPBYTE)szSize, sizeof(szSize[0]) * (lstrlen(szSize) + 1));

#ifdef THE_SHELL_CAN_HANDLE_CUSTOM_SMALL_ICON_SIZES_YET
        wnsprintf(szSize, ARRAYSIZE(szSize), TEXT("%d"), nSmallIcon);
        hr = HrSHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_USERMETRICS, SZ_REGVALUE_SMALLICONSIZE, 
            REG_SZ, (LPBYTE)szSize, sizeof(szSize[0]) * (lstrlen(szSize) + 1));
#endif
    }

    // WM_SETTINGCHANGE needs to be sent for this to update.  The caller needs to do that.
    return hr;
}


DWORD SetHighContrastAsync_WorkerThread(IN void *pv)
{
    BOOL fHighContrast = (BOOL) PtrToInt(pv);
    HIGHCONTRAST hc = {0};
    TCHAR szFlags[MAX_PATH];

    if (SUCCEEDED(HrRegGetValueString(HKEY_CURRENT_USER, SZ_REGKEY_ACCESS_HIGHCONTRAST, SZ_REGVALUE_ACCESS_HCFLAGS, szFlags, ARRAYSIZE(szFlags))))
    {
        DWORD dwFlags = StrToInt(szFlags);

        // Do async:
        hc.cbSize = sizeof(hc);
        if (SystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof(hc), &hc, 0))
        {
            BOOL fCurrentlySet = (dwFlags & HCF_HIGHCONTRASTON);        // I check the flags in the registry because USER32 may be out of date.

            // Only do the broadcast if it changed
            if (fHighContrast != fCurrentlySet)
            {
                if (fHighContrast)
                {
                    hc.dwFlags |= HCF_HIGHCONTRASTON;   // Add the bit.
                }
                else
                {
                    hc.dwFlags &= ~HCF_HIGHCONTRASTON;  // Clear the bit.
                }

                wnsprintf(szFlags, ARRAYSIZE(szFlags), TEXT("%d"), hc.dwFlags);
                HrRegSetValueString(HKEY_CURRENT_USER, SZ_REGKEY_ACCESS_HIGHCONTRAST, SZ_REGVALUE_ACCESS_HCFLAGS, szFlags);

                SendMessage(HWND_BROADCAST, WM_WININICHANGE, SPI_SETHIGHCONTRAST, (LPARAM)&hc);
            }
        }
    }

    return 0;
}



void AssertPositiveFontSizes(SYSTEMMETRICSALL * pState)
{
    // NTUSER will incorrectly scale positive LOGFONT lfHeights so we need to verify
    // that we always set negative sizes.
    AssertMsg((0 > pState->schemeData.lfIconTitle.lfHeight), TEXT("LOGFONT sizes must be negative because of a NTUSER bug. (lfIconTitle)"));
    AssertMsg((0 > pState->schemeData.ncm.lfCaptionFont.lfHeight), TEXT("LOGFONT sizes must be negative because of a NTUSER bug. (lfCaptionFont)"));
    AssertMsg((0 > pState->schemeData.ncm.lfMenuFont.lfHeight), TEXT("LOGFONT sizes must be negative because of a NTUSER bug. (lfMenuFont)"));
    AssertMsg((0 > pState->schemeData.ncm.lfMessageFont.lfHeight), TEXT("LOGFONT sizes must be negative because of a NTUSER bug. (lfMessageFont)"));
    AssertMsg((0 > pState->schemeData.ncm.lfSmCaptionFont.lfHeight), TEXT("LOGFONT sizes must be negative because of a NTUSER bug. (lfSmCaptionFont)"));
    AssertMsg((0 > pState->schemeData.ncm.lfStatusFont.lfHeight), TEXT("LOGFONT sizes must be negative because of a NTUSER bug. (lfStatusFont)"));
}


#define SZ_INILABLE_COLORS                          TEXT("colors")           // colors section name

/*
** set all of the data to the system.
**
** COMPATIBILITY NOTE:
**   EXCEL 5.0 people hook metrics changes off of WM_SYSCOLORCHANGE
** instead of WM_WININICHANGE.  Windows 3.1's Desktop applet always sent
** both when the metrics were updated, so nobody noticed this bug.
**   Be careful when re-arranging this function...
**
*/
HRESULT SystemMetricsAll_Set(IN SYSTEMMETRICSALL * pState, CDimmedWindow* pDimmedWindow)
{
    // COMPATIBILITY:
    //   Do metrics first since the color stuff might cause USER to generate a
    // WM_SYSCOLORCHANGE message and we don't want to send two of them...

    TraceMsg(TF_THEMEUI_SYSMETRICS, "desk.cpl: _SetSysStuff");
    SystemParametersInfoAsync(SPI_SETFLATMENU, NULL, IntToPtr(pState->fFlatMenus), 0, (SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE), pDimmedWindow);

    AssertMsg((0 != pState->nIcon), TEXT("We should never save an icon size of zero."));
    AssertMsg((0 != pState->nSmallIcon), TEXT("We should never save an small icon size of zero."));

    // NOTE: It would be nice to create one background thread and then make the 1 or 5 ClassicSystemParametersInfo()
    // calls on that single thread.
    if ((pState->dwChanged & METRIC_CHANGE) && pState->nIcon && pState->nSmallIcon)
    {
        HKEY hkey;

        TraceMsg(TF_THEMEUI_SYSMETRICS, "desk.cpl: Metrics Changed");

        TraceMsg(TF_THEMEUI_SYSMETRICS, "desk.cpl: Calling SPI_SETNONCLIENTMETRICS");
        pState->schemeData.ncm.cbSize = sizeof(pState->schemeData.ncm);
        AssertPositiveFontSizes(pState);
        SystemParametersInfoAsync(SPI_SETNONCLIENTMETRICS, sizeof(pState->schemeData.ncm), (void far *)(LPNONCLIENTMETRICS)&(pState->schemeData.ncm),
                sizeof(pState->schemeData.ncm), (SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE), pDimmedWindow);

        TraceMsg(TF_THEMEUI_SYSMETRICS,"desk.cpl: Calling SPI_SETICONTITLELOGFONT");
        SystemParametersInfoAsync(SPI_SETICONTITLELOGFONT, sizeof(LOGFONT), (void far *)(LPLOGFONT)&(pState->schemeData.lfIconTitle),
                sizeof(pState->schemeData.lfIconTitle), (SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE), pDimmedWindow);

        TraceMsg(TF_THEMEUI_SYSMETRICS,"desk.cpl: Calling SPI_ICONHORIZONTALSPACING");
        SystemParametersInfoAsync(SPI_ICONHORIZONTALSPACING, pState->nDXIcon + pState->nIcon, NULL, 0, (SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE), pDimmedWindow);

        TraceMsg(TF_THEMEUI_SYSMETRICS,"desk.cpl: Calling SPI_ICONVERTICALSPACING");
        SystemParametersInfoAsync(SPI_ICONVERTICALSPACING, pState->nDYIcon + pState->nIcon, NULL, 0, (SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE), pDimmedWindow);
        TraceMsg(TF_THEMEUI_SYSMETRICS,"desk.cpl: Done calling SPI's");

        if (RegCreateKey(HKEY_CURRENT_USER, SZ_REGKEY_USERMETRICS, &hkey) == ERROR_SUCCESS)
        {
            TCHAR val[8];

            AssertMsg((0 != pState->nIcon), TEXT("pState->nIcon should never be zero (0)."));
            wsprintf(val, TEXT("%d"), pState->nIcon);
            RegSetValueEx(hkey, SZ_REGVALUE_ICONSIZE, 0, REG_SZ, (LPBYTE)&val, SIZEOF(TCHAR) * (lstrlen(val) + 1));

#ifdef THE_SHELL_CAN_HANDLE_CUSTOM_SMALL_ICON_SIZES_YET
            AssertMsg((0 != pState->nSmallIcon), TEXT("pState->nIcon should never be zero (0)."));
            wsprintf(val, TEXT("%d"), pState->nSmallIcon);
            RegSetValueEx(hkey, SZ_REGVALUE_SMALLICONSIZE, 0, REG_SZ, (LPBYTE)&val, SIZEOF(TCHAR) * (lstrlen(val) + 1));
#else
//            RegDeleteValue(hkey, SZ_REGVALUE_SMALLICONSIZE);
#endif

            RegCloseKey(hkey);
        }

        // WM_SETTINGCHANGE is sent at the end of the function
    }

    if (pState->dwChanged & COLOR_CHANGE)
    {
        int i;
        int iColors[COLOR_MAX];
        COLORREF rgbColors[COLOR_MAX];
        TCHAR szRGB[32];
        COLORREF rgb;
        HKEY     hk;
        HDC      hdc;

        // restore magic colors back to Win31 defaults.
        hdc = GetDC(NULL);
        SetMagicColors(hdc, 0x00c0dcc0, 8);         // money green
        SetMagicColors(hdc, 0x00f0caa6, 9);         // IBM blue
        SetMagicColors(hdc, 0x00f0fbff, 246);       // off white
        ReleaseDC(NULL, hdc);

        // -------------------------------------------------
        // This call causes user to send a WM_SYSCOLORCHANGE
        // -------------------------------------------------
        for (i=0; i < COLOR_MAX; i++)
        {
            iColors[i] = i;
            rgbColors[i] = pState->schemeData.rgb[i] & 0x00FFFFFF;
        }

        SetSysColors(ARRAYSIZE(rgbColors), iColors, rgbColors);

        if (RegCreateKey(HKEY_CURRENT_USER, REGSTR_PATH_COLORS, &hk) == ERROR_SUCCESS)
        {
            // write out the color information to win.ini
            for (i = 0; i < COLOR_MAX; i++)
            {
                rgb = pState->schemeData.rgb[i];
                wsprintf(szRGB, TEXT("%d %d %d"), GetRValue(rgb), GetGValue(rgb), GetBValue(rgb));

                // For the time being we will update the INI file also.
                WriteProfileString(SZ_INILABLE_COLORS, s_pszColorNames[i], szRGB);

                // Update the registry (Be sure to include the terminating zero in the byte count!)
                RegSetValueEx(hk, s_pszColorNames[i], 0L, REG_SZ, (LPBYTE)szRGB, SIZEOF(TCHAR) * (lstrlen(szRGB)+1));
                TraceMsg(TF_THEMEUI_SYSMETRICS, "CPL:Write Color: %s=%s\n\r",s_pszColorNames[i], szRGB);
            }
            RegCloseKey(hk);
        }
    }
    else if (pState->dwChanged & METRIC_CHANGE)
    {
        // COMPATIBILITY HACK:
        // no colors were changed, but metrics were
        // EXCEL 5.0 people tied metrics changes to WM_SYSCOLORCHANGE
        // and ignore the WM_WININICHANGE (now called WM_SETTINGCHANGE)

        // send a bogus WM_SYSCOLORCHANGE
        PostMessageBroadAsync(WM_SYSCOLORCHANGE, 0, 0);
    }

    // if metrics changed at all send a WM_SETTINGCHANGE
    if (pState->dwChanged & METRIC_CHANGE)
    {
        PostMessageBroadAsync(WM_SETTINGCHANGE, SPI_SETNONCLIENTMETRICS, 0);
    }

#ifdef FEATURE_SETHIGHCONTRASTSPI
    // Start up a new thread and send this:
    SPICreateThread(SetHighContrastAsync_WorkerThread, (void *)pState->fHighContrast);
#endif // FEATURE_SETHIGHCONTRASTSPI

    return S_OK;
}


HRESULT SystemMetricsAll_Get(IN SYSTEMMETRICSALL * pState)
{
    HKEY hkey;

    // sizes and fonts
    pState->schemeData.ncm.cbSize = sizeof(pState->schemeData.ncm);
    ClassicSystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(pState->schemeData.ncm), (void far *)(LPNONCLIENTMETRICS)&(pState->schemeData.ncm), FALSE);

    ClassicSystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), (void far *)(LPLOGFONT)&(pState->schemeData.lfIconTitle), FALSE);

    // default shell icon sizes
    pState->nIcon = ClassicGetSystemMetrics(SM_CXICON);
    pState->nSmallIcon = pState->nIcon / 2;

    ClassicSystemParametersInfo(SPI_GETFLATMENU, NULL, &pState->fFlatMenus, 0);
    if (RegOpenKey(HKEY_CURRENT_USER, SZ_REGKEY_USERMETRICS, &hkey) == ERROR_SUCCESS)
    {
        TCHAR val[8];
        LONG len = sizeof(val);

        if (RegQueryValueEx(hkey, SZ_REGVALUE_ICONSIZE, 0, NULL, (LPBYTE)&val, (LPDWORD)&len) == ERROR_SUCCESS)
        {
            pState->nIcon = StrToInt(val);
        }

        len = SIZEOF(val);
        if (RegQueryValueEx(hkey, SZ_REGVALUE_SMALLICONSIZE, 0, NULL, (LPBYTE)&val, (LPDWORD)&len) == ERROR_SUCCESS)
        {
            pState->nSmallIcon = StrToInt(val);
        }

        RegCloseKey(hkey);
    }

    pState->nDXIcon = ClassicGetSystemMetrics(SM_CXICONSPACING) - pState->nIcon;
    if (pState->nDXIcon < 0)
    {
        pState->nDXIcon = 0;
    }

    pState->nDYIcon = ClassicGetSystemMetrics(SM_CYICONSPACING) - pState->nIcon;
    if (pState->nDYIcon < 0)
    {
        pState->nDYIcon = 0;
    }

    // system colors
    for (int nIndex = 0; nIndex < COLOR_MAX; nIndex++)
    {
        pState->schemeData.rgb[nIndex] = GetSysColor(nIndex);
    }

    HIGHCONTRAST hc = {0};
    TCHAR szTemp[MAX_PATH];

    szTemp[0] = 0;

    hc.cbSize = sizeof(hc);
    if (SystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof(hc), &hc, 0))
    {
        pState->fHighContrast = ((hc.dwFlags & HCF_HIGHCONTRASTON) ? TRUE : FALSE);
    }
    else
    {
        pState->fHighContrast = FALSE;
    }

    return S_OK;
}



HRESULT SystemMetricsAll_Copy(IN SYSTEMMETRICSALL * pStateSource, IN SYSTEMMETRICSALL * pStateDest)
{
    CopyMemory(pStateDest, pStateSource, sizeof(*pStateDest));
    return S_OK;
}


HRESULT SystemMetricsAll_Load(IN IThemeSize * pSizeToLoadFrom, IN SYSTEMMETRICSALL * pStateToLoad, IN const int * pnNewDPI)
{
    HRESULT hr = E_INVALIDARG;

    if (pSizeToLoadFrom && pStateToLoad)
    {
        pStateToLoad->schemeData.ncm.cbSize = sizeof(pStateToLoad->schemeData.ncm);
        pStateToLoad->schemeData.version = SCHEME_VERSION;
        pStateToLoad->schemeData.wDummy = 0;

        // Load Behavior System Metrics
        IPropertyBag * pPropertyBag;
        VARIANT var;

        var.boolVal = VARIANT_FALSE;
        hr = pSizeToLoadFrom->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
        if (SUCCEEDED(hr))
        {
            hr = pPropertyBag->Read(SZ_PBPROP_VSBEHAVIOR_FLATMENUS, &var, NULL);
            pPropertyBag->Release();
        }

        if (SUCCEEDED(hr))
        {
            pStateToLoad->fFlatMenus = (VARIANT_TRUE == var.boolVal);

            // Load Fonts
            hr = pSizeToLoadFrom->GetSystemMetricFont(SMF_CAPTIONFONT, &pStateToLoad->schemeData.ncm.lfCaptionFont);
            if (SUCCEEDED(hr))
            {
                hr = pSizeToLoadFrom->GetSystemMetricFont(SMF_SMCAPTIONFONT, &pStateToLoad->schemeData.ncm.lfSmCaptionFont);
                hr = pSizeToLoadFrom->GetSystemMetricFont(SMF_MENUFONT, &pStateToLoad->schemeData.ncm.lfMenuFont);
                hr = pSizeToLoadFrom->GetSystemMetricFont(SMF_STATUSFONT, &pStateToLoad->schemeData.ncm.lfStatusFont);
                hr = pSizeToLoadFrom->GetSystemMetricFont(SMF_MESSAGEFONT, &pStateToLoad->schemeData.ncm.lfMessageFont);

                hr = pSizeToLoadFrom->GetSystemMetricFont(SMF_ICONTITLEFONT, &pStateToLoad->schemeData.lfIconTitle);

                // Load Sizes
                hr = pSizeToLoadFrom->get_SystemMetricSize(SMS_BORDERWIDTH, &pStateToLoad->schemeData.ncm.iBorderWidth);
                hr = pSizeToLoadFrom->get_SystemMetricSize(SMS_SCROLLWIDTH, &pStateToLoad->schemeData.ncm.iScrollWidth);
                hr = pSizeToLoadFrom->get_SystemMetricSize(SMS_SCROLLHEIGHT, &pStateToLoad->schemeData.ncm.iScrollHeight);
                hr = pSizeToLoadFrom->get_SystemMetricSize(SMS_CAPTIONWIDTH, &pStateToLoad->schemeData.ncm.iCaptionWidth);
                hr = pSizeToLoadFrom->get_SystemMetricSize(SMS_CAPTIONHEIGHT, &pStateToLoad->schemeData.ncm.iCaptionHeight);
                hr = pSizeToLoadFrom->get_SystemMetricSize(SMS_SMCAPTIONWIDTH, &pStateToLoad->schemeData.ncm.iSmCaptionWidth);
                hr = pSizeToLoadFrom->get_SystemMetricSize(SMS_SMCAPTIONHEIGHT, &pStateToLoad->schemeData.ncm.iSmCaptionHeight);
                hr = pSizeToLoadFrom->get_SystemMetricSize(SMS_MENUWIDTH, &pStateToLoad->schemeData.ncm.iMenuWidth);
                hr = pSizeToLoadFrom->get_SystemMetricSize(SMS_MENUHEIGHT, &pStateToLoad->schemeData.ncm.iMenuHeight);

                // Load Color
                hr = S_OK;
                for (int nIndex = 0; SUCCEEDED(hr) && (nIndex < ARRAYSIZE(pStateToLoad->schemeData.rgb)); nIndex++)
                {
                    hr = pSizeToLoadFrom->get_SystemMetricColor(nIndex, &pStateToLoad->schemeData.rgb[nIndex]);
                }

                if (pnNewDPI)
                {
                    // We need to scale the fonts to fit correctly on the current monitor's DPI.
                    LogSystemMetrics("SystemMetricsAll_Load() BEFORE P->DPI loading AppearSchm", pStateToLoad);
                    DPIConvert_SystemMetricsAll_PersistToLive(TRUE, pStateToLoad, *pnNewDPI);
                    LogSystemMetrics("SystemMetricsAll_Load() AFTER P->DPI loading AppearSchm", pStateToLoad);
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = IconSize_Load(&pStateToLoad->nDXIcon, &pStateToLoad->nDYIcon, &pStateToLoad->nIcon, &pStateToLoad->nSmallIcon);
    }

    if (SUCCEEDED(hr))
    {
        enumThemeContrastLevels ContrastLevel = CONTRAST_NORMAL;

        if (FAILED(pSizeToLoadFrom->get_ContrastLevel(&ContrastLevel)))
        {
            ContrastLevel = CONTRAST_NORMAL;
        }

        pStateToLoad->fHighContrast = ((CONTRAST_NORMAL == ContrastLevel) ? FALSE : TRUE);
    }

    return hr;
}


// Copy the settings from pStateToLoad to pSizeToLoadFrom.
HRESULT SystemMetricsAll_Save(IN SYSTEMMETRICSALL * pState, IN IThemeSize * pSizeToSaveTo, IN const int * pnNewDPI)
{
    HRESULT hr = E_INVALIDARG;

    if (pSizeToSaveTo && pState)
    {
        pState->schemeData.ncm.cbSize = sizeof(pState->schemeData.ncm);
        pState->schemeData.version = SCHEME_VERSION;
        pState->schemeData.wDummy = 0;

        // Load Behavior System Metrics
        IPropertyBag * pPropertyBag;

        hr = pSizeToSaveTo->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
        if (SUCCEEDED(hr))
        {
            VARIANT var;

            var.vt = VT_BOOL;
            var.boolVal = (pState->fFlatMenus ? VARIANT_TRUE : VARIANT_FALSE);
            hr = pPropertyBag->Write(SZ_PBPROP_VSBEHAVIOR_FLATMENUS, &var);
            pPropertyBag->Release();
        }

        if (pnNewDPI)
        {
            // We need to scale the fonts & sizes to be current DPI independent
            LogSystemMetrics("SystemMetricsAll_Save() BEFORE DPI->P to save AppearSchm", pState);
            DPIConvert_SystemMetricsAll_LiveToPersist(TRUE, pState, *pnNewDPI);
            LogSystemMetrics("SystemMetricsAll_Save() AFTER DPI->P to save AppearSchm", pState);
        }

        // Load Fonts
        hr = pSizeToSaveTo->PutSystemMetricFont(SMF_CAPTIONFONT, &pState->schemeData.ncm.lfCaptionFont);
        hr = pSizeToSaveTo->PutSystemMetricFont(SMF_SMCAPTIONFONT, &pState->schemeData.ncm.lfSmCaptionFont);
        hr = pSizeToSaveTo->PutSystemMetricFont(SMF_MENUFONT, &pState->schemeData.ncm.lfMenuFont);
        hr = pSizeToSaveTo->PutSystemMetricFont(SMF_STATUSFONT, &pState->schemeData.ncm.lfStatusFont);
        hr = pSizeToSaveTo->PutSystemMetricFont(SMF_MESSAGEFONT, &pState->schemeData.ncm.lfMessageFont);

        hr = pSizeToSaveTo->PutSystemMetricFont(SMF_ICONTITLEFONT, &pState->schemeData.lfIconTitle);

        // Load Sizes
        hr = pSizeToSaveTo->put_SystemMetricSize(SMS_BORDERWIDTH, pState->schemeData.ncm.iBorderWidth);
        hr = pSizeToSaveTo->put_SystemMetricSize(SMS_SCROLLWIDTH, pState->schemeData.ncm.iScrollWidth);
        hr = pSizeToSaveTo->put_SystemMetricSize(SMS_SCROLLHEIGHT, pState->schemeData.ncm.iScrollHeight);
        hr = pSizeToSaveTo->put_SystemMetricSize(SMS_CAPTIONWIDTH, pState->schemeData.ncm.iCaptionWidth);
        hr = pSizeToSaveTo->put_SystemMetricSize(SMS_CAPTIONHEIGHT, pState->schemeData.ncm.iCaptionHeight);
        hr = pSizeToSaveTo->put_SystemMetricSize(SMS_SMCAPTIONWIDTH, pState->schemeData.ncm.iSmCaptionWidth);
        hr = pSizeToSaveTo->put_SystemMetricSize(SMS_SMCAPTIONHEIGHT, pState->schemeData.ncm.iSmCaptionHeight);
        hr = pSizeToSaveTo->put_SystemMetricSize(SMS_MENUWIDTH, pState->schemeData.ncm.iMenuWidth);
        hr = pSizeToSaveTo->put_SystemMetricSize(SMS_MENUHEIGHT, pState->schemeData.ncm.iMenuHeight);

        // Load Color
        for (int nIndex = 0; nIndex < ARRAYSIZE(pState->schemeData.rgb); nIndex++)
        {
            hr = pSizeToSaveTo->put_SystemMetricColor(nIndex, pState->schemeData.rgb[nIndex]);
        }
    }

    // We don't save the icon info if it is zero.  It should never be NULL in normal cases, except when
    // we are converting the settings in the upgrade case.
    if (SUCCEEDED(hr) && pState->nIcon)
    {
        hr = IconSize_Save(pState->nDXIcon, pState->nDYIcon, pState->nIcon, pState->nSmallIcon);
    }

    if (SUCCEEDED(hr))
    {
        enumThemeContrastLevels ContrastLevel = (pState->fHighContrast ? CONTRAST_HIGHBLACK : CONTRAST_NORMAL);
        pSizeToSaveTo->put_ContrastLevel(ContrastLevel);
    }


    return hr;
}





BOOL _GetRegValueString(HKEY hKey, LPCTSTR lpszValName, LPTSTR pszString, int cchSize)
{
    DWORD cbSize = sizeof(pszString[0]) * cchSize;
    DWORD dwType;
    DWORD dwError = RegQueryValueEx(hKey, lpszValName, NULL, &dwType, (LPBYTE)pszString, &cbSize);

    return (ERROR_SUCCESS == dwError);
}


//------------------------------------------------------------------------------------
//      SetRegValueString()
//
//      Just a little helper routine that takes string and writes it to the     registry.
//      Returns: success writing to Registry, should be always TRUE.
//------------------------------------------------------------------------------------
BOOL SetRegValueString(HKEY hMainKey, LPCTSTR pszSubKey, LPCTSTR pszRegValue, LPCTSTR pszString)
{
    HKEY hKey;
    BOOL fSucceeded = FALSE;
    DWORD dwDisposition;

    DWORD dwError = RegCreateKeyEx(hMainKey, pszSubKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hKey, &dwDisposition);
    if (ERROR_SUCCESS == dwError)
    {
        dwError = SHRegSetPath(hKey, NULL, pszRegValue, pszString, 0);
        if (ERROR_SUCCESS == dwError)
        {
            fSucceeded = TRUE;
        }

        RegCloseKey(hKey);
    }

    return fSucceeded;
}


//------------------------------------------------------------------------------------
//      GetRegValueString()
//
//      Just a little helper routine, gets an individual string value from the
//      registry and returns it to the caller. Takes care of registry headaches,
//      including a paranoid length check before getting the string.
//
//      Returns: success of string retrieval
//------------------------------------------------------------------------------------
BOOL GetRegValueString( HKEY hMainKey, LPCTSTR lpszSubKey, LPCTSTR lpszValName, LPTSTR lpszValue, int iMaxSize )
{
    HKEY hKey;                   // cur open key
    LONG lRet = RegOpenKeyEx( hMainKey, lpszSubKey, (DWORD)0, KEY_QUERY_VALUE, (PHKEY)&hKey );
    if( lRet == ERROR_SUCCESS )
    {
        BOOL fRet = _GetRegValueString(hKey, lpszValName, lpszValue, iMaxSize);

        // close subkey
        RegCloseKey( hKey );
        return fRet;
    }

    return FALSE;
}


//------------------------------------------------------------------------------------
//      SetRegValueDword()
//
//      Just a little helper routine that takes an dword and writes it to the
//      supplied location.
//
//      Returns: success writing to Registry, should be always TRUE.
//------------------------------------------------------------------------------------
BOOL SetRegValueDword( HKEY hk, LPCTSTR pSubKey, LPCTSTR pValue, DWORD dwVal )
{
    HKEY hkey = NULL;
    BOOL bRet = FALSE;

    if (ERROR_SUCCESS == RegOpenKey( hk, pSubKey, &hkey ))
    {
        if (ERROR_SUCCESS == RegSetValueEx(hkey, pValue, 0, REG_DWORD, (LPBYTE)&dwVal, sizeof(DWORD)))
        {
            bRet = TRUE;
        }
    }


    if (hkey)
    {
        RegCloseKey( hkey );
    }

    return bRet;
}


//------------------------------------------------------------------------------------
//      GetRegValueDword()
//
//      Just a little helper routine that takes an dword and writes it to the
//      supplied location.
//
//      Returns: success writing to Registry, should be always TRUE.
//------------------------------------------------------------------------------------
DWORD GetRegValueDword( HKEY hk, LPCTSTR pSubKey, LPCTSTR pValue )
{
    HKEY hkey = NULL;
    DWORD dwVal = REG_BAD_DWORD;

    if (ERROR_SUCCESS == RegOpenKey( hk, pSubKey, &hkey ))
    {
        DWORD dwType, dwSize = sizeof(DWORD);

        RegQueryValueEx( hkey, pValue, NULL, &dwType, (LPBYTE)&dwVal, &dwSize );
    }

    if (hkey)
    {
        RegCloseKey( hkey );
    }

    return dwVal;
}


//------------------------------------------------------------------------------------
//      SetRegValueInt()
//
//      Just a little helper routine that takes an int and writes it as a string to the
//      registry.
//
//      Returns: success writing to Registry, should be always TRUE.
//------------------------------------------------------------------------------------
BOOL SetRegValueInt( HKEY hMainKey, LPCTSTR lpszSubKey, LPCTSTR lpszValName, int iValue )
{
    TCHAR szValue[16];

    wnsprintf(szValue, ARRAYSIZE(szValue), TEXT("%d"), iValue);
    return SetRegValueString( hMainKey, lpszSubKey, lpszValName, szValue );
}


//------------------------------------------------------------------------------------
//      GetRegValueInt()
//
//      Just a little helper routine, gets an individual string value from the
//      registry and returns it to the caller as an int. Takes care of registry headaches,
//      including a paranoid length check before getting the string.
//
//      Returns: success of string retrieval
//------------------------------------------------------------------------------------
BOOL GetRegValueInt(HKEY hMainKey, LPCTSTR lpszSubKey, LPCTSTR lpszValName, int* piValue)
{
    TCHAR szValue[16];

    szValue[0] = 0;
    BOOL bOK = GetRegValueString( hMainKey, lpszSubKey, lpszValName, szValue, ARRAYSIZE(szValue));
    *piValue = StrToInt(szValue);

    return bOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\resource.h ===
/*****************************************************************************\
    FILE: resource.h

    DESCRIPTION:
        Header file for the resource file

    BryanSt 8/13/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#include <commctrl.h>


//  Features (This is where they are turned on and off)

// With this feature on, we add a "Theme Settings" button
// to the Theme tab.  This will open an advanced dialog to
// set a filter specifying which theme settings to apply
// when changing themes.  Users often get confused about the
// way this "Filter" works, so we are removing it on
// 10-23-2000 (JoelGros & GRaiz).  What users really want is
// layered settings and that this dialog's checkboxes will
// rollback those settings.  Way to late for this given it's
// low priority.
//#define FEATURE_THEME_SETTINGS_DIALOG

// This feature will enable a "Save As..." button on the Themes tab.
// Saving those themes will save the current .msstyles plus system metric
// values.
#define FEATURE_ENABLE_SAVEAS_THEMES


#define IDB_COLOR4               120
#define IDB_COLOR8               121
#define IDB_ENERGYSTAR           122
#define IDB_COLOR4DITHER         123
#define IDB_COLOR16              124
#define IDB_COLOR24              125
#define IDB_MONITOR              126


/////////////////////////////////////////////////////////////////////
// String Resource IDs (0x2000 - 0x10000)
/////////////////////////////////////////////////////////////////////
#define IDS_APPEARANCE_THEME_NAME                       2000
#define IDS_ADVDISPLAY_TITLE                            2001
#define IDS_SIZE_NORMAL                                 2002
#define IDS_NO_SKIN_DISPLAYNAME                         2003
#define IDS_CURRENT                                     2004
#define IDS_DEFAULT_APPEARANCES_SCHEME                  2005
#define IDS_CURRENTTHEME_DISPLAYNAME                    2006
#define IDS_THEMES_SUBDIR                               2007
#define IDS_THEMESUBDIR                                 2008
#define IDS_MYCUSTOMTHEME                               2009
#define IDS_THEME_OTHER                                 2010
#define IDS_THEME_FILETYPE                              2011
#define IDS_THEME_OPENTITLE                             2012
#define IDS_COMBO_EFFECTS_NOLIST                        2013
#define IDS_OLDTHEMENAME                                2014
#define IDS_PLUSTHEMESITE                               2015
#define IDS_THEME_CLASSIC_DISPNAME                      2016
#define IDS_THEME_PRO_DISPNAME                          2017
#define IDS_THEME_PER_DISPNAME                          2018
#define IDS_SCHEME_SIZE_NORMAL_CANONICAL                2019
#define IDS_SCHEME_SIZE_LARGE_CANONICAL                 2020
#define IDS_SCHEME_SIZE_EXTRALARGE_CANONICAL            2021
#define IDS_NONE                                        2022
#define IDS_SCREENRESFIXER_TITLE                        2023
#define IDS_SCREENRESFIXER_TEXT                         2024
#define IDS_MODIFIED_TEMPLATE                           2025
#define IDS_MODIFIED_FALLBACK                           2026
#define IDS_PROMSTHEME_DEFAULTCOLOR                     2027
#define IDS_PROMSTHEME_DEFAULTSIZE                      2028
#define IDS_CONMSTHEME_DEFAULTCOLOR                     2029
#define IDS_CONMSTHEME_DEFAULTSIZE                      2030
#define IDS_RETURNTOWELCOME                             2031
#define IDS_DEFAULTTHEMENAME                            2032
#define IDS_THEME_FILTER                                2033
#define IDS_CHANGESETTINGS_BADDUALVIEW                  2034
#define IDS_DEFAULT_APPEARANCES_SCHEME_CANONICAL        2035
#define IDS_THEMEFILE_WALLPAPER_PATH                    2036
#define IDS_THEMEFILE_FONT_CAPTION                      2037
#define IDS_THEMEFILE_FONT_SMCAPTION                    2038
#define IDS_THEMEFILE_FONT_MENU                         2039
#define IDS_THEMEFILE_FONT_STATUS                       2040
#define IDS_THEMEFILE_FONT_MESSAGE                      2041
#define IDS_THEMEFILE_FONT_ICON                         2042
#define IDS_THEMEFILE_CURSOR_SCHEME                     2043
#define IDS_DEFAULT_APPEARANCES_SIZE_CANONICAL          2044
#define IDS_SETTING_GEN_96DPI                           2045
#define IDS_SETTING_GEN_120DPI                          2046
#define IDS_SETTING_GEN_COMPAT_HELPLINK                 2047
#define IDS_SETUP_BETA2_UPGRADEWALLPAPER                2048
#define IDS_SCREENRESFIXER_ALTTEXT                      2049
#define IDS_PLEASEWAIT                                  2050
#define IDS_THEMEFILE_WALLPAPER_PATH_PER                2051

// Effects strings
//#define IDS_HELPFILE                                    2600  // AVAILABLE
#define IDS_NOICONSMSG1                                 2601
#define IDS_NOICONSMSG                                  2602
#define IDS_BADPATHMSG                                  2603
#define IDS_FONTSMOOTHWONTWORK                          2604
#define IDS_ICONCOLORWONTWORK                           2605
#define IDS_USE_LARGE                                   2613
#define IDS_256COLORPROBLEM                             2614

#define IDS_INVALIDPATH                                 2616
#define IDS_HELPFILE_PLUS                               2617
#define IDS_INTERNET                                    2619
#define IDS_DIRECTORY                                   2620
#define IDS_EFFECTS                                     2621
#define IDS_FADEEFFECT                                  2622
#define IDS_SCROLLEFFECT                                2623
#define IDS_CLEARTYPE                                   2624
#define IDS_STANDARDSMOOTHING                           2625
#define IDS_PAGE_TITLE                                  2626
#define IDS_UNKNOWNMONITOR                              2627
#define IDS_MULTIPLEMONITORS                            2628
#define MSG_CONFIGURATION_PROBLEM                       2629
#define IDS_OLD_DRIVER                                  2630
#define MSG_INVALID_OLD_DISPLAY_DRIVER                  2631
#define MSG_INVALID_NEW_DRIVER                          2632
#define MSG_INVALID_DEFAULT_DISPLAY_MODE                2633
#define MSG_INVALID_DISPLAY_DRIVER                      2634
#define MSG_INVALID_16COLOR_DISPLAY_MODE                2635
#define MSG_INVALID_DISPLAY_MODE                        2636
#define MSG_INVALID_CONFIGURATION                       2637
#define IDS_CHANGE_SETTINGS                             2638
#define IDS_CHANGESETTINGS_FAILED                       2639
#define IDS_REVERTBACK                                  2640
#define IDS_DISPLAYFORMAT                               2641
#define IDS_ADVDIALOGTITLE                              2642
#define IDS_TURNONTITLE                                 2643
#define IDS_TURNONMSG                                   2644
#define IDS_TURNITON                                    2645
#define IDS_SETTINGS_INVALID                            2646
#define IDS_SETTINGS_CANNOT_SAVE                        2648
#define IDS_SETTINGS_FAILED_SAVE                        2649
#define IDS_DYNAMIC_CHANGESETTINGS_FAILED               2650
#define IDS_TROUBLESHOOT_EXEC                           2651
#define IDS_NOTATTACHED                                 2652
#define IDS_PRIMARY                                     2653
#define IDS_SECONDARY                                   2654
#define ID_DSP_TXT_4BIT_COLOR                           2655
#define ID_DSP_TXT_8BIT_COLOR                           2656
#define ID_DSP_TXT_15BIT_COLOR                          2657
#define ID_DSP_TXT_16BIT_COLOR                          2658
#define ID_DSP_TXT_TRUECOLOR24                          2659
#define ID_DSP_TXT_TRUECOLOR32                          2660
#define ID_DSP_TXT_XBYY                                 2661
#define ID_DSP_TXT_CHANGE_FONT                          2662
#define ID_DSP_TXT_NEW_FONT                             2663
#define ID_DSP_TXT_ADMIN_INSTALL                        2664
#define ID_DSP_TXT_FONT_LATER                           2665
#define ID_DSP_CUSTOM_FONTS                             2666
#define ID_DSP_NORMAL_FONTSIZE_TEXT                     2667
#define ID_DSP_CUSTOM_FONTSIZE_TEXT                     2668
#define IDS_UNAVAILABLE                                 2669
#define IDS_10PTSAMPLEFACENAME                          2670
#define IDS_10PTSAMPLE                                  2671
#define IDS_RULERDIRECTION                              2672

// Theme fallback values
#define IDS_TFB_SOUND_DING                              2750        // Sounds
#define IDS_TFB_SOUND_NOTIFY                            2751
#define IDS_TFB_SOUND_CORD                              2752
#define IDS_TFB_SOUND_WINLOGON                          2753


// Error Strings
#define IDS_ERROR_TITLE_APPLYBASEAPPEARANCE             3000
#define IDS_ERROR_APPLYBASEAPPEARANCE                   3001
#define IDS_ERROR_APPLYBASEAPPEARANCE_LOADTHEME         3002
#define IDS_ERROR_UNKNOWN                               3003
#define IDS_ERROR_TITLE_APPLYBASEAPPEARANCE2            3004
#define IDS_ERROR_THEME_INVALID_TITLE                   3005
#define IDS_ERROR_THEME_INVALID                         3006
#define IDS_ERROR_THEME_SERVICE_NOTRUNNING              3007
#define IDS_ERROR_THEME_LOADFAILED                      3008
#define IDS_ERROR_THEME_DELETE                          3009
#define IDS_ERROR_THEME_DELETE_TITLE                    3010
#define IDS_ERROR_THEME_FILE_NOTFOUND                   3011
#define IDS_ERROR_TITLE_LOAD_MSSTYLES_FAIL              3012
#define IDS_ERROR_LOAD_MSSTYLES_FAIL                    3013


// Legacy Appearance Scheme Upgrade Mappings  (800 - 1000)
#define IDS_LEGACYSCHEME_NAME                           800         // 800-849
#define IDS_NEWSTYLE_NAME                               850         // 850-899
#define IDS_NEWSIZE_NAME                                900         // 900-949
#define IDS_NEWCONTRASTFLAGS                            950         // 950-999
#define IDS_LOCALIZATIONPOINTER                        1000         // 1000-1049

#define MAX_LEGACY_UPGRADE_SCENARIOS                    36


/////////////////////////////////////////////////////////////////////
// Dialogs  (1000 - 1100)
/////////////////////////////////////////////////////////////////////
// Base Pages
#define DLG_THEMESPG                                    1000
#define DLG_APPEARANCEPG                                1001
// Advanced Pages
#define DLG_APPEARANCE_ADVANCEDPG                       1002
#define DLG_THEMESETTINGSPG                             1003
// Supporting Dialogs
#define DLG_COLORPICK                                   1005
#define DLG_EFFECTS                                     1006
// Settings Pages
#define DLG_SINGLEMONITOR                               1007
#define DLG_MULTIMONITOR                                1008
#define DLG_WIZPAGE                                     1009
#define DLG_GENERAL                                     1010
#define DLG_KEEPNEW                                     1011
#define DLG_CUSTOMFONT                                  1012
#define DLG_ASKDYNACDS                                  1013
#define DLG_FAKE_SETTINGS                               1014
#define DLG_SCREENSAVER                                 1015
#define DLG_KEEPNEW2                                    1016
#define DLG_KEEPNEW3                                    1017

/////////////////////////////////////////////////////////////////////
// Dialog Controls  (1101 - 2000)
/////////////////////////////////////////////////////////////////////
//// Base Pages
// Themes Page controls
#define IDC_THPG_THEMELIST                              1101
#define IDC_THPG_THEMESETTINGS                          1102
#define IDC_THPG_THEME_PREVIEW                          1103
#define IDC_THPG_THEMEDESCRIPTION                       1104
#define IDC_THPG_THEMENAME                              1105
#define IDC_THPG_SAMPLELABLE                            1106
#define IDC_THPG_SAVEAS                                 1107
#define IDC_THPG_DELETETHEME                            1108


// Appearance Page controls
#define IDC_APPG_APPEARPREVIEW                          1110
#define IDC_APPG_LOOKFEEL                               1111
#define IDC_APPG_LOOKFEEL_LABLE                         1112
#define IDC_APPG_COLORSCHEME_LABLE                      1113
#define IDC_APPG_COLORSCHEME                            1114
#define IDC_APPG_WNDSIZE_LABLE                          1115
#define IDC_APPG_WNDSIZE                                1116
#define IDC_APPG_ADVANCED                               1117
#define IDC_APPG_EFFECTS                                1118
#define IDC_APPG_TESTFAULT                              1119

//// Advanced Pages
// Advanced Appearance controls
#define IDC_ADVAP_LOOKPREV                              1125
#define IDC_ADVAP_ELEMENTS                              1126
#define IDC_ADVAP_SIZELABEL                             1127
#define IDC_ADVAP_MAINSIZE                              1128
#define IDC_ADVAP_FONTNAME                              1129
#define IDC_ADVAP_FONTSIZE                              1130
#define IDC_ADVAP_FONTBOLD                              1131
#define IDC_ADVAP_FONTITAL                              1132
#define IDC_ADVAP_SIZEARROWS                            1133
#define IDC_ADVAP_COLORLABEL                            1134
#define IDC_ADVAP_MAINCOLOR                             1135
#define IDC_ADVAP_TEXTCOLOR                             1136
#define IDC_ADVAP_FONTLABEL                             1137
#define IDC_ADVAP_FNCOLORLABEL                          1138
#define IDC_ADVAP_FONTSIZELABEL                         1139
#define IDC_ADVAP_GRADIENTLABEL                         1140
#define IDC_ADVAP_GRADIENT                              1141
#define IDC_ADVAP_ELEMENTSLABEL                         1142
// Theme Settings controls
#define IDC_TSPG_THEMELIST_LABLE                        1150
#define IDC_TSPG_THEME_NAME                             1151
#define IDC_TSPG_SAVEASBUTTON                           1152
#define IDC_TSPG_DELETEBUTTON                           1153
#define IDC_TSPG_CB_SCREENSAVER                         1154 // Previously CB_SCRSVR
#define IDC_TSPG_CB_SOUNDS                              1155 // Previously CB_SOUND
#define IDC_TSPG_CB_MOUSE                               1156 // Previously CB_PTRS
#define IDC_TSPG_CB_WALLPAPER                           1157 // Previously CB_WALL
#define IDC_TSPG_CB_ICONS                               1158 // Previously CB_ICONS
#define IDC_TSPG_CB_COLORS                              1159 // Previously CB_COLORS
#define IDC_TSPG_CB_FONTS                               1160 // Previously CB_FONTS
#define IDC_TSPG_CB_BORDERS                             1161 // Previously CB_BORDERS
#define IDC_TSPG_CB_GROUP_LABEL                         1162
#define IDC_TSPG_CB_LABEL                               1163

// Effects
#define IDC_FULLWINDOWDRAGGING                          1170
#define IDC_FONTSMOOTHING                               1171
#define IDC_ICONHIGHCOLOR                               1172
#define IDC_STRETCHWALLPAPERFITSCREEN                   1173
#define IDD_PATH                                        1174
#define IDC_MENUANIMATION                               1175
#define IDD_ICON                                        1176
#define IDC_FONTSMOOTH                                  1177
#define IDD_BROWSE                                      1178
#define IDC_SHOWDRAG                                    1179
#define IDC_LARGEICONS                                  1180
#define IDC_KEYBOARDINDICATORS                          1181
#define IDC_COMBOEFFECT                                 1182
#define IDC_SHOWME                                      1183
#define IDC_COMBOFSMOOTH                                1184
#define IDC_MENUSHADOWS                                 1185
#define IDC_GRPBOX_2                                    1186
                     
                        

//// Supporting Dialogs
// Color Picker Dialog controls
#define IDC_CPDLG_16COLORS                              1205
#define IDC_CPDLG_COLORCUST                             1206
#define IDC_CPDLG_COLOROTHER                            1207
#define IDC_CPDLG_COLORETCH                             1208


// Screen Saver Dialog
#define IDC_CHOICES                                     1300
#define IDC_METHOD                                      1301
#define IDC_BIGICONSS                                   1302
#define IDC_SETTING                                     1303
#define IDC_TEST                                        1304
#define IDC_ENERGYSTAR_BMP                              1305
#define IDC_SCREENSAVEDELAY                             1306
#define IDC_SCREENSAVEARROW                             1307
#define IDC_LOWPOWERCONFIG                              1314

#define IDC_DEMO                                        1315
#define IDC_SSDELAYLABEL                                1316
#define IDC_ENERGY_TEXT                                 1317
#define IDC_ENERGY_TEXT2                                1318
#define IDC_ENERGY_TEXT3                                1319
#define IDC_USEPASSWORD                                 1320
#define IDC_SETPASSWORD                                 1321
#define IDC_SSDELAYSCALE                                1322
  


#define IDC_NO_HELP_2                                   201     // should be disabled for a control

// these need to be all clumped together because they are treated as a group
#define IDC_STARTMAINCOLOR      1500
#define IDC_CUSTOMMAINCOLOR     1549
#define IDC_ENDMAINCOLOR        IDC_CUSTOMMAINCOLOR
#define IDC_STARTTEXTCOLOR      1550
#define IDC_CUSTOMTEXTCOLOR     1599
#define IDC_ENDTEXTCOLOR        IDC_CUSTOMTEXTCOLOR
#define IDC_GRADIENT            1600

// Multimonitor controls

#define IDC_DISPLAYLIST         1800
#define IDC_DISPLAYDESK         1801
#define IDC_DISPLAYPROPERTIES   1802
#define IDC_DISPLAYNAME         1803
#define IDC_DISPLAYMODE         1804
#define IDC_DISPLAYUSEME        1805
#define IDC_DISPLAYPRIME        1806
#define IDC_COLORBOX            1807 // used to be ID_DSP_COLORBOX
#define IDC_SCREENSIZE          1808 // used to be ID_DSP_AREA_SB
#define IDC_FLASH               1810
#define IDC_DISPLAYTEXT         1811
#define IDC_SCREENSAMPLE        1812
#define IDC_COLORSAMPLE         1813
#define IDC_RESXY               1814
#define IDC_RES_LESS            1815
#define IDC_RES_MORE            1816
#define IDC_COLORGROUPBOX       1817
#define IDC_RESGROUPBOX         1818
#define IDC_MULTIMONHELP        1819
#define IDC_DISPLAYLABEL        1820
#define IDC_TROUBLESHOOT        1821
#define IDC_IDENTIFY            1822
#define IDC_WARNING_ICON        1823
#define IDC_DISABLEDMONITORS_MESSAGE        1824
#define IDC_DSP_CLRPALGRP       1825
#define IDC_DSP_COLORBAR        1826
#define IDC_DSP_DSKAREAGRP      1827
#define IDC_REFRESH_RATE        1828
#define IDC_MONITOR_BITMAP      1829
#define IDC_BIGICON             1830
#define IDC_COUNTDOWN           1831
#define IDC_FONTSIZEGRP         1832
#define IDC_FONT_SIZE           1833
#define IDC_CUSTFONTPER         1834
#define IDC_FONT_SIZE_STR       1835
#define IDC_DYNA_TEXT           1836
#define IDC_DYNA                1837
#define IDC_NODYNA              1838
#define IDC_YESDYNA             1839
#define IDC_SHUTUP              1840
#define IDC_CUSTOMSAMPLE        1841
#define IDC_CUSTOMRULER         1842
#define IDC_CUSTOMCOMBO         1843
#define IDC_NO_HELP_1           1844
#define IDC_FONTLIST            1845
#define IDC_CUSTOMFONT          1846
#define IDC_CHANGEDRV           1847
#define IDC_SETTINGS_GEN_COMPATWARNING 1848
#define IDC_PROGRESS            1849



// appearance elements
#define ELNAME_DESKTOP          1401
#define ELNAME_INACTIVECAPTION  1402
#define ELNAME_INACTIVEBORDER   1403
#define ELNAME_ACTIVECAPTION    1404
#define ELNAME_ACTIVEBORDER     1405
#define ELNAME_MENU             1406
#define ELNAME_MENUSELECTED     1407
#define ELNAME_WINDOW           1408
#define ELNAME_SCROLLBAR        1409
#define ELNAME_BUTTON           1410
#define ELNAME_SMALLCAPTION     1411
#define ELNAME_ICONTITLE        1412
#define ELNAME_CAPTIONBUTTON    1413
#define ELNAME_DISABLEDMENU     1414
#define ELNAME_MSGBOX           1415
#define ELNAME_SCROLLBUTTON     1416
#define ELNAME_APPSPACE         1417
#define ELNAME_SMCAPSYSBUT      1418
#define ELNAME_SMALLWINDOW      1419
#define ELNAME_DXICON           1420
#define ELNAME_DYICON           1421
#define ELNAME_INFO             1422
#define ELNAME_ICON             1423
#define ELNAME_SMICON           1424
#define ELNAME_HOTTRACKAREA     1425

// appearance strings for sample
#define IDS_ACTIVE              1450
#define IDS_INACTIVE            1451
#define IDS_MINIMIZED           1452
#define IDS_ICONTITLE           1453
#define IDS_NORMAL              1454
#define IDS_DISABLED            1455
#define IDS_SELECTED            1456
#define IDS_MSGBOX              1457
#define IDS_BUTTONTEXT          1458
#define IDS_SMCAPTION           1459
#define IDS_WINDOWTEXT          1460
#define IDS_MSGBOXTEXT          1461

#define IDS_BLANKNAME           1480
#define IDS_NOSCHEME2DEL        1481

#define IDS_SCHEME_WARNING       1300
#define IDS_FONTCHANGE_IN_SCHEME 1301
#define IDS_COPYOF_SCHEME        1302








/////////////////////////////////////////////////////////////////////
// Help defines (??? -????)
/////////////////////////////////////////////////////////////////////
// Settings tab
#define IDH_DISPLAY_SETTINGS_MONITOR_GRAPHIC            4064  
#define IDH_DISPLAY_SETTINGS_DISPLAY_LIST               4065  
#define IDH_DISPLAY_SETTINGS_COLORBOX                   4066 
#define IDH_DISPLAY_SETTINGS_SCREENAREA                 4067
#define IDH_DISPLAY_SETTINGS_EXTEND_DESKTOP_CHECKBOX    4068  
#define IDH_DISPLAY_SETTINGS_ADVANCED_BUTTON            4069 
#define IDH_DISPLAY_SETTINGS_USE_PRIMARY_CHECKBOX       4072
#define IDH_DISPLAY_SETTINGS_IDENTIFY_BUTTON            4073
#define IDH_DISPLAY_SETTINGS_TROUBLE_BUTTON             4074


#define IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_FONTSIZE      4080
#define IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_DYNA          4081
#define IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_RESTART       4082
#define IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_DONT_RESTART  4083 
#define IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_ASK_ME        4084

#define IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_CUSTOMFONT_LISTBOX    4085
#define IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_CUSTOMFONT_RULER      4086
#define IDH_DISPLAY_SETTINGS_ADVANCED_GENERAL_CUSTOMFONT_SAMPLE     4087

// Screen saver tab
#define IDH_DISPLAY_SCREENSAVER_SCREENSAVER_PASSWORD_CHECKBOX 4110
#define IDH_DISPLAY_SCREENSAVER_SCREENSAVER_LISTBOX           4111
#define IDH_DISPLAY_SCREENSAVER_SCREENSAVER_WAIT              4112
#define IDH_DISPLAY_SCREENSAVER_SCREENSAVER_PREVIEW           4113
#define IDH_DISPLAY_SCREENSAVER_SCREENSAVER_SETTINGS          4114
#define IDH_DISPLAY_SCREENSAVER_SCREENSAVER_MONITOR           4115
#define IDH_DISPLAY_SCREENSAVER_ENERGYSAVE_GRAPHIC            4116
#define IDH_DISPLAY_SCREENSAVER_POWER_BUTTON                  4117

// Advanced Appearance Tab
#define IDH_DISPLAY_APPEARANCE_SCHEME                   4120
#define IDH_DISPLAY_APPEARANCE_SAVEAS_BUTTON            4121
#define IDH_DISPLAY_APPEARANCE_SAVEAS_DIALOG_TEXTBOX    4170
#define IDH_DISPLAY_APPEARANCE_DELETE_BUTTON            4122
#define IDH_DISPLAY_APPEARANCE_GRAPHIC                  4123
#define IDH_DISPLAY_APPEARANCE_ITEM_SIZE                4124
#define IDH_DISPLAY_APPEARANCE_FONT_BOLD                4125
#define IDH_DISPLAY_APPEARANCE_FONT_SIZE                4126
#define IDH_DISPLAY_APPEARANCE_FONT_COLOR               4127
#define IDH_DISPLAY_APPEARANCE_FONT_ITALIC              4128
#define IDH_DISPLAY_APPEARANCE_ITEM_COLOR               4129
#define IDH_DISPLAY_APPEARANCE_ITEM_LIST                4130
#define IDH_DISPLAY_APPEARANCE_FONT_LIST                4131
#define IDH_DISPLAY_APPEARANCE_GRADIENT                 4132
#define IDH_DISPLAY_APPEARANCE_ITEM_COLOR2              4133

// display.hlp IDH_'s
#define IDH_DISPLAY_EFFECTS_DESKTOP_ICONS               4300
#define IDH_DISPLAY_EFFECTS_CHANGE_ICON_BUTTON          4301
#define IDH_DISPLAY_EFFECTS_ALL_COLORS_CHECKBOX         4302
#define IDH_DISPLAY_EFFECTS_DRAG_WINDOW_CHECKBOX        4303
#define IDH_DISPLAY_EFFECTS_SMOOTH_FONTS_CHECKBOX       4304
//#define IDH_DISPLAY_EFFECTS_STRETCH                   4305    //Obsolete in NT5
#define IDH_DISPLAY_EFFECTS_ANIMATE_WINDOWS             4305
#define IDH_DISPLAY_EFFECTS_LARGE_ICONS_CHECKBOX        4306
#define IDH_DISPLAY_EFFECTS_DEFAULT_ICON_BUTTON         4307
#define IDH_DISPLAY_EFFECTS_HIDE_KEYBOARD_INDICATORS    4308
#define IDH_DISPLAY_EFFECTS_SMOOTH_FONTS_LISTBOX        4309
#define IDH_DISPLAY_EFFECTS_ANIMATE_LISTBOX             4310
#define IDH_DISPLAY_EFFECTS_MENUSHADOWS                 4311


/////////////////////////////////////////////////////////////////////
// Wizard Pages  (401 - 500)
/////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////
// Menu IDs (501 - 530)
/////////////////////////////////////////////////////////////////////
// appearance preview menu
#define IDR_MENU                                        501
#define MENU_MONITOR                                    502

/////////////////////////////////////////////////////////////////////
// Menu Item IDs (531 - 600)
/////////////////////////////////////////////////////////////////////
#define IDM_NORMAL                                      531
#define IDM_DISABLED                                    532
#define IDM_SELECTED                                    533


/////////////////////////////////////////////////////////////////////
// Bitmap Resource IDs (601 - 700)
/////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////
// Icons IDs (701 - 800)
/////////////////////////////////////////////////////////////////////
#define IDS_ICON                                        40                // This icon is actually stored in desk.cpl
#define IDI_THEMEICON                                   701               // This icon is for .theme and .msstyles files.


/////////////////////////////////////////////////////////////////////
// AVI Resource IDs (801 - 900)
/////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\screenresfixer.cpp ===
//#include "cabinet.h"
#include "priv.h"
#include <regstr.h>
#include <atlcom.h>
#include <shguidp.h>
#include <shlguid.h>

typedef struct
{
    DWORD dwWidth;
    DWORD dwHeight;
    DWORD dwColor;
    BOOL fAvailable;
} SCREENMODE;

class ATL_NO_VTABLE CScreenResFixer :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CScreenResFixer, &CLSID_ScreenResFixer>,
    public IContextMenu,
    public IScreenResFixer
{
public:
    CScreenResFixer() {}
    virtual ~CScreenResFixer() {}

    DECLARE_NOT_AGGREGATABLE(CScreenResFixer)

    BEGIN_COM_MAP(CScreenResFixer)
        COM_INTERFACE_ENTRY_IID(IID_IContextMenu, IContextMenu)
        COM_INTERFACE_ENTRY(IScreenResFixer)
    END_COM_MAP()

    // *** IContextMenu methods ***
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT iIndexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags) { return E_NOTIMPL; }
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax) { return E_NOTIMPL; }

private:
    int _PickScreenResolution(SCREENMODE* modes, int cModes);
    HRESULT _FixScreenResolution(BOOL fShowDisplayCPL);
};

// *** IContextMenu methods ***
STDMETHODIMP CScreenResFixer::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    WCHAR szTitle[256];
    HRESULT hr;

    szTitle[0] = 0;
    LoadString(HINST_THISDLL, IDS_SCREENRESFIXER_TITLE, szTitle, ARRAYSIZE(szTitle));

    BOOL fOK = FALSE;
    if (lpici)
    {
        WCHAR szText[512];
        szText[0] = 0;
        LoadString(HINST_THISDLL, IDS_SCREENRESFIXER_TEXT, szText, ARRAYSIZE(szText));
        fOK = (IDYES == SHMessageBoxCheck(NULL, szText, szTitle, MB_YESNO, 0, TEXT("ScreenCheck")));
    }
    else
    {
        WCHAR szText[512];
        szText[0] = 0;
        LoadString(HINST_THISDLL, IDS_SCREENRESFIXER_ALTTEXT, szText, ARRAYSIZE(szText));
        fOK = (IDOK == MessageBox(NULL, szText, szTitle, MB_OK));
    }

    if (fOK)
    {
        hr = _FixScreenResolution(!(lpici == NULL));
    }
    else
    {
        // If the user checked "Don't show me again" then force this setting into HKLM, so that it doesn't
        // show up for any users
        if (!SHRegGetBoolUSValue(REGSTR_PATH_EXPLORER TEXT("\\DontShowMeThisDialogAgain"), TEXT("ScreenCheck"), FALSE, TRUE))
        {
            SHRegSetUSValueW(REGSTR_PATH_EXPLORER TEXT("\\DontShowMeThisDialogAgain"), TEXT("ScreenCheck"), REG_SZ, L"no", sizeof(L"no"), SHREGSET_HKLM);
        }

        hr = S_OK;
    }

    // Now that the user finished with their screen resolution, tell the Start Menu
    // it's okay to pop up.
    HWND hwndTray = FindWindow(TEXT(WNDCLASS_TRAYNOTIFY), NULL);
    if (hwndTray)
        PostMessage(hwndTray, RegisterWindowMessage(TEXT("Welcome Finished")), 0, 0);

    return hr;
}

int CScreenResFixer::_PickScreenResolution(SCREENMODE* modes, int cModes)
{
    static const struct {
        int iMinWidth;
        int iMinHeight;
        int iMaxWidth;
        int iMaxHeight;
        int iIdealColor;
    } 
    picker[] = 
    {
        {  800, 600, 1024, 768, 32 },
        {  800, 600, 1024, 768, 24 },
        {  800, 600, 1024, 768, -1 },
        { 1024, 768,   -1,  -1, 32 },
        { 1024, 768,   -1,  -1, 24 },
        { 1024, 768,   -1,  -1, -1 },
    };

    for (int i = 0; i < ARRAYSIZE(picker); i++)
    {
        // Try for Ideal Color in given resolution range
        for (int iMode = 0; iMode < cModes; iMode++)
        {
            
            if ((modes[iMode].fAvailable) &&
                (modes[iMode].dwWidth >= (DWORD)picker[i].iMinWidth) &&
                (modes[iMode].dwHeight >= (DWORD)picker[i].iMinHeight))
            {
                if ((picker[i].iMaxWidth == -1) ||
                    ((modes[iMode].dwWidth < (DWORD)picker[i].iMaxWidth) &&
                     (modes[iMode].dwHeight < (DWORD)picker[i].iMaxHeight)))
                {
                    if (((picker[i].iIdealColor == -1) && (modes[iMode].dwColor >= 15)) ||
                        (modes[iMode].dwColor == (DWORD)picker[i].iIdealColor))
                    {
                        return iMode;
                    }
                }
            }
        }
    }

    return -1;
}

void UpdateRecycleBinInfo()
{
    static const LPTSTR lpszSubkey = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ScreenResFixer");
    static const LPTSTR lpszValue = TEXT("AdjustRecycleBinPosition");

    //Read if the we have done it once already.
    DWORD dwAdjustPos = 0; //Assume that Recycle-bin has been already positioned.
    DWORD dwSize = sizeof(dwAdjustPos);
    
    SHRegGetUSValue(lpszSubkey, lpszValue, NULL, &dwAdjustPos, &dwSize, FALSE, &dwAdjustPos, dwSize);
    // 0 => Recycle-bin hasn't been positioned because of resolution fixer.
    // 1 => Recycle-bin needs to be repositioned. It has't happened yet!
    // 2 => Recycle-bin has already been re-positioned. Nothing needs to be done here!
    if(dwAdjustPos == 0)
    {
        // 0 => Recycle-bin hasn't been positioned because of resolution fixer.
        // So, we need to change the settings sothat when desktop.cpp responds to res change,
        // it will position the recycle-bin.
        dwAdjustPos = 1;
        SHRegSetUSValue(lpszSubkey, lpszValue, REG_DWORD, &dwAdjustPos, sizeof(dwAdjustPos), SHREGSET_HKCU | SHREGSET_FORCE_HKCU);
    }
}

HRESULT CScreenResFixer::_FixScreenResolution(BOOL fShowDisplayCPL)
{
    IDisplaySettings * pds;

    HRESULT hr = CoCreateInstance(CLSID_DisplaySettings, NULL, CLSCTX_INPROC_SERVER,
                 IID_PPV_ARG(IDisplaySettings, &pds));

    if (SUCCEEDED(hr))
    {
        for (DWORD dwMon = 0; SUCCEEDED(pds->SetMonitor(dwMon)); dwMon++)
        {
            BOOL fAttached = FALSE;
            hr = pds->GetAttached(&fAttached);
            if (SUCCEEDED(hr) && fAttached)
            {
                DWORD dwWidth, dwHeight, dwColor;
                hr = pds->GetSelectedMode(&dwWidth, &dwHeight, &dwColor);
                if (SUCCEEDED(hr) && ((dwWidth < 800) || (dwHeight < 600) || (dwColor < 15)))
                {
                    DWORD cModes = 0;
                    hr = pds->GetModeCount(&cModes, TRUE);

                    if (SUCCEEDED( hr ) && (cModes > 0))
                    {
                        SCREENMODE* modes = new SCREENMODE[cModes];
                        if (modes)
                        {
                            for (DWORD i = 0; i < cModes; i++)
                            {
                                hr = pds->GetMode(i, TRUE, &modes[i].dwWidth, &modes[i].dwHeight, &modes[i].dwColor);
                                modes[i].fAvailable =  SUCCEEDED(hr) && ((i <= 0) || 
                                                        (modes[i].dwWidth != modes[i-1].dwWidth) ||
                                                        (modes[i].dwHeight != modes[i-1].dwHeight) ||
                                                        (modes[i].dwColor != modes[i-1].dwColor));
                            }

                            int iMode = _PickScreenResolution(modes, cModes);
                            if (iMode != -1)
                            {
                                static BOOL fRecycleBinInfoUpdated = FALSE; //to begin with!
                                //We are about to change the mode. Make a note in registry
                                if(!fRecycleBinInfoUpdated)
                                {
                                    UpdateRecycleBinInfo();
                                    fRecycleBinInfoUpdated = TRUE;
                                }
                                
                                BOOL fApplied = FALSE;
                                pds->SetSelectedMode(NULL, modes[iMode].dwWidth, modes[iMode].dwHeight, modes[iMode].dwColor, &fApplied, fShowDisplayCPL ? DS_BACKUPDISPLAYCPL : 0);
                                if (!fApplied)
                                {
                                    hr = E_FAIL;
                                }
                            }

                            delete [] modes;
                            modes = NULL;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                }
            }
        }
    }

    return hr;
}


HRESULT CScreenResFixer_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj)
{
    HRESULT hr = E_INVALIDARG;

    if (!punkOuter && ppvObj)
    {
        CComObject<CScreenResFixer> * pThis = new CComObject<CScreenResFixer>();

        *ppvObj = NULL;
        if (pThis)
        {
            hr = pThis->QueryInterface(riid, ppvObj);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\screensaverpg.h ===
/*****************************************************************************\
    FILE: ScreenSaverPg.cpp

    DESCRIPTION:
        This file contains the COM object implementation that will display the
    ScreenSaver tab in the Display Control Panel.

    18-Feb-94   (Tracy Sharpe) Added power management functionality.
               Commented out several pieces of code that weren't being
               used.
    5/30/2000 (Bryan Starbuck) BryanSt: Turned into C++ and COM.  Exposed
              as an API so other tabs can communicate with it.  This enables
              the Plus! Theme page to modify the screen saver.

    Copyright (C) Microsoft Corp 1994-2000. All rights reserved.
\*****************************************************************************/

#ifndef _SSDLG_H
#define _SSDLG_H


HRESULT CScreenSaverPage_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);


#endif // _SSDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\screenresfixer.h ===
#ifndef SCREENRESFIXER_H
#define SCREENRESFIXER_H

HRESULT CScreenResFixer_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);

typedef struct
{
    DWORD dwWidth;
    DWORD dwHeight;
    DWORD dwColor;
    BOOL fAvailable;
} SCREENMODE;

class CScreenResFixer : public IContextMenu
{
public:
    CScreenResFixer() {}
    virtual ~CScreenResFixer() {}

    // *** IUnknown methods
    STDMETHODIMP  QueryInterface(REFIID riid, PVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // *** IContextMenu methods ***
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT iIndexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags) { return E_NOTIMPL; }
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax) { return E_NOTIMPL; }

private:
    LONG _cRef;

    int _PickScreenResolution(SCREENMODE* modes, int cModes);
    void _FixScreenResolution(BOOL fShowDisplayCPL);
};

#endif // SCREENRESFIXER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\screensaverpg.cpp ===
/*****************************************************************************\
    FILE: ScreenSaverPg.cpp

    DESCRIPTION:
        This file contains the COM object implementation that will display the
    ScreenSaver tab in the Display Control Panel.

    18-Feb-94   (Tracy Sharpe) Added power management functionality.
               Commented out several pieces of code that weren't being
               used.
    5/30/2000 (Bryan Starbuck) BryanSt: Turned into C++ and COM.  Exposed
              as an API so other tabs can communicate with it.  This enables
              the Plus! Theme page to modify the screen saver.
    11/08/2000 (Bryan Starbuck) BryanSt: Moved from \nt\shell\cpls\desknt5 to
              \nt\shell\themes\themeui\.

    Copyright (C) Microsoft Corp 1994-2000. All rights reserved.
\*****************************************************************************/


#include "priv.h"
#pragma hdrstop

#include <scrnsave.h>

#include "exe.h"
#include "ScreenSaverPg.h"
#include <MSGinaExports.h>  // for ShellIsFriendlyUIActive, etc..


#define         SFSE_SYSTEM     0
#define         SFSE_PRG        1
#define         SFSE_WINDOWS    2
#define         SFSE_FILE       3

#define         MAX_METHODS     100
#define         MIN_MINUTES     1
#define         MAX_MINUTES     9999    //The UI will allow upto four digits. 
#define         BUFFER_SIZE     400

#define WMUSER_SETINITSS        (WM_USER + 1)

/* Local funcprototypes... */
void  SearchForScrEntries     ( UINT, LPCTSTR );
BOOL  FreeScrEntries          ( void );
int   lstrncmp                ( LPTSTR, LPTSTR, int );
LPTSTR FileName                ( LPTSTR szPath);
LPTSTR StripPathName           ( LPTSTR szPath);
LPTSTR NiceName                ( LPTSTR szPath);

void  AddBackslash(LPTSTR pszPath);
void  AppendPath(LPTSTR pszPath, LPTSTR pszSpec);

PTSTR  PerformCheck(LPTSTR, BOOL);
void  DoScreenSaver(HWND hDlg, BOOL b);

void ScreenSaver_AdjustTimeouts(HWND hWnd,int BaseControlID);
void EnableDisablePowerDelays(HWND hDlg);

TCHAR   g_szSaverName[MAX_PATH];                    // Screen Saver EXE
HICON  hDefaultIcon = NULL;
HICON  hIdleWildIcon;
BOOL    bWasConfig=0;   // We were configing the screen saver
HWND    g_hwndTestButton;
HWND    g_hwndLastFocus;
BOOL    g_fPasswordWasPreviouslyEnabled = FALSE;
BOOL    g_fPasswordDirty = FALSE;                   // tells us if the user has actually changed the state of the password combobox
BOOL    g_fFriendlyUI = FALSE;                 // is winlogon going to switch back to the welcome screen, or call LockWorkStation for real?
BOOL    g_fPasswordBoxDeterminedByPolicy = FALSE;
BOOL    g_fSettingsButtonOffByPolicy = FALSE;
BOOL    g_fTimeoutDeterminedByPolicy = FALSE;
BOOL    g_fScreenSaverExecutablePolicy = FALSE;
// Local global variables

HICON  hIcons[MAX_METHODS];
UINT   wNumMethods = 0;
PTSTR   aszMethods[MAX_METHODS];
PTSTR   aszFiles[MAX_METHODS];

static const TCHAR c_szDemoParentClass[] = TEXT("SSDemoParent");

//  static TCHAR szFileNameCopy[MAX_PATH];
static int  g_iMethod;
static BOOL g_fPreviewActive;
static BOOL g_fAdapPwrMgnt = FALSE;

/*
 * Registry value for the "Password Protected" check box
 *
 * These are different for NT and Win95 to keep screen
 * savers built exclusivly for Win95 from trying to
 * handle password checks.  (NT does all password checking
 * in the built in security system to maintain C2
 * level security)
 */

#   define SZ_USE_PASSWORD     TEXT("ScreenSaverIsSecure")
#   define PWRD_REG_TYPE       REG_SZ
#   define CCH_USE_PWRD_VALUE  2
#   define CB_USE_PWRD_VALUE   (CCH_USE_PWRD_VALUE * SIZEOF(TCHAR))
TCHAR gpwdRegYes[CCH_USE_PWRD_VALUE] = TEXT("1");
TCHAR gpwdRegNo[CCH_USE_PWRD_VALUE]  = TEXT("0");
#define PasswdRegData(f)    ((f) ? (PBYTE)gpwdRegYes : (PBYTE)gpwdRegNo)

UDACCEL udAccel[] = {{0,1},{2,5},{4,30},{8,60}};

#include "help.h"

#define IDH_DESK_LOWPOWERCFG IDH_SCRSAVER_GRAPHIC

//  To simplify some things, the base control ID of a time control is associated
//  with its corresponding ClassicSystemParametersInfo action codes.
typedef struct {
    int taBaseControlID;
    UINT taGetTimeoutAction;
    UINT taSetTimeoutAction;
    UINT taGetActiveAction;
    UINT taSetActiveAction;
}   TIMEOUT_ASSOCIATION;

//  Except for the case of the "screen save" delay, each time grouping has three
//  controls-- a switch to determine whether that time should be used or not and
//  an edit box and an updown control to change the delay time.  ("Screen save"
//  is turned off my choosing (None) from the screen saver list)  These three
//  controls must be organized as follows:
#define BCI_DELAY               0
#define BCI_ARROW               1
#define BCI_SWITCH              2

//  Associations between base control IDs and ClassicSystemParametersInfo action codes.
//  The TA_* #defines are used as symbolic indexes into this array.  Note that
//  TA_SCREENSAVE is a special case-- it does NOT have a BCI_SWITCH.
#define TA_SCREENSAVE           0

TIMEOUT_ASSOCIATION g_TimeoutAssociation[] = {
    IDC_SCREENSAVEDELAY, SPI_GETSCREENSAVETIMEOUT, SPI_SETSCREENSAVETIMEOUT,
    SPI_GETSCREENSAVEACTIVE, SPI_SETSCREENSAVEACTIVE,
};

int g_Timeout[] = {
    0,
    0,
    0,
};

HBITMAP g_hbmDemo = NULL;
HBITMAP g_hbmEnergyStar = NULL;
BOOL g_bInitSS = TRUE;          // assume we are in initialization process
BOOL g_bChangedSS = FALSE;      // changes have been made






class CScreenSaverPg            : public CObjectWithSite
                                , public CObjectCLSID
                                , public IBasePropPage
                                , public IPropertyBag
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IBasePropPage ***
    virtual STDMETHODIMP GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog);
    virtual STDMETHODIMP OnApply(IN PROPPAGEONAPPLY oaAction);

    // *** IShellPropSheetExt ***
    virtual STDMETHODIMP AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam);
    virtual STDMETHODIMP ReplacePage(IN EXPPS uPageID, IN LPFNSVADDPROPSHEETPAGE pfnReplaceWith, IN LPARAM lParam) {return E_NOTIMPL;}

    // *** IPropertyBag ***
    virtual STDMETHODIMP Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog);
    virtual STDMETHODIMP Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar);

protected:

private:
    CScreenSaverPg();
    virtual ~CScreenSaverPg(void);

    // Private Member Variables
    int                     m_cRef;

    BOOL                    m_fSecure;
    BOOL                    m_fUIInitialized;           // Have we activated the UI tab and loaded the UI controls with state?
    BOOL                    m_fScreenSavePolicy;
    BOOL                    m_fScreenSaveActive;
    LONG                    m_lWaitTime;
    HWND                    m_hDlg;



    // Private Member Functions
    HRESULT _InitState(void);
    BOOL _InitSSDialog(HWND hDlg);
    HRESULT _OnSetActive(void);
    HRESULT _OnApply(void);
    HRESULT _OnSelectionChanged(void);
    HRESULT _SaveIni(HWND hDlg);
    HRESULT _SetByPath(LPCWSTR pszPath);

    INT_PTR _ScreenSaverDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
    friend INT_PTR CALLBACK ScreenSaverDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);

    friend HRESULT CScreenSaverPage_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj);
};






//===========================
// *** Class Internals & Helpers ***
//===========================
const DWORD aSaverHelpIds[] = {
        IDC_NO_HELP_1,          NO_HELP,

        IDC_CHOICES,            IDH_DISPLAY_SCREENSAVER_SCREENSAVER_LISTBOX, 

        IDC_SSDELAYLABEL,       IDH_DISPLAY_SCREENSAVER_SCREENSAVER_WAIT,
        IDC_SSDELAYSCALE,       IDH_DISPLAY_SCREENSAVER_SCREENSAVER_WAIT,
        IDC_SCREENSAVEDELAY,    IDH_DISPLAY_SCREENSAVER_SCREENSAVER_WAIT,
        IDC_SCREENSAVEARROW,    IDH_DISPLAY_SCREENSAVER_SCREENSAVER_WAIT, 
    
        IDC_TEST,               IDH_DISPLAY_SCREENSAVER_SCREENSAVER_PREVIEW,

        IDC_SETTING,            IDH_DISPLAY_SCREENSAVER_SCREENSAVER_SETTINGS,
        IDC_BIGICONSS,          IDH_DISPLAY_SCREENSAVER_SCREENSAVER_MONITOR,

        IDC_ENERGY_TEXT,        NO_HELP,
        IDC_ENERGYSTAR_BMP,     IDH_DISPLAY_SCREENSAVER_ENERGYSAVE_GRAPHIC,
        IDC_USEPASSWORD,        IDH_DISPLAY_SCREENSAVER_SCREENSAVER_PASSWORD_CHECKBOX, 
        // IDC_SETPASSWORD,        IDH_COMM_PASSWDBUTT,
        IDC_LOWPOWERCONFIG,     IDH_DISPLAY_SCREENSAVER_POWER_BUTTON,
        IDC_ENERGY_TEXT2,       NO_HELP,
        0, 0
};


// are we going to return to the welcome dialog in the friendly UI case?
BOOL WillReturnToWelcome()
{
    HKEY hkey;
    BOOL bRet = TRUE;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_SCREENSAVE, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
    {
        TCHAR szTemp[4];
        DWORD dwType;
        DWORD dwSize = sizeof(szTemp);

        if ((RegQueryValueEx(hkey, TEXT("NoAutoReturnToWelcome"), NULL, &dwType, (BYTE*)szTemp, &dwSize) == ERROR_SUCCESS) &&
            (dwType == REG_SZ))
        {
            bRet = !(StrToInt(szTemp));
        }

        RegCloseKey(hkey);
    }

    return bRet;
}

/*
 * Win95 and NT store different values in different places of the registry to
 * determine if the screen saver is secure or not.
 *
 * We can't really consolidate the two because the screen savers do different
 * actions based on which key is set.  Win95 screen savers do their own
 * password checking, but NT must let the secure desktop winlogon code do it.
 *
 * Therefore to keep Win95 screen savers from requesting the password twice on
 * NT, we use  REGSTR_VALUE_USESCRPASSWORD == (REG_DWORD)1 on Win95 to indicate
 * that a screen saver should check for the password, and
 * "ScreenSaverIsSecure" == (REG_SZ)"1" on NT to indicate that WinLogon should
 * check for a password.
 *
 * This function will deal with the differences.
 */
static BOOL IsPasswdSecure(HKEY hKey)
{
    union {
        DWORD dw;
        TCHAR asz[4];
    } uData;

    DWORD dwSize, dwType;
    BOOL fSecure = FALSE;

    dwSize = SIZEOF(uData);

    if (RegQueryValueEx(hKey,SZ_USE_PASSWORD,NULL, &dwType, (BYTE *)&uData, &dwSize) == ERROR_SUCCESS)
    {
        switch (dwType)
        {
        case REG_DWORD:
            fSecure = (uData.dw == 1);
            break;

        case REG_SZ:
            fSecure = (uData.asz[0] == TEXT('1'));
            break;
        }
    }

    // if we are in friendly UI mode, we might want to treat this as secure even if SZ_USE_PASSWORD is not set
    if (g_fFriendlyUI && !fSecure)
    {
        fSecure = WillReturnToWelcome();
    }

    return fSecure;
}


static void NEAR
EnableDlgChild( HWND dlg, HWND kid, BOOL val )
{
    if( !val && ( kid == GetFocus() ) )
    {
        // give prev tabstop focus
        SendMessage( dlg, WM_NEXTDLGCTL, 1, 0L );
    }

    EnableWindow( kid, val );
}

static void NEAR
EnableDlgItem( HWND dlg, int idkid, BOOL val )
{
    EnableDlgChild( dlg, GetDlgItem( dlg, idkid ), val );
}

HWND GetSSDemoParent( HWND page )
{
    static HWND parent = NULL;

    if (!parent || !IsWindow(parent))
    {
        parent = CreateWindowEx( 0, c_szDemoParentClass,
            TEXT(""), WS_CHILD | WS_CLIPCHILDREN, 0, 0, 0, 0,
            GetDlgItem(page, IDC_BIGICONSS), NULL, HINST_THISDLL, NULL );
    }

    return parent;
}

void ForwardSSDemoMsg(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    HWND hwndChild;

    hwnd = GetSSDemoParent(hwnd);

    if (hwnd)
    {
        for (hwndChild = GetWindow(hwnd, GW_CHILD); hwnd && (hwndChild != NULL);
            hwndChild = GetWindow(hwndChild, GW_HWNDNEXT))
        {
            SendMessage(hwndChild, uMessage, wParam, lParam);
        }
    }
}

void ParseSaverName( LPTSTR lpszName )
{
    if( *lpszName == TEXT('\"') )
    {
        LPTSTR lpcSrc = lpszName + 1;

        while( *lpcSrc && *lpcSrc != TEXT('\"') )
        {
            *lpszName++ = *lpcSrc++;
        }

        *lpszName = 0;  // clear second quote
    }
}

// YUCK:
// since our screen saver preview is in a different process,
//   it is possible that we paint in the wrong order.
// this ugly hack makes sure the demo always paints AFTER the dialog

WNDPROC g_lpOldStaticProc = NULL;

LRESULT  StaticSubclassProc(HWND wnd, UINT msg, WPARAM wp, LPARAM lp)
{
    LRESULT result =
        CallWindowProc(g_lpOldStaticProc, wnd, msg, wp, lp);

    if (msg == WM_PAINT)
    {
        HWND demos = GetSSDemoParent(GetParent(wnd));

        if (demos)
        {
            RedrawWindow(demos, NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
        }
    }

    return result;
}


HRESULT CScreenSaverPg::_InitState(void)
{
    HRESULT hr = S_OK;
    HKEY  hKey;
    int Counter;
    int nActive;
    int Timeout;

    m_fScreenSavePolicy = FALSE;
    m_fScreenSaveActive = TRUE;

    // Fetch the timeout value from the win.ini and adjust between 1:00-60:00
    for (Counter = 0; Counter < ARRAYSIZE(g_TimeoutAssociation); Counter++)
    {
        // Fetch the timeout value from the win.ini and adjust between 1:00-60:00
        ClassicSystemParametersInfo(g_TimeoutAssociation[Counter].taGetTimeoutAction, 0, &Timeout, 0);

        //  The Win 3.1 guys decided that 0 is a valid ScreenSaveTimeOut value.
        //  This causes our screen savers not to kick in (who cares?).  In any
        //  case, I changed this to allow 0 to go through.  In this way, the
        //  user immediately sees that the value entered is not valid to fire
        //  off the screen saver--the OK button is disabled.  I don't know if
        //  I fully agree with this solution--it is just the minimal amount of
        //  code.  The optimal solution would be to ask the 3.1 guys why 0 is
        //  valid?  -cjp
        Timeout = min(max(Timeout, 1), MAX_MINUTES * 60);

        //  Convert Timeout to minutes, rounding up.
        Timeout = (Timeout + 59) / 60;
        g_Timeout[Counter] = Timeout;

        ClassicSystemParametersInfo(g_TimeoutAssociation[Counter].taGetActiveAction, 0, &nActive, SPIF_UPDATEINIFILE);
        if (Counter == TA_SCREENSAVE)
        {
            // I found that NTUSER will return random values so we don't use them.  If people want to set the policy,
            // they should do in the registry.
//            m_fScreenSaveActive = nActive;
        }
    }


    // Find the name of the exe used as a screen saver. "" means that the
    // default screen saver will be used.  First check the system policies
    if (RegOpenKey(HKEY_CURRENT_USER, TEXT("Software\\Policies\\Microsoft\\Windows\\Control Panel\\Desktop"), &hKey) == ERROR_SUCCESS)
    {
        BOOL fSettings;
        ULONG cbSize;
        
        cbSize = ARRAYSIZE(g_szSaverName);
        if (RegQueryValueEx(hKey, TEXT("SCRNSAVE.EXE"), NULL, NULL, (LPBYTE)g_szSaverName, &cbSize) == ERROR_SUCCESS)
        {
            g_fScreenSaverExecutablePolicy = TRUE;
            LogStatus("POLICY ENABLED: ScreenSaver selection is forced to a certain SS file.");
        }

        cbSize = SIZEOF(m_fSecure);
        if (RegQueryValueEx(hKey, TEXT("ScreenSaverIsSecure"), NULL, NULL, (LPBYTE)&m_fSecure, &cbSize) == ERROR_SUCCESS)
        {
            g_fPasswordBoxDeterminedByPolicy = TRUE;
            LogStatus("POLICY ENABLED: ScreenSaverIsSecure is on.");
        }

        cbSize = SIZEOF( fSettings );
        if (RegQueryValueEx(hKey, TEXT("ScreenSaverSettingsButton"), NULL, NULL, (LPBYTE)&fSettings, &cbSize) == ERROR_SUCCESS)
        {
            g_fSettingsButtonOffByPolicy = TRUE;
            LogStatus("POLICY ENABLED: ScreenSaver settings button is disabled.");
        }

        TCHAR szTemp[20];
        if (SUCCEEDED(HrRegGetValueString(hKey, NULL, SZ_POLICY_SCREENSAVETIMEOUT, szTemp, ARRAYSIZE(szTemp))) &&
            szTemp[0])
        {
            m_lWaitTime = StrToInt(szTemp);
            g_fTimeoutDeterminedByPolicy = TRUE;
            LogStatus("POLICY ENABLED: ScreenSaver timeout value is set.");
        }

        if (SUCCEEDED(HrRegGetValueString(hKey, NULL, TEXT("ScreenSaveActive"), szTemp, ARRAYSIZE(szTemp))) &&
            szTemp[0])
        {
            m_fScreenSavePolicy = TRUE;
            m_fScreenSaveActive = StrToInt(szTemp);
            LogStatus("POLICY ENABLED: ScreenSaver Active is set.");
        }
        RegCloseKey(hKey);
    }
    
    if (!g_fScreenSaverExecutablePolicy)
    {
        if (FAILED(HrRegGetPath(HKEY_CURRENT_USER, SZ_REGKEY_CPDESKTOP, SZ_INIKEY_SCREENSAVER, g_szSaverName, ARRAYSIZE(g_szSaverName))))
        {
            TCHAR szTempPath[MAX_PATH];

            GetPrivateProfileString(SZ_INISECTION_SCREENSAVER, SZ_INIKEY_SCREENSAVER, TEXT(""), g_szSaverName, ARRAYSIZE(g_szSaverName), SZ_INISECTION_SYSTEMINI);

            StrCpyN(szTempPath, g_szSaverName, ARRAYSIZE(szTempPath));
            SHExpandEnvironmentStrings(szTempPath, g_szSaverName, ARRAYSIZE(g_szSaverName));
        }
    }

    ParseSaverName(g_szSaverName);  // remove quotes and params

    // Call will fail if monitor or adapter don't support DPMS.
    int dummy; 

    g_fAdapPwrMgnt = ClassicSystemParametersInfo(SPI_GETLOWPOWERACTIVE, 0, &dummy, 0);
    if (!g_fAdapPwrMgnt)
    {
        g_fAdapPwrMgnt = ClassicSystemParametersInfo(SPI_GETPOWEROFFACTIVE, 0, &dummy, 0);
    }

    // initialize the password checkbox
    if (RegOpenKey(HKEY_CURRENT_USER,REGSTR_PATH_SCREENSAVE,&hKey) == ERROR_SUCCESS)
    {
        if (IsPasswdSecure(hKey))
        {
            g_fPasswordWasPreviouslyEnabled = TRUE;
        }
        RegCloseKey(hKey);
    }

    return hr;
}


BOOL CScreenSaverPg::_InitSSDialog(HWND hDlg)
{
    WNDCLASS wc;
    PTSTR  pszMethod;
    UINT  wTemp,wLoop;
    BOOL  fContinue;
    UINT  Counter;
    int   ControlID;
    int   wMethod;
    DWORD dwUserCount;
    HKEY  hKey;
    HWND  hwnd;
    int nActive;
    TCHAR szBuffer[MAX_PATH];

    m_hDlg = hDlg;
    m_fUIInitialized = TRUE;

    HINSTANCE hInstDeskCPL = LoadLibrary(TEXT("desk.cpl"));

    if (!GetClassInfo(HINST_THISDLL, c_szDemoParentClass, &wc))
    {
        // if two pages put one up, share one dc
        wc.style = 0;
        wc.lpfnWndProc = DefWindowProc;
        wc.cbClsExtra = wc.cbWndExtra = 0;
        wc.hInstance = HINST_THISDLL;
        wc.hIcon = (HICON)( wc.hCursor = NULL );
        wc.hbrBackground = (HBRUSH) GetStockObject( BLACK_BRUSH );
        wc.lpszMenuName = NULL;
        wc.lpszClassName = c_szDemoParentClass;

        if( !RegisterClass( &wc ) )
            return FALSE;
    }

    // Fetch the timeout value from the win.ini and adjust between 1:00-60:00
    for (Counter = 0; Counter < ARRAYSIZE(g_TimeoutAssociation); Counter++)
    {
        //  The base control id specifies the edit control id.
        ControlID = g_TimeoutAssociation[Counter].taBaseControlID;

        // Set the maximum length of all of the fields...
        SendDlgItemMessage(hDlg, ControlID, EM_LIMITTEXT, 4, 0); //Allow four digits.

        ClassicSystemParametersInfo(g_TimeoutAssociation[Counter].taGetActiveAction, 0, &nActive, SPIF_UPDATEINIFILE);
        if (Counter != TA_SCREENSAVE)
        {
            CheckDlgButton(hDlg, ControlID + BCI_SWITCH, nActive);
        }
        else
        {
//            m_fScreenSaveActive = nActive;
        }

        SetDlgItemInt(hDlg, ControlID, g_Timeout[Counter], FALSE);

        //  The associated up/down control id must be one after the edit control id.
        ControlID++;

        SendDlgItemMessage(hDlg, ControlID, UDM_SETRANGE, 0, MAKELPARAM(MAX_MINUTES, MIN_MINUTES));
        SendDlgItemMessage(hDlg, ControlID, UDM_SETACCEL, 4, (LPARAM)(LPUDACCEL)udAccel);
    }

    // Find the name of the exe used as a screen saver. "" means that the
    // default screen saver will be used.  First check the system policies
    if (RegOpenKey(HKEY_CURRENT_USER, TEXT("Software\\Policies\\Microsoft\\Windows\\Control Panel\\Desktop"), &hKey) == ERROR_SUCCESS)
    {
        BOOL fPower;
        ULONG cbSize;
        
        cbSize = SIZEOF(fPower);
        if (RegQueryValueEx(hKey, TEXT("ScreenSaverPowerButton"), NULL, NULL, (LPBYTE)&fPower, &cbSize) == ERROR_SUCCESS)
        {
            EnableWindow(GetDlgItem(hDlg, IDC_LOWPOWERCONFIG), FALSE);
        }

        RegCloseKey(hKey);
    }

    if (g_fPasswordBoxDeterminedByPolicy)
    {
        CheckDlgButton(hDlg, IDC_USEPASSWORD, m_fSecure);
        EnableWindow(GetDlgItem(hDlg, IDC_USEPASSWORD), FALSE);
    }

    // if we are running with the new friendly UI w/ multiple users on the system, then we switch to text from "Password protect"
    // to "Return to the Welcome screen" because winlogon will do a switch user instead of a LockWorkStation in this case
    if (ShellIsFriendlyUIActive()                                       &&
        ShellIsMultipleUsersEnabled()                                   &&
        (ERROR_SUCCESS == ShellGetUserList(TRUE, &dwUserCount, NULL))   &&
        (dwUserCount > 1))
    {
        if (LoadString(HINST_THISDLL, IDS_RETURNTOWELCOME, szBuffer, ARRAYSIZE(szBuffer)))
        {
            SetDlgItemText(hDlg, IDC_USEPASSWORD, szBuffer);
            g_fFriendlyUI = TRUE;

            if (WillReturnToWelcome())
            {
                g_fPasswordWasPreviouslyEnabled = TRUE;
            }
        }
    }

    if (g_fSettingsButtonOffByPolicy)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_SETTING), FALSE);
    }

    if (g_fTimeoutDeterminedByPolicy)
    {
        SetDlgItemInt(hDlg, IDC_SCREENSAVEDELAY, (UINT) m_lWaitTime / 60, FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_SCREENSAVEDELAY), FALSE);
    }

    if (m_fScreenSavePolicy && !m_fScreenSaveActive)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_CHOICES), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_SETTING), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_SSDELAYLABEL), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_SCREENSAVEDELAY), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_SCREENSAVEARROW), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_SSDELAYSCALE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_USEPASSWORD), FALSE);
    }

    if (g_fScreenSaverExecutablePolicy)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_CHOICES), FALSE);
    }

    // Copy all of the variables into their copies...
    //  lstrcpy(szFileNameCopy, g_szSaverName);

    // Load in the default icon...
    if (hInstDeskCPL)
    {
        hDefaultIcon = LoadIcon(hInstDeskCPL, MAKEINTRESOURCE(IDS_ICON));
    }

    // Find the methods to save the screen.  If the method that was
    // selected is not found, the program will assume that the
    // first method in the list will be the one that is elected...
    wNumMethods = 0;
    wMethod = -1;

    SearchForScrEntries(SFSE_PRG,NULL);
    SearchForScrEntries(SFSE_SYSTEM,NULL);
    SearchForScrEntries(SFSE_WINDOWS,NULL);
    SearchForScrEntries(SFSE_FILE,g_szSaverName);

    szBuffer[0] = 0;

    TCHAR szNone[MAX_PATH];
    LoadString(HINST_THISDLL, IDS_NONE, szNone, ARRAYSIZE(szNone));

    // Set up the combo box for the different fields...
    SendDlgItemMessage(hDlg, IDC_CHOICES, CB_ADDSTRING, 0, (LPARAM)szNone);
    for (wTemp = 0; (wTemp < wNumMethods) && (ARRAYSIZE(aszFiles) > wTemp) && (ARRAYSIZE(aszMethods) > wTemp); wTemp++)
    {
        // Lock down the information and pass it to the combo box...
        pszMethod = aszMethods[wTemp];
        wLoop = (UINT)SendDlgItemMessage(hDlg,IDC_CHOICES,CB_ADDSTRING,0, (LPARAM)(pszMethod+1));
        SendDlgItemMessage(hDlg, IDC_CHOICES, CB_SETITEMDATA, wLoop, wTemp);

        // If we have the correct item, keep a copy so we can select it out of the combo box...
        // check for filename only as well as full path name
        if (!lstrcmpi(FileName(aszFiles[wTemp]), FileName(g_szSaverName)))
        {
            wMethod = wTemp;
            StrCpyN(szBuffer, pszMethod + 1, ARRAYSIZE(szBuffer));
        }
    }

    if (m_fScreenSavePolicy && !m_fScreenSaveActive)
    {
        wMethod = -1;
    }

    // Attempt to select the string we recieved from the
    // system.ini entry.  If there is no match, select the
    // first item from the list...
    if ((wMethod == -1) || (wNumMethods == 0))
    {
        fContinue = TRUE;
    }
    else
    {
        if (SendDlgItemMessage(hDlg, IDC_CHOICES, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)szBuffer) == CB_ERR)
            fContinue = TRUE;
        else
            fContinue = FALSE;
    }

    if (fContinue)
    {
       SendDlgItemMessage(hDlg,IDC_CHOICES,CB_SETCURSEL,0,0l);
       StrCpyN(g_szSaverName, TEXT(""), ARRAYSIZE(g_szSaverName));
       wMethod = -1;
    }

    g_hbmDemo = LoadMonitorBitmap( TRUE );
    if (g_hbmDemo)
    {
        SendDlgItemMessage(hDlg,IDC_BIGICONSS,STM_SETIMAGE, IMAGE_BITMAP,(LPARAM)g_hbmDemo);
    }

    if (hInstDeskCPL)
    {
        g_hbmEnergyStar = (HBITMAP) LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_ENERGYSTAR), IMAGE_BITMAP, 0, 0, LR_LOADTRANSPARENT | LR_LOADMAP3DCOLORS);
        if (g_hbmEnergyStar)
        {
            SendDlgItemMessage(hDlg, IDC_ENERGYSTAR_BMP, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)g_hbmEnergyStar);
        }
    }

    // Hide/Disable the energy related controls if the adaptor/monitor does not
    // support power mgnt.
    EnableDisablePowerDelays(hDlg);

    // subclass the static control so we can synchronize painting
    hwnd = GetDlgItem(hDlg, IDC_BIGICONSS);
    if (hwnd)
    {
        g_lpOldStaticProc = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_WNDPROC);
        SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)(WNDPROC)StaticSubclassProc);
        // Turn off the mirroring style for this control to allow the screen saver preview to work.
        SetWindowLong(hwnd, GWL_EXSTYLE, GetWindowLong(hwnd, GWL_EXSTYLE) & ~RTL_MIRRORED_WINDOW);
    }

    if (hInstDeskCPL)
    {
        FreeLibrary(hInstDeskCPL);
    }

    return TRUE;
}

// Build a command line in a format suitable for passing as the second
// parameter to CreateProcess.
void _PathBuildArgs(LPTSTR pszBuf, DWORD cchBuf, LPCTSTR pszExe, LPCTSTR pszFormat, ...)
{
    StrCpyN(pszBuf, pszExe, cchBuf);
    PathQuoteSpaces(pszBuf);

    int cchBufUsed = lstrlen(pszBuf);
    pszBuf += cchBufUsed;
    cchBuf -= cchBufUsed;

    va_list ap;
    va_start(ap, pszFormat);
    wvnsprintf(pszBuf, cchBuf, pszFormat, ap);
    va_end(ap);
}

#define SS_WINDOWCLOSE_WAIT_LIMIT 5000

BOOL CALLBACK EnumSSChildWindowsProc(HWND hwndC, LPARAM lParam)
{
    HWND hwndDemo = (HWND)lParam;

    TraceMsg(TF_FUNC, "hwndDemo = %08x hwndC = %08x", hwndDemo, hwndC);

    if (IsWindow(hwndDemo) && (hwndDemo == GetParent(hwndC)))
    {      
        DWORD dwStart = GetTickCount();

        TraceMsg(TF_FUNC, "dwStart = %08x", dwStart);
    
        while (IsWindow(hwndC))
        {
            DWORD_PTR dwResult;

            TraceMsg(TF_FUNC, "Sending WM_CLOSE tickcount = %08x", GetTickCount());
            
            BOOL fShouldEndTask = !SendMessageTimeout(hwndC, WM_CLOSE, 0, 0, 
                    SMTO_ABORTIFHUNG | SMTO_NOTIMEOUTIFNOTHUNG | SMTO_NORMAL, 2000, &dwResult);

            TraceMsg(TF_FUNC, "Return from sending WM_CLOSE tickcount = %08x fShouldEndTask = %d", GetTickCount(), fShouldEndTask);

            if (!fShouldEndTask)
            {
                DWORD dwWait = dwStart + SS_WINDOWCLOSE_WAIT_LIMIT - GetTickCount();

                TraceMsg(TF_FUNC, "dwWait = %d", dwWait);

                if (dwWait > SS_WINDOWCLOSE_WAIT_LIMIT)
                {
                    TraceMsg(TF_FUNC, "Wait exceeded, ending task");
                    fShouldEndTask = TRUE;
                }
            }

            if (fShouldEndTask)
            {
                TraceMsg(TF_FUNC, "Call EndTask task for %08x", hwndC);
                EndTask(hwndC, FALSE, FALSE);
                TraceMsg(TF_FUNC, "Return from EndTask task for %08x", hwndC);
                break;
            }
        }
    }

    return TRUE;
}

void SetNewSSDemo(HWND hDlg, int iMethod)
{
    HBITMAP hbmOld;
    POINT ptIcon;
    HWND hwndDemo;
    HICON hicon;

    RECT rc = {MON_X, MON_Y, MON_X+MON_DX, MON_Y+MON_DY};

    hwndDemo = GetSSDemoParent(hDlg);
    if (hwndDemo)
    {
        // blank out the background with dialog color
        hbmOld = (HBITMAP) SelectObject(g_hdcMem, g_hbmDemo);
        FillRect(g_hdcMem, &rc, GetSysColorBrush(COLOR_DESKTOP));
        SelectObject(g_hdcMem, hbmOld);

        // make sure the old window is gone
        EnumChildWindows(hwndDemo, EnumSSChildWindowsProc, (LPARAM)hwndDemo);

        Yield(); // paranoid
        Yield(); // really paranoid
        ShowWindow(hwndDemo, SW_HIDE);
        g_fPreviewActive = FALSE;

        if (iMethod >= 0 && aszMethods[iMethod][0] == TEXT('P'))
        {
            RECT rc;
            BITMAP bm;
            UpdateWindow(hDlg);
            //UpdateWindow(GetDlgItem(hDlg, IDC_BIGICONSS));
            TCHAR szArgs[MAX_PATH];

            GetObject(g_hbmDemo, sizeof(bm), &bm);
            GetClientRect(GetDlgItem(hDlg, IDC_BIGICONSS), &rc);
            rc.left = ( rc.right - bm.bmWidth ) / 2 + MON_X;
            rc.top = ( rc.bottom - bm.bmHeight ) / 2 + MON_Y;
            MoveWindow(hwndDemo, rc.left, rc.top, MON_DX, MON_DY, FALSE);
            _PathBuildArgs(szArgs, ARRAYSIZE(szArgs), g_szSaverName, TEXT(" /p %d"), hwndDemo);
            if (WinExecN(g_szSaverName, szArgs, SW_NORMAL) > 32)
            {
                ShowWindow(hwndDemo, SW_SHOWNA);
                g_fPreviewActive = TRUE;
                return;
            }
        }

        if (iMethod != -1)
        {
            ptIcon.x = ClassicGetSystemMetrics(SM_CXICON);
            ptIcon.y = ClassicGetSystemMetrics(SM_CYICON);

            // draw the icon double size
            ASSERT(ptIcon.y*2 <= MON_DY);
            ASSERT(ptIcon.x*2 <= MON_DX);

            hicon = hIcons[iMethod];

            if (hicon == NULL && aszMethods[iMethod][0] == TEXT('I'))
                hicon = hIdleWildIcon;
            if (hicon == NULL)
                hicon = hDefaultIcon;

            hbmOld = (HBITMAP) SelectObject(g_hdcMem, g_hbmDemo);
            DrawIconEx(g_hdcMem,
                MON_X + (MON_DX-ptIcon.x*2)/2,
                MON_Y + (MON_DY-ptIcon.y*2)/2,
                hicon, ptIcon.x*2, ptIcon.y*2, 0, NULL, DI_NORMAL);
            SelectObject(g_hdcMem, hbmOld);
        }
    }

    InvalidateRect(GetDlgItem(hDlg, IDC_BIGICONSS), NULL, FALSE);
}

static void SS_SomethingChanged(HWND hDlg)
{
    if (!g_bInitSS)
    {
        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
    }
}

static void SetScreenSaverPassword(HWND hDlg, int iMethod)
{
    if (iMethod >= 0 && aszMethods[iMethod][0] == TEXT('P'))
    {
        TCHAR szArgs[MAX_PATH];

        _PathBuildArgs(szArgs, ARRAYSIZE(szArgs), g_szSaverName, TEXT(" /a %u"), GetParent(hDlg));
        WinExecN(g_szSaverName, szArgs, SW_NORMAL);
    }
}


INT_PTR CALLBACK ScreenSaverDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CScreenSaverPg * pThis = (CScreenSaverPg *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        PROPSHEETPAGE * pPropSheetPage = (PROPSHEETPAGE *) lParam;

        if (pPropSheetPage)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, pPropSheetPage->lParam);
            pThis = (CScreenSaverPg *)pPropSheetPage->lParam;
        }
    }

    if (pThis)
        return pThis->_ScreenSaverDlgProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}



BOOL SelectSSFromList(HWND hDlg)
{
    HWND hwndSSList = GetDlgItem(hDlg, IDC_CHOICES);
    BOOL fExistsInList = FALSE;

    // Select the current item in the list since another tab
    // may have changed this value.
    for (UINT nIndex = 0; nIndex < wNumMethods; nIndex++)
    {
        if (!StrCmpI(g_szSaverName, aszFiles[nIndex]))
        {
            int nItem = ComboBox_FindString(hwndSSList, 0, &(aszMethods[nIndex][1]));
            if (-1 != nItem)
            {
                ComboBox_SetCurSel(hwndSSList, nItem);
            }

            fExistsInList = TRUE;
            break;
        }
    }

    return fExistsInList;
}


HRESULT CScreenSaverPg::_OnSetActive(void)
{
    EnableDisablePowerDelays(m_hDlg);

    if (!SelectSSFromList(m_hDlg))
    {
        UINT wTemp;
        UINT wLoop;

        // We couldn't find it, so add it to aszMethods[].
        SearchForScrEntries(SFSE_FILE, g_szSaverName);

        // Now add it to the Drop Down.
        for (wTemp = 0; (wTemp < wNumMethods) && (ARRAYSIZE(aszFiles) > wTemp) && (ARRAYSIZE(aszMethods) > wTemp); wTemp++)
        {
            // Did we find the correct index?
            if (!StrCmpI(FileName(aszFiles[wTemp]), FileName(g_szSaverName)))
            {
                // Yes, so set the index.
                wLoop = (UINT)SendDlgItemMessage(m_hDlg, IDC_CHOICES, CB_ADDSTRING, 0, (LPARAM)(aszMethods[wTemp]+1));
                SendDlgItemMessage(m_hDlg, IDC_CHOICES, CB_SETITEMDATA, wLoop, wTemp);
                break;
            }
        }

        SelectSSFromList(m_hDlg);             // Try again now that we added it.  Another tab or API may have asked for us to use this SS.
    }

    if (!g_fPreviewActive)
    {
        g_bInitSS = TRUE;
        SendMessage(m_hDlg, WM_COMMAND, MAKELONG(IDC_CHOICES, CBN_SELCHANGE), (LPARAM)GetDlgItem(m_hDlg, IDC_CHOICES));
        g_bInitSS = FALSE;
    }

    return S_OK;
}


HRESULT CScreenSaverPg::_OnApply(void)
{
    // Our parent dialog will be notified of the Apply event and will call our
    // IBasePropPage::OnApply() to do the real work.
    return S_OK;
}


HRESULT CScreenSaverPg::_OnSelectionChanged(void)
{
    HRESULT hr = E_FAIL;
    PTSTR  pszMethod;
    int   wMethod;
    BOOL  fEnable;

    // Dump the name of the current selection into the buffer... 
    int wTemp = (int)SendDlgItemMessage(m_hDlg, IDC_CHOICES, CB_GETCURSEL,0,0l);
    if (wTemp)
    {
        wMethod = (int)SendDlgItemMessage(m_hDlg, IDC_CHOICES, CB_GETITEMDATA, wTemp, 0l);

        // Grey the button accordingly...
        pszMethod = aszMethods[wMethod];
        if ((pszMethod[0] == TEXT('C') ||       // can config
            pszMethod[0] == TEXT('I') ||       // IdleWild
            pszMethod[0] == TEXT('P')) &&
            !g_fSettingsButtonOffByPolicy)        // can preview
            EnableDlgItem(m_hDlg, IDC_SETTING, TRUE);
        else
            EnableDlgItem(m_hDlg, IDC_SETTING, FALSE);


        if (!g_fPasswordBoxDeterminedByPolicy)
        {
            EnableDlgItem(m_hDlg, IDC_USEPASSWORD, TRUE);
            CheckDlgButton(m_hDlg, IDC_USEPASSWORD, g_fPasswordWasPreviouslyEnabled);
        }

        // For fun, create an extra copy of g_szSaverName...
        pszMethod = aszFiles[wMethod];
        StrCpyN(g_szSaverName, pszMethod, ARRAYSIZE(g_szSaverName));
        fEnable = TRUE;
    }
    else
    {
        wMethod = -1;
        StrCpyN(g_szSaverName, TEXT(""), ARRAYSIZE(g_szSaverName));

        EnableDlgItem(m_hDlg, IDC_SETTING, FALSE);
        EnableDlgItem(m_hDlg, IDC_USEPASSWORD, FALSE);
        fEnable = FALSE;
    }

    //  Following are enabled as a group... (oh really?)
    EnableDlgItem(m_hDlg, IDC_SSDELAYLABEL, fEnable);
    EnableDlgItem(m_hDlg, IDC_SCREENSAVEDELAY, !g_fTimeoutDeterminedByPolicy && fEnable);
    EnableDlgItem(m_hDlg, IDC_SCREENSAVEARROW, fEnable);
    EnableDlgItem(m_hDlg, IDC_SSDELAYSCALE, fEnable);
    EnableDlgItem(m_hDlg, IDC_TEST, fEnable);

    g_iMethod = (int)wMethod;
    SetNewSSDemo(m_hDlg, wMethod);
    SS_SomethingChanged(m_hDlg);

    return hr;
}


INT_PTR CScreenSaverPg::_ScreenSaverDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR *lpnm;

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR *)lParam;
            switch(lpnm->code)
            {
                case PSN_APPLY:
                    _OnApply();
                    break;

                // nothing to do on cancel...
                case PSN_RESET:
                    if (g_fPreviewActive)
                        SetNewSSDemo(hDlg, -1);
                    break;

                case PSN_KILLACTIVE:
                    if (g_fPreviewActive)
                        SetNewSSDemo(hDlg, -1);
                    break;

                case PSN_SETACTIVE:
                    _OnSetActive();
                    break;
            }
            break;

        case WM_INITDIALOG:
            g_bInitSS = TRUE;
            _InitSSDialog(hDlg);
            g_bInitSS = FALSE;
            break;

        case WM_DISPLAYCHANGE:
        case WM_SYSCOLORCHANGE: {
            HBITMAP hbm;

            hbm = g_hbmDemo;

            g_hbmDemo = LoadMonitorBitmap( TRUE );
            if (g_hbmDemo)
            {
                // Got a new bitmap, use it and delete the old one.
                SendDlgItemMessage(hDlg,IDC_BIGICONSS,STM_SETIMAGE, IMAGE_BITMAP,(LPARAM)g_hbmDemo);
                if (hbm)
                {
                    DeleteObject(hbm);
                }
            }
            else
            {
                // Couldn't get a new bitmap, just reuse the old one
                g_hbmDemo = hbm;
            }

            break;
        }


        case WM_DESTROY:
            FreeScrEntries();
            if (g_fPreviewActive)
                SetNewSSDemo(hDlg, -1);
            if (g_hbmDemo)
            {
                SendDlgItemMessage(hDlg,IDC_BIGICONSS,STM_SETIMAGE,IMAGE_BITMAP, (LPARAM)NULL);
                DeleteObject(g_hbmDemo);
            }
            if (g_hbmEnergyStar)
            {
                SendDlgItemMessage(hDlg,IDC_ENERGYSTAR_BMP,STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)NULL);
                DeleteObject(g_hbmEnergyStar);
            }
            break;

        case WM_VSCROLL:
            if (LOWORD(wParam) == SB_THUMBPOSITION)
                ScreenSaver_AdjustTimeouts(hDlg, GetDlgCtrlID((HWND)lParam) - BCI_ARROW);
            break;

        case WM_HELP:
            WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, TEXT("display.hlp"), HELP_WM_HELP, (DWORD_PTR)aSaverHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, TEXT("display.hlp"), HELP_CONTEXTMENU, (DWORD_PTR) aSaverHelpIds);
            break;

        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
            ForwardSSDemoMsg(hDlg, message, wParam, lParam);
            break;

        case WMUSER_SETINITSS:
            g_bInitSS = (BOOL) lParam;
            break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                /* Check for a selection change in the combo box. If there is
                    one, then update the method number as well as the
                    configure button... */
                case IDC_CHOICES:
                    if(HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        _OnSelectionChanged();
                    }
                    break;

                /* If the edit box loses focus, translate... */
                case IDC_SCREENSAVEDELAY:
                    if (HIWORD(wParam) == EN_KILLFOCUS)
                        ScreenSaver_AdjustTimeouts(hDlg, LOWORD(wParam));
                    else
                        //check if initdialog is finished
                        if((FALSE == g_bInitSS) && (EN_CHANGE == (HIWORD(wParam))))
                            SS_SomethingChanged(hDlg);
                    break;

                case IDC_LOWPOWERCONFIG:
                    // Configure the low power timeout event.
                    WinExec("rundll32 shell32.dll,Control_RunDLL powercfg.cpl,,",
                            SW_SHOWNORMAL);
                    break;

                /* If the user wishes to test... */
                 case IDC_TEST:
                    switch( HIWORD( wParam ) )
                    {
                        case BN_CLICKED:
                        DoScreenSaver(hDlg,TRUE);
                        break;
                    }
                    break;

                /* Tell the DLL that it can do the configure... */
                case IDC_SETTING:
                if (HIWORD(wParam) == BN_CLICKED) {
                    DoScreenSaver(hDlg,FALSE);
                    break;
                }

                case IDC_USEPASSWORD:
                if (HIWORD(wParam) == BN_CLICKED)
                {
                    // the user actually toggled the checbox, so set our dirty flag
                    g_fPasswordDirty = TRUE;

                    g_fPasswordWasPreviouslyEnabled = IsDlgButtonChecked( hDlg, IDC_USEPASSWORD );
                    SS_SomethingChanged(hDlg);
                    break;
                }

                case IDC_SETPASSWORD:
                if (HIWORD(wParam) == BN_CLICKED)
                {
                    // ask new savers to change passwords
                    int wTemp = (int)SendDlgItemMessage(hDlg,IDC_CHOICES, CB_GETCURSEL,0,0l);
                    if (wTemp)
                    {
                        SetScreenSaverPassword(hDlg, (int)SendDlgItemMessage(hDlg,IDC_CHOICES, CB_GETITEMDATA,wTemp,0l));
                    }
                    break;
                }
            }
            break;

        case WM_CTLCOLORSTATIC:
            if( (HWND)lParam == GetSSDemoParent( hDlg ) )
            {
                return (INT_PTR)GetStockObject( NULL_BRUSH );
            }
            break;
    }
    return FALSE;
}

/*******************************************************************************
*
*  ScreenSaver_AdjustTimeouts
*
*  DESCRIPTION:
*     Called whenever the user adjusts the delay of one of the time controls.
*     Adjusts the delays of the other time controls such that the screen saver
*     delay is less than the low power delay and that the low power delay is
*     less than the power off delay.
*
*  PARAMETERS:
*     hWnd, handle of ScreenSaver window.
*     BaseControlID, base control ID of the radio, edit, and arrow time control
*        combination.
*
*******************************************************************************/

VOID
NEAR PASCAL
ScreenSaver_AdjustTimeouts(HWND hWnd, int BaseControlID)
{
    BOOL fTranslated;
    int Timeout;

    //  Get the new timeout for this time control and validate it's contents.
    Timeout = (int) GetDlgItemInt(hWnd, BaseControlID + BCI_DELAY, &fTranslated, FALSE);
    Timeout = min(max(Timeout, 1), MAX_MINUTES);
    SetDlgItemInt(hWnd, BaseControlID + BCI_DELAY, (UINT) Timeout, FALSE);

    //  Check the new value of this time control against the other timeouts,
    //  adjust their values if necessary.  Be careful when changing the order
    //  of these conditionals.
    //
    if (BaseControlID == IDC_SCREENSAVEDELAY)
    {
        if (g_Timeout[TA_SCREENSAVE] != Timeout)
        {
            g_Timeout[TA_SCREENSAVE] = Timeout;
            SS_SomethingChanged(hWnd);
        }
    }
    else
    {
        if (Timeout < g_Timeout[TA_SCREENSAVE])
        {
            g_Timeout[TA_SCREENSAVE] = Timeout;
            SetDlgItemInt(hWnd, IDC_SCREENSAVEDELAY, (UINT) Timeout, FALSE);
        }
    }
}


void EnableDisablePowerDelays(HWND hDlg)
{
    int i;
    static idCtrls[] = { IDC_ENERGY_TEXT,
                         IDC_ENERGY_TEXT2,
                         IDC_ENERGY_TEXT3,
                         IDC_ENERGYSTAR_BMP,
                         IDC_LOWPOWERCONFIG,
                         0 };

    for (i = 0; idCtrls[i] != 0; i++)
        ShowWindow( GetDlgItem( hDlg, idCtrls[i] ), g_fAdapPwrMgnt ? SW_SHOWNA : SW_HIDE );
}


/* This routine will search for entries that are screen savers.  The directory
    searched is either the system directory (.. */

void SearchForScrEntries(UINT wDir, LPCTSTR file)
{
    TCHAR szPath[MAX_PATH];
    TCHAR szPath2[MAX_PATH];
    HANDLE hfind;
    WIN32_FIND_DATA fd;

    // don't do any work if no space left
    if( wNumMethods >= MAX_METHODS )
        return;

    /* Get the directory where the program resides... */
    GetModuleFileName(HINST_THISDLL, szPath, ARRAYSIZE(szPath));
    StripPathName(szPath);

    switch ( wDir )
    {
        case SFSE_WINDOWS:
            /* Search the windows directory and place the path with the \ in
                the szPath variable... */
            if (!GetWindowsDirectory(szPath2, ARRAYSIZE(szPath2)))
            {
                szPath2[0] = 0;
            }

sfseSanityCheck:
            /* if same dir as where it was launched, don't search again */
            if (!lstrcmpi(szPath, szPath2))
               return;

            StrCpyN(szPath, szPath2, ARRAYSIZE(szPath));
            break;

        case SFSE_SYSTEM:
            /* Search the system directory and place the path with the \ in
                the szPath variable... */
            GetSystemDirectory(szPath2, ARRAYSIZE(szPath2));
            goto sfseSanityCheck;

        case SFSE_FILE:
            /* Search the directory containing 'file' */
            StrCpyN(szPath2, file, ARRAYSIZE(szPath2));
            StripPathName(szPath2);
            goto sfseSanityCheck;
    }

    AppendPath(szPath, TEXT("*.scr"));

    if( ( hfind = FindFirstFile( szPath, &fd ) ) != INVALID_HANDLE_VALUE )
    {
        StripPathName(szPath);

        do
        {
            PTSTR pszDesc;
            BOOL fLFN;

            fLFN = !(fd.cAlternateFileName[0] == 0 ||
                    lstrcmp(fd.cFileName, fd.cAlternateFileName) == 0);

            StrCpyN(szPath2, szPath, ARRAYSIZE(szPath2));
            AppendPath(szPath2, fd.cFileName);

            // Note: PerformCheck does an alloc
            if( ( pszDesc = PerformCheck( szPath2, fLFN ) ) != NULL )
            {
                BOOL bAdded = FALSE;
                UINT i;

                for( i = 0; i < wNumMethods; i++ )
                {
                    if( !lstrcmpi( pszDesc, aszMethods[ i ] ) )
                    {
                        bAdded = TRUE;
                        break;
                    }
                }

                if( !bAdded )
                {
                    PTSTR pszEntries;

                    // COMPATIBILITY: always use short name
                    // otherwise some apps fault when peeking at SYSTEM.INI
                    if( fLFN )
                    {
                        StrCpyN(szPath2, szPath, ARRAYSIZE(szPath2));
                        AppendPath(szPath2, fd.cAlternateFileName);
                    }

                    if( ( pszEntries = StrDup( szPath2 ) ) != NULL )
                    {
                        if (pszDesc[0] != TEXT('P'))
                            hIcons[wNumMethods] = ExtractIcon(HINST_THISDLL, szPath2, 0);
                        else
                            hIcons[wNumMethods] = NULL;

                        aszMethods[wNumMethods] = pszDesc;
                        aszFiles[wNumMethods] = pszEntries;
                        wNumMethods++;
                        bAdded = TRUE;
                    }
                }

                if( !bAdded )
                    LocalFree((HLOCAL)pszDesc);
            }

        } while( FindNextFile( hfind, &fd ) && ( wNumMethods < MAX_METHODS ) );

        FindClose(hfind);
    }
    return;
}

//
//  This routine checks a given file to see if it is indeed a screen saver
//  executable...
//
//  a valid screen saver exe has the following description line:
//
//      SCRNSAVE [c] : description :
//
//      SCRNSAVE is a required name that indicates a screen saver.
//
PTSTR PerformCheck(LPTSTR lpszFilename, BOOL fLFN)
{
    int  i;
    TCHAR chConfig=TEXT('C');       // assume configure
    LPTSTR pch;
    DWORD dw;
    WORD  Version;
    WORD  Magic;
    TCHAR szBuffer[MAX_PATH];
    DWORD cchSizePch = (ARRAYSIZE(szBuffer)-1);

    // Get the description...
    pch = szBuffer + 1;

    //  if we have a LFN (Long File Name) dont bother getting the
    //  exe descrription
    dw = GetExeInfo(lpszFilename, pch, cchSizePch, fLFN ? GEI_EXPVER : GEI_DESCRIPTION);
    Version = HIWORD(dw);
    Magic   = LOWORD(dw);

    if (dw == 0)
        return NULL;

    if (Magic == PEMAGIC || fLFN)
    {
        BOOL fGotName = FALSE;

        if (!fLFN)
        {
            HINSTANCE hSaver = LoadLibraryEx(lpszFilename, NULL, LOAD_LIBRARY_AS_DATAFILE);

            // We have a 32 bit screen saver with a short name, look for an NT style
            // decription in it's string table
            if (hSaver)
            {
                if (LoadString(hSaver, IDS_DESCRIPTION, pch, cchSizePch))
                {
                    fGotName = TRUE;
                }
                FreeLibrary(hSaver);
            }
        }

        if (!fGotName)
        {
            //  we have a LFN (LongFileName) or a Win32 screen saver,
            //  Win32 exe's in general dont have a description field so
            //  we assume they can configure.  We also try to build
            //  a "nice" name for it.
            StrCpyN(pch, lpszFilename, cchSizePch);

            pch = FileName(pch);                    // strip path part
            if ( ((TCHAR)CharUpper((LPTSTR)(pch[0]))) == TEXT('S') && ((TCHAR)CharUpper((LPTSTR)(pch[1]))) == TEXT('S'))     // map SSBEZIER.SCR to BEZIER.SCR
                pch+=2;

            pch = NiceName(pch);                    // map BEZIER.SCR to Bezier
        }
    }
    else
    {
        LPTSTR pchTemp;

        //  we have a 8.3 file name 16bit screen saveer, parse the
        //  description string from the exehdr
        /* Check to make sure that at least the 11 characters needed for info
            are there... */
        if (lstrlen(pch) < 9)
            return NULL;

        /* Check the first 8 characters for the string... */
        if (lstrncmp(TEXT("SCRNSAVE"), pch, 8))
            return NULL;

        // If successful, allocate enough space for the string and copy the
        // string to the new one...

        pch = pch + 8;                 // skip over 'SCRNSAVE'

        while (*pch==TEXT(' '))                   // advance over white space
            pch++;

        if (*pch==TEXT('C') || *pch==TEXT('c'))         // parse the configure flag
        {
            chConfig = TEXT('C');
            pch++;
        }

        if (*pch==TEXT('X') || *pch==TEXT('x'))         // parse the don't configure flag
            chConfig = *pch++;

        // we might be pointing at a name or separation goop
        pchTemp = pch;                      // remember this spot

        while (*pch && *pch!=TEXT(':'))           // find separator
            pch++;

        while (*pch==TEXT(':') || *pch==TEXT(' '))      // advance over whtspc/last colon
            pch++;

        // if we haven't found a name yet fall back on the saved location
        if (!*pch)
            pch = pchTemp;

        while (*pch==TEXT(':') || *pch==TEXT(' '))      // re-advance over whtspc
            pch++;

        /* In case the screen saver has version information information
            embedded after the name, check to see if there is a colon TEXT(':')
            in the description and replace it with a NULL... */

        for (i=0; pch[i]; i++)              //
        {
#if defined(DBCS) || (defined(FE_SB) && !defined(UNICODE))
            if (IsDBCSLeadByte(pch[i]))
            {
                i++;
            }
            else
#endif
            if (pch[i]==TEXT(':'))
                pch[i]=0;
        }
// Space is OK for DBCS (FE)
        while(i>0 && pch[i-1]==TEXT(' '))         // remove trailing space
            pch[--i]=0;
    }

#ifdef DEBUG
    if (Magic != PEMAGIC)
    {
        lstrcat(pch, TEXT(" (16-bit)"));
    }

    if (Version == 0x030A)
        lstrcat(pch, TEXT(" (3.10)"));

    if (Version == 0x0400)
        lstrcat(pch, TEXT(" (4.00)"));
#endif
    //
    // assume any Win32 4.0 screen saver can do Preview mode
    //
    if (chConfig == TEXT('C') && Version >= 0x0400 && Magic == PEMAGIC)
        chConfig = TEXT('P');                     // mark as configurable/preview

    pch[-1] = chConfig;
    return StrDup(pch-1);
}


BOOL FreeScrEntries( void )
{
    UINT wLoop;

    for(wLoop = 0; wLoop < wNumMethods; wLoop++)
    {
        if(aszMethods[wLoop] != NULL)
            LocalFree((HANDLE)aszMethods[wLoop]);
        if(aszFiles[wLoop] != NULL)
            LocalFree((HANDLE)aszFiles[wLoop]);
        if(hIcons[wLoop] != NULL)
            FreeResource(hIcons[wLoop]);
    }

    if (hDefaultIcon)
        FreeResource(hDefaultIcon);

    if (hIdleWildIcon)
        FreeResource(hIdleWildIcon);

    hDefaultIcon=hIdleWildIcon=NULL;
    wNumMethods = 0;

    return TRUE;
}


int lstrncmp( LPTSTR lpszString1, LPTSTR lpszString2, int nNum )
{
    /* While we can still compare characters, compare.  If the strings are
        of different lengths, characters will be different... */
    while(nNum)
    {
        if(*lpszString1 != *lpszString2)
            return *lpszString1 - *lpszString2;
        lpszString1++;
        lpszString2++;
        nNum--;
    }
    return 0;
}


HRESULT CScreenSaverPg::_SaveIni(HWND hDlg)
{
    HRESULT hr = S_OK;
    LPTSTR pszMethod = TEXT("");
    BOOL bSSActive;
    int  wMethod,wTemp;
    UINT Counter;
    HKEY hKey;
    TCHAR szBuffer[MAX_PATH];

    if (m_fUIInitialized)
    {
        // Find the current method selection...
        wTemp = 0;
        if (wNumMethods)
        {
            // Dump the name of the current selection into the buffer... 
            wTemp = (int)SendDlgItemMessage(hDlg, IDC_CHOICES, CB_GETCURSEL, 0, 0);
            if (wTemp)
            {
                wMethod = (int)SendDlgItemMessage(hDlg, IDC_CHOICES, CB_GETITEMDATA, wTemp, 0);

                // Dump the method name into the buffer...
                pszMethod = aszFiles[wMethod];
            }
        }

        // since "(None)" is always the first entry in the combobox, we can use it to see if we have
        // a screensaver or not
        if (wTemp == 0)
        {
            // 0th inxed is "(None)" so the screensaver is disabled
            bSSActive = FALSE;
        }
        else
        {
            bSSActive = TRUE;
        }
    }
    else
    {
        TCHAR szNone[MAX_PATH];
        LoadString(HINST_THISDLL, IDS_NONE, szNone, ARRAYSIZE(szNone));

        if ((g_szSaverName[0] == TEXT('\0')) || (lstrcmpi(szNone, g_szSaverName) == 0))
        {
            // screensaver was not set, OR it was set to "(None)" -- therefore it is not active
            bSSActive = FALSE;
        }
        else
        {
            bSSActive = TRUE;
        }

        pszMethod = g_szSaverName;
    }

    // Now quote any spaces
    BOOL hasspace = FALSE;
    LPTSTR pc;

    for (pc = pszMethod; *pc; pc++)
    {
        if (*pc == TEXT(' '))
        {
            hasspace = TRUE;
            break;
        }
    }

    if (hasspace)
    {
        // if we need to add quotes we'll need two sets
        // because GetBlahBlahProfileBlah APIs strip quotes
        wnsprintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("\"\"%s\"\""), pszMethod);
    }
    else
    {
        StrCpyN(szBuffer, pszMethod, ARRAYSIZE(szBuffer));
    }

    // Save the buffer...
    if (!WritePrivateProfileString(SZ_INISECTION_SCREENSAVER, SZ_INIKEY_SCREENSAVER, (szBuffer[0] != TEXT('\0') ? szBuffer : NULL), SZ_INISECTION_SYSTEMINI))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    // In win2k we decided to leave the screensaver ALWAYS active so that when the policy changed, it would take
    // w/out rebooting. This has become a PITA so we now do it the right way.
    ClassicSystemParametersInfo(SPI_SETSCREENSAVEACTIVE, bSSActive, NULL, SPIF_UPDATEINIFILE);

    for (Counter = 0; Counter < (sizeof(g_TimeoutAssociation) / sizeof(TIMEOUT_ASSOCIATION)); Counter++)
    {
        ClassicSystemParametersInfo(g_TimeoutAssociation[Counter].taSetTimeoutAction, (UINT) (g_Timeout[Counter] * 60), NULL, SPIF_UPDATEINIFILE);

        if (Counter != TA_SCREENSAVE)
        {
            ClassicSystemParametersInfo(g_TimeoutAssociation[Counter].taSetActiveAction,
                                        IsDlgButtonChecked(hDlg, g_TimeoutAssociation[Counter].taBaseControlID + BCI_SWITCH),
                                        NULL,
                                        SPIF_UPDATEINIFILE);
        }

    }

    // save the state of the TEXT("use password") checkbox
    if (RegCreateKey(HKEY_CURRENT_USER, REGSTR_PATH_SCREENSAVE, &hKey) == ERROR_SUCCESS)
    {
        if (g_fPasswordDirty)
        {
            if (g_fFriendlyUI)
            {
                // the user actually toggled the value, so don't automatically return to the welcome screen since they have
                // now made their own decision on this subject
                RegSetValueEx(hKey, TEXT("NoAutoReturnToWelcome"), 0, REG_SZ, (BYTE*)TEXT("1"), sizeof(TEXT("1")));

                RegSetValueEx(hKey, SZ_USE_PASSWORD, 0, PWRD_REG_TYPE, PasswdRegData(IsDlgButtonChecked(hDlg,IDC_USEPASSWORD)), CB_USE_PWRD_VALUE);
            }
            else
            {
                RegSetValueEx(hKey, SZ_USE_PASSWORD, 0, PWRD_REG_TYPE, PasswdRegData(IsDlgButtonChecked(hDlg,IDC_USEPASSWORD)), CB_USE_PWRD_VALUE);
            }
        }

        RegCloseKey(hKey);
    }

    // Broadcast a WM_WININICHANGE message...
    SendNotifyMessage(HWND_BROADCAST, WM_WININICHANGE, 0, (LPARAM)TEXT("Windows"));

    return hr;
}

/*
 * Thread for DoScreenSaver()
 */
typedef struct
{
    HWND    hDlg;
    TCHAR   szPath[MAX_PATH];
    TCHAR   szArgs[MAX_PATH];
} SSRUNDATA, *LPSSRUNDATA;

DWORD RunScreenSaverThread( LPVOID lpv )
{
    BOOL bSvrState;
    LPSSRUNDATA lpssrd;
    HWND hwndSettings, hwndPreview;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    HINSTANCE hiThd;
    TCHAR szPath[MAX_PATH];

    // Lock ourselves in mem so we don't fault if app unloads us
    GetModuleFileName(HINST_THISDLL, szPath, ARRAYSIZE(szPath));
    hiThd = LoadLibrary( szPath );

    lpssrd = (LPSSRUNDATA)lpv;

    hwndSettings = GetDlgItem( lpssrd->hDlg, IDC_SETTING);
    hwndPreview  = GetDlgItem( lpssrd->hDlg, IDC_TEST);

    // Save previous screen saver state
    ClassicSystemParametersInfo( SPI_GETSCREENSAVEACTIVE,0, &bSvrState, FALSE);

    // Disable current screen saver
    if( bSvrState )
        ClassicSystemParametersInfo( SPI_SETSCREENSAVEACTIVE,FALSE, NULL, FALSE );

    // Stop the miniture preview screen saver
    if (g_fPreviewActive)
        SetNewSSDemo( lpssrd->hDlg, -1);

    // Exec the screen saver and wait for it to die
    ZeroMemory(&StartupInfo,sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    StartupInfo.dwFlags = STARTF_USESHOWWINDOW;
    StartupInfo.wShowWindow = (WORD)SW_NORMAL;

    if (CreateProcess(lpssrd->szPath, lpssrd->szArgs, NULL, NULL, FALSE, 0, NULL, NULL, &StartupInfo, &ProcessInformation))
    {
        WaitForSingleObject( ProcessInformation.hProcess, INFINITE );
        CloseHandle(ProcessInformation.hProcess);
        CloseHandle(ProcessInformation.hThread);
    }

    // Restore Screen saver state
    if( bSvrState )
        ClassicSystemParametersInfo( SPI_SETSCREENSAVEACTIVE, bSvrState, NULL, FALSE );

    // Restart miniture preview
    PostMessage(lpssrd->hDlg, WMUSER_SETINITSS, NULL, (LPARAM)TRUE);
    PostMessage(lpssrd->hDlg, WM_COMMAND, MAKELONG(IDC_CHOICES, CBN_SELCHANGE),
                                    (LPARAM)GetDlgItem( lpssrd->hDlg, IDC_CHOICES));
    PostMessage(lpssrd->hDlg, WMUSER_SETINITSS, NULL, (LPARAM)FALSE);

    // Enable setting and preview buttons
    EnableWindow( hwndSettings, TRUE );
    EnableWindow( hwndPreview,  TRUE );

    LocalFree( lpv );

    if (hiThd)
    {
        FreeLibraryAndExitThread( hiThd, 0 );
    }

    return 0;
}


// This routine actually calls the screen saver...
void DoScreenSaver(HWND hWnd, BOOL fSaver)
{
    if (g_szSaverName[0] != TEXT('\0'))
    {
        LPSSRUNDATA lpssrd = (LPSSRUNDATA) LocalAlloc(LMEM_FIXED, sizeof(*lpssrd));
        if (lpssrd != NULL)
        {
            lpssrd->hDlg = hWnd;
            StrCpyN(lpssrd->szPath, g_szSaverName, ARRAYSIZE(lpssrd->szPath));

            if (fSaver)
            {
                _PathBuildArgs(lpssrd->szArgs, ARRAYSIZE(lpssrd->szArgs), g_szSaverName, TEXT(" /s"));
            }
            else 
            {
                _PathBuildArgs(lpssrd->szArgs, ARRAYSIZE(lpssrd->szArgs), g_szSaverName, TEXT(" /c:%lu"), (LPARAM)hWnd);
            }

            // Disable setting and preview buttons
            HWND hwndSettings = GetDlgItem(hWnd, IDC_SETTING);
            HWND hwndPreview  = GetDlgItem(hWnd, IDC_TEST);

            EnableWindow(hwndSettings, FALSE);
            EnableWindow(hwndPreview,  FALSE);

            DWORD id;
            HANDLE hThd = CreateThread(NULL, 0, RunScreenSaverThread, lpssrd, 0, &id);
            if (hThd != NULL)
            {
                CloseHandle(hThd);
            }
            else
            {
                // Exec failed, re-enable setting and preview buttons and clean up thread params
                EnableWindow(hwndSettings, TRUE);
                EnableWindow(hwndPreview,  TRUE);
                LocalFree(lpssrd);
            }
        }
    }
}


#define SLASH(c)     ((c) == TEXT('/') || (c) == TEXT('\\'))

LPTSTR FileName(LPTSTR szPath)
{
    LPTSTR   sz;

    for (sz=szPath; *sz; sz++)
    {
        NULL;
    }

#if defined(DBCS) || (defined(FE_SB) && !defined(UNICODE))
    for (; sz>szPath && !SLASH(*sz) && *sz!=TEXT(':'); sz=CharPrev(szPath, sz))
#else
    for (; sz>=szPath && !SLASH(*sz) && *sz!=TEXT(':'); sz--)
#endif
    {
        NULL;
    }

#if defined(DBCS) || (defined(FE_SB) && !defined(UNICODE))
    if ( !IsDBCSLeadByte(*sz) && (SLASH(*sz) || *sz == TEXT(':')) )
    {
        sz = CharNext(sz);
    }
    return  sz;
#else
    return ++sz;
#endif
}

void AddBackslash(LPTSTR pszPath)
{
#if defined(DBCS) || (defined(FE_SB) && !defined(UNICODE))
    LPTSTR lpsz = &pszPath[lstrlen(pszPath)];
    lpsz = CharPrev(pszPath, lpsz);
    if ( *lpsz != TEXT('\\') )
#else
    if( pszPath[ lstrlen( pszPath ) - 1 ] != TEXT('\\') )
#endif
    {
        lstrcat( pszPath, TEXT("\\") );
    }
}


LPTSTR StripPathName(LPTSTR szPath)
{
    LPTSTR   sz;
#if defined(DBCS) || (defined(FE_SB) && !defined(UNICODE))
    LPTSTR   szFile;
#endif
    sz = FileName(szPath);

#if defined(DBCS) || (defined(FE_SB) && !defined(UNICODE))
    szFile = sz;
    if ( szFile >szPath+1 )
    {
        szFile = CharPrev( szPath, szFile );
        if (SLASH(*szFile))
        {
            szFile = CharPrev(szPath, szFile);
            if (*szFile != TEXT(':'))
            {
                sz--;
            }
        }
    }
#else
    if (sz > szPath+1 && SLASH(sz[-1]) && sz[-2] != TEXT(':'))
    {
        sz--;
    }
#endif

    *sz = 0;
    return szPath;
}

void AppendPath(LPTSTR pszPath, LPTSTR pszSpec)
{
    AddBackslash(pszPath);
    lstrcat(pszPath, pszSpec);
}


LPTSTR NiceName(LPTSTR szPath)
{
    LPTSTR   sz;
    LPTSTR   lpsztmp;

    sz = FileName(szPath);

    for(lpsztmp = sz; *lpsztmp  && *lpsztmp != TEXT('.'); lpsztmp = CharNext(lpsztmp))
    {
        NULL;
    }

    *lpsztmp = TEXT('\0');

    if (IsCharUpper(sz[0]) && IsCharUpper(sz[1]))
    {
        CharLower(sz);
        CharUpperBuff(sz, 1);
    }

    return sz;
}


HRESULT HrStrToVariant(IN LPCWSTR pszString, VARIANT * pVar)
{
    HRESULT hr = E_INVALIDARG;

    if (pszString && pVar)
    {
        pVar->vt = VT_BSTR;
        hr = HrSysAllocStringW(pszString, &pVar->bstrVal);
    }

    return hr;
}





//===========================
// *** IBasePropPage Interface ***
//===========================
HRESULT CScreenSaverPg::GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog)
{
    HRESULT hr = E_INVALIDARG;

    if (ppAdvDialog)
    {
        *ppAdvDialog = NULL;
        hr = E_NOTIMPL;     // We don't want to add an Advnaced Dialog.
    }

    return hr;
}


HRESULT CScreenSaverPg::OnApply(IN PROPPAGEONAPPLY oaAction)
{
    HRESULT hr = S_OK;

    if (PPOAACTION_CANCEL != oaAction)
    {
        if (m_hDlg)
        {
            // Make sure the time we have is the last one entered...
            SendMessage(m_hDlg, WM_COMMAND, MAKELONG(IDC_SCREENSAVEDELAY, EN_KILLFOCUS), (LPARAM)GetDlgItem(m_hDlg, IDC_SCREENSAVEDELAY));
        }

        // Try to save the current settings...
        _SaveIni(m_hDlg);
    }

    if (PPOAACTION_OK == oaAction)
    {
    }

    return hr;
}




//===========================
// *** IShellPropSheetExt Interface ***
//===========================
HRESULT CScreenSaverPg::AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam)
{
    HRESULT hr = E_INVALIDARG;
    PROPSHEETPAGE psp = {0};

    psp.dwSize = sizeof(psp);
    psp.hInstance = HINST_THISDLL;
    psp.dwFlags = PSP_DEFAULT;
    psp.lParam = (LPARAM) this;

    psp.pszTemplate = MAKEINTRESOURCE(DLG_SCREENSAVER);
    psp.pfnDlgProc = ScreenSaverDlgProc;

    HPROPSHEETPAGE hpsp = CreatePropertySheetPage(&psp);
    if (hpsp)
    {
        if (pfnAddPage(hpsp, lParam))
        {
            hr = S_OK;
        }
        else
        {
            DestroyPropertySheetPage(hpsp);
            hr = E_FAIL;
        }
    }

    return hr;
}



//===========================
// *** IPropertyBag Interface ***
//===========================
HRESULT CScreenSaverPg::Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        if (!StrCmpW(pszPropName, SZ_PBPROP_SCREENSAVER_PATH))
        {
            // The caller is asking for the ScreenSaver path.
            WCHAR szLongPath[MAX_PATH];

            DWORD cchSize = GetLongPathName(g_szSaverName, szLongPath, ARRAYSIZE(szLongPath));
            if ((0 == cchSize) || (ARRAYSIZE(szLongPath) < cchSize))
            {
                // It failed
                StrCpyNW(szLongPath, g_szSaverName, ARRAYSIZE(szLongPath));
            }

            hr = HrStrToVariant(szLongPath, pVar);
        }
    }

    return hr;
}


HRESULT CScreenSaverPg::Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar && (VT_BSTR == pVar->vt))
    {
        if (!StrCmpW(pszPropName, SZ_PBPROP_SCREENSAVER_PATH))
        {
            if (m_fScreenSavePolicy && !m_fScreenSaveActive)
            {
                hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
            }
            else
            {
                _SetByPath(pVar->bstrVal);
                hr = S_OK;
            }
        }
    }

    return hr;
}



HRESULT CScreenSaverPg::_SetByPath(LPCWSTR pszPath)
{
    HRESULT hr = S_OK;

    // COMPATIBILITY: always use short name
    // otherwise some apps fault when peeking at SYSTEM.INI
    DWORD cchSize = GetShortPathNameW(pszPath, g_szSaverName, ARRAYSIZE(g_szSaverName));
    if ((0 == cchSize) || (ARRAYSIZE(g_szSaverName) < cchSize))
    {
        // It failed
        StrCpyNW(g_szSaverName, pszPath, ARRAYSIZE(g_szSaverName));
    }

    if (m_hDlg)
    {
        ComboBox_SetCurSel(m_hDlg, 0);
        SelectSSFromList(m_hDlg);
    }

    return hr;
}


//===========================
// *** IUnknown Interface ***
//===========================
ULONG CScreenSaverPg::AddRef()
{
    m_cRef++;
    return m_cRef;
}


ULONG CScreenSaverPg::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CScreenSaverPg::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CScreenSaverPg, IObjectWithSite),
        QITABENT(CScreenSaverPg, IPropertyBag),
        QITABENT(CScreenSaverPg, IPersist),
        QITABENT(CScreenSaverPg, IBasePropPage),
        QITABENTMULTI(CScreenSaverPg, IShellPropSheetExt, IBasePropPage),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CScreenSaverPg::CScreenSaverPg() : CObjectCLSID(&PPID_ScreenSaver), m_cRef(1)
{
    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.

    // This is a global that we want to initialize.
    g_szSaverName[0] = TEXT('\0');

    m_fScreenSavePolicy = FALSE;
    m_fScreenSaveActive = TRUE;
    m_lWaitTime = 0;
    m_hDlg = NULL;
    m_fUIInitialized = FALSE;

    _InitState();
}


CScreenSaverPg::~CScreenSaverPg()
{
}


HRESULT CScreenSaverPage_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj)
{
    HRESULT hr = E_INVALIDARG;

    if (!punkOuter && ppvObj)
    {
        CScreenSaverPg * pThis = new CScreenSaverPg();

        *ppvObj = NULL;
        if (pThis)
        {
            hr = pThis->QueryInterface(riid, ppvObj);
            pThis->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\settings.cpp ===
#include "priv.h"

static const TCHAR sc_szCoverClass[] = TEXT("DeskSaysNoPeekingItsASurprise");
const TCHAR g_szNULL[] = TEXT("");


int FmtMessageBox(HWND hwnd, UINT fuStyle, DWORD dwTitleID, DWORD dwTextID)
{
    TCHAR Title[256];
    TCHAR Text[2000];

    LoadString(HINST_THISDLL, dwTextID, Text, ARRAYSIZE(Text));
    LoadString(HINST_THISDLL, dwTitleID, Title, ARRAYSIZE(Title));

    return (ShellMessageBox(HINST_THISDLL, hwnd, Text, Title, fuStyle));
}

HBITMAP FAR LoadMonitorBitmap( BOOL bFillDesktop )
{
    HBITMAP hbm,hbmT;
    BITMAP bm;
    HBRUSH hbrT;
    HDC hdc;

    hbm = LoadBitmap(HINST_THISDLL, MAKEINTRESOURCE(IDB_MONITOR));

    if (hbm == NULL)
    {
        //Assert(0);
        return NULL;
    }

    //
    // convert the "base" of the monitor to the right color.
    //
    // the lower left of the bitmap has a transparent color
    // we fixup using FloodFill
    //
    hdc = CreateCompatibleDC(NULL);
    if (hdc)
    {
        hbmT = (HBITMAP) SelectObject(hdc, hbm);
        hbrT = (HBRUSH) SelectObject(hdc, GetSysColorBrush(COLOR_3DFACE));

        GetObject(hbm, sizeof(bm), &bm);

        ExtFloodFill(hdc, 0, bm.bmHeight-1, GetPixel(hdc, 0, bm.bmHeight-1), FLOODFILLSURFACE);

        // unless the caller would like to do it, we fill in the desktop here
        if( bFillDesktop )
        {
            SelectObject(hdc, GetSysColorBrush(COLOR_DESKTOP));

            ExtFloodFill(hdc, MON_X+1, MON_Y+1, GetPixel(hdc, MON_X+1, MON_Y+1), FLOODFILLSURFACE);
        }

        // clean up after ourselves
        SelectObject(hdc, hbrT);
        SelectObject(hdc, hbmT);
        DeleteDC(hdc);
    }

    return hbm;
}

BOOL CALLBACK _AddDisplayPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    PROPSHEETHEADER FAR * ppsh = (PROPSHEETHEADER FAR *) lParam;

    if (ppsh)
    {
        if (hpage && (ppsh->nPages < MAX_PAGES))
        {
            ppsh->phpage[ppsh->nPages++] = hpage;
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\settings.h ===
//
// New message IDs
//

#define MSG_DSP_SETUP_MESSAGE    WM_USER + 0x200



#define SZ_REBOOT_NECESSARY     TEXT("System\\CurrentControlSet\\Control\\GraphicsDrivers\\RebootNecessary")
#define SZ_INVALID_DISPLAY      TEXT("System\\CurrentControlSet\\Control\\GraphicsDrivers\\InvalidDisplay")
#define SZ_DETECT_DISPLAY       TEXT("System\\CurrentControlSet\\Control\\GraphicsDrivers\\DetectDisplay")
#define SZ_NEW_DISPLAY          TEXT("System\\CurrentControlSet\\Control\\GraphicsDrivers\\NewDisplay")
#define SZ_DISPLAY_4BPP_MODES   TEXT("System\\CurrentControlSet\\Control\\GraphicsDrivers\\Display4BppModes")

#define SZ_VIDEO                TEXT("Video")
#define SZ_FONTDPI              TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontDPI")
#define SZ_FONTDPI_PROF         TEXT("SYSTEM\\CurrentControlSet\\Hardware Profiles\\Current\\Software\\Fonts")
#define SZ_LOGPIXELS            TEXT("LogPixels")
#define SZ_DEVICEDESCRIPTION    TEXT("Device Description")
#define SZ_INSTALLEDDRIVERS     TEXT("InstalledDisplayDrivers")
#define SZ_SERVICES             TEXT("\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\")
#define SZ_BACKBACKDOT          TEXT("\\\\.\\")
#define SZ_DOTSYS               TEXT(".sys")
#define SZ_DOTDLL               TEXT(".dll")

#define SZ_FILE_SEPARATOR       TEXT(", ")

#define SZ_WINDOWMETRICS        TEXT("Control Panel\\Desktop\\WindowMetrics")
#define SZ_APPLIEDDPI           TEXT("AppliedDPI")

#define SZ_CONTROLPANEL         TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Control Panel")
#define SZ_ORIGINALDPI          TEXT("OriginalDPI")



//==========================================================================
//                          Typedefs
//==========================================================================


extern HWND ghwndPropSheet;
extern const TCHAR g_szNULL[];

#define CDPI_NORMAL     96      // Arbitrarily, 96dpi is "Normal"

// information about the monitor bitmap
// x, y, dx, dy define the size of the "screen" part of the bitmap
// the RGB is the color of the screen's desktop
// these numbers are VERY hard-coded to a monitor bitmap
#define MON_X   16
#define MON_Y   17
#define MON_DX  152
#define MON_DY  112
#define MON_W   184
#define MON_H   170
#define MON_RGB RGB(0, 128, 128)
#define MON_TRAY 8

INT_PTR CALLBACK GeneralPageProc    (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK _AddDisplayPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam);
void AddFakeSettingsPage(IThemeUIPages *pThemeUI, PROPSHEETHEADER * ppsh);
INT_PTR CALLBACK MultiMonitorDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
int ComputeNumberOfDisplayDevices();
int FmtMessageBox(HWND hwnd, UINT fuStyle, DWORD dwTitleID, DWORD dwTextID);
HBITMAP FAR LoadMonitorBitmap( BOOL bFillDesktop );
int DisplaySaveSettings(PVOID pContext, HWND hwnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\settingspg.h ===
/*****************************************************************************\
    FILE: SettingsPg.h

    DESCRIPTION:
        This code will display a "Settings" tab in the
    "Display Properties" dialog

    BryanSt 1/05/2001    Updated and Converted to C++

    Copyright (C) Microsoft Corp 1993-2001. All rights reserved.
\*****************************************************************************/

#ifndef _SETTINGSPG_H
#define _SETTINGSPG_H


typedef struct
{
    BOOL fFoceSmallFont;
    IUnknown * punkSite;
} GENERAL_ADVDLG_INITPARAMS;

#endif // _SETTINGSPG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\stgtheme.h ===
/*****************************************************************************\
    FILE: stgTheme.h

    DESCRIPTION:
        This is the Autmation Object to theme manager object.

    BryanSt 4/3/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _FILE_H_STGTHEME
#define _FILE_H_STGTHEME



#endif // _FILE_H_STGTHEME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\stgtheme.cpp ===
/*****************************************************************************\
    FILE: stgTheme.cpp

    DESCRIPTION:
        This is the Autmation Object to theme manager object.

    BryanSt 4/3/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"

extern BOOL IsUserHighContrastUser(void);

//===========================
// *** Class Internals & Helpers ***
//===========================
// lParam can be: 0 == do a case sensitive search.  1 == do a case insensitive search.
int DPA_StringCompareCB(LPVOID pvString1, LPVOID pvString2, LPARAM lParam)
{
    // return < 0 for pvPidl1 before pvPidl2.
    // return == 0 for pvPidl1 equals pvPidl2.
    // return > 0 for pvPidl1 after pvPidl2.
    int nSort = 0;      // Default to equal
    LPCTSTR pszToInsert = (LPCTSTR)pvString1;
    LPCTSTR pszToComparePath = (LPCTSTR)pvString2;

    if (pszToInsert && pszToComparePath)
    {
        LPCTSTR pszToCompareFileName = PathFindFileName(pszToComparePath);

        if (pszToCompareFileName)
        {
            nSort = StrCmp(pszToInsert, pszToCompareFileName);
        }
    }

    return nSort;
}



#define SZ_THEMES_FILTER        TEXT("*.theme")
#define SZ_ALL_FILTER           TEXT("*.*")

HRESULT CThemeManager::_AddThemesFromDir(LPCTSTR pszPath, BOOL fFirstLevel, int nInsertLoc)
{
    HRESULT hr = S_OK;
    WIN32_FIND_DATA findFileData;
    TCHAR szSearch[MAX_PATH];

    AssertMsg((nInsertLoc >= 0), TEXT("nInsertLoc should never be negative"));
    StrCpyN(szSearch, pszPath, ARRAYSIZE(szSearch));
    PathAppend(szSearch, SZ_THEMES_FILTER);

    HANDLE hFindFiles = FindFirstFile(szSearch, &findFileData);
    if (hFindFiles && (INVALID_HANDLE_VALUE != hFindFiles))
    {
        while (hFindFiles && (INVALID_HANDLE_VALUE != hFindFiles))
        {
            if (!(FILE_ATTRIBUTE_DIRECTORY & findFileData.dwFileAttributes))
            {
                StrCpyN(szSearch, pszPath, ARRAYSIZE(szSearch));
                PathAppend(szSearch, findFileData.cFileName);
                LPWSTR pszPath = StrDup(szSearch);

                if (pszPath)
                {
                    if (nInsertLoc)
                    {
                        if (-1 == DPA_InsertPtr(m_hdpaThemeDirs, nInsertLoc - 1, pszPath))
                        {
                            // We failed so free the memory
                            LocalFree(pszPath);
                            hr = E_OUTOFMEMORY;
                        }
                        else
                        {
                            nInsertLoc++;
                        }
                    }
                    else
                    {
                        if (-1 == DPA_SortedInsertPtr(m_hdpaThemeDirs, PathFindFileName(pszPath), 0, DPA_StringCompareCB, NULL, DPAS_INSERTBEFORE, pszPath))
                        {
                            // We failed so free the memory
                            LocalFree(pszPath);
                            hr = E_OUTOFMEMORY;
                        }
                    }
                }
            }

            if (!FindNextFile(hFindFiles, &findFileData))
            {
                break;
            }
        }

        FindClose(hFindFiles);
    }

    // We only want to recurse one directory.
    if (fFirstLevel)
    {
        StrCpyN(szSearch, pszPath, ARRAYSIZE(szSearch));
        PathAppend(szSearch, SZ_ALL_FILTER);

        HANDLE hFindFiles = FindFirstFile(szSearch, &findFileData);
        if (hFindFiles && (INVALID_HANDLE_VALUE != hFindFiles))
        {
            while (hFindFiles && (INVALID_HANDLE_VALUE != hFindFiles))
            {
                // We are looking for any directories. Of course we exclude "." and "..".
                if ((FILE_ATTRIBUTE_DIRECTORY & findFileData.dwFileAttributes) &&
                    StrCmpI(findFileData.cFileName, TEXT(".")) &&
                    StrCmpI(findFileData.cFileName, TEXT("..")))
                {
                    StrCpyN(szSearch, pszPath, ARRAYSIZE(szSearch));
                    PathAppend(szSearch, findFileData.cFileName);

                    _AddThemesFromDir(szSearch, FALSE, nInsertLoc);
                }

                if (!FindNextFile(hFindFiles, &findFileData))
                {
                    break;
                }
            }

            FindClose(hFindFiles);
        }
    }

    // We will want to repeat this process recursively for directories.  At least
    // one level of recursively.

    return hr;
}


HRESULT CThemeManager::_InitThemeDirs(void)
{
    HRESULT hr = S_OK;

    if (!m_hdpaThemeDirs)
    {
        if (SHRegGetBoolUSValue(SZ_THEMES, SZ_REGVALUE_ENABLEPLUSTHEMES, FALSE, TRUE))
        {
            m_hdpaThemeDirs = DPA_Create(2);
            if (m_hdpaThemeDirs)
            {
                TCHAR szPath[MAX_PATH];

                // The follwoing directories can contain themes:
                //   Plus!98 Install Path\Themes
                //   Plus!95 Install Path\Themes
                //   Kids for Plus! Install Path\Themes
                //   Program Files\Plus!\Themes
                if (SUCCEEDED(GetPlusThemeDir(szPath, ARRAYSIZE(szPath))))
                {
                    _AddThemesFromDir(szPath, TRUE, 0);
                }

                hr = SHGetResourcePath(TRUE, szPath, ARRAYSIZE(szPath));
                if (SUCCEEDED(hr))
                {
                    _AddThemesFromDir(szPath, TRUE, 1);
                }

                if (SHGetSpecialFolderPath(NULL, szPath, CSIDL_APPDATA, TRUE))
                {
                    PathAppend(szPath, TEXT("Microsoft\\Windows\\Themes"));
                    _AddThemesFromDir(szPath, TRUE, 1);
                }

                if (SHGetSpecialFolderPath(NULL, szPath, CSIDL_PERSONAL, TRUE))
                {
                    _AddThemesFromDir(szPath, TRUE, 1);
                }

                // Enum any paths 3rd parties add to the registry
                HKEY hKey;
                if (SUCCEEDED(HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_THEMES_THEMEDIRS, 0, KEY_READ, &hKey)))
                {
                    for (int nDirIndex = 0; SUCCEEDED(hr); nDirIndex++)
                    {
                        TCHAR szValueName[MAXIMUM_VALUE_NAME_LENGTH];
                        DWORD cchSize = ARRAYSIZE(szValueName);
                        DWORD dwType;
                        DWORD cbSize = sizeof(szPath);

                        hr = HrRegEnumValue(hKey, nDirIndex, szValueName, &cchSize, 0, &dwType, (LPBYTE)szPath, &cbSize);
                        if (SUCCEEDED(hr))
                        {
                            TCHAR szFinalPath[MAX_PATH];

                            if (0 == SHExpandEnvironmentStringsForUserW(NULL, szPath, szFinalPath, ARRAYSIZE(szFinalPath)))
                            {
                                StrCpyN(szFinalPath, szPath, ARRAYSIZE(szFinalPath));
                            }
                            _AddThemesFromDir(szFinalPath, TRUE, 1);
                        }
                    }

                    hr = S_OK;
                    RegCloseKey(hKey);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}


#define SZ_THEMES                       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Themes")
#define SZ_REGVALUE_REQUIRESIGNING      TEXT("Require VisualStyle Signing")

HRESULT CThemeManager::_EnumSkinCB(THEMECALLBACK tcbType, LPCWSTR pszFileName, OPTIONAL LPCWSTR pszDisplayName, OPTIONAL LPCWSTR pszToolTip, OPTIONAL int iIndex)
{
    HRESULT hr = S_OK;

    // only signed theme files will be enumerated and passed to this function

    if (pszFileName)
    {
        LPWSTR pszPath = StrDup(pszFileName);

        AssertMsg((NULL != m_hdpaSkinDirs), TEXT("We should never hit this.  We will leak.  -BryanSt"));
        if (pszPath)
        {
            if (-1 == DPA_AppendPtr(m_hdpaSkinDirs, pszPath))
            {
                // We failed so free the memory
                LocalFree(pszPath);
            }
        }
    }

    return hr;
}


BOOL CThemeManager::EnumSkinCB(THEMECALLBACK tcbType, LPCWSTR pszFileName, OPTIONAL LPCWSTR pszDisplayName, 
    OPTIONAL LPCWSTR pszToolTip, OPTIONAL int iIndex, LPARAM lParam)
{
    CThemeManager * pThis = (CThemeManager *) lParam;
    HRESULT hr = E_FAIL;

    if (pThis)
    {
        hr = pThis->_EnumSkinCB(tcbType, pszFileName, pszDisplayName, pszToolTip, iIndex);
    }

    return SUCCEEDED(hr);
}


HRESULT CThemeManager::_EnumSkinsFromKey(HKEY hKey)
{
    HRESULT hr = S_OK;
    TCHAR szPath[MAX_PATH];

    for (int nDirIndex = 0; SUCCEEDED(hr); nDirIndex++)
    {
        TCHAR szValueName[MAXIMUM_VALUE_NAME_LENGTH];
        DWORD cchSize = ARRAYSIZE(szValueName);
        DWORD dwType;
        DWORD cbSize = sizeof(szPath);

        hr = HrRegEnumValue(hKey, nDirIndex, szValueName, &cchSize, 0, &dwType, (LPBYTE)szPath, &cbSize);
        if (SUCCEEDED(hr))
        {
            hr = ExpandResourceDir(szPath, ARRAYSIZE(szPath));
            if (SUCCEEDED(hr))
            {
                hr = EnumThemes(szPath, CThemeManager::EnumSkinCB, (LPARAM) this);
                LogStatus("EnumThemes(path=\"%ls\") returned %#08lx in CThemeManager::_EnumSkinsFromKey.\r\n", szPath, hr);
            }
        }
    }

    return S_OK;
}



HRESULT CThemeManager::_InitSkinDirs(void)
{
    HRESULT hr = S_OK;

    if (!m_hdpaSkinDirs)
    {
        m_hdpaSkinDirs = DPA_Create(2);
        if (m_hdpaSkinDirs)
        {
            // We only want to add skins if they are supported.  They are only supported if the VisualStyle manager
            // can run.  We will know that if QueryThemeServices() returns QTS_GLOBALAVAILABLE.
            BOOL fVisualStylesSupported = (QueryThemeServicesWrap() & QTS_AVAILABLE);
            LogStatus("QueryThemeServices() returned %hs in CThemeManager::_InitSkinDirs\r\n", (fVisualStylesSupported ? "TRUE" : "FALSE"));

            // Note that the VisualStyle's Manager API only works when explorer is running.  This means we will
            // lack functionality, but it is their limitation, not ours.
            if (fVisualStylesSupported)
            {
                HKEY hNewKey;

                if (SUCCEEDED(HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_THEMES_MSTHEMEDIRS, 0, KEY_READ, &hNewKey)))
                {
                    hr = _EnumSkinsFromKey(hNewKey);
                    RegCloseKey(hNewKey);
                }

                if (SUCCEEDED(HrRegOpenKeyEx(HKEY_CURRENT_USER, SZ_THEMES_MSTHEMEDIRS, 0, KEY_READ, &hNewKey)))
                {
                    hr = _EnumSkinsFromKey(hNewKey);
                    RegCloseKey(hNewKey);
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}



HRESULT CThemeManager::_InitSelectedThemeFile(void)
{
    HRESULT hr = E_INVALIDARG;

    if (!_pszSelectTheme)
    {
        WCHAR szPath[MAX_PATH];

        DWORD dwError = SHRegGetPathW(HKEY_CURRENT_USER, SZ_REGKEY_CURRENT_THEME, NULL, szPath, 0);
        hr = HRESULT_FROM_WIN32(dwError);

        // Is this the "<UserName>'s Custom Theme" item?
        // Or did it fail?  If it failed, then no theme is selected.
        if (SUCCEEDED(hr))
        {
            Str_SetPtr(&_pszSelectTheme, szPath);
            hr = S_OK;
        }
    }

    return hr;
}


HRESULT CThemeManager::_SetSelectedThemeEntree(LPCWSTR pszPath)
{
    HRESULT hr = E_INVALIDARG;

    Str_SetPtr(&_pszSelectTheme, pszPath);
    if (pszPath)
    {
        hr = HrRegSetPath(HKEY_CURRENT_USER, SZ_REGKEY_CURRENT_THEME, NULL, TRUE, pszPath);
    }
    else
    {
        hr = HrRegDeleteValue(HKEY_CURRENT_USER, SZ_REGKEY_CURRENT_THEME, NULL);
    }

    return hr;
}




//===========================
// *** IThemeManager Interface ***
//===========================
HRESULT CThemeManager::get_SelectedTheme(OUT ITheme ** ppTheme)
{
    HRESULT hr = E_INVALIDARG;

    if (ppTheme)
    {
        *ppTheme = NULL;
        if (IsSafeHost(&hr))
        {
            // In the future, we may want to call into PPID_Theme's IPropertyBag
            // to find the current visual style.  This will factor in "(Modified)"
            // themes.
            hr = _InitSelectedThemeFile();
            if (SUCCEEDED(hr))
            {
                hr = CThemeFile_CreateInstance(_pszSelectTheme, ppTheme);
            }
        }
    }

    return hr;
}


/*****************************************************************************\
    DESCRIPTION:
        Don't forget that this change is not applied until ::ApplyNow() is
    called.
\*****************************************************************************/
HRESULT CThemeManager::put_SelectedTheme(IN ITheme * pTheme)
{
    HRESULT hr = E_INVALIDARG;

    if (IsSafeHost(&hr))
    {
        CComBSTR bstrPath;

        if (pTheme)
        {
            // Persist the filename to the registry.
            hr = pTheme->GetPath(VARIANT_TRUE, &bstrPath);
        }

        if (SUCCEEDED(hr))
        {
            IPropertyBag * pPropertyBag;

            hr = _GetPropertyBagByCLSID(&PPID_Theme, &pPropertyBag);
            if (SUCCEEDED(hr))
            {
                hr = SHPropertyBag_WriteStr(pPropertyBag, SZ_PBPROP_THEME_LOADTHEME, bstrPath);
                pPropertyBag->Release();
            }
        }
    }

    return hr;
}


HRESULT CThemeManager::get_WebviewCSS(OUT BSTR * pbstrPath)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pbstrPath)
    {
        *pbstrPath = NULL;
        if (IsHostLocalZone(CAS_REG_VALIDATION, &hr))
        {
            IThemeScheme * pThemeScheme;

            hr = _saveGetSelectedScheme(&pThemeScheme);
            if (SUCCEEDED(hr))
            {
                IThemeStyle * pThemeStyle;

                hr = pThemeScheme->get_SelectedStyle(&pThemeStyle);
                if (SUCCEEDED(hr))
                {
                    IThemeSize * pThemeSize;

                    hr = pThemeStyle->get_SelectedSize(&pThemeSize);
                    if (SUCCEEDED(hr))
                    {
                        hr = pThemeSize->get_WebviewCSS(pbstrPath);

                        pThemeSize->Release();
                    }

                    pThemeStyle->Release();
                }

                pThemeScheme->Release();
            }
        }
    }

    return hr;
}


HRESULT CThemeManager::get_length(OUT long * pnLength)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pnLength)
    {
        *pnLength = 0;
        if (IsSafeHost(&hr))
        {
            hr = _InitThemeDirs();
            if (SUCCEEDED(hr))
            {
                if (m_hdpaThemeDirs)
                {
                    *pnLength += DPA_GetPtrCount(m_hdpaThemeDirs);
                }
            }
        }
    }

    return hr;
}


HRESULT CThemeManager::get_item(IN VARIANT varIndex, OUT ITheme ** ppTheme)
{
    HRESULT hr = E_INVALIDARG;

    if (ppTheme)
    {
        *ppTheme = NULL;
        if (IsSafeHost(&hr))
        {
            long nCount = 0;

            hr = E_INVALIDARG;
            get_length(&nCount);

            // This is sortof gross, but if we are passed a pointer to another variant, simply
            // update our copy here...
            if (varIndex.vt == (VT_BYREF | VT_VARIANT) && varIndex.pvarVal)
                varIndex = *(varIndex.pvarVal);

            switch (varIndex.vt)
            {
            case VT_I2:
                varIndex.lVal = (long)varIndex.iVal;
                // And fall through...

            case VT_I4:
                if ((varIndex.lVal >= 0) && (varIndex.lVal < nCount))
                {
                    if (m_hdpaThemeDirs)
                    {
                        LPWSTR pszFilename = (LPWSTR) DPA_GetPtr(m_hdpaThemeDirs, varIndex.lVal);

                        if (pszFilename)
                        {
                            hr = CThemeFile_CreateInstance(pszFilename, ppTheme);
                        }
                        else
                        {
                            hr = E_FAIL;
                        }
                    }
                    else
                    {
                        AssertMsg(0, TEXT("This should have been initiailized by get_Length(). -BryanSt"));
                        hr = E_FAIL;
                    }
                }
            break;
            case VT_BSTR:
            if (varIndex.bstrVal)
            {
                hr = CThemeFile_CreateInstance(varIndex.bstrVal, ppTheme);
            }
            else
            {
                hr = E_INVALIDARG;
            }
            break;

            default:
                hr = E_NOTIMPL;
            }
        }
    }
    return hr;
}


HRESULT CThemeManager::get_SelectedScheme(OUT IThemeScheme ** ppThemeScheme)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeScheme)
    {
        *ppThemeScheme = NULL;
        if (IsSafeHost(&hr))
        {
            if (!_pThemeSchemeSelected)
            {
                hr = _saveGetSelectedScheme(&_pThemeSchemeSelected);
            }

            if (_pThemeSchemeSelected)
            {
                IUnknown_Set((IUnknown **) ppThemeScheme, _pThemeSchemeSelected);
                hr = S_OK;
            }
        }
    }

    return hr;
}


HRESULT CThemeManager::_saveGetSelectedScheme(OUT IThemeScheme ** ppThemeScheme)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeScheme)
    {
        *ppThemeScheme = NULL;
        BOOL fIsThemeActive = IsThemeActive();

        LogStatus("IsThemeActive() returned %hs in CThemeManager::_saveGetSelectedScheme.\r\n", (fIsThemeActive ? "TRUE" : "FALSE"));

        // The selected Scheme can either be a legacy "Appearance Scheme" or
        // a selected ".msstyles" (skin) file.
        if (fIsThemeActive)
        {
            WCHAR szPath[MAX_PATH];

            hr = GetCurrentThemeName(szPath, ARRAYSIZE(szPath), NULL, 0, NULL, 0);
            LogStatus("GetCurrentThemeName(path=\"%ls\", color=\"%ls\", size=\"%ls\") returned %#08lx in CThemeManager::_saveGetSelectedScheme.\r\n", szPath, TEXT("NULL"), TEXT("NULL"), hr);
            if (SUCCEEDED(hr))
            {
                hr = CSkinScheme_CreateInstance(szPath, ppThemeScheme);
            }

            // Currently, we create this object and get the size
            // in order to force an upgrade in case it's neccessary.
            IThemeScheme * pThemeSchemeTemp;
            if (SUCCEEDED(CAppearanceScheme_CreateInstance(NULL, IID_PPV_ARG(IThemeScheme, &pThemeSchemeTemp))))
            {
                long nLength;

                pThemeSchemeTemp->get_length(&nLength);
                pThemeSchemeTemp->Release();
            }
        }

        // We want to get the Appearance scheme if no visual style is selected (i.e. IsThemeActive() returns FALSE).
        // However, if uxtheme gets confused, IsThemeActive() will return TRUE but GetCurrentThemeName() will fail.
        // in that case, we want to also fallback to the classic visual style so the UI is usable.
        if (FAILED(hr))
        {
            // The "Control Panel\\Appearance","Current" key will indicate the selected
            // Appearance Scheme.
            hr = CAppearanceScheme_CreateInstance(NULL, IID_PPV_ARG(IThemeScheme, ppThemeScheme));
        }
    }

    return hr;
}


/*****************************************************************************\
    DESCRIPTION:
        Don't forget that this change is not applied until ::ApplyNow() is
    called.
\*****************************************************************************/
HRESULT CThemeManager::put_SelectedScheme(IN IThemeScheme * pThemeScheme)
{
    HRESULT hr;

    if (IsSafeHost(&hr))
    {
        if (pThemeScheme)
        {
            CComBSTR bstrPath;
            IThemeStyle * pThemeStyle;

            IUnknown_Set((IUnknown **) &_pThemeSchemeSelected, pThemeScheme);

            pThemeScheme->get_Path(&bstrPath);      // It's fine if it returns NULL or empty str.
            hr = pThemeScheme->get_SelectedStyle(&pThemeStyle);
            if (SUCCEEDED(hr))
            {
                CComBSTR bstrStyle;

                hr = pThemeStyle->get_Name(&bstrStyle);
                if (SUCCEEDED(hr))
                {
                    IThemeSize * pThemeSize;

                    hr = pThemeStyle->get_SelectedSize(&pThemeSize);
                    if (SUCCEEDED(hr))
                    {
                        CComBSTR bstrSize;

                        hr = pThemeSize->get_Name(&bstrSize);
                        if (SUCCEEDED(hr))
                        {
                            VARIANT variant;

                            variant.vt = VT_BSTR;
                            variant.bstrVal = bstrPath;
                            hr = Write(SZ_PBPROP_VISUALSTYLE_PATH, &variant);
                            if (SUCCEEDED(hr))
                            {
                                variant.bstrVal = bstrStyle;
                                hr = Write(SZ_PBPROP_VISUALSTYLE_COLOR, &variant);
                                if (SUCCEEDED(hr))
                                {
                                    variant.bstrVal = bstrSize;
                                    hr = Write(SZ_PBPROP_VISUALSTYLE_SIZE, &variant);
                                }
                            }
                        }

                        pThemeSize->Release();
                    }
                }

                pThemeStyle->Release();
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
}


HRESULT CThemeManager::get_schemeLength(OUT long * pnLength)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pnLength)
    {
        *pnLength = 1;
        if (IsSafeHost(&hr))
        {
            hr = _InitSkinDirs();
            if (SUCCEEDED(hr))
            {
                if (m_hdpaSkinDirs)
                {
                    *pnLength += DPA_GetPtrCount(m_hdpaSkinDirs);
                }
            }
        }
    }

    return hr;
}


HRESULT CThemeManager::get_schemeItem(IN VARIANT varIndex, OUT IThemeScheme ** ppThemeScheme)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeScheme)
    {
        if (IsSafeHost(&hr))
        {
            long nCount = 0;

            hr = E_INVALIDARG;
            get_schemeLength(&nCount);
            *ppThemeScheme = NULL;

            // This is sortof gross, but if we are passed a pointer to another variant, simply
            // update our copy here...
            if (varIndex.vt == (VT_BYREF | VT_VARIANT) && varIndex.pvarVal)
                varIndex = *(varIndex.pvarVal);

            switch (varIndex.vt)
            {
            case VT_I2:
                varIndex.lVal = (long)varIndex.iVal;
                // And fall through...

            case VT_I4:
                if ((varIndex.lVal >= 0) && (varIndex.lVal < nCount))
                {
                    if (0 == varIndex.lVal)
                    {
                        // 0 is the Appearance scheme, which means there isn't a skin.
                        // This is the same as the legacy Appeanance tab.
                        hr = CAppearanceScheme_CreateInstance(NULL, IID_PPV_ARG(IThemeScheme, ppThemeScheme));
                    }
                    else
                    {
                        if (m_hdpaSkinDirs)
                        {
                            LPWSTR pszFilename = (LPWSTR) DPA_GetPtr(m_hdpaSkinDirs, varIndex.lVal-1);

                            if (pszFilename)
                            {
                                hr = CSkinScheme_CreateInstance(pszFilename, ppThemeScheme);
                            }
                            else
                            {
                                hr = E_FAIL;
                            }
                        }
                        else
                        {
                            AssertMsg(0, TEXT("This should have been initiailized by get_schemeLength(). -BryanSt"));
                            hr = E_FAIL;
                        }
                    }
                }
            break;
            case VT_BSTR:
            if (varIndex.bstrVal && varIndex.bstrVal[0] &&
                !StrCmpI(PathFindExtension(varIndex.bstrVal), TEXT(".msstyles")))
            {
                hr = CSkinScheme_CreateInstance(varIndex.bstrVal, ppThemeScheme);
            }
            else
            {
                hr = CAppearanceScheme_CreateInstance(NULL, IID_PPV_ARG(IThemeScheme, ppThemeScheme));
            }
            break;

            default:
                hr = E_NOTIMPL;
            }
        }
    }

    return hr;
}


HRESULT CThemeManager::GetSelectedSchemeProperty(IN BSTR bstrName, OUT BSTR * pbstrValue)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrName && pbstrValue)
    {
        *pbstrValue = NULL;
        if (IsSafeHost(&hr))
        {
            TCHAR szPath[MAX_PATH];
            TCHAR szColor[MAX_PATH];
            TCHAR szSize[MAX_PATH];
            BOOL fIsThemeActive = IsThemeActive();

            LogStatus("IsThemeActive() returned %hs in CThemeManager::GetSelectedSchemeProperty.\r\n", (fIsThemeActive ? "TRUE" : "FALSE"));


            szPath[0] = 0;
            szColor[0] = 0;
            szSize[0] = 0;
            if (fIsThemeActive)
            {
                hr = GetCurrentThemeName(szPath, ARRAYSIZE(szPath), szColor, ARRAYSIZE(szColor),
                                         szSize, ARRAYSIZE(szSize));
                LogStatus("GetCurrentThemeName() returned %#08lx in CThemeManager::GetSelectedSchemeProperty.\r\n", hr);
            }

            if (SUCCEEDED(hr))
            {
                if (!StrCmpI(bstrName, SZ_CSP_PATH))
                {
                    PathRemoveFileSpec(szPath);
                    hr = HrSysAllocString(szPath, pbstrValue);
                }
                else if (!StrCmpI(bstrName, SZ_CSP_FILE))
                {
                    hr = HrSysAllocString(szPath, pbstrValue);
                }
                else if (!StrCmpI(bstrName, SZ_CSP_DISPLAYNAME))
                {
                    if (szPath[0])
                    {
                        hr = GetThemeDocumentationProperty(szPath, SZ_THDOCPROP_DISPLAYNAME, szPath, ARRAYSIZE(szPath));
                        LogStatus("GetThemeDocumentationProperty() returned %#08lx in CThemeManager::GetSelectedSchemeProperty.\r\n", hr);
                    }

                    if (SUCCEEDED(hr))
                    {
                        hr = HrSysAllocString(szPath, pbstrValue);
                    }
                }
                else if (!StrCmpI(bstrName, SZ_CSP_CANONICALNAME))
                {
                    if (szPath[0])
                    {
                        hr = GetThemeDocumentationProperty(szPath, SZ_THDOCPROP_CANONICALNAME, szPath, ARRAYSIZE(szPath));
                        LogStatus("GetThemeDocumentationProperty() returned %#08lx in CThemeManager::GetSelectedSchemeProperty.\r\n", hr);
                    }

                    if (SUCCEEDED(hr))
                    {
                        hr = HrSysAllocString(szPath, pbstrValue);
                    }
                }
                else if (!StrCmpI(bstrName, SZ_CSP_COLOR))
                {
                    hr = HrSysAllocString(szColor, pbstrValue);
                }
                else if (!StrCmpI(bstrName, SZ_CSP_SIZE))
                {
                    hr = HrSysAllocString(szSize, pbstrValue);
                }
            }
        }
    }

    return hr;
}


HRESULT CThemeManager::GetSpecialTheme(IN BSTR bstrName, OUT ITheme ** ppTheme)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrName && ppTheme)
    {
        *ppTheme = NULL;
        if (IsSafeHost(&hr))
        {
            if (!StrCmpI(SZ_STDEFAULTTHEME, bstrName))
            {
                TCHAR szPath[MAX_PATH];
            
                hr = HrRegGetPath(HKEY_CURRENT_USER, SZ_THEMES, SZ_REGVALUE_INSTALL_THEME, szPath, ARRAYSIZE(szPath));
                if (SUCCEEDED(hr))
                {
                    ExpandResourceDir(szPath, ARRAYSIZE(szPath));
                    hr = CThemeFile_CreateInstance(szPath, ppTheme);
                }
            }
        }
    }

    return hr;
}


HRESULT CThemeManager::SetSpecialTheme(IN BSTR bstrName, IN ITheme * pTheme)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrName)
    {
        if (IsSafeHost(&hr))
        {
            if (!StrCmpI(SZ_STDEFAULTTHEME, bstrName))
            {
                CComBSTR bstrPath;

                if (pTheme)
                {
                    hr = pTheme->GetPath(VARIANT_TRUE, &bstrPath);
                }
                else
                {
                    bstrPath = L"";     // This means use "Windows Classic".
                }

                if (bstrPath)
                {
                    hr = HrRegSetPath(HKEY_CURRENT_USER, SZ_THEMES, SZ_REGVALUE_INSTALL_THEME, TRUE, bstrPath);
                }
            }
        }
    }

    return hr;
}


HRESULT CThemeManager::GetSpecialScheme(IN BSTR bstrName, OUT IThemeScheme ** ppThemeScheme, OUT IThemeStyle ** ppThemeStyle, OUT IThemeSize ** ppThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrName && ppThemeScheme && ppThemeStyle && ppThemeSize)
    {
        *ppThemeScheme = NULL;
        *ppThemeStyle = NULL;
        *ppThemeSize = NULL;

        TCHAR szVisualStylePath[MAX_PATH];
        DWORD dwType;
        DWORD cbSize = sizeof(szVisualStylePath);

        // Is a SetVisualStyle policy is set, don't honor this call
        if (ERROR_SUCCESS == SHRegGetUSValue(SZ_REGKEY_POLICIES_SYSTEM, SZ_REGVALUE_POLICY_SETVISUALSTYLE, &dwType, (void *) szVisualStylePath, &cbSize, FALSE, NULL, 0)
            || IsUserHighContrastUser())
        {
            hr = E_ACCESSDENIED; // Don't mess with visual styles when SetVisualStyle is enforced or high contrast is on
        } 
        else if(IsSafeHost(&hr))
        {
            if (!StrCmpI(SZ_SSDEFAULVISUALSTYLEON, bstrName) ||
                !StrCmpI(SZ_SSDEFAULVISUALSTYLEOFF, bstrName))
            {
                TCHAR szRegKey[MAX_PATH];
                TCHAR szVisualStyle[MAX_PATH];

                wnsprintf(szRegKey, ARRAYSIZE(szRegKey), TEXT("%s\\%s"), SZ_THEMES, bstrName);
                hr = HrRegGetPath(HKEY_CURRENT_USER, szRegKey, SZ_REGVALUE_INSTALL_VISUALSTYLE, szVisualStyle, ARRAYSIZE(szVisualStyle));
                if (SUCCEEDED(hr))
                {
                    TCHAR szColorStyle[MAX_PATH];

                    ExpandResourceDir(szVisualStyle, ARRAYSIZE(szVisualStyle));
                    hr = HrRegGetValueString(HKEY_CURRENT_USER, szRegKey, SZ_REGVALUE_INSTALL_VSCOLOR, szColorStyle, ARRAYSIZE(szColorStyle));
                    if (SUCCEEDED(hr))
                    {
                        TCHAR szSize[MAX_PATH];

                        hr = HrRegGetValueString(HKEY_CURRENT_USER, szRegKey, SZ_REGVALUE_INSTALL_VSSIZE, szSize, ARRAYSIZE(szSize));
                        if (SUCCEEDED(hr))
                        {
                            CComVariant varIndex(szVisualStyle);

                            hr = get_schemeItem(varIndex, ppThemeScheme);
                            if (SUCCEEDED(hr))
                            {
                                CComVariant varColorIndex(szColorStyle);

                                hr = (*ppThemeScheme)->get_item(varColorIndex, ppThemeStyle);
                                if (SUCCEEDED(hr))
                                {
                                    CComVariant varSizeIndex(szSize);

                                    hr = (*ppThemeStyle)->get_item(varSizeIndex, ppThemeSize);
                                }
                            }
                        }
                    }
                }

                if (FAILED(hr))
                {
                    // Return consistent results.
                    ATOMICRELEASE(*ppThemeScheme);
                    ATOMICRELEASE(*ppThemeStyle);
                    ATOMICRELEASE(*ppThemeSize);
                }
            }
        }
    }

    return hr;
}


HRESULT CThemeManager::SetSpecialScheme(IN BSTR bstrName, IN IThemeScheme * pThemeScheme, IThemeStyle * pThemeStyle, IThemeSize * pThemeSize)
{
    HRESULT hr = E_NOTIMPL;

    if (IsSafeHost(&hr))
    {
    }

    return hr;
}


HRESULT CThemeManager::ApplyNow(void)
{
    HRESULT hr = E_INVALIDARG;

    if (IsSafeHost(&hr))
    {
        hr = ApplyPressed(TUIAP_NONE | TUIAP_WAITFORAPPLY);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\store.h ===
/*****************************************************************************\
    FILE: store.h

    DESCRIPTION:
        This file will get and set effect settings into the persisted store.
    That persisted store is the registery and in SystemParametersInfo.

    BryanSt 4/17/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _STORE_H
#define _STORE_H


#define MENU_EFFECT_FADE        1
#define MENU_EFFECT_SCROLL      2

#define FONT_SMOOTHING_MONO        0
#define FONT_SMOOTHING_AA          1
#define FONT_SMOOTHING_CT          2

#define PATH_WIN  0
#define PATH_SYS  1
#define PATH_IEXP 2

enum ICON_SIZE_TYPES {
   ICON_DEFAULT         = 0,
   ICON_LARGE           = 1,
   ICON_INDETERMINATE   = 2
};

#define ICON_DEFAULT_SMALL    16
#define ICON_DEFAULT_NORMAL   32
#define ICON_DEFAULT_LARGE    48


extern GUID CLSID_EffectsPage;



class CEffectState
{
public:
    // Private Member Variables
    int      _nLargeIcon;             // Large Icon State            (iOldLI, iNewLI)
    int      _nHighIconColor;         // High Icon Colour            (iOldHIC, iNewHIC)
    WPARAM   _wpMenuAnimation;        // Menu Animation State        (wOldMA, wNewMA)
    BOOL     _fFontSmoothing;         // Font Smoothing State        (bOldSF, bNewSF)
    DWORD    _dwFontSmoothingType;    // Font Smoothing Type         (dwOldSFT, dwNewSFT)
    BOOL     _fDragWindow;            // Drag Window State           (bOldDW, bNewDW)
    BOOL     _fKeyboardIndicators;    // Keyboard Indicators         (uOldKI, uNewKI)
    DWORD    _dwAnimationEffect;      // Animation Effect            (dwOldEffect, dwNewEffect)
    BOOL     _fMenuShadows;           // Show Menu Shadows

    // Old values (before they were dirtied)
    int      _nOldLargeIcon;             // Large Icon State            (iOldLI)
    int      _nOldHighIconColor;         // High Icon Colour            (iOldHIC)
    WPARAM   _wpOldMenuAnimation;        // Menu Animation State        (wOldMA)
    BOOL     _fOldFontSmoothing;         // Font Smoothing State        (bOldSF)
    DWORD    _dwOldFontSmoothingType;    // Font Smoothing Type         (dwOldSFT)
    BOOL     _fOldDragWindow;            // Drag Window State           (bOldDW)
    BOOL     _fOldKeyboardIndicators;    // Keyboard Indicators         (uOldKI)
    DWORD    _dwOldAnimationEffect;      // Animation Effect            (dwOldEffect)
    BOOL     _fOldMenuShadows;           // Show Menu Shadows

    // Private Member Functions
    HRESULT Load(void);
    HRESULT Save(void);
    HRESULT Clone(OUT CEffectState ** ppEffectClone);
    BOOL IsDirty(void);
    HRESULT GetIconPath(IN CLSID clsid, IN LPCWSTR pszName, IN LPWSTR pszPath, IN DWORD cchSize);
    HRESULT SetIconPath(IN CLSID clsid, IN LPCWSTR pszName, IN LPCWSTR pszPath, IN int nResourceID);

    CEffectState(void);

    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

private:

    // Private Member Variables
    long                    m_cRef;

    // Private Member Functions
    HRESULT _SaveWorkerProc(void);
    HRESULT _SaveSettings(BOOL fBroadcast);
    static DWORD CALLBACK Save_WorkerProc(void * pThis);

    virtual ~CEffectState(void);
};




int GetBitsPerPixel(void);

extern HINSTANCE g_hmodShell32;



#endif // _STORE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\settingspg.cpp ===
/*****************************************************************************\
    FILE: SettingsPg.cpp

    DESCRIPTION:
        This code will display a "Settings" tab in the
    "Display Properties" dialog

    BryanSt 1/05/2001    Updated and Converted to C++

    Copyright (C) Microsoft Corp 1993-2001. All rights reserved.
\*****************************************************************************/

#include "priv.h"

#include "SettingsPg.h"
#include "DisplaySettings.h"
#include "shlobjp.h"
#include "shlwapi.h"
#include "ntreg.hxx"
#include "AdvAppearPg.h"
#include <tchar.h>
#include <dbt.h>
#include <oleacc.h>
#include <devguid.h>

#define EIS_NOT_INVALID                          0x00000001
#define EIS_EXEC_INVALID_NEW_DRIVER              0x00000002
#define EIS_EXEC_INVALID_DEFAULT_DISPLAY_MODE    0x00000003
#define EIS_EXEC_INVALID_DISPLAY_DRIVER          0x00000004
#define EIS_EXEC_INVALID_OLD_DISPLAY_DRIVER      0x00000005
#define EIS_EXEC_INVALID_16COLOR_DISPLAY_MODE    0x00000006
#define EIS_EXEC_INVALID_DISPLAY_MODE            0x00000007
#define EIS_EXEC_INVALID_CONFIGURATION           0x00000008
#define EIS_EXEC_INVALID_DISPLAY_DEVICE          0x00000009

LRESULT CALLBACK MonitorWindowProc(HWND hwnd, UINT msg,WPARAM wParam,LPARAM lParam);
LRESULT CALLBACK SliderSubWndProc (HWND hwndSlider, UINT uMsg, WPARAM wParam, LPARAM lParam, WPARAM uID, ULONG_PTR dwRefData);
int ComputeNumberOfDisplayDevices();

BOOL MakeMonitorBitmap(int w, int h, LPCTSTR sz, HBITMAP *pBitmap, HBITMAP *pMaskBitmap, int cx, int cy, BOOL fSelected);

typedef struct _APPEXT {
    TCHAR szKeyName[MAX_PATH];
    TCHAR szDefaultValue[MAX_PATH];
    struct _APPEXT* pNext;
} APPEXT, *PAPPEXT;

VOID CheckForDuplicateAppletExtensions(HKEY hkDriver);
VOID DeskAESnapshot(HKEY hkExtensions, PAPPEXT* ppAppExt);
VOID DeskAECleanup(PAPPEXT pAppExt);
VOID DeskAEDelete(PTCHAR szDeleteFrom, PTCHAR mszExtensionsToRemove);

#define SELECTION_THICKNESS 4
#define MONITOR_BORDER      1

#define REGSTR_VAL_SAFEBOOT        TEXT("System\\CurrentControlSet\\Control\\SafeBoot\\Option")

// Maximum number of monitors supported.
#define MONITORS_MAX    10

#define PREVIEWAREARATIO 2

#define MM_REDRAWPREVIEW (WM_USER + 1)
#define MM_MONITORMOVED  (WM_USER + 2)

#define ToolTip_Activate(hTT, activate) \
    SendMessage(hTT, TTM_ACTIVATE, (WPARAM) activate, (LPARAM) 0)

#define ToolTip_AddTool(hTT, lpti) \
    SendMessage(hTT, TTM_ADDTOOL, (WPARAM) 0, (LPARAM) (lpti))

#define ToolTip_DelTool(hTT, lpti) \
    SendMessage(hTT, TTM_DELTOOL, (WPARAM) 0, (LPARAM) (lpti))

#define ToolTip_GetCurrentTool(hTT, lpti) \
    SendMessage(hTT, TTM_GETCURRENTTOOL, (WPARAM) 0, (LPARAM) (lpti))

#define ToolTip_RelayEvent(hTT, _msg, h, m, wp, lp)                         \
    _msg.hwnd = h; _msg.message = m; _msg.wParam = wp; _msg.lParam = lp;\
    SendMessage(hTT, TTM_RELAYEVENT, (WPARAM) 0, (LPARAM) &_msg);

#define ToolTip_SetDelayTime(hTT, d, t) \
    SendMessage(hTT, TTM_SETDELAYTIME, (WPARAM) d, (LPARAM)MAKELONG((t), 0))

#define ToolTip_SetToolInfo(hTT, lpti) \
    SendMessage(hTT, TTM_SETTOOLINFO, (WPARAM) 0, (LPARAM) (lpti))

#define ToolTip_TrackActivate(hTT, bActivate, lpti) \
    SendMessage(hTT, TTM_TRACKACTIVATE, (WPARAM) (bActivate), (LPARAM) (lpti))

#define ToolTip_TrackPosition(hTT, x, y) \
    SendMessage(hTT, TTM_TRACKPOSITION, (WPARAM) 0, (LPARAM) MAKELONG((x), (y)))

#define ToolTip_Update(hTT) \
    SendMessage(hTT, TTM_UPDATE, (WPARAM) 0, (LPARAM) 0)

VOID
CDECL
TRACE(
    PCTSTR pszMsg,
    ...
    )
/*++

Outputs a message to the setup log.  Prepends "desk.cpl  " to the strings and
appends the correct newline chars (\r\n)==

  --*/
{
    TCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    va_start(vArgs, pszMsg);
    wvsprintf(ach, pszMsg, vArgs);
    va_end(vArgs);

    OutputDebugString(ach);
}

#ifdef _WIN64
//
//  GetDlgItem and GetDlgCtrlID don't support INT_PTR's,
//  so we have to do it manually.
//  Fortunately, GetWindowLongPtr(GWLP_ID) actually returns a full 64-bit
//  value instead of truncating at 32-bits.
//

#define GetDlgCtrlIDP(hwnd)  GetWindowLongPtr(hwnd, GWLP_ID)

HWND GetDlgItemP(HWND hDlg, INT_PTR id)
{
    HWND hwndChild = GetWindow(hDlg, GW_CHILD);
    while (hwndChild && GetDlgCtrlIDP(hwndChild) != id)
        hwndChild = GetWindow(hwndChild, GW_HWNDNEXT);
    return hwndChild;
}

#else
#define GetDlgItemP     GetDlgItem
#define GetDlgCtrlIDP   GetDlgCtrlID
#endif


//
// display devices
//
typedef struct _multimon_device {

    //
    // Main class for settings
    //

    CDisplaySettings * pds;

    //
    // Color and resolution information cache
    // Rebuild when modes are enumerated.
    //

    int            cColors;
    PLONGLONG      ColorList;
    int            cResolutions;
    PPOINT         ResolutionList;


    ULONG          ComboBoxItem;
    DISPLAY_DEVICE DisplayDevice;
    ULONG          DisplayIndex;
    POINT          Snap;
    HDC            hdc;

    //
    // Image information.
    //
    int            w,h;
    HIMAGELIST     himl;
    int            iImage;

    BOOLEAN        bTracking;
    HWND           hwndFlash;  //Flash window.
} MULTIMON_DEVICE, *PMULTIMON_DEVICE;

#define GetDlgCtrlDevice(hwnd) ((PMULTIMON_DEVICE)GetDlgCtrlIDP(hwnd))

BOOL gfFlashWindowRegistered = FALSE;
HWND ghwndToolTipTracking;
HWND ghwndToolTipPopup;
HWND ghwndPropSheet;

void AddTrackingToolTip(PMULTIMON_DEVICE pDevice, HWND hwnd);
void RemoveTrackingToolTip(HWND hwnd);

void AddPopupToolTip(HWND hwndC);
void RemovePopupToolTip(HWND hwndC);

#if QUICK_REFRESH
#define IDC_FREQUENCY_START     2000
HMENU CreateFrequencyMenu(PMULTIMON_DEVICE pDevice);
#endif

extern int AskDynaCDS(HWND hDlg);
extern int GetDisplayCPLPreference(LPCTSTR szRegVal);
extern void SetDisplayCPLPreference(LPCTSTR szRegVal, int val);

// Prototype for CreateStdAccessibleProxy.
// A and W versions are available - pClassName can be ANSI or UNICODE
// string. This is a TCHAR-style prototype, but you can do a A or W
// specific one if desired.
typedef HRESULT (WINAPI *PFNCREATESTDACCESSIBLEPROXY) (
    HWND     hWnd,
    LPTSTR   pClassName,
    LONG     idObject,
    REFIID   riid,
    void **  ppvObject
    );

// Same for LresultFromObject...
typedef LRESULT (WINAPI *PFNLRESULTFROMOBJECT)(
    REFIID riid,
    WPARAM wParam,
    LPUNKNOWN punk
    );


PRIVATE PFNCREATESTDACCESSIBLEPROXY s_pfnCreateStdAccessibleProxy = NULL;
PRIVATE PFNLRESULTFROMOBJECT s_pfnLresultFromObject = NULL;

BOOL g_fAttemptedOleAccLoad ;
HMODULE g_hOleAcc;

//-----------------------------------------------------------------------------
static const DWORD sc_MultiMonitorHelpIds[] =
{
   IDC_SCREENSAMPLE,  IDH_DISPLAY_SETTINGS_MONITOR_GRAPHIC,
   IDC_MULTIMONHELP,  IDH_DISPLAY_SETTINGS_MONITOR_GRAPHIC,
   IDC_DISPLAYDESK,   IDH_DISPLAY_SETTINGS_MONITOR_GRAPHIC,

   IDC_DISPLAYLABEL,  IDH_DISPLAY_SETTINGS_DISPLAY_LIST,
   IDC_DISPLAYLIST,   IDH_DISPLAY_SETTINGS_DISPLAY_LIST,
   IDC_DISPLAYTEXT,   IDH_DISPLAY_SETTINGS_DISPLAY_LIST,

   IDC_COLORGROUPBOX, IDH_DISPLAY_SETTINGS_COLORBOX,
   IDC_COLORBOX,      IDH_DISPLAY_SETTINGS_COLORBOX,
   IDC_COLORSAMPLE,   IDH_DISPLAY_SETTINGS_COLORBOX,

   IDC_RESGROUPBOX,   IDH_DISPLAY_SETTINGS_SCREENAREA,
   IDC_SCREENSIZE,    IDH_DISPLAY_SETTINGS_SCREENAREA,
   IDC_RES_LESS,      IDH_DISPLAY_SETTINGS_SCREENAREA,
   IDC_RES_MORE,      IDH_DISPLAY_SETTINGS_SCREENAREA,
   IDC_RESXY,         IDH_DISPLAY_SETTINGS_SCREENAREA,

   IDC_DISPLAYUSEME,  IDH_DISPLAY_SETTINGS_EXTEND_DESKTOP_CHECKBOX,
   IDC_DISPLAYPRIME,  IDH_DISPLAY_SETTINGS_USE_PRIMARY_CHECKBOX,

   IDC_IDENTIFY,          IDH_DISPLAY_SETTINGS_IDENTIFY_BUTTON,
   IDC_TROUBLESHOOT,      IDH_DISPLAY_SETTINGS_TROUBLE_BUTTON,
   IDC_DISPLAYPROPERTIES, IDH_DISPLAY_SETTINGS_ADVANCED_BUTTON,

   0, 0
};

class CAccessibleWrapper: public IAccessible
{
        // We need to do our own refcounting for this wrapper object
        ULONG          m_ref;

        // Need ptr to the IAccessible
        IAccessible *  m_pAcc;
        HWND           m_hwnd;
public:
        CAccessibleWrapper( HWND hwnd, IAccessible * pAcc );
        virtual ~CAccessibleWrapper(void);

        // IUnknown
        // (We do our own ref counting)
        virtual STDMETHODIMP            QueryInterface(REFIID riid, void** ppv);
        virtual STDMETHODIMP_(ULONG)    AddRef();
        virtual STDMETHODIMP_(ULONG)    Release();

        // IDispatch
        virtual STDMETHODIMP            GetTypeInfoCount(UINT* pctinfo);
        virtual STDMETHODIMP            GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
        virtual STDMETHODIMP            GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames,
            LCID lcid, DISPID* rgdispid);
        virtual STDMETHODIMP            Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
            DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
            UINT* puArgErr);

        // IAccessible
        virtual STDMETHODIMP            get_accParent(IDispatch ** ppdispParent);
        virtual STDMETHODIMP            get_accChildCount(long* pChildCount);
        virtual STDMETHODIMP            get_accChild(VARIANT varChild, IDispatch ** ppdispChild);

        virtual STDMETHODIMP            get_accName(VARIANT varChild, BSTR* pszName);
        virtual STDMETHODIMP            get_accValue(VARIANT varChild, BSTR* pszValue);
        virtual STDMETHODIMP            get_accDescription(VARIANT varChild, BSTR* pszDescription);
        virtual STDMETHODIMP            get_accRole(VARIANT varChild, VARIANT *pvarRole);
        virtual STDMETHODIMP            get_accState(VARIANT varChild, VARIANT *pvarState);
        virtual STDMETHODIMP            get_accHelp(VARIANT varChild, BSTR* pszHelp);
        virtual STDMETHODIMP            get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic);
        virtual STDMETHODIMP            get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut);
        virtual STDMETHODIMP            get_accFocus(VARIANT * pvarFocusChild);
        virtual STDMETHODIMP            get_accSelection(VARIANT * pvarSelectedChildren);
        virtual STDMETHODIMP            get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction);

        virtual STDMETHODIMP            accSelect(long flagsSel, VARIANT varChild);
        virtual STDMETHODIMP            accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);
        virtual STDMETHODIMP            accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);
        virtual STDMETHODIMP            accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint);
        virtual STDMETHODIMP            accDoDefaultAction(VARIANT varChild);

        virtual STDMETHODIMP            put_accName(VARIANT varChild, BSTR szName);
        virtual STDMETHODIMP            put_accValue(VARIANT varChild, BSTR pszValue);
};

CAccessibleWrapper::CAccessibleWrapper( HWND hwnd, IAccessible * pAcc )
    : m_ref( 1 ),
      m_pAcc( pAcc ),
      m_hwnd( hwnd )
{
    ASSERT( m_pAcc );
    m_pAcc->AddRef();
}


CAccessibleWrapper::~CAccessibleWrapper()
{
    m_pAcc->Release();
}


// IUnknown
// Implement refcounting ourselves
// Also implement QI ourselves, so that we return a ptr back to the wrapper.
STDMETHODIMP  CAccessibleWrapper::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    if ((riid == IID_IUnknown)  ||
        (riid == IID_IDispatch) ||
        (riid == IID_IAccessible))
    {
        *ppv = (IAccessible *) this;
    }
    else
        return(E_NOINTERFACE);

    AddRef();
    return(NOERROR);
}


STDMETHODIMP_(ULONG) CAccessibleWrapper::AddRef()
{
    return ++m_ref;
}


STDMETHODIMP_(ULONG) CAccessibleWrapper::Release()
{
    ULONG ulRet = --m_ref;

    if( ulRet == 0 )
        delete this;

    return ulRet;
}

// IDispatch
// - pass all through m_pAcc

STDMETHODIMP  CAccessibleWrapper::GetTypeInfoCount(UINT* pctinfo)
{
    return m_pAcc->GetTypeInfoCount(pctinfo);
}


STDMETHODIMP  CAccessibleWrapper::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
{
    return m_pAcc->GetTypeInfo(itinfo, lcid, pptinfo);
}


STDMETHODIMP  CAccessibleWrapper::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames,
            LCID lcid, DISPID* rgdispid)
{
    return m_pAcc->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
}

STDMETHODIMP  CAccessibleWrapper::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
            DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
            UINT* puArgErr)
{
    return m_pAcc->Invoke(dispidMember, riid, lcid, wFlags,
            pdispparams, pvarResult, pexcepinfo,
            puArgErr);
}

// IAccessible
// - pass all through m_pAcc

STDMETHODIMP  CAccessibleWrapper::get_accParent(IDispatch ** ppdispParent)
{
    return m_pAcc->get_accParent(ppdispParent);
}


STDMETHODIMP  CAccessibleWrapper::get_accChildCount(long* pChildCount)
{
    return m_pAcc->get_accChildCount(pChildCount);
}


STDMETHODIMP  CAccessibleWrapper::get_accChild(VARIANT varChild, IDispatch ** ppdispChild)
{
    return m_pAcc->get_accChild(varChild, ppdispChild);
}



STDMETHODIMP  CAccessibleWrapper::get_accName(VARIANT varChild, BSTR* pszName)
{
    return m_pAcc->get_accName(varChild, pszName);
}



STDMETHODIMP  CAccessibleWrapper::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    // varChild.lVal specifies which sub-part of the component
    // is being queried.
    // CHILDID_SELF (0) specifies the overall component - other
    // non-0 values specify a child.

    // In a trackbar, CHILDID_SELF refers to the overall trackbar
    // (which is what we want), whereas other values refer to the
    // sub-components - the actual slider 'thumb', and the 'page
    // up/page down' areas to the left/right of it.
    if( varChild.vt == VT_I4 && varChild.lVal == CHILDID_SELF )
    {
        HWND hDlg;
        TCHAR achRes[120];
#ifndef UNICODE
        WCHAR wszRes[120];
#endif

        hDlg = GetParent( m_hwnd );

        SendDlgItemMessage(hDlg, IDC_RESXY, WM_GETTEXT, 120, (LPARAM)achRes);
#ifdef UNICODE
        *pszValue = SysAllocString( achRes );
#else
        MultiByteToWideChar( CP_ACP, 0, achRes, -1, wszRes, 120 );
        *pszValue = SysAllocString( wszRes );
#endif
        return S_OK;

    }
    else
    {
        // Pass requests about the sub-components to the
        // 'original' IAccessible for us).
        return m_pAcc->get_accValue(varChild, pszValue);
    }
}


STDMETHODIMP  CAccessibleWrapper::get_accDescription(VARIANT varChild, BSTR* pszDescription)
{
    return m_pAcc->get_accDescription(varChild, pszDescription);
}


STDMETHODIMP  CAccessibleWrapper::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    return m_pAcc->get_accRole(varChild, pvarRole);
}


STDMETHODIMP  CAccessibleWrapper::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    return m_pAcc->get_accState(varChild, pvarState);
}


STDMETHODIMP  CAccessibleWrapper::get_accHelp(VARIANT varChild, BSTR* pszHelp)
{
    return m_pAcc->get_accHelp(varChild, pszHelp);
}


STDMETHODIMP  CAccessibleWrapper::get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic)
{
    return m_pAcc->get_accHelpTopic(pszHelpFile, varChild, pidTopic);
}


STDMETHODIMP  CAccessibleWrapper::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut)
{
    return m_pAcc->get_accKeyboardShortcut(varChild, pszKeyboardShortcut);
}


STDMETHODIMP  CAccessibleWrapper::get_accFocus(VARIANT * pvarFocusChild)
{
    return m_pAcc->get_accFocus(pvarFocusChild);
}


STDMETHODIMP  CAccessibleWrapper::get_accSelection(VARIANT * pvarSelectedChildren)
{
    return m_pAcc->get_accSelection(pvarSelectedChildren);
}


STDMETHODIMP  CAccessibleWrapper::get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction)
{
    return m_pAcc->get_accDefaultAction(varChild, pszDefaultAction);
}



STDMETHODIMP  CAccessibleWrapper::accSelect(long flagsSel, VARIANT varChild)
{
    return m_pAcc->accSelect(flagsSel, varChild);
}


STDMETHODIMP  CAccessibleWrapper::accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
    return m_pAcc->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
}


STDMETHODIMP  CAccessibleWrapper::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    return m_pAcc->accNavigate(navDir, varStart, pvarEndUpAt);
}


STDMETHODIMP  CAccessibleWrapper::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{
    return m_pAcc->accHitTest(xLeft, yTop, pvarChildAtPoint);
}


STDMETHODIMP  CAccessibleWrapper::accDoDefaultAction(VARIANT varChild)
{
    return m_pAcc->accDoDefaultAction(varChild);
}



STDMETHODIMP  CAccessibleWrapper::put_accName(VARIANT varChild, BSTR szName)
{
    return m_pAcc->put_accName(varChild, szName);
}


STDMETHODIMP  CAccessibleWrapper::put_accValue(VARIANT varChild, BSTR pszValue)
{
    return m_pAcc->put_accValue(varChild, pszValue);
}


class CSettingsPage  :  public CObjectWithSite,
                        public CObjectCLSID,
                        public IMultiMonConfig,
                        public IPropertyBag, 
                        public IBasePropPage

{
    friend int ComputeNumberOfDisplayDevices();
    friend int DisplaySaveSettings(PVOID pContext, HWND hwnd);

    private:
        // Data Section
        PMULTIMON_DEVICE _pCurDevice;
        PMULTIMON_DEVICE _pPrimaryDevice;

        // HWND for the main window
        HWND _hDlg;
        HWND _hwndDesk;
        HWND _hwndList;

        // union of all monitor RECTs
        RECT _rcDesk;

        // ref count
        LONG _cRef;
        LONG _nInApply;

        // how to translate to preview size
        int   _DeskScale;
        POINT _DeskOff;
        UINT  _InSetInfo;
        ULONG _NumDevices;
        HBITMAP _hbmScrSample;
        HBITMAP _hbmMonitor;
        HIMAGELIST _himl;
        DWORD _dwInvalidMode;


        // UI variables
        int  _iColor;
        int  _iResolution;

        BOOL _bBadDriver         : 1;
        BOOL _bNoAttach          : 1;
        BOOL _bDirty             : 1;

        MULTIMON_DEVICE _Devices[MONITORS_MAX];

        // Private functions
        void _DeskToPreview(LPRECT in, LPRECT out);
        void _OffsetPreviewToDesk(HWND hwndC, LPRECT prcNewPreview, LPRECT prcOldPreview, LPRECT out);
        BOOL _QueryForceSmallFont();
        void _SetPreviewScreenSize(int HRes, int VRes, int iOrgXRes, int iOrgYRes);
        void _CleanupRects(HWND hwndP);
        void _ConfirmPositions();
        void _DoAdvancedSettingsSheet();
        BOOL _HandleHScroll(HWND hwndSB, int iCode, int iPos);
        void _RedrawDeskPreviews();
        void _OnAdvancedClicked();

        BOOL _InitDisplaySettings(BOOL bExport);
        int  _EnumerateAllDisplayDevices(); //Enumerates and returns the number of devices.
        void _DestroyMultimonDevice(PMULTIMON_DEVICE pDevice);
        void _DestroyDisplaySettings();

        void _InitUI();
        void _UpdateUI(BOOL fAutoSetColorDepth = TRUE, int FocusToCtrlID = 0);
        LPTSTR _FormatMessageInvoke(LPCTSTR pcszFormat, va_list *argList);
        LPTSTR _FormatMessageWrap(LPCTSTR pcszFormat, ...);
        void _GetDisplayName(PMULTIMON_DEVICE pDevice, LPTSTR pszDisplay, DWORD cchSize);
        int  _SaveDisplaySettings(DWORD dwSet);
        BOOL _RebuildDisplaySettings(BOOL bComplete);
        void _ForwardToChildren(UINT message, WPARAM wParam, LPARAM lParam);

        static BOOL _CanSkipWarningBecauseKnownSafe(CDisplaySettings *rgpds[], ULONG numDevices);
        static BOOL _AnyChange(CDisplaySettings *rgpds[], ULONG numDevices);
        static BOOL _AnyColorChange(CDisplaySettings *rgpds[], ULONG numDevices);
        static BOOL _IsSingleToMultimonChange(CDisplaySettings *rgpds[],
                                              ULONG numDevices);

        static int _DisplaySaveSettings(CDisplaySettings *rgpds[],
                                        ULONG            numDevices,
                                        HWND             hDlg);

        static int _SaveSettings(CDisplaySettings *rgpds[],
                                 ULONG numDevices,
                                 HWND hDlg,
                                 DWORD dwSet);

        BOOL _AreExtraMonitorsDisabledOnPersonal();
        BOOL _InitMessage();
        void _vPreExecMode();
        void _vPostExecMode();
    public:
        CSettingsPage();
        virtual ~CSettingsPage(void);

        static BOOL RegisterPreviewWindowClass(WNDPROC pfnWndProc);
        // *** IUnknown methods ***
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // *** IMultiMonConfig methods ***
        STDMETHOD ( Initialize ) ( HWND hwndHost, WNDPROC pfnWndProc, DWORD dwReserved);
        STDMETHOD ( GetNumberOfMonitors ) (int * pCMon, DWORD dwReserved);
        STDMETHOD ( GetMonitorData) (int iMonitor, MonitorData * pmd, DWORD dwReserved);
        STDMETHOD ( Paint) (THIS_ int iMonitor, DWORD dwReserved);

        // *** IShellPropSheetExt ***
        virtual STDMETHODIMP AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam);
        virtual STDMETHODIMP ReplacePage(IN EXPPS uPageID, IN LPFNSVADDPROPSHEETPAGE pfnReplaceWith, IN LPARAM lParam);

        // *** IObjectWithSite ***
        virtual STDMETHODIMP SetSite(IUnknown *punkSite);

        // *** IPropertyBag ***
        virtual STDMETHODIMP Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog);
        virtual STDMETHODIMP Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar);

        // *** IBasePropPage ***
        virtual STDMETHODIMP GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog);
        virtual STDMETHODIMP OnApply(IN PROPPAGEONAPPLY oaAction);

        BOOL InitMultiMonitorDlg(HWND hDlg);
        PMULTIMON_DEVICE GetCurDevice(){return _pCurDevice;};

        int  GetNumberOfAttachedDisplays();
        void UpdateActiveDisplay(PMULTIMON_DEVICE pDevice, BOOL bRepaint = TRUE);
        BOOL HandleMonitorChange(HWND hwndP, BOOL bMainDlg, BOOL bRepaint = TRUE);
        void SetDirty(BOOL bDirty=TRUE);
        BOOL SetPrimary(PMULTIMON_DEVICE pDevice);
        BOOL SetMonAttached(PMULTIMON_DEVICE pDevice, BOOL bSetAttached,
                            BOOL bForce, HWND hwnd);

        HWND  GetCurDeviceHwnd() { return GetDlgItemP(_hwndDesk, (INT_PTR) _pCurDevice);};
        ULONG GetNumDevices()    { return _NumDevices;};
        BOOL  QueryNoAttach()    { return _bNoAttach;};
        BOOL  IsDirty()          { return _bDirty;};

        void GetMonitorPosition(PMULTIMON_DEVICE pDevice, HWND hwndP, PPOINT ptPos);

        static INT_PTR CALLBACK SettingsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
        LRESULT CALLBACK WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam);

        IThemeUIPages* _pThemeUI;
};

#if 0
    TraceMsg(TF_DUMP_CSETTINGS,"\t     cb          = %d",     _DisplayDevice.cb           );
    TraceMsg(TF_DUMP_CSETTINGS,"\t     DeviceName  = %s",     _pstrDisplayDevice   );
    TraceMsg(TF_DUMP_CSETTINGS,"\t     DeviceString= %s",     _DisplayDevice.DeviceString );
    TraceMsg(TF_DUMP_CSETTINGS,"\t     StateFlags  = %08lx",  _DisplayDevice.StateFlags   );
#endif

CSettingsPage::CSettingsPage() : _cRef(1), CObjectCLSID(&PPID_Settings)
{
    ASSERT(_pCurDevice == NULL);
    ASSERT(_pPrimaryDevice == NULL);
    ASSERT(_DeskScale == 0);
    ASSERT(_InSetInfo == 0);
    ASSERT(_NumDevices == 0);
    ASSERT(IsRectEmpty(&_rcDesk));
    ASSERT(_bNoAttach == FALSE);
    ASSERT(_bDirty == FALSE);

    _nInApply = 0;
};


CSettingsPage::~CSettingsPage()
{
};


void CSettingsPage::_DestroyMultimonDevice(PMULTIMON_DEVICE pDevice)
{
    ASSERT(pDevice->pds);
    pDevice->pds->Release();
    pDevice->pds = NULL;

    if(pDevice->hwndFlash)
    {
        DestroyWindow(pDevice->hwndFlash);
        pDevice->hwndFlash = NULL;
    }

    if (pDevice->hdc) {
        DeleteDC(pDevice->hdc);
        pDevice->hdc = NULL;
    }

    if (pDevice->ResolutionList) {
        LocalFree(pDevice->ResolutionList);
        pDevice->ResolutionList = NULL;
    }

    if (pDevice->ColorList) {
        LocalFree(pDevice->ColorList);
        pDevice->ColorList = NULL;
    }
}

void CSettingsPage::_DestroyDisplaySettings()
{
    ULONG iDevice;
    HWND    hwndC;
    ASSERT(_NumDevices);
    TraceMsg(TF_GENERAL, "DestroyDisplaySettings: %d devices", _NumDevices);

    // We are about to destroy the _Devices below. Pointerts to these devices are used as the
    // CtrlIDs for the monitor windows. So, we need destroy the monitor windows first;
    // otherwise, if the monitor windows are destroyed later, they try to use these invalid
    // pDevice in FlashText. (pDevice->hwndFlash will fault).
    hwndC = GetWindow(_hwndDesk, GW_CHILD);
    while (hwndC)
    {
        RemoveTrackingToolTip(hwndC);
        RemovePopupToolTip(hwndC);
        DestroyWindow(hwndC);
        hwndC = GetWindow(_hwndDesk, GW_CHILD);
    }

    // Now, we can destroy the _Devices safely.
    for (iDevice = 0; iDevice < _NumDevices; iDevice++) {
        _DestroyMultimonDevice(_Devices + iDevice);
        // Note: pds is destroyed and set to zero already in the above call.
        //delete _Devices[iDevice].pds;
        //_Devices[iDevice].pds = 0;
    }

    if (_himl) {
        ImageList_Destroy(_himl);
        _himl = NULL;
    }

    DestroyWindow(ghwndToolTipTracking);
    DestroyWindow(ghwndToolTipPopup);

    ghwndToolTipTracking = NULL;
    ghwndToolTipPopup = NULL;

    TraceMsg(TF_GENERAL, "DestroyDisplaySettings: Finished destroying all devices");
}

//
// deterines if the applet is in detect mode.
//

//
// Called to put up initial messages that need to appear above the dialog
// box
//

BOOL CSettingsPage::_InitMessage()
{
    {
        //
        // _bBadDriver will be set when we fail to build the list of modes,
        // or something else failed during initialization.
        //
        // In almost every case, we should already know about this situation
        // based on our boot code.
        // However, if this is a new situation, just report a "bad driver"
        //

        DWORD dwExecMode;
        if (_pThemeUI && (SUCCEEDED(_pThemeUI->GetExecMode(&dwExecMode))))
        {
            if (_bBadDriver)
            {
                ASSERT(dwExecMode == EM_INVALID_MODE);

                _pThemeUI->SetExecMode(EM_INVALID_MODE);
                dwExecMode = EM_INVALID_MODE;
                _dwInvalidMode = EIS_EXEC_INVALID_DISPLAY_DRIVER;
            }


            if (dwExecMode == EM_INVALID_MODE)
            {
                DWORD Mesg;

                switch(_dwInvalidMode) {

                case EIS_EXEC_INVALID_NEW_DRIVER:
                    Mesg = MSG_INVALID_NEW_DRIVER;
                    break;
                case EIS_EXEC_INVALID_DEFAULT_DISPLAY_MODE:
                    Mesg = MSG_INVALID_DEFAULT_DISPLAY_MODE;
                    break;
                case EIS_EXEC_INVALID_DISPLAY_DRIVER:
                    Mesg = MSG_INVALID_DISPLAY_DRIVER;
                    break;
                case EIS_EXEC_INVALID_OLD_DISPLAY_DRIVER:
                    Mesg = MSG_INVALID_OLD_DISPLAY_DRIVER;
                    break;
                case EIS_EXEC_INVALID_16COLOR_DISPLAY_MODE:
                    Mesg = MSG_INVALID_16COLOR_DISPLAY_MODE;
                    break;
                case EIS_EXEC_INVALID_DISPLAY_MODE:
                    Mesg = MSG_INVALID_DISPLAY_MODE;
                    {
                        //
                        // If we are in safe mode, then we will get to here when
                        // we initially log in.  We are in forced VGA mode, so there
                        // is no real error here.  Emulate a click on the OK button
                        // and everybody is happy.
                        //
                        HKEY hSafe;

                        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                         REGSTR_VAL_SAFEBOOT,
                                         0,
                                         KEY_READ,
                                         &hSafe) == ERROR_SUCCESS) {

                            //
                            // If we ever care about the actual safe mode, the value
                            // is nameed "OptionValue"
                            //
                            RegCloseKey(hSafe);
                            PropSheet_PressButton(GetParent(_hDlg), PSBTN_OK);
                            return TRUE;
                        }
                    }
                    break;
                case EIS_EXEC_INVALID_CONFIGURATION:
                default:
                    Mesg = MSG_INVALID_CONFIGURATION;
                    break;
                }

                FmtMessageBox(_hDlg,
                              MB_ICONEXCLAMATION,
                              MSG_CONFIGURATION_PROBLEM,
                              Mesg);

                //
                // For a bad display driver or old display driver, let's send the
                // user straight to the installation dialog.
                //

                if ((_dwInvalidMode == EIS_EXEC_INVALID_OLD_DISPLAY_DRIVER) ||
                    (_dwInvalidMode == EIS_EXEC_INVALID_DISPLAY_DRIVER))
                {
                    ASSERT(FALSE);
                }
            }
        }
    }

    return TRUE;
}

VOID CSettingsPage::_vPreExecMode()
{

    HKEY hkey;
//    DWORD data;

    //
    // This function sets up the execution mode of the applet.
    // There are four vlid modes.
    //
    // EXEC_NORMAL - When the apple is launched from the control panel
    //
    // EXEC_INVALID_MODE is exactly the same as for NORMAL except we will
    //                   not mark the current mode as tested so the user has
    //                   to at least test a mode
    //
    // EXEC_DETECT - When the applet is launched normally, but a detect was
    //               done on the previous boot (the key in the registry is
    //               set)
    //
    // EXEC_SETUP  - When we launch the applet in setup mode from setup (Both
    //               the registry key is set and the setup flag is passed in).
    //

    //
    // These two keys should only be checked \ deleted if the machine has been
    // rebooted and the detect \ new display has actually happened.
    // So we will look for the RebootNecessary key (a volatile key) and if
    // it is not present, then we can delete the key.  Otherwise, the reboot
    // has not happened, and we keep the key
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     SZ_REBOOT_NECESSARY,
                     0,
                     KEY_READ | KEY_WRITE,
                     &hkey) != ERROR_SUCCESS) {

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         SZ_DETECT_DISPLAY,
                         0,
                         KEY_READ | KEY_WRITE,
                         &hkey) == ERROR_SUCCESS) {

            //
            // NOTE: This key is also set when EXEC_SETUP is being run.
            //

            DWORD dwExecMode;
            if (_pThemeUI && (SUCCEEDED(_pThemeUI->GetExecMode(&dwExecMode))))
            {
                if (dwExecMode == EM_NORMAL) {

                    _pThemeUI->SetExecMode(EM_DETECT);

                } else {

                    //
                    // If we are in setup mode, we also check the extra values
                    // under DetectDisplay that control the unattended installation.
                    //

                    ASSERT(dwExecMode == EM_SETUP);

                }
            }

            RegCloseKey(hkey);
        }

        //
        // Check for a new driver being installed
        //

        DWORD dwExecMode;
        if (_pThemeUI && (SUCCEEDED(_pThemeUI->GetExecMode(&dwExecMode))))
        {
            if ( (dwExecMode == EM_NORMAL) &&
                 (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               SZ_NEW_DISPLAY,
                               0,
                               KEY_READ | KEY_WRITE,
                               &hkey) == ERROR_SUCCESS) ) {

                _pThemeUI->SetExecMode(EM_INVALID_MODE);
                _dwInvalidMode = EIS_EXEC_INVALID_NEW_DRIVER;

                RegCloseKey(hkey);
            }
        }

        RegDeleteKey(HKEY_LOCAL_MACHINE,
                     SZ_DETECT_DISPLAY);

        RegDeleteKey(HKEY_LOCAL_MACHINE,
                     SZ_NEW_DISPLAY);
    }
    {
        LPTSTR psz = NULL;
        LPTSTR pszInv = NULL;

        DWORD dwExecMode;
        if (_pThemeUI && (SUCCEEDED(_pThemeUI->GetExecMode(&dwExecMode))))
        {
            switch(dwExecMode) {

                case EM_NORMAL:
                    psz = TEXT("Normal Execution mode");
                    break;
                case EM_DETECT:
                    psz = TEXT("Detection Execution mode");
                    break;
                case EM_SETUP:
                    psz = TEXT("Setup Execution mode");
                    break;
                case EM_INVALID_MODE:
                    psz = TEXT("Invalid Mode Execution mode");

                    switch(_dwInvalidMode) {

                        case EIS_EXEC_INVALID_NEW_DRIVER:
                            pszInv = TEXT("Invalid new driver");
                            break;
                        default:
                            pszInv = TEXT("*** Invalid *** Invalid mode");
                            break;
                    }
                    break;
                default:
                    psz = TEXT("*** Invalid *** Execution mode");
                    break;
            }

            if (dwExecMode == EM_INVALID_MODE)
            {
                TraceMsg(TF_FUNC, "\t\t sub invalid mode : %ws", pszInv);
            }
        }
        TraceMsg(TF_FUNC, "\n\n", psz);
    }
}


VOID CSettingsPage::_vPostExecMode() {

    HKEY hkey;
    DWORD cb;
    DWORD data;

    //
    // Check for various invalid configurations
    //

    DWORD dwExecMode;
    if (_pThemeUI && (SUCCEEDED(_pThemeUI->GetExecMode(&dwExecMode))))
    {
        if ( (dwExecMode == EM_NORMAL) &&
             (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           SZ_INVALID_DISPLAY,
                           0,
                           KEY_READ | KEY_WRITE,
                           &hkey) == ERROR_SUCCESS) ) {

            _pThemeUI->SetExecMode(EM_INVALID_MODE);

            //
            // Check for these fields in increasing order of "badness" or
            // "detail" so that the *worst* error is the one remaining in the
            // _dwInvalidMode  variable once all the checks are done.
            //

            cb = 4;
            if (RegQueryValueEx(hkey,
                                TEXT("DefaultMode"),
                                NULL,
                                NULL,
                                (LPBYTE)(&data),
                                &cb) == ERROR_SUCCESS)
            {
                _dwInvalidMode = EIS_EXEC_INVALID_DEFAULT_DISPLAY_MODE;
            }

            cb = 4;
            if (RegQueryValueEx(hkey,
                                TEXT("BadMode"),
                                NULL,
                                NULL,
                                (LPBYTE)(&data),
                                &cb) == ERROR_SUCCESS)
            {
                _dwInvalidMode = EIS_EXEC_INVALID_DISPLAY_MODE;
            }

            cb = 4;
            if (RegQueryValueEx(hkey,
                                TEXT("16ColorMode"),
                                NULL,
                                NULL,
                                (LPBYTE)(&data),
                                &cb) == ERROR_SUCCESS)
            {
                _dwInvalidMode = EIS_EXEC_INVALID_16COLOR_DISPLAY_MODE;
            }


            cb = 4;
            if (RegQueryValueEx(hkey,
                                TEXT("InvalidConfiguration"),
                                NULL,
                                NULL,
                                (LPBYTE)(&data),
                                &cb) == ERROR_SUCCESS)
            {
                _dwInvalidMode = EIS_EXEC_INVALID_CONFIGURATION;
            }

            cb = 4;
            if (RegQueryValueEx(hkey,
                                TEXT("MissingDisplayDriver"),
                                NULL,
                                NULL,
                                (LPBYTE)(&data),
                                &cb) == ERROR_SUCCESS)
            {
                _dwInvalidMode = EIS_EXEC_INVALID_DISPLAY_DRIVER;
            }

            //
            // This last case will be set in addition to the previous one in the
            // case where the driver was an old driver linking to winsvr.dll
            // and we can not load it.
            //

            cb = 4;
            if (RegQueryValueEx(hkey,
                                TEXT("OldDisplayDriver"),
                                NULL,
                                NULL,
                                (LPBYTE)(&data),
                                &cb) == ERROR_SUCCESS)
            {
                _dwInvalidMode = EIS_EXEC_INVALID_OLD_DISPLAY_DRIVER;
            }

            RegCloseKey(hkey);

        }
    }

    //
    // Delete all of these bad configuration keys since we only want the
    // user to see the message once.
    //

    RegDeleteKey(HKEY_LOCAL_MACHINE,
                 SZ_INVALID_DISPLAY);

{
    LPTSTR psz = NULL;
    LPTSTR pszInv = NULL;

    DWORD dwExecMode;
    if (_pThemeUI && (SUCCEEDED(_pThemeUI->GetExecMode(&dwExecMode))))
    {
        if (dwExecMode == EM_INVALID_MODE)
        {
            switch (_dwInvalidMode)
            {
            case EIS_EXEC_INVALID_DEFAULT_DISPLAY_MODE:
                pszInv = TEXT("Default mode being used");
                break;
            case EIS_EXEC_INVALID_DISPLAY_DRIVER:
                pszInv = TEXT("Invalid Display Driver");
                break;
            case EIS_EXEC_INVALID_OLD_DISPLAY_DRIVER:
                pszInv = TEXT("Old Display Driver");
                break;
            case EIS_EXEC_INVALID_16COLOR_DISPLAY_MODE:
                pszInv = TEXT("16 color mode not supported");
                break;
            case EIS_EXEC_INVALID_DISPLAY_MODE:
                pszInv = TEXT("Invalid display mode");
                break;
            case EIS_EXEC_INVALID_CONFIGURATION:
                pszInv = TEXT("Invalid configuration");
                break;
            default:
                psz = TEXT("*** Invalid *** Invalid mode");
                break;
            }

            TraceMsg(TF_FUNC, "\t\t sub invlid mode : %ws", pszInv);
            TraceMsg(TF_FUNC, "\n\n", psz);
        }
    }
}
}


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void CSettingsPage::_DeskToPreview(LPRECT in, LPRECT out)
{
    out->left   = _DeskOff.x + MulDiv(in->left   - _rcDesk.left,_DeskScale,1000);
    out->top    = _DeskOff.y + MulDiv(in->top    - _rcDesk.top, _DeskScale,1000);
    out->right  = _DeskOff.x + MulDiv(in->right  - _rcDesk.left,_DeskScale,1000);
    out->bottom = _DeskOff.y + MulDiv(in->bottom - _rcDesk.top, _DeskScale,1000);
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void CSettingsPage::_OffsetPreviewToDesk(HWND hwndC, LPRECT prcNewPreview, LPRECT prcOldPreview, LPRECT out)
{
    int x = 0, y = 0;
    int dtLeft, dtRight, dtTop, dtBottom;
    int nTotal;
    HWND hwndT;
    RECT rcC, rcT, rcPosT;
    BOOL bx = FALSE, by = FALSE;
    PMULTIMON_DEVICE pDeviceT;

    dtLeft = prcNewPreview->left - prcOldPreview->left;
    dtRight = prcNewPreview->right - prcOldPreview->right;
    dtTop = prcNewPreview->top - prcOldPreview->top;
    dtBottom = prcNewPreview->bottom - prcOldPreview->bottom;

    nTotal = abs(dtLeft) + abs(dtRight) + abs(dtTop) + abs(dtBottom);

    if (nTotal == 0) {
        
        return;
    
    } else if (nTotal > 2) {
    
        //
        // walk all other windows and snap our window to them
        //

        GetWindowRect(hwndC, &rcC);

        for (hwndT = GetWindow(hwndC,  GW_HWNDFIRST); 
             (hwndT && (!bx || !by));
             hwndT = GetWindow(hwndT, GW_HWNDNEXT))
        {
            if (hwndT == hwndC)
                continue;

            GetWindowRect(hwndT, &rcT);
            pDeviceT = GetDlgCtrlDevice(hwndT);

            if (pDeviceT) {
            
                pDeviceT->pds->GetCurPosition(&rcPosT);
    
                if (!bx) {
    
                    bx = TRUE;
    
                    if (rcC.left == rcT.left) {
    
                        x = rcPosT.left - out->left;
                    
                    } else if (rcC.left == rcT.right) {
    
                        x = rcPosT.right - out->left;
                    
                    } else if (rcC.right == rcT.left) {
    
                        x = rcPosT.left - out->right;
        
                    } else if (rcC.right == rcT.right) {
    
                        x = rcPosT.right - out->right;
    
                    } else {
    
                        bx = FALSE;
                    }
                }
    
                if (!by) {
                
                    by = TRUE;
    
                    if (rcC.top == rcT.top) {
    
                        y = rcPosT.top - out->top;
    
                    } else if (rcC.top == rcT.bottom) {
    
                        y = rcPosT.bottom - out->top;
    
                    } else if (rcC.bottom == rcT.top) {
    
                        y = rcPosT.top - out->bottom;
    
                    } else if (rcC.bottom == rcT.bottom) {
    
                        y = rcPosT.bottom - out->bottom;
                    
                    } else {
    
                        by = FALSE; 
                    }
                }
            }
        }

        if (!bx) {
            x = _rcDesk.left + MulDiv(prcNewPreview->left - _DeskOff.x,1000,_DeskScale);
            x = x - out->left;
        }

        if (!by) {
            y = _rcDesk.top  + MulDiv(prcNewPreview->top  - _DeskOff.y,1000,_DeskScale);
            y = y - out->top;
        }
    
    } else {
    
        x = dtLeft * 8;
        y = dtTop * 8;
    }

    OffsetRect(out, x, y);
}


//-----------------------------------------------------------------------------
int CSettingsPage::_SaveSettings(CDisplaySettings *rgpds[], ULONG numDevices, HWND hDlg, DWORD dwSet)
{
    int     iRet = 0;
    ULONG   iDevice;

    for (iDevice = 0; iDevice < numDevices; iDevice++)
    {
        // PERF - we should only save the settings for devices that have
        // changed.
        if (rgpds[iDevice])
        {
            int iResult = rgpds[iDevice]->SaveSettings(dwSet);
            if (iResult != DISP_CHANGE_SUCCESSFUL)
            {
                if (iResult == DISP_CHANGE_RESTART)
                {
                    iRet = iResult;
                    continue;
                }
                else
                {
                    FmtMessageBox(hDlg,
                                  MB_ICONEXCLAMATION,
                                  IDS_CHANGE_SETTINGS,
                                  IDS_CHANGESETTINGS_FAILED);

                    ASSERT(iResult < 0);
                    return iResult;
                }
            }
        }
    }

    return iRet;
}



INT_PTR CALLBACK KeepNewDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    UINT_PTR idTimer = 0;
    HICON hicon;
    TCHAR szRevert[100];
    TCHAR szString[120];

    switch(message)
    {
        case WM_INITDIALOG:

            hicon = LoadIcon(NULL, IDI_QUESTION);
            if (hicon)
                SendDlgItemMessage(hDlg, IDC_BIGICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hicon);

            LoadString(HINST_THISDLL, IDS_REVERTBACK, szRevert, ARRAYSIZE(szRevert));
            wnsprintf(szString, ARRAYSIZE(szString), szRevert, lParam);
            SetDlgItemText(hDlg, IDC_COUNTDOWN, szString);
            idTimer = SetTimer(hDlg, lParam, 1000, NULL);

            SetFocus(GetDlgItem(hDlg, IDNO));

            // FALSE so that the focus set above is kept
            return FALSE;

        case WM_DESTROY:

            // raymondc - this code is dead; idTimer is initialized to zero
            // fortunately, timers are automatically killed at window destruction
            // if (idTimer)
            //    KillTimer(hDlg, idTimer);
            hicon = (HICON)SendDlgItemMessage(hDlg, IDC_BIGICON, STM_GETIMAGE, IMAGE_ICON, 0);
            if (hicon)
                DestroyIcon(hicon);
            break;

        case WM_TIMER:

            KillTimer(hDlg, wParam);
            LoadString(HINST_THISDLL, IDS_REVERTBACK, szRevert, ARRAYSIZE(szRevert));
            wnsprintf(szString, ARRAYSIZE(szString), szRevert, wParam - 1);
            SetDlgItemText(hDlg, IDC_COUNTDOWN, szString);
            idTimer = SetTimer(hDlg, wParam - 1, 1000, NULL);

            if (wParam == 1)
                EndDialog(hDlg, IDNO);

            break;

        case WM_COMMAND:

            EndDialog(hDlg, wParam);
            break;

        default:

            return FALSE;
    }
    return TRUE;
}

BOOL CSettingsPage::_RebuildDisplaySettings(BOOL bComplete)
{
    BOOL result = TRUE;
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    for (ULONG iDevice = 0; iDevice < _NumDevices; iDevice++)
    {
        _Devices[iDevice].pds->Release();
        _Devices[iDevice].pds = new CDisplaySettings();
    }
    RedrawWindow(_hDlg, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);

    SetCursor(hcur);
    return result;
}

int CSettingsPage::GetNumberOfAttachedDisplays()
{
    int nDisplays = 0;

    for (ULONG iDevice = 0; iDevice < _NumDevices; iDevice++)
    {
        if (_Devices[iDevice].pds->IsAttached())
            nDisplays++;
    }
    return nDisplays;
}

BOOL CSettingsPage::_AnyColorChange(CDisplaySettings *rgpds[], ULONG numDevices)
{
    for (ULONG iDevice = 0; iDevice < numDevices; iDevice++)
    {
        if (rgpds[iDevice]->IsAttached() && rgpds[iDevice]->IsColorChanged())
            return TRUE;
    }
    return FALSE;
}

/* static */ BOOL CSettingsPage::_IsSingleToMultimonChange(CDisplaySettings *rgpds[],
                                                       ULONG numDevices)
{
    int nAttached = 0;
    int nOrgAttached = 0;

    for (ULONG iDevice = 0;
         (iDevice < numDevices) && (nOrgAttached <= 1);
         iDevice++)
    {
        if (rgpds[iDevice]->IsOrgAttached())
            nOrgAttached++;
        if (rgpds[iDevice]->IsAttached())
            nAttached++;
    }

    return ((nOrgAttached <= 1) && (nAttached > 1));
}

BOOL CSettingsPage::_AnyChange(CDisplaySettings *rgpds[], ULONG numDevices)
{
   for (ULONG iDevice = 0; iDevice < numDevices; iDevice++)
   {
       if (rgpds[iDevice]->IsAttached() && rgpds[iDevice]->bIsModeChanged())
       {
           return TRUE;
       }
   }

   return FALSE;
}

BOOL CSettingsPage::_CanSkipWarningBecauseKnownSafe(CDisplaySettings *rgpds[], ULONG numDevices)
{
    BOOL fSafe = TRUE;

    for (ULONG iDevice = 0; iDevice < numDevices; iDevice++)
    {
        if (rgpds[iDevice] && !rgpds[iDevice]->IsKnownSafe())
        {
            fSafe = FALSE;
            break;
        }
    }

    return fSafe;
}

BOOL CSettingsPage::_QueryForceSmallFont()
{
    for (ULONG iDevice = 0; iDevice < _NumDevices; iDevice++)
    {
        if ((_Devices[iDevice].pds->IsAttached()) &&
            (!_Devices[iDevice].pds->IsSmallFontNecessary()))
        {
            return FALSE;
        }
    }
    return TRUE;
}

LPTSTR  CSettingsPage::_FormatMessageInvoke(LPCTSTR pcszFormat, va_list *argList)

{
    LPTSTR  pszOutput;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                      pcszFormat,
                      0, 0,
                      reinterpret_cast<LPTSTR>(&pszOutput), 0,
                      argList) == 0)
    {
        pszOutput = NULL;
    }
    return(pszOutput);
}

LPTSTR  CSettingsPage::_FormatMessageWrap(LPCTSTR pcszFormat, ...)

{
    LPTSTR      pszOutput;
    va_list     argList;

    va_start(argList, pcszFormat);
    pszOutput = _FormatMessageInvoke(pcszFormat, &argList);
    va_end(argList);
    return(pszOutput);
}

void CSettingsPage::_GetDisplayName(PMULTIMON_DEVICE pDevice, LPTSTR pszDisplay, DWORD cchSize)
{
    LPTSTR  pszFormattedOutput;
    TCHAR   szMonitor[140];
    TCHAR   szDisplayFormat[40];

    LoadString(HINST_THISDLL, IDS_DISPLAYFORMAT, szDisplayFormat, ARRAYSIZE(szDisplayFormat));

    pDevice->pds->GetMonitorName(szMonitor, ARRAYSIZE(szMonitor));

    pszFormattedOutput = _FormatMessageWrap(szDisplayFormat,
                                            pDevice->DisplayIndex,
                                            szMonitor,
                                            pDevice->DisplayDevice.DeviceString);
    lstrcpyn(pszDisplay, pszFormattedOutput, cchSize);
    LocalFree(pszFormattedOutput);
}


void CSettingsPage::_OnAdvancedClicked()
{
    BOOL bCanBePruned, bIsPruningReadOnly;
    BOOL bBeforeIsPruningOn, bAfterIsPruningOn;

    if (_pCurDevice && _pCurDevice->pds)
    {
        _pCurDevice->pds->GetPruningMode(&bCanBePruned,
                                         &bIsPruningReadOnly,
                                         &bBeforeIsPruningOn);

        _DoAdvancedSettingsSheet();

        if (bCanBePruned && !bIsPruningReadOnly)
        {
            _pCurDevice->pds->GetPruningMode(&bCanBePruned,
                                             &bIsPruningReadOnly,
                                             &bAfterIsPruningOn);
            if (bBeforeIsPruningOn != bAfterIsPruningOn)
            {
                // pruning mode has changed - update the UI
                _InitUI();
                _UpdateUI();
            }
        }
    }
}


//-----------------------------------------------------------------------------
void CSettingsPage::_DoAdvancedSettingsSheet()
{
    if (_pCurDevice && _pCurDevice->pds)
    {
        PROPSHEETHEADER psh;
        HPROPSHEETPAGE rPages[MAX_PAGES];
        PROPSHEETPAGE psp;
        HPSXA hpsxa = NULL;
        HPSXA hpsxaOEM = NULL;
        HPSXA hpsxaAdapter = NULL;
        HPSXA* phpsxaChildren = NULL;
        INT_PTR iResult = 0;
        TCHAR szDisplay[140 + 256 + 20];  //Monitor-name and Adapter Properties.
        TCHAR szMonitor[140];
        TCHAR szDisplayFormat[35];
        GENERAL_ADVDLG_INITPARAMS generalInitParams = {0};

        // Create the "Monitor-name and Adapter-name properties" string to be used as the title for these
        // property sheets.
        LoadString(HINST_THISDLL, IDS_ADVDIALOGTITLE, szDisplayFormat, ARRAYSIZE(szDisplayFormat));

        _pCurDevice->pds->GetMonitorName(szMonitor, ARRAYSIZE(szMonitor));

        wnsprintf(szDisplay, ARRAYSIZE(szDisplay), szDisplayFormat, szMonitor, _pCurDevice->DisplayDevice.DeviceString);

        generalInitParams.fFoceSmallFont = _QueryForceSmallFont();
        generalInitParams.punkSite = _punkSite;         // They don't get a ref because their property dialog appears and goes away before this function returns.

        psh.dwSize = sizeof(psh);
        psh.dwFlags = PSH_PROPTITLE;
        psh.hwndParent = GetParent(_hDlg);
        psh.hInstance = HINST_THISDLL;
        psh.pszCaption = szDisplay;
        psh.nPages = 0;
        psh.nStartPage = 0;
        psh.phpage = rPages;

        psp.dwSize = sizeof(psp);
        psp.dwFlags = PSP_DEFAULT;
        psp.hInstance = HINST_THISDLL;

        psp.pfnDlgProc = GeneralPageProc;
        psp.pszTemplate = MAKEINTRESOURCE(DLG_GENERAL);
        psp.lParam = (LPARAM)&generalInitParams;

        rPages[psh.nPages] = CreatePropertySheetPage(&psp);
        if (rPages[psh.nPages])
            psh.nPages++;

        IDataObject * pdo = NULL;
        _pCurDevice->pds->QueryInterface(IID_IDataObject, (LPVOID *) &pdo);

        CRegistrySettings RegSettings(_pCurDevice->DisplayDevice.DeviceKey);
        HKEY hkDriver = RegSettings.OpenDrvRegKey();

        if (hkDriver != INVALID_HANDLE_VALUE) 
        {
            CheckForDuplicateAppletExtensions(hkDriver);
        }

        //
        // load the generic (non hardware specific) extensions
        //
    
        if( ( hpsxa = SHCreatePropSheetExtArrayEx( HKEY_LOCAL_MACHINE, REGSTR_PATH_CONTROLSFOLDER TEXT("\\Device"), 8, pdo) ) != NULL )
        {
            SHAddFromPropSheetExtArray( hpsxa, _AddDisplayPropSheetPage, (LPARAM)&psh );
        }

        //
        // Load the hardware-specific extensions
        //
        // NOTE it is very important to load the OEM extensions *after* the
        // generic extensions some HW extensions expect to be the last tabs
        // in the propsheet (right before the settings tab)
        //
        // FEATURE - we may need a way to NOT load the vendor extensions in case
        // they break our applet.
        //

        if( ( hpsxaOEM = SHCreatePropSheetExtArrayEx( HKEY_LOCAL_MACHINE, REGSTR_PATH_CONTROLSFOLDER TEXT("\\Display"), 8, pdo) ) != NULL )
        {
            SHAddFromPropSheetExtArray( hpsxaOEM, _AddDisplayPropSheetPage, (LPARAM)&psh );
        }

        //
        // Load the applet extensions for the adapter
        //

        if (hkDriver != INVALID_HANDLE_VALUE) 
        {

            if( ( hpsxaAdapter = SHCreatePropSheetExtArrayEx( hkDriver, TEXT("Display"), 8, pdo) ) != NULL )
            {
                SHAddFromPropSheetExtArray( hpsxaAdapter, _AddDisplayPropSheetPage, (LPARAM)&psh );
            }

            RegCloseKey(hkDriver);
        }

        //
        // Load the applet extensions for the adapter child devices (e.g. monitors)
        //
    
        DEVINST devInstAdapter, devInstMonitor;
        DWORD cChildDevices = 0, nChild, index;
        HDEVINFO hDevMonitors = INVALID_HANDLE_VALUE;
        SP_DEVINFO_DATA DevInfoData;
        HKEY hkMonitor;
        BOOL bMonitors = FALSE;
        LPTSTR szAdapterInstanceID = RegSettings.GetDeviceInstanceId();
    
        if (szAdapterInstanceID != NULL) 
        {
            if (CM_Locate_DevNodeW(&devInstAdapter, szAdapterInstanceID, 0) == CR_SUCCESS)
            {
                //
                // Get the number of child devices
                //
    
                cChildDevices = 0;
                if (CM_Get_Child(&devInstMonitor, devInstAdapter, 0) == CR_SUCCESS) 
                {
                    do 
                    {
                        cChildDevices++;
                    } 
                    while (CM_Get_Sibling(&devInstMonitor, devInstMonitor, 0) == CR_SUCCESS);
                }
    
                //
                // Allocate the memory
                //
    
                if (cChildDevices > 0) 
                {
                    phpsxaChildren = (HPSXA*)LocalAlloc(LPTR, cChildDevices * sizeof(HPSXA));
    
                    hDevMonitors = SetupDiGetClassDevs((LPGUID)&GUID_DEVCLASS_MONITOR,
                                                       NULL,
                                                       NULL,
                                                       0);
                }
    
                //
                // Load the applet extensions
                //
    
                if ((phpsxaChildren != NULL) &&
                    (hDevMonitors != INVALID_HANDLE_VALUE))
                {
                    nChild = 0;
                    if (CM_Get_Child(&devInstMonitor, devInstAdapter, 0) == CR_SUCCESS) 
                    {
                        do 
                        {
                            DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
                            index = 0;
                            while (SetupDiEnumDeviceInfo(hDevMonitors, 
                                                         index, 
                                                         &DevInfoData)) {
    
                                if (DevInfoData.DevInst == devInstMonitor) {
    
                                    hkMonitor = SetupDiOpenDevRegKey(hDevMonitors,
                                                                     &DevInfoData,
                                                                     DICS_FLAG_GLOBAL,
                                                                     0,
                                                                     DIREG_DRV ,
                                                                     KEY_ALL_ACCESS);
    
                                    if (hkMonitor != INVALID_HANDLE_VALUE) 
                                    {
                                        if ((phpsxaChildren[nChild] = SHCreatePropSheetExtArrayEx(hkMonitor, 
                                                                                                  TEXT("Display"), 
                                                                                                  8, 
                                                                                                  pdo)) != NULL)
                                        {
                                            bMonitors = TRUE;
                                            SHAddFromPropSheetExtArray(phpsxaChildren[nChild], 
                                                                       _AddDisplayPropSheetPage, 
                                                                       (LPARAM)&psh);
                                        }
    
                                        RegCloseKey(hkMonitor);
                                    }
    
                                    break;
                                }
    
                                DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
                                index++;
                            }
    
                            nChild++;
                        } 
                        while ((nChild < cChildDevices) &&
                               (CM_Get_Sibling(&devInstMonitor, devInstMonitor, 0) == CR_SUCCESS));
                    }
                }
            }
        }
    
        //
        // add a fake settings page to fool OEM extensions (must be last)
        //
        if (hpsxa || hpsxaOEM || hpsxaAdapter || bMonitors)
        {
            AddFakeSettingsPage(_pThemeUI, &psh);
        }

        if (psh.nPages)
        {
            iResult = PropertySheet(&psh);
        }

        _GetDisplayName(_pCurDevice, szDisplay, ARRAYSIZE(szDisplay));

        if (_NumDevices == 1)
        {
            //Set the name of the primary in the static text
            //strip the first token off (this is the number we dont want it)
            TCHAR *pch;
            for (pch=szDisplay; *pch && *pch != TEXT(' '); pch++);
            for (;*pch && *pch == TEXT(' '); pch++);
            SetDlgItemText(_hDlg, IDC_DISPLAYTEXT, pch);
        }
        else
        {
            ComboBox_DeleteString(_hwndList, _pCurDevice->ComboBoxItem);
            ComboBox_InsertString(_hwndList, _pCurDevice->ComboBoxItem, szDisplay);
            ComboBox_SetItemData(_hwndList, _pCurDevice->ComboBoxItem, (DWORD_PTR)_pCurDevice);
            ComboBox_SetCurSel(_hwndList, _pCurDevice->ComboBoxItem);
        }

        if( hpsxa )
            SHDestroyPropSheetExtArray( hpsxa );
        
        if( hpsxaOEM )
            SHDestroyPropSheetExtArray( hpsxaOEM );
        
        if( hpsxaAdapter )
            SHDestroyPropSheetExtArray( hpsxaAdapter );
        
        if (phpsxaChildren != NULL)
        {
            for (nChild = 0; nChild < cChildDevices; nChild++) {
                if (phpsxaChildren[nChild] != NULL) 
                {
                    SHDestroyPropSheetExtArray(phpsxaChildren[nChild]);
                }
            }
            LocalFree(phpsxaChildren);
        }

        if (hDevMonitors != INVALID_HANDLE_VALUE)
        {
            SetupDiDestroyDeviceInfoList(hDevMonitors);
        }
    
        if (pdo)
            pdo->Release();

        if ((iResult == ID_PSRESTARTWINDOWS) || (iResult == ID_PSREBOOTSYSTEM))
        {
            PropSheet_CancelToClose(GetParent(_hDlg));

            if (iResult == ID_PSREBOOTSYSTEM)
                PropSheet_RebootSystem(ghwndPropSheet);
            else
                PropSheet_RestartWindows(ghwndPropSheet);
        }

        //
        // APPCOMPAT
        // Reset the dirty flag based on what the extensions did.
        //

        //
        // Reset the controls in case someone changed the selected mode.
        //

        UpdateActiveDisplay(NULL);
    }
}

//-----------------------------------------------------------------------------
void CSettingsPage::UpdateActiveDisplay(PMULTIMON_DEVICE pDevice, BOOL bRepaint /*=TRUE*/)
{
    if (_pCurDevice && _pCurDevice->pds)
    {
        HWND hwndC;

        _InSetInfo++;

        if (pDevice == NULL)
            pDevice = (PMULTIMON_DEVICE)ComboBox_GetItemData(_hwndList, ComboBox_GetCurSel(_hwndList));
        else
            ComboBox_SetCurSel(_hwndList, pDevice->ComboBoxItem);

        if (pDevice && pDevice != (PMULTIMON_DEVICE)CB_ERR)
        {
            hwndC = GetCurDeviceHwnd();

            // The Current Device has changed, so, force recreating the bitmap the next time
            // we paint the monitor on the preview window.
            _pCurDevice->w = pDevice->w = 0;

            _pCurDevice = pDevice;

            if (hwndC)
                RedrawWindow(hwndC, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);

            hwndC = GetCurDeviceHwnd();
            if (hwndC)
                RedrawWindow(hwndC, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);

            if(_NumDevices > 1)
            {
                // Update the two check box windows
                CheckDlgButton(_hDlg, IDC_DISPLAYPRIME, _pCurDevice->pds->IsPrimary());
                EnableWindow(GetDlgItem(_hDlg, IDC_DISPLAYPRIME),
                         _pCurDevice->pds->IsAttached() &&
                         !_pCurDevice->pds->IsRemovable() &&
                         !_pCurDevice->pds->IsPrimary());

                CheckDlgButton(_hDlg, IDC_DISPLAYUSEME, _pCurDevice->pds->IsAttached());
                EnableWindow(GetDlgItem(_hDlg, IDC_DISPLAYUSEME),
                         !_bNoAttach && !_pCurDevice->pds->IsPrimary());
            }

            // Reset the values for the list boxes, and then repaint it
            if(bRepaint)
            {
                _InitUI();
                _UpdateUI(FALSE /*fAutoSetColorDepth*/);
            }
        }
        else
        {
            // No display device !
            TraceMsg(TF_WARNING, "**** UpdateActiveDisplay: No display device!!!!");
            ASSERT(FALSE);
        }

        _InSetInfo--;
    }
}

// ---------------------------------------------------------------------------
// Initialize the resolution and color UI widgets
//

void CSettingsPage::_InitUI()
{
    if (_pCurDevice && _pCurDevice->pds)
    {
        int       i;
        int       Color;

        // Update the Color list
        TraceMsg(TF_FUNC, "_InitUI() -- Color list");

        SendDlgItemMessage(_hDlg, IDC_COLORBOX, CB_RESETCONTENT, 0, 0);

        if (_pCurDevice->ColorList)
        {
            LocalFree(_pCurDevice->ColorList);
            _pCurDevice->ColorList = NULL;
        }
        _pCurDevice->cColors = _pCurDevice->pds->GetColorList(NULL, &_pCurDevice->ColorList);

        for (i = 0; i < _pCurDevice->cColors; i++)
        {
            TCHAR  achColor[50];
            DWORD  idColor = ID_DSP_TXT_TRUECOLOR32;

            Color = (int) *(_pCurDevice->ColorList + i);

            //
            // convert bit count to number of colors and make it a string
            //

            switch (Color)
            {
            case 32: idColor = ID_DSP_TXT_TRUECOLOR32; break;
            case 24: idColor = ID_DSP_TXT_TRUECOLOR24; break;
            case 16: idColor = ID_DSP_TXT_16BIT_COLOR; break;
            case 15: idColor = ID_DSP_TXT_15BIT_COLOR; break;
            case  8: idColor = ID_DSP_TXT_8BIT_COLOR; break;
            case  4: idColor = ID_DSP_TXT_4BIT_COLOR; break;
            default:
                ASSERT(FALSE);
            }

            LoadString(HINST_THISDLL, idColor, achColor, ARRAYSIZE(achColor));
            SendDlgItemMessage(_hDlg, IDC_COLORBOX, CB_INSERTSTRING, i, (LPARAM)achColor);
        }

        //
        // Update the screen Size List
        //

        TraceMsg(TF_FUNC, "_InitUI() -- Screen Size list");

        if (_pCurDevice->ResolutionList)
        {
            LocalFree(_pCurDevice->ResolutionList);
            _pCurDevice->ResolutionList = NULL;
        }
        _pCurDevice->cResolutions =
            _pCurDevice->pds->GetResolutionList(-1, &_pCurDevice->ResolutionList);

        SendDlgItemMessage(_hDlg, IDC_SCREENSIZE, TBM_SETRANGE, TRUE,
                           MAKELONG(0, _pCurDevice->cResolutions - 1));

        TraceMsg(TF_FUNC, "_InitUI() -- Res MaxRange = %d", _pCurDevice->cResolutions - 1);

        // Reset the indices since they are no longer valid
        _iResolution = -1;
        _iColor = -1;

        //EnableWindow(GetDlgItem(_hDlg, IDC_COLORBOX), _fOrgAttached);
        //EnableWindow(GetDlgItem(_hDlg, IDC_SCREENSIZE), _fOrgAttached);
    }
}

// ---------------------------------------------------------------------------
// Update the resolution and color UI widgets
//
void CSettingsPage::_UpdateUI(BOOL fAutoSetColorDepth, int FocusToCtrlID)
{
    if (_pCurDevice && _pCurDevice->pds)
    {
        int  i;
        POINT Res;
        int   Color;
        BOOL bRepaint;

        // Get the current values
        _pCurDevice->pds->GetCurResolution(&Res);
        Color = _pCurDevice->pds->GetCurColor();

        // Update the color listbox
        TraceMsg(TF_FUNC, "_UpdateUI() -- Set Color %d", Color);

        for (i=0; i<_pCurDevice->cColors; i++)
        {
            if (Color == (int) *(_pCurDevice->ColorList + i))
            {
                TraceMsg(TF_FUNC, "_UpdateUI() -- Set Color index %d", i);

                if (_iColor == i)
                {
                    TraceMsg(TF_FUNC, "_UpdateUI() -- Set Color index %d - is current", i);
                    break;
                }

                HBITMAP hbm, hbmOld;
                int iBitmap = IDB_COLOR4DITHER;
                HDC hdc = GetDC(NULL);
                int bpp = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL);

                SendDlgItemMessage(_hDlg, IDC_COLORBOX, CB_SETCURSEL, i, 0);

                if (Color <= 4)
                    iBitmap = IDB_COLOR4;
                else if (bpp >= 16)
                {
                    if (Color <= 8)
                        iBitmap = IDB_COLOR8;
                    else if (Color <= 16)
                        iBitmap = IDB_COLOR16;
                    else
                        iBitmap = IDB_COLOR24;
                }

                ReleaseDC(NULL, hdc);

                hbm = (HBITMAP)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(iBitmap), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
                if (hbm)
                {
                    hbmOld = (HBITMAP) SendDlgItemMessage(_hDlg, IDC_COLORSAMPLE, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hbm);
                    if (hbmOld)
                    {
                        DeleteObject(hbmOld);
                    }
                }

                _iColor = i;
                break;
            }
        }

        if (i == _pCurDevice->cColors)
        {
            TraceMsg(TF_ERROR, "_UpdateUI -- !!! inconsistent color list !!!");
        }


        TraceMsg(TF_FUNC, "_UpdateUI() -- Set Resolution %d %d", Res.x, Res.y);

        // Update the resolution string
        {
            TCHAR achStr[80];
            TCHAR achRes[120];

            LoadString(HINST_THISDLL, ID_DSP_TXT_XBYY, achStr, ARRAYSIZE(achStr));
            wnsprintf(achRes, ARRAYSIZE(achRes), achStr, Res.x, Res.y);

            SendDlgItemMessage(_hDlg, IDC_RESXY, WM_SETTEXT, 0, (LPARAM)achRes);
        }

        // Update the resolution slider
        for (i=0; i<_pCurDevice->cResolutions; i++)
        {
            if ( (Res.x == (*(_pCurDevice->ResolutionList + i)).x) &&
                 (Res.y == (*(_pCurDevice->ResolutionList + i)).y) )
            {
                TraceMsg(TF_FUNC, "_UpdateUI() -- Set Resolution index %d", i);

                if (_iResolution == i)
                {
                    TraceMsg(TF_FUNC, "_UpdateUI() -- Set Resolution index %d - is current", i);
                    break;
                }

                SendDlgItemMessage(_hDlg, IDC_SCREENSIZE, TBM_SETPOS, TRUE, i);
                break;
            }
        }

        if (i == _pCurDevice->cResolutions)
        {
            TraceMsg(TF_ERROR, "_UpdateUI -- !!! inconsistent color list !!!");
        }

        bRepaint = (i != _iResolution);
        _iResolution = i;

        // If the resolution has changed, we have to repaint the preview window
        // Set the focus back to the trackbar after the repaint so any further
        // kb events will be send to it rather than the preview window
        if (bRepaint) {
            SendMessage(_hDlg, MM_REDRAWPREVIEW, 0, 0);
        }

        if (FocusToCtrlID != 0) {
            SetFocus(GetDlgItem(_hDlg, FocusToCtrlID));
        }
    }
}

//----------------------------------------------------------------------------
//
//  SetPrimary()
//
//----------------------------------------------------------------------------

BOOL
CSettingsPage::SetPrimary(
    PMULTIMON_DEVICE pDevice)
{
    //
    // Check if state is already set.
    //

    if (pDevice == _pPrimaryDevice)
    {
        pDevice->pds->SetPrimary(TRUE);
        return TRUE;
    }

    ASSERT(pDevice->pds->IsAttached());

    _pPrimaryDevice->pds->SetPrimary(FALSE);
    pDevice->pds->SetPrimary(TRUE);
    _pPrimaryDevice = pDevice;

    SetDirty();

    return TRUE;
}

//----------------------------------------------------------------------------
//
//  SetMonAttached()
//
//----------------------------------------------------------------------------

BOOL
CSettingsPage::SetMonAttached(
    PMULTIMON_DEVICE pDevice,
    BOOL bSetAttached,
    BOOL bForce,
    HWND hwnd)
{
    if (pDevice->pds->IsAttached() == bSetAttached)
    {
        return TRUE;
    }

    if (bSetAttached)
    {
        //
        // Make sure this device actually has a rectangle.
        // If it does not (not configured in the registry, then we need
        // to put up a popup and ask the user to configure the device.
        //

        if (hwnd)
        {
            //
            // Check to see if we should ask the user about enabling this device
            //

            if (bForce == FALSE)
            {
                TCHAR szTurnItOn[400];
                TCHAR szTurnOnTitleFormat[30];
                TCHAR szTurnOnTitle[110];
                LPTSTR pstr = szTurnItOn;
                DWORD chSize = ARRAYSIZE(szTurnItOn);

                LoadString(HINST_THISDLL, IDS_TURNONTITLE, szTurnOnTitleFormat, ARRAYSIZE(szTurnOnTitleFormat));
                wnsprintf(szTurnOnTitle, ARRAYSIZE(szTurnOnTitle), szTurnOnTitleFormat, pDevice->DisplayIndex);

                if (GetNumberOfAttachedDisplays() == 1)
                {
                    LoadString(HINST_THISDLL, IDS_TURNONMSG, szTurnItOn, ARRAYSIZE(szTurnItOn));
                    pstr += lstrlen(szTurnItOn);
                    chSize -= lstrlen(szTurnItOn);
                }

                LoadString(HINST_THISDLL, IDS_TURNITON, pstr, chSize);

                if (ShellMessageBox(HINST_THISDLL, hwnd, szTurnItOn, szTurnOnTitle,
                                    MB_YESNO | MB_ICONINFORMATION) != IDYES)
                {
                   return FALSE;
                }
            }
        }

        pDevice->pds->SetAttached(TRUE);

    }
    else  // (bSetAttached == FALSE)
    {
        //
        // Can't detach if we have only one device or it's the primary.
        // The UI should disable this situation
        //

        if ((GetNumberOfAttachedDisplays() == 1) ||
            pDevice->pds->IsPrimary())
        {
            ASSERT(FALSE);
        }

        pDevice->pds->SetAttached(FALSE);
    }

    SetDirty();

    return TRUE;
}

//----------------------------------------------------------------------------
//
//  SetDirty
//
//----------------------------------------------------------------------------
void CSettingsPage::SetDirty(BOOL bDirty)
{
    _bDirty = bDirty;

    if (_bDirty)
    {
        EnableApplyButton(_hDlg);
//        PostMessage(GetParent(_hDlg), PSM_CHANGED, (WPARAM)_hDlg, 0L);
    }
}

//-----------------------------------------------------------------------------

void CSettingsPage::_CleanupRects(HWND hwndP)
{
    int   n;
    HWND  hwndC;
    DWORD arcDev[MONITORS_MAX];
    RECT arc[MONITORS_MAX];
    DWORD iArcPrimary = 0;

    RECT rc;
    RECT rcU;
    int   i;
    RECT rcPrev;
    int sx,sy;
    int x,y;

    //
    // get the positions of all the windows
    //

    n = 0;

    for (ULONG iDevice = 0; iDevice < _NumDevices; iDevice++)
    {
        PMULTIMON_DEVICE pDevice = &_Devices[iDevice];

        hwndC = GetDlgItemP(hwndP, (INT_PTR) pDevice);

        if (hwndC != NULL)
        {
            RECT rcPos;
            RECT rcPreview;

            TraceMsg(TF_GENERAL, "_CleanupRects start Device %08lx, Dev = %d, hwnd = %08lx",
                     pDevice, iDevice, hwndC);

            ShowWindow(hwndC, SW_SHOW);

            GetWindowRect(hwndC, &arc[n]);
            MapWindowPoints(NULL, hwndP, (POINT FAR*)&arc[n], 2);

            pDevice->pds->GetCurPosition(&rcPos);
            pDevice->pds->GetPreviewPosition(&rcPreview);

            _OffsetPreviewToDesk(hwndC, &arc[n], &rcPreview, &rcPos);

            arc[n] = rcPos;
            arcDev[n] = iDevice;

            // TEMP
            // For non-atached devices, make sure they end up to the right
            // Eventually, non-attached devices should be showed aligned on the
            // right hand side of the window.

            if (!pDevice->pds->IsAttached())
            {
                OffsetRect(&arc[n], 10000, 0);
            }

            if (pDevice->pds->IsPrimary())
            {
                TraceMsg(TF_GENERAL, "_CleanupRects primary Device %08lx", pDevice);

                iArcPrimary = n;
            }


            n++;
        }
    }

    //
    // cleanup the rects
    //

    AlignRects(arc, n, iArcPrimary, CUDR_NORMAL);
    
    //
    // Get the union.
    //
    SetRectEmpty(&rcU);
    for (i=0; i<n; i++)
        UnionRect(&rcU, &rcU, &arc[i]);
    GetClientRect(hwndP, &rcPrev);

    //
    // only rescale if the new desk hangs outside the preview area.
    // or is too small
    //

    _DeskToPreview(&rcU, &rc);
    x = ((rcPrev.right  - rcPrev.left)-(rc.right  - rc.left))/2;
    y = ((rcPrev.bottom - rcPrev.top) -(rc.bottom - rc.top))/2;

    if (rcU.left < 0 || rcU.top < 0 || x < 0 || y < 0 ||
        rcU.right > rcPrev.right || rcU.bottom > rcPrev.bottom ||
        (x > (rcPrev.right-rcPrev.left)/8 &&
         y > (rcPrev.bottom-rcPrev.top)/8))
    {
        _rcDesk = rcU;
        sx = MulDiv(rcPrev.right  - rcPrev.left - 16,1000,_rcDesk.right  - _rcDesk.left);
        sy = MulDiv(rcPrev.bottom - rcPrev.top  - 16,1000,_rcDesk.bottom - _rcDesk.top);

        _DeskScale = min(sx,sy) * 2 / 3;
        _DeskToPreview(&_rcDesk, &rc);
        _DeskOff.x = ((rcPrev.right  - rcPrev.left)-(rc.right  - rc.left))/2;
        _DeskOff.y = ((rcPrev.bottom - rcPrev.top) -(rc.bottom - rc.top))/2;
    }

    //
    // Show all the windows and save them all to the devmode.
    //
    for (i=0; i < n; i++)
    {
        RECT rcPos;
        POINT ptPos;

        _Devices[arcDev[i]].pds->GetCurPosition(&rcPos);
        hwndC = GetDlgItemP(hwndP, (INT_PTR) &_Devices[arcDev[i]]);

        _DeskToPreview(&arc[i], &rc);

        rc.right =  MulDiv(RECTWIDTH(rcPos),  _DeskScale, 1000);
        rc.bottom = MulDiv(RECTHEIGHT(rcPos), _DeskScale, 1000);

        TraceMsg(TF_GENERAL, "_CleanupRects set Dev = %d, hwnd = %08lx", arcDev[i], hwndC);
        TraceMsg(TF_GENERAL, "_CleanupRects window pos %d,%d,%d,%d", rc.left, rc.top, rc.right, rc.bottom);
        
        SetWindowPos(hwndC,
                     NULL,
                     rc.left,
                     rc.top,
                     rc.right,
                     rc.bottom,
                     SWP_NOZORDER);
        
        rc.right += rc.left;
        rc.bottom += rc.top;

        _Devices[arcDev[i]].pds->SetPreviewPosition(&rc);

        ptPos.x = arc[i].left;
        ptPos.y = arc[i].top;

        _Devices[arcDev[i]].pds->SetCurPosition(&ptPos);
    }

    TraceMsg(TF_GENERAL, "");
}

void CSettingsPage::_ConfirmPositions()
{
    ASSERT (_NumDevices > 1);

    PMULTIMON_DEVICE pDevice;
    ULONG iDevice;

    for (iDevice = 0; iDevice < _NumDevices; iDevice++)
    {
        pDevice = &_Devices[iDevice];
        if (pDevice->pds->IsOrgAttached())
        {
            RECT rcOrg, rcCur;

            pDevice->pds->GetCurPosition(&rcCur);
            pDevice->pds->GetOrgPosition(&rcOrg);
            if ((rcCur.left != rcOrg.left) ||
                (rcCur.top != rcOrg.top))
            {
                POINT ptOrg;

                ptOrg.x = rcCur.left;
                ptOrg.y = rcCur.top;
                pDevice->pds->SetOrgPosition(&ptOrg);
                SetDirty(TRUE);
            }
        }
    }
}

void CSettingsPage::GetMonitorPosition(PMULTIMON_DEVICE pDevice, HWND hwndP, PPOINT ptPos)
{
    int iPrimary = 0;
    HWND hwndC;
    RECT rcPos;
    RECT rcPreview;
    RECT arc[MONITORS_MAX];
    int i;

    for (ULONG iDevice = 0; iDevice < _NumDevices; iDevice++)
    {
        PMULTIMON_DEVICE pDevice = &_Devices[iDevice];

        hwndC = GetDlgItemP(hwndP, (INT_PTR) pDevice);
        ASSERT(hwndC);

        GetWindowRect(hwndC, &arc[iDevice]);
        MapWindowPoints(NULL, hwndP, (POINT FAR*)&arc[iDevice], 2);

        pDevice->pds->GetCurPosition(&rcPos);
        pDevice->pds->GetPreviewPosition(&rcPreview);

        _OffsetPreviewToDesk(hwndC, &arc[iDevice], &rcPreview, &rcPos);
        
        arc[iDevice] = rcPos;

        if (pDevice->pds->IsPrimary()) {
            iPrimary = iDevice;
        }
    }

    AlignRects(arc, iDevice, iPrimary, CUDR_NORMAL);

    i = (int)(pDevice - _Devices);
    ptPos->x = arc[i].left;
    ptPos->y = arc[i].top;
}

BOOL CSettingsPage::HandleMonitorChange(HWND hwndP, BOOL bMainDlg, BOOL bRepaint /*=TRUE*/)
{
    if (!bMainDlg && _InSetInfo)
        return FALSE;

    SetDirty();

    if (bMainDlg)
        BringWindowToTop(hwndP);
    _CleanupRects(GetParent(hwndP));
    UpdateActiveDisplay(_pCurDevice, bRepaint);
    return TRUE;
}

BOOL CSettingsPage::RegisterPreviewWindowClass(WNDPROC pfnWndProc)
{
    TraceMsg(TF_GENERAL, "InitMultiMonitorDlg\n");
    WNDCLASS         cls;

    cls.hCursor        = LoadCursor(NULL,IDC_ARROW);
    cls.hIcon          = NULL;
    cls.lpszMenuName   = NULL;
    cls.lpszClassName  = TEXT("Monitor32");
    cls.hbrBackground  = (HBRUSH)(COLOR_DESKTOP + 1);
    cls.hInstance      = HINST_THISDLL;
    cls.style          = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;
    cls.lpfnWndProc    = pfnWndProc;
    cls.cbWndExtra     = SIZEOF(LPVOID);
    cls.cbClsExtra     = 0;

    return RegisterClass(&cls);
}

LRESULT CALLBACK DeskWndProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, UINT_PTR uID, DWORD_PTR dwRefData);

// This function is called from desk.c; Hence extern "C".
// This function is needed to determine if we need to use the single monitor's dialog
// or multi-monitor's dialog template at the time of starting the control panel applet.
int ComputeNumberOfDisplayDevices(void)
{
    int iNumberOfDevices = 0;
    CSettingsPage * pMultiMon = new CSettingsPage;

    if (pMultiMon)
    {
        int iDevice;

        // Enumerate all display devices to count the number of valid devices.
        iNumberOfDevices = pMultiMon->_EnumerateAllDisplayDevices();

        // Now that we have the number of devices, let's cleanup the device settings we
        // created in the process of enumerating above.
        for (iDevice = 0; iDevice < iNumberOfDevices; iDevice++)
            pMultiMon->_DestroyMultimonDevice(&pMultiMon->_Devices[iDevice]);

        // Let's clean up the MultiMon we allocated earlier.
        pMultiMon->Release();
    }

    return iNumberOfDevices;
}


int ComputeNumberOfMonitorsFast(BOOL fFastDetect)       
{
    int nVideoCards = 0;
    int nIndex;
    DISPLAY_DEVICE dispDevice = {0};

    dispDevice.cb = sizeof(dispDevice);
    for (nIndex = 0; EnumDisplayDevices(NULL, nIndex, &dispDevice, 0); nIndex++)
    {
        // Fast Detect means the caller only cares if there are more than 1.
        if (fFastDetect && (nVideoCards > 1))
        {
            break;
        }
        dispDevice.cb = sizeof(dispDevice);
        if (!(dispDevice.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER))
        {
            nVideoCards++;
        }
    }

    return nVideoCards;
}



BOOL CSettingsPage::_InitDisplaySettings(BOOL bExport)
{
    HWND             hwndC;
    int              iItem;
    LONG             iPrimeDevice = 0;
    TCHAR            ach[128];
    PMULTIMON_DEVICE pDevice;
    RECT             rcPrimary;

    HCURSOR hcur;

    _InSetInfo = 1;
    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    // Reset all the data so we can reinitialize the applet.
    //

    {
        ComboBox_ResetContent(_hwndList);
        SetRectEmpty(&_rcDesk);

        hwndC = GetWindow(_hwndDesk, GW_CHILD);
        while (hwndC)
        {
            RemoveTrackingToolTip(hwndC);
            RemovePopupToolTip(hwndC);
            DestroyWindow(hwndC);
            hwndC = GetWindow(_hwndDesk, GW_CHILD);
        }

        ShowWindow(_hwndDesk, SW_HIDE);

        if (_himl != NULL)
        {
            ImageList_Destroy(_himl);
            _himl = NULL;
        }

        //
        // Clear out all the devices.
        //
        for (ULONG iDevice = 0; iDevice < _NumDevices; iDevice++) {
            pDevice = _Devices + iDevice;
            _DestroyMultimonDevice(pDevice);
            ZeroMemory(pDevice, sizeof(MULTIMON_DEVICE));
        }

        ZeroMemory(_Devices + _NumDevices,
                   sizeof(_Devices) - sizeof(MULTIMON_DEVICE) * _NumDevices);

        _NumDevices = 0;
    }

    //
    // Enumerate all the devices in the system.
    //
    // Note: This function computes the _NumDevices.

    _EnumerateAllDisplayDevices();

    if (_NumDevices == 0)
    {
        ASSERT(0);
        return FALSE;
    }

    // Because we are getting the registry values, the current state of
    // the registry may be inconsistent with that of the system:
    //
    // EmumDisplayDevices will return the active primary in the
    // system, which may be different than the actual primary marked in the
    // registry

    BOOL bTmpDevicePrimary  = FALSE;
    ULONG iDevice;

    _pPrimaryDevice = NULL;

    for (iDevice = 0; iDevice < _NumDevices; iDevice++)
    {
        // First, we can pick any monitor that is attached as the primary.
        if (_Devices[iDevice].pds->IsAttached())
        {
            if ((_pPrimaryDevice == NULL) && 
                !_Devices[iDevice].pds->IsRemovable())
            {
                _pPrimaryDevice = &_Devices[iDevice];
                TraceMsg(TF_GENERAL, "InitDisplaySettings: primary found %d\n", iDevice);
            }

            // If the DISPLAY_DEVICE structure tells us this is the primary,
            // Pick this one.
            if (_Devices[iDevice].DisplayDevice.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
            {
                if (bTmpDevicePrimary)
                {
                    ASSERT(FALSE);
                }
                else
                {
                    _pPrimaryDevice = &_Devices[iDevice];
                    bTmpDevicePrimary = TRUE;
                    TraceMsg(TF_GENERAL, "InitDisplaySettings: Tmp DEVICE_PRIMARY found %d", iDevice);
                }

                // Check that the position should really be 0,0
                RECT pos;

                _Devices[iDevice].pds->GetCurPosition(&pos);

                if ((pos.left == 0) &&
                    (pos.top == 0))
                {
                    _pPrimaryDevice = &_Devices[iDevice];
                    TraceMsg(TF_GENERAL, "InitDisplaySettings: Best DEVICE_PRIMARY found %d", iDevice);
                }
                else
                {
                    ASSERT(FALSE);
                    TraceMsg(TF_GENERAL, "InitDisplaySettings: PRIMARY is not at 0,0");
                }
            }
        }
    }

    if (_pPrimaryDevice == NULL)
    {
        TraceMsg(TF_GENERAL, "InitDisplaySettings: NO Attached devices !!!");

        // We must be running setup.
        // Pick the first non-removable device as the primary.
        for (iDevice = 0; iDevice < _NumDevices; iDevice++)
        {
            if (!_Devices[iDevice].pds->IsRemovable()) 
            {
                _pPrimaryDevice = &_Devices[iDevice];
                break;
            }
        }

        if (_pPrimaryDevice == NULL)
        {
            ASSERT(FALSE);
            TraceMsg(TF_GENERAL, "InitDisplaySettings: All devices are removable !!!");
            
            _pPrimaryDevice = &_Devices[0];
        }
    }

    _pCurDevice = _pPrimaryDevice;

    //
    // Reset the primary's variables to make sure it is a properly formated
    // primary entry.
    //

    SetMonAttached(_pPrimaryDevice, TRUE, TRUE, NULL);
    SetPrimary(_pPrimaryDevice);
    _pPrimaryDevice->pds->GetCurPosition(&rcPrimary);

    //
    // compute the max image size needed for a monitor bitmap
    //
    // NOTE this must be the max size the images will *ever*
    // be we cant just take the current max size.
    // we use the client window size, a child monitor cant be larger than this.
    //
    RECT rcDesk;
    GetClientRect(_hwndDesk, &rcDesk);
    int cxImage = rcDesk.right;
    int cyImage = rcDesk.bottom;

    //
    // Create a temporary monitor bitmap
    //
    HBITMAP hbm = NULL;
    MakeMonitorBitmap(cxImage, cyImage, NULL, &hbm, NULL, cxImage, cyImage, FALSE);

    //
    // Go through all the devices one last time to create the windows
    //
    for (iDevice = 0; iDevice < _NumDevices; iDevice++)
    {
        TCHAR szDisplay[256];
        pDevice = &_Devices[iDevice];
        MonitorData md = {0};
        RECT rcPos;
        LPVOID pWindowData = (LPVOID)this;
        pDevice->DisplayIndex = iDevice + 1;
        _GetDisplayName(pDevice, szDisplay, ARRAYSIZE(szDisplay));
        iItem = ComboBox_AddString(_hwndList, szDisplay);

        pDevice->ComboBoxItem = iItem;

        ComboBox_SetItemData(_hwndList,
                             iItem,
                             (DWORD_PTR)pDevice);

        //
        // If the monitor is part of the desktop, show it on the screen
        // otherwise keep it invisible.
        //

        wnsprintf(ach, ARRAYSIZE(ach), TEXT("%d"), iDevice + 1);

        // Set the selection
        //

        if (pDevice == _pPrimaryDevice)
        {
            iPrimeDevice = iDevice;
        }

        if (!pDevice->pds->IsAttached())
        {
            // By default set the unattached monitors to the right of the primary monitor
            POINT ptPos = {rcPrimary.right, rcPrimary.top};
            pDevice->pds->SetCurPosition(&ptPos);
        }

        pDevice->pds->GetCurPosition(&rcPos);

        if (bExport)
        {
            md.dwSize = SIZEOF(MonitorData);
            if ( pDevice->pds->IsPrimary() )
                md.dwStatus |= MD_PRIMARY;
            if ( pDevice->pds->IsAttached() )
                md.dwStatus |= MD_ATTACHED;
            md.rcPos = rcPos;

            pWindowData = &md;
        }

        if (_himl == NULL)
        {
            UINT flags = ILC_COLORDDB | ILC_MASK;
            _himl = ImageList_Create(cxImage, cyImage, flags, _NumDevices, 1);
            ASSERT(_himl);
            ImageList_SetBkColor(_himl, GetSysColor(COLOR_APPWORKSPACE));
        }

        pDevice->w      = -1;
        pDevice->h      = -1;
        pDevice->himl   = _himl;
        pDevice->iImage = ImageList_AddMasked(_himl, hbm, CLR_DEFAULT);

        TraceMsg(TF_GENERAL, "InitDisplaySettings: Creating preview windows %s at %d %d %d %d",
                 ach, rcPos.left, rcPos.top, rcPos.right, rcPos.bottom);

        // HACK! Use pDevice as its own id.  Doesn't work on Win64.
        hwndC = CreateWindowEx(
                               0, // WS_EX_CLIENTEDGE,
                               TEXT("Monitor32"), ach,
                               WS_CLIPSIBLINGS | /* WS_DLGFRAME | */ WS_VISIBLE | WS_CHILD,
                               rcPos.left, rcPos.top, RECTWIDTH(rcPos), RECTHEIGHT(rcPos),
                               _hwndDesk,
                               (HMENU)pDevice,
                               HINST_THISDLL,
                               pWindowData);

        ASSERT(hwndC);
        AddTrackingToolTip(pDevice, hwndC);
        AddPopupToolTip(hwndC);
    }

    ToolTip_Activate(ghwndToolTipPopup, TRUE);
    ToolTip_SetDelayTime(ghwndToolTipPopup, TTDT_INITIAL, 1000);
    ToolTip_SetDelayTime(ghwndToolTipPopup, TTDT_RESHOW, 1000);

    //  nuke the temp monitor bitmap.
    if (hbm)
        DeleteObject(hbm);

    //
    // Set the primary device as the current device
    //

    ComboBox_SetCurSel(_hwndList, iPrimeDevice);

    // Initialize all the constants and the settings fields
    _DeskScale = 1000;
    _DeskOff.x = 0;
    _DeskOff.y = 0;
    _CleanupRects(_hwndDesk);

    // Now: depends on whether we have a multimon system, change the UI
    if (_NumDevices == 1)
    {
        HWND hwndDisable;

        hwndDisable = GetDlgItem(_hDlg, IDC_MULTIMONHELP);
        ShowWindow(hwndDisable, SW_HIDE);
        ShowWindow(_hwndDesk, SW_HIDE);

        // set up bitmaps for sample screen
        _hbmScrSample = LoadMonitorBitmap( TRUE ); // let them do the desktop
        SendDlgItemMessage(_hDlg, IDC_SCREENSAMPLE, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)_hbmScrSample);

        // get a base copy of the bitmap for when the "internals" change
        _hbmMonitor = LoadMonitorBitmap( FALSE ); // we'll do the desktop

        //Hide the combo box, keep the static text
        ShowWindow(_hwndList, SW_HIDE);

        //Set the name of the primary in the static text
        //strip the first token off (this is the number we dont want it)
        TCHAR *pch, szDisplay[MAX_PATH];
        _GetDisplayName(_pPrimaryDevice, szDisplay, ARRAYSIZE(szDisplay));
        for (pch=szDisplay; *pch && *pch != TEXT(' '); pch++);
        for (;*pch && *pch == TEXT(' '); pch++);
        SetDlgItemText(_hDlg, IDC_DISPLAYTEXT, pch);

        // Hide the check boxes

        // Single monitors use a different dialog template now!
        hwndDisable = GetDlgItem(_hDlg, IDC_DISPLAYPRIME);
        if(hwndDisable)
            ShowWindow(hwndDisable, SW_HIDE);
        hwndDisable = GetDlgItem(_hDlg, IDC_DISPLAYUSEME);
        if(hwndDisable)
            ShowWindow(hwndDisable, SW_HIDE);

    }
    else if (_NumDevices > 0)
    {
        //Hide the static text, keep the combo box
        ShowWindow(GetDlgItem(_hDlg, IDC_DISPLAYTEXT), SW_HIDE);

        // Hide the Multimon version of the preview objects
        ShowWindow(GetDlgItem(_hDlg, IDC_SCREENSAMPLE), SW_HIDE);

        // In case of multiple devices, subclass the _hwndDesk window for key board support
        SetWindowSubclass(_hwndDesk, DeskWndProc, 0, (DWORD_PTR)this);
        ShowWindow(_hwndDesk, SW_SHOW);
    }

    //
    // Paint the UI.
    //

    UpdateActiveDisplay(_pCurDevice);

    //
    // Reset the cursor and leave
    //

    SetCursor(hcur);
    _InSetInfo--;

    return TRUE;
}

//
// This function enumerates all the devices and returns the number of
// devices found in the system.
//

int  CSettingsPage::_EnumerateAllDisplayDevices()
{
    PMULTIMON_DEVICE pDevice;
    int iEnum;
    BOOL fSuccess;
    ULONG dwVgaPrimary = 0xFFFFFFFF;

    //
    // Enumerate all the devices in the system.
    //

    for (iEnum = 0; _NumDevices < MONITORS_MAX; iEnum++)
    {
        pDevice = &_Devices[_NumDevices];
        ZeroMemory(&(pDevice->DisplayDevice), sizeof(DISPLAY_DEVICE));
        pDevice->DisplayDevice.cb = sizeof(DISPLAY_DEVICE);

        fSuccess = EnumDisplayDevices(NULL, iEnum, &pDevice->DisplayDevice, 0);

        TraceMsg(TF_GENERAL, "Device %d       ", iEnum);
        TraceMsg(TF_GENERAL, "cb %d           ", pDevice->DisplayDevice.cb);
        TraceMsg(TF_GENERAL, "DeviceName %ws  ", pDevice->DisplayDevice.DeviceName);
        TraceMsg(TF_GENERAL, "DeviceString %ws", pDevice->DisplayDevice.DeviceString);
        TraceMsg(TF_GENERAL, "StateFlags %08lx", pDevice->DisplayDevice.StateFlags);

        // ignore device's we cant create a DC for.
        if (!fSuccess)
        {
            TraceMsg(TF_GENERAL, "End of list\n");
            break;
        }

        // We won't even include the MIRRORING drivers in the list for
        // now.
        if (pDevice->DisplayDevice.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER)
        {
            TraceMsg(TF_GENERAL, "Mirroring driver - skip it\n");
            continue;
        }

        // dump the device software key
        TraceMsg(TF_GENERAL, "DeviceKey %s", pDevice->DisplayDevice.DeviceKey);

        // Create the settings for this device
        pDevice->pds = new CDisplaySettings();
        if (pDevice->pds)
        {
            if (pDevice->pds->InitSettings(&pDevice->DisplayDevice))
            {
                // Determine if the VGA is the primary.
                // This will only happen for SETUP or BASEVIDEO
                //
                // We want to delete this device later on if we have others.
                if (pDevice->DisplayDevice.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
                {
                    CRegistrySettings crv(&pDevice->DisplayDevice.DeviceKey[0]);

                    LPTSTR pszMini = crv.GetMiniPort();

                    // If VGA is active, then go to pass 2.
                    // Otherwise, let's try to use this device
                    //

                    if (pszMini && (!lstrcmpi(TEXT("vga"), pszMini)))
                    {
                        TraceMsg(TF_GENERAL, "EnumDevices - VGA primary\n");
                        dwVgaPrimary = _NumDevices;
                    }
                }
                // Add it to the list.
                _NumDevices++;
            }
            else
            {
                pDevice->pds->Release();
                pDevice->pds = NULL;
            }
        }
    }

    //
    // If the primary VGA is not needed, remove it.
    //

    if ((dwVgaPrimary != 0xFFFFFFFF) &&
        (_NumDevices >= 2))
    {
        TraceMsg(TF_GENERAL, "REMOVE primary VGA device\n");

        _Devices[dwVgaPrimary].pds->Release();
        _Devices[dwVgaPrimary].pds = NULL;

        _NumDevices--;
        _Devices[dwVgaPrimary] = _Devices[_NumDevices];

    }

    return(_NumDevices);  //Return the number of devices.
}


//-----------------------------------------------------------------------------
BOOL CSettingsPage::InitMultiMonitorDlg(HWND hDlg)
{
    HWND hwndSlider;
    BOOL fSucceeded;

    _hDlg = hDlg;
    _hwndDesk = GetDlgItem(_hDlg, IDC_DISPLAYDESK);
    _hwndList = GetDlgItem(_hDlg, IDC_DISPLAYLIST);

    hwndSlider = GetDlgItem(hDlg, IDC_SCREENSIZE);
    ASSERT(hwndSlider != NULL);

    fSucceeded = SetWindowSubclass(hwndSlider, SliderSubWndProc, 0, NULL);
    ASSERT(fSucceeded);

    // Determine in what mode we are running the applet before getting information
    _vPreExecMode();

    // Create a tooltip window
    ghwndToolTipTracking = CreateWindowEx(WS_EX_TOPMOST, TOOLTIPS_CLASS, TEXT(""),
                                WS_POPUP, CW_USEDEFAULT, CW_USEDEFAULT,
                                CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL,
                                HINST_THISDLL, NULL);

    ghwndToolTipPopup = CreateWindowEx(WS_EX_TOPMOST, TOOLTIPS_CLASS, TEXT(""),
                                WS_POPUP, CW_USEDEFAULT, CW_USEDEFAULT,
                                CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL,
                                HINST_THISDLL, NULL);

    RegisterPreviewWindowClass(&MonitorWindowProc);
    _InitDisplaySettings(FALSE);

    if (_NumDevices > 1)
        _ConfirmPositions();

    if (ClassicGetSystemMetrics(SM_REMOTESESSION)) {
        EnableWindow(GetDlgItem(_hDlg, IDC_DISPLAYPROPERTIES), FALSE);
    }

    // Determine if any errors showed up during enumerations and initialization
    _vPostExecMode();

    // Now tell the user what we found out during initialization
    // Errors, or what we found during detection
    PostMessage(hDlg, MSG_DSP_SETUP_MESSAGE, 0, 0);

    // Since this could have taken a very long time, just make us visible
    // if another app (like progman) came up.
    ShowWindow(hDlg, SW_SHOW);

    return TRUE;
}


LRESULT CALLBACK DeskWndProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, UINT_PTR uID, DWORD_PTR dwRefData)
{
    CSettingsPage * pcmm = (CSettingsPage *)dwRefData;
    HWND hwndC;
    RECT rcPos;
    BOOL bMoved = TRUE;
    int iMonitor, nMoveUnit;

    switch(message)
    {
        case WM_GETDLGCODE:
             return DLGC_WANTCHARS | DLGC_WANTARROWS;

        case WM_KILLFOCUS:
            RedrawWindow(hDlg, NULL, NULL, RDW_INVALIDATE);
            break;

        case WM_MOUSEMOVE: {
                MSG mmsg;
                ToolTip_RelayEvent(ghwndToolTipPopup, mmsg, hDlg, message, wParam, lParam);
            }
            break;

        case WM_PAINT:
            if (GetFocus() != hDlg)
                break;
            return(DefSubclassProc(hDlg, message, wParam, lParam));
            break;

        case WM_LBUTTONDOWN:
            SetFocus(hDlg);
            break;

        case WM_KEYDOWN:

            nMoveUnit = ((GetKeyState(VK_CONTROL) & 0x8000) ? 1 : 3);
            hwndC = pcmm->GetCurDeviceHwnd();
            GetWindowRect(hwndC, &rcPos);
            MapWindowRect(NULL, hDlg, &rcPos);
            switch(wParam)
            {
                case VK_LEFT:
                    MoveWindow(hwndC, rcPos.left - nMoveUnit, rcPos.top, RECTWIDTH(rcPos), RECTHEIGHT(rcPos), TRUE);
                    break;
                case VK_RIGHT:
                    MoveWindow(hwndC, rcPos.left + nMoveUnit, rcPos.top, RECTWIDTH(rcPos), RECTHEIGHT(rcPos), TRUE);
                    break;
                case VK_UP:
                    MoveWindow(hwndC, rcPos.left, rcPos.top - nMoveUnit, RECTWIDTH(rcPos), RECTHEIGHT(rcPos), TRUE);
                    break;
                case VK_DOWN:
                    MoveWindow(hwndC, rcPos.left, rcPos.top + nMoveUnit, RECTWIDTH(rcPos), RECTHEIGHT(rcPos), TRUE);
                    break;
                default:
                    bMoved = FALSE;
                    break;
            }

            if (bMoved)
            {
                pcmm->HandleMonitorChange(hwndC, FALSE, FALSE);
                if (IsWindowVisible(ghwndToolTipPopup)) {
                    ToolTip_Update(ghwndToolTipPopup);
                }
            }

            break;

        case WM_CHAR:

            if (wParam >= TEXT('0') && wParam <= TEXT('9') && pcmm) {
                iMonitor = (TCHAR)wParam - TEXT('0');
                if ((iMonitor == 0) && (pcmm->GetNumDevices() >= 10))
                {
                    iMonitor = 10;
                }

                if ((iMonitor > 0) && ((ULONG)iMonitor <= pcmm->GetNumDevices()))
                {
                    HWND hwndList = GetDlgItem(GetParent(hDlg), IDC_DISPLAYLIST);
                    ComboBox_SetCurSel(hwndList, iMonitor - 1);
                    pcmm->UpdateActiveDisplay(NULL);
                    return 0;
                }
            }
            break;

        case WM_DESTROY:
            RemoveWindowSubclass(hDlg, DeskWndProc, 0);
            break;

        default:
            break;
    }

    return DefSubclassProc(hDlg, message, wParam, lParam);
}


//-----------------------------------------------------------------------------
//
// Callback functions PropertySheet can use
//
INT_PTR CALLBACK CSettingsPage::SettingsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CSettingsPage * pcmm = (CSettingsPage *) GetWindowLongPtr(hDlg, DWLP_USER);
    switch (message)
    {
        case WM_INITDIALOG:
            {
                PROPSHEETPAGE * pPropSheetPage = (PROPSHEETPAGE *) lParam;

                if (pPropSheetPage)
                {
                    SetWindowLongPtr(hDlg, DWLP_USER, pPropSheetPage->lParam);
                    pcmm = (CSettingsPage *)pPropSheetPage->lParam;
                }

                if (pcmm)
                {
                    SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pcmm);
                    ghwndPropSheet = GetParent(hDlg);

                    SetWindowLong(ghwndPropSheet,
                                  GWL_STYLE,
                                  GetWindowLong(ghwndPropSheet, GWL_STYLE) | WS_CLIPCHILDREN);

                    if (pcmm->InitMultiMonitorDlg(hDlg))
                    {
                        //
                        // if we have a invalid mode force the user to Apply
                        //
                        DWORD dwExecMode;
                        if (pcmm->_pThemeUI && (SUCCEEDED(pcmm->_pThemeUI->GetExecMode(&dwExecMode))))
                        {
                            if (dwExecMode == EM_INVALID_MODE)
                                pcmm->SetDirty();
                        }

                        return TRUE;
                    }
                    else
                        return FALSE;
                }
            }
            break;
        case WM_DESTROY:
            if (pcmm)
            {
                pcmm->WndProc(message, wParam, lParam);
                SetWindowLongPtr(hDlg, DWLP_USER, NULL);
            }
            if(gfFlashWindowRegistered)
            {
                gfFlashWindowRegistered = FALSE;
                UnregisterClass(TEXT("MonitorNumber32"), HINST_THISDLL);
            }
            break;
        default:
            if (pcmm)
                return pcmm->WndProc(message, wParam, lParam);
            break;
    }

    return FALSE;
}

void CSettingsPage::_SetPreviewScreenSize(int HRes, int VRes, int iOrgXRes, int iOrgYRes)
{
    HBITMAP hbmOld, hbmOld2;
    HBRUSH hbrOld;
    HDC hdcMem, hdcMem2;


    // stretching the taskbar could get messy, we'll only do the desktop
    int mon_dy = MON_DY - MON_TRAY;

    // init to identical extents
    SIZE dSrc = { MON_DX, mon_dy };
    SIZE dDst = { MON_DX, mon_dy };

    // set up a work area to play in
    if (!_hbmMonitor || !_hbmScrSample)
        return;

    HDC hdc = GetDC(NULL);
    hdcMem = CreateCompatibleDC(hdc);
    hdcMem2 = CreateCompatibleDC(hdc);
    ReleaseDC(NULL, hdc);
    if (!hdcMem2 || !hdcMem)
        return;
    hbmOld2 = (HBITMAP)SelectObject(hdcMem2, _hbmScrSample);
    hbmOld = (HBITMAP)SelectObject(hdcMem, _hbmMonitor);

    // see if we need to shrink either aspect of the image
    if (HRes > iOrgXRes || VRes > iOrgYRes)
    {
        // make sure the uncovered area will be seamless with the desktop
        RECT rc = { MON_X, MON_Y, MON_X + MON_DX, MON_Y + mon_dy };
        HBRUSH hbr = CreateSolidBrush(GetPixel( hdcMem, MON_X + 1, MON_Y + 1 ));

        if (hbr)
        {
            FillRect(hdcMem2, &rc, hbr);
            DeleteObject(hbr);
        }
    }

    // stretch the image to reflect the new resolution
    if( HRes > iOrgXRes )
        dDst.cx = MulDiv( MON_DX, iOrgXRes, HRes );
    else if( HRes < iOrgXRes )
        dSrc.cx = MulDiv( MON_DX, HRes, iOrgXRes );

    if( VRes > iOrgYRes )
        dDst.cy = MulDiv( mon_dy, iOrgYRes, VRes );
    else if( VRes < iOrgYRes )
        dSrc.cy = MulDiv( mon_dy, VRes, iOrgYRes );

    SetStretchBltMode( hdcMem2, COLORONCOLOR );
    StretchBlt( hdcMem2, MON_X, MON_Y, dDst.cx, dDst.cy,
                hdcMem, MON_X, MON_Y, dSrc.cx, dSrc.cy, SRCCOPY);

    // now fill the new image's desktop with the possibly-dithered brush
    // the top right corner seems least likely to be hit by the stretch...

    hbrOld = (HBRUSH)SelectObject( hdcMem2, GetSysColorBrush( COLOR_DESKTOP ) );
    ExtFloodFill(hdcMem2, MON_X + MON_DX - 2, MON_Y+1,
                 GetPixel(hdcMem2, MON_X + MON_DX - 2, MON_Y+1), FLOODFILLSURFACE);

    // clean up after ourselves
    SelectObject( hdcMem2, hbrOld );
    SelectObject( hdcMem2, hbmOld2 );
    DeleteObject( hdcMem2 );
    SelectObject( hdcMem, hbmOld );
    DeleteObject( hdcMem );
}

void CSettingsPage::_RedrawDeskPreviews()
{
    if (_NumDevices > 1)
    {
        _CleanupRects(_hwndDesk);
        RedrawWindow(_hwndDesk, NULL, NULL, RDW_ALLCHILDREN | RDW_ERASE | RDW_INVALIDATE);
    }
    else if (_pCurDevice && _pCurDevice->pds)
    {
        RECT rcPos, rcOrgPos;
        _pCurDevice->pds->GetCurPosition(&rcPos);
        _pCurDevice->pds->GetOrgPosition(&rcOrgPos);
        _SetPreviewScreenSize(RECTWIDTH(rcPos), RECTHEIGHT(rcPos), RECTWIDTH(rcOrgPos), RECTHEIGHT(rcOrgPos));
        // only invalidate the "screen" part of the monitor bitmap
        rcPos.left = MON_X;
        rcPos.top = MON_Y;
        rcPos.right = MON_X + MON_DX + 2;  // fudge (trust me)
        rcPos.bottom = MON_Y + MON_DY + 1; // fudge (trust me)
        InvalidateRect(GetDlgItem(_hDlg, IDC_SCREENSAMPLE), &rcPos, FALSE);
    }
}


int DisplaySaveSettings(PVOID pContext, HWND hwnd)
{
    CDisplaySettings *rgpds[1];
    rgpds[0] = (CDisplaySettings*) pContext;
    if(rgpds[0]->bIsModeChanged())
        return CSettingsPage::_DisplaySaveSettings(rgpds, 1, hwnd);
    else
        return DISP_CHANGE_SUCCESSFUL;
}

int CSettingsPage::_DisplaySaveSettings(CDisplaySettings *rgpds[], ULONG numDevices, HWND hDlg)
{
    BOOL  bReboot = FALSE;
    BOOL  bTest = FALSE;
    int   iSave;
    ULONG iDevice;
    POINT ptCursorSave;

    // Test the new settings first
    iSave = _SaveSettings(rgpds, numDevices, hDlg, CDS_TEST);

    if (iSave < DISP_CHANGE_SUCCESSFUL)
    {
        FmtMessageBox(hDlg,
                      MB_ICONEXCLAMATION,
                      IDS_CHANGE_SETTINGS,
                      IDS_SETTINGS_INVALID);

        return iSave;
    }

    int iDynaResult;

    // Ask first and then change the settings.
    if (!bReboot &&
        (_AnyChange(rgpds, numDevices) ||
         _IsSingleToMultimonChange(rgpds, numDevices)))
    {
        iDynaResult = AskDynaCDS(hDlg);
        if (iDynaResult == -1)
        {
            return DISP_CHANGE_NOTUPDATED;
        }
        else if (iDynaResult == 0)
        {
            bReboot = TRUE;
        }
    }

    if (!bReboot && _AnyChange(rgpds, numDevices) &&
        !_CanSkipWarningBecauseKnownSafe(rgpds, numDevices))
    {
        bTest = TRUE;
    }

    // Save the settings to the registry.
    iSave = _SaveSettings(rgpds, numDevices, hDlg, CDS_UPDATEREGISTRY | CDS_NORESET);

    if (iSave < DISP_CHANGE_SUCCESSFUL)
    {
        // NOTE
        // If we get NOT_UPDATED, this mean security may be turned on.
        // We could still try to do the dynamic change.
        // This only works in single mon ...
        if (iSave == DISP_CHANGE_NOTUPDATED)
        {
            FmtMessageBox(hDlg,
                          MB_ICONEXCLAMATION,
                          IDS_CHANGE_SETTINGS,
                          IDS_SETTINGS_CANNOT_SAVE);
        }
        else
        {
            FmtMessageBox(hDlg,
                          MB_ICONEXCLAMATION,
                          IDS_CHANGE_SETTINGS,
                          IDS_SETTINGS_FAILED_SAVE);
        }

        // Restore the settings to their original state
        for (iDevice = 0; iDevice < numDevices; iDevice++)
        {
            rgpds[iDevice]->RestoreSettings();
        }

        _SaveSettings(rgpds, numDevices, hDlg, CDS_UPDATEREGISTRY | CDS_NORESET);
        return iSave;
    }

    if (bReboot)
    {
        iSave = DISP_CHANGE_RESTART;
    }

    // Try to change the mode dynamically if it was requested
    GetCursorPos(&ptCursorSave);

    if (iSave == DISP_CHANGE_SUCCESSFUL)
    {
        // If EnumDisplaySettings was called with EDS_RAWMODE, we need CDS_RAWMODE below.
        // Otherwise, it's harmless.
        iSave = ChangeDisplaySettings(NULL, CDS_RAWMODE);
        //We post a message to ourselves to destroy it later.
        // Check the return from the dynamic mode switch.
        if (iSave < 0)
        {
            DWORD dwMessage =
                ((iSave == DISP_CHANGE_BADDUALVIEW) ? IDS_CHANGESETTINGS_BADDUALVIEW
                                                    : IDS_DYNAMIC_CHANGESETTINGS_FAILED);
            FmtMessageBox(hDlg,
                          MB_ICONEXCLAMATION,
                          IDS_CHANGE_SETTINGS,
                          dwMessage);
        }
        else if (iSave == DISP_CHANGE_SUCCESSFUL)
        {
            // Set the cursor to where it was before we changed the display
            // (ie, if we changed a 2ndary monitor, the cursor would have been
            // placed on the primary after the application of the change, move
            // it back to the 2ndary monitor.  If the change failed, we are
            // just placing the cursor back to it orig pos
            SetCursorPos(ptCursorSave.x, ptCursorSave.y);

            // Determine what to do based on the return code.
            if (bTest && (IDYES != DialogBoxParam(HINST_THISDLL,
                                             MAKEINTRESOURCE(DLG_KEEPNEW),
                                             GetParent(hDlg),
                                             KeepNewDlgProc, 15)))
            {
                iSave = DISP_CHANGE_NOTUPDATED;
            }
        }
    }

    // Determine what to do based on the return code.
    if (iSave >= DISP_CHANGE_SUCCESSFUL)
    {
        // Confirm the settings
        for (iDevice = 0; iDevice < numDevices; iDevice++)
        {
            rgpds[iDevice]->ConfirmChangeSettings();
        }
    }
    else
    {
        // Restore the settings to their original state
        for (iDevice = 0; iDevice < numDevices; iDevice++)
        {
            rgpds[iDevice]->RestoreSettings();
        }

        //DLI: This last function call will actually go refresh the whole desktop
        // If EnumDisplaySettings was called with EDS_RAWMODE, we need CDS_RAWMODE below.
        // Otherwise, it's harmless.
        ChangeDisplaySettings(NULL, CDS_RAWMODE);
    }

    return iSave;
}

//-----------------------------------------------------------------------------
//
// Resolution slider
//
CSettingsPage::_HandleHScroll(HWND hwndTB, int iCode, int iPos)
{
    if (_pCurDevice && _pCurDevice->pds)
    {
        int iRes = _iResolution;
        int cRes = (int)SendMessage(hwndTB, TBM_GETRANGEMAX, TRUE, 0);

        TraceMsg(TF_FUNC, "_HandleHScroll: MaxRange = %d, iRes = %d, iPos = %d", cRes, iRes, iPos);

        // Message box if something bad is going to happen ?
        //    _VerifyPrimaryMode(TRUE);

        switch (iCode)
        {
            case TB_LINEUP:
            case TB_PAGEUP:
                if (iRes != 0)
                    iRes--;
                break;

            case TB_LINEDOWN:
            case TB_PAGEDOWN:
                if (++iRes >= cRes)
                    iRes = cRes;
                break;

            case TB_BOTTOM:
                iRes = cRes;
                break;

            case TB_TOP:
                iRes = 0;
                break;

            case TB_THUMBTRACK:
            case TB_THUMBPOSITION:
                iRes = iPos;
                break;

            default:
                return FALSE;
        }

        TraceMsg(TF_FUNC, "_HandleHScroll: iRes = %d, iCode = %d", iRes, iCode);

        // We only want to automatically set the color depth for the user if they
        // changed the resolution. (not just set focus to the control)
        BOOL fAutoSetColorDepth = (_iResolution != iRes);       // iPos

        _pCurDevice->pds->SetCurResolution(_pCurDevice->ResolutionList + iRes, fAutoSetColorDepth);

        // Repaint the control in case they changed
        _UpdateUI(TRUE /*fAutoSetColorDepth*/, IDC_SCREENSIZE);

        DWORD dwExecMode;
        if (_pThemeUI && (SUCCEEDED(_pThemeUI->GetExecMode(&dwExecMode))))
        {
            if ( (dwExecMode == EM_NORMAL) ||
                 (dwExecMode == EM_INVALID_MODE) ||
                 (dwExecMode == EM_DETECT) ) {

                //
                // Set the apply button if resolution has changed
                //

                if (_pCurDevice->pds->bIsModeChanged())
                    SetDirty();

                return 0;
            }
        }
    }

    return TRUE;
}

void CSettingsPage::_ForwardToChildren(UINT message, WPARAM wParam, LPARAM lParam)
{
    HWND hwndC = GetDlgItem(_hDlg, IDC_SCREENSIZE);
    if (hwndC)
        SendMessage(hwndC, message, wParam, lParam);
}

LRESULT CALLBACK CSettingsPage::WndProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR * lpnm;
    HWND hwndC;
    HWND hwndSample;
    HBITMAP hbm;

    switch (message)
    {
    case WM_NOTIFY:

        lpnm = (NMHDR FAR *)lParam;
        switch (lpnm->code)
        {
        case PSN_APPLY:
            return TRUE;
        default:
            return FALSE;
        }
        break;

    case WM_CTLCOLORSTATIC:

        if (GetDlgCtrlID((HWND)lParam) == IDC_DISPLAYDESK)
        {
            return (UINT_PTR)GetSysColorBrush(COLOR_APPWORKSPACE);
        }
        return FALSE;


    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_DISPLAYPRIME:

            if (!SetPrimary(_pCurDevice))
            {
                return FALSE;
            }

            hwndC = GetCurDeviceHwnd();
            HandleMonitorChange(hwndC, TRUE);

            break;


        case IDC_DISPLAYUSEME:
            // Don't pop up warning dialog box if this display is already attached
            // or if there are already more than 1 display
            if (!_pCurDevice ||
                !SetMonAttached(_pCurDevice,
                                !_pCurDevice->pds->IsAttached(),
                                TRUE,
                                _hDlg))
            {
                return FALSE;
            }

            hwndC = GetCurDeviceHwnd();
            HandleMonitorChange(hwndC, TRUE);

            break;

        case IDC_DISPLAYLIST:
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case CBN_DBLCLK:
                goto DoDeviceSettings;

            case CBN_SELCHANGE:
                UpdateActiveDisplay(NULL);
                break;

            default:
                return FALSE;
            }
            break;

        case IDC_DISPLAYPROPERTIES:
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
            DoDeviceSettings:
            case BN_CLICKED:
                if (IsWindowEnabled(GetDlgItem(_hDlg, IDC_DISPLAYPROPERTIES)))
                    _OnAdvancedClicked();
                break;

            default:
                return FALSE;
            }
            break;

        case IDC_COLORBOX:
            switch(GET_WM_COMMAND_CMD(wParam, lParam))
            {
                case CBN_SELCHANGE:
                {
                    HWND hwndColorBox = GetDlgItem(_hDlg, IDC_COLORBOX);
                    int iClr = ComboBox_GetCurSel(hwndColorBox);

                    if ((iClr != CB_ERR) && _pCurDevice && _pCurDevice->pds && _pCurDevice->ColorList)
                    {
                        // Message box if something bad is going to happen ?
                        //    _VerifyPrimaryMode(TRUE);
                        _pCurDevice->pds->SetCurColor((int) *(_pCurDevice->ColorList + iClr));

                        // Repaint the control in case they changed
                        _UpdateUI(TRUE /*fAutoSetColorDepth*/, IDC_COLORBOX);
                    }

                    break;
                }
                default:
                    break;
            }

            break;

        case IDC_TROUBLESHOOT:
            // Invokes the trouble shooter for the Settings tab.
            {
                TCHAR szCommand[MAX_PATH];

                LoadString(HINST_THISDLL,IDS_TROUBLESHOOT_EXEC, szCommand, ARRAYSIZE(szCommand));
                HrShellExecute(_hwndDesk, NULL, TEXT("HelpCtr.exe"), szCommand, NULL, SW_NORMAL);
            }
            break;

        case IDC_IDENTIFY:
            // Flashes the Text on all the monitors simultaneously
            {
                HWND  hwndC;

                //Enumerate all the monitors and flash this for each!
                hwndC = GetWindow(_hwndDesk, GW_CHILD);
                while (hwndC)
                {
                    PostMessage(hwndC, WM_COMMAND, MAKEWPARAM(IDC_FLASH, 0), MAKELPARAM(0, 0));
                    hwndC = GetWindow(hwndC, GW_HWNDNEXT);
                }
            }
            break;

        default:
            return FALSE;
        }

        // Enable the apply button only if we are not in setup.
        DWORD dwExecMode;
        if (_pThemeUI && (SUCCEEDED(_pThemeUI->GetExecMode(&dwExecMode))))
        {
            if ( (dwExecMode == EM_NORMAL) ||
                 (dwExecMode == EM_INVALID_MODE) ||
                 (dwExecMode == EM_DETECT) )
            {
                // Set the apply button if something changed
                if (_pCurDevice && _pCurDevice->pds &&
                    _pCurDevice->pds->bIsModeChanged())
                {
                    SetDirty();
                }
            }
        }
        break;

    case WM_HSCROLL:
        _HandleHScroll((HWND)lParam, (int) LOWORD(wParam), (int) HIWORD(wParam));
        break;

#if QUICK_REFRESH
    case WM_RBUTTONDOWN:
        if (_NumDevices == 1 && GetKeyState(VK_CONTROL) & 0x8000)
        {
            HMENU hfreq;
            HWND hwnd;
            POINT pt;
            RECT rc;
            DWORD cmd;

            hwnd = GetDlgItem(_hDlg, IDC_SCREENSAMPLE);
            GetWindowRect(hwnd, &rc);
            GetCursorPos(&pt);

            if (!PtInRect(&rc,pt))
            {
                break;
            }

            hfreq = CreateFrequencyMenu(_pCurDevice);

            cmd = TrackPopupMenu(hfreq, TPM_RIGHTBUTTON | TPM_RETURNCMD,
                                 pt.x, pt.y, 0, _hDlg, NULL);
            if (cmd && _pCurDevice && _pCurDevice->pds)
            {
                _pCurDevice->pds->SetCurFrequency(cmd - IDC_FREQUENCY_START);
                SetDirty();
            }

            DestroyMenu(hfreq);
        }
        break;
#endif // QUICK_REFRESH

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, TEXT("display.hlp"), HELP_WM_HELP,
            (DWORD_PTR)(LPTSTR)sc_MultiMonitorHelpIds);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, TEXT("display.hlp"), HELP_CONTEXTMENU,
            (DWORD_PTR)(LPTSTR)sc_MultiMonitorHelpIds);
        break;

    case WM_DISPLAYCHANGE:
    case WM_WININICHANGE:
        _ForwardToChildren(message, wParam, lParam);
        break;

    case WM_SYSCOLORCHANGE:
        if (_himl)
            ImageList_SetBkColor(_himl, GetSysColor(COLOR_APPWORKSPACE));

        //
        // Needs to be passed to all the new common controls so they repaint
        // correctly using the new system colors
        //
        _ForwardToChildren(message, wParam, lParam);

        //
        // Rerender the monitor(s) bitmap(s) to reflect the new colors
        //
        if (_NumDevices == 1) {
            // set up bitmaps for sample screen
            if (_hbmScrSample && (GetObjectType(_hbmScrSample) != 0)) {
                DeleteObject(_hbmScrSample);
                _hbmScrSample = 0;
            }
            _hbmScrSample = LoadMonitorBitmap( TRUE ); // let them do the desktop
            SendDlgItemMessage(_hDlg, IDC_SCREENSAMPLE, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)_hbmScrSample);

            // get a base copy of the bitmap for when the "internals" change
            if (_hbmMonitor && (GetObjectType(_hbmMonitor) != 0)) {
                DeleteObject(_hbmMonitor);
                _hbmMonitor = 0;
            }
            _hbmMonitor = LoadMonitorBitmap( FALSE ); // we'll do the desktop
        }
        else if (_NumDevices > 0)
        {
            HBITMAP hbm, hbmMask;
            int cx, cy;
            UINT iDevice;
            PMULTIMON_DEVICE pDevice;
            TCHAR            ach[4];

            // replace each monitor bitmap with one with correct colors
            for (iDevice = 0; (iDevice < _NumDevices); iDevice++)
            {
                pDevice = &_Devices[iDevice];

                if (pDevice)
                {
                    _itot(iDevice+1,ach,10);
                    ImageList_GetIconSize(pDevice->himl, &cx, &cy);
                    MakeMonitorBitmap(pDevice->w,pDevice->h,ach,&hbm,&hbmMask,cx,cy, (pDevice == _pCurDevice));
                    ImageList_Replace(pDevice->himl,pDevice->iImage,hbm,hbmMask);

                    DeleteObject(hbm);
                    DeleteObject(hbmMask);
                }
            }
        }

        break;

#if 0
    //
    // NOTE:  until video supports device interfaces, we cannot use
    //        WM_DEVICECHANGE to detect video changes.  The default WM_DEVCHANGE
    //        only reports about legacy devices
    //
    case WM_DEVICECHANGE:
        //
        // Rebuild the device list if we are not currently enumerating,
        // because enumerating may cause another device to come on-line
        //
        // We only reenumerate if a new *video* device arrives
        //
        if (!_InSetInfo &&
            (wParam == DBT_DEVICEARRIVAL || wParam == DBT_DEVICEREMOVECOMPLETE))
        {
                        DEV_BROADCAST_HDR *bhdr = (DEV_BROADCAST_HDR *) lParam;

            // check for something else here, most likely the dev interface guid
                        if (bhdr->dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE)
            {
                _InitDisplaySettings(FALSE);
            }
        }

        break;
#endif

    case WM_DESTROY:
        TraceMsg(TF_GENERAL, "WndProc:: WM_DESTROY");
        hwndSample = GetDlgItem(_hDlg, IDC_COLORSAMPLE);
        hbm = (HBITMAP)SendMessage(hwndSample, STM_SETIMAGE, IMAGE_BITMAP, NULL);
        if (hbm)
            DeleteObject(hbm);

        if (_NumDevices == 1)
        {
            hwndSample = GetDlgItem(_hDlg, IDC_SCREENSAMPLE);
            hbm = (HBITMAP)SendMessage(hwndSample, STM_SETIMAGE, IMAGE_BITMAP, NULL);
            if (hbm)
                DeleteObject(hbm);

            if (_hbmScrSample && (GetObjectType(_hbmScrSample) != 0))
                DeleteObject(_hbmScrSample);
            if (_hbmMonitor && (GetObjectType(_hbmMonitor) != 0))
                DeleteObject(_hbmMonitor);
        }

        _DestroyDisplaySettings();

        break;

    case MSG_DSP_SETUP_MESSAGE:
        return _InitMessage();
        // MultiMonitor CPL specific messages
    case MM_REDRAWPREVIEW:
        _RedrawDeskPreviews();
        break;

    case WM_LBUTTONDBLCLK:
        if (_NumDevices == 1)
        {
            HWND hwndSample = GetDlgItem(_hDlg, IDC_SCREENSAMPLE);
            if(NULL != hwndSample)
            {
                POINT pt;
                RECT rc;

                pt.x = GET_X_LPARAM(lParam);  // horizontal position of cursor
                pt.y = GET_Y_LPARAM(lParam);  // vertical position of cursor
                GetWindowRect(hwndSample, &rc);

                if(ClientToScreen(_hDlg, &pt) && PtInRect(&rc, pt))
                    PostMessage(_hDlg, WM_COMMAND, MAKEWPARAM(IDC_DISPLAYPROPERTIES, BN_CLICKED), (LPARAM)hwndSample);
            }

            break;
        }
        else
            return FALSE;

    default:
        return FALSE;
    }

    return TRUE;
}


// IUnknown methods
HRESULT CSettingsPage::QueryInterface(REFIID riid, LPVOID * ppvObj)
{ 
    static const QITAB qit[] = {
        QITABENT(CSettingsPage, IObjectWithSite),
        QITABENT(CSettingsPage, IPropertyBag),
        QITABENT(CSettingsPage, IBasePropPage),
        QITABENTMULTI(CSettingsPage, IShellPropSheetExt, IBasePropPage),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

ULONG CSettingsPage::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CSettingsPage::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

// IMultiMonConfig methods
HRESULT CSettingsPage::Initialize(HWND hwndHost, WNDPROC pfnWndProc, DWORD dwReserved)
{
    HRESULT hr = E_FAIL;

    if (hwndHost && RegisterPreviewWindowClass(pfnWndProc))
    {
        _hwndDesk = hwndHost;
        if (_InitDisplaySettings(TRUE))
            hr = S_OK;
    }
    return hr;
}

HRESULT CSettingsPage::GetNumberOfMonitors(int * pCMon, DWORD dwReserved)
{
    if (pCMon)
    {
        *pCMon = _NumDevices;
        return S_OK;
    }

    return E_FAIL;
}

HRESULT CSettingsPage::GetMonitorData(int iMonitor, MonitorData * pmd, DWORD dwReserved)
{
    ASSERT(pmd);
    if ((pmd == NULL) || ((ULONG)iMonitor >= _NumDevices))
        return ResultFromWin32(ERROR_INVALID_PARAMETER);

    PMULTIMON_DEVICE pDevice = &_Devices[iMonitor];

    pmd->dwSize = SIZEOF(MonitorData);
    if ( pDevice->pds->IsPrimary() )
        pmd->dwStatus |= MD_PRIMARY;
    if ( pDevice->pds->IsAttached() )
        pmd->dwStatus |= MD_ATTACHED;
    pDevice->pds->GetCurPosition(&pmd->rcPos);

    return S_OK;
}

HRESULT CSettingsPage::Paint(int iMonitor, DWORD dwReserved)
{
    _RedrawDeskPreviews();

    return S_OK;
}


/*----------------------------------------------------------------------------
----------------------------------------------------------------------------*/
HFONT GetFont(LPRECT prc)
{
    LOGFONT lf;

    FillMemory(&lf,  SIZEOF(lf), 0);
    lf.lfWeight = FW_EXTRABOLD;
    lf.lfHeight = prc->bottom - prc->top;
    lf.lfWidth  = 0;
    lf.lfPitchAndFamily = FF_SWISS;
    lf.lfOutPrecision = OUT_TT_ONLY_PRECIS;

    return CreateFontIndirect(&lf);
}

/*----------------------------------------------------------------------------
----------------------------------------------------------------------------*/
#define HANG_TIME 2500

LRESULT CALLBACK BigNumberWindowProc(HWND hwnd, UINT msg,WPARAM wParam,LPARAM lParam)
{
    TCHAR ach[80];
    HFONT hfont;
    RECT  rc;
    HDC   hdc;
    HRGN  hrgnTxtA;
    PAINTSTRUCT ps;
    HGDIOBJ hOldPen;
    HGDIOBJ hNewPen;

    switch (msg)
    {
    case WM_CREATE:
        break;

    case WM_SIZE:
        GetWindowText(hwnd, ach, ARRAYSIZE(ach));
        GetClientRect(hwnd, &rc);
        hfont = GetFont(&rc);

        hdc = GetDC(hwnd);
        SelectObject(hdc, hfont);

        BeginPath(hdc);
            SetBkMode(hdc, TRANSPARENT);
            TextOut(hdc,0,0,ach,lstrlen(ach));
        EndPath(hdc);

        hrgnTxtA = PathToRegion(hdc);
        SetWindowRgn(hwnd,hrgnTxtA,TRUE);

        ReleaseDC(hwnd, hdc);
        DeleteObject(hfont);
        break;

    case WM_TIMER:
        DestroyWindow(hwnd);
        return 0;

    case WM_PAINT:
        GetWindowText(hwnd, ach, ARRAYSIZE(ach));
        GetClientRect(hwnd, &rc);
        hfont = GetFont(&rc);

        if (hfont)
        {
            hdc = BeginPaint(hwnd, &ps);
            //The following paints the whole region (which is in the shape of the number) black!
            PatBlt(hdc, 0, 0, rc.right, rc.bottom, BLACKNESS | NOMIRRORBITMAP);

            SelectObject(hdc, hfont);
            SetTextColor(hdc, 0xFFFFFF);
            //Let's create a path that is the shape of the region by drawing that number.
            BeginPath(hdc);
                SetBkMode(hdc, TRANSPARENT);
                TextOut(hdc,0,0,ach,lstrlen(ach));
            EndPath(hdc);

            // The above TextOut calljust created the path. Let's now actually draw the number!
            // Note: We are drawing the number in white there by changing whatever painted as black
            // a few moments ago!
            TextOut(hdc,0,0,ach,lstrlen(ach));

            //Let's create a thick black brush to paint the borders of the number we just drew!
            hNewPen = CreatePen(PS_INSIDEFRAME, 4, 0x0); //Black Color
            if (hNewPen)
            {
                hOldPen = SelectObject(hdc, hNewPen);

                //Draw the border of the white number with the thick black brush!
                StrokePath(hdc);

                SelectObject(hdc, hOldPen);
                DeleteObject(hNewPen);
            }

            EndPaint(hwnd, &ps);
            DeleteObject(hfont);
        }
        break;
    }

    return DefWindowProc(hwnd,msg,wParam,lParam);
}

int Bail()
{
    POINT pt;
    POINT pt0;
    DWORD time0;
    DWORD d;

    d     = GetDoubleClickTime();
    time0 = GetMessageTime();
    pt0.x = (int)(short)LOWORD(GetMessagePos());
    pt0.y = (int)(short)HIWORD(GetMessagePos());

    if (GetTickCount()-time0 > d)
        return 2;

    if (!((GetAsyncKeyState(VK_LBUTTON) | GetAsyncKeyState(VK_RBUTTON)) & 0x8000))
        return 1;

    GetCursorPos(&pt);

    if ((pt.y - pt0.y) > 2 || (pt.y - pt0.y) < -2)
        return 1;

    if ((pt.x - pt0.x) > 2 || (pt.x - pt0.x) < -2)
        return 1;

    return 0;
}

void FlashText(HWND hDlg, PMULTIMON_DEVICE pDevice, LPCTSTR sz, LPRECT prc, BOOL fWait)
{
    HFONT hfont;
    SIZE  size;
    HDC   hdc;
    int   i;

    if (!pDevice->pds->IsOrgAttached())
        return;

    if (pDevice->hwndFlash && IsWindow(pDevice->hwndFlash))
    {
        DestroyWindow(pDevice->hwndFlash);
        pDevice->hwndFlash = NULL;
    }

    if (sz == NULL)
        return;

    if (fWait)
    {
        while ((i=Bail()) == 0)
            ;

        if (i == 1)
            return;
    }

    hdc = GetDC(NULL);
    hfont = GetFont(prc);
    SelectObject(hdc, hfont);
    if (!GetTextExtentPoint(hdc, sz, lstrlen(sz), &size))
    {
        size.cx = 0;
        size.cy = 0;
    }
    ReleaseDC(NULL, hdc);
    DeleteObject(hfont);

    if (!gfFlashWindowRegistered)
    {
        WNDCLASS    cls;
        cls.hCursor        = LoadCursor(NULL,IDC_ARROW);
        cls.hIcon          = NULL;
        cls.lpszMenuName   = NULL;
        cls.lpszClassName  = TEXT("MonitorNumber32");
        cls.hbrBackground  = (HBRUSH)(COLOR_DESKTOP + 1);
        cls.hInstance      = HINST_THISDLL;
        cls.style          = CS_VREDRAW | CS_HREDRAW;
        cls.lpfnWndProc    = BigNumberWindowProc;
        cls.cbWndExtra     = 0;
        cls.cbClsExtra     = 0;

        RegisterClass(&cls);

        gfFlashWindowRegistered = TRUE;
    }

    pDevice->hwndFlash = CreateWindowEx(
        WS_EX_TOPMOST | WS_EX_TOOLWINDOW, //WS_BORDER,
        TEXT("MonitorNumber32"), sz,
        WS_POPUP,
        (prc->right  + prc->left - size.cx)/2,
        (prc->bottom + prc->top  - size.cy)/2,
        size.cx,
        size.cy,
        hDlg,   //Set the dialog as the parent sothat we get back the activation after flash window goes away!
        NULL,
        HINST_THISDLL,
        NULL);

    if (pDevice->hwndFlash)
    {
        ShowWindow(pDevice->hwndFlash, SW_SHOW);
        UpdateWindow(pDevice->hwndFlash);
        SetTimer(pDevice->hwndFlash, 1, HANG_TIME, NULL);
    }
}


void DrawMonitorNum(HDC hdc, int w, int h, LPCTSTR sz, BOOL fDrawBackground=TRUE)
{
    HFONT    hfont;
    HFONT    hfontT;
    RECT     rc;
    COLORREF rgb;
    COLORREF rgbDesk;

    SetRect(&rc, 0, 0, w, h);

    rgb     = GetSysColor(COLOR_CAPTIONTEXT);
    rgbDesk = GetSysColor(COLOR_DESKTOP);

    if (fDrawBackground)
        FillRect(hdc, &rc, GetSysColorBrush (COLOR_DESKTOP));

    InflateRect(&rc, -(MON_X*w / MON_W)>> 1, -(MON_Y*h/ MON_H));

    if (rgbDesk == rgb)
        rgb = GetSysColor(COLOR_WINDOWTEXT);

    if (rgbDesk == rgb)
        rgb = rgbDesk ^ 0x00FFFFFF;

    SetTextColor(hdc, rgb);

    hfont = GetFont(&rc);
    if (hfont)
    {
        hfontT = (HFONT)SelectObject(hdc, hfont);
        SetTextAlign(hdc, TA_CENTER | TA_TOP);
        SetBkMode(hdc, TRANSPARENT);
        ExtTextOut(hdc, (rc.left+rc.right)/2, rc.top, 0, NULL, sz, lstrlen(sz), NULL);
        SelectObject(hdc, hfontT);
        DeleteObject(hfont);
    }
}

void AddTrackingToolTip(PMULTIMON_DEVICE pDevice, HWND hwnd)
{
    TOOLINFO ti;
    TCHAR location[16];
    RECT rcPos;

    //
    // New tool Tip
    //

    pDevice->pds->GetCurPosition(&rcPos);
    wnsprintf(location, ARRAYSIZE(location), TEXT("%d, %d"), rcPos.left, rcPos.top);

    GetWindowRect(hwnd, &rcPos);

    ti.cbSize      = sizeof(TOOLINFO);
    ti.uFlags      = TTF_TRACK;
    ti.hwnd        = hwnd;
    ti.uId         = (UINT_PTR) pDevice;
    ti.hinst       = HINST_THISDLL;
    ti.lpszText    = location;
    ti.rect.left   = rcPos.left + 2;
    ti.rect.top    = rcPos.top + 2;
    ti.rect.right  = rcPos.right - 2;// ti.rect.left + 10;
    ti.rect.bottom = rcPos.bottom - 2; //  ti.rect.top + 10;

    ToolTip_AddTool(ghwndToolTipTracking, &ti);
    pDevice->bTracking = FALSE;

    TraceMsg(TF_GENERAL, "Added TOOLTIP hwnd %08lx, uId %08lx\n", ti.hwnd, ti.uId);
    return;
}

void RemoveTrackingToolTip(HWND hwnd)
{
    TOOLINFO ti;

    ZeroMemory(&ti, sizeof(TOOLINFO));
    ti.cbSize      = sizeof(TOOLINFO);
    ti.hwnd        = hwnd;
    ti.uId         = (UINT_PTR) GetDlgCtrlDevice(hwnd);

    ToolTip_DelTool(ghwndToolTipTracking, &ti);
}

BOOLEAN TrackToolTip(PMULTIMON_DEVICE pDevice, HWND hwnd, BOOL bTrack)
{
    TOOLINFO ti;
    BOOLEAN oldTracking;

    ZeroMemory(&ti, sizeof(TOOLINFO));
    ti.cbSize      = sizeof(TOOLINFO);
    ti.hwnd        = hwnd;
    ti.uId         = (UINT_PTR) pDevice;

    oldTracking = pDevice->bTracking;
    pDevice->bTracking = (BOOLEAN)bTrack;
    ToolTip_TrackActivate(ghwndToolTipTracking, bTrack, &ti);

    TraceMsg(TF_GENERAL, "Track TOOLTIP hwnd %08lx, uId %08lx\n", ti.hwnd, ti.uId);

    return oldTracking;
}

void AddPopupToolTip(HWND hwndC)
{
    TOOLINFO ti;

    //
    // New tool Tip
    //
    ti.cbSize      = sizeof(TOOLINFO);
    ti.uFlags      = TTF_IDISHWND | TTF_SUBCLASS | TTF_CENTERTIP;
    ti.hwnd        = hwndC;
    ti.uId         = (UINT_PTR) hwndC;
    ti.hinst       = HINST_THISDLL;
    GetWindowRect(hwndC, &ti.rect);
    ti.lpszText    = LPSTR_TEXTCALLBACK;

    ToolTip_AddTool(ghwndToolTipPopup, &ti);
}

void RemovePopupToolTip(HWND hwndC)
{
    TOOLINFO ti;

    ZeroMemory(&ti, sizeof(TOOLINFO));
    ti.cbSize      = sizeof(TOOLINFO);
    ti.hwnd        = hwndC;
    ti.uId         = (UINT_PTR) hwndC;

    ToolTip_DelTool(ghwndToolTipPopup, &ti);
}

#if QUICK_REFRESH

HMENU CreateFrequencyMenu(PMULTIMON_DEVICE pDevice)
{
    HMENU hfreq;
    MENUITEMINFO mii;

    ZeroMemory(&mii, sizeof(mii));
    mii.cbSize = sizeof(mii);

    if (!(hfreq = CreatePopupMenu())) {
        return NULL;
    }

    PLONGLONG freqs;
    UINT i, iFreq = pDevice->pds->GetFrequencyList(-1, NULL, &freqs);
    int curFreq = pDevice->pds->GetCurFrequency(), freq;
    TCHAR ach[LINE_LEN], achFre[50];

    mii.fMask = MIIM_TYPE | MFT_STRING | MIIM_ID | MIIM_STATE;
    mii.dwTypeData = ach;
    mii.fType = MFT_STRING;
    mii.fState = MFS_ENABLED;

    for (i = 0; i < iFreq; i++ ) {
        freq = (int) freqs[i];

        if (freq == 1) {
            LoadString(HINST_THISDLL, IDS_DEFFREQ, ach, ARRAYSIZE(ach));
        }
        else {
            DWORD  idFreq = IDS_FREQ;

            if (freq < 50) {
                idFreq = IDS_INTERLACED;
            }

            LoadString(HINST_THISDLL, idFreq, achFre, ARRAYSIZE(achFre));
            wnsprintf(ach, ARRAYSIZE(ach), TEXT("%d %s"), freq, achFre);
        }

        mii.cch = lstrlen(ach);
        mii.wID = IDC_FREQUENCY_START + freq;

        mii.fState = MFS_ENABLED;
        if (curFreq == freq)
            mii.fState = MFS_CHECKED;
        InsertMenuItem(hfreq, i, TRUE, &mii);
    }

    LocalFree(freqs);

    return hfreq;
}

#endif

BOOL MakeMonitorBitmap(int w, int h, LPCTSTR sz, HBITMAP *pBitmap, HBITMAP *pMaskBitmap, int cx, int cy, BOOL fSelected)
{
    HDC     hdc;        // work dc
    HDC     hdcS;       // screen dc

    ASSERT(w <= cx);
    ASSERT(h <= cy);

    *pBitmap = NULL;

    hdcS = GetDC(NULL);
    hdc  = CreateCompatibleDC(hdcS);
    if (hdc)
    {
        HDC     hdcT;       // another work dc

        hdcT = CreateCompatibleDC(hdcS);
        if (hdcT)
        {
            HBITMAP hbm;        // 128x128 bitmap we will return
            HBITMAP hbmT = NULL;// bitmap loaded from resource
            HBITMAP hbmM = NULL;// mask bitmap
            HDC     hdcM = NULL;// another work dc
            RECT    rc;

            if (pMaskBitmap)
                hdcM = CreateCompatibleDC(hdcS);

            hbm  = CreateCompatibleBitmap(hdcS, cx, cy);
            if (hbm)
            {
                hbmT = CreateCompatibleBitmap(hdcS, w, h);
                if(pMaskBitmap)
                    hbmM = CreateBitmap(cx,cy,1,1,NULL);
                ReleaseDC(NULL,hdcS);

                if (hbmT)
                {
                    SelectObject(hdc, hbm);
                    SelectObject(hdcT,hbmT);
                    if (pMaskBitmap && hdcM)
                        SelectObject(hdcM, hbmM);
                }
                *pBitmap = hbm;
            }

            // Make sure the color of the borders (selection & normal) is different than the background color.
            HBRUSH hbrDiff = NULL;
            BOOL bNeedDiff = ((fSelected &&
                               (GetSysColor(COLOR_APPWORKSPACE) == GetSysColor(COLOR_HIGHLIGHT))) ||
                              (GetSysColor(COLOR_APPWORKSPACE) == GetSysColor(COLOR_BTNHIGHLIGHT)));
            if(bNeedDiff)
            {
                DWORD rgbDiff = ((GetSysColor(COLOR_ACTIVEBORDER) != GetSysColor(COLOR_APPWORKSPACE))
                                    ? GetSysColor(COLOR_ACTIVEBORDER)
                                    : GetSysColor(COLOR_APPWORKSPACE) ^ 0x00FFFFFF);
                hbrDiff = CreateSolidBrush(rgbDiff);
            }

            // Fill it with the selection color or the background color.
            SetRect(&rc, 0, 0, w, h);
            FillRect(hdcT, &rc,
                     (fSelected ? ((GetSysColor(COLOR_APPWORKSPACE) != GetSysColor(COLOR_HIGHLIGHT))
                                       ? GetSysColorBrush(COLOR_HIGHLIGHT)
                                       : hbrDiff)
                                : GetSysColorBrush(COLOR_APPWORKSPACE)));

            InflateRect(&rc, -SELECTION_THICKNESS, -SELECTION_THICKNESS);
            FillRect(hdcT, &rc,
                     ((GetSysColor(COLOR_APPWORKSPACE) != GetSysColor(COLOR_BTNHIGHLIGHT))
                          ? GetSysColorBrush(COLOR_BTNHIGHLIGHT)
                          : hbrDiff));

            if (hbrDiff)
            {
                DeleteObject(hbrDiff);
                hbrDiff = NULL;
            }

            InflateRect(&rc, -MONITOR_BORDER, -MONITOR_BORDER);
            FillRect(hdcT, &rc, GetSysColorBrush(COLOR_DESKTOP));

            // fill bitmap with transparent color
            SetBkColor(hdc,GetSysColor(COLOR_APPWORKSPACE));
            SetRect(&rc, 0, 0, cx, cy);
            ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

            // copy bitmap to upper-left of bitmap
            BitBlt(hdc,0,0,w,h,hdcT,0,0,SRCCOPY);

            // draw the monitor number, if provided, in the bitmap (in the right place)
            if (sz)
                DrawMonitorNum(hdc, w, h, sz, FALSE);

            // make mask, if needed.
            if (pMaskBitmap && hdcM)
            {
                BitBlt(hdcM,0,0,cx,cy,hdc,0,0,SRCCOPY);
                *pMaskBitmap = hbmM;
            }

            if (hbmT)
                DeleteObject(hbmT);

            if (pMaskBitmap && hdcM)
                DeleteDC(hdcM);

            DeleteDC(hdcT);
        }
        DeleteDC(hdc);
    }

    return TRUE;
}

//
// SnapMonitorRect
//
// called while the user is moving a monitor window (WM_MOVING)
// if the CTRL key is not down we will snap the window rect
// to the edge of one of the other monitors.
//
// this is done so the user can easily align monitors
//
// NOTE pDevice->Snap must be initialized to 0,0 in WM_ENTERSIZEMOVE
//
void SnapMonitorRect(PMULTIMON_DEVICE pDevice, HWND hwnd, RECT *prc)
{
    HWND hwndT;
    int  d;
    RECT rcT;
    RECT rc;

    //
    // allow the user to move the window anywhere when the CTRL key is down
    //
    if (GetKeyState(VK_CONTROL) & 0x8000)
        return;

    //
    // macros to help in alignment
    //
    #define SNAP_DX 6
    #define SNAP_DY 6

    #define SNAPX(f,x) \
        d = rcT.x - rc.f; if (abs(d) <= SNAP_DX) rc.left+=d, rc.right+=d;

    #define SNAPY(f,y) \
        d = rcT.y - rc.f; if (abs(d) <= SNAP_DY) rc.top+=d, rc.bottom+=d;

    //
    // get current rect and offset it by the amount we have corrected
    // it so far (this alignes the rect with the position of the mouse)
    //
    rc = *prc;
    OffsetRect(&rc, pDevice->Snap.x, pDevice->Snap.y);

    //
    // walk all other windows and snap our window to them
    //
    for (hwndT = GetWindow(hwnd,  GW_HWNDFIRST); hwndT;
         hwndT = GetWindow(hwndT, GW_HWNDNEXT))
    {
        if (hwndT == hwnd)
            continue;

        GetWindowRect(hwndT, &rcT);
        InflateRect(&rcT,SNAP_DX,SNAP_DY);

        if (IntersectRect(&rcT, &rcT, &rc))
        {
            GetWindowRect(hwndT, &rcT);

            SNAPX(right,left);  SNAPY(bottom,top);
            SNAPX(right,right); SNAPY(bottom,bottom);
            SNAPX(left,left);   SNAPY(top,top);
            SNAPX(left,right);  SNAPY(top,bottom);
        }
    }

    //
    // adjust the amount we have snap'ed so far, and return the new rect
    //
    pDevice->Snap.x += prc->left - rc.left;
    pDevice->Snap.y += prc->top  - rc.top;
    *prc = rc;
}

WPARAM GetKeyStates()
{
    WPARAM wParam = 0x0;

    if (GetKeyState(VK_CONTROL) & 0x8000)
        wParam |= MK_CONTROL;
    if (GetKeyState(VK_LBUTTON) & 0x8000)
        wParam |= MK_LBUTTON;
    if (GetKeyState(VK_MBUTTON) & 0x8000)
        wParam |= MK_MBUTTON;
    if (GetKeyState(VK_RBUTTON) & 0x8000)
        wParam |= MK_RBUTTON;
    if (GetKeyState(VK_SHIFT) & 0x8000)
        wParam |= MK_SHIFT;

    return wParam;
}


LRESULT CALLBACK MonitorWindowProc(HWND hwnd, UINT msg,WPARAM wParam,LPARAM lParam)
{
    TOOLINFO ti;
    PAINTSTRUCT ps;
    HDC hdc;
    RECT rc;
    int w,h;
    TCHAR ach[80];
    PMULTIMON_DEVICE pDevice;
    HWND hDlg = GetParent(GetParent(hwnd));
    RECT rcPos;
    MSG mmsg;
    CSettingsPage * pcmm = (CSettingsPage *) GetWindowLongPtr(hwnd, 0);

    switch (msg)
    {
        case WM_CREATE:
            ASSERT(((LPCREATESTRUCT)lParam)->lpCreateParams);
            SetWindowLongPtr(hwnd, 0, (LONG_PTR)((LPCREATESTRUCT)lParam)->lpCreateParams);
            break;

        case WM_NCCREATE:
            // turn off RTL_MIRRORED_WINDOW in GWL_EXSTYLE
            SHSetWindowBits(hwnd, GWL_EXSTYLE, RTL_MIRRORED_WINDOW, 0);
            break;
        case WM_NCHITTEST:
            //
            // return HTCAPTION so that we can get the ENTERSIZEMOVE message.
            //
            pDevice = GetDlgCtrlDevice(hwnd);
            // Let disabled monitors move
            if (pDevice) // if (pDevice && pDevice->pds->IsAttached())
                return HTCAPTION;
            break;

        case WM_NCLBUTTONDBLCLK:
            FlashText(hDlg, GetDlgCtrlDevice(hwnd), NULL,NULL,FALSE);
            PostMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_DISPLAYPROPERTIES, BN_CLICKED), (LPARAM)hwnd );
            break;

        case WM_CHILDACTIVATE:
            if (GetFocus() != GetParent(hwnd)) {
                SetFocus(GetParent(hwnd));
            }
            break;

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, TEXT("display.hlp"), HELP_WM_HELP,
                (DWORD_PTR)(LPTSTR)sc_MultiMonitorHelpIds);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, TEXT("display.hlp"), HELP_CONTEXTMENU,
                (DWORD_PTR)(LPTSTR)sc_MultiMonitorHelpIds);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
            case IDC_DISPLAYPRIME:
            case IDC_DISPLAYUSEME:
            case IDC_DISPLAYPROPERTIES:
                PostMessage(hDlg, WM_COMMAND, wParam, lParam);
                break;

            case IDC_FLASH:
                pDevice = GetDlgCtrlDevice(hwnd);

                pDevice->pds->GetOrgPosition(&rcPos);

                if (!IsRectEmpty(&rcPos))
                {
                    GetWindowText(hwnd, ach, ARRAYSIZE(ach));
                    FlashText(hDlg, pDevice, ach, &rcPos, FALSE);
                }
                break;

#if QUICK_REFRESH
            default:
                ASSERT(LOWORD(wParam) - IDC_FREQUENCY_START > 0);

                pDevice = GetDlgCtrlDevice(hwnd);
                pDevice->pds->SetCurFrequency(LOWORD(wParam) - IDC_FREQUENCY_START);
                pcmm->SetDirty();
#endif
                break;
            }

            break;

        case WM_INITMENUPOPUP:
            pDevice = GetDlgCtrlDevice(hwnd);

            CheckMenuItem((HMENU)wParam, IDC_DISPLAYUSEME,
                          pDevice->pds->IsAttached() ? MF_CHECKED : MF_UNCHECKED);
            CheckMenuItem((HMENU)wParam, IDC_DISPLAYPRIME,
                          pDevice->pds->IsPrimary()  ? MF_CHECKED : MF_UNCHECKED);
            // until I figure out how to render on a non attached monitor, just
            // disable the menu item
            EnableMenuItem((HMENU)wParam, IDC_FLASH,
                           pDevice->pds->IsAttached() ? MF_ENABLED : MF_GRAYED);
            EnableMenuItem((HMENU)wParam, IDC_DISPLAYPROPERTIES,
                           IsWindowEnabled(GetDlgItem(GetParent(GetParent(hwnd)), IDC_DISPLAYPROPERTIES)) ?
                           MF_ENABLED : MF_GRAYED);
            EnableMenuItem((HMENU)wParam, IDC_DISPLAYUSEME,
                           pDevice->pds->IsPrimary() ? MF_GRAYED : MF_ENABLED);

            EnableMenuItem((HMENU)wParam, IDC_DISPLAYPRIME,
                           ((pDevice->pds->IsAttached() && 
                             !pDevice->pds->IsRemovable() &&
                             !pDevice->pds->IsPrimary()) ? 
                            MF_ENABLED : MF_GRAYED));

            SetMenuDefaultItem((HMENU)wParam, IDC_DISPLAYPROPERTIES, MF_BYCOMMAND);
            break;

        case WM_NCMOUSEMOVE:
            ToolTip_RelayEvent(ghwndToolTipPopup, mmsg, NULL, WM_MOUSEMOVE, GetKeyStates(), lParam);
            break;

        case WM_NCMBUTTONDOWN:
            ToolTip_RelayEvent(ghwndToolTipPopup, mmsg, NULL, WM_MBUTTONDOWN, GetKeyStates(), lParam);
            break;

        case WM_NCMBUTTONUP:
            ToolTip_RelayEvent(ghwndToolTipPopup, mmsg, NULL, WM_MBUTTONUP, GetKeyStates(), lParam);
            break;

        case WM_NCRBUTTONDOWN:
            ToolTip_RelayEvent(ghwndToolTipPopup, mmsg, NULL, WM_RBUTTONDOWN, GetKeyStates(), lParam);

            pDevice = GetDlgCtrlDevice(hwnd);

            if (pDevice && pcmm)
            {
                HMENU hmenu;
                POINT pt;

                hmenu = LoadMenu(HINST_THISDLL, MAKEINTRESOURCE(MENU_MONITOR));

                if (hmenu)
                {
#if QUICK_REFRESH
                    if (GetKeyState(VK_CONTROL) & 0x8000) {
                        HMENU hsub;
                        MENUITEMINFO mii;
                        TCHAR ach[LINE_LEN];

                        LoadString(HINST_THISDLL, IDS_FREQUENCY, ach, ARRAYSIZE(ach));

                        hsub = GetSubMenu(hmenu, 0);
                        ZeroMemory(&mii, sizeof(mii));
                        mii.cbSize = sizeof(mii);
                        mii.fMask = MIIM_TYPE;
                        mii.fType = MFT_SEPARATOR;
                        InsertMenuItem(hsub, GetMenuItemCount(hsub), TRUE, &mii);

                        mii.fMask = MIIM_SUBMENU | MIIM_TYPE | MIIM_STATE;
                        mii.hSubMenu = CreateFrequencyMenu(pDevice);
                        mii.fType = MFT_STRING;
                        mii.fState = MFS_ENABLED;
                        mii.dwTypeData = ach;
                        InsertMenuItem(hsub, GetMenuItemCount(hsub), TRUE, &mii);

                        DestroyMenu(mii.hSubMenu);
                    }
#endif // QUICK_REFRESH

                    pcmm->UpdateActiveDisplay(pDevice);
                    GetCursorPos(&pt);
                    TrackPopupMenu(GetSubMenu(hmenu,0), TPM_RIGHTBUTTON,
                        pt.x, pt.y, 0, hwnd, NULL);

                    DestroyMenu(hmenu);
                }
            }
            break;

        case WM_NCRBUTTONUP:
            ToolTip_RelayEvent(ghwndToolTipPopup, mmsg, NULL, WM_RBUTTONUP, GetKeyStates(), lParam);
            break;

        case WM_NCLBUTTONDOWN:
            //TraceMsg(TF_FUNC, "WM_NCLBUTTONDOWN");
            // don't relay the message here because we want to keep the tool tip
            // active until they start moving the monitor.  This click might just
            // be for selection
            // ToolTip_RelayEvent(ghwndToolTipPopup, mmsg, hDlg, WM_LBUTTONDOWN, GetKeyStates(), lParam);

            BringWindowToTop(hwnd);
            pDevice = GetDlgCtrlDevice(hwnd);

            if (pcmm)
                pcmm->UpdateActiveDisplay(pDevice);

            pDevice->pds->GetOrgPosition(&rcPos);

            if (!IsRectEmpty(&rcPos))
            {
                GetWindowText(hwnd, ach, ARRAYSIZE(ach));
                FlashText(hDlg, pDevice, ach, &rcPos, TRUE);
            }

            break;

#if 0
        case WM_NCLBUTTONUP:
            ToolTip_RelayEvent(ghwndToolTipPopup, mmsg, NULL, WM_LBUTTONUP, GetKeyStates(), lParam);
            break;
#endif

        case WM_NOTIFY:
            switch (((NMHDR FAR *)lParam)->code)
            {
            case TTN_NEEDTEXT:
                pDevice = GetDlgCtrlDevice(hwnd);
                if (pDevice->pds->IsPrimary())
                {
                    LoadString(HINST_THISDLL, IDS_PRIMARY,
                               ((LPNMTTDISPINFO)lParam)->szText,
                               ARRAYSIZE(((LPNMTTDISPINFO)lParam)->szText) );
                }
                else if (!pDevice->pds->IsAttached())
                {
                    LoadString(HINST_THISDLL, IDS_NOTATTACHED,
                               ((LPNMTTDISPINFO)lParam)->szText,
                               ARRAYSIZE(((LPNMTTDISPINFO)lParam)->szText) );
                }
                else
                {
                    TCHAR szSecondary[32];
                    LoadString(HINST_THISDLL, IDS_SECONDARY, szSecondary, ARRAYSIZE(szSecondary));
                    pDevice->pds->GetCurPosition(&rcPos);
                    wsprintf(((LPNMTTDISPINFO)lParam)->szText, TEXT("%s (%d, %d)"), szSecondary, rcPos.left, rcPos.top);
                }
                break;

            default:
                break;
            }

            break;

        case WM_ENTERSIZEMOVE:
            //TraceMsg(TF_FUNC, "WM_ENTERSIZEMOVE");
            // relay a mouse up to clean the information tooltip
            ToolTip_RelayEvent(ghwndToolTipPopup, mmsg, NULL, WM_LBUTTONDOWN, GetKeyStates(), lParam);
            pDevice = GetDlgCtrlDevice(hwnd);
            pDevice->Snap.x = 0;
            pDevice->Snap.y = 0;
            FlashText(hDlg, pDevice, NULL,NULL,FALSE);
            break;

        case WM_MOVING:
            //TraceMsg(TF_FUNC, "WM_MOVING");
            pDevice = GetDlgCtrlDevice(hwnd);

            SnapMonitorRect(pDevice, hwnd, (RECT*)lParam);
            ZeroMemory(&ti, sizeof(ti));
            ti.cbSize = sizeof(TOOLINFO);

            if (!pDevice->bTracking) {
                ToolTip_TrackPosition(ghwndToolTipTracking,
                                      ((LPRECT)lParam)->left+2,
                                      ((LPRECT)lParam)->top+2);
                TrackToolTip(pDevice, hwnd, TRUE);
            }

            if (ToolTip_GetCurrentTool(ghwndToolTipTracking, &ti) && pcmm)
            {
                TCHAR location[16];
                POINT pt;

                pcmm->GetMonitorPosition(pDevice, GetParent(hwnd), &pt);
                wnsprintf(location, ARRAYSIZE(location), TEXT("%d, %d"), pt.x, pt.y);

                ti.lpszText    = location;
                ti.rect.left   = ((RECT*)lParam)->left + 2;
                ti.rect.top    = ((RECT*)lParam)->top + 2;
                ti.rect.right  = ti.rect.left + 10;
                ti.rect.bottom = ti.rect.top + 10;

                ToolTip_SetToolInfo(ghwndToolTipTracking, &ti);
                ToolTip_TrackPosition(ghwndToolTipTracking, ti.rect.left, ti.rect.top);
                // SendMessage(ghwndToolTip, TTM_UPDATE, 0, 0);
            }

            break;

        case WM_EXITSIZEMOVE:
            //TraceMsg(TF_FUNC, "WM_EXITSIZEMOVE");
            pDevice = GetDlgCtrlDevice(hwnd);
            TrackToolTip(pDevice, hwnd, FALSE);

            //
            // We don't want to pop up any dialogs here because the modal size
            // loop is still active (it eats any mouse movements and the dialogs
            // can't be moved by the user).
            //
            PostMessage(hwnd, MM_MONITORMOVED, 0, 0);
            break;

        case MM_MONITORMOVED:
            pDevice = GetDlgCtrlDevice(hwnd);
            if (pcmm)
            {
                //
                // If the user moved the monitor, see if they want to attach it
                //
                if (!pcmm->QueryNoAttach() && pDevice && !pDevice->pds->IsAttached())
                {
                    if (pcmm->SetMonAttached(pDevice, TRUE, FALSE, hwnd))
                    {
                        pcmm->UpdateActiveDisplay(pDevice);
                    }
                }
                pcmm->HandleMonitorChange(hwnd, FALSE);
            }

            RedrawWindow(GetParent(hwnd), NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
            return TRUE;

        case WM_DESTROY:
            FlashText(hDlg, GetDlgCtrlDevice(hwnd), NULL,NULL,FALSE);
            SetWindowLong(hwnd, 0, NULL);
            break;

        case WM_ERASEBKGND:
            //GetClientRect(hwnd, &rc);
            //FillRect((HDC)wParam, &rc, GetSysColorBrush(COLOR_APPWORKSPACE));
            return 0L;

        case WM_PAINT:

            hdc = BeginPaint(hwnd,&ps);
            GetWindowText(hwnd, ach, ARRAYSIZE(ach));
            GetClientRect(hwnd, &rc);
            w = rc.right;
            h = rc.bottom;

            pDevice = GetDlgCtrlDevice(hwnd);

            BOOL fSelected = (pcmm ? (BOOL)(pDevice == pcmm->GetCurDevice()) : FALSE);

            if (pDevice->w != w || pDevice->h != h)
            {
                HBITMAP hbm, hbmMask;
                int cx,cy;

                pDevice->w = w;
                pDevice->h = h;

                ImageList_GetIconSize(pDevice->himl, &cx, &cy);
                MakeMonitorBitmap(w,h,ach,&hbm,&hbmMask,cx,cy, fSelected);
                ImageList_Replace(pDevice->himl,pDevice->iImage,hbm,hbmMask);

                DeleteObject(hbm);
                DeleteObject(hbmMask);
            }

            if (!pDevice->pds->IsAttached())
            {
                FillRect(hdc, &rc, GetSysColorBrush(COLOR_APPWORKSPACE));

                if (pcmm && fSelected)
                {
                    ImageList_DrawEx(pDevice->himl,pDevice->iImage,hdc,0,0,w,h,
                        CLR_DEFAULT,CLR_DEFAULT,ILD_BLEND25);
                }
                else
                {
                    ImageList_DrawEx(pDevice->himl,pDevice->iImage,hdc,0,0,w,h,
                        CLR_DEFAULT,CLR_NONE,ILD_BLEND50);
                }
            }
            else
            {
                    ImageList_DrawEx(pDevice->himl,pDevice->iImage,hdc,0,0,w,h,
                        CLR_DEFAULT,CLR_DEFAULT,ILD_IMAGE);
            }

            EndPaint(hwnd,&ps);
            return 0L;
    }

    return DefWindowProc(hwnd,msg,wParam,lParam);
}

LRESULT CALLBACK SliderSubWndProc (HWND hwndSlider, UINT uMsg, WPARAM wParam, LPARAM lParam, WPARAM uID, ULONG_PTR dwRefData)
{
    ASSERT(uID == 0);
    ASSERT(dwRefData == 0);

    switch (uMsg)
    {
        case WM_GETOBJECT:
            if ( lParam == OBJID_CLIENT )
            {
                // At this point we will try to load oleacc and get the functions
                // we need.
                if (!g_fAttemptedOleAccLoad)
                {
                    g_fAttemptedOleAccLoad = TRUE;

                    ASSERT(s_pfnCreateStdAccessibleProxy == NULL);
                    ASSERT(s_pfnLresultFromObject == NULL);

                    g_hOleAcc = LoadLibrary(TEXT("OLEACC"));
                    if (g_hOleAcc != NULL)
                    {
#ifdef UNICODE
                        s_pfnCreateStdAccessibleProxy = (PFNCREATESTDACCESSIBLEPROXY)
                                                    GetProcAddress(g_hOleAcc, "CreateStdAccessibleProxyW");
#else
                        s_pfnCreateStdAccessibleProxy = (PFNCREATESTDACCESSIBLEPROXY)
                                                    GetProcAddress(g_hOleAcc, "CreateStdAccessibleProxyA");
#endif
                        s_pfnLresultFromObject = (PFNLRESULTFROMOBJECT)
                                                    GetProcAddress(g_hOleAcc, "LresultFromObject");
                    }
                    if (s_pfnLresultFromObject == NULL || s_pfnCreateStdAccessibleProxy == NULL)
                    {
                        if (g_hOleAcc)
                        {
                            // No point holding on to Oleacc since we can't use it.
                            FreeLibrary(g_hOleAcc);
                            g_hOleAcc = NULL;
                        }
                        s_pfnLresultFromObject = NULL;
                        s_pfnCreateStdAccessibleProxy = NULL;
                    }
                }


                if (g_hOleAcc && s_pfnCreateStdAccessibleProxy && s_pfnLresultFromObject)
                {
                    IAccessible *pAcc = NULL;
                    HRESULT hr;

                    // Create default slider proxy.
                    hr = s_pfnCreateStdAccessibleProxy(
                            hwndSlider,
                            TEXT("msctls_trackbar32"),
                            OBJID_CLIENT,
                            IID_IAccessible,
                            (void **)&pAcc
                            );


                    if (SUCCEEDED(hr) && pAcc)
                    {
                        // now wrap it up in our customized wrapper...
                        IAccessible * pWrapAcc = new CAccessibleWrapper( hwndSlider, pAcc );
                        // Release our ref to proxy (wrapper has its own addref'd ptr)...
                        pAcc->Release();

                        if (pWrapAcc != NULL)
                        {

                            // ...and return the wrapper via LresultFromObject...
                            LRESULT lr = s_pfnLresultFromObject( IID_IAccessible, wParam, pWrapAcc );
                            // Release our interface pointer - OLEACC has its own addref to the object
                            pWrapAcc->Release();

                            // Return the lresult, which 'contains' a reference to our wrapper object.
                            return lr;
                            // All done!
                        }
                    // If it didn't work, fall through to default behavior instead.
                    }
                }
            }
            break;

        case WM_DESTROY:
            RemoveWindowSubclass(hwndSlider, SliderSubWndProc, uID);
            break;

    } /* end switch */

    return DefSubclassProc(hwndSlider, uMsg, wParam, lParam);
}


BOOL CSettingsPage::_AreExtraMonitorsDisabledOnPersonal(void)
{
    BOOL fIsDisabled = IsOS(OS_PERSONAL);

    if (fIsDisabled)
    {
        // POSSIBLE FUTURE REFINEMENT: Insert call to ClassicSystemParametersInfo() to see if there are video cards that we had to disable.
        fIsDisabled = FALSE;
    }

    return fIsDisabled;
}

// *** IShellPropSheetExt ***
HRESULT CSettingsPage::AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam)
{
    HRESULT hr = S_OK;

    PROPSHEETPAGE psp = {0};

    psp.dwSize = sizeof(psp);
    psp.hInstance = HINST_THISDLL;
    psp.dwFlags = PSP_DEFAULT;
    psp.lParam = (LPARAM) this;

    // GetSystemMetics(SM_CMONITORS) returns only the enabled monitors. So, we need to 
    // enumerate ourselves to determine if this is a multimonitor scenario. We have our own
    // function to do this.
    // Use the appropriate dlg template for multimonitor and single monitor configs.
    // if(ClassicGetSystemMetrics(SM_CMONITORS) > 1)
    //
    // PERF-WARNING: calling EnumDisplaySettingsEx() is a huge perf hit, so see if we can
    // findout if there is only one adapter with a cheaper call.
    DEBUG_CODE(DebugStartWatch());
    if (!_AreExtraMonitorsDisabledOnPersonal() && (ComputeNumberOfMonitorsFast(TRUE) > 1))
    {
        psp.pszTemplate = MAKEINTRESOURCE(DLG_MULTIMONITOR);
    }
    else
    {
        psp.pszTemplate = MAKEINTRESOURCE(DLG_SINGLEMONITOR);
    }
    DEBUG_CODE(TraceMsg(TF_THEMEUI_PERF, "CSettingsPage::AddPages() took Time=%lums", DebugStopWatch()));

    psp.pfnDlgProc = CSettingsPage::SettingsDlgProc;

    HPROPSHEETPAGE hpsp = CreatePropertySheetPage(&psp);
    if (hpsp)
    {
        if (pfnAddPage(hpsp, lParam))
        {
            hr = S_OK;
        }
        else
        {
            DestroyPropertySheetPage(hpsp);
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CSettingsPage::ReplacePage(IN EXPPS uPageID, IN LPFNSVADDPROPSHEETPAGE pfnReplaceWith, IN LPARAM lParam)
{
    return E_NOTIMPL;
}

// *** IObjectWithSite ***
HRESULT CSettingsPage::SetSite(IN IUnknown * punkSite)
{
    if (_pThemeUI)
    {
        _pThemeUI->Release();
        _pThemeUI = NULL;
    }

    if (punkSite)
    {
        punkSite->QueryInterface(IID_PPV_ARG(IThemeUIPages, &_pThemeUI));
    }


    return CObjectWithSite::SetSite(punkSite);
}

// *** IPropertyBag ***
HRESULT CSettingsPage::Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog)
{
    HRESULT hr = E_INVALIDARG;

    return hr;
}


HRESULT CSettingsPage::Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar)
{
    HRESULT hr = E_INVALIDARG;

    return hr;
}


// *** IBasePropPage ***
HRESULT CSettingsPage::GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog)
{
    if (ppAdvDialog)
    {
        *ppAdvDialog = NULL;
    }

    return E_NOTIMPL;
}


HRESULT CSettingsPage::OnApply(IN PROPPAGEONAPPLY oaAction)
{
    if (IsDirty() && !_nInApply)
    {
        int status;

        _nInApply++;
        // Apply the settings, and enable\disable the Apply button
        // appropriatly.
        CDisplaySettings *rgpds[MONITORS_MAX];
        ULONG           iDevice;

        for (iDevice = 0; iDevice < _NumDevices; iDevice++) {
            rgpds[iDevice] = _Devices[iDevice].pds;
        }

        status = _DisplaySaveSettings(rgpds, _NumDevices, _hDlg);

        SetDirty(status < 0);

        if (status == DISP_CHANGE_RESTART)
        {
            PropSheet_RestartWindows(ghwndPropSheet);
        }
        else if (_pCurDevice && (status == DISP_CHANGE_SUCCESSFUL))
        {
            UINT iDevice;
            TCHAR szDeviceName[32];

            ASSERT(sizeof(szDeviceName) >=
                   sizeof(_pCurDevice->DisplayDevice.DeviceName));

            lstrcpy(szDeviceName, _pCurDevice->DisplayDevice.DeviceName);
            _InitDisplaySettings(FALSE);
            for (iDevice = 0; iDevice < _NumDevices; iDevice++)
            {
                if (lstrcmp(_Devices[iDevice].DisplayDevice.DeviceName, szDeviceName) == 0)
                {
                    UpdateActiveDisplay(_Devices + iDevice);
                    break;
                }
            }
        }
        else
        {
            // Make sure the dialog stays and redraw
            _InitDisplaySettings(FALSE);
            UpdateActiveDisplay(NULL);
            SetWindowLongPtr(_hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
        }

        _nInApply--;
    }

    return S_OK;
}


HRESULT CSettingsPage_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT LPVOID * ppvObj)
{
    HRESULT hr = E_INVALIDARG;

    if (!punkOuter && ppvObj)
    {
        CSettingsPage * pThis = new CSettingsPage();

        *ppvObj = NULL;
        if (pThis)
        {
            hr = pThis->QueryInterface(riid, ppvObj);
            pThis->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


VOID CheckForDuplicateAppletExtensions(HKEY hkDriver)
{
    DWORD dwCheckForDuplicates = 0, cb = sizeof(DWORD), Len = 0;
    HKEY hkExtensions = (HKEY)INVALID_HANDLE_VALUE;
    PAPPEXT pAppExtTemp = NULL, pAppExt = NULL;
    PTCHAR pmszAppExt = NULL;

    if (RegQueryValueEx(hkDriver,
                        TEXT("DeskCheckForDuplicates"),
                        NULL,
                        NULL,
                        (LPBYTE)(&dwCheckForDuplicates),
                        &cb) == ERROR_SUCCESS) 
    {
        RegDeleteValue(hkDriver, TEXT("DeskCheckForDuplicates"));
    }

    if (dwCheckForDuplicates != 1) 
        return;

    if (RegOpenKeyEx(hkDriver,
                     TEXT("Display\\shellex\\PropertySheetHandlers"),
                     0,
                     KEY_READ,
                     &hkExtensions) != ERROR_SUCCESS) 
    {
        hkExtensions = (HKEY)INVALID_HANDLE_VALUE;
        goto Fallout;
    }

    DeskAESnapshot(hkExtensions, &pAppExt);
    
    if (pAppExt != NULL) 
    {
        pAppExtTemp = pAppExt;
        Len = 0;
        while (pAppExtTemp) 
        {
            Len += lstrlen(pAppExtTemp->szDefaultValue) + 1;
            pAppExtTemp = pAppExtTemp->pNext;
        }

        pmszAppExt = (PTCHAR)LocalAlloc(LPTR, (Len + 1) * sizeof(TCHAR));
        if (pmszAppExt != NULL) 
        {
            pAppExtTemp = pAppExt;
            Len = 0;
            while (pAppExtTemp) 
            {
                lstrcpy(pmszAppExt + Len, pAppExtTemp->szDefaultValue);
                Len += lstrlen(pAppExtTemp->szDefaultValue) + 1;
                pAppExtTemp = pAppExtTemp->pNext;
            }

            
            DeskAEDelete(REGSTR_PATH_CONTROLSFOLDER TEXT("\\Display\\shellex\\PropertySheetHandlers"),
                         pmszAppExt);
            
            DeskAEDelete(REGSTR_PATH_CONTROLSFOLDER TEXT("\\Device\\shellex\\PropertySheetHandlers"),
                         pmszAppExt);

            LocalFree(pmszAppExt);
        }

        DeskAECleanup(pAppExt);
    }

Fallout:

    if (hkExtensions != INVALID_HANDLE_VALUE)
    {
        RegCloseKey(hkExtensions);
    }
}


VOID
DeskAESnapshot(
    HKEY hkExtensions,
    PAPPEXT* ppAppExt
    )
{
    HKEY hkSubkey = 0;
    DWORD index = 0;
    DWORD ulSize = MAX_PATH;
    APPEXT AppExtTemp;
    PAPPEXT pAppExtBefore = NULL;
    PAPPEXT pAppExtTemp = NULL;

    ulSize = sizeof(AppExtTemp.szKeyName) / sizeof(TCHAR);
    while (RegEnumKeyEx(hkExtensions, 
                        index, 
                        AppExtTemp.szKeyName, 
                        &ulSize, 
                        NULL, 
                        NULL, 
                        NULL, 
                        NULL) == ERROR_SUCCESS) {

            if (RegOpenKeyEx(hkExtensions,
                             AppExtTemp.szKeyName,
                             0,
                             KEY_READ,
                             &hkSubkey) == ERROR_SUCCESS) {

                ulSize = sizeof(AppExtTemp.szDefaultValue);
                if ((RegQueryValueEx(hkSubkey,
                                     NULL,
                                     0,
                                     NULL,
                                     (PBYTE)AppExtTemp.szDefaultValue,
                                     &ulSize) == ERROR_SUCCESS) && 
                    (AppExtTemp.szDefaultValue[0] != TEXT('\0'))) {

                    PAPPEXT pAppExt = (PAPPEXT)LocalAlloc(LPTR, sizeof(APPEXT));
                    
                    if (pAppExt != NULL) {

                        *pAppExt = AppExtTemp;

                        pAppExtBefore = pAppExtTemp = *ppAppExt;
                        
                        while((pAppExtTemp != NULL) &&
                              (lstrcmpi(pAppExtTemp->szDefaultValue,
                                        pAppExt->szDefaultValue) < 0)) {

                            pAppExtBefore = pAppExtTemp;
                            pAppExtTemp = pAppExtTemp->pNext;
                        }

                        if (pAppExtBefore != pAppExtTemp) {
                        
                            pAppExt->pNext = pAppExtBefore->pNext;
                            pAppExtBefore->pNext = pAppExt;

                        } else {

                            pAppExt->pNext = *ppAppExt;
                            *ppAppExt = pAppExt;
                        }
                    }
                }

                RegCloseKey(hkSubkey);
            }

        ulSize = sizeof(AppExtTemp.szKeyName) / sizeof(TCHAR);
        index++;
    }
}


VOID
DeskAEDelete(
    PTCHAR szDeleteFrom,
    PTCHAR mszExtensionsToRemove
    )
{
    TCHAR szKeyName[MAX_PATH];
    HKEY  hkDeleteFrom, hkExt;
    DWORD cSubKeys = 0, cbSize = 0;
    TCHAR szDefaultValue[MAX_PATH];
    PTCHAR szValue;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                     szDeleteFrom, 
                     0,
                     KEY_ALL_ACCESS,
                     &hkDeleteFrom) == ERROR_SUCCESS) {

        if (RegQueryInfoKey(hkDeleteFrom, 
                            NULL,
                            NULL,
                            NULL,
                            &cSubKeys,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL) == ERROR_SUCCESS) {
        
            while (cSubKeys--) {
        
                if (RegEnumKey(hkDeleteFrom, 
                               cSubKeys, 
                               szKeyName, 
                               ARRAYSIZE(szKeyName)) == ERROR_SUCCESS) {
        
                    int iComp = -1;
        
                    if (RegOpenKeyEx(hkDeleteFrom,
                                     szKeyName,
                                     0,
                                     KEY_READ,
                                     &hkExt) == ERROR_SUCCESS) {
        
                        cbSize = sizeof(szDefaultValue);
                        if ((RegQueryValueEx(hkExt,
                                             NULL,
                                             0,
                                             NULL,
                                             (PBYTE)szDefaultValue,
                                             &cbSize) == ERROR_SUCCESS) &&
                            (szDefaultValue[0] != TEXT('\0'))) {
        
                            szValue = mszExtensionsToRemove;
        
                            while (*szValue != TEXT('\0')) {
                            
                                iComp = lstrcmpi(szDefaultValue, szValue);
        
                                if (iComp <= 0) {
                                    break;
                                }
        
                                while (*szValue != TEXT('\0')) 
                                    szValue++;

                                szValue++;
                            }
                        }
        
                        RegCloseKey(hkExt);
                    }
        
                    if (iComp == 0) {
                    
                        SHDeleteKey(hkDeleteFrom, szKeyName);
                    }
                }
            }
        }

        RegCloseKey(hkDeleteFrom);
    }
} 


VOID
DeskAECleanup(
    PAPPEXT pAppExt
    )
{
    PAPPEXT pAppExtTemp;

    while (pAppExt) {
        pAppExtTemp = pAppExt->pNext;
        LocalFree(pAppExt);
        pAppExt = pAppExtTemp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\themefile.cpp ===
/*****************************************************************************\
    FILE: ThemeFile.cpp

    DESCRIPTION:
        This is the Autmation Object to theme scheme object.

    BryanSt 4/3/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <atlbase.h>
#include <mmsystem.h>
#include "ThSettingsPg.h"
#include "ThemeFile.h"



LPCTSTR s_pszCursorArray[SIZE_CURSOR_ARRAY] =
{   // different cursors
   TEXT("Arrow"),
   TEXT("Help"),
   TEXT("AppStarting"),
   TEXT("Wait"),
   TEXT("NWPen"),
   TEXT("No"),
   TEXT("SizeNS"),
   TEXT("SizeWE"),
   TEXT("Crosshair"),
   TEXT("IBeam"),
   TEXT("SizeNWSE"),
   TEXT("SizeNESW"),
   TEXT("SizeAll"),
   TEXT("UpArrow"),
   TEXT("Link"),
};


// This is a list of string pairs.  The first string in the pair is the RegKey and the second is the default sound.
// NULL means to delete the key.  If you use an environment string other than "%SystemRoot%", you need to
// update _ApplySounds();
#define SOUND_DEFAULT    (UINT)-1

THEME_FALLBACK_VALUES s_ThemeSoundsValues[SIZE_SOUNDS_ARRAY] =
{
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\.Default\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\AppGPFault\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\Close\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\DeviceConnect\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\DeviceDisconnect\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\DeviceFail\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\LowBatteryAlarm\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\MailBeep\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\Maximize\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\MenuCommand\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\MenuPopup\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\Minimize\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\Open\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\PrintComplete\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\RestoreDown\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\RestoreUp\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\RingIn\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\Ringout\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\SystemAsterisk\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\SystemExclamation\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\SystemExit\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\SystemHand\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\SystemNotification\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\SystemQuestion\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\SystemStart\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\SystemStartMenu\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\WindowsLogoff\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\.Default\\WindowsLogon\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\Explorer\\EmptyRecycleBin\\.Current"), SOUND_DEFAULT},
    {TEXT("AppEvents\\Schemes\\Apps\\Explorer\\Navigating\\.Current"), SOUND_DEFAULT},
};



//===========================
// *** Class Internals & Helpers ***
//===========================
BOOL CThemeFile::_IsCached(IN BOOL fLoading)
{
    DWORD dwCache = 0;

    dwCache |= _IsFiltered(THEMEFILTER_COLORS);
    dwCache |= _IsFiltered(THEMEFILTER_SMSTYLES) << 1;
    dwCache |= _IsFiltered(THEMEFILTER_SMSIZES) << 2;

    BOOL fIsCached = (dwCache == m_dwCachedState);
    if (fLoading)
    {
        m_dwCachedState = dwCache;
    }

    return fIsCached;
}


HRESULT CThemeFile::_GetCustomFont(LPCTSTR pszFontName, LOGFONT * pLogFont)
{
    HRESULT hr = S_OK;
    TCHAR szFont[MAX_PATH];
    
    if (GetPrivateProfileString(SZ_INISECTION_METRICS, pszFontName, SZ_EMPTY, szFont, ARRAYSIZE(szFont), m_pszThemeFile) &&
        szFont[0])
    {
        if (TEXT('@') == szFont[0])     // Is the string indirect for MUI?
        {
            TCHAR szTemp[MAX_PATH];

            if (SUCCEEDED(SHLoadIndirectString(szFont, szTemp, ARRAYSIZE(szTemp), NULL)))
            {
                StrCpyN(szFont, szTemp, ARRAYSIZE(szFont));
            }
        }

        if (TEXT('{') == szFont[0])
        {
            LPTSTR pszStart = &szFont[1];
            BOOL fHasMore = TRUE;

            LPTSTR pszEnd = StrChr(pszStart, TEXT(','));
            if (!pszEnd)
            {
                pszEnd = StrChr(pszStart, TEXT('}'));
                fHasMore = FALSE;
            }

            if (pszEnd)
            {
                pszEnd[0] = 0;  // Terminate Name.

                StrCpyN(pLogFont->lfFaceName, pszStart, ARRAYSIZE(pLogFont->lfFaceName));
                if (fHasMore)
                {
                    pszStart = &pszEnd[1];
                    pszEnd = StrStr(pszStart, TEXT("pt"));
                    if (pszEnd)
                    {
                        TCHAR szTemp[MAX_PATH];

                        pszEnd[0] = 0;  // Terminate Name.
                        pszEnd += 2;    // Skip past the "pt"

                        StrCpyN(szTemp, pszStart, ARRAYSIZE(szTemp));
                        PathRemoveBlanks(szTemp);

                        pLogFont->lfHeight = -MulDiv(StrToInt(szTemp), DPI_PERSISTED, 72);      // Map pt size to lfHeight
                        pLogFont->lfHeight = min(-3, pLogFont->lfHeight);        // Make sure the font doesn't get too small
                        pLogFont->lfHeight = max(-100, pLogFont->lfHeight);      // Make sure the font doesn't get too large
                        if (TEXT(',') == pszEnd[0])
                        {
                            pszStart = &pszEnd[1];
                            pszEnd = StrChr(pszStart, TEXT('}'));
                            if (pszEnd)
                            {
                                pszEnd[0] = 0;  // Terminate Name.
                
                                pLogFont->lfCharSet = (BYTE) StrToInt(pszStart);
                            }
                        }
                    }
                }
            }
        }
    }

    return hr;
}


HRESULT CThemeFile::_LoadCustomFonts(void)
{
    _GetCustomFont(TEXT("CaptionFont"), &(m_systemMetrics.schemeData.ncm.lfCaptionFont));
    _GetCustomFont(TEXT("SmCaptionFont"), &(m_systemMetrics.schemeData.ncm.lfSmCaptionFont));
    _GetCustomFont(TEXT("MenuFont"), &(m_systemMetrics.schemeData.ncm.lfMenuFont));
    _GetCustomFont(TEXT("StatusFont"), &(m_systemMetrics.schemeData.ncm.lfStatusFont));
    _GetCustomFont(TEXT("MessageFont"), &(m_systemMetrics.schemeData.ncm.lfMessageFont));
    _GetCustomFont(TEXT("IconFont"), &(m_systemMetrics.schemeData.lfIconTitle));

    return S_OK;
}


// Load the settings in memory
HRESULT CThemeFile::_LoadLiveSettings(int * pnDPI)
{
    HRESULT hr = S_OK;

    if (m_pszThemeFile)
    {
        if (pnDPI)
        {
            *pnDPI = DPI_PERSISTED;
        }

        // Get property bag with default settings.
        if (_punkSite)
        {
            IPropertyBag * pPropertyBag;

            hr = _punkSite->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
            if (SUCCEEDED(hr))
            {
                hr = SHPropertyBag_ReadByRef(pPropertyBag, SZ_PBPROP_SYSTEM_METRICS, (void *)&m_systemMetrics, sizeof(m_systemMetrics));

                if (pnDPI && FAILED(SHPropertyBag_ReadInt(pPropertyBag, SZ_PBPROP_DPI_MODIFIED_VALUE, pnDPI)))
                {
                    *pnDPI = DPI_PERSISTED;    // Default to the default DPI.
                }
                pPropertyBag->Release();
            }
        }
    }

    return hr;
}


// Load the settings in the .theme file.
HRESULT CThemeFile::_LoadSettings(void)
{
    int nCurrentDPI = DPI_PERSISTED;
    HRESULT hr = _LoadLiveSettings(&nCurrentDPI);

    if (m_pszThemeFile)
    {
        BOOL fFontsFilter = _IsFiltered(THEMEFILTER_SMSTYLES);
        TCHAR szIconMetrics[2048];

        if (m_systemMetrics.nIcon && m_systemMetrics.nSmallIcon)
        {
            ////////////////////////////////////////////
            // Get the icon Metrics
            DWORD cchSize = GetPrivateProfileString(SZ_INISECTION_METRICS, SZ_INIKEY_ICONMETRICS, SZ_EMPTY, szIconMetrics, ARRAYSIZE(szIconMetrics), m_pszThemeFile);
            // if we somehow come up with no icon metrics in the theme, just
            // PUNT and leave cur settings
            if (szIconMetrics[0])
            {                   // if something there to set
                ICONMETRICSA iconMetricsA;

                // translate stored data string to ICONMETRICS bytes
                if ((sizeof(iconMetricsA) == WriteBytesToBuffer(szIconMetrics, (void *)&iconMetricsA, sizeof(iconMetricsA))) &&  // char str read from and binary bytes
                    (sizeof(iconMetricsA) == iconMetricsA.cbSize))
                {
                    // ICONMETRICS are stored in ANSI format in the Theme file so if
                    // we're living in a UNICODE world we need to convert from ANSI
                    // to UNICODE
                    ICONMETRICSW iconMetricsW;

                    if (!fFontsFilter)
                    {
                        ConvertIconMetricsToWIDE(&iconMetricsA, &iconMetricsW);
                        m_systemMetrics.schemeData.lfIconTitle = iconMetricsW.lfFont;
                    }
                }
            }


            ////////////////////////////////////////////
            // Get Non-Client Metrics
            cchSize = GetPrivateProfileString(SZ_INISECTION_METRICS, SZ_INIKEY_NONCLIENTMETRICS, SZ_EMPTY, szIconMetrics, ARRAYSIZE(szIconMetrics), m_pszThemeFile);
            // if we somehow come up with no icon metrics in the theme, just
            // PUNT and leave cur settings
            if (szIconMetrics[0])
            {
                BOOL fBordersFilter = _IsFiltered(THEMEFILTER_SMSIZES);
                NONCLIENTMETRICSA nonClientMetrics;

                // if something there to set
                // translate stored data string to ICONMETRICS bytes
                if ((sizeof(nonClientMetrics) == WriteBytesToBuffer(szIconMetrics, (void *)&nonClientMetrics, sizeof(nonClientMetrics))) &&  // char str read from and binary bytes
                    (sizeof(nonClientMetrics) == nonClientMetrics.cbSize))
                {
                    // ICONMETRICS are stored in ANSI format in the Theme file so if
                    // we're living in a UNICODE world we need to convert from ANSI
                    // to UNICODE
                    NONCLIENTMETRICSW nonClientMetricsW = {0};

                    ConvertNCMetricsToWIDE(&nonClientMetrics, &nonClientMetricsW);
                    nonClientMetricsW.cbSize = sizeof(nonClientMetricsW); // paranoid

                    // what we reset if the user checks Font names and styles
                    if (!fFontsFilter)
                    {
                        // only (some) font information
                        TransmitFontCharacteristics(&(m_systemMetrics.schemeData.ncm.lfCaptionFont), &(nonClientMetricsW.lfCaptionFont), TFC_STYLE);
                        TransmitFontCharacteristics(&(m_systemMetrics.schemeData.ncm.lfSmCaptionFont), &(nonClientMetricsW.lfSmCaptionFont), TFC_STYLE);
                        TransmitFontCharacteristics(&(m_systemMetrics.schemeData.ncm.lfMenuFont), &(nonClientMetricsW.lfMenuFont), TFC_STYLE);
                        TransmitFontCharacteristics(&(m_systemMetrics.schemeData.ncm.lfStatusFont), &(nonClientMetricsW.lfStatusFont), TFC_STYLE);
                        TransmitFontCharacteristics(&(m_systemMetrics.schemeData.ncm.lfMessageFont), &(nonClientMetricsW.lfMessageFont), TFC_STYLE);
                    }

                    // what we reset if the user checks Font and window si&zes
                    if (!fBordersFilter)
                    {
                        // fonts
                        TransmitFontCharacteristics(&(m_systemMetrics.schemeData.ncm.lfCaptionFont), &(nonClientMetricsW.lfCaptionFont), TFC_SIZE);
                        TransmitFontCharacteristics(&(m_systemMetrics.schemeData.ncm.lfSmCaptionFont), &(nonClientMetricsW.lfSmCaptionFont), TFC_SIZE);
                        TransmitFontCharacteristics(&(m_systemMetrics.schemeData.ncm.lfMenuFont), &(nonClientMetricsW.lfMenuFont), TFC_SIZE);
                        TransmitFontCharacteristics(&(m_systemMetrics.schemeData.ncm.lfStatusFont), &(nonClientMetricsW.lfStatusFont), TFC_SIZE);
                        TransmitFontCharacteristics(&(m_systemMetrics.schemeData.ncm.lfMessageFont), &(nonClientMetricsW.lfMessageFont), TFC_SIZE);

                        // Since we are copying the font sizes, scale them to the current DPI.
                        // window elements sizes
                        m_systemMetrics.schemeData.ncm.iBorderWidth = nonClientMetricsW.iBorderWidth;
                        m_systemMetrics.schemeData.ncm.iScrollWidth = nonClientMetricsW.iScrollWidth;
                        m_systemMetrics.schemeData.ncm.iScrollHeight = nonClientMetricsW.iScrollHeight;
                        m_systemMetrics.schemeData.ncm.iCaptionWidth = nonClientMetricsW.iCaptionWidth;
                        m_systemMetrics.schemeData.ncm.iCaptionHeight = nonClientMetricsW.iCaptionHeight;
                        m_systemMetrics.schemeData.ncm.iSmCaptionWidth = nonClientMetricsW.iSmCaptionWidth;
                        m_systemMetrics.schemeData.ncm.iSmCaptionHeight = nonClientMetricsW.iSmCaptionHeight;
                        m_systemMetrics.schemeData.ncm.iMenuWidth = nonClientMetricsW.iMenuWidth;
                        m_systemMetrics.schemeData.ncm.iMenuHeight = nonClientMetricsW.iMenuHeight;

                        // Local custom fonts
                        _LoadCustomFonts();

                        if (nCurrentDPI != DPI_PERSISTED)
                        {
                            LogSystemMetrics("CThemeFile::_LoadSettings() BEFORE Loading from .theme", &m_systemMetrics);
                            DPIConvert_SystemMetricsAll(TRUE, &m_systemMetrics, DPI_PERSISTED, nCurrentDPI);
                            LogSystemMetrics("CThemeFile::_LoadSettings() AFTER Loading from .theme", &m_systemMetrics);
                        }

                        // CHARSET: In Win2k, fontfix.cpp was used as a hack to change the CHARSET from one language to another.
                        // That doesn't work for many reasons: a) not called on roaming, b) not called for OS lang changes, 
                        // c) won't fix the problem for strings with multiple languages, d) etc.
                        // Therefore, the SHELL team (BryanSt) had the NTUSER team (MSadek) agree to use DEFAULT_CHARSET all the time.
                        // If some app has bad logic testing the charset parameter, then the NTUSER team will shim that app to fix it.
                        // The shim would be really simple, on the return from a SystemParametersInfo(SPI_GETNONCLIENTMETRICS or ICONFONTS)
                        // just patch the lfCharSet param to the current charset.

                        // For all CHARSETs to DEFAULT_CHARSET
                        m_systemMetrics.schemeData.ncm.lfCaptionFont.lfCharSet = DEFAULT_CHARSET;
                        m_systemMetrics.schemeData.ncm.lfSmCaptionFont.lfCharSet = DEFAULT_CHARSET;
                        m_systemMetrics.schemeData.ncm.lfMenuFont.lfCharSet = DEFAULT_CHARSET;
                        m_systemMetrics.schemeData.ncm.lfStatusFont.lfCharSet = DEFAULT_CHARSET;
                        m_systemMetrics.schemeData.ncm.lfMessageFont.lfCharSet = DEFAULT_CHARSET;
                        m_systemMetrics.schemeData.lfIconTitle.lfCharSet = DEFAULT_CHARSET;
                    }
                }
            }


            ////////////////////////////////////////////
            // Get Colors
            BOOL fGrad = FALSE;         // Are gradient captions enabled?
            int nIndex;
            BOOL fColorFilter = _IsFiltered(THEMEFILTER_COLORS);

            ClassicSystemParametersInfo(SPI_GETGRADIENTCAPTIONS, 0, (LPVOID)&fGrad, 0);    // Init fGrad
            if (!fColorFilter)
            {
                for (nIndex = 0; nIndex < ARRAYSIZE(s_pszColorNames); nIndex++)
                {
                    TCHAR szColor[MAX_PATH];

                    // get string from theme
                    DWORD ccbSize = GetPrivateProfileString(SZ_INISECTION_COLORS, s_pszColorNames[nIndex], SZ_EMPTY, szColor, ARRAYSIZE(szColor), m_pszThemeFile);
                    if (!ccbSize || !szColor[0])
                    {
                        if ((nIndex == COLOR_GRADIENTACTIVECAPTION) && !szColor[0])
                        {
                            // They didn't specify the COLOR_GRADIENTACTIVECAPTION color, so use COLOR_ACTIVECAPTION
                            ccbSize = GetPrivateProfileString(SZ_INISECTION_COLORS, s_pszColorNames[COLOR_ACTIVECAPTION], SZ_EMPTY, szColor, ARRAYSIZE(szColor), m_pszThemeFile);
                        }
                        if ((nIndex == COLOR_GRADIENTINACTIVECAPTION) && !szColor[0])
                        {
                            // They didn't specify the COLOR_GRADIENTINACTIVECAPTION color, so use COLOR_INACTIVECAPTION
                            ccbSize = GetPrivateProfileString(SZ_INISECTION_COLORS, s_pszColorNames[COLOR_INACTIVECAPTION], SZ_EMPTY, szColor, ARRAYSIZE(szColor), m_pszThemeFile);
                        }
                    }

                    if (ccbSize && szColor[0])
                    {
                        m_systemMetrics.schemeData.rgb[nIndex] = RGBStringToColor(szColor);
                    }
                }
            }
        }
        else
        {
            AssertMsg((NULL != _punkSite), TEXT("The caller needs to set our site or we can't succeed because we can't find out the icon size."));
            hr = E_INVALIDARG;
        }

        hr = S_OK;
    }

    return hr;
}


HRESULT CThemeFile::_SaveSystemMetrics(SYSTEMMETRICSALL * pSystemMetrics)
{
    HRESULT hr = _LoadSettings();

    AssertMsg((NULL != m_pszThemeFile), TEXT("We don't have a file specified yet."));
    if (SUCCEEDED(hr) && m_pszThemeFile)
    {
        int nCurrentDPI = DPI_PERSISTED;

        _LoadLiveSettings(&nCurrentDPI);
        hr = SystemMetricsAll_Copy(pSystemMetrics, &m_systemMetrics);
        if (SUCCEEDED(hr))
        {
            // Write the following:
            LPWSTR pszStringOut;
            NONCLIENTMETRICSA nonClientMetricsA = {0};
            SYSTEMMETRICSALL systemMetricsPDPI;     // SYSMETS in persist DPI

            SystemMetricsAll_Copy(pSystemMetrics, &systemMetricsPDPI);
            // Scale the values so they are persisted in a DPI independent way.  (A.k.a., in 96 DPI)
            LogSystemMetrics("CThemeFile::_SaveSystemMetrics() BEFORE scale to P-DPI for .theme file", &systemMetricsPDPI);
            DPIConvert_SystemMetricsAll(TRUE, &systemMetricsPDPI, nCurrentDPI, DPI_PERSISTED);
            LogSystemMetrics("CThemeFile::_SaveSystemMetrics() AFTER scale to P-DPI for .theme file", &systemMetricsPDPI);

            ConvertNCMetricsToANSI(&(systemMetricsPDPI.schemeData.ncm), &nonClientMetricsA);

            // #1 "NonclientMetrics"
            hr = ConvertBinaryToINIByteString((BYTE *)&nonClientMetricsA, sizeof(nonClientMetricsA), &pszStringOut);
            if (SUCCEEDED(hr))
            {
                hr = _putThemeSetting(SZ_INISECTION_METRICS, SZ_INIKEY_NONCLIENTMETRICS, FALSE, pszStringOut);
                LocalFree(pszStringOut);

                if (SUCCEEDED(hr))
                {
                    // #2 "IconMetrics"
                    ICONMETRICSA iconMetricsA;

                    iconMetricsA.cbSize = sizeof(iconMetricsA);
                    GetIconMetricsFromSysMetricsAll(&systemMetricsPDPI, &iconMetricsA, sizeof(iconMetricsA));
                    hr = ConvertBinaryToINIByteString((BYTE *)&iconMetricsA, sizeof(iconMetricsA), &pszStringOut);
                    if (SUCCEEDED(hr))
                    {
                        hr = _putThemeSetting(SZ_INISECTION_METRICS, SZ_INIKEY_ICONMETRICS, FALSE, pszStringOut);
                        if (SUCCEEDED(hr))
                        {
                            int nIndex;

                            for (nIndex = 0; nIndex < ARRAYSIZE(s_pszColorNames); nIndex++)
                            {
                                LPWSTR pszColor;
                                DWORD dwColor = systemMetricsPDPI.schemeData.rgb[nIndex];

                                hr = ConvertBinaryToINIByteString((BYTE *)&dwColor, 3, &pszColor);
                                if (SUCCEEDED(hr))
                                {
                                    DWORD cchSize = lstrlen(pszColor);

                                    if (L' ' == pszColor[cchSize - 1])
                                    {
                                        pszColor[cchSize - 1] = 0;
                                    }

                                    hr = HrWritePrivateProfileStringW(SZ_INISECTION_COLORS, s_pszColorNames[nIndex], pszColor, m_pszThemeFile);
                                    LocalFree(pszColor);
                                }
                            }

                            // Delete the MUI version of the fonts because we just got new NONCLIENTMETRICs
                            _putThemeSetting(SZ_INISECTION_METRICS, TEXT("CaptionFont"), FALSE, NULL);
                            _putThemeSetting(SZ_INISECTION_METRICS, TEXT("SmCaptionFont"), FALSE, NULL);
                            _putThemeSetting(SZ_INISECTION_METRICS, TEXT("MenuFont"), FALSE, NULL);
                            _putThemeSetting(SZ_INISECTION_METRICS, TEXT("StatusFont"), FALSE, NULL);
                            _putThemeSetting(SZ_INISECTION_METRICS, TEXT("MessageFont"), FALSE, NULL);
                            _putThemeSetting(SZ_INISECTION_METRICS, TEXT("IconFont"), FALSE, NULL);
                        }
                        LocalFree(pszStringOut);
                    }
                }
            }
        }
    }

    return hr;
}


BOOL CThemeFile::_IsFiltered(IN DWORD dwFilter)
{
    BOOL fFiltered = FALSE;

    // Get property bag with default settings.
    if (_punkSite)
    {
        IPropertyBag * pPropertyBag;

        HRESULT hr = _punkSite->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
        if (SUCCEEDED(hr))
        {
            fFiltered = !SHPropertyBag_ReadBOOLDefRet(pPropertyBag, g_szCBNames[dwFilter], FALSE);
            pPropertyBag->Release();
        }
    }

    return fFiltered;
}


HRESULT CThemeFile::_ApplySounds(void)
{
    HRESULT hr = S_OK;

    if (!_IsFiltered(THEMEFILTER_SOUNDS))
    {
        int nIndex;

        for (nIndex = 0; nIndex < ARRAYSIZE(s_ThemeSoundsValues); nIndex++)
        {
            CComBSTR bstrPath;

            hr = _GetSound(s_ThemeSoundsValues[nIndex].pszRegKey, &bstrPath);
            if (SUCCEEDED(hr))
            {
                DWORD dwError = SHRegSetPathW(HKEY_CURRENT_USER, s_ThemeSoundsValues[nIndex].pszRegKey, NULL, bstrPath, 0);
                hr = HRESULT_FROM_WIN32(dwError);
            }
            else
            {

                // First delete the value because we many need to switch from REG_SZ to REG_EXPAND_SZ
                // Ignore if this fails
                HrRegDeleteValue(HKEY_CURRENT_USER, s_ThemeSoundsValues[nIndex].pszRegKey, NULL);
                hr = E_FAIL;

                // The file didn't specify what to use, so reset to the default values.
                if (s_ThemeSoundsValues[nIndex].nResourceID)
                {
                    // Use the specified value.
                    TCHAR szReplacement[MAX_PATH];
                    DWORD dwType;
                    DWORD cbSize;

                    if (s_ThemeSoundsValues[nIndex].nResourceID == SOUND_DEFAULT)
                    {
                        TCHAR szDefaultKey[MAX_PATH];
                        StrCpy(szDefaultKey, s_ThemeSoundsValues[nIndex].pszRegKey);

                        LPTSTR p = szDefaultKey + lstrlen(szDefaultKey) - ARRAYSIZE(L".Current") + 1;

                        // Replace ".Current" with ".default"
                        if (*p == L'.')
                        {
                            StrCpy(p, L".Default");
                            cbSize = sizeof szReplacement;
                            hr = HrSHGetValue(HKEY_CURRENT_USER, szDefaultKey, NULL, &dwType, (LPVOID) szReplacement, &cbSize);
                            if (SUCCEEDED(hr))
                            {
                                PathUnExpandEnvStringsWrap(szReplacement, ARRAYSIZE(szReplacement));
                            }
                        }
                    }
                    else
                    {
                        if (0 != LoadString(HINST_THISDLL, s_ThemeSoundsValues[nIndex].nResourceID, szReplacement, ARRAYSIZE(szReplacement)))
                        {
                            hr = S_OK;
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        dwType = (StrStrW(szReplacement, L"%SystemRoot%")) ? REG_EXPAND_SZ : REG_SZ;
                        cbSize = ((lstrlen(szReplacement) + 1) * sizeof(szReplacement[0]));

                        hr = HrSHSetValue(HKEY_CURRENT_USER, s_ThemeSoundsValues[nIndex].pszRegKey, NULL, dwType, (LPVOID) szReplacement, cbSize);
                    }
                }
                else
                {
                    // We leave the value deleted because the default was empty.
                }
            }
        }

        hr = S_OK;  // We don't care if it fails.

        // Need to flush buffer and ensure new sounds used for next events
        sndPlaySoundW(NULL, SND_ASYNC | SND_NODEFAULT);

        // Clear the current pointer scheme string from the registry so that Mouse
        // cpl doesn't display a bogus name.  Don't care if this fails.
        RegSetValue(HKEY_CURRENT_USER, SZ_REGKEY_SOUNDS, REG_SZ, TEXT(".current"), 0);
    }

    return hr;
}


HRESULT CThemeFile::_ApplyCursors(void)
{
    HRESULT hr = S_OK;

    if (!_IsFiltered(THEMEFILTER_CURSORS))
    {
        int nIndex;

        for (nIndex = 0; nIndex < ARRAYSIZE(s_pszCursorArray); nIndex++)
        {
            BSTR bstrPath;
            hr = _getThemeSetting(SZ_INISECTION_CURSORS, s_pszCursorArray[nIndex], THEMESETTING_LOADINDIRECT, &bstrPath);
            if (FAILED(hr) || !bstrPath[0])
            {
                // The caller didn't specify a value so delete the key so we use default values.
                hr = HrRegDeleteValue(HKEY_CURRENT_USER, SZ_INISECTION_CURSORS, s_pszCursorArray[nIndex]);
                if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                {
                    hr = S_OK;      // it may already not exist, which is fine.
                }
            }
            else if (SUCCEEDED(hr))
            {
                hr = HrRegSetValueString(HKEY_CURRENT_USER, SZ_INISECTION_CURSORS, s_pszCursorArray[nIndex], bstrPath);
            }
        }

        BSTR bstrCursor;
        if (SUCCEEDED(_getThemeSetting(SZ_INISECTION_CURSORS, SZ_INIKEY_CURSORSCHEME, THEMESETTING_LOADINDIRECT, &bstrCursor)) && bstrCursor && bstrCursor[0])
        {
            // Set the cursor scheme
            HrRegSetValueString(HKEY_CURRENT_USER, SZ_REGKEY_CP_CURSORS, NULL, bstrCursor);

            // GPease wants me to mark this regkey -1 so he knows it was changed from the display CPL.  See
            // him with questions.
            HrRegSetDWORD(HKEY_CURRENT_USER, SZ_REGKEY_CP_CURSORS, SZ_REGVALUE_CURSOR_CURRENTSCHEME, 2);
        }
        else
        {
            HrRegDeleteValue(HKEY_CURRENT_USER, SZ_REGKEY_CP_CURSORS, NULL);
            HrRegDeleteValue(HKEY_CURRENT_USER, SZ_REGKEY_CP_CURSORS, SZ_REGVALUE_CURSOR_CURRENTSCHEME);
        }

        // For the system to start using the new cursors.
        SystemParametersInfoAsync(SPI_SETCURSORS, 0, 0, 0, SPIF_SENDCHANGE, NULL);
    }

    return hr;
}


HRESULT CThemeFile::_ApplyWebview(void)
{
    HRESULT hr = S_OK;

    // We aren't going to support this.
    return hr;
}


HRESULT CThemeFile::_ApplyThemeSettings(void)
{
    HRESULT hr = E_INVALIDARG;

    if (m_pszThemeFile)
    {
        HCURSOR hCursorOld = ::SetCursor(LoadCursor(NULL, IDC_WAIT));

        hr = S_OK;
        if (!((METRIC_CHANGE | COLOR_CHANGE | SCHEME_CHANGE) & m_systemMetrics.dwChanged))
        {
            // Only load settings if we haven't loaded the settings yet.
            hr = _LoadSettings();
        }

        if (SUCCEEDED(hr))
        {
            hr = _ApplySounds();
            if (SUCCEEDED(hr))
            {
                hr = _ApplyCursors();
                if (SUCCEEDED(hr))
                {
                    hr = _ApplyWebview();
                }
            }
        }
        
        // OTHERS:
        // 1. Save Icon: SPI_SETICONMETRICS w/iconMetricsW.iHorzSpacing, iVertSpacing, (Policy bIconSpacing).
        // 2. Save Icon: SPI_SETICONMETRICS w/iconMetricsW.lfFont (Policy bIconFont).
        // 2. Save Icon: from Theme:"Control Panel\\Desktop\\WindowMetrics","Shell Icon Size" to reg same. (Policy bIconSpacing).  Repeate for "Shell Small Icon Size"
        ::SetCursor(hCursorOld);
    }

    return hr;
}


HRESULT CThemeFile::_getThemeSetting(IN LPCWSTR pszIniSection, IN LPCWSTR pszIniKey, DWORD dwFlags, OUT BSTR * pbstrPath)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrPath)
    {
        *pbstrPath = 0;
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        if (m_pszThemeFile)
        {
            WCHAR szPath[MAX_PATH];
            DWORD cbRead = 0;

            szPath[0] = 0;
            if (THEMESETTING_LOADINDIRECT & dwFlags)
            {
                TCHAR szMUIIniKey[MAX_PATH];

                wnsprintf(szMUIIniKey, ARRAYSIZE(szMUIIniKey), TEXT("%s.MUI"), pszIniKey);
                cbRead = SHGetIniStringW(pszIniSection, szMUIIniKey, szPath, ARRAYSIZE(szPath), m_pszThemeFile);
            }

            if (0 == cbRead)
            {
                cbRead = SHGetIniStringW(pszIniSection, pszIniKey, szPath, ARRAYSIZE(szPath), m_pszThemeFile);
            }

            if (cbRead)
            {
                if (L'@' == szPath[0])
                {
                    TCHAR szTemp[MAX_PATH];

                    if (SUCCEEDED(SHLoadIndirectString(szPath, szTemp, ARRAYSIZE(szTemp), NULL)))
                    {
                        StrCpyN(szPath, szTemp, ARRAYSIZE(szPath));
                    }
                }

                hr = ExpandResourceDir(szPath, ARRAYSIZE(szPath));
                hr = ExpandThemeTokens(m_pszThemeFile, szPath, ARRAYSIZE(szPath));      // Expand %ThemeDir% or %WinDir%

                // Sometimes szPath won't be a path.
                if (SUCCEEDED(hr) && !PathIsFileSpec(szPath))
                {
                    hr = ((CF_NOTFOUND == ConfirmFile(szPath, TRUE)) ? HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) : S_OK);
                }

                if (SUCCEEDED(hr))
                {
                    hr = HrSysAllocString(szPath, pbstrPath);
                }
            }
        }
    }

    return hr;
}


// pszPath - NULL means delete value
HRESULT CThemeFile::_putThemeSetting(IN LPCWSTR pszIniSection, IN LPCWSTR pszIniKey, BOOL fUTF7, IN OPTIONAL LPWSTR pszPath)
{
    HRESULT hr = E_INVALIDARG;

    if (m_pszThemeFile)
    {
        TCHAR szPath[MAX_PATH];
        LPCWSTR pszValue = pszPath;

        szPath[0] = 0;
        if (pszValue && !PathIsRelative(pszValue) & PathFileExists(pszValue))
        {
            if (PathUnExpandEnvStringsForUser(NULL, pszValue, szPath, ARRAYSIZE(szPath)))
            {
                pszValue = szPath;
            }
        }

        StrReplaceToken(TEXT("%WinDir%\\"), TEXT("%WinDir%"), szPath, ARRAYSIZE(szPath));
        StrReplaceToken(TEXT("%SystemRoot%\\"), TEXT("%WinDir%"), szPath, ARRAYSIZE(szPath));
        if (fUTF7)
        {
            if (SHSetIniStringW(pszIniSection, pszIniKey, pszValue, m_pszThemeFile))
            {
                hr = S_OK;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        else
        {
            hr = HrWritePrivateProfileStringW(pszIniSection, pszIniKey, pszValue, m_pszThemeFile);
        }

        TCHAR szMUIIniKey[MAX_PATH];

        // Delete any ".MUI" copies because they are out of date.
        wnsprintf(szMUIIniKey, ARRAYSIZE(szMUIIniKey), TEXT("%s.MUI"), pszIniKey);
        HrWritePrivateProfileStringW(pszIniSection, szMUIIniKey, NULL, m_pszThemeFile);
    }

    return hr;
}


HRESULT CThemeFile::_getIntSetting(IN LPCWSTR pszIniSection, IN LPCWSTR pszIniKey, int nDefault, OUT int * pnValue)
{
    HRESULT hr = E_INVALIDARG;

    if (pnValue)
    {
        *pnValue = 0;
        hr = E_FAIL;
        if (m_pszThemeFile)
        {
            *pnValue = GetPrivateProfileInt(pszIniSection, pszIniKey, nDefault, m_pszThemeFile);
            hr = S_OK;
        }
    }

    return hr;
}


HRESULT CThemeFile::_putIntSetting(IN LPCWSTR pszIniSection, IN LPCWSTR pszIniKey, IN int nValue)
{
    HRESULT hr = E_INVALIDARG;

    if (m_pszThemeFile)
    {
        if (WritePrivateProfileInt(pszIniSection, pszIniKey, nValue, m_pszThemeFile))
        {
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}





//===========================
// *** ITheme Interface ***
//===========================
HRESULT CThemeFile::get_DisplayName(OUT BSTR * pbstrDisplayName)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrDisplayName)
    {
        WCHAR szDisplayName[MAX_PATH];

        *pbstrDisplayName = NULL;
        hr = _getThemeSetting(SZ_INISECTION_THEME, SZ_INIKEY_DISPLAYNAME, THEMESETTING_NORMAL, pbstrDisplayName);
        if (FAILED(hr))
        {
            LPCTSTR pszFileName = PathFindFileName(m_pszThemeFile);

            hr = E_FAIL;
            if (pszFileName)
            {
                SHTCharToUnicode(pszFileName, szDisplayName, ARRAYSIZE(szDisplayName));
                PathRemoveExtensionW(szDisplayName);

                hr = HrSysAllocStringW(szDisplayName, pbstrDisplayName);
            }
        }
    }

    return hr;
}


HRESULT CThemeFile::put_DisplayName(IN BSTR bstrDisplayName)
{
    HRESULT hr = E_INVALIDARG;

    // NULL bstrDisplayName is allowed, it means to delete the name in the file
    // so the filename will be used in the future.
    if (bstrDisplayName)
    {
        hr = _putThemeSetting(SZ_INISECTION_THEME, SZ_INIKEY_DISPLAYNAME, TRUE, bstrDisplayName);
    }
    else
    {
        SHSetIniStringW(SZ_INISECTION_THEME, SZ_INIKEY_DISPLAYNAME, NULL, m_pszThemeFile);
        hr = S_OK;
    }

    return hr;
}


HRESULT CThemeFile::get_ScreenSaver(OUT BSTR * pbstrPath)
{
    return _getThemeSetting(SZ_INISECTION_SCREENSAVER, SZ_INIKEY_SCREENSAVER, THEMESETTING_NORMAL, pbstrPath);
}


HRESULT CThemeFile::put_ScreenSaver(IN BSTR bstrPath)
{
    return _putThemeSetting(SZ_INISECTION_SCREENSAVER, SZ_INIKEY_SCREENSAVER, TRUE, bstrPath);
}


HRESULT CThemeFile::get_Background(OUT BSTR * pbstrPath)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrPath)
    {
        hr = _getThemeSetting(SZ_INISECTION_BACKGROUND, SZ_INIKEY_BACKGROUND, THEMESETTING_LOADINDIRECT, pbstrPath);
        if (SUCCEEDED(hr))
        {
            TCHAR szNone[MAX_PATH];

            LoadString(HINST_THISDLL, IDS_NONE, szNone, ARRAYSIZE(szNone));
            if (!StrCmpI(szNone, *pbstrPath))
            {
                (*pbstrPath)[0] = 0;
            }
        }
    }

    return hr;
}


HRESULT CThemeFile::put_Background(IN BSTR bstrPath)
{
    return _putThemeSetting(SZ_INISECTION_BACKGROUND, SZ_INIKEY_BACKGROUND, TRUE, bstrPath);
}


HRESULT CThemeFile::get_BackgroundTile(OUT enumBkgdTile * pnTile)
{
    HRESULT hr = E_INVALIDARG;

    if (pnTile)
    {
        TCHAR szSize[10];
        int tile = 0;       // Zero is the default value to use if the registry is empty.
        int stretch = 0;

        if (SUCCEEDED(HrRegGetValueString(HKEY_CURRENT_USER, SZ_INISECTION_BACKGROUND, SZ_REGVALUE_TILEWALLPAPER, szSize, ARRAYSIZE(szSize))))
        {
            tile = StrToInt(szSize);
        }

        if (SUCCEEDED(HrRegGetValueString(HKEY_CURRENT_USER, SZ_INISECTION_BACKGROUND, SZ_REGVALUE_WALLPAPERSTYLE, szSize, ARRAYSIZE(szSize))))
        {
            tile = (2 & StrToInt(szSize));
        }

        // If a theme is selected, and we are using a plus wall paper then
        // find out if tiling is on, and what style to use from the ini file.
        // Otherwise, we already got the information from the registry.
        _getIntSetting(SZ_INISECTION_BACKGROUND, SZ_REGVALUE_TILEWALLPAPER, tile, &tile);
        _getIntSetting(SZ_INISECTION_BACKGROUND, SZ_REGVALUE_WALLPAPERSTYLE, stretch, &stretch);

        stretch &= 2;
        _getIntSetting(SZ_INISECTION_MASTERSELECTOR, SZ_REGVALUE_STRETCH, stretch, &stretch);

        if (tile)
        {
            *pnTile = BKDGT_TILE;
        }
        else if (stretch)
        {
            *pnTile = BKDGT_STRECH;
        }
        else
        {
            *pnTile = BKDGT_CENTER;
        }

        hr = S_OK;
    }

    return hr;
}


HRESULT CThemeFile::put_BackgroundTile(IN enumBkgdTile nTile)
{
    HRESULT hr = E_INVALIDARG;

    switch (nTile)
    {
    case BKDGT_STRECH:
        hr = _putThemeSetting(SZ_INISECTION_BACKGROUND, SZ_REGVALUE_TILEWALLPAPER, FALSE, TEXT("0"));
        hr = _putThemeSetting(SZ_INISECTION_BACKGROUND, SZ_REGVALUE_WALLPAPERSTYLE, FALSE, TEXT("2"));
        break;
    case BKDGT_CENTER:
        hr = _putThemeSetting(SZ_INISECTION_BACKGROUND, SZ_REGVALUE_TILEWALLPAPER, FALSE, TEXT("0"));
        hr = _putThemeSetting(SZ_INISECTION_BACKGROUND, SZ_REGVALUE_WALLPAPERSTYLE, FALSE, TEXT("0"));
        break;
    case BKDGT_TILE:
        hr = _putThemeSetting(SZ_INISECTION_BACKGROUND, SZ_REGVALUE_TILEWALLPAPER, FALSE, TEXT("1"));
        hr = _putThemeSetting(SZ_INISECTION_BACKGROUND, SZ_REGVALUE_WALLPAPERSTYLE, FALSE, TEXT("0"));
        break;
    };

    return hr;
}


HRESULT CThemeFile::get_VisualStyle(OUT BSTR * pbstrPath)
{
    return _getThemeSetting(SZ_INISECTION_VISUALSTYLES, SZ_INIKEY_VISUALSTYLE, THEMESETTING_NORMAL, pbstrPath);
}


HRESULT CThemeFile::put_VisualStyle(IN BSTR bstrPath)
{
    return _putThemeSetting(SZ_INISECTION_VISUALSTYLES, SZ_INIKEY_VISUALSTYLE, TRUE, bstrPath);
}


HRESULT CThemeFile::get_VisualStyleColor(OUT BSTR * pbstrPath)
{
    return _getThemeSetting(SZ_INISECTION_VISUALSTYLES, SZ_INIKEY_VISUALSTYLECOLOR, THEMESETTING_NORMAL, pbstrPath);
}


HRESULT CThemeFile::put_VisualStyleColor(IN BSTR bstrPath)
{
    return _putThemeSetting(SZ_INISECTION_VISUALSTYLES, SZ_INIKEY_VISUALSTYLECOLOR, TRUE, bstrPath);
}


HRESULT CThemeFile::get_VisualStyleSize(OUT BSTR * pbstrPath)
{
    return _getThemeSetting(SZ_INISECTION_VISUALSTYLES, SZ_INIKEY_VISUALSTYLESIZE, THEMESETTING_NORMAL, pbstrPath);
}


HRESULT CThemeFile::put_VisualStyleSize(IN BSTR bstrPath)
{
    return _putThemeSetting(SZ_INISECTION_VISUALSTYLES, SZ_INIKEY_VISUALSTYLESIZE, TRUE, bstrPath);
}


HRESULT CThemeFile::GetPath(IN VARIANT_BOOL fExpand, OUT BSTR * pbstrPath)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrPath && m_pszThemeFile)
    {
        TCHAR szPath[MAX_PATH];

        StrCpyN(szPath, m_pszThemeFile, ARRAYSIZE(szPath));
        if (VARIANT_TRUE == fExpand)
        {
            TCHAR szPathTemp[MAX_PATH];
            
            if (SHExpandEnvironmentStrings(szPath, szPathTemp, ARRAYSIZE(szPathTemp)))
            {
                StrCpyN(szPath, szPathTemp, ARRAYSIZE(szPath));
            }
        }

        hr = HrSysAllocString(szPath, pbstrPath);
    }

    return hr;
}


HRESULT CThemeFile::SetPath(IN BSTR bstrPath)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrPath)
    {
        Str_SetPtr(&m_pszThemeFile, bstrPath);
        hr = S_OK;
    }

    return hr;
}


HRESULT CThemeFile::GetCursor(IN BSTR bstrCursor, OUT BSTR * pbstrPath)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrPath)
    {
        *pbstrPath = NULL;

        if (bstrCursor)
        {
            hr = _getThemeSetting(SZ_INISECTION_CURSORS, bstrCursor, THEMESETTING_LOADINDIRECT, pbstrPath);
        }
    }

    return hr;
}


HRESULT CThemeFile::SetCursor(IN BSTR bstrCursor, IN BSTR bstrPath)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrCursor)
    {
        hr = _putThemeSetting(SZ_INISECTION_CURSORS, bstrCursor, TRUE, bstrPath);
    }

    return hr;
}


HRESULT CThemeFile::_GetSound(LPCWSTR pszSoundName, OUT BSTR * pbstrPath)
{
    HRESULT hr = E_INVALIDARG;

    if (pszSoundName && pbstrPath)
    {
        *pbstrPath = NULL;
        hr = _getThemeSetting(pszSoundName, SZ_INIKEY_DEFAULTVALUE, THEMESETTING_LOADINDIRECT, pbstrPath);
    }

    return hr;
}


HRESULT CThemeFile::GetSound(IN BSTR bstrSoundName, OUT BSTR * pbstrPath)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrPath)
    {
        *pbstrPath = NULL;

        if (bstrSoundName)
        {
            hr = _GetSound(bstrSoundName, pbstrPath);
            if (FAILED(hr))
            {
                int nIndex;

                for (nIndex = 0; nIndex < ARRAYSIZE(s_ThemeSoundsValues); nIndex++)
                {
                    if (!StrCmpI(bstrSoundName, s_ThemeSoundsValues[nIndex].pszRegKey))
                    {
                        // First delete the value because we many need to switch from REG_SZ to REG_EXPAND_SZ
                        TCHAR szReplacement[MAX_PATH];

                        LoadString(HINST_THISDLL, s_ThemeSoundsValues[nIndex].nResourceID, szReplacement, ARRAYSIZE(szReplacement));
                        hr = HrSysAllocStringW(szReplacement, pbstrPath);
                        break;
                    }
                }
            }
        }
    }

    return hr;
}


HRESULT CThemeFile::SetSound(IN BSTR bstrSoundName, IN BSTR bstrPath)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrSoundName && bstrPath)
    {
        hr = _putThemeSetting(bstrSoundName, SZ_INIKEY_DEFAULTVALUE, TRUE, bstrPath);
    }

    return hr;
}


HRESULT CThemeFile::GetIcon(IN BSTR bstrIconName, OUT BSTR * pbstrIconPath)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrIconPath)
    {
        *pbstrIconPath = NULL;

        if (bstrIconName)
        {
            WCHAR szPath[MAX_URL_STRING];
            WCHAR szIconType[MAX_PATH];

            StrCpyNW(szPath, bstrIconName, ARRAYSIZE(szPath));
            LPWSTR pszSeparator = StrChrW(szPath, L':');
            if (pszSeparator)
            {
                StrCpyNW(szIconType, CharNext(pszSeparator), ARRAYSIZE(szIconType));
                pszSeparator[0] = 0;
            }
            else
            {
                // The caller should specify this but this is a safe fallback.
                StrCpyNW(szIconType, L"DefaultValue", ARRAYSIZE(szIconType));
            }

            hr = _getThemeSetting(szPath, szIconType, THEMESETTING_NORMAL, pbstrIconPath);
            if (FAILED(hr))
            {
                // The Plus! 98 format started adding "Software\Classes" to the path.
                // So try that now.
                // Plus!95 format: "[CLSID\{20D04FE0-3AEA-1069-A2D8-08002B30309D}\DefaultIcon]"
                // Plus!98 format: "[Software\Classes\CLSID\{20D04FE0-3AEA-1069-A2D8-08002B30309D}\DefaultIcon]"
                WCHAR szPath98[MAX_URL_STRING];

                wnsprintfW(szPath98, ARRAYSIZE(szPath98), L"Software\\Classes\\%ls", szPath);
                hr = _getThemeSetting(szPath98, szIconType, THEMESETTING_NORMAL, pbstrIconPath);
            }
        }
    }

    return hr;
}


HRESULT CThemeFile::SetIcon(IN BSTR bstrIconName, IN BSTR bstrIconPath)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrIconName && bstrIconPath)
    {
        WCHAR szPath[MAX_URL_STRING];
        WCHAR szIconType[MAX_PATH];

        StrCpyNW(szPath, bstrIconName, ARRAYSIZE(szPath));
        LPWSTR pszSeparator = StrChrW(szPath, L':');
        if (pszSeparator)
        {
            StrCpyNW(szIconType, CharNext(pszSeparator), ARRAYSIZE(szIconType));
            pszSeparator[0] = 0;
        }
        else
        {
            // The caller should specify this but this is a safe fallback.
            StrCpyNW(szIconType, L"DefaultValue", ARRAYSIZE(szIconType));
        }

        hr = _putThemeSetting(szPath, szIconType, TRUE, bstrIconPath);
    }

    return hr;
}




//===========================
// *** IPropertyBag Interface ***
//===========================
HRESULT CThemeFile::Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        if (!StrCmpW(pszPropName, SZ_PBPROP_SYSTEM_METRICS))
        {
            hr = _LoadSettings();

            // This is pretty ugly.
            pVar->vt = VT_BYREF;
            pVar->byref = &m_systemMetrics;
        }
        else if (!StrCmpW(pszPropName, SZ_PBPROP_HASSYSMETRICS))
        {
            hr = _LoadSettings();

            pVar->vt = VT_BOOL;
            pVar->boolVal = VARIANT_FALSE;
            if (SUCCEEDED(hr))
            {
                TCHAR szIconMetrics[2048];

                DWORD cchSize = GetPrivateProfileString(SZ_INISECTION_METRICS, SZ_INIKEY_ICONMETRICS, SZ_EMPTY, szIconMetrics, ARRAYSIZE(szIconMetrics), m_pszThemeFile);
                if (szIconMetrics[0])
                {
                    cchSize = GetPrivateProfileString(SZ_INISECTION_METRICS, SZ_INIKEY_NONCLIENTMETRICS, SZ_EMPTY, szIconMetrics, ARRAYSIZE(szIconMetrics), m_pszThemeFile);
                    if (szIconMetrics[0])
                    {
                        cchSize = GetPrivateProfileString(SZ_INISECTION_COLORS, s_pszColorNames[COLOR_ACTIVECAPTION], SZ_EMPTY, szIconMetrics, ARRAYSIZE(szIconMetrics), m_pszThemeFile);
                        pVar->boolVal = (szIconMetrics[0] ? VARIANT_TRUE : VARIANT_FALSE);
                    }
                }
            }
        }
    }

    return hr;
}


HRESULT CThemeFile::Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar)
{
    HRESULT hr = E_NOTIMPL;

    if (pszPropName && pVar)
    {
        if (!StrCmpW(pszPropName, SZ_PBPROP_APPLY_THEMEFILE))
        {
            VariantInit(pVar);
            hr = _ApplyThemeSettings();       // This will do nothing if already loaded.
        }
        else if (!StrCmpW(pszPropName, SZ_PBPROP_SYSTEM_METRICS) && (VT_BYREF == pVar->vt) && pVar->byref)
        {
            SYSTEMMETRICSALL * pCurrent = (SYSTEMMETRICSALL *) pVar->byref;

            // The caller will pass SYSTEMMETRICS in the live system DPI.
            hr = _SaveSystemMetrics(pCurrent);
        }
    }

    return hr;
}





//===========================
// *** IUnknown Interface ***
//===========================
ULONG CThemeFile::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CThemeFile::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CThemeFile::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CThemeFile, IObjectWithSite),
        QITABENT(CThemeFile, IPropertyBag),
        QITABENT(CThemeFile, ITheme),
        QITABENT(CThemeFile, IDispatch),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CThemeFile::CThemeFile(LPCTSTR pszThemeFile) : CImpIDispatch(LIBID_Theme, 1, 0, IID_ITheme), m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    
    m_dwCachedState = 0xFFFFFFFF;

    InitFrost();
}


CThemeFile::~CThemeFile()
{
    Str_SetPtr(&m_pszThemeFile, NULL);

    DllRelease();
}


HRESULT CThemeFile_CreateInstance(IN LPCWSTR pszThemeFile, OUT ITheme ** ppTheme)
{
    HRESULT hr = E_INVALIDARG;

    if (ppTheme)
    {
        CThemeFile * pObject = new CThemeFile(pszThemeFile);

        hr = E_OUTOFMEMORY;
        *ppTheme = NULL;
        if (pObject)
        {
            hr = pObject->SetPath((BSTR)pszThemeFile);
            if (SUCCEEDED(hr))
            {
                hr = pObject->QueryInterface(IID_PPV_ARG(ITheme, ppTheme));
            }

            pObject->Release();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\store.cpp ===
//---------------------------------------------------------------------------
//
//  File: plustab.cpp
//
//  Main Implementation of the Effects page
//
//---------------------------------------------------------------------------


#include "priv.h"
#pragma hdrstop

#include "shlwapip.h"
#include "shlguidp.h"
#include "EffectsAdvPg.h"
#include "store.h"
#include "regutil.h"

// OLE-Registry magic number
GUID CLSID_EffectsPage = { 0x41e300e0, 0x78b6, 0x11ce,{0x84, 0x9b, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00}};

#define SPI_GETKEYBOARDINDICATORS SPI_GETMENUUNDERLINES//0x100A
#define SPI_SETKEYBOARDINDICATORS SPI_SETMENUUNDERLINES//0x100B

#define SPI_GETFONTCLEARTYPE      116
#define SPI_SETFONTCLEARTYPE      117

// Handle to the DLL
extern HINSTANCE g_hInst;

// vars needed for new shell api
#define SZ_SHELL32                  TEXT("shell32.dll")
#define SZ_SHUPDATERECYCLEBINICON   "SHUpdateRecycleBinIcon"    // Parameter for GetProcAddr()... DO NOT TEXT("") IT!

typedef void (* PFNSHUPDATERECYCLEBINICON)( void );

// Function prototype
BOOL CALLBACK PlusPackDlgProc( HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam );

// Icon Stuff
int   GetIconState (void);
BOOL  ChangeIconSizes(int iOldState, int iNewState);


// animation stuff
WPARAM GetAnimations(DWORD *pdwEffect);
void SetAnimations(WPARAM wVal, DWORD dwEffect, DWORD dwBroadCast);

BOOL DisplayFontSmoothingDetails(DWORD *pdwSetting)
{
    return FALSE;
}

int GetBitsPerPixel(void)
{
    int iBitsPerPixel = 8;
    HDC hDC = GetDC(NULL);

    if (hDC)
    {
        iBitsPerPixel = GetDeviceCaps(hDC, BITSPIXEL);
        ReleaseDC(NULL, hDC);
    }

    return iBitsPerPixel;
}

int GetIconState(void)
{
    BOOL bRet;
    int iSize;

    bRet = GetRegValueInt(HKEY_CURRENT_USER, SZ_REGKEY_USERMETRICS, SZ_REGVALUE_ICONSIZE, &iSize);
    if (bRet == FALSE)
        return ICON_DEFAULT;

    if (iSize == ICON_DEFAULT_NORMAL)
        return ICON_DEFAULT;
    else if (iSize == ICON_DEFAULT_LARGE)
        return ICON_LARGE;
    return ICON_INDETERMINATE;
}


BOOL ChangeIconSizes(int iOldState, int iNewState)
{
    BOOL bRet;
    int  iOldSize, iNewSize;
    int  iHorz;
    int  iVert;

    // Don't bother if nothing changed
    if (iOldState == iNewState)
        return FALSE;

    // Get New Size
    switch (iNewState)
        {
        case ICON_DEFAULT:
            iNewSize = ICON_DEFAULT_NORMAL;
            break;

        case ICON_LARGE:
            iNewSize = ICON_DEFAULT_LARGE;
            break;

        case ICON_INDETERMINATE:
            // Don't bother to change anything
            return FALSE;

        default:
            return FALSE;
        }

    // Get Original Size
    bRet = GetRegValueInt(HKEY_CURRENT_USER, SZ_REGKEY_USERMETRICS, SZ_REGVALUE_ICONSIZE, &iOldSize);
    if (!bRet)
    {
        // Try geting system default instead
        iOldSize = ClassicGetSystemMetrics(SM_CXICON);
    }

    // Don't need to change size if nothing has really changed
    if (iNewSize == iOldSize)
        return FALSE;

    // Get new horizontal spacing
    iHorz = ClassicGetSystemMetrics(SM_CXICONSPACING);
    iHorz -= iOldSize;
    if (iHorz < 0)
    {
        iHorz = 0;
    }
    iHorz += iNewSize;

    // Get new vertical spacing
    iVert = ClassicGetSystemMetrics(SM_CYICONSPACING);
    iVert -= iOldSize;
    if (iVert < 0)
    {
        iVert = 0;
    }
    iVert += iNewSize;

        // Set New sizes and spacing
    bRet = SetRegValueInt(HKEY_CURRENT_USER, SZ_REGKEY_USERMETRICS, SZ_REGVALUE_ICONSIZE, iNewSize);
    if (!bRet)
        return FALSE;

    // We don't need to call the Async version because this function is called on a background thread.
    ClassicSystemParametersInfo(SPI_ICONHORIZONTALSPACING, iHorz, NULL, (SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE));
    ClassicSystemParametersInfo(SPI_ICONVERTICALSPACING, iVert, NULL, (SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE));

    // We need to do this in order to force DefView to update.
    // BUG:194437
    ICONMETRICS iconMetrics;
    iconMetrics.cbSize = sizeof(iconMetrics);
    ClassicSystemParametersInfo(SPI_GETICONMETRICS, sizeof(iconMetrics), &iconMetrics, 0);
    ClassicSystemParametersInfo(SPI_SETICONMETRICS, sizeof(iconMetrics), &iconMetrics, SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE);

    // We did change the sizes
    return TRUE;
}


//
//  GetAnimations
//
//  Get current state of animations (windows / menus / etc.).
//
WPARAM GetAnimations(DWORD *pdwEffect)
{
    BOOL fMenu = FALSE, fWindow = FALSE, fCombo = FALSE, fSmooth = FALSE, fList = FALSE, fFade = FALSE;
    ANIMATIONINFO ai;

    ai.cbSize = sizeof(ai);
    if (ClassicSystemParametersInfo(SPI_GETANIMATION, sizeof(ai), (PVOID)&ai, 0 ))
    {
        fWindow = (ai.iMinAnimate) ? TRUE : FALSE;
    }

    ClassicSystemParametersInfo(SPI_GETCOMBOBOXANIMATION, 0, (PVOID)&fCombo, 0 );
    ClassicSystemParametersInfo(SPI_GETLISTBOXSMOOTHSCROLLING, 0, (PVOID)&fList, 0 );
    ClassicSystemParametersInfo(SPI_GETMENUANIMATION, 0, (PVOID)&fMenu, 0 );
    fSmooth = GetRegValueDword(HKEY_CURRENT_USER, SZ_REGKEY_CPDESKTOP, SZ_REGVALUE_SMOOTHSCROLL);

    if (fSmooth == REG_BAD_DWORD)
    {
        fSmooth = 1;
    }
    
    ClassicSystemParametersInfo(SPI_GETMENUFADE, 0, (PVOID)&fFade, 0 );
    *pdwEffect = (fFade ? MENU_EFFECT_FADE : MENU_EFFECT_SCROLL);
    
    if (fMenu && fWindow && fCombo && fSmooth && fList)
        return BST_CHECKED;

    if ((!fMenu) && (!fWindow) && (!fCombo) && (!fSmooth) && (!fList))
        return BST_UNCHECKED;

    return BST_INDETERMINATE;
}

//
//  SetAnimations
//
//  Set animations according (windows / menus / etc.) according to flag.
//
void SetAnimations(WPARAM wVal, DWORD dwEffect, DWORD dwBroadcast)
{
    if (!IsTSPerfFlagEnabled(TSPerFlag_NoAnimation))
    {
        ANIMATIONINFO ai;

        // Note, if the checkbox is indeterminate, we treat it like it was checked.
        // We should never get this far if the user didn't change something so this should be okay.
        BOOL bVal = (wVal == BST_UNCHECKED) ? 0 : 1;
        BOOL bEfx = (dwEffect == MENU_EFFECT_FADE) ? 1 : 0;
        
        ai.cbSize = sizeof(ai);
        ai.iMinAnimate = bVal;
        ClassicSystemParametersInfo(SPI_SETANIMATION, sizeof(ai), (PVOID)&ai, dwBroadcast);
        ClassicSystemParametersInfo(SPI_SETCOMBOBOXANIMATION, 0, IntToPtr(bVal), dwBroadcast);
        ClassicSystemParametersInfo(SPI_SETLISTBOXSMOOTHSCROLLING, 0, IntToPtr(bVal), dwBroadcast);
        ClassicSystemParametersInfo(SPI_SETMENUANIMATION, 0, IntToPtr(bVal), dwBroadcast);
        ClassicSystemParametersInfo(SPI_SETTOOLTIPANIMATION, 0, IntToPtr(bVal), dwBroadcast);
        SetRegValueDword(HKEY_CURRENT_USER, SZ_REGKEY_CPDESKTOP, SZ_REGVALUE_SMOOTHSCROLL, bVal);

        ClassicSystemParametersInfo(SPI_SETMENUFADE, 0, IntToPtr(bEfx), dwBroadcast);
        ClassicSystemParametersInfo(SPI_SETTOOLTIPFADE, 0, IntToPtr(bEfx), dwBroadcast);
        ClassicSystemParametersInfo(SPI_SETSELECTIONFADE, 0, bVal ? IntToPtr(bEfx) : 0, dwBroadcast);
    }
}




CEffectState::CEffectState() : m_cRef(1)
{
}


CEffectState::~CEffectState()
{
}


HRESULT CEffectState::Load(void)
{
    HRESULT hr = S_OK;

    // Get the values for the settings from the registry and set the checkboxes
    // Large Icons
    _nLargeIcon = GetIconState();

    // Full Color Icons
    if(FALSE == GetRegValueInt(HKEY_CURRENT_USER, SZ_REGKEY_USERMETRICS, SZ_REGVALUE_ICONCOLORDEPTH, &_nHighIconColor)) // Key not in registry yet
    {
        _nHighIconColor = 4;
    }

    // Use animations
    _wpMenuAnimation = GetAnimations(&_dwAnimationEffect);
    
    // Smooth edges of screen fonts
    _fFontSmoothing = FALSE;
    ClassicSystemParametersInfo(SPI_GETFONTSMOOTHING, 0, (PVOID)&_fFontSmoothing, 0);

    _dwFontSmoothingType = FONT_SMOOTHING_AA;
    if (ClassicSystemParametersInfo(SPI_GETFONTSMOOTHINGTYPE, 0, (PVOID)&_dwFontSmoothingType, 0)) 
    {
    }

    if (FONT_SMOOTHING_MONO == _dwFontSmoothingType)
    {
        _dwFontSmoothingType = FONT_SMOOTHING_AA;
    }

    // Show contents while dragging
    _fDragWindow = FALSE;
    ClassicSystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, (PVOID)&_fDragWindow, 0);

    _fKeyboardIndicators = FALSE;
    ClassicSystemParametersInfo(SPI_GETKEYBOARDINDICATORS, 0, (PVOID)&_fKeyboardIndicators, 0);

    _fMenuShadows = TRUE;
    ClassicSystemParametersInfo(SPI_GETDROPSHADOW, 0, (PVOID)&_fMenuShadows, 0);

    // Set the old values so we know when they changed.
    _nOldLargeIcon = _nLargeIcon;
    _nOldHighIconColor = _nHighIconColor;
    _wpOldMenuAnimation = _wpMenuAnimation;
    _fOldFontSmoothing = _fFontSmoothing;
    _dwOldFontSmoothingType = _dwFontSmoothingType;
    _fOldDragWindow = _fDragWindow;
    _fOldKeyboardIndicators = _fKeyboardIndicators;
    _dwOldAnimationEffect = _dwAnimationEffect;
    _fOldMenuShadows = _fMenuShadows;

    return hr;
}


HRESULT CEffectState::Save(void)
{
    // ClassicSystemParametersInfo() will hang if a top level window is hung (#162570) and USER will not fix that bug.
    // Therefore, we need to make that API call on a background thread because we need to
    // be more rebust than to hang.
    AddRef();
    SPICreateThread(Save_WorkerProc, (void *)this);
    return S_OK;
}


DWORD CEffectState::Save_WorkerProc(void * pvThis)
{
    CEffectState * pThis = (CEffectState *) pvThis;

    if (pThis)
    {
        pThis->_SaveWorkerProc();
    }

    return 0;
}


HRESULT CEffectState::_SaveWorkerProc(void)
{
    HRESULT hr = S_OK;

    // First pass to persist the settings.
    hr = _SaveSettings(FALSE);
    if (SUCCEEDED(hr))
    {
        // Second pass to broadcast the change.  This may hang if apps are hung.
        // This pass may only make it half way thru before it aborts.  In some cases
        // it's only given 30 seconds to do it's work.  If no apps are hung, that should be
        // fine.  This is cancelled after a period of time because we need this process to go
        // away, or the Display CPL will not open again if the user launches it again.
        hr = _SaveSettings(TRUE);
    }

    Release();
    return hr;
}


// POSSIBLE FUTURE PERF REFINEMENT:
// We could optimize this by checking if we have more than 5 or so
// broadcasts to make.  Then don't send the broadcasts on SystemParametersInfo()
// but instead with WM_WININICHANGE with 0,0.  This may reduce flicker.
HRESULT CEffectState::_SaveSettings(BOOL fBroadcast)
{
    HRESULT hr = S_OK;
    BOOL bDorked = FALSE;
    DWORD dwUpdateFlags = (fBroadcast ? (SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE) : SPIF_UPDATEINIFILE);
    BOOL bSendSettingsChange = FALSE;

    // Full Color Icons
    if(_nOldHighIconColor != _nHighIconColor)
    {
        SetRegValueInt(HKEY_CURRENT_USER, SZ_REGKEY_USERMETRICS, SZ_REGVALUE_ICONCOLORDEPTH, _nHighIconColor);
        if ((GetBitsPerPixel() < 16) && (_nHighIconColor == 16)) // Display mode won't support icon high colors
        {
        }
        else
        {
           _nOldHighIconColor = _nHighIconColor;
           bSendSettingsChange = TRUE;
        }
    }

    // Full window drag
    if (_fOldDragWindow != _fDragWindow)
    {
        if (fBroadcast)
        {
            _fOldDragWindow = _fDragWindow;
        }

        if (!IsTSPerfFlagEnabled(TSPerFlag_NoWindowDrag))
        {
            ClassicSystemParametersInfo(SPI_SETDRAGFULLWINDOWS, _fDragWindow, 0, dwUpdateFlags);
        }

        // we need to send this because the tray's autohide switches off this
        bSendSettingsChange = TRUE;
    }

    // Show Menu Shadows
    if (_fOldMenuShadows != _fMenuShadows)
    {
        if (fBroadcast)
        {
            _fOldMenuShadows = _fMenuShadows;
        }
        ClassicSystemParametersInfo(SPI_SETDROPSHADOW, 0, IntToPtr(_fMenuShadows), dwUpdateFlags);
        // we need to send this because the tray's autohide switches off this
        PostMessageBroadAsync(WM_SETTINGCHANGE, 0, 0);

        bSendSettingsChange = TRUE;
    }

    // Font smoothing
    if ((_fOldFontSmoothing != _fFontSmoothing) || (_dwOldFontSmoothingType != _dwFontSmoothingType))
    {
        if (!_fFontSmoothing)
        {
            // #168059: If font smoothing is off, we need to set SPI_SETFONTSMOOTHINGTYPE to xxx
            // Otherwise, it will still use ClearType.
            _dwFontSmoothingType = FONT_SMOOTHING_MONO;
        }

        ClassicSystemParametersInfo(SPI_SETFONTSMOOTHINGTYPE, 0, (PVOID)UlongToPtr(_dwFontSmoothingType), dwUpdateFlags);

        if (fBroadcast)
        {
            _dwOldFontSmoothingType = _dwFontSmoothingType;
            _fOldFontSmoothing = _fFontSmoothing;
        }

        ClassicSystemParametersInfo(SPI_SETFONTSMOOTHING, _fFontSmoothing, 0, dwUpdateFlags);
        if (fBroadcast)
        {
            // Now have the windows repaint with the change.  Whistler #179531
            RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ERASENOW | RDW_UPDATENOW | RDW_ALLCHILDREN);
        }
    }

    // Menu animations
    if ((_wpOldMenuAnimation != _wpMenuAnimation) || (_dwOldAnimationEffect != _dwAnimationEffect))
    {
        if (fBroadcast)
        {
            _wpOldMenuAnimation = _wpMenuAnimation;
        }
        SetAnimations(_wpMenuAnimation, _dwAnimationEffect, dwUpdateFlags);

        if (fBroadcast)
        {
            _dwOldAnimationEffect = _dwAnimationEffect;
        }
    }

    // Keyboard indicators
    if (_fOldKeyboardIndicators != _fKeyboardIndicators)
    {
        if (fBroadcast)
        {
            _fOldKeyboardIndicators = _fKeyboardIndicators;
        }

        // Are we turning this on? (!_fKeyboardIndicators means "don't show" -> hide)
        if (!_fKeyboardIndicators)
        {
            // Yes, on: hide the key cues, turn on the mechanism
            ClassicSystemParametersInfo(SPI_SETKEYBOARDINDICATORS, 0, IntToPtr(_fKeyboardIndicators), dwUpdateFlags);
            PostMessageBroadAsync(WM_CHANGEUISTATE, MAKEWPARAM(UIS_SET, UISF_HIDEFOCUS | UISF_HIDEACCEL), 0);
        }
        else
        {
            // No, off: means show the keycues, turn off the mechanism
            PostMessageBroadAsync(WM_CHANGEUISTATE, MAKEWPARAM(UIS_CLEAR, UISF_HIDEFOCUS | UISF_HIDEACCEL), 0);

            ClassicSystemParametersInfo(SPI_SETKEYBOARDINDICATORS, 0, IntToPtr(_fKeyboardIndicators), dwUpdateFlags);
        }
    }

    // Large Icons
    bSendSettingsChange = ChangeIconSizes(_nOldLargeIcon, _nLargeIcon);
    if (bSendSettingsChange)
    {
        if (fBroadcast)
        {
            _nOldLargeIcon = _nLargeIcon;
        }
        bDorked = TRUE;
    }

    // Make the system notice we changed the system icons
    if (bDorked)
    {
        PFNSHUPDATERECYCLEBINICON pfnSHUpdateRecycleBinIcon = NULL;
        SHChangeNotify(SHCNE_ASSOCCHANGED, 0, NULL, NULL); // should do the trick!

        // Load SHUpdateRecycleBinIcon() if it exists
        HINSTANCE hmodShell32 = LoadLibrary(SZ_SHELL32);
        if (hmodShell32)
        {
            pfnSHUpdateRecycleBinIcon = (PFNSHUPDATERECYCLEBINICON)GetProcAddress(hmodShell32, SZ_SHUPDATERECYCLEBINICON);
            if (pfnSHUpdateRecycleBinIcon != NULL)
            {
                pfnSHUpdateRecycleBinIcon();
            }
            FreeLibrary(hmodShell32);
        }
    }

    if (bSendSettingsChange)
    {
        // We post this message because if an app is hung or slow, we don't want to hang.
        PostMessageBroadAsync(WM_SETTINGCHANGE, 0, 0);
    }

    return hr;
}


HRESULT CEffectState::Clone(OUT CEffectState ** ppEffectClone)
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppEffectClone = new CEffectState();
    if (*ppEffectClone)
    {
        hr = S_OK;

        (*ppEffectClone)->_nLargeIcon = _nLargeIcon;
        (*ppEffectClone)->_nHighIconColor = _nHighIconColor;
        (*ppEffectClone)->_wpMenuAnimation = _wpMenuAnimation;
        (*ppEffectClone)->_fFontSmoothing = _fFontSmoothing;
        (*ppEffectClone)->_dwFontSmoothingType = _dwFontSmoothingType;
        (*ppEffectClone)->_fDragWindow = _fDragWindow;
        (*ppEffectClone)->_fKeyboardIndicators = _fKeyboardIndicators;
        (*ppEffectClone)->_dwAnimationEffect = _dwAnimationEffect;
        (*ppEffectClone)->_fMenuShadows = _fMenuShadows;

        (*ppEffectClone)->_nOldLargeIcon = _nOldLargeIcon;
        (*ppEffectClone)->_nOldHighIconColor = _nOldHighIconColor;
        (*ppEffectClone)->_wpOldMenuAnimation = _wpOldMenuAnimation;
        (*ppEffectClone)->_fOldFontSmoothing = _fOldFontSmoothing;
        (*ppEffectClone)->_dwOldFontSmoothingType = _dwOldFontSmoothingType;
        (*ppEffectClone)->_fOldDragWindow = _fOldDragWindow;
        (*ppEffectClone)->_fOldKeyboardIndicators = _fOldKeyboardIndicators;
        (*ppEffectClone)->_dwOldAnimationEffect = _dwOldAnimationEffect;
        (*ppEffectClone)->_fOldMenuShadows = _fOldMenuShadows;
    }

    return hr;
}



BOOL CEffectState::IsDirty(void)
{
    BOOL fDirty = FALSE;

    if ((_nLargeIcon != _nOldLargeIcon) ||
        (_nHighIconColor != _nOldHighIconColor) ||
        (_wpMenuAnimation != _wpOldMenuAnimation) ||
        (_fFontSmoothing != _fOldFontSmoothing) ||
        (_dwFontSmoothingType != _dwOldFontSmoothingType) ||
        (_fDragWindow != _fOldDragWindow) ||
        (_fMenuShadows != _fOldMenuShadows) ||
        (_fKeyboardIndicators != _fOldKeyboardIndicators) ||
        (_dwAnimationEffect != _dwOldAnimationEffect))
    {
        fDirty = TRUE;
    }

    return fDirty;
}



ULONG CEffectState::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CEffectState::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\themepg.h ===
/*****************************************************************************\
    FILE: ThemePg.h

    DESCRIPTION:
        This code will display a "Theme" tab in the
    "Display Properties" dialog (the base dialog, not the advanced dlg).

    BryanSt 3/23/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 1993-2000. All rights reserved.
\*****************************************************************************/

#ifndef _THEMEPG_H
#define _THEMEPG_H

#include <cowsite.h>
#include "PreviewTh.h"
#include "ThSettingsPg.h"


#define SIZE_ICONS_ARRAY           5

extern LPCWSTR s_Icons[SIZE_ICONS_ARRAY];

enum eThemeType
{
    eThemeFile = 0,
    eThemeURL,
    eThemeModified,
    eThemeOther,
};

typedef struct
{
    eThemeType type;
    union
    {
        ITheme * pTheme;
        LPWSTR pszUrl;
    };
} THEME_ITEM_BLOCK;


class CThemePage                : public CObjectWithSite
                                , public CObjectWindow
                                , public CObjectCLSID
                                , public IPropertyBag
                                , public IBasePropPage
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IShellPropSheetExt ***
    virtual STDMETHODIMP AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam);
    virtual STDMETHODIMP ReplacePage(IN EXPPS uPageID, IN LPFNSVADDPROPSHEETPAGE pfnReplaceWith, IN LPARAM lParam) {return E_NOTIMPL;}

    // *** IObjectWithSite ***
    virtual STDMETHODIMP SetSite(IUnknown *punkSite);

    // *** IPropertyBag ***
    virtual STDMETHODIMP Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog);
    virtual STDMETHODIMP Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar);

    // *** IBasePropPage ***
    virtual STDMETHODIMP GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog);
    virtual STDMETHODIMP OnApply(IN PROPPAGEONAPPLY oaAction);

    CThemePage();
protected:

private:
    virtual ~CThemePage(void);

    // Private Member Variables
    long                    m_cRef;

    HWND                    m_hwndThemeCombo;
    HWND                    m_hwndDeleteButton;
    int                     m_nPreviousSelected;        // Track the previously selected item so we can reset.
    HKEY                    m_hkeyFilter;               // We cache this key because it will probably be used 16 times.
    BOOL                    m_fFilters[ARRAYSIZE(g_szCBNames)];  // These are the theme filters
    ITheme *                m_pLastSelected;            // Used to see if the user selected the same item.
    ITheme *                m_pSelectedTheme;
    IThemePreview *         m_pThemePreview;
    IPropertyBag  *         m_pScreenSaverUI;
    IPropertyBag  *         m_pBackgroundUI;
    IPropertyBag  *         m_pAppearanceUI;            // Used to set the system metrics and visual style settings.
    LPWSTR                  m_pszThemeToApply;          // When the apply button is pressed, we need to apply this theme.
    LPWSTR                  m_pszThemeLaunched;         // When we open up, load this team because the caller wants that theme loaded when the dialog first opens.
    LPWSTR                  m_pszLastAppledTheme;       // If NULL, then the theme is modified, otherwise the path to the last applied theme file.
    LPWSTR                  m_pszModifiedName;          // This is the display name we use for the "xxx (Modified)" item.
    BOOL                    m_fInInit;
    BOOL                    m_fInited;                  // Have we loaded the settings yet?
    THEME_ITEM_BLOCK        m_Modified;

    // Private Member Functions
    INT_PTR _ThemeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    HRESULT _OnInitThemesDlg(HWND hDlg);
    HRESULT _OnDestroy(HWND hDlg);
    INT_PTR _OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    HRESULT _OnSetActive(HWND hDlg);
    HRESULT _OnApply(HWND hDlg, LPARAM lParam);
    HRESULT _OnSetSelection(IN int nIndex);
    HRESULT _OnSelectOther(void);
    HRESULT _OnThemeChange(HWND hDlg, BOOL fOnlySelect);

    HRESULT _OnOpenAdvSettingsDlg(HWND hDlg);
    HRESULT _FreeThemeDropdown(void);
    HRESULT _UpdatePreview(void);
    HRESULT _InitScreenSaver(void);
    HRESULT _InitFilterKey(void);
    HRESULT _LoadThemeFilterState(void);
    HRESULT _SaveThemeFilterState(void);
    HRESULT _RemoveTheme(int nIndex);

    HRESULT _SaveAs(void);
    HRESULT _DeleteTheme(void);
    HRESULT _EnableDeleteIfAppropriate(void);

    HRESULT _OnSetBackground(void);
    HRESULT _OnSetIcons(void);
    HRESULT _OnSetSystemMetrics(void);
    HRESULT _ApplyThemeFile(void);

    HRESULT _RemoveUserTheme(void);
    HRESULT _ChooseOtherThemeFile(IN LPCWSTR pszFile, BOOL fOnlySelect);
    HRESULT _LoadCustomizeValue(void);
    HRESULT _CustomizeTheme(void);
    HRESULT _HandleCustomizedEntre(void);
    HRESULT _PersistState(void);

    HRESULT _AddUrls(void);
    HRESULT _AddUrl(LPCTSTR pszDisplayName, LPCTSTR pszUrl);
    HRESULT _AddThemeFile(LPCTSTR pszDisplayName, int * pnIndex, ITheme * pTheme);
    ITheme * _GetThemeFile(int nIndex);
    LPCWSTR _GetThemeUrl(int nIndex);
    HRESULT _OnLoadThemeValues(ITheme * pTheme, BOOL fOnlySelect);
    HRESULT _DisplayThemeOpenErr(LPCTSTR pszOpenFile);

    BOOL _IsFiltered(IN DWORD dwFilter);
    BOOL _IsDirty(void);

    static INT_PTR CALLBACK ThemeDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};


#endif // _THEMEPG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\themefile.h ===
/*****************************************************************************\
    FILE: ThemeFile.h

    DESCRIPTION:
        This is the Autmation Object to theme scheme object.

    BryanSt 4/3/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _FILE_H_THEMEFILE
#define _FILE_H_THEMEFILE

#include <atlbase.h>


#define THEMESETTING_NORMAL         0x00000000
#define THEMESETTING_LOADINDIRECT   0x00000001

#define SIZE_CURSOR_ARRAY           15
#define SIZE_SOUNDS_ARRAY           30

typedef struct
{
    LPCTSTR pszRegKey;
    UINT nResourceID;
} THEME_FALLBACK_VALUES;


extern LPCTSTR s_pszCursorArray[SIZE_CURSOR_ARRAY];
extern THEME_FALLBACK_VALUES s_ThemeSoundsValues[SIZE_SOUNDS_ARRAY];

HRESULT CThemeFile_CreateInstance(IN LPCWSTR pszThemeFile, OUT ITheme ** ppTheme);


class CThemeFile                : public CImpIDispatch
                                , public CObjectWithSite
                                , public ITheme
                                , public IPropertyBag
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IPropertyBag ***
    virtual STDMETHODIMP Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog);
    virtual STDMETHODIMP Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar);

    // *** ITheme ***
    virtual STDMETHODIMP get_DisplayName(OUT BSTR * pbstrDisplayName);
    virtual STDMETHODIMP put_DisplayName(IN BSTR bstrDisplayName);
    virtual STDMETHODIMP get_Background(OUT BSTR * pbstrPath);
    virtual STDMETHODIMP put_Background(IN BSTR bstrPath);
    virtual STDMETHODIMP get_BackgroundTile(OUT enumBkgdTile * pnTile);
    virtual STDMETHODIMP put_BackgroundTile(IN enumBkgdTile nTile);
    virtual STDMETHODIMP get_ScreenSaver(OUT BSTR * pbstrPath);
    virtual STDMETHODIMP put_ScreenSaver(IN BSTR bstrPath);
    virtual STDMETHODIMP get_VisualStyle(OUT BSTR * pbstrPath);
    virtual STDMETHODIMP put_VisualStyle(IN BSTR bstrPath);
    virtual STDMETHODIMP get_VisualStyleColor(OUT BSTR * pbstrPath);
    virtual STDMETHODIMP put_VisualStyleColor(IN BSTR bstrPath);
    virtual STDMETHODIMP get_VisualStyleSize(OUT BSTR * pbstrPath);
    virtual STDMETHODIMP put_VisualStyleSize(IN BSTR bstrPath);

    virtual STDMETHODIMP GetPath(IN VARIANT_BOOL fExpand, OUT BSTR * pbstrPath);
    virtual STDMETHODIMP SetPath(IN BSTR bstrPath);
    virtual STDMETHODIMP GetCursor(IN BSTR bstrCursor, OUT BSTR * pbstrPath);
    virtual STDMETHODIMP SetCursor(IN BSTR bstrCursor, IN BSTR bstrPath);
    virtual STDMETHODIMP GetSound(IN BSTR bstrSoundName, OUT BSTR * pbstrPath);
    virtual STDMETHODIMP SetSound(IN BSTR bstrSoundName, IN BSTR bstrPath);
    virtual STDMETHODIMP GetIcon(IN BSTR bstrIconName, OUT BSTR * pbstrIconPath);
    virtual STDMETHODIMP SetIcon(IN BSTR bstrIconName, IN BSTR bstrIconPath);

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }


private:
    CThemeFile(LPCTSTR pszThemeFile);
    virtual ~CThemeFile(void);


    // Private Member Variables
    long                    m_cRef;

    LPTSTR                  m_pszThemeFile;
    DWORD                   m_dwCachedState;                        // Have we cached the state yet?
    SYSTEMMETRICSALL        m_systemMetrics;                        // This is the system metrics attributes in the file


    // Private Member Functions
    HRESULT _getThemeSetting(IN LPCWSTR pszIniSection, IN LPCWSTR pszIniKey, DWORD dwFlags, OUT BSTR * pbstrPath);
    HRESULT _putThemeSetting(IN LPCWSTR pszIniSection, IN LPCWSTR pszIniKey, BOOL fUTF7, IN LPWSTR pszPath);
    HRESULT _getIntSetting(IN LPCWSTR pszIniSection, IN LPCWSTR pszIniKey, int nDefault, OUT int * pnValue);
    HRESULT _putIntSetting(IN LPCWSTR pszIniSection, IN LPCWSTR pszIniKey, IN int nValue);
    HRESULT _LoadLiveSettings(int * pnDPI);        // Load the settings in memory
    HRESULT _LoadSettings(void);            // Load the settings in the .theme file.
    HRESULT _ApplyThemeSettings(void);
    HRESULT _ApplySounds(void);
    HRESULT _ApplyCursors(void);
    HRESULT _ApplyWebview(void);
    HRESULT _GetSound(LPCWSTR pszSoundName, OUT BSTR * pbstrPath);
    HRESULT _SaveSystemMetrics(SYSTEMMETRICSALL * pSystemMetrics);

    HRESULT _LoadCustomFonts(void);
    HRESULT _GetCustomFont(LPCTSTR pszFontName, LOGFONT * pLogFont);
    HRESULT _getThemeSetting(IN LPCWSTR pszIniSection, IN LPCWSTR pszIniKey, OUT BSTR * pbstrPath);

    BOOL _IsFiltered(IN DWORD dwFilter);
    BOOL _IsCached(IN BOOL fLoading);

    // Friend Functions
    friend HRESULT CThemeFile_CreateInstance(IN LPCWSTR pszThemeFile, OUT ITheme ** ppTheme);
};


#endif // _FILE_H_THEMEFILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\themeutils.h ===
/*****************************************************************************\
    FILE: themeutils.h

    DESCRIPTION:
        This class will load and save the "Theme" settings from their persisted
    state.

    BryanSt 5/26/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _THEMEUTIL_H
#define _THEMEUTIL_H


/////////////////////////////////////////////////////////////////////
// String Constants
/////////////////////////////////////////////////////////////////////
// Registry Strings
#define SZ_REGKEY_USERMETRICS           TEXT("Control Panel\\Desktop\\WindowMetrics")
#define SZ_REGKEY_CURRENTTHEME          TEXT("Software\\Microsoft\\Plus!\\Themes\\Current")     // Previously szPlus_CurTheme
#define SZ_REGKEY_PROGRAMFILES          TEXT("Software\\Microsoft\\Windows\\CurrentVersion")
#define SZ_REGKEY_PLUS95DIR             TEXT("Software\\Microsoft\\Plus!\\Setup")         // PLUS95_KEY
#define SZ_REGKEY_PLUS98DIR             TEXT("Software\\Microsoft\\Plus!98")          // PLUS98_KEY
#define SZ_REGKEY_KIDSDIR               TEXT("Software\\Microsoft\\Microsoft Kids\\Kids Plus!")   // KIDS_KEY
#define SZ_REGKEY_SOUNDS                TEXT("AppEvents\\Schemes")   

#define SZ_REGVALUE_PLUS95DIR           TEXT("DestPath")  // PLUS95_PATH
#define SZ_REGVALUE_PLUS98DIR           TEXT("Path")        // PLUS98_PATH
#define SZ_REGVALUE_KIDSDIR             TEXT("InstallDir")            // KIDS_PATH
#define SZ_REGVALUE_PROGRAMFILESDIR     TEXT("ProgramFilesDir")
#define SZ_REGVALUE_WALLPAPERSTYLE      TEXT("WallpaperStyle")
#define SZ_REGVALUE_TILEWALLPAPER       TEXT("TileWallpaper")
#define SZ_REGVALUE_STRETCH             TEXT("Stretch")


#define SZ_INISECTION_SCREENSAVER       TEXT("boot")
#define SZ_INISECTION_THEME             TEXT("Theme")
#define SZ_INISECTION_BACKGROUND        TEXT("Control Panel\\Desktop")
#define SZ_INISECTION_COLORS            TEXT("Control Panel\\Colors")
#define SZ_INISECTION_CURSORS           TEXT("Control Panel\\Cursors")
#define SZ_INISECTION_VISUALSTYLES      TEXT("VisualStyles")
#define SZ_INISECTION_MASTERSELECTOR    TEXT("MasterThemeSelector")
#define SZ_INISECTION_METRICS           TEXT("Metrics")
#define SZ_INISECTION_CONTROLINI        TEXT("control.ini")
#define SZ_INISECTION_SYSTEMINI         TEXT("system.ini")

#define SZ_INIKEY_SCREENSAVER           TEXT("SCRNSAVE.EXE")
#define SZ_INIKEY_BACKGROUND            TEXT("Wallpaper")
#define SZ_INIKEY_VISUALSTYLE           TEXT("Path")
#define SZ_INIKEY_VISUALSTYLECOLOR      TEXT("ColorStyle")
#define SZ_INIKEY_VISUALSTYLESIZE       TEXT("Size")
#define SZ_INIKEY_ICONMETRICS           TEXT("IconMetrics")
#define SZ_INIKEY_NONCLIENTMETRICS      TEXT("NonclientMetrics")
#define SZ_INIKEY_DEFAULTVALUE          TEXT("DefaultValue")
#define SZ_INIKEY_THEMEMAGICTAG         TEXT("MTSM")
#define SZ_INIKEY_THEMEMAGICVALUE       TEXT("DABJDKT")
#define SZ_INIKEY_DISPLAYNAME           TEXT("DisplayName")
#define SZ_INIKEY_CURSORSCHEME          TEXT("DefaultValue")




/////////////////////////////////////////////////////////////////////
// Data Structures
/////////////////////////////////////////////////////////////////////
// for ConfirmFile()
#define CF_EXISTS    1
#define CF_FOUND     2
#define CF_NOTFOUND  3




/////////////////////////////////////////////////////////////////////
// Shared Function
/////////////////////////////////////////////////////////////////////
HRESULT GetPlusThemeDir(IN LPTSTR pszPath, IN int cchSize);
HRESULT ExpandThemeTokens(IN LPCTSTR pszThemeFile, IN LPTSTR pszPath, IN int cchSize);
int ConfirmFile(IN LPTSTR lpszPath, IN BOOL bUpdate);
void InitFrost(void);
int WriteBytesToBuffer(IN LPTSTR pszInput, IN void * pOut, IN int cbSize);
void ConvertIconMetricsToWIDE(LPICONMETRICSA aIM, LPICONMETRICSW wIM);
void ConvertNCMetricsToWIDE(LPNONCLIENTMETRICSA aNCM, LPNONCLIENTMETRICSW wNCM);
void ConvertIconMetricsToANSI(LPICONMETRICSW wIM, LPICONMETRICSA aIM);
void ConvertNCMetricsToANSI(LPNONCLIENTMETRICSW wNCM, LPNONCLIENTMETRICSA aNCM);
void ConvertLogFontToANSI(LPLOGFONTW wLF, LPLOGFONTA aLF);
HRESULT ConvertBinaryToINIByteString(BYTE * pBytes, DWORD cbSize, LPWSTR * ppszStringOut);
COLORREF RGBStringToColor(LPTSTR lpszRGB);
BOOL IsValidThemeFile(IN LPCWSTR pszTest);
HRESULT GetIconMetricsFromSysMetricsAll(SYSTEMMETRICSALL * pSystemMetrics, LPICONMETRICSA pIconMetrics, DWORD cchSize);

void TransmitFontCharacteristics(PLOGFONT plfDst, PLOGFONT plfSrc, int iXmit);
#define TFC_STYLE    1
#define TFC_SIZE     2

/////////////////////////////////////////////////////////////////////
// The following functions are used to "SnapShot" settings and save
// or restore them from a .theme file.
/////////////////////////////////////////////////////////////////////
HRESULT SnapShotLiveSettingsToTheme(IPropertyBag * pPropertyBag, LPCWSTR pszPath, ITheme ** ppTheme);


#endif // _THEMEUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\themepg.cpp ===
/*****************************************************************************\
    FILE: ThemePg.cpp

    DESCRIPTION:
        This code will display a "Theme" tab in the
    "Display Properties" dialog (the base dialog, not the advanced dlg).

    BryanSt 3/23/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 1993-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "ThemePg.h"
#include "AdvAppearPg.h"
#include "ThSettingsPg.h"



//============================================================================================================
// *** Globals ***
//============================================================================================================
const static DWORD FAR aThemesHelpIds[] = {
        IDC_THPG_THEME_PREVIEW,         IDH_DISPLAY_THEMES_PREVIEW,         // Preview window
        IDC_THPG_THEMELIST,             IDH_DISPLAY_THEMES_LIST,            // Drop Down containing Plus! Themes
        IDC_THPG_THEMESETTINGS,         IDH_DISPLAY_THEMES_SETTINGS,        // "Properties" button to Advanced settings.
        IDC_THPG_THEMEDESCRIPTION,      (DWORD)-1,                          // 
        IDC_THPG_THEMENAME,             IDH_DISPLAY_THEMES_LIST,            // Title for Themes Drop Down
        IDC_THPG_SAMPLELABLE,           IDH_DISPLAY_THEMES_PREVIEW,         // Label for Preview
        IDC_THPG_SAVEAS,                IDH_DISPLAY_THEMES_SAVEAS,          // Button for Theme "Save As..."
        IDC_THPG_DELETETHEME,           IDH_DISPLAY_THEMES_DELETETHEME,     // Button for Theme "Delete"
        0, 0
};

#define SZ_HELPFILE_THEMES             TEXT("display.hlp")

// EnableApplyButton() fails in WM_INITDIALOG so we need to do it later.
#define WMUSER_DELAYENABLEAPPLY            (WM_USER + 1)
#define DelayEnableApplyButton(hDlg)    PostMessage(hDlg, WMUSER_DELAYENABLEAPPLY, 0, 0)

//===========================
// *** Class Internals & Helpers ***
//===========================
BOOL CThemePage::_IsDirty(void)
{
    BOOL fIsDirty = FALSE;

    if (m_pSelectedTheme)
    {
        fIsDirty = TRUE;
    }

    return fIsDirty;
}


INT_PTR CALLBACK CThemePage::ThemeDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CThemePage * pThis = (CThemePage *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        PROPSHEETPAGE * pPropSheetPage = (PROPSHEETPAGE *) lParam;

        if (pPropSheetPage)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, pPropSheetPage->lParam);
            pThis = (CThemePage *)pPropSheetPage->lParam;
        }
    }

    if (pThis)
        return pThis->_ThemeDlgProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}


HRESULT CThemePage::_OnOpenAdvSettingsDlg(HWND hDlg)
{
    IAdvancedDialog * pAdvDialog;
    HRESULT hr = GetAdvancedDialog(&pAdvDialog);

    if (SUCCEEDED(hr))
    {
        BOOL fEnableApply = FALSE;

        IUnknown_SetSite(pAdvDialog, SAFECAST(this, IObjectWithSite *));
        hr = pAdvDialog->DisplayAdvancedDialog(hDlg, SAFECAST(this, IPropertyBag *), &fEnableApply);
        IUnknown_SetSite(pAdvDialog, NULL);
        if (SUCCEEDED(hr) && fEnableApply)
        {
            EnableApplyButton(hDlg);
        }

        pAdvDialog->Release();
    }

    return hr;
}


HRESULT CThemePage::_EnableDeleteIfAppropriate(void)
{
    HRESULT hr = E_UNEXPECTED;
    BOOL fEnabled = FALSE;
    ITheme * pCurrent = m_pSelectedTheme;

    if (!pCurrent)
    {
        pCurrent = _GetThemeFile(ComboBox_GetCurSel(m_hwndThemeCombo));
    }

    if (pCurrent)
    {
        CComBSTR bstrPath;

        if (SUCCEEDED(pCurrent->GetPath(VARIANT_TRUE, &bstrPath)) &&
            bstrPath && bstrPath[0])
        {
            TCHAR szReadOnlyDir[MAX_PATH];
            TCHAR szCommonRoot[MAX_PATH];

            if (ExpandEnvironmentStrings(TEXT("%SystemRoot%\\Resources"), szReadOnlyDir, ARRAYSIZE(szReadOnlyDir)))
            {
                PathCommonPrefix(bstrPath, szReadOnlyDir, szCommonRoot);
                if (!StrStrI(szCommonRoot, szReadOnlyDir))
                {
                    fEnabled = TRUE;
                }
            }
        }
    }

    EnableWindow(m_hwndDeleteButton, fEnabled);
    return hr;
}



HRESULT CThemePage::_DeleteTheme(void)
{
    HRESULT hr = E_UNEXPECTED;

    if (m_pSelectedTheme)
    {
        CComBSTR bstrPath;

        if (SUCCEEDED(m_pSelectedTheme->GetPath(VARIANT_TRUE, &bstrPath)) &&
            bstrPath && bstrPath[0])
        {
            HCURSOR old = SetCursor(LoadCursor(NULL, IDC_WAIT));
            hr = HrSHFileOpDeleteFile(_hwnd, (FOF_NOCONFIRMATION | FOF_NOERRORUI), bstrPath);      // We use SHFileOperation so it will go into the Recycle Bin for undo reasons.
            SetCursor(old);

            if (FAILED(hr))
            {
                if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
                {
                    TCHAR szTitle[MAX_PATH];

                    LoadString(HINST_THISDLL, IDS_ERROR_THEME_DELETE_TITLE, szTitle, ARRAYSIZE(szTitle));
                    ErrorMessageBox(_hwnd, szTitle, IDS_ERROR_THEME_DELETE, hr, bstrPath, 0);
                }
            }
            else
            {
                int nIndex = ComboBox_GetCurSel(m_hwndThemeCombo);

                IUnknown_SetSite(m_pSelectedTheme, NULL);   // Break any back pointers.
                ATOMICRELEASE(m_pSelectedTheme);    // Indicate that we no longer need to apply anything.
                hr = _RemoveTheme(nIndex);
                if (SUCCEEDED(hr))
                {
                    if (!_GetThemeFile(nIndex))
                    {
                        // Now we want to select the next item in the list.  However we want to avoid
                        // choosing "Browse..." because that will bring up the dialog.
                        for (nIndex = 0; nIndex < ComboBox_GetCount(m_hwndThemeCombo); nIndex++)
                        {
                            if (_GetThemeFile(nIndex))
                            {
                                break;
                            }
                        }
                    }

                    if (_GetThemeFile(nIndex))
                    {
                        // We found something good.
                        ComboBox_SetCurSel(m_hwndThemeCombo, nIndex);
                        _OnThemeChange(_hwnd, FALSE);
                    }
                }
            }
        }
    }

    return hr;
}


HRESULT CThemePage::_SaveAs(void)
{
    TCHAR szFileName[MAX_PATH];
    TCHAR szPath[MAX_PATH];

    LoadString(HINST_THISDLL, IDS_DEFAULTTHEMENAME, szFileName, ARRAYSIZE(szFileName));
    HRESULT hr = SHGetFolderPath(NULL, CSIDL_PERSONAL, NULL, 0, szPath);
    if (SUCCEEDED(hr) && _punkSite)
    {
        OPENFILENAME ofn = { 0 };
        TCHAR szFilter[MAX_PATH];

        LoadString(HINST_THISDLL, IDS_THEME_FILTER, szFilter, ARRAYSIZE(szFilter)-2);
        int nLen = lstrlen(szFilter);
        nLen += lstrlen(&szFilter[nLen+1]);
        szFilter[nLen+2] = szFilter[nLen+3] = 0;
        PathAppend(szPath, szFileName);

        ofn.lStructSize = sizeof(ofn);
        ofn.hwndOwner = _hwnd;
        ofn.hInstance = HINST_THISDLL;
        ofn.lpstrFilter = szFilter;
        ofn.nFilterIndex = 1;
        ofn.lpstrFile = szPath;
        ofn.nMaxFile = ARRAYSIZE(szPath);
        ofn.lpstrDefExt = TEXT("theme");
        ofn.Flags = (OFN_EXPLORER | OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT | OFN_ENABLESIZING);

        // 1. Display SaveAs... dialog
        if (GetSaveFileName(&ofn))
        {
            IPropertyBag * pPropertyBag = NULL;

            hr = _punkSite->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
            if (SUCCEEDED(hr))
            {
                ITheme * pTheme;
                TCHAR szDisplayName[MAX_PATH];
                HCURSOR old = SetCursor(LoadCursor(NULL, IDC_WAIT));

                StrCpyN(szDisplayName, PathFindFileName(szPath), ARRAYSIZE(szPath));
                PathRemoveExtension(szDisplayName);
                hr = SnapShotLiveSettingsToTheme(pPropertyBag, szPath, &pTheme);
                SetCursor(old);

                if (SUCCEEDED(hr))
                {
                    CComBSTR bstrName(szDisplayName);

                    Str_SetPtr(&m_pszLastAppledTheme, szPath);
                    hr = pTheme->put_DisplayName(NULL);
                    if (SUCCEEDED(hr))
                    {
                        _ChooseOtherThemeFile(szPath, TRUE);
                    }
                    pTheme->Release();
                }

                pPropertyBag->Release();
            }
        }
    }

    return hr;
}


HRESULT CThemePage::_RemoveTheme(int nIndex)
{
    HRESULT hr = E_FAIL;
    LPARAM lParam = ComboBox_GetItemData(m_hwndThemeCombo, nIndex);

    if (CB_ERR != lParam)
    {
        THEME_ITEM_BLOCK * pThemeItemBock = (THEME_ITEM_BLOCK *) lParam;

        if (pThemeItemBock && (pThemeItemBock != &m_Modified))
        {
            if (eThemeFile == pThemeItemBock->type)
            {
                ATOMICRELEASE(pThemeItemBock->pTheme);
            }
            else if (eThemeURL == pThemeItemBock->type)
            {
                Str_SetPtr(&(pThemeItemBock->pszUrl), NULL);
            }

            LocalFree(pThemeItemBock);
        }

        ComboBox_DeleteString(m_hwndThemeCombo, nIndex);
        hr = S_OK;
    }

    return hr;
}


HRESULT CThemePage::_FreeThemeDropdown(void)
{
    HRESULT hr = S_OK;

    if (m_hwndThemeCombo)
    {
        do
        {
            // Remove the themes fromt he list..
        }
        while (SUCCEEDED(_RemoveTheme(0)));
    }

    return hr;
}


HRESULT IUnknown_GetBackground(IUnknown * punk, LPTSTR pszPath, DWORD cchSize)
{
    HRESULT hr = E_FAIL;

    if (punk)
    {
        IPropertyBag * ppb;

        hr = punk->QueryInterface(IID_PPV_ARG(IPropertyBag, &ppb));
        if (SUCCEEDED(hr))
        {
            hr = SHPropertyBag_ReadStr(ppb, SZ_PBPROP_BACKGROUNDSRC_PATH, pszPath, cchSize);
            ppb->Release();
        }
    }

    return hr;
}


/*****************************************************************************\
    DESCRIPTION:
        This function will determine the currently applied theme.  It will then
    have it selected from the list or select "Custom" if appropriate.

    STATES:
        When the CPL opens, the currently selected .theme can be:
    1. "<Theme Name> (Modified)".  This means the "ThemeFile" regkey will be empty
       and "DisplayName of Modified" will contain the name.  In this case m_pszModifiedName
       will contain that display name.
    2. Any .theme file.  In this case, any .theme file is selected.  "ThemeFile" will
       have the path to the file.
\*****************************************************************************/
HRESULT CThemePage::_LoadCustomizeValue(void)
{
    HRESULT hr = S_OK;
    TCHAR szPath[MAX_PATH];
    DWORD cbSize = sizeof(szPath);
    DWORD dwType;

    // See if the user has choosen a value in the past.
    hr = HrRegGetPath(HKEY_CURRENT_USER, SZ_REGKEY_LASTTHEME, SZ_REGVALUE_LT_THEMEFILE, szPath, ARRAYSIZE(szPath)); 
    if (FAILED(hr))
    {
        // Get the global value.
        hr = HrRegGetPath(HKEY_LOCAL_MACHINE, SZ_REGKEY_LASTTHEME, SZ_REGVALUE_LT_THEMEFILE, szPath, ARRAYSIZE(szPath)); 
    }

    if (SUCCEEDED(hr))
    {
        // They have, so we use it as long as nothing has changed (like someone changing the background from the outside)
        TCHAR szWallpaper[MAX_PATH];

        if (szPath[0] &&
            SUCCEEDED(HrRegGetPath(HKEY_CURRENT_USER, SZ_REGKEY_LASTTHEME, SZ_REGVALUE_LT_WALLPAPER, szWallpaper, ARRAYSIZE(szWallpaper))) &&
            _punkSite)
        {
            TCHAR szCurrWallpaper[MAX_PATH];

            if (SUCCEEDED(IUnknown_GetBackground(_punkSite, szCurrWallpaper, ARRAYSIZE(szCurrWallpaper))))
            {
                PathExpandEnvStringsWrap(szCurrWallpaper, ARRAYSIZE(szCurrWallpaper));
                if (StrCmpI(szCurrWallpaper, szWallpaper))
                {
                    TCHAR szName[MAX_PATH];

                    cbSize = sizeof(szName);
                    if (SUCCEEDED(HrSHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_LASTTHEME, SZ_REGVALUE_MODIFIED_DISPNAME, &dwType, (LPVOID) szName, &cbSize)) &&
                        !szName[0])
                    {
                        // We don't have a good custom name so force one now.  This happens when
                        // We have a valid theme but someone makes a modification by using IE to
                        // change the wallpaper.
                        Str_SetPtr(&m_pszLastAppledTheme, szPath);
                        _CustomizeTheme();
                    }

                    // Someone changed the wallpaper outside of our UI so we need to treat the theme as "Customized"
                    szPath[0] = 0;
                }
            }
        }
    }

    if (FAILED(hr))
    {
        // Treat it as customized
        szPath[0] = 0;
    }

    if (!szPath[0])
    {
        TCHAR szName[MAX_PATH];

        szName[0] = 0;
        cbSize = sizeof(szName);
        if (FAILED(HrSHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_LASTTHEME, SZ_REGVALUE_MODIFIED_DISPNAME, &dwType, (LPVOID) szName, &cbSize)) || !szName[0])
        {
            LoadString(HINST_THISDLL, IDS_MODIFIED_FALLBACK, szName, ARRAYSIZE(szName));
        }

        Str_SetPtr(&m_pszModifiedName, szName);   // This means the theme is customized.
    }

    Str_SetPtr(&m_pszLastAppledTheme, (szPath[0] ? szPath : NULL));   // This means the theme is customized.

    hr = _HandleCustomizedEntre();
    if (szPath[0])
    {
        // Now we need to select the item from the list.
        hr = _ChooseOtherThemeFile(szPath, TRUE);
    }

    m_fInited = TRUE;
    return hr;
}


/*****************************************************************************\
    DESCRIPTION:
        This function is called if someone modified a value in the theme.  Since
    they have modified it, we want the display name to change so:
    a. They know that it's not the same, and
    b. They can switch back if they don't like the modifications.

    This function will create the new Display Name, normally "Football 200 (Modified)"
    and call to have it added to the drop down.
\*****************************************************************************/
HRESULT CThemePage::_CustomizeTheme(void)
{
    // Are we already
    if (m_pszLastAppledTheme)
    {
        Str_SetPtr(&m_pszModifiedName, NULL);

        if (m_pSelectedTheme)
        {
            CComBSTR bstrDisplayName;

            if (SUCCEEDED(m_pSelectedTheme->get_DisplayName(&bstrDisplayName)))
            {
                TCHAR szTemplate[MAX_PATH];
                TCHAR szDisplayName[MAX_PATH];

                LoadStringW(HINST_THISDLL, IDS_MODIFIED_TEMPLATE, szTemplate, ARRAYSIZE(szTemplate));
                wnsprintf(szDisplayName, ARRAYSIZE(szDisplayName), szTemplate, bstrDisplayName);
                Str_SetPtr(&m_pszModifiedName, szDisplayName);
            }
        }

        if (!m_pszModifiedName)
        {
            TCHAR szDisplayName[MAX_PATH];

            LoadStringW(HINST_THISDLL, IDS_MODIFIED_FALLBACK, szDisplayName, ARRAYSIZE(szDisplayName));
            Str_SetPtr(&m_pszModifiedName, szDisplayName);
        }

        Str_SetPtr(&m_pszLastAppledTheme, NULL);   // This means the theme is customized.
    }

    return _HandleCustomizedEntre();
}


/*****************************************************************************\
    DESCRIPTION:
        This function will add the "Modified" item to the menu if needed and select
    it.  Or it will remove it if appropriate.
\*****************************************************************************/
HRESULT CThemePage::_HandleCustomizedEntre(void)
{
    HRESULT hr = S_OK;

    // If m_pszLastAppledTheme is NULL, then we want to make sure "<ThemeName> (Modified)" is
    // in the list and is selected.
    if (!m_pszLastAppledTheme)
    {
        // We now know we want one to exist and to select it.
        THEME_ITEM_BLOCK * pThemeItemBock = (THEME_ITEM_BLOCK *) ComboBox_GetItemData(m_hwndThemeCombo, 0);

        if (m_pszModifiedName)
        {
            // We now need to update the name or add it.
            if (pThemeItemBock && ((THEME_ITEM_BLOCK *)CB_ERR != pThemeItemBock) && (eThemeModified == pThemeItemBock->type))
            {
                // It already exists so we need to update the title to make it up to date.
                _RemoveUserTheme();
                int nIndex = ComboBox_InsertString(m_hwndThemeCombo, 0, m_pszModifiedName);
                if ((CB_ERR != nIndex) && (CB_ERRSPACE != nIndex))
                {
                    if (CB_ERR == ComboBox_SetItemData(m_hwndThemeCombo, 0, &m_Modified))
                    {
                        hr = E_FAIL;
                    }
                }
            }
            else
            {
                // If it isn't found, so add it.
                int nIndex = ComboBox_InsertString(m_hwndThemeCombo, 0, m_pszModifiedName);
                if ((CB_ERR != nIndex) && (CB_ERRSPACE != nIndex))
                {
                    if (CB_ERR == ComboBox_SetItemData(m_hwndThemeCombo, 0, &m_Modified))
                    {
                        hr = E_FAIL;
                    }
                }
            }
        }

        _OnSetSelection(0);
        m_nPreviousSelected = 0;
    }

    return hr;
}


HRESULT CThemePage::_RemoveUserTheme(void)
{
    HRESULT hr = S_OK;
    THEME_ITEM_BLOCK * pThemeItemBock = (THEME_ITEM_BLOCK *) ComboBox_GetItemData(m_hwndThemeCombo, 0);

    // We now need to update the name or add it.
    if (pThemeItemBock && ((THEME_ITEM_BLOCK *)CB_ERR != pThemeItemBock) && (eThemeModified == pThemeItemBock->type))
    {
        ComboBox_DeleteString(m_hwndThemeCombo, 0);
    }

    return hr;
}


ITheme * CThemePage::_GetThemeFile(int nIndex)
{
    ITheme * pTheme = NULL;
    THEME_ITEM_BLOCK * pThemeItemBock = (THEME_ITEM_BLOCK *) ComboBox_GetItemData(m_hwndThemeCombo, nIndex);

    if (((THEME_ITEM_BLOCK *)CB_ERR != pThemeItemBock) && pThemeItemBock && (eThemeFile == pThemeItemBock->type))
    {
        pTheme = pThemeItemBock->pTheme;
    }

    return pTheme;
}


LPCWSTR CThemePage::_GetThemeUrl(int nIndex)
{
    LPCWSTR pszUrl = NULL;
    THEME_ITEM_BLOCK * pThemeItemBock = (THEME_ITEM_BLOCK *) ComboBox_GetItemData(m_hwndThemeCombo, nIndex);

    if (((THEME_ITEM_BLOCK *)CB_ERR != pThemeItemBock) && pThemeItemBock && (eThemeURL == pThemeItemBock->type))
    {
        pszUrl = pThemeItemBock->pszUrl;
    }

    return pszUrl;
}


HRESULT CThemePage::_AddThemeFile(LPCTSTR pszDisplayName, int * pnIndex, ITheme * pTheme)
{
    THEME_ITEM_BLOCK * pThemeItemBock = (THEME_ITEM_BLOCK *) LocalAlloc(LPTR, sizeof(*pThemeItemBock));
    HRESULT hr = (pThemeItemBock ? S_OK : E_OUTOFMEMORY);

    if (SUCCEEDED(hr))
    {
        int nAddIndex;

        if (!pnIndex)
        {
            nAddIndex = ComboBox_AddString(m_hwndThemeCombo, pszDisplayName);
        }
        else
        {
            nAddIndex = ComboBox_InsertString(m_hwndThemeCombo, *pnIndex, pszDisplayName);
            *pnIndex = nAddIndex;
        }

        pThemeItemBock->type = eThemeFile;
        pThemeItemBock->pTheme = pTheme;
        if ((CB_ERR != nAddIndex) && (CB_ERRSPACE != nAddIndex))
        {
            if (CB_ERR == ComboBox_SetItemData(m_hwndThemeCombo, nAddIndex, pThemeItemBock))
            {
                hr = E_FAIL;
            }
        }
        else
        {
            LocalFree(pThemeItemBock);
        }
    }

    return hr;
}


HRESULT CThemePage::_AddUrl(LPCTSTR pszDisplayName, LPCTSTR pszUrl)
{
    THEME_ITEM_BLOCK * pThemeItemBock = (THEME_ITEM_BLOCK *) LocalAlloc(LPTR, sizeof(*pThemeItemBock));
    HRESULT hr = (pThemeItemBock ? S_OK : E_OUTOFMEMORY);

    if (SUCCEEDED(hr))
    {
        LPTSTR pszUrlDup = NULL;
        
        Str_SetPtr(&pszUrlDup, pszUrl);
        if (pszUrlDup)
        {
            int nAddIndex = ComboBox_AddString(m_hwndThemeCombo, pszDisplayName);

            pThemeItemBock->type = eThemeURL;
            pThemeItemBock->pszUrl = pszUrlDup;
            if ((CB_ERR != nAddIndex) && (CB_ERRSPACE != nAddIndex))
            {
                ComboBox_SetItemData(m_hwndThemeCombo, nAddIndex, pThemeItemBock);
            }
            else
            {
                LocalFree(pThemeItemBock);
            }
        }
        else
        {
            LocalFree(pThemeItemBock);
        }
    }

    return hr;
}


HRESULT CThemePage::_AddUrls(void)
{
    HKEY hKey;
    DWORD dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_REGKEY_THEME_SITES, 0, KEY_READ, &hKey);
    HRESULT hr = HRESULT_FROM_WIN32(dwError);

    if (SUCCEEDED(hr))
    {
        for (DWORD dwIndex = 0; SUCCEEDED(hr); dwIndex++)
        {
            TCHAR szValue[MAXIMUM_SUB_KEY_LENGTH];

            dwError = RegEnumKey(hKey, dwIndex, szValue, ARRAYSIZE(szValue));
            hr = HRESULT_FROM_WIN32(dwError);

            if (SUCCEEDED(hr))
            {
                TCHAR szURL[MAX_URL_STRING];
                DWORD dwType;
                DWORD cbSize = sizeof(szURL);

                if ((ERROR_SUCCESS == SHGetValue(hKey, szValue, TEXT("URL"), &dwType, (void *)szURL, &cbSize)) &&
                    (REG_SZ == dwType))
                {
                    HKEY hKeyURL;

                    if (ERROR_SUCCESS == RegOpenKeyEx(hKey, szValue, 0, KEY_READ, &hKeyURL))
                    {
                        TCHAR szDisplayName[MAX_PATH];
        
                        if (SUCCEEDED(SHLoadRegUIString(hKeyURL, TEXT("DisplayName"), szDisplayName, ARRAYSIZE(szDisplayName))))
                        {
                            _AddUrl(szDisplayName, szURL);
                        }

                        RegCloseKey(hKeyURL);
                    }
                }

            }
        }

        hr = S_OK;
        RegCloseKey(hKey);
    }

    return hr;
}


BOOL DoesThemeHaveAVisualStyle(ITheme * pTheme)
{
    BOOL fHasVisualStyle = FALSE;
    CComBSTR bstrPath;

    if (SUCCEEDED(pTheme->get_VisualStyle(&bstrPath)) &&
        bstrPath && bstrPath[0])
    {
        fHasVisualStyle = TRUE;
    }

    return fHasVisualStyle;
}


HRESULT CThemePage::_OnInitThemesDlg(HWND hDlg)
{
    HRESULT hr = E_FAIL;

    m_fInInit = TRUE;
    _FreeThemeDropdown();    // Purge any existing items.

    AssertMsg((NULL != _punkSite), TEXT("We need our site pointer in order to save the settings."));
    if (_punkSite)
    {
        IThemeManager * pThemeManager;

        _hwnd = hDlg;
        m_hwndThemeCombo = GetDlgItem(hDlg, IDC_THPG_THEMELIST);
        m_hwndDeleteButton = GetDlgItem(hDlg, IDC_THPG_DELETETHEME);

        hr = _punkSite->QueryInterface(IID_PPV_ARG(IThemeManager, &pThemeManager));
        if (SUCCEEDED(hr))
        {
            VARIANT varIndex;
            BOOL fVisualStylesSupported = (QueryThemeServicesWrap() & QTS_AVAILABLE);

            LogStatus("QueryThemeServices() returned %hs\r\n", (fVisualStylesSupported ? "TRUE" : "FALSE"));

            IUnknown_SetSite(m_pSelectedTheme, NULL);   // Break any back pointers.
            ATOMICRELEASE(m_pSelectedTheme);

            varIndex.vt = VT_I4;
            for (varIndex.lVal = 0; SUCCEEDED(hr); varIndex.lVal++)
            {
                ITheme * pTheme;

                hr = pThemeManager->get_item(varIndex, &pTheme);
                if (SUCCEEDED(hr))
                {
                    if (!fVisualStylesSupported && DoesThemeHaveAVisualStyle(pTheme))
                    {
                        // Filter out .theme files if they have a .msstyles file and the
                        // system doesn't currently support visual styles.
                    }
                    else
                    {
                        CComBSTR bstrDisplayName;

                        IUnknown_SetSite(pTheme, _punkSite);
                        hr = pTheme->get_DisplayName(&bstrDisplayName);
                        IUnknown_SetSite(pTheme, NULL); // This prevents leaking the site object.
                        if (SUCCEEDED(hr))
                        {
                            hr = _AddThemeFile(bstrDisplayName, NULL, pTheme);
                            if (SUCCEEDED(hr))
                            {
                                pTheme = NULL;
                            }
                        }
                    }

                    ATOMICRELEASE(pTheme);
                }
            }

            hr = S_OK;

            _UpdatePreview();
            pThemeManager->Release();
        }

        // Add Web URLs
        _AddUrls();

        // Add the "Other..." entre
        WCHAR szOtherTheme[MAX_PATH];
        LoadStringW(HINST_THISDLL, IDS_THEME_OTHER, szOtherTheme, ARRAYSIZE(szOtherTheme));
        ComboBox_AddString(m_hwndThemeCombo, szOtherTheme);

        _LoadCustomizeValue();
        m_nPreviousSelected = ComboBox_GetCurSel(m_hwndThemeCombo);
        if (m_pszThemeLaunched)
        {
            hr = _ChooseOtherThemeFile(m_pszThemeLaunched, FALSE);
            DelayEnableApplyButton(_hwnd);
        }
        _EnableDeleteIfAppropriate();
    }

    m_fInInit = FALSE;
    return hr;
}


#define SZ_EXTENSION            L".Theme"

HRESULT CThemePage::_ChooseOtherThemeFile(IN LPCWSTR pszFile, BOOL fOnlySelect)
{
    HRESULT hr = E_FAIL;

    // Get results and check that it is a valid theme file
    if (!IsValidThemeFile(pszFile))
    {
        TCHAR szErrorMessage[MAX_URL_STRING];
        TCHAR szTitle[MAX_PATH];
        TCHAR szMessage[MAX_URL_STRING];

        // Bad file: post msg before going back to common open
        LoadString(HINST_THISDLL, IDS_ERROR_THEME_INVALID_TITLE, szTitle, ARRAYSIZE(szTitle));
        LoadString(HINST_THISDLL, IDS_ERROR_THEME_INVALID, szErrorMessage, ARRAYSIZE(szErrorMessage));
        wnsprintf(szMessage, ARRAYSIZE(szMessage), szErrorMessage, pszFile);

        MessageBox(m_hwndThemeCombo, szMessage, szTitle, (MB_OK | MB_ICONERROR | MB_APPLMODAL));
    }
    else
    {
        // Now we want to:
        int nSlot = -1;
        int nCount = ComboBox_GetCount(m_hwndThemeCombo);
        int nIndex;

        hr = S_OK;

        // 1. Is it in the list already?
        for (nIndex = 0; nIndex < nCount; nIndex++)
        {
            ITheme * pTheme = _GetThemeFile(nIndex);

            if (pTheme)
            {
                CComBSTR bstrPath;

                hr = pTheme->GetPath(VARIANT_TRUE, &bstrPath);
                if (SUCCEEDED(hr))
                {
                    if (!StrCmpIW(bstrPath, pszFile))
                    {
                        // We found it, so stop looking.
                        nSlot = nIndex;
                        break;
                    }
                }
            }
        }

        // 2. If it is not in the list, add it.  We put it on the bottom, right above "Other...".
        if (-1 == nSlot)
        {
            ITheme * pThemeNew;

            hr = CThemeFile_CreateInstance(pszFile, &pThemeNew);
            if (SUCCEEDED(hr))
            {
                CComBSTR bstrDisplayName;

                hr = pThemeNew->get_DisplayName(&bstrDisplayName);
                if (SUCCEEDED(hr))
                {
                    nIndex = ComboBox_GetCount(m_hwndThemeCombo);

                    if (nIndex > 1)
                    {
                        nIndex -= 1;
                    }

                    hr = _AddThemeFile(bstrDisplayName, &nIndex, pThemeNew);
                    nSlot = nIndex;
                }

                if (FAILED(hr))
                {
                    pThemeNew->Release();
                }
            }
        }

        if (-1 != nSlot)
        {
            ComboBox_SetCurSel(m_hwndThemeCombo, nIndex);
            _EnableDeleteIfAppropriate();

            // 3. Select the theme from the list.
            if (CB_ERR != ComboBox_GetItemData(m_hwndThemeCombo, ComboBox_GetCurSel(m_hwndThemeCombo)))
            {
                // Okay, we now know we won't recurse infinitely, so let's recurse.
                hr = _OnThemeChange(_hwnd, fOnlySelect);
            }
            else
            {
                hr = E_FAIL;
                AssertMsg(0, TEXT("We should have correctly selected the item.  Please investiate.  -BryanSt"));
            }
        }
        else
        {
            hr = E_FAIL;
        }
        // POSSIBLE USABILITY REFINEMENT:
        // We want to add this directory to the MRU because it may have other themes or we should allow it to be available later.
    }

    return hr;
}


// This function is isolated in order to reduce stack space.
HRESULT CThemePage::_DisplayThemeOpenErr(LPCTSTR pszOpenFile)
{
    TCHAR szErrorMessage[MAX_PATH];
    TCHAR szTitle[MAX_PATH];
    TCHAR szMessage[MAX_PATH];

    // Bad file: post msg before going back to common open
    LoadString(HINST_THISDLL, IDS_ERROR_THEME_INVALID_TITLE, szTitle, ARRAYSIZE(szTitle));
    LoadString(HINST_THISDLL, IDS_ERROR_THEME_INVALID, szErrorMessage, ARRAYSIZE(szErrorMessage));
    wnsprintf(szMessage, ARRAYSIZE(szMessage), szErrorMessage, pszOpenFile);

    MessageBox(m_hwndThemeCombo, szMessage, szTitle, (MB_OK | MB_ICONERROR | MB_APPLMODAL));
    return HRESULT_FROM_WIN32(ERROR_CANCELLED);           // We already displayed an error dialog so don't do it later.
}


HRESULT CThemePage::_OnSelectOther(void)
{
    HRESULT hr = E_FAIL;
    OPENFILENAME ofnOpen = {0};
    WCHAR szOpenFile[MAX_PATH];
    WCHAR szFileSpec[MAX_PATH];
    WCHAR szCurrentDirectory[MAX_PATH];
    WCHAR szTitle[MAX_PATH];

    LoadStringW(HINST_THISDLL, IDS_THEME_OPENTITLE, szTitle, ARRAYSIZE(szTitle));
    LoadStringW(HINST_THISDLL, IDS_THEME_FILETYPE, szFileSpec, ARRAYSIZE(szFileSpec)-2);

    DWORD cchSize = lstrlenW(szFileSpec);
    szFileSpec[cchSize + 1] = szFileSpec[cchSize + 2] = 0;      // Add the double NULLs to the end.
    LPWSTR pszEnd = StrChrW(szFileSpec, L'|');
    if (pszEnd)
    {
        pszEnd[0] = 0;
    }

    DWORD dwError = SHRegGetPath(HKEY_CURRENT_USER, SZ_REGKEY_IE_DOWNLOADDIR, SZ_REGVALUE_IE_DOWNLOADDIR, szCurrentDirectory, 0);
    if (ERROR_SUCCESS != dwError)
    {
        SHGetFolderPath(NULL, CSIDL_PROGRAM_FILES, NULL, 0, szCurrentDirectory);
    }
    hr = E_FAIL;
    do
    {
        StrCpyNW(szOpenFile, L"*" SZ_EXTENSION, ARRAYSIZE(szOpenFile));  // start w/ *.Theme

        ofnOpen.lStructSize = sizeof(OPENFILENAME);
        ofnOpen.hwndOwner = m_hwndThemeCombo;
        ofnOpen.lpstrFilter = szFileSpec;
        ofnOpen.lpstrCustomFilter = NULL;
        ofnOpen.nMaxCustFilter = 0;
        ofnOpen.nFilterIndex = 1;
        ofnOpen.lpstrFile = szOpenFile;
        ofnOpen.nMaxFile = ARRAYSIZE(szOpenFile);
        ofnOpen.lpstrFileTitle = NULL; // szFileTitle;
        ofnOpen.nMaxFileTitle = 0;             // sizeof(szFileTitle);
        ofnOpen.lpstrInitialDir = szCurrentDirectory;
        ofnOpen.lpstrTitle = szTitle;
        ofnOpen.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
        ofnOpen.lpstrDefExt = CharNextW(SZ_EXTENSION);

        // NOTE: We could make the UI much better by providing a OFNHookProc with the CDN_FILEOK flag.  This would allow
        // us to verify the file without closing the dialog.

        // Display the File Open dialog.
        if (!GetOpenFileNameW(&ofnOpen))
        {
            // If they didn't open a file, could be hit cancel but
            // also check for lowmem return

            // select old theme in list
            ComboBox_SetCurSel(m_hwndThemeCombo, m_nPreviousSelected);
            _EnableDeleteIfAppropriate();
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);       // We don't need to display any error dialogs later since the user cancelled.
            break;
        }
        else
        {
            // Get results and check that it is a valid theme file
            if (!IsValidThemeFile(szOpenFile))
            {
                hr = _DisplayThemeOpenErr(szOpenFile);
            }
            else
            {
                hr = S_OK;
            }
        }
    }
    while (FAILED(hr));

    if (SUCCEEDED(hr))
    {
        hr = _ChooseOtherThemeFile(szOpenFile, FALSE);
    }

    return hr;
}


HRESULT CThemePage::_LoadThemeFilterState(void)
{
    HRESULT hr = _InitFilterKey();

    if (SUCCEEDED(hr))
    {
        DWORD dwType;
        WCHAR szEnabled[5];
        DWORD cbSize;

        COMPILETIME_ASSERT(ARRAYSIZE(g_szCBNames) == ARRAYSIZE(m_fFilters));
        for (int nIndex = 0; nIndex < ARRAYSIZE(g_szCBNames); nIndex++)
        {
            m_fFilters[nIndex] = TRUE; // Default to true.
            cbSize = sizeof(szEnabled);

            if (SUCCEEDED(HrRegQueryValueEx(m_hkeyFilter, &(g_szCBNames[nIndex][SIZE_THEME_FILTER_STR]), 0, &dwType, (LPBYTE) szEnabled, &cbSize)) &&
                !StrCmpIW(szEnabled, L"0"))
            {
                m_fFilters[nIndex] = FALSE;
            }
        }
    }

    return hr;
}


HRESULT CThemePage::_SaveThemeFilterState(void)
{
    HRESULT hr = _InitFilterKey();

    if (SUCCEEDED(hr))
    {
        for (int nIndex = 0; nIndex < ARRAYSIZE(g_szCBNames); nIndex++)
        {
            hr = HrRegSetValueString(m_hkeyFilter, NULL, &(g_szCBNames[nIndex][SIZE_THEME_FILTER_STR]), (m_fFilters[nIndex] ? L"1" : L"0"));
        }
    }

    return hr;
}




HRESULT CThemePage::_UpdatePreview(void)
{
    HRESULT hr = S_OK;

    if (!m_pThemePreview)
    {
        hr = CThemePreview_CreateInstance(NULL, IID_PPV_ARG(IThemePreview, &m_pThemePreview));
        if (SUCCEEDED(hr) && _punkSite)
        {
            IPropertyBag * pPropertyBag;

            hr = _punkSite->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
            if (SUCCEEDED(hr))
            {
                HWND hwndParent = GetParent(m_hwndThemeCombo);
                HWND hwndPlaceHolder = GetDlgItem(hwndParent, IDC_THPG_THEME_PREVIEW);
                RECT rcPreview;

                AssertMsg((NULL != m_hwndThemeCombo), TEXT("We should have this window at this point.  -BryanSt"));
                GetClientRect(hwndPlaceHolder, &rcPreview);
                MapWindowPoints(hwndPlaceHolder, hwndParent, (LPPOINT)&rcPreview, 2);

                hr = m_pThemePreview->CreatePreview(hwndParent, TMPREV_SHOWBKGND | TMPREV_SHOWICONS | TMPREV_SHOWVS, WS_VISIBLE | WS_CHILDWINDOW | WS_BORDER | WS_OVERLAPPED, WS_EX_CLIENTEDGE, rcPreview.left, rcPreview.top, RECTWIDTH(rcPreview), RECTHEIGHT(rcPreview), pPropertyBag, IDC_THPG_THEME_PREVIEW);
                if (SUCCEEDED(hr))
                {
                    IPropertyBag * pPropertyBag;

                    // If we succeeded, remove the dummy window.
                    DestroyWindow(hwndPlaceHolder);

                    hr = _punkSite->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
                    if (SUCCEEDED(hr))
                    {
                        hr = SHPropertyBag_WritePunk(pPropertyBag, SZ_PBPROP_PREVIEW1, m_pThemePreview);
                        pPropertyBag->Release();
                    }
                }

                pPropertyBag->Release();
            }
        }
    }
    else if (_punkSite)
    {
        IThemeUIPages * pThemeUIPages;

        hr = _punkSite->QueryInterface(IID_PPV_ARG(IThemeUIPages, &pThemeUIPages));
        if (SUCCEEDED(hr))
        {
            hr = pThemeUIPages->UpdatePreview(0);
        }
        pThemeUIPages->Release();
    }

    return hr;
}


BOOL CThemePage::_IsFiltered(IN DWORD dwFilter)
{
    BOOL fFiltered = FALSE;
    VARIANT varFilter;

    if (SUCCEEDED(Read(g_szCBNames[dwFilter], &varFilter, NULL)) &&
        (VT_BOOL == varFilter.vt))
    {
        fFiltered = (VARIANT_TRUE != varFilter.boolVal);
    }

    return fFiltered;
}


HRESULT CThemePage::_OnDestroy(HWND hDlg)
{
    _FreeThemeDropdown();
    return S_OK;
}


HRESULT CThemePage::_InitScreenSaver(void)
{
    HRESULT hr = S_OK;

    if (!m_pScreenSaverUI)
    {
        ATOMICRELEASE(m_pBackgroundUI);
        ATOMICRELEASE(m_pAppearanceUI);

        hr = E_FAIL;
        if (_punkSite)
        {
            IThemeUIPages * pThemeUI;

            hr = _punkSite->QueryInterface(IID_PPV_ARG(IThemeUIPages, &pThemeUI));
            if (SUCCEEDED(hr))
            {
                IEnumUnknown * pEnumUnknown;

                hr = pThemeUI->GetBasePagesEnum(&pEnumUnknown);
                if (SUCCEEDED(hr))
                {
                    IUnknown * punk;

                    // This may not exit due to policy
                    if (SUCCEEDED(IEnumUnknown_FindCLSID(pEnumUnknown, PPID_ScreenSaver, &punk)))
                    {
                        hr = punk->QueryInterface(IID_PPV_ARG(IPropertyBag, &m_pScreenSaverUI));
                        punk->Release();
                    }

                    if (SUCCEEDED(hr))
                    {
                        // This may not exit due to policy
                        if (SUCCEEDED(IEnumUnknown_FindCLSID(pEnumUnknown, PPID_Background, &punk)))
                        {
                            hr = punk->QueryInterface(IID_PPV_ARG(IPropertyBag, &m_pBackgroundUI));
                            punk->Release();
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        // This may not exit due to policy
                        if (SUCCEEDED(IEnumUnknown_FindCLSID(pEnumUnknown, PPID_BaseAppearance, &punk)))
                        {
                            hr = punk->QueryInterface(IID_PPV_ARG(IPropertyBag, &m_pAppearanceUI));
                            punk->Release();
                        }
                    }

                    pEnumUnknown->Release();
                }

                pThemeUI->Release();
            }
        }
    }

    return hr;
}


LPCWSTR s_Icons[SIZE_ICONS_ARRAY] =
{
    L"CLSID\\{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\DefaultIcon:DefaultValue",       // My Computer
    L"CLSID\\{450D8FBA-AD25-11D0-98A8-0800361B1103}\\DefaultIcon:DefaultValue",       // My Documents
    L"CLSID\\{208D2C60-3AEA-1069-A2D7-08002B30309D}\\DefaultIcon:DefaultValue",       // My Network Places
    L"CLSID\\{645FF040-5081-101B-9F08-00AA002F954E}\\DefaultIcon:full",               // Recycle Bin (Full)
    L"CLSID\\{645FF040-5081-101B-9F08-00AA002F954E}\\DefaultIcon:empty",              // Recycle Bin (Empty)
};


extern BOOL g_fDoNotInstallThemeWallpaper;     // This is used to not install wallpaper.

HRESULT CThemePage::_OnSetBackground(void)
{
    HRESULT hr = S_OK;

    if (!_IsFiltered(THEMEFILTER_WALLPAPER) &&
        !SHGetRestriction(NULL, POLICY_KEY_ACTIVEDESKTOP, SZ_POLICY_NOCHANGEWALLPAPER) &&
        !g_fDoNotInstallThemeWallpaper)
    {
        // Get the screen saver from the theme and tell the Screen Saver page to use it.
        if (m_pSelectedTheme)
        {
            CComBSTR bstrPath;

            if (FAILED(m_pSelectedTheme->get_Background(&bstrPath)))        // This will fail if the there isn't a wallpaper set.
            {
                bstrPath = L"";
            }

            // This call will fail if the hide background tab policies is enabled.
            if (SUCCEEDED(SHPropertyBag_WriteStr(m_pBackgroundUI, SZ_PBPROP_BACKGROUND_PATH, bstrPath)))
            {
                enumBkgdTile nTile = BKDGT_STRECH;
                if (FAILED(m_pSelectedTheme->get_BackgroundTile(&nTile)))
                {
                    nTile = BKDGT_STRECH;   // Default to stretch, it's good for you.
                }

                LPCWSTR pszExtension = PathFindExtensionW(bstrPath);
                // If our wallpaper is an HTML page we need to force stretching on and tiling off
                if (pszExtension &&
                    ((StrCmpIW(pszExtension, L".htm") == 0) ||
                     (StrCmpIW(pszExtension, L".html") == 0)))
                {
                    nTile = BKDGT_STRECH;
                }

                hr = SHPropertyBag_WriteDWORD(m_pBackgroundUI, SZ_PBPROP_BACKGROUND_TILE, nTile);
            }
        }
    }

    return hr;
}


HRESULT CThemePage::_OnSetIcons(void)
{
    HRESULT hr = S_OK;

    if (!_IsFiltered(THEMEFILTER_ICONS) && m_pSelectedTheme)
    {
        int nForIndex;

        for (nForIndex = 0; nForIndex < ARRAYSIZE(s_Icons); nForIndex++)
        {
            CComBSTR bstrPath;
            CComBSTR bstrIconString(s_Icons[nForIndex]);

            // We will probably want to reset any blank values to standard windows settings.
            hr = m_pSelectedTheme->GetIcon(bstrIconString, &bstrPath);

            // If the theme file doesn't specify the icon or specified "", we need to 
            // pass "" to SHPropertyBag_WriteStr() so it will delete the regkey.  This will
            // revert the icons back to their default value.

            // We ignore error values because this will fail if the hide background tab
            // policy is enabled
            SHPropertyBag_WriteStr(m_pBackgroundUI, s_Icons[nForIndex], (bstrPath ? bstrPath : L""));
        }
    }

    return hr;
}


HRESULT CThemePage::_OnSetSystemMetrics(void)
{
    HRESULT hr = S_OK;

    if (m_pSelectedTheme)
    {
        CComBSTR bstrPath;
        HRESULT hrVisualStyle;      // S_OK if we loaded a visual style, which is optional.

#ifndef ENABLE_IA64_VISUALSTYLES
        // We use a different regkey for 64bit because we need to leave it off until the pre-Whistler
        // 64-bit release forks from the Whistler code base.
        if (SHRegGetBoolUSValue(SZ_REGKEY_APPEARANCE, SZ_REGVALUE_DISPLAYSCHEMES64, FALSE, FALSE))
        {
            hrVisualStyle = m_pSelectedTheme->get_VisualStyle(&bstrPath);
        }
        else
        {
            hrVisualStyle = E_FAIL;        // In this case, themes are disabled so we ignore that value from the file.
        }
#else // ENABLE_IA64_VISUALSTYLES
        hrVisualStyle = m_pSelectedTheme->get_VisualStyle(&bstrPath);
#endif // ENABLE_IA64_VISUALSTYLES

        if (SUCCEEDED(hrVisualStyle))       // It's fine if this isn't present.
        {
            hrVisualStyle = hr = SHPropertyBag_WriteStr(m_pAppearanceUI, SZ_PBPROP_VISUALSTYLE_PATH, bstrPath);
            if (SUCCEEDED(hr))
            {
                hr = m_pSelectedTheme->get_VisualStyleColor(&bstrPath);
                if (SUCCEEDED(hr))
                {
                    hr = SHPropertyBag_WriteStr(m_pAppearanceUI, SZ_PBPROP_VISUALSTYLE_COLOR, bstrPath);
                    if (SUCCEEDED(hr))
                    {
                        hr = m_pSelectedTheme->get_VisualStyleSize(&bstrPath);
                        if (SUCCEEDED(hr))
                        {
                            hr = SHPropertyBag_WriteStr(m_pAppearanceUI, SZ_PBPROP_VISUALSTYLE_SIZE, bstrPath);
                        }
                    }
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            IPropertyBag * pPropertyBag;

            hr = m_pSelectedTheme->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
            if (SUCCEEDED(hr))
            {
                BOOL fHasSysMetricsSections = FALSE;

                // If the .theme file specifies "[IconMetrics]" and "[NonclientMetrics]" sections, then load them.
                // If a .theme file wants to use the values from the visual style, then these should be missing.
                if (SUCCEEDED(SHPropertyBag_ReadBOOL(pPropertyBag, SZ_PBPROP_HASSYSMETRICS, &fHasSysMetricsSections)) &&
                    fHasSysMetricsSections)
                {
                    SYSTEMMETRICSALL systemMetrics = {0};

                    // We want to copy the SYSTEMMETRICSALL structure from the file to the base Appearance page.
                    // If the user has a filter, these are the base values that may not get replaced.
                    hr = SHPropertyBag_ReadByRef(pPropertyBag, SZ_PBPROP_SYSTEM_METRICS, (void *)&systemMetrics, sizeof(systemMetrics));
                    if (SUCCEEDED(hr))
                    {
                        if (FAILED(hrVisualStyle))   // Skip setting the visual style drop down to a placeholder value if we set it to a real value above.
                        {
                            WCHAR szPath[MAX_PATH];

                            bstrPath = L"";
                            hr = SHPropertyBag_WriteStr(m_pAppearanceUI, SZ_PBPROP_VISUALSTYLE_PATH, bstrPath);
                            if (SUCCEEDED(hr))
                            {
                                LoadString(HINST_THISDLL, IDS_DEFAULT_APPEARANCES_SCHEME_CANONICAL, szPath, ARRAYSIZE(szPath));
                                hr = SHPropertyBag_WriteStr(m_pAppearanceUI, SZ_PBPROP_VISUALSTYLE_COLOR, szPath);
                                if (FAILED(hr))
                                {
                                    // This call will fail on builds with EN+MUI because we fail to give the canonical names in
                                    // the registry.  This is an inherint problem with previous OSs putting the localized name
                                    // in the registry.  We can only upgrade and fix that name to be canonical if the strings we load
                                    // from the registry (MUI) match that in the registry, which are from the base OS language (EN).
                                    LoadString(HINST_THISDLL, IDS_DEFAULT_APPEARANCES_SCHEME, szPath, ARRAYSIZE(szPath));
                                    hr = SHPropertyBag_WriteStr(m_pAppearanceUI, SZ_PBPROP_VISUALSTYLE_COLOR, szPath);

                                    // MUI: We may still fail to select the string.  The user can change MUI languages in such a way
                                    // that we can't upgrade the DisplayName to be MUI complient, and the language in the DLL may
                                    // not match the langauge in the registry.
                                    hr = S_OK;
                                }

                                if (SUCCEEDED(hr))
                                {
                                    LoadString(HINST_THISDLL, IDS_DEFAULT_APPEARANCES_SIZE_CANONICAL, szPath, ARRAYSIZE(szPath));
                                    hr = SHPropertyBag_WriteStr(m_pAppearanceUI, SZ_PBPROP_VISUALSTYLE_SIZE, szPath);
                                    if (FAILED(hr))
                                    {
                                        // This call will fail on builds with EN+MUI because we fail to give the canonical names in
                                        // the registry.  This is an inherint problem with previous OSs putting the localized name
                                        // in the registry.  We can only upgrade and fix that name to be canonical if the strings we load
                                        // from the registry (MUI) match that in the registry, which are from the base OS language (EN).
                                        LoadString(HINST_THISDLL, IDS_SIZE_NORMAL, szPath, ARRAYSIZE(szPath));
                                        hr = SHPropertyBag_WriteStr(m_pAppearanceUI, SZ_PBPROP_VISUALSTYLE_SIZE, szPath);

                                        // MUI: We may still fail to select the string.  The user can change MUI languages in such a way
                                        // that we can't upgrade the DisplayName to be MUI complient, and the language in the DLL may
                                        // not match the langauge in the registry.
                                        hr = S_OK;
                                    }
                                }
                            }
                        }

                        // We want to force Flat Menu off because this .theme file does not specify a visual style.
                        // Flat Menu needs to be off because the .theme files can't specify the new system metrics for the
                        // flat menu colors.  Now put the system metrics back.
                        systemMetrics.fFlatMenus = FALSE;
                        SHPropertyBag_WriteByRef(m_pAppearanceUI, SZ_PBPROP_SYSTEM_METRICS, (void *)&systemMetrics);
                    }
                }

                pPropertyBag->Release();
            }
        }
    }

    return hr;
}


HRESULT CThemePage::_OnSetSelection(IN int nIndex)
{
    ComboBox_SetCurSel(m_hwndThemeCombo, nIndex);
    m_pLastSelected = _GetThemeFile(nIndex);
    _EnableDeleteIfAppropriate();

    return S_OK;
}


HRESULT CThemePage::_OnThemeChange(HWND hDlg, BOOL fOnlySelect)
{
    HRESULT hr = S_OK;
    int nIndex = ComboBox_GetCurSel(m_hwndThemeCombo);
    ITheme * pTheme = _GetThemeFile(nIndex);
    ITheme * pThemePrevious = NULL;

    if (-1 == nIndex)
    {
        nIndex = 0;
    }

    IUnknown_Set((IUnknown **)&pThemePrevious, pTheme);
    if (pTheme)
    {
        if (m_pLastSelected != pTheme)   // Don't bother if the selection hasn't changed.
        {
            if (-1 == nIndex)
            {
                nIndex = 0; // The caller may NOT select nothing.
            }

            _RemoveUserTheme();
            Str_SetPtr(&m_pszModifiedName, NULL); // Remove the name so it's generated next time.
            hr = _OnLoadThemeValues(pTheme, fOnlySelect);

            if (!fOnlySelect)
            {
                PropSheet_Changed(GetParent(hDlg), hDlg);
                _UpdatePreview();
                if (!m_fInInit)
                {
                    DelayEnableApplyButton(hDlg);
                }
            }
        }
    }
    else
    {
        if (!fOnlySelect)
        {
            LPCWSTR pszUrl = _GetThemeUrl(nIndex);

            if (pszUrl)
            {
                HrShellExecute(m_hwndThemeCombo, NULL, pszUrl, NULL, NULL, SW_SHOW);
                ComboBox_SetCurSel(m_hwndThemeCombo, m_nPreviousSelected);
                _EnableDeleteIfAppropriate();
                hr = S_OK;
            }
            else
            {
                // This could be the "Other..." item or the "<UserName>'s Customer Theme".
                // We can find out by seeing if it's the last one.
                if ((ComboBox_GetCount(m_hwndThemeCombo) - 1) == nIndex)
                {
                    // This means that it was the "Other..." entre.
                    hr = _OnSelectOther();
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        m_nPreviousSelected = ComboBox_GetCurSel(m_hwndThemeCombo);
    }
    else
    {
        if (!fOnlySelect)
        {
            if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
            {
                TCHAR szTitle[MAX_PATH];
                CComBSTR bstrPath;

                if (pTheme)
                {
                    pTheme->GetPath(VARIANT_TRUE, &bstrPath);
                }

                LoadString(HINST_THISDLL, IDS_ERROR_THEME_INVALID_TITLE, szTitle, ARRAYSIZE(szTitle));
                if (HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE) == hr)
                {
                    TCHAR szErrMsg[MAX_PATH * 2];
                    TCHAR szTemplate[MAX_PATH * 2];

                    // A common error will be that the service is not running.  Let's customize
                    // that message to make it friendly.
                    LoadString(HINST_THISDLL, IDS_ERROR_THEME_SERVICE_NOTRUNNING, szTemplate, ARRAYSIZE(szTemplate));
                    wnsprintf(szErrMsg, ARRAYSIZE(szErrMsg), szTemplate, EMPTYSTR_FORNULL(bstrPath));
                    MessageBox(_hwnd, szErrMsg, szTitle, (MB_OK | MB_ICONERROR));
                }
                if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                {
                    TCHAR szErrMsg[MAX_PATH * 2];
                    TCHAR szTemplate[MAX_PATH * 2];

                    // Often a .theme file will be incorrectly installed and we can't find the other files
                    // (like background, screensaver, icons, sounds, etc.).  Let's give a better message.
                    LoadString(HINST_THISDLL, IDS_ERROR_THEME_FILE_NOTFOUND, szTemplate, ARRAYSIZE(szTemplate));
                    wnsprintf(szErrMsg, ARRAYSIZE(szErrMsg), szTemplate, EMPTYSTR_FORNULL(bstrPath));
                    MessageBox(_hwnd, szErrMsg, szTitle, (MB_OK | MB_ICONERROR));
                }
                else
                {
                    ErrorMessageBox(_hwnd, szTitle, IDS_ERROR_THEME_LOADFAILED, hr, bstrPath, 0);
                }
            }

            _OnLoadThemeValues(m_pSelectedTheme, TRUE);
            ComboBox_SetCurSel(m_hwndThemeCombo, m_nPreviousSelected);
        }
    }

    IUnknown_Set((IUnknown **)&pThemePrevious, NULL);
    return hr;
}


HRESULT CThemePage::_OnLoadThemeValues(ITheme * pTheme, BOOL fOnlySelect)
{
    HRESULT hr = S_OK;

    if (pTheme)
    {
        if (m_pLastSelected != pTheme)   // Don't bother if the selection hasn't changed.
        {
            IUnknown_SetSite(m_pSelectedTheme, NULL);   // Break any back pointers.
            IUnknown_Set((IUnknown **)&m_pSelectedTheme, pTheme);
            IUnknown_SetSite(m_pSelectedTheme, _punkSite);

            _RemoveUserTheme();
            Str_SetPtr(&m_pszModifiedName, NULL); // Remove the name so it's generated next time.

            if (!fOnlySelect)
            {
                CComBSTR bstrPath;

                hr = _InitScreenSaver();
                if (SUCCEEDED(hr))
                {
                    // Set the Screen Saver: Get the screen saver from the theme and tell the Screen Saver page to use it.
                    if (!_IsFiltered(THEMEFILTER_SCREENSAVER) && 
                        !SHGetRestriction(NULL, POLICY_KEY_SYSTEM, SZ_POLICY_NODISPSCREENSAVERPG) &&
                        !SHGetRestriction(SZ_REGKEY_POLICIES_DESKTOP, NULL, SZ_POLICY_SCREENSAVEACTIVE))
                    {
                        m_pSelectedTheme->get_ScreenSaver(&bstrPath);       // If this is not specified, we set the wallpaper to "NONE".
                        hr = SHPropertyBag_WriteStr(m_pScreenSaverUI, SZ_PBPROP_SCREENSAVER_PATH, (bstrPath ? bstrPath : L""));
                    }

                    if (SUCCEEDED(hr))
                    {
                        // Set the Background:
                        hr = _OnSetBackground();

                        if (SUCCEEDED(hr))
                        {
                            // Set the Icons:
                            hr = _OnSetIcons();

                            if (SUCCEEDED(hr))
                            {
                                // Set the System Metrics:
                                hr = _OnSetSystemMetrics();

                                if (SUCCEEDED(hr))
                                {
                                    hr = m_pSelectedTheme->GetPath(VARIANT_TRUE, &bstrPath);
                                    if (SUCCEEDED(hr))
                                    {
                                        Str_SetPtrW(&m_pszThemeToApply, bstrPath);
                                        Str_SetPtrW(&m_pszLastAppledTheme, bstrPath);
                                        m_pLastSelected = pTheme;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return hr;
}


INT_PTR CThemePage::_OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = 1;   // Not handled (WM_COMMAND seems to be different)
    const WORD idCtrl = GET_WM_COMMAND_ID(wParam, lParam);

    switch (idCtrl)
    {
        case IDC_THPG_THEMESETTINGS:
            _OnOpenAdvSettingsDlg(hDlg);
            break;

        case IDC_THPG_SAVEAS:
            _SaveAs();
            break;

        case IDC_THPG_DELETETHEME:
            _DeleteTheme();
            break;

        case IDC_THPG_THEMELIST:
            if (HIWORD(wParam) == CBN_SELENDOK)
            {
                _OnThemeChange(hDlg, FALSE);
                _EnableDeleteIfAppropriate();
            }
            break;
        default:
            break;
    }

    return fHandled;
}



HRESULT CThemePage::_OnSetActive(HWND hDlg)
{
    return S_OK;
}


HRESULT CThemePage::_OnApply(HWND hDlg, LPARAM lParam)
{
    // Our parent dialog will be notified of the Apply event and will call our
    // IBasePropPage::OnApply() to do the real work.
    return S_OK;
}


// This Property Sheet appear in the top level of the "Display Control Panel".
INT_PTR CThemePage::_ThemeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;

    switch(message)
    {
    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
        {
            case PSN_SETACTIVE:
                _OnSetActive(hDlg);
                break;
            case PSN_APPLY:
                _OnApply(hDlg, lParam);
                break;

            case PSN_RESET:
                break;
        }
        break;

    case WM_INITDIALOG:
        _OnInitThemesDlg(hDlg);
        break;

    case WM_DESTROY:
        _OnDestroy(hDlg);
        break;

    case WM_QUERYNEWPALETTE:
    case WM_PALETTECHANGED:
        SendDlgItemMessage(hDlg, IDC_THPG_THEME_PREVIEW, message, wParam, lParam);
        return TRUE;

    case WM_HELP:
        WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, SZ_HELPFILE_THEMES, HELP_WM_HELP, (DWORD_PTR) aThemesHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, SZ_HELPFILE_THEMES, HELP_CONTEXTMENU, (DWORD_PTR) aThemesHelpIds);
        break;

    case WM_COMMAND:
        _OnCommand(hDlg, message, wParam, lParam);
        break;

    case WMUSER_DELAYENABLEAPPLY:
        EnableApplyButton(hDlg);
        break;
    }

    return FALSE;
}


HRESULT CThemePage::_PersistState(void)
{
    HRESULT hr = S_OK;

    if (m_fInited)
    {
        LPCWSTR pszValue = (m_pszLastAppledTheme ? m_pszLastAppledTheme : L"");
        TCHAR szCurrWallpaper[MAX_PATH];

        HrRegSetPath(HKEY_CURRENT_USER, SZ_REGKEY_LASTTHEME, SZ_REGVALUE_LT_THEMEFILE, TRUE, pszValue);
        if (SUCCEEDED(IUnknown_GetBackground(_punkSite, szCurrWallpaper, ARRAYSIZE(szCurrWallpaper))))
        {
            PathUnExpandEnvStringsWrap(szCurrWallpaper, ARRAYSIZE(szCurrWallpaper));
            HrRegSetPath(HKEY_CURRENT_USER, SZ_REGKEY_LASTTHEME, SZ_REGVALUE_LT_WALLPAPER, TRUE, szCurrWallpaper);
        }

        pszValue = (m_pszModifiedName ? m_pszModifiedName : L"");
        DWORD cbSize = (sizeof(pszValue[0]) * (lstrlen(pszValue) + 1));
        HrSHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_LASTTHEME, SZ_REGVALUE_MODIFIED_DISPNAME, REG_SZ, (LPVOID) pszValue, cbSize);
    }

    return hr;
}


HRESULT CThemePage::_ApplyThemeFile(void)
{
    HRESULT hr = S_OK;

    if (m_pszThemeToApply)
    {
        if (m_pSelectedTheme)
        {
            IPropertyBag * pPropertyBag;

            hr = m_pSelectedTheme->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
            if (SUCCEEDED(hr))
            {
                VARIANT varEmpty;

                VariantInit(&varEmpty);
                // Here we need to apply all the settings in the theme, like: Sounds, Cursors, Webview
                // that haven't been pushed to the other tabs.
                hr = pPropertyBag->Write(SZ_PBPROP_APPLY_THEMEFILE, &varEmpty);
                pPropertyBag->Release();
            }
        }
    }

    return hr;
}


HRESULT CThemePage::_InitFilterKey(void)
{
    HRESULT hr = S_OK;

    if (!m_hkeyFilter)
    {
        hr = HrRegCreateKeyEx(HKEY_CURRENT_USER, SZ_REGKEY_THEME_FILTERS, 0, NULL, 0, (KEY_WRITE | KEY_READ), NULL, &m_hkeyFilter, NULL);
    }

    return hr;
}




//===========================
// *** IPropertyBag Interface ***
//===========================
HRESULT CThemePage::Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        // We have a list of "ThemeFilter:" properties for all of the filter values on
        // what part of themes to apply.
        if (!StrCmpNIW(SZ_PBPROP_THEME_FILTER, pszPropName, SIZE_THEME_FILTER_STR))
        {
            pVar->vt = VT_BOOL;
            pVar->boolVal = VARIANT_TRUE;
            for (int nIndex = 0; nIndex < ARRAYSIZE(g_szCBNames); nIndex++)
            {
                if (!StrCmpIW(pszPropName, g_szCBNames[nIndex]))
                {
                    pVar->boolVal = (m_fFilters[nIndex] ? VARIANT_TRUE : VARIANT_FALSE);
                    hr = S_OK;
                    break;
                }
            }
        }
        else if (!StrCmpIW(SZ_PBPROP_THEME_DISPLAYNAME, pszPropName))
        {
            WCHAR szDisplayName[MAX_PATH];
            int nIndex = ComboBox_GetCurSel(m_hwndThemeCombo);

            if ((ARRAYSIZE(szDisplayName) > ComboBox_GetLBTextLen(m_hwndThemeCombo, nIndex)) && 
                (CB_ERR != ComboBox_GetLBText(m_hwndThemeCombo, nIndex, szDisplayName)))
            {
                pVar->vt = VT_BSTR;
                hr = HrSysAllocStringW(szDisplayName, &pVar->bstrVal);
            }
        }
    }

    return hr;
}


HRESULT CThemePage::Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        if (!StrCmpW(pszPropName, SZ_PBPROP_CUSTOMIZE_THEME))
        {
            // We don't care what the variant is.
            // Note that we don't null out m_pSelectedTheme.  This is because we still want to apply it.
            hr = _CustomizeTheme();
        }
        // We have a list of "ThemeFilter:" properties for all of the filter values on
        // what part of themes to apply.
        else if (!StrCmpNIW(SZ_PBPROP_THEME_FILTER, pszPropName, SIZE_THEME_FILTER_STR) &&
                 (VT_BOOL == pVar->vt))
        {
            for (int nIndex = 0; nIndex < ARRAYSIZE(g_szCBNames); nIndex++)
            {
                if (!StrCmpIW(pszPropName, g_szCBNames[nIndex]))
                {
                    m_fFilters[nIndex] = (VARIANT_TRUE == pVar->boolVal);
                    hr = S_OK;
                    break;
                }
            }
        }
        else if ((VT_LPWSTR == pVar->vt) &&
            !StrCmpW(pszPropName, SZ_PBPROP_THEME_LAUNCHTHEME))
        {
            Str_SetPtrW(&m_pszThemeLaunched, pVar->bstrVal);
            m_nPreviousSelected = ComboBox_GetCurSel(m_hwndThemeCombo);
            hr = S_OK;
        }
        else if ((VT_BSTR == pVar->vt) &&
            !StrCmpW(pszPropName, SZ_PBPROP_THEME_LOADTHEME) &&
            pVar->bstrVal)
        {
            ITheme * pTheme;
            
            hr = CThemeFile_CreateInstance(pVar->bstrVal, &pTheme);
            if (SUCCEEDED(hr))
            {
                hr = _OnLoadThemeValues(pTheme, FALSE);
                if (SUCCEEDED(hr) && !m_fInited)
                {
                    m_fInited = TRUE;
                }

                pTheme->Release();
            }
        }
    }

    return hr;
}




//===========================
// *** IBasePropPage Interface ***
//===========================
HRESULT CThemePage::GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog)
{
#ifdef FEATURE_THEME_SETTINGS_DIALOG
    return CThemeSettingsPage_CreateInstance(ppAdvDialog);

#else // FEATURE_THEME_SETTINGS_DIALOG

    *ppAdvDialog = NULL;
    return S_OK;
#endif // FEATURE_THEME_SETTINGS_DIALOG
}


HRESULT CThemePage::OnApply(IN PROPPAGEONAPPLY oaAction)
{
    HRESULT hr = S_OK;
    HCURSOR old = SetCursor(LoadCursor(NULL, IDC_WAIT));

    if ((PPOAACTION_CANCEL != oaAction))
    {
        hr = _SaveThemeFilterState();
        AssertMsg((NULL != _punkSite), TEXT("We need our site pointer in order to save the settings."));
        if (_IsDirty() && _punkSite)
        {
            // m_pSelectedTheme will be NULL if a Theme wasn't chosen to be applied.
            if (m_pSelectedTheme)
            {
                IPropertyBag * pPropertyBag;

                hr = _punkSite->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
                if (SUCCEEDED(hr))
                {
                    CComBSTR bstrPath;

                    if (m_pSelectedTheme)
                    {
                        // Persist the filename to the registry.
                        hr = m_pSelectedTheme->GetPath(VARIANT_TRUE, &bstrPath);
                    }

                    hr = SHPropertyBag_WriteStr(pPropertyBag, SZ_PBPROP_THEME_SETSELECTION, bstrPath);
                    pPropertyBag->Release();
                }

                if (SUCCEEDED(hr))
                {
                    hr = _ApplyThemeFile();

                    IUnknown_SetSite(m_pSelectedTheme, NULL);   // Break any back pointers.
                    ATOMICRELEASE(m_pSelectedTheme);    // Indicate that we no longer need to apply anything.
                }
            }
        }

        // We save the Theme selection even if the user didn't change themes.  They may have caused
        // the theme selection to become customized.
        _PersistState();
    }

    SetCursor(old);
    return hr;
}



#define FEATURE_SHOWTHEMEPAGE           TRUE

//===========================
// *** IShellPropSheetExt Interface ***
//===========================
HRESULT CThemePage::AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam)
{
    HRESULT hr = S_OK;

    // Does the policy say to add the Themes Tab?
    if (SHRegGetBoolUSValue(SZ_REGKEY_APPEARANCE, SZ_REGVALUE_DISPLAYTHEMESPG, FALSE, FEATURE_SHOWTHEMEPAGE))
    {
        PROPSHEETPAGE psp = {0};

        psp.dwSize = sizeof(psp);
        psp.hInstance = HINST_THISDLL;
        psp.dwFlags = PSP_DEFAULT;
        psp.lParam = (LPARAM) this;

        psp.pszTemplate = MAKEINTRESOURCE(DLG_THEMESPG);
        psp.pfnDlgProc = CThemePage::ThemeDlgProc;

        HPROPSHEETPAGE hpsp = CreatePropertySheetPage(&psp);
        if (hpsp)
        {
            if (pfnAddPage(hpsp, lParam))
            {
                hr = S_OK;
            }
            else
            {
                DestroyPropertySheetPage(hpsp);
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}



//===========================
// *** IObjectWithSite Interface ***
//===========================
HRESULT CThemePage::SetSite(IN IUnknown * punkSite)
{
    if (!punkSite)
    {
        // We need to break back pointers.
        IUnknown_SetSite(m_pSelectedTheme, NULL);
    }

    return CObjectWithSite::SetSite(punkSite);
}


//===========================
// *** IUnknown Interface ***
//===========================
ULONG CThemePage::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CThemePage::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CThemePage::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CThemePage, IObjectWithSite),
        QITABENT(CThemePage, IOleWindow),
        QITABENT(CThemePage, IPersist),
        QITABENT(CThemePage, IPropertyBag),
        QITABENT(CThemePage, IBasePropPage),
        QITABENTMULTI(CThemePage, IShellPropSheetExt, IBasePropPage),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CThemePage::CThemePage() : m_cRef(1), CObjectCLSID(&PPID_Theme)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pSelectedTheme);
    ASSERT(!m_pThemePreview);
    ASSERT(!m_pScreenSaverUI);
    ASSERT(!m_pBackgroundUI);
    ASSERT(!m_pAppearanceUI);
    ASSERT(!m_pszThemeToApply);
    ASSERT(!m_hkeyFilter);
    ASSERT(!m_pszLastAppledTheme);
    ASSERT(!m_pszModifiedName);
    ASSERT(!m_hwndDeleteButton);

    m_fInited = FALSE;
    m_fInInit = FALSE;
    m_Modified.type = eThemeModified;
    m_Modified.pszUrl = NULL;

    // Load the Theme Filter state.
    _LoadThemeFilterState();
}


CThemePage::~CThemePage()
{
    IUnknown_SetSite(m_pSelectedTheme, NULL);   // Break any back pointers.

    ATOMICRELEASE(m_pSelectedTheme);
    ATOMICRELEASE(m_pThemePreview);
    ATOMICRELEASE(m_pScreenSaverUI);
    ATOMICRELEASE(m_pBackgroundUI);
    ATOMICRELEASE(m_pAppearanceUI);

    Str_SetPtrW(&m_pszLastAppledTheme, NULL);
    Str_SetPtrW(&m_pszModifiedName, NULL);
    Str_SetPtrW(&m_pszThemeToApply, NULL);
    Str_SetPtrW(&m_pszThemeLaunched, NULL);

    if (m_hkeyFilter)
    {
        RegCloseKey(m_hkeyFilter);
    }

    DllRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\thscheme.cpp ===
/*****************************************************************************\
    FILE: thScheme.cpp

    DESCRIPTION:
        This is the Autmation Object to theme scheme object.

    BryanSt 5/11/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <cowsite.h>
#include <atlbase.h>
#include "util.h"
#include "theme.h"
#include "appstyle.h"
#include "thsize.h"
#include "thstyle.h"
#include "thscheme.h"


//===========================
// *** Class Internals & Helpers ***
//===========================




//===========================
// *** ITheme Interface ***
//===========================
HRESULT CSkinScheme::get_DisplayName(OUT BSTR * pbstrDisplayName)
{
    WCHAR szDisplayName[MAX_PATH];
    HRESULT hr = GetThemeDocumentationProperty(m_pszFilename, SZ_THDOCPROP_DISPLAYNAME, szDisplayName, ARRAYSIZE(szDisplayName));

    LogStatus("GetThemeDocumentationProperty(path=\"%ls\", displayname=\"%ls\") returned %#08lx.\r\n", m_pszFilename, szDisplayName, hr);
    if (SUCCEEDED(hr))
    {
        hr = HrSysAllocStringW(szDisplayName, pbstrDisplayName);
    }

    return hr;
}


HRESULT CSkinScheme::get_Path(OUT BSTR * pbstrPath)
{
    return HrSysAllocString(m_pszFilename, pbstrPath);
}


HRESULT CSkinScheme::put_Path(IN BSTR bstrPath)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrPath)
    {
        Str_SetPtr(&m_pszFilename, bstrPath);
        hr = (m_pszFilename ? S_OK : E_OUTOFMEMORY);
    }

    return hr;
}


HRESULT CSkinScheme::get_length(OUT long * pnLength)
{
    HRESULT hr = E_INVALIDARG;

    if (pnLength)
    {
        hr = S_OK;
        if (COLLECTION_SIZE_UNINITIALIZED == m_nSize)
        {
            THEMENAMEINFO themeInfo;
            m_nSize = 0;

            // Make sure there are at least 1 color or return a failure HR.
            hr = EnumThemeColors(m_pszFilename, NULL, m_nSize, &themeInfo);
            do
            {
                m_nSize++;
            }
            while (SUCCEEDED(EnumThemeColors(m_pszFilename, NULL, m_nSize, &themeInfo)));
        }

        *pnLength = m_nSize;
    }

    return hr;
}


HRESULT CSkinScheme::get_item(IN VARIANT varIndex, OUT IThemeStyle ** ppThemeStyle)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeStyle)
    {
        long nCount = 0;

        get_length(&nCount);
        *ppThemeStyle = NULL;

        // This is sortof gross, but if we are passed a pointer to another variant, simply
        // update our copy here...
        if (varIndex.vt == (VT_BYREF | VT_VARIANT) && varIndex.pvarVal)
            varIndex = *(varIndex.pvarVal);

        switch (varIndex.vt)
        {
        case VT_I2:
            varIndex.lVal = (long)varIndex.iVal;
            // And fall through...

        case VT_I4:
        if ((varIndex.lVal >= 0) && (varIndex.lVal < nCount) && m_pszFilename)
        {
            THEMENAMEINFO themeInfo;

            hr = EnumThemeColors(m_pszFilename, NULL, varIndex.lVal, &themeInfo);
            LogStatus("EnumThemeColors(path=\"%ls\") returned %#08lx in CSkinScheme::get_item.\r\n", m_pszFilename, hr);
            if (SUCCEEDED(hr))
            {
                hr = CSkinStyle_CreateInstance(m_pszFilename, themeInfo.szName, themeInfo.szDisplayName, ppThemeStyle);
            }
        }
        break;
        case VT_BSTR:
        if (varIndex.bstrVal)
        {
            if (!varIndex.bstrVal[0])
            {
                if (m_pszFilename)
                {
                    TCHAR szColor[MAX_PATH];
                    TCHAR szSize[MAX_PATH];

                    hr = GetThemeDefaults(m_pszFilename, szColor, ARRAYSIZE(szColor), szSize, ARRAYSIZE(szSize));
                    LogStatus("GetThemeDefaults(pszFilename=\"%ls\", szColor=\"%ls\", szSize=\"%ls\") returned %#08lx in CSkinScheme::get_item.\r\n", m_pszFilename, szColor, szSize, hr);
                    if (SUCCEEDED(hr))
                    {
                        hr = CSkinStyle_CreateInstance(m_pszFilename, szColor, ppThemeStyle);
                    }
                }
            }
            else
            {
                THEMENAMEINFO themeInfo;

                for (long nIndex = 0; FAILED(hr) && (nIndex < nCount) && SUCCEEDED(EnumThemeColors(m_pszFilename, NULL, nIndex, &themeInfo));
                            nIndex++)
                {
                    if (!StrCmpIW(themeInfo.szDisplayName, varIndex.bstrVal) ||
                        !StrCmpIW(themeInfo.szName, varIndex.bstrVal))
                    {
                        hr = CSkinStyle_CreateInstance(m_pszFilename, themeInfo.szName, themeInfo.szDisplayName, ppThemeStyle);
                    }
                }
            }
        }
        break;

        default:
            hr = E_NOTIMPL;
        }
    }

    return hr;
}


HRESULT CSkinScheme::get_SelectedStyle(OUT IThemeStyle ** ppThemeStyle)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeStyle)
    {
        WCHAR szCurrentPath[MAX_PATH];
        WCHAR szCurrentStyle[MAX_PATH];

        szCurrentPath[0] = 0;
        szCurrentStyle[0] = 0;
        *ppThemeStyle = NULL;
        hr = GetCurrentThemeName(szCurrentPath, ARRAYSIZE(szCurrentPath), szCurrentStyle, ARRAYSIZE(szCurrentStyle), NULL, 0);
        LogStatus("GetCurrentThemeName(path=\"%ls\", color=\"%ls\", size=\"%ls\") returned %#08lx in CSkinScheme::get_SelectedStyle.\r\n", szCurrentPath, szCurrentStyle, TEXT("NULL"), hr);
        if (SUCCEEDED(hr))
        {
            AssertMsg((0 != szCurrentStyle[0]), TEXT("The GetCurrentThemeName() API returned an invalid value."));

            // Is this skin currently selected?
            if (!StrCmpIW(m_pszFilename, szCurrentPath))
            {
                // Yes, so get the color style from that API.
                if (!m_pSelectedStyle)
                {
                    hr = CSkinStyle_CreateInstance(m_pszFilename, szCurrentStyle, &m_pSelectedStyle);
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }
            
        if (FAILED(hr))
        {
            ATOMICRELEASE(m_pSelectedStyle);

            // No, so find the default color style for this skin(scheme).
            hr = GetThemeDefaults(m_pszFilename, szCurrentStyle, ARRAYSIZE(szCurrentStyle), NULL, 0);
            LogStatus("GetThemeDefaults(szCurrentStyle=\"%ls\", szCurrentStyle=\"%ls\") returned %#08lx in CSkinScheme::get_SelectedStyle.\r\n", szCurrentStyle, szCurrentStyle, hr);
            if (SUCCEEDED(hr))
            {
                hr = CSkinStyle_CreateInstance(m_pszFilename, szCurrentStyle, &m_pSelectedStyle);
            }
        }

        if (m_pSelectedStyle)
        {
            IUnknown_Set((IUnknown **)ppThemeStyle, m_pSelectedStyle);
        }
    }

    return hr;
}


HRESULT CSkinScheme::put_SelectedStyle(IN IThemeStyle * pThemeStyle)
{
    IUnknown_Set((IUnknown **)&m_pSelectedStyle, pThemeStyle);
    return S_OK;
}


HRESULT CSkinScheme::AddStyle(OUT IThemeStyle ** ppThemeStyle)
{
    if (ppThemeStyle)
    {
        *ppThemeStyle = NULL;
    }

    return E_NOTIMPL;
}





//===========================
// *** IUnknown Interface ***
//===========================
ULONG CSkinScheme::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CSkinScheme::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


//===========================
// *** Class Methods ***
//===========================
HRESULT CSkinScheme::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CSkinScheme, IPersist),
        QITABENT(CSkinScheme, IThemeScheme),
        QITABENT(CSkinScheme, IDispatch),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


CSkinScheme::CSkinScheme(IN LPCWSTR pszFilename) : CImpIDispatch(LIBID_Theme, 1, 0, IID_IThemeScheme), CObjectCLSID(&CLSID_SkinScheme), m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pSelectedStyle);

    Str_SetPtr(&m_pszFilename, pszFilename);
    m_nSize = COLLECTION_SIZE_UNINITIALIZED;
}


CSkinScheme::~CSkinScheme()
{
    ATOMICRELEASE(m_pSelectedStyle);
    Str_SetPtr(&m_pszFilename, NULL);

    DllRelease();
}



HRESULT CSkinScheme_CreateInstance(IN LPCWSTR pszFilename, OUT IThemeScheme ** ppThemeScheme)
{
    HRESULT hr = E_INVALIDARG;

    if (pszFilename && ppThemeScheme)
    {
        TCHAR szPath[MAX_PATH];

        StrCpyN(szPath, pszFilename, ARRAYSIZE(szPath));
        ExpandResourceDir(szPath, ARRAYSIZE(szPath));
        
        CSkinScheme * pObject = new CSkinScheme(szPath);

        *ppThemeScheme = NULL;
        hr = E_OUTOFMEMORY;
        if (pObject)
        {
            if (pObject->m_pszFilename)
            {
                hr = pObject->QueryInterface(IID_PPV_ARG(IThemeScheme, ppThemeScheme));
            }

            pObject->Release();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\thscheme.h ===
/*****************************************************************************\
    FILE: thScheme.h

    DESCRIPTION:
        This is the Autmation Object to theme scheme object.  This one will be
    a skin.

    BryanSt 5/9/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _FILE_H_THSCHEME
#define _FILE_H_THSCHEME

#include <cowsite.h>
#include <atlbase.h>


static const GUID CLSID_SkinScheme = { 0x570fdefa, 0x5907, 0x47fe, { 0x96, 0x6b, 0x90, 0x30, 0xb4, 0xba, 0x10, 0xcd } };// {570FDEFA-5907-47fe-966B-9030B4BA10CD}
HRESULT CSkinScheme_CreateInstance(IN LPCWSTR pszFilename, OUT IThemeScheme ** ppThemeScheme);




class CSkinScheme               : public CImpIDispatch
                                , public CObjectCLSID
                                , public IThemeScheme
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IThemeScheme ***
    virtual STDMETHODIMP get_DisplayName(OUT BSTR * pbstrDisplayName);
    virtual STDMETHODIMP put_DisplayName(IN BSTR bstrDisplayName) {return E_NOTIMPL;}
    virtual STDMETHODIMP get_Path(OUT BSTR * pbstrPath);
    virtual STDMETHODIMP put_Path(IN BSTR bstrPath);
    virtual STDMETHODIMP get_length(OUT long * pnLength);
    virtual STDMETHODIMP get_item(IN VARIANT varIndex, OUT IThemeStyle ** ppThemeStyle);
    virtual STDMETHODIMP get_SelectedStyle(OUT IThemeStyle ** ppThemeStyle);
    virtual STDMETHODIMP put_SelectedStyle(IN IThemeStyle * pThemeStyle);
    virtual STDMETHODIMP AddStyle(OUT IThemeStyle ** ppThemeStyle);

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

private:
    CSkinScheme(IN LPCWSTR pszFilename);
    virtual ~CSkinScheme(void);


    // Private Member Variables
    long                    m_cRef;

    IThemeStyle *           m_pSelectedStyle;       // The selected style.
    LPWSTR                  m_pszFilename;          // This is the full path to the ".thx" file
    long                    m_nSize;                // The size of the collection of "Color Styles".

    // Private Member Functions

    // Friend Functions
    friend HRESULT CSkinScheme_CreateInstance(IN LPCWSTR pszFilename, OUT IThemeScheme ** ppThemeScheme);
};


#endif // _FILE_H_THSCHEME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\themeutils.cpp ===
/*****************************************************************************\
    FILE: themeutils.cpp

    DESCRIPTION:
        This class will load and save the "Theme" settings from their persisted
    state.

    BryanSt 5/26/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "ThemePg.h"
#include "ThemeFile.h"




// Determine if we need to get this value from the effects tab.
BOOL g_bGradient = TRUE;

BOOL g_bReadOK, g_bWroteOK;             // Save: read from reg/sys, write to file
                                    // Apply: not implemented since ignoring results anyway

#define MAX_MSGLEN   512         // TRANSLATORS: English strs max 256
                                 // MAX_MSGLEN must be at least 2xMAX_STRLEN
                                 // MAX_MSGLEN must be at least 2xMAX_PATH

TCHAR szCurDir[MAX_PATH+1];    // last dir opened a theme file from

TCHAR szMsg[MAX_MSGLEN+1];        // scratch buffer


//
// *Path
//
// These routines help to make themes transportable between computers.
// The problem is that the registry keeps filenames for the various
// theme elements and, of course, these are hard-coded paths that vary
// from machine to machine.
//
// The way we work around this problem is by storing filenames in the
// theme file as _relative_ paths: relative to the theme file directory
// or the Windows directory. (Actually, these routines are set up to
// be relative to any number of directories.) When saving a filename to
// a theme, we check to see if any relative paths can be abstracted out.
// When retrieving a filename from a theme, we take the abstract placeholder
// and replace it with the current sessions instances.

// these must parallel each other. abstract strs must start with %
void ExpandSZ(LPTSTR pszSrc, int cchSize)
{
    LPTSTR pszTmp = (LPTSTR)LocalAlloc(GPTR, (MAX_PATH * sizeof(TCHAR)));
    if (pszTmp)
    {
       if (ExpandEnvironmentStrings(pszSrc, pszTmp, MAX_PATH))
       {
          StrCpyN(pszSrc, pszTmp, cchSize);
       }

       LocalFree(pszTmp);
    }
}


// HandGet
//
// Just a little helper routine, gets an individual string value from the 
// registry and returns it to the caller. Takes care of registry headaches,
// including a paranoid length check before getting the string.
//
// NOTE that this function thinks it's getting a string value. If it's
// another kind, this function will do OK: but the caller may be surprised
// if expecting a string.
//
// Returns: success of string retrieval
BOOL HandGet(HKEY hKeyRoot, LPTSTR lpszSubKey, LPTSTR lpszValName, LPTSTR lpszRet)
{
    LONG lret;
    HKEY hKey;                       // cur open key
    BOOL bOK = TRUE;
    DWORD dwSize = 0;
    DWORD dwType;

    // inits
    // get subkey
    lret = RegOpenKeyEx( hKeyRoot, lpszSubKey,
        (DWORD)0, KEY_QUERY_VALUE, (PHKEY)&hKey );
    if (lret != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    // now do our paranoid check of data size
    lret = RegQueryValueEx(hKey, lpszValName,
        (LPDWORD)NULL,
        (LPDWORD)&dwType,
        (LPBYTE)NULL,  // null for size info only
        (LPDWORD)&dwSize );
    
    if (ERROR_SUCCESS == lret)
    {     // saw something there
        // here's the size check before getting the data
        if (dwSize > (DWORD)(MAX_PATH * sizeof(TCHAR)))
        { // if string too big
            bOK = FALSE;               // can't read, so very bad news
            g_bReadOK = FALSE;
        }
        else
        {                        // size is OK to continue
            // now really get the value
            lret = RegQueryValueEx(hKey, lpszValName,
                (LPDWORD)NULL,
                (LPDWORD)&dwType,
                (LPBYTE)lpszRet, // getting actual value
                (LPDWORD)&dwSize);
            
            // If this is an EXPAND_SZ we need to expand it...
            if (REG_EXPAND_SZ == dwType)
            {
                ExpandSZ(lpszRet, MAX_PATH);
            }
            
            if (ERROR_SUCCESS != lret)
                bOK = FALSE;
        }
    }
    else
    {
        bOK = FALSE;
    }

    // cleanup
    // close subkey
    RegCloseKey(hKey);

    return (bOK);
}


HRESULT _GetPlus98ThemesDir(LPTSTR pszPath, DWORD cchSize)
{
    HRESULT hr = HrRegGetPath(HKEY_LOCAL_MACHINE, SZ_REGKEY_PLUS98DIR, SZ_REGVALUE_PLUS98DIR, pszPath, cchSize);
    if (SUCCEEDED(hr))
    {
        TCHAR szSubDir[MAX_PATH];

        LoadString(HINST_THISDLL, IDS_THEMES_SUBDIR, szSubDir, ARRAYSIZE(szSubDir));
        PathAppend(pszPath, szSubDir);
    }

    return hr;
}


HRESULT _GetPlus95ThemesDir(LPTSTR pszPath, DWORD cchSize)
{
    HRESULT hr = HrRegGetPath(HKEY_LOCAL_MACHINE, SZ_REGKEY_PLUS95DIR, SZ_REGVALUE_PLUS98DIR, pszPath, cchSize);
    if (SUCCEEDED(hr))
    {
        TCHAR szSubDir[MAX_PATH];

        LPTSTR pszFile = PathFindFileName(pszPath);
        if (pszFile)
        {
            // Plus!95 DestPath has "Plus!.dll" on the end so get rid of that.
            pszFile[0] = 0;
        }

        // Tack on a "Themes" onto the path
        LoadString(HINST_THISDLL, IDS_THEMES_SUBDIR, szSubDir, ARRAYSIZE(szSubDir));
        PathAppend(pszPath, szSubDir);
    }

    return hr;
}


HRESULT _GetKidsThemesDir(LPTSTR pszPath, DWORD cchSize)
{
    HRESULT hr = HrRegGetPath(HKEY_LOCAL_MACHINE, SZ_REGKEY_KIDSDIR, SZ_REGVALUE_KIDSDIR, pszPath, cchSize);
    if (SUCCEEDED(hr))
    {
        TCHAR szSubDir[MAX_PATH];

        // Tack a "\Plus! for Kids\Themes" onto the path
        PathAppend(pszPath, TEXT("Plus! for Kids"));
        LoadString(HINST_THISDLL, IDS_THEMES_SUBDIR, szSubDir, ARRAYSIZE(szSubDir));
        PathAppend(pszPath, szSubDir);
    }

    return hr;
}


HRESULT _GetHardDirThemesDir(LPTSTR pszPath, DWORD cchSize)
{
    HRESULT hr = HrRegGetPath(HKEY_LOCAL_MACHINE, SZ_REGKEY_PROGRAMFILES, SZ_REGVALUE_PROGRAMFILESDIR, pszPath, cchSize);
    if (SUCCEEDED(hr))
    {
        TCHAR szSubDir[MAX_PATH];

        PathAppend(pszPath, TEXT("Plus!"));
        LoadString(HINST_THISDLL, IDS_THEMES_SUBDIR, szSubDir, ARRAYSIZE(szSubDir));
        PathAppend(pszPath, szSubDir);
    }

    return hr;
}


/*****************************************************************************\
    DESCRIPTION:
        Find any one of the directories that a previous plus pack may have
    installed.  This may include Plus! 95, 98, kids, etc.
\*****************************************************************************/
HRESULT GetPlusThemeDir(IN LPTSTR pszPath, IN int cchSize)
{
    HRESULT hr = S_OK;

    // The follwoing directories can contain themes:
    //   Plus!98 Install Path\Themes
    //   Plus!95 Install Path\Themes
    //   Kids for Plus! Install Path\Themes
    //   Program Files\Plus!\Themes
    hr = _GetPlus98ThemesDir(pszPath, cchSize);
    if (FAILED(hr))
    {
        hr = _GetPlus95ThemesDir(pszPath, cchSize);
        if (FAILED(hr))
        {
            hr = _GetKidsThemesDir(pszPath, cchSize);
            if (FAILED(hr))
            {
                hr = _GetHardDirThemesDir(pszPath, cchSize);
            }
        }
    }

    return hr;
}




TCHAR g_szThemeDir[MAX_PATH];  // dir of most theme files
TCHAR g_szWinDir[MAX_PATH];    // Windows directory

LPTSTR g_pszThemeValues[] = {g_szThemeDir, g_szWinDir, g_szWinDir};
LPCTSTR g_pszThemeTokens[] = {TEXT("%ThemeDir%"),   TEXT("%WinDir%"),  TEXT("%SystemRoot%")};

void ReplaceStringToken(IN LPCTSTR pszSource, IN LPCTSTR pszToken, IN LPCTSTR pszReplacement, IN LPTSTR pszDest, IN int cchSize)
{
    LPCTSTR pszLastPart = &pszSource[lstrlen(pszToken)];

    if (L'\\' == pszLastPart[0])
    {
        pszLastPart++;          // Skip past any slashes
    }

    StrCpyN(pszDest, pszReplacement, cchSize);
    PathAppend(pszDest, pszLastPart);
}

/*****************************************************************************\
    DESCRIPTION:
        Find any tokens in the path (%ThemeDir%, %WinDir%) and replace them
    with the correct paths.
\*****************************************************************************/
HRESULT ExpandThemeTokens(IN LPCTSTR pszThemeFile, IN LPTSTR pszPath, IN int cchSize)
{
    HRESULT hr = S_OK;
    int nIndex;
    TCHAR szFinalPath[MAX_PATH];
    TCHAR szOriginalPath[MAX_PATH];

    szFinalPath[0] = 0;
    StrCpyN(szFinalPath, pszPath, ARRAYSIZE(szFinalPath));
    StrCpyN(szOriginalPath, pszPath, ARRAYSIZE(szOriginalPath));

    InitFrost();
    AssertMsg((0 != g_szThemeDir[0]), TEXT("Someone needs to call InitFrost() first to in this."));
    AssertMsg((0 != g_szWinDir[0]), TEXT("Someone needs to call InitFrost() first to in this."));

    for (nIndex = 0; nIndex < ARRAYSIZE(g_pszThemeTokens); nIndex++)
    {
        if (!StrCmpNI(g_pszThemeTokens[nIndex], szFinalPath, lstrlen(g_pszThemeTokens[nIndex]) - 1))
        {
            // We found the token to replace.
            TCHAR szTempPath[MAX_PATH];

            StrCpyN(szTempPath, szFinalPath, ARRAYSIZE(szTempPath));
            ReplaceStringToken(szTempPath, g_pszThemeTokens[nIndex], g_pszThemeValues[nIndex], szFinalPath, ARRAYSIZE(szFinalPath));
            if ((0 == nIndex) && !PathFileExists(szFinalPath))
            {
                // Sometimes the .theme file will not be in the Theme directory, so we need to try
                // the directory containing the .theme file.
                TCHAR szThemeDir[MAX_PATH];

                StrCpyN(szThemeDir, pszThemeFile, ARRAYSIZE(szThemeDir));
                PathRemoveFileSpec(szThemeDir);
                StrCpyN(szTempPath, szOriginalPath, ARRAYSIZE(szTempPath));
                ReplaceStringToken(szTempPath, g_pszThemeTokens[nIndex], szThemeDir, szFinalPath, ARRAYSIZE(szFinalPath));
            }
            else
            {
                // It worked
            }

            hr = S_OK;
            break;
        }
    }

    if (0 == SHExpandEnvironmentStringsForUserW(NULL, szFinalPath, pszPath, cchSize))
    {
        StrCpyN(pszPath, szFinalPath, cchSize);
    }

    return hr;
}


//
// ConfirmFile
//
// This function does the "smart" file searching that's supposed to be
// built into each resource file reference in applying themes.
//
// First see if the full pathname + file given actually exists.
// If it does not, then try looking for the same filename (stripped from path)
// in other standard directories, in this order:
//    Current Theme file directory
//    Theme switcher THEMES subdirectory
//    Windows directory
//    Windows/MEDIA directory
//    Windows/CURSORS directory
//    Windows/SYSTEM directory
//
// Input: LPTSTR lpszPath     full pathname 
//        BOOL  bUpdate       whether to alter the filename string with found file
// Returns: int flag telling if and how file has been confirmed
//              CF_EXISTS   pathname passed in was actual file
//              CF_FOUND    file did not exist, but found same filename elsewhere
//              CF_NOTFOUND file did not exist, could not find elsewhere
//          
int ConfirmFile(IN LPTSTR lpszPath, IN BOOL bUpdate)
{
    TCHAR szWork[MAX_PATH+1];
    TCHAR szTest[MAX_PATH+1];
    int iret = CF_NOTFOUND;          // default value
    LPTSTR lpFile;
    LPTSTR lpNumber;
    HANDLE hTest;

    // special case easy return: if it's null, then trivially satisfied.
    if (!*lpszPath)
        return CF_EXISTS;  // NO WORK EXIT

    // Inits
    // copy pathname to a work string for the function
    StrCpyN(szWork, lpszPath, ARRAYSIZE(szWork));

    // input can be of the form foo.dll,13. need to strip off that comma,#
    // but hold onto it to put back at the end if we change the pathname
    lpNumber = StrChr(szWork, TEXT(','));
    if (lpNumber && *lpNumber)
    {
        // if there is a comma
        lpFile = lpNumber;            // temp
        lpNumber = CharNext(lpNumber);// hold onto number
        *lpFile = 0;
    }

    // TODO: In Blackcomb we should call SHPathPrepareForWrite() in case
    //       szWork is stored on removable media that the user should insert.

    // Do the checks
    // *** first check if the given file just exists as is
    hTest = CreateFile(szWork, GENERIC_READ, FILE_SHARE_READ,
        (LPSECURITY_ATTRIBUTES)NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
    if (hTest != INVALID_HANDLE_VALUE)
    {
        // success
        iret = CF_EXISTS;             // assign ret value
        // don't need to worry about bUpdate: found with input string
    }
    else            // otherwise, let's go searching for the same filename in other dirs
    {
        // get ptr to the filename separated from the path
        lpFile = PathFindFileName(szWork);

        // *** try the cur theme file dir
        StrCpyN(szTest, szCurDir, ARRAYSIZE(szTest));
        StrCatBuff(szTest, lpFile, ARRAYSIZE(szTest));
        hTest = CreateFile(szTest, GENERIC_READ, FILE_SHARE_READ,
            (LPSECURITY_ATTRIBUTES)NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
        if (hTest != INVALID_HANDLE_VALUE)
        {   // success
            iret = CF_FOUND;           // assign ret value
        }
        else    // *** otherwise try the Theme switcher THEMES subdirectory
        {
            StrCpyN(szTest, g_szThemeDir, ARRAYSIZE(szTest));
            StrCatBuff(szTest, lpFile, ARRAYSIZE(szTest));
            hTest = CreateFile(szTest, GENERIC_READ, FILE_SHARE_READ,
                (LPSECURITY_ATTRIBUTES)NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
            if (hTest != INVALID_HANDLE_VALUE)
            {   // success
                iret = CF_FOUND;           // assign ret value
            }
            else            // *** otherwise try the win dir
            {
                StrCpyN(szTest, g_szWinDir, ARRAYSIZE(szTest));
                StrCatBuff(szTest, lpFile, ARRAYSIZE(szTest));
                hTest = CreateFile(szTest, GENERIC_READ, FILE_SHARE_READ,
                    (LPSECURITY_ATTRIBUTES)NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
                if (hTest != INVALID_HANDLE_VALUE)
                {   // success
                    iret = CF_FOUND;           // assign ret value
                }
                else                    // *** otherwise try the win/media dir
                {
                    // can get this one directly from Registry
                    HandGet(HKEY_LOCAL_MACHINE,
                        TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"),
                        TEXT("MediaPath"), szTest);

#ifdef THEYREMOVEREGSETTING
                    StrCpyN(szTest, g_szWinDir, ARRAYSIZE(szTest));
                    StrCatBuff(szTest, TEXT("Media\\"), ARRAYSIZE(szTest));
#endif

                    StrCatBuff(szTest, TEXT("\\"), ARRAYSIZE(szTest));
                    StrCatBuff(szTest, lpFile, ARRAYSIZE(szTest));

                    hTest = CreateFile(szTest, GENERIC_READ, FILE_SHARE_READ,
                        (LPSECURITY_ATTRIBUTES)NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
                    if (hTest != INVALID_HANDLE_VALUE)
                    {   // success
                        iret = CF_FOUND;           // assign ret value
                    }
                    else      // *** otherwise try the win/cursors dir
                    {
                        StrCpyN(szTest, g_szWinDir, ARRAYSIZE(szTest));
                        StrCatBuff(szTest, TEXT("CURSORS\\"), ARRAYSIZE(szTest));
                        StrCatBuff(szTest, lpFile, ARRAYSIZE(szTest));
                        hTest = CreateFile(szTest, GENERIC_READ, FILE_SHARE_READ,
                            (LPSECURITY_ATTRIBUTES)NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
                        if (hTest != INVALID_HANDLE_VALUE)
                        {   // success
                            iret = CF_FOUND;           // assign ret value
                        }
                        else    // *** otherwise try the win/system dir
                        {
                            StrCpyN(szTest, g_szWinDir, ARRAYSIZE(szTest));
                            StrCatBuff(szTest, TEXT("SYSTEM\\"), ARRAYSIZE(szTest));
                            StrCatBuff(szTest, lpFile, ARRAYSIZE(szTest));
                            hTest = CreateFile(szTest, GENERIC_READ, FILE_SHARE_READ,
                                (LPSECURITY_ATTRIBUTES)NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
                            if (hTest != INVALID_HANDLE_VALUE)
                            {   // success
                                iret = CF_FOUND;           // assign ret value
                            }
                            else    // *** otherwise try the win/system32 dir
                            {
                                StrCpyN(szTest, g_szWinDir, ARRAYSIZE(szTest));
                                StrCatBuff(szTest, TEXT("SYSTEM32\\"), ARRAYSIZE(szTest));
                                StrCatBuff(szTest, lpFile, ARRAYSIZE(szTest));

                                hTest = CreateFile(szTest, GENERIC_READ, FILE_SHARE_READ,
                                    (LPSECURITY_ATTRIBUTES)NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
                                if (hTest != INVALID_HANDLE_VALUE)
                                {   // success
                                    iret = CF_FOUND;           // assign ret value
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // if found anywhere other than orig, copy found path/str as requested
        if ((iret == CF_FOUND) && bUpdate)
        {
            StrCpy(lpszPath, szTest);
            // if we stripped off a number, let's add it back on
            if (lpNumber && *lpNumber)
            {
                StrCatBuff(lpszPath, TEXT(","), MAX_PATH);
                StrCatBuff(lpszPath, lpNumber, MAX_PATH);
            }
        }  // endif found file by searching
   }
   
   // cleanup
   if (iret != CF_NOTFOUND)
       CloseHandle(hTest);           // close file if opened

   return (iret);
}


// InitFrost
// Since there are no window classes to register, this routine just loads
// the strings and, since there's only one instance, calls InitInstance().
//
// Returns: success of initialization
void InitFrost(void)
{
    static BOOL s_fInited = FALSE;

    if (FALSE == s_fInited)
    {
        BOOL bret;
        HDC hdc;

        s_fInited = TRUE;

        if (!GetWindowsDirectory(g_szWinDir, ARRAYSIZE(g_szWinDir)))
        {
            g_szWinDir[0] = 0;
        }

        if (FAILED(GetPlusThemeDir(g_szThemeDir, ARRAYSIZE(g_szThemeDir))))
        {
            StrCpyN(g_szThemeDir, g_szWinDir, ARRAYSIZE(g_szThemeDir));
        }

        // Initialize our g_bGradient flag
        // We may need to get the g_bGradient flag from the Effects tab.
        hdc = GetDC(NULL);
        g_bGradient = (BOOL)(GetDeviceCaps(hdc, BITSPIXEL) > 8);
        ReleaseDC(NULL, hdc);
    
        // init directory strings
        szCurDir[0];

        // default current dir
        StrCpyN(szCurDir, g_szThemeDir, ARRAYSIZE(szCurDir));
    
        // Windows directory
        if (TEXT('\\') != g_szWinDir[lstrlen(g_szWinDir)-1])
        {
            StrCatBuff(g_szWinDir, TEXT("\\"), ARRAYSIZE(g_szWinDir));
        }
    
        // see if there is a previous theme file to return to
        bret = HandGet(HKEY_CURRENT_USER, SZ_REGKEY_CURRENTTHEME, NULL, szMsg);
        if (bret)
        {
            // get init cur dir from prev theme file
            StrCpyN(szCurDir, szMsg, ARRAYSIZE(szCurDir));
            PathFindFileName(szCurDir)[0] = 0;
        }
    }
}


// ascii to integer conversion routine
//

// ***DEBUG*** int'l: is this true? 
// These don't need to be UNICODE/international ready, since they
// *only* deal with strings from the Registry and our own private
// INI files.

/* CAREFUL!! This atoi just IGNORES non-numerics like decimal points!!! */
/* checks for (>=1) leading negative sign */
int latoi(LPSTR s)
{
   int n;
   LPSTR pS;
   BOOL bSeenNum;
   BOOL bNeg;

   n=0;
   bSeenNum = bNeg = FALSE;

   for (pS=s; *pS; pS++) {
      if ((*pS >= '0') && (*pS <= '9')) {
         bSeenNum = TRUE;
         n = n*10 + (*pS - '0');
      }
      if (!bSeenNum && (*pS == '-')) {
         bNeg = TRUE;
      }
   }

   if (bNeg) {
      n = -n;
   }
   
   return(n);
}


//
// Utility routine for above; takes ASCII string to binary in 
// global pValue[] buffer.
//
// Since the values this guy is manipulating is purely ASCII
// numerics we should be able to get away with this char pointer
// arithmetic.  If they were not simple ASCII numerics I think
// we could get into trouble with some DBCS chars
//
// Uses: writes binary data to global pValue[]
//
int WriteBytesToBuffer(IN LPTSTR pszInput, IN void * pOut, IN int cbSize)
{
   LPTSTR lpszCur, lpszNext, lpszEnd;
   BYTE * pbCur = (BYTE *)pOut;
   int iTemp, iBytes;
#ifdef UNICODE
   CHAR szTempA[10];
#endif

   // inits
   lpszNext = pszInput;
   iBytes = 0;
   lpszEnd = pszInput + lstrlen(pszInput);   // points to null term

   // translating loop
   while (*lpszNext && (lpszNext < lpszEnd) && (iBytes < cbSize))
   {
      // update str pointers
      // hold onto your starting place
      lpszCur = lpszNext;
      // advance pointer to next and null terminate cur
      while ((TEXT(' ') != *lpszNext) && *lpszNext) { lpszNext++; }
      *lpszNext = 0;    lpszNext++;
      // on last number, this leaves lpszNext pointing past lpszEnd

      // translate this string-number into binary number and place in
      // output buffer.
#ifdef UNICODE
      wcstombs(szTempA, lpszCur, sizeof(szTempA));
      iTemp = latoi(szTempA);
#else // !UNICODE
      iTemp = latoi(lpszCur);
#endif
      *pbCur = (BYTE)iTemp;
      pbCur++;                      // incr byte loc in output buffer

      // keep track of your bytes
      iBytes++;
   }

   //
   // cleanup
   return (iBytes);
}


HRESULT ConvertBinaryToINIByteString(BYTE * pBytes, DWORD cbSize, LPWSTR * ppszStringOut)
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppszStringOut = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * ((4 * cbSize) + 1));
    if (*ppszStringOut)
    {
        LPWSTR pszCurrent = *ppszStringOut;
        DWORD dwIndex;
        TCHAR szTemp[10];

        for (dwIndex = 0; dwIndex < cbSize; dwIndex++)
        {
            wnsprintf(szTemp, ARRAYSIZE(szTemp), TEXT("%d "), pBytes[dwIndex]);
            StrCpy(pszCurrent, szTemp);
            pszCurrent += lstrlen(szTemp);
        }

        hr = S_OK;
    }

    return hr;
}


void ConvertLogFontToWIDE(LPLOGFONTA aLF, LPLOGFONTW wLF)
{
   ZeroMemory(wLF, sizeof(wLF));
   wLF->lfHeight = aLF->lfHeight;
   wLF->lfWidth = aLF->lfWidth;
   wLF->lfEscapement = aLF->lfEscapement;
   wLF->lfOrientation = aLF->lfOrientation;
   wLF->lfWeight = aLF->lfWeight;
   wLF->lfItalic = aLF->lfItalic;
   wLF->lfUnderline = aLF->lfUnderline;
   wLF->lfStrikeOut = aLF->lfStrikeOut;
   wLF->lfCharSet = aLF->lfCharSet;
   wLF->lfOutPrecision = aLF->lfOutPrecision;
   wLF->lfClipPrecision = aLF->lfClipPrecision;
   wLF->lfQuality = aLF->lfQuality;
   wLF->lfPitchAndFamily = aLF->lfPitchAndFamily;

   MultiByteToWideChar(CP_ACP, 0, aLF->lfFaceName, -1, wLF->lfFaceName, LF_FACESIZE);
}


void ConvertIconMetricsToWIDE(LPICONMETRICSA aIM, LPICONMETRICSW wIM)
{
   ZeroMemory(wIM, sizeof(wIM));

   wIM->cbSize = sizeof(*wIM);
   wIM->iHorzSpacing = aIM->iHorzSpacing;
   wIM->iVertSpacing = aIM->iVertSpacing;
   wIM->iTitleWrap = aIM->iTitleWrap;
   ConvertLogFontToWIDE(&aIM->lfFont, &wIM->lfFont);
}


void ConvertNCMetricsToWIDE(LPNONCLIENTMETRICSA aNCM, LPNONCLIENTMETRICSW wNCM)
{
   ZeroMemory(wNCM, sizeof(wNCM));

   wNCM->cbSize = sizeof(*wNCM);
   wNCM->iBorderWidth = aNCM->iBorderWidth;
   wNCM->iScrollWidth = aNCM->iScrollWidth;
   wNCM->iScrollHeight = aNCM->iScrollHeight;
   wNCM->iCaptionWidth = aNCM->iCaptionWidth;
   wNCM->iCaptionHeight = aNCM->iCaptionHeight;
   ConvertLogFontToWIDE(&aNCM->lfCaptionFont, &wNCM->lfCaptionFont);
   wNCM->iSmCaptionWidth = aNCM->iSmCaptionWidth;
   wNCM->iSmCaptionHeight = aNCM->iSmCaptionHeight;
   ConvertLogFontToWIDE(&aNCM->lfSmCaptionFont, &wNCM->lfSmCaptionFont);
   wNCM->iMenuWidth = aNCM->iMenuWidth;
   wNCM->iMenuHeight = aNCM->iMenuHeight;
   ConvertLogFontToWIDE(&aNCM->lfMenuFont, &wNCM->lfMenuFont);
   ConvertLogFontToWIDE(&aNCM->lfStatusFont, &wNCM->lfStatusFont);
   ConvertLogFontToWIDE(&aNCM->lfMessageFont, &wNCM->lfMessageFont);
}


void ConvertLogFontToANSI(LPLOGFONTW wLF, LPLOGFONTA aLF)
{
   ZeroMemory(aLF, sizeof(aLF));
   aLF->lfHeight = wLF->lfHeight;
   aLF->lfWidth = wLF->lfWidth;
   aLF->lfEscapement = wLF->lfEscapement;
   aLF->lfOrientation = wLF->lfOrientation;
   aLF->lfWeight = wLF->lfWeight;
   aLF->lfItalic = wLF->lfItalic;
   aLF->lfUnderline = wLF->lfUnderline;
   aLF->lfStrikeOut = wLF->lfStrikeOut;
   aLF->lfCharSet = wLF->lfCharSet;
   aLF->lfOutPrecision = wLF->lfOutPrecision;
   aLF->lfClipPrecision = wLF->lfClipPrecision;
   aLF->lfQuality = wLF->lfQuality;
   aLF->lfPitchAndFamily = wLF->lfPitchAndFamily;

   SHUnicodeToAnsi(wLF->lfFaceName, aLF->lfFaceName, ARRAYSIZE(aLF->lfFaceName));
}


void ConvertIconMetricsToANSI(LPICONMETRICSW wIM, LPICONMETRICSA aIM)
{
   ZeroMemory(aIM, sizeof(aIM));

   aIM->cbSize = sizeof(aIM);
   aIM->iHorzSpacing = wIM->iHorzSpacing;
   aIM->iVertSpacing = wIM->iVertSpacing;
   aIM->iTitleWrap = wIM->iTitleWrap;
   ConvertLogFontToANSI(&wIM->lfFont, &aIM->lfFont);
}


void ConvertNCMetricsToANSI(LPNONCLIENTMETRICSW wNCM, LPNONCLIENTMETRICSA aNCM)
{
   ZeroMemory(aNCM, sizeof(aNCM));

   aNCM->cbSize = sizeof(*aNCM);
   aNCM->iBorderWidth = wNCM->iBorderWidth;
   aNCM->iScrollWidth = wNCM->iScrollWidth;
   aNCM->iScrollHeight = wNCM->iScrollHeight;
   aNCM->iCaptionWidth = wNCM->iCaptionWidth;
   aNCM->iCaptionHeight = wNCM->iCaptionHeight;
   ConvertLogFontToANSI(&wNCM->lfCaptionFont, &aNCM->lfCaptionFont);
   aNCM->iSmCaptionWidth = wNCM->iSmCaptionWidth;
   aNCM->iSmCaptionHeight = wNCM->iSmCaptionHeight;
   ConvertLogFontToANSI(&wNCM->lfSmCaptionFont, &aNCM->lfSmCaptionFont);
   aNCM->iMenuWidth = wNCM->iMenuWidth;
   aNCM->iMenuHeight = wNCM->iMenuHeight;
   ConvertLogFontToANSI(&wNCM->lfMenuFont, &aNCM->lfMenuFont);
   ConvertLogFontToANSI(&wNCM->lfStatusFont, &aNCM->lfStatusFont);
   ConvertLogFontToANSI(&wNCM->lfMessageFont, &aNCM->lfMessageFont);
}


HRESULT GetIconMetricsFromSysMetricsAll(SYSTEMMETRICSALL * pSystemMetrics, LPICONMETRICSA pIconMetrics, DWORD cchSize)
{
    HRESULT hr = E_INVALIDARG;

    if (pIconMetrics && (sizeof(*pIconMetrics) == cchSize))
    {
        ZeroMemory(pIconMetrics, sizeof(*pIconMetrics));

        pIconMetrics->cbSize = sizeof(*pIconMetrics);
        SystemParametersInfoA(SPI_GETICONMETRICS, sizeof(*pIconMetrics), pIconMetrics, 0);

        ConvertLogFontToANSI(&pSystemMetrics->schemeData.lfIconTitle, &pIconMetrics->lfFont);

        hr = S_OK;
    }

    return hr;
}

//
// TransmitFontCharacteristics
//
// This is actually a pretty key function. See, font characteristics are
// all set together: a LOGFONT has name and style and size info all in one.
// But when you are setting all the nonclient metrics like window caption
// and menu size, you need to stretch the font sizes with it. But we give the
// user a choice of changing window sizes without "changing" the font; i.e.
// without applying a new font name and style from the theme.
//
// So we need to be able to pick apart the name and style from the size
// characteristics. And here it is.
//
// Really just a helper routine for the above function, so we don't have all
// this gunk inline five times.
//
void TransmitFontCharacteristics(PLOGFONT plfDst, PLOGFONT plfSrc, int iXmit)
{
   switch (iXmit)
   {
   case TFC_SIZE:
      plfDst->lfHeight = plfSrc->lfHeight;
      plfDst->lfWidth = plfSrc->lfWidth;
      break;
   case TFC_STYLE:
      plfDst->lfEscapement = plfSrc->lfEscapement;
      plfDst->lfOrientation = plfSrc->lfOrientation;
      plfDst->lfWeight = plfSrc->lfWeight;
      plfDst->lfItalic = plfSrc->lfItalic;
      plfDst->lfUnderline = plfSrc->lfUnderline;
      plfDst->lfStrikeOut = plfSrc->lfStrikeOut;
      plfDst->lfCharSet = plfSrc->lfCharSet;
      plfDst->lfOutPrecision = plfSrc->lfOutPrecision;
      plfDst->lfClipPrecision = plfSrc->lfClipPrecision;
      plfDst->lfQuality = plfSrc->lfQuality;
      plfDst->lfPitchAndFamily = plfSrc->lfPitchAndFamily;
      lstrcpy(plfDst->lfFaceName, plfSrc->lfFaceName);
      break;
   }
}


// RGB to String to RGB utilities.
COLORREF RGBStringToColor(LPTSTR lpszRGB)
{
   LPTSTR lpszCur, lpszNext;
   BYTE bRed, bGreen, bBlue;
#ifdef UNICODE
   CHAR szTempA[10];
#endif

   // inits
   lpszNext = lpszRGB;

   // set up R for translation
   lpszCur = lpszNext;
   while ((TEXT(' ') != *lpszNext) && *lpszNext) { lpszNext++; }
   *lpszNext = 0;    lpszNext++;
   // get Red
#ifdef UNICODE
   wcstombs(szTempA, (wchar_t *)lpszCur, sizeof(szTempA));
   bRed = (BYTE)latoi(szTempA);
#else // !UNICODE
   bRed = (BYTE)latoi(lpszCur);
#endif
   // set up G for translation
   lpszCur = lpszNext;
   while ((TEXT(' ') != *lpszNext) && *lpszNext) { lpszNext++; }
   *lpszNext = 0;    lpszNext++;
   // get Green
#ifdef UNICODE
   wcstombs(szTempA, (wchar_t *)lpszCur, sizeof(szTempA));
   bGreen = (BYTE)latoi(szTempA);
#else // !UNICODE
   bGreen = (BYTE)latoi(lpszCur);
#endif
   // set up B for translation
   lpszCur = lpszNext;
   while ((TEXT(' ') != *lpszNext) && *lpszNext) { lpszNext++; }
   *lpszNext = 0;    lpszNext++;
   // get Blue
#ifdef UNICODE
   wcstombs(szTempA, (wchar_t *)lpszCur, sizeof(szTempA));
   bBlue = (BYTE)latoi(szTempA);
#else // !UNICODE
   bBlue = (BYTE)latoi(lpszCur);
#endif

   // OK, now combine them all for the big finish.....!
   return(RGB(bRed, bGreen, bBlue));
}



// IsValidThemeFile
//
// Answers the question.
BOOL IsValidThemeFile(IN LPCWSTR pszTest)
{
   WCHAR szValue[MAX_PATH];
   BOOL fIsValid = FALSE;

   if (GetPrivateProfileString(SZ_INISECTION_MASTERSELECTOR, SZ_INIKEY_THEMEMAGICTAG, SZ_EMPTY, szValue, ARRAYSIZE(szValue), pszTest))
   {
       fIsValid = !StrCmp(szValue, SZ_INIKEY_THEMEMAGICVALUE);
   }

   return fIsValid;
}




HRESULT SnapCreateTemplate(LPCWSTR pszPath, ITheme ** ppTheme)
{
    HRESULT hr = E_INVALIDARG;

    if (ppTheme)
    {
        *ppTheme = NULL;

        if (pszPath)
        {
            // Start with a template ("Windows Classic.theme").
            TCHAR szTemplate[MAX_PATH];

            DeleteFile(pszPath);
            StrCpyN(szTemplate, pszPath, ARRAYSIZE(szTemplate));
            PathRemoveFileSpec(szTemplate);
            SHCreateDirectoryEx(NULL, szTemplate, NULL);

            hr = SHGetResourcePath(TRUE, szTemplate, ARRAYSIZE(szTemplate));
            if (SUCCEEDED(hr))
            {
                PathAppend(szTemplate, TEXT("Themes\\Windows Classic.theme"));
                if (CopyFile(szTemplate, pszPath, FALSE))
                {
                    hr = CThemeFile_CreateInstance(pszPath, ppTheme);
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
        }
   }

   return hr;
}



/*****************************************************************************\
    DESCRIPTION:
        This function will grab the live settings (from pPropertyBag) and put
    theme into a file specified by pszPath.  A pointer to the Theme will be
    returned in ppTheme.  If the settings cannot be obtained, they will come
    from "Windows Classic.theme".  This includes the Display Name, so the call
    will almost always want to specify that if this function returns successfully.

    PARAMETERS:
        pPropertyBag: This is were the settings will be read from.
        pszPath: This is the file will be saved to.  It will be replaced if it exists.
        ppTheme: This will be created and returned if successful.
\*****************************************************************************/
HRESULT SnapShotLiveSettingsToTheme(IPropertyBag * pPropertyBag, LPCWSTR pszPath, ITheme ** ppTheme)
{
    HRESULT hr = SnapCreateTemplate(pszPath, ppTheme);

    if (SUCCEEDED(hr))
    {
        TCHAR szPath[MAX_PATH];
        ITheme * pTheme = *ppTheme;

        // 1. Save the Background
        // We may fail to get the background path if the policy turns it off.
        if (SUCCEEDED(SHPropertyBag_ReadStr(pPropertyBag, SZ_PBPROP_BACKGROUNDSRC_PATH, szPath, ARRAYSIZE(szPath))))
        {
            CComBSTR bstrPath(szPath);
            hr = pTheme->put_Background(bstrPath);
            if (SUCCEEDED(hr))
            {
                DWORD dwBackgroundTile;

                if (SUCCEEDED(SHPropertyBag_ReadDWORD(pPropertyBag, SZ_PBPROP_BACKGROUND_TILE, &dwBackgroundTile)))
                {
                    enumBkgdTile nTile = BKDGT_STRECH;

                    switch (dwBackgroundTile)
                    {
                    case WPSTYLE_CENTER:
                        nTile = BKDGT_CENTER;
                        break;
                    case WPSTYLE_TILE:
                        nTile = BKDGT_TILE;
                        break;
                    };

                    hr = pTheme->put_BackgroundTile(nTile);
                }
            }
        }

        // 2. Save Screen Saver
        if (SUCCEEDED(hr))
        {
            // This will fail with policies enabled.  In that case, we just use the default value.
            if (SUCCEEDED(SHPropertyBag_ReadStr(pPropertyBag, SZ_PBPROP_SCREENSAVER_PATH, szPath, ARRAYSIZE(szPath))))
            {
                CComBSTR bstrPath(szPath);
                hr = pTheme->put_ScreenSaver(bstrPath);
            }
        }

        // 3. Save Visual Style
        if (SUCCEEDED(hr))
        {
            // It's okay to have no visual style selected.
            if (SUCCEEDED(SHPropertyBag_ReadStr(pPropertyBag, SZ_PBPROP_VISUALSTYLE_PATH, szPath, ARRAYSIZE(szPath))) && szPath[0])
            {
                CComBSTR bstrPath(szPath);

                hr = pTheme->put_VisualStyle(bstrPath);
                if (SUCCEEDED(hr) &&
                    SUCCEEDED(SHPropertyBag_ReadStr(pPropertyBag, SZ_PBPROP_VISUALSTYLE_COLOR, szPath, ARRAYSIZE(szPath))))
                {
                    bstrPath = szPath;

                    hr = pTheme->put_VisualStyleColor(bstrPath);
                    if (SUCCEEDED(hr) &&
                        SUCCEEDED(SHPropertyBag_ReadStr(pPropertyBag, SZ_PBPROP_VISUALSTYLE_SIZE, szPath, ARRAYSIZE(szPath))))
                    {
                        bstrPath = szPath;

                        hr = pTheme->put_VisualStyleSize(bstrPath);
                    }
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            // 4. Save System Metrics
            IPropertyBag * pPropertyBagFile;

            hr = pTheme->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBagFile));
            if (SUCCEEDED(hr))
            {
                VARIANT var = {0};

                // This call will return SYSTEMMETRICS relative to the currently live DPI.
                hr = pPropertyBag->Read(SZ_PBPROP_SYSTEM_METRICS, &var, NULL);
                if (SUCCEEDED(hr) && (VT_BYREF == var.vt) && var.byref)
                {
                    SYSTEMMETRICSALL * pCurrent = (SYSTEMMETRICSALL *) var.byref;

                    IUnknown_SetSite(pPropertyBagFile, pPropertyBag);   // Set the site so they can get settings.
                    hr = SHPropertyBag_WriteByRef(pPropertyBagFile, SZ_PBPROP_SYSTEM_METRICS, (void *)pCurrent);
                    IUnknown_SetSite(pPropertyBagFile, NULL);   // Break any back pointers.
                }

                pPropertyBagFile->Release();
            }
        }

        // 5. Save Sounds
        int nIndex;

        for (nIndex = 0; nIndex < ARRAYSIZE(s_ThemeSoundsValues); nIndex++)
        {
            if (FAILED(HrRegGetPath(HKEY_CURRENT_USER, s_ThemeSoundsValues[nIndex].pszRegKey, NULL, szPath, ARRAYSIZE(szPath))))
            {
                szPath[0] = 0;
            }

            pTheme->SetSound((BSTR)s_ThemeSoundsValues[nIndex].pszRegKey, szPath);
        }


        // 6. Save Icons
        for (nIndex = 0; (nIndex < ARRAYSIZE(s_Icons)); nIndex++)
        {
            // This can fail if the background policy is enabled.
            if (SUCCEEDED(SHPropertyBag_ReadStr(pPropertyBag, s_Icons[nIndex], szPath, ARRAYSIZE(szPath))))
            {
                pTheme->SetIcon((BSTR)s_Icons[nIndex], szPath);
            }
        }


        // 7. Save Cursors
        for (nIndex = 0; nIndex < ARRAYSIZE(s_pszCursorArray); nIndex++)
        {
            if (FAILED(HrRegGetPath(HKEY_CURRENT_USER, SZ_INISECTION_CURSORS, s_pszCursorArray[nIndex], szPath, ARRAYSIZE(szPath))))
            {
                szPath[0] = 0;
            }

            pTheme->SetCursor((BSTR)s_pszCursorArray[nIndex], szPath);
        }

        if (SUCCEEDED(HrRegGetPath(HKEY_CURRENT_USER, SZ_INISECTION_CURSORS, NULL, szPath, ARRAYSIZE(szPath))))
        {
            pTheme->SetCursor(SZ_INIKEY_CURSORSCHEME, szPath);
        }

        if (FAILED(hr))
        {
            // Partially written files are very bad.
            DeleteFile(pszPath);
            ATOMICRELEASE(*ppTheme);
        }
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\thsettingspg.h ===
/*****************************************************************************\
    FILE: ThSettingsPg.h

    DESCRIPTION:
        This code will display a "Theme Settings" tab in the advanced
    "Display Properties" dialog (the advanced dialog, not the base dlg).

    BryanSt 3/23/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 1993-2000. All rights reserved.
\*****************************************************************************/

#ifndef _THEMESETTINGSPG_H
#define _THEMESETTINGSPG_H

#include <cowsite.h>



HRESULT CThemeSettingsPage_CreateInstance(OUT IAdvancedDialog ** ppAdvDialog);


#define THEMEFILTER_SCREENSAVER             0x00000000
#define THEMEFILTER_SOUNDS                  0x00000001
#define THEMEFILTER_CURSORS                 0x00000002
#define THEMEFILTER_WALLPAPER               0x00000003
#define THEMEFILTER_ICONS                   0x00000004
#define THEMEFILTER_COLORS                  0x00000005
#define THEMEFILTER_SMSTYLES                0x00000006
#define THEMEFILTER_SMSIZES                 0x00000007


#define SIZE_THEME_FILTERS          9
extern const TCHAR * g_szCBNames[SIZE_THEME_FILTERS];


#endif // _THEMESETTINGSPG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\thsettingspg.cpp ===
/*****************************************************************************\
    FILE: ThSettingsPg.cpp

    DESCRIPTION:
        This code will display a "Theme Settings" tab in the advanced
    "Display Properties" dialog (the advanced dialog, not the base dlg).

    BryanSt 3/23/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 1993-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "regutil.h"
#include "ThSettingsPg.h"
#include "AdvAppearPg.h"



//============================================================================================================
// Class
//============================================================================================================
class CThemeSettingsPage        : public CObjectWithSite
                                , public IAdvancedDialog
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IAdvancedDialog ***
    virtual STDMETHODIMP DisplayAdvancedDialog(IN HWND hwndParent, IN IPropertyBag * pBasePage, IN BOOL * pfEnableApply);

    CThemeSettingsPage();
protected:

private:
    virtual ~CThemeSettingsPage(void);

    // Private Member Variables
    long                    m_cRef;
    BOOL                    m_fDirty;
    HWND                    m_hDlg;
    IPropertyBag *          m_pPropertyBag;

    // Private Member Functions
    INT_PTR _ThemeSettingsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    HRESULT _OnInitThemesDlg(HWND hDlg);
    HRESULT _OnDestroy(HWND hDlg);
    INT_PTR _OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

    HRESULT _LoadState(IN IPropertyBag * pBasePage);
    HRESULT _SaveState(IN IPropertyBag * pBasePage);

    HRESULT _OnSaveButton(HWND hDlg);
    HRESULT _OnDeleteButton(HWND hDlg);
    HRESULT _IsDirty(IN BOOL * pIsDirty);

    static INT_PTR CALLBACK ThemeSettingsDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};








//============================================================================================================
// *** Globals ***
//============================================================================================================
const static DWORD FAR aThemeSettingsHelpIds[] = {
    IDC_TSPG_THEMELIST_LABLE,           IDH_DISPLAY_THEMESETTINGS_NAMELABLE,
    IDC_TSPG_THEME_NAME,                IDH_DISPLAY_THEMESETTINGS_NAME,
    IDC_TSPG_CB_GROUP_LABEL,            IDH_DISPLAY_THEMESETTINGS_LABEL,
    IDC_TSPG_CB_LABEL,                  IDH_DISPLAY_THEMESETTINGS_LABEL,
    IDC_TSPG_CB_WALLPAPER,              IDH_DISPLAY_THEMESETTINGS_WALLPAPER,
    IDC_TSPG_CB_SOUNDS,                 IDH_DISPLAY_THEMESETTINGS_SOUNDS,
    IDC_TSPG_CB_MOUSE,                  IDH_DISPLAY_THEMESETTINGS_MOUSE,
    IDC_TSPG_CB_SCREENSAVER,            IDH_DISPLAY_THEMESETTINGS_SCREENSAVER,
    IDC_TSPG_CB_ICONS,                  IDH_DISPLAY_THEMESETTINGS_ICONS, 
    IDC_TSPG_CB_COLORS,                 IDH_DISPLAY_THEMESETTINGS_COLORS, 
    IDC_TSPG_CB_FONTS,                  IDH_DISPLAY_THEMESETTINGS_FONTS,
    IDC_TSPG_CB_BORDERS,                IDH_DISPLAY_THEMESETTINGS_BORDERS, 
    0, 0
};

#define SZ_HELPFILE_THEMESETTINGS           TEXT("display.hlp")


const TCHAR * g_szCBNames[SIZE_THEME_FILTERS] =
{
    SZ_PBPROP_THEME_FILTER TEXT("Screen saver"),
    SZ_PBPROP_THEME_FILTER TEXT("Sound events"),
    SZ_PBPROP_THEME_FILTER TEXT("Mouse pointers"),
    SZ_PBPROP_THEME_FILTER TEXT("Desktop wallpaper"),
    SZ_PBPROP_THEME_FILTER TEXT("Icons"),
//    TEXT("Icon size and spacing"),
    SZ_PBPROP_THEME_FILTER TEXT("Colors"),
    SZ_PBPROP_THEME_FILTER TEXT("Font names and styles"),
    SZ_PBPROP_THEME_FILTER TEXT("Font and window sizes"),
    SZ_PBPROP_THEME_FILTER TEXT("Rotate theme monthly")
};  




//===========================
// *** Class Internals & Helpers ***
//===========================
INT_PTR CALLBACK CThemeSettingsPage::ThemeSettingsDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CThemeSettingsPage * pThis = (CThemeSettingsPage *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        pThis = (CThemeSettingsPage *) lParam;

        if (pThis)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        }
    }

    if (pThis)
        return pThis->_ThemeSettingsDlgProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}


HRESULT CThemeSettingsPage::_OnSaveButton(HWND hDlg)
{
    HRESULT hr = E_NOTIMPL;

    return hr;
}


HRESULT CThemeSettingsPage::_OnDeleteButton(HWND hDlg)
{
    HRESULT hr = E_NOTIMPL;

    return hr;
}


HRESULT CThemeSettingsPage::_OnInitThemesDlg(HWND hDlg)
{
    m_hDlg = hDlg;
    
    if (m_pPropertyBag)
    {
        VARIANT varName;

        VariantInit(&varName);
        HRESULT hr = m_pPropertyBag->Read(SZ_PBPROP_THEME_DISPLAYNAME, &varName, NULL);
        if (SUCCEEDED(hr))
        {
            if (VT_BSTR == varName.vt)
            {
                SetWindowTextW(GetDlgItem(hDlg, IDC_TSPG_THEME_NAME), varName.bstrVal);
            }

            VariantClear(&varName);
        }
    }

    return _LoadState(m_pPropertyBag);
}


HRESULT CThemeSettingsPage::_OnDestroy(HWND hDlg)
{
    return S_OK;
}


INT_PTR CThemeSettingsPage::_OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = 1;   // Not handled (WM_COMMAND seems to be different)
    WORD idCtrl = GET_WM_COMMAND_ID(wParam, lParam);

    switch (idCtrl)
    {
    case IDOK:
        _SaveState(m_pPropertyBag);
        EndDialog(hDlg, IDOK);
        break;

    case IDCANCEL:
        EndDialog(hDlg, IDCANCEL);
        break;

    case IDC_TSPG_CB_SCREENSAVER:
    case IDC_TSPG_CB_SOUNDS:
    case IDC_TSPG_CB_MOUSE:
    case IDC_TSPG_CB_WALLPAPER:
    case IDC_TSPG_CB_ICONS:
    case IDC_TSPG_CB_COLORS:
    case IDC_TSPG_CB_FONTS:
    case IDC_TSPG_CB_BORDERS:
        m_fDirty = TRUE;
        break;

    default:
        break;
    }

    return fHandled;
}



// This Property Sheet appear in the top level of the "Display Control Panel".
INT_PTR CThemeSettingsPage::_ThemeSettingsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
    case WM_NOTIFY:
        break;

    case WM_INITDIALOG:
        _OnInitThemesDlg(hDlg);
        break;

    case WM_DESTROY:
        _OnDestroy(hDlg);
        break;

    case WM_HELP:
        WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, SZ_HELPFILE_THEMESETTINGS, HELP_WM_HELP, (DWORD_PTR) aThemeSettingsHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, SZ_HELPFILE_THEMESETTINGS, HELP_CONTEXTMENU, (DWORD_PTR) aThemeSettingsHelpIds);
        break;

    case WM_COMMAND:
        _OnCommand(hDlg, message, wParam, lParam);
        break;
    }

    return FALSE;
}



HRESULT CThemeSettingsPage::_IsDirty(IN BOOL * pIsDirty)
{
    HRESULT hr = E_INVALIDARG;

    if (pIsDirty)
    {
        *pIsDirty = m_fDirty;
        hr = S_OK;
    }

    return hr;
}


HRESULT CThemeSettingsPage::_LoadState(IN IPropertyBag * pPropertyBag)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pPropertyBag)
    {
        for (int nIndex = IDC_TSPG_CB_SCREENSAVER; nIndex <= IDC_TSPG_CB_BORDERS; nIndex++)
        {
            VARIANT varFilter;

            varFilter.vt = VT_BOOL;
            varFilter.boolVal = VARIANT_TRUE;

            hr = pPropertyBag->Read(g_szCBNames[nIndex - IDC_TSPG_CB_SCREENSAVER], &varFilter, NULL);
            CheckDlgButton(m_hDlg, nIndex, ((VARIANT_TRUE == varFilter.boolVal) ? BST_CHECKED : BST_UNCHECKED));
        }
    }

    return hr;
}


HRESULT CThemeSettingsPage::_SaveState(IN IPropertyBag * pBasePage)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pBasePage)
    {
        for (int nIndex = IDC_TSPG_CB_SCREENSAVER; nIndex <= IDC_TSPG_CB_BORDERS; nIndex++)
        {
            VARIANT varFilter;

            varFilter.vt = VT_BOOL;
            varFilter.boolVal = ((BST_UNCHECKED != IsDlgButtonChecked(m_hDlg, nIndex)) ? VARIANT_TRUE : VARIANT_FALSE);

            hr = pBasePage->Write(g_szCBNames[nIndex - IDC_TSPG_CB_SCREENSAVER], &varFilter);
        }
    }

    return hr;
}




//===========================
// *** IAdvancedDialog Interface ***
//===========================
HRESULT CThemeSettingsPage::DisplayAdvancedDialog(IN HWND hwndParent, IN IPropertyBag * pBasePage, IN BOOL * pfEnableApply)
{
    HRESULT hr = E_INVALIDARG;

    if (hwndParent && pBasePage && pfEnableApply)
    {
        // Load State Into Advanced Dialog 
        *pfEnableApply = FALSE;
        IUnknown_Set((IUnknown **) &m_pPropertyBag, pBasePage);

        hr = S_OK;
        // Display Advanced Dialog
        if (IDOK == DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_THEMESETTINGSPG), hwndParent, CThemeSettingsPage::ThemeSettingsDlgProc, (LPARAM)this))
        {
            // The user clicked OK, so merge modified state back into base dialog
            _IsDirty(pfEnableApply);
        }
    }

    return hr;
}





//===========================
// *** IUnknown Interface ***
//===========================
ULONG CThemeSettingsPage::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CThemeSettingsPage::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CThemeSettingsPage::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CThemeSettingsPage, IObjectWithSite),
        QITABENT(CThemeSettingsPage, IAdvancedDialog),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CThemeSettingsPage::CThemeSettingsPage() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_fDirty);
    ASSERT(!m_hDlg);
    ASSERT(!m_pPropertyBag);

}


CThemeSettingsPage::~CThemeSettingsPage()
{
    IUnknown_Set((IUnknown **) &m_pPropertyBag, NULL);
    DllRelease();
}




HRESULT CThemeSettingsPage_CreateInstance(OUT IAdvancedDialog ** ppAdvDialog)
{
    HRESULT hr = E_INVALIDARG;

    if (ppAdvDialog)
    {
        CThemeSettingsPage * pThis = new CThemeSettingsPage();

        if (pThis)
        {
            hr = pThis->QueryInterface(IID_PPV_ARG(IAdvancedDialog, ppAdvDialog));
            pThis->Release();
        }
        else
        {
            *ppAdvDialog = NULL;
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\thsize.cpp ===
/*****************************************************************************\
    FILE: thSize.cpp

    DESCRIPTION:
        This is the Autmation Object to theme size object.  This one will be
    for the Skin objects.

    BryanSt 5/13/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <cowsite.h>
#include <atlbase.h>
#include "util.h"
#include "thsize.h"




//===========================
// *** Class Internals & Helpers ***
//===========================
HRESULT CSkinSize::_InitVisualStyle(void)
{
    HRESULT hr = S_OK;

    if (!m_hTheme)
    {
        if (m_pszFilename && m_pszStyleName && m_pszSizeName)
        {
            HTHEMEFILE hThemeFile;
            
            // Load the skin
            hr = OpenThemeFile(m_pszFilename, m_pszStyleName, m_pszSizeName, &hThemeFile, FALSE);
            LogStatus("OpenThemeFile(path=\"%ls\", color=\"%ls\", size=\"%ls\") returned %#08lx in CSkinSize::_InitVisualStyle.\r\n", m_pszFilename, m_pszStyleName, m_pszSizeName, hr);

            if (SUCCEEDED(hr))
            {
                m_hTheme = OpenThemeDataFromFile(hThemeFile, NULL, NULL, FALSE);
                LogStatus("OpenThemeDataFromFile() returned %#08lx in CSkinSize::_InitVisualStyle.\r\n", m_hTheme);
                hr = ((NULL == m_hTheme) ? E_FAIL : S_OK);

                CloseThemeFile(hThemeFile);
            }

        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
}



//===========================
// *** IThemeSize Interface ***
//===========================
HRESULT CSkinSize::get_DisplayName(OUT BSTR * pbstrDisplayName)
{
    return HrSysAllocString(m_pszDisplayName, pbstrDisplayName);
}


HRESULT CSkinSize::put_DisplayName(IN BSTR bstrDisplayName)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrDisplayName)
    {
        Str_SetPtr(&m_pszDisplayName, bstrDisplayName);
        hr = (m_pszDisplayName ? S_OK : E_OUTOFMEMORY);
    }

    return hr;
}


HRESULT CSkinSize::get_Name(OUT BSTR * pbstrName)
{
    return HrSysAllocString(m_pszSizeName, pbstrName);
}


HRESULT CSkinSize::put_Name(IN BSTR bstrName)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrName)
    {
        Str_SetPtr(&m_pszSizeName, bstrName);
        hr = (m_pszSizeName ? S_OK : E_OUTOFMEMORY);
    }

    return hr;
}


HRESULT CSkinSize::get_WebviewCSS(OUT BSTR * pbstrPath)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrPath)
    {
        *pbstrPath = NULL;
        hr = _InitVisualStyle();
        if (SUCCEEDED(hr))
        {
            WCHAR szPath[MAX_PATH];
            WCHAR szFilename[MAX_PATH];

            StrCpyNW(szPath, m_pszFilename, ARRAYSIZE(szPath));
            PathRemoveFileSpec(szPath);                     // Remove the filename ("xx.msstyles") from the path.

            hr = GetThemeSysString(m_hTheme, TMT_CSSNAME, szFilename, ARRAYSIZE(szFilename));
            LogStatus("GetThemeDefaults(szFilename=\"%ls\") returned %#08lx in CSkinSize::get_WebviewCSS.\r\n", szFilename, hr);
            if (SUCCEEDED(hr))
            {
                PathAppend(szPath, szFilename);
                hr = HrSysAllocString(szPath, pbstrPath);
            }
        }
    }

    return hr;
}


HRESULT CSkinSize::get_SystemMetricColor(IN int nSysColorIndex, OUT COLORREF * pColorRef)
{
    HRESULT hr = E_INVALIDARG;

    if (pColorRef)
    {
        *pColorRef = 0x00000000;

        hr = _InitVisualStyle();
        if (SUCCEEDED(hr))
        {
            *pColorRef = GetThemeSysColor(m_hTheme, nSysColorIndex);
            hr = S_OK;
        }

//        LogStatus("CSkinSize::get_SystemMetricColor() GetThemeSysColor()=%#08lx returned %#08lx in CSkinSize::get_SystemMetricColor.\r\n", *pColorRef, hr);
    }

    return hr;
}


HRESULT CSkinSize::get_SystemMetricSize(IN enumSystemMetricSize nSystemMetricIndex, OUT int * pnSize)
{
    HRESULT hr = E_INVALIDARG;

    if (pnSize)
    {
        *pnSize = 0;

        hr = _InitVisualStyle();
        if (SUCCEEDED(hr))
        {
            hr = S_OK;

            switch (nSystemMetricIndex)
            {
            case SMS_BORDERWIDTH:
                *pnSize = GetThemeSysSize96(m_hTheme, SM_CXBORDER);
                break;

            case SMS_SCROLLWIDTH:
                *pnSize = GetThemeSysSize96(m_hTheme, SM_CXVSCROLL);
                break;

            case SMS_SCROLLHEIGHT:
                *pnSize = GetThemeSysSize96(m_hTheme, SM_CYHSCROLL);
                break;

            case SMS_CAPTIONWIDTH:
                *pnSize = GetThemeSysSize96(m_hTheme, SM_CXSIZE);
                break;

            case SMS_CAPTIONHEIGHT:
                *pnSize = GetThemeSysSize96(m_hTheme, SM_CYSIZE);
                break;

            case SMS_SMCAPTIONWIDTH:
                *pnSize = GetThemeSysSize96(m_hTheme, SM_CXSMSIZE);
                break;

            case SMS_SMCAPTIONHEIGHT:
                *pnSize = GetThemeSysSize96(m_hTheme, SM_CYSMSIZE);
                break;

            case SMS_MENUWIDTH:
                *pnSize = GetThemeSysSize96(m_hTheme, SM_CXMENUSIZE);
                break;

            case SMS_MENUHEIGHT:
                *pnSize = GetThemeSysSize96(m_hTheme, SM_CYMENUSIZE);
                break;

            default:
                hr = E_INVALIDARG;
                break;
            }
        }
    }

    return hr;
}

HRESULT CSkinSize::GetSystemMetricFont(IN enumSystemMetricFont nSPIFontIndex, IN LOGFONTW * plfFont)
{
    HRESULT hr = E_INVALIDARG;

    if (plfFont)
    {
        hr = _InitVisualStyle();
        if (SUCCEEDED(hr))
        {
            if (!m_fFontsLoaded)
            {
                if (SUCCEEDED(hr = GetThemeSysFont96(m_hTheme, TMT_CAPTIONFONT, &m_sysMetrics.schemeData.ncm.lfCaptionFont)) &&
                    SUCCEEDED(hr = GetThemeSysFont96(m_hTheme, TMT_SMALLCAPTIONFONT, &m_sysMetrics.schemeData.ncm.lfSmCaptionFont)) &&
                    SUCCEEDED(hr = GetThemeSysFont96(m_hTheme, TMT_MENUFONT, &m_sysMetrics.schemeData.ncm.lfMenuFont)) &&
                    SUCCEEDED(hr = GetThemeSysFont96(m_hTheme, TMT_STATUSFONT, &m_sysMetrics.schemeData.ncm.lfStatusFont)) &&
                    SUCCEEDED(hr = GetThemeSysFont96(m_hTheme, TMT_MSGBOXFONT, &m_sysMetrics.schemeData.ncm.lfMessageFont)) &&
                    SUCCEEDED(hr = GetThemeSysFont96(m_hTheme, TMT_ICONTITLEFONT, &m_sysMetrics.schemeData.lfIconTitle)))
                {
                    m_fFontsLoaded = TRUE;
                }
            }

            if (SUCCEEDED(hr))
            {
                switch (nSPIFontIndex)
                {
                case SMF_CAPTIONFONT:
                    *plfFont = m_sysMetrics.schemeData.ncm.lfCaptionFont;
                    break;

                case SMF_SMCAPTIONFONT:
                    *plfFont = m_sysMetrics.schemeData.ncm.lfSmCaptionFont;
                    break;

                case SMF_MENUFONT:
                    *plfFont = m_sysMetrics.schemeData.ncm.lfMenuFont;
                    break;

                case SMF_STATUSFONT:
                    *plfFont = m_sysMetrics.schemeData.ncm.lfStatusFont;
                    break;

                case SMF_MESSAGEFONT:
                    *plfFont = m_sysMetrics.schemeData.ncm.lfMessageFont;
                    break;

                case SMF_ICONTITLEFONT:
                    *plfFont = m_sysMetrics.schemeData.lfIconTitle;
                    break;

                default:
                    hr = E_INVALIDARG;
                    break;
                }
            }
        }
    }

    return hr;
}








//===========================
// *** IPropertyBag Interface ***
//===========================
HRESULT CSkinSize::Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        if (!StrCmpW(pszPropName, SZ_PBPROP_VSBEHAVIOR_FLATMENUS))
        {
            hr = _InitVisualStyle();
            if (SUCCEEDED(hr))
            {
                pVar->vt = VT_BOOL;
                pVar->boolVal = (GetThemeSysBool(m_hTheme, TMT_FLATMENUS) ? VARIANT_TRUE : VARIANT_FALSE);
                LogStatus("GetThemeSysBool()=%#08lx returned %#08lx in CSkinSize::Read.\r\n", pVar->boolVal, hr);
            }
        }
    }

    return hr;
}






//===========================
// *** IUnknown Interface ***
//===========================
ULONG CSkinSize::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CSkinSize::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


//===========================
// *** Class Methods ***
//===========================
HRESULT CSkinSize::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CSkinSize, IThemeSize),
        QITABENT(CSkinSize, IPropertyBag),
        QITABENT(CSkinSize, IDispatch),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


CSkinSize::CSkinSize(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszSizeName, IN LPCWSTR pszDisplayName) : CImpIDispatch(LIBID_Theme, 1, 0, IID_IThemeSize), m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_hTheme);
    m_fFontsLoaded = FALSE;

    Str_SetPtr(&m_pszFilename, pszFilename);
    Str_SetPtr(&m_pszDisplayName, pszDisplayName);
    Str_SetPtr(&m_pszStyleName, pszStyleName);
    Str_SetPtr(&m_pszSizeName, pszSizeName);
}


CSkinSize::~CSkinSize()
{
    Str_SetPtr(&m_pszFilename, NULL);
    Str_SetPtr(&m_pszDisplayName, NULL);
    Str_SetPtr(&m_pszStyleName, NULL);
    Str_SetPtr(&m_pszSizeName, NULL);

    if (m_hTheme)
    {
        CloseThemeData(m_hTheme);
    }

    DllRelease();
}


HRESULT CSkinSize_CreateInstance(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszSizeName, IN LPCWSTR pszDisplayName, OUT IThemeSize ** ppThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeSize)
    {
        CSkinSize * pObject = new CSkinSize(pszFilename, pszStyleName, pszSizeName, pszDisplayName);

        *ppThemeSize = NULL;
        hr = E_OUTOFMEMORY;
        if (pObject)
        {
            if (pObject->m_pszFilename && pObject->m_pszStyleName &&pObject->m_pszSizeName && pObject->m_pszDisplayName)
            {
                hr = pObject->QueryInterface(IID_PPV_ARG(IThemeSize, ppThemeSize));
            }

            pObject->Release();
        }
    }

    return hr;
}


HRESULT CSkinSize_CreateInstance(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszSizeName, OUT IThemeSize ** ppThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeSize)
    {
        *ppThemeSize = NULL;
        hr = E_FAIL;
        
        int nIndex;
        // Find the display name
        for (nIndex = 0; ; nIndex++)
        {
            THEMENAMEINFO themeInfo;

            if (SUCCEEDED(EnumThemeSizes(pszFilename, pszStyleName, nIndex, &themeInfo)))
            {
                // Did we find the correct color style?
                if (!StrCmpIW(pszSizeName, themeInfo.szName))
                {
                    // Yes, now use it's display name to use the other creator function.
                    hr = CSkinSize_CreateInstance(pszFilename, pszStyleName, pszSizeName, themeInfo.szDisplayName, ppThemeSize);
                    break;
                }

            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\thsize.h ===
/*****************************************************************************\
    FILE: thSize.h

    DESCRIPTION:
        This is the Autmation Object to theme size object.  This one will be
    for the Skin objects.

    BryanSt 5/13/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _FILE_H_THSIZE
#define _FILE_H_THSIZE

#include <cowsite.h>
#include <atlbase.h>



HRESULT CSkinSize_CreateInstance(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszSizeName, IN LPCWSTR pszDisplayName, OUT IThemeSize ** ppThemeSize);
HRESULT CSkinSize_CreateInstance(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszSizeName, OUT IThemeSize ** ppThemeSize);


class CSkinSize                 : public CImpIDispatch
                                , public IThemeSize
                                , public IPropertyBag
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IThemeSize ***
    virtual STDMETHODIMP get_DisplayName(OUT BSTR * pbstrDisplayName);
    virtual STDMETHODIMP put_DisplayName(IN BSTR bstrDisplayName);
    virtual STDMETHODIMP get_Name(OUT BSTR * pbstrName);
    virtual STDMETHODIMP put_Name(IN BSTR bstrName);
    virtual STDMETHODIMP get_SystemMetricColor(IN int nSysColorIndex, OUT COLORREF * pColorRef);
    virtual STDMETHODIMP put_SystemMetricColor(IN int nSysColorIndex, IN COLORREF ColorRef) {return E_NOTIMPL;}
    virtual STDMETHODIMP get_SystemMetricSize(IN enumSystemMetricSize nSystemMetricIndex, OUT int * pnSize);
    virtual STDMETHODIMP put_SystemMetricSize(IN enumSystemMetricSize nSystemMetricIndex, IN int nSize) {return E_NOTIMPL;}
    virtual STDMETHODIMP get_WebviewCSS(OUT BSTR * pbstrPath);
    virtual STDMETHODIMP get_ContrastLevel(OUT enumThemeContrastLevels * pContrastLevel) {if (pContrastLevel) {*pContrastLevel = CONTRAST_NORMAL;} return S_OK;}
    virtual STDMETHODIMP put_ContrastLevel(IN enumThemeContrastLevels ContrastLevel) {return E_NOTIMPL;}
    virtual STDMETHODIMP GetSystemMetricFont(IN enumSystemMetricFont nSPIFontIndex, IN LOGFONTW * pParamW);
    virtual STDMETHODIMP PutSystemMetricFont(IN enumSystemMetricFont nSPIFontIndex, IN LOGFONTW * pParamW) {return E_NOTIMPL;}

    // *** IPropertyBag ***
    virtual STDMETHODIMP Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog);
    virtual STDMETHODIMP Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar) {return E_NOTIMPL;}

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

private:
    CSkinSize(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszSizeName, IN LPCWSTR pszDisplayName);
    virtual ~CSkinSize(void);


    // Private Member Variables
    long                    m_cRef;

    LPWSTR                  m_pszFilename;          // This is the full path to the ".thx" file
    LPWSTR                  m_pszStyleName;         // This is the canonical name of the color style
    LPWSTR                  m_pszSizeName;          // This is the canonical name of the size
    LPWSTR                  m_pszDisplayName;       // This is the display name of the size
    HTHEME                  m_hTheme;               // This is the Theme we represent.

    BOOL                    m_fFontsLoaded;         // Have we loaded the fonts yet?
    SYSTEMMETRICSALL        m_sysMetrics;           // The loaded fonts

    // Private Methods
    HRESULT _InitVisualStyle(void);

    // Friend Functions
    friend HRESULT CSkinSize_CreateInstance(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszSizeName, IN LPCWSTR pszDisplayName, OUT IThemeSize ** ppThemeSize);
    friend HRESULT CSkinSize_CreateInstance(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszSizeName, OUT IThemeSize ** ppThemeSize);
};


#endif // _FILE_H_THSIZE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxbud\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	UxBud.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\thstyle.cpp ===
/*****************************************************************************\
    FILE: thStyle.cpp

    DESCRIPTION:
        This is the Autmation Object to theme style object.  This one will be
    for the Skin objects.

    BryanSt 5/13/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <cowsite.h>
#include <atlbase.h>
#include "util.h"
#include "theme.h"
#include "thsize.h"
#include "thstyle.h"




//===========================
// *** Class Internals & Helpers ***
//===========================



//===========================
// *** ITheme Interface ***
//===========================
HRESULT CSkinStyle::get_DisplayName(OUT BSTR * pbstrDisplayName)
{
    return HrSysAllocString(m_pszDisplayName, pbstrDisplayName);
}


HRESULT CSkinStyle::put_DisplayName(IN BSTR bstrDisplayName)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrDisplayName)
    {
        Str_SetPtr(&m_pszDisplayName, bstrDisplayName);
        hr = (m_pszDisplayName ? S_OK : E_OUTOFMEMORY);
    }

    return hr;
}


HRESULT CSkinStyle::get_Name(OUT BSTR * pbstrName)
{
    return HrSysAllocString(m_pszStyleName, pbstrName);
}


HRESULT CSkinStyle::put_Name(IN BSTR bstrName)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrName)
    {
        Str_SetPtr(&m_pszStyleName, bstrName);
        hr = (m_pszStyleName ? S_OK : E_OUTOFMEMORY);
    }

    return hr;
}


HRESULT CSkinStyle::get_length(OUT long * pnLength)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pnLength)
    {
        hr = S_OK;
        if (COLLECTION_SIZE_UNINITIALIZED == m_nSize)
        {
            THEMENAMEINFO themeInfo;
            m_nSize = 0;

            while (SUCCEEDED(EnumThemeSizes(m_pszFilename, m_pszStyleName, m_nSize, &themeInfo)))
            {
                m_nSize++;
            }
        }

        *pnLength = m_nSize;
    }

    return hr;
}


HRESULT CSkinStyle::get_item(IN VARIANT varIndex, OUT IThemeSize ** ppThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeSize)
    {
        long nCount = 0;

        get_length(&nCount);
        *ppThemeSize = NULL;

        // This is sortof gross, but if we are passed a pointer to another variant, simply
        // update our copy here...
        if (varIndex.vt == (VT_BYREF | VT_VARIANT) && varIndex.pvarVal)
            varIndex = *(varIndex.pvarVal);

        switch (varIndex.vt)
        {
        case VT_I2:
            varIndex.lVal = (long)varIndex.iVal;
            // And fall through...

        case VT_I4:
        if ((varIndex.lVal >= 0) && (varIndex.lVal < nCount))
        {
            THEMENAMEINFO themeInfo;

            hr = EnumThemeSizes(m_pszFilename, m_pszStyleName, varIndex.lVal, &themeInfo);
            LogStatus("EnumThemeSizes(path=\"%ls\", style=\"%ls\") returned %#08lx in CSkinStyle::get_item.\r\n", m_pszFilename, m_pszStyleName, hr);
            if (SUCCEEDED(hr))
            {
                hr = CSkinSize_CreateInstance(m_pszFilename, m_pszStyleName, themeInfo.szName, themeInfo.szDisplayName, ppThemeSize);
            }
        }
        break;
        case VT_BSTR:
        if (varIndex.bstrVal)
        {
            if (varIndex.bstrVal[0])
            {
                THEMENAMEINFO themeInfo;

                for (long nIndex = 0; FAILED(hr) && (nIndex < nCount) && SUCCEEDED(EnumThemeSizes(m_pszFilename, m_pszStyleName, nIndex, &themeInfo));
                            nIndex++)
                {
                    if (!StrCmpIW(themeInfo.szDisplayName, varIndex.bstrVal) ||
                        !StrCmpIW(themeInfo.szName, varIndex.bstrVal))
                    {
                        hr = CSkinSize_CreateInstance(m_pszFilename, m_pszStyleName, themeInfo.szName, themeInfo.szDisplayName, ppThemeSize);
                    }
                }
            }
            else
            {
                if (m_pszFilename && m_pszStyleName)
                {
                    TCHAR szColor[MAX_PATH];
                    TCHAR szSize[MAX_PATH];

                    hr = GetThemeDefaults(m_pszFilename, szColor, ARRAYSIZE(szColor), szSize, ARRAYSIZE(szSize));
                    LogStatus("GetThemeDefaults(szCurrentStyle=\"%ls\", szColor=\"%ls\", szSize=\"%ls\") returned %#08lx in CSkinStyle::get_item.\r\n", m_pszFilename, szColor, szSize, hr);
                    if (SUCCEEDED(hr) && !StrCmpI(m_pszStyleName, szColor))
                    {
                        hr = CSkinSize_CreateInstance(m_pszFilename, m_pszStyleName, szSize, ppThemeSize);
                    }
                }
            }
        }
        break;

        default:
            hr = E_NOTIMPL;
        }
    }

    return hr;
}


HRESULT CSkinStyle::get_SelectedSize(OUT IThemeSize ** ppThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeSize)
    {
        WCHAR szCurrentPath[MAX_PATH];
        WCHAR szCurrentStyle[MAX_PATH];
        WCHAR szCurrentSize[MAX_PATH];

        szCurrentPath[0] = 0;
        szCurrentPath[0] = 0;
        szCurrentPath[0] = 0;

        *ppThemeSize = NULL;
        if (!m_pSelectedSize)
        {
            hr = GetCurrentThemeName(szCurrentPath, ARRAYSIZE(szCurrentPath), szCurrentStyle, ARRAYSIZE(szCurrentStyle), szCurrentSize, ARRAYSIZE(szCurrentSize));
            LogStatus("GetCurrentThemeName(path=\"%ls\", color=\"%ls\", size=\"%ls\") returned %#08lx.\r\n", szCurrentPath, szCurrentStyle, szCurrentSize, hr);
            if (SUCCEEDED(hr))
            {
                // Is this the currently selected skin and style?
                if (!StrCmpIW(m_pszFilename, szCurrentPath) &&
                    !StrCmpIW(m_pszStyleName, szCurrentStyle))
                {
                    // Yes, so get the size from that API.
                    hr = CSkinSize_CreateInstance(szCurrentPath, szCurrentStyle, szCurrentSize, &m_pSelectedSize);
                }
                else
                {
                    hr = E_FAIL;
                }
            }

            if (FAILED(hr))
            {
                // No, so find the default color style for this skin(scheme).
                hr = GetThemeDefaults(m_pszFilename, szCurrentStyle, ARRAYSIZE(szCurrentStyle), szCurrentSize, ARRAYSIZE(szCurrentSize));
                LogStatus("GetThemeDefaults(m_pszFilename=\"%ls\", szCurrentStyle=\"%ls\", szCurrentSize=\"%ls\") returned %#08lx in CSkinStyle::get_SelectedSize.\r\n", m_pszFilename, szCurrentStyle, szCurrentSize, hr);
                if (SUCCEEDED(hr))
                {
                    hr = CSkinSize_CreateInstance(m_pszFilename, szCurrentStyle, szCurrentSize, &m_pSelectedSize);
                }
            }
        }

        if (m_pSelectedSize)
        {
            IUnknown_Set((IUnknown **)ppThemeSize, m_pSelectedSize);
            if (*ppThemeSize)
            {
                hr = S_OK;
            }
        }
    }

    return hr;
}


HRESULT CSkinStyle::put_SelectedSize(IN IThemeSize * pThemeSize)
{
    IUnknown_Set((IUnknown **)&m_pSelectedSize, pThemeSize);
    return S_OK;
}


HRESULT CSkinStyle::AddSize(OUT IThemeSize ** ppThemeSize)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeSize)
    {
        *ppThemeSize = NULL;
        hr = E_NOTIMPL;
    }

    return hr;
}





//===========================
// *** IUnknown Interface ***
//===========================
ULONG CSkinStyle::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CSkinStyle::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


//===========================
// *** Class Methods ***
//===========================
HRESULT CSkinStyle::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CSkinStyle, IThemeStyle),
        QITABENT(CSkinStyle, IDispatch),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


CSkinStyle::CSkinStyle(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszDisplayName) : CImpIDispatch(LIBID_Theme, 1, 0, IID_IThemeStyle), m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pSelectedSize);

    Str_SetPtr(&m_pszFilename, pszFilename);
    Str_SetPtr(&m_pszDisplayName, pszDisplayName);
    Str_SetPtr(&m_pszStyleName, pszStyleName);

    m_nSize = COLLECTION_SIZE_UNINITIALIZED;
}


CSkinStyle::~CSkinStyle()
{
    ATOMICRELEASE(m_pSelectedSize);

    Str_SetPtr(&m_pszFilename, NULL);
    Str_SetPtr(&m_pszDisplayName, NULL);
    Str_SetPtr(&m_pszStyleName, NULL);

    DllRelease();
}



HRESULT CSkinStyle_CreateInstance(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszDisplayName, OUT IThemeStyle ** ppThemeStyle)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeStyle)
    {
        CSkinStyle * pObject = new CSkinStyle(pszFilename, pszStyleName, pszDisplayName);

        *ppThemeStyle = NULL;
        hr = E_OUTOFMEMORY;
        if (pObject)
        {
            if (pObject->m_pszFilename && pObject->m_pszStyleName && pObject->m_pszDisplayName)
            {
                hr = pObject->QueryInterface(IID_PPV_ARG(IThemeStyle, ppThemeStyle));
            }

            pObject->Release();
        }
    }

    return hr;
}


HRESULT CSkinStyle_CreateInstance(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, OUT IThemeStyle ** ppThemeStyle)
{
    HRESULT hr = E_INVALIDARG;

    if (ppThemeStyle)
    {
        *ppThemeStyle = NULL;
        hr = S_OK;

        // Find the display name
        for (int nIndex = 0; SUCCEEDED(hr); nIndex++)
        {
            THEMENAMEINFO themeInfo;

            hr = EnumThemeColors(pszFilename, NULL, nIndex, &themeInfo);
            LogStatus("EnumThemeColors(pszFilename=\"%ls\") returned %#08lx in CSkinStyle_CreateInstance.\r\n", pszFilename, hr);
            if (SUCCEEDED(hr))
            {
                // Did we find the correct color style?
                if (!StrCmpIW(pszStyleName, themeInfo.szName))
                {
                    // Yes, now use it's display name to use the other creator function.
                    hr = CSkinStyle_CreateInstance(pszFilename, pszStyleName, themeInfo.szDisplayName, ppThemeStyle);
                    break;
                }

            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\util.h ===
/*****************************************************************************\
    FILE: util.h

    DESCRIPTION:
        Shared stuff that operates on all classes.

    BryanSt 8/13/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#ifndef _UTIL_H
#define _UTIL_H

#include "regutil.h"

#define HINST_THISDLL       g_hinst

extern BOOL g_fInSetup;

enum enumTSPerfFlag
{
    TSPerFlag_NoADWallpaper = 0,
    TSPerFlag_NoWallpaper,
    TSPerFlag_NoVisualStyles,
    TSPerFlag_NoWindowDrag,
    TSPerFlag_NoAnimation,
};

// String Helpers
HRESULT HrSysAllocStringA(IN LPCSTR pszSource, OUT BSTR * pbstrDest);
HRESULT HrSysAllocStringW(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest);
HRESULT BSTRFromStream(IStream * pStream, BSTR * pbstrXML);
LPSTR AllocStringFromBStr(BSTR bstr);
HRESULT CreateBStrVariantFromWStr(IN OUT VARIANT * pvar, IN LPCWSTR pwszString);
HRESULT HrSysAllocString(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest);
HRESULT BOOLToString(BOOL fBoolean, BSTR * pbstrValue);
HRESULT HrCopyStream(LPSTREAM pstmIn, LPSTREAM pstmOut, ULONG *pcb);
void PathUnExpandEnvStringsWrap(LPTSTR pszString, DWORD cchSize);
void PathExpandEnvStringsWrap(LPTSTR pszString, DWORD cchSize);

#ifdef UNICODE
#define SysAllocStringT(pszString)    SysAllocString(pszString)
#else
extern BSTR SysAllocStringA(LPCSTR pszString);
#define SysAllocStringT(pszString)    SysAllocStringA(pszString)
#endif

HRESULT GetQueryStringValue(BSTR bstrURL, LPCWSTR pwszValue, LPWSTR pwszData, int cchSizeData);
HRESULT UnEscapeHTML(BSTR bstrEscaped, BSTR * pbstrUnEscaped);
HRESULT StrReplaceToken(IN LPCTSTR pszToken, IN LPCTSTR pszReplaceValue, IN LPTSTR pszString, IN DWORD cchSize);
HRESULT HrWritePrivateProfileStringW(LPCWSTR pszAppName, LPCWSTR pszKeyName, LPCWSTR pszString, LPCWSTR pszFileName);


// XML Related Helpers
HRESULT XMLDOMFromBStr(BSTR bstrXML, IXMLDOMDocument ** ppXMLDoc);
HRESULT XMLBStrFromDOM(IXMLDOMDocument * pXMLDoc, BSTR * pbstrXML);
HRESULT XMLAppendElement(IXMLDOMElement * pXMLElementRoot, IXMLDOMElement * pXMLElementToAppend);
HRESULT XMLDOMFromFile(IN LPCWSTR pwzPath, OUT IXMLDOMDocument ** ppXMLDOMDoc);
HRESULT XMLElem_VerifyTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName);
HRESULT XMLElem_GetElementsByTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName, OUT IXMLDOMNodeList ** ppNodeList);
HRESULT XMLNodeList_GetChild(IXMLDOMNodeList * pNodeList, DWORD dwIndex, IXMLDOMNode ** ppXMLChildNode);
HRESULT XMLNode_GetChildTag(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszTagName, OUT IXMLDOMNode ** ppChildNode);
HRESULT XMLNode_GetTagText(IN IXMLDOMNode * pXMLNode, OUT BSTR * pbstrValue);
HRESULT XMLNode_GetAttributeValue(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszAttributeName, OUT BSTR * pbstrValue);
HRESULT XMLNode_GetChildTagTextValue(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, OUT BSTR * pbstrValue);
HRESULT XMLNode_GetChildTagTextValueToBool(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, OUT BOOL * pfBoolean);
BOOL XML_IsChildTagTextEqual(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, IN BSTR bstrText);






// File System Helpers
HRESULT CreateFileHrWrap(LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
                       DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE * phFileHandle);
HRESULT WriteFileWrap(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
HRESULT DeleteFileHrWrap(LPCWSTR pszPath);
HRESULT HrSHFileOpDeleteFile(HWND hwnd, FILEOP_FLAGS dwFlags, LPTSTR pszPath);



// Registry Helpers
HRESULT HrRegOpenKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
HRESULT HrRegCreateKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD Reserved, LPTSTR lpClass, DWORD dwOptions, 
       REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
HRESULT HrRegQueryValueEx(HKEY hKey, LPCTSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
HRESULT HrRegSetValueEx(IN HKEY hKey, IN LPCTSTR lpValueName, IN DWORD dwReserved, IN DWORD dwType, IN CONST BYTE *lpData, IN DWORD cbData);
HRESULT HrRegEnumKey(HKEY hKey, DWORD dwIndex, LPTSTR lpName, DWORD cbName);
HRESULT HrRegEnumValue(HKEY hKey, DWORD dwIndex, LPTSTR lpValueName, LPDWORD lpcValueName, LPDWORD lpReserved,
        LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
HRESULT HrRegQueryInfoKey(HKEY hKey, LPTSTR lpClass, LPDWORD lpcClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcMaxSubKeyLen, 
            LPDWORD lpcMaxClassLen, LPDWORD lpcValues, LPDWORD lpcMaxValueNameLen, LPDWORD lpcMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime);

HRESULT HrBStrRegQueryValue(IN HKEY hKey, IN LPCTSTR lpValueName, OUT BSTR * pbstr);
HRESULT HrSHGetValue(IN HKEY hKey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, OPTIONAL OUT LPDWORD pdwType, OPTIONAL OUT LPVOID pvData, OPTIONAL OUT LPDWORD pcbData);
HRESULT HrSHSetValue(IN HKEY hkey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, DWORD dwType, OPTIONAL OUT LPVOID pvData, IN DWORD cbData);
DWORD HrRegGetDWORD(HKEY hKey, LPCWSTR szKey, LPCWSTR szValue, DWORD dwDefault);
HRESULT HrRegSetDWORD(HKEY hKey, LPCWSTR szKey, LPCWSTR szValue, DWORD dwData);
HRESULT HrRegDeleteValue(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName);

HRESULT HrRegSetValueString(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszValueName, LPCWSTR pszString);
HRESULT HrRegGetValueString(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszValueName, LPWSTR pszString, DWORD cchSize);
HRESULT HrRegSetPath(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName, BOOL fUseExpandSZ, LPCWSTR pszPath);
HRESULT HrRegGetPath(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName, IN LPWSTR pszPath, IN DWORD cchSize);


// Palette Helpers
COLORREF GetNearestPaletteColor(HPALETTE hpal, COLORREF rgb);
BOOL IsPaletteColor(HPALETTE hpal, COLORREF rgb);


// Theme Specific Helpers
HRESULT SHGetResourcePath(BOOL fLocaleNode, IN LPWSTR pszPath, IN DWORD cchSize);
HRESULT ExpandResourceDir(IN LPWSTR pszPath, IN DWORD cchSize);
HRESULT GetCurrentUserCustomName(LPWSTR pszDisplayName, DWORD cchSize);
HRESULT InstallVisualStyle(IThemeManager * pThemeManager, LPCTSTR pszVisualStylePath, LPCTSTR pszVisualStyleColor, LPCTSTR pszVisualStyleSize);
HRESULT ApplyVisualStyle(LPCTSTR pszVisualStylePath, LPCTSTR pszVisualStyleColor, LPCTSTR pszVisualStyleSize);


// IProperty Bag Helpers
STDAPI SHPropertyBag_WritePunk(IN IPropertyBag * ppb, IN LPCWSTR pwzPropName, IN IUnknown * punk);
STDAPI SHPropertyBag_ReadByRef(IN IPropertyBag * ppb, IN LPCWSTR pwzPropName, IN void * p, IN SIZE_T cbSize);
STDAPI SHPropertyBag_WriteByRef(IN IPropertyBag * ppb, IN LPCWSTR pwzPropName, IN void * p);
HRESULT GetPageByCLSID(IUnknown * punkSite, const GUID * pClsid, IPropertyBag ** ppPropertyBag);
HRESULT IEnumUnknown_FindCLSID(IN IUnknown * punk, IN CLSID clsid, OUT IUnknown ** ppunkFound);


// UXTheme wrappers
DWORD QueryThemeServicesWrap(void);


// DPI APIs
void DPIScaleRect(RECT * pRect);
HBITMAP LoadBitmapAndDPIScale(HINSTANCE hInst, LPCTSTR pszBitmapName);


// Other Helpers
HRESULT GetPrivateProfileStringHrWrap(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
BOOL _InitComCtl32();
HRESULT HrRewindStream(IStream * pstm);
HRESULT HrShellExecute(HWND hwnd, LPCTSTR lpVerb, LPCTSTR lpFile, LPCTSTR lpParameters, LPCTSTR lpDirectory, INT nShowCmd);
COLORREF ConvertColor(LPTSTR pszColor);
BOOL IUnknown_CompareCLSID(IN IUnknown * punk, IN CLSID clsid);
UINT ErrorMessageBox(HWND hwndOwner, LPCTSTR pszTitle, UINT idTemplate, HRESULT hr, LPCTSTR pszParam, UINT dwFlags);
HRESULT DisplayThemeErrorDialog(HWND hwndParent, HRESULT hrError, UINT nTitle, UINT nTemplate);
BOOL EnumDisplaySettingsExWrap(LPCTSTR lpszDeviceName, DWORD iModeNum, LPDEVMODE lpDevMode, DWORD dwFlags);

BOOL IsOSNT(void);
DWORD GetOSVer(void);
void LogStatus(LPCSTR pszMessage, ...);
void LogSystemMetrics(LPCSTR pszMessage, SYSTEMMETRICSALL * pSystemMetrics);

int WritePrivateProfileInt(LPCTSTR szApp, LPCTSTR szKey, int nDefault, LPCTSTR pszFileName);
void PostMessageBroadAsync(IN UINT Msg, IN WPARAM wParam, IN LPARAM lParam);
void SystemParametersInfoAsync(IN UINT uiAction, IN UINT uiParam, IN void * pvParam, IN DWORD cbSize, IN UINT fWinIni, IN CDimmedWindow* pDimmedWindow);
void DebugStartWatch(void);
DWORD DebugStopWatch(void);
BOOL IsTSPerfFlagEnabled(enumTSPerfFlag eTSFlag);


void SPISetThreadCounter(LONG *pcThreads);
BOOL SPICreateThread(LPTHREAD_START_ROUTINE pfnThreadProc, void *pvData);

typedef struct tagPROGRESSINFO
{
    IProgressDialog * ppd;
    ULARGE_INTEGER uliBytesCompleted;
    ULARGE_INTEGER uliBytesTotal;
} PROGRESSINFO, * LPPROGRESSINFO;


HRESULT HrByteToStream(LPSTREAM *lppstm, LPBYTE lpb, ULONG cb);
void    GetDateString(char * szSentDateString, ULONG stringLen);




#endif // _UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxbud\stdafx.h ===
//---------------------------------------------------------------------------
// stdafx.h : include file for standard system include files
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <atlbase.h>

#include <uxthemep.h>
#include <tmschema.h>
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\thstyle.h ===
/*****************************************************************************\
    FILE: thStyle.h

    DESCRIPTION:
        This is the Autmation Object to theme style object.  This one will be
    for the Skin objects.

    BryanSt 5/13/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _FILE_H_THSTYLE
#define _FILE_H_THSTYLE

#include <cowsite.h>
#include <atlbase.h>



HRESULT CSkinStyle_CreateInstance(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszDisplayName, OUT IThemeStyle ** ppThemeStyle);
HRESULT CSkinStyle_CreateInstance(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, OUT IThemeStyle ** ppThemeStyle);


class CSkinStyle                : public CImpIDispatch
                                , public IThemeStyle
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IThemeStyle ***
    virtual STDMETHODIMP get_DisplayName(OUT BSTR * pbstrDisplayName);
    virtual STDMETHODIMP put_DisplayName(IN BSTR bstrDisplayName);
    virtual STDMETHODIMP get_Name(OUT BSTR * pbstrName);
    virtual STDMETHODIMP put_Name(IN BSTR bstrName);
    virtual STDMETHODIMP get_length(OUT long * pnLength);
    virtual STDMETHODIMP get_item(IN VARIANT varIndex, OUT IThemeSize ** ppThemeSize);
    virtual STDMETHODIMP get_SelectedSize(OUT IThemeSize ** ppThemeSize);
    virtual STDMETHODIMP put_SelectedSize(IN IThemeSize * pThemeSize);
    virtual STDMETHODIMP AddSize(OUT IThemeSize ** ppThemeSize);

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

private:
    CSkinStyle(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszDisplayName);
    virtual ~CSkinStyle(void);


    // Private Member Variables
    long                    m_cRef;

    LPWSTR                  m_pszFilename;          // This is the full path to the ".thx" file
    LPWSTR                  m_pszDisplayName;       // This is the display name of the color style
    LPWSTR                  m_pszStyleName;         // This is the canonical name of the color style
    long                    m_nSize;                // The size of the collection of Sizes.
    IThemeSize *            m_pSelectedSize;        // The selected size.


    // Private Member Functions

    // Friend Functions
    friend HRESULT CSkinStyle_CreateInstance(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, IN LPCWSTR pszDisplayName, OUT IThemeStyle ** ppThemeStyle);
    friend HRESULT CSkinStyle_CreateInstance(IN LPCWSTR pszFilename, IN LPCWSTR pszStyleName, OUT IThemeStyle ** ppThemeStyle);
};


#endif // _FILE_H_THSTYLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\util.cpp ===
/*****************************************************************************\
    FILE: util.cpp

    DESCRIPTION:
        Shared stuff that operates on all classes.

    BryanSt 4/4/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <atlbase.h>        // USES_CONVERSION
#include <comdef.h>
#include <errors.h>         // \\themes\\inc
#include <ctxdef.h> // hydra stuff
#include <regapi.h> // WINSTATION_REG_NAME
#include "WMPAPITemp.h"

#define SECURITY_WIN32
#include <sspi.h>
extern "C" {
    #include <Secext.h>     // for GetUserNameEx()
}


#define DECL_CRTFREE
#include <crtfree.h>

#include "util.h"

/////////////////////////////////////////////////////////////////////
// String Helpers
/////////////////////////////////////////////////////////////////////

HINSTANCE g_hinst;              // My instance handle
HANDLE g_hLogFile = INVALID_HANDLE_VALUE;


#ifdef DEBUG
DWORD g_TLSliStopWatchStartHi = 0xFFFFFFFF;
DWORD g_TLSliStopWatchStartLo = 0xFFFFFFFF;
LARGE_INTEGER g_liStopWatchFreq = {0};
#endif // DEBUG

/////////////////////////////////////////////////////////////////////
// Debug Timing Helpers
/////////////////////////////////////////////////////////////////////

#ifdef DEBUG
void DebugStartWatch(void)
{
    LARGE_INTEGER liStopWatchStart;

    if (-1 == g_TLSliStopWatchStartHi)
    {
        g_TLSliStopWatchStartHi = TlsAlloc();
        g_TLSliStopWatchStartLo = TlsAlloc();
        liStopWatchStart.QuadPart = 0;

        QueryPerformanceFrequency(&g_liStopWatchFreq);      // Only a one time call since it's value can't change while the system is running.
    }
    else
    {
        liStopWatchStart.HighPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartHi));
        liStopWatchStart.LowPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartLo));
    }

    AssertMsg((0 == liStopWatchStart.QuadPart), TEXT("Someone else is using our perf timer.  Stop nesting.")); // If you hit this, then the stopwatch is nested.
    QueryPerformanceCounter(&liStopWatchStart);

    TlsSetValue(g_TLSliStopWatchStartHi, IntToPtr(liStopWatchStart.HighPart));
    TlsSetValue(g_TLSliStopWatchStartLo, IntToPtr(liStopWatchStart.LowPart));
}

DWORD DebugStopWatch(void)
{
    LARGE_INTEGER liDiff;
    LARGE_INTEGER liStopWatchStart;
    
    QueryPerformanceCounter(&liDiff);
    liStopWatchStart.HighPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartHi));
    liStopWatchStart.LowPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartLo));
    liDiff.QuadPart -= liStopWatchStart.QuadPart;

    ASSERT(0 != g_liStopWatchFreq.QuadPart);    // I don't like to fault with div 0.
    DWORD dwTime = (DWORD)((liDiff.QuadPart * 1000) / g_liStopWatchFreq.QuadPart);

    TlsSetValue(g_TLSliStopWatchStartHi, (LPVOID) 0);
    TlsSetValue(g_TLSliStopWatchStartLo, (LPVOID) 0);

    return dwTime;
}
#endif // DEBUG






/////////////////////////////////////////////////////////////////////
// String Helpers
/////////////////////////////////////////////////////////////////////
#undef SysAllocStringA
BSTR SysAllocStringA(LPCSTR pszStr)
{
    BSTR bstrOut = NULL;

    if (pszStr)
    {
        DWORD cchSize = (lstrlenA(pszStr) + 1);
        LPWSTR pwszThunkTemp = (LPWSTR) LocalAlloc(LPTR, (sizeof(pwszThunkTemp[0]) * cchSize));  // assumes INFOTIPSIZE number of chars max

        if (pwszThunkTemp)
        {
            SHAnsiToUnicode(pszStr, pwszThunkTemp, cchSize);
            bstrOut = SysAllocString(pwszThunkTemp);
            LocalFree(pwszThunkTemp);
        }
    }

    return bstrOut;
}


HRESULT HrSysAllocStringA(IN LPCSTR pszSource, OUT BSTR * pbstrDest)
{
    HRESULT hr = S_OK;

    if (pbstrDest)
    {
        *pbstrDest = SysAllocStringA(pszSource);
        if (pszSource)
        {
            if (*pbstrDest)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT HrSysAllocStringW(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest)
{
    HRESULT hr = S_OK;

    if (pbstrDest)
    {
        *pbstrDest = SysAllocString(pwzSource);
        if (pwzSource)
        {
            if (*pbstrDest)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


LPSTR AllocStringFromBStr(BSTR bstr)
{
    USES_CONVERSION;        // atlbase.h

    char *a = W2A((bstr ? bstr : L""));
    int len = 1 + lstrlenA(a);

    char *p = (char *)LocalAlloc(LPTR, len);
    if (p)
    {
        StrCpyA(p, a);
    }

    return p;
}


HRESULT BSTRFromStream(IStream * pStream, BSTR * pbstr)
{
    STATSTG statStg = {0};
    HRESULT hr = pStream->Stat(&statStg, STATFLAG_NONAME);

    if (S_OK == hr)
    {
        DWORD cchSize = statStg.cbSize.LowPart;
        *pbstr = SysAllocStringLen(NULL, cchSize + 4);

        if (*pbstr)
        {
            LPSTR pszTemp = (LPSTR) LocalAlloc(LPTR, sizeof(pszTemp[0]) * (cchSize + 4));

            if (pszTemp)
            {
                ULONG cbRead;

                hr = pStream->Read(pszTemp, cchSize, &cbRead);
                pszTemp[cchSize] = 0;
                SHAnsiToUnicode(pszTemp, *pbstr, (cchSize + 1));

                LocalFree(pszTemp);
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}

// --------------------------------------------------------------------------------
// HrCopyStream
// --------------------------------------------------------------------------------
HRESULT HrCopyStream(LPSTREAM pstmIn, LPSTREAM pstmOut, ULONG *pcb)
{
    HRESULT        hr = S_OK;
    BYTE           buf[4096];
    ULONG          cbRead=0,
                   cbTotal=0;

    do
    {
        hr = pstmIn->Read(buf, sizeof(buf), &cbRead);
        if (FAILED(hr) || cbRead == 0)
        {
            break;
        }
        hr = pstmOut->Write(buf, cbRead, NULL);
        if (FAILED(hr))
        {
            break;
        }
        cbTotal += cbRead;
    }
    while (cbRead == sizeof (buf));
 
    if (pcb && SUCCEEDED(hr))
        *pcb = cbTotal;

    return hr;
}


HRESULT CreateBStrVariantFromWStr(IN OUT VARIANT * pvar, IN LPCWSTR pwszString)
{
    HRESULT hr = E_INVALIDARG;

    if (pvar)
    {
        pvar->bstrVal = SysAllocString(pwszString);
        if (pvar->bstrVal)
        {
            pvar->vt = VT_BSTR;
            hr = S_OK;
        }
        else
        {
            pvar->vt = VT_EMPTY;
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT HrSysAllocString(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest)
{
    HRESULT hr = S_OK;

    if (pbstrDest)
    {
        *pbstrDest = SysAllocString(pwzSource);
        if (pwzSource)
        {
            if (*pbstrDest)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT UnEscapeHTML(BSTR bstrEscaped, BSTR * pbstrUnEscaped)
{
    HRESULT hr = HrSysAllocString(bstrEscaped, pbstrUnEscaped);

    if (SUCCEEDED(hr))
    {
        // Find %xx and replace.
        LPWSTR pwszEscapedSequence = StrChrW(*pbstrUnEscaped, CH_HTML_ESCAPE);
        WCHAR wzEscaped[5] = L"0xXX";

        while (pwszEscapedSequence && (3 <= lstrlenW(pwszEscapedSequence)))
        {
            int nCharCode;

            wzEscaped[2] = pwszEscapedSequence[1];
            wzEscaped[3] = pwszEscapedSequence[2];
            StrToIntExW(wzEscaped, STIF_SUPPORT_HEX, &nCharCode);

            // Replace the '%' with the real char.
            pwszEscapedSequence[0] = (WCHAR) nCharCode;

            pwszEscapedSequence = CharNextW(pwszEscapedSequence);   // Skip pasted the replaced char.

            // Over write the 0xXX value.
            StrCpyW(pwszEscapedSequence, &pwszEscapedSequence[2]);

            // Next...
            pwszEscapedSequence = StrChrW(pwszEscapedSequence, CH_HTML_ESCAPE);
        }
    }

    return hr;
}



/*****************************************************************************\
    PARAMETERS:
        If fBoolean is TRUE, return "True" else "False".
HRESULT BOOLToString(BOOL fBoolean, BSTR * pbstrValue)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrValue)
    {
        LPCWSTR pwszValue;

        *pbstrValue = NULL;
        if (TRUE == fBoolean)
        {
            pwszValue = SZ_QUERYDATA_TRUE;
        }
        else
        {
            pwszValue = SZ_QUERYDATA_FALSE;
        }

        hr = HrSysAllocString(pwszValue, pbstrValue);
    }

    return hr;
}
\*****************************************************************************/



#define SZ_VALID_XML      L"<?xml"

/////////////////////////////////////////////////////////////////////
// XML Related Helpers
/////////////////////////////////////////////////////////////////////
HRESULT XMLDOMFromBStr(BSTR bstrXML, IXMLDOMDocument ** ppXMLDoc)
{
    HRESULT hr = E_FAIL;
    
    // We don't even want to
    // bother passing it to the XML DOM because they throw exceptions.  These
    // are caught and handled but we still don't want this to happen.  We try
    // to get XML from the web server, but we get HTML instead if the web server
    // fails or the web proxy returns HTML if the site isn't found.
    if (!StrCmpNIW(SZ_VALID_XML, bstrXML, (ARRAYSIZE(SZ_VALID_XML) - 1)))
    {
        hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLDOMDocument, ppXMLDoc));

        if (SUCCEEDED(hr))
        {
            VARIANT_BOOL fIsSuccessful;

            // NOTE: This will throw an 0xE0000001 exception in MSXML if the XML is invalid.
            //    This is not good but there isn't much we can do about it.  The problem is
            //    that web proxies give back HTML which fails to parse.
            hr = (*ppXMLDoc)->loadXML(bstrXML, &fIsSuccessful);
            if (SUCCEEDED(hr))
            {
                if (VARIANT_TRUE != fIsSuccessful)
                {
                    hr = E_FAIL;
                }
            }
        }

        if (FAILED(hr))
        {
            (*ppXMLDoc)->Release();
            *ppXMLDoc = NULL;
        }
    }

    return hr;
}


HRESULT XMLBStrFromDOM(IXMLDOMDocument * pXMLDoc, BSTR * pbstrXML)
{
    IStream * pStream;
    HRESULT hr = pXMLDoc->QueryInterface(IID_PPV_ARG(IStream, &pStream)); // check the return value

    if (S_OK == hr)
    {
        hr = BSTRFromStream(pStream, pbstrXML);
        pStream->Release();
    }

    return hr;
}


HRESULT XMLAppendElement(IXMLDOMElement * pXMLElementRoot, IXMLDOMElement * pXMLElementToAppend)
{
    IXMLDOMNode * pXMLNodeRoot;
    HRESULT hr = pXMLElementRoot->QueryInterface(IID_PPV_ARG(IXMLDOMNode, &pXMLNodeRoot));

    if (EVAL(SUCCEEDED(hr)))
    {
        IXMLDOMNode * pXMLNodeToAppend;
        
        hr = pXMLElementToAppend->QueryInterface(IID_PPV_ARG(IXMLDOMNode, &pXMLNodeToAppend));
        if (EVAL(SUCCEEDED(hr)))
        {
            hr = pXMLNodeRoot->appendChild(pXMLNodeToAppend, NULL);
            pXMLNodeToAppend->Release();
        }

        pXMLNodeRoot->Release();
    }

    return hr;
}


HRESULT XMLDOMFromFile(IN LPCWSTR pwzPath, OUT IXMLDOMDocument ** ppXMLDOMDoc)
{
    HRESULT hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLDOMDocument, ppXMLDOMDoc));

    if (SUCCEEDED(hr))
    {
        VARIANT xmlSource;

        xmlSource.vt = VT_BSTR;
        xmlSource.bstrVal = SysAllocString(pwzPath);

        if (xmlSource.bstrVal)
        {
            VARIANT_BOOL fIsSuccessful = VARIANT_TRUE;

            hr = (*ppXMLDOMDoc)->load(xmlSource, &fIsSuccessful);
            if ((S_FALSE == hr) || (VARIANT_FALSE == fIsSuccessful))
            {
                // This happens when the file isn't a valid XML file.
                hr = E_FAIL;
            }

            VariantClear(&xmlSource);
        }

        if (FAILED(hr))
        {
            ATOMICRELEASE(*ppXMLDOMDoc);
        }
    }

    return hr;
}


HRESULT XMLElem_VerifyTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName)
{
    BSTR bstrTagName;
    HRESULT hr = pXMLElementMessage->get_tagName(&bstrTagName);

    if (S_FALSE == hr)
    {
        hr = E_FAIL;
    }
    else if (SUCCEEDED(hr))
    {
        if (!bstrTagName || !pwszTagName || StrCmpIW(bstrTagName, pwszTagName))
        {
            hr = E_FAIL;
        }

        SysFreeString(bstrTagName);
    }

    return hr;
}

HRESULT XMLElem_GetElementsByTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName, OUT IXMLDOMNodeList ** ppNodeList)
{
    BSTR bstrTagName = SysAllocString(pwszTagName);
    HRESULT hr = E_OUTOFMEMORY;

    *ppNodeList = NULL;
    if (bstrTagName)
    {
        hr = pXMLElementMessage->getElementsByTagName(bstrTagName, ppNodeList);
        if (S_FALSE == hr)
        {
            hr = E_FAIL;
        }

        SysFreeString(bstrTagName);
    }

    return hr;
}


HRESULT XMLNode_GetAttributeValue(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszAttributeName, OUT BSTR * pbstrValue)
{
    BSTR bstrAttributeName = SysAllocString(pwszAttributeName);
    HRESULT hr = E_OUTOFMEMORY;

    *pbstrValue = NULL;
    if (bstrAttributeName)
    {
        IXMLDOMNamedNodeMap * pNodeAttributes;

        hr = pXMLNode->get_attributes(&pNodeAttributes);
        if (S_FALSE == hr)  hr = E_FAIL;
        if (SUCCEEDED(hr))
        {
            IXMLDOMNode * pTypeAttribute;

            hr = pNodeAttributes->getNamedItem(bstrAttributeName, &pTypeAttribute);
            if (S_FALSE == hr)  hr = ResultFromWin32(ERROR_NOT_FOUND);
            if (SUCCEEDED(hr))
            {
                VARIANT varAtribValue = {0};

                hr = pTypeAttribute->get_nodeValue(&varAtribValue);
                if (S_FALSE == hr)  hr = E_FAIL;
                if (SUCCEEDED(hr) && (VT_BSTR == varAtribValue.vt))
                {
                    *pbstrValue = SysAllocString(varAtribValue.bstrVal);
                }

                VariantClear(&varAtribValue);
                pTypeAttribute->Release();
            }

            pNodeAttributes->Release();
        }

        SysFreeString(bstrAttributeName);
    }

    return hr;
}


HRESULT XMLNode_GetChildTag(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszTagName, OUT IXMLDOMNode ** ppChildNode)
{
    HRESULT hr = E_INVALIDARG;

    *ppChildNode = NULL;
    if (pXMLNode)
    {
        IXMLDOMElement * pXMLElement;

        hr = pXMLNode->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pXMLElement));
        if (SUCCEEDED(hr))
        {
            IXMLDOMNodeList * pNodeList;

            hr = XMLElem_GetElementsByTagName(pXMLElement, pwszTagName, &pNodeList);
            if (SUCCEEDED(hr))
            {
                hr = XMLNodeList_GetChild(pNodeList, 0, ppChildNode);
                pNodeList->Release();
            }

            pXMLElement->Release();
        }
    }

    return hr;
}


HRESULT XMLNode_GetTagText(IN IXMLDOMNode * pXMLNode, OUT BSTR * pbstrValue)
{
    DOMNodeType nodeType = NODE_TEXT;
    HRESULT hr = pXMLNode->get_nodeType(&nodeType);

    *pbstrValue = NULL;

    if (S_FALSE == hr)  hr = E_FAIL;
    if (SUCCEEDED(hr))
    {
        if (NODE_TEXT == nodeType)
        {
            VARIANT varAtribValue = {0};

            hr = pXMLNode->get_nodeValue(&varAtribValue);
            if (S_FALSE == hr)  hr = E_FAIL;
            if (SUCCEEDED(hr) && (VT_BSTR == varAtribValue.vt))
            {
                *pbstrValue = SysAllocString(varAtribValue.bstrVal);
            }

            VariantClear(&varAtribValue);
        }
        else
        {
            hr = pXMLNode->get_text(pbstrValue);
        }
    }

    return hr;
}


HRESULT XMLNodeList_GetChild(IN IXMLDOMNodeList * pNodeList, IN DWORD dwIndex, OUT IXMLDOMNode ** ppXMLChildNode)
{
    HRESULT hr = pNodeList->get_item(dwIndex, ppXMLChildNode);

    if (S_FALSE == hr)
    {
        hr = ResultFromWin32(ERROR_NOT_FOUND);
    }

    return hr;
}


HRESULT XMLNode_GetChildTagTextValue(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, OUT BSTR * pbstrValue)
{
    IXMLDOMNode * pNodeType;
    HRESULT hr = XMLNode_GetChildTag(pXMLNode, bstrChildTag, &pNodeType);

    if (SUCCEEDED(hr))
    {
        hr = XMLNode_GetTagText(pNodeType, pbstrValue);
        pNodeType->Release();
    }

    return hr;
}


HRESULT XMLNode_GetChildTagTextValueToBool(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, OUT BOOL * pfBoolean)
{
    BSTR bstr;
    HRESULT hr = XMLNode_GetChildTagTextValue(pXMLNode, bstrChildTag, &bstr);

    if (SUCCEEDED(hr))
    {
        if (!StrCmpIW(bstr, L"on"))
        {
            *pfBoolean = TRUE;
        }
        else
        {
            *pfBoolean = FALSE;
        }

        SysFreeString(bstr);
    }

    return hr;
}


BOOL XML_IsChildTagTextEqual(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, IN BSTR bstrText)
{
    BOOL fIsChildTagTextEqual = FALSE;
    BSTR bstrChildText;
    HRESULT hr = XMLNode_GetChildTagTextValue(pXMLNode, bstrChildTag, &bstrChildText);

    if (SUCCEEDED(hr))
    {
        // Is this <TYPE>email</TYPE>?
        if (!StrCmpIW(bstrChildText, bstrText))
        {
            // No, so keep looking.
            fIsChildTagTextEqual = TRUE;
        }

        SysFreeString(bstrChildText);
    }

    return fIsChildTagTextEqual;
}





/////////////////////////////////////////////////////////////////////
// File System Wrapping Helpers
/////////////////////////////////////////////////////////////////////
HRESULT CreateFileHrWrap(LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
                       DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE * phFileHandle)
{
    HRESULT hr = S_OK;
    HANDLE hTemp = NULL;
    DWORD dwError = 0;

    if (!phFileHandle)
        phFileHandle = &hTemp;

    *phFileHandle = CreateFile(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
    if (INVALID_HANDLE_VALUE == *phFileHandle)
    {
        dwError = GetLastError();
        hr = ResultFromWin32(dwError);
    }

    if (hTemp)
        CloseHandle(hTemp);

    return hr;
}


HRESULT WriteFileWrap(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    if (!WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped))
    {
        dwError = GetLastError();
        hr = ResultFromWin32(dwError);
    }

    return hr;
}


HRESULT DeleteFileHrWrap(LPCWSTR pszPath)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    if (!DeleteFileW(pszPath))
    {
        dwError = GetLastError();
        hr = ResultFromWin32(dwError);
    }

    return hr;
}


HRESULT HrSHFileOpDeleteFile(HWND hwnd, FILEOP_FLAGS dwFlags, LPTSTR pszPath)
{
    HRESULT hr = S_OK;
    SHFILEOPSTRUCT FileOp = {0};

    pszPath[lstrlen(pszPath)+1] = 0;  // Ensure double terminated.

    FileOp.wFunc = FO_DELETE;
    FileOp.fAnyOperationsAborted = TRUE;
    FileOp.hwnd = hwnd;
    FileOp.pFrom = pszPath;
    FileOp.fFlags = dwFlags;

    if (SHFileOperation(&FileOp))
    {
        hr = ResultFromLastError();
    }

    return hr;
}


HRESULT GetPrivateProfileStringHrWrap(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
{
    HRESULT hr = S_OK;
    DWORD chGot = GetPrivateProfileStringW(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName);

    // What else can indicate an error value?
    if (0 == chGot)
    {
        hr = ResultFromLastError();
        if (SUCCEEDED(hr))
            hr = E_FAIL;
    }

    return hr;
}





/////////////////////////////////////////////////////////////////////
// Registry Helpers
/////////////////////////////////////////////////////////////////////
HRESULT HrRegOpenKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
{
    DWORD dwError = RegOpenKeyEx(hKey, lpSubKey, ulOptions, samDesired, phkResult);

    return ResultFromWin32(dwError);
}


HRESULT HrRegCreateKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD Reserved, LPTSTR lpClass, DWORD dwOptions, 
       REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
{
    DWORD dwError = RegCreateKeyEx(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);

    return ResultFromWin32(dwError);
}


HRESULT HrRegQueryValueEx(IN HKEY hKey, IN LPCTSTR lpValueName, IN LPDWORD lpReserved, IN LPDWORD lpType, IN LPBYTE lpData, IN LPDWORD lpcbData)
{
    DWORD dwError = RegQueryValueEx(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);

    return ResultFromWin32(dwError);
}


HRESULT HrRegSetValueEx(IN HKEY hKey, IN LPCTSTR lpValueName, IN DWORD dwReserved, IN DWORD dwType, IN CONST BYTE *lpData, IN DWORD cbData)
{
    DWORD dwError = RegSetValueEx(hKey, lpValueName, dwReserved, dwType, lpData, cbData);

    return ResultFromWin32(dwError);
}


HRESULT HrRegEnumKey(HKEY hKey, DWORD dwIndex, LPTSTR lpName, DWORD cbName)
{
    DWORD dwError = RegEnumKey(hKey, dwIndex, lpName, cbName);

    return ResultFromWin32(dwError);
}


HRESULT HrRegEnumValue(HKEY hKey, DWORD dwIndex, LPTSTR lpValueName, LPDWORD lpcValueName, LPDWORD lpReserved,
        LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
{
    DWORD dwError = RegEnumValue(hKey, dwIndex, lpValueName, lpcValueName, lpReserved, lpType, lpData, lpcbData);

    return ResultFromWin32(dwError);
}


HRESULT HrRegQueryInfoKey(HKEY hKey, LPTSTR lpClass, LPDWORD lpcClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcMaxSubKeyLen, 
            LPDWORD lpcMaxClassLen, LPDWORD lpcValues, LPDWORD lpcMaxValueNameLen, LPDWORD lpcMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
{
    DWORD dwError = RegQueryInfoKey(hKey, lpClass, lpcClass, lpReserved, lpcSubKeys, lpcMaxSubKeyLen, 
            lpcMaxClassLen, lpcValues, lpcMaxValueNameLen, lpcMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime);

    return ResultFromWin32(dwError);
}


HRESULT HrBStrRegQueryValue(IN HKEY hKey, IN LPCTSTR lpValueName, OUT BSTR * pbstr)
{
    TCHAR szValue[MAX_PATH];
    DWORD dwType;
    DWORD cbSize = sizeof(szValue);
    HRESULT hr = HrRegQueryValueEx(hKey, lpValueName, 0, &dwType, (BYTE *)szValue, &cbSize);

    *pbstr = NULL;
    if (SUCCEEDED(hr))
    {
        hr = HrSysAllocStringW(szValue, pbstr);
    }

    return hr;
}


HRESULT HrSHGetValue(IN HKEY hKey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, OPTIONAL OUT LPDWORD pdwType,
                    OPTIONAL OUT LPVOID pvData, OPTIONAL OUT LPDWORD pcbData)
{
    DWORD dwError = SHGetValue(hKey, pszSubKey, pszValue, pdwType, pvData, pcbData);

    return ResultFromWin32(dwError);
}


HRESULT HrSHSetValue(IN HKEY hkey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, DWORD dwType, OPTIONAL OUT LPVOID pvData, IN DWORD cbData)
{
    DWORD dwError = SHSetValue(hkey, pszSubKey, pszValue, dwType, pvData, cbData);

    return ResultFromWin32(dwError);
}


HRESULT HrRegSetValueString(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName, OUT LPCWSTR pszString)
{
    DWORD cbSize = ((lstrlenW(pszString) + 1) * sizeof(pszString[0]));

    return  HrSHSetValue(hKey, pszSubKey, pszValueName, REG_SZ, (BYTE *)pszString, cbSize);
}


HRESULT HrRegGetValueString(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName, IN LPWSTR pszString, IN DWORD cchSize)
{
    DWORD dwType;
    DWORD cbSize = (cchSize * sizeof(pszString[0]));

    HRESULT hr = HrSHGetValue(hKey, pszSubKey, pszValueName, &dwType, (BYTE *)pszString, &cbSize);
    if (SUCCEEDED(hr) && (REG_SZ != dwType))
    {
        hr = E_FAIL;
    }

    return hr;
}


/*****************************************************************************\
    DESCRIPTION:
        This function will store paths in the registry.  The user calls the
    fuction with full paths are they are converted to relative path.  The
    strings prefer to be stored in REG_EXPAND_SZ, but it will fallback to
    REG_SZ if needed.
\*****************************************************************************/
HRESULT HrRegSetPath(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName, BOOL fUseExpandSZ, OUT LPCWSTR pszPath)
{
    TCHAR szFinalPath[MAX_PATH];

    if (!PathUnExpandEnvStrings(pszPath, szFinalPath, ARRAYSIZE(szFinalPath)))
    {
        StrCpyN(szFinalPath, pszPath, ARRAYSIZE(szFinalPath));  // We failed so use the original.
    }

    DWORD cbSize = ((lstrlenW(szFinalPath) + 1) * sizeof(szFinalPath[0]));
    HRESULT hr = E_FAIL;

    if (fUseExpandSZ)
    {
        hr = HrSHSetValue(hKey, pszSubKey, pszValueName, REG_EXPAND_SZ, (BYTE *)szFinalPath, cbSize);
    }

    if (FAILED(hr))
    {
        // Maybe it already exists as a REG_SZ so we will store it there.  Note that we are still storing it
        // unexpanded even thought it's in REG_SZ.  If the caller does not like it, use
        // another function like SHRegSetPath().
        cbSize = ((lstrlenW(szFinalPath) + 1) * sizeof(szFinalPath[0]));
        hr = HrSHSetValue(hKey, pszSubKey, pszValueName, REG_SZ, (BYTE *)szFinalPath, cbSize);
    }

    return  hr;
}


HRESULT HrRegGetPath(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName, IN LPWSTR pszPath, IN DWORD cchSize)
{
    TCHAR szFinalPath[MAX_PATH];
    DWORD dwType;
    DWORD cbSize = sizeof(szFinalPath);

    HRESULT hr = HrSHGetValue(hKey, pszSubKey, pszValueName, &dwType, (BYTE *)szFinalPath, &cbSize);
    if (SUCCEEDED(hr) &&
        ((REG_EXPAND_SZ == dwType) || (REG_SZ == dwType)))
    {
        if (0 == SHExpandEnvironmentStrings(szFinalPath, pszPath, cchSize))
        {
            StrCpyN(pszPath, szFinalPath, cchSize);  // We failed so use the original.
        }
    }

    return  hr;
}


HRESULT HrRegDeleteValue(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName)
{
    HRESULT hr = S_OK;
    HKEY hKeySub = hKey;

    if (pszSubKey)
    {
        hr = HrRegOpenKeyEx(hKey, pszSubKey, 0, KEY_WRITE, &hKeySub);
    }

    if (SUCCEEDED(hr))
    {
        DWORD dwError = RegDeleteValue(hKeySub, pszValueName);

        hr = ResultFromWin32(dwError);
    }

    if (hKeySub == hKey)
    {
        RegCloseKey(hKeySub);
    }

    return hr;
}


DWORD HrRegGetDWORD(HKEY hKey, LPCWSTR szKey, LPCWSTR szValue, DWORD dwDefault)
{
    DWORD dwResult = dwDefault;
    DWORD cbSize = sizeof(dwResult);
    DWORD dwType;
    DWORD dwError = SHGetValue(hKey, szKey, szValue, &dwType, &dwResult, &cbSize);

    if ((ERROR_SUCCESS != dwError) ||
        ((REG_DWORD != dwType) && (REG_BINARY != dwType)) || (sizeof(dwResult) != cbSize))
    {
        return dwDefault;
    }

    return dwResult;
}


HRESULT HrRegSetDWORD(HKEY hKey, LPCWSTR szKey, LPCWSTR szValue, DWORD dwData)
{
    DWORD dwError = SHSetValue(hKey, szKey, szValue, REG_DWORD, &dwData, sizeof(dwData));

    return ResultFromWin32(dwError);
}








/////////////////////////////////////////////////////////////////////
// Palette Helpers
/////////////////////////////////////////////////////////////////////
COLORREF GetNearestPaletteColor(HPALETTE hpal, COLORREF rgb)
{
    PALETTEENTRY pe = {0};
    UINT nIndex = GetNearestPaletteIndex(hpal, rgb & 0x00FFFFFF);

    if (CLR_INVALID != nIndex)
    {
        GetPaletteEntries(hpal, nIndex, 1, &pe);
    }

    return RGB(pe.peRed, pe.peGreen, pe.peBlue);
}


BOOL IsPaletteColor(HPALETTE hpal, COLORREF rgb)
{
    return GetNearestPaletteColor(hpal, rgb) == (rgb & 0xFFFFFF);
}





/////////////////////////////////////////////////////////////////////
// Other Helpers
/////////////////////////////////////////////////////////////////////
HRESULT HrRewindStream(IStream * pstm)
{
    LARGE_INTEGER  liOrigin = {0,0};

    return pstm->Seek(liOrigin, STREAM_SEEK_SET, NULL);
}



#define SET_FLAG(dwAllFlags, dwFlag)      ((dwAllFlags) |= (dwFlag))
#define IS_FLAG_SET(dwAllFlags, dwFlag)   ((BOOL)((dwAllFlags) & (dwFlag)))





HRESULT HrByteToStream(LPSTREAM *lppstm, LPBYTE lpb, ULONG cb)
{
    // Locals
    HRESULT hr=S_OK;
    LARGE_INTEGER  liOrigin = {0,0};

    // Create H Global Stream
    hr = CreateStreamOnHGlobal (NULL, TRUE, lppstm);
    if (FAILED(hr))
        goto exit;

    // Write String
    hr = (*lppstm)->Write (lpb, cb, NULL);
    if (FAILED(hr))
        goto exit;

    // Rewind the steam
    hr = (*lppstm)->Seek(liOrigin, STREAM_SEEK_SET, NULL);
    if (FAILED(hr))
        goto exit;

exit:
    // Done
    return hr;
}

const char szDayOfWeekArray[7][4] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" } ;
const char szMonthOfYearArray[12][4] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" } ;

void GetDateString(char * szSentDateString, ULONG stringLen)
{
    // Sent Date
    SYSTEMTIME stSentTime;
    CHAR szMonth[10], szWeekDay[12] ; 

    GetSystemTime(&stSentTime);

    lstrcpynA(szWeekDay, szDayOfWeekArray[stSentTime.wDayOfWeek], ARRAYSIZE(szWeekDay)) ;
    lstrcpynA(szMonth, szMonthOfYearArray[stSentTime.wMonth-1], ARRAYSIZE(szMonth)) ;

    wnsprintfA(szSentDateString, stringLen, "%s, %u %s %u %2d:%02d:%02d ", (LPSTR) szWeekDay, stSentTime.wDay, 
                                (LPSTR) szMonth, stSentTime.wYear, stSentTime.wHour, 
                                stSentTime.wMinute, stSentTime.wSecond) ;
}


/*****************************************************************************\
    PARAMETERS:
        RETURN: Win32 HRESULT (Not Script Safe).
            SUCCEEDED(hr) for OK and out params filled in.
            FAILED(hr) for all errors.
\*****************************************************************************/
HRESULT GetQueryStringValue(BSTR bstrURL, LPCWSTR pwszValue, LPWSTR pwszData, int cchSizeData)
{
    HRESULT hr = E_FAIL;
    LPCWSTR pwszIterate = bstrURL;

    pwszIterate = StrChrW(pwszIterate, L'?');   // Advance to Query part of URL.
    while (pwszIterate && pwszIterate[0])
    {
        pwszIterate++;  // Start at first value
        
        LPCWSTR pwszEndOfValue = StrChrW(pwszIterate, L'=');
        if (!pwszEndOfValue)
            break;
        
        int cchValueSize = (INT)(UINT)(pwszEndOfValue - pwszIterate);
        if (0 == StrCmpNIW(pwszValue, pwszIterate, cchValueSize))
        {
            int cchSizeToCopy = cchSizeData;  // Copy rest of line by default.

            pwszIterate = StrChrW(pwszEndOfValue, L'&');
            if (pwszIterate)
            {
                cchSizeToCopy = (INT)(UINT)(pwszIterate - pwszEndOfValue);
            }

            // It matches, now get the Data.
            StrCpyNW(pwszData, (pwszEndOfValue + 1), cchSizeToCopy);
            hr = S_OK;
            break;
        }
        else
        {
            pwszIterate = StrChrW(pwszEndOfValue, L'&');
        }
    }

    return hr;
}


BOOL _InitComCtl32()
{
    static BOOL fInitialized = FALSE;

    if (!fInitialized)
    {
        INITCOMMONCONTROLSEX icc;

        icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icc.dwICC = (ICC_ANIMATE_CLASS | ICC_USEREX_CLASSES | ICC_COOL_CLASSES | ICC_INTERNET_CLASSES | ICC_PAGESCROLLER_CLASS | ICC_NATIVEFNTCTL_CLASS | ICC_LISTVIEW_CLASSES | ICC_LINK_CLASS);
        fInitialized = InitCommonControlsEx(&icc);
    }
    return fInitialized;
}


DWORD GetCurrentSessionID(void)
{
    DWORD dwProcessID = (DWORD) -1;
    ProcessIdToSessionId(GetCurrentProcessId(), &dwProcessID);

    return dwProcessID;
}

typedef struct
{
    LPCWSTR pszRegKey;
    LPCWSTR pszRegValue;
} TSPERFFLAG_ITEM;

const TSPERFFLAG_ITEM s_TSPerfFlagItems[] =
{
    {L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Remote\\%d", L"ActiveDesktop"},              // TSPerFlag_NoADWallpaper
    {L"Remote\\%d\\Control Panel\\Desktop", L"Wallpaper"},                                                  // TSPerFlag_NoWallpaper
    {L"Software\\Microsoft\\Windows\\CurrentVersion\\ThemeManager\\Remote\\%d", L"ThemeActive"},            // TSPerFlag_NoVisualStyles
    {L"Remote\\%d\\Control Panel\\Desktop", L"DragFullWindows"},                                            // TSPerFlag_NoWindowDrag
    {L"Remote\\%d\\Control Panel\\Desktop", L"SmoothScroll"},                                               // TSPerFlag_NoAnimation
};


BOOL IsTSPerfFlagEnabled(enumTSPerfFlag eTSFlag)
{
    BOOL fIsTSFlagEnabled = FALSE;
    static BOOL s_fTSSession = -10;

    if (-10 == s_fTSSession)
    {
        s_fTSSession = GetSystemMetrics(SM_REMOTESESSION);
    }

    if (s_fTSSession)
    {
        TCHAR szTemp[MAX_PATH];
        DWORD dwType;
        DWORD cbSize = sizeof(szTemp);
        TCHAR szRegKey[MAX_PATH];

        wnsprintf(szRegKey, ARRAYSIZE(szRegKey), s_TSPerfFlagItems[eTSFlag].pszRegKey, GetCurrentSessionID());

        if (ERROR_SUCCESS == SHGetValueW(HKEY_CURRENT_USER, szRegKey, s_TSPerfFlagItems[eTSFlag].pszRegValue, &dwType, (void *)szTemp, &cbSize))
        {
            fIsTSFlagEnabled = TRUE;
        }
    }

    return fIsTSFlagEnabled;
}


HRESULT HrShellExecute(HWND hwnd, LPCTSTR lpVerb, LPCTSTR lpFile, LPCTSTR lpParameters, LPCTSTR lpDirectory, INT nShowCmd)
{
    HRESULT hr = S_OK;
    HINSTANCE hReturn = ShellExecute(hwnd, lpVerb, lpFile, lpParameters, lpDirectory, nShowCmd);

    if ((HINSTANCE)32 > hReturn)
    {
        hr = ResultFromLastError();
    }

    return hr;
}


HRESULT StrReplaceToken(IN LPCTSTR pszToken, IN LPCTSTR pszReplaceValue, IN LPTSTR pszString, IN DWORD cchSize)
{
    HRESULT hr = S_OK;
    LPTSTR pszTempLastHalf = NULL;
    LPTSTR pszNextToken = pszString;

    while (0 != (pszNextToken = StrStrI(pszNextToken, pszToken)))
    {
        // We found one.
        LPTSTR pszPastToken = pszNextToken + lstrlen(pszToken);

        Str_SetPtr(&pszTempLastHalf, pszPastToken);      // Keep a copy because we will overwrite it.

        pszNextToken[0] = 0;    // Remove the rest of the string.
        StrCatBuff(pszString, pszReplaceValue, cchSize);
        StrCatBuff(pszString, pszTempLastHalf, cchSize);

        pszNextToken += lstrlen(pszReplaceValue);
    }

    Str_SetPtr(&pszTempLastHalf, NULL);

    return hr;
}


HRESULT HrWritePrivateProfileStringW(LPCWSTR pszAppName, LPCWSTR pszKeyName, LPCWSTR pszString, LPCWSTR pszFileName)
{
    HRESULT hr = S_OK;

    if (!WritePrivateProfileStringW(pszAppName, pszKeyName, pszString, pszFileName))
    {
        hr = ResultFromLastError();
    }

    return hr;
}


BOOL IUnknown_CompareCLSID(IN IUnknown * punk, IN CLSID clsid)
{
    BOOL fIsEqual = FALSE;

    if (punk)
    {
        CLSID clsidPageID;
        HRESULT hr = IUnknown_GetClassID(punk, &clsidPageID);

        if (SUCCEEDED(hr) && IsEqualCLSID(clsidPageID, clsid))
        {
            fIsEqual = TRUE;
        }
    }

    return fIsEqual;
}


HRESULT IEnumUnknown_FindCLSID(IN IUnknown * punk, IN CLSID clsid, OUT IUnknown ** ppunkFound)
{
    HRESULT hr = E_INVALIDARG;

    if (punk && ppunkFound)
    {
        IEnumUnknown * pEnum;

        *ppunkFound = NULL;
        hr = punk->QueryInterface(IID_PPV_ARG(IEnumUnknown, &pEnum));
        if (SUCCEEDED(hr))
        {
            IUnknown * punkToTry;
            ULONG ulFetched;

            pEnum->Reset();

            hr = E_FAIL;
            while (SUCCEEDED(pEnum->Next(1, &punkToTry, &ulFetched)) &&
                (1 == ulFetched))
            {
                if (IUnknown_CompareCLSID(punkToTry, clsid))
                {
                    *ppunkFound = punkToTry;
                    hr = S_OK;
                    break;
                }

                punkToTry->Release();
            }

            pEnum->Release();
        }
    }

    return hr;
}


BYTE WINAPI MyStrToByte(LPCTSTR sz)
{
    BYTE l=0;

    while (*sz >= TEXT('0') && *sz <= TEXT('9'))
    {
        l = (BYTE) l*10 + (*sz++ - TEXT('0'));
    }

    return l;
}


COLORREF ConvertColor(LPTSTR pszColor)
{
    BYTE RGBTemp[3];
    LPTSTR pszTemp = pszColor;
    UINT i;

    if (!pszColor || !*pszColor)
    {
        return RGB(0,0,0);
    }

    for (i =0; i < 3; i++)
    {
        // Remove leading spaces
        while (*pszTemp == TEXT(' '))
        {
            pszTemp++;
        }

        // Set pszColor to the beginning of the number
        pszColor = pszTemp;

        // Find the end of the number and null terminate
        while ((*pszTemp) && (*pszTemp != TEXT(' ')))
        {
            pszTemp++;
        }

        if (*pszTemp != TEXT('\0'))
        {
            *pszTemp = TEXT('\0');
        }

        pszTemp++;
        RGBTemp[i] = MyStrToByte(pszColor);
    }

    return (RGB(RGBTemp[0], RGBTemp[1], RGBTemp[2]));
}



// Paremeters:
//  hwndOwner  -- owner window
//  idTemplate -- specifies template (e.g., "Can't open %2%s\n\n%1%s")
//  hr         -- specifies the HRESULT error code
//  pszParam   -- specifies the 2nd parameter to idTemplate
//  dwFlags    -- flags for MessageBox
UINT ErrorMessageBox(HWND hwndOwner, LPCTSTR pszTitle, UINT idTemplate, HRESULT hr, LPCTSTR pszParam, UINT dwFlags)
{
    TCHAR szErrNumString[MAX_PATH * 2];
    TCHAR szTemplate[MAX_PATH * 2];
    TCHAR szErrMsg[MAX_PATH * 2];

    if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr, 0, szErrNumString, ARRAYSIZE(szErrNumString), NULL))
    {
        szErrNumString[0] = 0;      // We will not be able to display an error message.
    }

    // These error messages are so useless to customers, that we prefer to leave it blank.
    if ((E_INVALIDARG == hr) ||
        (ResultFromWin32(ERROR_INVALID_PARAMETER) == hr))
    {
        szErrNumString[0] = 0; 
    }

    LoadString(HINST_THISDLL, idTemplate, szTemplate, ARRAYSIZE(szTemplate));
    if (pszParam)
    {
        wnsprintf(szErrMsg, ARRAYSIZE(szErrMsg), szTemplate, szErrNumString, pszParam);
    }
    else
    {
        wnsprintf(szErrMsg, ARRAYSIZE(szErrMsg), szTemplate, szErrNumString);
    }

    return MessageBox(hwndOwner, szErrMsg, pszTitle, (MB_OK | MB_ICONERROR));
}


HRESULT DisplayThemeErrorDialog(HWND hwndParent, HRESULT hrError, UINT nTitle, UINT nTemplate)
{
    HRESULT hr = S_OK;

    if (FAILED(hrError))
    {
        hr = ResultFromWin32(ERROR_CANCELLED);
        if (!g_fInSetup &&           // Don't display an error during setup.
            (ResultFromWin32(ERROR_CANCELLED) != hrError))
        {
            //---- get error from theme manager ----
            WCHAR szErrorMsg[MAX_PATH*2];
            WCHAR szTitle[MAX_PATH];

            szErrorMsg[0] = 0;      // In case the error function fails.
            if (FAILED(hrError))
            {
                PARSE_ERROR_INFO Info = {sizeof(Info)};

                if (SUCCEEDED(GetThemeParseErrorInfo(&Info)))
                {
                    lstrcpy(szErrorMsg, Info.szMsg);
                }
                else
                {
                    *szErrorMsg = 0;        // no error avail
                }
            }

            // We want to display UI if an error occured here.  We want to do
            // it instead of our parent because THEMELOADPARAMS contains
            // extra error information that we can't pass back to the caller.
            // However, we will only display error UI if our caller wants us
            // to.  We determine that by the fact that they make an hwnd available
            // to us.  We get the hwnd by getting our site pointer and getting
            // the hwnd via ::GetWindow().
            LoadString(HINST_THISDLL, nTitle, szTitle, ARRAYSIZE(szTitle));
            ErrorMessageBox(hwndParent, szTitle, nTemplate, hrError, szErrorMsg, (MB_OK | MB_ICONEXCLAMATION));
        }
    }

    return hr;
}



BOOL IsOSNT(void)
{
    OSVERSIONINFOA osVerInfoA;

    osVerInfoA.dwOSVersionInfoSize = sizeof(osVerInfoA);
    if (!GetVersionExA(&osVerInfoA))
        return VER_PLATFORM_WIN32_WINDOWS;   // Default to this.

    return (VER_PLATFORM_WIN32_NT == osVerInfoA.dwPlatformId);
}


DWORD GetOSVer(void)
{
    OSVERSIONINFOA osVerInfoA;

    osVerInfoA.dwOSVersionInfoSize = sizeof(osVerInfoA);
    if (!GetVersionExA(&osVerInfoA))
        return VER_PLATFORM_WIN32_WINDOWS;   // Default to this.

    return osVerInfoA.dwMajorVersion;
}


BOOL HideBackgroundTabOnTermServices(void)
{
    BOOL fHideThisPage = FALSE;
    TCHAR   szSessionName[WINSTATIONNAME_LENGTH * 2];
    TCHAR   szBuf[MAX_PATH*2];
    TCHAR   szActualValue[MAX_PATH*2];
    DWORD   dwLen;
    DWORD   i;

    ZeroMemory((PVOID)szSessionName,sizeof(szSessionName));
    dwLen = GetEnvironmentVariable(TEXT("SESSIONNAME"), szSessionName, ARRAYSIZE(szSessionName));
    if (dwLen != 0)
    {
        // Now that we have the session name, search for the # character.
        for(i = 0; i < dwLen; i++)
        {
            if (szSessionName[i] == TEXT('#'))
            {
                szSessionName[i] = TEXT('\0');
                break;
            }
        }

        // Here is what we are looking for in NT5:
        //  HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\
        //      WinStations\RDP-Tcp\UserOverride\Control Panel\Desktop
        //
        // The value is:
        //      Wallpaper
        wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s\\%s\\%s\\%s"), WINSTATION_REG_NAME, szSessionName, WIN_USEROVERRIDE, REGSTR_PATH_DESKTOP);

        // See if we can get the wallpaper string.  This will fail if the key
        // doesn't exist.  This means the policy isn't set.
        if (SUCCEEDED(HrRegGetValueString(HKEY_LOCAL_MACHINE, szBuf, L"Wallpaper", szActualValue, ARRAYSIZE(szActualValue))))
        {
            fHideThisPage = TRUE;
        }
    }

    return fHideThisPage;
}


extern BOOL FadeEffectAvailable(void);

void LogStartInformation(void)
{
    BOOL fTemp;

    // Frequently users will report that something is broken in the Display CPL.
    // However, the real problem is that someone turned on a policy that locks UI
    // and the user didn't know that the policy was enabled.  We log those here so
    // it's quick to find those issues.
    if (SHRestricted(REST_NODISPLAYCPL)) LogStatus("POLICY ENABLED: Do not show the Display CPL.");
    if (SHRestricted(REST_NODISPLAYAPPEARANCEPAGE)) LogStatus("POLICY ENABLED: Hide the Themes and Appearance tab.");
    if (SHRestricted(REST_NOTHEMESTAB)) LogStatus("POLICY ENABLED: Hide the Themes tab.");
    if (SHRestricted(REST_NODISPBACKGROUND)) LogStatus("POLICY ENABLED: Hide the Desktop tab.");
    if (SHRestricted(REST_NODISPSCREENSAVEPG)) LogStatus("POLICY ENABLED: Hide the ScreenSaver tab.");
    if (SHRestricted(REST_NODISPSETTINGSPG)) LogStatus("POLICY ENABLED: Hide the Settings tab.");
    if (SHRestricted(REST_NOVISUALSTYLECHOICE)) LogStatus("POLICY ENABLED: User not allowed to change the Visual Style.");
    if (SHRestricted(REST_NOCOLORCHOICE)) LogStatus("POLICY ENABLED: User Not allowed to change the Visual Style Color Selection.");
    if (SHRestricted(REST_NOSIZECHOICE)) LogStatus("POLICY ENABLED: User not allowed to change the Visual Style size selection.");

    if (0 != SHGetRestriction(NULL,POLICY_KEY_EXPLORER,POLICY_VALUE_ANIMATION)) LogStatus("POLICY ENABLED: Policy disallows fade effect. (Effects dialog)");
    if (0 != SHGetRestriction(NULL,POLICY_KEY_EXPLORER, POLICY_VALUE_KEYBOARDNAV)) LogStatus("POLICY ENABLED: Policy disallows changing underline key accell. (Effects dialog)");
    if (0 != SHGetRestriction(NULL,POLICY_KEY_ACTIVEDESKTOP, SZ_POLICY_NOCHANGEWALLPAPER)) LogStatus("POLICY ENABLED: Policy disallows changing wallpaper. (Desktop tab)");
    if (0 != SHGetRestriction(NULL,POLICY_KEY_SYSTEM, SZ_POLICY_NODISPSCREENSAVERPG)) LogStatus("POLICY ENABLED: Policy hides ScreenSaver page.");
    if (0 != SHGetRestriction(SZ_REGKEY_POLICIES_DESKTOP, NULL, SZ_POLICY_SCREENSAVEACTIVE)) LogStatus("POLICY ENABLED: Policy forces screensaver on or off");
    if (0 != SHGetRestriction(NULL,POLICY_KEY_EXPLORER, POLICY_VALUE_KEYBOARDNAV)) LogStatus("POLICY ENABLED: Policy disallows changing underline key accell. (Effects dialog)");

    if (IsTSPerfFlagEnabled(TSPerFlag_NoAnimation)) LogStatus("POLICY ENABLED: TS Perf Policy disallows animations. (Effects dialog)");
    if (IsTSPerfFlagEnabled(TSPerFlag_NoWindowDrag)) LogStatus("POLICY ENABLED: TS Perf Policy disallows full window drag. (Effects dialog)");
    if (IsTSPerfFlagEnabled(TSPerFlag_NoVisualStyles)) LogStatus("POLICY ENABLED: TS Perf Policy disallows visual styles.");
    if (IsTSPerfFlagEnabled(TSPerFlag_NoWallpaper)) LogStatus("POLICY ENABLED: TS Perf Policy disallows Wallpaper.");
    if (IsTSPerfFlagEnabled(TSPerFlag_NoADWallpaper)) LogStatus("POLICY ENABLED: TS Perf Policy disallows AD Wallpaper.");

    if (HideBackgroundTabOnTermServices()) LogStatus("POLICY ENABLED: TS Set a policy forcing a certain wallpaper, so the Desktop tab is hidden.");
    if (!FadeEffectAvailable()) LogStatus("POLICY ENABLED: A policy forces Fade Effects off (Effects dialog)");

    if (!ClassicSystemParametersInfo(SPI_GETFONTSMOOTHINGTYPE, 0, (PVOID)&fTemp, 0)) LogStatus("POLICY ENABLED: SPI_GETFONTSMOOTHINGTYPE hides FontSmoothing. (Effects dialog)");
    if (ClassicSystemParametersInfo(SPI_GETUIEFFECTS, 0, (PVOID) &fTemp, 0) && !fTemp) LogStatus("POLICY ENABLED: SPI_GETUIEFFECTS hides lots of UI effects. (Effects dialog)");
    if (ClassicSystemParametersInfo(SPI_GETGRADIENTCAPTIONS, 0, (PVOID) &fTemp, 0) && !fTemp) LogStatus("POLICY ENABLED: SPI_GETGRADIENTCAPTIONS turns off Caption bar Gradients. (Advance Appearance)");
}


void LogStatus(LPCSTR pszMessage, ...)
{
    static int nLogOn = -1;
    va_list vaParamList;

    va_start(vaParamList, pszMessage);

    if (-1 == nLogOn)
    {
        nLogOn = (SHRegGetBoolUSValue(SZ_THEMES, SZ_REGVALUE_LOGINFO, FALSE, FALSE) ? 1 : 0);
    }

    if (1 == nLogOn)
    {
        if (INVALID_HANDLE_VALUE == g_hLogFile)
        {
            TCHAR szPath[MAX_PATH];

            if (GetWindowsDirectory(szPath, ARRAYSIZE(szPath)))
            {
                PathAppend(szPath, TEXT("Theme.log"));
                g_hLogFile = CreateFile(szPath, (GENERIC_READ | GENERIC_WRITE), FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
                if (INVALID_HANDLE_VALUE != g_hLogFile)
                {
                    WCHAR szUserName[MAX_PATH];
                    CHAR szTimeDate[MAX_PATH];
                    CHAR szHeader[MAX_PATH];
                    FILETIME ftCurrentUTC;
                    FILETIME ftCurrent;
                    SYSTEMTIME stCurrent;
                    DWORD cbWritten;

                    SetFilePointer(g_hLogFile, 0, NULL, FILE_END);
                    
                    GetLocalTime(&stCurrent);
                    SystemTimeToFileTime(&stCurrent, &ftCurrent);
                    LocalFileTimeToFileTime(&ftCurrent, &ftCurrentUTC);
                    SHFormatDateTimeA(&ftCurrentUTC, NULL, szTimeDate, ARRAYSIZE(szTimeDate));

                    ULONG cchUserSize = ARRAYSIZE(szUserName);
                    if (!GetUserNameEx(NameDisplay, szUserName, &cchUserSize) &&
                        !GetUserNameEx(NameUserPrincipal, szUserName, &cchUserSize) &&
                        !GetUserNameEx(NameSamCompatible, szUserName, &cchUserSize) &&
                        !GetUserNameEx(NameUniqueId, szUserName, &cchUserSize))
                    {
                        szUserName[0] = 0;
                    }

                    TCHAR szProcess[MAX_PATH];
                    if (!GetModuleFileName(NULL, szProcess, ARRAYSIZE(szProcess)))
                    {
                        szProcess[0] = 0;
                    }

                    wnsprintfA(szHeader, ARRAYSIZE(szHeader), "\r\n\r\n%hs - USER: %ls (%ls)\r\n", szTimeDate, szUserName, szProcess);
                    WriteFile(g_hLogFile, szHeader, lstrlenA(szHeader), &cbWritten, NULL);

                    // Log information that we need to do on every startup.  (Like Policies that are on that confuse people)
                    LogStartInformation();
                }

            }
        }

        if (INVALID_HANDLE_VALUE != g_hLogFile)
        {
            CHAR szMessage[4000];
            DWORD cbWritten;
            wvsprintfA(szMessage, pszMessage, vaParamList);
            WriteFile(g_hLogFile, szMessage, lstrlenA(szMessage), &cbWritten, NULL);
        }
    }

    va_end(vaParamList);
}


void LogSystemMetrics(LPCSTR pszMessage, SYSTEMMETRICSALL * pSystemMetrics)
{
    CHAR szSysMetrics[1024];        // Random because it's big.
    
    if (pSystemMetrics)
    {
        wnsprintfA(szSysMetrics, ARRAYSIZE(szSysMetrics), "Sz(Brdr=%d, Scrl=%d, Cap=%d, Menu=%d, Icon=%d, DXIn=%d) Ft(Cap=%d(%d), SmCap=%d(%d), Menu=%d(%d), Stus=%d(%d), Msg=%d(%d))", 
                pSystemMetrics->schemeData.ncm.iBorderWidth,
                pSystemMetrics->schemeData.ncm.iScrollWidth,
                pSystemMetrics->schemeData.ncm.iCaptionHeight,
                pSystemMetrics->schemeData.ncm.iMenuHeight,
                pSystemMetrics->nIcon,
                pSystemMetrics->nDYIcon,
                pSystemMetrics->schemeData.ncm.lfCaptionFont.lfHeight,
                pSystemMetrics->schemeData.ncm.lfCaptionFont.lfCharSet,
                pSystemMetrics->schemeData.ncm.lfSmCaptionFont.lfHeight,
                pSystemMetrics->schemeData.ncm.lfSmCaptionFont.lfCharSet,
                pSystemMetrics->schemeData.ncm.lfMenuFont.lfHeight,
                pSystemMetrics->schemeData.ncm.lfMenuFont.lfCharSet,
                pSystemMetrics->schemeData.ncm.lfStatusFont.lfHeight,
                pSystemMetrics->schemeData.ncm.lfStatusFont.lfCharSet,
                pSystemMetrics->schemeData.ncm.lfMessageFont.lfHeight,
                pSystemMetrics->schemeData.ncm.lfMessageFont.lfCharSet);
    }
    else
    {
        szSysMetrics[0] = 0;
    }

    LogStatus("SYSMET: %s: %s\r\n", pszMessage, szSysMetrics);
}



#define SzFromInt(sz, n)            (wsprintf((LPTSTR)sz, (LPTSTR)TEXT("%d"), n), (LPTSTR)sz)

int WritePrivateProfileInt(LPCTSTR szApp, LPCTSTR szKey, int nDefault, LPCTSTR pszFileName)
{
    CHAR sz[7];

    return WritePrivateProfileString(szApp, szKey, SzFromInt(sz, nDefault), pszFileName);
}


#define SZ_RESOURCEDIR              L"Resources"

HRESULT SHGetResourcePath(BOOL fLocaleNode, IN LPWSTR pszPath, IN DWORD cchSize)
{
    DWORD dwFlags = (CSIDL_FLAG_CREATE | CSIDL_RESOURCES);

    return SHGetFolderPath(NULL, dwFlags, NULL, 0, pszPath);
}


#define SZ_RESOURCEDIR_TOKEN        TEXT("%ResourceDir%")
#define SZ_RESOURCELDIR_TOKEN       TEXT("%ResourceDirL%")
HRESULT ExpandResourceDir(IN LPWSTR pszPath, IN DWORD cchSize)
{
    HRESULT hr = S_OK;
    BOOL fLocalized = FALSE;
    LPCTSTR pszToken = StrStrW(pszPath, SZ_RESOURCEDIR_TOKEN);

    if (!pszToken)
    {
        pszToken = StrStrW(pszPath, SZ_RESOURCELDIR_TOKEN);
    }

    // Do we have stuff to replace?
    if (pszToken)
    {
        // Yes, so get the replacement value.
        WCHAR szResourceDir[MAX_PATH];

        hr = SHGetResourcePath(fLocalized, szResourceDir, ARRAYSIZE(szResourceDir));
        if (SUCCEEDED(hr))
        {
            hr = StrReplaceToken((fLocalized ? SZ_RESOURCELDIR_TOKEN : SZ_RESOURCEDIR_TOKEN), szResourceDir, pszPath, cchSize);
        }
    }

    return hr;
}


STDAPI SHPropertyBag_WritePunk(IN IPropertyBag * pPropertyPage, IN LPCWSTR pwzPropName, IN IUnknown * punk)
{
    HRESULT hr = E_INVALIDARG;

    if (pPropertyPage && pwzPropName)
    {
        VARIANT va;

        va.vt = VT_UNKNOWN;
        va.punkVal = punk;

        hr = pPropertyPage->Write(pwzPropName, &va);
    }

    return hr;
}


STDAPI SHPropertyBag_ReadByRef(IN IPropertyBag * pPropertyPage, IN LPCWSTR pwzPropName, IN void * p, IN SIZE_T cbSize)
{
    HRESULT hr = E_INVALIDARG;

    if (pPropertyPage && pwzPropName && p)
    {
        VARIANT va;

        hr = pPropertyPage->Read(pwzPropName, &va, NULL);
        if (SUCCEEDED(hr))
        {
            if ((VT_BYREF == va.vt) && va.byref)
            {
                CopyMemory(p, va.byref, cbSize);
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }

    return hr;
}


STDAPI SHPropertyBag_WriteByRef(IN IPropertyBag * pPropertyPage, IN LPCWSTR pwzPropName, IN void * p)
{
    HRESULT hr = E_INVALIDARG;

    if (pPropertyPage && pwzPropName && p)
    {
        VARIANT va;

        va.vt = VT_BYREF;
        va.byref = p;
        hr = pPropertyPage->Write(pwzPropName, &va);
    }

    return hr;
}

LONG s_cSpiDummy = -1;
LONG *g_pcSpiThreads = &s_cSpiDummy;

void SPISetThreadCounter(LONG *pcThreads)
{
    if (!pcThreads)
        pcThreads = &s_cSpiDummy;
    InterlockedExchangePointer((void **) &g_pcSpiThreads, pcThreads);
}

typedef struct 
{
    LPTHREAD_START_ROUTINE pfnThreadProc;
    void *pvData;
    UINT idThread;
}SPITHREAD;

DWORD CALLBACK _SPIWrapperThreadProc(void *pv)
{
    SPITHREAD *pspi = (SPITHREAD *)pv;
    DWORD dwRet = pspi->pfnThreadProc(pspi->pvData);
    //  then we check to see 
    if (0 == InterlockedDecrement(g_pcSpiThreads))
    {
        PostThreadMessage(pspi->idThread, WM_NULL, 0, 0);
    }
    delete pspi;
    return dwRet;
}

BOOL SPICreateThread(LPTHREAD_START_ROUTINE pfnThreadProc, void *pvData)
{
    SPITHREAD *pspi = new SPITHREAD;
    if (pspi)
    {
        pspi->idThread = GetCurrentThreadId();
        pspi->pfnThreadProc = pfnThreadProc;
        pspi->pvData = pvData;
        InterlockedIncrement(g_pcSpiThreads);
        return SHCreateThread(_SPIWrapperThreadProc, pspi, (CTF_COINIT | CTF_INSIST | CTF_FREELIBANDEXIT), NULL);
    }
    else
    {
        // CTF_INSIST
        pfnThreadProc(pvData);
        return TRUE;
    }
}

void PostMessageBroadAsync(IN UINT Msg, IN WPARAM wParam, IN LPARAM lParam)
{
    // We don't want to hang our UI if other apps are hung or slow when
    // we need to tell them to update their changes.  So we choose this
    // mechanism.
    //
    // The alternatives are:
    // SendMessageCallback: Except we don't need to do anything when the apps
    //   are done.
    // SendMessageTimeout: Except we don't want to incure any timeout.
    PostMessage(HWND_BROADCAST, Msg, wParam, lParam);
}


typedef struct
{
    BOOL fFree;         // Do you need to call LocalFree() on pvData?
    UINT uiAction;
    UINT uiParam;
    UINT fWinIni;
    void * pvData;
    CDimmedWindow* pDimmedWindow;
} SPIS_INFO;

DWORD SystemParametersInfoAsync_WorkerThread(IN void *pv)
{
    SPIS_INFO * pSpisInfo = (SPIS_INFO *) pv;
    HINSTANCE hInstance = LoadLibrary(TEXT("desk.cpl"));

    if (pSpisInfo)
    {
        ClassicSystemParametersInfo(pSpisInfo->uiAction, pSpisInfo->uiParam, pSpisInfo->pvData, pSpisInfo->fWinIni);
        if (pSpisInfo->fFree && pSpisInfo->pvData)
        {
            LocalFree(pSpisInfo->pvData);
        }

        if (pSpisInfo->pDimmedWindow)
        {
            pSpisInfo->pDimmedWindow->Release();
        }

        LocalFree(pv);
    }

    if (hInstance)
    {
        FreeLibrary(hInstance);
    }

    return 0;
}


void SystemParametersInfoAsync(IN UINT uiAction, IN UINT uiParam, IN void * pvParam, IN DWORD cbSize, IN UINT fWinIni, IN CDimmedWindow* pDimmedWindow)
{
    // ClassicSystemParametersInfo() will hang if a top level window is hung (#162570) and USER will not fix that bug.
    // Therefore, we need to make that API call on a background thread because we need to
    // be more rebust than to hang.
    SPIS_INFO * pSpisInfo = (SPIS_INFO *) LocalAlloc(LPTR, sizeof(*pSpisInfo));

    if (pSpisInfo)
    {
        BOOL fAsyncOK = TRUE;

        pSpisInfo->fFree = (0 != cbSize);
        pSpisInfo->pvData = pvParam;
        pSpisInfo->uiAction = uiAction;
        pSpisInfo->uiParam = uiParam;
        pSpisInfo->fWinIni = fWinIni;
        pSpisInfo->pDimmedWindow = pDimmedWindow;
        // Spawning thread is responsible for addref dimmed window, but not releasing
        // that is the repsonsibility of the spawned thread
        if (pSpisInfo->pDimmedWindow)
        {
            pSpisInfo->pDimmedWindow->AddRef();
        }

        if (pSpisInfo->fFree)
        {
            pSpisInfo->pvData = LocalAlloc(LPTR, cbSize);
            if (!pSpisInfo->pvData)
            {
                pSpisInfo->pvData = pvParam;
                fAsyncOK = FALSE;
                pSpisInfo->fFree = FALSE;
            }
            else
            {
                CopyMemory(pSpisInfo->pvData, pvParam, cbSize);
            }
        }

        if (fAsyncOK)
            SPICreateThread(SystemParametersInfoAsync_WorkerThread, (void *)pSpisInfo);
        else
            SystemParametersInfoAsync_WorkerThread((void *)pSpisInfo);
    }
}


HRESULT GetCurrentUserCustomName(LPWSTR pszDisplayName, DWORD cchSize)
{
    HRESULT hr = S_OK;
#ifdef FEATURE_USECURRENTNAME_INCUSTOMTHEME
    WCHAR szUserName[MAX_PATH];
    ULONG cchUserSize = ARRAYSIZE(szUserName);

    if (GetUserNameEx(NameDisplay, szUserName, &cchUserSize))
    {
        // It succeeded, so use it.
        WCHAR szTemplate[MAX_PATH];

        LoadString(HINST_THISDLL, IDS_CURRENTTHEME_DISPLAYNAME, szTemplate, ARRAYSIZE(szTemplate));
        wnsprintf(pszDisplayName, cchSize, szTemplate, szUserName);
    }
    else
#endif // FEATURE_USECURRENTNAME_INCUSTOMTHEME
    {
        // It failed, so load "My Custom Theme".  This may happen on personal.
        LoadString(HINST_THISDLL, IDS_MYCUSTOMTHEME, pszDisplayName, cchSize);
    }

    return hr;
}


HRESULT InstallVisualStyle(IThemeManager * pThemeManager, LPCTSTR pszVisualStylePath, LPCTSTR pszVisualStyleColor, LPCTSTR pszVisualStyleSize)
{
    HRESULT hr = E_OUTOFMEMORY;
    CComVariant varTheme(pszVisualStylePath);

    if (varTheme.bstrVal)
    {
        IThemeScheme * pVisualStyle;

        hr = pThemeManager->get_schemeItem(varTheme, &pVisualStyle);
        if (SUCCEEDED(hr))
        {
            CComVariant varStyleName(pszVisualStyleColor);

            if (!varStyleName.bstrVal)
                hr = E_OUTOFMEMORY;
            else
            {
                IThemeStyle * pThemeStyle;

                hr = pVisualStyle->get_item(varStyleName, &pThemeStyle);
                if (SUCCEEDED(hr))
                {
                    CComVariant varSizeName(pszVisualStyleSize);

                    if (!varSizeName.bstrVal)
                        hr = E_OUTOFMEMORY;
                    else
                    {
                        IThemeSize * pThemeSize;

                        hr = pThemeStyle->get_item(varSizeName, &pThemeSize);
                        if (SUCCEEDED(hr))
                        {
                            hr = pThemeStyle->put_SelectedSize(pThemeSize);
                            if (SUCCEEDED(hr))
                            {
                                hr = pVisualStyle->put_SelectedStyle(pThemeStyle);
                                if (SUCCEEDED(hr))
                                {
                                    hr = pThemeManager->put_SelectedScheme(pVisualStyle);
                                }
                            }

                            pThemeSize->Release();
                        }
                    }

                    pThemeStyle->Release();
                }
            }

            pVisualStyle->Release();
        }
    }

    return hr;
}


// {B2A7FD52-301F-4348-B93A-638C6DE49229}
DEFINE_GUID(CLSID_WMPSkinMngr, 0xB2A7FD52, 0x301F, 0x4348, 0xB9, 0x3A, 0x63, 0x8C, 0x6D, 0xE4, 0x92, 0x29);

// {076F2FA6-ED30-448B-8CC5-3F3EF3529C7A}
DEFINE_GUID(IID_IWMPSkinMngr, 0x076F2FA6, 0xED30, 0x448B, 0x8C, 0xC5, 0x3F, 0x3E, 0xF3, 0x52, 0x9C, 0x7A);

HRESULT ApplyVisualStyle(LPCTSTR pszVisualStylePath, LPCTSTR pszVisualStyleColor, LPCTSTR pszVisualStyleSize)
{
    HRESULT hr = S_OK;
    HTHEMEFILE hThemeFile = NULL;
    DWORD dwFlags = 0;

    if (pszVisualStylePath)
    {
        // Load the skin
        hr = OpenThemeFile(pszVisualStylePath, pszVisualStyleColor, pszVisualStyleSize, &hThemeFile, TRUE);
        LogStatus("OpenThemeFile(%ls. %ls, %ls) returned hr=%#08lx.\r\n", pszVisualStylePath, pszVisualStyleColor, pszVisualStyleSize, hr);
    }

    if (SUCCEEDED(hr))
    {
        hr = ApplyTheme(hThemeFile, dwFlags, NULL);
        LogStatus("ApplyTheme(%hs) returned hr=%#08lx.\r\n", (hThemeFile ? "hThemeFile" : "NULL"), hr);
    }

    if (hThemeFile)
    {
        CloseThemeFile(hThemeFile);     // don't need to hold this open anymore
    }

    if (SUCCEEDED(hr))
    {
        CComBSTR bstrPath(pszVisualStylePath);

        if (pszVisualStylePath && !bstrPath)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            IWMPSkinMngr * pWMPSkinMngr;

            // Ignore failures until we are guarenteed they are in setup.
            if (SUCCEEDED(CoCreateInstance(CLSID_WMPSkinMngr, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IWMPSkinMngr, &pWMPSkinMngr))))
            {
                pWMPSkinMngr->SetVisualStyle(bstrPath);
                pWMPSkinMngr->Release();
            }
        }
    }

    return hr;
}


HRESULT GetPageByCLSID(IUnknown * punkSite, const GUID * pClsid, IPropertyBag ** ppPropertyBag)
{
    HRESULT hr = E_FAIL;

    *ppPropertyBag = NULL;
    if (punkSite)
    {
        IThemeUIPages * pThemeUI;

        hr = punkSite->QueryInterface(IID_PPV_ARG(IThemeUIPages, &pThemeUI));
        if (SUCCEEDED(hr))
        {
            IEnumUnknown * pEnumUnknown;

            hr = pThemeUI->GetBasePagesEnum(&pEnumUnknown);
            if (SUCCEEDED(hr))
            {
                IUnknown * punk;

                // This may not exit due to policy
                hr = IEnumUnknown_FindCLSID(pEnumUnknown, *pClsid, &punk);
                if (SUCCEEDED(hr))
                {
                    hr = punk->QueryInterface(IID_PPV_ARG(IPropertyBag, ppPropertyBag));
                    punk->Release();
                }

                pEnumUnknown->Release();
            }

            pThemeUI->Release();
        }
    }

    return hr;
}


DWORD QueryThemeServicesWrap(void)
{
    DWORD dwResult = QueryThemeServices();

    if (IsTSPerfFlagEnabled(TSPerFlag_NoVisualStyles))
    {
        dwResult = (dwResult & ~QTS_AVAILABLE);     // Remove the QTS_AVAILABLE flag because they are forced of because of TS Perf Flags
        LogStatus("Visual Styles Forced off because of TS Perf Flags\r\n");
    }
    LogStatus("QueryThemeServices() returned %d.  In QueryThemeServicesWrap\r\n", dwResult);

    return dwResult;
}


void PathUnExpandEnvStringsWrap(LPTSTR pszString, DWORD cchSize)
{
    TCHAR szTemp[MAX_PATH];

    StrCpyN(szTemp, pszString, ARRAYSIZE(szTemp));
    if (!PathUnExpandEnvStrings(szTemp, pszString, cchSize))
    {
        StrCpyN(pszString, szTemp, cchSize);
    }
}



void PathExpandEnvStringsWrap(LPTSTR pszString, DWORD cchSize)
{
    TCHAR szTemp[MAX_PATH];

    StrCpyN(szTemp, pszString, ARRAYSIZE(szTemp));
    if (0 == SHExpandEnvironmentStrings(szTemp, pszString, cchSize))
    {
        StrCpyN(pszString, szTemp, cchSize);
    }
}


// PERF: This API is INCREADIBLY slow so be very very careful when you use it.
BOOL EnumDisplaySettingsExWrap(LPCTSTR lpszDeviceName, DWORD iModeNum, LPDEVMODE lpDevMode, DWORD dwFlags)
{
    DEBUG_CODE(DebugStartWatch());

    BOOL fReturn = EnumDisplaySettingsEx(lpszDeviceName, iModeNum, lpDevMode, dwFlags);

    DEBUG_CODE(TraceMsg(TF_THEMEUI_PERF, "EnumDisplaySettingsEx() took Time=%lums", DebugStopWatch()));

    return fReturn;
}


#define DEFAULT_DPI             96.0f
void DPIScaleRect(RECT * pRect)
{
    HDC hdcScreen = GetDC(NULL);

    if (hdcScreen)
    {
        double dScaleX = (GetDeviceCaps(hdcScreen, LOGPIXELSX) / DEFAULT_DPI);
        double dScaleY = (GetDeviceCaps(hdcScreen, LOGPIXELSY) / DEFAULT_DPI);

#define DPI_SCALEX(nSizeX)          ((int) ((nSizeX) * dScaleX))
#define DPI_SCALEY(nSizeY)          ((int) ((nSizeY) * dScaleY))

        if ((DEFAULT_DPI != dScaleX) || (DEFAULT_DPI != dScaleY))
        {
            pRect->top = DPI_SCALEY(pRect->top);
            pRect->bottom = DPI_SCALEY(pRect->bottom);
            pRect->left = DPI_SCALEX(pRect->left);
            pRect->right = DPI_SCALEX(pRect->right);
        }

        ReleaseDC(NULL, hdcScreen);
    }

}


// We may want to move this to shlwapi
#define DEFAULT_DPI             96.0f
HBITMAP LoadBitmapAndDPIScale(HINSTANCE hInst, LPCTSTR pszBitmapName)
{
    HBITMAP hBitmap = LoadBitmap(hInst, pszBitmapName);
    HDC hdcScreen = GetDC(NULL);

    if (hdcScreen)
    {
        double dScaleX = (GetDeviceCaps(hdcScreen, LOGPIXELSX) / DEFAULT_DPI);
        double dScaleY = (GetDeviceCaps(hdcScreen, LOGPIXELSY) / DEFAULT_DPI);

#define DPI_SCALEX(nSizeX)          ((int) ((nSizeX) * dScaleX))
#define DPI_SCALEY(nSizeY)          ((int) ((nSizeY) * dScaleY))

        if ((DEFAULT_DPI != dScaleX) || (DEFAULT_DPI != dScaleY))
        {
            // We need to scale the bitmap.
            HDC hdcBitmapSrc = CreateCompatibleDC(hdcScreen);

            if (hdcBitmapSrc)
            {
                HDC hdcBitmapDest = CreateCompatibleDC(hdcScreen);

                SelectObject(hdcBitmapSrc, hBitmap);        // Put the bitmap into the source DC
                if (hdcBitmapDest)
                {
                    BITMAP bitmapInfo;

                    if (GetObject(hBitmap, sizeof(bitmapInfo), &bitmapInfo))
                    {
                        SetStretchBltMode(hdcBitmapDest, HALFTONE);

                        if (StretchBlt(hdcBitmapDest, 0, 0, DPI_SCALEX(bitmapInfo.bmWidth), DPI_SCALEY(bitmapInfo.bmHeight), hdcBitmapSrc, 0, 0, bitmapInfo.bmWidth, bitmapInfo.bmHeight, SRCCOPY))
                        {
                            HBITMAP hBitmapScaled = (HBITMAP)SelectObject(hdcBitmapSrc, NULL);        // Get the bitmap from the DC
                            if (hBitmapScaled)
                            {
                                DeleteObject(hBitmap);
                                hBitmap = hBitmapScaled;
                            }
                        }
                    }

                    DeleteDC(hdcBitmapDest);
                }

                DeleteDC(hdcBitmapSrc);
            }
        }

        ReleaseDC(NULL, hdcScreen);
    }

    return hBitmap;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\themeui\wmpapitemp.h ===
/* The WMP team should add this file to our enlistment as "wmpshell.h" soon.
   This is a place holder until they do that.
 */


/* File created by MIDL compiler version 5.01.0164 */
/* at Tue Nov 07 18:40:17 2000
 */
/* Compiler settings for .\wmpshell.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmpshell_h__
#define __wmpshell_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWMPSkinMngr_FWD_DEFINED__
#define __IWMPSkinMngr_FWD_DEFINED__
typedef interface IWMPSkinMngr IWMPSkinMngr;
#endif 	/* __IWMPSkinMngr_FWD_DEFINED__ */


#ifndef __WMPPlayAsPlaylistLauncher_FWD_DEFINED__
#define __WMPPlayAsPlaylistLauncher_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMPPlayAsPlaylistLauncher WMPPlayAsPlaylistLauncher;
#else
typedef struct WMPPlayAsPlaylistLauncher WMPPlayAsPlaylistLauncher;
#endif /* __cplusplus */

#endif 	/* __WMPPlayAsPlaylistLauncher_FWD_DEFINED__ */


#ifndef __WMPAddToPlaylistLauncher_FWD_DEFINED__
#define __WMPAddToPlaylistLauncher_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMPAddToPlaylistLauncher WMPAddToPlaylistLauncher;
#else
typedef struct WMPAddToPlaylistLauncher WMPAddToPlaylistLauncher;
#endif /* __cplusplus */

#endif 	/* __WMPAddToPlaylistLauncher_FWD_DEFINED__ */


#ifndef __WMPBurnAudioCDLauncher_FWD_DEFINED__
#define __WMPBurnAudioCDLauncher_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMPBurnAudioCDLauncher WMPBurnAudioCDLauncher;
#else
typedef struct WMPBurnAudioCDLauncher WMPBurnAudioCDLauncher;
#endif /* __cplusplus */

#endif 	/* __WMPBurnAudioCDLauncher_FWD_DEFINED__ */


#ifndef __WMPSkinMngr_FWD_DEFINED__
#define __WMPSkinMngr_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMPSkinMngr WMPSkinMngr;
#else
typedef struct WMPSkinMngr WMPSkinMngr;
#endif /* __cplusplus */

#endif 	/* __WMPSkinMngr_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IWMPSkinMngr_INTERFACE_DEFINED__
#define __IWMPSkinMngr_INTERFACE_DEFINED__

/* interface IWMPSkinMngr */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPSkinMngr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("076F2FA6-ED30-448B-8CC5-3F3EF3529C7A")
    IWMPSkinMngr : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetVisualStyle( 
            /* [in] */ BSTR bstrPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPSkinMngrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPSkinMngr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPSkinMngr __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPSkinMngr __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVisualStyle )( 
            IWMPSkinMngr __RPC_FAR * This,
            /* [in] */ BSTR bstrPath);
        
        END_INTERFACE
    } IWMPSkinMngrVtbl;

    interface IWMPSkinMngr
    {
        CONST_VTBL struct IWMPSkinMngrVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPSkinMngr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPSkinMngr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPSkinMngr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPSkinMngr_SetVisualStyle(This,bstrPath)	\
    (This)->lpVtbl -> SetVisualStyle(This,bstrPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWMPSkinMngr_SetVisualStyle_Proxy( 
    IWMPSkinMngr __RPC_FAR * This,
    /* [in] */ BSTR bstrPath);


void __RPC_STUB IWMPSkinMngr_SetVisualStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPSkinMngr_INTERFACE_DEFINED__ */



#ifndef __WMPLauncher_LIBRARY_DEFINED__
#define __WMPLauncher_LIBRARY_DEFINED__

/* library WMPLauncher */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_WMPLauncher;

EXTERN_C const CLSID CLSID_WMPPlayAsPlaylistLauncher;

#ifdef __cplusplus

class DECLSPEC_UUID("CE3FB1D1-02AE-4a5f-A6E9-D9F1B4073E6C")
WMPPlayAsPlaylistLauncher;
#endif

EXTERN_C const CLSID CLSID_WMPAddToPlaylistLauncher;

#ifdef __cplusplus

class DECLSPEC_UUID("F1B9284F-E9DC-4e68-9D7E-42362A59F0FD")
WMPAddToPlaylistLauncher;
#endif

EXTERN_C const CLSID CLSID_WMPBurnAudioCDLauncher;

#ifdef __cplusplus

class DECLSPEC_UUID("8DD448E6-C188-4aed-AF92-44956194EB1F")
WMPBurnAudioCDLauncher;
#endif

EXTERN_C const CLSID CLSID_WMPSkinMngr;

#ifdef __cplusplus


class DECLSPEC_UUID("B2A7FD52-301F-4348-B93A-638C6DE49229")
WMPSkinMngr;
#endif
#endif /* __WMPLauncher_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxbud\tests.h ===
//---------------------------------------------------------------------------
//  tests.h - tests for uxbud
//---------------------------------------------------------------------------
BOOL GetTestInfo(TESTINFO **ppTestInfo, int *piCount);
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxbud\uxbud.h ===
//---------------------------------------------------------------------------
//  uxbud.h - automated buddy tests for uxtheme.dll
//---------------------------------------------------------------------------
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
//---------------------------------------------------------------------------
typedef BOOL (*TESTPROC)();
//---------------------------------------------------------------------------
struct TESTINFO
{
    TESTPROC pfnTest;
    CHAR *pszName;
    CHAR *pszDesc;
};
//---------------------------------------------------------------------------
//---- defined by test modules ----

extern BOOL GetTestInfo(TESTINFO **ppTestInfo, int *piCount);
//---------------------------------------------------------------------------
//---- used by test modulels ----

void Output(LPCSTR pszFormat, ...);
BOOL ReportResults(BOOL fPassed, HRESULT hr, LPCWSTR pszTestName);
BOOL FileCompare(LPCWSTR pszName1, LPCWSTR pszName2);
BOOL RunCmd(LPCWSTR pszExeName, LPCWSTR pszParams, BOOL fHide, BOOL fDisplayParams,
    BOOL fWait=TRUE);
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxbud\tests.cpp ===
//---------------------------------------------------------------------------
//  tests.cpp - tests for uxbud
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "uxbud.h"
#include "tests.h"
#include "winuserp.h"
#include "wingdip.h"
//---------------------------------------------------------------------------
#define MAX_PRINT_FILE_SIZE 512
//---------------------------------------------------------------------------
int GetStockAvailCount()
{
    //---- slow but better than nothing! ----
    int iCount=0;

    HANDLE *pHandles = new HANDLE[10000];
    if (pHandles)
    {
        //---- create a bunch of stock bitmaps ----
        while (1)
        {
            HBITMAP hBitmap = CreateBitmap(1, 1, 1, 24, NULL);
            if (! hBitmap)
            {
                MessageBox(NULL, L"CreateBitmap() failed", L"bummer, man!", MB_OK);
                break;
            }

            hBitmap = SetBitmapAttributes(hBitmap, SBA_STOCK);
            if (! hBitmap)
            {
                //---- finally used up all avail stock bitmaps ----
                break;
            }

            pHandles[iCount++] = hBitmap;
        }

        //---- free a bunch of stock bitmaps ----
        for (int i=0; i < iCount; i++)
        {
            HBITMAP hBitmap = ClearBitmapAttributes((HBITMAP)pHandles[i], SBA_STOCK);
            if (! hBitmap)
            {
                MessageBox(NULL, L"SetBitmapAttributes() failed to reset stock", L"bummer, man!", MB_OK);
            }
            else
            {
                DeleteObject(hBitmap);
            }
        }
            
        delete [] pHandles;
    }
    else
    {
        MessageBox(NULL, L"cannot allocate 10K handle array", L"bummer, man!", MB_OK);
    }

    return iCount;
}
//---------------------------------------------------------------------------
BOOL ZapDir(LPCWSTR pszDirName)
{
    //---- does this guy exist? ----
    DWORD dwMask = GetFileAttributes(pszDirName);
    BOOL fExists = (dwMask != 0xffffffff);

    if (! fExists)
        return TRUE;        // not an error
    
    //---- delete all files or subdirs within the dir ----
    HANDLE hFile;
    WIN32_FIND_DATA wfd;
    BOOL   bFile = TRUE;
    WCHAR szSearchPattern[MAX_PATH];

    wsprintf(szSearchPattern, L"%s\\*.*", pszDirName);

    for (hFile=FindFirstFile(szSearchPattern, &wfd); (hFile != INVALID_HANDLE_VALUE) && (bFile);
        bFile=FindNextFile(hFile, &wfd))
    {
        if ((lstrcmp(wfd.cFileName, TEXT("."))==0) || (lstrcmp(wfd.cFileName, TEXT(".."))==0))
            continue;

        WCHAR szFullName[MAX_PATH];
        wsprintf(szFullName, L"%s\\%s", pszDirName, wfd.cFileName);

        if ((wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            if (! ZapDir(szFullName))
                return FALSE;
        }
        else
        {
            if (! DeleteFile(szFullName))
                return FALSE;
        }
    }

    FindClose(hFile);

    //---- this requires an empty dir ----
    return RemoveDirectory(pszDirName);
}
//---------------------------------------------------------------------------
BOOL TestFile(LPCWSTR pszFileName)
{
    DWORD dwMask = GetFileAttributes(pszFileName);
    BOOL fExists = (dwMask != 0xffffffff);

    Output("  TestFile(%S)=%s\n", pszFileName, (fExists) ? "true" : "false");

    return fExists;
}
//---------------------------------------------------------------------------
BOOL PrintFileContents(LPCSTR pszTitle, LPCWSTR pszFileName)
{
    HANDLE hFile = NULL;
    DWORD dw;
    CHAR szBuff[MAX_PRINT_FILE_SIZE];
    BOOL fRead = FALSE;

    //---- open files ----
    hFile = CreateFile(pszFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        goto exit;

    ReadFile(hFile, szBuff, MAX_PRINT_FILE_SIZE, &dw, NULL);
    if (! dw)
        goto exit;

    szBuff[dw] = 0;     // null terminate string
    fRead = TRUE;

    Output("  %s: %s\n", pszTitle, szBuff);

exit:
    Output("  PrintFileContents: %S (fRead=%d)\n", pszFileName, fRead);

    CloseHandle(hFile);
    return fRead;
}
//---------------------------------------------------------------------------
BOOL ErrorTester(LPCSTR pszCallTitle, HRESULT hr)
{
    WCHAR szErrBuff[2*MAX_PATH];
    HRESULT hr2;
    BOOL fGotMsg = FALSE;

    if (SUCCEEDED(hr))      
    {
        //---- error - should have FAILED ----
        Output("  Error - %s Succeeded (expected error)\n");
        goto exit;
    }

    hr2 = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr, 0, szErrBuff, ARRAYSIZE(szErrBuff), NULL);
    if (FAILED(hr2))
    {
        wsprintf(szErrBuff, L"Cannot format error=0x%x (FormatError=0x%x)", hr, hr2);
    }

    Output("  %s returned hr=0x%x, error: %S\n", pszCallTitle, hr, szErrBuff);
    fGotMsg = TRUE;
    
exit:
    return fGotMsg;
}
//---------------------------------------------------------------------------
BOOL CompareFiles(LPCWSTR pszName1, LPCWSTR pszName2)
{
    BOOL fSame = FileCompare(pszName1, pszName2);
    
    Output("  Compare(%S, %S) = %s\n", pszName1, pszName2, 
        (fSame) ? "same" : "different");

    return fSame;
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
BOOL LoadTest()
{
    Output("LoadTest\n");
    BOOL fPassed = FALSE;
    HRESULT hr = S_OK;

    //---- open and close a theme file a few times; ensure working set doesn't ----
    //---- grow much for this process or for theme service ----

    for (int i=0; i < 6; i++)
    {
        Output("  LoadTest: pass %d\n", i);
  
        //---- load the luna theme ----
        HTHEMEFILE hThemeFile;
    
        //---- use "luna.msstyles" ----
        WCHAR szName[MAX_PATH];
        GetWindowsDirectoryW(szName, MAX_PATH);
        wcscat(szName, L"\\resources\\themes\\luna\\luna.msstyles");

        //---- load for local (not global) use to avoid stock brush/bitmap issues ----
        HRESULT hr = OpenThemeFile(szName, NULL, NULL, &hThemeFile, FALSE);
        if (FAILED(hr))
            goto exit;

        hr = CloseThemeFile(hThemeFile);
        if (FAILED(hr))
            goto exit;
    }

    fPassed = TRUE;

exit:
    return ReportResults(fPassed, hr, L"LoadTest");
}
//---------------------------------------------------------------------------
BOOL ApplyTest()
{
    BOOL fPassed = FALSE;
    HTHEMEFILE hThemeFile;
    WCHAR szName[MAX_PATH];
    HRESULT hr;

    Output("ApplyTest\n");

    //---- apply "classic", "professional", and "luna" themes a few times ----

    for (int i=0; i < 3; i++)
    {
        Output("  ApplyTest: pass %d\n", i);

        //---- apply "classic" ----
        Output("    Classic\n");

        ApplyTheme(NULL, 0, NULL);
        Sleep(500);

        //---- load PROFESSIONAL theme ----
        Output("    PROFESSIONAL\n");
        
        GetWindowsDirectoryW(szName, MAX_PATH);
        wcscat(szName, L"\\resources\\themes\\professional\\professional.msstyles");

        hr = OpenThemeFile(szName, NULL, NULL, &hThemeFile, TRUE);
        if (FAILED(hr))
            goto exit;

        //---- apply PROFESSIONAL ----
        hr = ApplyTheme(hThemeFile, AT_LOAD_SYSMETRICS, NULL);
        if (FAILED(hr))
            goto exit;
        Sleep(500);

        hr = CloseThemeFile(hThemeFile);
        if (FAILED(hr))
            goto exit;

        //---- load LUNA theme ----
        Output("    LUNA\n");

        GetWindowsDirectoryW(szName, MAX_PATH);
        wcscat(szName, L"\\resources\\themes\\luna\\luna.msstyles");

        hr = OpenThemeFile(szName, NULL, NULL, &hThemeFile, TRUE);
        if (FAILED(hr))
            goto exit;

        //---- apply LUNA theme ----
        hr = ApplyTheme(hThemeFile, AT_LOAD_SYSMETRICS, NULL);
        if (FAILED(hr))
            goto exit;
        Sleep(500);

        hr = CloseThemeFile(hThemeFile);
        if (FAILED(hr))
            goto exit;

        Output("  ApplyTest: after applying Luna, StockAvailCount=%d\n", GetStockAvailCount());
    }

    fPassed = TRUE;

exit: 
    return ReportResults(fPassed, hr, L"ApplyTest");
}
//---------------------------------------------------------------------------
BOOL PackTest()
{
    BOOL fPassed = FALSE;
    WCHAR szParams[512];
    WCHAR szWinDir[MAX_PATH];
    HRESULT hr = S_OK;

    Output("PackTest\n");

    //---- unpack professional.msstyles ----
    if (! ZapDir(L"professional"))
        goto exit;

    CreateDirectory(L"professional", NULL);

    GetWindowsDirectory(szWinDir, ARRAYSIZE(szWinDir));
    wsprintf(szParams, L"/a /u %s\\resources\\themes\\professional\\professional.msstyles", szWinDir);

    //---- run unpack in "professional" subdir ----
    SetCurrentDirectory(L"professional");
    BOOL fRunOk = RunCmd(L"packthem", szParams, TRUE, FALSE);
    SetCurrentDirectory(L"..");

    if (! fRunOk)
        goto exit;

    if (! TestFile(L"professional\\default.ini"))
        goto exit;

    //---- pack it up ----
    if (! RunCmd(L"packthem", L"professional", TRUE, TRUE))
        goto exit;
    
    if (! TestFile(L"professional\\professional.msstyles"))
        goto exit;

    fPassed = TRUE;

exit:
    return ReportResults(fPassed, hr, L"PackTest");
}
//---------------------------------------------------------------------------
BOOL PackErrTest()
{
    BOOL fPassed = FALSE;
    HRESULT hr = S_OK;

    Output("PackErrTest\n");

    //---- run packthem on dir with missing "themes.ini" file ----
    if (! ZapDir(L"TestTheme"))
        goto exit;

    CreateDirectory(L"TestTheme", NULL);

    if (! RunCmd(L"packthem", L"/e TestTheme", TRUE, TRUE))
        goto exit;

    if (! TestFile(L"packthem.err"))
        goto exit;

    if (! PrintFileContents("Packthem Missing File: ", L"packthem.err"))
        goto exit;

    //---- run packthem on dir with bad syntax "themes.ini" file ----
    CopyFile(L".\\TestTheme.ini", L".\\TestTheme\\themes.ini", TRUE);

    if (! RunCmd(L"packthem", L"/e TestTheme", TRUE, TRUE))
        goto exit;

    if (! TestFile(L"packthem.err"))
        goto exit;

    if (! PrintFileContents("Packthem Bad Syntax: ", L"packthem.err"))
        goto exit;

    fPassed = TRUE;
    
exit:
    return ReportResults(fPassed, hr, L"PackErrTest");
}
//---------------------------------------------------------------------------
BOOL ApiErrTest()
{
    Output("ApiErrTest\n");

    BOOL fPassed = FALSE;
    WCHAR szErrBuff[2*MAX_PATH];
    COLORREF crValue;
    HRESULT hr;
    HTHEMEFILE hThemeFile;

    //---- GetThemeColor() with bad HTHEME ----
    hr = GetThemeColor(NULL, 1, 1, TMT_TEXTCOLOR, &crValue);
    ErrorTester("GetThemeColor()", hr);
    
    //---- OpenThemeFile() with corrupt file ----
    hr = OpenThemeFile(L"rcdll.dll", NULL, NULL, &hThemeFile, FALSE);
    ErrorTester("OpenThemeFile()", hr);

    fPassed = TRUE;
    
    return ReportResults(fPassed, hr, L"ApiErrTest");
}
//---------------------------------------------------------------------------
BOOL ImageConTest()
{
    BOOL fPassed = FALSE;
    HRESULT hr = S_OK;

    Output("ImageConTest\n");

    DeleteFile(L"image.bmp");

    if (! RunCmd(L"imagecon", L"image.png image.bmp", TRUE, TRUE))
        goto exit;

    if (! TestFile(L"image.bmp"))
        goto exit;

    fPassed = TRUE;

exit:
    return ReportResults(fPassed, hr, L"ImageConTest");
}
//---------------------------------------------------------------------------
BOOL BinaryTest()
{
    BOOL fPassed = FALSE;
    BOOL fFailed = FALSE;
    Output("BinaryTest\n");

    //---- load the professional theme ----
    HTHEMEFILE hThemeFile;

    //---- use "profesional.msstyles" ----
    WCHAR szName[MAX_PATH];
    GetWindowsDirectoryW(szName, MAX_PATH);
    wcscat(szName, L"\\resources\\themes\\professional\\professional.msstyles");

    //---- load for local (not global) use to avoid stock brush/bitmap issues ----
    HRESULT hr = OpenThemeFile(szName, NULL, NULL, &hThemeFile, FALSE);
    if (FAILED(hr))
    {
        Output("  OpenThemeFile() failed with hr=0x%x\n", hr);
        goto exit;
    }

    //---- dump out the properties to "PropDump.txt" ----
    hr = DumpLoadedThemeToTextFile(hThemeFile, L"PropDump.txt", FALSE, FALSE);
    if (FAILED(hr))
    {
        Output("  DumpLoadedThemeToTextFile() failed with hr=0x%x\n", hr);
        goto exit;
    }

    //---- compare to known good file ----
    if (! CompareFiles(L"PropDump.ok", L"PropDump.txt"))
        fFailed = TRUE;

    //---- dump out the packed object to "ObjDump.txt" ----
    hr = DumpLoadedThemeToTextFile(hThemeFile, L"ObjDump.txt", TRUE, FALSE);
    if (FAILED(hr))
    {
        Output("  DumpLoadedThemeToTextFile() failed with hr=0x%x\n", hr);
        goto exit;
    }

    //---- compare to known good file ----
    if (! CompareFiles(L"ObjDump.ok", L"ObjDump.txt"))
        fFailed = TRUE;

    if (! fFailed)
        fPassed = TRUE;

exit:
    return ReportResults(fPassed, hr, L"BinaryTest");
}
//---------------------------------------------------------------------------
WCHAR *BitmapNames[] = 
{
    L"BorderFill",
    L"BorderFill-R",
    L"ImageFile",
    L"ImageFile-R",
    L"Glyph",
    L"Glyph-R",
    L"MultiImage",
    L"MultiImage-R",
    L"Text",
    L"Text-R",
    L"Borders",
    L"Borders-R",
    L"SourceSizing",
    L"SourceSizing-R",
};
//---------------------------------------------------------------------------
BOOL DrawingTest()
{
    BOOL fPassed = FALSE;
    BOOL fFailed = FALSE;
    HRESULT hr = S_OK;

    Output("DrawingTest\n");

    //---- run "clipper -c" to produce drawing bitmaps ----
    if (! RunCmd(L"clipper", L"-c", FALSE, TRUE))
        goto exit;

    //---- compare bitmaps to known good files ----
    int iCount = ARRAYSIZE(BitmapNames);
    for (int i=0; i < iCount; i++)
    {
        WCHAR szOkName[MAX_PATH];
        WCHAR szTestName[MAX_PATH];

        wsprintf(szOkName, L"%s.bok", BitmapNames[i]);
        wsprintf(szTestName, L"%s.bmp", BitmapNames[i]);

        if (! CompareFiles(szOkName, szTestName))
            fFailed = TRUE;
    }

    if (! fFailed)
        fPassed = TRUE;

exit:
    return ReportResults(fPassed, hr, L"DrawingTest");
}
//---------------------------------------------------------------------------
TESTINFO TestInfo[] =
{
    {DrawingTest,   "drawing",  "test out low level drawing"},
    {PackTest,      "pack",     "test out theme file packing & unpacking"},
    {PackErrTest,   "packerr",  "test out err msgs from theme file packing"},
    {BinaryTest,    "binary",   "dump out text from binary theme data"},
    {LoadTest,      "load",     "test loading and unloading of theme files"},
    {ApplyTest,     "apply",    "test global loading & setting of themes"},
    {ApiErrTest,    "apierr",   "test err msgs from api calls"},
    //{ApiTest,       "api",      "test uxtheme public api"},
    //{PrivateTest,   "private",  "test private api calls"},
    {ImageConTest,  "imagecon", "test out theme file packing & unpacking"},
};    
//---------------------------------------------------------------------------
BOOL GetTestInfo(TESTINFO **ppTestInfo, int *piCount)
{
    *ppTestInfo = TestInfo;
    *piCount = ARRAYSIZE(TestInfo);

    return TRUE;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxbud\uxbud.cpp ===
//---------------------------------------------------------------------------
//  UxBud.cpp - quick cmdline test for uxtheme.dll
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "uxbud.h"
//---------------------------------------------------------------------------
BOOL fQuiet = FALSE;
HANDLE hFileOutput = NULL;

TESTINFO *pTestInfo;
int iTestCount;
//---------------------------------------------------------------------------
void Output(LPCSTR pszFormat, ...)
{
    //---- writes to both "uxbud.log" and console ----
    va_list args;
    va_start(args, pszFormat);

    //---- format caller's string ----
    CHAR szBigBuff[256];
    vsprintf(szBigBuff, pszFormat, args);

    if (hFileOutput != INVALID_HANDLE_VALUE)
    {
        //---- expand all LF to CR/LF ----
        CHAR szBuff2[512];
        CHAR *s = szBigBuff;
        CHAR *p = szBuff2;

        while (*s)
        {
            if (*s == '\n')
            {
                *p++ = '\r';
            }

            *p++ = *s++;
        }

        *p = 0;     // zero terminate szBuff2

        //---- write expanded buff to log file ----
        DWORD dw;
        WriteFile(hFileOutput, szBuff2, strlen(szBuff2), &dw, NULL);
    }
    
    if (! fQuiet)
        printf(szBigBuff);

    va_end(args);
}
//-----------------------------------------------------------------
BOOL ReportResults(BOOL fPassed, HRESULT hr, LPCWSTR pszTestName)
{
    Output("%S ", pszTestName);

    if (fPassed)
    {
        Output("PASSED\n\n");
    }
    else
    {
        if (hr == S_OK)
            hr = GetLastError();

        WCHAR szBuff[2*MAX_PATH];

        if (THEME_PARSING_ERROR(hr))
        {
            PARSE_ERROR_INFO Info = {sizeof(Info)};

            HRESULT hr2 = GetThemeParseErrorInfo(&Info);
            if (SUCCEEDED(hr2))
            {
                lstrcpy(szBuff, Info.szMsg);
            }
            else
            {
                wsprintf(szBuff, L"Unknown parsing error");
            }
        }
        else
        {
            // normal win32 error
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr, 0, szBuff, ARRAYSIZE(szBuff), NULL);
        }

        Output("FAILED [%S]\n\n", pszTestName, szBuff);
    }

    return fPassed;
}
//---------------------------------------------------------------------------
BOOL RunCmd(LPCWSTR pszExeName, LPCWSTR pszParams, BOOL fHide, BOOL fDisplayParams,
    BOOL fWait)
{
    HANDLE hInst;
    BOOL fRanOk = FALSE;

    STARTUPINFO si;
    memset(&si, 0, sizeof(si));
    si.cb = sizeof(STARTUPINFO);
    si.dwFlags = STARTF_FORCEOFFFEEDBACK;       // don't mess with our cursor

    if (fHide)
    {
        si.dwFlags |= STARTF_USESHOWWINDOW;         // hide window
        si.wShowWindow = SW_HIDE;
    }

    PROCESS_INFORMATION pi;
    TCHAR pszBuff[2*_MAX_PATH];

    if (pszParams)
        wsprintf(pszBuff, _T("%s %s"), pszExeName, pszParams);
    else
    {
        lstrcpy(pszBuff, pszExeName);
    }

    BOOL bSuccess = CreateProcess(NULL, pszBuff, NULL, NULL,
        FALSE, 0, NULL, NULL, &si, &pi);
    if (! bSuccess)
        goto exit;

    hInst = pi.hProcess;
    
    if (! hInst)
        goto exit;

    if (fWait)
    {
        //---- wait for process to terminate ----
        DWORD dwVal;
        dwVal = WaitForSingleObject(hInst, INFINITE);

        if (dwVal != WAIT_OBJECT_0)
            goto exit;

        DWORD dwExitCode;
        if (! GetExitCodeProcess(hInst, &dwExitCode))
            goto exit;

        if (dwExitCode)
            goto exit;
    }

    fRanOk = TRUE;

exit:

    if (fWait)          // being used for the test...
    {
        if (fDisplayParams)
            Output("  RunCmd: %S (ranok=%d)\n", pszBuff, fRanOk);
        else
            Output("  RunCmd: %S <params> (ranok=%d)\n", pszExeName, fRanOk);
    }

    CloseHandle(hInst);
    return fRanOk;
}
//---------------------------------------------------------------------------
BOOL TestAll()
{
    DWORD dwStartTicks = GetTickCount();

    for (int i=0; i < iTestCount; i++)
    {
        pTestInfo[i].pfnTest();
    }

    DWORD dwTicks = GetTickCount() - dwStartTicks;

    if (! fQuiet)
        printf("Total test time: %d secs\n", dwTicks/1000);

    return TRUE;
}
//---------------------------------------------------------------------------
void PrintTests()
{
    printf("available tests: \n");

    for (int i=0; i < iTestCount; i++)
    {
        printf("  %s \t(%s)\n", pTestInfo[i].pszName, pTestInfo[i].pszDesc);
    }
    
    printf("\n");
}
//---------------------------------------------------------------------------
void PrintHelp()
{
    printf("\nusage\n");
    printf("  uxbud [ <options> ] \n\n");

    printf("UxBud will run a set of quick tests to verify basic \"uxtheme.dll\"\n");
    printf("functionality.  If no options are specified, one pass over the normal\n");
    printf("set of tests will be run and the \"uxbud.log\" file created will be \n");
    printf("compared against the known good \"uxbud.ok\" log file.  This will result\n");
    printf("in an overall PASS or FAIL msg at the end of the uxbud run.\n\n");

    printf("<options>:\n\n");

    printf("  -r <number>    (to specify a repeat factor)\n");
    printf("  -q             (to run in quiet mode\n");
    printf("  -?             (to print this usage msg\n");
    printf("  <test>         (to run a specific test\n\n");

    PrintTests();
}
//---------------------------------------------------------------------------
BOOL HandleOptions(LPTSTR pszCmdLine, TESTPROC *ppfnTest, int *piRepeat, BOOL *pfQuiet, int *piRetVal)
{
    BOOL fContinue = TRUE;
    USES_CONVERSION;

    *piRetVal = 0;

    if ((! pszCmdLine) || (! *pszCmdLine))  // no options
        return TRUE;

    LPCSTR p = W2A(pszCmdLine);
    
    while ((p) && (*p))
    {
        while (isspace(*p))
            p++;

        //---- process switches ----
        if ((*p == '/') || (*p == '-'))    
        {
            p++;

            if ((*p == 'r') || (*p == 'R'))        // repeat factor
            {   
                p++;
                while (isspace(*p))
                    p++;

                sscanf(p, "%d", piRepeat);

                //---- skip over the scanned number ----
                while (isdigit(*p))
                    p++;
            }
            else if ((*p == 'q') || (*p == 'Q'))    // quiet mode
            {   
                p++;
                *pfQuiet = TRUE;
            }
            else if (*p == '?')        // cmdline help
            {   
                p++;
                PrintHelp();
                fContinue = FALSE;
                break;
            }

        }
        else        // test name specified
        {
            for (int i=0; i < iTestCount; i++)
            {
                if (lstrcmpiA(p, pTestInfo[i].pszName)==0)
                {
                    *ppfnTest = pTestInfo[i].pfnTest;
                    break;
                }
            }

            if (i == iTestCount)        // not found
            {
                printf("\nError - unrecognized test: %s\n\n", p);
                PrintTests();

                *piRetVal = 1;
                fContinue = FALSE;
            }

            break;
        }
    }

    return fContinue;
}
//---------------------------------------------------------------------------
BOOL FileCompare(LPCWSTR pszName1, LPCWSTR pszName2)
{
    BOOL fSame = FALSE;
    HANDLE hFile1 = NULL;
    HANDLE hFile2 = NULL;
    CHAR *pszBuff1 = NULL;
    CHAR *pszBuff2= NULL;
    DWORD dw1, dw2;

    //---- open files ----
    hFile1 = CreateFile(pszName1, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hFile1 == INVALID_HANDLE_VALUE)
        goto exit;

    hFile2 = CreateFile(pszName2, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hFile2 == INVALID_HANDLE_VALUE)
        goto exit;

    DWORD dwSize1, dwSize2;
    
    dwSize1 = GetFileSize(hFile1, NULL);
    dwSize2 = GetFileSize(hFile1, NULL);

    if ((! dwSize1) || (dwSize1 != dwSize2))
        goto exit;

    pszBuff1 = new CHAR[dwSize1];
    if (! pszBuff1)
        goto exit;

    pszBuff2 = new CHAR[dwSize1];
    if (! pszBuff2)
        goto exit;

    ReadFile(hFile1, pszBuff1, dwSize1, &dw1, NULL);
    ReadFile(hFile2, pszBuff2, dwSize1, &dw2, NULL);

    if ((dw1 != dwSize1) || (dw2 != dwSize1))
        goto exit;
    
    if (memcmp(pszBuff1, pszBuff2, dwSize1)!=0)
        goto exit;
    
    fSame = TRUE;
    
exit:
    delete [] pszBuff1;
    delete [] pszBuff2;

    CloseHandle(hFile1);
    CloseHandle(hFile2);

    return fSame;
}
//---------------------------------------------------------------------------
extern "C" WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE previnst, 
    LPTSTR pszCmdLine, int nShowCmd)
{
    //---- default run params ----
    int iRepeat = 1;
    int iRetVal = 0;
    TESTPROC pfnTest = TestAll;

    GetTestInfo(&pTestInfo, &iTestCount);

    if (! HandleOptions(pszCmdLine, &pfnTest, &iRepeat, &fQuiet, &iRetVal))
        return iRetVal;

    //---- create the log file ----
    hFileOutput = CreateFile(L"uxbud.log", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
    if (hFileOutput == INVALID_HANDLE_VALUE)
    {
        printf("\nError - could not open uxbud.log output file\n");
        return 1;
    }

	printf("\nUxBud - quick (under 3 mins) test for uxtheme.dll (version 1.0)\n\n");
    
    if (iRepeat > 1)
        Output("REPEAT FACTOR=%d\n\n", iRepeat);

    //---- run the needed test ----
    for (int i=0; i < iRepeat; i++)
    {
        if (iRepeat > 1)
            Output("TEST PASS: %d\n\n", i);

        pfnTest();
    }

    //---- close the log file ----
    if (hFileOutput)
        CloseHandle(hFileOutput);

    if ((iRepeat == 1) && (pfnTest == TestAll))     // standard run
    {
        if (FileCompare(L"uxbud.log", L"uxbud.ok"))
        {
            printf("*** UxBud PASSED ****\n");
        }
        else
        {
            printf("\nFailure detected - running: windiff uxbud.ok uxbud.log...)\n\n");
            printf("*** UxBud FAILED ****\n");

            RunCmd(L"windiff", L"uxbud.ok uxbud.log", TRUE, FALSE, FALSE);
        }
    }

	return 0;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\appinfo.h ===
//---------------------------------------------------------------------------
//  AppInfo.h - manages app-level theme information (thread safe)
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#include "ThemeFile.h"
//---------------------------------------------------------------------------
struct THEME_FILE_ENTRY
{
    int iRefCount;
    CUxThemeFile *pThemeFile;
};
//---------------------------------------------------------------------------
class CAppInfo
{
public:
    //---- public methods ----
    CAppInfo();
    ~CAppInfo();

    void ClosePreviewThemeFile();
    BOOL CompositingEnabled();
    BOOL AppIsThemed();
    BOOL CustomAppTheme();
    BOOL WindowHasTheme(HWND hwnd);
    HRESULT OpenWindowThemeFile(HWND hwnd, CUxThemeFile **ppThemeFile);
    HRESULT LoadCustomAppThemeIfFound();
    DWORD GetAppFlags();
    HWND PreviewHwnd();
    void SetAppFlags(DWORD dwFlags);
    void SetPreviewThemeFile(HANDLE handle, HWND hwnd);
    void ResetAppTheme(int iChangeNum, BOOL fMsgCheck, BOOL *pfChanged, BOOL *pfFirstMsg);
    BOOL IsSystemThemeActive();

    //---- themefile obj list ----
    HRESULT OpenThemeFile(HANDLE handle, CUxThemeFile **ppThemeFile);
    HRESULT BumpRefCount(CUxThemeFile *pThemeFile);
    void CloseThemeFile(CUxThemeFile *pThemeFile);

    //---- foreign window tracking ----
    BOOL GetForeignWindows(HWND **ppHwnds, int *piCount);
    BOOL OnWindowDestroyed(HWND hwnd);
    BOOL HasThemeChanged();

#ifdef DEBUG
void DumpFileHolders();
#endif

protected:
    //---- helper methods ----
    BOOL TrackForeignWindow(HWND hwnd);

    //---- data ----
    BOOL _fCustomAppTheme;
    CUxThemeFile *_pPreviewThemeFile;
    HWND _hwndPreview;

    CUxThemeFile *_pAppThemeFile;
    int _iChangeNum;            // last change number from theme service 
    int _iFirstMsgChangeNum;    // last change number from WM_THEMECHANGED_TRIGGER msg
    BOOL _fCompositing;
    BOOL _fFirstTimeHooksOn;
    BOOL _fNewThemeDiscovered;
    DWORD _dwAppFlags;

    //---- file list ----
    CSimpleArray<THEME_FILE_ENTRY> _ThemeEntries;

    //---- foreign window list ----
    CSimpleArray<HWND> _ForeignWindows;

    CRITICAL_SECTION _csAppInfo;
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\appinfo.cpp ===
//---------------------------------------------------------------------------
//  AppInfo.cpp - manages app-level theme information
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "info.h"
#include "AppInfo.h"
#include "sethook.h"
#include "services.h"
#include "themefile.h"
#include "tmreg.h"
#include "renderlist.h"
#include "nctheme.h"
#include "loader.h"
#include "tmutils.h"
//---------------------------------------------------------------------------
//---- values for _pThemeFile, besides valid ptrs ----

//---- if we have no windows open, we cannot track if theme is active ----
#define THEME_UNKNOWN  NULL 

//---- if we are unhooked, we no that no theme file is avail for us ----
#define THEME_NONE     (CUxThemeFile *)(-1)
//---------------------------------------------------------------------------
CAppInfo::CAppInfo()
{
    _fCustomAppTheme    = FALSE;
    _hwndPreview        = NULL;

    _pPreviewThemeFile  = NULL;

    _fFirstTimeHooksOn   = TRUE;
    _fNewThemeDiscovered = FALSE;

    _pAppThemeFile      = THEME_NONE;   // no hooks
    _iChangeNum         = -1;

    _dwAppFlags = (STAP_ALLOW_NONCLIENT | STAP_ALLOW_CONTROLS);

    //---- compositing ON by default ----
    _fCompositing       = TRUE;     
    GetCurrentUserThemeInt(THEMEPROP_COMPOSITING, TRUE, &_fCompositing);

    InitializeCriticalSection(&_csAppInfo);
}
//---------------------------------------------------------------------------
CAppInfo::~CAppInfo()
{
    ClosePreviewThemeFile();

    //---- ignore iRefCount here - force elements to be deleted ----
    for (int i=0; i < _ThemeEntries.m_nSize; i++)
    {
        _ThemeEntries[i].pThemeFile->ValidateObj();
        delete _ThemeEntries[i].pThemeFile;
    }

    DeleteCriticalSection(&_csAppInfo);
}
//---------------------------------------------------------------------------
void CAppInfo::ResetAppTheme(int iChangeNum, BOOL fMsgCheck, BOOL *pfChanged, BOOL *pfFirstMsg)
{
    CAutoCS cs(&_csAppInfo);

    if (pfChanged)
        *pfChanged = FALSE;

    //---- NOTE: "_pAppThemeFile" doesn't hold a refcount on the shared memory map file ----

    //---- this is done so that, processes who close all of their windows but continue ----
    //---- to run (like WinLogon), will not hold a refcount on old themes (since ----
    //---- they never receive any more WM_THEMECHANGED msgs until they create ----
    //---- another window.  If we were to remove HOOKS between every theme change, ----
    //---- we could use the OnHooksDisableld code to remove the theme file hold ----
    //---- but design is to let hooks stay ON why we apply and unapply themes. ----

    if ((iChangeNum == -1) || (_iChangeNum != iChangeNum) || (_fNewThemeDiscovered))
    {
        //---- new change number for this process ----
        if (HOOKSACTIVE())
            _pAppThemeFile = THEME_UNKNOWN;
        else
            _pAppThemeFile = THEME_NONE;

        Log(LOG_TMCHANGE, L"ResetAppTheme - CHANGE: iChangeNum=0x%x, _pAppThemeFile=%d", 
            iChangeNum, _pAppThemeFile);
        
        _iChangeNum = iChangeNum;
        _fNewThemeDiscovered = FALSE;

        //---- update caller's info ----
        if (pfChanged)
            *pfChanged = TRUE;
    }

    if (fMsgCheck)      
    {
        *pfFirstMsg = FALSE;

        if ((iChangeNum != -1) && (_iFirstMsgChangeNum != iChangeNum))
        {
            //---- new WM_THEMECHANGED_TRIGGER msg for this process ----
            _iFirstMsgChangeNum = iChangeNum;

            //---- update caller's info ----
            *pfFirstMsg = TRUE;
        }
    }
}
//---------------------------------------------------------------------------
BOOL CAppInfo::HasThemeChanged()
{
    CAutoCS cs(&_csAppInfo);

    BOOL fChanged = _fNewThemeDiscovered;
   _fNewThemeDiscovered = FALSE;

    return fChanged;
}
//---------------------------------------------------------------------------
void CAppInfo::ClosePreviewThemeFile()
{
    CAutoCS cs(&_csAppInfo);

    if (_pPreviewThemeFile)
    {
        CloseThemeFile(_pPreviewThemeFile);
        _pPreviewThemeFile = NULL;
    }

    _hwndPreview = NULL;
}
//---------------------------------------------------------------------------
BOOL CAppInfo::CompositingEnabled()
{
    CAutoCS cs(&_csAppInfo);

    return (_fCompositing);
}
//---------------------------------------------------------------------------
HRESULT CAppInfo::LoadCustomAppThemeIfFound()
{
    CAutoCS cs(&_csAppInfo);
    CCurrentUser hkeyCurrentUser(KEY_READ);

    RESOURCE HKEY hklm = NULL;
    HTHEMEFILE hThemeFile = NULL;
    HRESULT hr = S_OK;
    int code32;

    if (! _fFirstTimeHooksOn)
        goto exit;

     _fFirstTimeHooksOn = FALSE;

    //---- see if this app has custom theme ----
    WCHAR szCustomKey[2*MAX_PATH];
    wsprintf(szCustomKey, L"%s\\%s\\%s", THEMEMGR_REGKEY, 
        THEMEPROP_CUSTOMAPPS, g_szProcessName);

    //---- open hkcu ----
    code32 = RegOpenKeyEx(hkeyCurrentUser, szCustomKey, 0, KEY_READ, &hklm);
    if (code32 != ERROR_SUCCESS)       
        goto exit;

    //---- read the "DllValue" value ----
    WCHAR szDllName[MAX_PATH];
    hr = RegistryStrRead(hklm, THEMEPROP_DLLNAME, szDllName, ARRAYSIZE(szDllName));
    if (FAILED(hr))
        goto exit;

    //---- read the "color" value ----
    WCHAR szColorName[MAX_PATH];
    hr = RegistryStrRead(hklm, THEMEPROP_COLORNAME, szColorName, ARRAYSIZE(szColorName));
    if (FAILED(hr))
        *szColorName = 0;

    //---- read the "size" value ----
    WCHAR szSizeName[MAX_PATH];
    hr = RegistryStrRead(hklm, THEMEPROP_SIZENAME, szSizeName, ARRAYSIZE(szSizeName));
    if (FAILED(hr))
        *szSizeName = 0;

    Log(LOG_TMCHANGE, L"Custom app theme found: %s, %s, %s", szDllName, szColorName, szSizeName);

    hr = ::OpenThemeFile(szDllName, szColorName, szSizeName, &hThemeFile, FALSE);
    if (FAILED(hr))
        goto exit;

    _fCustomAppTheme = TRUE;

    //---- tell every window in our process that theme has changed ----
    hr = ApplyTheme(hThemeFile, AT_PROCESS, NULL);
    if (FAILED(hr))
        goto exit;

exit:
    if (FAILED(hr))
    {
        if (hThemeFile)
            ::CloseThemeFile(hThemeFile);
    }

    if (hklm)
        RegCloseKey(hklm);
    return hr;
}
//---------------------------------------------------------------------------
BOOL CAppInfo::AppIsThemed()
{
    CAutoCS cs(&_csAppInfo);

    return HOOKSACTIVE();
}
//---------------------------------------------------------------------------
BOOL CAppInfo::CustomAppTheme()
{
    CAutoCS cs(&_csAppInfo);

    return _fCustomAppTheme;
}
//---------------------------------------------------------------------------
BOOL CAppInfo::IsSystemThemeActive()
{
    HANDLE handle;
    BOOL fActive = FALSE;

    HRESULT hr = CThemeServices::GetGlobalTheme(&handle);
    if (SUCCEEDED(hr))
    {
        if (handle)
        {
            fActive = TRUE;
            CloseHandle(handle);
        }
    }

    return fActive;
}
//---------------------------------------------------------------------------
BOOL CAppInfo::WindowHasTheme(HWND hwnd)
{
    //---- keep this logic in sync with "OpenWindowThemeFile()" ----
    CAutoCS cs(&_csAppInfo);

    BOOL fHasTheme = FALSE;

    if (HOOKSACTIVE())
    {
        //---- check for preview window match ----
        if ((ISWINDOW(hwnd)) && (ISWINDOW(_hwndPreview)))
        {
            if ((hwnd == _hwndPreview) || (IsChild(_hwndPreview, hwnd)))
            {
                if (_pPreviewThemeFile)
                    fHasTheme = TRUE;
            }
        }

        //---- if not preview, just use app theme file ----
        if ((! fHasTheme) && (_pAppThemeFile != THEME_NONE))
        {
            fHasTheme = TRUE;
        }
    }

    return fHasTheme;
}
//---------------------------------------------------------------------------
HRESULT CAppInfo::OpenWindowThemeFile(HWND hwnd, CUxThemeFile **ppThemeFile)
{
    //---- keep this logic in sync with "WindowHasTheme()" ----

    HRESULT hr = S_OK;
    CUxThemeFile *pThemeFile = NULL;
    CAutoCS cs(&_csAppInfo);

    if (hwnd)
        TrackForeignWindow(hwnd);

    if (HOOKSACTIVE())
    {
        //---- check for preview window match ----
        if ((ISWINDOW(hwnd)) && (ISWINDOW(_hwndPreview)))
        {
            if ((hwnd == _hwndPreview) || (IsChild(_hwndPreview, hwnd)))
            {
                if (_pPreviewThemeFile)
                {
                    //---- bump ref count ----
                    hr = BumpRefCount(_pPreviewThemeFile);
                    if (FAILED(hr))
                        goto exit;

                    pThemeFile = _pPreviewThemeFile;
                }
            }
        }

        //---- if not preview, just use app theme file ----
        if ((! pThemeFile) && (_pAppThemeFile != THEME_NONE))
        {
            if (_pAppThemeFile == THEME_UNKNOWN || !_pAppThemeFile->IsReady())      
            {
                HANDLE handle = NULL;

                hr = CThemeServices::GetGlobalTheme(&handle);
                if (FAILED(hr))
                    goto exit;

                Log(LOG_TMCHANGE, L"New App Theme handle=0x%x", handle);

                if (handle)
                {
                    //---- get a shared CUxThemeFile object for the handle ----
                    hr = OpenThemeFile(handle, &pThemeFile);
                    if (FAILED(hr))
                    {
                        // Since it's the global theme, no need to clean stock objects
                        CloseHandle(handle);
                        goto exit;
                    }

                    //---- set our app theme file ----
                    _pAppThemeFile = pThemeFile;

                    //---- update our cached change number to match ----
                    _iChangeNum = GetLoadIdFromTheme(_pAppThemeFile);
                    _fNewThemeDiscovered = TRUE;
                }           
            }
            else
            {
                //---- bump ref count ----
                hr = BumpRefCount(_pAppThemeFile);
                if (FAILED(hr))
                    goto exit;

                pThemeFile = _pAppThemeFile;
            }
        }
    }

exit:
    if (pThemeFile)
    {
        *ppThemeFile = pThemeFile;
    }
    else
    {
        hr = MakeError32(ERROR_NOT_FOUND);   
    }

    return hr;
}
//---------------------------------------------------------------------------
DWORD CAppInfo::GetAppFlags()
{
    CAutoCS cs(&_csAppInfo);

    return _dwAppFlags;
}
//---------------------------------------------------------------------------
void CAppInfo::SetAppFlags(DWORD dwFlags)
{
    CAutoCS cs(&_csAppInfo);

    _dwAppFlags = dwFlags;
}
//---------------------------------------------------------------------------
void CAppInfo::SetPreviewThemeFile(HANDLE handle, HWND hwnd)
{
    CAutoCS cs(&_csAppInfo);

    ClosePreviewThemeFile();

    //---- set new file ----
    if (handle)
    {
        HRESULT hr = OpenThemeFile(handle, &_pPreviewThemeFile);
        if (FAILED(hr))
        {
            // We don't own the handle, so no clean up
            Log(LOG_ALWAYS, L"Failed to add theme file to list");
            _pPreviewThemeFile = NULL;
        }
    }

    _hwndPreview = hwnd;
}
//---------------------------------------------------------------------------
HWND CAppInfo::PreviewHwnd()
{
    CAutoCS cs(&_csAppInfo);

    return _hwndPreview;
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
// If we fail, dont return a theme file and let the caller clean up
//---------------------------------------------------------------------------
HRESULT CAppInfo::OpenThemeFile(HANDLE handle, CUxThemeFile **ppThemeFile)
{
    CAutoCS autoCritSect(&_csAppInfo);
    CUxThemeFile *pFile = NULL;
    HRESULT hr = S_OK;

    BOOL fGotit = FALSE;

    if (! handle)
    {
        hr = MakeError32(ERROR_INVALID_HANDLE);
        goto exit;
    }

    for (int i=0; i < _ThemeEntries.m_nSize; i++)
    {
        THEME_FILE_ENTRY *pEntry = &_ThemeEntries[i];

        pEntry->pThemeFile->ValidateObj();

        if (pEntry->pThemeFile->_hMemoryMap == handle)
        {
            pEntry->iRefCount++;
            fGotit = TRUE;
            *ppThemeFile = pEntry->pThemeFile;
            break;
        }
    }

    if (! fGotit)
    {
        pFile = new CUxThemeFile;
        if (! pFile)
        {
            hr = MakeError32(E_OUTOFMEMORY);
            goto exit;
        }

        hr = pFile->OpenFromHandle(handle);
        if (FAILED(hr))
        {
            goto exit;
        }

        THEME_FILE_ENTRY entry = {1, pFile};

        if (! _ThemeEntries.Add(entry))
        {
            hr = MakeError32(E_OUTOFMEMORY);
            goto exit;
        }

        pFile->ValidateObj();
        *ppThemeFile = pFile;
    }

exit:
    if ((FAILED(hr)) && (pFile))
    {
        delete pFile;
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CAppInfo::BumpRefCount(CUxThemeFile *pThemeFile)
{
    HRESULT hr = S_OK;
    CAutoCS autoCritSect(&_csAppInfo);
 
    pThemeFile->ValidateObj();

    BOOL fGotit = FALSE;

    for (int i=0; i < _ThemeEntries.m_nSize; i++)
    {
        THEME_FILE_ENTRY *pEntry = &_ThemeEntries[i];

        pEntry->pThemeFile->ValidateObj();

        if (pEntry->pThemeFile == pThemeFile)
        {
            pEntry->iRefCount++;
            fGotit = TRUE;
            break;
        }
    }

    if (! fGotit)
        hr = MakeError32(ERROR_NOT_FOUND);

    return hr;
}
//---------------------------------------------------------------------------
void CAppInfo::CloseThemeFile(CUxThemeFile *pThemeFile)
{
    CAutoCS autoCritSect(&_csAppInfo);
 
    BOOL fGotit = FALSE;

    pThemeFile->ValidateObj();

    for (int i=0; i < _ThemeEntries.m_nSize; i++)
    {
        THEME_FILE_ENTRY *pEntry = &_ThemeEntries[i];

        pEntry->pThemeFile->ValidateObj();

        if (pEntry->pThemeFile == pThemeFile)
        {
            pEntry->iRefCount--;
            fGotit = TRUE;

            if (! pEntry->iRefCount)
            {
                //---- clear app themefile? ----
                if (pEntry->pThemeFile == _pAppThemeFile)
                {
                    _pAppThemeFile = THEME_UNKNOWN;
                }
                
                delete pEntry->pThemeFile;
                _ThemeEntries.RemoveAt(i);
            }

            break;
        }
    }

    if (! fGotit)
        Log(LOG_ERROR, L"Could not find ThemeFile in list: 0x%x", pThemeFile);
}
//---------------------------------------------------------------------------
#ifdef DEBUG
void CAppInfo::DumpFileHolders()
{
    CAutoCS autoCritSect(&_csAppInfo);

    if (LogOptionOn(LO_TMHANDLE))
    {
        int iCount = _ThemeEntries.m_nSize;

        if (! iCount)
        {
            Log(LOG_TMHANDLE, L"---- No CUxThemeFile objects ----");
        }
        else
        {
            Log(LOG_TMHANDLE, L"---- Dump of %d CUxThemeFile objects ----", iCount);

            for (int i=0; i < _ThemeEntries.m_nSize; i++)
            {
                THEME_FILE_ENTRY *pEntry = &_ThemeEntries[i];
                pEntry->pThemeFile->ValidateObj();

                if (pEntry->pThemeFile)
                {
                    CUxThemeFile *tf = pEntry->pThemeFile;
                    THEMEHDR *th = (THEMEHDR *)tf->_pbThemeData;

                    Log(LOG_TMHANDLE, L"CUxThemeFile[%d]: refcnt=%d, memfile=%d",
                        i, pEntry->iRefCount, th->iLoadId);
                }
            }
        }
    }
}
#endif
//---------------------------------------------------------------------------
BOOL CAppInfo::TrackForeignWindow(HWND hwnd)
{
    CAutoCS autoCritSect(&_csAppInfo);

    WCHAR szDeskName[MAX_PATH] = {0};
    BOOL fForeign = TRUE;

    //---- get desktop name for window ----
    if (GetWindowDesktopName(hwnd, szDeskName, ARRAYSIZE(szDeskName)))
    {
        if (AsciiStrCmpI(szDeskName, L"default")==0)
        {
            fForeign = FALSE;
        }
    }

    if (fForeign)
    {
        BOOL fNeedToAdd = TRUE;

        //---- see if we already know about this window ----
        for (int i=0; i < _ForeignWindows.m_nSize; i++)
        {
            if (_ForeignWindows[i] == hwnd)
            {
                fNeedToAdd = FALSE;
                break;
            }
        }

        if (fNeedToAdd)
        {
            if (_ForeignWindows.Add(hwnd))
            {
                //Log(LOG_TMHANDLE, L"**** ADDED Foreign Window: hwnd=0x%x, desktop=%s ****", hwnd, szDeskName);
            }
            else
            {
                Log(LOG_TMHANDLE, L"Could not add foreign window=0x%x to tracking list", hwnd);
            }
        }
    }

    return fForeign;
}
//---------------------------------------------------------------------------
BOOL CAppInfo::OnWindowDestroyed(HWND hwnd)
{
    CAutoCS autoCritSect(&_csAppInfo);

    BOOL fFound = FALSE;

    //---- remove from the foreign list, if present ----
    for (int i=0; i < _ForeignWindows.m_nSize; i++)
    {
        if (_ForeignWindows[i] == hwnd)
        {
            _ForeignWindows.RemoveAt(i);

            fFound = TRUE;
            //Log(LOG_TMHANDLE, L"**** REMOVED Foreign Window: hwnd=0x%x", hwnd);
            break;
        }
    }

    //---- see if preview window went away ----
    if ((_hwndPreview) && (hwnd == _hwndPreview))
    {
        ClosePreviewThemeFile();
    }


    return fFound;
}
//---------------------------------------------------------------------------
BOOL CAppInfo::GetForeignWindows(HWND **ppHwnds, int *piCount)
{
    CAutoCS autoCritSect(&_csAppInfo);

    //---- note: we don't see window creates (OpenThemeData) and  ----
    //---- destroys (WM_NCDESTROY) when hooks are off; therefore ----
    //---- this data may be incomplete.  hopefully, vtan or USER ----
    //---- can give us a more reliable way to enumerate windows ----
    //---- on secured desktops ----

    //---- validate windows in list, from last to first ----
    int i = _ForeignWindows.m_nSize;
    while (--i >= 0)
    {
        if (! IsWindow(_ForeignWindows[i]))
        {
            _ForeignWindows.RemoveAt(i);
        }
    }

    BOOL fOk = FALSE;
    int iCount = _ForeignWindows.m_nSize;

    if (iCount)
    {
        //---- allocate memory to hold window list ----
        HWND *pHwnds = new HWND[iCount];
        if (pHwnds)
        {
            //---- copy windows to caller's new list ----
            for (int i=0; i < iCount; i++)
            {
                pHwnds[i] = _ForeignWindows[i];
            }

            *ppHwnds = pHwnds;
            *piCount = iCount;
            fOk = TRUE;
        }
    }

    return fOk;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\bmpcache.h ===
//---------------------------------------------------------------------------
//  BmpCache.cpp - single bitmap/hdc cache object for uxtheme
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
class CBitmapCache
{
public:
    //---- public methods ----
    CBitmapCache();
    ~CBitmapCache();

    HBITMAP AcquireBitmap(HDC hdc, int iWidth, int iHeight);
    void ReturnBitmap();

protected:
    //---- data ----
    HBITMAP _hBitmap;
    int _iWidth;
    int _iHeight;

    CRITICAL_SECTION _csBitmapCache;
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\borderfill.cpp ===
//---------------------------------------------------------------------------
//  BorderFill.cpp - implements the drawing API for bgtype = BorderFill
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "Render.h"
#include "Utils.h"
#include "gradient.h"
#include "tmutils.h"
#include "rgn.h"
#include "BorderFill.h"
#include "CacheList.h"
#include "gradient.h"
#include "drawhelp.h"
//---------------------------------------------------------------------------
HRESULT CBorderFill::PackProperties(CRenderObj *pRender, BOOL fNoDraw, int iPartId, int iStateId)
{
    memset(this, 0, sizeof(CBorderFill));     // allowed because we have no vtable
    _eBgType = BT_BORDERFILL;

    //---- save off partid, stateid for debugging ----
    _iSourcePartId = iPartId;
    _iSourceStateId = iStateId;

    if (fNoDraw)
    {
        //---- this is used to fake a bgtype=none object ----
        _fNoDraw = TRUE;
    }
    else
    {
        //---- get border type ----
        if (FAILED(pRender->GetEnumValue(iPartId, iStateId, TMT_BORDERTYPE, (int *)&_eBorderType)))
            _eBorderType = BT_RECT;  // TODO: Make Zero the default when no bordertype is specified.

        //---- get border color ----
        if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_BORDERCOLOR, &_crBorder)))
            _crBorder = RGB(0, 0, 0);

        //---- get border size ----
        if (FAILED(pRender->GetInt(iPartId, iStateId, TMT_BORDERSIZE, &_iBorderSize)))
            _iBorderSize = 1; // TODO: Make Zero the default when no bordersize is specified.

        if (_eBorderType == BT_ROUNDRECT)
        {
            //---- get round rect width ----
            if (FAILED(pRender->GetInt(iPartId, iStateId, TMT_ROUNDCORNERWIDTH, &_iRoundCornerWidth)))
                _iRoundCornerWidth = 80;

            //---- get round rect height ----
            if (FAILED(pRender->GetInt(iPartId, iStateId, TMT_ROUNDCORNERHEIGHT, &_iRoundCornerHeight)))
                _iRoundCornerHeight = 80;
        }

        //---- get fill type ----
        if (FAILED(pRender->GetEnumValue(iPartId, iStateId, TMT_FILLTYPE, (int *)&_eFillType)))
            _eFillType = FT_SOLID;

        if (_eFillType == FT_SOLID)
        {
            //---- get fill color ----
            if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_FILLCOLOR, &_crFill)))
                _crFill = RGB(255, 255, 255);
        }
        else if (_eFillType == FT_TILEIMAGE)
        {
            _iDibOffset = pRender->GetValueIndex(iPartId, iStateId, TMT_DIBDATA);

            if (_iDibOffset == -1)      // not found
                _iDibOffset = 0;
        }
        else            // one of the graident filltypes
        {
            _iGradientPartCount = 0;
            GRADIENTPART gpParts[5];        // max is 5 for now

            for (int i=0; i < ARRAYSIZE(gpParts); i++)
            { 
                COLORREF crPart;
                if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_GRADIENTCOLOR1+i, &crPart)))
                    break;

                int iPartRatio;
                if (FAILED(pRender->GetInt(iPartId, iStateId, TMT_GRADIENTRATIO1+i, &iPartRatio)))
                    iPartRatio = 0;

                _crGradientColors[_iGradientPartCount] = crPart;
                _iGradientRatios[_iGradientPartCount] = iPartRatio;

                _iGradientPartCount++;
            }
        }

        //---- ContentMargins ----
        if (FAILED(pRender->GetMargins(NULL, iPartId, iStateId, TMT_CONTENTMARGINS, NULL, 
            &_ContentMargins)))
        {
            _ContentMargins.cxLeftWidth = _iBorderSize;
            _ContentMargins.cxRightWidth = _iBorderSize;
            _ContentMargins.cyTopHeight = _iBorderSize;
            _ContentMargins.cyBottomHeight = _iBorderSize;
        }
    }

    return S_OK;
}
//---------------------------------------------------------------------------
BOOL CBorderFill::KeyProperty(int iPropId)
{
    BOOL fKey = FALSE;

    switch (iPropId)
    {
        case TMT_BGTYPE:
        case TMT_BORDERSIZE:
        case TMT_ROUNDCORNERWIDTH:
        case TMT_ROUNDCORNERHEIGHT:
        case TMT_GRADIENTRATIO1:
        case TMT_GRADIENTRATIO2:
        case TMT_GRADIENTRATIO3:
        case TMT_GRADIENTRATIO4:
        case TMT_GRADIENTRATIO5:
        //case TMT_IMAGEFILE:       // borrowed from imagefile
        case TMT_CONTENTMARGINS:
        case TMT_BORDERCOLOR:
        case TMT_FILLCOLOR:
        case TMT_GRADIENTCOLOR1:
        case TMT_GRADIENTCOLOR2:
        case TMT_GRADIENTCOLOR3:
        case TMT_GRADIENTCOLOR4:
        case TMT_GRADIENTCOLOR5:
        case TMT_BORDERTYPE:
        case TMT_FILLTYPE:
            fKey = TRUE;
            break;
    }

    return fKey;
}
//---------------------------------------------------------------------------
void CBorderFill::DumpProperties(CSimpleFile *pFile, BYTE *pbThemeData, BOOL fFullInfo)
{
    if (fFullInfo)
        pFile->OutLine(L"Dump of CBorderFill at offset=0x%x", (BYTE *)this - pbThemeData);
    else
        pFile->OutLine(L"Dump of CBorderFill");
    
    pFile->OutLine(L"  _eBgType=%d, _fNoDraw=%d", _eBgType, _fNoDraw);

    pFile->OutLine(L"  _eBorderType=%d, _iBorderSize=%d, _crBorder=0x%08x",
        _eBorderType, _iBorderSize, _crBorder);

    pFile->OutLine(L"  _iRoundCornerWidth=%d, _iRoundCornerHeight=%d",
        _iRoundCornerWidth, _iRoundCornerHeight);

    if (fFullInfo)
    {
        pFile->OutLine(L"  _eFillType=%d, _iDibOffset=%d, _crFill=0x%08x",
            _eFillType, _iDibOffset, _crFill);
    }
    else
    {
        pFile->OutLine(L"  _eFillType=%d, _crFill=0x%08x",
            _eFillType, _crFill);
    }
    
    pFile->OutLine(L"  _ContentMargins=%d, %d, %d, %d", 
        _ContentMargins.cxLeftWidth, _ContentMargins.cxRightWidth,
        _ContentMargins.cyTopHeight, _ContentMargins.cyBottomHeight);

    pFile->OutLine(L"  _iGradientPartCount=%d", _iGradientPartCount);

    for (int i=0; i < _iGradientPartCount; i++)
    {
        pFile->OutLine(L"  _crGradientColors[%d]=0x%08x, _iGradientRatios[%d]=%d",
            i, _iGradientRatios[i], i, _iGradientRatios[i]);
    }
}
//---------------------------------------------------------------------------
HRESULT CBorderFill::DrawComplexBackground(CRenderObj *pRender, HDC hdcOrig, 
    const RECT *pRect, BOOL fGettingRegion, BOOL fBorder, BOOL fContent, 
        OPTIONAL const RECT *pClipRect)
{
    CSaveClipRegion scrOrig;
    HRESULT hr = S_OK;

    bool fGradient = false;
    int iWidth;
    int iHeight;

    //---- pen & brush should proceed hdc so auto-delete happens in correct order ----
    CAutoGDI<HPEN> hPen;
    CAutoGDI<HBRUSH> hBrush;
    CAutoDC hdc(hdcOrig);

    CMemoryDC memoryDC;

    //---- draw border first (along with simple fills) ----
    BOOL fHavePath = FALSE;

    int width = WIDTH(*pRect);
    int height = HEIGHT(*pRect);

    if (pClipRect)      // use GDI clipping for complex cases
    {
        //---- get previous clipping region (for restoring at end) ----
        hr = scrOrig.Save(hdc);
        if (FAILED(hr))
            goto exit;

        //---- add "pClipRect" to the GDI clipping region ----
        int iRetVal = IntersectClipRect(hdc, pClipRect->left, pClipRect->top,
            pClipRect->right, pClipRect->bottom);
        if (iRetVal == ERROR)
        {
            hr = MakeErrorLast();
            goto exit;
        }
    }

    if ((fBorder) && (_iBorderSize))
    {
        hPen = CreatePen(PS_SOLID | PS_INSIDEFRAME, _iBorderSize, _crBorder);
        if (! hPen)
        {
            hr = MakeErrorLast();
            goto exit;
        }
    }


    if (fContent)
    {
        if (_eFillType == FT_SOLID)
        {
            hBrush = CreateSolidBrush(_crFill);
            if (! hBrush)
            {
                hr = MakeErrorLast();
                goto exit;
            }
        }
        else if (_eFillType == FT_TILEIMAGE)
        {
#if 0
            HBITMAP hBitmap = NULL;


            //---- don't return on error - will default to NULL brush below ----
            HRESULT hr = pRender->GetBitmap(hdc, _iImageFileOffset, iPartId, iStateId, &hBitmap);
            if (FAILED(hr))
                goto exit;

            //Log("TileImage: GetBitmap() returns hr=0x%x, hBitmap=0x%x", hr, hBitmap);

            hBrush = CreatePatternBrush(hBitmap);
            Log(LOG_TM, L"TileImage: CreatePatternBrush() returns hBrush=0x%x, Error=0x%x", hBrush, GetLastError());

            pRender->ReturnBitmap(hBitmap);
            if (! hBrush)
            {
                hr = MakeErrorLast();
                goto exit;
            }
#endif
        }
        else
            fGradient = true;
    }

    if (fGettingRegion)
        fGradient = false;

    if (! hBrush)       // no brush wanted
        hBrush = (HBRUSH)GetStockObject(NULL_BRUSH);

    if (! hPen)         // no pen wanted
        hPen = (HPEN)GetStockObject(NULL_PEN);

    hdc.SelectPen(hPen);
    hdc.SelectBrush(hBrush);

    if (_eBorderType == BT_RECT)
    {
        if (_iBorderSize > 0)
        {
            //---- no need to create a path for region in this case ----
            Rectangle(hdc, pRect->left, pRect->top, pRect->right, pRect->bottom);
        }
        else
        {
            FillRect(hdc, pRect, hBrush);
        }
    }
    else if (_eBorderType == BT_ROUNDRECT)
    {
        int iEllipHeight = (_iRoundCornerHeight*height)/100;
        int iEllipWidth = (_iRoundCornerWidth*width)/100;

        RoundRect(hdc, pRect->left, pRect->top, pRect->right, pRect->bottom, 
            iEllipHeight, iEllipWidth);

        if (fGradient)      // create a path of the border
        {
            BeginPath(hdc);
            RoundRect(hdc, pRect->left, pRect->top, pRect->right, pRect->bottom, 
                iEllipHeight, iEllipWidth);
            EndPath(hdc);

            fHavePath = TRUE;
        }
    }
    else        //  if (_eBorderType == BT_ELLIPSE)
    {
        Ellipse(hdc, pRect->left, pRect->top, pRect->right, pRect->bottom);

        if (fGradient)      // create a path of the border
        {
            BeginPath(hdc);
            Ellipse(hdc, pRect->left, pRect->top, pRect->right, pRect->bottom);
            EndPath(hdc);

            fHavePath = TRUE;
        }
    }

    if (! fGradient)       // we're done
        goto exit;

    //---- draw gradient fill within the border drawn above ----

    //---- shrink rect to subtract border ----
    RECT rect;
    SetRect(&rect, pRect->left, pRect->top, pRect->right, pRect->bottom);

    rect.left += _iBorderSize;
    rect.top += _iBorderSize;

    rect.right -= _iBorderSize;
    rect.bottom -= _iBorderSize;

    iWidth = WIDTH(rect);
    iHeight = HEIGHT(rect);

    hr = memoryDC.OpenDC(hdc, iWidth, iHeight);
    if (FAILED(hr))
        goto exit;

    //---- paint our bounding rect into dcBitmap with our gradient ----
    RECT rect2;
    SetRect(&rect2, 0, 0, iWidth, iHeight);

    GRADIENTPART gpParts[5];        // max is 5 for now

    //---- get gradient colors & ratios ----
    for (int i=0; i < _iGradientPartCount; i++)
    { 
        COLORREF crPart = _crGradientColors[i];

        gpParts[i].Color.bRed = RED(crPart);
        gpParts[i].Color.bGreen = GREEN(crPart);
        gpParts[i].Color.bBlue = BLUE(crPart);
        gpParts[i].Color.bAlpha = 255;

        gpParts[i].Ratio = (BYTE)_iGradientRatios[i];
    };

    if (_eFillType == FT_RADIALGRADIENT)
    {
        PaintGradientRadialRect(memoryDC, rect2, _iGradientPartCount, gpParts);
    }
    else if (_eFillType == FT_VERTGRADIENT)
    {
        PaintVertGradient(memoryDC, rect2, _iGradientPartCount, gpParts);
    }
    else            //  if (_eFillType == FT_HORZGRADIENT)
    {
        PaintHorzGradient(memoryDC, rect2, _iGradientPartCount, gpParts);
    }


    if (fHavePath)
    {
        CSaveClipRegion scrCurrent;
        hr = scrCurrent.Save(hdc);       // save current clip region
        if (FAILED(hr))
            goto exit;

        //---- select our shape as the clipping region in normal hdc ----
        SelectClipPath(hdc, RGN_AND);
        
        //---- blt our gradient into the shape-clipped rect into the normal hdc ----
        BitBlt(hdc, rect.left, rect.top, iWidth, iHeight, memoryDC, 0, 0, SRCCOPY);

        scrCurrent.Restore(hdc);     // restore current clip region
    }
    else
    {
        //---- blt our gradient into the shape-clipped rect into the normal hdc ----
        BitBlt(hdc, rect.left, rect.top, iWidth, iHeight, memoryDC, 0, 0, SRCCOPY);
    }

exit:
    scrOrig.Restore(hdc);        // restore clipping region 

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CBorderFill::DrawBackground(CRenderObj *pRender, HDC hdcOrig, 
    const RECT *pRect, OPTIONAL const DTBGOPTS *pOptions)
{
    HRESULT hr = S_OK;

    //---- options ----
    DWORD dwOptionFlags = 0;
    BOOL fBorder = TRUE;
    BOOL fContent = TRUE;
    BOOL fGettingRegion = FALSE;
    const RECT *pClipRect = NULL;

    if (pOptions)
    {
        dwOptionFlags = pOptions->dwFlags;

        if (dwOptionFlags & DTBG_CLIPRECT)
            pClipRect = &pOptions->rcClip;

        if (dwOptionFlags & DTBG_OMITBORDER)
            fBorder = FALSE;

        if (dwOptionFlags & DTBG_OMITCONTENT)
            fContent = FALSE;

        if (dwOptionFlags & DTBG_COMPUTINGREGION)
            fGettingRegion = TRUE;
    }

    //---- optimize for perf-sensitive paths thru here ----
    if (_fNoDraw)   
    {
        //---- nothing to do ----
    }
    else if ((_eFillType == FT_SOLID) && (_eBorderType == BT_RECT)) // solid rectangle
    {
        if (! _iBorderSize)         // no border case
        {
            if (fContent)
            {
                //---- clip, if needed ----
                RECT rcContent = *pRect;
                if (pClipRect)
                    IntersectRect(&rcContent, &rcContent, pClipRect);

                //---- fastest solid rect ----
                COLORREF crOld = SetBkColor(hdcOrig, _crFill);
                ExtTextOut(hdcOrig, 0, 0, ETO_OPAQUE, &rcContent, NULL, 0, NULL);
        
                //---- restore old color ----
                SetBkColor(hdcOrig, crOld);
            }
        }
        else                    // border case
        {
            COLORREF crOld = GetBkColor(hdcOrig);   

            //---- draw clipped borders ----
            if (fBorder)
            {
                RECT rcLine;

                SetBkColor(hdcOrig, _crBorder);

                //---- draw LEFT line ----
                SetRect(&rcLine, pRect->left, pRect->top, pRect->left+_iBorderSize, 
                    pRect->bottom);

                if (pClipRect)
                    IntersectRect(&rcLine, &rcLine, pClipRect);

                ExtTextOut(hdcOrig, 0, 0, ETO_OPAQUE, &rcLine, NULL, 0, NULL);

                //---- draw RIGHT line ----
                SetRect(&rcLine, pRect->right-_iBorderSize, pRect->top, pRect->right, 
                    pRect->bottom);

                if (pClipRect)
                    IntersectRect(&rcLine, &rcLine, pClipRect);

                ExtTextOut(hdcOrig, 0, 0, ETO_OPAQUE, &rcLine, NULL, 0, NULL);

                //---- draw TOP line ----
                SetRect(&rcLine, pRect->left, pRect->top, pRect->right, 
                    pRect->top+_iBorderSize);

                if (pClipRect)
                    IntersectRect(&rcLine, &rcLine, pClipRect);

                ExtTextOut(hdcOrig, 0, 0, ETO_OPAQUE, &rcLine, NULL, 0, NULL);

                //---- draw BOTTOM line ----
                SetRect(&rcLine, pRect->left, pRect->bottom-_iBorderSize, pRect->right, 
                    pRect->bottom);

                if (pClipRect)
                    IntersectRect(&rcLine, &rcLine, pClipRect);

                ExtTextOut(hdcOrig, 0, 0, ETO_OPAQUE, &rcLine, NULL, 0, NULL);
            }
            
            //---- remove borders from rect to draw content ----
            if (fContent)
            {
                RECT rcContent = *pRect;
                rcContent.left += _iBorderSize;
                rcContent.right -= _iBorderSize;
                rcContent.top += _iBorderSize;
                rcContent.bottom -= _iBorderSize;

                if (pClipRect)
                    IntersectRect(&rcContent, &rcContent, pClipRect);

                //---- fastest solid rect ----
                SetBkColor(hdcOrig, _crFill);
                ExtTextOut(hdcOrig, 0, 0, ETO_OPAQUE, &rcContent, NULL, 0, NULL);
            }

            //---- restore old color ----
            SetBkColor(hdcOrig, crOld);
        }
    }
    else           // all other cases
    {
        hr = DrawComplexBackground(pRender, hdcOrig, pRect, fGettingRegion,
            fBorder, fContent, pClipRect);
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CBorderFill::GetBackgroundRegion(CRenderObj *pRender, OPTIONAL HDC hdc, 
    const RECT *pRect, HRGN *pRegion)
{
    HRESULT hr;

    //---- see if it even has a transparent part ----
    if (! IsBackgroundPartiallyTransparent())
    {
        //---- return the bounding rect as the region ----
        HRGN hrgn = CreateRectRgn(pRect->left, pRect->top,
            pRect->right, pRect->bottom);

        if (! hrgn)
            return MakeErrorLast();

        *pRegion = hrgn;
        return S_OK;
    }

    //---- create a memory dc/bitmap to draw info ----
    CMemoryDC hdcMemory;

    //---- use maximum drawing values as size of DC ----
    hr = hdcMemory.OpenDC(NULL, RECTWIDTH(pRect), RECTHEIGHT(pRect));
    if (FAILED(hr))
        return hr;

    BOOL fOK = BeginPath(hdcMemory);
    if (! fOK)
        return MakeErrorLast();

    DTBGOPTS Opts = {sizeof(Opts), DTBG_COMPUTINGREGION};

    hr = DrawBackground(pRender, hdcMemory, pRect, &Opts);
    if (FAILED(hr))
        return hr;

    fOK = EndPath(hdcMemory);
    if (! fOK)
        return MakeErrorLast();

    HRGN hrgn = PathToRegion(hdcMemory);
    if (! hrgn)
        return MakeErrorLast();

    *pRegion = hrgn;
    return S_OK;
}  
//---------------------------------------------------------------------------
BOOL CBorderFill::IsBackgroundPartiallyTransparent()
{
    return ((_eBorderType != BT_RECT) || _fNoDraw);
}
//---------------------------------------------------------------------------
HRESULT CBorderFill::HitTestBackground(CRenderObj *pRender, OPTIONAL HDC hdc,
    DWORD dwHTFlags, const RECT *pRect, HRGN hrgn, POINT ptTest, OUT WORD *pwHitCode)
{
    MARGINS margins;
    GetContentMargins(pRender, hdc, &margins);
    *pwHitCode = HitTestRect( dwHTFlags, pRect, margins, ptTest );
    return S_OK;
}
//---------------------------------------------------------------------------
void CBorderFill::GetContentMargins(CRenderObj *pRender, OPTIONAL HDC hdc, MARGINS *pMargins)
{
    *pMargins = _ContentMargins;

    //---- adjust for DPI scaling ----
#if 0
    int iDcDpi;

    if (DpiDiff(hdc, &iDcDpi)))
    {
        pMargins->cxLeftWidth = DpiScale(pMargins->cxLeftWidth, iDcDpi);
        pMargins->cxRightWidth = DpiScale(pMargins->cxRightWidth, iDcDpi);
        pMargins->cyTopHeight = DpiScale(pMargins->cyTopHeight, iDcDpi);
        pMargins->cyBottomHeight = DpiScale(pMargins->cyBottomHeight, iDcDpi);
    }
#endif
}
//---------------------------------------------------------------------------
HRESULT CBorderFill::GetBackgroundContentRect(CRenderObj *pRender, OPTIONAL HDC hdc, 
    const RECT *pBoundingRect, RECT *pContentRect)
{
    MARGINS margins;
    GetContentMargins(pRender, hdc, &margins);

    pContentRect->left = pBoundingRect->left + margins.cxLeftWidth;
    pContentRect->top = pBoundingRect->top + margins.cyTopHeight;

    pContentRect->right = pBoundingRect->right - margins.cxRightWidth;
    pContentRect->bottom = pBoundingRect->bottom - margins.cyBottomHeight;

    return S_OK; 
}
//---------------------------------------------------------------------------
HRESULT CBorderFill::GetBackgroundExtent(CRenderObj *pRender, OPTIONAL HDC hdc, 
    const RECT *pContentRect, RECT *pExtentRect)
{
    MARGINS margins;
    GetContentMargins(pRender, hdc, &margins);

    pExtentRect->left = pContentRect->left - margins.cxLeftWidth;
    pExtentRect->top = pContentRect->top-+ margins.cyTopHeight;

    pExtentRect->right = pContentRect->right + margins.cxRightWidth;
    pExtentRect->bottom = pContentRect->bottom + margins.cyBottomHeight;

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CBorderFill::GetPartSize(HDC hdc, THEMESIZE eSize, SIZE *psz)
{
    HRESULT hr = S_OK;

    if (eSize == TS_MIN)
    {
        psz->cx = max(1, _iBorderSize*2); 
        psz->cy = max(1, _iBorderSize*2);
    }
    else if (eSize == TS_TRUE)        
    {
        psz->cx = _iBorderSize*2 + 1; 
        psz->cy = _iBorderSize*2 + 1;
    }
    else
    {
        hr = MakeError32(E_INVALIDARG);
    }

    return hr;
} 
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\blackrect.cpp ===
//---------------------------------------------------------------------------
//    blackrect.cpp - special code for debugging the infamous black rect
//                    problem.  not compiled; keep around until we fix this
//                    problem.
//---------------------------------------------------------------------------
HRESULT CRenderObj::CreateBitmapFromData(HDC hdc, int iDibOffset, OUT HBITMAP *phBitmap)
{
    RESOURCE HDC hdcTemp = NULL;
    RESOURCE HBITMAP hBitmap = NULL;
    HRESULT hr = S_OK;

    BYTE *pDibData = (BYTE *)(_pbThemeData + iDibOffset);
    BITMAPINFOHEADER *pBitmapHdr;
    pBitmapHdr = (BITMAPINFOHEADER *)pDibData;

    BOOL fAlphaChannel;
    fAlphaChannel = (pBitmapHdr->biBitCount == 32);

    if (! hdc)
    {
        hdcTemp = GetWindowDC(NULL);
        if (! hdcTemp)
        {
            Log(LOG_ERROR, L"GetWindowDC() failed in CreateBitmapFromData");
            hr = MakeErrorLast();
            goto exit;
        }

        hdc = hdcTemp;
    }

    //---- create the actual bitmap ----
    //---- if using alpha channel, we must use a DIB ----
    if (fAlphaChannel)
    {
        void *pv;
        hBitmap = CreateDIBSection(hdc, (BITMAPINFO *)pBitmapHdr, DIB_RGB_COLORS, 
            &pv, NULL, 0);

        //Log(LOG_TM, L"CreateDIBSection() returned hBitmap=0x%x, lasterr=0x%x", hBitmap, GetLastError());
    }
    else
    {
        hBitmap = CreateCompatibleBitmap(hdc, pBitmapHdr->biWidth, pBitmapHdr->biHeight);

        //Log(LOG_TM, L"CreateCompatibleBitmap() returned hBitmap=0x%x, lasterr=0x%x", hBitmap, GetLastError());
    }

    if (! hBitmap)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    int iSetVal;

#if 1          
    //---- SetDIBits() can take unaligned data, right? ----
    iSetVal = SetDIBits(hdc, hBitmap, 0, pBitmapHdr->biHeight, DIBDATA(pBitmapHdr), (BITMAPINFO *)pBitmapHdr,
        DIB_RGB_COLORS);
#else           
    //---- ensure all is DWORD aligned for SetDIBits() call ----
    BITMAPINFOHEADER AlignedHdr;
    int iBytesPerPixel, iRawBytes, iBytesPerRow, iTotalBytes;
    BYTE *pbAlignedBits;

    iBytesPerPixel = pBitmapHdr->biBitCount/8;      // bitcount will be 24 or 32
    iRawBytes = pBitmapHdr->biWidth * iBytesPerPixel;
    iBytesPerRow = 4*((iRawBytes+3)/4);
    iTotalBytes = pBitmapHdr->biHeight * iBytesPerRow;

    pbAlignedBits = new BYTE[iTotalBytes];
    if (! pbAlignedBits)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    memcpy(pbAlignedBits, DIBDATA(pBitmapHdr), iTotalBytes);

    AlignedHdr = *pBitmapHdr;
    Log(LOG_TM, L"Calling SetDIBits() with BITMAPINFOHEADER and bits DWORD aligned");

    iSetVal = SetDIBits(hdc, hBitmap, 0, AlignedHdr.biHeight, pbAlignedBits, (BITMAPINFO *)&AlignedHdr,
        DIB_RGB_COLORS);

    delete [] pbAlignedBits;
#endif

    //Log(LOG_TM, L"SetDIBits() returned iSetVal=%d, lasterr=0x%x", iSetVal, GetLastError());

#if 0           // #ifdef LOGGING
    if ((pBitmapHdr->biWidth == 16) && (pBitmapHdr->biHeight == 16))        // problem bitmap we are debugging
    {
        const int len = 3*16*16;
        DWORD pbNewBits[16*16];             // aligned, quadwords (when we only use 3 bytes) to make GetDIBits() happy
        BITMAPINFOHEADER NewHdr = *pBitmapHdr;

        int iGetVal;
        iGetVal = GetDIBits(hdc, hBitmap, 0, pBitmapHdr->biHeight, pbNewBits, (LPBITMAPINFO)&NewHdr, DIB_RGB_COLORS);

        Log(LOG_TM, L"GetDIBits() returned iGetVal=%d, lasterr=0x%x", iGetVal, GetLastError());
        
        if (iGetVal)
        {
            BYTE *bOrig = DIBDATA(pBitmapHdr);
            BYTE *bNew = (BYTE *)pbNewBits;

            for (int b=0; b < len; b++)
            {
                if (*bOrig != *bNew)
                {
                    Log(LOG_TM, L"old/new bitmap bytes do not match: offset=%d, bOrig=0x%x, bNew=0x%x", 
                        b, bOrig, bNew);
                    DEBUG_BREAK;
                    break;
                }
                bOrig++;
                bNew++;
            }
        }
    }
#endif

    if (! iSetVal)
    {
        hr = MakeErrorLast();
        goto exit;
    }
        
    *phBitmap = hBitmap;

exit:
    if (hdcTemp)
        ReleaseDC(NULL, hdcTemp);

    if (FAILED(hr))
    {
        if (hBitmap)
            DeleteObject(hBitmap);
    }

    return hr;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\borderfill.h ===
//---------------------------------------------------------------------------
//  BorderFill.h - implements the drawing API for bgtype = BorderFill
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#include "DrawBase.h"
//---------------------------------------------------------------------------
class CRenderObj;       // forward
class CSimpleFile;      // forward
//---------------------------------------------------------------------------
//    Note: draw objects like CBorderFill cannot have virtual methods
//          since they reside in the shared memory map file.
//---------------------------------------------------------------------------
class CBorderFill : public CDrawBase
{
public:
    //---- loader methods ----
    HRESULT PackProperties(CRenderObj *pRender, BOOL fNoDraw, int iPartId, int iStateId);
    
    static BOOL KeyProperty(int iPropId);

    void DumpProperties(CSimpleFile *pFile, BYTE *pbThemeData, BOOL fFullInfo);

    //---- drawing/measuring methods ----
    HRESULT DrawBackground(CRenderObj *pRender, HDC hdcOrig, const RECT *pRect, 
        OPTIONAL const DTBGOPTS *pOptions);

    HRESULT GetBackgroundRegion(CRenderObj *pRender, OPTIONAL HDC hdc, const RECT *pRect, 
        HRGN *pRegion);

    BOOL IsBackgroundPartiallyTransparent();

    HRESULT HitTestBackground(CRenderObj *pRender, OPTIONAL HDC hdc,
        DWORD dwHTFlags, const RECT *pRect, HRGN hrgn, POINT ptTest, OUT WORD *pwHitCode);

    HRESULT GetBackgroundContentRect(CRenderObj *pRender, OPTIONAL HDC hdc, 
        const RECT *pBoundingRect, RECT *pContentRect);

    HRESULT GetBackgroundExtent(CRenderObj *pRender, OPTIONAL HDC hdc, 
        const RECT *pContentRect, RECT *pExtentRect);

    HRESULT GetPartSize(HDC hdc, THEMESIZE eSize, SIZE *psz);

    //---- helper methods ----
    void GetContentMargins(CRenderObj *pRender, OPTIONAL HDC hdc, MARGINS *pMargins);

    HRESULT DrawComplexBackground(CRenderObj *pRender, HDC hdcOrig, 
        const RECT *pRect, BOOL fGettingRegion, BOOL fBorder, BOOL fContent, 
        OPTIONAL const RECT *pClipRect);

public:
    //---- general ----
    BOOL _fNoDraw;              // this is used for bgtype=none

    //---- border ----
    BORDERTYPE _eBorderType;
    COLORREF _crBorder;
    int _iBorderSize;
    int _iRoundCornerWidth;
    int _iRoundCornerHeight;

    //---- fill ----
    FILLTYPE _eFillType;
    COLORREF _crFill;
    int _iDibOffset; 

    //---- margins ----
    MARGINS _ContentMargins;
    
    //---- gradients ----
    int _iGradientPartCount;
    COLORREF _crGradientColors[5];
    int _iGradientRatios[5];

    //---- id ----
    int _iSourcePartId; 
    int _iSourceStateId;
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\bmpcache.cpp ===
//---------------------------------------------------------------------------
//  BmpCache.cpp - single bitmap/hdc cache object for uxtheme
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "BmpCache.h"
//---------------------------------------------------------------------------
CBitmapCache::CBitmapCache()
{
    _hBitmap = NULL;
    
    _iWidth = 0;
    _iHeight = 0;

    InitializeCriticalSection(&_csBitmapCache);
}
//---------------------------------------------------------------------------
CBitmapCache::~CBitmapCache()
{
    if (_hBitmap)
    {
        DeleteObject(_hBitmap);
    }

    DeleteCriticalSection(&_csBitmapCache);
}
//---------------------------------------------------------------------------
HBITMAP CBitmapCache::AcquireBitmap(HDC hdc, int iWidth, int iHeight)
{
    EnterCriticalSection(&_csBitmapCache);

    if ((iWidth > _iWidth) || (iHeight > _iHeight) || (! _hBitmap))
    {
        if (_hBitmap)
        {
            DeleteObject(_hBitmap);

            _hBitmap = NULL;
            _iWidth = 0;
            _iHeight = 0;
        }
        
        //---- create new bitmap & hdc ----
        struct {
            BITMAPINFOHEADER    bmih;
            ULONG               masks[3];
        } bmi;

        bmi.bmih.biSize = sizeof(bmi.bmih);
        bmi.bmih.biWidth = iWidth;
        bmi.bmih.biHeight = iHeight;
        bmi.bmih.biPlanes = 1;
        bmi.bmih.biBitCount = 32;
        bmi.bmih.biCompression = BI_BITFIELDS;
        bmi.bmih.biSizeImage = 0;
        bmi.bmih.biXPelsPerMeter = 0;
        bmi.bmih.biYPelsPerMeter = 0;
        bmi.bmih.biClrUsed = 3;
        bmi.bmih.biClrImportant = 0;
        bmi.masks[0] = 0xff0000;    // red
        bmi.masks[1] = 0x00ff00;    // green
        bmi.masks[2] = 0x0000ff;    // blue

        _hBitmap = CreateDIBitmap(hdc, &bmi.bmih, CBM_CREATEDIB , NULL, (BITMAPINFO*)&bmi.bmih, 
            DIB_RGB_COLORS);

        if (_hBitmap)
        {
            _iWidth = iWidth;
            _iHeight = iHeight;
        }
    }
    
    return _hBitmap;
}
//---------------------------------------------------------------------------
void CBitmapCache::ReturnBitmap()
{
    LeaveCriticalSection(&_csBitmapCache);
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\cache.cpp ===
//---------------------------------------------------------------------------
//  Cache.cpp - implements the CRenderCache object
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "Cache.h"
#include "Info.h"
#include "tmutils.h"
//---------------------------------------------------------------------------
CRenderCache::CRenderCache(CRenderObj *pRender, __int64 iUniqueId)
{
    strcpy(_szHead, "rcache"); 
    strcpy(_szTail, "end");

    _pRenderObj = pRender;
    _iUniqueId = iUniqueId;

    _hFont = NULL;

    _plfFont = NULL;
}
//---------------------------------------------------------------------------
CRenderCache::~CRenderCache()
{
    //---- delete bitmaps ----
    int cnt = _BitmapCache.GetSize();
    for (int i=0; i < cnt; i++)
    {
        Log(LOG_CACHE, L"DELETE cache bitmap: 0x%x", _BitmapCache[i].hBitmap);
        DeleteObject(_BitmapCache[i].hBitmap);
    }

    //---- delete font ----
    if (_hFont)
        DeleteObject(_hFont);

    strcpy(_szHead, "deleted"); 
}
//---------------------------------------------------------------------------
HRESULT CRenderCache::GetBitmap(int iDibOffset, OUT HBITMAP *phBitmap)
{
    HRESULT hr = S_OK;
    int cnt = _BitmapCache.GetSize();

    for (int i=0; i < cnt; i++)
    {
        BITMAPENTRY *be = &_BitmapCache[i];

        if (be->iDibOffset == iDibOffset)
        {
            Log(LOG_TM, L"GetBitmap - CACHE HIT: class=%s, diboffset=%d, bitmap=0x%x", 
                SHARECLASS(_pRenderObj), be->iDibOffset, be->hBitmap);

            *phBitmap = be->hBitmap;

            goto exit;
        }
    }

    //---- no match found ----
    hr = MakeError32(ERROR_NOT_FOUND);

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CRenderCache::AddBitmap(int iDibOffset, HBITMAP hBitmap)
{
    HRESULT hr = S_OK;
    BITMAPENTRY entry;

    //---- add new entry for our part/state ----
    entry.iDibOffset = iDibOffset;
    entry.hBitmap = hBitmap;
    //entry.iRefCount = 1;            // new entry

    Log(LOG_CACHE, L"ADD cache bitmap: 0x%x", entry.hBitmap);

    if (! _BitmapCache.Add(entry))
        hr = MakeError32(E_OUTOFMEMORY);

    return hr;
}
//---------------------------------------------------------------------------
void CRenderCache::ReturnBitmap(HBITMAP hBitmap)
{
}
//---------------------------------------------------------------------------
HRESULT CRenderCache::GetScaledFontHandle(HDC hdc, LOGFONT *plfUnscaled, HFONT *phFont)
{
    HRESULT hr = S_OK;

    //---- caches one font only ----
    if ((! _plfFont) || (! FONTCOMPARE(*_plfFont, *plfUnscaled)))
    {
        Log(LOG_TM, L"Font CACHE MISS: %s", plfUnscaled->lfFaceName);

        if (_hFont)
        {
            DeleteObject(_hFont);
            _hFont = NULL;
            _plfFont = NULL;
        }

        LOGFONT lfScaled = *plfUnscaled;
        
        //---- convert to current screen dpi ----
        ScaleFontForHdcDpi(hdc, &lfScaled);

        _hFont = CreateFontIndirect(&lfScaled);
        if (! _hFont)
        {
            hr = MakeError32(E_OUTOFMEMORY);
            goto exit;
        }

        _plfFont = plfUnscaled;
    }
    else
        Log(LOG_TM, L"Font CACHE HIT");

    *phFont = _hFont;

exit:
    return hr;
}
//---------------------------------------------------------------------------
void CRenderCache::ReturnFontHandle(HFONT hFont)
{
}
//---------------------------------------------------------------------------
BOOL CRenderCache::ValidateObj()
{
    BOOL fValid = TRUE;

    //---- check object quickly ----
    if (   (! this)                         
        || (ULONGAT(_szHead) != 'cacr')     // "rcac"
        || (ULONGAT(&_szHead[4]) != 'eh')  // "he" 
        || (ULONGAT(_szTail) != 'dne'))     // "end"
    {
        Log(LOG_ERROR, L"Corrupt CRenderCache object: 0x%08x", this);
        fValid = FALSE;
    }

    return fValid;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\cache.h ===
//---------------------------------------------------------------------------
//  Cache.h - implements the CRenderCache object
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#include "Render.h"
//---------------------------------------------------------------------------
struct BITMAPENTRY      // for bitmap cache
{
    int iDibOffset;   
    HBITMAP hBitmap;
    //int iRefCount;
};
//---------------------------------------------------------------------------
class CRenderCache
{
public:
	CRenderCache(CRenderObj *pRender, __int64 iUniqueId);
    ~CRenderCache();

public:
    HRESULT GetBitmap(int iDibOffset, OUT HBITMAP *pBitmap);
    HRESULT AddBitmap(int iDibOffset, HBITMAP hBitmap);
    void ReturnBitmap(HBITMAP hBitmap);

    HRESULT GetScaledFontHandle(HDC hdc, LOGFONT *plf, HFONT *phFont);
    void ReturnFontHandle(HFONT hFont);

    BOOL ValidateObj();
    
public:
    //---- data ----
    char _szHead[8];

    CRenderObj *_pRenderObj;
    __int64 _iUniqueId;

protected:
    //---- bitmap cache ----
    CSimpleArray<BITMAPENTRY> _BitmapCache;

    //---- font cache -----
    HFONT _hFont;
    LOGFONT *_plfFont;      // just keep ptr to it in shared memory

    char _szTail[4];
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\cachelist.cpp ===
//---------------------------------------------------------------------------
//  CacheList.cpp - manages list of CRenderCache objects
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "CacheList.h"
//---------------------------------------------------------------------------
DWORD _tls_CacheListIndex = 0xffffffff;        // index to tls pObjectPool
//---------------------------------------------------------------------------
CCacheList::CCacheList()
{
    Log(LOG_CACHE, L"CCacheList: CREATED cache list for this thread");
}
//---------------------------------------------------------------------------
CCacheList::~CCacheList()
{
    for (int i=0; i < _CacheEntries.m_nSize; i++)
    {
        if (_CacheEntries[i])
            delete _CacheEntries[i];
    }

    Log(LOG_CACHE, L"~CCacheList: DELETED cache list for this thread");
}
//---------------------------------------------------------------------------
HRESULT CCacheList::GetCacheObject(CRenderObj *pRenderObj, int iSlot, CRenderCache **ppCache)
{
    static int iPassCount = 0;

    HRESULT hr = S_OK;
    CRenderCache *pCache;

    if (iSlot >= _CacheEntries.m_nSize)
    {
        hr = Resize(iSlot);
        if (FAILED(hr))
            goto exit;
    }
    
    pCache = _CacheEntries[iSlot];

    //---- is this an old object (old objects are freed on discovery) ----
    if (pCache)
    {
        BOOL fBad = (pRenderObj->_iUniqueId != pCache->_iUniqueId);
        if (! fBad)
        {
            //---- verify integrity of cache/render design ----
            if (pRenderObj != pCache->_pRenderObj)
            {
                // should never happen
                Log(LOG_ERROR, L"cache object doesn't match CRenderObj");
                fBad = TRUE;
            }
        }

        if (fBad)
        {
            Log(LOG_CACHE, L"GetCacheObject: deleting OLD OBJECT (slot=%d)", iSlot);

            delete pCache;
            pCache = NULL;
            _CacheEntries[iSlot] = NULL;
        }
    }

    //---- create an object on demand ----
    if (! pCache)
    {
        Log(LOG_CACHE, L"GetCacheObject: creating cache obj ON DEMAND (slot=%d)", iSlot);

        pCache = new CRenderCache(pRenderObj, pRenderObj->_iUniqueId);
        if (! pCache)
        {
            hr = MakeError32(E_OUTOFMEMORY);
            goto exit;
        }

        _CacheEntries[iSlot] = pCache;

        ASSERT(pRenderObj == pCache->_pRenderObj);
    }
    else
    {
        Log(LOG_CACHE, L"GetCacheObject: using EXISTING OBJ (slot=%d)", iSlot);
    }

    *ppCache = pCache;

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CCacheList::Resize(int iMaxSlotNum)
{
    HRESULT hr = S_OK;

    Log(LOG_CACHE, L"CCacheList::Resize: new MaxSlot=%d", iMaxSlotNum);

    int iOldSize = _CacheEntries.m_nSize;

    if (iMaxSlotNum >= iOldSize)
    {
        typedef CRenderCache *Entry;

        Entry *pNew = (Entry *)realloc(_CacheEntries.m_aT, 
            (iMaxSlotNum+1) * sizeof(Entry));

        if (! pNew)
            hr = MakeError32(E_OUTOFMEMORY);
        else
        {
            _CacheEntries.m_nAllocSize = iMaxSlotNum + 1;
	        _CacheEntries.m_aT = pNew;
		    _CacheEntries.m_nSize = iMaxSlotNum + 1;

            for (int i=iOldSize; i < _CacheEntries.m_nSize; i++)
                _CacheEntries[i] = NULL;
        }
    }

    return hr;
}
//---------------------------------------------------------------------------
CCacheList *GetTlsCacheList(BOOL fOkToCreate)
{
    CCacheList *pList = NULL;

    if (_tls_CacheListIndex != 0xffffffff)     // init-ed in ProcessAttach()
    {
        pList = (CCacheList *)TlsGetValue(_tls_CacheListIndex);
        if ((! pList) && (fOkToCreate))             // not yet initialized
        {
            //---- create a thread-local cache list ----
            pList = new CCacheList();
            TlsSetValue(_tls_CacheListIndex, pList);
        }
    }

    return pList;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\drawbase.h ===
//---------------------------------------------------------------------------
//    drawbase.h - base class for draw objects
//---------------------------------------------------------------------------
#pragma once

//---------------------------------------------------------------------------
class CRenderObj;       // forward
//---------------------------------------------------------------------------
class CDrawBase
{
public:
    //---- data ----
    BGTYPE _eBgType;              // all draw objects must start with this
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\drawbase.cpp ===
//---------------------------------------------------------------------------
//    drawbase.cpp - base class for draw objects
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "drawbase.h"
#include "rgn.h"
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\cachelist.h ===
//---------------------------------------------------------------------------
//  CacheList.h - manages list of CRenderCache objects
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#include "Cache.h"
//---------------------------------------------------------------------------
extern DWORD _tls_CacheListIndex;
//---------------------------------------------------------------------------
class CCacheList
{
    //---- methods ----
public:
    CCacheList();
    ~CCacheList();

    HRESULT GetCacheObject(CRenderObj *pRenderObj, int iSlot, CRenderCache **ppCache);
    HRESULT Resize(int iMaxSlot);

    //---- data ----
protected:
    CSimpleArray<CRenderCache *> _CacheEntries;
};
//---------------------------------------------------------------------------
CCacheList *GetTlsCacheList(BOOL fOkToCreate);
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\drawhelp.h ===
//---------------------------------------------------------------------------
//  DrawHelp.h - flat drawing helper routines
//---------------------------------------------------------------------------
#pragma once


//---------------------------------------------------------------------------
WORD HitTestRect(DWORD dwHTFlags, LPCRECT prc, const MARGINS& margins, const POINT& pt );
WORD HitTestTemplate(DWORD dwHTFlags, LPCRECT prc, HRGN hrgn, const MARGINS& margins, const POINT& pt );
WORD HitTest9Grid( DWORD dwHTFlags, LPCRECT prc, const MARGINS& margins, const POINT& ptTest );

// UxTheme private version of DrawEdge
HRESULT _DrawEdge(HDC hdc, const RECT *pDestRect, UINT uEdge, UINT uFlags, 
    COLORREF clrLight, COLORREF clrHighlight, COLORREF clrShadow, COLORREF clrDkShadow, COLORREF clrFill,
    OPTIONAL OUT RECT *pContentRect);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\filedump.h ===
//---------------------------------------------------------------------------
//  FileDump.h - Writes the contents of a theme file as formatted
//               text to a text file.  Used for uxbud and other testing so
//               its in both FRE and DEBUG builds.
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
class CUxThemeFile;     // forward
//---------------------------------------------------------------------------
HRESULT DumpThemeFile(LPCWSTR pszFileName, CUxThemeFile *pThemeFile, BOOL fPacked,
    BOOL fFullInfo);
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\dllmain.cpp ===
//---------------------------------------------------------------------------
//  DllMain.cpp - Dll Entry point for UxTheme DLL
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "Utils.h"
#include "sethook.h"
#include "CacheList.h"
#include "RenderList.h"
#include "info.h"
#include "themeldr.h"
#include "ninegrid2.h"
//---------------------------------------------------------------------------
BOOL ThreadStartUp()
{
    BOOL fInit = ThemeLibStartUp(TRUE);

    Log(LOG_TMSTARTUP, L"Thread startup");
    return fInit;
}
//---------------------------------------------------------------------------
BOOL ThreadShutDown()
{
    Log(LOG_TMSTARTUP, L"Thread shutdown");

    ThemeLibShutDown(TRUE);

    //---- destroy the thread-local object pool ----
    CCacheList *pList = GetTlsCacheList(FALSE);
    if (pList)
    {
        TlsSetValue(_tls_CacheListIndex, NULL);
        delete pList;
    }

    return TRUE;
}
//---------------------------------------------------------------------------
BOOL ProcessStartUp(HINSTANCE hModule)
{
    //---- don't init twice ----
    if (g_fUxthemeInitialized)
    {
        return TRUE;
    }
    
    g_hInst = hModule;

    _tls_CacheListIndex = TlsAlloc();
    if (_tls_CacheListIndex == (DWORD) -1)
        goto exit;
    
    if (!ThemeLibStartUp(FALSE))
        goto cleanup4;

    if (!GlobalsStartup())
        goto cleanup3;

    if (!ThemeHookStartup())
        goto cleanup2;

    if (!NineGrid2StartUp())
        goto cleanup1;

    // everything succeeded!
    Log(LOG_TMSTARTUP, L"Finished ProcessStartUp() (succeeded)");
    return TRUE;

cleanup1:
    ThemeHookShutdown();
cleanup2:
    GlobalsShutdown();
cleanup3:
    ThemeLibShutDown(FALSE);
cleanup4:
    TlsFree(_tls_CacheListIndex);
exit:
    // something failed
    Log(LOG_TMSTARTUP, L"Finished ProcessStartUp() (failure)");
    return FALSE;
}
//---------------------------------------------------------------------------
BOOL ProcessShutDown() 
{
    //---- beware: in case of StartUp failure, all resources may not have been allocated ----

    Log(LOG_TMSTARTUP, L"Starting ProcessShutDown()");

    ThreadShutDown();           // not called by system on last thread

    //---- process shutdown ----
    NineGrid2ShutDown();

    ThemeLibShutDown(FALSE);

    ThemeHookShutdown();
    GlobalsShutdown();

    TlsFree(_tls_CacheListIndex);
    _tls_CacheListIndex = 0xffffffff;

    return TRUE;
}
//---------------------------------------------------------------------------
BOOL APIENTRY DllMain(HINSTANCE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
    BOOL fOk = TRUE;

    switch (ul_reason_for_call) 
    {
        case DLL_PROCESS_ATTACH:
            fOk = ProcessStartUp(hModule);
            break;

        case DLL_THREAD_ATTACH:
            fOk = ThreadStartUp();
            break;

        case DLL_THREAD_DETACH:
            fOk = ThreadShutDown();
            break;

        case DLL_PROCESS_DETACH:
            fOk = ProcessShutDown();
            break;
    }

    return fOk;
} 
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\drawhelp.cpp ===
//---------------------------------------------------------------------------
//  DrawHelp.cpp - flat drawing helper routines
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "DrawHelp.h"
#include "rgn.h"

#define cxRESIZE       (ClassicGetSystemMetrics(SM_CXEDGE)+ClassicGetSystemMetrics( SM_CXSIZEFRAME ))
#define cyRESIZE       (ClassicGetSystemMetrics(SM_CYEDGE)+ClassicGetSystemMetrics( SM_CYSIZEFRAME ))
#define cxRESIZEPAD    ClassicGetSystemMetrics(SM_CXVSCROLL)
#define cyRESIZEPAD    ClassicGetSystemMetrics(SM_CYHSCROLL)

//---------------------------------------------------------------------------
typedef WORD (* HITTESTRECTPROC)(LPCRECT, int, int, const POINT&, WORD);
WORD _HitTestRectCorner( HITTESTRECTPROC, HITTESTRECTPROC, LPCRECT, 
                         int, int, int, int, const POINT&, 
                         WORD, WORD, WORD, WORD );

//---------------------------------------------------------------------------
WORD _HitTestRectLeft( 
    LPCRECT prc, int cxMargin, int cyMargin, const POINT& pt, WORD wMiss )
{
    return ((WORD)((pt.x <= (prc->left + cxMargin)) ? HTLEFT : wMiss));
}
//---------------------------------------------------------------------------
WORD _HitTestRectTop( 
    LPCRECT prc, int cxMargin, int cyMargin, const POINT& pt, WORD wMiss )
{
    return ((WORD)((pt.y <= (prc->top + cyMargin)) ? HTTOP : wMiss));
}
//---------------------------------------------------------------------------
WORD _HitTestRectRight( 
    LPCRECT prc, int cxMargin, int cyMargin, const POINT& pt, WORD wMiss )
{
    return ((WORD)((pt.x >= (prc->right - cxMargin)) ? HTRIGHT : wMiss));
}
//---------------------------------------------------------------------------
WORD _HitTestRectBottom( 
    LPCRECT prc, int cxMargin, int cyMargin, const POINT& pt, WORD wMiss )
{
    return ((WORD)((pt.y >= (prc->bottom - cyMargin)) ? HTBOTTOM : wMiss));
}
//---------------------------------------------------------------------------
WORD _HitTestRectTopLeft( 
    LPCRECT prc, int cxMargin, int cyMargin, const POINT& pt, WORD wMiss )
{
    return _HitTestRectCorner(
        _HitTestRectLeft, _HitTestRectTop, prc, 
        cxMargin, cyMargin, cxRESIZEPAD, cyRESIZEPAD,
        pt, HTTOPLEFT, HTLEFT, HTTOP, wMiss );
}
//---------------------------------------------------------------------------
WORD _HitTestRectTopRight( 
    LPCRECT prc, int cxMargin, int cyMargin, const POINT& pt, WORD wMiss )
{
    return _HitTestRectCorner( 
        _HitTestRectRight, _HitTestRectTop, prc, 
        cxMargin, cyMargin, cxRESIZEPAD, cyRESIZEPAD,
        pt, HTTOPRIGHT, HTRIGHT, HTTOP, wMiss );
}
//---------------------------------------------------------------------------
WORD _HitTestRectBottomLeft( 
    LPCRECT prc, int cxMargin, int cyMargin, const POINT& pt, WORD wMiss )
{
    return _HitTestRectCorner( 
        _HitTestRectLeft, _HitTestRectBottom, prc, 
        cxMargin, cyMargin, cxRESIZEPAD, cyRESIZEPAD,
        pt, HTBOTTOMLEFT, HTLEFT, HTBOTTOM, wMiss );
}
//---------------------------------------------------------------------------
WORD _HitTestRectBottomRight( 
    LPCRECT prc, int cxMargin, int cyMargin, const POINT& pt, WORD wMiss )
{
    return _HitTestRectCorner(
        _HitTestRectRight, _HitTestRectBottom, prc, 
        cxMargin, cyMargin, cxRESIZEPAD, cyRESIZEPAD,
        pt, HTBOTTOMRIGHT, HTRIGHT, HTBOTTOM, wMiss );
}
//---------------------------------------------------------------------------
WORD _HitTestRectCorner(
    HITTESTRECTPROC pfnX, HITTESTRECTPROC pfnY, 
    LPCRECT prc,                        // target rect
    int cxMargin, int cyMargin,         // width, height of resizing borders
    int cxMargin2, int cyMargin2,       // width, height of scrollbars
    const POINT& pt,                    // test point
    WORD wHitC, WORD wHitX, WORD wHitY, // winning hittest codes
    WORD wMiss )                        // losing hittest code
{
    WORD wRetX = pfnX( prc, cxMargin, cyMargin, pt, wMiss );
    WORD wRetY = pfnY( prc, cxMargin, cyMargin, pt, wMiss );

    if( wMiss != wRetX && wMiss != wRetY )
        return wHitC;

    if( wMiss != wRetX )
    {
        wMiss = wHitX;
        if( wMiss != pfnY( prc, cxMargin2, cyMargin2, pt, wMiss ) )
            return wHitC;
    }
    else if( wMiss != wRetY )
    {
        wMiss = wHitY;
        if( wMiss != pfnX( prc, cxMargin2, cyMargin2, pt, wMiss ) )
            return wHitC;
    }

    return wMiss;
}

//---------------------------------------------------------------------------
WORD HitTest9Grid( LPCRECT prc, const MARGINS& margins, const POINT& pt )
{
    ASSERT(PtInRect(prc,pt));

    WORD wHit =  HTCLIENT;

    //  test left side
    if( HTLEFT == _HitTestRectLeft( prc, margins.cxLeftWidth, 0, pt, wHit ) )
    {
        if( HTTOP == _HitTestRectTop( prc, 0, margins.cyTopHeight, pt, wHit ) )
            return HTTOPLEFT;
        if( HTBOTTOM == _HitTestRectBottom( prc, 0, margins.cyBottomHeight, pt, wHit ) )
            return HTBOTTOMLEFT;
        wHit = HTLEFT;
    }
    else //  test right side
    if( HTRIGHT == _HitTestRectRight( prc, margins.cxRightWidth, 0, pt, wHit ) )
    {
        if( HTTOP == _HitTestRectTop( prc, 0, margins.cyTopHeight, pt, wHit ) )
            return HTTOPRIGHT;
        if( HTBOTTOM == _HitTestRectBottom( prc, 0, margins.cyBottomHeight, pt, wHit ) )
            return HTBOTTOMRIGHT;
        wHit = HTRIGHT;
    }
    else //  test top
    if( HTTOP == _HitTestRectTop( prc, 0, margins.cyTopHeight, pt, wHit ) )
    {
        return HTTOP;
    }
    else //  test bottom
    if( HTBOTTOM == _HitTestRectBottom( prc, 0, margins.cyBottomHeight, pt, wHit ) )
    {
        return HTBOTTOM;
    }

    return wHit;
}

//---------------------------------------------------------------------------
WORD _HitTestResizingRect( DWORD dwHTFlags, LPCRECT prc, const POINT& pt, 
                           WORD w9GridHit, WORD wMiss )
{
    WORD wHit = wMiss;
    BOOL fTestLeft    = TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER_LEFT);
    BOOL fTestTop     = TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER_TOP);
    BOOL fTestRight   = TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER_RIGHT);
    BOOL fTestBottom  = TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER_BOTTOM);
    BOOL fTestCaption = TESTFLAG( dwHTFlags, HTTB_CAPTION );

    switch( w9GridHit )
    {
        case HTLEFT:
            if( fTestLeft )
            {
                //  first test for a hit in the corner resizing areas, respecting caller's option flags.
                if( (fTestTop    && (wHit = _HitTestRectTopLeft( prc, cxRESIZE, cyRESIZE, pt, wMiss )) != HTLEFT) ||
                    (fTestBottom && (wHit = _HitTestRectBottomLeft( prc, cxRESIZE, cyRESIZE, pt, wMiss )) != HTLEFT) )
                    break;
                //  failed corners, just test the resizing margin within the specified 9-grid hit seg.
                wHit = _HitTestRectLeft( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            }
            break;
        case HTTOP:
            if( fTestCaption )
                wHit = wMiss = HTCAPTION;
            
            if( fTestTop )
            {
                //  first test for a hit in the corner resizing areas, respecting caller's option flags.
                if( (fTestLeft  && (wHit = _HitTestRectTopLeft( prc, cxRESIZE, cyRESIZE, pt, wMiss )) != HTTOP) ||
                    (fTestRight && (wHit = _HitTestRectTopRight( prc, cxRESIZE, cyRESIZE, pt, wMiss )) != HTTOP) )
                    break;
                //  failed corners, just test the resizing margin within the specified 9-grid hit seg.
                wHit = _HitTestRectTop( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            }
            break;
        
        case HTRIGHT:
            if( fTestRight )
            {
                //  first test for a hit in the corner resizing areas, respecting caller's option flags.
                if( (fTestTop && (wHit = _HitTestRectTopRight( prc, cxRESIZE, cyRESIZE, pt, wMiss )) != HTRIGHT) ||
                    (fTestBottom && (wHit = _HitTestRectBottomRight( prc, cxRESIZE, cyRESIZE, pt, wMiss )) != HTRIGHT) )
                    break;
                //  failed corners, just test the resizing margin within the specified 9-grid hit seg.
                 wHit = _HitTestRectRight( prc, cxRESIZE, cyRESIZE, pt, wMiss );
                break;
            }
        
        case HTBOTTOM:
            if( fTestBottom )
            {
                //  first test for a hit in the corner resizing areas, respecting caller's option flags.
                if( (fTestLeft  && (wHit = _HitTestRectBottomLeft( prc, cxRESIZE, cyRESIZE, pt, wMiss )) != HTBOTTOM) ||
                    (fTestRight && (wHit = _HitTestRectBottomRight( prc, cxRESIZE, cyRESIZE, pt, wMiss )) != HTBOTTOM) )
                    break;
                //  failed corners, just test the resizing margin within the specified 9-grid hit seg.
                wHit = _HitTestRectBottom( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            }
            break;
        
        case HTTOPLEFT:
            if( fTestCaption )
                wHit = wMiss = HTCAPTION;
            //  first test for a resizing hit in the corner, and failing that, test the
            //  resizing margin on either side.
            if( fTestTop && fTestLeft )
                wHit = _HitTestRectTopLeft( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            else if( fTestLeft )
                wHit = _HitTestRectLeft( prc, cxRESIZE, cyRESIZE, pt, wMiss ); 
            else if( fTestTop )
                wHit = _HitTestRectTop( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            break;
        
        case HTTOPRIGHT:
            if( fTestCaption )
                wHit = wMiss = HTCAPTION;
            //  first test for a resizing hit in the corner, and failing that, test the
            //  resizing margin on either side.
            if( fTestTop && fTestRight )
                wHit = _HitTestRectTopRight( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            else if( fTestRight )
                wHit = _HitTestRectRight( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            else if( fTestTop )
                wHit = _HitTestRectTop( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            break;
        
        case HTBOTTOMLEFT:
            //  first test for a resizing hit in the corner, and failing that, test the
            //  resizing margin on either side.
            if( fTestBottom && fTestLeft )
                wHit = _HitTestRectBottomLeft( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            else if( fTestLeft )
                wHit = _HitTestRectLeft( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            else if( fTestBottom )
                wHit = _HitTestRectBottom( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            break;
        
        case HTBOTTOMRIGHT:
            //  first test for a resizing hit in the corner, and failing that, test the
            //  resizing margin on either side.
            if( fTestBottom && fTestRight )
                wHit = _HitTestRectBottomRight( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            else if( fTestRight )
                wHit = _HitTestRectRight( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            else if( fTestBottom )
                wHit = _HitTestRectBottom( prc, cxRESIZE, cyRESIZE, pt, wMiss );
            break;
    }
    return wHit;
}

//---------------------------------------------------------------------------
WORD HitTestRect(DWORD dwHTFlags, LPCRECT prc, const MARGINS& margins, const POINT& pt )
{
    WORD wHit = HTNOWHERE;
    
    if( PtInRect( prc, pt ) )
    {
        wHit = HitTest9Grid( prc, margins, pt );

        if( HTCLIENT != wHit )
        {
            if( TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER) )
            {
                WORD wMiss = HTBORDER;
                wHit = _HitTestResizingRect( dwHTFlags, prc, pt, wHit, wMiss );
            }
            else if( TESTFLAG(dwHTFlags, HTTB_CAPTION|HTTB_FIXEDBORDER) )
            {
                switch( wHit )
                {
                    case HTTOP:
                    case HTTOPLEFT:
                    case HTTOPRIGHT:
                        wHit = (WORD)(TESTFLAG(dwHTFlags, HTTB_CAPTION) ? HTCAPTION : HTBORDER);
                        break;
                    default:
                        wHit = HTBORDER;
                }                
            }

        } // !HTCLIENT
    } // PtInRect

    return wHit;
}

//---------------------------------------------------------------------------
WORD _HitTestResizingTemplate( DWORD dwHTFlags, HRGN hrgn, const POINT& pt,
                               WORD w9GridHit, WORD wMiss )
{
    WORD wHit = wMiss;
    BOOL fTestLeft    = TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER_LEFT);
    BOOL fTestTop     = TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER_TOP);
    BOOL fTestRight   = TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER_RIGHT);
    BOOL fTestBottom  = TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER_BOTTOM);
    BOOL fTestCaption = TESTFLAG( dwHTFlags, HTTB_CAPTION );
    BOOL fInsideRgn;

    switch( w9GridHit )
    {
        case HTLEFT:
            if( !fTestLeft )
            {
                return wMiss;
            }
            break;
        case HTTOP:
            if( fTestCaption )
                wMiss = HTCAPTION;

            if( !fTestTop )
            {
                return wMiss;
            }
            break;
        case HTRIGHT:
            if( !fTestRight )
            {
                return wMiss;
            }
            break;
        case HTBOTTOM:
            if( !fTestBottom )
            {
                return wMiss;
            }
            break;
        case HTTOPLEFT:
            if( fTestCaption )
                wMiss = HTCAPTION;

            if( !fTestTop || !fTestLeft )
            {
                return wMiss;
            }
            break;

        case HTTOPRIGHT:
            if( fTestCaption )
                wMiss = HTCAPTION;

            if( !fTestTop || !fTestRight )
            {
                return wMiss;
            }
            break;

        case HTBOTTOMLEFT:
            if( !fTestBottom || !fTestLeft )
            {
                return wMiss;
            }
            break;

        case HTBOTTOMRIGHT:
            if( !fTestBottom || !fTestRight )
            {
                return wMiss;
            }
            break;
    }

    fInsideRgn = PtInRegion(hrgn, pt.x, pt.y);

    if( fInsideRgn )
    {
        wHit = w9GridHit;
    }
    return wHit;
}

//---------------------------------------------------------------------------
WORD HitTestTemplate(DWORD dwHTFlags, LPCRECT prc, HRGN hrgn, const MARGINS& margins, const POINT& pt )
{
    WORD wHit = HTNOWHERE;
    
    if( PtInRect( prc, pt ) )
    {
        wHit = HitTest9Grid( prc, margins, pt );

        if( HTCLIENT != wHit )
        {
            if( TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER) )
            {
                WORD wMiss = HTBORDER;
                wHit = _HitTestResizingTemplate( dwHTFlags, hrgn, pt, wHit, wMiss );
            }
            else if( TESTFLAG(dwHTFlags, HTTB_CAPTION|HTTB_FIXEDBORDER) )
            {
                switch( wHit )
                {
                    case HTTOP:
                    case HTTOPLEFT:
                    case HTTOPRIGHT:
                        wHit = (WORD)(TESTFLAG(dwHTFlags, HTTB_CAPTION) ? HTCAPTION : HTBORDER);
                        break;
                    default:
                        wHit = HTBORDER;
                }
            }

        } // !HTCLIENT
    }
    return wHit;
}

//  --------------------------------------------------------------------------
//  FillRectClr
//
//  History:    2000-12-06  lmouton     borrowed from comctl32\v6\cutils.c
//---------------------------------------------------------------------------
void FillRectClr(HDC hdc, LPRECT prc, COLORREF clr)
{
    COLORREF clrSave = SetBkColor(hdc, clr);
    ExtTextOut(hdc,0,0,ETO_OPAQUE,prc,NULL,0,NULL);
    SetBkColor(hdc, clrSave);
}

//---------------------------------------------------------------------------
//  _DrawEdge
//
// Classic values are:
//   clrLight = 192 192 192
//   clrHighlight = 255 255 255
//   clrShadow = 128 128 128
//   clrDkShadow = 0 0 0
//   clrFill = 192 192 192
//
//  History:    2000-12-06  lmouton     borrowed from comctl32\v6\cutils.c, modified colors
//---------------------------------------------------------------------------
HRESULT _DrawEdge(HDC hdc, const RECT *pDestRect, UINT uEdge, UINT uFlags, 
    COLORREF clrLight, COLORREF clrHighlight, COLORREF clrShadow, COLORREF clrDkShadow, COLORREF clrFill,
    OUT RECT *pContentRect)
{
    if (hdc == NULL || pDestRect == NULL)
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    RECT     rc, rcD;
    UINT     bdrType;
    COLORREF clrTL = 0;
    COLORREF clrBR = 0;

    // This is were we would adjust for high DPI if the new "BF_DPISCALE" flag is specified in uFlags.
    int      cxBorder = GetSystemMetrics(SM_CXBORDER);
    int      cyBorder = GetSystemMetrics(SM_CYBORDER);
    
    //
    // Enforce monochromicity and flatness
    //    

    // if (oemInfo.BitCount == 1)
    //    uFlags |= BF_MONO;
    if (uFlags & BF_MONO)
        uFlags |= BF_FLAT;    

    CopyRect(&rc, pDestRect);

    //
    // Draw the border segment(s), and calculate the remaining space as we
    // go.
    //
    bdrType = (uEdge & BDR_OUTER);
    if (bdrType)
    {
DrawBorder:
        //
        // Get colors.  Note the symmetry between raised outer, sunken inner and
        // sunken outer, raised inner.
        //

        if (uFlags & BF_FLAT)
        {
            if (uFlags & BF_MONO)
                clrBR = (bdrType & BDR_OUTER) ? clrDkShadow : clrHighlight;
            else
                clrBR = (bdrType & BDR_OUTER) ? clrShadow: clrFill;
            
            clrTL = clrBR;
        }
        else
        {
            // 5 == HILIGHT
            // 4 == LIGHT
            // 3 == FACE
            // 2 == SHADOW
            // 1 == DKSHADOW

            switch (bdrType)
            {
                // +2 above surface
                case BDR_RAISEDOUTER:           // 5 : 4
                    clrTL = ((uFlags & BF_SOFT) ? clrHighlight : clrLight);
                    clrBR = clrDkShadow;     // 1
                    break;

                // +1 above surface
                case BDR_RAISEDINNER:           // 4 : 5
                    clrTL = ((uFlags & BF_SOFT) ? clrLight : clrHighlight);
                    clrBR = clrShadow;       // 2
                    break;

                // -1 below surface
                case BDR_SUNKENOUTER:           // 1 : 2
                    clrTL = ((uFlags & BF_SOFT) ? clrDkShadow : clrShadow);
                    clrBR = clrHighlight;      // 5
                    break;

                // -2 below surface
                case BDR_SUNKENINNER:           // 2 : 1
                    clrTL = ((uFlags & BF_SOFT) ? clrShadow : clrDkShadow);
                    clrBR = clrLight;        // 4
                    break;

                default:
                    hr = E_INVALIDARG;
            }
        }

        if FAILED(hr)
        {
            return hr;
        }

        //
        // Draw the sides of the border.  NOTE THAT THE ALGORITHM FAVORS THE
        // BOTTOM AND RIGHT SIDES, since the light source is assumed to be top
        // left.  If we ever decide to let the user set the light source to a
        // particular corner, then change this algorithm.
        //
            
        // Bottom Right edges
        if (uFlags & (BF_RIGHT | BF_BOTTOM))
        {            
            // Right
            if (uFlags & BF_RIGHT)
            {       
                rc.right -= cxBorder;
                // PatBlt(hdc, rc.right, rc.top, g_cxBorder, rc.bottom - rc.top, PATCOPY);
                rcD.left = rc.right;
                rcD.right = rc.right + cxBorder;
                rcD.top = rc.top;
                rcD.bottom = rc.bottom;

                FillRectClr(hdc, &rcD, clrBR);
            }
            
            // Bottom
            if (uFlags & BF_BOTTOM)
            {
                rc.bottom -= cyBorder;
                // PatBlt(hdc, rc.left, rc.bottom, rc.right - rc.left, g_cyBorder, PATCOPY);
                rcD.left = rc.left;
                rcD.right = rc.right;
                rcD.top = rc.bottom;
                rcD.bottom = rc.bottom + cyBorder;

                FillRectClr(hdc, &rcD, clrBR);
            }
        }
        
        // Top Left edges
        if (uFlags & (BF_TOP | BF_LEFT))
        {
            // Left
            if (uFlags & BF_LEFT)
            {
                // PatBlt(hdc, rc.left, rc.top, g_cxBorder, rc.bottom - rc.top, PATCOPY);
                rc.left += cxBorder;

                rcD.left = rc.left - cxBorder;
                rcD.right = rc.left;
                rcD.top = rc.top;
                rcD.bottom = rc.bottom; 

                FillRectClr(hdc, &rcD, clrTL);
            }
            
            // Top
            if (uFlags & BF_TOP)
            {
                // PatBlt(hdc, rc.left, rc.top, rc.right - rc.left, g_cyBorder, PATCOPY);
                rc.top += cyBorder;

                rcD.left = rc.left;
                rcD.right = rc.right;
                rcD.top = rc.top - cyBorder;
                rcD.bottom = rc.top;

                FillRectClr(hdc, &rcD, clrTL);
            }
        }
        
    }

    bdrType = (uEdge & BDR_INNER);
    if (bdrType)
    {
        //
        // Strip this so the next time through, bdrType will be 0.
        // Otherwise, we'll loop forever.
        //
        uEdge &= ~BDR_INNER;
        goto DrawBorder;
    }

    //
    // Fill the middle & clean up if asked
    //
    if (uFlags & BF_MIDDLE)    
        FillRectClr(hdc, &rc, (uFlags & BF_MONO) ? clrHighlight : clrFill);

    if ((uFlags & BF_ADJUST) && (pContentRect != NULL))
        CopyRect(pContentRect, &rc);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\gdisemu.cpp ===
// gdisemu.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#include "gdisemu.h"

// This is an example of an exported variable
//GDISEMU_API int nGdisemu=0;

int StreamCopyTile(
    HDC				hdcTarget,
    HDC				hdcSource,
	DS_COPYTILE *	cmd)
{
    RECTL *     dstRect = &cmd->rclDst;
    RECTL *     srcRect = &cmd->rclSrc;
    POINTL *    tileOrigin = &cmd->ptlOrigin;

    // brain dead for now

    LONG    tileWidth = srcRect->right - srcRect->left;
    LONG    tileHeight = srcRect->bottom - srcRect->top;
    LONG    y = dstRect->top;
    LONG    yEnd = dstRect->bottom;
    LONG    xEnd = dstRect->right;

    if(tileWidth <= 0 || tileHeight <= 0)
        return FALSE;

	if(tileOrigin->x >= tileWidth || tileOrigin->y >= tileHeight)
		return FALSE;

	LONG	sy = tileOrigin->y;

    while(y < yEnd)
    {
        LONG    dy = yEnd - y;

        if(dy > (tileHeight - sy)) dy = (tileHeight - sy);

        LONG x = dstRect->left;

		LONG sx = tileOrigin->x;

        while(x < xEnd)
        {
            LONG dx = xEnd - x;

            if(dx > (tileWidth - sx)) dx = (tileWidth - sx);

            if(!BitBlt(hdcTarget, x, y, dx, dy, hdcSource, srcRect->left + sx, srcRect->top + sy, SRCCOPY))
                return FALSE;

            x += dx;
			sx = 0;
        }

        y += dy;
		sy = 0;
    }

    return TRUE;
}

int StreamTransparentTile(
    HDC						hdcTarget,
    HDC						hdcSource,
	DS_TRANSPARENTTILE *	cmd)
{
    RECTL *     dstRect = &cmd->rclDst;
    RECTL *     srcRect = &cmd->rclSrc;
    POINTL *    tileOrigin = &cmd->ptlOrigin;

    // brain dead for now

    LONG    tileWidth = srcRect->right - srcRect->left;
    LONG    tileHeight = srcRect->bottom - srcRect->top;
    LONG    y = dstRect->top;
    LONG    yEnd = dstRect->bottom;
    LONG    xEnd = dstRect->right;

    if(tileWidth <= 0 || tileHeight <= 0)
        return FALSE;

	if(tileOrigin->x >= tileWidth || tileOrigin->y >= tileHeight)
		return FALSE;

	LONG	sy = tileOrigin->y;

    while(y < yEnd)
    {
        LONG    dy = yEnd - y;

        if(dy > (tileHeight - sy)) dy = (tileHeight - sy);

        LONG x = dstRect->left;

		LONG sx = tileOrigin->x;

        while(x < xEnd)
        {
            LONG dx = xEnd - x;

            if(dx > (tileWidth - sx)) dx = (tileWidth - sx);

            if(!GdiTransparentBlt(hdcTarget, x, y, dx, dy, hdcSource, srcRect->left + sx, srcRect->top + sy, dx, dy, cmd->crTransparentColor))
                return FALSE;

            x += dx;
			sx = 0;
        }

        y += dy;
		sy = 0;
    }

    return TRUE;
}

int StreamAlphaTile(
    HDC						hdcTarget,
    HDC						hdcSource,
	DS_ALPHATILE *			cmd)
{
    RECTL *     dstRect = &cmd->rclDst;
    RECTL *     srcRect = &cmd->rclSrc;
    POINTL *    tileOrigin = &cmd->ptlOrigin;

    // brain dead for now

    LONG    tileWidth = srcRect->right - srcRect->left;
    LONG    tileHeight = srcRect->bottom - srcRect->top;
    LONG    y = dstRect->top;
    LONG    yEnd = dstRect->bottom;
    LONG    xEnd = dstRect->right;

    if(tileWidth <= 0 || tileHeight <= 0)
        return FALSE;

	if(tileOrigin->x >= tileWidth || tileOrigin->y >= tileHeight)
		return FALSE;

	LONG	sy = tileOrigin->y;

    while(y < yEnd)
    {
        LONG    dy = yEnd - y;

        if(dy > (tileHeight - sy)) dy = (tileHeight - sy);

        LONG x = dstRect->left;

		LONG sx = tileOrigin->x;

        while(x < xEnd)
        {
            LONG dx = xEnd - x;

            if(dx > (tileWidth - sx)) dx = (tileWidth - sx);

            if(!GdiAlphaBlend(hdcTarget, x, y, dx, dy, hdcSource, srcRect->left + sx, srcRect->top + sy, dx, dy, cmd->blendFunction))
                return FALSE;

            x += dx;
			sx = 0;
        }

        y += dy;
		sy = 0;
    }

    return TRUE;
}

int StreamSolidFill(
    HDC				hdcTarget,
	DS_SOLIDFILL *	cmd)
{
	HBRUSH	hbr = CreateSolidBrush(cmd->crSolidColor);
	FillRect(hdcTarget, (RECT *) &cmd->rclDst, hbr);
	DeleteObject(hbr);

	return TRUE;
}

int StreamStretch(
    HDC				hdcTarget,
	HDC				hdcSource,
	DS_STRETCH *	cmd)
{
	StretchBlt(hdcTarget, cmd->rclDst.left,
						  cmd->rclDst.top,
						  (cmd->rclDst.right - cmd->rclDst.left),
						  (cmd->rclDst.bottom - cmd->rclDst.top),
			   hdcSource, cmd->rclSrc.left,
						  cmd->rclSrc.top,
						  (cmd->rclSrc.right - cmd->rclSrc.left),
						  (cmd->rclSrc.bottom - cmd->rclSrc.top),
						  SRCCOPY);
	return TRUE;
}

int StreamTransparentStretch(
    HDC				hdcTarget,
	HDC				hdcSource,
	DS_TRANSPARENTSTRETCH *	cmd)
{
	GdiTransparentBlt(hdcTarget, cmd->rclDst.left,
						  cmd->rclDst.top,
						  (cmd->rclDst.right - cmd->rclDst.left),
						  (cmd->rclDst.bottom - cmd->rclDst.top),
			   hdcSource, cmd->rclSrc.left,
						  cmd->rclSrc.top,
						  (cmd->rclSrc.right - cmd->rclSrc.left),
						  (cmd->rclSrc.bottom - cmd->rclSrc.top),
						  cmd->crTransparentColor);
	return TRUE;
}

int StreamAlphaStretch(
    HDC				hdcTarget,
	HDC				hdcSource,
	DS_ALPHASTRETCH *	cmd)
{
	GdiAlphaBlend(hdcTarget, cmd->rclDst.left,
						  cmd->rclDst.top,
						  (cmd->rclDst.right - cmd->rclDst.left),
						  (cmd->rclDst.bottom - cmd->rclDst.top),
			   hdcSource, cmd->rclSrc.left,
						  cmd->rclSrc.top,
						  (cmd->rclSrc.right - cmd->rclSrc.left),
						  (cmd->rclSrc.bottom - cmd->rclSrc.top),
						  cmd->blendFunction);
	return TRUE;
}

/*GDISEMU_API*/ int DrawStream(int cjIn, void * pvIn)
{
    HDC     hdcTarget = NULL;
    HDC     hdcSource = NULL;

    if(cjIn < sizeof(ULONG))
       return FALSE;

    ULONG * pul = (ULONG *) pvIn;

	// All streams should begin with DS_MAGIC
    if(*pul++ != DS_MAGIC)
        return FALSE;

    cjIn -= sizeof(ULONG);

    while(cjIn >= sizeof(ULONG))
    {
        ULONG   command = pul[0];
        int     commandSize;

        switch(command)
        {
        case DS_SETTARGETID: // set target

            commandSize = sizeof(DS_SETTARGET);

            if(cjIn < commandSize)
                return FALSE;

            hdcTarget = (HDC) pul[1];

            break;

        case DS_SETSOURCEID: // set source

            commandSize = sizeof(DS_SETSOURCE);

            if(cjIn < commandSize)
                return FALSE;

            hdcSource = (HDC) pul[1];

            break;

		case DS_SOLIDFILLID:

            commandSize = sizeof(DS_SOLIDFILL);

            if(cjIn < commandSize)
                return FALSE;

			if(!StreamSolidFill(hdcTarget, (DS_SOLIDFILL*) pul))
				return FALSE;

			break;

        case DS_COPYTILEID: // tile copy bits

            commandSize = sizeof(DS_COPYTILE);

            if(cjIn < commandSize)
                return FALSE;

            if(!StreamCopyTile(hdcTarget, hdcSource, (DS_COPYTILE*) pul))
                return FALSE;

            break;

        case DS_TRANSPARENTTILEID: // tile copy bits

            commandSize = sizeof(DS_TRANSPARENTTILE);

            if(cjIn < commandSize)
                return FALSE;

            if(!StreamTransparentTile(hdcTarget, hdcSource, (DS_TRANSPARENTTILE*) pul))
                return FALSE;

			break;

        case DS_ALPHATILEID: // tile copy bits

            commandSize = sizeof(DS_TRANSPARENTTILE);

            if(cjIn < commandSize)
                return FALSE;

            if(!StreamAlphaTile(hdcTarget, hdcSource, (DS_ALPHATILE*) pul))
                return FALSE;

            break;

        case DS_STRETCHID: // tile copy bits

            commandSize = sizeof(DS_STRETCH);

            if(cjIn < commandSize)
                return FALSE;

            if(!StreamStretch(hdcTarget, hdcSource, (DS_STRETCH*) pul))
                return FALSE;

            break;

        case DS_TRANSPARENTSTRETCHID: // tile copy bits

            commandSize = sizeof(DS_TRANSPARENTSTRETCH);

            if(cjIn < commandSize)
                return FALSE;

            if(!StreamTransparentStretch(hdcTarget, hdcSource, (DS_TRANSPARENTSTRETCH*) pul))
                return FALSE;

            break;

        case DS_ALPHASTRETCHID: // tile copy bits

            commandSize = sizeof(DS_ALPHASTRETCH);

            if(cjIn < commandSize)
                return FALSE;

            if(!StreamAlphaStretch(hdcTarget, hdcSource, (DS_ALPHASTRETCH*) pul))
                return FALSE;

            break;

        default:
            return FALSE;
        }

        cjIn -= commandSize;
        pul += commandSize / 4;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\filedump.cpp ===
//---------------------------------------------------------------------------
//  FileDump.cpp - Writes the contents of a theme file as formatted
//               text to a text file.  Used for uxbud and other testing so
//               its in both FRE and DEBUG builds.
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "Loader.h"
#include "Loader.h"
#include "borderfill.h"
#include "imagefile.h"
#include "textdraw.h"
#include "tmutils.h"
//---------------------------------------------------------------------------
int DumpType(CSimpleFile *pFile, CUxThemeFile *pThemeFile, MIXEDPTRS &u, 
    BOOL fPacked, BOOL fFullInfo)
{
    BOOL fPropDump = (! fPacked);
    UNPACKED_ENTRYHDR hdr;

    FillAndSkipHdr(u, &hdr);
    BYTE *origPd = u.pb;

    int i;

    if (fPropDump)
    {
        if (hdr.ePrimVal == TMT_DIBDATA && !fFullInfo)
        {
            pFile->OutLine(L"    type=%d, primType=%d", hdr.usTypeNum, hdr.ePrimVal);
        } 
        else
        {
            pFile->OutLine(L"    type=%d, primType=%d, len=%d", 
                hdr.usTypeNum, hdr.ePrimVal, hdr.dwDataLen);
        }
    }

    switch (hdr.ePrimVal)
    {
        case TMT_JUMPTOPARENT:
            if (fPropDump)
            {
                if (fFullInfo)
                    pFile->OutLine(L"      JumpToParent: index=%d", *u.pi);
                else
                    pFile->OutLine(L"      JumpToParent");
            }
            break;

        case TMT_PARTJUMPTABLE:
            return hdr.ePrimVal;         // let caller process data for this

        case TMT_STATEJUMPTABLE:
            return hdr.ePrimVal;         // let caller process data for this

        case TMT_STRING:
            if (fPropDump)
                pFile->OutLine(L"      String: %s", u.pc);
            break;

        case TMT_INT:
            if (fPropDump)
                pFile->OutLine(L"      Int: %d", *u.pi);
            break;

        case TMT_BOOL:
            if (fPropDump)
                pFile->OutLine(L"      Bool: %d", *u.pb);
            break;

        case TMT_COLOR:
            if (fPropDump)
            {
                int color;
                color = *u.pi;
                pFile->OutLine(L"      Color: %d, %d, %d", color & 0xff, (color >> 8) & 0xff, 
                    (color >> 16) & 0xff);
            }
            break;

        case TMT_MARGINS:
            if (fPropDump)
            {
                int vals[4];
                for (i=0; i < 4; i++)
                    vals[i] = *u.pi++;

                pFile->OutLine(L"      Margins: lw=%d, rw=%d, th=%d, bh=%d", vals[0], 
                    vals[1], vals[2], vals[3]);
            }
            break;

        case TMT_FILENAME:
            if (fPropDump)
                pFile->OutLine(L"      Filename: %s", u.pw);
            break;

        case TMT_SIZE:
            if (fPropDump)
                pFile->OutLine(L"      Size: %d", *u.pi);
            break;

        case TMT_POSITION:
            if (fPropDump)
            {
                int val1, val2;
                val1 = *u.pi++;
                val2 = *u.pi++;

                pFile->OutLine(L"      Position: x=%d, y=%d", val1, val2);
            }
            break;

        case TMT_RECT:
            if (fPropDump)
            {
                int vals[4];

                for (i=0; i < 4; i++)
                    vals[i] = *u.pi++;

                pFile->OutLine(L"      Rect: left=%d, top=%d, width=%d, height=%d", vals[0], 
                    vals[1], vals[2], vals[3]);
            }
            break;

        case TMT_FONT:
            if (fPropDump)
            {
                LOGFONT *plf;
                plf = (LOGFONT *)u.pb;

                //---- dump resolution-independent font points ----
                int iFontPoints = FontPointSize(plf->lfHeight);

                pFile->OutLine(L"      Font: name=%s, size=%d points", plf->lfFaceName, iFontPoints);
            }
            break;

        case TMT_THEMEMETRICS:
            if (fPropDump)
            {
                THEMEMETRICS *ptm;
                ptm= (THEMEMETRICS *)u.pb;

                //---- dump theme metrics: fonts ----
                for (i=0; i < TM_FONTCOUNT; i++)
                {
                    //---- dump resolution-independent font points ----
                    int iFontPoints = FontPointSize(ptm->lfFonts[i].lfHeight);

                    pFile->OutLine(L"      TM_Font[%d]: name=%s, size=%d points", 
                        i, ptm->lfFonts[i].lfFaceName, iFontPoints);
                }
                pFile->OutLine(L"      -----------------------------------------");

                //---- dump theme metrics: colors ----
                for (i=0; i < TM_COLORCOUNT; i++)
                {
                    pFile->OutLine(L"      TM_Color[%d]: %d, %d, %d", 
                        i, RED(ptm->crColors[i]), GREEN(ptm->crColors[i]), BLUE(ptm->crColors[i]));
                }
                pFile->OutLine(L"      -----------------------------------------");

                //---- dump theme metrics: sizes ----
                for (i=0; i < TM_SIZECOUNT; i++)
                {
                    pFile->OutLine(L"      TM_Size[%d]: %d",
                        i, ptm->iSizes[i]);
                }
                pFile->OutLine(L"      -----------------------------------------");

                //---- dump theme metrics: bools ----
                for (i=0; i < TM_BOOLCOUNT; i++)
                {
                    pFile->OutLine(L"      TM_Bool[%d]: %d",
                        i, ptm->fBools[i]);
                }
                pFile->OutLine(L"      -----------------------------------------");

                //---- dump theme metrics: strings ----
                for (i=0; i < TM_STRINGCOUNT; i++)
                {
                    WCHAR *psz;
            
                    if (ptm->iStringOffsets[i])
                        psz = (LPWSTR)(pThemeFile->_pbThemeData + ptm->iStringOffsets[i]);
                    else
                        psz = L"";

                    pFile->OutLine(L"      TM_String[%d]: %s", i, psz);
                }
                pFile->OutLine(L"      -----------------------------------------");
            }

            break;

        case TMT_ENUM:
            if (fPropDump)
                pFile->OutLine(L"      Enum: dtype=%d, val=%d", hdr.usTypeNum, *u.pi);
            break;

        case TMT_DIBDATA:
            if (fPropDump)
            {
                TMBITMAPHEADER    *pThemeBitmapHeader;

                pThemeBitmapHeader = reinterpret_cast<TMBITMAPHEADER*>(u.pb);

                if (pThemeBitmapHeader->hBitmap == NULL)
                {
                    BITMAPINFOHEADER *pHdr;

                    pHdr = BITMAPDATA(pThemeBitmapHeader);

                    if (fFullInfo)
                    {
                        pFile->OutLine(L"      DibData: width=%d, height=%d, total size: %d", 
                            pHdr->biWidth, pHdr->biHeight, hdr.dwDataLen); 
                    }
                    else
                    {
                        pFile->OutLine(L"      DibData: width=%d, height=%d",
                            pHdr->biWidth, pHdr->biHeight);
                    }
                } 
                else        // STOCKBITMAPHDR
                {
                    if (fFullInfo)
                    {
                        pFile->OutLine(L"      STOCKBITMAPHDR: dwColorDepth=%d, hBitmap=%8X, total size: %d", 
                            pThemeBitmapHeader->dwColorDepth, 
                            pThemeBitmapHeader->hBitmap, hdr.dwDataLen); 
                    }
                    else
                    {
                        pFile->OutLine(L"      STOCKBITMAPHDR: dwColorDepth=%d", 
                            pThemeBitmapHeader->dwColorDepth);
                    }
                }
            }
            break;

        default:
            if (fPropDump)
                pFile->OutLine(L"      Unexpected ptype=%d", hdr.ePrimVal);
            break;
    }

    u.pb = origPd + hdr.dwDataLen;

    return hdr.ePrimVal;
}
//---------------------------------------------------------------------------
void DumpPackedObjs(CSimpleFile *pFile, CUxThemeFile *pThemeFile, int iOffset, 
    BOOL fPacked, BOOL fFullInfo)
{
    MIXEDPTRS u;
    UNPACKED_ENTRYHDR hdr;

    u.pb = pThemeFile->_pbThemeData + iOffset;

    //---- first come the draw objects ----
    while (1)
    {
        if (*u.ps == TMT_RGNLIST)
        {
            FillAndSkipHdr(u, &hdr);

            int iStateCount = *u.pb;
            
            pFile->OutLine(L"RgnDataList: StateCount=%d", iStateCount);

            pFile->OutLine(L" ");

            u.pb += hdr.dwDataLen;
            continue;
        }

        if (*u.ps == TMT_STOCKBRUSHES)
        {
            FillAndSkipHdr(u, &hdr);

            pFile->OutLine(L"StockBrushes");
            pFile->OutLine(L" ");

            u.pb += hdr.dwDataLen;
            continue;
        }

        if (*u.ps != TMT_DRAWOBJ)
            break;

        FillAndSkipHdr(u, &hdr);

        DRAWOBJHDR *ph = (DRAWOBJHDR *)u.pb;
        u.pb += sizeof(DRAWOBJHDR);

        pFile->OutLine(L"DrawObj: part=%d, state=%d", ph->iPartNum, ph->iStateNum);

        BGTYPE eBgType = *(BGTYPE *)u.pb;
        if (eBgType == BT_BORDERFILL)
        {
            CBorderFill *bfobj = (CBorderFill *)u.pb;
            u.pb += sizeof(CBorderFill);

            bfobj->DumpProperties(pFile, pThemeFile->_pbThemeData, fFullInfo);
        }
        else
        {
            CImageFile *ifobj = (CImageFile *)u.pb;
            u.pb += sizeof(CImageFile) + sizeof(DIBINFO)*ifobj->_iMultiImageCount;

            ifobj->DumpProperties(pFile, pThemeFile->_pbThemeData, fFullInfo);
        }

        pFile->OutLine(L" ");
    }

    //---- then come the text objects ----
    while (*u.ps == TMT_TEXTOBJ)        
    {
        u.pb += ENTRYHDR_SIZE;

        DRAWOBJHDR *ph = (DRAWOBJHDR *)u.pb;
        u.pb += sizeof(DRAWOBJHDR);

        pFile->OutLine(L"TextObj: part=%d, state=%d", ph->iPartNum, ph->iStateNum);

        CTextDraw *tdobj = (CTextDraw *)u.pb;
        u.pb += sizeof(CTextDraw);

        tdobj->DumpProperties(pFile, pThemeFile->_pbThemeData, fFullInfo);

        pFile->OutLine(L" ");
    }
}
//---------------------------------------------------------------------------
void DumpSectionData(CSimpleFile *pFile, CUxThemeFile *pThemeFile, int iIndex, 
    BOOL fPacked, BOOL fFullInfo)
{
    MIXEDPTRS u;

    u.pb = pThemeFile->_pbThemeData + iIndex;

    bool atend = false;

    while (! atend)
    {
        int pnum = DumpType(pFile, pThemeFile, u, fPacked, fFullInfo);

        //---- special post-handling ----
        switch (pnum)
        {
            case TMT_PARTJUMPTABLE:
                {
                    int iPackObjsOffset = *u.pi++;
                    if (! fPacked)      // property dump
                    {
                        BYTE cnt = *u.pb++;
                    
                        if (fFullInfo)
                        {
                            pFile->OutLine(L"  PartJumpTable: drawobj offset=%d, cnt=%d", 
                                iPackObjsOffset, cnt);
                        }
                        else
                        {
                            pFile->OutLine(L"  PartJumpTable: drawobj cnt=%d",
                                cnt);
                        }

                        for (int i=0; i < cnt; i++)
                        {
                            int index = *u.pi++;

                            if (fFullInfo)
                                pFile->OutLine(L"  Part[%d]: index=%d", i, index);
                            else
                                pFile->OutLine(L"  Part[%d]", i);

                            if (index > -1)
                                DumpSectionData(pFile, pThemeFile, index, fPacked, fFullInfo);
                        }
                    }
                    else                // packed object dump
                    {
                        DumpPackedObjs(pFile, pThemeFile, iPackObjsOffset, fPacked, fFullInfo);
                    }
                }
                atend = true;
                break;

            case TMT_STATEJUMPTABLE:
                {
                    if (! fPacked)
                    {
                        BYTE cnt = *u.pb++;
                        pFile->OutLine(L"    StateJumpTable: cnt=%d", cnt);
                        for (int i=0; i < cnt; i++)
                        {
                            int index = *u.pi++;

                            if (fFullInfo)
                                pFile->OutLine(L"    State[%d]: index=%d", i, index);
                            else
                                pFile->OutLine(L"    State[%d]", i);

                            if (index > -1)
                                DumpSectionData(pFile, pThemeFile, index, fPacked, fFullInfo);
                        }
                    }
                }
                atend = true;
                break;

            case TMT_JUMPTOPARENT:
                atend = true;
                break;
        }
    }
}
//---------------------------------------------------------------------------
HRESULT DumpThemeFile(LPCWSTR pszFileName, CUxThemeFile *pThemeFile, BOOL fPacked,
    BOOL fFullInfo)
{
    MIXEDPTRS u;
    CHAR szSignature[kcbBeginSignature + 1];
    CSimpleFile OutFile;
    CSimpleFile *pFile = &OutFile;

    HRESULT hr = OutFile.Create(pszFileName, TRUE);
    if (FAILED(hr))
        goto exit;

    u.pb = pThemeFile->_pbThemeData;

    pFile->OutLine(L"Loaded Theme Dump");
    pFile->OutLine(L"");        // blank line
    pFile->OutLine(L"Header Section");

    //---- dump header ----
    THEMEHDR *hdr = (THEMEHDR *)u.pb;
    u.pb += sizeof(THEMEHDR);

    if (fFullInfo)
        pFile->OutLine(L"  dwTotalLength: %d", hdr->dwTotalLength);

    memcpy(szSignature, hdr->szSignature, kcbBeginSignature);
    szSignature[kcbBeginSignature] = '\0';
    pFile->OutLine(L"  szSignature: %S", szSignature);
    
    pFile->OutLine(L"  dwVersion: 0x%x", hdr->dwVersion);
    pFile->OutLine(L"  dwFlags: 0x%x", hdr->dwFlags);

    if (fFullInfo)
        pFile->OutLine(L"  dwCheckSum: 0x%x", hdr->dwCheckSum);

    if (fFullInfo)
        pFile->OutLine(L"  DllName: %s", ThemeString(pThemeFile, hdr->iDllNameOffset));

    pFile->OutLine(L"  Color: %s", ThemeString(pThemeFile, hdr->iColorParamOffset));
    pFile->OutLine(L"  Size: %s", ThemeString(pThemeFile, hdr->iSizeParamOffset));

    if (fFullInfo)
    {
        pFile->OutLine(L"  Strings: index=%d, length=%d", hdr->iStringsOffset, hdr->iStringsLength);
        pFile->OutLine(L"  SectionIndex: index=%d, length=%d", hdr->iSectionIndexOffset, hdr->iSectionIndexLength);
    
        pFile->OutLine(L"  iGlobalsOffset: %d", hdr->iGlobalsOffset);
        pFile->OutLine(L"  iGlobalsTextObjOffset: %d", hdr->iGlobalsTextObjOffset);
        pFile->OutLine(L"  iGlobalsDrawObjOffset: %d", hdr->iGlobalsDrawObjOffset);

        pFile->OutLine(L"  iSysMetricsOffset: %d", hdr->iSysMetricsOffset);
    }

    //---- dump strings section ----
    pFile->OutLine(L"");        // blank line
    if (fFullInfo)
    {
        pFile->OutLine(L"Strings Section (index=%d, length=%d)", 
            THEMEFILE_OFFSET(u.pb), hdr->iStringsLength);
    }
    else
    {
        pFile->OutLine(L"Strings Section");
    }

    u.pb = pThemeFile->_pbThemeData + hdr->iStringsOffset;
    int len = lstrlen(u.pw);
    WCHAR *pLastStringChar = (WCHAR *)(u.pb + hdr->iStringsLength - 1);

    BOOL fFirstString = TRUE;

    while (u.pw <= pLastStringChar)
    {
        if (fFullInfo)
            pFile->OutLine(L"  index=%d: %s", THEMEFILE_OFFSET(u.pb), u.pw);
        else
        {
            if (! fFirstString)     // don't show pathnames
                pFile->OutLine(L"  %s", u.pw);
        }

        u.pw += (1 + len);
        len = lstrlen(u.pw);

        if (fFirstString)
            fFirstString = FALSE;
    }
    
    //---- index section ----
    u.pb = pThemeFile->_pbThemeData + hdr->iSectionIndexOffset;

    pFile->OutLine(L"");        // blank line

    if (fFullInfo)
    {
        pFile->OutLine(L"Index Section (index=%d, length=%d)", 
            THEMEFILE_OFFSET(u.pb), hdr->iSectionIndexLength);
    }
    else
    {
        pFile->OutLine(L"Index Section");
    }

    APPCLASSLIVE *ac = (APPCLASSLIVE *)u.pb;
    DWORD cnt = hdr->iSectionIndexLength/sizeof(APPCLASSLIVE);
    for (DWORD i=0; i < cnt; i++)
    {
        LPCWSTR pszApp = ThemeString(pThemeFile, ac->dwAppNameIndex);
        LPCWSTR pszClass = ThemeString(pThemeFile, ac->dwClassNameIndex);

        if (fFullInfo)
        {
            pFile->OutLine(L"[%s::%s] (index=%d, length=%d)", pszApp, pszClass,
                ac->iIndex, ac->iLen);
        }
        else
        {
            pFile->OutLine(L"[%s::%s]", pszApp, pszClass);
        }

        DumpSectionData(pFile, pThemeFile, ac->iIndex, fPacked, fFullInfo);

        ac++;
    }

    pFile->OutLine(L"END of Live Data dump");
    pFile->OutLine(L"");        // blank line

exit:
    return hr;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\globals.h ===
//---------------------------------------------------------------------------//
//  globals.h - variables shared by uxtheme modules
//---------------------------------------------------------------------------//
#pragma once
//---------------------------------------------------------------------------
class CThemeServices;       // forward
class CAppInfo;             // forward
class CRenderList;          // forward
class CUxThemeFile;         // forward
class CBitmapCache;         // forward
//---------------------------------------------------------------------------
#define PROPFLAGS_RESET_TRANSPARENT   (1 << 0)   // hwnd needs WS_EX_TRANSPARENT reset
#define PROPFLAGS_RESET_COMPOSITED    (1 << 1)   // hwnd needs WS_EX_COMPOSITED reset
//---------------------------------------------------------------------------
#define WM_THEMECHANGED_TRIGGER     WM_UAHINIT   // reuse this msgnum with WPARAM != NULL
//---------------------------------------------------------------------------//
extern HINSTANCE g_hInst;
extern WCHAR     g_szProcessName[MAX_PATH];
extern DWORD     g_dwProcessId;
extern BOOL      g_fUxthemeInitialized;
extern BOOL      g_fEarlyHookRequest;
extern HWND      g_hwndFirstHooked;
extern HWND      g_hwndFirstHooked;

extern CBitmapCache *g_pBitmapCacheScaled;
extern CBitmapCache *g_pBitmapCacheUnscaled;
//---------------------------------------------------------------------------
//  theme atoms
enum THEMEATOM
{
    THEMEATOM_Nil = -1,

    THEMEATOM_SUBIDLIST,
    THEMEATOM_SUBAPPNAME,
    THEMEATOM_HTHEME,
    THEMEATOM_PROPFLAGS,
    THEMEATOM_UNUSED__________, /// RECYCLE ME!
    THEMEATOM_SCROLLBAR,
    THEMEATOM_PRINTING,
    THEMEATOM_DLGTEXTURING,
    //  insert new theme atom indices here
    THEMEATOM_NONCLIENT,

    THEMEATOM_Count
};
//  187504:  Since whistler beta1, we use hardcoded atom values to avoid our atoms being
//           destroyed as a user logs off.
#define HARDATOM_BASE   0xA910 // arbitrary, but less than 0xC000 (real atom base).
#define HARDATOM_HIGH   0xA94F // range of 64 atoms
inline ATOM GetThemeAtom( THEMEATOM ta )    
{
    ASSERT(ta > THEMEATOM_Nil && ta < THEMEATOM_Count);
    ATOM atom = (ATOM)(HARDATOM_BASE + ta);
    ASSERT(atom <= HARDATOM_HIGH);
    return atom;
}

//---------------------------------------------------------------------------
enum THEMEHOOKSTATE
{
    HS_INITIALIZED,
    HS_UNHOOKING,
    HS_UNINITIALIZED,
};

extern  THEMEHOOKSTATE  g_eThemeHookState;
#define HOOKSACTIVE()   (HS_INITIALIZED == g_eThemeHookState)
#define UNHOOKING()     (HS_UNHOOKING   == g_eThemeHookState)

//---------------------------------------------------------------------------
extern CAppInfo          *g_pAppInfo;
extern CRenderList       *g_pRenderList;
//---------------------------------------------------------------------------
BOOL GlobalsStartup();
BOOL GlobalsShutdown();

HRESULT BumpThemeFileRefCount(CUxThemeFile *pThemeFile);
void    CloseThemeFile(CUxThemeFile *pThemeFile);
//---------------------------------------------------------------------------

#define PRINTING_ASKING                 1       
#define PRINTING_WINDOWDIDNOTHANDLE     2

//---------------------------------------------------------------------------
#define _WindowHasTheme(hwnd) (g_pAppInfo->WindowHasTheme(hwnd))
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\globals.cpp ===
//---------------------------------------------------------------------------//
//  globals.cpp - variables shared by uxtheme modules
//---------------------------------------------------------------------------//
//  NOTE: global variables in this module are NOT protected by a critical 
//  section are subject to being set by 2 different threads at the same 
//  time.  Therefore, these variables should only be set during uxtheme init.
//---------------------------------------------------------------------------//
#include "stdafx.h"
#include "globals.h"
#include "AppInfo.h"
#include "services.h"
#include "ThemeFile.h"
#include "RenderList.h"
#include "CacheList.h"
#include "bmpcache.h"
//---------------------------------------------------------------------------//
HINSTANCE g_hInst                   = NULL;
WCHAR     g_szProcessName[MAX_PATH] = {0};
DWORD     g_dwProcessId             = 0;
BOOL      g_fUxthemeInitialized     = FALSE;
BOOL      g_fEarlyHookRequest       = FALSE;
HWND      g_hwndFirstHooked         = 0;

THEMEHOOKSTATE    g_eThemeHookState = HS_UNINITIALIZED;
CAppInfo          *g_pAppInfo       = NULL;
CRenderList       *g_pRenderList    = NULL;

CBitmapCache *g_pBitmapCacheScaled        = NULL;
CBitmapCache *g_pBitmapCacheUnscaled        = NULL;

#ifdef LAME_BUTTON
void InitLameText();
#else
#define InitLameText()
#endif

//---------------------------------------------------------------------------
BOOL GlobalsStartup()
{
    BOOL fInit = FALSE;

    Log(LOG_TMSTARTUP, L"GlobalsStartup");
    
    g_dwProcessId = GetCurrentProcessId();

    //---- create global objects ----
    CThemeServices::StaticInitialize();

    g_pRenderList = new CRenderList();
    if (! g_pRenderList)
        goto exit;

    g_pAppInfo = new CAppInfo();
    if (! g_pAppInfo)
        goto exit;

    WCHAR szPath[MAX_PATH];
    if (! GetModuleFileNameW( NULL, szPath, ARRAYSIZE(szPath) ))
        goto exit;

    WCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szExt[_MAX_EXT];
    _wsplitpath(szPath, szDrive, szDir, g_szProcessName, szExt);

    g_pBitmapCacheScaled = new CBitmapCache();
    if (! g_pBitmapCacheScaled)
        goto exit;

    g_pBitmapCacheUnscaled = new CBitmapCache();
    if (! g_pBitmapCacheUnscaled)
        goto exit;

    InitLameText();

    if (g_fEarlyHookRequest)
    {
        //---- May want to PostMessage() a request to theme ldr ----
        //---- to trigger our hooks & send us WM_THEMECHANGED msg ---
        //---- if it looks like some apps need this.  For now, ----
        //---- let's see if just relying on queued us msgs to do work ----
        //---- is sufficient. ----
    }
    
    g_fUxthemeInitialized = TRUE;
    fInit = TRUE;

exit:
    return fInit;
}
//---------------------------------------------------------------------------//
BOOL GlobalsShutdown()
{
    Log(LOG_TMSTARTUP, L"GlobalsShutDown");

    SAFE_DELETE(g_pBitmapCacheScaled);
    SAFE_DELETE(g_pBitmapCacheUnscaled);
    SAFE_DELETE(g_pAppInfo);
    SAFE_DELETE(g_pRenderList);
    CThemeServices::StaticTerminate();

    g_fUxthemeInitialized = FALSE;

    return TRUE;
}

//---------------------------------------------------------------------------//
HWINSTA _GetWindowStation( LPTSTR pszName, int cchName )
{
    HWINSTA hWinsta = GetProcessWindowStation();
    *pszName = 0;
    if( hWinsta != NULL )
    {
        DWORD cbNeeded = 0;
        GetUserObjectInformation( hWinsta, UOI_NAME, pszName, cchName, &cbNeeded );
    }
    return hWinsta;
}

//---------------------------------------------------------------------------//
HRESULT BumpThemeFileRefCount(CUxThemeFile *pThemeFile)
{
    HRESULT hr;

    if (g_pAppInfo)
        hr = g_pAppInfo->BumpRefCount(pThemeFile); 
    else
        hr = MakeError32(E_FAIL);

    return hr;
}
//---------------------------------------------------------------------------//
void CloseThemeFile(CUxThemeFile *pThemeFile)
{
    if (g_pAppInfo)
        g_pAppInfo->CloseThemeFile(pThemeFile);
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\gdisemu.h ===
// The following ifdef block is the standard way of creating macros which make exporting 
// from a DLL simpler. All files within this DLL are compiled with the GDISEMU_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see 
// GDISEMU_API functions as being imported from a DLL, wheras this DLL sees symbols
// defined with this macro as being exported.
#ifdef GDISEMU_EXPORTS
#define GDISEMU_API __declspec(dllexport)
#else
#define GDISEMU_API __declspec(dllimport)
#endif

#define DS_MAGIC                'DrwS'
#define DS_SETTARGETID          0
#define DS_SETSOURCEID          1
#define DS_COPYTILEID           2
#define DS_SOLIDFILLID          3
#define DS_TRANSPARENTTILEID    4
#define DS_ALPHATILEID          5
#define DS_STRETCHID            6
#define DS_TRANSPARENTSTRETCHID 7
#define DS_ALPHASTRETCHID       8

typedef struct _DS_HEADER
{
    ULONG   magic;
} DS_HEADER;

typedef struct _DS_SETTARGET
{
    ULONG   ulCmdID;
    HDC     hdc;
    RECTL   rclBounds;
} DS_SETTARGET;

typedef struct _DS_SETSOURCE
{
    ULONG   ulCmdID;
    HDC     hdc;
} DS_SETSOURCE;

typedef struct _DS_COPYTILE
{
    ULONG   ulCmdID;
    RECTL   rclDst;
    RECTL   rclSrc;
    POINTL  ptlOrigin;
} DS_COPYTILE;

typedef struct _DS_SOLIDFILL
{
    ULONG       ulCmdID;
    RECTL       rclDst;
    COLORREF    crSolidColor;
} DS_SOLIDFILL;

typedef struct _DS_TRANSPARENTTILE
{
    ULONG       ulCmdID;
    RECTL       rclDst;
    RECTL       rclSrc;
    POINTL      ptlOrigin;
    COLORREF    crTransparentColor;
} DS_TRANSPARENTTILE;

typedef struct _DS_ALPHATILE
{
    ULONG           ulCmdID;
    RECTL           rclDst;
    RECTL           rclSrc;
    POINTL          ptlOrigin;
    BLENDFUNCTION   blendFunction;
} DS_ALPHATILE;

typedef struct _DS_STRETCHC
{
    ULONG       ulCmdID;
    RECTL       rclDst;
    RECTL       rclSrc;
} DS_STRETCH;

typedef struct _DS_TRANSPARENTSTRETCHC
{
    ULONG       ulCmdID;
    RECTL       rclDst;
    RECTL       rclSrc;
    COLORREF    crTransparentColor;
} DS_TRANSPARENTSTRETCH;

typedef struct _DS_ALPHASTRETCHC
{
    ULONG       ulCmdID;
    RECTL       rclDst;
    RECTL       rclSrc;
    BLENDFUNCTION   blendFunction;
} DS_ALPHASTRETCH;

/*GDISEMU_API */int DrawStream(int cjIn, void * pvIn);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\gradient.h ===
//---------------------------------------------------------------------------
//  Gradient.h - gradient drawing support
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#define SYSCOLOR(c) (c|0x80000000)

#define RGBA2WINCOLOR(color) (color.bBlue << 16) | (color.bGreen << 8) | (color.bRed);
#define FIXCOLORVAL(val)     ((val > 255) ? 255 : ((val < 0) ? 0 : val))
//---------------------------------------------------------------------------
struct RGBA
{
    BYTE bRed;
    BYTE bGreen;
    BYTE bBlue;
    BYTE bAlpha;     // not currently supported   
};
//---------------------------------------------------------------------------
struct GRADIENTPART
{
    BYTE Ratio;     // 0-255 ratio for this color (sum of ratios must be <= 255)
    RGBA Color;
};
//---------------------------------------------------------------------------
//---- public ----
HRESULT PaintGradientRadialRect(HDC hdc, RECT &rcBounds, int iPartCount, 
    GRADIENTPART *pGradientParts);

HRESULT PaintHorzGradient(HDC hdc, RECT &rcBounds, int iPartCount, 
    GRADIENTPART *pGradientParts);

HRESULT PaintVertGradient(HDC hdc, RECT &rcBounds, int iPartCount, 
    GRADIENTPART *pGradientParts);

//---- helpers ----
void PaintGradientVertBand(HDC hdc, RECT &rcBand, COLORREF color1, COLORREF color2);
void PaintGradientHorzBand(HDC hdc, RECT &rcBand, COLORREF color1, COLORREF color2);
void PaintGradientRadialBand(HDC hdc, RECT &rcBand, int radiusOffset,
    int radius, COLORREF color1, COLORREF color2);
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\gradient.cpp ===
//---------------------------------------------------------------------------
//  Gradient.cpp - gradient drawing support
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "Render.h"
#include "Utils.h"
#include "gradient.h"
//---------------------------------------------------------------------------
HRESULT PaintGradientRadialRect(HDC hdc, RECT &rcBand, int iPartCount, 
    GRADIENTPART *pGradientParts)
{ 
    if (iPartCount < 2)
        return MakeError32(E_INVALIDARG);

    int width = WIDTH(rcBand);
    int height = HEIGHT(rcBand);

    int radius = width;
    if (height > width)
        radius = height;

    radius = radius/2;

    int radiusOffset = 0;
    int ratioTotal = 0;
    UCHAR ratio;
    bool firstColor = true;
    COLORREF color, prevcolor = 0;

    for (int i=0; i <= iPartCount; i++)        // go thru 1 extra time at end
    {
        if (i == iPartCount)       // solid part of last color for remaining ratio
        {
            color = prevcolor;
            ratio = static_cast<UCHAR>(255 - ratioTotal);
        }
        else
        {
            color = RGBA2WINCOLOR(pGradientParts[i].Color);
            ratio = pGradientParts[i].Ratio;
        }

        if (firstColor)
        {
            prevcolor = color;
            firstColor = false;
        }

        int radius2 = radius*ratio/255;
        if (radius2)
            PaintGradientRadialBand(hdc, rcBand, radiusOffset, radius2, prevcolor, color);

        radiusOffset += radius2;
        prevcolor = color;
        ratioTotal += ratio;
    }

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT PaintHorzGradient(HDC hdc, RECT &rcBand, int iPartCount, 
    GRADIENTPART *pGradientParts)
{
    if (iPartCount < 2)
        return MakeError32(E_INVALIDARG);

    int width = WIDTH(rcBand);
    int xoffset = rcBand.left;
    int ratioTotal = 0;
    UCHAR ratio;
    bool firstColor = true;
    COLORREF color, prevcolor = 0;

    for (int i=0; i <= iPartCount; i++)        // go thru 1 extra time at end
    {
        if (i == iPartCount)       // solid part of last color for remaining ratio
        {
            color = prevcolor;
            ratio = static_cast<UCHAR>(255 - ratioTotal);
        }
        else
        {
            color = RGBA2WINCOLOR(pGradientParts[i].Color);
            ratio = pGradientParts[i].Ratio;
        }

        if (firstColor)
        {
            prevcolor = color;
            firstColor = false;
        }

        int width2 = width*ratio/255;
        if (width2)
        {
            RECT rect2 = {xoffset, rcBand.top, xoffset+width2, rcBand.bottom};
            PaintGradientHorzBand(hdc, rect2, prevcolor, color);
        }

        xoffset += width2;
        prevcolor = color;
        ratioTotal += ratio;
    }

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT PaintVertGradient(HDC hdc, RECT &rcBounds, int iPartCount, 
    GRADIENTPART *pGradientParts)
{
    if (iPartCount < 2)
        return MakeError32(E_INVALIDARG);

    int iHeight = HEIGHT(rcBounds);
    int yoffset = rcBounds.top;
    int ratioTotal = 0;
    UCHAR ratio;
    bool firstColor = true;
    COLORREF color, prevcolor = 0;

    for (int i=0; i <= iPartCount; i++)        // go thru 1 extra time at end
    {
        if (i == iPartCount)       // solid part of last color for remaining ratio
        {
            color = prevcolor;
            ratio = static_cast<UCHAR>(255 - ratioTotal);
        }
        else
        {
            color = RGBA2WINCOLOR(pGradientParts[i].Color);
            ratio = pGradientParts[i].Ratio;
        }

        if (firstColor)
        {
            prevcolor = color;
            firstColor = false;
        }

        int iHeight2 = iHeight*ratio/255;
        if (iHeight2)
        {
            RECT rect2 = {rcBounds.left, yoffset, rcBounds.right, yoffset+iHeight2};
            PaintGradientVertBand(hdc, rect2, prevcolor, color);
        }

        yoffset += iHeight2;
        prevcolor = color;
        ratioTotal += ratio;
    }

    return S_OK;
}
//---------------------------------------------------------------------------
void DrawGradient(HDC hdc, RECT &rcBand, COLORREF color1, COLORREF color2, BOOL fHorz)
{
    TRIVERTEX vert[2];
    GRADIENT_RECT gRect;

    vert[0].x = rcBand.left;
    vert[0].y = rcBand.top;
    vert[1].x = rcBand.right;
    vert[1].y = rcBand.bottom; 

    // first vertex
    vert[0].Red   = (USHORT)(GetRValue(color1) << 8);
    vert[0].Green = (USHORT)(GetGValue(color1) << 8);
    vert[0].Blue  = (USHORT)(GetBValue(color1) << 8);
    vert[0].Alpha = 0x0000;

    // second vertex
    vert[1].Red   = (USHORT)(GetRValue(color2) << 8);
    vert[1].Green = (USHORT)(GetGValue(color2) << 8);
    vert[1].Blue  = (USHORT)(GetBValue(color2) << 8);
    vert[1].Alpha = 0x0000;

    gRect.UpperLeft  = 0;
    gRect.LowerRight = 1;

    GdiGradientFill(hdc, vert, 2, &gRect, 1, fHorz ? GRADIENT_FILL_RECT_H : GRADIENT_FILL_RECT_V);
}
//---------------------------------------------------------------------------
void PaintGradientHorzBand(HDC hdc, RECT &rcBand, COLORREF color1, COLORREF color2)
{
    DrawGradient(hdc, rcBand, color1, color2, TRUE);
}
//---------------------------------------------------------------------------
void PaintGradientVertBand(HDC hdc, RECT &rcBand, COLORREF color1, COLORREF color2)
{
    DrawGradient(hdc, rcBand, color1, color2, FALSE);
}
//---------------------------------------------------------------------------
void PaintGradientRadialBand(HDC hdc, RECT &rcBand, int radiusOffset,
    int radius, COLORREF color1, COLORREF color2)
{
    int red1 = RED(color1);
    int red2 = RED(color2);
    int green1 = GREEN(color1);
    int green2 = GREEN(color2);
    int blue1 = BLUE(color1);
    int blue2 = BLUE(color2);

    int maxcolors = abs(red1 - red2);

    int cnt = abs(green1 - green2);
    if (cnt > maxcolors)
        maxcolors = cnt;

    cnt = abs(blue1 - blue2);
    if (cnt > maxcolors)
        maxcolors = cnt;

    int linewidth;
    if (color1 == color2)               // just do solid color1
        linewidth = radius;
    else if (radius > maxcolors)
        linewidth = radius/maxcolors;
    else
        linewidth = 1;

    POINT center = {rcBand.left + WIDTH(rcBand)/2, rcBand.top + HEIGHT(rcBand)/2};
    radiusOffset += linewidth/2;        // center pen within line

    for (int r=0; r < radius; r += linewidth)
    {
        int red = (red2*r + red1*(radius-r))/radius;
        int green = (green2*r + green1*(radius-r))/radius;
        int blue = (blue2*r + blue1*(radius-r))/radius;

        int radius2 = radiusOffset + r;   // center pen within target line

        //---- calculate rcBand around "center" with "radius2" ----
        int left = center.x - radius2;
        int right = center.x + radius2;
        int top = center.y - radius2;
        int bottom = center.y + radius2;

        //---- overlap lines slightly so that bg doesn't leak thru ----
        HPEN pen = CreatePen(PS_SOLID, linewidth+2, RGB(red, green, blue));
        HPEN oldpen = (HPEN)SelectObject(hdc, pen);

        Arc(hdc, left, top, right, bottom, 0, 0, 0, 0);

        SelectObject(hdc, oldpen);
        DeleteObject(pen);
    }
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\handlers.cpp ===
#include "stdafx.h"
#include "handlers.h"

//-------------------------------------------------------------------------//
//  Declare registered message vars **here**
//-------------------------------------------------------------------------//
#define __NO_APPHACKS__
//-------------------------------------------------------------------------//
//  Message Handlers
//-------------------------------------------------------------------------//

//  Rules for message handlers [scotthan]:
//
//  (1) Use DECL_ macros to declare message handler prototype and
//      table entries for message handlers below.
//  (2) A message handler implementation should NOT:
//      1. call DefWindowProc or CallWindowProc directly,
//         but rather use DoMsgDefault().
//      2. delete the incoming CThemeWnd* object,
//  (3) A message handler SHOULD:
//      1. Honor the codepage value in the message block when
//         handling messages that carry string args.
//         If the codepage member is CP_WINUNICODE, the widechar
//         string processing should be assumed; otherwise, multibyte
//         string processing should be assumed.
//      2. If a message should not be forwarded for default processing,
//         mark the message as handled using MsgHandled().
//  (4) Handlers should be listed in the BEGIN/ENDMSG() block
//      below in decreasing order of expected frequency.


//---------------------//
//  WndProc overrides
//---------------------//

//  msg handler decls:
DECL_MSGHANDLER( OnOwpPostCreate );
DECL_MSGHANDLER( OnOwpPreStyleChange );
DECL_MSGHANDLER( OnOwpPreWindowPosChanging );
DECL_MSGHANDLER( OnOwpPreWindowPosChanged );
DECL_MSGHANDLER( OnOwpPostWindowPosChanged );
DECL_MSGHANDLER( OnOwpPostSettingChange );
DECL_MSGHANDLER( OnOwpPreMeasureItem );
DECL_MSGHANDLER( OnOwpPreDrawItem );
DECL_MSGHANDLER( OnOwpPreMenuChar );
DECL_MSGHANDLER( OnOwpPostThemeChanged );
DECL_MSGHANDLER( OnOwpPreNcPaint );
DECL_MSGHANDLER( OnOwpPostNcPaint );

//  handler table:
BEGIN_HANDLER_TABLE(_rgOwpHandlers)
    // frequent messages
    DECL_MSGENTRY( WM_NCPAINT,           OnOwpPreNcPaint, OnOwpPostNcPaint )
    DECL_MSGENTRY( WM_WINDOWPOSCHANGING, OnOwpPreWindowPosChanging, NULL )
    DECL_MSGENTRY( WM_WINDOWPOSCHANGED,  OnOwpPreWindowPosChanged, OnOwpPostWindowPosChanged )
    DECL_MSGENTRY( WM_SETTINGCHANGE,     NULL, OnOwpPostSettingChange )
    DECL_MSGENTRY( WM_MEASUREITEM,       OnOwpPreMeasureItem, NULL )
    DECL_MSGENTRY( WM_DRAWITEM,          OnOwpPreDrawItem, NULL )
    DECL_MSGENTRY( WM_MDISETMENU,        NULL, NULL )

    // rare messages:
    DECL_MSGENTRY( WM_MENUCHAR,          OnOwpPreMenuChar, NULL )
    DECL_MSGENTRY( WM_STYLECHANGING,     OnOwpPreStyleChange, NULL )
    DECL_MSGENTRY( WM_STYLECHANGED,      OnOwpPreStyleChange, NULL )
    DECL_MSGENTRY( WM_NCCREATE,          NULL, NULL )
    DECL_MSGENTRY( WM_CREATE,            NULL, OnOwpPostCreate )
    DECL_MSGENTRY( WM_NCDESTROY,         NULL, NULL )
    DECL_MSGENTRY( WM_THEMECHANGED,      NULL, OnOwpPostThemeChanged  )      // we handle in line in ThemePreWndProc()
    DECL_MSGENTRY( WM_THEMECHANGED_TRIGGER,    NULL, NULL )      // we handle in line in ThemePreWndProc()
END_HANDLER_TABLE()

//  Note: values of high owp message must be in sync w/ table.
#define WNDPROC_MSG_LAST  WM_THEMECHANGED_TRIGGER   // 0x031B (alias for WM_UAHINIT)


//------------------------//
//  DefDlgProc overrides
//------------------------//

//  msg handler decls:
DECL_MSGHANDLER( OnDdpPostCtlColor );
DECL_MSGHANDLER( OnDdpCtlColor );
DECL_MSGHANDLER( OnDdpPrint );
DECL_MSGHANDLER( OnDdpPostInitDialog );

//  handler table:
BEGIN_HANDLER_TABLE(_rgDdpHandlers)
    // frequent messages:
    DECL_MSGENTRY( WM_CTLCOLORDLG,       NULL, OnDdpPostCtlColor )
    DECL_MSGENTRY( WM_CTLCOLORSTATIC,    NULL, OnDdpCtlColor)
    DECL_MSGENTRY( WM_CTLCOLORBTN,       NULL, OnDdpCtlColor)
    DECL_MSGENTRY( WM_CTLCOLORMSGBOX,    NULL, OnDdpPostCtlColor )
    DECL_MSGENTRY( WM_PRINTCLIENT,       NULL, OnDdpPrint )
    // rare messages:
    DECL_MSGENTRY( WM_INITDIALOG,        NULL, OnDdpPostInitDialog )
END_HANDLER_TABLE()

//  Note: values of high ddp message must be in sync w/ table.
#define DEFDLGPROC_MSG_LAST   WM_PRINTCLIENT   // 0x0318


//--------------------------//
//  DefWindowProc override
//--------------------------//

//  msg handler decls:
DECL_MSGHANDLER( OnDwpNcPaint );
DECL_MSGHANDLER( OnDwpNcHitTest );
DECL_MSGHANDLER( OnDwpNcActivate );
DECL_MSGHANDLER( OnDwpNcLButtonDown );
DECL_MSGHANDLER( OnDwpNcThemeDrawCaption );
DECL_MSGHANDLER( OnDwpNcThemeDrawFrame );
DECL_MSGHANDLER( OnDwpNcMouseMove );
DECL_MSGHANDLER( OnDwpNcMouseLeave );
DECL_MSGHANDLER( OnDwpWindowPosChanged );
DECL_MSGHANDLER( OnDwpSysCommand );
DECL_MSGHANDLER( OnDwpSetText );
DECL_MSGHANDLER( OnDwpSetIcon );
DECL_MSGHANDLER( OnDwpStyleChanged );
DECL_MSGHANDLER( OnDwpPrint );
DECL_MSGHANDLER( OnDwpPrintClient );
DECL_MSGHANDLER( OnDwpContextMenu );

//  handler table:
BEGIN_HANDLER_TABLE(_rgDwpHandlers)
    // frequent messages:
    DECL_MSGENTRY( WM_NCHITTEST,          OnDwpNcHitTest,     NULL )
    DECL_MSGENTRY( WM_NCPAINT,            OnDwpNcPaint,       NULL )
    DECL_MSGENTRY( WM_NCACTIVATE,         OnDwpNcActivate,    NULL )
    DECL_MSGENTRY( WM_NCMOUSEMOVE,        OnDwpNcMouseMove,   NULL )
    DECL_MSGENTRY( WM_NCMOUSELEAVE,       OnDwpNcMouseLeave,  NULL )
    DECL_MSGENTRY( WM_WINDOWPOSCHANGED,   OnDwpWindowPosChanged, NULL )
    DECL_MSGENTRY( WM_SYSCOMMAND,         OnDwpSysCommand,    NULL )
    DECL_MSGENTRY( WM_NCLBUTTONDOWN,      OnDwpNcLButtonDown, NULL )
    DECL_MSGENTRY( WM_NCUAHDRAWCAPTION,   OnDwpNcThemeDrawCaption, NULL )
    DECL_MSGENTRY( WM_NCUAHDRAWFRAME,     OnDwpNcThemeDrawFrame, NULL )
    DECL_MSGENTRY( WM_PRINT,              OnDwpPrint,  NULL )
    DECL_MSGENTRY( WM_PRINTCLIENT,        OnDwpPrintClient, NULL )
    DECL_MSGENTRY( WM_CTLCOLORMSGBOX,     OnDdpPostCtlColor, NULL)         // Strange: Sent to DefWindowProc, but is a Dialog message
    DECL_MSGENTRY( WM_CTLCOLORSTATIC,     OnDdpCtlColor, NULL)
    DECL_MSGENTRY( WM_CTLCOLORBTN,        OnDdpCtlColor, NULL)
    // rare messages:
    DECL_MSGENTRY( WM_SETTEXT,            OnDwpSetText,       NULL )
    DECL_MSGENTRY( WM_SETICON,            OnDwpSetIcon,       NULL )
    DECL_MSGENTRY( WM_STYLECHANGED,       OnDwpStyleChanged,  NULL )
    DECL_MSGENTRY( WM_CONTEXTMENU,        OnDwpContextMenu,   NULL )
    DECL_MSGENTRY( WM_THEMECHANGED_TRIGGER,    NULL, NULL )
    DECL_MSGENTRY( WM_NCDESTROY,          NULL, NULL )
END_HANDLER_TABLE()

//  Note: values of high dwp message must be in sync w/ handler table.
#define DEFWNDPROC_MSG_LAST  WM_THEMECHANGED_TRIGGER // 0x031B

//---------------------------------------------------------------------------
BOOL _FindMsgHandler( UINT, MSGENTRY [], int, IN HOOKEDMSGHANDLER*, IN HOOKEDMSGHANDLER* );
BOOL _SetMsgHandler( UINT, MSGENTRY [], int, IN HOOKEDMSGHANDLER, BOOL );

//---------------------------------------------------------------------------
//  Special case hook handling
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
BOOL _IsExcludedSystemProcess( LPCWSTR pszProcess )
{
    static  const WCHAR*    _rgszSystemProcessList[]   =
    {
        L"lsass",       //  Local Security Authority sub-system
        L"services",    //  Service Control Manager
        L"svchost",     //  Service Host
        L"mstask",      //  Microsoft Task Scheduler
        L"dfssvc",      //  Distributed File System Service
        L"winmgmt",     //  Windows Management Instrumentation
        L"spoolsv",     //  Print Spool Service
        L"msdtc",       //  Microsoft Distributed Transaction Co-ordinator
        L"regsvc",      //  Remote Registry Service
        L"webclnt",     //  Web Client
        L"mspmspsv",    //  WMDM PMSP Service (what is this?)
        L"ntvdm"        //  NT virtual DOS machine
    };

    return AsciiScanStringList( pszProcess, _rgszSystemProcessList, 
                           ARRAYSIZE(_rgszSystemProcessList), TRUE );
}

//---------------------------------------------------------------------------
BOOL _IsProcessOnInteractiveWindowStation() // check if we're on winsta0.
{
    BOOL    fRet    = FALSE;
    HWINSTA hWinSta = GetProcessWindowStation();
    
    if( hWinSta != NULL )
    {
        DWORD   cbLength = 0;
        WCHAR   wszName[0xFF];
        WCHAR*  pszName = wszName;

        GetUserObjectInformationW(hWinSta, UOI_NAME, NULL, 0, &cbLength);
        if( cbLength < sizeof(wszName) )
        {
            pszName = (WCHAR*)LocalAlloc(LMEM_FIXED, cbLength);
            if( NULL == pszName )
                return FALSE;
        }

        if (pszName != NULL)
        {
            if( GetUserObjectInformationW(hWinSta, UOI_NAME, pszName, cbLength, &cbLength) != FALSE )
            {
                fRet = (0 == AsciiStrCmpI(pszName, L"winsta0"));
            }

            if( pszName != wszName )
                LocalFree(pszName);
        }
    }
    return(fRet);
}

//---------------------------------------------------------------------------
BOOL _IsWin16App() // check if this is a 16-bit process
{
    GUITHREADINFO gti;
    gti.cbSize = sizeof(gti);
    gti.flags  = GUI_16BITTASK;

    return GetGUIThreadInfo( GetCurrentThreadId(), &gti ) && 
           TESTFLAG(gti.flags, GUI_16BITTASK );
}

//---------------------------------------------------------------------------
BOOL ApiHandlerInit( const LPCTSTR pszProcess, USERAPIHOOK* puahTheme, const USERAPIHOOK* puahReal )
{
    //  exclude known non-UI system processes
    if( _IsExcludedSystemProcess( pszProcess ) )
        return FALSE;

    //  exclude any process not hosted on winsta0.
    if( !_IsProcessOnInteractiveWindowStation() )
        return FALSE;

    if( _IsWin16App() )
        return FALSE;
    
    //  SHIMSHIM [scotthan]:

#ifdef _DEBUG
    //---- temp patch against msvcmon ----
    if( 0 == AsciiStrCmpI(pszProcess, L"msvcmon") )
    {
        return FALSE;
    }

    //---- temp patch against msdev ----
    if( 0 == AsciiStrCmpI(pszProcess, L"msdev") )
    {
        return FALSE;
    }

    //---- Aid in debugging classic/themed differences: ---
    if( 0 == AsciiStrCmpI( pszProcess, L"mditest1" ) )
    {
        return FALSE;
    }
#endif

#ifndef __NO_APPHACKS__

    static  const WCHAR* _rgszExcludeAppList[] =
    {
#ifdef THEME_CALCSIZE
        // Invoking SetWindowPos from CThemeWnd::SetFrameTheme on our Post-WM_CREATE handler 
        // causes emacs to divide by zero after receiving meaningless rects from two 
        // successive calls to AdjustWindowRectEx from his WM_WINDOWPOSCHANGING handler.   
        // I don't believe it is related to the fact that AdjustWindowRectEx has yet 
        // to be implemented for themed windows (raid# 140989), but rather that the wndproc
        // is not ready for a WM_WINDOWPOSCHANGING message on the abrubtly on the 
        // heels of a WM_CREATE handler.
        L"emacs",

        L"neoplanet", // 247283: We rush in to theme neoplanet's dialogs, which we almost
        L"np",        // immediately revoke, but not before sizing the dialog to theme-compatible
                      // client rect. When we withdraw, we leave it clipped.  No good way to deal 
                      // with this for beta2.

        // HTML Editor++ v.8: 286676:
        // This guy recomputes his nonclient area, and then AVs dereferencing a 
        // WM_WINDOWPOSCHANGING message under themes.
        L"coffee", 
#endif THEME_CALCSIZE

        L"refcntr", // 205059: Corel Reference Center; lower 10% of window is clipped.

        L"KeyFramerPro", // 336456: Regardless of whether themes are enabled, Boris KeyFramer Pro v.5 
                         //         does two SetWindowRgn() calls for every WM_PAINT, the first with a region, 
                         //         the next with NULL,  Is the app trying to clip his painting?  
                         //         If so, this is not what SetWindowRgn was intended for, and explains why this
                         //         app is so clunky at window resizing. Rather, SelectClipRgn is the
                         //         correct API.
                         //         When themes are enabled, we keep revoking and re-attatching with each
                         //         SetWindowRgn call, so we get substantial flicker.
                         //         The ISV should be notified of this bug.

        // Applications that do custom non-client painting and hence look broken when 
        // themed. Our only recourse at the moment it to exclude them from non-client 
        // themeing so that we don't stomp whatever they are trying to do.
        L"RealJBox",    // 273370: Real JukeBox
        L"RealPlay",    // 285368: Real AudioPlayer
        L"TeamMgr",     // 286654: Microsoft Team Manager97
        L"TrpMaker",    // 307107: Rand McNally TripMaker 2000
        L"StrFindr",    // 307535: Rand McNally StreetFinder 2000
        L"Exceed",      // 276244: Hummingbird Exceed 6.2/7.0
        L"VP30",        // 328676: Intel Video Phone

        //  313407: Groove, build 760
        //  Calls DefWindowProc for NCPAINT, then paints his own caption over it.
        //  Note: this just might work correctly if we had a DrawFrameControl hook.
        L"groove", // filever 1.1.0.760, 1/22/2001 tested.

        // 303756: Exclude all Lotus SmartSuite apps to provide consistency among their 
        // apps. All of them draw into the caption bar.
        L"WordPro",     // 285065: Lotus WordPro, a particularly poorly implemented app.
        L"SmartCtr",    //         It's WordPerfect compat menu is the elephant man of modern software.
        L"123w",
        L"Approach",
        L"FastSite",
        L"F32Main",
        L"Org5",

        // 358337: Best Technology - GCC Developer Lite.  Custom caption bar fights with Luna.
        L"GCCDevL",     // install point: http://www.besttechnology.co.jp/download/GDL1_0_3_6.EXE

        // 360422: J Zenrin The Real Digital Map Z3(T1):Max/Min/Close buttons are overlapped on classic buttons in title bar.
        L"emZmain", 

        // 364337:  Encarta World English Dictionary: Luna system buttons are overlaid on top of app's custom ones when mousing over
        L"ewed.exe",

        // 343171:  Reaktor Realtime Instrument: pressing the close button while themed causes this app to 
        //          spin in a tight loop running at realtime priority, effectively hanging the machine. 
        //          The message loop for this app is extremely timing sensitive, the additional overhead 
        //          introduced by theming alters the timing enough to break this app.
        L"Reaktor",
    };

    if( AsciiScanStringList( pszProcess, _rgszExcludeAppList, 
                        ARRAYSIZE(_rgszExcludeAppList), TRUE ) )
    {
        return FALSE;
    }

#ifdef THEME_CALCSIZE
    // Winstone 99 needs modified NC_CALCSIZE behavior for Netscape or it will hang.
    if ( 0 == AsciiStrCmpI( pszProcess, L"Netscape" ))
    {
        if (FindWindowEx(NULL, NULL, L"ZDBench32Frame", NULL) != NULL)
        {
            _SetMsgHandler( WM_NCCALCSIZE, _rgDwpHandlers, ARRAYSIZE(_rgDwpHandlers),
                         OnDwpNcCalcSize2, FALSE );
            return TRUE;
        }
    }
#endif THEME_CALCSIZE

    //-------------------------
    // This AppHack was once fixed, but got broke again with 
    // addition of logic for partial-screen maximized windows.
    //
    // Something in our answer to NCCALCSIZE causes quick time player 
    // to continously flood its 'control' frame window's winproc with 
    // WM_PAINTS by repeatedly calling InvalidateRgn + UpdateWindow.   My
    // suspicion is that he looks at what DefWindowProc returns from
    // NCCALCSIZE to determine the area he needs to manage, and when
    // this doesn't hash with other SYSMET values and/or AdjustWindowRect, 
    // he redundantly invalidates himself,
    //
    // This only repros if qtp is launched w/ .mov file, works fine if 
    // launched without a file and then a file is loaded.
#ifdef THEME_CALCSIZE
    if( 0 == AsciiStrCmpI( pszProcess, L"QuickTimePlayer" ))
    {
        _SetMsgHandler( WM_NCCALCSIZE, _rgDwpHandlers, ARRAYSIZE(_rgDwpHandlers),
                     OnDwpNcCalcSize2, FALSE );
        return TRUE;
    }

    //  SEANHI DID NOT RECEIVE THE S/W FROM APPLIB AND SO WAS UNABLE TO VERIFY THIS 
    //  NO LONGER REPROS W/ ELIMINATION OF THEMED SYSMETS
    //-------------------------
    // Paradox 9 appHack for nonclient button sizes:
    //
    // Paradox table schema view uses DrawFrameControl to render both
    // a classic toolframe (small) caption and buttons, but uses the 
    // themed values of SM_CYSIZE instead of SM_CYSMSIZE to size the buttons. 
    // This apphack redirects requests in this process for SM_CX/YSIZE to SM_CX/YSMSIZE.
    if( 0 == AsciiStrCmpI( pszProcess, L"pdxwin32" ) )
    {
        _SetGsmHandler( SM_CXSIZE, OnGsmCxSmBtnSize );
        _SetGsmHandler( SM_CYSIZE, OnGsmCySmBtnSize );
        return TRUE;
    }
#endif THEME_CALCSIZE



    //-------------------------
#else
#   pragma message("App hacks disabled")
#endif __NO_APPHACKS__


    return TRUE;
}

//---------------------------------------------------------------------------
//  Handler table utility functions
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
void HandlerTableInit() {}

//---------------------------------------------------------------------------
BOOL _InitMsgMask( LPBYTE prgMsgMask, DWORD dwMaskBytes, MSGENTRY* prgEntries, int cEntries, 
    IN OUT BOOL& fInit )
{
    if( !fInit )
    {
        for( int i = 0; i < cEntries; i++ )
        {
            if( -1 == prgEntries[i].nMsg )
            {
                ASSERT(prgEntries[i].pnRegMsg);
                //  Initialize registered message entry
                prgEntries[i].nMsg = *prgEntries[i].pnRegMsg;

                Log(LOG_TMHANDLE, L"InitMsgMsg corrected registered msg: 0x%x", prgEntries[i].nMsg);
            }

            //---- ensure we set up limit on table correctly ----
            ASSERT((prgEntries[i].nMsg)/8 < dwMaskBytes);
            
            SET_MSGMASK( prgMsgMask, prgEntries[i].nMsg );
        }
        fInit = TRUE;
    }

    return fInit;
}

//---------------------------------------------------------------------------
//  Scan of MSG table as linear array:
inline int _FindMsgHandler(
    UINT nMsg,
    MSGENTRY rgEntries[],
    int cEntries,
    OUT OPTIONAL HOOKEDMSGHANDLER* ppfnHandler,
    OUT OPTIONAL HOOKEDMSGHANDLER* ppfnHandler2 )
{
    ASSERT( nMsg );
    ASSERT( nMsg != (UINT)-1 );

    if( ppfnHandler )  *ppfnHandler  = NULL;
    if( ppfnHandler2 ) *ppfnHandler2 = NULL;

    for( int i = 0; i < cEntries; i++ )
    {
        if( rgEntries[i].nMsg == nMsg )
        {
            //  If no handler requested, return success
            if( NULL == ppfnHandler && NULL == ppfnHandler2 )
                return i;

            //  Assign outbound handler values
            if( ppfnHandler )  *ppfnHandler  = rgEntries[i].pfnHandler;
            if( ppfnHandler2 ) *ppfnHandler2 = rgEntries[i].pfnHandler2;

            //  return TRUE iif caller got what he asked for.
            return ((ppfnHandler && *ppfnHandler) || (ppfnHandler2 && *ppfnHandler2)) ? i : -1;
        }
    }
    return -1;
}

//---------------------------------------------------------------------------
//  Modify existing handler
inline BOOL _SetMsgHandler(
    UINT nMsg,
    MSGENTRY rgEntries[],
    int cEntries,
    IN HOOKEDMSGHANDLER pfnHandler, 
    BOOL fHandler2 )
{
    int i = _FindMsgHandler( nMsg, rgEntries, cEntries, NULL, NULL );
    if( i >= 0 )
    {
        if( fHandler2 )
            rgEntries[i].pfnHandler2 = pfnHandler;
        else
            rgEntries[i].pfnHandler = pfnHandler;
        return TRUE;
    }
    return FALSE;
}


#define CBMSGMASK(msgHigh)  (((msgHigh)+1)/8 + ((((msgHigh)+1) % 8) ? 1: 0))

//---------------------------------------------------------------------------
DWORD GetOwpMsgMask( LPBYTE* prgMsgMask )
{
    static BOOL _fOwpMask = FALSE; // initialized?
    static BYTE _rgOwpMask[CBMSGMASK(WNDPROC_MSG_LAST)] = {0};

    if( _InitMsgMask( _rgOwpMask, ARRAYSIZE(_rgOwpMask), _rgOwpHandlers, ARRAYSIZE(_rgOwpHandlers), _fOwpMask ) )
    {
        *prgMsgMask = _rgOwpMask;
        return ARRAYSIZE(_rgOwpMask);
    }
    return 0;
}

//---------------------------------------------------------------------------
DWORD GetDdpMsgMask( LPBYTE* prgMsgMask )
{
    static BOOL _fDdpMask = FALSE; // initialized?
    static BYTE _rgDdpMask[CBMSGMASK(DEFDLGPROC_MSG_LAST)] = {0};

    if( _InitMsgMask( _rgDdpMask, ARRAYSIZE(_rgDdpMask), _rgDdpHandlers, ARRAYSIZE(_rgDdpHandlers), _fDdpMask ) )
    {
        *prgMsgMask = _rgDdpMask;
        return ARRAYSIZE(_rgDdpMask);
    }
    return 0;
}

//---------------------------------------------------------------------------
DWORD GetDwpMsgMask( LPBYTE* prgMsgMask )
{
    static BOOL _fDwpMask = FALSE; // initialized?
    static BYTE _rgDwpMask[CBMSGMASK(DEFWNDPROC_MSG_LAST)] = {0};

    if( _InitMsgMask( _rgDwpMask, ARRAYSIZE(_rgDwpMask), _rgDwpHandlers, ARRAYSIZE(_rgDwpHandlers), _fDwpMask ) )
    {
        *prgMsgMask = _rgDwpMask;
        return ARRAYSIZE(_rgDwpMask);
    }
    return 0;
}

//---------------------------------------------------------------------------
BOOL FindOwpHandler(
    UINT nMsg, HOOKEDMSGHANDLER* ppfnPre, HOOKEDMSGHANDLER* ppfnPost )
{
    return _FindMsgHandler( nMsg, _rgOwpHandlers, ARRAYSIZE(_rgOwpHandlers),
                         ppfnPre, ppfnPost ) >= 0;
}

//---------------------------------------------------------------------------
BOOL FindDdpHandler(
    UINT nMsg, HOOKEDMSGHANDLER* ppfnPre, HOOKEDMSGHANDLER* ppfnPost )
{
    return _FindMsgHandler( nMsg, _rgDdpHandlers, ARRAYSIZE(_rgDdpHandlers),
                         ppfnPre, ppfnPost ) >= 0;
}

//---------------------------------------------------------------------------
BOOL FindDwpHandler( UINT nMsg, HOOKEDMSGHANDLER* ppfnPre )
{
    HOOKEDMSGHANDLER pfnPost;
    return _FindMsgHandler( nMsg, _rgDwpHandlers, ARRAYSIZE(_rgDwpHandlers),
                         ppfnPre, &pfnPost ) >= 0;
}

//---------------------------------------------------------------------------
//  Performs default message processing.
LRESULT WINAPI DoMsgDefault( const THEME_MSG *ptm )
{
    ASSERT( ptm );
    if( ptm->pfnDefProc )
    {
        MsgHandled( ptm );
        if( MSGTYPE_DEFWNDPROC == ptm->type )
            return ptm->pfnDefProc( ptm->hwnd, ptm->uMsg, ptm->wParam, ptm->lParam );
        else
        {
            ASSERT( NULL == ptm->pfnDefProc ); // bad initialization (_InitThemeMsg)
        }
    }
    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\imagefile.cpp ===
//---------------------------------------------------------------------------
//  ImageFile.cpp - implements the drawing API for bgtype = ImageFile
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "Render.h"
#include "Utils.h"
#include "tmutils.h"
#include "rgn.h"
#include "ImageFile.h"
#include "CacheList.h"
#include "DrawHelp.h"
#include "ninegrid2.h"
#include "TmReg.h"
#include "globals.h"
#include "bmpcache.h"
//---------------------------------------------------------------------------
void AdjustSizeMin(SIZE *psz, int ixMin, int iyMin)
{
    if (psz->cx < ixMin)
    {
        psz->cx = ixMin;
    }

    if (psz->cy < iyMin)
    {
        psz->cy = iyMin;
    }
}
//---------------------------------------------------------------------------
HRESULT CMaxImageFile::PackMaxProperties(CRenderObj *pRender, int iPartId, int iStateId,
        OUT int *piMultiDibCount)
{
    HRESULT hr = PackProperties(pRender, iPartId, iStateId);

    *piMultiDibCount = _iMultiImageCount;

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CImageFile::PackProperties(CRenderObj *pRender, int iPartId, int iStateId)
{
    HRESULT hr = S_OK;

    memset(this, 0, sizeof(CImageFile));     // allowed because we have no vtable
    _eBgType = BT_IMAGEFILE;

    //---- save off partid, stateid for debugging ----
    _iSourcePartId = iPartId;
    _iSourceStateId = iStateId;

    DIBINFO *pdi = &_ImageInfo;

    pdi->iMinDpi = 96;      // only way this gets set for now

    pdi->iDibOffset = pRender->GetValueIndex(iPartId, iStateId, TMT_DIBDATA);
    if (pdi->iDibOffset == -1)      // not found
        pdi->iDibOffset = 0;
    
    //---- image-related fields ----
    if (FAILED(pRender->GetInt(iPartId, iStateId, TMT_IMAGECOUNT, &_iImageCount)))
        _iImageCount = 1;        // default value

    if (_iImageCount < 1)        // avoid divide by zero problems
        _iImageCount = 1;

    if (FAILED(pRender->GetEnumValue(iPartId, iStateId, TMT_IMAGELAYOUT, (int *)&_eImageLayout)))
        _eImageLayout = IL_HORIZONTAL;        // default value until we are converted

    if (pdi->iDibOffset)
    {
        //---- compute some fields from bitmap ----
        hr = SetImageInfo(pdi, pRender, iPartId, iStateId);
        if (FAILED(hr))
            goto exit;
    }

    //---- get MinSize ----
    if (FAILED(pRender->GetPosition(iPartId, iStateId, TMT_MINSIZE, (POINT *)&pdi->szMinSize)))
    {
        pdi->szMinSize.cx  = pdi->iSingleWidth;
        pdi->szMinSize.cy  = pdi->iSingleHeight;
    }
    else
    {
        AdjustSizeMin(&pdi->szMinSize, 1, 1);
    }

    //---- get TrueSizeScalingType ----
    if (FAILED(pRender->GetEnumValue(iPartId, iStateId, TMT_TRUESIZESCALINGTYPE, (int *)&_eTrueSizeScalingType)))
        _eTrueSizeScalingType = TSST_NONE;      // default
    
    //---- sizing ----
    if (FAILED(pRender->GetEnumValue(iPartId, iStateId, TMT_SIZINGTYPE, (int *)&pdi->eSizingType)))
        pdi->eSizingType = ST_STRETCH;       // default

    if (FAILED(pRender->GetBool(iPartId, iStateId, TMT_BORDERONLY, &pdi->fBorderOnly)))
        pdi->fBorderOnly = FALSE;

    if (FAILED(pRender->GetInt(iPartId, iStateId, TMT_TRUESIZESTRETCHMARK, &_iTrueSizeStretchMark)))
        _iTrueSizeStretchMark = 0;      // default

    if (FAILED(pRender->GetBool(iPartId, iStateId, TMT_UNIFORMSIZING, &_fUniformSizing)))
        _fUniformSizing = FALSE;        // default

    if (FAILED(pRender->GetBool(iPartId, iStateId, TMT_INTEGRALSIZING, &_fIntegralSizing)))
        _fIntegralSizing = FALSE;        // default

    //---- transparency ----
    if (FAILED(pRender->GetBool(iPartId, iStateId, TMT_TRANSPARENT, &pdi->fTransparent)))
        pdi->fTransparent = FALSE;

    if (pdi->fTransparent)
    {
        if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_TRANSPARENTCOLOR, &pdi->crTransparent)))
            pdi->crTransparent = DEFAULT_TRANSPARENT_COLOR; 
    }

    //---- MirrorImage ----
    if (FAILED(pRender->GetBool(iPartId, iStateId, TMT_MIRRORIMAGE, &_fMirrorImage)))
        _fMirrorImage = TRUE;              // default setting

    //---- alignment ----
    if (FAILED(pRender->GetEnumValue(iPartId, iStateId, TMT_HALIGN, (int *)&_eHAlign)))
        _eHAlign = HA_CENTER;      // default value

    if (FAILED(pRender->GetEnumValue(iPartId, iStateId, TMT_VALIGN, (int *)&_eVAlign)))
        _eVAlign = VA_CENTER;      // default value

    //---- for regular or glyph truesize images ----
    if (SUCCEEDED(pRender->GetBool(iPartId, iStateId, TMT_BGFILL, &_fBgFill)))
    {
        //---- get fill color ----
        if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_FILLCOLOR, &_crFill)))
            _crFill = RGB(255, 255, 255);
    }

    //---- SizingMargins ----
    if (FAILED(pRender->GetMargins(NULL, iPartId, iStateId, TMT_SIZINGMARGINS, 
        NULL, &_SizingMargins)))
    {
        _SizingMargins.cxLeftWidth = 0;
        _SizingMargins.cxRightWidth = 0;
        _SizingMargins.cyTopHeight = 0;
        _SizingMargins.cyBottomHeight = 0;
    }

    //---- ContentMargins ----
    if (FAILED(pRender->GetMargins(NULL, iPartId, iStateId, TMT_CONTENTMARGINS, 
        NULL, &_ContentMargins)))
    {
        _ContentMargins = _SizingMargins;
    }

    //---- SourceGrow ----
    if (FAILED(pRender->GetBool(iPartId, iStateId, TMT_SOURCEGROW, &_fSourceGrow)))
        _fSourceGrow = FALSE;         // default

    //---- SourceShrink ----
    if (FAILED(pRender->GetBool(iPartId, iStateId, TMT_SOURCESHRINK, &_fSourceShrink)))
        _fSourceShrink = FALSE;       // default

    //---- NormalSize ----
    if (FAILED(pRender->GetPosition(iPartId, iStateId, TMT_NORMALSIZE, (POINT *)&_szNormalSize)))
    {
        _szNormalSize.cx = 60;
        _szNormalSize.cy = 30;
    }
    else
    {
        AdjustSizeMin(&_szNormalSize, 1, 1);
    }

    //---- glphytype ----
    if (FAILED(pRender->GetEnumValue(iPartId, iStateId, TMT_GLYPHTYPE, (int *)&_eGlyphType)))
        _eGlyphType = GT_NONE;      // default value

    if (_eGlyphType == GT_FONTGLYPH)
    {
        //---- font-based glyphs ----
        if (FAILED(pRender->GetFont(NULL, iPartId, iStateId, TMT_GLYPHFONT, FALSE, &_lfGlyphFont)))
            goto exit;              // required

        if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_GLYPHTEXTCOLOR, &_crGlyphTextColor)))
            _crGlyphTextColor = RGB(0, 0, 0);       // default color

        if (FAILED(pRender->GetInt(iPartId, iStateId, TMT_GLYPHINDEX, &_iGlyphIndex)))
            _iGlyphIndex = 1;               // default index
    }
    else if (_eGlyphType == GT_IMAGEGLYPH)
    {
        //---- image-based glyphs ----
        pdi = &_GlyphInfo;

        pdi->iMinDpi = 96;      // only way this gets set for now

        pdi->iDibOffset = pRender->GetValueIndex(iPartId, iStateId, TMT_GLYPHDIBDATA);
        if (pdi->iDibOffset == -1)
            pdi->iDibOffset = 0;

        if (pdi->iDibOffset > 0)       // found 
        {
            hr = SetImageInfo(pdi, pRender, iPartId, iStateId);
            if (FAILED(hr))
                goto exit;
        }

        if (SUCCEEDED(pRender->GetBool(iPartId, iStateId, TMT_GLYPHTRANSPARENT, &pdi->fTransparent)))
        {
            if (FAILED(pRender->GetColor(iPartId, iStateId, TMT_GLYPHTRANSPARENTCOLOR, &pdi->crTransparent)))
                pdi->crTransparent = DEFAULT_TRANSPARENT_COLOR;
        }

        pdi->eSizingType = ST_TRUESIZE;     // glyphs are always true size
        pdi->fBorderOnly = FALSE;           // glyphs are never borderonly (for now)
    }

    if (_eGlyphType != GT_NONE)
    {
        if (FAILED(pRender->GetBool(iPartId, iStateId, TMT_GLYPHONLY, &_fGlyphOnly)))
            _fGlyphOnly = FALSE;
    }

    //---- multi files specified? ----
    if (FAILED(pRender->GetEnumValue(iPartId, iStateId, TMT_IMAGESELECTTYPE, (int *)&_eImageSelectType)))
        _eImageSelectType = IST_NONE;

    //---- fill in multi DIBINFO's ----
    if (_eImageSelectType != IST_NONE)
    {
        DIBINFO *pParent;

        if (_eGlyphType == GT_IMAGEGLYPH)
        {
            pParent = &_GlyphInfo;
        }
        else
        {
            pParent = &_ImageInfo;
        }

        for (int i=0; i < MAX_IMAGEFILE_SIZES; i++)
        {
            //---- get ImageFileN ----
            int iDibOffset = pRender->GetValueIndex(iPartId, iStateId, TMT_DIBDATA1 + i);
            if (iDibOffset == -1)
                break;

            _iMultiImageCount++;

            DIBINFO *pdi = MultiDibPtr(i);
        
            *pdi = *pParent;        // inherit some props from parent
            pdi->iDibOffset = iDibOffset;

            hr = SetImageInfo(pdi, pRender, iPartId, iStateId);
            if (FAILED(hr))
                goto exit;

            //---- get MinDpiN ----
            if (FAILED(pRender->GetInt(iPartId, iStateId, TMT_MINDPI1 + i, &pdi->iMinDpi)))
            {
                pdi->iMinDpi = 96;     // default
            }
            else
            {
                //---- ensure value >= 1 ----
                if (pdi->iMinDpi < 1)
                {
                    pdi->iMinDpi = 1;
                }
            }

            //---- get MinSizeN ----
            if (FAILED(pRender->GetPosition(iPartId, iStateId, TMT_MINSIZE1 + i,
                (POINT *)&pdi->szMinSize)))
            {
                pdi->szMinSize.cx  = pdi->iSingleWidth;
                pdi->szMinSize.cy  = pdi->iSingleHeight;
            }
            else
            {
                AdjustSizeMin(&pdi->szMinSize, 1, 1);
            }

        }

        if (_iMultiImageCount > 0)
        {
            *pParent = *MultiDibPtr(0);     // use first multi entry as primary object
        }
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
BOOL CImageFile::KeyProperty(int iPropId)
{
    BOOL fKey = FALSE;

    switch (iPropId)
    {
        case TMT_BGTYPE:
        case TMT_TRANSPARENT:
        case TMT_AUTOSIZE:
        case TMT_BORDERONLY:
        case TMT_IMAGECOUNT:
        case TMT_ALPHALEVEL:
        case TMT_ALPHATHRESHOLD:
        case TMT_IMAGEFILE:
        case TMT_IMAGEFILE1:
        case TMT_IMAGEFILE2:
        case TMT_IMAGEFILE3:
        case TMT_IMAGEFILE4:
        case TMT_IMAGEFILE5:
        case TMT_SIZINGMARGINS:
        case TMT_CONTENTMARGINS:
        case TMT_TRANSPARENTCOLOR:
        case TMT_SIZINGTYPE:
        case TMT_HALIGN:
        case TMT_VALIGN:
        case TMT_IMAGELAYOUT:
        case TMT_BGFILL:
        case TMT_MIRRORIMAGE:
        case TMT_TRUESIZESTRETCHMARK:
        case TMT_TRUESIZESCALINGTYPE:
        case TMT_IMAGESELECTTYPE:
        case TMT_UNIFORMSIZING:
        case TMT_INTEGRALSIZING:
        case TMT_SOURCEGROW:
        case TMT_SOURCESHRINK:
        case TMT_NORMALSIZE:
        case TMT_MINSIZE:
        case TMT_MINSIZE1:
        case TMT_MINSIZE2:
        case TMT_MINSIZE3:
        case TMT_MINSIZE4:
        case TMT_MINSIZE5:
        case TMT_MINDPI1:
        case TMT_MINDPI2:
        case TMT_MINDPI3:
        case TMT_MINDPI4:
        case TMT_MINDPI5:

        //---- glyph properties ----
        case TMT_GLYPHTYPE:
        case TMT_GLYPHIMAGEFILE:
        case TMT_GLYPHTRANSPARENT:
        case TMT_GLYPHTRANSPARENTCOLOR:
        case TMT_GLYPHFONT:
        case TMT_GLYPHINDEX:
        case TMT_GLYPHTEXTCOLOR:
        case TMT_GLYPHONLY:

        // case TMT_FILLCOLOR:  - this prop belongs to BorderFill (we borrow it)

            fKey = TRUE;
            break;
    }

    return fKey;
}
//---------------------------------------------------------------------------
DIBINFO *CImageFile::EnumImageFiles(int iIndex)
{
    DIBINFO *pdi = NULL;
    BOOL fHasGlyph = (_eGlyphType == GT_IMAGEGLYPH);

    //---- enum in this order: primary, glyph, multi images ----

    if (iIndex == 0)
    {
        pdi = &_ImageInfo;
    }
    else if (iIndex == 1)  
    {
        if (fHasGlyph)
            pdi = &_GlyphInfo;
    }

    if (! pdi)          // not yet set
    {
        if (fHasGlyph)
            iIndex -= 2;
        else
            iIndex -= 1;

        if (iIndex < _iMultiImageCount)
        {
            pdi = MultiDibPtr(iIndex);
        }
    }

    return pdi;
}
//---------------------------------------------------------------------------
void CImageFile::DumpProperties(CSimpleFile *pFile, BYTE *pbThemeData, BOOL fFullInfo)
{
    if (fFullInfo)
        pFile->OutLine(L"Dump of CImageFile at offset=0x%x", (BYTE *)this - pbThemeData);
    else
        pFile->OutLine(L"Dump of CImageFile");
    
    pFile->OutLine(L"  _eBgType=%d", _eBgType);

    DIBINFO *pdi = &_ImageInfo;

    if (fFullInfo)
    {
        pFile->OutLine(L"  iDibOffset=%d, _iImageCount=%d, _eImageLayout=%d",
            pdi->iDibOffset, _iImageCount, _eImageLayout);
    }
    else
    {
        pFile->OutLine(L"  _iImageCount=%d, _eImageLayout=%d, MinSize=(%d, %d)",
            _iImageCount, _eImageLayout, pdi->szMinSize.cx, pdi->szMinSize.cy);
    }

    pFile->OutLine(L"  _iSingleWidth=%d, _iSingleHeight=%d, _fMirrorImage=%d",
        pdi->iSingleWidth, pdi->iSingleHeight, _fMirrorImage);

    //---- dump multiple image info ----
    for (int i=0; i < _iMultiImageCount; i++)
    {
        DIBINFO *pdi = MultiDibPtr(i);

        pFile->OutLine(L"  Multi[%d]: sw=%d, sh=%d, diboff=%d, rgnoff=%d",
            i, pdi->iSingleWidth, pdi->iSingleHeight,
            (pdi->iDibOffset > 0), (pdi->iRgnListOffset > 0));

        pFile->OutLine(L"      MinDpi=%d, MinSize=(%d, %d)",
            pdi->iMinDpi, pdi->szMinSize.cx, pdi->szMinSize.cy);

        pFile->OutLine(L"    sizetype=%d, bordonly=%d, fTrans=%d, crTrans=0x%x, fAlpha=%d, iAlphaThres=%d",
            pdi->eSizingType, pdi->fBorderOnly, pdi->fTransparent, pdi->crTransparent, 
            pdi->fAlphaChannel, pdi->iAlphaThreshold);
    }

    pFile->OutLine(L"  _eSizingType=%d, _fBorderOnly=%d, _eTrueSizeScalingType=%d",
        pdi->eSizingType, pdi->fBorderOnly, _eTrueSizeScalingType);

    pFile->OutLine(L"  _fTransparent=%d, _crTransparent=0x%08x",
        pdi->fTransparent, pdi->crTransparent);

    pFile->OutLine(L"  _fAlphaChannel=%d, _iAlphaThreshold=%d",
        pdi->fAlphaChannel, pdi->iAlphaThreshold);

    pFile->OutLine(L"  _eHAlign=%d, _eVAlign=%d, _iTrueSizeStretchMark=%d",
        _eHAlign, _eVAlign, _iTrueSizeStretchMark);

    pFile->OutLine(L"  _fUniformSizing=%d, _fIntegralSizing=%d",
        _fUniformSizing, _fIntegralSizing);

    pFile->OutLine(L"  _fBgFill=%d, _crFill=0x%08x",
        _fBgFill, _crFill);

    pFile->OutLine(L"  _fSourceGrow=%d, _fSourceShrink=%d, _szNormalSize=(%d, %d)",
        _fSourceGrow, _fSourceShrink, _szNormalSize.cx, _szNormalSize.cy);

    pFile->OutLine(L"  _SizingMargins=%d, %d, %d, %d", 
        _SizingMargins.cxLeftWidth, _SizingMargins.cxRightWidth,
        _SizingMargins.cyTopHeight, _SizingMargins.cyBottomHeight);

    pFile->OutLine(L"  _ContentMargins=%d, %d, %d, %d", 
        _ContentMargins.cxLeftWidth, _ContentMargins.cxRightWidth,
        _ContentMargins.cyTopHeight, _ContentMargins.cyBottomHeight);

    pFile->OutLine(L" _fFontGlyph=%d, _iGlyphIndex=%d, _crGlyphTextColor=0x%x",
        (_eGlyphType==GT_FONTGLYPH), _iGlyphIndex, _crGlyphTextColor);

    pFile->OutLine(L" _lfGlyphFont=%s, _fGlyphOnly=%d, _fImageGlyph=%d",
        _lfGlyphFont.lfFaceName, _fGlyphOnly, (_eGlyphType==GT_IMAGEGLYPH));

    //---- dump glyph properties ----
    pdi = &_GlyphInfo;

    if (fFullInfo)
    {
        pFile->OutLine(L" Glyph: iDibOffset=%d, iSingleWidth=%d, iSingleHeight=%d",
            pdi->iDibOffset, pdi->iSingleWidth, pdi->iSingleHeight);
    }
    else
    {
        pFile->OutLine(L" _iGlyphSingleWidth=%d, _iGlyphSingleHeight=%d",
            pdi->iSingleWidth, pdi->iSingleHeight);
    }

    pFile->OutLine(L" _fGlyphTransparent=%d, _crGlyphTransparent=0x%x, _fGlyphAlpha=%d",
        pdi->fTransparent, pdi->crTransparent, pdi->fAlphaChannel);

    //pFile->OutLine(L" Glyph: iAlphaThreshold=%d", pdi->iAlphaThreshold);
}
//---------------------------------------------------------------------------
HRESULT CImageFile::SetImageInfo(DIBINFO *pdi, CRenderObj *pRender, int iPartId, int iStateId)
{
    HRESULT hr = S_OK;

    if (! pRender->_pbThemeData)
    {
        hr = E_FAIL;        
        goto exit;
    }

    TMBITMAPHEADER *pThemeBitmapHeader = NULL;

    pThemeBitmapHeader = reinterpret_cast<TMBITMAPHEADER*>(pRender->_pbThemeData + pdi->iDibOffset);
    ASSERT(pThemeBitmapHeader->dwSize == TMBITMAPSIZE);
    
    pdi->fAlphaChannel = pThemeBitmapHeader->fTrueAlpha;
    if (pdi->fAlphaChannel)
    {
        if (FAILED(pRender->GetBool(iPartId, iStateId, TMT_ALPHATHRESHOLD, &pdi->iAlphaThreshold)))
            pdi->iAlphaThreshold = 255;
    }

    int iWidth = - 1;
    int iHeight = -1;

    if (pThemeBitmapHeader->hBitmap)
    {
        BITMAP bmInfo;
        if (GetObject(pThemeBitmapHeader->hBitmap, sizeof(bmInfo), &bmInfo))
        {
            iWidth = bmInfo.bmWidth;
            iHeight = bmInfo.bmHeight;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        BITMAPINFOHEADER* pbmInfo = BITMAPDATA(pThemeBitmapHeader);
        if (pbmInfo)
        {
            iWidth = pbmInfo->biWidth;
            iHeight = pbmInfo->biHeight;
        }
        else
        {
            hr = E_FAIL;
        }
    }

     //---- get SingleWidth/SingleHeight of bitmap ----
    if ((iWidth != -1) && (iHeight != -1))
    {
        if (_eImageLayout == IL_HORIZONTAL)
        {
            pdi->iSingleWidth = iWidth / _iImageCount;       
            pdi->iSingleHeight = iHeight;
        }
        else        // vertical
        {
            pdi->iSingleWidth = iWidth;
            pdi->iSingleHeight = iHeight / _iImageCount;       
        }
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
BOOL CImageFile::HasRegionImageFile(DIBINFO *pdi, int *piMaxState)
{
    BOOL fGot = FALSE;

    if ((pdi->fTransparent) || (pdi->fAlphaChannel))
    {
        if (pdi->iDibOffset > 0)
        {
            fGot = TRUE;
            *piMaxState = _iImageCount;
        }
    }

    return fGot;
}
//---------------------------------------------------------------------------
void CImageFile::SetRgnListOffset(DIBINFO *pdi, int iOffset)
{
    //---- get offset to the actual jump table  ----
    pdi->iRgnListOffset = iOffset + ENTRYHDR_SIZE;
}
//---------------------------------------------------------------------------
HRESULT CImageFile::BuildRgnData(DIBINFO *pdi, CRenderObj *pRender, int iStateId, RGNDATA **ppRgnData, 
     int *piDataLen)
{
    RESOURCE HRGN hrgn = NULL;
    RESOURCE RGNDATA *pRgnData = NULL;
    int iTotalBytes = 0;
    int iRectCount;
    DWORD len, len2;
    HBITMAP hBitmap = NULL;
    HRESULT hr = S_OK;
    BOOL fStock = FALSE;

    if ((! pdi->fAlphaChannel) && (! pdi->fTransparent))        // empty region
        goto gotit;
    
    if (pRender->_pbThemeData && pdi->iDibOffset > 0)
    {
        fStock = ((reinterpret_cast<TMBITMAPHEADER*>(pRender->_pbThemeData + pdi->iDibOffset))->hBitmap != NULL);
    }

    hr = pRender->GetBitmap(NULL, pdi->iDibOffset, &hBitmap);
    if (FAILED(hr))
        goto exit;

    int iXOffset, iYOffset;
    GetOffsets(iStateId, pdi, &iXOffset, &iYOffset);

    //---- create a region ----
    hr = CreateBitmapRgn(hBitmap, iXOffset, iYOffset, pdi->iSingleWidth, pdi->iSingleHeight,
        pdi->fAlphaChannel, pdi->iAlphaThreshold, pdi->crTransparent, 0, &hrgn);
    if (FAILED(hr))
    {
        //---- soft error - author said it was transparent but it wasn't ----
        hr = S_OK;
        goto gotit;
    }
    
    //---- extract region data ----
    len = GetRegionData(hrgn, 0, NULL);       // get required length
    if (! len)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    iRectCount = len/sizeof(RECT);     // # of rects
    len += ((sizeof(BYTE)+sizeof(BYTE))*iRectCount);        // room for grid id's for each point

    iTotalBytes = len + sizeof(RGNDATAHEADER);
    pRgnData = (RGNDATA *) new BYTE[iTotalBytes];
    len2 = GetRegionData(hrgn, len, pRgnData);
    if (! len2)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    //---- grid-ize the point values within each rect ----
    RECT  rcImage;
    SetRect( &rcImage, 0, 0, pdi->iSingleWidth, pdi->iSingleHeight ); 

    hr = pRender->PrepareRegionDataForScaling(pRgnData, &rcImage, &_SizingMargins);
    if (FAILED(hr))
        goto exit;

gotit:
    *ppRgnData = pRgnData;
    *piDataLen = iTotalBytes;

exit:

    if (hBitmap && !fStock)
    {
        pRender->ReturnBitmap(hBitmap);
    }

    if (hrgn)
        DeleteObject(hrgn);

    if (FAILED(hr))
    {
        if (pRgnData)
            delete [] pRgnData;
    }

    return hr;
}
//---------------------------------------------------------------------------
// Helper function for DrawBackgroundDS
void StreamSetSource(BYTE** pvStream, HBITMAP hbmSrc)
{
    DS_SETSOURCE* pdsSetSource = (DS_SETSOURCE*)*pvStream;
    pdsSetSource->ulCmdID = DS_SETSOURCEID;
    pdsSetSource->hbm = HandleToULong(hbmSrc);
    *pvStream += sizeof(DS_SETSOURCE);
}
//---------------------------------------------------------------------------
void StreamInit(BYTE** pvStream, HDC hdcDest, HBITMAP hbmSrc, RECTL* prcl)
{
    DS_HEADER* pdsHeader = (DS_HEADER*)*pvStream;
    pdsHeader->magic = DS_MAGIC;
    *pvStream += sizeof(DS_HEADER);

    DS_SETTARGET* pdsSetTarget = (DS_SETTARGET*)*pvStream;
    pdsSetTarget->ulCmdID = DS_SETTARGETID;
    pdsSetTarget->hdc = HandleToULong(hdcDest);
    pdsSetTarget->rclDstClip = *prcl;
    *pvStream += sizeof(DS_SETTARGET);

    StreamSetSource(pvStream, hbmSrc);
}
//---------------------------------------------------------------------------
HBITMAP CreateScaledTempBitmap(HDC hdc, HBITMAP hSrcBitmap, int ixSrcOffset, int iySrcOffset,
    int iSrcWidth, int iSrcHeight, int iDestWidth, int iDestHeight)
{
    HBITMAP hTempBitmap = NULL;

    if (hSrcBitmap)        // create a DIB from caller's bitmap (Clipper test program)
    {
        //---- reuse our bitmap ----
        hTempBitmap = g_pBitmapCacheScaled->AcquireBitmap(hdc, iDestWidth, iDestHeight);
        if (hTempBitmap)
        {
            HDC hdcDest = CreateCompatibleDC(hdc);
            if (hdcDest)
            {
                HBITMAP hOldDestBitmap = (HBITMAP)SelectObject(hdcDest, hTempBitmap);

                HDC hdcSrc = CreateCompatibleDC(hdc);
                if (hdcSrc)
                {
                    SetLayout(hdcSrc, 0);
                    SetLayout(hdcDest, 0);

                    HBITMAP hOldSrcBitmap = (HBITMAP) SelectObject(hdcSrc, hSrcBitmap);

                    int iOldSM = SetStretchBltMode(hdcDest, COLORONCOLOR);

                    //---- stretch src to dest ----
                    StretchBlt(hdcDest, 0, 0, iDestWidth, iDestHeight, 
                        hdcSrc, ixSrcOffset, iySrcOffset, iSrcWidth, iSrcHeight, 
                        SRCCOPY);

                    SetStretchBltMode(hdcDest, iOldSM);

                    SelectObject(hdcSrc, hOldSrcBitmap);
                    DeleteDC(hdcSrc);
                }

                SelectObject(hdcDest, hOldDestBitmap);
                DeleteDC(hdcDest);
            }
        }
    }

    return hTempBitmap;
}
//---------------------------------------------------------------------------
HBITMAP CreateUnscaledTempBitmap(HDC hdc, HBITMAP hSrcBitmap, int ixSrcOffset, int iySrcOffset,
    int iDestWidth, int iDestHeight)
{
    HBITMAP hTempBitmap = NULL;

    if (hSrcBitmap)        // create a DIB from caller's bitmap (Clipper test program)
    {
        //---- reuse our bitmap ----
        hTempBitmap = g_pBitmapCacheUnscaled->AcquireBitmap(hdc, iDestWidth, iDestHeight);
        if (hTempBitmap)
        {
            HDC hdcDest = CreateCompatibleDC(hdc);
            if (hdcDest)
            {
                HBITMAP hOldDestBitmap = (HBITMAP) SelectObject(hdcDest, hTempBitmap);
                
                HDC hdcSrc = CreateCompatibleDC(hdc);
                if (hdcSrc)
                {
                    SetLayout(hdcSrc, 0);
                    SetLayout(hdcDest, 0);

                    HBITMAP hOldSrcBitmap = (HBITMAP) SelectObject(hdcSrc, hSrcBitmap);

                    //---- copy src to dest ----
                    BitBlt(hdcDest, 0, 0, iDestWidth, iDestHeight, hdcSrc, ixSrcOffset, iySrcOffset, 
                        SRCCOPY);

                    SelectObject(hdcSrc, hOldSrcBitmap);
                    DeleteDC(hdcSrc);
                }

                SelectObject(hdcDest, hOldDestBitmap);
                DeleteDC(hdcDest);
            }
        }
    }

    return hTempBitmap;
}
//---------------------------------------------------------------------------
HRESULT CImageFile::DrawBackgroundDS(DIBINFO *pdi, TMBITMAPHEADER *pThemeBitmapHeader, BOOL fStock, 
    CRenderObj *pRender, HDC hdc, int iStateId, const RECT *pRect, BOOL fForceStretch, 
    MARGINS *pmarDest, float xMarginFactor, float yMarginFactor, OPTIONAL const DTBGOPTS *pOptions)
{
    //---- bitmaps we may create ----
    HBITMAP hBitmapStock = NULL;
    HBITMAP hBitmapTempScaled = NULL;
    HBITMAP hBitmapTempUnscaled = NULL;

    //---- copy of bitmap handle to use ----
    HBITMAP hDsBitmap = NULL;
    HRESULT hr = S_OK;

    int iTempSrcWidth = pdi->iSingleWidth;
    int iTempSrcHeight = pdi->iSingleHeight;

    int iXOffset, iYOffset;
    GetOffsets(iStateId, pdi, &iXOffset, &iYOffset);

    if (pThemeBitmapHeader)    // get stock bitmap (32 bit format)
    {
        hr = pRender->GetBitmap(hdc, pdi->iDibOffset, &hBitmapStock);
        if (FAILED(hr))
            goto exit;

        hDsBitmap = hBitmapStock;
    }
    else                        // caller passed in bitmap (unknown format)
    {
        hBitmapTempUnscaled = CreateUnscaledTempBitmap(hdc, pdi->hProcessBitmap, iXOffset, iYOffset, 
            pdi->iSingleWidth, pdi->iSingleHeight);
        if (! hBitmapTempUnscaled)
        {
            hr = E_FAIL;
            goto exit;
        }

        hDsBitmap = hBitmapTempUnscaled;

        //---- src is now just a single image ----
        iXOffset = iYOffset = 0;
    }

    //---- handle scaled margins ----
    if ((xMarginFactor != 1) || (yMarginFactor != 1))  
    {
        iTempSrcWidth = int(pdi->iSingleWidth * xMarginFactor);
        iTempSrcHeight = int(pdi->iSingleHeight * yMarginFactor);

        hBitmapTempScaled = CreateScaledTempBitmap(hdc, hDsBitmap, iXOffset, iYOffset,
            pdi->iSingleWidth, pdi->iSingleHeight, iTempSrcWidth, iTempSrcHeight);
        if (! hBitmapTempScaled)
        {
            hr = E_FAIL;
            goto exit;
        }

        hDsBitmap = hBitmapTempScaled;

        //---- src is now just a single image ----
        iXOffset = iYOffset = 0;
    }

    if (hDsBitmap)
    {

        RECTL rclSrc  = { iXOffset, iYOffset, iXOffset + iTempSrcWidth, iYOffset + iTempSrcHeight };
        RECTL rclDest = { pRect->left, pRect->top, pRect->right, pRect->bottom };

        // Flip Dest Rect if someone passed us inverted co-ordinates
        if (rclDest.left > rclDest.right)
        {
            int xTemp = rclDest.left;
            rclDest.left = rclDest.right;
            rclDest.right = xTemp;
        }
        if (rclDest.top > rclDest.bottom)
        {
            int yTemp = rclDest.bottom;
            rclDest.bottom = rclDest.top;
            rclDest.top = yTemp;
        }

        DWORD dwOptionFlags = 0;
        if (pOptions)
        {
            dwOptionFlags = pOptions->dwFlags;
        }

        // Initialize Drawing Stream
        BYTE   stream[500];
        BYTE*  pvStreamStart = stream;
        BYTE*  pvStream = stream;

        RECTL  rclClip = rclDest;

        if (dwOptionFlags & DTBG_CLIPRECT)
        {
            IntersectRect((LPRECT)&rclClip, (LPRECT)&rclDest, &pOptions->rcClip);
        }

        StreamInit(&pvStream, hdc, hDsBitmap, &rclClip);

        DS_NINEGRID* pvNineGrid = (DS_NINEGRID*)pvStream;
        pvNineGrid->ulCmdID = DS_NINEGRIDID;

        if ((fForceStretch) || (pdi->eSizingType == ST_STRETCH))
        {
            pvNineGrid->ngi.flFlags = DSDNG_STRETCH;
        }
        else if (pdi->eSizingType == ST_TRUESIZE)
        {
            pvNineGrid->ngi.flFlags = DSDNG_TRUESIZE;
        }
        else 
        {
            pvNineGrid->ngi.flFlags = DSDNG_TILE;
        }

        if (pdi->fAlphaChannel)
        {
            pvNineGrid->ngi.flFlags |= DSDNG_PERPIXELALPHA;
        }
        else if (pdi->fTransparent)
        {
            pvNineGrid->ngi.flFlags |= DSDNG_TRANSPARENT;
        }

        if ((dwOptionFlags & DTBG_MIRRORDC) || (IsMirrored(hdc)))
        {
            if (_fMirrorImage)
            {
                pvNineGrid->ngi.flFlags |= DSDNG_MUSTFLIP;

                //---- workaround: needed by GdiDrawStream if we don't have a mirrored DC ----
                //---- gdi should only look at the DSDNG_MUSTFLIP flag ----
                if (! IsMirrored(hdc))
                {
                    int xTemp = rclDest.left;
                    rclDest.left = rclDest.right;
                    rclDest.right = xTemp;
                }
            }
        }

        pvNineGrid->rclDst = rclDest;
        pvNineGrid->rclSrc = rclSrc;

        if (pdi->eSizingType == ST_TRUESIZE)
        {
            pvNineGrid->ngi.ulLeftWidth    = 0;
            pvNineGrid->ngi.ulRightWidth   = 0;
            pvNineGrid->ngi.ulTopHeight    = 0;
            pvNineGrid->ngi.ulBottomHeight = 0;
        } 
        else
        {
            //---- copy scaled Src margins ----
            pvNineGrid->ngi.ulLeftWidth    = pmarDest->cxLeftWidth;
            pvNineGrid->ngi.ulRightWidth   = pmarDest->cxRightWidth;
            pvNineGrid->ngi.ulTopHeight    = pmarDest->cyTopHeight;
            pvNineGrid->ngi.ulBottomHeight = pmarDest->cyBottomHeight;
        }
        
        pvNineGrid->ngi.crTransparent  = pdi->crTransparent;

        pvStream += sizeof(DS_NINEGRID);

        GdiDrawStream(hdc, (int)(pvStream - pvStreamStart), (char*) pvStreamStart);

    }
    else
    {
        hr = E_FAIL;
    }

exit:
    //---- clean up temp bitmaps ----
    if (hBitmapTempScaled)
    {
        g_pBitmapCacheScaled->ReturnBitmap();
    }

    if (hBitmapTempUnscaled)
    {
        g_pBitmapCacheUnscaled->ReturnBitmap();
    }

    if ((hBitmapStock) && (! fStock))       // not really stock (was "create on demand")
    {
        pRender->ReturnBitmap(hBitmapStock);
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CImageFile::DrawBackgroundDNG(DIBINFO *pdi, TMBITMAPHEADER *pThemeBitmapHeader, BOOL fStock, CRenderObj *pRender, 
    HDC hdc, int iStateId, const RECT *pRect, BOOL fForceStretch,
    MARGINS *pmarDest, OPTIONAL const DTBGOPTS *pOptions)
{
    HRESULT hr = E_FAIL;

    //---- options ----
    DWORD dwOptionFlags = 0;
    const RECT *pClipRect = NULL;

    if (pOptions)
    {
        dwOptionFlags = pOptions->dwFlags;

        if (dwOptionFlags & DTBG_CLIPRECT)
            pClipRect = &pOptions->rcClip;
    }

    int iXOffset, iYOffset;
    GetOffsets(iStateId, pdi, &iXOffset, &iYOffset);

    DWORD dwFlags = 0;

    if (! (dwOptionFlags & DTBG_DRAWSOLID))
    {
        if (pdi->fTransparent)
        {
            dwFlags = NGI_TRANS;
        }
        if (pdi->fAlphaChannel)
        {
            dwFlags = NGI_ALPHA;
        }
    }

    ULONG* pvSrcBits = NULL;
    int iWidth = 0; 
    int iHeight = 0;
    BOOL fFreeBits = FALSE;

    if (pThemeBitmapHeader)
    {
        BITMAPINFOHEADER* pHeader = BITMAPDATA(pThemeBitmapHeader);
        if (pHeader && pHeader->biBitCount == 32)
        {
            pvSrcBits = (ULONG*)DIBDATA(pHeader);
        }
        iWidth = pHeader->biWidth;
        iHeight = pHeader->biHeight;
    }
    else if (pdi->hProcessBitmap)
    {
        BITMAP bm;
        if (GetObject(pdi->hProcessBitmap, sizeof(bm), &bm))
        {
            BITMAPINFO bmInfo = {{sizeof(BITMAPINFOHEADER), bm.bmWidth, bm.bmHeight, 1, 32, BI_RGB, 0, 0, 0, 0, 0}, NULL};
            pvSrcBits = new DWORD[bm.bmWidth * bm.bmHeight];
            if (pvSrcBits)
            {
                if (GetDIBits(hdc, pdi->hProcessBitmap, 0, bm.bmHeight, pvSrcBits, &bmInfo, DIB_RGB_COLORS))
                {
                    fFreeBits = TRUE;
                    iWidth = bm.bmWidth;
                    iHeight = bm.bmHeight;
                }
                else
                {
                    delete[] pvSrcBits;
                    pvSrcBits = NULL;
                }
            }
        }
    }

    if (pvSrcBits)
    {
        NGIMAGE ngi;
        ngi.hbm = NULL;
        ngi.iWidth = pdi->iSingleWidth;
        ngi.iHeight = pdi->iSingleHeight;
        ngi.margin = _SizingMargins;
        //ngi.marDest = *pmarDest;
        ngi.dwFlags = dwFlags;
        ngi.crTrans = pdi->crTransparent;

        if (fForceStretch)
            ngi.eSize = ST_STRETCH;
        else
            ngi.eSize = pdi->eSizingType;
        
        DWORD dwDNGFlags = 0;

        if ((dwOptionFlags & DTBG_MIRRORDC) || (IsMirrored(hdc)))
        {
            if (_fMirrorImage)
            {
                dwDNGFlags |= DNG_MUSTFLIP;
            }
        }

        ngi.iBufWidth = iWidth;
        int iDibOffset = (iHeight - iYOffset) - pdi->iSingleHeight;
        ngi.pvBits = pvSrcBits + (iDibOffset * ngi.iBufWidth) + iXOffset;

        RECT rcDest = *pRect;

        if (pdi->fBorderOnly &&
           (RECTHEIGHT(&rcDest) > ngi.margin.cyTopHeight + ngi.margin.cyBottomHeight) &&
           (RECTWIDTH(&rcDest) > ngi.margin.cxLeftWidth + ngi.margin.cxRightWidth))
        {
            RECT rcTop = rcDest;
            RECT rcLeft = rcDest;
            RECT rcBottom = rcDest;
            RECT rcRight = rcDest;

            rcLeft.top    = rcRight.top    = rcTop.bottom = rcTop.top       + ngi.margin.cyTopHeight;
            rcLeft.bottom = rcRight.bottom = rcBottom.top = rcBottom.bottom - ngi.margin.cyBottomHeight;

            rcLeft.right = rcLeft.left   + ngi.margin.cxLeftWidth;
            rcRight.left = rcRight.right - ngi.margin.cxRightWidth;

            if (pClipRect)
            {
                IntersectRect(&rcLeft,   pClipRect, &rcLeft);
                IntersectRect(&rcTop,    pClipRect, &rcTop);
                IntersectRect(&rcRight,  pClipRect, &rcRight);
                IntersectRect(&rcBottom, pClipRect, &rcBottom);
            }

            hr = DrawNineGrid2(hdc, &ngi, &rcDest, &rcTop, dwDNGFlags);
            if (SUCCEEDED(hr))
            {
                hr = DrawNineGrid2(hdc, &ngi, &rcDest, &rcLeft, dwDNGFlags);
                if (SUCCEEDED(hr))
                {
                    hr = DrawNineGrid2(hdc, &ngi, &rcDest, &rcRight, dwDNGFlags);
                    if (SUCCEEDED(hr))
                    {
                        hr = DrawNineGrid2(hdc, &ngi, &rcDest, &rcBottom, dwDNGFlags);
                    }
                }
            }
        }
        else
        {
            hr = DrawNineGrid2(hdc, &ngi, &rcDest, pClipRect, dwDNGFlags);
        }

        if (fFreeBits)
        {
            delete[] pvSrcBits;
        }
    }

    if (FAILED(hr))
    {
        Log(LOG_ALWAYS, L"DrawBackground FAILED: class=%s, hr=0x%x", 
           SHARECLASS(pRender), hr);
    }

    return hr;
}
//---------------------------------------------------------------------------
DIBINFO *CImageFile::SelectCorrectImageFile(CRenderObj *pRender, HDC hdc, OPTIONAL const RECT *prc, 
    BOOL fForGlyph, OPTIONAL TRUESTRETCHINFO *ptsInfo)
{
    DIBINFO *pdiDefault = (fForGlyph) ? &_GlyphInfo : &_ImageInfo;
    DIBINFO *pdi = NULL;
    BOOL fForceRectSizing = FALSE;
    int iWidth = 1;      
    int iHeight = 1;    

    //---- do we need a screen dc? ----
    BOOL fReleaseDC = FALSE;
    if (! hdc)
    {
        hdc = GetWindowDC(NULL);
        if (hdc)
            fReleaseDC = TRUE;
    }

    if (prc)
    {
        iWidth = WIDTH(*prc);
        iHeight = HEIGHT(*prc);
    }

    //---- see if our clients wants to force a TRUESIZE to stretch ----
    if ((fForGlyph) || (_ImageInfo.eSizingType == ST_TRUESIZE))
    {   
        if ((pRender) && (pRender->_dwOtdFlags & OTD_FORCE_RECT_SIZING))
        {
            fForceRectSizing = TRUE;
        }
    }

    //---- find correct file by DPI or Size ----
    if ((fForGlyph) || (_eGlyphType != GT_IMAGEGLYPH))   // match multifiles to reg or glyph 
    {
        BOOL fSizing = FALSE;
        BOOL fDpi = FALSE;

        if ((fForceRectSizing) || (_eImageSelectType == IST_SIZE) || (_fSourceGrow))
        {
            if (prc)
                fSizing = TRUE;
        }
        else 
        {
            fDpi = (_eImageSelectType == IST_DPI);
        }

        if (fDpi)               // DPI-based image selection
        {
            int iMinDestDpi = __min(GetDeviceCaps(hdc, LOGPIXELSX), GetDeviceCaps(hdc, LOGPIXELSY));

            //---- search from largest to smallest ----
            for (int i=_iMultiImageCount-1; i >= 0; i--)
            {
                if (MultiDibPtr(i)->iMinDpi <= iMinDestDpi)     // got him
                {
                    pdi = MultiDibPtr(i);
                    break;
                }
            }
        }
        else if (fSizing)       // Sizing-base image selection
        {
            if (_iMultiImageCount)
            {
                //---- search from largest to smallest ----
                for (int i=_iMultiImageCount-1; i >= 0; i--)
                {
                    DIBINFO *pdii = MultiDibPtr(i);
                    if ((pdii->szMinSize.cx <= iWidth) && (pdii->szMinSize.cy <= iHeight))
                    {
                        pdi = pdii;
                        break;
                    }
                }
            }
        }
    }

    if (! pdi)      // no match found
    {
        pdi = pdiDefault;
    }

    //---- determine drawing size of selected file (MultiImage or regular) ----
    if (ptsInfo)       
    {
        ptsInfo->fForceStretch = FALSE;   
        ptsInfo->fFullStretch = FALSE;

        ptsInfo->szDrawSize.cx = 0;
        ptsInfo->szDrawSize.cy = 0;

        //---- this sizing only applies to TRUESIZE images ----
        if ((pdi->eSizingType == ST_TRUESIZE) && (_eTrueSizeScalingType != TSST_NONE))
        {
            if (prc)
            {
                //---- force an exact stretch match? ----
                if ((fForceRectSizing) || (pdi->iSingleWidth > iWidth) || (pdi->iSingleHeight > iHeight))
                {
                    //---- either Forced to stretch by caller or image is too big for dest RECT ----
                    ptsInfo->fForceStretch = TRUE;
                    ptsInfo->fFullStretch = TRUE;

                    ptsInfo->szDrawSize.cx = iWidth;
                    ptsInfo->szDrawSize.cy = iHeight;
                }
            }

            if (! ptsInfo->fForceStretch)       // keep trying..
            {
                //---- see if image is too small for dest RECT ---
                SIZE szTargetSize = {0, 0};
                
                if (_eTrueSizeScalingType == TSST_DPI)
                {
                    int ixDpiDc = GetDeviceCaps(hdc, LOGPIXELSX);
                    int iyDpiDc = GetDeviceCaps(hdc, LOGPIXELSY);
                    
                    szTargetSize.cx = MulDiv(pdi->iSingleWidth, ixDpiDc, pdi->iMinDpi);
                    szTargetSize.cy = MulDiv(pdi->iSingleHeight, iyDpiDc, pdi->iMinDpi);
                }
                else if ((_eTrueSizeScalingType == TSST_SIZE) && (prc))
                {
                    szTargetSize.cx = MulDiv(pdi->iSingleWidth, iWidth, pdi->szMinSize.cx);
                    szTargetSize.cy = MulDiv(pdi->iSingleHeight, iHeight, pdi->szMinSize.cy);
                }

                if (szTargetSize.cx)        // was set
                {
                    //---- clip targetsize against dest rect ----
                    if (prc)
                    {
                        szTargetSize.cx = __min(szTargetSize.cx, iWidth);
                        szTargetSize.cy = __min(szTargetSize.cy, iHeight);
                    }

                    int ixPercentExceed = 100*(szTargetSize.cx - pdi->iSingleWidth)/pdi->iSingleWidth;
                    int iyPercentExceed = 100*(szTargetSize.cy - pdi->iSingleHeight)/pdi->iSingleHeight;

                    if ((ixPercentExceed >= _iTrueSizeStretchMark) && (iyPercentExceed >= _iTrueSizeStretchMark))
                    {
                        ptsInfo->fForceStretch = TRUE;
                        ptsInfo->szDrawSize = szTargetSize;
                    }
                }
            }
        }
    }

    if (! pdi)
    {
        pdi = pdiDefault;
    }

    if (fReleaseDC)
    {
        ReleaseDC(NULL, hdc);
    }

    return pdi;
}
//---------------------------------------------------------------------------
void CImageFile::GetDrawnImageSize(DIBINFO *pdi, const RECT *pRect, TRUESTRETCHINFO *ptsInfo,
    SIZE *pszDraw)
{
    //---- szDraw is the size image will be drawn to ----
    if (pdi->eSizingType == ST_TRUESIZE)        
    {
        if (ptsInfo->fForceStretch) 
        {
            *pszDraw = ptsInfo->szDrawSize;

            //---- integral sizing (stretched truesize only) ----
            if ((_fIntegralSizing) && (! ptsInfo->fFullStretch))
            {
                float flFactX = float(ptsInfo->szDrawSize.cx)/pdi->iSingleWidth;
                float flFactY = float(ptsInfo->szDrawSize.cy)/pdi->iSingleHeight;

                //---- cast float's to int to get lowest int (vs. rounded) ----
                pszDraw->cx = pdi->iSingleWidth * int(flFactX);
                pszDraw->cy = pdi->iSingleHeight * int(flFactY);
            }
        }
        else        // use original image size
        {
            pszDraw->cx = pdi->iSingleWidth;
            pszDraw->cy = pdi->iSingleHeight;
        }

        //---- Uniform Sizing ----
        if (_fUniformSizing)
        {
            int iSingleWidth = pdi->iSingleWidth;
            int iSingleHeight = pdi->iSingleHeight;

            double fact1 = double(pszDraw->cx)/iSingleWidth;
            double fact2 = double(pszDraw->cy)/iSingleHeight;

            //---- select the smallest factor to use for both dims ----
            if (fact1 < fact2)
            {
                pszDraw->cy = int(iSingleHeight*fact1);
            }
            else if (fact1 > fact2)
            {
                pszDraw->cx = int(iSingleWidth*fact2);
            }
        }
    }
    else        // ST_TILE or ST_STRETCH: pRect determines size
    {
        if (pRect)
        {
            pszDraw->cx = WIDTH(*pRect);
            pszDraw->cy = HEIGHT(*pRect);
        }
        else        // void function so just return 0
        {
            pszDraw->cx = 0;
            pszDraw->cy = 0;
        }
    }
}
//---------------------------------------------------------------------------
HRESULT CImageFile::DrawImageInfo(DIBINFO *pdi, CRenderObj *pRender, HDC hdc, int iStateId,
    const RECT *pRect, const DTBGOPTS *pOptions, TRUESTRETCHINFO *ptsInfo)
{
    HRESULT hr = S_OK;
    TMBITMAPHEADER *pThemeBitmapHeader = NULL;
    BOOL fStock = FALSE;
    RECT rcLocal;
    DWORD dwFlags;
    SIZE szDraw;
    BOOL fRectFilled;
    MARGINS marDest;
    float xFactor;
    float yFactor;

    if (pOptions)
        dwFlags = pOptions->dwFlags;
    else
        dwFlags = 0;

    //---- validate bitmap header ----
    if (! pdi->hProcessBitmap)      // regular, section based DIB
    {
        if (pRender->_pbThemeData && pdi->iDibOffset > 0)
        {
            pThemeBitmapHeader = reinterpret_cast<TMBITMAPHEADER*>(pRender->_pbThemeData + pdi->iDibOffset);
            ASSERT(pThemeBitmapHeader->dwSize == TMBITMAPSIZE);
            fStock = (pThemeBitmapHeader->hBitmap != NULL);
        }

        if (!pRender->IsReady())
        {
            // Stock bitmaps in section are cleaning, don't try to paint with an old HBITMAP
            hr = E_FAIL;
            //Log(LOG_TMBITMAP, L"Obsolete theme section: class=%s", SHARECLASS(pRender));
            goto exit;
        }

        if (pThemeBitmapHeader == NULL)
        {
            hr = E_FAIL;
            Log(LOG_ALWAYS, L"No TMBITMAPHEADER: class=%s, hr=0x%x", SHARECLASS(pRender), hr);
            goto exit;
        }
    }

    //----- set szDraw to size image will be drawn at ----
    GetDrawnImageSize(pdi, pRect, ptsInfo, &szDraw);

    rcLocal = *pRect;
    fRectFilled = TRUE;

    //---- horizontal alignment ----
    if (WIDTH(rcLocal) > szDraw.cx)
    {
        fRectFilled = FALSE;

        if (_eHAlign == HA_LEFT)
        {
            rcLocal.right = rcLocal.left + szDraw.cx;
        }
        else if (_eHAlign == HA_CENTER)
        {
            rcLocal.left += (WIDTH(rcLocal) - szDraw.cx) / 2;
            rcLocal.right = rcLocal.left + szDraw.cx;
        }
        else
        {
            rcLocal.left = rcLocal.right - szDraw.cx;
        }
    }

    //---- vertical alignment ----
    if (HEIGHT(rcLocal) > szDraw.cy)
    {
        fRectFilled = FALSE;

        if (_eVAlign == VA_TOP)
        {
            rcLocal.bottom = rcLocal.top + szDraw.cy;
        }
        else if (_eVAlign == VA_CENTER)
        {
            rcLocal.top += (HEIGHT(rcLocal) - szDraw.cy) / 2;
            rcLocal.bottom = rcLocal.top + szDraw.cy;
        }
        else
        {
            rcLocal.top = rcLocal.bottom - szDraw.cy;
        }
    }

    //---- BgFill ----
    if ((! fRectFilled) && (! pdi->fBorderOnly) && (_fBgFill))
    {
        if (! (dwFlags & DTBG_OMITCONTENT))
        {
            //---- paint bg ----
            HBRUSH hbr = CreateSolidBrush(_crFill);
            if (! hbr)
            {
                hr = GetLastError();
                goto exit;
            }

            FillRect(hdc, pRect, hbr);
            DeleteObject(hbr);
        }
    }

    //---- calculate source/margin scaling factors ----
    marDest = _SizingMargins;

    if (pdi->eSizingType == ST_TRUESIZE)        // sizing margins ignored - no scaling needed
    {
        xFactor = 1;
        yFactor = 1;
    }
    else    
    {
        //---- scale destination sizing margins ----
        ScaleMargins(&marDest, hdc, pRender, pdi, &szDraw, &xFactor, &yFactor);
    }
        
#if 1         // keep this in sync with #if in parser.cpp

    //---- new GDI drawing ----
    hr = DrawBackgroundDS(pdi, pThemeBitmapHeader, fStock, pRender, hdc, iStateId, &rcLocal, 
        ptsInfo->fForceStretch, &marDest, xFactor, yFactor, pOptions);

#else

    //---- old drawing (keep around until DS is burned in) ----
    hr = DrawBackgroundDNG(pdi, pThemeBitmapHeader, fStock, pRender, hdc, iStateId, &rcLocal, 
        ptsInfo->fForceStretch, &marDest, pOptions);
    
#endif

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CImageFile::DrawBackground(CRenderObj *pRender, HDC hdc, int iStateId,
    const RECT *pRect, OPTIONAL const DTBGOPTS *pOptions)
{
    HRESULT hr = S_OK;
    TRUESTRETCHINFO tsInfo;

    if (! _fGlyphOnly)
    {
        DIBINFO *pdi = SelectCorrectImageFile(pRender, hdc, pRect, FALSE, &tsInfo);

        //---- draw normal image ----
        hr = DrawImageInfo(pdi, pRender, hdc, iStateId, pRect, pOptions, &tsInfo);
    }

    //---- draw glyph, if needed ----
    if (SUCCEEDED(hr) && (_eGlyphType != GT_NONE))
    {
        RECT rc;
        hr = GetBackgroundContentRect(pRender, hdc, pRect, &rc);
        if (SUCCEEDED(hr))
        {
            if (_eGlyphType == GT_FONTGLYPH)
            {
                hr = DrawFontGlyph(pRender, hdc, &rc, pOptions);
            }
            else
            {
                DIBINFO *pdi = SelectCorrectImageFile(pRender, hdc, &rc, TRUE, &tsInfo);

                //---- draw glyph image ----
                hr = DrawImageInfo(pdi, pRender, hdc, iStateId, &rc, pOptions, &tsInfo);
            }
        }
    }

    return hr;
}

//---------------------------------------------------------------------------
HRESULT CImageFile::DrawFontGlyph(CRenderObj *pRender, HDC hdc, RECT *prc, 
    OPTIONAL const DTBGOPTS *pOptions)
{
    HRESULT hr = S_OK;
    DWORD dwFlags = DT_SINGLELINE;
    HFONT hFont = NULL;
    HFONT hOldFont = NULL;
    COLORREF crOld = 0;
    CSaveClipRegion scrOrig;
    int iOldMode = 0;
    WCHAR szText[2] = { (WCHAR)_iGlyphIndex, 0 };

    //---- options ----
    DWORD dwOptionFlags = 0;
    const RECT *pClipRect = NULL;

    if (pOptions)
    {
        dwOptionFlags = pOptions->dwFlags;

        if (dwOptionFlags & DTBG_CLIPRECT)
            pClipRect = &pOptions->rcClip;
    }

    //---- create the font ----
    hr = pRender->GetScaledFontHandle(hdc, &_lfGlyphFont, &hFont);
    if (FAILED(hr))
        goto exit;

    //---- make it active ----
    hOldFont = (HFONT)SelectObject(hdc, hFont);
    if (! hOldFont)
    {
        hr = MakeErrorLast();
        goto exit;
    }

    //---- set the text color ----
    crOld = SetTextColor(hdc, _crGlyphTextColor);

    //---- draw text with transparent background ----
    iOldMode = SetBkMode(hdc, TRANSPARENT);

    //---- set the HORZ alignment flags ----
    if (_eHAlign == HA_LEFT)
        dwFlags |= DT_LEFT;
    else if (_eHAlign == HA_CENTER)
        dwFlags |= DT_CENTER;
    else
        dwFlags |= DT_RIGHT;

    //---- set the VERT alignment flags ----
    if (_eVAlign == VA_TOP)
        dwFlags |= DT_TOP;
    else if (_eVAlign == VA_CENTER)
        dwFlags |= DT_VCENTER;
    else
        dwFlags |= DT_BOTTOM;

    //---- add clipping ----
    if (pClipRect)      
    {
        //---- get previous clipping region (for restoring at end) ----
        hr = scrOrig.Save(hdc);
        if (FAILED(hr))
            goto exit;

        //---- add "pClipRect" to the GDI clipping region ----
        int iRetVal = IntersectClipRect(hdc, pClipRect->left, pClipRect->top,
            pClipRect->right, pClipRect->bottom);
        if (iRetVal == ERROR)
        {
            hr = MakeErrorLast();
            goto exit;
        }
    }

    //---- draw the char ----
    if (! DrawTextEx(hdc, szText, 1, prc, dwFlags, NULL))
    {
        hr = MakeErrorLast();
        goto exit;
    }

exit:

    if (pClipRect)
        scrOrig.Restore(hdc);

    //---- reset the background mode ----
    if (iOldMode != TRANSPARENT)
        SetBkMode(hdc, iOldMode);

    //---- restore text color ----
    if (crOld != _crGlyphTextColor)
        SetTextColor(hdc, crOld);

    //---- restore font ----
    if (hOldFont)
        SelectObject(hdc, hOldFont);

    if (hFont)
        pRender->ReturnFontHandle(hFont);

    return hr;
}
//---------------------------------------------------------------------------
BOOL CImageFile::IsBackgroundPartiallyTransparent(int iStateId)
{
    DIBINFO *pdi = &_ImageInfo;     // primary image determines transparency

    return ((pdi->fAlphaChannel) || (pdi->fTransparent));
}
//---------------------------------------------------------------------------
HRESULT CImageFile::HitTestBackground(CRenderObj *pRender, OPTIONAL HDC hdc, int iStateId, 
    DWORD dwHTFlags, const RECT *pRect, HRGN hrgn, POINT ptTest, OUT WORD *pwHitCode)
{
    *pwHitCode = HTNOWHERE;

    if (! PtInRect(pRect, ptTest))
        return S_OK;    // nowhere

    //---- background might have transparent parts - get its region ----
    HRESULT hr = S_OK;
    HRGN    hrgnBk = NULL;

    if( !hrgn && IsBackgroundPartiallyTransparent(iStateId) )
    {
        hr = GetBackgroundRegion(pRender, hdc, iStateId, pRect, &hrgnBk);
        if( SUCCEEDED(hr) )
            hrgn = hrgnBk;
    }

    MARGINS margins;
    if( TESTFLAG(dwHTFlags, HTTB_SYSTEMSIZINGMARGINS) && 
        TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER) &&
        !TESTFLAG(dwHTFlags, HTTB_SIZINGTEMPLATE) )
    {
        ZeroMemory( &margins, sizeof(margins) );

        int cxBorder = ClassicGetSystemMetrics( SM_CXSIZEFRAME );
        int cyBorder = ClassicGetSystemMetrics( SM_CXSIZEFRAME );

        if( TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER_LEFT) )
            margins.cxLeftWidth = cxBorder;

        if( TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER_RIGHT) )
            margins.cxRightWidth = cxBorder;

        if( TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER_TOP) )
            margins.cyTopHeight = cyBorder;

        if( TESTFLAG(dwHTFlags, HTTB_RESIZINGBORDER_BOTTOM) )
            margins.cyBottomHeight = cyBorder;
    }
    else
    {
        hr = GetScaledContentMargins(pRender, hdc, pRect, &margins);
        if (FAILED(hr))
            goto exit;
    }

    if( hrgn )
    {
        //  122013 - we originally delegated to a sophisticated but broken
        //           resizing area region hit test algorithm for regioned windows,
        //           but for whistler we'll just do the bounding
        //           rectangle thang instead.
        //*pwHitCode = HitTestRgn( dwHTFlags, pRect, hrgn, margins, ptTest );

        RECT rcRgn;
        if( GetRgnBox( hrgn, &rcRgn ) )
        {
            if( TESTFLAG(dwHTFlags, HTTB_SIZINGTEMPLATE) )
            {
                *pwHitCode = HitTestTemplate( dwHTFlags, &rcRgn, hrgn, margins, ptTest );
            }
            else
            {
                *pwHitCode = HitTestRect( dwHTFlags, &rcRgn, margins, ptTest );
            }
        }
        SAFE_DELETE_GDIOBJ(hrgnBk);
    }
    else
    {
        *pwHitCode = HitTestRect( dwHTFlags, pRect, margins, ptTest );
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CImageFile::GetBackgroundRegion(CRenderObj *pRender, OPTIONAL HDC hdc, int iStateId,
    const RECT *pRect, HRGN *pRegion)
{
    HRESULT hr = S_OK;
    RGNDATA *pRgnData;
    CMemoryDC hdcMemory;
    HRGN hrgn;
    int iRgnDataOffset = 0;
    MIXEDPTRS u;

    DIBINFO *pdi = SelectCorrectImageFile(pRender, hdc, pRect, FALSE);

    //---- get rgndata offset ----
    if ((pdi->iRgnListOffset) && (pRender->_pbThemeData))
    {
        u.pb = pRender->_pbThemeData + pdi->iRgnListOffset;
        int iMaxState = (*u.pb++) - 1;
        if (iStateId > iMaxState)
            iStateId = 0;
        iRgnDataOffset = u.pi[iStateId];
    }

    //---- see if it even has a transparent part ----
    if (iRgnDataOffset)
    {
        //---- stretch those puppies & create a new region ----
        pRgnData = (RGNDATA *)(pRender->_pbThemeData + iRgnDataOffset 
            + sizeof(RGNDATAHDR) + ENTRYHDR_SIZE);

        SIZE szSrcImage = {pdi->iSingleWidth, pdi->iSingleHeight};

        hr = _ScaleRectsAndCreateRegion(pRgnData, pRect, &_SizingMargins, &szSrcImage, &hrgn);

        if (FAILED(hr))
            goto exit;
    }
    else
    {
        //---- return the bounding rect as the region ----
        hrgn = CreateRectRgn(pRect->left, pRect->top,
            pRect->right, pRect->bottom);

        if (! hrgn)
        {
            hr = MakeErrorLast();
            goto exit;
        }
    }

    *pRegion = hrgn;

exit:
    return hr;
}  
//---------------------------------------------------------------------------
HRESULT CImageFile::GetBackgroundContentRect(CRenderObj *pRender, OPTIONAL HDC hdc, 
    const RECT *pBoundingRect, RECT *pContentRect)
{
    MARGINS margins;
    HRESULT hr = GetScaledContentMargins(pRender, hdc, pBoundingRect, &margins);
    if (FAILED(hr))
        goto exit;

    pContentRect->left = pBoundingRect->left + margins.cxLeftWidth;
    pContentRect->top = pBoundingRect->top + margins.cyTopHeight;

    pContentRect->right = pBoundingRect->right - margins.cxRightWidth;
    pContentRect->bottom = pBoundingRect->bottom - margins.cyBottomHeight;

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CImageFile::GetBackgroundExtent(CRenderObj *pRender, OPTIONAL HDC hdc, 
    const RECT *pContentRect, RECT *pExtentRect)
{
    MARGINS margins;
    HRESULT hr = GetScaledContentMargins(pRender, hdc, pContentRect, &margins);
    if (FAILED(hr))
        goto exit;

    pExtentRect->left = pContentRect->left - margins.cxLeftWidth;
    pExtentRect->top = pContentRect->top-+ margins.cyTopHeight;

    pExtentRect->right = pContentRect->right + margins.cxRightWidth;
    pExtentRect->bottom = pContentRect->bottom + margins.cyBottomHeight;

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CImageFile::GetScaledContentMargins(CRenderObj *pRender, OPTIONAL HDC hdc, 
    OPTIONAL const RECT *prcDest, MARGINS *pMargins)
{
    HRESULT hr = S_OK;
    *pMargins = _ContentMargins;

    //---- now scale the margins ----
    SIZE szDraw;
    TRUESTRETCHINFO tsInfo;

    DIBINFO *pdi = SelectCorrectImageFile(pRender, hdc, prcDest, FALSE, NULL);
    
    GetDrawnImageSize(pdi, prcDest, &tsInfo, &szDraw);

    hr = ScaleMargins(pMargins, hdc, pRender, pdi, &szDraw);

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CImageFile::GetPartSize(CRenderObj *pRender, HDC hdc, OPTIONAL const RECT *prc, 
    THEMESIZE eSize, SIZE *psz)
{
    HRESULT hr = S_OK;
    TRUESTRETCHINFO tsInfo;

    DIBINFO *pdi = SelectCorrectImageFile(pRender, hdc, prc, FALSE, &tsInfo);

    if (eSize == TS_MIN)
    {
        MARGINS margins;
        hr = GetScaledContentMargins(pRender, hdc, prc, &margins);
        if (FAILED(hr))
            goto exit;

        psz->cx = max(1, margins.cxLeftWidth + margins.cxRightWidth);
        psz->cy = max(1, margins.cyTopHeight + margins.cyBottomHeight);
    }
    else if (eSize == TS_TRUE)
    {
        psz->cx = pdi->iSingleWidth;
        psz->cy = pdi->iSingleHeight;
    }
    else if (eSize == TS_DRAW)
    {
        GetDrawnImageSize(pdi, prc, &tsInfo, psz);
    }
    else
    {
        hr = MakeError32(E_INVALIDARG);
        goto exit;
    }

exit:
    return hr;
} 
//---------------------------------------------------------------------------
HRESULT CImageFile::GetBitmap(CRenderObj *pRender, HDC hdc, const RECT *prc, HBITMAP *phBitmap)
{
    int iStockDibOffset = pRender->GetValueIndex(_iSourcePartId, _iSourceStateId, TMT_STOCKDIBDATA);
    if (iStockDibOffset > 0)
    {
        return pRender->GetBitmap(NULL, iStockDibOffset, phBitmap);
    }
    else
    {
        return E_INVALIDARG;
    }
}
//---------------------------------------------------------------------------
void CImageFile::GetOffsets(int iStateId, DIBINFO *pdi, int *piXOffset, int *piYOffset)
{
    if (_eImageLayout == IL_HORIZONTAL)
    {
        //---- iStateId in the image index ----
        if ((iStateId <= 0) || (iStateId > _iImageCount))
            *piXOffset = 0;
        else
            *piXOffset = (iStateId-1) * (pdi->iSingleWidth);

        *piYOffset = 0;
    }
    else        // vertical
    {
        //---- iStateId in the image index ----
        if ((iStateId <= 0) || (iStateId > _iImageCount))
            *piYOffset = 0;
        else
            *piYOffset = (iStateId-1) * (pdi->iSingleHeight);

        *piXOffset = 0;
    }

}
//---------------------------------------------------------------------------
HRESULT CImageFile::ScaleMargins(IN OUT MARGINS *pMargins, HDC hdcOrig, CRenderObj *pRender, 
    DIBINFO *pdi, const SIZE *pszDraw, OPTIONAL float *pfx, OPTIONAL float *pfy)
{
    HRESULT hr = S_OK;
    COptionalDC hdc(hdcOrig);
    BOOL fForceRectSizing = FALSE;

    if ((pRender) && (pRender->_dwOtdFlags & OTD_FORCE_RECT_SIZING))
    {
        fForceRectSizing = TRUE;
    }

    float xFactor = 1;
    float yFactor = 1;

    //---- any margins to size? ----
    if ((pMargins->cxLeftWidth) || (pMargins->cxRightWidth) || (pMargins->cyBottomHeight)
                   || (pMargins->cyTopHeight))
    {
        if ((pszDraw->cx > 0) && (pszDraw->cy > 0))
        {
            BOOL fxNeedScale = FALSE;
            BOOL fyNeedScale = FALSE;

            //---- scale if dest rect is too small in one dimension ----
            if ((_fSourceShrink) || (fForceRectSizing))
            {
                if (pszDraw->cx < pdi->szMinSize.cx) 
                {
                    fxNeedScale = TRUE;
                }

                if (pszDraw->cy < pdi->szMinSize.cy) 
                {
                    fyNeedScale = TRUE;
                }
            }

            if ((_fSourceGrow) || (fForceRectSizing))
            {
                if ((! fxNeedScale) && (! fyNeedScale))
                {
                    //---- calculate our Dest DPI ----
                    int iDestDpi;

                    if (fForceRectSizing)   
                    {
                        iDestDpi = (pRender) ? (pRender->GetDpiOverride()) : 0;

                        if (! iDestDpi)
                        {
                            //---- make up a DPI based on sizes (IE will pass us the actual DPI soon) ----
                            int ixFakeDpi = MulDiv(pdi->iMinDpi, pszDraw->cx, _szNormalSize.cx);
                            int iyFakeDpi = MulDiv(pdi->iMinDpi, pszDraw->cy, _szNormalSize.cy);

                            iDestDpi = (ixFakeDpi + iyFakeDpi)/2;
                        }
                    }
                    else
                    {
                        iDestDpi = GetDeviceCaps(hdc, LOGPIXELSX);
                    }

                    //---- scale source/margins by Dest DPI ----
                    if (iDestDpi >= 2*pdi->iMinDpi)     
                    {
                        xFactor *= iDestDpi/pdi->iMinDpi;
                        yFactor *= iDestDpi/pdi->iMinDpi;

                    }
                }
            }

            //---- scale by ratio of our image to draw size ----
            if (fxNeedScale)
            {
                xFactor *= float(pszDraw->cx)/float(_szNormalSize.cx);
            }

            if (fyNeedScale)
            {
                yFactor *= float(pszDraw->cy)/float(_szNormalSize.cy);
            }
        }

        //---- use smallest factor for both ----
        if (xFactor < yFactor)
        {
            yFactor = xFactor;
        }
        else if (yFactor < xFactor)
        {
            xFactor = yFactor;
        }

        //---- integer truncation ----
        if (xFactor > 1.0)
        {
            xFactor = float(int(xFactor));
        }

        if (yFactor > 1.0)
        {
            yFactor = float(int(yFactor));
        }

        //---- scale the margin values ----
        if (xFactor != 1)
        {
            pMargins->cxLeftWidth = ROUND(xFactor*pMargins->cxLeftWidth);
            pMargins->cxRightWidth = ROUND(xFactor*pMargins->cxRightWidth);
        }

        if (yFactor != 1)
        {
            pMargins->cyTopHeight = ROUND(yFactor*pMargins->cyTopHeight);
            pMargins->cyBottomHeight = ROUND(yFactor*pMargins->cyBottomHeight);
        }
    }

    //---- return factors to interested callers ----
    if (pfx)
    {
        *pfx = xFactor;
    }

    if (pfy)
    {
        *pfy = yFactor;
    }

    return hr;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\handlers.h ===
#ifndef __HANDLERS_H__
#define __HANDLERS_H__

//---------------------------------------------------------------------------//
#define _MSG_SWITCH_ // determines handler selection implementation 
                     // (switch block vs. linear array search (vs. hash table lookup?) )

//-------------------//
//  Forwards
class  CThemeWnd;
struct _NCTHEMEMET;
typedef struct _NCTHEMEMET NCTHEMEMET;

//---------------------------------------------------------------------------
//  Hook modification
BOOL ApiHandlerInit( const LPCTSTR pszTarget, USERAPIHOOK* puahTheme, const USERAPIHOOK* puahReal );


//---------------------------------------------------------------------------
//  Window message handler support
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
typedef enum _MSGTYPE
{
    MSGTYPE_PRE_WNDPROC,    // pre-wndproc override
    MSGTYPE_POST_WNDPROC,   // post-wndproc override
    MSGTYPE_PRE_DEFDLGPROC, // pre-DefDlgProc override
    MSGTYPE_POST_DEFDLGPROC,// post-DefDlgProc override
    MSGTYPE_DEFWNDPROC,     // DefWindowProc hook.
}MSGTYPE;

//---------------------------------------------------------------------------
typedef struct _THEME_MSG
{
    HWND    hwnd;        // message target.
    UINT    uMsg;        // message id.
    WPARAM  wParam;      // message WPARAM
    LPARAM  lParam;      // message LPARAM 
    MSGTYPE type;        // type of message (dwp, sent, posted)
    UINT    uCodePage;   // message codepage.  This will invariably be CP_WINUNICODE for
                         //     a message processed via the wide-char defwindowproc, or
                         //     the current user default codepage for messages passed through
                         //     the ansi defwindowproc.
    WNDPROC pfnDefProc;  // address of function handler should call to do default processing
    LRESULT lRet;        // Post overrides only: msg result from default handler.
    BOOL    fHandled;    // handler should set this value.

}THEME_MSG, *PTHEME_MSG;

//---------------------------------------------------------------------------
//  Message handler prototype
typedef LRESULT (CALLBACK * HOOKEDMSGHANDLER)(CThemeWnd* pwnd, THEME_MSG *ptm );

//---------------------------------------------------------------------------
//  Message handler array element
typedef struct _MSGENTRY 
{ 
    UINT nMsg;                      // message identifier (zero if registered message)
    UINT *pnRegMsg;                 // address of registered message var (NULL if stock message)
    HOOKEDMSGHANDLER pfnHandler;    // primary handler
    HOOKEDMSGHANDLER pfnHandler2;   // secondary handler (optional for DWP, WH handlers)
} MSGENTRY, *PMSGENTRY;

//---------------------------------------------------------------------------
//  Performs default processing on the message
LRESULT WINAPI DoMsgDefault( const THEME_MSG* ptm );

//---------------------------------------------------------------------------
inline void WINAPI MsgHandled( const THEME_MSG *ptm, BOOL fHandled = TRUE )   {
    ((PTHEME_MSG)ptm)->fHandled = fHandled;
}

//---------------------------------------------------------------------------
//  message mask helpers
#define MAKE_MSGBIT( nMsg )                ((BYTE)(1 << (nMsg & 7)))
#define SET_MSGMASK( prgMsgMask, nMsg )    (prgMsgMask[nMsg/8] |= MAKE_MSGBIT(nMsg))
#define CLEAR_MSGMASK( prgMsgMask, nMsg )  (prgMsgMask[nMsg/8] &= ~MAKE_MSGBIT(nMsg))
#define CHECK_MSGMASK( prgMsgMask, nMsg )  ((prgMsgMask[nMsg/8] & MAKE_MSGBIT(nMsg)) != 0)

//---------------------------------------------------------------------------//
//  Message handler table access
extern void HandlerTableInit();

DWORD       GetOwpMsgMask( LPBYTE* prgMsgList );
DWORD       GetDdpMsgMask( LPBYTE* prgMsgList );
DWORD       GetDwpMsgMask( LPBYTE* prgMsgList );

BOOL        FindOwpHandler( UINT uMsg, 
                            OUT OPTIONAL HOOKEDMSGHANDLER* ppfnPre, 
                            OUT OPTIONAL HOOKEDMSGHANDLER* ppfnPost );
BOOL        FindDdpHandler( UINT uMsg, 
                            OUT OPTIONAL HOOKEDMSGHANDLER* ppfnPre, 
                            OUT OPTIONAL HOOKEDMSGHANDLER* ppfnPost );
BOOL        FindDwpHandler( UINT uMsg, 
                            OUT OPTIONAL HOOKEDMSGHANDLER* ppfn );

//---------------------------------------------------------------------------//
//  table decl helpers
#define DECL_MSGHANDLER(handler)                  LRESULT CALLBACK handler(CThemeWnd*, THEME_MSG *)
#define DECL_REGISTERED_MSG(msg)                  extern UINT msg;

#define BEGIN_HANDLER_TABLE(rgEntries)            static MSGENTRY rgEntries[] = {
#define END_HANDLER_TABLE()                       };

#define DECL_MSGENTRY(msg,pfnPre,pfnPost)         {msg, NULL, pfnPre, pfnPost},

//---------------------------------------------------------------------------
//  SystemParametersInfo handler support
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//  SystemParametersInfo handler prototype
typedef BOOL (CALLBACK * SPIHANDLER)(
    NCTHEMEMET *pnctm, 
    IN UINT uiAction, IN UINT uiParam, IN OUT PVOID pvParam, IN UINT fWinIni, 
    SYSTEMPARAMETERSINFO pfnDefault, BOOL& fHandled );

BOOL FindSpiHandler( IN UINT uiAction, OUT SPIHANDLER* pfnHandler );

//---------------------------------------------------------------------------//
//  table decl helpers
#define DECL_SPIHANDLER(handler)                  BOOL CALLBACK handler(NCTHEMEMET*, UINT, UINT, PVOID, UINT, SYSTEMPARAMETERSINFO, BOOL& )
#define BEGIN_SPIHANDLER_TABLE()                  BOOL FindSpiHandler( UINT uiAction, SPIHANDLER* pfnHandler ) {\
                                                       switch(uiAction){
#define DECL_SPIENTRY(uiAction, handler)          case uiAction: {*pfnHandler = handler; return TRUE;}
#define END_SPIHANDLER_TABLE()                    }return FALSE;}


//---------------------------------------------------------------------------
//  GetSystemMetrics handler support
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//  GetSystemMetrics handler prototype
typedef int (CALLBACK * GSMHANDLER)(
    NCTHEMEMET *pnctm, IN int iMetric, 
    GETSYSTEMMETRICSPROC pfnDefault, BOOL& fHandled );

typedef struct _GSMENTRY {
    int iMetric;
    GSMHANDLER pfnHandler;
} GSMENTRY;

BOOL FindGsmHandler( IN int iMetric, OUT GSMHANDLER* pfnHandler );

#define DECL_GSMHANDLER(handler)                  int CALLBACK handler(NCTHEMEMET*, int, GETSYSTEMMETRICSPROC, BOOL& )
#define BEGIN_GSMHANDLER_TABLE(rgEntries)         static GSMENTRY rgEntries[] = {
#define END_GSMHANDLER_TABLE()                    };
#define DECL_GSMENTRY(iMetric, handler)           {iMetric, handler},

#endif __HANDLERS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\info.h ===
//---------------------------------------------------------------------------
//  Info.h - implements the information services of the CRenderObj object
//---------------------------------------------------------------------------
#ifndef _INFO_H
#define _INFO_H

#include <loader.h>
//---------------------------------------------------------------------------
class CRenderObj;       // forward
//---------------------------------------------------------------------------
HRESULT GetHwndThemeFile(HWND hwnd, LPCWSTR pszClassIdList, 
    CUxThemeFile **ppThemeFile);

HRESULT MatchThemeClass(LPCTSTR pszAppName, LPCTSTR pszClassId, 
    CUxThemeFile *pThemeFile, int *piOffset, int *piClassNameOffset);

HRESULT MatchThemeClassList(HWND hwnd, LPCTSTR pstClassIdList, 
    CUxThemeFile *pThemeFile, int *piOffset, int *piClassNameOffset);

HTHEME _OpenThemeDataFromFile(HTHEMEFILE hLoadedThemeFile, HWND hwnd, LPCWSTR pszClassList, DWORD dwFlags);

HTHEME _OpenThemeData(HWND hwnd, LPCWSTR pszClassIdList, DWORD dwFlags);

HRESULT _ApplyTheme(CUxThemeFile *pThemeFile, DWORD dwApplyFlags,
    OPTIONAL LPCWSTR pszTargetApp, OPTIONAL HWND hwndTarget);

HRESULT _OpenThemeFileFromData(CRenderObj *pRender, HTHEMEFILE *phThemeFile);

void ClearExStyleBits(HWND hwnd);
void AddPropFlags(HWND hwnd, DWORD dwNewFlags);
//---------------------------------------------------------------------------
BOOL EnumProcessWindows(WNDENUMPROC lpEnumFunc, LPARAM lParam);
void WindowDump(LPCWSTR pszWhere);
//---------------------------------------------------------------------------
inline THEMEMETRICS *GetThemeMetricsPtr(CUxThemeFile *pThemeFile)
{
    THEMEHDR *hdr = (THEMEHDR *)(pThemeFile->_pbThemeData);
    return (THEMEMETRICS *)(pThemeFile->_pbThemeData + hdr->iSysMetricsOffset + ENTRYHDR_SIZE);
}
//---------------------------------------------------------------------------
#endif // _INFO_H
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\messagebroadcast.h ===
//  --------------------------------------------------------------------------
//  Module Name: MessageBroadcast.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to manager sending or posting messages to windows to tell them that
//  things have changed.
//
//  History:    2000-11-11  vtan        created (split from services.cpp)
//  --------------------------------------------------------------------------
#ifndef     _MessageBroadcast_
#define     _MessageBroadcast_
//  --------------------------------------------------------------------------
#include "SimpStr.h"
//  --------------------------------------------------------------------------
enum MSG_TYPE
{
    MT_SIMPLE,    
    MT_ALLTHREADS,          // send at least one msg to each thread/window in system
    MT_FILTERED,            // by processid, HWND, exclude
};
//  --------------------------------------------------------------------------
class CThemeFile;       // forward
//  --------------------------------------------------------------------------
//  CMessageBroadcast
//
//  Purpose:    Class used internally to assist with message sending which
//              must be done on the client side on behalf of the server.
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

class   CMessageBroadcast
{
    public:
                                    CMessageBroadcast (BOOL fAllDesktops=TRUE);
                                    ~CMessageBroadcast (void);

                void                PostSimpleMsg(UINT msg, WPARAM wParam, LPARAM lParam);
                void                PostAllThreadsMsg(UINT msg, WPARAM wParam, LPARAM lParam);

                void                PostFilteredMsg(UINT msg, WPARAM wParam, LPARAM lParam, 
                                        HWND hwndTarget, BOOL fProcess, BOOL fExclude);

    private:
        static  BOOL    CALLBACK    DesktopCallBack(LPTSTR lpszDesktop, LPARAM lParam);
        static  BOOL    CALLBACK    TopWindowCallBack(HWND hwnd, LPARAM lParam);
        static  BOOL    CALLBACK    ChildWindowCallBack(HWND hwnd, LPARAM lParam);
                void                Worker(HWND hwnd);
                void                EnumRequestedWindows();


    private:
                MSG                 _msg;
                HWND                _hwnd;
                DWORD               _dwProcessID;
                BOOL                _fExclude;
                MSG_TYPE            _eMsgType;
                BOOL                _fAllDesktops;
                CSimpleArray<DWORD> _ThreadsProcessed;

};

#endif  /*  _MessageBroadcast_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\imagefile.h ===
//---------------------------------------------------------------------------
//  ImageFile.h - implements the drawing API for bgtype = ImageFile
//---------------------------------------------------------------------------
#pragma once
//---------------------------------------------------------------------------
#include "DrawBase.h"
//---------------------------------------------------------------------------
#define MAX_IMAGEFILE_SIZES 5
//---------------------------------------------------------------------------
struct TMBITMAPHEADER;     // forward
//---------------------------------------------------------------------------
struct DIBINFO        // used for all dibs in an CImageFile object
{
    //---- the bits ----
    int iDibOffset;             // for DIB's in section
    HBITMAP hProcessBitmap;     // for process-specific objects

    //---- size of a single, state image ----
    int iSingleWidth;
    int iSingleHeight;

    //---- custom region data ----
    int iRgnListOffset;

    //---- stretching/sizing ----
    SIZINGTYPE eSizingType;
    BOOL fBorderOnly;

    //---- transparency ----
    BOOL fTransparent;
    COLORREF crTransparent;

    //---- alpha ----
    BOOL fAlphaChannel;
    int iAlphaThreshold;

    //---- usage info ----
    int iMinDpi;
    SIZE szMinSize;
};
//---------------------------------------------------------------------------
struct TRUESTRETCHINFO
{
    BOOL fForceStretch;     // forcing a TRUE SIZE image to be stretched
    BOOL fFullStretch;      // stretch to fill entire dest RECT
    SIZE szDrawSize;        // size to stretch image to
};
//---------------------------------------------------------------------------
//    Note: draw objects like CImageFile cannot have virtual methods
//          since they reside in the shared memory map file.
//---------------------------------------------------------------------------
class CImageFile : public CDrawBase
{
public:
    //---- load-time methods ----
    static BOOL KeyProperty(int iPropId);

    DIBINFO *EnumImageFiles(int iIndex);

    void DumpProperties(CSimpleFile *pFile, BYTE *pbThemeData, BOOL fFullInfo);

    BOOL HasRegionImageFile(DIBINFO *pdi, int *piMaxState);

    BOOL ImageUsesBrushes(DIBINFO *pdi, int *piBrushCount);

    void SetRgnListOffset(DIBINFO *pdi, int iOffset);

    HRESULT BuildRgnData(DIBINFO *pdi, CRenderObj *pRender, int iStateId,
        RGNDATA **ppRgnData, int *piDataLen);

    //---- draw-time methods ----
    HRESULT DrawBackground(CRenderObj *pRender, HDC hdc, int iStateId, const RECT *pRect, 
        OPTIONAL const DTBGOPTS *pOptions);

    BOOL IsBackgroundPartiallyTransparent(int iStateId);

    HRESULT HitTestBackground(CRenderObj *pRender, OPTIONAL HDC hdc, 
        int iStateId, DWORD dwHTFlags, const RECT *pRect, HRGN hrgn, 
        POINT ptTest, OUT WORD *pwHitCode);

    HRESULT GetBackgroundRegion(CRenderObj *pRender, OPTIONAL HDC hdc, int iStateId, 
        const RECT *pRect, HRGN *pRegion);

    HRESULT GetBackgroundContentRect(CRenderObj *pRender, OPTIONAL HDC hdc,
        const RECT *pBoundingRect, RECT *pContentRect);

    HRESULT GetBackgroundExtent(CRenderObj *pRender, OPTIONAL HDC hdc, 
        const RECT *pContentRect, RECT *pExtentRect);

    HRESULT GetPartSize(CRenderObj *pRender, HDC hdc, const RECT *prc, THEMESIZE eSize, SIZE *psz);

    HRESULT GetBitmap(CRenderObj *pRender, HDC hdc, const RECT *prc, HBITMAP *phBitmap);

    HRESULT ScaleMargins(IN OUT MARGINS *pMargins, HDC hdcOrig, CRenderObj *pRender, 
        DIBINFO *pdi, const SIZE *pszDraw, OPTIONAL float *pfx=NULL, OPTIONAL float *pfy=NULL);

    DIBINFO *SelectCorrectImageFile(CRenderObj *pRender, HDC hdc, const RECT *prc, 
        BOOL fForGlyph, OPTIONAL TRUESTRETCHINFO *ptsInfo=NULL);

    void GetDrawnImageSize(DIBINFO *pdi, const RECT *pRect, TRUESTRETCHINFO *ptsInfo, SIZE *pszDraw);

    //---- multi dibs must be placed just after object ----
    inline DIBINFO *MultiDibPtr(int iIndex)
    {
        DIBINFO *pdi = NULL;

        if ((iIndex < 0) && (iIndex >= _iMultiImageCount))
        {
            ASSERT(0 && L"illegal index for MultiDibPtr()");
        }
        else
        {
            DIBINFO * pDibs = (DIBINFO *)(this+1);
            pdi = &pDibs[iIndex];
        }

        return pdi;
    }

protected:
    //---- call this via CMaxImageFile::PackProperties() ----
    HRESULT PackProperties(CRenderObj *pRender, int iPartId, int iStateId);

    //---- helper methods ----
    HRESULT DrawImageInfo(DIBINFO *pdi, CRenderObj *pRender, HDC hdc, int iStateId,
        const RECT *pRect, const DTBGOPTS *pOptions, TRUESTRETCHINFO *ptsInfo);

    HRESULT DrawBackgroundDNG(DIBINFO *pdi, TMBITMAPHEADER *pThemeBitmapHeader, BOOL fStock, 
        CRenderObj *pRender, HDC hdc, int iStateId, const RECT *pRect, BOOL fForceStretch, 
        MARGINS *pmarDest, OPTIONAL const DTBGOPTS *pOptions);

    HRESULT DrawBackgroundDS(DIBINFO *pdi, TMBITMAPHEADER *pThemeBitmapHeader, BOOL fStock, 
        CRenderObj *pRender, HDC hdc, int iStateId, const RECT *pRect, BOOL fForceStretch, 
        MARGINS *pmarDest, float xMarginFactor, float yMarginFactor, 
        OPTIONAL const DTBGOPTS *pOptions);

    HRESULT SetImageInfo(DIBINFO *pdi, CRenderObj *pRender, int iPartId, int iStateId);

    HRESULT GetScaledContentMargins(CRenderObj *pRender, OPTIONAL HDC hdc, OPTIONAL const RECT *prcDest,
        MARGINS *pMargins);

    void GetOffsets(int iStateId, DIBINFO *pdi, int *piXOffset, int *piYOffset);

    HRESULT DrawFontGlyph(CRenderObj *pRender, HDC hdc, RECT *prc, 
        OPTIONAL const DTBGOPTS *pOptions);
    

public:
    //---- primary image ----
    DIBINFO _ImageInfo;

    //---- multiple DPI scaling images ----
    int _iMultiImageCount;            // number of DIBINFO's that immediately follow object
    IMAGESELECTTYPE _eImageSelectType;

    //---- properties common to all DIBINFO's in this object ----
    int _iImageCount;
    IMAGELAYOUT _eImageLayout;

    //---- mirroring ----
    BOOL _fMirrorImage;

    //---- TrueSize images ----
    TRUESIZESCALINGTYPE _eTrueSizeScalingType;
    HALIGN _eHAlign;
    VALIGN _eVAlign;
    BOOL _fBgFill;
    COLORREF _crFill;
    int _iTrueSizeStretchMark;       // percent at which we stretch a truesize image
    BOOL _fUniformSizing;            // both width & height must grow together
    BOOL _fIntegralSizing;           // for TRUESIZE sizing and for Border sizing           
    
    //---- margins ----
    MARGINS _SizingMargins;
    MARGINS _ContentMargins;
    BOOL _fSourceGrow;
    BOOL _fSourceShrink;
    SIZE _szNormalSize;

    //---- glyph ----
    BOOL _fGlyphOnly;
    GLYPHTYPE _eGlyphType;

    //---- font-based glyph ----
    COLORREF _crGlyphTextColor;
    LOGFONT _lfGlyphFont;
    int _iGlyphIndex;

    //---- image-based glyph ----
    DIBINFO _GlyphInfo;

    //---- id ----
    int _iSourcePartId; 
    int _iSourceStateId;

    //---- multiple DIBINFO's may follow at end ----
};
//---------------------------------------------------------------------------
class CMaxImageFile : public CImageFile
{
public:
    HRESULT PackMaxProperties(CRenderObj *pRender, int iPartId, int iStateId,
        OUT int *piMultiDibCount);

    DIBINFO MultiDibs[MAX_IMAGEFILE_SIZES];  // actual number of multi dibs varies with each obj
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\loader.cpp ===
//---------------------------------------------------------------------------
//  Loader.cpp - loads the theme data into shared memory
//---------------------------------------------------------------------------
#include "stdafx.h"
#include <regstr.h>
#include "Loader.h"
#include "Parser.h"
#include "Utils.h"
#include "TmReg.h"
#include "TmUtils.h"
#include "syscolors.h"
#include "Render.h"
#include "BorderFill.h"
#include "ImageFile.h"
#include "TextDraw.h"
#include "info.h"
//---------------------------------------------------------------------------
#define POINTS_DPI96(pts)   -MulDiv(pts, 96, 72)
//---------------------------------------------------------------------------
WCHAR pszColorsKey[] = L"Control Panel\\Colors";
//---------------------------------------------------------------------------
typedef struct 
{
    THEMEMETRICS tm;
    HANDLE hUserToken;
} THEMEMETRICS_THREADINFO;
//---------------------------------------------------------------------------
CThemeLoader::CThemeLoader()
{
    _pbLocalData = NULL;
    _iEntryHdrLevel = -1;
    
    InitThemeMetrics(&_LoadThemeMetrics);
    
    SYSTEM_INFO si;

    GetSystemInfo(&si);
    _dwPageSize = si.dwPageSize;
}
//---------------------------------------------------------------------------
CThemeLoader::~CThemeLoader()
{
    FreeLocalTheme();
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::LoadClassDataIni(HINSTANCE hInst, LPCWSTR pszColorName,
    LPCWSTR pszSizeName, LPWSTR pszFoundIniName, DWORD dwMaxIniNameChars, LPWSTR *ppIniData)
{
    COLORSIZECOMBOS *combos;
    HRESULT hr = FindComboData(hInst, &combos);
    if (FAILED(hr))
        return hr;

    int iSizeIndex = 0;
    int iColorIndex = 0;

    if ((pszColorName) && (* pszColorName))
    {
        hr = GetColorSchemeIndex(hInst, pszColorName, &iColorIndex);
        if (FAILED(hr))
            return hr;
    }

    if ((pszSizeName) && (* pszSizeName))
    {
        hr = GetSizeIndex(hInst, pszSizeName, &iSizeIndex);
        if (FAILED(hr))
            return hr;
    }

    int filenum = COMBOENTRY(combos, iColorIndex, iSizeIndex);
    if (filenum == -1)
        return MakeError32(ERROR_NOT_FOUND);

    //---- locate resname for classdata file "filenum" ----
    hr = GetResString(hInst, L"FILERESNAMES", filenum, pszFoundIniName, dwMaxIniNameChars);
    if (SUCCEEDED(hr))
    {
        hr = AllocateTextResource(hInst, pszFoundIniName, ppIniData);
        if (FAILED(hr))
            return hr;
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::LoadTheme(LPCWSTR pszThemeName, LPCWSTR pszColorParam,
        LPCWSTR pszSizeParam, OUT HANDLE *pHandle, BOOL fGlobalTheme)
{
    HRESULT hr;
    CThemeParser *pParser = NULL;
    HINSTANCE hInst = NULL;
    WCHAR *pThemesIni = NULL;
    WCHAR *pDataIni = NULL;
    WCHAR szClassDataName[_MAX_PATH+1];

    DWORD dwStartTime = StartTimer();

    Log(LOG_TMCHANGE, L"LoadTheme: filename=%s", pszThemeName);

    FreeLocalTheme();

    //---- allocate a local theme data to construct ----

    _pbLocalData = (BYTE*) VirtualAlloc(NULL, MAX_SHAREDMEM_SIZE, MEM_RESERVE, PAGE_READWRITE);
    if (NULL == _pbLocalData)
    {
        hr = MakeError32(E_OUTOFMEMORY);
        goto exit;
    }
    _iLocalLen = 0;

    //---- load the Color Scheme from "themes.ini" ----
    hr = LoadThemeLibrary(pszThemeName, &hInst);
    if (FAILED(hr))
        goto exit;
    
    pParser = new CThemeParser(fGlobalTheme);
    if (! pParser)
    {
        hr = MakeError32(E_OUTOFMEMORY);
        goto exit;
    }

    //---- if a color scheme is specified, ask parser to load it ----
    if ((pszColorParam) && (*pszColorParam))     
    {
        //---- load the "themes.ini" text ----
        hr = AllocateTextResource(hInst, CONTAINER_RESNAME, &pThemesIni);
        if (FAILED(hr))
            goto exit;

        //---- parser call to load color scheme & keep state ----
        hr = pParser->ParseThemeBuffer(pThemesIni, 
            CONTAINER_RESNAME, pszColorParam, hInst, this, NULL, NULL, PTF_CONTAINER_PARSE);
        if (FAILED(hr))
            goto exit;
    }

    //---- load the classdata file resource into memory ----
    hr = LoadClassDataIni(hInst, pszColorParam, pszSizeParam, szClassDataName, 
        ARRAYSIZE(szClassDataName), &pDataIni);
    if (FAILED(hr))
        goto exit;

    //---- parse & build binary theme ----
    hr = pParser->ParseThemeBuffer(pDataIni, 
        szClassDataName, pszColorParam, hInst, this, NULL, NULL, PTF_CLASSDATA_PARSE);
    if (FAILED(hr))
        goto exit;

    _fGlobalTheme = fGlobalTheme;

    hr = PackAndLoadTheme(pszThemeName, pszColorParam, pszSizeParam, hInst);
    if (FAILED(hr))
        goto exit;

    if (LogOptionOn(LO_TMLOAD))
    {
        DWORD dwTicks;
        dwTicks = StopTimer(dwStartTime);

        WCHAR buff[100];
        TimeToStr(dwTicks, buff);
        Log(LOG_TMLOAD, L"LoadTheme took: %s", buff);
    }

exit:

    if (FAILED(hr) && pParser)
    {
        pParser->CleanupStockBitmaps();
    }

    if (pParser)
        delete pParser;

    if (hInst)
        FreeLibrary(hInst);
    
    if (pThemesIni)
        delete [] pThemesIni;

    if (pDataIni)
        delete [] pDataIni;

    FreeLocalTheme();

    if (SUCCEEDED(hr))
    {
        if (_fGlobalTheme)
        {
            THEMEHDR *hdr = (THEMEHDR *) _LoadingThemeFile._pbThemeData;
            hdr->dwFlags |= SECTION_HASSTOCKOBJECTS;
        }

        //---- transfer theme file handle to caller ----
        *pHandle = _LoadingThemeFile.Unload();
    }
    else
    {
        _LoadingThemeFile.CloseFile();
    }

    return hr;
}
//---------------------------------------------------------------------------
void CThemeLoader::FreeLocalTheme()
{
    if (_pbLocalData)
    {
        VirtualFree(_pbLocalData, 0, MEM_RELEASE);
        _pbLocalData = NULL;
        _iLocalLen = 0; 
    }

    _LocalIndexes.RemoveAll();
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::EmitAndCopyBlock(MIXEDPTRS &u, void *pSrc, DWORD dwLen)
{
    HRESULT hr = AllocateThemeFileBytes(u.pb, dwLen);
    if (FAILED(hr))
        return hr;

    memcpy(u.pb, (BYTE*) pSrc, dwLen);
    u.pb += dwLen;
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::EmitObject(MIXEDPTRS &u, SHORT propnum, BYTE privnum, void *pHdr, DWORD dwHdrLen, void *pObj, DWORD dwObjLen)
{
    EmitEntryHdr(u, propnum, privnum);
    
    HRESULT hr = AllocateThemeFileBytes(u.pb, dwHdrLen + dwObjLen);
    if (FAILED(hr))
        return hr;

    memcpy(u.pb, (BYTE*) pHdr, dwHdrLen);
    u.pb += dwHdrLen;
    memcpy(u.pb, (BYTE*) pObj, dwObjLen);
    u.pb += dwObjLen;
    
    EndEntry(u);

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::EmitString(MIXEDPTRS &u, LPCWSTR pSrc, DWORD dwLen, int *piOffSet)
{
    HRESULT hr = AllocateThemeFileBytes(u.pb, (dwLen + 1) * sizeof(WCHAR));
    if (FAILED(hr))
        return hr;

    lstrcpy(u.px, pSrc);
    if (piOffSet)
    {
        *piOffSet = THEME_OFFSET(u.pb);
    }
    u.px += dwLen + 1;
    return S_OK;
}
//---------------------------------------------------------------------------
int CThemeLoader::GetMaxState(APPCLASSLOCAL *ac, int iPartNum)
{
    //---- calculate max. state index ----
    int iMaxState = -1;
    int pscnt = ac->PartStateIndexes.GetSize();

    for (int i=0; i < pscnt; i++)
    {
        PART_STATE_INDEX *psi = &ac->PartStateIndexes[i];

        if (psi->iPartNum == iPartNum)
        {
            if (psi->iStateNum > iMaxState)
                iMaxState = psi->iStateNum;
        }
    }

    return iMaxState;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::CopyPartGroup(APPCLASSLOCAL *ac, MIXEDPTRS &u, int iPartNum, 
    int *piPartJumpTable, int iPartZeroIndex, int iGlobalsOffset, BOOL fGlobalsGroup)
{
    HRESULT hr = S_OK;
    int *piStateJumpTable = NULL;

    //---- calculate max. state index ----
    int iMaxState = GetMaxState(ac, iPartNum);
    if (iMaxState < 0)          // no states to copy
        goto exit;

    //---- update part jump table index ----
    if (piPartJumpTable)
        piPartJumpTable[iPartNum] = THEME_OFFSET(u.pb);

    if (iMaxState > 0)          // create a state jump table
    {
        //---- create state jump table ----
        hr = EmitEntryHdr(u, TMT_STATEJUMPTABLE, TMT_STATEJUMPTABLE);
        if (FAILED(hr))
            goto exit;

        int statecnt = 1 + iMaxState;

        hr = AllocateThemeFileBytes(u.pb, 1 + statecnt * sizeof(int));
        if (FAILED(hr))
            goto exit;

        // 1 byte table entry count
        *u.pb++ = (BYTE)statecnt;

        piStateJumpTable = u.pi;

        //---- default "not avail" indexes for children ----
        for (int j=0; j < statecnt; j++)
            *u.pi++ = -1;

        EndEntry(u);
    }

    int pscnt, iStateZeroIndex;
    iStateZeroIndex = THEME_OFFSET(u.pb);
    pscnt = ac->PartStateIndexes.GetSize();

    //---- copy each defined part/state section ----
    for (int state=0; state <= iMaxState; state++)
    {
        PART_STATE_INDEX *psi = NULL;

        //---- find entry for "state" ----
        for (int i=0; i < pscnt; i++)
        {
            psi = &ac->PartStateIndexes[i];

            if ((psi->iPartNum == iPartNum) && (psi->iStateNum == state))
                break;
        }

        if (i == pscnt)     // not found
            continue;

        //---- update state jump table entry ----
        if (piStateJumpTable)
            piStateJumpTable[state] = THEME_OFFSET(u.pb);

        //---- copy the actual PART/STATE DATA  ----
        hr = EmitAndCopyBlock(u, _pbLocalData+psi->iIndex, psi->iLen);

        //---- update child's "JumpToParent" value ----
        if (! state)    
        {
            if (fGlobalsGroup) 
            {
                *(u.pi-1) = -1;      // end of the line   
            }
            else if (! iPartNum)     // simple class jumps to globals
            {
                *(u.pi-1) = iGlobalsOffset;
            }
            else                // parts jumps to their base class
            {
                *(u.pi-1) = iPartZeroIndex;
            }
        }
        else        // states jumps to their base part
        {
            *(u.pi-1) = iStateZeroIndex;
        }
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::CopyClassGroup(APPCLASSLOCAL *ac, MIXEDPTRS &u, int iGlobalsOffset,
    int iClassNameOffset)
{
    HRESULT hr = S_OK;
    int *piPartJumpTable = NULL;
    int *piFirstPackObj = NULL;
    int partcnt;
    int iPartZeroIndex;
    CRenderObj *pRender = NULL;
    BOOL fGlobals = (iGlobalsOffset == THEME_OFFSET(u.pb));

    BYTE *pStartOfSection = u.pb;

    BOOL fGlobalGroup = (THEME_OFFSET(u.pb) == iGlobalsOffset);

    //---- always create a part table ----
    hr = EmitEntryHdr(u, TMT_PARTJUMPTABLE, TMT_PARTJUMPTABLE);
    if (FAILED(hr))
        goto exit;

    partcnt = 1 + ac->iMaxPartNum;
    
    // offset to first packed DrawObj/TextObj
    piFirstPackObj = u.pi;
    hr = AllocateThemeFileBytes(u.pb, 1 + (1 + partcnt) * sizeof(int));
    if (FAILED(hr))
        goto exit;

    *u.pi++ = 0;        // will update later

    // partcnt
    *u.pb++ = (BYTE)partcnt;

    piPartJumpTable = u.pi;

    //---- default "not avail" indexes for children ----
    for (int j=0; j < partcnt; j++)
        *u.pi++ = -1;

    EndEntry(u);


    iPartZeroIndex = THEME_OFFSET(u.pb);

    //---- copy each defined part section ----
    for (int j=0; j <= ac->iMaxPartNum; j++)
    {
        CopyPartGroup(ac, u, j, piPartJumpTable, iPartZeroIndex, 
            iGlobalsOffset, fGlobalGroup);
    }

    //---- now, extract draw objs for each part/state as needed ----
    *piFirstPackObj = THEME_OFFSET(u.pb);

    //---- build a CRenderObj to access the just copied class section ----
    hr = CreateRenderObj(&_LoadingThemeFile, 0, THEME_OFFSET(pStartOfSection), 
        iClassNameOffset, 0, FALSE, NULL, NULL, 0, &pRender);
    if (FAILED(hr))
        goto exit;

    if (fGlobals)
        _iGlobalsDrawObj = THEME_OFFSET(u.pb);

    hr = PackDrawObjects(u, pRender, ac->iMaxPartNum, fGlobals);
    if (FAILED(hr))
        goto exit;

    if (fGlobals)
        _iGlobalsTextObj = THEME_OFFSET(u.pb);

    hr = PackTextObjects(u, pRender, ac->iMaxPartNum, fGlobals);
    if (FAILED(hr))
        goto exit;

    //---- write "end of class" marker ----
    hr = EmitEntryHdr(u, TMT_ENDOFCLASS, TMT_ENDOFCLASS);
    if (FAILED(hr))
        goto exit;

    EndEntry(u);

exit:
    delete pRender;
    return hr;
}
//---------------------------------------------------------------------------
__inline HRESULT CThemeLoader::AllocateThemeFileBytes(BYTE *upb, DWORD dwAdditionalLen)
{
    ASSERT(upb != NULL && _LoadingThemeFile._pbThemeData != NULL);

    if (PtrToUint(upb) / _dwPageSize != PtrToUint(upb + dwAdditionalLen) / _dwPageSize)
    {
        if (NULL == VirtualAlloc(_LoadingThemeFile._pbThemeData, upb - _LoadingThemeFile._pbThemeData + 1 + dwAdditionalLen, MEM_COMMIT, PAGE_READWRITE))
        {
            return MakeError32(ERROR_NOT_ENOUGH_MEMORY);        
        }
    }
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::CopyLocalThemeToLive(int iTotalLength, 
    LPCWSTR pszThemeName, LPCWSTR pszColorParam, LPCWSTR pszSizeParam)
{
    int i;
    MIXEDPTRS u;
    HRESULT hr = S_OK;

    u.pb = (BYTE*) VirtualAlloc(_LoadingThemeFile._pbThemeData, sizeof(THEMEHDR), MEM_COMMIT, PAGE_READWRITE);
    if (u.pb == NULL)
    {
        return MakeError32(ERROR_NOT_ENOUGH_MEMORY);        
    }

    _iGlobalsOffset = -1;
    _iSysMetricsOffset = -1;
    int iIndexCount = _LocalIndexes.GetSize();

    //---- build header ----
    THEMEHDR *hdr = (THEMEHDR *)u.pb;
    u.pb += sizeof(THEMEHDR);

    hdr->dwTotalLength = iTotalLength;

    memcpy(hdr->szSignature, kszBeginCacheFileSignature, kcbBeginSignature);

    hdr->dwVersion = THEMEDATA_VERSION;
    hdr->dwFlags = 0;       // not yet ready to be accessed

    hdr->iDllNameOffset = 0;     // will be updated
    hdr->iColorParamOffset = 0;  // will be updated
    hdr->iSizeParamOffset = 0;   // will be updated
    hdr->dwLangID = (DWORD) GetUserDefaultUILanguage();
    hdr->iLoadId = 0;            // was iLoadCounter
    
    hdr->iGlobalsOffset = 0;            // will be updated
    hdr->iGlobalsTextObjOffset = 0;     // will be updated
    hdr->iGlobalsDrawObjOffset = 0;     // will be updated

    hdr->dwCheckSum = 0;         // will be updated

    // Store the time stamp of the .msstyles file in the live file, this will be written to the cache file
    // for later comparison (Whistler:190202).
    ::ZeroMemory(&hdr->ftModifTimeStamp, sizeof &hdr->ftModifTimeStamp);

    HANDLE hFile = ::CreateFile(pszThemeName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        // There's nothing we can do if GetFileTime() fails
        ::GetFileTime(hFile, NULL, NULL, &hdr->ftModifTimeStamp);
        ::CloseHandle(hFile);
    }

    //---- build string section ----
    hdr->iStringsOffset = THEME_OFFSET(u.pb);
    DWORD *pdwFirstString = u.pdw;  
    int len;

    //---- add header strings ----
    len = lstrlen(pszThemeName);
    if (len)
    {
        hr = EmitString(u, pszThemeName, len, &hdr->iDllNameOffset);
        if (FAILED(hr))
            goto exit;
    }
    
    len = lstrlen(pszColorParam);
    if (len)
    {
        hr = EmitString(u, pszColorParam, len, &hdr->iColorParamOffset);
        if (FAILED(hr))
            goto exit;
    }
    
    len = lstrlen(pszSizeParam);
    if (len)
    {
        hr = EmitString(u, pszSizeParam, len, &hdr->iSizeParamOffset);
        if (FAILED(hr))
            goto exit;
    }

    //---- add strings from class index ----
    for (i=0; i < iIndexCount; i++)
    {
        APPCLASSLOCAL *ac = &_LocalIndexes[i];

        int len = ac->csAppName.GetLength();
        if (len)
        {
            hr = EmitString(u, ac->csAppName, len, (int*) &ac->LiveIndex.dwAppNameIndex);
            if (FAILED(hr))
                goto exit;
        }
        else
            ac->LiveIndex.dwAppNameIndex = 0;

        len = ac->csClassName.GetLength();
        if (len)
        {
            hr = EmitString(u, ac->csClassName, len, (int*) &ac->LiveIndex.dwClassNameIndex);
            if (FAILED(hr))
                goto exit;
        }
        else
            ac->LiveIndex.dwClassNameIndex = 0;
    }

    //---- copy strings from LOADTHEMEMETRICS -----
    for (i=0; i < TM_STRINGCOUNT; i++)
    {
        CWideString *ws = &_LoadThemeMetrics.wsStrings[i];
        int len = ws->GetLength();
        if (len)
        {
            hr = EmitString(u, *ws, len, &_LoadThemeMetrics.iStringOffsets[i]);
            if (FAILED(hr))
                goto exit;
        }
        else
            _LoadThemeMetrics.iStringOffsets[i] = 0;
    }

    int iStringLength = int(u.pb - ((BYTE *)pdwFirstString));
    hdr->iStringsLength = iStringLength;

    //---- write index header ----
    hdr->iSectionIndexOffset = THEME_OFFSET(u.pb);
    hdr->iSectionIndexLength = iIndexCount * sizeof(APPCLASSLIVE);

    APPCLASSLIVE *acl = (APPCLASSLIVE *)u.pb;     // will write these in parallel with theme data
    hr = AllocateThemeFileBytes(u.pb, hdr->iSectionIndexLength);
    if (FAILED(hr))
        goto exit;

    u.pb += hdr->iSectionIndexLength;

    //---- write index AND theme data in parallel ----

    //---- first pass thru, copy [globals] and all [app::xxx] sections ----
    for (i=0; i < iIndexCount; i++)         // for each parent section 
    {
        APPCLASSLOCAL *ac = &_LocalIndexes[i];

        if ((i) && (! ac->LiveIndex.dwAppNameIndex))     // not an [app::] section
            continue;

        acl->dwAppNameIndex = ac->LiveIndex.dwAppNameIndex;
        acl->dwClassNameIndex = ac->LiveIndex.dwClassNameIndex;

        acl->iIndex = THEME_OFFSET(u.pb);

        if (AsciiStrCmpI(ac->csClassName, L"globals")== 0)      // globals section
            _iGlobalsOffset = acl->iIndex;

        hr = CopyClassGroup(ac, u, _iGlobalsOffset, acl->dwClassNameIndex);
        if (FAILED(hr))
            goto exit;

        acl->iLen = THEME_OFFSET(u.pb) - acl->iIndex;

        acl++;
    }

    //---- second pass thru, copy all non-[app::xxx] sections (except [globals]) ----
    for (i=0; i < iIndexCount; i++)         // for each parent section 
    {
        APPCLASSLOCAL *ac = &_LocalIndexes[i];

        if ((! i) || (ac->LiveIndex.dwAppNameIndex))     // don't process [app::] sections
            continue;

        acl->dwAppNameIndex = ac->LiveIndex.dwAppNameIndex;
        acl->dwClassNameIndex = ac->LiveIndex.dwClassNameIndex;

        acl->iIndex = THEME_OFFSET(u.pb);

        if (AsciiStrCmpI(ac->csClassName, L"sysmetrics")== 0)      // SysMetrics section
        {
            _iSysMetricsOffset = acl->iIndex;

            hr = EmitEntryHdr(u, TMT_THEMEMETRICS, TMT_THEMEMETRICS);
            if (FAILED(hr))
                goto exit;

            DWORD len = sizeof(THEMEMETRICS);
            
            hr = EmitAndCopyBlock(u, (BYTE*) (THEMEMETRICS*) &_LoadThemeMetrics, len);

            EndEntry(u);

            //---- add a "jump to parent" to be consistent (not used) ----
            hr = EmitEntryHdr(u, TMT_JUMPTOPARENT, TMT_JUMPTOPARENT);
            if (FAILED(hr))
                goto exit;

            hr = AllocateThemeFileBytes(u.pb, sizeof(int));
            if (FAILED(hr))
                goto exit;

            *u.pi++ = -1;
            EndEntry(u);
        }
        else            // regular section
        {
            hr = CopyClassGroup(ac, u, _iGlobalsOffset, acl->dwClassNameIndex);
            if (FAILED(hr))
                goto exit;
        }

        acl->iLen = THEME_OFFSET(u.pb) - acl->iIndex;
        acl++;
    }

    hr = EmitAndCopyBlock(u, (BYTE*) kszEndCacheFileSignature, kcbEndSignature);
    if (FAILED(hr))
        goto exit;
  
    //---- ensure we got the calc size right ----
    DWORD dwActualLen;
    dwActualLen = THEME_OFFSET(u.pb);
    if (hdr->dwTotalLength != dwActualLen)
    {
        //---- make this growable so we really have enough room ----
        //Log(LOG_TMCHANGE, L"ThemeLoader - calculated len=%d, actual len=%d", 
        //    hdr->dwTotalLength, dwActualLen);
        hdr->dwTotalLength = dwActualLen;         
    }

    Log(LOG_TMCHANGE, L"ThemeLoader - theme size: %d", dwActualLen);

    //----- update header fields ----
    hdr->dwFlags |= SECTION_READY;
    hdr->iGlobalsOffset = _iGlobalsOffset;
    hdr->iSysMetricsOffset = _iSysMetricsOffset;
    hdr->iGlobalsTextObjOffset = _iGlobalsTextObj;
    hdr->iGlobalsDrawObjOffset = _iGlobalsDrawObj;

#ifdef NEVER
    hdr->dwCheckSum = _LoadingThemeFile.DataCheckSum();
#else
    hdr->dwCheckSum = 0;
#endif // NEVER

exit:
    return hr;

}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::PackMetrics()
{
    //---- find the optional [SysMetrics] section ----
    int iIndexCount = _LocalIndexes.GetSize();
    APPCLASSLOCAL *ac = NULL;

    for (int i=0; i < iIndexCount; i++)
    {
        ac = &_LocalIndexes[i];
    
        if (AsciiStrCmpI(ac->csClassName, L"SysMetrics")==0)
            break;
    }

    if (i == iIndexCount)       // not found
        return S_OK;
    
    //---- walk thru the properties & put into _LoadThemeMetrics ----
    if (! ac->PartStateIndexes.GetSize())       // no data
        return S_OK;

    MIXEDPTRS u;
    //---- parts & states not allowed so just use entry "0" ----
    u.pb = _pbLocalData + ac->PartStateIndexes[0].iIndex;
    UCHAR *lastpb = u.pb + ac->PartStateIndexes[0].iLen;

    while ((u.pb < lastpb) && (*u.pw != TMT_JUMPTOPARENT))
    {
        UNPACKED_ENTRYHDR hdr;

        FillAndSkipHdr(u, &hdr);

        switch (hdr.ePrimVal)
        {
            case TMT_FONT:
                _LoadThemeMetrics.lfFonts[hdr.usTypeNum-TMT_FIRSTFONT] = *(LOGFONT *)u.pb;
                break;

            case TMT_COLOR:
                _LoadThemeMetrics.crColors[hdr.usTypeNum-TMT_FIRSTCOLOR] = *(COLORREF *)u.pb;
                break;

            case TMT_BOOL:
                _LoadThemeMetrics.fBools[hdr.usTypeNum-TMT_FIRSTBOOL] = (BOOL)*u.pb;
                break;

            case TMT_SIZE:
                _LoadThemeMetrics.iSizes[hdr.usTypeNum-TMT_FIRSTSIZE] = *(int *)u.pb;
                break;

            case TMT_INT:
                _LoadThemeMetrics.iInts[hdr.usTypeNum-TMT_FIRSTINT] = *(int *)u.pb;
                break;

            case TMT_STRING:
                _LoadThemeMetrics.wsStrings[hdr.usTypeNum-TMT_FIRSTSTRING] = (WCHAR *)u.pb;
                break;
        }

        u.pb += hdr.dwDataLen;      // skip to next entry
    }

    //---- compute packed size of theme metrics ----

    //---- the actual entry ----
    ac->iPackedSize = ENTRYHDR_SIZE + sizeof(THEMEMETRICS);

    //---- a "jump to parent" entry ----
    ac->iPackedSize += ENTRYHDR_SIZE + sizeof(int);

    //---- add strings used in sysmetrics ----
    for (i=0; i < TM_STRINGCOUNT; i++)
    {
        int len =  _LoadThemeMetrics.wsStrings[i].GetLength();
        ac->iPackedSize += sizeof(WCHAR)*(1 + len);
    }
    
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::PackThemeStructs()
{
    HRESULT hr = PackMetrics();
    if (FAILED(hr))
        return hr;

    //---- IMAGEDATA and TEXTDATA packing go here ----

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::PackAndLoadTheme(LPCWSTR pszThemeName, LPCWSTR pszColorParam,
        LPCWSTR pszSizeParam, HINSTANCE hInst)
{
    WCHAR szColor[MAX_PATH];
    WCHAR szSize[MAX_PATH];

    HRESULT hr = PackThemeStructs();        

    //---- if color not specifed, get default color ----
    if ((! pszColorParam) || (! *pszColorParam))     
    {
        hr = GetResString(hInst, L"COLORNAMES", 0, szColor, ARRAYSIZE(szColor));
        if (FAILED(hr))
            goto exit;

        pszColorParam = szColor;
    }

    //---- if size not specifed, get default size ----
    if ((! pszSizeParam) || (! *pszSizeParam))     
    {
        hr = GetResString(hInst, L"SIZENAMES", 0, szSize, ARRAYSIZE(szSize));
        if (FAILED(hr))
            goto exit;

        pszSizeParam = szSize;
    }

    hr = _LoadingThemeFile.CreateFile(MAX_SHAREDMEM_SIZE, TRUE);
    if (FAILED(hr))
        goto exit;

    //---- copy local theme data to live ----
    hr = CopyLocalThemeToLive(MAX_SHAREDMEM_SIZE, pszThemeName, pszColorParam, pszSizeParam);
    if (FAILED(hr))
        goto exit;

exit:
    return hr;
}
//---------------------------------------------------------------------------
BOOL CThemeLoader::GetThemeName(LPTSTR NameBuff, int BuffSize)
{
    Log(LOG_TM, L"GetThemeName()");

    int len = _wsThemeFileName.GetLength();
    if (BuffSize < len)
        return FALSE;

    lstrcpy(NameBuff, _wsThemeFileName);
    return TRUE;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::AddMissingParent(LPCWSTR pszAppName, LPCWSTR pszClassName, 
    int iPartNum, int iStateNum)
{
    //---- add missing parent section ----
    int iData = 0;
    int iStart = GetNextDataIndex();

    HRESULT hr = AddData(TMT_JUMPTOPARENT, TMT_JUMPTOPARENT, &iData, sizeof(iData));
    if (FAILED(hr))
        return hr;

    int iLen = GetNextDataIndex() - iStart;
    
    hr = AddIndexInternal(pszAppName, pszClassName, iPartNum, iStateNum, 
        iStart, iLen);
    if (FAILED(hr))
        return hr;
    
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::AddIndex(LPCWSTR pszAppName, LPCWSTR pszClassName, 
    int iPartNum, int iStateNum, int iIndex, int iLen)
{
    HRESULT hr;

    if (iPartNum)       // ensure parent exists
    {
        if (! IndexExists(pszAppName, pszClassName, 0, 0))
        {
            hr = AddMissingParent(pszAppName, pszClassName, 0, 0);
            if (FAILED(hr))
                return hr;
        }
    }


    if (iStateNum)      // ensure parent exists
    {
        if (! IndexExists(pszAppName, pszClassName, iPartNum, 0))
        {
            hr = AddMissingParent(pszAppName, pszClassName, iPartNum, 0);
            if (FAILED(hr))
                return hr;
        }
    }

    hr = AddIndexInternal(pszAppName, pszClassName, iPartNum, iStateNum, iIndex,
        iLen);
    if (FAILED(hr))
        return hr;
    
    return S_OK;
}
//---------------------------------------------------------------------------
BOOL CThemeLoader::IndexExists(LPCWSTR pszAppName, LPCWSTR pszClassName, 
    int iPartNum, int iStateNum)
{
    //---- try to find existing entry ----
    int cnt = _LocalIndexes.GetSize();

    for (int i=0; i < cnt; i++)
    {
        LPCWSTR localAppName = _LocalIndexes[i].csAppName;

        if ((pszAppName) && (*pszAppName))
        {
            if ((! localAppName) || (! *localAppName))
                continue;
            if (AsciiStrCmpI(pszAppName, localAppName) != 0)
                continue;
        }
        else if ((localAppName) && (*localAppName))
            continue;

        if (AsciiStrCmpI(pszClassName, _LocalIndexes[i].csClassName)==0)
            break;
    }

    if (i == cnt)       // not found
        return FALSE;

    //---- find matching child info ----
    APPCLASSLOCAL *acl = &_LocalIndexes[i];

    for (int c=0; c < acl->PartStateIndexes.m_nSize; c++)
    {
        if (acl->PartStateIndexes[c].iPartNum == iPartNum)
        {
            if (acl->PartStateIndexes[c].iStateNum == iStateNum)
                return TRUE;
        }
    }

    return FALSE;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::AddIndexInternal(LPCWSTR pszAppName, LPCWSTR pszClassName, 
    int iPartNum, int iStateNum, int iIndex, int iLen)
{
    //---- try to find existing entry ----
    int cnt = _LocalIndexes.GetSize();

    for (int i=0; i < cnt; i++)
    {
        LPCWSTR localAppName = _LocalIndexes[i].csAppName;

        if ((pszAppName) && (*pszAppName))
        {
            if ((! localAppName) || (! *localAppName))
                continue;
            if (AsciiStrCmpI(pszAppName, localAppName) != 0)
                continue;
        }
        else if ((localAppName) && (*localAppName))
            continue;

        if (AsciiStrCmpI(pszClassName, _LocalIndexes[i].csClassName)==0)
            break;
    }

    APPCLASSLOCAL *acl;

    if (i == cnt)       // not found - create a new entry
    {
        APPCLASSLOCAL local;

        local.csAppName = pszAppName;
        local.csClassName = pszClassName;
        local.iMaxPartNum = 0;
        local.iPackedSize = 0;

        _LocalIndexes.Add(local);

        int last = _LocalIndexes.GetSize()-1;
        acl = &_LocalIndexes[last];
    }
    else                // update existing entry with child info
    {    
        acl = &_LocalIndexes[i];

        // child info should not be there already
        for (int c=0; c < acl->PartStateIndexes.m_nSize; c++)
        {
            if (acl->PartStateIndexes[c].iPartNum == iPartNum)
            {
                if (acl->PartStateIndexes[c].iStateNum == iStateNum)
                {
                    return MakeError32(ERROR_ALREADY_EXISTS); 
                }
            }
        }
    }

    //---- add the part ----
    if (iPartNum > acl->iMaxPartNum)
        acl->iMaxPartNum = iPartNum;

    PART_STATE_INDEX psi;
    psi.iPartNum = iPartNum;
    psi.iStateNum = iStateNum;
    psi.iIndex = iIndex;
    psi.iLen = iLen;

    acl->PartStateIndexes.Add(psi);

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::AddData(SHORT sTypeNum, PRIMVAL ePrimVal, const void *pData, DWORD dwLen)
{
    DWORD dwFullLen = ENTRYHDR_SIZE + dwLen;
    HRESULT hr;
    BYTE bFiller = ALIGN_FACTOR - 1;

    MIXEDPTRS u;
    u.pb = _pbLocalData + _iLocalLen;

    //---- add to local copy of theme data ----
    if ((PtrToUint(u.pb) / _dwPageSize != PtrToUint(u.pb + dwFullLen + bFiller) / _dwPageSize)
        || _iLocalLen == 0)
    {
        if (NULL == VirtualAlloc(_pbLocalData, _iLocalLen + 1 + dwFullLen + bFiller, MEM_COMMIT, PAGE_READWRITE))
        {
            return MakeError32(ERROR_NOT_ENOUGH_MEMORY);        
        }
    }

    hr = EmitEntryHdr(u, sTypeNum, ePrimVal);
    if (FAILED(hr))
        goto exit;

    if (dwLen)
    {
        memcpy(u.pb, pData, dwLen);
        u.pb += dwLen;
    }

    //---- this may generate filler bytes ----
    bFiller = (BYTE)EndEntry(u);

    _iLocalLen += (dwFullLen + bFiller);

exit:
    return hr;
}
//---------------------------------------------------------------------------
int CThemeLoader::GetNextDataIndex()
{
    return _iLocalLen;
}
//---------------------------------------------------------------------------
void SetSysBool(THEMEMETRICS* ptm, int iBoolNum, int iSpiSetNum)
{
    BOOL fVal = ptm->fBools[iBoolNum - TMT_FIRSTBOOL];
    BOOL fSet = ClassicSystemParametersInfo(iSpiSetNum, 0, IntToPtr(fVal), SPIF_SENDCHANGE | SPIF_UPDATEINIFILE);
    if (! fSet)
    {
        Log(LOG_ALWAYS, L"Error returned from ClassicSystemParametersInfo() call to set BOOL");
    }
}
//---------------------------------------------------------------------------
void SetSystemMetrics_Worker(THEMEMETRICS* ptm)
{
#ifdef DEBUG
    if (LogOptionOn(LO_TMLOAD))
    {
        WCHAR szUserName[MAX_PATH];
        DWORD dwSize = ARRAYSIZE(szUserName);
    
        GetUserName(szUserName, &dwSize);

        Log(LOG_TMLOAD, L"SetSystemMetrics_Worker: User=%s, SM_REMOTESESSION=%d", 
            szUserName, GetSystemMetrics(SM_REMOTESESSION));
    }
#endif
    //---- apply nonclient metrics ----
    NONCLIENTMETRICS ncm = {sizeof(ncm)};
    BOOL fSet;

    //----- scale all sizes from 96-dpi to match current screen logical DPI ----
    ncm.iBorderWidth = ScaleSizeForScreenDpi(ptm->iSizes[TMT_SIZINGBORDERWIDTH - TMT_FIRSTSIZE]);

    ncm.iCaptionWidth = ScaleSizeForScreenDpi(ptm->iSizes[TMT_CAPTIONBARWIDTH - TMT_FIRSTSIZE]);
    ncm.iCaptionHeight = ScaleSizeForScreenDpi(ptm->iSizes[TMT_CAPTIONBARHEIGHT - TMT_FIRSTSIZE]);
    
    ncm.iSmCaptionWidth = ScaleSizeForScreenDpi(ptm->iSizes[TMT_SMCAPTIONBARWIDTH - TMT_FIRSTSIZE]);
    ncm.iSmCaptionHeight = ScaleSizeForScreenDpi(ptm->iSizes[TMT_SMCAPTIONBARHEIGHT - TMT_FIRSTSIZE]);
    
    ncm.iMenuWidth = ScaleSizeForScreenDpi(ptm->iSizes[TMT_MENUBARWIDTH - TMT_FIRSTSIZE]);
    ncm.iMenuHeight = ScaleSizeForScreenDpi(ptm->iSizes[TMT_MENUBARHEIGHT - TMT_FIRSTSIZE]);
    
    ncm.iScrollWidth = ScaleSizeForScreenDpi(ptm->iSizes[TMT_SCROLLBARWIDTH - TMT_FIRSTSIZE]);
    ncm.iScrollHeight = ScaleSizeForScreenDpi(ptm->iSizes[TMT_SCROLLBARHEIGHT - TMT_FIRSTSIZE]);

    //---- transfer font info (stored internally at 96 dpi) ----
    ncm.lfCaptionFont = ptm->lfFonts[TMT_CAPTIONFONT - TMT_FIRSTFONT];
    ncm.lfSmCaptionFont = ptm->lfFonts[TMT_SMALLCAPTIONFONT - TMT_FIRSTFONT];
    ncm.lfMenuFont = ptm->lfFonts[TMT_MENUFONT - TMT_FIRSTFONT];
    ncm.lfStatusFont = ptm->lfFonts[TMT_STATUSFONT - TMT_FIRSTFONT];
    ncm.lfMessageFont = ptm->lfFonts[TMT_MSGBOXFONT - TMT_FIRSTFONT];

    //---- scale fonts (from 96 dpi to current screen dpi) ----
    ScaleFontForScreenDpi(&ncm.lfCaptionFont);
    ScaleFontForScreenDpi(&ncm.lfSmCaptionFont);
    ScaleFontForScreenDpi(&ncm.lfMenuFont);
    ScaleFontForScreenDpi(&ncm.lfStatusFont);
    ScaleFontForScreenDpi(&ncm.lfMessageFont);

    fSet = ClassicSystemParametersInfo(SPI_SETNONCLIENTMETRICS,
                                       sizeof(NONCLIENTMETRICS),
                                       &ncm, 
                                       SPIF_SENDCHANGE | SPIF_UPDATEINIFILE);
    if (! fSet)
    {
        Log(LOG_ALWAYS, L"Error returned from ClassicSystemParametersInfo(SPI_SETNONCLIENTMETRICS)");
    }

    //---- apply the remaining font ----
    LOGFONT lf = ptm->lfFonts[TMT_ICONTITLEFONT - TMT_FIRSTFONT];
    ScaleFontForScreenDpi(&lf);
    fSet = ClassicSystemParametersInfo(SPI_SETICONTITLELOGFONT,
                                       sizeof(LOGFONT),
                                       &lf, 
                                       SPIF_SENDCHANGE | SPIF_UPDATEINIFILE);
    if (! fSet)
    {
        Log(LOG_ALWAYS, L"Error returned from ClassicSystemParametersInfo(SPI_SETICONTITLELOGFONT)");
    }

    //---- apply the sys bools (one at a time, unfortunately) ----
    SetSysBool(ptm, TMT_FLATMENUS, SPI_SETFLATMENU);

    //---- apply system colors ----
    int iIndexes[TM_COLORCOUNT];
    for (int i=0; i < TM_COLORCOUNT; i++)
    {
        iIndexes[i] = i;
    }

    fSet = SetSysColors(TM_COLORCOUNT, iIndexes, ptm->crColors);
    if (! fSet)
    {
        Log(LOG_ALWAYS, L"Error returned from SetSysColors()");
    }

    HRESULT hr = PersistSystemColors(ptm);     // write them to registry
    if (FAILED(hr))
    {
        Log(LOG_ALWAYS, L"failed to persist SysColors");
    }
}
//---------------------------------------------------------------------------
STDAPI_(DWORD) SetSystemMetrics_WorkerThread(void* pv)
{
    THEMEMETRICS_THREADINFO* ptm = (THEMEMETRICS_THREADINFO*)pv;
    ASSERT(ptm);
    
    BOOL fSuccess = TRUE;

    if (ptm->hUserToken)
    {
        fSuccess = ImpersonateLoggedOnUser(ptm->hUserToken);

        if (!fSuccess)
        {
            Log(LOG_ALWAYS, L"ImpersonateLoggedOnUser failed in SetSystemMetrics");
        }
    }
    
    if (fSuccess)
    {
        SetSystemMetrics_Worker(&ptm->tm);
    }

    if (ptm->hUserToken)
    {
        if (fSuccess)
        {
            RevertToSelf();
        }
        CloseHandle(ptm->hUserToken);
    }
    
    LocalFree(ptm);
    
    FreeLibraryAndExitThread(g_hInst, 0);
}
//---------------------------------------------------------------------------
void SetSystemMetrics(THEMEMETRICS* ptm, BOOL fSyncLoad)
{
    BOOL bSuccess = FALSE;
    HMODULE hmod;

    if (!ptm)           
    {
        return;
    }

    if (! fSyncLoad)      // ok to use a new thread
    {
        // add a dllref for the thread we are creating
        hmod = LoadLibrary(TEXT("uxtheme.dll"));
        if (hmod)
        {
            THEMEMETRICS_THREADINFO* ptmCopy = (THEMEMETRICS_THREADINFO*)LocalAlloc(LPTR, sizeof(THEMEMETRICS_THREADINFO));

            if (ptmCopy)
            {
                // fill in all of the thememetrics info for the thread we are going to create
                CopyMemory(ptmCopy, ptm, sizeof(THEMEMETRICS));

                HANDLE hToken = NULL;
                // If the calling thread is impersonating, use the same token
                // OpenThreadToken can fail if the thread is not impersonating
#ifdef DEBUG
                BOOL fSuccess = 
#endif
                OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_IMPERSONATE, FALSE, &hToken);
#ifdef DEBUG
                if (!fSuccess)
                {
                    DWORD dw = GetLastError();
                    Log(LOG_TMCHANGE, L"OpenThreadToken failed in SetSystemMetrics, last error=%d", dw);
                }
#endif

                ptmCopy->hUserToken = hToken;

                // we want to do this async since we end up calling xxxSendMessage for a TON of things which blocks this 
                // thread which can cause deadlocks
                HANDLE hThread = CreateThread(NULL, 0, SetSystemMetrics_WorkerThread, ptmCopy,  0, NULL);

                if (hThread)
                {
                    CloseHandle(hThread);
                    bSuccess = TRUE;
                }
                else
                {
                    LocalFree(ptmCopy);
                }
            }

            if (!bSuccess)
            {
                FreeLibrary(hmod);
            }
        }
    }

    if (!bSuccess)
    {
        // failed, fall back to calling synchronously
        SetSystemMetrics_Worker(ptm);
    }
}
//---------------------------------------------------------------------------
void SetFont(LOGFONT *plf, LPCWSTR lszFontName, int iPointSize)
{
    memset(plf, 0, sizeof(LOGFONT));

    plf->lfWeight = FW_NORMAL;
    plf->lfCharSet = DEFAULT_CHARSET;
    plf->lfHeight = iPointSize;

    lstrcpy(plf->lfFaceName, lszFontName);
}
//---------------------------------------------------------------------------
COLORREF DefaultColors[] = 
{
    RGB(212, 208, 200),     // Scrollbar (0)
    RGB(58, 110, 165),      // Background (1)
    RGB(10, 36, 106),       // ActiveCaption (2)
    RGB(128, 128, 128),     // InactiveCaption (3)
    RGB(212, 208, 200),     // Menu (4)
    RGB(255, 255, 255),     // Window (5)
    RGB(0, 0, 0),           // WindowFrame (6)
    RGB(0, 0, 0),           // MenuText (7)
    RGB(0, 0, 0),           // WindowText (8)
    RGB(255, 255, 255),     // CaptionText (9)
    RGB(212, 208, 200),     // ActiveBorder (10)
    RGB(212, 208, 200),     // InactiveBorder (11)
    RGB(128, 128, 128),     // AppWorkSpace (12)
    RGB(10, 36, 106),       // Highlight (13)
    RGB(255, 255, 255),     // HighlightText (14)
    RGB(212, 208, 200),     // BtnFace (15)
    RGB(128, 128, 128),     // BtnShadow (16)
    RGB(128, 128, 128),     // GrayText (17)
    RGB(0, 0, 0),           // BtnText (18)
    RGB(212, 208, 200),     // InactiveCaptionText (19)
    RGB(255, 255, 255),     // BtnHighlight (20)
    RGB(64, 64, 64),        // DkShadow3d (21)
    RGB(212, 208, 200),     // Light3d (22)
    RGB(0, 0, 0),           // InfoText (23)
    RGB(255, 255, 225),     // InfoBk (24)
    RGB(181, 181, 181),     // ButtonAlternateFace (25)
    RGB(0, 0, 128),         // HotTracking (26)
    RGB(166, 202, 240),     // GradientActiveCaption (27)
    RGB(192, 192, 192),     // GradientInactiveCaption (28)
    RGB(206, 211, 225),     // MenuiHilight (29)
    RGB(244, 244, 240),     // MenuBar (30)
};
//---------------------------------------------------------------------------
HRESULT InitThemeMetrics(LOADTHEMEMETRICS *tm)
{
    memset(tm, 0, sizeof(*tm));     // zero out in case we miss a property

    //---- init fonts ----
    SetFont(&tm->lfFonts[TMT_CAPTIONFONT - TMT_FIRSTFONT], L"tahoma bold", POINTS_DPI96(8));
    SetFont(&tm->lfFonts[TMT_SMALLCAPTIONFONT - TMT_FIRSTFONT], L"tahoma", POINTS_DPI96(8));
    SetFont(&tm->lfFonts[TMT_MENUFONT - TMT_FIRSTFONT], L"tahoma", POINTS_DPI96(8));
    SetFont(&tm->lfFonts[TMT_STATUSFONT - TMT_FIRSTFONT], L"tahoma", POINTS_DPI96(8));
    SetFont(&tm->lfFonts[TMT_MSGBOXFONT - TMT_FIRSTFONT], L"tahoma", POINTS_DPI96(8));
    SetFont(&tm->lfFonts[TMT_ICONTITLEFONT - TMT_FIRSTFONT], L"tahoma", POINTS_DPI96(8));

    //---- init bools ----
    tm->fBools[TMT_FLATMENUS - TMT_FIRSTBOOL] = FALSE;

    //---- init sizes ----
    tm->iSizes[TMT_SIZINGBORDERWIDTH - TMT_FIRSTSIZE] = 1;
    tm->iSizes[TMT_SCROLLBARWIDTH - TMT_FIRSTSIZE] = 16;
    tm->iSizes[TMT_SCROLLBARHEIGHT - TMT_FIRSTSIZE] = 16;
    tm->iSizes[TMT_CAPTIONBARWIDTH - TMT_FIRSTSIZE] = 18;
    tm->iSizes[TMT_CAPTIONBARHEIGHT - TMT_FIRSTSIZE] = 19;
    tm->iSizes[TMT_SMCAPTIONBARWIDTH - TMT_FIRSTSIZE] = 12;
    tm->iSizes[TMT_SMCAPTIONBARHEIGHT - TMT_FIRSTSIZE] = 19;
    tm->iSizes[TMT_MENUBARWIDTH - TMT_FIRSTSIZE] = 18;
    tm->iSizes[TMT_MENUBARHEIGHT - TMT_FIRSTSIZE] = 19;

    //---- init strings ----
    tm->iStringOffsets[TMT_CSSNAME - TMT_FIRSTSTRING] = 0;
    tm->iStringOffsets[TMT_XMLNAME - TMT_FIRSTSTRING] = 0;

    tm->wsStrings[TMT_CSSNAME - TMT_FIRSTSTRING] = L"";
    tm->wsStrings[TMT_XMLNAME - TMT_FIRSTSTRING] = L"";
    
    //---- init ints ----
    tm->iInts[TMT_MINCOLORDEPTH - TMT_FIRSTINT] = 16;

    //---- init colors ----
    for (int i=0; i < TM_COLORCOUNT; i++)
        tm->crColors[i] = DefaultColors[i];

    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT PersistSystemColors(THEMEMETRICS *tm)
{
    HRESULT         hr;
    LONG            lErrorCode;
    HKEY            hkcu;
    CCurrentUser    hKeyCurrentUser(KEY_SET_VALUE);

    lErrorCode = RegOpenKeyEx(hKeyCurrentUser,
                              REGSTR_PATH_COLORS,
                              0,
                              KEY_SET_VALUE,
                              &hkcu);
    if (ERROR_SUCCESS == lErrorCode)
    {
        hr = S_OK;

        //---- believe it or not, we have to manually write each color ----
        //---- as a string to the registry to persist them ----

        ASSERT(iSysColorSize == TM_COLORCOUNT);       // should also match winuser.h entries

        //---- are gradients turned on? ----
        BOOL fGradientsEnabled = FALSE;  
        ClassicSystemParametersInfo(SPI_GETGRADIENTCAPTIONS, 0, (LPVOID)&fGradientsEnabled, 0);

        //---- enough colors for a gradient? ----
        HDC hdc = GetDC(NULL);
        if (hdc)
        {
            if (GetDeviceCaps(hdc, BITSPIXEL) <= 8)
                fGradientsEnabled = FALSE;
            ReleaseDC(NULL, hdc);
        }

        for (int i=0; i < iSysColorSize; i++)
        {
            // If this is the Gradient Caption setting and the system does
            // not currently show gradient captions then don't write them out
            // to the theme file.
            if ((i == COLOR_GRADIENTACTIVECAPTION) || (i == COLOR_GRADIENTINACTIVECAPTION))
            {
                if (! fGradientsEnabled)
                    continue;
            }

            //---- translate color into "r, g, b" value string ----
            WCHAR buff[100];
            COLORREF cr = tm->crColors[i];
            wsprintf(buff, L"%d %d %d", RED(cr), GREEN(cr), BLUE(cr));

            //---- write color key/value to registry ----
            lErrorCode = RegSetValueEx(hkcu,
                                       pszSysColorNames[i],
                                       0,
                                       REG_SZ,
                                       reinterpret_cast<BYTE*>(buff),
                                       (lstrlen(buff) + 1) * sizeof(WCHAR));
            if (ERROR_SUCCESS != lErrorCode)
            {
                if (SUCCEEDED(hr))
                {
                    hr = MakeError32(lErrorCode);
                }
            }
        }
        (LONG)RegCloseKey(hkcu);
    }
    else
    {
        hr = MakeError32(lErrorCode);
    }

    return hr;
}
//---------------------------------------------------------------------------
BOOL CThemeLoader::KeyDrawPropertyFound(int iStateDataOffset)
{
    BOOL fFound = FALSE;
    MIXEDPTRS u;
    UNPACKED_ENTRYHDR hdr;
    
    u.pb = _LoadingThemeFile._pbThemeData + iStateDataOffset;

    while (*u.ps != TMT_JUMPTOPARENT)
    {
        if (CBorderFill::KeyProperty((*u.ps)))
        {
            fFound = TRUE;
            break;
        }

        if (CImageFile::KeyProperty((*u.ps)))
        {
            fFound = TRUE;
            break;
        }

        //---- skip to next entry ----
        FillAndSkipHdr(u, &hdr);
        u.pb += hdr.dwDataLen;
    }

    return fFound;
}
//---------------------------------------------------------------------------
BOOL CThemeLoader::KeyTextPropertyFound(int iStateDataOffset)
{
    BOOL fFound = FALSE;
    MIXEDPTRS u;
    UNPACKED_ENTRYHDR hdr;

    u.pb = _LoadingThemeFile._pbThemeData + iStateDataOffset;

    while (*u.ps != TMT_JUMPTOPARENT)
    {
        if (CTextDraw::KeyProperty((*u.ps)))
        {
            fFound = TRUE;
            break;
        }

        //---- skip to next entry ----
        FillAndSkipHdr(u, &hdr);
        u.pb += hdr.dwDataLen;
    }

    return fFound;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::PackImageFileInfo(DIBINFO *pdi, CImageFile *pImageObj, MIXEDPTRS &u, 
    CRenderObj *pRender, int iPartId, int iStateId)
{
    HRESULT hr = S_OK;

    //---- write custom region data ----
    int iMaxState;
    if ((! iStateId) && (pImageObj->HasRegionImageFile(pdi, &iMaxState)))
    {
        //---- update object's _iRgnDataOffset field ----
        pImageObj->SetRgnListOffset(pdi, THEME_OFFSET(u.pb));

        //---- write the TMT_RGNLIST entry ----
        hr = EmitEntryHdr(u, TMT_RGNLIST, TMT_RGNLIST);
        if (FAILED(hr))
            goto exit;

        int cEntries = iMaxState + 1;         // number of jump table entries

        hr = AllocateThemeFileBytes(u.pb, 1 + cEntries * sizeof(int));
        if (FAILED(hr))
            goto exit;

        *u.pb++ = static_cast<BYTE>(cEntries);

        //---- write jump table now and update asap ----
        int *piJumpTable = u.pi;

        for (int i=0; i <= iMaxState; i++)
            *u.pi++ = 0;

        for (int iRgnState=0; iRgnState <= iMaxState; iRgnState++)
        {
            //---- build & pack custom region data for each state in this object's imagefile ----
            CAutoArrayPtr<RGNDATA> pRgnData;
            int iDataLen;

            hr = pImageObj->BuildRgnData(pdi, pRender, iRgnState, &pRgnData, &iDataLen);
            if (FAILED(hr))
                goto exit;

            if (iDataLen)       // if we got a non-empty region
            {
                piJumpTable[iRgnState] = THEME_OFFSET(u.pb);

                RGNDATAHDR rdHdr = {iPartId, iRgnState, 0};

                //---- copy rgndata hdr ----
                hr = EmitObject(u, TMT_RGNDATA, TMT_RGNDATA, &rdHdr, sizeof(rdHdr), pRgnData, iDataLen);
                if (FAILED(hr))
                    goto exit;
            }
        }

        EndEntry(u);
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::PackDrawObject(MIXEDPTRS &u, CRenderObj *pRender, int iPartId, 
    int iStateId)
{
    HRESULT hr = S_OK;

    BGTYPE eBgType;
    if (FAILED(pRender->GetEnumValue(iPartId, iStateId, TMT_BGTYPE, (int *)&eBgType)))
        eBgType = BT_BORDERFILL;      // default value

    DRAWOBJHDR hdr = {iPartId, iStateId};

    if ((eBgType == BT_BORDERFILL) || (eBgType == BT_NONE))
    {
        CBorderFill bfobj;

        hr = bfobj.PackProperties(pRender, (eBgType == BT_NONE), iPartId, iStateId);
        if (FAILED(hr))
            goto exit;

        //---- copy "bfobj" to packed bytes ----
                
        hr = EmitObject(u, TMT_DRAWOBJ, TMT_DRAWOBJ, &hdr, sizeof(hdr), &bfobj, sizeof(bfobj));
        if (FAILED(hr))
            goto exit;
    }
    else            // imagefile
    {
        CMaxImageFile maxif;
        int iMultiCount;

        hr = maxif.PackMaxProperties(pRender, iPartId, iStateId, &iMultiCount);
        if (FAILED(hr))
            goto exit;

        //---- process all DIBINFO structs in the CImageFile obj ----
        for (int i=0; ; i++)
        {
            DIBINFO *pdi = maxif.EnumImageFiles(i);
            if (! pdi)
                break;
    
            hr = PackImageFileInfo(pdi, &maxif, u, pRender, iPartId, iStateId);
            if (FAILED(hr))
                goto exit;
        }

        //---- copy imagefile obj & multi DIB's to packed bytes ----
        DWORD dwLen = sizeof(CImageFile) + sizeof(DIBINFO)*iMultiCount;

        hr = EmitObject(u, TMT_DRAWOBJ, TMT_DRAWOBJ, &hdr, sizeof(hdr), &maxif, dwLen);
        if (FAILED(hr))
            goto exit;
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::PackTextObject(MIXEDPTRS &u, CRenderObj *pRender, int iPartId, int iStateId)
{
    HRESULT hr;
    DRAWOBJHDR hdr = {iPartId, iStateId};
    CTextDraw ctobj;

    hr = ctobj.PackProperties(pRender, iPartId, iStateId);
    if (FAILED(hr))
        goto exit;

    hr = EmitObject(u, TMT_TEXTOBJ, TMT_TEXTOBJ, &hdr, sizeof(hdr), &ctobj, sizeof(ctobj));
    if (FAILED(hr))
        goto exit;

exit:
    return hr;
}
//---------------------------------------------------------------------------
int CThemeLoader::GetPartOffset(CRenderObj *pRender, int iPartNum)
{
    int iOffset;
    int iPartCount;
    MIXEDPTRS u;

    //---- see if state table exists for this part ----
    u.pb = pRender->_pbSectionData;

    if (*u.ps != TMT_PARTJUMPTABLE)
    {
        iOffset = -1;
        goto exit;
    }

    u.pb += ENTRYHDR_SIZE + sizeof(int);       // skip over hdr + PackedObjOffset
    iPartCount = *u.pb++;
    
    if (iPartNum >= iPartCount)    // iPartCount is MaxPart+1
    {
        iOffset = -1;
        goto exit;
    }

    iOffset = u.pi[iPartNum];

exit:
    return iOffset;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::PackDrawObjects(MIXEDPTRS &uOut, CRenderObj *pRender, 
    int iMaxPart, BOOL fGlobals)
{
    HRESULT hr = S_OK;
    MIXEDPTRS u;

    //---- build a draw obj for each part ----
    for (int iPart=0; iPart <= iMaxPart; iPart++)
    {
        int iPartOff = GetPartOffset(pRender, iPart);
        if (iPartOff == -1)
            continue;

        u.pb = _LoadingThemeFile._pbThemeData + iPartOff;

        if (*u.ps == TMT_STATEJUMPTABLE)
        {
            u.pb += ENTRYHDR_SIZE;
            int iMaxState = (*u.pb++) - 1;
            int *piStateJumpTable = u.pi;

            //---- build a draw obj for each needed state ----
            for (int iState=0; iState <= iMaxState; iState++)
            {
                int iStateDataOffset = piStateJumpTable[iState];
                if (iStateDataOffset == -1)
                    continue;

                if ((fGlobals) || (KeyDrawPropertyFound(iStateDataOffset)))
                {
                    hr = PackDrawObject(uOut, pRender, iPart, iState);
                    if (FAILED(hr))
                        goto exit;

                    if (fGlobals)       // just needed to force (part=0, state=0)
                        fGlobals = FALSE;
                }
            }
        }
        else            // no state jump table
        {
            if ((fGlobals) || (KeyDrawPropertyFound(THEME_OFFSET(u.pb))))
            {
                hr = PackDrawObject(uOut, pRender, iPart, 0);
                if (FAILED(hr))
                    goto exit;
            }
        }
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::PackTextObjects(MIXEDPTRS &uOut, CRenderObj *pRender, 
    int iMaxPart, BOOL fGlobals)
{
    HRESULT hr = S_OK;
    MIXEDPTRS u;

    //---- build a text obj for each part ----
    for (int iPart=0; iPart <= iMaxPart; iPart++)
    {
        int iPartOff = GetPartOffset(pRender, iPart);
        if (iPartOff == -1)
            continue;

        u.pb = _LoadingThemeFile._pbThemeData + iPartOff;

        if (*u.ps == TMT_STATEJUMPTABLE)
        {
            u.pb += ENTRYHDR_SIZE;
            int iMaxState = (*u.pb++) - 1;
            int *piStateJumpTable = u.pi;

            //---- build a text obj for each needed state ----
            for (int iState=0; iState <= iMaxState; iState++)
            {
                int iStateDataOffset = piStateJumpTable[iState];
                if (iStateDataOffset == -1)
                    continue;

                if ((fGlobals) || (KeyTextPropertyFound(iStateDataOffset)))
                {
                    hr = PackTextObject(uOut, pRender, iPart, iState);
                    if (FAILED(hr))
                        goto exit;

                    if (fGlobals)       // just needed to force (part=0, state=0)
                        fGlobals = FALSE;
                }
            }
        }
        else            // no state jump table
        {
            if ((fGlobals) || (KeyTextPropertyFound(THEME_OFFSET(u.pb))))
            {
                hr = PackTextObject(uOut, pRender, iPart, 0);
                if (FAILED(hr))
                    goto exit;
            }
        }
    }

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT CThemeLoader::EmitEntryHdr(MIXEDPTRS &u, SHORT propnum, BYTE privnum)
{
    HRESULT hr = S_OK;

    if (_iEntryHdrLevel == MAX_ENTRY_NESTING)
    {
        Log(LOG_ERROR, L"Maximum entry nesting exceeded");
        hr = E_FAIL;
        goto exit;
    }

    if (_LoadingThemeFile._pbThemeData != NULL)
    {
        hr = AllocateThemeFileBytes(u.pb, ENTRYHDR_SIZE);
        if (FAILED(hr))
            goto exit;
    }

    //---- bump up the nesting level of entries ----
    _iEntryHdrLevel++;

    *u.ps++ = propnum;
    *u.pb++ = privnum;

    _pbEntryHdrs[_iEntryHdrLevel] = u.pb;    // used to update next 2 fields in EndEntry()

    *u.pb++ = 0;        // filler to align end of data to 4/8 bytes
    *u.pi++ = 0;        // length 

exit:
    return hr;
}
//---------------------------------------------------------------------------
int CThemeLoader::EndEntry(MIXEDPTRS &u)
{
    MIXEDPTRS uHdr;
    uHdr.pb = _pbEntryHdrs[_iEntryHdrLevel];

    //---- calcuate actual length of date emitted ----
    int iActualLen = (int)(u.pb - (uHdr.pb + sizeof(BYTE) + sizeof(int)));

    //---- calculate filler to be aligned ----
    int iAlignLen = ((iActualLen + ALIGN_FACTOR - 1)/ALIGN_FACTOR) * ALIGN_FACTOR;
    BYTE bFiller = (BYTE)(iAlignLen - iActualLen);

    if (_LoadingThemeFile._pbThemeData != NULL)
    {
        HRESULT hr = AllocateThemeFileBytes(u.pb, bFiller);
        if (FAILED(hr))
            return -1;
    }

    //---- emit filler bytes to be correctly aligned ----
    for (int i=0; i < bFiller; i++)
        *u.pb++ = 0 ;

    //---- update the entry Hdr ----
    *uHdr.pb++ = bFiller;
    *uHdr.pi++ = iAlignLen;

    //---- decrement the nesting level of entries ----
    _iEntryHdrLevel--;

    return bFiller;
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\info.cpp ===
//---------------------------------------------------------------------------
//  Info.cpp - implements the information services of the CRenderObj object
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "Render.h"
#include "Utils.h"
#include "Loader.h"
#include "sethook.h"
#include "info.h"
#include "RenderList.h"
#include "Services.h"
#include "appinfo.h"
#include "tmutils.h"
#include "borderfill.h"
#include "imagefile.h"
#include "textdraw.h"
//---------------------------------------------------------------------------
HRESULT MatchThemeClass(LPCTSTR pszAppName, LPCTSTR pszClassId, 
    CUxThemeFile *pThemeFile, int *piOffset, int *piClassNameOffset)
{
    THEMEHDR *pHdr = (THEMEHDR *)pThemeFile->_pbThemeData; 
    MIXEDPTRS u;
    u.pb = pThemeFile->_pbThemeData + pHdr->iSectionIndexOffset;

    DWORD dwCount = pHdr->iSectionIndexLength/sizeof(APPCLASSLIVE);
    APPCLASSLIVE *acl = (APPCLASSLIVE *)u.pb;

    for (DWORD i=0; i < dwCount; i++, acl++)
    {
        if (acl->dwAppNameIndex) 
        {
            if ((! pszAppName) || (! *pszAppName))
                continue;       // not a match

            LPCWSTR pszApp = ThemeString(pThemeFile, acl->dwAppNameIndex);

            if (AsciiStrCmpI(pszAppName, pszApp) != 0)
                continue;       // not a match
        }

        if (acl->dwClassNameIndex)
        {
            LPCWSTR pszClass = ThemeString(pThemeFile, acl->dwClassNameIndex);

            if (AsciiStrCmpI(pszClassId, pszClass)==0)        // matches
            {
                *piOffset = acl->iIndex;
                *piClassNameOffset = acl->dwClassNameIndex;
                return S_OK;
            }
        }
    }

    return MakeError32(ERROR_NOT_FOUND);      // not found
}
//---------------------------------------------------------------------------
HRESULT MatchThemeClassList(HWND hwnd, LPCTSTR pszClassIdList, 
    CUxThemeFile *pThemeFile, int *piOffset, int *piClassNameOffset)
{
    LPCTSTR pszAppName = NULL;
    WCHAR *pszIdListBuff = NULL;
    WCHAR szAppSubName[MAX_PATH];
    WCHAR szIdSubName[MAX_PATH];
    int len;
    Log(LOG_TM, L"MatchThemeClassList(): classlist=%s", pszClassIdList);
    HRESULT hr = S_OK;

    if (! pszClassIdList)
        return MakeError32(E_INVALIDARG);

    //---- first check Hwnd IdList substitutions ----
    if (hwnd)
    {
        ATOM atomIdSub = (ATOM)GetProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_SUBIDLIST)));

        if (atomIdSub)
        {
            if (GetAtomName(atomIdSub, szIdSubName, ARRAYSIZE(szIdSubName)))
            {
                pszClassIdList = szIdSubName;
                Log(LOG_TM, L"MatchThemeClassList: hwnd prop IdList OVERRIDE: %s", pszClassIdList);
            }
        }
    }

    //---- now check Hwnd AppName substitutions ----
    if (hwnd)
    {
        ATOM atomAppSub = (ATOM)GetProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_SUBAPPNAME)));

        if (atomAppSub)
        {
            if (GetAtomName(atomAppSub, szAppSubName, ARRAYSIZE(szAppSubName)))
            {
                pszAppName = szAppSubName;
                Log(LOG_TM, L"MatchThemeClassList: hwnd prop AppName OVERRIDE: %s", pszAppName);
            }
        }
    }

    //---- make a copy of pszClassIdList ----
    len = lstrlen(pszClassIdList);
    pszIdListBuff = new WCHAR[len+1];
    if (! pszIdListBuff)
    {
        hr = MakeError32(E_OUTOFMEMORY);
        goto exit;
    }

    lstrcpy(pszIdListBuff, pszClassIdList);

    LPTSTR classId;
    BOOL fContinue;

    classId = pszIdListBuff;
    fContinue = TRUE;

    //---- check each ClassId in the list ----
    while (fContinue)
    {
        fContinue = lstrtoken(classId, _TEXT(';'));
        hr = MatchThemeClass(pszAppName, classId, pThemeFile, piOffset, piClassNameOffset);
        if (SUCCEEDED(hr))
            break;

        classId += lstrlen(classId)+1;
    }

exit:
    if (pszIdListBuff)
        delete [] pszIdListBuff;

    return hr;
}
//---------------------------------------------------------------------------
HTHEME _OpenThemeDataFromFile(HTHEMEFILE hLoadedThemeFile, HWND hwnd, 
    LPCWSTR pszClassIdList, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    RESOURCE CUxThemeFile *pThemeFile = (CUxThemeFile *)hLoadedThemeFile;
    int iOffset;
    int iClassNameOffset;
    HTHEME hTheme = NULL;

    //---- match classid list to theme and get the offset ----
    hr = MatchThemeClassList(hwnd, pszClassIdList, pThemeFile, &iOffset,
        &iClassNameOffset);
    if (FAILED(hr))
    {
        Log(LOG_TMOPEN, L"hLoadedThemeFile: No match for class=%s", pszClassIdList);
        goto exit;
    }
    
    hr = g_pRenderList->OpenRenderObject(pThemeFile, iOffset, iClassNameOffset, NULL,
        NULL, hwnd, dwFlags, &hTheme);
    if (FAILED(hr))
        goto exit;

    //---- store hTheme with window ----
    if (! (dwFlags & OTD_NONCLIENT))
    {
        //---- store the hTheme so we know its themed ----
        if (hwnd)
            SetProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_HTHEME)), (void *)hTheme);
    }

    Log(LOG_TMOPEN, L"hLoadedThemeFile: returning hTheme=0x%x", hTheme);

exit:
    SET_LAST_ERROR(hr);
    return hTheme;
}
//---------------------------------------------------------------------------
HTHEME _OpenThemeData(HWND hwnd, LPCWSTR pszClassIdList, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    RESOURCE CUxThemeFile *pThemeFile = NULL;
    HTHEME hTheme = NULL;
    BOOL fOk;
    DWORD dwAppFlags;

    SET_LAST_ERROR(hr);

    if (! g_fUxthemeInitialized)
        goto exit;

    Log(LOG_TMOPEN, L"_OpenThemeData: hwnd=0x%x, ClassIdList=%s", hwnd, pszClassIdList);

    //---- remove previous HTHEME property ----
    if (hwnd)
        RemoveProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_HTHEME)));

    if (! g_pAppInfo->AppIsThemed())     // this process has been excluded from theming
    {
        Log(LOG_TMOPEN, L"App not themed");
        hr = MakeError32(ERROR_NOT_FOUND);
        SET_LAST_ERROR(hr);
        goto exit;
    }

    //---- ensure app allows this type of themeing ----
    dwAppFlags = g_pAppInfo->GetAppFlags();

    if (dwFlags & OTD_NONCLIENT)
    {
        fOk = ((dwAppFlags & STAP_ALLOW_NONCLIENT) != 0);    
    }
    else
    {
        fOk = ((dwAppFlags & STAP_ALLOW_CONTROLS) != 0);
    }

    if (! fOk)
    {
        Log(LOG_TMOPEN, L"AppFlags don't allow theming client/nonclient windows");
        hr = MakeError32(ERROR_NOT_FOUND);
        SET_LAST_ERROR(hr);
        goto exit;
    }

    //---- find Theme File for this HWND and REFCOUNT it for _OpenThemeDataFromFile call ----
    hr = GetHwndThemeFile(hwnd, pszClassIdList, &pThemeFile);
    if (FAILED(hr))
    {
        Log(LOG_TMOPEN, L"no theme entry for this classidlist: %s", pszClassIdList);
        SET_LAST_ERROR(hr);
        goto exit;
    }

    hTheme = _OpenThemeDataFromFile(pThemeFile, hwnd, pszClassIdList, dwFlags);
    
exit:
    //---- always close the pThemeFile here and decrement its refcnt ----
    //---- case 1: if we failed to get an HTHEME, we don't want a refcnt on it ----
    //---- case 2: if we do get an HTHEME, it get's its own refcnt on it ----
    if (pThemeFile)
        g_pAppInfo->CloseThemeFile(pThemeFile);

    return hTheme;
}
//---------------------------------------------------------------------------
HRESULT GetHwndThemeFile(HWND hwnd, LPCWSTR pszClassIdList, CUxThemeFile **ppThemeFile)
{
    HRESULT hr = S_OK;

    //----- check input params ----
    if ((! pszClassIdList) || (! *pszClassIdList))
    {
        hr = MakeError32(E_INVALIDARG);
        goto exit;
    }

    //---- get a shared CUxThemeFile object for the hwnd ----
    hr = g_pAppInfo->OpenWindowThemeFile(hwnd, ppThemeFile);
    if (FAILED(hr))
        goto exit;

exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT _OpenThemeFileFromData(CRenderObj *pRender, HTHEMEFILE *phThemeFile)
{
    LogEntry(L"OpenThemeFileFromData");

    HRESULT hr = S_OK;

    *phThemeFile = pRender->_pThemeFile;

    LogExit(L"OpenThemeFileFromData");
    return hr;
}
//---------------------------------------------------------------------------
void ClearExStyleBits(HWND hwnd)
{
    Log(LOG_COMPOSITE, L"ClearExStyleBits called for hwnd=0x%x", hwnd);
    
    //---- see if window needs its exstyle cleared ----
    DWORD dwFlags = PtrToInt(GetProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_PROPFLAGS))));

    if (dwFlags & (PROPFLAGS_RESET_TRANSPARENT | PROPFLAGS_RESET_COMPOSITED))
    {
        DWORD dwExStyle = GetWindowLong(hwnd, GWL_EXSTYLE);

        if (dwFlags & PROPFLAGS_RESET_TRANSPARENT)
        {
            Log(LOG_COMPOSITE, L"Clearning WS_EX_TRANSPARENT for hwnd=0x%x", hwnd);
            dwExStyle &= ~(WS_EX_TRANSPARENT);
        }

        if (dwFlags & PROPFLAGS_RESET_COMPOSITED)
        {
            Log(LOG_COMPOSITE, L"Clearning WS_EX_COMPOSITED for hwnd=0x%x", hwnd);
            dwExStyle &= ~(WS_EX_COMPOSITED);
        }

        //---- reset the correct ExStyle bits ----
        SetWindowLong(hwnd, GWL_EXSTYLE, dwExStyle);

        //---- reset the property flags ----
        dwFlags &= ~(PROPFLAGS_RESET_TRANSPARENT | PROPFLAGS_RESET_COMPOSITED);
        SetProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_PROPFLAGS)), IntToPtr(dwFlags));
    }
}
//---------------------------------------------------------------------------
void AddPropFlags(HWND hwnd, DWORD dwNewFlags)
{
    DWORD dwFlags = PtrToInt(GetProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_PROPFLAGS))));

    dwFlags |= dwNewFlags;

    if (dwNewFlags & PROPFLAGS_RESET_TRANSPARENT)
        Log(LOG_COMPOSITE, L"Setting TRANSPARENT prop flag for hwnd=0x%x", hwnd);

    if (dwNewFlags & PROPFLAGS_RESET_COMPOSITED)
        Log(LOG_COMPOSITE, L"Setting COMPOSITED prop flag for hwnd=0x%x", hwnd);

    SetProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_PROPFLAGS)), IntToPtr(dwFlags));
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
struct EPW
{
    WNDENUMPROC lpCallBackCaller;
    LPARAM lParamCaller;
    
    HWND *pHwnds;           // OPTIONAL list of hwnds to remove as they are enum-ed
    int iCountHwnds;        // count of remaining HWND's in pHwnds
};
//---------------------------------------------------------------------------
BOOL CALLBACK ChildWinCallBack(HWND hwnd, LPARAM lParam)
{
    BOOL fResult = TRUE;

    if (IsWindowProcess(hwnd, g_dwProcessId))
    {
        EPW *pEpw = (EPW *)lParam;
        
        fResult = pEpw->lpCallBackCaller(hwnd, pEpw->lParamCaller);

        //---- remove from list ----
        if (pEpw->pHwnds) 
        {
            for (int i=0; i < pEpw->iCountHwnds; i++)
            {
                if (pEpw->pHwnds[i] == hwnd)     // found it
                {
                    pEpw->iCountHwnds--;     

                    if (i != pEpw->iCountHwnds)       // switch last with current
                        pEpw->pHwnds[i] = pEpw->pHwnds[pEpw->iCountHwnds];

                    break;
                }
            }
        }
    }

    return fResult;
}
//---------------------------------------------------------------------------
BOOL CALLBACK TopWinCallBack(HWND hwnd, LPARAM lParam)
{
    BOOL fResult = ChildWinCallBack(hwnd, lParam);
    if (fResult)
    {
        //---- we need to check for hwnd having at least one child ----
        //---- since EnumChildWindows() of a hwnd without children ----
        //---- returns an error ----

        if (GetWindow(hwnd, GW_CHILD))      // if hwnd has at least one child
        {
            fResult = EnumChildWindows(hwnd, ChildWinCallBack, lParam);
        }
    }

    return fResult;
}
//---------------------------------------------------------------------------
BOOL CALLBACK DesktopWinCallBack(LPTSTR lpszDesktop, LPARAM lParam)
{
    //---- open the desktop ----
    HDESK hDesk = OpenDesktop(lpszDesktop, DF_ALLOWOTHERACCOUNTHOOK, FALSE, 
        DESKTOP_READOBJECTS | DESKTOP_ENUMERATE);

    if (hDesk)
    {
        //---- enum windows on desktop ----
        EnumDesktopWindows(hDesk, TopWinCallBack, lParam);

        CloseDesktop(hDesk);
    }

    return TRUE;        // return values from EnumDesktopWindows() not reliable
}
//---------------------------------------------------------------------------
BOOL EnumProcessWindows(WNDENUMPROC lpEnumFunc, LPARAM lParam)
{
    HWND *pHwnds = NULL;
    int iCount = 0;
    EPW epw = {lpEnumFunc, lParam};

    //---- get list of themed windows on "foreign" desktops for this process ----
    BOOL fGotForeignList = g_pAppInfo->GetForeignWindows(&pHwnds, &iCount);
    if (fGotForeignList)
    {
        epw.pHwnds = pHwnds;
        epw.iCountHwnds = iCount;
    }

    //---- this will enum all windows for this process (all desktops, all child levels) ----
    BOOL fOk = EnumDesktops(GetProcessWindowStation(), DesktopWinCallBack, (LPARAM)&epw);
    if ((fOk) && (fGotForeignList) && (epw.iCountHwnds))
    {
        //---- get updated count ----
        iCount = epw.iCountHwnds;

        //---- turn off list maintainance ----
        epw.pHwnds = NULL;
        epw.iCountHwnds = 0;

        Log(LOG_TMHANDLE, L"---- Enuming %d Foreign Windows ----", iCount);

        //---- enumerate remaining hwnd's in list ----
        for (int i=0; i < iCount; i++)
        {
            fOk = ChildWinCallBack(pHwnds[i], (LPARAM)&epw);

            if (! fOk)
                break;
        }
    }

    if (pHwnds)
        delete [] pHwnds;

    return fOk;
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
BOOL CALLBACK DumpCallback(HWND hwnd, LPARAM lParam)
{
    WCHAR szName[MAX_PATH];
    WCHAR szDeskName[MAX_PATH] = {0};
    BOOL fIsForeign = TRUE;

    //---- get classname of window ----
    GetClassName(hwnd, szName, MAX_PATH);

    //---- get desktop name for window ----
    if (GetWindowDesktopName(hwnd, szDeskName, ARRAYSIZE(szDeskName)))
    {
        if (AsciiStrCmpI(szDeskName, L"default")==0)
        {
            fIsForeign = FALSE;
        }
    }

    if (fIsForeign)
    {
        Log(LOG_WINDUMP, L"    hwnd=0x%x, class=%s, DESK=%s", hwnd, szName, szDeskName); 
    }
    else
    {
        Log(LOG_WINDUMP, L"    hwnd=0x%x, class=%s", hwnd, szName); 
    }

    return TRUE;
}
//---------------------------------------------------------------------------
void WindowDump(LPCWSTR pszWhere)
{
    if (LogOptionOn(LO_WINDUMP))
    {
        Log(LOG_WINDUMP, L"---- Window Dump for Process [%s] ----", pszWhere);

        EnumProcessWindows(DumpCallback, NULL);
    }
    else
    {
        Log(LOG_TMHANDLE, L"---- %s ----", pszWhere);
    }
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\messagebroadcast.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: MessageBroadcast.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to manager sending or posting messages to windows to tell them that
//  things have changed.
//
//  History:    2000-11-11  vtan        created (split from services.cpp)
//  --------------------------------------------------------------------------

#include "stdafx.h"

#include "MessageBroadcast.h"

#include "Services.h"
#include "ThemeSection.h"
#include "Loader.h"

#define TBOOL(x)    ((BOOL)(x))
#define TW32(x)     ((DWORD)(x))
#define THR(x)      ((HRESULT)(x))
#define goto        !!DO NOT USE GOTO!! - DO NOT REMOVE THIS ON PAIN OF DEATH

//  --------------------------------------------------------------------------
//  CMessageBroadcast::CMessageBroadcast
//
//  Arguments:  fAllDesktops - if TRUE, all accessible desktops will be enum-ed
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CMessageBroadcast
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

CMessageBroadcast::CMessageBroadcast (BOOL fAllDesktops) :
    _hwnd(NULL),
    _dwProcessID(0),
    _fExclude(FALSE)

{
    ZeroMemory(&_msg, sizeof(_msg));

    _eMsgType = MT_SIMPLE;  // default (set in each request function)        

    _fAllDesktops = fAllDesktops;
}

//  --------------------------------------------------------------------------
//  CMessageBroadcast::~CMessageBroadcast
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CMessageBroadcast
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

CMessageBroadcast::~CMessageBroadcast (void)

{
}

//  --------------------------------------------------------------------------
//  CMessageBroadcast::EnumRequestedWindows
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Enumerate all windows in all desktops or just on current desktop
//
//  History:    2000-12-20  rfernand        created
//  --------------------------------------------------------------------------
void    CMessageBroadcast::EnumRequestedWindows (void)
{
    if (_fAllDesktops)
    {
        //---- enumerate all desktops in current session/station ----
        TBOOL(EnumDesktops(GetProcessWindowStation(), DesktopCallBack, reinterpret_cast<LPARAM>(this)));
    }
    else
    {
        //---- enumerate all windows in current desktop ----
        TopWindowCallBack(GetDesktopWindow(), reinterpret_cast<LPARAM>(this));
    }
}

//  --------------------------------------------------------------------------
void    CMessageBroadcast::PostSimpleMsg(UINT msg, WPARAM wParam, LPARAM lParam)
{
    _eMsgType = MT_SIMPLE;

    _msg.message = msg;
    _msg.wParam = wParam;
    _msg.lParam = lParam;

    EnumRequestedWindows();
}
//  --------------------------------------------------------------------------
void    CMessageBroadcast::PostAllThreadsMsg(UINT msg, WPARAM wParam, LPARAM lParam)
{
    //---- post the msg to a window on each unique processid/threadid ----

    _ThreadsProcessed.RemoveAll();      // will track unique processid/threadid we have posted to
    
    _eMsgType = MT_ALLTHREADS;

    _msg.message = msg;
    _msg.wParam = wParam;
    _msg.lParam = lParam;

    EnumRequestedWindows();
}

//  --------------------------------------------------------------------------
//  CMessageBroadcast::PostFilteredMsg
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Builds a message and stores conditions for the enumerator to
//              make a decision on whether a message needs to be posted. Then
//              enumerate all the windows (and children).
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

void    CMessageBroadcast::PostFilteredMsg(UINT msg, WPARAM wParam, LPARAM lParam, 
     HWND hwndTarget, BOOL fProcess, BOOL fExclude)
{
    _eMsgType = MT_FILTERED;

    //---- set up the message ----
    _msg.message = msg;

    _msg.wParam = wParam;
    _msg.lParam = lParam;
    
    _hwnd = hwndTarget;

    if (fProcess)
    {
        _dwProcessID = GetCurrentProcessId();
    }
    else
    {
        _dwProcessID = 0;
    }

    _fExclude = (fExclude != NULL);

    //---- enumerate all desktops in current session/station ----
    EnumRequestedWindows();
}

//  --------------------------------------------------------------------------
//  CMessageBroadcast::DesktopCallBack
//
//  Arguments:  See the platform SDK under EnumDesktops.
//
//  Returns:    BOOL
//
//  Purpose:    enum all windows for specified desktop
//
//  History:    2000-12-13  rfernand        created
//  --------------------------------------------------------------------------

BOOL    CALLBACK    CMessageBroadcast::DesktopCallBack(LPTSTR lpszDesktop, LPARAM lParam)
{
    HDESK hDesk = OpenDesktop(lpszDesktop, 0, FALSE, DESKTOP_READOBJECTS | DESKTOP_ENUMERATE);
    if (hDesk)
    {
        Log(LOG_TMCHANGEMSG, L"CMessageBroadcast: Desktop Opened: %s", lpszDesktop);

        //---- enum windows on desktop ----
        TBOOL(EnumDesktopWindows(hDesk, TopWindowCallBack, lParam));

        CloseDesktop(hDesk);
    }

    return TRUE;            // EnumDesktopWindows() returns unreliable errors
}

//  --------------------------------------------------------------------------
//  CMessageBroadcast::TopWindowCallBack
//
//  Arguments:  hwnd, lParam
//
//  Returns:    TRUE (keep enumerating)
//
//  Purpose:    call "Worker" for hwnd and all of its (nested) children
//
//  History:    2000-12-13  rfernand        created
//  --------------------------------------------------------------------------

BOOL CALLBACK    CMessageBroadcast::TopWindowCallBack (HWND hwnd, LPARAM lParam)

{
    //---- process top level window ----
    reinterpret_cast<CMessageBroadcast*>(lParam)->Worker(hwnd);

    //---- process all children windows ----
    TBOOL(EnumChildWindows(hwnd, ChildWindowCallBack, lParam));

    return TRUE;
}

//  --------------------------------------------------------------------------
//  CMessageBroadcast::ChildWindowCallBack
//
//  Arguments:  hwnd, lParam
//
//  Returns:    TRUE (keep enumerating)
//
//  Purpose:    call "Worker" for hwnd 
//
//  History:    2000-12-13  rfernand        created
//  --------------------------------------------------------------------------

BOOL CALLBACK    CMessageBroadcast::ChildWindowCallBack (HWND hwnd, LPARAM lParam)

{
    //---- process top level window ----
    reinterpret_cast<CMessageBroadcast*>(lParam)->Worker(hwnd);

    return TRUE;
}

//  --------------------------------------------------------------------------
//  CMessageBroadcast::Worker
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Performs validation on whether the HWND should get the built
//              message.
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

void CMessageBroadcast::Worker (HWND hwnd)

{
    if (_eMsgType == MT_SIMPLE)     
    {
        TBOOL(PostMessage(hwnd, _msg.message, _msg.wParam, _msg.lParam));
    }
    else if (_eMsgType == MT_ALLTHREADS)     
    {
        DWORD dwThreadId = GetWindowThreadProcessId(hwnd, NULL);
        BOOL fSendIt = TRUE;

        //---- is this a new thread? ----
        for (int i=0; i < _ThreadsProcessed.m_nSize; i++)
        {
            if (_ThreadsProcessed[i] == dwThreadId)
            {
                fSendIt = FALSE;
                break;
            }
        }

        if (fSendIt)
        {
            TBOOL(PostMessage(hwnd, _msg.message, _msg.wParam, _msg.lParam));

            _ThreadsProcessed.Add(dwThreadId);
        }
    }
    else            // MT_FILTERED
    {
        bool    fMatch;

        fMatch = true;

        if (_dwProcessID != 0)
        {
            fMatch = (IsWindowProcess(hwnd, _dwProcessID) != FALSE);
            if (_fExclude)
            {
                fMatch = !fMatch;
            }
        }

        if (fMatch)
        {
            if (_hwnd != NULL)   
            {
                fMatch = ((_hwnd == hwnd) || IsChild(_hwnd, hwnd));
                if (_fExclude)
                {
                    fMatch = !fMatch;
                }
            }

            if (fMatch)
            {
                TBOOL(PostMessage(hwnd, _msg.message, _msg.wParam, _msg.lParam));

                //Log(LOG_TMCHANGE, L"Worker: just POSTED msg=0x%x to hwnd=0x%x",
                //    _msg.message, hwnd);
            }
        }
    }
}

//  --------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\nctheme.h ===
//-------------------------------------------------------------------------//
//  NCTheme.h
//-------------------------------------------------------------------------//
#ifndef __NC_THEME_H__
#define __NC_THEME_H__

#include "handlers.h"

//---------------------------------------------------------------------------//
//  Enable/disable rude message dumping
//
//---------------------------------------------------------------------------//
//#define _ENABLE_MSG_SPEW_

//---------------------------------------------------------------------------//
//  Enable/disable rude scrollinfo dumping
//
//#define _ENABLE_SCROLL_SPEW_

//---------------------------------------------------------------------------//
//  Debug CThemeWnd, critsec double deletion
#define DEBUG_THEMEWND_DESTRUCTOR

//---------------------------------------------------------------------------
//  Target window theme class flags
#define TWCF_DIALOG             0x00000001
#define TWCF_FRAME              0x00000002
#define TWCF_TOOLFRAME          0x00000004  
#define TWCF_SCROLLBARS         0x00000010
#define TWCF_CLIENTEDGE         0x00010000  // not targetted per se

#define TWCF_NCTHEMETARGETMASK  0x0000FFFF
#define TWCF_ALL    (TWCF_DIALOG|TWCF_FRAME|TWCF_TOOLFRAME|\
                     TWCF_SCROLLBARS|TWCF_CLIENTEDGE)
#define TWCF_ANY    TWCF_ALL

//---------------------------------------------------------------------------
//  per-window NC rectangle identifiers.
typedef enum _eNCWNDMETRECT
{
    #define NCRC_FIRST  NCRC_WINDOW
    NCRC_WINDOW  = 0,    //  window rect
    NCRC_CLIENT  = 1,    //  client rect
    NCRC_UXCLIENT = 2,   //  client rect, computed based on theme layout.
    NCRC_CONTENT = 3,    //  frame content area (client area + scrollbars + clientedge)
    NCRC_MENUBAR = 4,    //  menubar rect

    //  the following members should be in same sequence as eFRAMEPARTS
    NCRC_CAPTION = 5,    //  window frame caption segment
    NCRC_FRAMELEFT = 6,  //  window frame left segment
    NCRC_FRAMERIGHT = 7, //  window frame right segment
    NCRC_FRAMEBOTTOM = 8,//  window frame bottom segment
    #define NCRC_FRAMEFIRST NCRC_CAPTION
    #define NCRC_FRAMELAST  NCRC_FRAMEBOTTOM

    NCRC_CAPTIONTEXT = 9,//  caption text rect
    NCRC_CLIENTEDGE = 10,//  client edge inner rect
    NCRC_HSCROLL = 11,   //  horizontal scrollbar
    NCRC_VSCROLL = 12,   //  vertical scrollbar
    NCRC_SIZEBOX = 13,   //  gripper box
    NCRC_SYSBTN = 14,    //  system button/icon

    //  Standard frame button
    //  (followed by identically ordered MDI frame buttons!!)
    #define NCBTNFIRST    NCRC_CLOSEBTN
    NCRC_CLOSEBTN = 15,  //  close btn
    NCRC_MINBTN = 16,    //  minimize/restore button
    NCRC_MAXBTN = 17,    //  maximize/restore button
    NCRC_HELPBTN = 18,   //  help button
    #define NCBTNLAST     NCRC_HELPBTN
    #define NCBTNRECTS    ((NCBTNLAST - NCBTNFIRST)+1)

    //  MDI frame buttons for maximized MDI child 
    //  (preceeded by identically ordered standard frame buttons!!)
    #define NCMDIBTNFIRST NCRC_MDICLOSEBTN
    NCRC_MDICLOSEBTN = 19,//  MDI child close btn
    NCRC_MDIMINBTN = 20,  //  MDI child minimize/restore button
    NCRC_MDIMAXBTN = 21,  //  MDI child maximize/restore button
    NCRC_MDISYSBTN = 22,  //  MDI child system button/icon
    NCRC_MDIHELPBTN = 23, //  MDI child help button
    #define NCMDIBTNLAST  NCRC_MDIHELPBTN
    #define NCMDIBTNRECTS ((NCMDIBTNLAST- NCMDIBTNFIRST)+1)

#ifdef LAME_BUTTON
    NCRC_LAMEBTN,   //  "Comments..." (formerly "Lame...") link.
#endif LAME_BUTTON,
    
    NCRC_COUNT,     //  count of rectangles

} eNCWNDMETRECT;

//---------------------------------------------------------------------------
//  NCWNDMET::rgframeparts array indices
typedef enum _eFRAMEPARTS
{
    iCAPTION,
    iFRAMELEFT,
    iFRAMERIGHT,
    iFRAMEBOTTOM,

    cFRAMEPARTS,
} eFRAMEPARTS;

//---------------------------------------------------------------------------
//  nonclient window metrics
typedef struct _NCWNDMET
{
    //----------------------//
    //  per-window metrics
    BOOL                fValid;            //  
    BOOL                fFrame;            //  WS_CAPTION style?
    BOOL                fSmallFrame;       //  toolframe style?
    BOOL                fMin;              //  minimized.
    BOOL                fMaxed;            //  maximized
    BOOL                fFullMaxed;        //  full-screen maximized or maximized child window.
    ULONG               dwStyle;           //  WINDOWINFO::dwStyle
    ULONG               dwExStyle;         //  WINDOWINFO::dwExStyle
    ULONG               dwWindowStatus;    //  WINDOWINFO::dwWindowStatus
    ULONG               dwStyleClass;      //  style class.
    WINDOWPARTS         rgframeparts[cFRAMEPARTS];   //  rendered frame parts
    WINDOWPARTS         rgsizehitparts[cFRAMEPARTS]; //  frame resizing border hit test template parts.
    FRAMESTATES         framestate;        //  current frame & caption state
    HFONT               hfCaption;         //  Font handle for dynamically resizing caption.  This handle
                                           //  is not owned by NCWNDMET, and should not be destroyed with it.
    COLORREF            rgbCaption;        //  color of caption text.
    SIZE                sizeCaptionText;   //  size of caption text
    MARGINS             CaptionMargins;    //  Margins for in-frame caption
    int                 iMinButtonPart;    //  restore / minimize as appropriate
    int                 iMaxButtonPart;    //  restore / maximize as appropriate
    CLOSEBUTTONSTATES   rawCloseBtnState;  //  zero-relative close button state.  Final state must be computed using the MAKE_BTNSTATE macro.
    CLOSEBUTTONSTATES   rawMinBtnState;    //  zero-relative min btnstate.  Final state must be computed using the MAKE_BTNSTATE macro.  
    CLOSEBUTTONSTATES   rawMaxBtnState;    //  zero-relative max btnstate.  Final state must be computed using the MAKE_BTNSTATE macro.
    int                 cyMenu;            //  return value of CalcMenuBar or Gsm(SM_CYMENUSIZE)
    int                 cnMenuOffsetLeft;  //  left menubar margin from window edge
    int                 cnMenuOffsetRight; //  right menubar margin from window edge
    int                 cnMenuOffsetTop;   //  top menubar margin from window edge
    int                 cnBorders;         //  window border width, according to USER
    RECT                rcS0[NCRC_COUNT];  //  nonclient area component rects, screen relative coords
    RECT                rcW0[NCRC_COUNT];  //  nonclient area component rects, window relative coords
    
} NCWNDMET, *PNCWNDMET;

//---------------------------------------------------------------------------
//  nonclient part transparency bitfield
typedef struct
{
    BOOL fCaption : 1;
    BOOL fSmallCaption: 1;
    BOOL fMinCaption : 1;
    BOOL fSmallMinCaption : 1;
    BOOL fMaxCaption : 1;
    BOOL fSmallMaxCaption : 1;
    BOOL fFrameLeft : 1;
    BOOL fFrameRight : 1;
    BOOL fFrameBottom : 1;
    BOOL fSmFrameLeft : 1;
    BOOL fSmFrameRight : 1;
    BOOL fSmFrameBottom : 1;
    BOOL fReserved0 : 1;
    BOOL fReserved1 : 1;
    BOOL fReserved2 : 1;
    BOOL fReserved3 : 1;
} NCTRANSPARENCY, *PNCTRANSPARENCY;
//---------------------------------------------------------------------------
//  nonclient theme metrics
typedef struct _NCTHEMEMET
{
    HTHEME  hTheme;                // theme handle
    HTHEME  hThemeTab;             // tab's theme handle for "prop sheet" dialogs
    SIZE    sizeMinimized;         // size of minimized window
    BOOL    fCapSizingTemplate:1;     // has a caption sizing template
    BOOL    fLeftSizingTemplate:1;    // has a left frame sizing template
    BOOL    fRightSizingTemplate:1;   // has a frame right sizing template
    BOOL    fBottomSizingTemplate:1;  // has a frame bottom sizing template
    BOOL    fSmCapSizingTemplate:1;   // has a small caption sizing template
    BOOL    fSmLeftSizingTemplate:1;  // has a small left frame sizing template
    BOOL    fSmRightSizingTemplate:1; // has a small frame right sizing template
    BOOL    fSmBottomSizingTemplate:1;// has a small frame bottom sizing template
    MARGINS marCaptionText;        // margin member values of {0,0,0,0} are interpreted as default
    MARGINS marMinCaptionText;     // margin member values of {0,0,0,0} are interpreted as default
    MARGINS marMaxCaptionText;     // margin member values of {0,0,0,0} are interpreted as default
    MARGINS marSmCaptionText;      // margin member values of {0,0,0,0} are interpreted as default
    int     dyMenuBar;             // difference between SM_CYMENU and SM_CYMENUSIZE.
    int     cyMaxCaption;          // height of maximized window caption (for top/button caption only)
    int     cnSmallMaximizedWidth; // width of maximized window caption (for left/right caption only)
    int     cnSmallMaximizedHeight;// height of maximized window caption (for top/button caption only)
    SIZE    sizeBtn;               // size of normal nonclient button
    SIZE    sizeSmBtn;             // size of toolframe nonclient button
    HBRUSH  hbrTabDialog;             // brush for special tab dialogs
    HBITMAP hbmTabDialog;          // must save the bitmap to keep the brush valid
    NCTRANSPARENCY nct;            // cached transparency checks.

    struct {
        BOOL fValid;
        int  cxBtn;
        int  cxSmBtn;
    } theme_sysmets;

} NCTHEMEMET, *PNCTHEMEMET;

//---------------------------------------------------------------------------
typedef struct _NCEVALUATE
{
    //  IN params:
    BOOL    fIgnoreWndRgn;

    //  CThemeWnd::_Evaluate OUT params:
    ULONG   fClassFlags;
    ULONG   dwStyle;
    ULONG   dwExStyle;
    BOOL    fExile;
    PVOID   pvWndCompat; // optional
} NCEVALUATE, *PNCEVALUATE;

//---------------------------------------------------------------------------
//  nonclient theme metric API
BOOL    GetCurrentNcThemeMetrics( OUT NCTHEMEMET* pnctm );
HTHEME  GetCurrentNcThemeHandle();
HRESULT AcquireNcThemeMetrics();
BOOL    IsValidNcThemeMetrics( NCTHEMEMET* pnctm );
BOOL    ThemeNcAdjustWindowRect( NCTHEMEMET* pnctm, LPCRECT prcSrc, LPCRECT prcDest, BOOL fWantClientRect );
void    InitNcThemeMetrics( NCTHEMEMET* pnctm = NULL );
void    ClearNcThemeMetrics( NCTHEMEMET* pnctm = NULL );

//---------------------------------------------------------------------------
typedef struct _NCPAINTOVERIDE
{
    NCWNDMET*  pncwm;
    NCTHEMEMET nctm;
} NCPAINTOVERIDE, *PNCPAINTOVERIDE;

//---------------------------------------------------------------------------
class CMdiBtns;

//---------------------------------------------------------------------------
//  Hook state flags
#define HOOKSTATE_IN_DWP                0x00000001  // prevents Post-wndproc OWP from deleting the themewnd
#define HOOKSTATE_DETACH_WINDOWDESTROY  0x00000002  // tags themewnd for detach on window death
#define HOOKSTATE_DETACH_THEMEDESTROY   0x00000004  // tags themewnd for detach on theme death

//---------------------------------------------------------------------------
class CThemeWnd
//---------------------------------------------------------------------------
{
public:
    //  ref counting
    LONG              AddRef();
    LONG              Release();

    //  access operators
    operator HWND()   { return _hwnd; }
    operator HTHEME() { return _hTheme; }
    
    //  theme object attach/detach methods
    static ULONG      EvaluateWindowStyle( HWND hwnd );
    static ULONG      EvaluateStyle( DWORD dwStyle, DWORD dwExStyle );
    static CThemeWnd* Attach( HWND hwnd, IN OUT OPTIONAL NCEVALUATE* pnce = NULL );  // attaches CThemeWnd instance from window
    static CThemeWnd* FromHwnd( HWND hwnd ); // Retrieves CThemeWnd instance from window
    static CThemeWnd* FromHdc( HDC hdc, int cScanAncestors = 0 ); // maximum number of ancestor windows to grock.
    static void       Detach( HWND hwnd, DWORD dwDisposition ); // detaches CThemeWnd instance from window
    static void       DetachAll( DWORD dwDisposition ); // detaches all CThemeWnd instances in the current process
    static void       RemoveWindowProperties(HWND hwnd, BOOL fDestroying);
    static BOOL       Reject( HWND hwnd, BOOL fExile );
    static BOOL       Fail( HWND hwnd );
           BOOL       Revoke();  // revokes theming on a themed window

    BOOL              TestCF( ULONG fClassFlag ) const     
                              { return (_fClassFlags & fClassFlag) != 0; }

    //  Theme state
    BOOL        IsNcThemed();
    BOOL        IsFrameThemed();

    //  set/remove/change theme
    void        SetFrameTheme( ULONG dwFlags, IN OPTIONAL WINDOWINFO* pwi );
    void        RemoveFrameTheme( ULONG dwFlags );
    void        ChangeTheme( THEME_MSG* ptm );

    #define FTF_CREATE             0x00000001   // 'soft' theme the window during creation sequence.
    #define FTF_REDRAW             0x00000010   // force frame redraw.
    #define FTF_NOMODIFYRGN        0x00000040   // don't touch window region.
    #define FTF_NOMODIFYPLACEMENT  0x00000080   // don't move the window

    //  Theme revocation
    #define RF_NORMAL     0x00000001
    #define RF_REGION     0x00000002
    #define RF_TYPEMASK   0x0000FFFF
    #define RF_DEFER      0x00010000   // defer revocation until next WM_WINDOWPOSCHANGED
    #define RF_INREVOKE   0x00020000

    void        SetRevokeFlags( ULONG dwFlags ) {_dwRevokeFlags = dwFlags;}
    DWORD       GetRevokeFlags() const {return _dwRevokeFlags;}
    DWORD       IsRevoked( IN OPTIONAL ULONG dwFlags = 0 ) const   
                                       {return dwFlags ? TESTFLAG(_dwRevokeFlags, dwFlags) : 
                                                         TESTFLAG(_dwRevokeFlags, RF_TYPEMASK);}

    void        EnterRevoke()          {AddRef(); _dwRevokeFlags |= RF_INREVOKE;}
    void        LeaveRevoke()          {_dwRevokeFlags &= ~RF_INREVOKE; Release();}

    //  NCPaint hooking:
    BOOL        InNcPaint() const      { return _cNcPaint != 0; }
    void        EnterNcPaint()         { _cNcPaint++; }
    void        LeaveNcPaint()         { _cNcPaint--; }

    BOOL        InNcThemePaint() const { return _cNcThemePaint != 0; }
    void        EnterNcThemePaint()    { _cNcThemePaint++; }
    void        LeaveNcThemePaint()    { _cNcThemePaint--; }

    //  window region state
    void        SetDirtyFrameRgn( BOOL fDirty, BOOL fFrameChanged = FALSE );
    BOOL        DirtyFrameRgn() const      { return _fDirtyFrameRgn; }
    BOOL        AssigningFrameRgn() const  { return _fAssigningFrameRgn; }
    BOOL        AssignedFrameRgn() const   { return _fAssignedFrameRgn; }
    
    //  window region management
    void        AssignFrameRgn( BOOL fAssign, DWORD dwFlags );
    HRGN        CreateCompositeRgn( IN const NCWNDMET* pncwm,
                                    OUT HRGN rghrgnParts[],
                                    OUT HRGN rghrgnTemplates[] /* arrays presumed cFRAMEPARTS in length */);

    //  metrics/layout/state helpers.
    BOOL        GetNcWindowMetrics( IN OPTIONAL LPCRECT prcWnd, 
                                    OUT OPTIONAL NCWNDMET** ppncwm,
                                    OUT OPTIONAL NCTHEMEMET* pnctm, 
                                    IN DWORD dwOptions );
                #define NCWMF_RECOMPUTE      0x00000001  // recompute values
                #define NCWMF_PREVIEW        0x00000002  // Only used for the preview forces recalculating of NCTHEMEMET
    void        ReleaseNcWindowMetrics( IN NCWNDMET* pncwm );

    BOOL        InThemeSettingChange() const  {return _fInThemeSettingChange;}
    void        EnterThemeSettingChange()     {_fInThemeSettingChange = TRUE;}
    void        LeaveThemeSettingChange()     {_fInThemeSettingChange = FALSE;}

    UINT        NcCalcMenuBar( int, int, int ); // user32!CalcMenuBar wrap

    void        ScreenToWindow( LPPOINT prgPts, UINT cPts );
    void        ScreenToWindowRect( LPRECT prc );

    // MDI frame state.
    void        UpdateMDIFrameStuff( HWND hwndMDIClient, BOOL fSetMenu = FALSE );
    void        ThemeMDIMenuButtons( BOOL fTheme, BOOL fRedraw );
    void        ModifyMDIMenubar( BOOL fTheme, BOOL fRedraw );
    
    //  hit testing and mouse tracking
    WORD        NcBackgroundHitTest( POINT ptHit, LPCRECT prcWnd, DWORD dwStyle, DWORD dwExStyle, FRAMESTATES fs,
                                     const WINDOWPARTS rgiParts[],
                                     const WINDOWPARTS rgiTemplates[],
                                     const RECT rgrcParts[] /* all arrays presumed cFRAMEPARTS in length */);

    //  determines whether the indicated button should be tracked on mouse events.
    BOOL        ShouldTrackFrameButton( UINT uHitcode );

    //  Track mouse on NC frame button; copies back appropriate syscmd (SC_) code and target window, 
    //  returns TRUE if tracking was handled, otherwise FALSE if default tracking is required.
    BOOL        TrackFrameButton( IN HWND hwnd, IN INT uHitCode, OUT OPTIONAL WPARAM* puSysCmd, 
                                  BOOL fHottrack = FALSE );

    //  hot NC hittest identifier accessors
    int         GetNcHotItem()            { return _htHot; }
    void        SetNcHotItem(int htHot)   { _htHot = htHot; }

    //  style change handling
    void        StyleChanged( UINT iGWL, DWORD dwOld, DWORD dwNew );
    BOOL        SuppressingStyleMsgs() { return _fSuppressStyleMsgs; }
    void        SuppressStyleMsgs()   { _fSuppressStyleMsgs = TRUE; }
    void        AllowStyleMsgs()      { _fSuppressStyleMsgs = FALSE; }

    //  App icon management
    HICON       AcquireFrameIcon( DWORD dwStyle, DWORD dwExStyle, BOOL fWinIniChange );
    void        SetFrameIcon(HICON hIcon) { _hAppIcon = hIcon; }

    //  non-client painting
    void        NcPaint( IN OPTIONAL HDC hdc, 
                         IN ULONG dwFlags, 
                         IN OPTIONAL HRGN hrgnUpdate, 
                         IN OPTIONAL PNCPAINTOVERIDE pncpo );

                #define NCPF_DEFAULT            0x00000000
                #define NCPF_ACTIVEFRAME        0x00000001
                #define NCPF_INACTIVEFRAME      0x00000002

                #define DC_BACKGROUND           0x00010000
                #define DC_ENTIRECAPTION        0xFFFFFFFF
    void        NcPaintCaption( IN HDC hdcOut, 
                                IN NCWNDMET* pncwm, 
                                IN BOOL fBuffered, 
                                IN OPTIONAL DWORD dwCaptionFlags = DC_ENTIRECAPTION, 
                                IN DTBGOPTS *pdtbopts = NULL );

                #define RNCF_CAPTION            0x00000001
                #define RNCF_SCROLLBAR          0x00000002
                #define RNCF_FRAME              0x00000004
                #define RNCF_ALL                0xFFFFFFFF
    BOOL        HasRenderedNcPart( DWORD dwField ) const   { return TESTFLAG(_dwRenderedNcParts, dwField); }
    void        SetRenderedNcPart( DWORD dwField )         { _dwRenderedNcParts |= dwField; }
    void        ClearRenderedNcPart( DWORD dwField )       { _dwRenderedNcParts &= ~dwField; }

    void        LockRedraw( BOOL bLock )             { _cLockRedraw += (bLock ? 1 : -1); }

    BOOL        HasProcessedEraseBk()                { return _fProcessedEraseBk; }
    void        ProcessedEraseBk(BOOL fProcessed)    { _fProcessedEraseBk = fProcessed; }

    //  Maxed MDI child button ownerdraw implementation
    HWND        GetMDIClient() const                { return _hwndMDIClient; }
    CMdiBtns*   LoadMdiBtns( IN OPTIONAL HDC hdc, IN OPTIONAL UINT uSysCmd = 0 );
    void        UnloadMdiBtns( IN OPTIONAL UINT uSysCmd = 0 );

    //  resource management
    void        InitWindowMetrics();

    //  lame button support
#ifdef LAME_BUTTON
                //  ExStyles not defined by user
                #define WS_EX_LAMEBUTTONON      0x00000800L 
                #define WS_EX_LAMEBUTTON        0x00008000L 
    void        ClearLameResources();
    void        InitLameResources();
    void        DrawLameButton(HDC hdc, IN const NCWNDMET* pncwm);
    void        GetLameButtonMetrics( NCWNDMET* pncwm, const SIZE* psizeCaption );
#else
#   define      ClearLameResources()
#   define      InitLameResources()
#   define      DrawLameButton(hdc, pncwm)
#   define      GetLameButtonMetrics(pncwm, psize)
#endif // LAME_BUTTON

    //  Debugging:
#ifdef DEBUG
    void        Spew( DWORD dwSpewFlags, LPCTSTR pszFmt, LPCTSTR pszWndClassList = NULL );
    static void SpewAll( DWORD dwSpewFlags, LPCTSTR pszFmt, LPCTSTR pszWndClassList = NULL );
    static void SpewLeaks();
#endif DEBUG

    //  CThemeWnd object-window association
private:
    static ULONG    _Evaluate( HWND hwnd, NCEVALUATE* pnce );
    static ULONG    _EvaluateExclusions( HWND hwnd, NCEVALUATE* pnce );

    BOOL            _AttachInstance( HWND hwnd, HTHEME hTheme, ULONG fTargetFlags, PVOID pvWndCompat );
    BOOL            _DetachInstance( DWORD dwDisposition );
    void            _CloseTheme();

    static BOOL CALLBACK _DetachDesktopWindowsCB( HWND hwnd, LPARAM dwProcessId );

    //  Ctor, Dtor
private:  // auto-instantiated and deleted through friends
    CThemeWnd();
    ~CThemeWnd();

    //  Misc private methods
private:
    static BOOL     _PostWndProc( HWND, UINT, WPARAM, LPARAM, LRESULT* );
    static BOOL     _PostDlgProc( HWND, UINT, WPARAM, LPARAM, LRESULT* );
    static BOOL     _PreDefWindowProc( HWND, UINT, WPARAM, LPARAM, LRESULT* );

    static HTHEME   _AcquireThemeHandle( HWND hwnd, IN OUT ULONG *pfClassFlags );
    void            _AssignRgn( HRGN hrgn, DWORD dwFlags );
    void            _FreeRegionHandles();

    //  Private data
private:

    CHAR       _szHead[9];         // header signature used for object validation

    HWND       _hwnd;
    LONG       _cRef;              // ref count.
    HTHEME     _hTheme;            // theme handle
    DWORD      _dwRenderedNcParts; // mask of the NC elements we've drawn, to decide if we should track them
    ULONG      _dwRevokeFlags;     // theme revoke flags
    ULONG      _fClassFlags;       // theming class flag bits
    NCWNDMET   _ncwm;              // per-window metrics
    HICON      _hAppIcon;          // application's icon
    HRGN       _hrgnWnd;           // cached window region.
    HRGN       _rghrgnParts[cFRAMEPARTS]; // cached nc component subregions.
    HRGN       _rghrgnSizingTemplates[cFRAMEPARTS]; // cached nc frame resizing hittest template subregions.
    BOOL       _fDirtyFrameRgn;    // State flag: window region needs updating.
    BOOL       _fFrameThemed;      // SetFrameTheme() has been invoked on a valid frame window
    BOOL       _fAssigningFrameRgn;// SetWindowRgn state flag.
    BOOL       _fAssignedFrameRgn; // Region state flag
    BOOL       _fSuppressStyleMsgs;    // Suppress style change messages to arrive at the WndProc
    BOOL       _fProcessedEraseBk;
    BOOL       _fInThemeSettingChange; // window is being sent a theme setting change message.
    BOOL       _fDetached;         // Detached object; leave it alone!
    BOOL       _fThemedMDIBtns;    // MDI menubar buttons have been themed-rendered.
    BOOL       _fCritSectsInit;    // critical section(s) have been initialize
    HWND       _hwndMDIClient;     // MDICLIENT child window.
    int        _cLockRedraw;       // paint lock reference count.
    int        _cNcPaint;          // NCPAINT message ref count
    int        _cNcThemePaint;     // Indicator: we're painting the nonclient area.
    SIZE       _sizeRgn;           // window rgn size.
    int        _htHot;             // hittest code of the current hot NC element
    CMdiBtns*  _pMdiBtns;
    CRITICAL_SECTION _cswm;    // serializes access to _ncwm.

#ifdef DEBUG_THEMEWND_DESTRUCTOR
    BOOL       _fDestructed;       // destructor has been called.
    BOOL       _fDeleteCritsec;    // deleted WNDMET critsec
#endif DEBUG_THEMEWND_DESTRUCTOR

#ifdef LAME_BUTTON
    HFONT      _hFontLame;        // font used to draw the lame button text
    SIZE       _sizeLame;         // the text extent of the lame text
#endif // LAME_BUTTON

    static LONG _cObj;            // instance count

#ifdef DEBUG
public:
    TCHAR      _szCaption[MAX_PATH];
    TCHAR      _szWndClass[MAX_PATH];
#endif DEBUG

    CHAR       _szTail[4];        // tail signature used for object validation

    //  Message tracking
public:

    //   Friends
    friend LRESULT _ThemeDefWindowProc( HWND, UINT, WPARAM, LPARAM, BOOL );
    friend BOOL     ThemePreWndProc( HWND, UINT, WPARAM, LPARAM, LRESULT*, VOID** );
    friend BOOL     ThemePostWndProc( HWND, UINT, WPARAM, LPARAM, LRESULT*, VOID** );
    friend BOOL     ThemePreDefDlgProc( HWND, UINT, WPARAM, LPARAM, LRESULT*, VOID** );
    friend BOOL     ThemePrePostDlgProc( HWND, UINT, WPARAM, LPARAM, LRESULT*, VOID** );
    friend BOOL     ThemePostDefDlgProc(HWND, UINT, WPARAM, LPARAM, LRESULT*, VOID**);
};

//------------------------------------------ -------------------------------//
//  forwards:

//  Internal sysmet wrappers.   These functions can be more efficient than
//  calling through USER32, and support theme preview functionality.
int   NcGetSystemMetrics(int);
BOOL  NcGetNonclientMetrics( OUT OPTIONAL NONCLIENTMETRICS* pncm, BOOL fRefresh = FALSE );
void  NcClearNonclientMetrics();
HFONT NcGetCaptionFont( BOOL fSmallCaption );

HWND  NcPaintWindow_Find(); // retrieves window in current thread that is processing NCPAINT

//
void PrintClientNotHandled(HWND hwnd);

//  hook function workers
int  _InternalGetSystemMetrics( int, BOOL& fHandled );
BOOL _InternalSystemParametersInfo( UINT, UINT, PVOID, UINT, BOOL fUnicode, BOOL& fHandled );

//------------------------------------------ -------------------------------//
///  debug spew
#define NCTF_THEMEWND       0x00000001
#define NCTF_AWR            0x00000002 // ThemeAdjustWindowRectEx vs Calcsize
#define NCTF_SETFRAMETHEME  0x00000004 // 
#define NCTF_CALCWNDPOS     0x00000008 // WM_NCCALCSIZE, WM_WINDOWPOSCHANGED.
#define NCTF_RGNWND         0x00000010 // region window debugging
#define NCTF_MDIBUTTONS     0x00000020 // region window debugging
#define NCTF_NCPAINT        0x00000040 // debug painting
#define NCTF_SYSMETS        0x00000080 // system metrics calls
#define NCTF_ALWAYS         0xFFFFFFFF // always trace



#ifdef DEBUG
    void   CDECL _NcTraceMsg( ULONG uFlags, LPCTSTR pszFmt, ...);
    void   INIT_THEMEWND_DBG( CThemeWnd* pwnd );
    void   SPEW_RECT( ULONG ulTrace, LPCTSTR pszMsg, LPCRECT prc );
    void   SPEW_MARGINS( ULONG ulTrace, LPCTSTR pszMsg, LPCRECT prcParent, LPCRECT prcChild );
    void   SPEW_RGNRECT( ULONG ulTrace, LPCTSTR pszMsg, HRGN hrgn, int iPartID );
    void   SPEW_WINDOWINFO( ULONG ulTrace, WINDOWINFO* );
    void   SPEW_NCWNDMET( ULONG ulTrace, LPCTSTR, NCWNDMET* );
    void   SPEW_SCROLLINFO( ULONG ulTrace, LPCTSTR pszMsg, HWND hwnd, LPCSCROLLINFO psi );
    void   SPEW_THEMEMSG( ULONG ulTrace, LPCTSTR pszMsg, THEME_MSG* ptm );
#   define SPEW_THEMEWND(pwnd,dwFlags,txt,classlist)  (pwnd)->Spew( dwFlags, txt, classlist )
#   define SPEW_THEMEWND_LEAKS(pwnd)           (pwnd)->SpewLeaks()
#else  // DEBUG
    inline void CDECL _NcTraceMsg( ULONG uFlags, LPCTSTR pszFmt, ...) {}
#   define INIT_THEMEWND_DBG( pwnd );
#   define SPEW_RECT( ulTrace, pszMsg, prc )
#   define SPEW_MARGINS( ulTrace, pszMsg, prcParent, prcChild )
#   define SPEW_RGNRECT( ulTrace, pszMsg, hrgn, iPartID )
#   define SPEW_WINDOWINFO( ulTrace, pwi )
#   define SPEW_NCWNDMET( ulTrace, pszMsg, pncwm )
#   define SPEW_SCROLLINFO( ulTrace, pszMsg, hwnd, psi )
#   define SPEW_THEMEMSG( ulTrace, pszMsg, ptm )
#   define SPEW_THEMEWND(pwnd,dwFlags,txt,classlist)  (pwnd)->Spew( dwFlags, txt, classlist )
#   define SPEW_THEMEWND_LEAKS(pwnd)           (pwnd)->SpewLeaks()
#endif // DEBUG

#endif __NC_THEME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\themes\uxtheme\nctheme.cpp ===
//-------------------------------------------------------------------------//
//  NCTheme.cpp
//-------------------------------------------------------------------------//
//  bug: resizable dialog (themesel) doesn't repaint client when needed
//       (for test case, resize "themesel" using "bussolid" theme.
//-------------------------------------------------------------------------//
#include "stdafx.h"
#include "nctheme.h"
#include "sethook.h"
#include "info.h"
#include "rgn.h"        // AddToCompositeRgn()
#include "scroll.h"     // DrawSizeBox, DrawScrollBar, HandleScrollCmd
#include "resource.h"
#include "tmreg.h"
#include "wrapper.h"
#include "appinfo.h"

//-------------------------------------------------------------------------//
///  local macros, consts, vars
//-------------------------------------------------------------------------//
const   RECT rcNil                       = {-1,-1,-1,-1};
const   WINDOWPARTS BOGUS_WINDOWPART     = (WINDOWPARTS)0;
#define VALID_WINDOWPART(part)           ((part)!=BOGUS_WINDOWPART)
#define WS_MINMAX                        (WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define HAS_CAPTIONBAR( dwStyle )        (WS_CAPTION == ((dwStyle) & WS_CAPTION))
#define DLGWNDCLASSNAME                  TEXT("#32770")
#define DLGWNDCLASSNAMEW                 L"#32770"

#define NUMBTNSTATES                     4 /*number of defined states*/
#define MAKE_BTNSTATE(framestate, state) ((((framestate)-1) * NUMBTNSTATES) + (state))
#define MDIBTNINDEX(ncrc)                ((ncrc)-NCMDIBTNFIRST)

#ifdef  MAKEPOINT
#undef  MAKEPOINT
#endif  MAKEPOINT
#define MAKEPOINT(pt,lParam)             POINTSTOPOINT(pt, MAKEPOINTS(lParam))

#define IsHTFrameButton(htCode)             \
            (((htCode) == HTMINBUTTON) ||   \
             ((htCode) == HTMAXBUTTON) ||   \
             ((htCode) == HTCLOSE)     ||   \
             ((htCode) == HTHELP))

#define IsTopLevelWindow(hwnd)          (IsWindow(hwnd) && NULL==GetParent(hwnd))

#define IsHTScrollBar(htCode)           (((htCode) == HTVSCROLL) || ((htCode) == HTHSCROLL))

#define SIG_CTHEMEWND_HEAD              "themewnd"
#define SIG_CTHEMEWND_TAIL              "end"

//-------------------------------------------------------------------------//
HWND  _hwndFirstTop = NULL;         // first themed window in process
TCHAR _szWindowMetrics[128] = {0};  // WM_SETTINGCHANGE string param.
//-------------------------------------------------------------------------//

//  debug painting switch.
#define DEBUG_NCPAINT 

//-------------------------------------------------------------------------//
//  internal helper forwards
//-------------------------------------------------------------------------//
HDC     _GetNonclientDC( IN HWND hwnd, IN OPTIONAL HRGN hrgnUpdate );
BOOL    _ClientRectToScreen( HWND, LPRECT prcClient );
void    _ScreenToParent( HWND, LPRECT prcWnd );
BOOL    _GetWindowMonitorRect( HWND hwnd, LPRECT prcMonitor );
BOOL    _GetMaximizedContainer( IN HWND hwnd, OUT LPRECT prcContainer );
BOOL    _IsFullMaximized( IN OPTIONAL HWND hwnd, IN LPCRECT prcWnd );
BOOL    _IsMessageWindow( HWND );
void    _MDIUpdate( HWND hwndMDIChildOrClient, UINT uSwpFlags );
BOOL    _MDIClientUpdateChildren( HWND hwndMDIClient );
void    _MDIChildUpdateParent( HWND hwndMDIChild, BOOL fSetMenu = FALSE );
HWND    _MDIGetActive( HWND, OUT OPTIONAL BOOL* pfMaximized = NULL );
HWND    _MDIGetParent( HWND hwnd, OUT OPTIONAL CThemeWnd** ppMdiFrame = NULL, OUT OPTIONAL HWND *phwndMDIClient = NULL );
HRESULT _CreateBackgroundBitmap( IN OPTIONAL HDC, IN HTHEME, IN int iPartId, IN int iStateId, IN OUT LPSIZE, OUT HBITMAP*);
HRESULT _CreateMdiMenuItemBitmap( IN HDC hdc, IN HTHEME hTheme, IN OUT SIZE* pSize, IN OUT MENUITEMINFO* pmii );
void    _ComputeElementOffset( HTHEME, int iPartId, int iStateId, LPCRECT prcBase, POINT *pptOffset);
int     _GetRawClassicCaptionHeight( DWORD dwStyle, DWORD dwExStyle );
int     _GetSumClassicCaptionHeight( DWORD dwStyle, DWORD dwExStyle );
void    _ComputeNcWindowStatus( IN HWND, IN DWORD dwStatus, IN OUT NCWNDMET* pncwm );
BOOL    _NeedsWindowEdgeStyle(DWORD dwStyle, DWORD dwExStyle );
BOOL    _MNCanClose(HWND);
int     _GetWindowBorders(LONG lStyle, DWORD dwExStyle );
BOOL    _GetWindowMetrics( HWND, IN OPTIONAL HWND hwndMDIActive, OUT NCWNDMET* pncwm );
BOOL    _IsNcPartTransparent( WINDOWPARTS part, const NCTHEMEMET& nctm );
BOOL    _GetNcFrameMetrics( HWND, HTHEME hTheme, const NCTHEMEMET&, IN OUT NCWNDMET& );
BOOL    _GetNcCaptionMargins( HTHEME hTheme, IN const NCTHEMEMET& nctm, IN OUT NCWNDMET& ncwm );
LPWSTR  _AllocWindowText( IN HWND hwnd );
BOOL    _GetNcCaptionTextSize( IN HTHEME hTheme, IN HWND hwnd, IN HFONT hf, OUT SIZE* psizeCaption );
BOOL    _GetNcCaptionTextRect( IN OUT NCWNDMET* pncwm );
COLORREF _GetNcCaptionTextColor( FRAMESTATES iStateId );
void    _GetNcBtnHitTestRect( IN const NCWNDMET* pncwm, IN UINT uHitcode, BOOL fWindowRelative, OUT LPRECT prcHit );
void    _GetBrushesForPart(HTHEME hTheme, int iPart, HBITMAP* phbm, HBRUSH* phbr);
BOOL    _ShouldAssignFrameRgn( IN const NCWNDMET* pncwm, IN const NCTHEMEMET& nctm );
BOOL    _IsNcPartTransparent( WINDOWPARTS part, const NCTHEMEMET& nctm );
BOOL    _ComputeNcPartTransparency( HTHEME, IN OUT NCTHEMEMET* pnctm );
HRESULT _LoadNcThemeMetrics( HWND, IN OUT OPTIONAL NCTHEMEMET* pnctm );
HRESULT _LoadNcThemeSysMetrics( HWND hwnd, IN OUT OPTIONAL NCTHEMEMET* pnctm );
void    _NcSetPreviewMetrics( BOOL fPreview );
BOOL    _NcUsingPreviewMetrics();

//-------------------------------------------------------------------------//
#ifdef THEMED_NCBTNMETRICS
BOOL    _GetClassicNcBtnMetrics( IN OPTIONAL NCWNDMET* pncwm, IN OPTIONAL HICON hAppIcon, 
                                 IN OPTIONAL BOOL fCanClose, IN OPTIONAL BOOL fRefresh = FALSE );
#else  THEMED_NCBTNMETRICS
BOOL    _GetNcBtnMetrics( IN OUT NCWNDMET*, IN const NCTHEMEMET*, IN HICON, IN OPTIONAL BOOL );
#endif THEMED_NCBTNMETRICS

//-------------------------------------------------------------------------//
//  Debug painting.
#if defined(DEBUG) 
ULONG _NcTraceFlags = 0;
#   if defined(DEBUG_NCPAINT)
#       define BEGIN_DEBUG_NCPAINT()  int cgbl = 0; if(TESTFLAG(_NcTraceFlags, NCTF_NCPAINT)) {GdiSetBatchLimit(1);}
#       define END_DEBUG_NCPAINT()    if(TESTFLAG(_NcTraceFlags, NCTF_NCPAINT)) {GdiSetBatchLimit(cgbl);}
        HRESULT _DebugDrawThemeBackground(HTHEME, HDC, int, int, const RECT*, OPTIONAL const RECT*);
        HRESULT _DebugDrawThemeBackgroundEx(HTHEME, HDC, int, int, const RECT *prc, OPTIONAL const DTBGOPTS*);
        void    NcDebugClipRgn( HDC hdc, COLORREF rgbPaint );
#       define  NcDrawThemeBackground   _DebugDrawThemeBackground
#       define  NcDrawThemeBackgroundEx _DebugDrawThemeBackgroundEx
#   else  //defined(DEBUG_NCPAINT)
#       define BEGIN_DEBUG_NCPAINT()
#       define END_DEBUG_NCPAINT()
#       define  NcDrawThemeBackground   DrawThemeBackground
#       define  NcDrawThemeBackgroundEx DrawThemeBackgroundEx
#       define NcDebugClipRgn(hdc,rgbPaint)
#   endif //defined(DEBUG_NCPAINT)
#else
#   define BEGIN_DEBUG_NCPAINT()
#   define END_DEBUG_NCPAINT()
#   define  NcDrawThemeBackground   DrawThemeBackground
#   define  NcDrawThemeBackgroundEx DrawThemeBackgroundEx
#   define NcDebugClipRgn(hdc,rgbPaint)
#endif //defined(DEBUG)
#define RGBDEBUGBKGND   RGB(0xFF,0x00,0xFF) // debug background indicator fill color

//-------------------------------------------------------------------------//
//  process-global metrics
static NCTHEMEMET _nctmCurrent = {0};

CRITICAL_SECTION _csNcSysMet = {0}; // protects access to _incmCurrent 
CRITICAL_SECTION _csThemeMet = {0}; // protects access to _nctmCurrent 

//-------------------------------------------------------------------------//
//  process NONCLIENTMETRICS cache.
struct CInternalNonclientMetrics
//-------------------------------------------------------------------------//
{
    const NONCLIENTMETRICS& GetNcm()
    { 
        Acquire(FALSE);
        return _ncm;
    }

    HFONT GetFont( BOOL fSmallCaption )
    {
        if( _fSet)
        {
            return fSmallCaption ? _hfSmCaption : _hfCaption;
        }
        
        return NULL;
    }

    void operator =( const NONCLIENTMETRICS& ncmSrc )
    {
        _ncm = ncmSrc;

        SAFE_DELETE_GDIOBJ(_hfCaption);
        _hfCaption   = CreateFontIndirect( &_ncm.lfCaptionFont );

        SAFE_DELETE_GDIOBJ(_hfSmCaption);
        _hfSmCaption = CreateFontIndirect( &_ncm.lfSmCaptionFont );

        _fSet = TRUE;
    }

    BOOL Acquire( BOOL fRefresh )
    {
        //---- quick check for outdated metrics ----
        if (!_fPreview)
        {
            int iNewHeight = GetSystemMetrics(SM_CYSIZE);

            if (iNewHeight != _iCaptionButtonHeight)        // out of date
            {
                fRefresh = TRUE;        // force the issue   
                _iCaptionButtonHeight = iNewHeight;
            }
        }

        //  normal metrics
        if( !_fSet || fRefresh )
        {
            // save logfont checksum
            LOGFONT lfCaption   = _ncm.lfCaptionFont;
            LOGFONT lfSmCaption = _ncm.lfSmCaptionFont;

            Log(LOG_TMLOAD, L"Acquire: calling ClassicSystemParmetersInfo");

            _ncm.cbSize = sizeof(_ncm);
            _fSet = ClassicSystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, &_ncm, FALSE );

            if( _fSet )
            {
                // if old, new logfont checksums don't match, recycle our fonts
                if( CompareLogfont( &lfCaption, &_ncm.lfCaptionFont) )
                {
                    SAFE_DELETE_GDIOBJ(_hfCaption);
                    _hfCaption = CreateFontIndirect(&_ncm.lfCaptionFont);
                }

                if( CompareLogfont( &lfSmCaption, &_ncm.lfSmCaptionFont) )
                {
                    SAFE_DELETE_GDIOBJ(_hfSmCaption);
                    _hfSmCaption = CreateFontIndirect(&_ncm.lfSmCaptionFont);
                }
            }
        }
        return _fSet;
    }

    void Clear() 
    { 
        SAFE_DELETE_GDIOBJ(_hfCaption); 
        SAFE_DELETE_GDIOBJ(_hfSmCaption);
        ZeroMemory( &_ncm, sizeof(_ncm) );
        _fSet = FALSE;
    }

    static int CompareLogfont( const LOGFONT* plf1, const LOGFONT* plf2 )
    {
        int n = memcmp( plf1, plf2, sizeof(LOGFONT) - sizeof(plf1->lfFaceName) );
        if( !n )
        {
            n = lstrcmp( plf1->lfFaceName, plf2->lfFaceName );
        }
        return n;
    }

    NONCLIENTMETRICS _ncm;
    int              _iCaptionButtonHeight;
    BOOL             _fSet;
    HFONT            _hfCaption;
    HFONT            _hfSmCaption;
    BOOL             _fPreview;

} _incmCurrent = {0}, _incmPreview = {0};

//-------------------------------------------------------------------------//
//  MDI sys button group abstraction
class CMdiBtns
//-------------------------------------------------------------------------//
{
public:
    CMdiBtns();
    ~CMdiBtns() { Unload(); }

    BOOL Load( IN HTHEME hTheme, IN OPTIONAL HDC hdc = NULL, IN OPTIONAL UINT uSysCmd = 0 );
    BOOL ThemeItem( HMENU hMenu, int iPos, MENUITEMINFO* pmii, BOOL fTheme );
    void Unload( IN OPTIONAL UINT uSysCmd = 0 );
    BOOL Measure( IN HTHEME hTheme, IN OUT MEASUREITEMSTRUCT* pmis );
    BOOL Draw( IN HTHEME hTheme, IN DRAWITEMSTRUCT* pdis );

private:
   
    #define MDIBTNCOUNT 3   // 1=min, 2=restore, 3=close
    //------------------------------------//
    //  MDI sys button descriptor element
    struct MDIBTN
    {
        UINT        wID;
        WINDOWPARTS iPartId;
        SIZINGTYPE  sizingType;
        SIZE        size;
        UINT        fTypePrev;
        HBITMAP     hbmPrev;
        HBITMAP     hbmTheme;

    } _rgBtns[MDIBTNCOUNT];

private:
    MDIBTN*                   _FindBtn( IN UINT wID );
    static CLOSEBUTTONSTATES  _CalcState( IN ULONG ulodAction, IN ULONG ulodState );
};

//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
//  utility impl
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
BOOL _ClientRectToScreen( HWND hwnd, LPRECT prcClient )
{
    if( prcClient && GetClientRect( hwnd, prcClient ) )
    {
        POINT* pp = (POINT*)prcClient;

        //---- use MapWindowPoints() to account for mirrored windows ----
        MapWindowPoints(hwnd, HWND_DESKTOP, pp, 2);
        return TRUE;
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
void _ScreenToParent( HWND hwnd, LPRECT prcWnd )
{
    //if we have a parent, we need to convert to those coords
    HWND hwndParent = GetAncestor(hwnd, GA_PARENT);
    POINT* pp = (POINT*)prcWnd;
    
    //---- use MapWindowPoints() to account for mirrored windows ----
    MapWindowPoints(HWND_DESKTOP, hwndParent, pp, 2);
}

//-------------------------------------------------------------------------//
inline BOOL _StrictPtInRect( LPCRECT prc, const POINT& pt )
{
    //  Win32 PtInRect will test positive for an empty rectangle...
    return !IsRectEmpty(prc) &&
           PtInRect( prc, pt );
}

//-------------------------------------------------------------------------//
inline BOOL _RectInRect( LPCRECT prcTest, LPCRECT prc )
{
    if ( prc->left   < prcTest->left  &&
         prc->right  > prcTest->right &&
         prc->top    < prcTest->top   &&
         prc->bottom > prcTest->bottom   )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//-------------------------------------------------------------------------//
inline HDC _GetNonclientDC( IN HWND hwnd, IN OPTIONAL HRGN hrgnUpdate )
{
    // private GetDCEx #defines from user
    #define DCX_USESTYLE         0x00010000L
    #define DCX_NODELETERGN      0x00040000L

    DWORD dwDCX = DCX_USESTYLE|DCX_WINDOW|DCX_LOCKWINDOWUPDATE;

    if( hrgnUpdate != NULL )
        dwDCX |= (DCX_INTERSECTRGN|DCX_NODELETERGN);
    
    return GetDCEx( hwnd, hrgnUpdate, dwDCX );
}

//-------------------------------------------------------------------------//
HWND _MDIGetActive( HWND hwndMDIClient, OUT OPTIONAL BOOL* pfMaximized )
{
    BOOL fMaximized = FALSE;
    HWND hwndActive = NULL;

    if( IsWindow( hwndMDIClient ) )
        hwndActive = (HWND)SendMessage( hwndMDIClient, WM_MDIGETACTIVE, 0, (LPARAM)&fMaximized );

    if( pfMaximized ) *pfMaximized = fMaximized;
    return hwndActive;
}

//-------------------------------------------------------------------------////
//  computes rectangle of window's default monitor
BOOL _GetWindowMonitorRect( HWND hwnd, LPRECT prcMonitor )
{
    if( IsWindow(hwnd) )
    {
        //  default to primary monitor
        SetRect( prcMonitor, 0, 0, 
                 NcGetSystemMetrics(SM_CXSCREEN), 
                 NcGetSystemMetrics(SM_CYSCREEN));

        //  try determining window's real monitor
        HMONITOR hMon = MonitorFromWindow( hwnd, MONITOR_DEFAULTTONULL );
        if( hMon )
        {
            MONITORINFO mi;
            mi.cbSize = sizeof(mi);
            if( GetMonitorInfo( hMon, &mi ) )
            {
                *prcMonitor = mi.rcWork;
            }
        }
        return TRUE;
    }
    return FALSE;
}

//-------------------------------------------------------------------------////
//  determines whether the indicate window is as large or larger than
//  the target monitor
BOOL _GetMaximizedContainer( 
    IN HWND hwnd, 
    OUT LPRECT prcContainer )
{
    ASSERT(IsWindow(hwnd));

    HWND hwndParent = GetParent(hwnd);
    if( hwndParent )
    {
        return GetWindowRect( hwndParent, prcContainer );
    }

    // top-level window: container is primary monitor
    return _GetWindowMonitorRect( hwnd, prcContainer );
}

//-------------------------------------------------------------------------////
//  determines whether the indicate window is as large or larger than
//  the target monitor
BOOL _IsFullMaximized( IN OPTIONAL HWND hwnd, IN LPCRECT prcWnd )
{
    if( !IsWindow(hwnd) ) 
        return TRUE; // assume full-screen maximized window

    if( IsZoomed(hwnd) )
    {
        RECT rcContainer = {0};
        if( !_GetMaximizedContainer( hwnd, &rcContainer ) )
            return TRUE;

        //  determine whether the rect is contained in the screen rect
        return _RectInRect( &rcContainer, prcWnd );
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
//
//  _GetRawClassicCaptionHeight() - 
//
//  Using system metrics, computes the total height of the caption bar
//  including edge and borders
//
inline int _GetRawClassicCaptionHeight( DWORD dwStyle, DWORD dwExStyle )
{
    ASSERT(HAS_CAPTIONBAR(dwStyle)); // shouldn't be here without WS_CAPTION
    return NcGetSystemMetrics( 
        TESTFLAG(dwExStyle, WS_EX_TOOLWINDOW ) ? SM_CYSMCAPTION : SM_CYCAPTION );
}

//-------------------------------------------------------------------------//
//
//  _GetSumClassicCaptionHeight() - 
//
//  Using system metrics, computes the total height of the caption bar
//  including edge and borders
//
inline int _GetSumClassicCaptionHeight( DWORD dwStyle, DWORD dwExStyle )
{
    ASSERT(HAS_CAPTIONBAR(dwStyle)); // shouldn't be here without WS_CAPTION
    //  Factor in window border width.
    return _GetWindowBorders( dwStyle, dwExStyle) +
           _GetRawClassicCaptionHeight( dwStyle, dwExStyle );
}

//-------------------------------------------------------------------------//
//
//  GetWindowBorders()  - port from win32k, rtl\winmgr.c
//
//  Computes window border dimensions based on style bits.
//
int _GetWindowBorders(LONG lStyle, DWORD dwExStyle )
{
    int cBorders = 0;

    //
    // Is there a 3D border around the window?
    //
    if( TESTFLAG(dwExStyle, WS_EX_WINDOWEDGE) )
        cBorders += 2;
    else if ( TESTFLAG(dwExStyle, WS_EX_STATICEDGE) )
        ++cBorders;

    //
    // Is there a single flat border around the window?  This is true for
    // WS_BORDER, WS_DLGFRAME, and WS_EX_DLGMODALFRAME windows.
    //
    if( TESTFLAG(lStyle, WS_CAPTION) || TESTFLAG(dwExStyle, WS_EX_DLGMODALFRAME) )
        ++cBorders;

    //
    // Is there a sizing flat border around the window?
    //
    if( TESTFLAG(lStyle, WS_THICKFRAME) && !TESTFLAG(lStyle, WS_MINIMIZE) )
    {
        NONCLIENTMETRICS ncm;
        cBorders += (NcGetNonclientMetrics( &ncm, FALSE ) ? 
                        ncm.iBorderWidth : NcGetSystemMetrics( SM_CXBORDER ));
    }

    return(cBorders);
}

//-------------------------------------------------------------------------//
//  Determines whether WS_EX_WINDOWEDGE should be assumed.
//  Ripped from USER sources (rtl\winmgr.c)
BOOL _NeedsWindowEdgeStyle(DWORD dwStyle, DWORD dwExStyle )
{
    BOOL fGetsWindowEdge = FALSE;

    if (dwExStyle & WS_EX_DLGMODALFRAME)
        fGetsWindowEdge = TRUE;
    else if (dwExStyle & WS_EX_STATICEDGE)
        fGetsWindowEdge = FALSE;
    else if (dwStyle & WS_THICKFRAME)
        fGetsWindowEdge = TRUE;
    else switch (dwStyle & WS_CAPTION)
    {
        case WS_DLGFRAME:
            fGetsWindowEdge = TRUE;
            break;
        case WS_CAPTION:
            fGetsWindowEdge = TRUE; // PORTPORT: SHIMSHIM should be: = (RtlGetExpWinVer(hMod) > VER40)
                                    // we will assume a new app; old apps are denied.
            break;
    }

    return(fGetsWindowEdge);
}

//-------------------------------------------------------------------------//
//  _MNCanClose
//
//  returns TRUE only if USER32 determines that the window can be closed
//  (by checking its system menu items and their disabled state)
//
BOOL _MNCanClose(HWND hwnd)
{
    LogEntryNC(L"_MNCanClose");

    BOOL fRetVal = FALSE;
    
    TITLEBARINFO tbi = {sizeof(tbi)};

    //---- don't use GetSystemMenu() - has user handle leak issues ----
    if (GetTitleBarInfo(hwnd, &tbi))
    {
        //---- mask out the good bits ----
        DWORD dwVal = (tbi.rgstate[5] & (~(STATE_SYSTEM_PRESSED | STATE_SYSTEM_FOCUSABLE)));
        fRetVal = (dwVal == 0);     // only if no bad bits are left
    }

    if ( !fRetVal && TESTFLAG(GetWindowLong(hwnd, GWL_EXSTYLE), WS_EX_MDICHILD) )
    {
        HMENU hMenu = GetSystemMenu(hwnd, FALSE);
        MENUITEMINFO menuInfo; 

        menuInfo.cbSize = sizeof(MENUITEMINFO);
        menuInfo.fMask = MIIM_STATE;
        if ( GetMenuItemInfo(hMenu, SC_CLOSE, FALSE, &menuInfo) )
        {
            fRetVal = !(menuInfo.fState & MFS_GRAYED) ? TRUE : FALSE;
        } 
    }
    
    LogExitNC(L"_MNCanClose");
    return fRetVal;
}

//-------------------------------------------------------------------------//
void CThemeWnd::UpdateMDIFrameStuff( HWND hwndMDIClient, BOOL fSetMenu )
{
    HWND hwndMDIActive = _MDIGetActive( hwndMDIClient, NULL );

    //  cache MDIClient, maximized M window handle
    _hwndMDIClient = IsWindow(hwndMDIActive) ? hwndMDIClient : NULL;
}

//-------------------------------------------------------------------------//
BOOL CALLBACK _FreshenThemeMetricsCB( HWND hwnd, LPARAM lParam )
{
    CThemeWnd* pwnd = CThemeWnd::FromHwnd( hwnd );
    if( VALID_THEMEWND(pwnd) )
    {
        pwnd->AddRef();
        pwnd->GetNcWindowMetrics( NULL, NULL, NULL, NCWMF_RECOMPUTE );
        pwnd->Release();
    }
    return TRUE;
}

//-------------------------------------------------------------------------//
BOOL _IsMessageWindow( HWND hwnd )
{
    //  A window parented by HWND_MESSAGE has no UI and should not be themed.
    static ATOM _atomMsgWnd = 0;

    HWND hwndParent = (HWND)GetWindowLongPtr( hwnd, GWLP_HWNDPARENT );
    if( hwndParent )
    {
        ATOM atomParent = (ATOM)GetClassLong( hwndParent, GCW_ATOM );
        
        // have we seen the message window wndclass before?
        if( _atomMsgWnd ) 
            return (atomParent == _atomMsgWnd); // compare class atoms

        //  haven't seen a message window come through in this process,
        //  so compare class names.
        WCHAR szClass[128];
        if( GetClassNameW( hwndParent, szClass, ARRAYSIZE(szClass) ) )
        {
            if( 0 == AsciiStrCmpI( szClass, L"Message" ) )
            {
                _atomMsgWnd = atomParent;
                return TRUE;
            }
        }
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
//  Retrieves MDI frame and/or MDICLIENT window for an MDI child window
HWND _MDIGetParent( 
    HWND hwnd, OUT OPTIONAL CThemeWnd** ppMdiFrame, OUT OPTIONAL HWND* phwndMDIClient )
{
    if( ppMdiFrame )     *ppMdiFrame = NULL;
    if( phwndMDIClient ) *phwndMDIClient = NULL;

    if( TESTFLAG(GetWindowLong( hwnd, GWL_EXSTYLE ), WS_EX_MDICHILD)  )
    {
        HWND hwndMDIClient = GetParent(hwnd);
        if( IsWindow(hwndMDIClient) )
        {
            HWND hwndFrame = GetParent(hwndMDIClient);
            if( IsWindow(hwndFrame) )
            {
                if( phwndMDIClient ) *phwndMDIClient = hwndMDIClient;
                if( ppMdiFrame )
                    *ppMdiFrame = CThemeWnd::FromHwnd(hwndFrame);

                return hwndFrame;
            }
        }
    }
    return NULL;
}

//-------------------------------------------------------------------------//
HWND _FindMDIClient( HWND hwndFrame )
{
    for( HWND hwndChild = GetWindow(hwndFrame, GW_CHILD); hwndChild != NULL; 
         hwndChild = GetNextWindow(hwndChild, GW_HWNDNEXT))
    {
        TCHAR szClass[48];
        if( GetClassName(hwndChild, szClass, ARRAYSIZE(szClass)) )
        {
            if( 0 == lstrcmpi(szClass, TEXT("MDIClient")) )
            {
                return hwndChild;
            }
        }
    }
    return NULL;
}

//-------------------------------------------------------------------------//
// Handle MDI relative updating on WM_WINDOWPOSCHANGED
void _MDIUpdate( HWND hwnd, UINT uSwpFlags)
{
    //  Notify MDI frame if we became maximized, etc.
    BOOL bIsClient = FALSE;

    // Could be the MDI client, could be a MDI child
    if (!(TESTFLAG(uSwpFlags, SWP_NOMOVE) && TESTFLAG(uSwpFlags, SWP_NOSIZE)))
    {
        bIsClient = _MDIClientUpdateChildren( hwnd );
    }
    if (!bIsClient)
    {
        _MDIChildUpdateParent( hwnd, FALSE );
    }
}

//-------------------------------------------------------------------------//
// Post-WM_WINDOWPOSCHANGED processing for MDI client or children.
// We need to recompute each child when the MDI client moves.
BOOL _MDIClientUpdateChildren( HWND hwndMDIChildOrClient )
{
    // Find if it's the MDI client window
    HWND hWndChild = GetWindow(hwndMDIChildOrClient, GW_CHILD);
    if (IsWindow(hWndChild) && TESTFLAG(GetWindowLong(hWndChild, GWL_EXSTYLE), WS_EX_MDICHILD))
    {
        // Yes it's the MDI client, refresh each MDI child's metrics
        do
        {
            _FreshenThemeMetricsCB(hWndChild, NULL);
        } while (NULL != (hWndChild = GetWindow(hWndChild, GW_HWNDNEXT)));
        return TRUE;
    }

    return FALSE;
}

//-------------------------------------------------------------------------//
//  Informs MDI frame that a child window may
void _MDIChildUpdateParent( HWND hwndMDIChild, BOOL fSetMenu )
{
    CThemeWnd* pwndParent;
    HWND hwndMDIClient;

    if( _MDIGetParent( hwndMDIChild, &pwndParent, &hwndMDIClient ) && 
        VALID_THEMEWND(pwndParent) )
    {
        pwndParent->UpdateMDIFrameStuff( hwndMDIClient, fSetMenu );
    }
}

//-------------------------------------------------------------------------//
//  Creates a replacement menu item bitmap for MDI frame window menubar 
//  buttons for maximized MDI child.
HRESULT _CreateMdiMenuItemBitmap( 
    IN HDC hdc, 
    IN HTHEME hTheme, 
    IN OUT SIZE* pSize, 
    IN OUT MENUITEMINFO* pmii )
{
    WINDOWPARTS       iPartId;
    CLOSEBUTTONSTATES iStateId = CBS_NORMAL;

    switch( (UINT)pmii->wID )
    {
        case SC_CLOSE:
            iPartId  = WP_MDICLOSEBUTTON;
            break;

        case SC_MINIMIZE:
            iPartId = WP_MDIMINBUTTON;
            break;

        case SC_RESTORE:
            iPartId  = WP_MDIRESTOREBUTTON; 
            break;

        default:
            return E_INVALIDARG;
    }
    iStateId = TESTFLAG(pmii->fState, MFS_DISABLED) ? CBS_DISABLED : CBS_NORMAL;

    if( NULL == pSize )
    {
        SIZE size;
        size.cx = NcGetSystemMetrics(SM_CXMENUSIZE);
        size.cy = NcGetSystemMetrics(SM_CYMENUSIZE);
        pSize = &size;
    }

    return _CreateBackgroundBitmap( hdc, hTheme, iPartId, iStateId, pSize, &pmii->hbmpItem );
}

//-------------------------------------------------------------------------//
HRESULT _CreateBackgroundBitmap( 
    IN OPTIONAL HDC hdcCompatible, 
    IN HTHEME hTheme, 
    IN int iPartId, 
    IN int iStateId, 
    IN OUT LPSIZE pSize, // in: if cx <= 0 || cx <=0, assume truesize.  out: background size
    OUT HBITMAP* phbmOut )
{
    ASSERT(hdcCompatible);
    ASSERT(hTheme);
    ASSERT(pSize);
    ASSERT(phbmOut);

    HRESULT hr = E_FAIL;
    SIZE    size;
    
    *phbmOut  = NULL;
    size      = *pSize;
    pSize->cx = pSize->cy = 0;

    //  Create working DC.
    HDC hdcMem = CreateCompatibleDC(hdcCompatible);

    if( hdcMem != NULL )
    {
        //  determine output size;
        hr = (size.cx <= 0 || size.cy <= 0) ?
            GetThemePartSize( hTheme, hdcCompatible, iPartId, iStateId, NULL, TS_TRUE, &size ) : S_OK;

        if( SUCCEEDED(hr) )
        {
            HBITMAP hbmOut = CreateCompatibleBitmap( hdcCompatible, size.cx, size.cy );
            if( hbmOut )
            {
                HBITMAP hbm0 = (HBITMAP)SelectObject(hdcMem, hbmOut);
                RECT rcBkgnd;
                SetRect( &rcBkgnd, 0, 0, size.cx, size.cy );
                hr = NcDrawThemeBackground( hTheme, hdcMem, iPartId, iStateId, &rcBkgnd, 0 );
                SelectObject( hdcMem, hbm0 );

                if( SUCCEEDED(hr) )
                {
                    *phbmOut = hbmOut;
                    pSize->cx = size.cx;
                    pSize->cy = size.cy;
                }
                else
                {
                    SAFE_DELETE_GDIOBJ(hbmOut);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        DeleteDC(hdcMem);
    }

    return hr;
}

//-------------------------------------------------------------------------//
//  _ComputeElementOffset() - calculates specified offset for caption or button
//  This could be generalized in the themeapi, yes? [scotthan]
void _ComputeElementOffset(
    HTHEME hTheme, 
    int iPartId, 
    int iStateId, 
    LPCRECT prcBase, 
    POINT *pptOffset)
{
    OFFSETTYPE eOffsetType;
    if (FAILED(GetThemeEnumValue(hTheme, iPartId, iStateId, TMT_OFFSETTYPE, (int *)&eOffsetType)))
        eOffsetType = OT_TOPLEFT;       // default value

    POINT ptOffset;
    if (FAILED(GetThemePosition(hTheme, iPartId, iStateId, TMT_OFFSET, &ptOffset)))
    {
        ptOffset.x = 0;
        ptOffset.y = 0;
    }

    RECT rcBase = *prcBase;

    switch (eOffsetType)
    {
        case OT_TOPLEFT:
            ptOffset.x += rcBase.left;
            ptOffset.y += rcBase.top;
            break;

        case OT_TOPRIGHT:
            ptOffset.x += rcBase.right;
            ptOffset.y += rcBase.top;
            break;

        case OT_TOPMIDDLE:
            ptOffset.x += (rcBase.left + rcBase.right)/2;
            ptOffset.y += rcBase.top;
            break;

        case OT_BOTTOMLEFT:
            ptOffset.x += rcBase.left;
            ptOffset.y += rcBase.bottom;
            break;

        case OT_BOTTOMRIGHT:
            ptOffset.x += rcBase.right;
            ptOffset.y += rcBase.bottom;
            break;

        case OT_BOTTOMMIDDLE:
            ptOffset.x += (rcBase.left + rcBase.right)/2;
            ptOffset.y += rcBase.bottom;
            break;

        // Todo: handle the remaining cases:
        case OT_LEFTOFCAPTION:
        case OT_RIGHTOFCAPTION:
        case OT_LEFTOFLASTBUTTON:
        case OT_RIGHTOFLASTBUTTON:
        case OT_ABOVELASTBUTTON:
        case OT_BELOWLASTBUTTON:
            ASSERT(FALSE);
            break;
    }

    *pptOffset = ptOffset;
}

//-------------------------------------------------------------------------//
//  _ComputeNcWindowStatus
//
//  Assigns and translates window status bits to/in NCWNDMET block.
//
void _ComputeNcWindowStatus( IN HWND hwnd, IN DWORD dwStatus, IN OUT NCWNDMET* pncwm )
{
    BOOL fActive = TESTFLAG( dwStatus, WS_ACTIVECAPTION );

    if (fActive || !HAS_CAPTIONBAR(pncwm->dwStyle) )
    {
        pncwm->framestate  = FS_ACTIVE;
    }
    else
    {
        pncwm->framestate  = FS_INACTIVE;
    }

    if( HAS_CAPTIONBAR(pncwm->dwStyle) )
    {
        pncwm->rgbCaption = _GetNcCaptionTextColor( pncwm->framestate );
    }
}

//-------------------------------------------------------------------------////
BOOL _GetWindowMetrics( HWND hwnd, IN OPTIONAL HWND hwndMDIActive, OUT NCWNDMET* pncwm )
{
    WINDOWINFO wi;
    wi.cbSize = sizeof(wi);
    if( GetWindowInfo( hwnd, &wi ) )
    {
        pncwm->dwStyle         = wi.dwStyle;
        pncwm->dwExStyle       = wi.dwExStyle;
        pncwm->rcS0[NCRC_WINDOW] = wi.rcWindow;
        pncwm->rcS0[NCRC_CLIENT] = wi.rcClient;

        pncwm->fMin   = IsIconic(hwnd);
        pncwm->fMaxed = IsZoomed(hwnd);
        pncwm->fFullMaxed = pncwm->fMaxed ? _IsFullMaximized(hwnd, &wi.rcWindow) : FALSE;

        pncwm->dwWindowStatus  = wi.dwWindowStatus;
        
        
        //  if this window is the active MDI child and is owned by the foreground window 
        //  (which may not be the case if a popup, for example, is foremost), then
        //  fix up the status bit.
        if( hwnd == hwndMDIActive )
        {
            HWND hwndFore = GetForegroundWindow();
            if( IsChild(hwndFore, hwndMDIActive) )
            {
                pncwm->dwWindowStatus = WS_ACTIVECAPTION;
            }
        }
        

        return TRUE;
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
BOOL _ShouldAssignFrameRgn( 
    IN const NCWNDMET* pncwm, 
    IN const NCTHEMEMET& nctm )
{
    if( TESTFLAG( CThemeWnd::EvaluateStyle(pncwm->dwStyle, pncwm->dwExStyle), TWCF_FRAME|TWCF_TOOLFRAME) )
    {
        //  always need window region for maximized windows.
        if( pncwm->fFullMaxed )
            return TRUE;

        //  otherwise, need region only if the background is transparent
        for( int i = 0; i < ARRAYSIZE( pncwm->rgframeparts ); i++ )
        {
            if( _IsNcPartTransparent( pncwm->rgframeparts[i], nctm ) )
                return TRUE;
        }
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
BOOL _IsNcPartTransparent( WINDOWPARTS part, const NCTHEMEMET& nctm )
{
    #define GET_NCTRANSPARENCY(part,field) \
        case part: return nctm.nct.##field
    
    switch(part)
    {
        GET_NCTRANSPARENCY(WP_CAPTION,          fCaption);
        GET_NCTRANSPARENCY(WP_SMALLCAPTION,     fCaption);
        GET_NCTRANSPARENCY(WP_MINCAPTION,       fMinCaption);
        GET_NCTRANSPARENCY(WP_SMALLMINCAPTION,  fSmallMinCaption);
        GET_NCTRANSPARENCY(WP_MAXCAPTION,       fMaxCaption);
        GET_NCTRANSPARENCY(WP_SMALLMAXCAPTION,  fSmallMaxCaption);
        GET_NCTRANSPARENCY(WP_FRAMELEFT,        fFrameLeft);
        GET_NCTRANSPARENCY(WP_FRAMERIGHT,       fFrameRight);
        GET_NCTRANSPARENCY(WP_FRAMEBOTTOM,      fFrameBottom);    
        GET_NCTRANSPARENCY(WP_SMALLFRAMELEFT,   fSmFrameLeft);
        GET_NCTRANSPARENCY(WP_SMALLFRAMERIGHT,  fSmFrameRight);
        GET_NCTRANSPARENCY(WP_SMALLFRAMEBOTTOM, fSmFrameBottom);    
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
BOOL _ComputeNcPartTransparency( HTHEME hTheme, IN OUT NCTHEMEMET* pnctm )
{
    #define TEST_NCTRANSPARENCY(part)   IsThemePartDefined(hTheme,part,0) ? \
        IsThemeBackgroundPartiallyTransparent(hTheme,part,FS_ACTIVE) : FALSE;
    
    pnctm->nct.fCaption         = TEST_NCTRANSPARENCY(WP_CAPTION);
    pnctm->nct.fSmallCaption    = TEST_NCTRANSPARENCY(WP_SMALLCAPTION);
    pnctm->nct.fMinCaption      = TEST_NCTRANSPARENCY(WP_MINCAPTION);
    pnctm->nct.fSmallMinCaption = TEST_NCTRANSPARENCY(WP_SMALLMINCAPTION);
    pnctm->nct.fMaxCaption      = TEST_NCTRANSPARENCY(WP_MAXCAPTION);
    pnctm->nct.fSmallMaxCaption = TEST_NCTRANSPARENCY(WP_SMALLMAXCAPTION);

    pnctm->nct.fFrameLeft       = TEST_NCTRANSPARENCY(WP_FRAMELEFT);
    pnctm->nct.fFrameRight      = TEST_NCTRANSPARENCY(WP_FRAMERIGHT);
    pnctm->nct.fFrameBottom     = TEST_NCTRANSPARENCY(WP_FRAMEBOTTOM);
    pnctm->nct.fSmFrameLeft     = TEST_NCTRANSPARENCY(WP_SMALLFRAMELEFT);
    pnctm->nct.fSmFrameRight    = TEST_NCTRANSPARENCY(WP_SMALLFRAMERIGHT);
    pnctm->nct.fSmFrameBottom   = TEST_NCTRANSPARENCY(WP_SMALLFRAMEBOTTOM);

    return TRUE;
}

//-------------------------------------------------------------------------//
//  NCTHEMEMET implementation
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
BOOL GetCurrentNcThemeMetrics( OUT NCTHEMEMET* pnctm )
{
    *pnctm = _nctmCurrent;
    return IsValidNcThemeMetrics( pnctm );
}

//-------------------------------------------------------------------------//
HTHEME GetCurrentNcThemeHandle()
{
    return _nctmCurrent.hTheme;
}

//-------------------------------------------------------------------------//
void InitNcThemeMetrics( NCTHEMEMET* pnctm )
{
    if( !pnctm )
        pnctm = &_nctmCurrent;

    ZeroMemory( pnctm, sizeof(*pnctm) );
}

//---------------------------------------------------------------------------
void ClearNcThemeMetrics( NCTHEMEMET* pnctm )
{
    if( !pnctm )
        pnctm = &_nctmCurrent;

    //---- minimize THREAD-UNSAFE access to _nctmCurrent by ----
    //---- NULL-ing out the hTheme type members as soon as ----
    //---- they are closed ----

    if( pnctm->hTheme )
    {
        CloseThemeData( pnctm->hTheme );
        pnctm->hTheme = NULL;
    }

    if( pnctm->hThemeTab )
    {
        CloseThemeData( pnctm->hThemeTab );
        pnctm->hThemeTab = NULL;
    }

    SAFE_DELETE_GDIOBJ( pnctm->hbmTabDialog );
    SAFE_DELETE_GDIOBJ( pnctm->hbrTabDialog );

    InitNcThemeMetrics( pnctm );
}

//-------------------------------------------------------------------------//
//  Computes process-global, per-theme metrics for the nonclient area theme.
HRESULT AcquireNcThemeMetrics()
{
    HRESULT hr = S_OK;

    EnterCriticalSection( &_csThemeMet );

    ClearNcThemeMetrics( &_nctmCurrent );
    NcGetNonclientMetrics( NULL, FALSE );
    hr = _LoadNcThemeMetrics(NULL, &_nctmCurrent);

    LeaveCriticalSection( &_csThemeMet );

    Log(LOG_TMCHANGE, L"AcquireNcThemeMetrics: got hTheme=0x%x", _nctmCurrent.hTheme);

    return hr;
}

//-------------------------------------------------------------------------//
//  Computes and/or loads per-theme (as opposed to per-window)
//  system metrics and resources not managed by the theme manager.
//  
//  Called by _LoadNcThemeMetrics
HRESULT _LoadNcThemeSysMetrics( HWND hwnd, IN OUT NCTHEMEMET* pnctm )
{
    HRESULT hr = E_FAIL;
    ASSERT(pnctm);

    //  grab system metrics for nonclient area.
    NONCLIENTMETRICS ncm = {0};
    ncm.cbSize = sizeof(ncm);
    if( NcGetNonclientMetrics( &ncm, FALSE ) )
    {
#ifdef THEMED_NCBTNMETRICS
        _GetClassicNcBtnMetrics( NULL, NULL, FALSE, TRUE );
#endif THEMED_NCBTNMETRICS

        hr = S_OK;

        //  Establish minimized window size
        if( 0 >= pnctm->sizeMinimized.cx )
            pnctm->sizeMinimized.cx = NcGetSystemMetrics( SM_CXMINIMIZED );
        if( 0 >= pnctm->sizeMinimized.cy )
            pnctm->sizeMinimized.cy = NcGetSystemMetrics( SM_CYMINIMIZED );
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        if( SUCCEEDED(hr) )
            hr = E_FAIL;
    }

    //  Maximized caption height or width
    pnctm->cyMaxCaption   = _GetRawClassicCaptionHeight( WS_CAPTION|WS_OVERLAPPED, 0 );

    return hr;
}

//-------------------------------------------------------------------------//
//  Computes and/or loads per-theme (as opposed to per-window)
//  metrics and resources not managed by the theme manager
HRESULT _LoadNcThemeMetrics( HWND hwnd, NCTHEMEMET* pnctm )
{
    HRESULT hr = E_FAIL;

    //  Initialize incoming NCTHEMEMET:
    if( pnctm )
    {
        InitNcThemeMetrics( pnctm );

        HTHEME hTheme = ::OpenNcThemeData( hwnd, L"Window" );
        if( hTheme )
        {
            pnctm->hTheme = hTheme;

            //  determine transparency for each frame part.
            _ComputeNcPartTransparency(hTheme, pnctm);

            //  menubar pixels not accounted for by CalcMenuBar or PaintMenuBar
            pnctm->dyMenuBar = NcGetSystemMetrics(SM_CYMENU) - NcGetSystemMetrics(SM_CYMENUSIZE);

            //  normal caption margins
            if( FAILED( GetThemeMargins( hTheme, NULL, WP_CAPTION, CS_ACTIVE, TMT_CAPTIONMARGINS,
                                          NULL, &pnctm->marCaptionText )) )
            {
                FillMemory( &pnctm->marCaptionText, sizeof(pnctm->marCaptionText), 0 );
            }

            //  maximized caption margins
            if( FAILED( GetThemeMargins( hTheme, NULL, WP_MAXCAPTION, CS_ACTIVE, TMT_CAPTIONMARGINS,
                                          NULL, &pnctm->marMaxCaptionText )) )
            {
                FillMemory( &pnctm->marMaxCaptionText, sizeof(pnctm->marMaxCaptionText), 0 );
            }

            //  minimized caption margins
            if( FAILED( GetThemeMargins( hTheme, NULL, WP_MINCAPTION, CS_ACTIVE, TMT_CAPTIONMARGINS,
                                          NULL, &pnctm->marMinCaptionText )) )
            {
                FillMemory( &pnctm->marMinCaptionText, sizeof(pnctm->marMinCaptionText), 0 );
            }


            //  dynamically resizing small (toolframe) caption margins
            if( FAILED( GetThemeMargins( hTheme, NULL, WP_SMALLCAPTION, CS_ACTIVE, TMT_CAPTIONMARGINS,
                                          NULL, &pnctm->marSmCaptionText )) )
            {
                FillMemory( &pnctm->marSmCaptionText, sizeof(pnctm->marSmCaptionText), 0 );
            }

            //  caption and frame resizing border hittest template parts
            pnctm->fCapSizingTemplate    = IsThemePartDefined( hTheme, WP_CAPTIONSIZINGTEMPLATE, 0);
            pnctm->fLeftSizingTemplate   = IsThemePartDefined( hTheme, WP_FRAMELEFTSIZINGTEMPLATE, 0);
            pnctm->fRightSizingTemplate  = IsThemePartDefined( hTheme, WP_FRAMERIGHTSIZINGTEMPLATE, 0);
            pnctm->fBottomSizingTemplate = IsThemePartDefined( hTheme, WP_FRAMEBOTTOMSIZINGTEMPLATE, 0);

            //  toolwindow caption and frame resizing border hittest template parts
            pnctm->fSmCapSizingTemplate    = IsThemePartDefined( hTheme, WP_SMALLCAPTIONSIZINGTEMPLATE, 0);
            pnctm->fSmLeftSizingTemplate   = IsThemePartDefined( hTheme, WP_SMALLFRAMELEFTSIZINGTEMPLATE, 0);
            pnctm->fSmRightSizingTemplate  = IsThemePartDefined( hTheme, WP_SMALLFRAMERIGHTSIZINGTEMPLATE, 0);
            pnctm->fSmBottomSizingTemplate = IsThemePartDefined( hTheme, WP_SMALLFRAMEBOTTOMSIZINGTEMPLATE, 0);

            //  Minimized window size.
            //  If this is a truesize image, honor its dimensions; otherwise use
            //  width, height properties.  Fall back on system metrics.
            SIZINGTYPE st = ST_TRUESIZE;
            hr = GetThemeInt( hTheme, WP_MINCAPTION, FS_ACTIVE, TMT_SIZINGTYPE, (int*)&st );

            if( ST_TRUESIZE == st )
            {
                hr = GetThemePartSize( hTheme, NULL, WP_MINCAPTION, FS_ACTIVE, NULL, 
                                       TS_TRUE, &pnctm->sizeMinimized );

                if( FAILED(hr) )
                {
                    GetThemeMetric( hTheme, NULL, WP_MINCAPTION, FS_ACTIVE, TMT_WIDTH,
                                    (int*)&pnctm->sizeMinimized.cx );
                    GetThemeMetric( hTheme, NULL, WP_MINCAPTION, FS_ACTIVE, TMT_HEIGHT,
                                    (int*)&pnctm->sizeMinimized.cy );
                }
            }

            //  -- normal nonclient button size.
            int cy = NcGetSystemMetrics( SM_CYSIZE );
            hr = GetThemePartSize( pnctm->hTheme, NULL, WP_CLOSEBUTTON, 0, NULL, TS_TRUE, &pnctm->sizeBtn );
            if( SUCCEEDED(hr) )
            {
                pnctm->theme_sysmets.cxBtn = MulDiv( cy, pnctm->sizeBtn.cx, pnctm->sizeBtn.cy );
            }
            else
            {
                pnctm->theme_sysmets.cxBtn = 
                pnctm->sizeBtn.cx = NcGetSystemMetrics( SM_CXSIZE );
                
                pnctm->sizeBtn.cy = cy;
            }
          
            //  -- toolframe nonclient button size.
            cy = NcGetSystemMetrics( SM_CYSMSIZE );
            hr = GetThemePartSize( pnctm->hTheme, NULL, WP_SMALLCLOSEBUTTON, 0, NULL, TS_TRUE, &pnctm->sizeSmBtn );
            if( SUCCEEDED(hr) )
            {
                pnctm->theme_sysmets.cxSmBtn = MulDiv( cy, pnctm->sizeSmBtn.cx, pnctm->sizeSmBtn.cy );
            }
            else
            {
                pnctm->theme_sysmets.cxSmBtn = 
                pnctm->sizeSmBtn.cx = NcGetSystemMetrics( SM_CXSMSIZE );

                pnctm->sizeSmBtn.cy = cy;
            }
            
            //  -- validate sysmet hook values
            pnctm->theme_sysmets.fValid = TRUE;

            //  dialog background for dialogs parented by PROPSHEETs or
            //  specifically stamped via EnableThemeDialogTexture to match the tab control background.
            //
            // We need to open the tab control's theme so that we can get the background of tab dialogs
            // We can't dynamically load this because of how this cache is set up: It's all or nothing.
            pnctm->hThemeTab = ::OpenThemeData(hwnd, L"Tab");
            _GetBrushesForPart(pnctm->hThemeTab, TABP_BODY, &pnctm->hbmTabDialog, &pnctm->hbrTabDialog);

            hr = _LoadNcThemeSysMetrics( hwnd, pnctm );
        }
    }

    return hr;
}

//-------------------------------------------------------------------------//
BOOL IsValidNcThemeMetrics( NCTHEMEMET* pnctm )
{
    return pnctm->hTheme != NULL;
}

//-------------------------------------------------------------------------//
//  THREADWINDOW implementation
//-------------------------------------------------------------------------//
//
//  Note: this is a fixed length array of threads-window mappings.
//  We'll use this to keep track of the threads processing a certain message
//
//  Thread local storage would be better suited to the task, but we
//  learned early on that the unique load/unload situation of uxtheme
//  causes us to miss DLL_THREAD_DETACH in some scenarios, which would mean
//  leaking the TLS.
//

typedef struct _THREADWINDOW
{
    DWORD dwThread;
    HWND  hwnd;

} THREADWINDOW;

//-------------------------------------------------------------------------//
//  WM_NCPAINT tracking:
THREADWINDOW _rgtwNcPaint[16] = {0}; // threads processing NCPAINT in this process
int          _cNcPaintWnd = 0;       // count of threads processing NCPAINT in this process
CRITICAL_SECTION _csNcPaint;         // serializes access to _rgtwNcPaint

//-------------------------------------------------------------------------//
void NcPaintWindow_Add( HWND hwnd )
{
    EnterCriticalSection( &_csNcPaint );
    for( int i = 0; i < ARRAYSIZE(_rgtwNcPaint); i++ )
    {
        if( 0 == _rgtwNcPaint[i].dwThread )
        {
            _rgtwNcPaint[i].dwThread = GetCurrentThreadId();
            _rgtwNcPaint[i].hwnd = hwnd;
            _cNcPaintWnd++;
        }
    }
    LeaveCriticalSection( &_csNcPaint );
}

//-------------------------------------------------------------------------//
void NcPaintWindow_Remove()
{
    if( _cNcPaintWnd )
    {
        DWORD dwThread = GetCurrentThreadId();
        EnterCriticalSection( &_csNcPaint );
        for( int i = 0; i < ARRAYSIZE(_rgtwNcPaint); i++ )
        {
            if( dwThread == _rgtwNcPaint[i].dwThread )
            {
                _rgtwNcPaint[i].dwThread = 0;
                _rgtwNcPaint[i].hwnd = 0;
                _cNcPaintWnd--;
                break;
            }
        }  
        LeaveCriticalSection( &_csNcPaint );
    }
}

//-------------------------------------------------------------------------//
HWND NcPaintWindow_Find()
{
    HWND  hwnd = NULL;

    if( _cNcPaintWnd )
    {
        DWORD dwThread = GetCurrentThreadId();

        EnterCriticalSection( &_csNcPaint );
        for( int i = 0; i < ARRAYSIZE(_rgtwNcPaint); i++ )
        {
            if( dwThread == _rgtwNcPaint[i].dwThread )
            {
                hwnd = _rgtwNcPaint[i].hwnd;
                break;
            }
        }
        LeaveCriticalSection( &_csNcPaint );
    }
    return hwnd;
}

//-------------------------------------------------------------------------//
//  CThemeWnd implementation
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
LONG CThemeWnd::_cObj = 0;

//-------------------------------------------------------------------------//
CThemeWnd::CThemeWnd()
    :   _hwnd(NULL),
        _hTheme(NULL),
        _dwRenderedNcParts(0),
        _hwndMDIClient(NULL),
        _hAppIcon(NULL),
        _hrgnWnd(NULL),
        _fClassFlags(0),
        _fDirtyFrameRgn(0),
        _fFrameThemed(FALSE),
        _fThemedMDIBtns(FALSE),
        _pMdiBtns(NULL),
        _fAssigningFrameRgn(FALSE),
        _fAssignedFrameRgn(FALSE),
        _fSuppressStyleMsgs(FALSE),
        _fInThemeSettingChange(FALSE),
        _fDetached(FALSE),
        _fCritSectsInit(FALSE),
        _dwRevokeFlags(0),
        _cLockRedraw(0),
        _cNcPaint(0),
        _cNcThemePaint(0),
        _htHot(HTERROR),
        _fProcessedEraseBk(0),
#ifdef LAME_BUTTON
        _hFontLame(NULL),
#endif // LAME_BUTTON
#ifdef DEBUG_THEMEWND_DESTRUCTOR
        _fDestructed(FALSE),
        _fDeleteCritsec(FALSE),
#endif DEBUG_THEMEWND_DESTRUCTOR
        _cRef(1)
{
    InterlockedIncrement( &_cObj );

    //  set object validation signature tags
    strcpy(_szHead, SIG_CTHEMEWND_HEAD); 
    strcpy(_szTail, SIG_CTHEMEWND_TAIL);

    //  cached subregion arrays
    ZeroMemory( _rghrgnParts, sizeof(_rghrgnParts) );
    ZeroMemory( _rghrgnSizingTemplates, sizeof(_rghrgnSizingTemplates) );
    
    //  initialize add'l structures.
    InitWindowMetrics();
    FillMemory(&_sizeRgn, sizeof(_sizeRgn), 0xFF);

#ifdef DEBUG
    *_szCaption = *_szWndClass = 0;
#endif DEBUG
}

//-------------------------------------------------------------------------//
CThemeWnd::~CThemeWnd()
{
    _CloseTheme();
    _FreeRegionHandles();
    UnloadMdiBtns();
    ClearLameResources();

    if( _fCritSectsInit )
    {
        DeleteCriticalSection( &_cswm );
#ifdef DEBUG_THEMEWND_DESTRUCTOR
        _fDeleteCritsec = TRUE;
#endif DEBUG_THEMEWND_DESTRUCTOR
    }
    InterlockedDecrement( &_cObj );

#ifdef DEBUG_THEMEWND_DESTRUCTOR
    _fDestructed = TRUE;       // destructor has been called.
#endif DEBUG_THEMEWND_DESTRUCTOR
}

//-------------------------------------------------------------------------//
void CThemeWnd::_CloseTheme()
{
    if( _hTheme )
    {
        CloseThemeData(_hTheme);
        _hTheme = NULL;
    }
}    

//-------------------------------------------------------------------------//
LONG CThemeWnd::AddRef()
{
    return InterlockedIncrement( &_cRef );
}

//-------------------------------------------------------------------------//
LONG CThemeWnd::Release()
{
    LONG cRef = InterlockedDecrement( &_cRef );

    if( 0 == cRef )
    {
        if (_hwnd)
        {
            //---- check if last window of app ----
            ShutDownCheck(_hwnd);
        }

        //Log(LOG_RFBUG, L"DELETING CThemeWnd=0x%08x", this);
        delete this;
    }
    return cRef;
}

//-------------------------------------------------------------------------//
ULONG CThemeWnd::EvaluateWindowStyle( HWND hwnd )
{
    ULONG dwStyle   = GetWindowLong( hwnd, GWL_STYLE );
    ULONG dwExStyle = GetWindowLong( hwnd, GWL_EXSTYLE );

    return EvaluateStyle( dwStyle, dwExStyle );
}

//-------------------------------------------------------------------------//
//  CThemeWnd::EvaluateStyle() - determines appropriate theming flags for the
//  specified window style bits.
ULONG CThemeWnd::EvaluateStyle( DWORD dwStyle, DWORD dwExStyle )
{
    ULONG fClassFlags = 0;

    //--- frame check ---
    if( HAS_CAPTIONBAR(dwStyle) )
    {
        fClassFlags |=
            (TESTFLAG(dwExStyle, WS_EX_TOOLWINDOW) ? TWCF_TOOLFRAME : TWCF_FRAME );
    }

    //--- client edge check ---
    if( TESTFLAG(dwExStyle, WS_EX_CLIENTEDGE) )
        fClassFlags |= TWCF_CLIENTEDGE;

    //--- scrollbar check ---
    if( TESTFLAG(dwStyle, WS_HSCROLL|WS_VSCROLL) )
        fClassFlags |= TWCF_SCROLLBARS;

    return fClassFlags;
}

//-------------------------------------------------------------------------//
//  CThemeWnd::_EvaluateExclusions() - determines special-case per-window exclusions
ULONG CThemeWnd::_EvaluateExclusions( HWND hwnd, NCEVALUATE* pnce )
{
    //  Windows parented by HWND_MESSAGE should not be themed..
    if( _IsMessageWindow(hwnd) )
    {
        pnce->fExile = TRUE;
        return 0L;
    }

    TCHAR szWndClass[128];
    *szWndClass = 0;


    if( TESTFLAG(pnce->fClassFlags, (TWCF_FRAME|TWCF_TOOLFRAME)) )
    {
        do
        {
            if( !pnce->fIgnoreWndRgn )
            {
                //--- Complex region check on frame
                RECT rcRgn = {0};
                int  nRgn = GetWindowRgnBox( hwnd, &rcRgn );
                if( COMPLEXREGION == nRgn || SIMPLEREGION == nRgn )
                {
                    pnce->fClassFlags &= ~TWCF_FRAME;
                    break;
                }
            }

//  SHIMSHIM [scotthan]:
#ifndef __NO_APPHACKS__
            //  Check for excluded window classes.
            static LPCWSTR _rgExcludedClassesW[]  = 
            { 
                L"MsoCommandBar",   //  Outlook's custom combobox control.
                                    // (122225) In OnOwpPostCreate we call SetWindowPos which causes
                                    // a WM_WINDOWPOSCHANGING to be sent to the control. However
                                    // the controls isn't ready to begin accepting messages and
                                    // the following error message is display:
                                    //
                                    // Runtime Error!
                                    // Program: Outlook.exe
                                    // R6025 - pure virtual function call

                L"Exceed",          // 150248: Hummingbird Exceed 6.xx 
                                    // The application's main window class name, a hidden window 
                                    // whose only purpose is to appear in the task bar in order to handle
                                    // his context menu. The ExceedWndProc AVs when themed due to the
                                    // additional messages generated in OnOwpPostCreate.

                //---- winlogoon hidden windows ----
                L"NDDEAgnt",            // on private desktop
                L"MM Notify Callback",  // on private desktop
                L"SAS window class",    // on private desktop
            };

            if( GetClassNameW( hwnd, szWndClass, ARRAYSIZE(szWndClass) )  &&
                AsciiScanStringList( szWndClass, _rgExcludedClassesW, 
                                ARRAYSIZE(_rgExcludedClassesW), TRUE ) )
            {
                pnce->fClassFlags &= ~TWCF_FRAME;
                pnce->fExile = TRUE;
                break;
            }
#endif __NO_APPHACKS__
        
        } while(0);
    }

    // Some applications (MsDev) create scrollbar controls and incorrectly include
    // WS_[V|H]SCROLL style bits causing us to think they are non-client scrolls. 
    // See #204191.
    if( TESTFLAG(pnce->fClassFlags, TWCF_SCROLLBARS) )
    {
        if( !*szWndClass && GetClassName( hwnd, szWndClass, ARRAYSIZE(szWndClass) ) )
        {
            if( 0 == AsciiStrCmpI(szWndClass, L"scrollbar") )
                pnce->fClassFlags &= ~TWCF_SCROLLBARS;
        }
    }

    return pnce->fClassFlags;

}

//-------------------------------------------------------------------------//
//  CThemeWnd::_Evaluate() - determines appropriate theming flags for the
//  specified window.
ULONG CThemeWnd::_Evaluate( HWND hwnd, NCEVALUATE* pnce )
{
    pnce->fClassFlags = 0;
    pnce->dwStyle   = GetWindowLong( hwnd, GWL_STYLE );
    pnce->dwExStyle = GetWindowLong( hwnd, GWL_EXSTYLE );

    if( GetClassLong( hwnd, GCW_ATOM ) == (DWORD)(DWORD_PTR)WC_DIALOG )
    {
        pnce->fClassFlags |= TWCF_DIALOG;
    }
    

#ifdef DEBUG
    //--- dialog check ---
    if( TESTFLAG( pnce->fClassFlags, TWCF_DIALOG ) )
    {
        TCHAR szWndClass[96];
        if( !GetClassNameW( hwnd, szWndClass, ARRAYSIZE(szWndClass) ) )
            return 0;
        ASSERT(0 == lstrcmpW(szWndClass, DLGWNDCLASSNAMEW));
    }
#endif DEBUG

    pnce->fClassFlags |= EvaluateStyle( pnce->dwStyle, pnce->dwExStyle );

    if( pnce->fClassFlags )
    {
        pnce->fClassFlags = _EvaluateExclusions( hwnd, pnce );
    }

    return pnce->fClassFlags;
}

//-------------------------------------------------------------------------//
//  Retrieves the address of the CThemeWnd object instance from the
//  indicated window.
CThemeWnd* CThemeWnd::FromHwnd( HWND hwnd )
{
    CThemeWnd *pwnd = NULL;

    if( IsWindow(hwnd) )
    {
        if( g_dwProcessId )
        {
            DWORD dwPid = 0;
            GetWindowThreadProcessId( hwnd, &dwPid );
            if( dwPid == g_dwProcessId )
            {
                pwnd = (CThemeWnd*)GetProp( hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_NONCLIENT)) );

                if ( VALID_THEMEWND(pwnd) )
                {
                    // verify this is a valid CThemeWnd object pointer
                    if ( IsBadReadPtr(pwnd, sizeof(CThemeWnd)) ||
                         (memcmp(pwnd->_szHead, SIG_CTHEMEWND_HEAD, ARRAYSIZE(pwnd->_szHead)) != 0) ||
                         (memcmp(pwnd->_szTail, SIG_CTHEMEWND_TAIL, ARRAYSIZE(pwnd->_szTail)) != 0) )
                    {
                        pwnd = THEMEWND_REJECT;
                    }
                }
            }
        }
    }

    return pwnd;
}

//-------------------------------------------------------------------------//
//  retrieves CThemeWnd instance from window or ancestors.
CThemeWnd* CThemeWnd::FromHdc( HDC hdc, int cAncestors )
{
    HWND hwnd = NULL;

    for( hwnd = WindowFromDC(hdc); 
         cAncestors >=0 && IsWindow(hwnd); 
         cAncestors--, hwnd = GetParent(hwnd) )
    {
        CThemeWnd* pwnd = FromHwnd(hwnd);
        if( VALID_THEMEWND(pwnd) )
        {
            return pwnd;
        }
    }

    return NULL;
}

//-------------------------------------------------------------------------//
//  Static wrapper: attaches a CThemeWnd instance to the specified window.
CThemeWnd* CThemeWnd::Attach( HWND hwnd, IN OUT OPTIONAL NCEVALUATE* pnce )
{
    LogEntryNC(L"Attach");

#ifdef LOGGING
    //---- remember first window (app window) hooked for ShutDownCheck() ----
    //---- this is only for BoundsChecker (tm) runs for finding leaks ----
    if (! g_hwndFirstHooked)
    {
        if ((GetMenu(hwnd)) && (! GetParent(hwnd)))
            g_hwndFirstHooked = hwnd;
    }
#endif

    CThemeWnd* pwnd = NULL;

    //  Note: Important not to do anything here that causes
    //  a window message to be posted or sent to the window: could
    //  mean tying ourselves up in a recursive knot (see _ThemeDefWindowProc).

    pwnd = FromHwnd( hwnd );

    if( NULL == pwnd )
    {
        HTHEME hTheme = NULL;
        NCEVALUATE nce;

        //  copy any IN params from NCEVALUATE struct
        if( !pnce )
        {
            ZeroMemory(&nce, sizeof(nce));
            pnce = &nce;
        }

        ULONG  ulTargetFlags = _Evaluate( hwnd, pnce );

        //  Anything worth theming?
        if( TESTFLAG(ulTargetFlags, TWCF_NCTHEMETARGETMASK) )
        {
            hTheme = _AcquireThemeHandle( hwnd, &ulTargetFlags );
            if( NULL == hTheme )
            {
                Fail(hwnd);
            }
        }
        else
        {
            //  reject windows with untargeted a
            Reject(hwnd, pnce->fExile);
        }

        if( NULL != hTheme )
        {
            //  Yes, create a real nctheme object for the window
            if( (pwnd = new CThemeWnd) != NULL )
            {
                if( !pwnd->_AttachInstance( hwnd, hTheme, ulTargetFlags, pnce->pvWndCompat ) )
                {
                    pwnd->Release();
                    pwnd = NULL;
                }
            }
            else        // cleanup hTheme if CThemeWnd creation failed
            {
                CloseThemeData(hTheme);
            }
        }
    }

    LogExitNC(L"Attach");
    return pwnd;
}

//-------------------------------------------------------------------------//
//  Instance method: attaches the CThemeWnd object to the specified window.
BOOL CThemeWnd::_AttachInstance( HWND hwnd, HTHEME hTheme, ULONG ulTargetFlags, PVOID pvWndCompat )
{
    if( _fCritSectsInit || NT_SUCCESS(RtlInitializeCriticalSection( &_cswm )) )
    {
        Log(LOG_NCATTACH, L"_AttachInstance: Nonclient attached to hwnd=0x%x", hwnd);

        _fCritSectsInit = TRUE;
        _hwnd   = hwnd;
        _hTheme = hTheme;
        _fClassFlags = ulTargetFlags;

        _fFrameThemed = TESTFLAG( ulTargetFlags, TWCF_FRAME|TWCF_TOOLFRAME );
        return SetProp( hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_NONCLIENT)), this );
    }

    return FALSE;
}

//-------------------------------------------------------------------------//
void CThemeWnd::RemoveWindowProperties(HWND hwnd, BOOL fDestroying)
{
    //---- remove properties that require theme or hooks ----
    RemoveProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_HTHEME)));

    if (fDestroying)
    {
        // Help apps by cleaning up the dialog texture.
        RemoveProp(hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_DLGTEXTURING)));

        //---- remove all remaining theme properties ----
        ApplyStringProp(hwnd, NULL, GetThemeAtom(THEMEATOM_SUBIDLIST));
        ApplyStringProp(hwnd, NULL, GetThemeAtom(THEMEATOM_SUBAPPNAME));

        //---- notify appinfo (foreign tracking, preview) ----
        g_pAppInfo->OnWindowDestroyed(hwnd);
    }
    else
    {
        //---- only do this if hwnd is not being destroyed ----
        ClearExStyleBits(hwnd);
    }
}
//-------------------------------------------------------------------------//
//  Static wrapper: detaches and destroys the CThemeWnd instance attached to the indicated
//  window
void CThemeWnd::Detach( HWND hwnd, DWORD dwDisposition )
{
    LogEntryNC(L"Detach");

    //  DO NOT GENERATE ANY WINDOW MESSAGES FROM THIS FUNCTION!!!
    //  (unless cleaning up frame).

    //  Prevent message threads from detaching when unhook thread (DetachAll) is executing...
    if( !UNHOOKING() || TESTFLAG(dwDisposition, HMD_BULKDETACH) )
    {
        CThemeWnd* pwnd = FromHwnd( hwnd );

        if( pwnd ) // nonclient tagged
        {
            if( VALID_THEMEWND(pwnd) )
            {
                //  only one thread flips the _fDetached bit and proceeds through
                //  instance detatch and object free.   Otherwise, object can be freed
                //  simultaneously on two different threads, 
                //  e.g. (1) message thread and (2) UIAH_UNHOOK thread (ouch! scotthan).
                if( !InterlockedCompareExchange( (LONG*)&pwnd->_fDetached, TRUE, FALSE ) )
                {
                    pwnd->_DetachInstance( dwDisposition );
                    pwnd->Release();
                }
            }
            else
            {
                RemoveProp( hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_NONCLIENT)) );
            }
        }

        if (hwnd)
        {
            RemoveWindowProperties( hwnd, ((dwDisposition & HMD_WINDOWDESTROY) != 0) );
        }
    }

    LogExitNC(L"Detach");
}

//-------------------------------------------------------------------------//
//  Instance method: detaches the CThemeWnd object from the specified window.
BOOL CThemeWnd::_DetachInstance( DWORD dwDisposition )
{
    HWND hwnd = _hwnd;

    //  untheme maxed MDI child sysbuttons.
    ThemeMDIMenuButtons(FALSE, FALSE);

    //  Here's our last chance to ensure frame theme is withdrawn cleanly.
    if( (IsFrameThemed() || IsRevoked(RF_REGION)) && AssignedFrameRgn() && 
        !TESTFLAG(dwDisposition, HMD_PROCESSDETACH|HMD_WINDOWDESTROY))
    {
        RemoveFrameTheme( FTF_REDRAW );
    }

    //SPEW_THEMEWND( pwnd, 0, TEXT("UxTheme - Detaching and deleting themewnd: %s\n") );
    DetachScrollBars( hwnd );

    _hwnd = 
    _hwndMDIClient = NULL;

    UnloadMdiBtns();

    _CloseTheme();

    Log(LOG_NCATTACH, L"_DetachInstance: Nonclient detached to hwnd=0x%x", hwnd);

    RemoveProp( hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_NONCLIENT)) );
    return TRUE;
}

//-------------------------------------------------------------------------//
// Ensures that the specified window will not be themed during its lifetime
BOOL CThemeWnd::Reject( HWND hwnd, BOOL fExile )
{
    //  set a 'nil' tag on the window
    return hwnd ? SetProp( hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_NONCLIENT)), 
                           fExile ? THEMEWND_EXILE : THEMEWND_REJECT ) : FALSE;
}

//-------------------------------------------------------------------------//
// Ensures that the specified window will not be themed during its lifetime
BOOL CThemeWnd::Fail( HWND hwnd )
{
    //  set a failure tag on the window
    return hwnd ? SetProp( hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_NONCLIENT)), 
                           THEMEWND_FAILURE ) : FALSE;
}

//-------------------------------------------------------------------------//
// Revokes theming on a themed window
BOOL CThemeWnd::Revoke()
{
    //  Warning Will Robinson:  After we detach, the CThemeWnd::_hwnd
    //  and related members will be reset, so save this on the stack.

    BOOL fRet = TRUE;
    HWND hwnd = _hwnd;

    if( !IsRevoked(RF_INREVOKE) )
    {
        EnterRevoke();
        _dwRevokeFlags &= ~RF_DEFER;
        Detach( hwnd, HMD_REVOKE );
        fRet = Reject( hwnd, TRUE );
        LeaveRevoke();
    }
    return fRet;
}

//-------------------------------------------------------------------------//
//  cookie passed to EnumChildWindows callback for CThemeWnd::DetachAll
typedef struct 
{
    DWORD dwProcessId;
    DWORD dwDisposition;
}DETACHALL;

//-------------------------------------------------------------------------//
//  EnumChildWindows callback for CThemeWnd::DetachAll
BOOL CThemeWnd::_DetachDesktopWindowsCB( HWND hwnd, LPARAM lParam )
{
    DETACHALL* pda = (DETACHALL*)lParam;

    //  detach this window
    if( IsWindowProcess( hwnd, pda->dwProcessId ) )
    {
        //---- clear the nonclient theme ----
        CThemeWnd::Detach(hwnd, HMD_THEMEDETACH|pda->dwDisposition);

        if( !TESTFLAG(pda->dwDisposition, HMD_PROCESSDETACH) )
        {
            //---- clear the client theme now, so that we can invalidate ----
            //---- all old theme handles after this.  ----
            SafeSendMessage(hwnd, WM_THEMECHANGED, (WPARAM)-1, 0);

            Log(LOG_TMHANDLE, L"Did SEND of WM_THEMECHANGED to client hwnd=0x%x", hwnd);
        }
    }

    return TRUE;
}

//-------------------------------------------------------------------------//
//  Detaches all themed windows managed by this process.
void CThemeWnd::DetachAll( DWORD dwDisposition )
{
    DETACHALL da;
    da.dwProcessId   = GetCurrentProcessId();
    da.dwDisposition = dwDisposition;
    da.dwDisposition |= HMD_BULKDETACH;

    //---- this will enum all windows for this process (all desktops, all child levels) ----
    EnumProcessWindows( _DetachDesktopWindowsCB, (LPARAM)&da );
}

//-------------------------------------------------------------------------//
HTHEME CThemeWnd::_AcquireThemeHandle( HWND hwnd, ULONG* pfClassFlags  )
{
    HTHEME hTheme = ::OpenNcThemeData( hwnd, L"Window" );

    if( NULL == hTheme )
    {
        if( pfClassFlags )
        {
            if( TESTFLAG(*pfClassFlags, TWCF_ANY) )
                (*pfClassFlags) &= ~TWCF_ALL;
            else
                *pfClassFlags = 0;
        }
    }

    //---- Did OpenNcThemeData() discover a new theme ----
    if (g_pAppInfo->HasThemeChanged())
    {
        //---- IMPORTANT: we must refresh our theme metrics now, ----
        //---- BEFORE we do our nonclient layout calcs & build a region window ----
        AcquireNcThemeMetrics();
    }

    return hTheme;
}

//-------------------------------------------------------------------------//
//  CThemeWnd::SetFrameTheme
//
//  Initiates theming of the frame.
void CThemeWnd::SetFrameTheme( 
    IN ULONG dwFlags,
    IN OPTIONAL WINDOWINFO* pwi )
{
    LogEntryNC(L"SetFrameTheme");

    ASSERT(TestCF( TWCF_FRAME|TWCF_TOOLFRAME ));
    InitLameResources();

    DWORD fSwp = SWP_NOZORDER|SWP_NOACTIVATE;
    RECT  rcWnd = {0};
    BOOL  bSwp = FALSE;

    if( !TESTFLAG( dwFlags, FTF_NOMODIFYPLACEMENT ) )
    {
        GetWindowRect( _hwnd, &rcWnd );
        fSwp |= (SWP_NOSIZE|SWP_NOMOVE/*|SWP_FRAMECHANGED 341700: this flag causes some apps to crash on WINDOWPOSCHANGED*/);
        bSwp = TRUE;
    }

    //  Generate a WM_WINDOWPOSCHANGING message to
    //  force a SetWindowRgn + frame repaint.
    if( TESTFLAG(dwFlags, FTF_REDRAW) )
    {
        fSwp |= SWP_DRAWFRAME;
    }
    else
    {
        fSwp |= SWP_NOSENDCHANGING;
    }

    //  theme MDI menubar buttons
    _hwndMDIClient = _FindMDIClient(_hwnd);
    if( _hwndMDIClient )
    {
        ThemeMDIMenuButtons(TRUE, FALSE);
    }

    //  Kick frame region update.
    _fFrameThemed = TRUE;         // we invoked SetFrameTheme.  Must be set BEFORE SetWindowPos.so we handle NCCALCSIZE properly.
    SetDirtyFrameRgn(TRUE, TRUE); // ensure region assembly on non-resizing windows and dlgs.

    if( !TESTFLAG( dwFlags, FTF_NOMODIFYPLACEMENT ) && bSwp )
    {
        _ScreenToParent( _hwnd, &rcWnd );
        SetWindowPos( _hwnd, NULL, rcWnd.left, rcWnd.top,
                      RECTWIDTH(&rcWnd), RECTHEIGHT(&rcWnd), fSwp );
    }

    LogExitNC(L"SetFrameTheme");
}

//-------------------------------------------------------------------------//
void CThemeWnd::_FreeRegionHandles() 
{ 
#ifdef DEBUG
    if( _hrgnWnd )
    {
        SPEW_RGNRECT(NCTF_RGNWND, TEXT("_FreeRegionHandles() - deleting window region"), _hrgnWnd, -1 );
    }
#endif DEBUG

    SAFE_DELETE_GDIOBJ(_hrgnWnd);

    for( int i = 0; i < cFRAMEPARTS; i++ )
    {
#ifdef DEBUG
        if( _rghrgnParts[i] )
        {
            SPEW_RGNRECT(NCTF_RGNWND, TEXT("_FreeRegionHandles() - deleting component region"), _rghrgnParts[i], _ncwm.rgframeparts[i] );
        }

        if( _rghrgnSizingTemplates[i] )
        {
            SPEW_RGNRECT(NCTF_RGNWND, TEXT("_FreeRegionHandles() - deleting template region"), _rghrgnSizingTemplates[i], _ncwm.rgframeparts[i] );
        }
#endif DEBUG

        SAFE_DELETE_GDIOBJ(_rghrgnParts[i]);
        SAFE_DELETE_GDIOBJ(_rghrgnSizingTemplates[i]);
    }
}

//-------------------------------------------------------------------------//
//  CThemeWnd::RemoveFrameTheme
//
//  Initiates theming of the frame.    This method will not free the
//  theme handle nor update the theme index.
void CThemeWnd::RemoveFrameTheme( ULONG dwFlags )
{
    LogEntryNC(L"RemoveFrameTheme");

    ASSERT(TestCF( TWCF_FRAME|TWCF_TOOLFRAME ));

    _fFrameThemed = FALSE; // we're reverting SetFrameTheme
    ClearRenderedNcPart(RNCF_ALL);

    //  Remove region
    if( AssignedFrameRgn() && !TESTFLAG(dwFlags, FTF_NOMODIFYRGN) )
    {
        _fAssignedFrameRgn = FALSE;
        _AssignRgn( NULL, dwFlags );
        _FreeRegionHandles();
    }

    //  Force redraw
    if( TESTFLAG(dwFlags, FTF_REDRAW) )
        InvalidateRect( _hwnd, NULL, TRUE );

    ClearLameResources();

    LogExitNC(L"RemoveFrameTheme");
}

//-------------------------------------------------------------------------//
BOOL CThemeWnd::IsNcThemed()
{
    if( _hTheme != NULL && (IsRevoked(RF_DEFER) || !IsRevoked(RF_INREVOKE|RF_TYPEMASK)) &&
        TestCF(TWCF_ANY & TWCF_NCTHEMETARGETMASK) )
    {
        if( TestCF(TWCF_FRAME|TWCF_TOOLFRAME) )
        {
            //  if we're a frame window, we should be properly initialized
            //  w/ SetFrameTheme()
            return _fFrameThemed;
        }

        return TRUE;
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
BOOL CThemeWnd::IsFrameThemed()
{
    return IsNcThemed() && _fFrameThemed &&
           (AssignedFrameRgn() ? TRUE : TestCF( TWCF_FRAME|TWCF_TOOLFRAME ));
}

//-------------------------------------------------------------------------//
void CThemeWnd::SetDirtyFrameRgn( BOOL fDirty, BOOL fFrameChanged )
{ 
    _fDirtyFrameRgn = fDirty; 

    Log(LOG_NCATTACH, L"SetDirtyFrameRgn: fDirty=%d, fFrameChanged=%d", 
        fDirty, fFrameChanged);
    
    if( fFrameChanged )  // assure a region update despite no size change.
    {
        _sizeRgn.cx = _sizeRgn.cy = -1; 
    }
}

//-------------------------------------------------------------------------//
//  CThemeWnd::CreateCompositeRgn() - assembles a composite region from
//  non-client segment regions sized to fill the specified window rectangle.
//
HRGN CThemeWnd::CreateCompositeRgn( 
    IN const NCWNDMET* pncwm,
    OUT HRGN rghrgnParts[],
    OUT HRGN rghrgnTemplates[] )
{
    ASSERT( pncwm->fFrame == TRUE ); // shouldn't be here unless we're a frame window

    HRGN hrgnWnd = NULL, hrgnContent = NULL;
    HRGN rghrgn[cFRAMEPARTS] = {0};
    int  i;

    if( pncwm->fFullMaxed )
    {
        //  All full-screen maximized windows get a region, which is used to clip
        //  the window to the current monitor.   The window region for a maximized
        //  window consists of the maxcaption region combined with a rect region
        //  corresponding to the content area.
        RECT rcFullCaption  = pncwm->rcW0[NCRC_CAPTION];
        rcFullCaption.top   += pncwm->cnBorders;
        rcFullCaption.left  += pncwm->cnBorders;
        rcFullCaption.right -= pncwm->cnBorders;
        
        if( SUCCEEDED(GetThemeBackgroundRegion(_hTheme, NULL, pncwm->rgframeparts[iCAPTION], pncwm->framestate,
                                               &rcFullCaption, &rghrgn[iCAPTION])) )
        {
            SPEW_RGNRECT(NCTF_RGNWND, TEXT("CreateCompositeRgn() maximized caption rgn"), rghrgn[iCAPTION], pncwm->rgframeparts[iCAPTION] );
            AddToCompositeRgn(&hrgnWnd, rghrgn[iCAPTION], 0, 0);
        
            if( !IsRectEmpty( &pncwm->rcW0[NCRC_CONTENT] ) )
            {
                //  remainder of full-maxed frame region is the content area (client+menubar+scrollbars),
                //  and is always rectangular
                hrgnContent = CreateRectRgnIndirect( &pncwm->rcW0[NCRC_CONTENT] );
                SPEW_RGNRECT(NCTF_RGNWND, TEXT("CreateCompositeRgn() maximized frame content rgn"), hrgnContent, 0 );

                AddToCompositeRgn(&hrgnWnd, hrgnContent, 0, 0);
    	        SAFE_DELETE_GDIOBJ(hrgnContent);
            }
        }
    }
    else
    {
        //  Normal windows consist of either a stand-alone frame part, or a frame
        //  part plus a caption part.   In the first case, the window region is
        //  the frame region.   In the second case, the window region is a composite
        //  of the frame and caption rects.

        for( i = 0; i < ARRAYSIZE(pncwm->rgframeparts); i++ )
        {
            if( (iCAPTION == i || !pncwm->fMin) && !IsRectEmpty( &pncwm->rcW0[NCRC_FRAMEFIRST + i] ) )
            {
                if( _IsNcPartTransparent(pncwm->rgframeparts[i], _nctmCurrent) )
                {
                    if( FAILED(GetThemeBackgroundRegion( _hTheme, NULL, pncwm->rgframeparts[i], pncwm->framestate,
                                                         &pncwm->rcW0[NCRC_FRAMEFIRST+i], &rghrgn[i] )) )
                    {
                        rghrgn[i] = NULL;
                    }
                }
                else
                {
                    rghrgn[i] = CreateRectRgnIndirect( &pncwm->rcW0[NCRC_FRAMEFIRST + i] );
                }
            }

            if( rghrgn[i] != NULL )
            {
                SPEW_RGNRECT(NCTF_RGNWND, TEXT("CreateCompositeRgn() frame subrgn"), rghrgn[i], pncwm->rgframeparts[i] );
                AddToCompositeRgn(&hrgnWnd, rghrgn[i], 0, 0);
            }
        }

        //  don't forget window content area (client+menubar+scrollbars), which is always rectangular
        if( !pncwm->fMin && !IsRectEmpty( &pncwm->rcW0[NCRC_CONTENT] ) )
        {
            hrgnContent = CreateRectRgnIndirect( &pncwm->rcW0[NCRC_CONTENT] );
            SPEW_RGNRECT(NCTF_RGNWND, TEXT("CreateCompositeRgn() normal frame content rgn"), hrgnContent, 0 );

            AddToCompositeRgn(&hrgnWnd, hrgnContent, 0, 0);
    	    SAFE_DELETE_GDIOBJ(hrgnContent);
        }
    }

    //  copy subregions back to caller
    CopyMemory( rghrgnParts, rghrgn, sizeof(rghrgn) );

    //  extract frame resizing templates
    ZeroMemory( rghrgn, sizeof(rghrgn) ); // reuse region array
    for( i = 0; i < cFRAMEPARTS; i++ )
    {
        const RECT* prc = &pncwm->rcW0[NCRC_FRAMEFIRST + i];

        if( VALID_WINDOWPART(pncwm->rgsizehitparts[i]) && !IsRectEmpty( prc ) )
        {
            if( SUCCEEDED(GetThemeBackgroundRegion( _hTheme, NULL, pncwm->rgsizehitparts[i], pncwm->framestate,
                                                    prc, &rghrgn[i])) )
            {

                SPEW_RGNRECT(NCTF_RGNWND, TEXT("CreateCompositeRgn() sizing template"), rghrgn[i], pncwm->rgframeparts[i] );
            }
        }
    }
    CopyMemory( rghrgnTemplates, rghrgn, sizeof(rghrgn) );

    return hrgnWnd;
}

//-------------------------------------------------------------------------//
void CThemeWnd::AssignFrameRgn( BOOL fAssign, DWORD dwFlags )
{
    if( fAssign )
    {
        NCWNDMET*  pncwm = NULL;
        NCTHEMEMET nctm = {0};
        if( GetNcWindowMetrics( NULL, &pncwm, &nctm, 0 ) )
        {
            //  should we set up a window region on this frame?
            if( pncwm->fFrame )
            {
                if( _ShouldAssignFrameRgn( pncwm, nctm ) )
                {
                    if( (_sizeRgn.cx != RECTWIDTH(&pncwm->rcW0[NCRC_WINDOW]) || 
                         _sizeRgn.cy != RECTHEIGHT(&pncwm->rcW0[NCRC_WINDOW])) )
                    {
                        HRGN hrgnWnd = NULL;
                        HRGN rghrgnParts[cFRAMEPARTS] = {0};
                        HRGN rghrgnTemplates[cFRAMEPARTS] = {0};
                        
                        if( (hrgnWnd = CreateCompositeRgn( pncwm, rghrgnParts, rghrgnTemplates )) != NULL )
                        {
                            _sizeRgn.cx = RECTWIDTH(&pncwm->rcW0[NCRC_WINDOW]);
                            _sizeRgn.cy = RECTHEIGHT(&pncwm->rcW0[NCRC_WINDOW]);

                            //  cache all of our regions for fast hit-testing.
                            _FreeRegionHandles();
                            _hrgnWnd     =  _DupRgn( hrgnWnd ); // dup this one cuz after _AssignRgn, we don't own it.
                            CopyMemory( _rghrgnParts, rghrgnParts, sizeof(_rghrgnParts) );
                            CopyMemory( _rghrgnSizingTemplates, rghrgnTemplates, sizeof(_rghrgnSizingTemplates) );

                            //  assign the region
                            _AssignRgn( hrgnWnd, dwFlags );
                        }
                    }
                }
                // otherwise, if we've assigned a region, make sure we remove it.
                else if( AssignedFrameRgn() ) 
                {
                    fAssign = FALSE;
                }
            }
        }
    }

    if( !fAssign )
    {
        _AssignRgn( NULL, dwFlags );
        FillMemory(&_sizeRgn, sizeof(_sizeRgn), 0xFF);
        _FreeRegionHandles();
    }
    SetDirtyFrameRgn(FALSE); // make sure we reset this in case we didn't hit _AssignRgn.
}

//-------------------------------------------------------------------------//
//  CThemeWnd::_AssignRgn() - assigns the specified region
//  to the window, prevents recursion (SetWindowRgn w/ bRedraw == TRUE
//  generates WM_WINDOWPOSCHANGING, WM_NCCALCSIZE, && WM_NCPAINT).
//
void CThemeWnd::_AssignRgn( HRGN hrgn, DWORD dwFlags )
{
    if( TESTFLAG(dwFlags, FTF_NOMODIFYRGN) )
    {
        _fAssignedFrameRgn = FALSE;
    }
    else if( !IsWindowInDestroy(_hwnd) )
    {
        //  Assign the new region.
        _fAssigningFrameRgn = TRUE;
        SPEW_RGNRECT(NCTF_RGNWND, TEXT("_AssignRgn() rect"), hrgn, -1 );
        _fAssignedFrameRgn = SetWindowRgn( _hwnd, hrgn, TESTFLAG(dwFlags, FTF_REDRAW) ) != 0;
        _fAssigningFrameRgn = FALSE;

    }
    SetDirtyFrameRgn(FALSE);
}

//-------------------------------------------------------------------------//
//  CThemeWnd::GetNcWindowMetrics
//
//  Computes internal per-window theme metrics.
//
BOOL CThemeWnd::GetNcWindowMetrics(
    IN  OPTIONAL LPCRECT prcWnd,
    OUT OPTIONAL NCWNDMET** ppncwm,
    OUT OPTIONAL NCTHEMEMET* pnctm,
    IN  DWORD dwOptions )
{
    LogEntryNC(L"GetNcWindowMetrics");

    NCTHEMEMET  nctm;
    BOOL        bRet         = FALSE;
    BOOL        fMenuBar     = _ncwm.cyMenu != 0;
    WINDOWPARTS rgframeparts[cFRAMEPARTS]; 

    CopyMemory( rgframeparts, _ncwm.rgframeparts, sizeof(rgframeparts) );
    
    //  fetch per-theme metrics; we're going to need theme throughout
    if (TESTFLAG(dwOptions, NCWMF_PREVIEW))
    {
        _LoadNcThemeMetrics(_hwnd, &nctm);
    } 
    else if( !GetCurrentNcThemeMetrics( &nctm ) )
    {
        goto exit;
    }
    
    if( pnctm ) *pnctm = nctm;

    if( !_ncwm.fValid || prcWnd != NULL )
        dwOptions |= NCWMF_RECOMPUTE;

    if( TESTFLAG(dwOptions, NCWMF_RECOMPUTE) )
    {
        //  get caption text size before entering critsec (sends WM_GETTEXTLENGTH, WM_GETTEXT).
        SIZE  sizeCaptionText = {0};
        HFONT hfCaption = NULL;
        HWND  hwndMDIActive = NULL;

        //  Do rough determination of whether or not we're a frame window and need to compute text metrics.  
        //  We'll finalize this later
        BOOL fFrame, fSmallFrame;

        if( _ncwm.fValid )
        {
            fFrame      = TESTFLAG( CThemeWnd::EvaluateStyle(_ncwm.dwStyle, _ncwm.dwExStyle), TWCF_FRAME|TWCF_TOOLFRAME );
            fSmallFrame = TESTFLAG( CThemeWnd::EvaluateStyle(_ncwm.dwStyle, _ncwm.dwExStyle), TWCF_TOOLFRAME );
        }
        else
        {
            fFrame = TestCF(TWCF_FRAME|TWCF_TOOLFRAME);
            fSmallFrame = TestCF(TWCF_TOOLFRAME);
        }

        //  Compute text metrics outside of critical section (sends WM_GETTEXT);
        if( fFrame && _fFrameThemed )
        {
            hfCaption = NcGetCaptionFont( fSmallFrame );
            _GetNcCaptionTextSize( _hTheme, _hwnd, hfCaption, &sizeCaptionText );
        }
        
        //  Retrieve active MDI sibling outside of critical section (sends WM_MDIGETACTIVE);
        if( TESTFLAG(GetWindowLong(_hwnd, GWL_EXSTYLE), WS_EX_MDICHILD) )
        {
            hwndMDIActive = _MDIGetActive( GetParent(_hwnd) );
        }
        
        ASSERT(_fCritSectsInit);
        EnterCriticalSection( &_cswm );
        
        ZeroMemory( &_ncwm, sizeof(_ncwm) );

        if( (bRet = _GetWindowMetrics( _hwnd, hwndMDIActive, &_ncwm )) != FALSE )
        {
            _ComputeNcWindowStatus( _hwnd, _ncwm.dwWindowStatus, &_ncwm );

            //  if window RECT is provided by the caller, stuff it now.
            if( prcWnd )
            {
                _ncwm.rcS0[NCRC_WINDOW] = *prcWnd;
                SetRectEmpty( &_ncwm.rcS0[NCRC_CLIENT] );
            }

            //  stuff caption text size
            _ncwm.sizeCaptionText = sizeCaptionText;
            _ncwm.hfCaption = hfCaption;

            //  retrieve frame metrics.
            if( _GetNcFrameMetrics( _hwnd, _hTheme, nctm, _ncwm ) )
            {
                if( _ncwm.fFrame )
                {
                    //  user32!SetMenu has been called, or the caption or frame part has changed
                    //  So ensure frame region update.
                    if( (_ncwm.cyMenu == 0 && fMenuBar) || (_ncwm.cyMenu > 0  && !fMenuBar) ||
                        memcmp( rgframeparts, _ncwm.rgframeparts, sizeof(rgframeparts) ) )
                    {
                        SetDirtyFrameRgn(TRUE, TRUE);
                    }

                    //  Compute NC button placement
                    AcquireFrameIcon(_ncwm.dwStyle, _ncwm.dwExStyle, FALSE);

#ifdef THEMED_NCBTNMETRICS
                    _GetClassicNcBtnMetrics( &_ncwm, _hAppIcon, _MNCanClose(_hwnd), FALSE );
#else  THEMED_NCBTNMETRICS
                    _GetNcBtnMetrics( &_ncwm, &nctm, _hAppIcon, _MNCanClose(_hwnd) );
#endif THEMED_NCBTNMETRICS

                    // Determine the caption margin for lame button metrics.
                    _GetNcCaptionMargins( _hTheme, nctm, _ncwm );
                    _GetNcCaptionTextRect( &_ncwm );

                    if( _ncwm.fFrame )
                    {
                        GetLameButtonMetrics( &_ncwm, &sizeCaptionText );
                    }
                }

                //  Compute window-relative metrics
                //
                //  If passed a window rect, base offsets on current window rect. 
                //  This is done to ensure preview window's (_hwnd) fake child windows are rendered correctly.
                RECT rcWnd = _ncwm.rcS0[NCRC_WINDOW];

                if( prcWnd )
                {
                    if( _hwnd )
                        GetWindowRect( _hwnd, &rcWnd );

                     // for an incoming window rect, assign the computed client rect.
                    _ncwm.rcS0[NCRC_CLIENT] = _ncwm.rcS0[NCRC_UXCLIENT];

                }

                for( int i = NCRC_FIRST; i < NCRC_COUNT; i++ )
                {
                    _ncwm.rcW0[i] = _ncwm.rcS0[i];
                    OffsetRect( &_ncwm.rcW0[i], -rcWnd.left, -rcWnd.top ); 
                }

                //  All base computations are done; mark valid.
                _ncwm.fValid = TRUE;
            }
        }
        
        LeaveCriticalSection( &_cswm );
    }

    if( ppncwm )
    {
        *ppncwm = &_ncwm;
    }

    bRet = TRUE;

exit:
    LogExitNC(L"GetNcWindowMetrics");
    return bRet;
}

//-------------------------------------------------------------------------//
void CThemeWnd::ReleaseNcWindowMetrics( IN NCWNDMET* pncwm )
{
    LeaveCriticalSection( &_cswm );
}

//-------------------------------------------------------------------------//
inline COLORREF _GetNcCaptionTextColor( FRAMESTATES iStateId )
{
    return GetSysColor( FS_ACTIVE == iStateId ? 
            COLOR_CAPTIONTEXT : COLOR_INACTIVECAPTIONTEXT );
}

//-------------------------------------------------------------------------//
//  Get CTLCOLOR brush for solid fills
void _GetBrushesForPart(HTHEME hTheme, int iPart, HBITMAP* phbm, HBRUSH* phbr)
{
    int nBgType;

    *phbm = NULL;
    *phbr = NULL;

    //  Get CTLCOLOR brush for solid fills
    HRESULT hr = GetThemeEnumValue( hTheme, iPart, 0, TMT_BGTYPE, &nBgType );
    if( SUCCEEDED( hr ))
    {
        if (BT_BORDERFILL == nBgType)
        {
            int nFillType;
            hr = GetThemeEnumValue( hTheme, iPart, 0, TMT_FILLTYPE, &nFillType );
            if (SUCCEEDED( hr ) &&
                FT_SOLID == nFillType)
            {
                COLORREF cr;
                hr = GetThemeColor( hTheme, iPart, 0, TMT_FILLCOLOR, &cr);

                *phbr = CreateSolidBrush(cr);
            }
            else
            {
                ASSERTMSG(FALSE, "Themes: The theme file specified an invalid fill type for dialog boxes");
            }
        }
        else if (BT_IMAGEFILE == nBgType)
        {
            HDC hdc = GetWindowDC(NULL);
            if ( hdc )
            {
                hr = GetThemeBitmap(hTheme, hdc, iPart, 0, NULL, phbm);
                if (SUCCEEDED(hr))
                {
                    *phbr = CreatePatternBrush(*phbm);
                }
                ReleaseDC(NULL, hdc);
            }
        }
    }
}

//-------------------------------------------------------------------------//
//
//  Chooses appropriate hit testing parts for the various Nc area
//
void _GetNcSizingTemplates(
    IN const NCTHEMEMET& nctm,
    IN OUT NCWNDMET& ncwm )         // window metric block.   dwStyle, dwExStyle, rcS0[NCRC_WINDOW] members are required.
{
    FillMemory( ncwm.rgsizehitparts, sizeof(ncwm.rgsizehitparts), BOGUS_WINDOWPART );

    // No need on windows without frames
    if( !ncwm.fFrame )
        return;

    // minimized or full-screen maximized window
    if( ncwm.fMin || ncwm.fFullMaxed )
        return;

    // No need on windows that aren't sizable
    if( !TESTFLAG(ncwm.dwStyle, WS_THICKFRAME) )
        return;

    if( ncwm.fSmallFrame)
    {
        if (nctm.fSmCapSizingTemplate)
            ncwm.rgsizehitparts[iCAPTION]    = WP_SMALLCAPTIONSIZINGTEMPLATE;

        if (nctm.fSmLeftSizingTemplate)
            ncwm.rgsizehitparts[iFRAMELEFT]   = WP_SMALLFRAMELEFTSIZINGTEMPLATE;

        if (nctm.fSmRightSizingTemplate)
            ncwm.rgsizehitparts[iFRAMERIGHT]  = WP_SMALLFRAMERIGHTSIZINGTEMPLATE;

        if (nctm.fSmBottomSizingTemplate)
            ncwm.rgsizehitparts[iFRAMEBOTTOM] = WP_SMALLFRAMEBOTTOMSIZINGTEMPLATE;
    }
    else
    {
        if (nctm.fCapSizingTemplate)
            ncwm.rgsizehitparts[iCAPTION]     = WP_CAPTIONSIZINGTEMPLATE;

        if (nctm.fLeftSizingTemplate)
            ncwm.rgsizehitparts[iFRAMELEFT]   = WP_FRAMELEFTSIZINGTEMPLATE;

        if (nctm.fRightSizingTemplate)
            ncwm.rgsizehitparts[iFRAMERIGHT]  = WP_FRAMERIGHTSIZINGTEMPLATE;

        if (nctm.fBottomSizingTemplate)
            ncwm.rgsizehitparts[iFRAMEBOTTOM] = WP_FRAMEBOTTOMSIZINGTEMPLATE;
    }
}

//-------------------------------------------------------------------------//
//
//  Computes theme metrics for frame window.
//
BOOL _GetNcFrameMetrics( 
    IN OPTIONAL HWND hwnd,          // window handle (required for multiline menubar calcs).
    IN HTHEME hTheme,               // theme handle (required)
    IN const NCTHEMEMET& nctm,      // theme metric block
    IN OUT NCWNDMET& ncwm )         // window metric block.   dwStyle, dwExStyle, rcS0[NCRC_WINDOW] members are required.
{
    LogEntryNC(L"_GetNcFrameMetrics");
    ASSERT(hTheme);
    
    //  recompute style class
    ncwm.dwStyleClass = CThemeWnd::EvaluateStyle( ncwm.dwStyle, ncwm.dwExStyle );
    ncwm.cnBorders    = _GetWindowBorders( ncwm.dwStyle, ncwm.dwExStyle );

    //  compute frame attributes, state
    ncwm.fFrame       = TESTFLAG( ncwm.dwStyleClass, (TWCF_FRAME|TWCF_TOOLFRAME) );
    ncwm.fSmallFrame  = TESTFLAG( ncwm.dwStyleClass, TWCF_TOOLFRAME );

    //  compute frame and caption parts
    if( ncwm.fFrame )
    {
        ncwm.rgframeparts[iFRAMEBOTTOM] = 
        ncwm.rgframeparts[iFRAMELEFT]   = 
        ncwm.rgframeparts[iFRAMERIGHT]  = 
        ncwm.rgframeparts[iCAPTION]     = BOGUS_WINDOWPART;

        if( ncwm.fMin ) // minimized window
        {
            ncwm.rgframeparts[iCAPTION] = WP_MINCAPTION;
        }
        else if( ncwm.fFullMaxed ) // full-screen maximized window
        {
            ncwm.rgframeparts[iCAPTION] = WP_MAXCAPTION;
        }
        else // normal or partial-screen maximized window with thick border
        {
            if( ncwm.fSmallFrame )
            {
                ncwm.rgframeparts[iCAPTION]     = WP_SMALLCAPTION;
                ncwm.rgframeparts[iFRAMELEFT]   = WP_SMALLFRAMELEFT;
                ncwm.rgframeparts[iFRAMERIGHT]  = WP_SMALLFRAMERIGHT;
                ncwm.rgframeparts[iFRAMEBOTTOM] = WP_SMALLFRAMEBOTTOM;
            }
            else 
            {
                ncwm.rgframeparts[iCAPTION]     = ncwm.fMaxed ? WP_MAXCAPTION : WP_CAPTION;
                ncwm.rgframeparts[iFRAMELEFT]   = WP_FRAMELEFT;
                ncwm.rgframeparts[iFRAMERIGHT]  = WP_FRAMERIGHT;
                ncwm.rgframeparts[iFRAMEBOTTOM] = WP_FRAMEBOTTOM;
            }
        }

        //  stash caption text color.
        ncwm.rgbCaption = _GetNcCaptionTextColor( ncwm.framestate );
        
        //  retrieve sizing templates.
        _GetNcSizingTemplates( nctm, ncwm );
    }

    //-----------------------------------------------------------//
    //   Frame metrics
    //
    //   Frame area includes 'skin' boundaries,
    //   menu, integrated caption and client edge.
    //
    //   Independent of the frame is the separate caption seg,
    //   scrollbars, and sizebox
    //-----------------------------------------------------------//
    if( ncwm.fFrame )  //  frame windows only
    {
        //  Initialize positions of main frame components...

        //  Content rect: area bounded by frame theme.
        //  Client rect:  area contained in content rect that excludes all nonclient
        //                elements (viz, scrollbars, menubar, inside edges).
        //  Caption rect: pertains to minimized and maximized windows, 
        //                and normal windows if the theme defines a caption part
        ncwm.rcS0[NCRC_CAPTION] =
        ncwm.rcS0[NCRC_CONTENT] = ncwm.rcS0[NCRC_WINDOW];
        SetRectEmpty( &ncwm.rcS0[NCRC_UXCLIENT] );

        if( ncwm.fMin ) /* minimized frame */
        {
            //  zero out content, client rectangles.
            ncwm.rcS0[NCRC_CONTENT].right = ncwm.rcS0[NCRC_CONTENT].left;
            ncwm.rcS0[NCRC_CONTENT].bottom = ncwm.rcS0[NCRC_CONTENT].top;

            ncwm.rcS0[NCRC_CLIENT]   = 
            ncwm.rcS0[NCRC_UXCLIENT] = ncwm.rcS0[NCRC_CONTENT];
        }
        else
        {
            NONCLIENTMETRICS ncm;
            if( NcGetNonclientMetrics( &ncm, FALSE ) )
            {
                ncwm.rcS0[NCRC_FRAMEBOTTOM] = 
                ncwm.rcS0[NCRC_FRAMELEFT] = 
                ncwm.rcS0[NCRC_FRAMERIGHT] = ncwm.rcS0[NCRC_WINDOW];

                //  themed caption rect spans left, top, right bordersS
                //  and 1 pixel edge below caption
                ncwm.rcS0[NCRC_CAPTION].bottom  = 
                            ncwm.rcS0[NCRC_CAPTION].top + ncwm.cnBorders + 
                            (ncwm.fSmallFrame ? ncm.iSmCaptionHeight : ncm.iCaptionHeight) + 
                            1 /* 1 pixel below caption */;

                // update the content and rects while we're here:
                InflateRect( &ncwm.rcS0[NCRC_CONTENT], -ncwm.cnBorders, -ncwm.cnBorders );
                ncwm.rcS0[NCRC_CONTENT].top = ncwm.rcS0[NCRC_CAPTION].bottom;
                if( ncwm.rcS0[NCRC_CONTENT].bottom < ncwm.rcS0[NCRC_CONTENT].top )
                    ncwm.rcS0[NCRC_CONTENT].bottom = ncwm.rcS0[NCRC_CONTENT].top;

                //  at this point the client rect is identical to the content rect (haven't computed menubar, scrollbars).
                ncwm.rcS0[NCRC_UXCLIENT] = ncwm.rcS0[NCRC_CONTENT]; 

                //  bottom border segment.
                ncwm.rcS0[NCRC_FRAMEBOTTOM].top = ncwm.rcS0[NCRC_FRAMEBOTTOM].bottom - ncwm.cnBorders;

                //  side border segments
                ncwm.rcS0[NCRC_FRAMELEFT].top  = 
                ncwm.rcS0[NCRC_FRAMERIGHT].top = ncwm.rcS0[NCRC_CAPTION].bottom;
                
                ncwm.rcS0[NCRC_FRAMELEFT].bottom  = 
                ncwm.rcS0[NCRC_FRAMERIGHT].bottom = ncwm.rcS0[NCRC_FRAMEBOTTOM].top;

                ncwm.rcS0[NCRC_FRAMELEFT].right = ncwm.rcS0[NCRC_FRAMELEFT].left  + ncwm.cnBorders;
                ncwm.rcS0[NCRC_FRAMERIGHT].left = ncwm.rcS0[NCRC_FRAMERIGHT].right - ncwm.cnBorders;
            }
        }
    }
    else // frameless windows with scrollbars and/or client-edge:
    {
        //  Non-frame windows
        ncwm.rcS0[NCRC_UXCLIENT] = ncwm.rcS0[NCRC_WINDOW];
        InflateRect( &ncwm.rcS0[NCRC_UXCLIENT], -ncwm.cnBorders, -ncwm.cnBorders );
        ncwm.rcS0[NCRC_CONTENT] = ncwm.rcS0[NCRC_UXCLIENT];
    }

    // Menubar
    if( !(ncwm.fMin || TESTFLAG( ncwm.dwStyle, WS_CHILD )) )  // child windows don't have menubars
    {
        //  Menubar offsets (for painting)
        ncwm.cnMenuOffsetTop   = ncwm.rcS0[NCRC_CONTENT].top  - ncwm.rcS0[NCRC_WINDOW].top;
        ncwm.cnMenuOffsetLeft  = ncwm.rcS0[NCRC_CONTENT].left - ncwm.rcS0[NCRC_WINDOW].left;
        ncwm.cnMenuOffsetRight = ncwm.rcS0[NCRC_WINDOW].right - ncwm.rcS0[NCRC_CONTENT].right;

        if( hwnd )
        {
            //  calc menubar does the right thing for multiline menubars
            ncwm.cyMenu = CalcMenuBar( hwnd, ncwm.cnMenuOffsetLeft,
                                       ncwm.cnMenuOffsetRight, 
                                       ncwm.cnMenuOffsetTop,
                                       &ncwm.rcS0[NCRC_WINDOW] );
        }
        else
        {
            //  no window (e.g. preview) == no menu, meaning don't call CalcMenuBar.
            //  we emulate computations best we can:
            ncwm.cyMenu = NcGetSystemMetrics( SM_CYMENUSIZE ); 
        }

        //  CalcMenuBar and SM_CYMENUSIZE are 1 pixel short of reality.
        if( ncwm.cyMenu )
            ncwm.cyMenu += nctm.dyMenuBar;

        //  Menubar rect (for hit-testing and clipping)
        SetRect( &ncwm.rcS0[NCRC_MENUBAR],
                  ncwm.rcS0[NCRC_CONTENT].left,
                  ncwm.rcS0[NCRC_CONTENT].top,
                  ncwm.rcS0[NCRC_CONTENT].right,
                  min(ncwm.rcS0[NCRC_CONTENT].bottom, ncwm.rcS0[NCRC_CONTENT].top + ncwm.cyMenu) );

        ncwm.rcS0[NCRC_UXCLIENT].top = ncwm.rcS0[NCRC_MENUBAR].bottom;
    }

    //  Client Edge.
    if( !ncwm.fMin && TESTFLAG(ncwm.dwExStyle, WS_EX_CLIENTEDGE) )
    {
        CopyRect( &ncwm.rcS0[NCRC_CLIENTEDGE], &ncwm.rcS0[NCRC_UXCLIENT] );
        InflateRect( &ncwm.rcS0[NCRC_UXCLIENT],
                     -NcGetSystemMetrics( SM_CXEDGE ),
                     -NcGetSystemMetrics( SM_CYEDGE ));
    }

    //-----------------------------------------------------------//
    //  Scrollbars and sizebox/gripper
    //-----------------------------------------------------------//

    if( !ncwm.fMin )
    {
        //  horizontal scroll bar.
        if( TESTFLAG(ncwm.dwStyle, WS_HSCROLL) )
        {
            ncwm.rcS0[NCRC_HSCROLL] = ncwm.rcS0[NCRC_UXCLIENT];
            ncwm.rcS0[NCRC_HSCROLL].top = ncwm.rcS0[NCRC_UXCLIENT].bottom =
                ncwm.rcS0[NCRC_HSCROLL].bottom - NcGetSystemMetrics( SM_CYHSCROLL );

            if( IsRectEmpty( &ncwm.rcS0[NCRC_CLIENT] ) /* this happens in preview */ )
            {
                ncwm.rcS0[NCRC_HSCROLL].left  = ncwm.rcS0[NCRC_UXCLIENT].left;
                ncwm.rcS0[NCRC_HSCROLL].right = ncwm.rcS0[NCRC_UXCLIENT].right;
            }
            else
            {
                ncwm.rcS0[NCRC_HSCROLL].left  = ncwm.rcS0[NCRC_CLIENT].left;
                ncwm.rcS0[NCRC_HSCROLL].right = ncwm.rcS0[NCRC_CLIENT].right;
            }
        }

        //  vertical scroll bar
        if( TESTFLAG(ncwm.dwStyle, WS_VSCROLL) )
        {
            ncwm.rcS0[NCRC_VSCROLL] = ncwm.rcS0[NCRC_UXCLIENT];

            if( TESTFLAG(ncwm.dwExStyle, WS_EX_LAYOUTRTL) ^ TESTFLAG(ncwm.dwExStyle, WS_EX_LEFTSCROLLBAR) )
            {
                ncwm.rcS0[NCRC_VSCROLL].right = ncwm.rcS0[NCRC_UXCLIENT].left =
                    ncwm.rcS0[NCRC_VSCROLL].left + NcGetSystemMetrics( SM_CXVSCROLL );

                //  Adjust for horz scroll, gripper
                if( TESTFLAG(ncwm.dwStyle, WS_HSCROLL) )
                {
                    ncwm.rcS0[NCRC_SIZEBOX]= ncwm.rcS0[NCRC_HSCROLL];
                    ncwm.rcS0[NCRC_SIZEBOX].right = ncwm.rcS0[NCRC_HSCROLL].left =
                        ncwm.rcS0[NCRC_UXCLIENT].left;
                }
            }
            else
            {
                ncwm.rcS0[NCRC_VSCROLL].left = ncwm.rcS0[NCRC_UXCLIENT].right =
                    ncwm.rcS0[NCRC_VSCROLL].right - NcGetSystemMetrics( SM_CXVSCROLL );

                //  Adjust for horz scroll, gripper
                if( TESTFLAG(ncwm.dwStyle, WS_HSCROLL) )
                {
                    ncwm.rcS0[NCRC_SIZEBOX]= ncwm.rcS0[NCRC_HSCROLL];
                    ncwm.rcS0[NCRC_SIZEBOX].left = ncwm.rcS0[NCRC_HSCROLL].right =
                        ncwm.rcS0[NCRC_UXCLIENT].right;
                }
            }

            if( IsRectEmpty( &ncwm.rcS0[NCRC_CLIENT] ) /* this happens in preview */ )
            {
                ncwm.rcS0[NCRC_VSCROLL].top    = ncwm.rcS0[NCRC_UXCLIENT].top;
                ncwm.rcS0[NCRC_VSCROLL].bottom = ncwm.rcS0[NCRC_UXCLIENT].bottom;
            }
            else
            {
                ncwm.rcS0[NCRC_VSCROLL].top    = ncwm.rcS0[NCRC_CLIENT].top;
                ncwm.rcS0[NCRC_VSCROLL].bottom = ncwm.rcS0[NCRC_CLIENT].bottom;
            }
        }
    }

    LogExitNC(L"_GetNcFrameMetrics");
    return TRUE;
}

#define EXT_TRACK_VERT  0x01
#define EXT_TRACK_HORZ  0x02

//-------------------------------------------------------------------------//
void _GetNcBtnHitTestRect( 
    IN const NCWNDMET* pncwm, 
    IN UINT uHitcode, 
    BOOL fWindowRelative, 
    OUT LPRECT prcHit )
{
    const RECT* prcBtn = NULL;
    int   dxLeft = 0; // button's left side delta
    int   dxRight = 0; // button's right side delta
    
    //  adjust hitrect to classic-look caption bar strip:
    RECT  rcHit = fWindowRelative ? pncwm->rcW0[NCRC_CAPTION] : pncwm->rcS0[NCRC_CAPTION];
    rcHit.top   += pncwm->cnBorders;
    rcHit.left  += pncwm->cnBorders;
    rcHit.right -= pncwm->cnBorders;
    rcHit.bottom -= 1;

    //  determine which button we're working with, how to extend the left, right sides.
    switch( uHitcode )
    {
        case HTMINBUTTON:
            prcBtn  = fWindowRelative ? &pncwm->rcW0[NCRC_MINBTN] : &pncwm->rcS0[NCRC_MINBTN];
            dxLeft  = -1;
            break;

        case HTMAXBUTTON:
            prcBtn  = fWindowRelative ? &pncwm->rcW0[NCRC_MAXBTN] : &pncwm->rcS0[NCRC_MAXBTN];
            dxRight = 1;
            break;

        case HTHELP:
            prcBtn  = fWindowRelative ? &pncwm->rcW0[NCRC_HELPBTN] : &pncwm->rcS0[NCRC_HELPBTN];
            dxLeft  = -1;
            dxRight = 1;
            break;

        case HTCLOSE:
            prcBtn  = fWindowRelative ? &pncwm->rcW0[NCRC_CLOSEBTN] : &pncwm->rcS0[NCRC_CLOSEBTN];
            dxLeft  = -1;
            dxRight = rcHit.right - prcBtn->right;
            break;

        case HTSYSMENU:
            prcBtn  = fWindowRelative ? &pncwm->rcW0[NCRC_SYSBTN] : &pncwm->rcS0[NCRC_SYSBTN];
            dxLeft  = rcHit.left - prcBtn->left;
            dxRight = 1;
            break;
    }

    if( prcBtn )
    {
        *prcHit = *prcBtn;
        if( !IsRectEmpty( prcBtn ) )
        {
            rcHit.left  = prcBtn->left  + dxLeft;
            rcHit.right = prcBtn->right + dxRight;
            *prcHit = rcHit;
        }
    }
    else
    {
        SetRectEmpty( prcHit );
    }
}

//-------------------------------------------------------------------------//
//  wraps alloc, retrieval of window text 
LPWSTR _AllocWindowText( IN HWND hwnd )
{
    LPWSTR pszRet = NULL;

    if (hwnd && IsWindow(hwnd))
    {
        if( (pszRet = new WCHAR[MAX_PATH]) != NULL )
        {
            int cch;
            if( (cch = InternalGetWindowText(hwnd, pszRet, MAX_PATH)) <= 0 )
            {
                __try // some wndprocs can't handle an early WM_GETTEXT (eg.310700).
                {
                    cch = GetWindowText(hwnd, pszRet, MAX_PATH);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    cch = 0;
                }
            }
            
            if( !cch )
            {
                SAFE_DELETE_ARRAY(pszRet); // delete and zero pointer
            }
        }
    }

    return pszRet;
}

//-------------------------------------------------------------------------//
//  _GetNcCaptionMargins() - computes a margin from the window ULC based on the
//          offsets in the theme and the location of enabled caption buttons.  The left
//          margin is to the right of the last left-aligned button, and the right margin
//          is to the left of the first right-aligned button.
//
BOOL _GetNcCaptionMargins( IN HTHEME hTheme, IN const NCTHEMEMET& nctm, IN OUT NCWNDMET& ncwm )
{
    ZeroMemory( &ncwm.CaptionMargins, sizeof(ncwm.CaptionMargins) );
    
    if( ncwm.fFrame )
    {
        //  assign per-window CaptinMargins, hfCaption values
        if( ncwm.fSmallFrame )
        {
            ncwm.CaptionMargins = nctm.marSmCaptionText;
        }
        else
        {
            if( ncwm.fMaxed ) 
            {
                ncwm.CaptionMargins = nctm.marMaxCaptionText;
            }
            else if( ncwm.fMin )
            {
                ncwm.CaptionMargins = nctm.marMinCaptionText;
            }
            else
            {
                ncwm.CaptionMargins = nctm.marCaptionText;
            }
        }
        ncwm.hfCaption = NcGetCaptionFont(ncwm.fSmallFrame);


        RECT  rcContainer = ncwm.rcS0[NCRC_CAPTION];
        RECT  *prcBtn = &ncwm.rcS0[NCBTNFIRST];
        rcContainer.left   += ncwm.cnBorders;
        rcContainer.right -= ncwm.cnBorders;

        //  sysmenu icon, if present, is the leftmost limit
        if( !IsRectEmpty( &ncwm.rcS0[NCRC_SYSBTN] ) )
        {
            rcContainer.left = ncwm.rcS0[NCRC_SYSBTN].right;
        }

        // Compute our rightmost limit
        for( UINT cRects = NCBTNRECTS; cRects; --cRects, ++prcBtn )
        {
            if (!IsRectEmpty(prcBtn))
            {
                if( prcBtn->left < rcContainer.right )
                {
                    rcContainer.right = prcBtn->left;
                }
            }
        }

        if( rcContainer.right < rcContainer.left )
        {
            rcContainer.right = rcContainer.left;
        }

        // final captions margins are adjusted to accommodate buttons.
        ncwm.CaptionMargins.cxLeftWidth  += (rcContainer.left - ncwm.rcS0[NCRC_CAPTION].left);
        ncwm.CaptionMargins.cxRightWidth += (ncwm.rcS0[NCRC_CAPTION].right - rcContainer.right);

        return TRUE;
    }
    
    return FALSE;
}

//-------------------------------------------------------------------------//
BOOL _GetNcCaptionTextSize( HTHEME hTheme, HWND hwnd, HFONT hf, OUT SIZE* psizeCaption )
{
    BOOL   fRet = FALSE;
    LPWSTR pszCaption = _AllocWindowText( hwnd );

    psizeCaption->cx = psizeCaption->cy = 0;

    if( pszCaption )
    {
        HDC hdc = GetWindowDC(hwnd);
        if( hdc )
        {
            //---- select font ----
            HFONT hf0 = (HFONT)SelectObject(hdc, hf);

            //---- let theme mgr do the calculation ----
            RECT rcExtent;
            HRESULT hr = GetThemeTextExtent( hTheme, hdc, WP_CAPTION, 0,
                pszCaption, lstrlen(pszCaption), 0, NULL, &rcExtent );

            //---- store result in "psizeCaption ----
            if (SUCCEEDED(hr))
            {
                psizeCaption->cx = WIDTH(rcExtent);
                psizeCaption->cy = HEIGHT(rcExtent);
            }

            //---- clean up ----
            SelectObject(hdc, hf0);
            ReleaseDC(hwnd, hdc);
        }

        SAFE_DELETE_ARRAY(pszCaption);
    }
    return fRet;
}

//-------------------------------------------------------------------------//
//  Retrieves position of available area for caption text, in window-relative
//  coordinates
BOOL _GetNcCaptionTextRect( IN OUT NCWNDMET* pncwm )
{
    pncwm->rcS0[NCRC_CAPTIONTEXT] = pncwm->rcS0[NCRC_CAPTION];

    //  accommodate classic top sizing border:
    pncwm->rcS0[NCRC_CAPTIONTEXT].top  += pncwm->cnBorders;

    //  Assign left, right based on resp. caption margins
    pncwm->rcS0[NCRC_CAPTIONTEXT].left  += pncwm->CaptionMargins.cxLeftWidth;
    pncwm->rcS0[NCRC_CAPTIONTEXT].right -= pncwm->CaptionMargins.cxRightWidth;

    //  vertically center the text between margins
    int cyPadding = (RECTHEIGHT(&pncwm->rcS0[NCRC_CAPTIONTEXT]) - pncwm->sizeCaptionText.cy)/2;
    pncwm->rcS0[NCRC_CAPTIONTEXT].top     += cyPadding;
    pncwm->rcS0[NCRC_CAPTIONTEXT].bottom  -= cyPadding;

    return TRUE;
}

//-------------------------------------------------------------------------//
//  retrieve the window icon
HICON CThemeWnd::AcquireFrameIcon( 
    DWORD dwStyle, DWORD dwExStyle, BOOL fWinIniChange )
{
    if( _hAppIcon != NULL )
    {
        if( fWinIniChange )
        {
            _hAppIcon = NULL;
        }
    }

    if( !TESTFLAG(dwStyle, WS_SYSMENU) || TESTFLAG(dwExStyle, WS_EX_TOOLWINDOW) )
    {
        //  return nil value without throwing away cached icon handle;
        //  this may be a transient style change.
        return NULL;
    }

    NONCLIENTMETRICS ncm = {0};
    NcGetNonclientMetrics( &ncm, FALSE );
    BOOL fPerferLargeIcon = ((30 < ncm.iCaptionHeight) ? TRUE : FALSE);
    if( NULL == _hAppIcon && NULL == (_hAppIcon = _GetWindowIcon(_hwnd, fPerferLargeIcon)) )
    {
        if ( HAS_CAPTIONBAR(dwStyle) &&
             ((dwStyle & (WS_BORDER|WS_DLGFRAME)) != WS_DLGFRAME) &&
             !TESTFLAG(dwExStyle, WS_EX_DLGMODALFRAME) )
        {
            // If we still can't get an icon and the window has
            // SYSMENU set, then they get the default winlogo icon
            _hAppIcon = LoadIcon(NULL, IDI_WINLOGO);
        }
    }

    return _hAppIcon;
}

//-------------------------------------------------------------------------//
void _CopyInflateRect( LPRECT prcDst, LPCRECT prcSrc, int cx, int cy)
{
    prcDst->left   = prcSrc->left   - cx;
    prcDst->right  = prcSrc->right  + cx;
    prcDst->top    = prcSrc->top    - cy;
    prcDst->bottom = prcSrc->bottom + cy;
}

//-------------------------------------------------------------------------//
//  CThemeWnd::ScreenToWindow() - transforms points from screen coords to
//  window coords.
//
void CThemeWnd::ScreenToWindow( LPPOINT prgPts, UINT cPts )
{
    RECT rcWnd;
    if( GetWindowRect( _hwnd, &rcWnd ) )
    {
        for( UINT i = 0; i < cPts; i++ )
        {
            prgPts[i].x -= rcWnd.left;
            prgPts[i].y -= rcWnd.top;
        }
    }
}

//-------------------------------------------------------------------------//
//  CThemeWnd::ScreenToWindow() - transforms non-empty rectangles from
//  screen coords to window coords.
//
void CThemeWnd::ScreenToWindowRect( LPRECT prc )
{
    if( !IsRectEmpty(prc) )
        ScreenToWindow( (LPPOINT)prc, 2 );
}

//-------------------------------------------------------------------------//
//  CThemeWnd::InitWindowMetrics()
//
//  initializes theme resources
void CThemeWnd::InitWindowMetrics()
{
    ZeroMemory( &_ncwm, sizeof(_ncwm) );
}

//-------------------------------------------------------------------------//
BOOL _fClassicNcBtnMetricsReset = TRUE;

//-------------------------------------------------------------------------//
//  computes classic button position
BOOL _GetClassicNcBtnMetrics( 
    IN OPTIONAL NCWNDMET* pncwm, 
    IN HICON hAppIcon, 
    IN OPTIONAL BOOL fCanClose, 
    BOOL fRefresh )
{
    static int  cxEdge, cyEdge;
    static int  cxBtn, cyBtn, cxSmBtn, cySmBtn;
    static RECT rcClose, rcMin, rcMax, rcHelp, rcSys;
    static RECT rcSmClose;
    static BOOL fInit = FALSE;

    if( _fClassicNcBtnMetricsReset || fRefresh )
    {
        cxBtn   = NcGetSystemMetrics( SM_CXSIZE );
        cyBtn   = NcGetSystemMetrics( SM_CYSIZE );
        cxSmBtn = NcGetSystemMetrics( SM_CXSMSIZE );
        cySmBtn = NcGetSystemMetrics( SM_CYSMSIZE );
        cxEdge  = NcGetSystemMetrics( SM_CXEDGE );
        cyEdge  = NcGetSystemMetrics( SM_CYEDGE ); 

        //  common top, w/ zero v-offset
        rcClose.top = rcMin.top = rcMax.top = rcHelp.top = rcSys.top = rcSmClose.top = 0;

        //  common bottom, w/ zero v-offset
        rcClose.bottom  = rcMin.bottom = rcMax.bottom = rcHelp.bottom = rcClose.top + (cyBtn - (cyEdge * 2));
        rcSmClose.bottom= (cySmBtn - (cyEdge * 2));

        //  sysmenu icon bottom
        rcSys.bottom    = rcSys.top + NcGetSystemMetrics(SM_CYSMICON);

        //  close, min, max left, right (as offsets from container's right boundary)
        rcClose.right   = -cxEdge; 
        rcClose.left    = rcClose.right - (cxBtn - cxEdge);

        rcMax.right     = rcClose.left  - cxEdge; 
        rcMax.left      = rcMax.right - (cxBtn - cxEdge);
        rcHelp          = rcMax;

        rcMin.right     = rcMax.left; 
        rcMin.left      = rcMin.right - (cxBtn - cxEdge);

        //  appicon left, right (as offsets from container's left boundary)
        rcSys.left      = cxEdge; 
        rcSys.right     = rcSys.left + NcGetSystemMetrics(SM_CXSMICON);
        
        //  toolwindow close, left, right
        rcSmClose.right = -cxEdge; 
        rcSmClose.left  = rcSmClose.right - (cxSmBtn - cxEdge);
        
        _fClassicNcBtnMetricsReset = FALSE;
    }

    if( !_fClassicNcBtnMetricsReset && 
        pncwm && pncwm->fFrame && TESTFLAG(pncwm->dwStyle, WS_SYSMENU) )
    {
        NONCLIENTMETRICS ncm;

        if( NcGetNonclientMetrics( &ncm, FALSE ) )
        {
            const RECT* prcBox = &pncwm->rcS0[NCRC_CAPTION];
            int   cnLOffset    = prcBox->left  + pncwm->cnBorders;
            int   cnROffset    = prcBox->right - pncwm->cnBorders;
            int   cnCtrOffset  = pncwm->cnBorders + prcBox->top + 
                                (pncwm->fSmallFrame ? (ncm.iCaptionHeight   - RECTHEIGHT(&rcClose))/2 : 
                                                      (ncm.iSmCaptionHeight - RECTHEIGHT(&rcSmClose))/2);

            //  assign outbound rectangles.
            //  vertically center w/ respect to classic caption area, 
            //  horizontally position w/ respect to respective container boundary.

            //  close button
            pncwm->rcS0[NCRC_CLOSEBTN] = pncwm->fSmallFrame ? rcSmClose : rcClose;
            OffsetRect( &pncwm->rcS0[NCRC_CLOSEBTN], cnROffset, cnCtrOffset );
            
            pncwm->rawCloseBtnState = fCanClose ? CBS_NORMAL : CBS_DISABLED;

            //  (1) min/max/help/appicons not displayed for toolwindows
            //  (2) min/max btns mutually exclusive w/ context help btn
            if( !TESTFLAG(pncwm->dwExStyle, WS_EX_TOOLWINDOW) )
            {
                //  min, max
                if( TESTFLAG(pncwm->dwStyle, WS_MINIMIZEBOX|WS_MAXIMIZEBOX) )
                {
                    pncwm->rcS0[NCRC_MINBTN] = rcMin;
                    OffsetRect( &pncwm->rcS0[NCRC_MINBTN], cnROffset, cnCtrOffset );

                    pncwm->rcS0[NCRC_MAXBTN] = rcMax;
                    OffsetRect( &pncwm->rcS0[NCRC_MAXBTN], cnROffset, cnCtrOffset );
                    
                    pncwm->iMaxButtonPart = pncwm->fMaxed ? WP_RESTOREBUTTON : WP_MAXBUTTON;
                    pncwm->iMinButtonPart = pncwm->fMin   ? WP_RESTOREBUTTON : WP_MINBUTTON;

                    pncwm->rawMaxBtnState = TESTFLAG(pncwm->dwStyle, WS_MAXIMIZEBOX) ? CBS_NORMAL : CBS_DISABLED;
                    pncwm->rawMinBtnState = TESTFLAG(pncwm->dwStyle, WS_MINIMIZEBOX) ? CBS_NORMAL : CBS_DISABLED;
                }
                //  help btn
                else if( TESTFLAG(pncwm->dwExStyle, WS_EX_CONTEXTHELP) )
                {
                    pncwm->rcS0[NCRC_HELPBTN] = rcHelp;
                    OffsetRect( &pncwm->rcS0[NCRC_HELPBTN], cnROffset, cnCtrOffset );
                }

                if( hAppIcon )
                {
                    //  sysmenu icon
                    pncwm->rcS0[NCRC_SYSBTN] = rcSys;
                    OffsetRect( &pncwm->rcS0[NCRC_SYSBTN], cnLOffset,  
                                pncwm->cnBorders + prcBox->top + (ncm.iCaptionHeight - RECTHEIGHT(&rcSys))/2 );
                }
            }
            return TRUE;
        }
        return FALSE;
    }
    return fInit;
}

//-------------------------------------------------------------------------//
//  computes classic button position
BOOL _GetNcBtnMetrics( 
    IN OUT   NCWNDMET* pncwm,
    IN const NCTHEMEMET* pnctm,
    IN HICON hAppIcon, 
    IN OPTIONAL BOOL fCanClose )
{
    BOOL fRet = TRUE;
    
    if( pncwm && pncwm->fFrame && TESTFLAG(pncwm->dwStyle, WS_SYSMENU) )
    {
        NONCLIENTMETRICS ncm;
        fRet = NcGetNonclientMetrics( &ncm, FALSE );
        if( fRet )
        {
            //  (1) compute baseline rectangles
            int cxEdge  = NcGetSystemMetrics( SM_CXEDGE );
            int cyEdge  = NcGetSystemMetrics( SM_CYEDGE );

            int cyBtn   = NcGetSystemMetrics( SM_CYSIZE );
            int cxBtn   = MulDiv( cyBtn, pnctm->sizeBtn.cx, pnctm->sizeBtn.cy );

            int cySmBtn = NcGetSystemMetrics( SM_CYSMSIZE );
            int cxSmBtn = MulDiv( cySmBtn, pnctm->sizeSmBtn.cx, pnctm->sizeSmBtn.cy );

            // remove padding from x,y
            cyBtn   -= (cyEdge * 2);
            cxBtn   -= (cyEdge * 2);
            cySmBtn -= (cyEdge * 2);
            cxSmBtn -= (cyEdge * 2);

            RECT rcClose, rcMin, rcMax, rcHelp, rcSys, rcSmClose;

            //  common top, w/ zero v-offset
            rcClose.top = rcMin.top = rcMax.top = rcHelp.top = rcSys.top = rcSmClose.top = 0;

            //  common bottom, w/ zero v-offset
            rcClose.bottom = rcMin.bottom = rcMax.bottom = rcHelp.bottom = 
                max( rcClose.top, rcClose.top + cyBtn );

            rcSmClose.bottom = 
                max( rcSmClose.top, cySmBtn );

            //  sysmenu icon bottom
            rcSys.bottom    = rcSys.top + NcGetSystemMetrics(SM_CYSMICON);

            //  close, min, max left, right (as offsets from container's right boundary)
            rcClose.right   = -cxEdge; 
            rcClose.left    = rcClose.right - cxBtn;

            rcMax.right     = rcClose.left - cxEdge; 
            rcMax.left      = rcMax.right  - cxBtn;
            rcHelp          = rcMax;

            rcMin.right     = rcMax.left   - cxEdge; 
            rcMin.left      = rcMin.right  - cxBtn;

            //  appicon left, right (as offsets from container's left boundary)
            rcSys.left      = cxEdge; 
            rcSys.right     = rcSys.left + NcGetSystemMetrics(SM_CXSMICON);
    
            //  toolwindow close, left, right
            rcSmClose.right = -cxEdge; 
            rcSmClose.left  = rcSmClose.right - cxSmBtn;

            const RECT* prcBox = &pncwm->rcS0[NCRC_CAPTION];
            int   cnLOffset    = prcBox->left  + pncwm->cnBorders;
            int   cnROffset    = prcBox->right - pncwm->cnBorders;
            int   cnCtrOffset  = pncwm->cnBorders + prcBox->top + 
                                (pncwm->fSmallFrame ? (ncm.iCaptionHeight   - RECTHEIGHT(&rcClose))/2 : 
                                                      (ncm.iSmCaptionHeight - RECTHEIGHT(&rcSmClose))/2);

            //  (2) assign outbound rectangles.
            //      vertically center w/ respect to classic caption area, 
            //      horizontally position w/ respect to respective container boundary.

            //  close button
            pncwm->rcS0[NCRC_CLOSEBTN] = pncwm->fSmallFrame ? rcSmClose : rcClose;
            OffsetRect( &pncwm->rcS0[NCRC_CLOSEBTN], cnROffset, cnCtrOffset );
            
            pncwm->rawCloseBtnState = fCanClose ? CBS_NORMAL : CBS_DISABLED;

            //  (1) min/max/help/appicons not displayed for toolwindows
            //  (2) min/max btns mutually exclusive w/ context help btn
            if( !TESTFLAG(pncwm->dwExStyle, WS_EX_TOOLWINDOW) )
            {
                //  min, max
                if( TESTFLAG(pncwm->dwStyle, WS_MINIMIZEBOX|WS_MAXIMIZEBOX) )
                {
                    pncwm->rcS0[NCRC_MINBTN] = rcMin;
                    OffsetRect( &pncwm->rcS0[NCRC_MINBTN], cnROffset, cnCtrOffset );

                    pncwm->rcS0[NCRC_MAXBTN] = rcMax;
                    OffsetRect( &pncwm->rcS0[NCRC_MAXBTN], cnROffset, cnCtrOffset );
                    
                    pncwm->iMaxButtonPart = pncwm->fMaxed ? WP_RESTOREBUTTON : WP_MAXBUTTON;
                    pncwm->iMinButtonPart = pncwm->fMin   ? WP_RESTOREBUTTON : WP_MINBUTTON;

                    pncwm->rawMaxBtnState = TESTFLAG(pncwm->dwStyle, WS_MAXIMIZEBOX) ? CBS_NORMAL : CBS_DISABLED;
                    pncwm->rawMinBtnState = TESTFLAG(pncwm->dwStyle, WS_MINIMIZEBOX) ? CBS_NORMAL : CBS_DISABLED;
                }
                //  help btn
                else if( TESTFLAG(pncwm->dwExStyle, WS_EX_CONTEXTHELP) )
                {
                    pncwm->rcS0[NCRC_HELPBTN] = rcHelp;
                    OffsetRect( &pncwm->rcS0[NCRC_HELPBTN], cnROffset, cnCtrOffset );
                }

                if( hAppIcon )
                {
                    //  sysmenu icon
                    pncwm->rcS0[NCRC_SYSBTN] = rcSys;
                    OffsetRect( &pncwm->rcS0[NCRC_SYSBTN], cnLOffset,  
                                pncwm->cnBorders + prcBox->top + (ncm.iCaptionHeight - RECTHEIGHT(&rcSys))/2 );
                }
            }
        }
    }
    return fRet;
}

//-------------------------------------------------------------------------//
//  CThemeWnd::NcBackgroundHitTest() - hit test the Caption or Frame part
//
WORD CThemeWnd::NcBackgroundHitTest( 
    POINT ptHit, LPCRECT prcWnd, 
    DWORD dwStyle, DWORD dwExStyle, 
    FRAMESTATES fs,
    const WINDOWPARTS rgiParts[],
    const WINDOWPARTS rgiTemplates[],
    const RECT rgrcParts[] )
{
    WORD        hitcode = HTNOWHERE;
    HRESULT     hr = E_FAIL;
    eFRAMEPARTS iPartHit = (eFRAMEPARTS)-1;

    //  do a standard rect hit test:
    for( int i = 0; i < cFRAMEPARTS; i++ )
    {
        if( _StrictPtInRect(&rgrcParts[i], ptHit) )
        {
            iPartHit = (eFRAMEPARTS)i;
            break;
        }
    }
    
    if( iPartHit >= 0 )
    {
        BOOL    fResizing = TESTFLAG(dwStyle, WS_THICKFRAME);
        DWORD   dwHTFlags = fResizing ? HTTB_RESIZINGBORDER : HTTB_FIXEDBORDER;

        RECT    rcHit = rgrcParts[iPartHit];

        switch( iPartHit )
        {
            case iCAPTION:
                //  Ensure caption rect and test point are zero-relative to
                //  the correct origin (if we have a window region, 
                //  this would be window origin, otherwise, it's the part origin.)
                if( _hrgnWnd != NULL )
                    rcHit = *prcWnd;
                if( fResizing )
                    dwHTFlags &= ~HTTB_RESIZINGBORDER_BOTTOM;
                break;

            case iFRAMEBOTTOM:
                if( fResizing )
                    dwHTFlags &= ~HTTB_RESIZINGBORDER_TOP;
                break;

            case iFRAMELEFT:
                if( fResizing )
                    dwHTFlags = HTTB_RESIZINGBORDER_LEFT;
                break;

            case iFRAMERIGHT:
                if( fResizing )
                    dwHTFlags = HTTB_RESIZINGBORDER_RIGHT;
                break;
        }

        ptHit.x -= prcWnd->left;
        ptHit.y -= prcWnd->top;
        OffsetRect( &rcHit, -prcWnd->left, -prcWnd->top );

    
        // Here our assumption is that the hit testing for the template
        // is "as good" or "better" than the rectangles checking applied
        // to the caption part.  So we do one or the other.  There are
        // situations where you would need to do both (if the template
        // were outside the window region and you were able to get USER to
        // send you NcHitTest messages for it).  For those situations
        // you would need to call both so that you can distinguish between
        // a mouse hit over the caption "client" area vs. over the
        // outside-transparent area.
        if( VALID_WINDOWPART(rgiTemplates[iPartHit]) )
        {
            hr = HitTestThemeBackground( _hTheme, NULL, rgiTemplates[iPartHit], fs,
                                         dwHTFlags | (fResizing ? HTTB_SIZINGTEMPLATE : 0),
                                         &rcHit, _rghrgnSizingTemplates[iPartHit], ptHit, &hitcode );
        }
        else
        {
            hr = HitTestThemeBackground( _hTheme, NULL, rgiParts[iPartHit], fs, 
                                         dwHTFlags | (fResizing ? HTTB_SYSTEMSIZINGMARGINS : 0),
                                         &rcHit, _hrgnWnd, ptHit, &hitcode );
        }

        if( SUCCEEDED(hr) )
        {
            if( iCAPTION == iPartHit && (HTCLIENT == hitcode || HTBORDER == hitcode) )
                hitcode = HTCAPTION;
        }
    }

    if ( FAILED(hr) )
    {
        hitcode = HTNOWHERE;
    }

    return hitcode;
}

//-------------------------------------------------------------------------//
//  CThemeWnd::TrackFrameButton() - track the mouse over the caption buttons,
//  pressing/releasing as appropriate.  Return back SC_* command to report or 0
//  if the mouse was released off of the button.
//
BOOL CThemeWnd::TrackFrameButton(
    HWND hwnd, 
    INT  iHitCode, 
    OUT OPTIONAL WPARAM* puSysCmd,
    BOOL fHottrack )
{
    int    iStateId, iNewStateId;
    int    iPartId = -1;
    UINT   cmd = 0;
    MSG    msg = {0};
    LPRECT prcBtnPaint = NULL;
    RECT   rcBtnTrack;
    HDC    hdc;

    if (puSysCmd)
    {
        *puSysCmd = 0;
    }

    // map iHitCode to the correct part number
    switch (iHitCode)
    {
        case HTHELP:
            cmd = SC_CONTEXTHELP;
            iPartId = WP_HELPBUTTON;
            prcBtnPaint = &_ncwm.rcW0[NCRC_HELPBTN];
            break;

        case HTCLOSE:
            cmd = SC_CLOSE;
            iPartId = _ncwm.fSmallFrame ? WP_SMALLCLOSEBUTTON : WP_CLOSEBUTTON;
            prcBtnPaint = &_ncwm.rcW0[NCRC_CLOSEBTN];
            break;

        case HTMINBUTTON:
            cmd = _ncwm.fMin ? SC_RESTORE : SC_MINIMIZE;
            iPartId = _ncwm.iMinButtonPart;
            prcBtnPaint = &_ncwm.rcW0[NCRC_MINBTN];
            break;

        case HTMAXBUTTON:
            cmd = _ncwm.fMaxed ? SC_RESTORE : SC_MAXIMIZE;
            iPartId = _ncwm.iMaxButtonPart;
            prcBtnPaint = &_ncwm.rcW0[NCRC_MAXBTN];
            break;

        case HTSYSMENU:
            if (puSysCmd)
            {
                *puSysCmd = SC_MOUSEMENU | iHitCode;
            }
            return TRUE;
    }

    // If we didn't recognize the hit code there's nothing to track
    if (iPartId >= 0 )
    {
        // Get the window DC, in window coords
        hdc = _GetNonclientDC(_hwnd, NULL);
        if ( hdc )
        {
            // Don't paint in the window's content area, clip to the content area
            ExcludeClipRect( hdc, _ncwm.rcW0[NCRC_CONTENT].left, 
                                  _ncwm.rcW0[NCRC_CONTENT].top, 
                                  _ncwm.rcW0[NCRC_CONTENT].right, 
                                  _ncwm.rcW0[NCRC_CONTENT].bottom );

            // Calculate the tracking rect. We track a larger button rect when maximized
            // but paint into the normal sized rect.
            rcBtnTrack = *prcBtnPaint;
            _GetNcBtnHitTestRect( &_ncwm, iHitCode, TRUE, &rcBtnTrack );

            // when tracking MDI child window frame buttons, clip to their
            // parent rect. 
            if ( TESTFLAG(GetWindowLong(hwnd, GWL_EXSTYLE), WS_EX_MDICHILD) )
            {
                RECT rcMDIClient;

                GetWindowRect(GetParent(hwnd), &rcMDIClient);
                ScreenToWindowRect(&rcMDIClient);
                InflateRect(&rcMDIClient, -NcGetSystemMetrics(SM_CXEDGE), -NcGetSystemMetrics(SM_CYEDGE));
                IntersectClipRect(hdc, rcMDIClient.left, rcMDIClient.top, rcMDIClient.right, rcMDIClient.bottom);
            }

            if (fHottrack)
            {
                // draw the button hot if the mouse is over it
                iStateId = (iHitCode == _htHot) ? SBS_HOT : CBS_NORMAL;
            }
            else
            {
                // draw the button depressed
                iStateId = SBS_PUSHED;
            }

            iStateId = MAKE_BTNSTATE(_ncwm.framestate, iStateId);
            NcDrawThemeBackground(_hTheme, hdc, iPartId, iStateId, prcBtnPaint, 0);

            // TODO NotifyWinEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_TITLEBAR, iButton, 0);


            if ( !fHottrack )
            {
                BOOL fTrack, fMouseUp = FALSE;
                SetCapture(hwnd);   // take mouse capture

                do // mouse button tracking loop
                {
                    fTrack = FALSE;

                    //  Let's go to sleep, to be awakened only on a mouse message placed in our
                    //  thread's queue.

                    switch (MsgWaitForMultipleObjectsEx(0, NULL, INFINITE /*why consume CPU processing a timeout when we don't have to?*/, 
                                                        QS_MOUSE, MWMO_INPUTAVAILABLE))
                    {
                     case WAIT_OBJECT_0: // a mouse message or important system event has been queued
                            

                    	if (PeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE))
                   	 {

                        // PeekMessage returns a point in screen relative coords. Mirror the
                        // point it this is a RTL window. Translate the point to window coords.
                        if ( TESTFLAG(_ncwm.dwExStyle, WS_EX_LAYOUTRTL) )
                        {
                            // mirror the point to hittest correctly
                            MIRROR_POINT(_ncwm.rcS0[NCRC_WINDOW], msg.pt);
                        }
                        ScreenToWindow( &msg.pt, 1 );

                        if (msg.message == WM_LBUTTONUP)
                        {
                            ReleaseCapture();
                            fMouseUp = TRUE;
                        }
                        else if ((msg.message == WM_MOUSEMOVE) && cmd)
                        {
                            iNewStateId = MAKE_BTNSTATE(_ncwm.framestate, PtInRect(&rcBtnTrack, msg.pt) ? SBS_PUSHED : SBS_NORMAL);

                            if (iStateId != iNewStateId)
                            {
                                iStateId = iNewStateId;
                                NcDrawThemeBackground(_hTheme, hdc, iPartId, iStateId, prcBtnPaint, 0);
                                // TODO NotifyWinEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_TITLEBAR, iButton, 0);
                            }
                         fTrack = TRUE;
                         }
             	       }
                    else
                    {
                        //  Check loss of capture.  This can happen if we loose activation 
                        //  via alt-tab and may not have received a WM_CAPTURECHANGED message

                        	if (GetCapture() != hwnd)
                        	{
                       	 break;
                        	}
                    	}
                    		 // Dequeue CAPTURECHANGED
                    if (PeekMessage(&msg, NULL, WM_CAPTURECHANGED, WM_CAPTURECHANGED, PM_REMOVE) ||
                        fMouseUp)
                    {
                         break;
                    }

                    
                    fTrack = TRUE;  // go back to sleep until the next mouse event
                    break;

                    default:
                    break; 
                   
                    }
               } while (fTrack);

                // draw button in normal state if it is not in that state already
                iNewStateId = MAKE_BTNSTATE(_ncwm.framestate, CBS_NORMAL);
                if (iStateId != iNewStateId)
                {
                    NcDrawThemeBackground(_hTheme, hdc, iPartId, iNewStateId, prcBtnPaint, 0);
                }

                // if we did not end up on a button return 0
                if( puSysCmd && (*puSysCmd = cmd) != 0 )
                {
                    // TODO NotifyWinEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_TITLEBAR, iButton, 0);

                    // If mouse wasn't released over the button, cancel the command.
                    if( !(fMouseUp && PtInRect(&rcBtnTrack, msg.pt)) )
                        *puSysCmd = 0;
                }

         	}
            // Done with DC now
            ReleaseDC(_hwnd, hdc);
        }
    }

    return TRUE;
}

//-------------------------------------------------------------------------//
DWORD GetTextAlignFlags(HTHEME hTheme, IN NCWNDMET* pncwm, BOOL fReverse)
{
    CONTENTALIGNMENT  contentAlignment = CA_LEFT;
    DWORD dwAlignFlags = 0;

    //---- compute text alignment ----
    GetThemeInt(hTheme, pncwm->rgframeparts[iCAPTION], pncwm->framestate, TMT_CONTENTALIGNMENT, 
                (int *)&contentAlignment);

    if (fReverse)
    {
        //---- reverse alignment ----
        switch(contentAlignment)
        {
            default:
            case CA_LEFT:   dwAlignFlags |= DT_RIGHT;   break;
            case CA_CENTER: dwAlignFlags |= DT_CENTER; break;
            case CA_RIGHT:  dwAlignFlags |= DT_LEFT;  break;
        }
    }
    else
    {
        //---- normal alignment ----
        switch(contentAlignment)
        {
            default:
            case CA_LEFT:   dwAlignFlags |= DT_LEFT;   break;
            case CA_CENTER: dwAlignFlags |= DT_CENTER; break;
            case CA_RIGHT:  dwAlignFlags |= DT_RIGHT;  break;
        }
    }

    return dwAlignFlags;
}

//-------------------------------------------------------------------------//
void _BorderRect( HDC hdc, COLORREF rgb, LPCRECT prc, int cxBorder, int cyBorder )
{
    COLORREF rgbSave = SetBkColor( hdc, rgb );
    RECT rc = *prc;

    //  bottom border
    rc = *prc; rc.top = prc->bottom - cyBorder;
    ExtTextOut( hdc, rc.left, rc.top, ETO_OPAQUE, &rc, NULL, 0, NULL );

    //  right border
    rc = *prc; rc.left = prc->right - cxBorder;
    ExtTextOut( hdc, rc.left, rc.top, ETO_OPAQUE, &rc, NULL, 0, NULL );

    //  left border
    rc = *prc; rc.right = prc->left + cxBorder;
    ExtTextOut( hdc, rc.left, rc.top, ETO_OPAQUE, &rc, NULL, 0, NULL );

    //  top border
    rc = *prc; rc.bottom = prc->top + cyBorder;
    ExtTextOut( hdc, rc.left, rc.top, ETO_OPAQUE, &rc, NULL, 0, NULL );

    SetBkColor( hdc, rgbSave );
}

//-------------------------------------------------------------------------//
void _DrawWindowEdges( HDC hdc, NCWNDMET* pncwm, BOOL fIsFrame )
{
    //  non-frame window edge & border
    if( !fIsFrame )
    {
        RECT rcWnd = pncwm->rcW0[NCRC_WINDOW];

        int  cxBorder = NcGetSystemMetrics(SM_CXBORDER),
             cyBorder = NcGetSystemMetrics(SM_CYBORDER);

        //  static, window edge
        if( TESTFLAG(pncwm->dwExStyle, WS_EX_WINDOWEDGE) )
        {
            RECT rcClip = rcWnd;

            InflateRect( &rcClip, -pncwm->cnBorders, -pncwm->cnBorders );
            ExcludeClipRect( hdc, rcClip.left, rcClip.top, rcClip.right, rcClip.bottom );
            DrawEdge( hdc, &rcWnd, EDGE_RAISED, BF_RECT | BF_ADJUST | BF_MIDDLE);
            SelectClipRgn( hdc, NULL );
        }
        else if( TESTFLAG(pncwm->dwExStyle, WS_EX_STATICEDGE) )
        {
            DrawEdge( hdc, &rcWnd, BDR_SUNKENOUTER, BF_RECT | BF_ADJUST );
        }
        // Normal border
        else if( TESTFLAG(pncwm->dwStyle, WS_BORDER) )
        {
            _BorderRect( hdc, GetSysColor( COLOR_WINDOWFRAME),
                         &rcWnd, cxBorder, cyBorder );
        }
    }

    //  client edge
    if( TESTFLAG(pncwm->dwExStyle, WS_EX_CLIENTEDGE) )
    {
#ifdef _TEST_CLIENTEDGE_

        HBRUSH hbr = CreateSolidBrush( RGB(255,0,255) );
        FillRect(hdc, &ncwm.rcW0[NCRC_CLIENTEDGE], hbr);
        DeleteObject(hbr);

#else  _TEST_CLIENTEDGE_

        DrawEdge( hdc, &pncwm->rcW0[NCRC_CLIENTEDGE], EDGE_SUNKEN, BF_RECT | BF_ADJUST);

#endif _TEST_CLIENTEDGE_
    }
}

//-------------------------------------------------------------------------//
void CThemeWnd::NcPaintCaption(
    IN HDC       hdcOut,
    IN NCWNDMET* pncwm,
    IN BOOL      fBuffered,
    IN DWORD     dwCaptionFlags, // draw caption flags (DC_xxx, winuser.h)
    IN DTBGOPTS* pdtbopts )
{
    ASSERT(hdcOut);
    ASSERT(pncwm);
    ASSERT(pncwm->fFrame);
    ASSERT(HAS_CAPTIONBAR(pncwm->dwStyle));

    DWORD dwOldAlign = 0;

    //  caption text implies caption background
    if( TESTFLAG( dwCaptionFlags, DC_TEXT|DC_ICON ) || 0 == dwCaptionFlags )
    {
        dwCaptionFlags = DC_ENTIRECAPTION;
    }

    if( dwCaptionFlags != DC_ENTIRECAPTION
#if defined(DEBUG) && defined(DEBUG_NCPAINT)
        || TESTFLAG( _NcTraceFlags, NCTF_NCPAINT )
#endif DEBUG
    )
    {
        fBuffered = FALSE;
    }

    //  create caption double buffer
    HBITMAP hbmBuf = fBuffered ? CreateCompatibleBitmap(hdcOut, RECTWIDTH(&pncwm->rcW0[NCRC_CAPTION]),
                                                        RECTHEIGHT(&pncwm->rcW0[NCRC_CAPTION])) : 
                                 NULL;
    
    if( !fBuffered || hbmBuf )
    {
        HDC hdc = fBuffered ? CreateCompatibleDC(hdcOut) : hdcOut;
        if( hdc )
        {
            //--- DO NOT EXIT FROM WITHIN THIS CONDITIONAL ---//
            EnterNcThemePaint(); 

            HBITMAP hbm0 = fBuffered ? (HBITMAP)SelectObject(hdc, hbmBuf) : NULL;

            if( TESTFLAG( dwCaptionFlags, DC_BACKGROUND ) )
            {
                //  Draw caption background

                RECT rcBkgnd = pncwm->rcW0[NCRC_CAPTION];
                if( pncwm->fFullMaxed )
                {
                    rcBkgnd.top   += pncwm->cnBorders;
                    rcBkgnd.left  += pncwm->cnBorders;
                    rcBkgnd.right -= pncwm->cnBorders;
                }
                NcDrawThemeBackgroundEx( _hTheme, hdc, pncwm->rgframeparts[iCAPTION], pncwm->framestate,
                                         &rcBkgnd, pdtbopts );
            }

            if( TESTFLAG( dwCaptionFlags, DC_BUTTONS ) )
            {
                //  Draw standard caption buttons
                if (!IsRectEmpty(&pncwm->rcW0[NCRC_CLOSEBTN]))
                {
                    NcDrawThemeBackground( _hTheme, hdc, pncwm->fSmallFrame ? WP_SMALLCLOSEBUTTON : WP_CLOSEBUTTON,
                                           MAKE_BTNSTATE(pncwm->framestate, pncwm->rawCloseBtnState),
                                           &pncwm->rcW0[NCRC_CLOSEBTN], 0);
                }

                if (!IsRectEmpty(&pncwm->rcW0[NCRC_MAXBTN]))
                {
                
                    NcDrawThemeBackground(_hTheme, hdc, pncwm->iMaxButtonPart,
                                          MAKE_BTNSTATE(pncwm->framestate, pncwm->rawMaxBtnState), 
                                          &pncwm->rcW0[NCRC_MAXBTN], 0);
                }

                if (!IsRectEmpty(&pncwm->rcW0[NCRC_MINBTN]))
                {
                    NcDrawThemeBackground( _hTheme, hdc, pncwm->iMinButtonPart,
                                           MAKE_BTNSTATE(pncwm->framestate, pncwm->rawMinBtnState), 
                                           &pncwm->rcW0[NCRC_MINBTN], 0);
                }

                if (!IsRectEmpty(&pncwm->rcW0[NCRC_HELPBTN]))
                    NcDrawThemeBackground(_hTheme, hdc, WP_HELPBUTTON, MAKE_BTNSTATE(pncwm->framestate, CBS_NORMAL), 
                                          &pncwm->rcW0[NCRC_HELPBTN], 0);
            }

            //  Draw sysmenu icon
            if( TESTFLAG( dwCaptionFlags, DC_ICON ) )
            {
                if (!IsRectEmpty(&pncwm->rcW0[NCRC_SYSBTN]) && _hAppIcon)
                {
                    #define MAX_APPICON_RETRIES 1
                    int cRetries = 0;

                    DWORD dwLayout = GetLayout(hdc);
                    if( GDI_ERROR != dwLayout && TESTFLAG(dwLayout, LAYOUT_RTL) )
                    {
                        SetLayout(hdc, dwLayout|LAYOUT_BITMAPORIENTATIONPRESERVED);
                    }

                    do 
                    {
                        //  note: we don't draw sysmenu icon mirrored
                        if( DrawIconEx(hdc, pncwm->rcW0[NCRC_SYSBTN].left, pncwm->rcW0[NCRC_SYSBTN].top, _hAppIcon,
                                       RECTWIDTH(&pncwm->rcW0[NCRC_SYSBTN]), RECTHEIGHT(&pncwm->rcW0[NCRC_SYSBTN]),
                                       0, NULL, DI_NORMAL))
                        {
                            break; // success; done
                        }

                        //  failure; try recycling the handle
                        if( _hAppIcon && GetLastError() == ERROR_INVALID_CURSOR_HANDLE )
                        {
                            _hAppIcon = NULL;
                            AcquireFrameIcon( pncwm->dwStyle, pncwm->dwExStyle, FALSE );

                            if( (++cRetries) > MAX_APPICON_RETRIES )
                            {
                                _hAppIcon = NULL; // failed to retrieve a new icon handle; bail for good.
                            }
                        }

                    } while( _hAppIcon && cRetries <= MAX_APPICON_RETRIES );

                    if( GDI_ERROR != dwLayout )
                    {
                        SetLayout(hdc, dwLayout);
                    }

                }
            }

            if( TESTFLAG( dwCaptionFlags, DC_TEXT ) )
            {
                //  Draw caption text
                HFONT  hf0 = NULL;
                DWORD  dwDTFlags = DT_SINGLELINE | DT_NOPREFIX | DT_END_ELLIPSIS;
                BOOL   fSelFont = FALSE;
                LPWSTR pszText = _AllocWindowText(_hwnd);

                if( pszText && *pszText )
                {
                    //  Compute frame text rect
                    if( pncwm->hfCaption )
                    {
                        hf0 = (HFONT)SelectObject( hdc, pncwm->hfCaption );
                        fSelFont = TRUE;
                    }

                    //---- compute text alignment ----
                    BOOL fReverse = TESTFLAG(_ncwm.dwExStyle, WS_EX_RIGHT);

                    dwDTFlags |= GetTextAlignFlags(_hTheme, pncwm, fReverse);
                }

                //---- adjust text align for WS_EX_RTLREADING ----
                if (TESTFLAG(_ncwm.dwExStyle, WS_EX_RTLREADING)) 
                    dwOldAlign = SetTextAlign(hdc, TA_RTLREADING | GetTextAlign(hdc));

                if( pszText && *pszText )
                {
                    //---- set options for DrawThemeText() ----
                    DTTOPTS DttOpts = {sizeof(DttOpts)};
                    DttOpts.dwFlags = DTT_TEXTCOLOR;
                    DttOpts.crText = pncwm->rgbCaption;

                    Log(LOG_RFBUG, L"Drawing Caption Text: left=%d, state=%d, text=%s",
                        pncwm->rcW0[NCRC_CAPTIONTEXT].left, pncwm->framestate, pszText);

                    //---- draw the caption text ----
                    DrawThemeTextEx(_hTheme, hdc, pncwm->rgframeparts[iCAPTION], pncwm->framestate, 
                        pszText, -1, dwDTFlags, &pncwm->rcW0[NCRC_CAPTIONTEXT], &DttOpts);
                }

                //---- free the text, if temp. allocated ----
                SAFE_DELETE_ARRAY(pszText)

                //---- draw the "Comments?" text ----
                SetBkMode( hdc, TRANSPARENT );
                SetTextColor( hdc, pncwm->rgbCaption );
                DrawLameButton(hdc, pncwm);

                //---- restore the text align ----
                if (TESTFLAG(_ncwm.dwExStyle, WS_EX_RTLREADING)) 
                    SetTextAlign(hdc, dwOldAlign);
            
                if( fSelFont )
                {
                    SelectObject(hdc, hf0);
                }
            }
            
            if( hdc != hdcOut )
            {
                //  Slap the bits on the output DC.
                BitBlt( hdcOut, pncwm->rcW0[NCRC_CAPTION].left, pncwm->rcW0[NCRC_CAPTION].top,
                        WIDTH(pncwm->rcW0[NCRC_CAPTION]), HEIGHT(pncwm->rcW0[NCRC_CAPTION]),
                        hdc, 0, 0, SRCCOPY );
                SelectObject(hdc, hbm0);
                DeleteDC(hdc);
            }

            LeaveNcThemePaint();
        }
        DeleteObject( hbmBuf );
    }

    if( IsWindowVisible(_hwnd) )
    {
        SetRenderedNcPart(RNCF_CAPTION);
    }
}

//-------------------------------------------------------------------------//
//  CThemeWnd::NcPaint() - NC painting worker
//
void CThemeWnd::NcPaint(
    IN OPTIONAL HDC    hdcIn,
    IN          ULONG  dwFlags,
    IN OPTIONAL HRGN   hrgnUpdate,
    IN OPTIONAL NCPAINTOVERIDE* pncpo)
{
    NCTHEMEMET  nctm;
    NCWNDMET*   pncwm = NULL;
    HDC         hdc   = NULL;

    if( _cLockRedraw > 0 ) 
        return;

    //  Compute all metrics before painting:
    if (pncpo) // preview override
    {
        ASSERT(hdcIn);
        hdc    = hdcIn;
        pncwm = pncpo->pncwm;
        nctm   = pncpo->nctm;
    }
    else       // live window
    {
        if( !GetNcWindowMetrics( NULL, &pncwm, &nctm, NCWMF_RECOMPUTE ) )
            return;

        //  Ensure status bits reflect caller's intention for frame state
        if( dwFlags != NCPF_DEFAULT )
        {
            _ComputeNcWindowStatus( _hwnd, TESTFLAG(dwFlags, NCPF_ACTIVEFRAME) ? WS_ACTIVECAPTION : 0, pncwm );
        }

        hdc = hdcIn ? hdcIn : _GetNonclientDC( _hwnd, hrgnUpdate );

        if (! hdc)
        {
            //---- don't assert here since stress (out of memory) could cause a legit failure ----
            Log(LOG_ALWAYS, L"call to GetDCEx() for nonclient painting failed");
        }
    }

    if( hdc != NULL )
    {
        //--- DO NOT EXIT FROM WITHIN THIS CONDITIONAL ---//
        
        BEGIN_DEBUG_NCPAINT();
        EnterNcThemePaint();

        //  Clip to content rect (alleviates flicker in menubar and scrollbars as we paint background)
        RECT rcClip;
        rcClip = pncwm->rcW0[NCRC_CONTENT];
        if( TESTFLAG(pncwm->dwExStyle, WS_EX_LAYOUTRTL) )
        {
            // mirror the clip rect relative to the window rect
            // and apply that as the clipping region for the dc
            MIRROR_RECT(pncwm->rcW0[NCRC_WINDOW], rcClip);
        }

        ExcludeClipRect( hdc, rcClip.left, rcClip.top, rcClip.right, rcClip.bottom );

        if( pncwm->fFrame )
        {
            //---- DrawThemeBackgroundEx() options ----
            DTBGOPTS dtbopts = {sizeof(dtbopts)};
            DTBGOPTS *pdtbopts = NULL;

            //  if not drawing preview, set "draw solid" option
            if(!pncpo)        
            {
                //  Because of the interleaving of NCPAINT and SetWindowRgn, drawing solid results 
                //  in some flicker and transparency bleed.  Commenting this out for now [scotthan]
                //dtbopts.dwFlags |= DTBG_DRAWSOLID;
                pdtbopts = &dtbopts;
            }

            //  Frame Background
            if( pncwm->fMin )
            {
                NcDrawThemeBackgroundEx( _hTheme, hdc, WP_MINCAPTION, pncwm->framestate,
                                         &pncwm->rcW0[NCRC_CAPTION], pdtbopts ) ;
            }
            else if( !pncwm->fFullMaxed )
            {
                NcDrawThemeBackgroundEx( _hTheme, hdc, pncwm->rgframeparts[iFRAMELEFT], pncwm->framestate,
                                         &pncwm->rcW0[NCRC_FRAMELEFT], pdtbopts );
                NcDrawThemeBackgroundEx( _hTheme, hdc, pncwm->rgframeparts[iFRAMERIGHT], pncwm->framestate,
                                         &pncwm->rcW0[NCRC_FRAMERIGHT], pdtbopts );
                NcDrawThemeBackgroundEx( _hTheme, hdc, pncwm->rgframeparts[iFRAMEBOTTOM], pncwm->framestate,
                                         &pncwm->rcW0[NCRC_FRAMEBOTTOM], pdtbopts );
            }

            SetRenderedNcPart(RNCF_FRAME);

            //  Caption
            NcPaintCaption( hdc, pncwm, !(pncwm->fMin || pncwm->fFullMaxed || pncpo),
                            DC_ENTIRECAPTION, pdtbopts );
        }

        //  Clip to client rect
        SelectClipRgn( hdc, NULL );

        //  Menubar
        if( !(pncwm->fMin || TESTFLAG(pncwm->dwStyle, WS_CHILD)) 
            && !IsRectEmpty(&pncwm->rcW0[NCRC_MENUBAR]) )
        {
            RECT rcMenuBar = pncwm->rcW0[NCRC_MENUBAR];
            BOOL fClip = RECTHEIGHT(&rcMenuBar) < pncwm->cyMenu;
             
            if( fClip )
            {
                IntersectClipRect( hdc, rcMenuBar.left, rcMenuBar.top, 
                                   rcMenuBar.right, rcMenuBar.bottom );
            }

            PaintMenuBar( _hwnd, hdc, pncwm->cnMenuOffsetLeft,
                          pncwm->cnMenuOffsetRight, pncwm->cnMenuOffsetTop,
                          TESTFLAG(pncwm->framestate, FS_ACTIVE) ? PMB_ACTIVE : 0 );
    
            //  deal with unpainted menubar pixels:
            if( nctm.dyMenuBar > 0 && RECTHEIGHT(&pncwm->rcW0[NCRC_MENUBAR]) >= pncwm->cyMenu )
            {
                rcMenuBar.top = rcMenuBar.bottom - nctm.dyMenuBar;
                COLORREF rgbBk = SetBkColor( hdc, GetSysColor(COLOR_MENU) );
                ExtTextOut(hdc, rcMenuBar.left, rcMenuBar.top, ETO_OPAQUE, &rcMenuBar, NULL, 0, NULL );
                SetBkColor( hdc, rgbBk );
            }

            if( fClip )
                SelectClipRgn( hdc, NULL );
        }

        //  Scrollbars
        if( !pncwm->fMin )
        {
            //  Draw static, window, client edges.
            _DrawWindowEdges( hdc, pncwm, pncwm->fFrame );

            RECT rcVScroll = pncwm->rcW0[NCRC_VSCROLL];
            if ( TESTFLAG(pncwm->dwExStyle, WS_EX_LAYOUTRTL) )
            {
                MIRROR_RECT(pncwm->rcW0[NCRC_WINDOW], rcVScroll);
            }

            if( TESTFLAG(pncwm->dwStyle, WS_VSCROLL) && 
                ( HasRenderedNcPart(RNCF_SCROLLBAR) || RectVisible(hdc, &rcVScroll)) )
            {
                if( TESTFLAG(pncwm->dwStyle, WS_HSCROLL) )
                {

                    //  Draw sizebox.
                    RECT rcSizeBox = pncwm->rcW0[NCRC_SIZEBOX];

                    if ( TESTFLAG(pncwm->dwExStyle, WS_EX_LAYOUTRTL) )
                    {
                        MIRROR_RECT(pncwm->rcW0[NCRC_WINDOW], rcSizeBox);
                    }

                    DrawSizeBox( _hwnd, hdc, rcSizeBox.left, rcSizeBox.top );
                }

                DrawScrollBar( _hwnd, hdc, pncpo ? &pncwm->rcW0[NCRC_VSCROLL]: NULL, TRUE /*vertical*/ );
                SetRenderedNcPart( RNCF_SCROLLBAR );
            }

            if( TESTFLAG(pncwm->dwStyle, WS_HSCROLL) && 
                ( HasRenderedNcPart(RNCF_SCROLLBAR) || RectVisible(hdc, &pncwm->rcW0[NCRC_HSCROLL])) )
            {
                DrawScrollBar( _hwnd, hdc, pncpo ? &pncwm->rcW0[NCRC_HSCROLL] : NULL, FALSE /*vertical*/ );
                SetRenderedNcPart( RNCF_SCROLLBAR );
            }
        }

        if (pncpo || hdcIn)
        {
            SelectClipRgn( hdc, NULL );
        }
        else
        {
            ReleaseDC( _hwnd, hdc );
        }

        LeaveNcThemePaint();
        END_DEBUG_NCPAINT();
    }
}

//-------------------------------------------------------------------------//
//  WM_STYLECHANGED themewnd instance handler
void CThemeWnd::StyleChanged( UINT iGWL, DWORD dwOld, DWORD dwNew )
{
    DWORD dwStyleOld, dwStyleNew, dwExStyleOld, dwExStyleNew;

    switch( iGWL )
    {
        case GWL_STYLE:
            dwStyleOld = dwOld;
            dwStyleNew = dwNew;
            dwExStyleOld = dwExStyleNew = GetWindowLong(_hwnd, GWL_EXSTYLE);
            break;

        case GWL_EXSTYLE:
            dwExStyleOld = dwOld;
            dwExStyleNew = dwNew;
            dwStyleOld = dwStyleNew = GetWindowLong(_hwnd, GWL_STYLE);
            break;

        default:
            return;
    }

    DWORD fClassFlagsOld  = CThemeWnd::EvaluateStyle( dwStyleOld, dwExStyleOld);
    DWORD fClassFlagsNew  = CThemeWnd::EvaluateStyle( dwStyleNew, dwExStyleNew);

    //  Update theme class flags.
    //  Always keep the scrollbar class flag if the window had it initially. User
    //  flips scroll styles on and off without corresponding style change notification.
    _fClassFlags = fClassFlagsNew | (_fClassFlags & TWCF_SCROLLBARS);
    _fFrameThemed = TESTFLAG( _fClassFlags, TWCF_FRAME|TWCF_TOOLFRAME );        

    //  Are we losing the frame?
    if( TESTFLAG( fClassFlagsOld, TWCF_FRAME|TWCF_TOOLFRAME ) &&
        !TESTFLAG( fClassFlagsNew, TWCF_FRAME|TWCF_TOOLFRAME ) )
    {
        ThemeMDIMenuButtons(FALSE, FALSE);

        if( AssignedFrameRgn() )
        {
            AssignFrameRgn(FALSE /*strip off frame rgn*/, FTF_REDRAW);
        }
    }
    //  Are we gaining a frame?
    else if( TESTFLAG( fClassFlagsNew, TWCF_FRAME|TWCF_TOOLFRAME ) &&
            !TESTFLAG( fClassFlagsOld, TWCF_FRAME|TWCF_TOOLFRAME ) )
    {
        SetFrameTheme(0, NULL);
    }

    //  Freshen window metrics
    GetNcWindowMetrics( NULL, NULL, NULL, NCWMF_RECOMPUTE );
}

//-------------------------------------------------------------------------//
//  ThemeDefWindowProc message handlers
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
//  WM_THEMECHANGED post-wndproc msg handler
LRESULT CALLBACK OnOwpPostThemeChanged( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    if (IS_THEME_CHANGE_TARGET(ptm->lParam))
    {
        //---- avoid redundant retheming (except for SetWindowTheme() calls)
        if ((HTHEME(*pwnd) == _nctmCurrent.hTheme) && (! (ptm->lParam & WTC_CUSTOMTHEME)))
        {
            Log(LOG_NCATTACH, L"OnOwpPostThemeChanged, just kicking the frame");

            //---- window got correct theme thru _XXXWindowProc() from sethook ----
            //---- we just need to redraw the frame for all to be right ----
            if (pwnd->IsFrameThemed())
            {
                //---- attach the region to the window now ----
                pwnd->SetFrameTheme(FTF_REDRAW, NULL);
            }
        }
        else
        {
            Log(LOG_NCATTACH, L"OnOwpPostThemeChanged, calling Full ::ChangeTheme()");

            //---- its a real, app/system theme change ----
            pwnd->ChangeTheme( ptm );
        }
    }

    MsgHandled( ptm );
    return 1L;
}

//-------------------------------------------------------------------------//
void CThemeWnd::ChangeTheme( THEME_MSG* ptm )
{
    if( _hTheme )       // hwnd attached for previous theme
    {
        //  do a lightweight detach from current theme
        _DetachInstance( HMD_CHANGETHEME );
    }

    if( IsAppThemed() )           // new theme is active
    {
        //  retrieve window client rect, style bits.
        WINDOWINFO wi;
        wi.cbSize = sizeof(wi);
        GetWindowInfo( ptm->hwnd, &wi );
        ULONG ulTargetFlags = EvaluateStyle( wi.dwStyle, wi.dwExStyle );
        
        //  If the window is themable
        if( TESTFLAG(ulTargetFlags, TWCF_NCTHEMETARGETMASK) )
        {
            //  Open the new theme
            HTHEME hTheme = ::OpenNcThemeData( ptm->hwnd, L"Window" );

            if( hTheme )
            {
                //  do a lightweight attach
                if( _AttachInstance( ptm->hwnd, hTheme, ulTargetFlags, NULL ) )
                {
                    //  reattach scrollbars
                    if( TESTFLAG( ulTargetFlags, TWCF_SCROLLBARS ) )
                    {
                        AttachScrollBars(ptm->hwnd);
                    }

                    if (IsFrameThemed())
                    {
                        //---- attach the region to the window now ----
                        SetFrameTheme(FTF_REDRAW, NULL);
                    }
                }
                else
                {
                    CloseThemeData( hTheme );
                }
            }
        }
    }

    if (! _hTheme)      // if an hwnd is no longer attached
    {
        // Left without a theme handle: This means either we failed to open a new theme handle or
        // failed to evaulate as a target, no new theme, etc.
        RemoveWindowProperties(ptm->hwnd, FALSE);

        //---- release our CThemeWnd obj so it doesn't leak (addref-protected by caller) ----
        Release();
    }

}
//-------------------------------------------------------------------------//
BOOL IsPropertySheetChild(HWND hDlg)
{
    while(hDlg)
    {
        ULONG ulFlags = HandleToUlong(GetProp(hDlg, MAKEINTATOM(GetThemeAtom(THEMEATOM_DLGTEXTURING))));

        if( ETDT_ENABLETAB == (ulFlags & ETDT_ENABLETAB) /* all bits in this mask are required */ )
        {
            return TRUE;
        }
        hDlg = GetAncestor(hDlg, GA_PARENT);
    }

    return FALSE;
}
//---------------------------------------------------------------------------
void PrintClientNotHandled(HWND hwnd)
{
    ATOM aIsPrinting = GetThemeAtom(THEMEATOM_PRINTING);
    DWORD dw = PtrToUlong(GetProp(hwnd, (PCTSTR)aIsPrinting));
    if (dw == PRINTING_ASKING)
        SetProp(hwnd, (PCTSTR)aIsPrinting, (HANDLE)PRINTING_WINDOWDIDNOTHANDLE);
}

//---------------------------------------------------------------------------
HBRUSH GetDialogColor(HWND hwnd, NCTHEMEMET &nctm)
{
    HBRUSH hbr = NULL;

    //  if this is a PROPSHEET child or the app called
    //  EnableThemeDialogTexture() on this hwnd, we'll use the tab background.
    if (IsPropertySheetChild(hwnd))
    {
        hbr = nctm.hbrTabDialog;
    }

    if( NULL == hbr )
    {
        hbr = GetSysColorBrush(COLOR_3DFACE);
    }

    return hbr;
}
//---------------------------------------------------------------------------
LRESULT CALLBACK OnDdpPrint(CThemeWnd* pwnd, THEME_MSG* ptm)
{
    LRESULT lRet = 0L;
    if (!ptm->lRet)
    {
        if (pwnd->HasProcessedEraseBk())
        {
            RECT rc;
            HDC hdc = (HDC)ptm->wParam;
            NCTHEMEMET nctm;
            if( GetCurrentNcThemeMetrics( &nctm ))
            {
                HBRUSH hbr = GetDialogColor(*pwnd, nctm);
                
                if (hbr)
                {
                    POINT pt;

                    if (GetClipBox(hdc, &rc) == NULLREGION)
                        GetClientRect(*pwnd, &rc);

                    SetBrushOrgEx(hdc, -rc.left, -rc.top, &pt);
                    FillRect(hdc, &rc, hbr);
                    SetBrushOrgEx(hdc, pt.x, pt.y, NULL);

                    lRet = (LRESULT)1;
                    MsgHandled( ptm );
                }
            }
        }
        else
        {
            PrintClientNotHandled(*pwnd);
        }
    }

    return lRet;
}

//---------------------------------------------------------------------------
LRESULT CALLBACK OnDdpCtlColor(CThemeWnd* pwnd, THEME_MSG *ptm )
{
    LRESULT lRet = 0L;
    if (!ptm->lRet && pwnd->HasProcessedEraseBk())
    {
        NCTHEMEMET nctm;
        if( GetCurrentNcThemeMetrics( &nctm ))
        {
            HBRUSH hbr = GetDialogColor(*pwnd, nctm);
            if (hbr)
            {
                RECT     rc;
                HDC      hdc = (HDC)ptm->wParam;

                GetWindowRect(((HWND)ptm->lParam), &rc);
                MapWindowPoints(NULL, *pwnd, (POINT*)&rc, 2);
                SetBkMode(hdc, TRANSPARENT);
                SetBrushOrgEx(hdc, -rc.left, -rc.top, NULL);

                // the hdc's default background color needs to be set
                // for for those controls that insist on using OPAQUE
                SetBkColor(hdc, GetSysColor(COLOR_BTNFACE));

                lRet = (LRESULT)hbr;
                MsgHandled( ptm );
            }
        }
    }
    return lRet;
}

//-------------------------------------------------------------------------//
//  WM_CTLCOLORxxx defwindowproc override handler
LRESULT CALLBACK OnDdpPostCtlColor( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    LRESULT lRet = 0L;
    if (!ptm->lRet)
    {
        // This is sent to the parent in the case of WM_CTLCOLORMSGBOX, but to the
        // dialog itself in the case of a WM_CTLCOLORDLG. This gets both.
        CThemeWnd* pwndDlg = CThemeWnd::FromHwnd((HWND)ptm->lParam);


        // WM_CTLCOLORMSGBOX is sent for Both the dialog AND the static
        // control inside. So we need to sniff: Are we talking to a dialog or a 
        // control. the pwnd is associated with the dialog, but not the control
        if (pwndDlg && VALID_THEMEWND(pwndDlg))
        {
            if (IsPropertySheetChild(*pwnd))
            {
                NCTHEMEMET nctm;
                if( GetCurrentNcThemeMetrics( &nctm ))
                {
                    HBRUSH hbr = GetDialogColor(*pwndDlg, nctm);
                    if (hbr)
                    {
                        lRet = (LRESULT) hbr;
                        pwndDlg->ProcessedEraseBk(TRUE);
                        MsgHandled(ptm);
                    }
                }
            }
        }
        else
        {
            // If we're talking to a control, forward to the control handler
            // because we have to offset the brush
            lRet = OnDdpCtlColor(pwnd, ptm );

        }
    }
    return lRet;
}

//-------------------------------------------------------------------------//
LRESULT CALLBACK OnDwpPrintClient( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    PrintClientNotHandled(*pwnd);

    return 0;
}



//---- Non-Client ----

//-------------------------------------------------------------------------//
//  WM_NCPAINT pre-wndmproc msg handler
LRESULT CALLBACK OnOwpPreNcPaint( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    NcPaintWindow_Add(*pwnd);

    if( !pwnd->InNcPaint() )
    {
        pwnd->ClearRenderedNcPart(RNCF_ALL); 
    }
    pwnd->EnterNcPaint();
    return 0L;
}

//-------------------------------------------------------------------------//
//  WM_NCPAINT DefWindowProc msg handler
LRESULT CALLBACK OnDwpNcPaint( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    LRESULT lRet = 0L;
    if( !pwnd->IsNcThemed() )
        return lRet;

    if( IsWindowVisible(*pwnd) )
    {
        pwnd->NcPaint( NULL, NCPF_DEFAULT, 1 == ptm->wParam ? NULL : (HRGN)ptm->wParam, NULL );
    }

    MsgHandled( ptm );
    return lRet;
}

//-------------------------------------------------------------------------//
//  WM_NCPAINT post-wndmproc msg handler
LRESULT CALLBACK OnOwpPostNcPaint( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    pwnd->LeaveNcPaint();
    NcPaintWindow_Remove();
    return 0L;
}

//-------------------------------------------------------------------------//
//  WM_PRINT DefWindowProc msg handler
LRESULT CALLBACK OnDwpPrint( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    LRESULT lRet = DoMsgDefault(ptm);
    if( !pwnd->IsNcThemed() )
        return lRet;

    if( ptm->lParam & PRF_NONCLIENT )
    {
        int iLayoutSave = GDI_ERROR;
        HDC hdc = (HDC)ptm->wParam;

        if (TESTFLAG(GetWindowLong(*pwnd, GWL_EXSTYLE), WS_EX_LAYOUTRTL))
        {
            // AnimateWindow sends WM_PRINT with an unmirrored memory hdc 
            iLayoutSave = SetLayout(hdc, LAYOUT_RTL);
        }

        pwnd->NcPaint( (HDC)ptm->wParam, NCPF_DEFAULT, NULL, NULL );

        if (iLayoutSave != GDI_ERROR)
        {
            SetLayout(hdc, iLayoutSave);
        }
    }

    return lRet;
}

//-------------------------------------------------------------------------//
//  WM_NCUAHDRAWCAPTION DefWindowProc msg handler
LRESULT CALLBACK OnDwpNcThemeDrawCaption( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    LRESULT lRet = 0L;
    if( !pwnd->IsNcThemed() || !pwnd->HasRenderedNcPart(RNCF_CAPTION) )
        return lRet;

    NCWNDMET* pncwm;
    if( pwnd->GetNcWindowMetrics( NULL, &pncwm, NULL, NCWMF_RECOMPUTE ) )
    {
        HDC hdc = _GetNonclientDC( *pwnd, NULL );
        if( hdc )
        {
            DTBGOPTS dtbo;
            dtbo.dwSize = sizeof(dtbo);
            dtbo.dwFlags = DTBG_DRAWSOLID;
            
            pwnd->NcPaintCaption( hdc, pncwm, TRUE, (DWORD)ptm->wParam, &dtbo );
            ReleaseDC( *pwnd, hdc );
            MsgHandled( ptm );
        }
    }

    return lRet;
}

//-------------------------------------------------------------------------//
//  WM_NCUAHDRAWFRAME DefWindowProc msg handler
LRESULT CALLBACK OnDwpNcThemeDrawFrame( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    LRESULT lRet = 0L;
    if( !pwnd->IsNcThemed() || !pwnd->HasRenderedNcPart(RNCF_FRAME) )
        return lRet;

    pwnd->NcPaint( (HDC)ptm->wParam, ptm->lParam & DF_ACTIVE ? NCPF_ACTIVEFRAME : NCPF_INACTIVEFRAME, NULL, NULL );

    MsgHandled( ptm );
    return lRet;
}

//-------------------------------------------------------------------------//
CMdiBtns* CThemeWnd::LoadMdiBtns( IN OPTIONAL HDC hdc, IN OPTIONAL UINT uSysCmd )
{
    if( NULL == _pMdiBtns && NULL == (_pMdiBtns = new CMdiBtns) )
    {
        return NULL;
    }

    return _pMdiBtns->Load( _hTheme, hdc, uSysCmd ) ? _pMdiBtns : NULL;
}

//-------------------------------------------------------------------------//
void CThemeWnd::UnloadMdiBtns( IN OPTIONAL UINT uSysCmd )
{
    SAFE_DELETE(_pMdiBtns);
}

//-------------------------------------------------------------------------//
//  WM_MEASUREITEM pre-wndproc msg handler
LRESULT CALLBACK OnOwpPreMeasureItem( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    if( pwnd->IsNcThemed() && IsWindow(pwnd->GetMDIClient()) )
    {
        MEASUREITEMSTRUCT* pmis = (MEASUREITEMSTRUCT*)ptm->lParam;

        CMdiBtns* pBtns = pwnd->LoadMdiBtns( NULL, pmis->itemID );
        if( pBtns )
        {
            if( pBtns->Measure( *pwnd, pmis ) )
            {
                MsgHandled(ptm);
                return TRUE;
            }
        }
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
//  WM_DRAWITEM pre-wndproc msg handler
LRESULT CALLBACK OnOwpPreDrawItem( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    if( pwnd->IsNcThemed() && IsWindow(pwnd->GetMDIClient()) )
    {
        DRAWITEMSTRUCT* pdis = (DRAWITEMSTRUCT*)ptm->lParam;

        CMdiBtns* pBtns = pwnd->LoadMdiBtns( NULL, pdis->itemID );
        if( pBtns )
        {
            if( pBtns->Draw( *pwnd, pdis ) )
            {
                MsgHandled(ptm);
                return TRUE;
            }
        }
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
//  WM_MENUCHAR pre-wndproc msg handler
LRESULT CALLBACK OnOwpPreMenuChar( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    //  Route MENUCHAR messages relating to themed MDI buttons to
    //  DefWindowProc (some apps assume all owner-drawn menuitems
    //  belong to themselves).
    HWND hwndMDIClient = pwnd->GetMDIClient();

    if( pwnd->IsNcThemed() && IsWindow(hwndMDIClient))
    {
        if( LOWORD(ptm->wParam) == TEXT('-') )
        {
            BOOL fMaxedChild;
            HWND hwndActive = _MDIGetActive(hwndMDIClient, &fMaxedChild );
            if( hwndActive && fMaxedChild )
            {
                MsgHandled(ptm);
                return DefFrameProc(ptm->hwnd, hwndMDIClient, ptm->uMsg, 
                                    ptm->wParam, ptm->lParam);
            }
        }
    }
    return 0L;
}

//-------------------------------------------------------------------------//
//  WM_NCHITTEST DefWindowProc msg handler
LRESULT CALLBACK OnDwpNcHitTest( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    if( !pwnd->IsNcThemed() )
        return DoMsgDefault( ptm );

    NCTHEMEMET nctm;
    NCWNDMET*  pncwm;
    POINT      pt;
    MAKEPOINT( pt, ptm->lParam );
    MsgHandled( ptm );

    if( pwnd->GetNcWindowMetrics( NULL, &pncwm, &nctm, 0 ) )
    {
        if( _StrictPtInRect( &pncwm->rcS0[NCRC_CLIENT], pt ) )
            return HTCLIENT;

        if( _StrictPtInRect( &pncwm->rcS0[NCRC_HSCROLL], pt ) )
            return HTHSCROLL;

        if( _StrictPtInRect( &pncwm->rcS0[NCRC_SIZEBOX], pt ) )
        {
            if (SizeBoxHwnd(*pwnd) && !TESTFLAG(pncwm->dwExStyle, WS_EX_LEFTSCROLLBAR))

            {
                return TESTFLAG(pncwm->dwExStyle, WS_EX_LAYOUTRTL) ? HTBOTTOMLEFT : HTBOTTOMRIGHT;
            }
            else
            {
                return HTGROWBOX;
            }
        }

        if ( TESTFLAG(pncwm->dwExStyle, WS_EX_LAYOUTRTL) )
        {
            // mirror the point to hittest correctly
            MIRROR_POINT(pncwm->rcS0[NCRC_WINDOW], pt);
        }

        if( _StrictPtInRect( &pncwm->rcS0[NCRC_VSCROLL], pt ) )
            return HTVSCROLL;

        if( _StrictPtInRect( &pncwm->rcS0[NCRC_MENUBAR], pt ) )
            return HTMENU;

        if( pncwm->fFrame )
        {
            RECT rcButton;
            
            // ---- close button ----
            _GetNcBtnHitTestRect( pncwm, HTCLOSE, FALSE, &rcButton );

            if ( _StrictPtInRect( &rcButton, pt ) )
            {
                return HTCLOSE;
            }

            // ---- minimize button ----
            _GetNcBtnHitTestRect( pncwm, HTMINBUTTON, FALSE, &rcButton );

            if ( _StrictPtInRect( &rcButton, pt ) )
            {
                return HTMINBUTTON;
            }

            // ---- maximize button ----
            _GetNcBtnHitTestRect( pncwm, HTMAXBUTTON, FALSE, &rcButton );

            if ( _StrictPtInRect( &rcButton, pt ) )
            {
                return HTMAXBUTTON;
            }

            // ---- sys menu ----
            _GetNcBtnHitTestRect( pncwm, HTSYSMENU, FALSE, &rcButton );

            if ( _StrictPtInRect( &rcButton, pt ) )
            {
                return HTSYSMENU;
            }

            // ---- help button ----
            _GetNcBtnHitTestRect( pncwm, HTHELP, FALSE, &rcButton );

            if ( _StrictPtInRect( &rcButton, pt ) )
            {
                return HTHELP;
            }
        
#ifdef LAME_BUTTON
            if ( TESTFLAG(pncwm->dwExStyle, WS_EX_LAMEBUTTON) )
            {
                if ( _StrictPtInRect( &pncwm->rcS0[NCRC_LAMEBTN], pt ) )
                    return HTLAMEBUTTON;
            }
#endif // LAME_BUTTON

            // don't need a mirrored point for the remaining hittests
            MAKEPOINT( pt, ptm->lParam );

            if( !_StrictPtInRect( &pncwm->rcS0[NCRC_CONTENT], pt ) )
            {
                if( pncwm->fMin || pncwm->fMaxed )
                {
                    if( _StrictPtInRect( &pncwm->rcS0[NCRC_CAPTION], pt ) )
                        return HTCAPTION;
                }

                //---- combined caption/frame case ----
                return pwnd->NcBackgroundHitTest( pt, &pncwm->rcS0[NCRC_WINDOW], pncwm->dwStyle, pncwm->dwExStyle, 
                                                  pncwm->framestate, pncwm->rgframeparts, pncwm->rgsizehitparts,
                                                  pncwm->rcS0 + NCRC_FRAMEFIRST ); 
            }
        }
    }

    return DoMsgDefault( ptm );
}


//-------------------------------------------------------------------------//
//  WM_WINDOWPOSCHANGING pre-wndproc override handler
LRESULT CALLBACK OnOwpPreWindowPosChanging( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    if( pwnd->IsFrameThemed() )
    {
        //  Suppress WM_WINDOWPOSCHANGING from being sent to wndproc if it
        //  was generated by us calling SetWindowRgn.   
        
        //  Many apps (e.g. Adobe Acrobat Reader, Photoshop dialogs, etc) that handle 
        //  WM_NCCALCSIZE, WM_WINDOWPOSCHANGING and/or WM_WINDOWPOSCHANGED are not 
        //  reentrant on their handlers for these messages, and therefore botch the
        //  recursion induced by our SetWindowRgn call when we post-process 
        //  WM_WINDOWPOSCHANGED.

        //  There is no reason that a theme-complient wndproc should ever know that
        //  it's window(s) host a region managed by the system.
        if( pwnd->AssigningFrameRgn() )
        {
            MsgHandled(ptm);
            return DefWindowProc(ptm->hwnd, ptm->uMsg, ptm->wParam, ptm->lParam);
        }
    }
    return 0L;
}

//-------------------------------------------------------------------------//
//  WM_WINDOWPOSCHANGED pre-wndproc override handler
LRESULT CALLBACK OnOwpPreWindowPosChanged( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    if( pwnd->IsFrameThemed() )
    {
        //  Suppress WM_WINDOWPOSCHANGING from being sent to wndproc if it
        //  was generated by us calling SetWindowRgn.   
        
        //  Many apps (e.g. Adobe Acrobat Reader, Photoshop dialogs, etc) that handle 
        //  WM_NCCALCSIZE, WM_WINDOWPOSCHANGING and/or WM_WINDOWPOSCHANGED are not 
        //  reentrant on their handlers for these messages, and therefore botch the
        //  recursion induced by our SetWindowRgn call when we post-process
        //  WM_WINDOWPOSCHANGED.

        //  There is no reason that a theme-complient wndproc should ever know that
        //  it's window(s) host a region managed by the system.

        if( pwnd->AssigningFrameRgn() )
        {
            MsgHandled(ptm);
            return DefWindowProc(ptm->hwnd, ptm->uMsg, ptm->wParam, ptm->lParam);
        }
    }
    return 0L;
}

//-------------------------------------------------------------------------//
//  WM_WINDOWPOSCHANGED message handler
inline LRESULT WindowPosChangedWorker( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    if( pwnd->IsRevoked(RF_DEFER) )
    {
        if( !pwnd->IsRevoked(RF_INREVOKE) )
        {
            pwnd->Revoke(); // don't touch PWND after this!
        }
    }
    else if( pwnd->IsNcThemed() && !IsWindowInDestroy(*pwnd) )
    {
        //  If were not resizing, update the window region.
        if( pwnd->IsFrameThemed() )
        {
            NCWNDMET*  pncwm = NULL;
            NCTHEMEMET nctm = {0};

            //  Freshen per-window metrics 
            if( !pwnd->AssigningFrameRgn() )
            {
                WINDOWPOS *pWndPos = (WINDOWPOS*) ptm->lParam;

                //  Freshen this window's per-window metrics
                pwnd->GetNcWindowMetrics( NULL, &pncwm, &nctm, NCWMF_RECOMPUTE );

                //  Freshen window metrics for nc-themed children (e.g., MDI child frames)
                EnumChildWindows( *pwnd, _FreshenThemeMetricsCB, NULL );

                if( !TESTFLAG(pWndPos->flags, SWP_NOSIZE) || pwnd->DirtyFrameRgn() || 
                     TESTFLAG(pWndPos->flags, SWP_FRAMECHANGED) )
                {
                    if( pWndPos->cx > 0 && pWndPos->cy > 0 )
                    {
                        pwnd->AssignFrameRgn( TRUE, FTF_REDRAW );
                    }
                }
            }
        }

        _MDIUpdate( *pwnd, ((WINDOWPOS*) ptm->lParam)->flags);
    }
    return 0L;
}

//-------------------------------------------------------------------------//
//  WM_WINDOWPOSCHANGED post-wndproc override handler
//  
//  Note: we'll handle this post-wndproc for normal, client-side wndprocs
LRESULT CALLBACK OnOwpPostWindowPosChanged( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    if( !IsServerSideWindow(ptm->hwnd) )
    {
        return WindowPosChangedWorker( pwnd, ptm );
    }
    return 0L;
}

//-------------------------------------------------------------------------//
//  WM_WINDOWPOSCHANGED DefWindowProc override handler.
//  
//  Note: we'll handle this in DefWindowProc only for windows with win32k-based
//  wndprocs, which are deprived of OWP callbacks.
LRESULT CALLBACK OnDwpWindowPosChanged( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    if( IsServerSideWindow(ptm->hwnd) )
    {
        WindowPosChangedWorker( pwnd, ptm );
    }
    return 0L;
}

//-------------------------------------------------------------------------//
//  WM_NACTIVATE DefWindowProc msg handler
LRESULT CALLBACK OnDwpNcActivate( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    LRESULT lRet = 1L;

    if( pwnd->IsNcThemed() )
    {
        // We need to forward on.  The DWP remembers the state
        // and MFC apps (for one) need this as well
        // but we don't want to actually paint, so lock the window
        ptm->lParam = (LPARAM)-1;
        lRet = DoMsgDefault(ptm);

        pwnd->NcPaint( NULL, ptm->wParam ? NCPF_ACTIVEFRAME : NCPF_INACTIVEFRAME, NULL, NULL );
        MsgHandled(ptm);
    }

    return lRet;
}

//-------------------------------------------------------------------------//
BOOL CThemeWnd::ShouldTrackFrameButton( UINT uHitcode )
{
    switch(uHitcode)
    {
        case HTHELP:
            return TESTFLAG(_ncwm.dwExStyle, WS_EX_CONTEXTHELP);

        case HTMAXBUTTON:
            if( !TESTFLAG(_ncwm.dwStyle, WS_MAXIMIZEBOX) || 
                 (CBS_DISABLED == _ncwm.rawMaxBtnState && FS_ACTIVE == _ncwm.framestate) )
            {
                break;
            }
            return TRUE;

        case HTMINBUTTON:
            if( !TESTFLAG(_ncwm.dwStyle, WS_MINIMIZEBOX) || 
                (CBS_DISABLED == _ncwm.rawMinBtnState && FS_ACTIVE == _ncwm.framestate) )
            {
                break;
            }
            return TRUE;

        case HTCLOSE:
            if( !_MNCanClose(_hwnd) || 
                (CBS_DISABLED == _ncwm.rawCloseBtnState && FS_ACTIVE == _ncwm.framestate) )
            {
                break;
            }
            return TRUE;

        case HTSYSMENU:
            return TESTFLAG(_ncwm.dwStyle, WS_SYSMENU);
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
//  WM_NCLBUTTONDOWN DefWindowProc msg handler
LRESULT CALLBACK OnDwpNcLButtonDown( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    WPARAM uSysCmd = 0;
    MsgHandled( ptm );

    switch( ptm->wParam /* hittest code */ )
    {
        case HTHELP:
        case HTMAXBUTTON:
        case HTMINBUTTON:
        case HTCLOSE:
        case HTSYSMENU:
            if( pwnd->ShouldTrackFrameButton(ptm->wParam) )
            {
                if( pwnd->HasRenderedNcPart(RNCF_CAPTION) )
                {
                    POINT      pt;
                    MAKEPOINT( pt, ptm->lParam );
                    if( !pwnd->TrackFrameButton( *pwnd, (int)ptm->wParam, &uSysCmd ) )
                    {
                        return DoMsgDefault( ptm );
                    }
                }
                else
                {
                    return DoMsgDefault( ptm );
                }
            }
            break;

        case HTHSCROLL:
        case HTVSCROLL:
            if( pwnd->HasRenderedNcPart(RNCF_SCROLLBAR) )
            {
                uSysCmd = ptm->wParam | ((ptm->wParam == HTVSCROLL) ? SC_HSCROLL:SC_VSCROLL);

                break;
            }

            // fall thru

        default:
            return DoMsgDefault( ptm );
    }

    // TODO USER will ignore system command if it is disabled on system menu here,
    // don't know why.  Imitating the code caused standard min/max/close buttons to
    // render so be careful.

    if( uSysCmd != 0 )
    {
        SendMessage( *pwnd, WM_SYSCOMMAND, uSysCmd, ptm->lParam );
    }

    return 0L;
}


//-------------------------------------------------------------------------//
//  WM_NCMOUSEMOVE DefWindowProc msg handler
LRESULT CALLBACK OnDwpNcMouseMove(CThemeWnd* pwnd, THEME_MSG *ptm)
{
    LRESULT lRet = DoMsgDefault(ptm);

    int htHotLast = pwnd->GetNcHotItem();
    int htHot;

    //
    // If the mouse has just entered the NC area, request
    // that we be notified when it leaves. 
    //
    if (htHotLast == HTERROR)
    {
        TRACKMOUSEEVENT tme;

        tme.cbSize      = sizeof(tme);
        tme.dwFlags     = TME_LEAVE | TME_NONCLIENT;
        tme.hwndTrack   = *pwnd;
        tme.dwHoverTime = 0;

        TrackMouseEvent(&tme);
    }

    //
    // Filter out the NC elements we don't care about hottracking. And only
    // track the element if we've previously rendered it. Some apps handle
    // painting non-client elements by handling ncpaint. They may not expect 
    // that we now hottrack.
    //
    if ( (IsHTFrameButton(ptm->wParam) && pwnd->HasRenderedNcPart(RNCF_CAPTION) && 
          pwnd->ShouldTrackFrameButton(ptm->wParam)) || 

         (IsHTScrollBar(ptm->wParam) && pwnd->HasRenderedNcPart(RNCF_SCROLLBAR)) )
    {
        htHot = (int)ptm->wParam;
    }
    else
    {
        htHot = HTNOWHERE;
    }

    //
    // anything to do?
    //
    if ((htHot != htHotLast) || IsHTScrollBar(htHot) || IsHTScrollBar(htHotLast))
    {
        POINT pt;

        MAKEPOINT( pt, ptm->lParam );

        //
        // save the hittest code of the NC element the mouse is 
        // currently over
        //
        pwnd->SetNcHotItem(htHot);

        //
        // Determine what should be repainted because the mouse
        // is no longer over it
        //
        if ( IsHTFrameButton(htHotLast) && pwnd->HasRenderedNcPart(RNCF_CAPTION) )
        {
            pwnd->TrackFrameButton(*pwnd, htHotLast, NULL, TRUE);
        }
        else if ( IsHTScrollBar(htHotLast) && pwnd->HasRenderedNcPart(RNCF_SCROLLBAR) )
        {
            ScrollBar_MouseMove(*pwnd, (htHot == htHotLast) ? &pt : NULL, (htHotLast == HTVSCROLL) ? TRUE : FALSE);
        }

        //
        // Determine what should be repainted because the mouse
        // is now over it
        //
        if ( IsHTFrameButton(htHot) && pwnd->HasRenderedNcPart(RNCF_CAPTION) )
        {
            pwnd->TrackFrameButton(*pwnd, htHot, NULL, TRUE);
        }
        else if ( IsHTScrollBar(htHot) && pwnd->HasRenderedNcPart(RNCF_SCROLLBAR) )
        {
            ScrollBar_MouseMove(*pwnd, &pt, (htHot == HTVSCROLL) ? TRUE : FALSE);
        }

    }

    return lRet;
}

//-------------------------------------------------------------------------//
//  WM_NCMOUSELEAVE DefWindowProc msg handler
LRESULT CALLBACK OnDwpNcMouseLeave(CThemeWnd* pwnd, THEME_MSG *ptm)
{
    LRESULT lRet = DoMsgDefault(ptm);

    int     htHot = pwnd->GetNcHotItem();

    //
    // the mouse has left NC area, nothing should be drawn in the
    // hot state anymore
    //
    pwnd->SetNcHotItem(HTERROR);

    if ( IsHTFrameButton(htHot) && pwnd->ShouldTrackFrameButton(htHot) &&
         pwnd->HasRenderedNcPart(RNCF_CAPTION) )
    {
        pwnd->TrackFrameButton(*pwnd, htHot, NULL, TRUE);
    }
    else if ( IsHTScrollBar(htHot) && pwnd->HasRenderedNcPart(RNCF_SCROLLBAR) )
    {
        ScrollBar_MouseMove(*pwnd, NULL, (htHot == HTVSCROLL) ? TRUE : FALSE);
    }

    return lRet;
}

//-------------------------------------------------------------------------//
//  WM_CONTEXTMENU DefWindowProc msg handler
LRESULT CALLBACK OnDwpContextMenu(CThemeWnd* pwnd, THEME_MSG *ptm)
{
    NCWNDMET*  pncwm;
    POINT      pt;
    MAKEPOINT( pt, ptm->lParam );
    MsgHandled( ptm );

    if( pwnd->GetNcWindowMetrics( NULL, &pncwm, NULL, 0 ) )
    {
        if ( TESTFLAG(pncwm->dwExStyle, WS_EX_LAYOUTRTL) )
        {
            // mirror the point to hittest correctly
            MIRROR_POINT(pncwm->rcS0[NCRC_WINDOW], pt);
        }

        if( _StrictPtInRect( &pncwm->rcS0[NCRC_HSCROLL], pt ) )
        {
            ScrollBar_Menu(*pwnd, *pwnd, ptm->lParam, FALSE);
            return 0;
        }

        if( _StrictPtInRect( &pncwm->rcS0[NCRC_VSCROLL], pt ) )
        {
            ScrollBar_Menu(*pwnd, *pwnd, ptm->lParam, TRUE);
            return 0;
        }
    }

    return DoMsgDefault( ptm );
}

//-------------------------------------------------------------------------//
//  WM_SYSCOMMAND DefWindowProc msg handler
LRESULT CALLBACK OnDwpSysCommand( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    LRESULT lRet = 0L;

    switch( ptm->wParam & ~0x0F )
    {
        //  Handle scroll commands
        case SC_VSCROLL:
        case SC_HSCROLL:
            HandleScrollCmd( *pwnd, ptm->wParam, ptm->lParam );
            MsgHandled( ptm );
            return lRet;
    }
    return DoMsgDefault( ptm );
}

//-------------------------------------------------------------------------//
//  MDI menubar button theme/untheme wrapper
void CThemeWnd::ThemeMDIMenuButtons( BOOL fTheme, BOOL fRedraw )
{
    //  Verify we're an MDI frame with a maximized mdi child
    if( _hwndMDIClient && !IsWindowInDestroy(_hwndMDIClient) )
    {
        BOOL fMaxed = FALSE;
        HWND hwndActive = _MDIGetActive( _hwndMDIClient, &fMaxed );
    
        if( hwndActive && fMaxed )
        {
            ModifyMDIMenubar(fTheme, fRedraw );
        }
    }
}

//-------------------------------------------------------------------------//
//  MDI menubar button theme/untheme worker
void CThemeWnd::ModifyMDIMenubar( BOOL fTheme, BOOL fRedraw )
{
    _fThemedMDIBtns = FALSE;

    if( IsFrameThemed() || !fTheme )
    {
        MENUBARINFO mbi;
        mbi.cbSize = sizeof(mbi);

        if( GetMenuBarInfo( _hwnd, OBJID_MENU, 0, &mbi ) )
        {
            _NcTraceMsg( NCTF_MDIBUTTONS, TEXT("ModifyMDIMenubar: GetMenuBarInfo() returns hMenu: %08lX, hwndMenu: %08lX"), mbi.hMenu, mbi.hwndMenu );

            int cItems = GetMenuItemCount( mbi.hMenu );
            int cThemedItems = 0;
            int cRedraw = 0;

            _NcTraceMsg( NCTF_MDIBUTTONS, TEXT("ModifyMDIMenubar: on entry, GetMenuItemCount(hMenu = %08lX) returns %d"), mbi.hMenu, cItems );

            if( cItems > 0 )
            {
                for( int i = cItems - 1; i >= 0 && cThemedItems < MDIBTNCOUNT; i-- )
                {
                    MENUITEMINFO mii;
                    mii.cbSize = sizeof(mii);
                    mii.fMask = MIIM_ID|MIIM_STATE|MIIM_FTYPE|MIIM_BITMAP;

                    if( GetMenuItemInfo( mbi.hMenu, i, TRUE, &mii ) )
                    {
                        _NcTraceMsg( NCTF_MDIBUTTONS, TEXT("GetMenuItemInfo by pos (%d) returns ID %04lX"), i, mii.wID );

                        switch( mii.wID )
                        {
                            case SC_RESTORE:
                            case SC_MINIMIZE:
                            case SC_CLOSE:
                            {
                                BOOL fThemed = TESTFLAG(mii.fType, MFT_OWNERDRAW);
                                if( (fThemed && fTheme) || (fThemed == fTheme) )
                                {
                                    cThemedItems = MDIBTNCOUNT; // one item is already done, assume all to be.
                                }
                                else
                                {
                                    CMdiBtns* pBtns = LoadMdiBtns( NULL, mii.wID );
                                    if( pBtns )
                                    {
                                        if( pBtns->ThemeItem( mbi.hMenu, i, &mii, fTheme ) )
                                        {
                                            cThemedItems++;
                                            cRedraw++;
                                            _NcTraceMsg( NCTF_MDIBUTTONS, TEXT("ModifyMDIMenubar: on entry, GetMenuItemCount(hMenu = %08lX) returns %d"), mbi.hMenu, GetMenuItemCount(mbi.hMenu) );
                                        }
                                    }
                                }
                                break;
                            }
                        }
                    }
                }
            }

            if( cThemedItems )
            {
                _fThemedMDIBtns = fTheme;

                if( fRedraw && cRedraw )
                {
                    DrawMenuBar( _hwnd );
                }
            }

            _NcTraceMsg( NCTF_MDIBUTTONS, TEXT("ModifyMDIMenubar: Modified %d menu items, exiting"), cThemedItems );
        }
    }
}

//-------------------------------------------------------------------------//
BOOL CThemeWnd::_PreDefWindowProc(    
    HWND hwnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam, 
    LRESULT *plRet )
{
    if (uMsg == WM_PRINTCLIENT)
    {
        PrintClientNotHandled(hwnd);
    }

    return FALSE;
}

//-------------------------------------------------------------------------//
BOOL CThemeWnd::_PostDlgProc(    
    HWND hwnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam, 
    LRESULT *plRet )
{
    switch( uMsg )
    {
        case WM_PRINTCLIENT:
        {
            PrintClientNotHandled(hwnd);
        }
        break;
    }

    return FALSE;
}


//-------------------------------------------------------------------------//
//  Handles Defwindowproc post-processing for unthemed windows.
BOOL CThemeWnd::_PostWndProc( 
    HWND hwnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam, 
    LRESULT *plRet )
{
    switch( uMsg )
    {
        //  Special-case WM_SYSCOMMAND for MDI frame window updates
        case WM_WINDOWPOSCHANGED:
            if( lParam /* don't trust this */)
            {
                _MDIUpdate( hwnd, ((WINDOWPOS*) lParam)->flags);
            }
            break;

        case WM_MDISETMENU:
        {
            HWND hwndActive = _MDIGetActive(hwnd);
            if( hwndActive )
                _MDIChildUpdateParent( hwndActive, TRUE );
            break;
        }
    }
    return FALSE;
}

//-------------------------------------------------------------------------//
//  WM_CREATE post-wndproc msg handler
LRESULT CALLBACK OnOwpPostCreate( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    if( -1 != ptm->lRet )
    {
        if( pwnd->TestCF( TWCF_FRAME|TWCF_TOOLFRAME ))
        {
            DWORD dwFTFlags = FTF_CREATE;
            CREATESTRUCT* pcs = (CREATESTRUCT*)ptm->lParam;

            if( pcs )
            {
                //  don't resize dialogs until post-WM_INITDIALOG
                if( pwnd->TestCF(TWCF_DIALOG) )
                {
                    dwFTFlags |= FTF_NOMODIFYPLACEMENT;
                }

                pwnd->SetFrameTheme( dwFTFlags, NULL );
                MsgHandled(ptm);
            }
        }
    }
    return 0L;
}

//---------------------------------------------------------------------------
//  WM_INITDIALOG post defdialogproc handler
LRESULT CALLBACK OnDdpPostInitDialog(CThemeWnd* pwnd, THEME_MSG* ptm)
{
    LRESULT lRet = ptm->lRet;

    //  Do this sequence for dialogs only
    if( pwnd->TestCF( TWCF_DIALOG ) && pwnd->TestCF( TWCF_FRAME|TWCF_TOOLFRAME ) )
    {
        DWORD dwFTFlags = FTF_CREATE;
        pwnd->SetFrameTheme( dwFTFlags, NULL );
        MsgHandled(ptm);
    }
    
    return lRet;    
}


//-------------------------------------------------------------------------//
//  WM_STYLECHANGING/WM_SYTLECHANGED Pre DefWindowProc msg handler
LRESULT CALLBACK OnOwpPreStyleChange( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    // Allow this message to arrive at detination WndProc?
    if ( pwnd->SuppressingStyleMsgs() )
    {
        MsgHandled(ptm);
        return DefWindowProc(ptm->hwnd, ptm->uMsg, ptm->wParam, ptm->lParam);
    }
    
    return 0L;
}

//-------------------------------------------------------------------------//
//  WM_SYTLECHANGED DefWindowProc msg handler
LRESULT CALLBACK OnDwpStyleChanged( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    pwnd->StyleChanged((UINT)ptm->wParam, ((STYLESTRUCT*)ptm->lParam)->styleOld, 
                                     ((STYLESTRUCT*)ptm->lParam)->styleNew );
    return 0L;
}

//-------------------------------------------------------------------------//
//  WM_SETTINGCHANGE post-wndproc handler
LRESULT CALLBACK OnOwpPostSettingChange( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    /*ignore theme setting change process refresh*/

    if( SPI_SETNONCLIENTMETRICS == ptm->wParam && !pwnd->InThemeSettingChange() )
    {
        //  recompute per-theme metrics.
        EnterCriticalSection( &_csThemeMet );
     
        //  force refresh of NONCLIENTMETRICS cache.
        NcGetNonclientMetrics( NULL, TRUE );

        LeaveCriticalSection( &_csThemeMet );

        pwnd->UnloadMdiBtns();

        //  recycle frame icon handle; current one is no longer valid.
        pwnd->AcquireFrameIcon( GetWindowLong(*pwnd, GWL_STYLE),
                                GetWindowLong(*pwnd, GWL_EXSTYLE), TRUE );

        //  frame windows should be invalidated.
        if( pwnd->IsFrameThemed() )
        {
            SetWindowPos( *pwnd, NULL, 0,0,0,0, SWP_DRAWFRAME|
                          SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE );
        }
    }
    
    return 0L;
}

//-------------------------------------------------------------------------//
//  WM_SETTEXT DefWindowProc msg handler
LRESULT CALLBACK OnDwpSetText( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    LRESULT lRet = 0L;
    if( pwnd->IsFrameThemed() )
    {
        //  prevent ourselves from painting as we call on RealDefWindowProc()
        //  to cache the new window text.
        pwnd->LockRedraw( TRUE );
        lRet = DoMsgDefault(ptm);
        pwnd->LockRedraw( FALSE );
    }
    return lRet;
}

//-------------------------------------------------------------------------//
//  WM_SETICON DefWindowProc msg handler
LRESULT CALLBACK OnDwpSetIcon( CThemeWnd* pwnd, THEME_MSG *ptm )
{
    LRESULT lRet = 0L;

    //  invalidate our app icon handle, force re-acquire.
    pwnd->SetFrameIcon(NULL);

    //  call on RealDefWindowProc to cache the icon
    lRet = DoMsgDefault( ptm );

    //  RealDefWindowProc won't call send a WM_NCUAHDRAWCAPTION for large icons
    if( ICON_BIG == ptm->wParam && pwnd->IsFrameThemed() )
    {
        NCWNDMET* pncwm;
        if( pwnd->GetNcWindowMetrics( NULL, &pncwm, NULL, NCWMF_RECOMPUTE ) )
        {
            HDC hdc = _GetNonclientDC( *pwnd, NULL );
            if( hdc )
            {
                DTBGOPTS dtbo;
                dtbo.dwSize = sizeof(dtbo);
                dtbo.dwFlags = DTBG_DRAWSOLID;
            
                pwnd->NcPaintCaption( hdc, pncwm, TRUE, (DWORD)DC_ICON, &dtbo );
                ReleaseDC( *pwnd, hdc );
            }
        }
    }
    return lRet;
}

//-------------------------------------------------------------------------//
#define NCPREV_CLASS TEXT("NCPreviewFakeWindow")

//-------------------------------------------------------------------------//
BOOL _fPreviewSysMetrics = FALSE;

//-------------------------------------------------------------------------//
void _NcSetPreviewMetrics( BOOL fPreview )
{
    BOOL fPrev = _fPreviewSysMetrics;
    _fPreviewSysMetrics = fPreview;
    
    if( fPreview != fPrev ) 
    {
        // make sure we reset button metrics if something has changed    
        _fClassicNcBtnMetricsReset = TRUE;
    }
}

//-------------------------------------------------------------------------//
inline BOOL _NcUsingPreviewMetrics()
{
    return _fPreviewSysMetrics;
}

//-------------------------------------------------------------------------//
BOOL NcGetNonclientMetrics( OUT OPTIONAL NONCLIENTMETRICS* pncm, BOOL fRefresh )
{
    BOOL fRet = FALSE;
    CInternalNonclientMetrics *pincm = NULL;

    EnterCriticalSection( &_csNcSysMet );

    //  Feed off a static instance of NONCLIENTMETRICS to reduce call overhead.
    if( _NcUsingPreviewMetrics() )
    {
        //  hand off preview metrics and get out.
        pincm = &_incmPreview;
    }
    else 
    {
        if( _incmCurrent.Acquire( fRefresh ) )
        {
            pincm = &_incmCurrent;
        }
    }

    if( pincm )
    {
        if( pncm )
        {
            *pncm = pincm->GetNcm();
        }
        fRet = TRUE;
    }

    LeaveCriticalSection( &_csNcSysMet );

    return fRet;
}

//-------------------------------------------------------------------------//
HFONT NcGetCaptionFont( BOOL fSmallCaption )
{
    EnterCriticalSection( &_csNcSysMet );

    HFONT hf = _NcUsingPreviewMetrics() ? _incmPreview.GetFont( fSmallCaption ) : 
                                    _incmCurrent.GetFont( fSmallCaption );
    
    Leav