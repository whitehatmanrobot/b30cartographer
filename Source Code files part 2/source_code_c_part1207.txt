s) ||
               ((tempFlags & PROTECTABLE) == 0))
           return flBadParameter;

        for (floorNo = 0 ; floorNo < flash->noOfFloors ; floorNo++)
        {
           /* Find boundries */
           status = flash->protectionBoundries(flash,area,
                                               &low,&high,floorNo);
           if(status == flOK) /* Set new protection values */
           {
              status = flash->protectionSet(flash,area,
                       (word)((high == 0) ? PROTECTABLE : tempFlags),
                       low,high,NULL,(byte)((floorNo == flash->noOfFloors - 1)
                       ? COMMIT_PROTECTION : DO_NOT_COMMIT_PROTECTION),floorNo);
           }
           if(status != flOK)
             return status;
        }
        break;

#endif /* FL_READ_ONLY */

     case FL_PROTECTION_REMOVE_KEY:

        if (flash->protectionKeyRemove == NULL)
        {
           DEBUG_PRINT(("Protection routine is NULL\r\n"));
           return flFeatureNotSupported;
        }
        return flash->protectionKeyRemove(flash,area);

     case FL_PROTECTION_INSERT_KEY:

        if (flash->protectionKeyInsert == NULL)
        {
           DEBUG_PRINT(("Protection routine is NULL\r\n"));
           return flFeatureNotSupported;
        }
        return flash->protectionKeyInsert(flash,area,(byte FAR1*)ioreq->irData);
     default:
        break;
  } /* protection routines */
  return flOK;
}

#endif /* HW_PROTECTION */

/*----------------------------------------------------------------------*/
/*                     p r e M o u n t I N F T L                        */
/*                                                                      */
/* Common entry point to all tl routines that may be perfomed before    */
/* the volume is mounted (except for the format routine                 */
/*                                                                      */
/* Parameters:                                                          */
/*      callType        : Enum type of posible routines                 */
/*      ioreq           : Input and output request packet               */
/*      flash           : Flash media mounted on this socket            */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failure               */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus preMountINFTL(FLFunctionNo callType, IOreq FAR2* ioreq ,FLFlash* flash, FLStatus* status)
{
  BNANDVolumeHeaderRecord* volume;
  ANANDUnitNo originalUnits[MAX_NO_OF_FLOORS];
  Bnand       vol       = vols + FL_GET_SOCKET_FROM_HANDLE(ioreq);
  byte        partition = FL_GET_PARTITION_FROM_HANDLE(ioreq);
  FLStatus    tmpStatus;

  DEBUG_PRINT(("Debug: starting INFTL preMount operation.\r\n"));

  /*************************/
  /* Find the media header */
  /*************************/

  tmpStatus = initINFTLbasic(&vol,flash);
  if(tmpStatus == flOK)
    tmpStatus = retrieveHeader(&vol,originalUnits,FALSE,TRUE);
  if(tmpStatus != flOK)
    return tmpStatus;

  *status = flOK;

  if (callType == FL_COUNT_VOLUMES) /* get number of BDTL volumes routine */
  {
     ioreq->irFlags = (byte)LE4(((BNANDBootRecord *)inftlBuffer)->
                       noOfBDTLPartitions);
     return flOK;
  }

  /* Check media header for the specific partition */
  volume = (BNANDVolumeHeaderRecord*)(inftlBuffer + sizeof(BNANDBootRecord));

  if (partition > LE4(((BNANDBootRecord *)inftlBuffer)->noOfBDTLPartitions))
  {
     *status = flBadDriveHandle;
  }
  else
  {
     volume += (LE4(((BNANDBootRecord *)inftlBuffer)->noOfBinaryPartitions)+
               partition);
  }

  switch (callType)
  {
#if (defined(QUICK_MOUNT_FEATURE) && !defined(FL_READ_ONLY))
     case FL_CLEAR_QUICK_MOUNT_INFO:
        if(*status != flBadDriveHandle) /* Valid partition number */
           *status = flash->erase(flash,
           (word)(LE4(volume->firstQuickMountUnit) << vol.blockMultiplierBits),
           (word)((LE4(volume->firstUnit) - LE4(volume->firstQuickMountUnit))
                  << vol.blockMultiplierBits));
        break;
#endif /* QUICK_MOUNT_FEATURE AND NOT FL_READ_ONLY */

#ifdef HW_PROTECTION
     case FL_PROTECTION_GET_TYPE:       /* Protection routines */
     case FL_PROTECTION_SET_LOCK:
     case FL_PROTECTION_CHANGE_KEY:
     case FL_PROTECTION_CHANGE_TYPE:
     case FL_PROTECTION_INSERT_KEY:
     case FL_PROTECTION_REMOVE_KEY:
        if(*status == flBadDriveHandle) /* Valid partition number */
           break;
        *status = protectionINFTL(&vol,volume,ioreq,callType);
        break;
#endif  /* HW_PROTECTION */

     default: /* not supported pre mount routine */
        return flBadParameter;
  } /* end of callType switch */
  return flOK; /* This TL took responsibility of this call */
}


#if (defined(FORMAT_VOLUME) && !defined(FL_READ_ONLY))

/*----------------------------------------------------------------------*/
/*                                e r a s e U n i t                     */
/*                                                                      */
/* Erase the unit while retaining the erase count.                      */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Physical unit to format                       */
/*                                                                      */
/*      the progress is repored by the progressCallBack routine         */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus eraseUnit(Bnand vol, ANANDUnitNo unitNo,
                          FLProgressCallback progressCallback)
{
  word     eraseMark;
  dword    eraseCount;
  FLStatus status;

  if (progressCallback)
  {
     status = (*progressCallback)((word)(vol.flash->noOfChips *
                                  (vol.flash->chipSize >> vol.unitSizeBits)),(word)(unitNo+1));
     if(status != flOK)
     {
        DFORMAT_PRINT(("Debug: ERROR failed reporting progress callback.\r\n"));
        dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
        return status;
     }
  }
  status = getUnitTailer(&vol,unitNo,&eraseMark,&eraseCount,UNIT_TAILER_OFFSET);
  if(status == flOK)
  {
     status = vol.flash->erase(vol.flash,(word)(unitNo << vol.blockMultiplierBits),
              (word)(1 << vol.blockMultiplierBits));
  }
  if (status == flOK)
  {
     eraseCount++;
     if (eraseCount == 0)               /* was hex FF's */
     eraseCount++;
     status = setUnitTailer(&vol,unitNo,ERASE_MARK,eraseCount,UNIT_TAILER_OFFSET);
  }
  if (status != flOK)
  {
     DEBUG_PRINT(("Debug: ERROR failed formating unit.\r\n"));
     markUnitBad(&vol,unitNo);  /* make sure unit format is not valid */
     dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
  }

  return status;
}


/*----------------------------------------------------------------------*/
/*                       f o r m a t I N F T L                          */
/*                                                                      */
/* Perform INFTL Format.                                                */
/*                                                                      */
/* Parameters:                                                          */
/*      volNo           : Volume serial no.                             */
/*      fp              : Address of FormatParams structure to use      */
/*      flash           : Flash media mounted on this socket            */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus formatINFTL(unsigned volNo, TLFormatParams *fp, FLFlash *flash)
{
  Bnand                       vol          = &vols[volNo];            /* TL record    */
  BDTLPartitionFormatParams   FAR2* bdtl   = fp->BDTLPartitionInfo;   /* bdtl input   */
  BinaryPartitionFormatParams FAR2* binary = fp->binaryPartitionInfo; /* binary input */
  BNANDBootRecord             * mediaHeader;   /* Disk header record     */
  BNANDVolumeHeaderRecord     * volumeHeader;  /* volume header record   */
  BNANDVolumeHeaderRecord     * volumeHeader2; /* volume header record   */
  CardAddress iBlock;                   /* Block counter index           */
  ANANDUnitNo iUnit;                    /* unit index for loops          */
  ANANDUnitNo unitsNeededForVolume;     /* good units needed for volume  */
  ANANDUnitNo floorGarantiedUnitsLeft;  /* garantied units not yet distributed */
  ANANDUnitNo binaryUnitsInFloor;       /* number of binary unit in this floor */
  ANANDUnitNo noOfUnitsPerFloor[MAX_NO_OF_FLOORS];
  ANANDUnitNo floorGarantiedUnits[MAX_NO_OF_FLOORS]; /* garantied good units in floor */
  ANANDUnitNo originalUnits[MAX_NO_OF_FLOORS]; /* unit no' of the original units */
  ANANDUnitNo goodUnits[MAX_NO_OF_FLOORS];     /* no of good blocks in floor */
  ANANDUnitNo skipedUnits;     /* number of good units to leave as unfrmated */
  ANANDUnitNo goodBlocks;
  FLStatus    status;                   /* status of TrueFFS routines      */
  Sbyte       volumeNo;                 /* current volume index            */
  Sbyte       noOfVolumes = fp->noOfBDTLPartitions + fp->noOfBinaryPartitions;
  dword       index;                    /* general loops index             */
  dword       sizeOfLastBinary;
  byte *      firstVolumePtr;
  byte        headersBuffer[sizeof(inftlBuffer)];
  byte        floorNo;                  /* current floor index             */
  byte        noOfFloors;
  byte        temp;
  byte        lastBinaryFloor;
#ifdef HW_PROTECTION
  ANANDUnitNo volumeStart;
  word        protectionType = 0;       /* Initialized to remove warrnings */
  /* Highest floor to leave DPS untouched - per DPS */
  byte        binaryFloorOfDPS[MAX_PROTECTED_PARTITIONS];
  byte        changeableProtection    = 0;
  byte        unchangeableProtection  = 0;
  byte        protectionKey[PROTECTION_KEY_LENGTH];
#endif /* HW_PROTECTION */
#ifdef WRITE_EXB_IMAGE
  BinaryPartitionFormatParams exbBinaryPartition;
  byte        exbSign[BINARY_SIGNATURE_LEN];
  byte        noOfBinary = fp->noOfBinaryPartitions;
#endif /* WRITE_EXB_IMAGE */
#ifdef QUICK_MOUNT_FEATURE
  Sword       quickMount[MAX_VOLUMES_PER_DOC];

/*  fp->flags |= TL_QUICK_MOUNT_FORMAT; */
  for (volumeNo=0;volumeNo<MAX_VOLUMES_PER_DOC;volumeNo++)
  {
     quickMount[volumeNo]=0;
  }
#endif /* QUICK_MOUNT_FEATURE */

 /*-------------------------------------------------------
  * Media header || Binary 0 + exb file || Binary 1,.. ||
  *-------------------------------------------------------*/

 /*-----------------------------------------------------
  * quick mount + BDTL 0 || quick mount + BDTL 1, ... ||
  *-----------------------------------------------------*/

  DEBUG_PRINT(("Debug: starting INFTL format by verifying arguments.\r\n"));

  tffsset(&vol,0,sizeof(vol));

  /* Check that there is up to 4 volumes on the device provided one is a
   * BDTL volume. If there is an exb file to be placed it would require
   * at least 1 binary volume
   */

  if ((fp->noOfBDTLPartitions < 1) ||
#ifdef WRITE_EXB_IMAGE
      ((fp->exbLen > 0) && (fp->noOfBDTLPartitions == MAX_VOLUMES_PER_DOC)) ||
#endif /* WRITE_EXB_IMAGE */
      (noOfVolumes > MAX_VOLUMES_PER_DOC))
  {
     DFORMAT_PRINT(("ERROR - There can be up to 4 volumes while at least one is a BDTL.\r\n"));
     return flBadParameter;
  }

  /*******************/
  /* Initialization  */
  /*******************/

  checkStatus(initINFTL(&vol,flash)); /* Initialize variables */
  noOfFloors = flash->noOfFloors;
  vol.noOfVirtualUnits = 0;

#ifdef FL_MALLOC
  status = initTables(&vol);   /* Allocate tables      */
#else
  status = initTables(&vol,0);
#endif /* FL_MALLOC */

  if(status != flOK)
  {
     DFORMAT_PRINT(("ERROR - Failed allocating memory for INFTL tables.\r\n"));
     dismountINFTL(&vol); /*Free tables must be done after call to initTables*/
     return status;
  }
  /* Calculate units per floor */
  noOfUnitsPerFloor[0] = (ANANDUnitNo)(vol.flash->chipSize >> vol.unitSizeBits) *
    ((vol.flash->noOfChips + (vol.flash->noOfChips % vol.flash->noOfFloors)) /
      vol.flash->noOfFloors);
  floorGarantiedUnits[0] = (ANANDUnitNo)((dword)((dword)fp->percentUse * (dword)noOfUnitsPerFloor[0]) / 100 - 1); /* - header */
  for (index=0;index+1<vol.flash->noOfFloors;index++)
  {
    noOfUnitsPerFloor[index] = noOfUnitsPerFloor[0];
    floorGarantiedUnits[index] = floorGarantiedUnits[0];
  }
  /* Last floor might have diffrent number of chips */
  noOfUnitsPerFloor[index] = (ANANDUnitNo)(vol.noOfUnits - (index*noOfUnitsPerFloor[0]));
  floorGarantiedUnits[index] = (ANANDUnitNo)((dword)fp->percentUse *
                               noOfUnitsPerFloor[index] / 100 - 1);

  /********************************************************************/
  /* Read BBT , find headers location and count number of good blocks */
  /********************************************************************/

  status = retrieveHeader (&vol ,originalUnits,TRUE,
             (fp->flags & FL_LEAVE_BINARY_AREA) ? TRUE : FALSE);
  tffscpy(headersBuffer,inftlBuffer,sizeof(headersBuffer));
  mediaHeader = (BNANDBootRecord *)headersBuffer;
  firstVolumePtr= headersBuffer + sizeof(BNANDBootRecord);

  /* If previous header was not found it is not possible to leave
   * the previous binary partition.
   */

  if(status == flBadFormat)
  {
     if(fp->flags & FL_LEAVE_BINARY_AREA)
     {
       DFORMAT_PRINT(("NOTE -  Previous binary partition data could not be found.\r\n"));
       fp->flags &= ~FL_LEAVE_BINARY_AREA;
     }
  }

  if(status == flBadBBT)
  {
     DFORMAT_PRINT(("ERROR - Unreadable Bad Blocks Table.\r\n"));
     dismountINFTL(&vol); /*Free tables must be done after call to initTables*/
     return status;
  }

  if(vol.physicalUnits[0] == BBT_BAD_UNIT)
  {
    DFORMAT_PRINT(("ERROR - IPL block is bad.\r\n"));
    dismountINFTL(&vol); /*Free tables must be done after call to initTables*/
    return flBadIPLBlock;
  }

  /* Loop over the floors of the media while counting the good units
   * the good units are needed for the transfere unit calculation.
   * In addition change the MTD values of Bad unit ro INFTL
   */

  for (floorNo = 0 , iUnit = 0 , index = 0 ; floorNo<noOfFloors ; floorNo++)
  {
     index += noOfUnitsPerFloor[floorNo];
     goodBlocks = noOfUnitsPerFloor[floorNo];
     for (;iUnit<index;iUnit++)
     {
        if (vol.physicalUnits[iUnit]!=BBT_GOOD_UNIT)
        {
           goodBlocks--;
           vol.physicalUnits[iUnit] = UNIT_BAD;
        }
        else
        {
           vol.physicalUnits[iUnit] = ANAND_UNIT_FREE;
        }
     }
     goodBlocks--; /* Do not count one unit for floor header */
     if (goodBlocks < floorGarantiedUnits[floorNo])
     {
        DFORMAT_PRINT(("ERROR - Too many bad block on flash->\r\n"));
        dismountINFTL(&vol); /*Free tables must be done after call to initTables*/
        return flVolumeTooSmall;
     }
     /* Save amount of good blocks for later */
     goodUnits[floorNo] = goodBlocks;
  }

  /************************************/
  /* Construct binary volumes headers */
  /************************************/

  volumeHeader = (BNANDVolumeHeaderRecord *) firstVolumePtr;
  goodBlocks   = 0; /* good units already used (counting headers)            */
  skipedUnits  = 0; /* good units to leave unformated (not counting headers) */
#ifdef HW_PROTECTION
  for(index = 0 ; index < MAX_PROTECTED_PARTITIONS ; index++)
    binaryFloorOfDPS[index] = MAX_NO_OF_FLOORS; /* Invalid floor no */
#endif /* HW_PROTECTION */

  if(fp->flags & FL_LEAVE_BINARY_AREA) /* Previous Boot area is kept */
  {
     if(fp->bootImageLen == -1) /* kept entirely */
     {
         for (index = 0;index < LE4(mediaHeader->noOfBinaryPartitions);
              index++,volumeHeader++)
         {
            /* not including headers */
            skipedUnits  += (ANANDUnitNo)LE4(volumeHeader->virtualUnits);
#ifdef HW_PROTECTION
            if (LE4(volumeHeader->flags) & PROTECTABLE)
            {
               if (LE4(volumeHeader->protectionArea) >= flash->totalProtectedAreas)
               {
                  tffsset(headersBuffer,0,sizeof(headersBuffer));
                  DFORMAT_PRINT(("ERROR - Previous Binary partition had a bad protection area field.\r\n"));
                  dismountINFTL(&vol); /*Free tables must be done after call to initTables*/
                  return flBadFormat;
               }
               binaryFloorOfDPS[LE4(volumeHeader->protectionArea)] =
               skipedUnits / floorGarantiedUnits[0];
            }
#endif /* HW_PROTECTION */
         }
     }
     else /* erase all previous binary partitions */
     {
        tffsset(headersBuffer,0,sizeof(headersBuffer));
        if(fp->bootImageLen != 0)
           DFORMAT_PRINT(("ERROR - Requested Binary partition size is diffrent then previous one.\r\n"));
     }
     /* clean the bdtl entries */
     tffsset(volumeHeader, 0,(word)(sizeof(headersBuffer)-((byte *)volumeHeader-headersBuffer)));
     goodBlocks  = skipedUnits;
     /* Update the number of partitions with the binary partitions */
     fp->noOfBinaryPartitions = (byte)(volumeHeader - (BNANDVolumeHeaderRecord *) firstVolumePtr);
     noOfVolumes = fp->noOfBDTLPartitions + fp->noOfBinaryPartitions;
     if(noOfVolumes > MAX_VOLUMES_PER_DOC)
     {
        DFORMAT_PRINT(("ERROR - There can be up to 4 volumes while at least one is a BDTL.\r\n"));
        dismountINFTL(&vol); /*Free tables must be done after call to initTables*/
        return flBadParameter;
     }
  }
  else /* Apply binary area format parameters */
  {
     tffsset(headersBuffer,0,sizeof(headersBuffer)); /* reset all binary area */
     for (volumeNo=0;volumeNo<fp->noOfBinaryPartitions;
          volumeNo++,binary++,volumeHeader++)
     {
        binary->length             = roundToUnits(binary->length);
        if (binary->length == 0)
        {
#ifdef WRITE_EXB_IMAGE
           if(((fp->exbLen == 0) && (volumeNo == 0)) ||
              ( volumeNo   != 0                    )   )
#endif /* WRITE_EXB_IMAGE */
           {
              DFORMAT_PRINT(("ERROR - BINARY partition length should not be 0.\r\n"));
              dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
              return flBadParameter;
           }
        }
        toLE4(volumeHeader->virtualUnits,binary->length);
#ifdef HW_PROTECTION
        toLE4(volumeHeader->flags       ,INFTL_BINARY |
                                         binary->protectionType);
#else
        toLE4(volumeHeader->flags       ,INFTL_BINARY);
#endif /* HW_PROTECTION */
        goodBlocks += (ANANDUnitNo)LE4(volumeHeader->virtualUnits); /* In Units */
     }
     binary = fp->binaryPartitionInfo;

     /* Add EXB area */
#ifdef WRITE_EXB_IMAGE
     if (fp->exbLen>0)
     {
        fp->exbLen  = roundToUnits(fp->exbLen);
        goodBlocks += (ANANDUnitNo)fp->exbLen;
        tffscpy(exbSign,SIGN_SPL,BINARY_SIGNATURE_NAME);
        tffsset(exbSign+BINARY_SIGNATURE_NAME,'F',BINARY_SIGNATURE_NAME);
        if (fp->noOfBinaryPartitions > 0)  /* Add firmware blocks */
        {
           toLE4(((BNANDVolumeHeaderRecord*)firstVolumePtr)->virtualUnits,
                 LE4(((BNANDVolumeHeaderRecord*)firstVolumePtr)->virtualUnits)
           + fp->exbLen);
        }
        else /* Must create a binary partition just for firmware */
        {
           fp->noOfBinaryPartitions          = 1;
           toLE4(volumeHeader->virtualUnits,fp->exbLen  );
#ifdef HW_PROTECTION
           if(noOfBinary) /* Do not use binary record unless it was allocated */
           {
              toLE4(volumeHeader->flags       ,INFTL_BINARY |
                                               binary->protectionType);
              exbBinaryPartition.protectionType = binary->protectionType;
           }
           else
#endif /* HW_PROTECTION */
              toLE4(volumeHeader->flags       ,INFTL_BINARY);
           binary                            = &exbBinaryPartition;
           volumeHeader++;
           noOfVolumes++;
        }
        fp->exbLen <<= vol.blockMultiplierBits;
     }
#endif /* WRITE_EXB_IMAGE */
     toLE4(mediaHeader->noOfBinaryPartitions, fp->noOfBinaryPartitions);
  }

  binaryUnitsInFloor = goodBlocks % floorGarantiedUnits[0];
  lastBinaryFloor    = goodBlocks / floorGarantiedUnits[0];
  goodBlocks        += noOfFloors;

  /********************************/
  /* Construct Main media header  */
  /********************************/

  tffscpy(mediaHeader->bootRecordId,"BNAND", TL_SIGNATURE);
  tffscpy(&(mediaHeader->osakVersion),TrueFFSVersion,sizeof(TrueFFSVersion));
  toLE4(mediaHeader->percentUsed        , fp->percentUse         );
  toLE4(mediaHeader->blockMultiplierBits , vol.blockMultiplierBits);
  toLE4(mediaHeader->formatFlags        , 0                      );
  toLE4(mediaHeader->noOfBDTLPartitions , fp->noOfBDTLPartitions );
/* noOfBinaryPartitions was already determinded */

  /**********************************/
  /* Construct BDTL volumes headers */
  /**********************************/

  for (volumeNo=1;(byte)volumeNo<LE4(mediaHeader->noOfBDTLPartitions);
       bdtl++,volumeNo++,volumeHeader++)
  {
     if (bdtl->length < flash->erasableBlockSize)
     {
        DFORMAT_PRINT(("ERROR - INFTL partition length should not be least one unit long.\r\n"));
        dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
        return flBadParameter;
     }
     toLE4(volumeHeader->virtualUnits        , roundToUnits(bdtl->length));
     toLE4(volumeHeader->spareUnits          , bdtl->noOfSpareUnits      );
     toLE4(volumeHeader->flags               , INFTL_BDTL                );
     goodBlocks += (ANANDUnitNo)LE4(volumeHeader->virtualUnits) + bdtl->noOfSpareUnits;
#ifdef HW_PROTECTION
     toLE4(volumeHeader->flags,LE4(volumeHeader->flags) |
                               bdtl->protectionType);
#endif /* HW_PROTECTION */
#ifdef QUICK_MOUNT_FEATURE
/*     if (fp->flags & TL_QUICK_MOUNT_FORMAT) */
     {
        dword quickMountBytes;

        quickMountBytes  = (ANANDUnitNo)(LE4(volumeHeader->virtualUnits) +
                           LE4(volumeHeader->spareUnits));
        quickMountBytes += ((quickMountBytes / noOfUnitsPerFloor[0] + 1) *
                           noOfUnitsPerFloor[0] * (100L-fp->percentUse) / 100L);
        quickMountBytes *= RAM_FACTOR;
        quickMountBytes += flash->pageSize;
        quickMount[volumeNo-1] = roundToUnits(quickMountBytes);
        goodBlocks += quickMount[volumeNo-1];
     }
#endif /* QUICK_MOUNT_FEATURE */
  }

  /* The size of the last partition is defined by the media itself */

  goodBlocks                             += fp->noOfSpareUnits;
  for(index=0,floorNo=0;floorNo<noOfFloors;floorNo++)
  {
    index+=floorGarantiedUnits[floorNo];
  }
  toLE4(volumeHeader->flags               , INFTL_BDTL | INFTL_LAST);
  toLE4(volumeHeader->spareUnits          , fp->noOfSpareUnits     );
  toLE4(volumeHeader->lastUnit            , vol.noOfUnits-1);
  toLE4(volumeHeader->virtualUnits        , index + noOfFloors - goodBlocks);
#ifdef QUICK_MOUNT_FEATURE
/*  if (fp->flags & TL_QUICK_MOUNT_FORMAT) */
  {
     dword quickMountBytes;

     quickMountBytes  = (ANANDUnitNo)(LE4(volumeHeader->virtualUnits) +
                        LE4(volumeHeader->spareUnits));
     quickMountBytes += ((quickMountBytes / noOfUnitsPerFloor[0] + 1) *
                        noOfUnitsPerFloor[0] * (100L-fp->percentUse) / 100L);
     quickMountBytes *= RAM_FACTOR;
     quickMountBytes += flash->pageSize;

     toLE4(mediaHeader->formatFlags   , QUICK_MOUNT);
     quickMount[volumeNo-1]      = roundToUnits(quickMountBytes);
     toLE4(volumeHeader->virtualUnits , LE4(volumeHeader->virtualUnits) -
                                        quickMount[volumeNo-1]);
  }
#endif /* QUICK_MOUNT_FEATURE */

  if ((LE4(volumeHeader->virtualUnits) < 1) ||
      (LE4(volumeHeader->virtualUnits) > vol.noOfUnits))
  {
     DFORMAT_PRINT(("ERROR - Partition lengths could not be placed on the media.\r\n"));
     dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
     return flVolumeTooSmall;
  }

  /*******************************************/
  /* Allocate protection area to the volumes */
  /*******************************************/

#ifdef HW_PROTECTION
  toLE4(volumeHeader->flags,LE4(volumeHeader->flags) | /* Ignore other flags */
                            fp->protectionType);

  for (volumeNo = noOfVolumes,
       volumeHeader = (BNANDVolumeHeaderRecord *)firstVolumePtr;
       volumeNo>0;volumeNo--,volumeHeader++)
  {
     if (LE4(volumeHeader->flags) & PROTECTABLE)
     {
        if (flash->protectionSet == NULL)
        {
           DFORMAT_PRINT(("ERROR - setting protection routines are not available.\r\n"));
           dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
           return flFeatureNotSupported;
        }
        if (LE4(volumeHeader->flags) & CHANGEABLE_PROTECTION) /* last areas (n,n-1,n-2..)*/
        {
           changeableProtection++; /* Number of protected partitions */
           toLE4(volumeHeader->protectionArea ,
                 flash->totalProtectedAreas - changeableProtection);
        }
        else /* first areas (0,1,2,..) */
        {
           toLE4(volumeHeader->protectionArea , unchangeableProtection);
           unchangeableProtection++;
        }
     }
  }

  /* Make sure the device support enough protected areas */

  if ((changeableProtection   > flash->changeableProtectedAreas) ||
      (unchangeableProtection + changeableProtection >
       flash->totalProtectedAreas))
  {
     DFORMAT_PRINT(("ERROR - too many protected areas.\r\n"));
     dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
     return flBadParameter;
  }

  /* Clear previous protection areas and write protect them */

  for (index=0;index<flash->totalProtectedAreas;index++)
  {
     /* Send default key to open all protected areas */
     status = flash->protectionKeyInsert(flash,(byte)index,(byte FAR1 *)DEFAULT_KEY);
  }

  /* Clear all floors execpt for those that have only binary partitions */
  for (floorNo=skipedUnits/floorGarantiedUnits[0];floorNo<noOfFloors;floorNo++)
  {
     for (index=0;index<flash->totalProtectedAreas;index++)
     {
        if(binaryFloorOfDPS[index] == floorNo)
           break; /* Belongs to a binary partition that must be left */
        status = flash->protectionSet(flash,(byte)index,
                 WRITE_PROTECTED,                           /* Write protect */
                 (index+1) << flash->erasableBlockSizeBits, /* Low address   */
                 (index+1) << flash->erasableBlockSizeBits, /* High address  */
                 (byte *)DEFAULT_KEY,DO_NOT_COMMIT_PROTECTION,floorNo);
        if (status != flOK)
        {
           DFORMAT_PRINT(("ERROR - FAILED clearing previous protection areas.\r\n"));
           dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
           return status;
        }
     }
  }
#endif /* HW_PROTECTION */

  /***********************************/
  /* Actual format of the partitions */
  /***********************************/

  DEBUG_PRINT(("Debug: INFTL format arguments have been verified, starting format.\r\n"));

  unitsNeededForVolume = 0;
  floorNo      = skipedUnits / floorGarantiedUnits[0];
  volumeNo     = -1;                  /* bdtl volume number */
  bdtl         = fp->BDTLPartitionInfo;
  iUnit        = originalUnits[floorNo]+1;  /* write after the first header */
  volumeHeader = (BNANDVolumeHeaderRecord *) firstVolumePtr; /* location of first partition header */
  floorGarantiedUnitsLeft = floorGarantiedUnits[floorNo]; /* floors units left */

  /* Skip the boot image area if the FL_LEAVE_BINARY_AREA was set */

  if (skipedUnits > 0 )
  {
     skipedUnits %= floorGarantiedUnits[0]; /* skipped units on the current floor */
     floorGarantiedUnitsLeft -= skipedUnits; /* floors units left */
     volumeHeader += (word)LE4(mediaHeader->noOfBinaryPartitions);
     sizeOfLastBinary = LE4((volumeHeader-1)->virtualUnits);

     /* Clear previous BDTL entries and adjust binary partition */
     for (index = 0 ; index < floorNo ; index++)
     {
        /* read previous floor header */
        status = flash->read(flash,((CardAddress)originalUnits[index]
                    << vol.unitSizeBits) + sizeof(BNANDBootRecord),
                    firstVolumePtr, sizeof(BNANDVolumeHeaderRecord) *
                    (fp->noOfBinaryPartitions) ,0);

        if(status != flOK)
        {
           DFORMAT_PRINT(("ERROR - FAILED reading previous INFTL header.\r\n"));
           dismountINFTL(&vol); /*Free tables must be done after call to initTables*/
           return status;
        }
        toLE4((volumeHeader-1)->virtualUnits , sizeOfLastBinary); /* adjust virtual size */
        if((index == (dword)(floorNo - 1)) && (skipedUnits == 0))
           toLE4((volumeHeader-1)->lastUnit , ((index+1) * noOfUnitsPerFloor[0]) - 1); /* adjust last block */

        /* Erase and write the new updated header */
        status = eraseUnit(&vol,originalUnits[index],fp->progressCallback);
        if(status != flOK)
        {
           DFORMAT_PRINT(("ERROR - FAILED erasing previous INFTL header.\r\n"));
           return status;
        }
        for (temp = 0 ; temp < NO_OF_MEDIA_HEADERS ; temp++)
        {
           status = flash->write(flash,((CardAddress)originalUnits[index]
                    << vol.unitSizeBits) + temp * HEADERS_SPACING,
                    headersBuffer, sizeof(headersBuffer),EDC);
           if (status != flOK)
           {
              DFORMAT_PRINT(("ERROR - FAILED rewriting INFTL header.\r\n"));
              dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
              return status;
           }
        }
     }

     /* Skip to first BDTL block */
     for (;skipedUnits > 0;skipedUnits--)
     {
        do
        {
           iUnit++;
        }while (vol.physicalUnits[iUnit] == UNIT_BAD);
     }

     /* Save last binary unit for floors header */
     if(iUnit != originalUnits[floorNo]+1)
        toLE4((volumeHeader-1)->lastUnit , iUnit - 1); /* adjust last block */
  }

  do /* loop over floors */
  {
     goodBlocks = goodUnits[floorNo]; /* Good blocks of the floor */

     /* Format as many volumes as posible in this floor */

     while((floorGarantiedUnitsLeft > 0) && (noOfVolumes >= 0))
     {
        if (unitsNeededForVolume == 0) /* Read header of next volume */
        {
           noOfVolumes--;
           toLE4(volumeHeader->firstQuickMountUnit , iUnit);
           unitsNeededForVolume = (ANANDUnitNo)(LE4(volumeHeader->virtualUnits) +
                                  LE4(volumeHeader->spareUnits));
#ifdef QUICK_MOUNT_FEATURE
           if (LE4(volumeHeader->flags) & INFTL_BDTL)
           {
              volumeNo++;
              unitsNeededForVolume +=quickMount[volumeNo];
           }
#else
           toLE4(volumeHeader->firstUnit , iUnit);
#endif /* QUICK_MOUNT_FEATURE */

      /* Copy protection key and type */

#ifdef HW_PROTECTION
           if (LE4(volumeHeader->flags) & INFTL_BDTL)
           {
              if (LE4(volumeHeader->flags) & INFTL_LAST)
              {
                 tffscpy(protectionKey,fp->protectionKey,PROTECTION_KEY_LENGTH);
                 protectionType = fp->protectionType;
              }
              else
              {
                 tffscpy(protectionKey,bdtl->protectionKey,PROTECTION_KEY_LENGTH);
                 protectionType = bdtl->protectionType;
              }
           }
           else /* Binary */
           {
              tffscpy(protectionKey,binary->protectionKey,PROTECTION_KEY_LENGTH);
              protectionType = binary->protectionType;
           }
#endif /* HW_PROTECTION */
        }

        /* update format indexs. */

        if (unitsNeededForVolume > floorGarantiedUnitsLeft)
        {
           /* Volume does not fits in floor */
           index                    = floorGarantiedUnitsLeft;
           unitsNeededForVolume    -= floorGarantiedUnitsLeft;
           floorGarantiedUnitsLeft  = 0;
        }
        else
        {
           /* Entire volume fits in floor */
           index                    = unitsNeededForVolume;
           floorGarantiedUnitsLeft -= unitsNeededForVolume;
           unitsNeededForVolume     = 0;
        }

        /*******************************************/
        /* Format the volumes blocks of this floor */
        /*******************************************/

#ifdef HW_PROTECTION
        volumeStart = iUnit;
#endif /* HW_PROTECTION */
        if (LE4(volumeHeader->flags) & INFTL_BDTL) /* BDTL VOLUME FORMAT   */
        {
           /* Add transfer units */

           if (floorNo == lastBinaryFloor)
           {
              index *= (goodBlocks - binaryUnitsInFloor);
              index /= (floorGarantiedUnits[floorNo] - binaryUnitsInFloor);
           }
           else
           {
              index *= goodBlocks;
              index /= floorGarantiedUnits[floorNo];
           }

           /* Format units */

           while (index > 0)
           {
              if (vol.physicalUnits[iUnit] == ANAND_UNIT_FREE)
              {
#ifdef QUICK_MOUNT_FEATURE
                 /* Set the real first unit after the quick mount data */

                 if (quickMount[volumeNo] >= 0)
                 {
                    if(quickMount[volumeNo] == 0)
                    {
                       toLE4(volumeHeader->firstUnit , iUnit);
                    }
                    (quickMount[volumeNo])--;
                 }
#endif /* QUICK_MOUNT_FEATURE */
                 index--;
                 status = eraseUnit(&vol, iUnit,fp->progressCallback);
                 if(status != flOK)
                    return status;
              }
              else
              {
                 if (fp->progressCallback)
                 {
                    (*fp->progressCallback)((word)(flash->noOfChips *
                    (flash->chipSize >> vol.unitSizeBits)),(word)(iUnit+1));
                 }
              }
              iUnit++;
           }
           if (unitsNeededForVolume == 0)
              bdtl++;
        }
        if (LE4(volumeHeader->flags) & INFTL_BINARY) /* BINARY VOLUME FORMAT */
        {
           toLE4(volumeHeader->firstUnit , LE4(volumeHeader->firstQuickMountUnit));
           for (; (index > 0) ; iUnit++)
           {
              if (vol.physicalUnits[iUnit] == ANAND_UNIT_FREE)
              {
                 index--;
                 status = eraseUnit(&vol, iUnit,fp->progressCallback);
                 if(status != flOK)
                    return status;

                 for (iBlock=0;iBlock<(1UL<<vol.unitSizeBits);iBlock+=(1L<<vol.erasableBlockSizeBits))
                 {
#ifdef WRITE_EXB_IMAGE
                    if (fp->exbLen > 0)
                    {
                       fp->exbLen--;
                       status = flash->write(flash, 8 + iBlock +
                         ((CardAddress)(iUnit) << vol.unitSizeBits),
                         exbSign,BINARY_SIGNATURE_LEN,EXTRA);
                    }
                    else
#endif /* WRITE_EXB_IMAGE */
                    {
                       status = flash->write(flash, binary->signOffset + iBlock +
                         ((CardAddress)(iUnit) << vol.unitSizeBits),
                         binary->sign,BINARY_SIGNATURE_NAME,EXTRA);
                    }
                    if (status != flOK)
                    {
                       DFORMAT_PRINT(("ERROR - FAILED formating binary unit.\r\n"));
                       dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
                       return status;
                    }
                 }
              }
              else                   /* unit is bad */
              {
                 if (fp->progressCallback)
                 {
                    (*fp->progressCallback)((word)(flash->noOfChips *
                    (flash->chipSize >> vol.unitSizeBits)),(word)(iUnit+1));
                 }
              }
           }
           if (unitsNeededForVolume == 0)
              binary++;
        }
#ifdef HW_PROTECTION

        /* Place protection attributes to the volume */

        if (LE4(volumeHeader->flags) & PROTECTABLE)
        {

#ifndef NT5PORT
            status = flash->protectionSet(flash,(byte)LE4(volumeHeader->protectionArea),
              protectionType, ((CardAddress)volumeStart %
              noOfUnitsPerFloor[floorNo]) << vol.unitSizeBits,
              ((CardAddress)((iUnit-1) % noOfUnitsPerFloor[floorNo])) << vol.unitSizeBits ,
              (byte *)&protectionKey,DO_NOT_COMMIT_PROTECTION,floorNo);
#else  /*NT5PORT*/
           status = flash->protectionSet(flash,(byte)LE4(volumeHeader->protectionArea),
              protectionType, ((CardAddress)volumeStart %
              noOfUnitsPerFloor[floorNo]) << vol.unitSizeBits,
              ((CardAddress)((iUnit-1) % noOfUnitsPerFloor[floorNo])) << vol.unitSizeBits ,
              protectionKey,DO_NOT_COMMIT_PROTECTION,floorNo);
#endif /*NT5PORT*/

           if (status != flOK)
           {
              DFORMAT_PRINT(("ERROR - FAILED setting protection.\r\n"));
              dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
              return status;
           }
        }
#endif /* HW_PROTECTION */

        if (unitsNeededForVolume == 0)
        {
           toLE4(volumeHeader->lastUnit , iUnit - 1);
           volumeHeader++;
        }
     } /* loop until no more units in this floor */

     /* Convert any leftovers to BDTL units */

     index = noOfUnitsPerFloor[floorNo] + floorNo*noOfUnitsPerFloor[0];
     while (iUnit < index)
     {
        if (vol.physicalUnits[iUnit] == ANAND_UNIT_FREE)
        {
           status = eraseUnit(&vol, iUnit,fp->progressCallback);
           if(status != flOK)
              return status;
        }
        else
        {
           if (fp->progressCallback)
           {
              (*fp->progressCallback)((word)(flash->noOfChips *
              (flash->chipSize >> vol.unitSizeBits)),(word)(iUnit+1));
           }
        }
        iUnit++;
     }

     /* Update last unit of BDTL partition */
     if ((unitsNeededForVolume == 0) &&
         (LE4((volumeHeader-1)->flags) & INFTL_BDTL))
     {
        toLE4((volumeHeader-1)->lastUnit , iUnit-1);
     }

     /***************************/
     /* Place the floors header */
     /***************************/

     iUnit = originalUnits[floorNo];

     status = eraseUnit(&vol, iUnit,NULL);
     if(status != flOK)
        return status;

     for (index = 0 ; index < NO_OF_MEDIA_HEADERS;index++)
     {
        status = flash->write(flash,((CardAddress)iUnit << vol.unitSizeBits)
                              + index * HEADERS_SPACING,headersBuffer,
                              sizeof(headersBuffer),EDC);
        if (status != flOK)
        {
           DFORMAT_PRINT(("ERROR - FAILED writing INFTL header.\r\n"));
           dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
           return status;
        }
     }

     /**************************/
     /* Prepare next iteration */
     /**************************/

     floorNo++;
     if (floorNo < noOfFloors)
     {
        iUnit=originalUnits[floorNo]+1;
        floorGarantiedUnitsLeft = floorGarantiedUnits[floorNo];

        /* Erase physical unit locations to enable independet unit headers */

        volumeHeader2 = (BNANDVolumeHeaderRecord *) firstVolumePtr; /* location of first partition header */
        while (volumeHeader2<=volumeHeader)
        {
           toLE4(volumeHeader2->firstUnit           , 0);
           toLE4(volumeHeader2->lastUnit            , 0);
           toLE4(volumeHeader2->firstQuickMountUnit , 0);
           volumeHeader2++;
        }
     }
     else
     {
        break;
     }
  } while (1); /* loop over floors */

  DEBUG_PRINT(("Debug: finished INFTL format.\r\n"));

  dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
  return flOK;
}

#endif /* FORMAT_VOLUME && not FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                       f l R e g i s t e r I N F T L                  */
/*                                                                      */
/* Register this translation layer                                      */
/*                                                                      */
/* Parameters:                                                          */
/*      None                                                            */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failure               */
/*----------------------------------------------------------------------*/

FLStatus flRegisterINFTL(void)
{
#ifdef FL_MALLOC
  int i;
#endif /* FL_MALLOC */

  if (noOfTLs >= TLS)
    return flTooManyComponents;

  tlTable[noOfTLs].mountRoutine     = mountINFTL;
  tlTable[noOfTLs].preMountRoutine  = preMountINFTL;

#if (defined(FORMAT_VOLUME) && !defined(FL_READ_ONLY))
  tlTable[noOfTLs].formatRoutine = formatINFTL;
#else
  tlTable[noOfTLs].formatRoutine = noFormat;
#endif /* FORMAT_VOLUME && not FL_READ_ONLY */
  noOfTLs++;

#ifdef FL_MALLOC
  /* reset multi sector buffer */
  for(i=0;( i < SOCKETS );i++) {
    multiSectorBufCounter[i] = -1;
  }
  /* reset convertion tables */
  for(i=0;( i < VOLUMES );i++) {
    vols[i].physicalUnits = NULL;
    vols[i].virtualUnits = NULL;
#ifdef NFTL_CACHE
  /* reset catche tables */
    vols[i].ucache = NULL;
    vols[i].scache = NULL;
#endif /* NFTL_CACHE */
  }
#endif /* FL_MALLOC */
  return flOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\inftl.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/inftl.h_V  $
 * 
 *    Rev 1.17   Apr 15 2002 07:37:28   oris
 * Added pointer to verify write in Bnand record.
 * Added support for VERIFY_ERASED_SECTOR compilation flag.
 * 
 *    Rev 1.16   Feb 19 2002 21:00:30   oris
 * Added FL_NORMAL_FOLDING / FL_FORCE_FOLDING / FL_NOT_IN_PLACE / CLEAR_DISCARD and UNIT_TAILER_OFFSET_2
 * 
 *    Rev 1.15   Jan 28 2002 21:25:56   oris
 * Removed the use of back-slashes in macro definitions.
 * Changed constants to Unsigned Long.
 * 
 *    Rev 1.14   Jan 23 2002 23:33:26   oris
 * Added definition of QUICK_MOUNT_VALID_SING_OFFSET.
 * 
 *    Rev 1.13   Jan 20 2002 10:50:44   oris
 * Added new defintions :
 *  - MAX_CREATE_UNIT_COUNT 
 *  - SECTORS_VERIFIED_PER_FOLDING 
 *  - ANAND_BAD_CHAIN_ADDRESS
 *  - ANAND_BAD_CHAIN_UNIT
 * Changed FL_BAD_ERASE_MARK to 0
 * Reorganized Bnand structure. 
 *  - Changed fields order 
 *  - Changed memory tables pointers to FAR1 pointers - for BIOS driver FAR heap.
 *  - Added fields to Bnand structure : verifiedSectorNo / curSectorWrite / firstMediaWrite
 *  - Removed badFormat field
 * Added verifiedSectorNo to quick mount record.
 * 
 *    Rev 1.12   Nov 16 2001 00:22:54   oris
 * Remove warnings.
 * removed QUICK_MOUNT_FEATURE ifdef.
 * 
 *    Rev 1.11   Nov 08 2001 10:49:58   oris
 * Reorganized Bnand structure and added debug state field.
 * Added INFTL_FAILED_MOUNT, ALL_PARITY_BITS_OK , DISCARD_UNIT_OFFSET definitions.
 * 
 *    Rev 1.10   Sep 24 2001 18:23:56   oris
 * Changed UNIT_UNAVAIL from 0x6a to 0x60 in order not to loose sector count.
 * 
 *    Rev 1.9   Sep 16 2001 21:48:02   oris
 * changed the MAX_UNIT_NUM to 32K
 * 
 *    Rev 1.8   Sep 15 2001 23:47:04   oris
 * Added MAX_FOLDING_LOOP definition.
 * Changed MAX_UNIT_NUM to cause 576MB to group 2 physical units to a single virtual unit.
 * 
 *    Rev 1.7   Jul 13 2001 01:06:24   oris
 * Changed second header offset to page 4 to prevent 6 PPP.
 * 
 *    Rev 1.6   Jun 17 2001 08:18:16   oris
 * Changed recusive include define to INFTL_H.
 * Added FL_BAD_ERASE_MARK    definition for units without the erase mark on mount operation.
 * 
 *    Rev 1.5   May 16 2001 21:20:20   oris
 * Added the FL_ prefix to the following defines: MALLOC and FREE.
 * Changed wear level counter from 0xFF to 0xFFF0
 * Change "data" named variables to flData to avoid name clashes.
 * 
 *    Rev 1.4   Apr 16 2001 13:51:10   oris
 * Changed stack allocation of multi-sector buffers to dynamic allocation.
 * 
 *    Rev 1.3   Apr 09 2001 15:14:18   oris
 * End with an empty line.
 * 
 *    Rev 1.2   Apr 01 2001 07:56:52   oris
 * copywrite notice.
 * Removed nested comments.
 * Moved macroes to the c file.
 * Changed variable types to standard flite types.
 * Compilation problem for big endien fixed.
 * Aliggned unit header structure (SecondANANDUnitHeader) to 8 bytes.
 * Changed BAD_UNIT define.
 * Added FL_VALID, FL_FIRST_VALID, FL_PRELIMINARY, FL_FIRST_PRELIMINARY defines.
 *
 *    Rev 1.1   Feb 14 2001 02:06:24   oris
 * Changed MAX_CHAIN_LENGTH to an environment variable.
 *
 *    Rev 1.0   Feb 13 2001 02:16:00   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

/*************************************************/
/* T r u e F F S   5.0   S o u r c e   F i l e s */
/* --------------------------------------------- */
/*************************************************/

/*****************************************************************************
* File Header                                                                *
* -----------                                                                *
* Name : inftl.h                                                             *
*                                                                            *
* Description : Data strucute and genreal defintions for INFTL flash         *
*               translation layer.                                           *
*                                                                            *
*****************************************************************************/


#ifndef INFTL_H
#define INFTL_H

#include "flbuffer.h"
#include "flflash.h"
#include "fltl.h"

typedef Sdword ANANDVirtualAddress;
typedef byte ANANDPhysUnit;
typedef word ANANDUnitNo;

/* Partition flags */

#define INFTL_BINARY                0x20000000L
#define INFTL_BDTL                  0x40000000L
#define INFTL_LAST                  0x80000000L
/* PROTECTABLE            defined in flbase.h as 1  */
/* READ_PROTECTED         defined in flbase.h as 2  */
/* WRITE_PROTECTED        defined in flbase.h as 4  */
/* LOCK_ENABLED           defined in flbase.h as 8  */
/* LOCK_ASSERTED          defined in flbase.h as 16 */
/* KEY_INSERTED           defined in flbase.h as 32 */
/* CHANGEABLE_PROTECTION  defined in flbase.h as 64 */


/* Media flags */

#define QUICK_MOUNT               1

/* TL limits */

#define MAX_NO_OF_FLOORS          4
#define MAX_VOLUMES_PER_DOC       4
#define MAX_FOLDING_LOOP          10
#define MAX_CREATE_UNIT_COUNT     1024
#define MAX_QUICK_MOUNT_UNITS     10

#ifdef ENVIRONMENT_VARS
#if (defined(VERIFY_WRITE) || defined (VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
#define SECTORS_VERIFIED_PER_FOLDING flSectorsVerifiedPerFolding
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */
#define MAX_UNIT_CHAIN               flMaxUnitChain
#else
#define SECTORS_VERIFIED_PER_FOLDING 64UL
#define MAX_UNIT_CHAIN               20
#endif /* ENVIRONMENT_VARS */
#define DOUBLE_MAX_UNIT_CHAIN        64 /* Double max unit chain */

/* Folding flags */

#define FL_NORMAL_FOLDING         0
#define FL_FORCE_FOLDING          1
#define FL_NOT_IN_PLACE           2

/* General defines */

#define NO_OF_MEDIA_HEADERS       2
#define HEADERS_SPACING           (8UL<<SECTOR_SIZE_BITS)
#define RAM_FACTOR                3L /* byte per erasable block for ram tables */
#define HEADER_SEARCH_BOUNDRY     16 /* must be a multiplication of 8 */
#define QUICK_MOUNT_VALID_SIGN    0xaaaa5555L

#define ANAND_UNASSIGNED_ADDRESS 0xffffffffL
#define ANAND_BAD_CHAIN_ADDRESS  0xfffffffeL
#define ANAND_SPARE_SIZE         16

#define UNIT_DATA_OFFSET              8UL
#define SECTOR_DATA_OFFSET            6UL
#define SECOND_HEADER_OFFSET          (4UL*SECTOR_SIZE)
#define UNIT_TAILER_OFFSET            (2UL*SECTOR_SIZE + 8UL)
#define UNIT_TAILER_OFFSET_2          (6UL*SECTOR_SIZE + 8UL)
#define DISCARD_UNIT_OFFSET           (UNIT_DATA_OFFSET + 7UL)
#define QUICK_MOUNT_VALID_SIGN_OFFSET 44UL

#define FL_VALID                 0x1
#define FL_FIRST_VALID           0x81
#define FL_PRELIMINARY           0x2
#define FL_FIRST_PRELIMINARY     0x82

#define ERASE_MARK               0x3c69
#define FL_BAD_ERASE_MARK        0x0

#define ANAND_UNIT_FREE    0xff
#define UNIT_COUNT         0x7f
#define FIRST_IN_CHAIN     0x80

#define UNIT_UNAVAIL       0x60    /* Illegal count denoting unit not available */
#define UNIT_BAD           0x6B
#define UNIT_MAX_COUNT     0x40    /* Largest valid count       */
#define DISCARD            0xAA    /* Valid used unit signature */
#define CLEAR_DISCARD      0x0     /* Mark unit as discarded    */
#define ANAND_BAD_PERCENTAGE 2     /* Maximum bad units         */

/*  Parity bits for unit header fields */
#define VU_PARITY_BIT        8     /* virtual Unit number  */
#define PU_PARITY_BIT        4     /* previous Unit number */
#define ANAC_PARITY_BIT      2     /* ANAC field           */
#define NAC_PARITY_BIT       1     /* NAC field            */
#define ALL_PARITY_BITS_OK   0xf   /* All parity bits      */

#define IS_BAD(u)       ( u == UNIT_BAD_MOUNT )

/*#define UNIT_BAD_MARKED   7*/

#define MAX_UNIT_SIZE_BITS   15
#define MORE_UNIT_BITS_MASK  3
#define ANAND_NO_UNIT        0xffff
#define ANAND_BAD_CHAIN_UNIT 0xfffe
#define MAX_UNIT_NUM         32768L


/* Block flags */

#define SECTOR_FREE         0xff
#define SECTOR_USED         0x55
#define SECTOR_IGNORE       0x11
#define SECTOR_DELETED      0x00


/* Debug modes flags */
#define INFTL_FAILED_MOUNT    1


#ifdef NFTL_CACHE
/* values for 2-bit entries in Sector Flags cache */
#define S_CACHE_SECTOR_DELETED 0x00
#define S_CACHE_SECTOR_IGNORE  0x01
#define S_CACHE_SECTOR_USED    0x02
#define S_CACHE_SECTOR_FREE    0x03
#define S_CACHE_4_SECTORS_FREE 0xff
#endif /* NFTL_CACHE */

#ifdef NFTL_CACHE
/* Unit Header cache entry, close relative of struct UnitHeader */
typedef struct {
  word virtualUnitNo;
  word prevUnitNo;
  byte  ANAC;
  byte  NAC;
} ucacheEntry; /* See doc2exb.c uses this value */

#endif /* NFTL_CACHE */

/* erase record */
typedef struct {
  LEulong  eraseCount;
  LEushort eraseMark;
  LEushort eraseMark1;
} UnitTailer;

/* unit header  */
typedef struct {
  LEushort virtualUnitNo;
  LEushort prevUnitNo;
  byte ANAC;
  byte NAC;
  byte parityPerField;
  byte discarded;
} ANANDUnitHeader;

/*  Second copy of unitHeader */
typedef struct {
  byte parityPerField;
  byte ANAC;
  LEushort prevUnitNo;
  LEushort virtualUnitNo;
  byte NAC;
  byte junk; /* alignment filed for int - 2 */
} SecondANANDUnitHeader;

/* Medium Boot Record */

typedef struct {
  LEmin    bootRecordId[2];      /* "BNAND" */
  LEmin    noOfBootImageBlocks;  /* number of good blocks in the boot image area */
  LEmin    noOfBinaryPartitions; /* number of binary partitions */
  LEmin    noOfBDTLPartitions;   /* number of BDTL partitions   */
  LEmin    blockMultiplierBits;   /* number of bits used to represent the
                      times a flash erasable block fits inside
                      an INFTL erasable unit. */
  LEmin    formatFlags;     /* QUICK_MOUNT */
  LEmin    osakVersion;     /* version of osak used to format the media */
  LEmin    percentUsed;
} BNANDBootRecord;

/* Volume record */

typedef struct {
  LEmin    virtualUnits; /* Virtual size exported by the trasnaltion layer */
  LEmin    firstUnit;    /* First unit of the partition                    */
  LEmin    lastUnit;     /* Last unit of the partition                     */
  LEmin    flags;        /* PROTECTABLE,CHANGEABLE_PROTECTION,INFTL_BINARY,INFTL_BDTL,INFTL_LAST */
  LEmin    spareUnits;   /* Number of spare garanteed units for INFTL partition */
  LEmin    firstQuickMountUnit; /* first unit used for the quick mount data */
  LEmin    protectionArea;      /* Number of protection area */
} BNANDVolumeHeaderRecord;

#ifndef FL_MALLOC

#define ANAND_HEAP_SIZE    (0x100000l / ASSUMED_NFTL_UNIT_SIZE) * (sizeof(ANANDUnitNo) + sizeof(ANANDPhysUnit)) * MAX_VOLUME_MBYTES

#ifdef NFTL_CACHE
#define U_CACHE_SIZE    ((MAX_VOLUME_MBYTES * 0x100000l) / ASSUMED_NFTL_UNIT_SIZE)
#define S_CACHE_SIZE    ((MAX_VOLUME_MBYTES * 0x100000l) / (SECTOR_SIZE * 4))
#endif

#endif /* FL_MALLOC */

#define WLnow           0xfff0

typedef struct {
  word alarm;
  ANANDUnitNo currUnit;
} WLdata;

struct tTLrec{
  FLFlash            *flash;         /* Poniter to MTD record           */
  dword              *verifyBuffer;  /* Pointer to socket verify buffer */
  FLBuffer           *buffer;        /* Pointer to socket buffer        */
  ANANDPhysUnit FAR1 *physicalUnits; /* unit table by physical no.      */
  ANANDUnitNo   FAR1 *virtualUnits;  /* unit table by logical no.       */
  const void    FAR0 *mappedSector;
#ifdef NFTL_CACHE
  ucacheEntry   FAR1 *ucache;               /* Unit Header cache */
  byte          FAR1 *scache;               /* Sector Flags cache */
#endif
#ifndef FL_MALLOC
  char*             heap;
#endif /* FL_MALLOC */
  CardAddress       mappedSectorAddress;

  /* Accumulated statistics. */
  Sdword            sectorsRead,
                    sectorsWritten,
                    sectorsDeleted,
                    parasiteWrites,
                    unitsFolded;

  WLdata            wearLevel;
  dword             eraseSum;
#ifdef NFTL_CACHE
  dword             firstUnitAddress;    /* address of the first unit of the volume */
#endif /* NFTL_CACHE */
  ANANDUnitNo       firstQuickMountUnit; /* The quick mount first unit            */
  ANANDUnitNo       firstUnit;           /* first unit number of the volume       */
  ANANDUnitNo       freeUnits;           /* Free units on media                   */
  ANANDUnitNo       noOfVirtualUnits;    /* No of units exported by the TL */
  ANANDUnitNo       noOfUnits;           /* No of units in the partition          */
  ANANDUnitNo       bootUnits;           /* No of boot units of the media         */
  ANANDUnitNo       roverUnit;    /* Starting point for allocation search         */
  ANANDUnitNo       countsValid;  /* Number of units for which unit count was set */
  word              sectorsPerUnit;      /* Number of 512 bytes in a unit         */
  word              sectorsPerUnitBits;  /* Bits used for no of sectors per unit  */
  word              sectorsPerUnitMask;  /* Number of 512 bytes in a unit - 1     */  
  SectorNo          virtualSectors;      /* No of sectors exported by the TL      */
  SectorNo          mappedSectorNo;      /* Currently mapped sector               */
#if (defined(VERIFY_WRITE) || defined (VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
  SectorNo          verifiedSectorNo;    /* Largest sector verified so far        */
  SectorNo          curSectorWrite;      /* Current update sector                 */
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */
  byte              flags;                 /* QUICK_MOUNT or not                  */
  byte              socketNo;              /* The volumes socket serial number    */
  byte              blockMultiplierBits;   /* the number of ersable blocks in     */
                                           /* an INFTL unit                       */
  byte              erasableBlockSizeBits; /* log2 of erasable block size         */
  byte              unitSizeBits;          /* log2 of TL unit size                */
  FLBoolean         firstMediaWrite;
#ifdef CHECK_MOUNT
  dword             debugState;            /* Used for internal debug */
#endif /* CHECK_MOUNT */
};

typedef TLrec Bnand;

typedef struct {
     LEulong      freeUnits;
     LEulong      roverUnit;
     LEulong      countsValid;
     LEulong      sectorsRead;
     LEulong      sectorsWritten;
     LEulong      sectorsDeleted;
     LEulong      parasiteWrites;
     LEulong      unitsFolded;
     LEulong      wearLevel_1;
     LEulong      wearLevel_2;
     LEulong      eraseSum;
     LEulong      validate; /* QUICK_MOUNT_VALID_SIGN */
     LEulong      checksum; /* checksum of entire quick mount info should be 55 */
     LEulong      verifiedSectorNo; /* Largest sector verified so far           */
}savedBnand;

#define VALIDATE_OFFSET     11*sizeof(LEmin)
#define inftlBuffer         vol.buffer->flData
#endif /* INFTL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\inftldbg.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/INFTLDBG.C_V  $
 * 
 *    Rev 1.0   Nov 16 2001 00:44:12   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

/*************************************************/
/* T r u e F F S   5.0   S o u r c e   F i l e s */
/* --------------------------------------------- */
/*************************************************/

/*****************************************************************************
* File Header                                                                *
* -----------                                                                *
* Name : inftldbg.c                                                          *
*                                                                            *
* Description : Implementation of INFTL debug routine.                       *
*                                                                            *
*****************************************************************************/

/*********************************************************/
/*  The following routine are for debuging INFTL chains. */
/*  They should not be compiled as part of TrueFFS based */
/*  drivers and application.                             */
/*********************************************************/

/* function prototype */

static FLStatus getUnitData(Bnand vol, ANANDUnitNo unitNo,
        ANANDUnitNo *virtualUnitNo, ANANDUnitNo *prevUnitNo,
        byte *ANAC, byte *NAC, byte *validFields);

static byte getSectorFlags(Bnand vol, CardAddress sectorAddress);


#ifdef CHECK_MOUNT
extern FILE* tl_out;

/* Macroes */

#define TL_DEBUG_PRINT     fprintf
#define STATUS_DEBUG_PRINT printf
#define SET_EXIT(x)        vol.debugState |= x   /* Add INFTL debug warnnings */
#define DID_MOUNT_FAIL     vol.debugState & INFTL_FAILED_MOUNT

#endif /* CHECK_MOUNT */

#ifdef CHAINS_DEBUG

byte * fileNameBuf1 = "Chains00.txt";
byte * fileNameBuf2 = "report.txt";

/*------------------------------------------------------------------------*/
/*                  g e t F i l e H a n d l e                             */
/*                                                                        */
/* Get file handle for debug print output file.                           */
/*                                                                        */
/* Parameters:                                                            */
/*      vol             : Pointer identifying drive                       */
/*      type            : File name identifier                            */
/*                                                                        */
/* Returns:                                                               */
/*      File handle to ourput file.                                       */
/*------------------------------------------------------------------------*/

#include <string.h>

FILE* getFileHandle(Bnand vol,byte type)
{
  char *fileName;
  char *logFileExt;

  switch (type)
  {
     case 0:
        fileName = fileNameBuf1;
        break;
     case 1:
        fileName = fileNameBuf2;
        break;
     default:
        return NULL;
  }

  logFileExt = strchr(fileName,'.');

  if (logFileExt == NULL)
  {
     return NULL;
  }
  else
  {
     (*(logFileExt-1))++;
  }

  if (DID_MOUNT_FAIL)
  {
     return (FILE *)FL_FOPEN(fileName,"a");
  }
  else
  {
    return NULL;
  }
}

/*------------------------------------------------------------------------*/
/*                  g o A l o n g V i r t u a l U n i t                   */
/*                                                                        */
/* Print the following info for a specified virtual chain:                */
/*                                                                        */
/*  Virtual  unit number : "Chain #XX :"                                  */
/*  Physical unit number : "#XX "                                         */
/*  Physical unit ANAC   : "(%XX)"                                        */
/*  Physical unit NAC    : "[%XX]"                                        */
/*  Previous unit        : "==>:" or "endofchain"                         */
/*                                                                        */
/*  The virtual unit state can have several comments:                     */
/*                                                                        */
/*  "FREE"                           - Legal state where irtual unit has  */
/*                                     no physical unit assigned          */
/*  "Chain XX is too long"           - The chains has 2 times the maxium  */
/*                                     legal chains length                */
/*  "Something wrong with chain #XX" - There is a problem with the chain: */
/*     a) "this unit should be the last in chain "                        */
/*        The ram convertin table does not have the first in chain mark   */
/*        for this unit although we know it is the last of its chain.     */
/*     b) "this unit points to the unit with the different vu no %XX"     */
/*        The virtual unit field of the current physical unit does not    */
/*        match the virtual unit number of the chain being inspected. The */
/*        new virtual unit is XX                                          */
/*                                                                        */
/* Parameters:                                                            */
/*      vol             : Pointer identifying drive                       */
/*      virtualUnit     : Number of the virtual unit to scan              */
/*      physUnits       : Physical unit table indicating the number of    */
/*                        virtual units each physical unit bellongs to.   */
/*      out             : File pointer for ouput                          */
/*                                                                        */
/* Returns:                                                               */
/*      None                                                              */
/*------------------------------------------------------------------------*/

void  goAlongVirtualUnit(Bnand vol,word virtualUnit,byte *physUnits,FILE* out)
{
  int i;
  ANANDUnitNo virtualUnitNo, prevUnitNo,unitNo;
  byte ANAC,NAC,parityPerField;
  unitNo=vol.virtualUnits[virtualUnit];

  FL_FPRINTF(out,"Chain #%d :", virtualUnit);
  if(unitNo==ANAND_NO_UNIT)
  {
     FL_FPRINTF(out,"FREE\n");
     return;
  }
  for(i=0;i<2*MAX_UNIT_CHAIN;i++)
  {
     if (physUnits != NULL)
        physUnits[unitNo]++;
     getUnitData(&vol,unitNo,&virtualUnitNo, &prevUnitNo,&ANAC,&NAC,&parityPerField);
     FL_FPRINTF(out,"#%d (%d)[%d]==>:",unitNo,ANAC,NAC);
     if(vol.physicalUnits[unitNo]&FIRST_IN_CHAIN)
     {
        FL_FPRINTF(out,"endofchain\n");
        return;
     }

     unitNo=prevUnitNo;
     if((prevUnitNo==ANAND_NO_UNIT)||(virtualUnitNo!=virtualUnit))
     {
         FL_FPRINTF(out,"\nSomething wrong with chain #%d\n",virtualUnit);
         TL_DEBUG_PRINT(tl_out,"\nSomething wrong with chain #%d\n",virtualUnit);
         SET_EXIT(INFTL_FAILED_MOUNT);
         if(prevUnitNo==ANAND_NO_UNIT)
         {
            FL_FPRINTF(out,"this unit should be the last in chain\n");
            TL_DEBUG_PRINT(tl_out,"this unit should be the last in chain (length %d)\n",i);
         }
         else
         {
            FL_FPRINTF(out,"this unit points to the unit with the different vu no %d\n",virtualUnitNo);
            TL_DEBUG_PRINT(tl_out,"this unit points to the unit with the different vu no %d\n",virtualUnitNo);
         }
         return;
     }
 }
 FL_FPRINTF(out,"Chain %d is too long \n",virtualUnit);
 TL_DEBUG_PRINT(tl_out,"Chain %d is too long \n",virtualUnit);
 SET_EXIT(INFTL_FAILED_MOUNT);
}

/*------------------------------------------------------------------------*/
/*                  c h e c k V i r t u a l C h a i n s                   */
/*                                                                        */
/* Print the physical units in each virtual unit of the media             */
/*                                                                        */
/* Parameters:                                                            */
/*      vol             : Pointer identifying drive                       */
/*      out             : File pointer to print the result                */
/*                                                                        */
/* Returns:                                                               */
/*      None                                                              */
/*------------------------------------------------------------------------*/

void checkVirtualChains(Bnand vol, FILE* out)
{
  word i;
#ifdef FL_MALLOC
  byte* physUnits;
#else
  byte physUnits[MAX_SUPPORTED_UNITS];
#endif /* FL_MALLOC */

  if (vol.noOfVirtualUnits == 0) /* Not format */
  {
     FL_FPRINTF(out,"\nThis is a format routine since no virtual unit are reported\n");
     return;
  }

#ifdef FL_MALLOC
  physUnits = (byte *)FL_MALLOC(vol.noOfUnits);
  if (physUnits == NULL)
#else
  if (MAX_SUPPORTED_UNITS < vol.noOfUnits)
#endif /* FL_MALLOC */
  {
    FL_FPRINTF(out,"\nCheck virtual chains will not check cross links due to lack of memory\n");
    TL_DEBUG_PRINT(tl_out,"\nCheck virtual chains will not check cross links due to lack of memory (no of units %d\n",vol.noOfUnits);
    SET_EXIT(INFTL_FAILED_MOUNT);
    return;
  }
  if (physUnits != NULL)
    tffsset(physUnits,0,vol.noOfUnits);

  /* Go along each of the virtual units */

  FL_FPRINTF(out,"Chains are :\n");

  for(i=0;i<vol.noOfVirtualUnits;i++)
      goAlongVirtualUnit(&vol,i,physUnits,out);

  FL_FPRINTF(out,"\nChecking if physicl units were used more then once\n");
  if (physUnits != NULL)
  {
     for(i=0;i<vol.noOfUnits;i++)
       if(physUnits[i]>1)
       {
          FL_FPRINTF(out,"Phys unit #%d were used more than once %d\n",i,physUnits[i]);
          TL_DEBUG_PRINT(tl_out,"Phys unit #%d were used more than once.\n",i);
          TL_DEBUG_PRINT(tl_out,"It was used %d times.\n",physUnits[i]);
          SET_EXIT(INFTL_FAILED_MOUNT);
       }
  }
  else
  {
     FL_FPRINTF(out,"\nCould not check due to lack of memory\n");
  }
  /* Free memory */

#ifdef FL_MALLOC
  FL_FREE(physUnits);
#endif /* FL_MALLOC */
}

/*------------------------------------------------------------------------*/
/*                c h e c k V o l u m e S t a t i s t i c s               */
/*                                                                        */
/* Print the volume statistics.                                           */
/*                                                                        */
/* Parameters:                                                            */
/*      vol             : Pointer identifying drive                       */
/*      out             : File pointer to print the result                */
/*                                                                        */
/* Returns:                                                               */
/*      None                                                              */
/*------------------------------------------------------------------------*/


void checkVolumeStatistics(Bnand vol , FILE* out)
{
  FL_FPRINTF(out,"\nThe volume statistics are:\n");
  FL_FPRINTF(out,"Socket nomber ----------------------------------- %d\n",vol.socketNo);
  FL_FPRINTF(out,"The volume internal flags ----------------------- %d\n",vol.flags);
  FL_FPRINTF(out,"Number of free units ---------------------------- %d\n",vol.freeUnits);
  TL_DEBUG_PRINT(tl_out,"Number of free units ---------------------------- %d\n",vol.freeUnits);
  FL_FPRINTF(out,"Number of boot unit ----------------------------- %d\n",vol.bootUnits);
  FL_FPRINTF(out,"Number of media units --------------------------- %d\n",vol.noOfUnits);
  FL_FPRINTF(out,"Number of virtual units ------------------------- %d\n",vol.noOfVirtualUnits);
  FL_FPRINTF(out,"Number of virtual sector on the volume ---------- %ld\n",vol.virtualSectors);
  FL_FPRINTF(out,"The media rover unit ---------------------------- %d\n",vol.roverUnit);
  FL_FPRINTF(out,"Physical first unit number of the volume -------- %d\n",vol.firstUnit);
#ifdef NFTL_CACHE
  FL_FPRINTF(out,"Physical first unit address --------------------- %d\n",vol.firstUnitAddress);
#endif /* NFTL_CACHE */
#ifdef QUICK_MOUNT_FEATURE
  FL_FPRINTF(out,"First quick mount unit -------------------------- %d\n",vol.firstQuickMountUnit);
#endif /* QUICK_MOUNT_FEATURE */
  FL_FPRINTF(out,"Number of unit with a valid sector count -------- %d\n",vol.countsValid);
  FL_FPRINTF(out,"The currently mapped sector number -------------- %ld\n",vol.mappedSectorNo);
  FL_FPRINTF(out,"The currently mapped sector address ------------- %ld\n",vol.mappedSectorAddress);

  FL_FPRINTF(out,"Number of sectors per unit ---------------------- %d\n",vol.sectorsPerUnit);
  FL_FPRINTF(out,"Number of bits needed to shift from block to unit %d\n",vol.blockMultiplierBits);
  FL_FPRINTF(out,"Number of bits used to represent a flash block -- %d\n",vol.erasableBlockSizeBits);
  FL_FPRINTF(out,"Number of bits used to represent a media unit --- %d\n",vol.unitSizeBits);

  FL_FPRINTF(out,"Number of sectors read -------------------------- %ld\n",vol.sectorsRead);
  FL_FPRINTF(out,"Number of sectors written ----------------------- %ld\n",vol.sectorsWritten);
  FL_FPRINTF(out,"Number of sectors deleted ----------------------- %ld\n",vol.sectorsDeleted);
  FL_FPRINTF(out,"Number of parasite write ------------------------ %ld\n",vol.parasiteWrites);
  FL_FPRINTF(out,"Number of units folded -------------------------- %ld\n",vol.unitsFolded);
  FL_FPRINTF(out,"The total erase counter ------------------------- %ld\n",vol.eraseSum);
  FL_FPRINTF(out,"Wear leveling counter limit---------------------- %ld\n",vol.wearLevel.alarm);
  FL_FPRINTF(out,"Wear leveling current unit ---------------------- %d\n",vol.wearLevel.currUnit);
  FL_FCLOSE(out);
}
#endif /* CHAINS_DEBUG */

#ifdef CHECK_MOUNT

/*------------------------------------------------------------------------*/
/*                c h e c k M o u n t I N F T L                           */
/*                                                                        */
/* Print Low level errors in INFTL format.                                */
/*                                                                        */
/* Parameters:                                                            */
/*      vol             : Pointer identifying drive                       */
/*                                                                        */
/* Returns:                                                               */
/*      flOK on success                                                   */
/*------------------------------------------------------------------------*/

FLStatus checkMountINFTL(Bnand vol)
{
   ANANDUnitNo erCount=0,freeUnits=0,iUnit;
   ANANDUnitNo virtualUnitNo,prevUnitNo;
   FLStatus status;
   byte pattern[SECTOR_SIZE],tempbuf[SECTOR_SIZE];
   byte sectorFlags,ANAC, NAC, prevANAC, parityPerField;
   word *erasePatt1;
   word *erasePatt2;
   word i,temp;
   dword sectorAddress;

   tffsset(pattern,0xff,SECTOR_SIZE);
   for (iUnit = 0; iUnit < vol.noOfUnits; iUnit++)
   {
       STATUS_DEBUG_PRINT("Checking unit %d\r",iUnit);
       if (vol.physicalUnits[iUnit] != UNIT_BAD)
       {
          /*Read unit header*/
          status=getUnitData(&vol,iUnit,&virtualUnitNo, &prevUnitNo,&ANAC,&NAC,&parityPerField);
          if((status!=flOK)||(!isValidParityResult(parityPerField)))
          {
             TL_DEBUG_PRINT(tl_out,"Error going along INFTL chains - could not get unit data of %d.\n",iUnit);
             TL_DEBUG_PRINT(tl_out,"Status = %d and parityPerField is %d.\n",status,parityPerField);
             SET_EXIT(INFTL_FAILED_MOUNT);
             continue;
          }

          /* FREE unit test that it's all erased and it has erase mark */
          if((virtualUnitNo==ANAND_NO_UNIT)&&
             (prevUnitNo==ANAND_NO_UNIT)   &&
             (ANAC==ANAND_UNIT_FREE)       &&
             (NAC==ANAND_UNIT_FREE))
          {
             freeUnits++;
             for(i=0;i<(1<<(vol.unitSizeBits - SECTOR_SIZE_BITS));i++)
             {
                /* Extra area */

                if(i!=2)  /* skip erase mark at - UNIT_TAILER_OFFSET */
                {
                   checkStatus(vol.flash.read(&vol.flash,
                   unitBaseAddress(vol,iUnit)+i*SECTOR_SIZE,
                   tempbuf,16,EXTRA));
                   if(tffscmp(tempbuf,pattern,16)!=0)
                   {
                      TL_DEBUG_PRINT(tl_out,"Extra area of FREE unit is not FF's in %d unit %d sector, it is\n",iUnit,i);
                      for(temp=0;temp<16;temp++)
                        TL_DEBUG_PRINT(tl_out,"%x ",tempbuf[temp]);
                      TL_DEBUG_PRINT(tl_out,"\n\n");
                      SET_EXIT(INFTL_FAILED_MOUNT);
                   }
                }
                else /* Erase mark sector offset */
                {
                   checkStatus(vol.flash.read(&vol.flash,
                   unitBaseAddress(vol,iUnit)+i*SECTOR_SIZE,
                   tempbuf,16,EXTRA));
                   if(tffscmp(tempbuf,pattern,8)!=0)
                   {
                      TL_DEBUG_PRINT(tl_out,"Extra area of FREE unit is not FF's in %d unit %d sector, it is\n",iUnit,i);
                      for(temp=0;temp<16;temp++)
                        TL_DEBUG_PRINT(tl_out,"%x ",tempbuf[temp]);
                      TL_DEBUG_PRINT(tl_out,"\n\n");
                      SET_EXIT(INFTL_FAILED_MOUNT);
                   }
                   erasePatt1=(unsigned short*)(&(tempbuf[12]));
                   erasePatt2=(unsigned short*)(&(tempbuf[14]));
                   if(*erasePatt1!=ERASE_MARK)
                   {
                      TL_DEBUG_PRINT(tl_out,"First Erase mark of FREE unit is not written well in Unit %d it is %x\n",iUnit,*erasePatt1);
                   }
                   if(*erasePatt2!=ERASE_MARK)
                   {
                      TL_DEBUG_PRINT(tl_out,"Second Erase mark of FREE unit is not written well in Unit %d it is %x\n",iUnit,*erasePatt2);
                   }
                   if ((*erasePatt1!=ERASE_MARK)||(*erasePatt2!=ERASE_MARK))
                      erCount++;
                }

                /* Data area */

                checkStatus(vol.flash.read(&vol.flash,
                unitBaseAddress(vol,iUnit)+i*SECTOR_SIZE,
		        tempbuf,SECTOR_SIZE,0));
                if(tffscmp(tempbuf,pattern,SECTOR_SIZE)!=0)
                {
                   TL_DEBUG_PRINT(tl_out,"Data area of FREE unit is not FF's in %d unit %d sector it is.\n",iUnit,i);
                   for(temp=0;temp<SECTOR_SIZE;temp++)
                   {
                     if (temp%0x10==0)
                        TL_DEBUG_PRINT(tl_out,"\n");
                     TL_DEBUG_PRINT(tl_out,"%x ",tempbuf[temp]);
                   }
                   TL_DEBUG_PRINT(tl_out,"\n\n");
                   SET_EXIT(INFTL_FAILED_MOUNT);
                }
             }
          }
          else /* Not a FREE unit */
          {
             /* If it's not erased test each valid sector for ecc/edc error */
             for(i=0;i<(1<<(vol.unitSizeBits - SECTOR_SIZE_BITS));i++)
             {
                sectorFlags  = getSectorFlags(&vol,unitBaseAddress(vol,iUnit)+i*SECTOR_SIZE);
                if(sectorFlags==SECTOR_FREE)
                {
                   /* Extra area */

                   switch(i)
                   {
                      case 0: /* Do not check extra area */
                      case 4:
                         break;
                      case 2: /* Check only erase mark */
                         checkStatus(vol.flash.read(&vol.flash,
                         unitBaseAddress(vol,iUnit)+i*SECTOR_SIZE,
                         tempbuf,16,EXTRA));
                         if(tffscmp(tempbuf,pattern,8)!=0)
                         {
                            TL_DEBUG_PRINT(tl_out,"Extra area of USED unit is not FF's in %d unit %d sector, it is\n",iUnit,i);
                            for(temp=0;temp<16;temp++)
                               TL_DEBUG_PRINT(tl_out,"%x ",tempbuf[temp]);
                            TL_DEBUG_PRINT(tl_out,"\n\n");
                            SET_EXIT(INFTL_FAILED_MOUNT);
                         }
                         else
                         {
                            erasePatt1=(unsigned short*)(&(tempbuf[12]));
                            erasePatt2=(unsigned short*)(&(tempbuf[14]));
                            if(*erasePatt1!=ERASE_MARK)
                            {
                               TL_DEBUG_PRINT(tl_out,"USED unit First Erase mark is not written well in Unit %d it is %x\n",iUnit,*erasePatt1);
                            }
                            if(*erasePatt2!=ERASE_MARK)
                            {
                               TL_DEBUG_PRINT(tl_out,"USED unit Second Erase mark is not written well in Unit %d it is %x\n",iUnit,*erasePatt2);
                            }
                            if ((*erasePatt1!=ERASE_MARK)||(*erasePatt2!=ERASE_MARK))
                            {
                               SET_EXIT(INFTL_FAILED_MOUNT);
                               erCount++;
                            }
                         }
                         break;

                      default: /* Make sure it is free (0xff) */
                         checkStatus(vol.flash.read(&vol.flash,
                         unitBaseAddress(vol,iUnit)+i*SECTOR_SIZE,
                         tempbuf,16,EXTRA));
                         if(tffscmp(tempbuf,pattern,16)!=0)
                         {
                            TL_DEBUG_PRINT(tl_out,"Extra area of USED unit is not FF's in %d unit %d sector, it is\n",iUnit,i);
                            for(temp=0;temp<16;temp++)
                               TL_DEBUG_PRINT(tl_out,"%x ",tempbuf[temp]);
                            TL_DEBUG_PRINT(tl_out,"\n\n");
                            SET_EXIT(INFTL_FAILED_MOUNT);
                         }
                   } /* End sector number case */

                   /* Data area */

                   checkStatus(vol.flash.read(&vol.flash,
                   unitBaseAddress(vol,iUnit)+i*SECTOR_SIZE,
	    	       tempbuf,SECTOR_SIZE,0));
                   if(tffscmp(tempbuf,pattern,SECTOR_SIZE)!=0)
                   {
                      TL_DEBUG_PRINT(tl_out,"Data area of USED unit FREE sector is not FF's in %d unit %d sector it is\n",iUnit,i);
                      for(temp=0;temp<SECTOR_SIZE;temp++)
                      {
                        if (temp%0x10==0)
                           TL_DEBUG_PRINT(tl_out,"\n");
                        TL_DEBUG_PRINT(tl_out,"%x ",tempbuf[temp]);
                      }
                      TL_DEBUG_PRINT(tl_out,"\n\n");
                      SET_EXIT(INFTL_FAILED_MOUNT);
                   }
                }
                else /* not a FREE sector - Used / Deleted / ignored */
                {
                   /* Extra area */

                   switch(i)
                   {
                      case 0: /* Do not check extra area */
                      case 4:
                         break;
                      case 2: /* Check only erase mark */
                         checkStatus(vol.flash.read(&vol.flash,
                         unitBaseAddress(vol,iUnit)+i*SECTOR_SIZE+8,
                         tempbuf,8,EXTRA));
                         erasePatt1=(unsigned short*)(&(tempbuf[4]));
                         erasePatt2=(unsigned short*)(&(tempbuf[6]));
                         if(*erasePatt1!=ERASE_MARK)
                         {
                            TL_DEBUG_PRINT(tl_out,"USED unit not a free sector First Erase mark is not written well in Unit %d it is %x\n",iUnit,*erasePatt1);
                         }
                         if(*erasePatt2!=ERASE_MARK)
                         {
                            TL_DEBUG_PRINT(tl_out,"USED unit not a free sector Second Erase mark is not written well in Unit %d it is %x\n",iUnit,*erasePatt2);
                         }
                         if ((*erasePatt1!=ERASE_MARK)||(*erasePatt2!=ERASE_MARK))
                         {
                            SET_EXIT(INFTL_FAILED_MOUNT);
                            erCount++;
                         }
                         break;

                      default: /* Make sure it is free (0xff) */
                         checkStatus(vol.flash.read(&vol.flash,
                         unitBaseAddress(vol,iUnit)+i*SECTOR_SIZE+8,
                         tempbuf,8,EXTRA));
                         if(tffscmp(tempbuf,pattern,8)!=0)
                         {
                            TL_DEBUG_PRINT(tl_out,"USED unit not a free sector is not FF's in %d unit %d sector, it is\n",iUnit,i);
                            for(temp=0;temp<8;temp++)
                               TL_DEBUG_PRINT(tl_out,"%x ",tempbuf[temp]);
                            TL_DEBUG_PRINT(tl_out,"\n\n");
                            SET_EXIT(INFTL_FAILED_MOUNT);
                         }
                   } /* End sector number case */

                   /* Data area */

                   status=vol.flash.read(&vol.flash,unitBaseAddress(vol,iUnit)+i*SECTOR_SIZE,tempbuf,SECTOR_SIZE,EDC);

                   if((sectorFlags==SECTOR_DELETED)||
                      (sectorFlags==SECTOR_USED))
             	   {
         		      if(status!=flOK)
          			  {
              			 if(sectorFlags==SECTOR_USED)
                         {
			                TL_DEBUG_PRINT(tl_out,"Used sector with ");
                         }
                         else
                         {
			                TL_DEBUG_PRINT(tl_out,"Deleted sector with ");
                         }
                		 TL_DEBUG_PRINT(tl_out,"ECC/EDC error in %d unit %d sector, the data is\n",iUnit,i);
                         for(temp=0;temp<SECTOR_SIZE;temp++)
                         {
                           if (temp%0x10==0)
                              TL_DEBUG_PRINT(tl_out,"\n");
                           TL_DEBUG_PRINT(tl_out,"%x ",tempbuf[temp]);
                         }
                         TL_DEBUG_PRINT(tl_out,"\n\n");
                         SET_EXIT(INFTL_FAILED_MOUNT);
           			  }
             	   }
           		   else /* sectorFlags == SECTOR_IGNORED */
                   {
                      vol.flash.read(&vol.flash,unitBaseAddress(vol,iUnit)+i*SECTOR_SIZE,tempbuf,SECTOR_SIZE,0);
           		      TL_DEBUG_PRINT(tl_out,"There is an ignored sector in %d unit %d sector the data is\n",iUnit,i);
                      for(temp=0;temp<SECTOR_SIZE;temp++)
                      {
                        if (temp%0x10==0)
                           TL_DEBUG_PRINT(tl_out,"\n");
                        TL_DEBUG_PRINT(tl_out,"%x ",tempbuf[temp]);
                      }
                      if (status == flOK)
                      {
                         TL_DEBUG_PRINT(tl_out,"\nThe EDC is fine, how about checking bit failures\n\n");
                      }
                      else
                      {
                         TL_DEBUG_PRINT(tl_out,"\nThe EDC is wrong\n\n");
                      }
                   }
                }
             } /* sector loop */
          } /* Used unit */
       } /* Good block */
    } /* unit loop */
    if (vol.debugState & INFTL_FAILED_MOUNT)
    {
       TL_DEBUG_PRINT(tl_out,"\nNote that all unit numbers are relative to first unit = %d\n",vol.firstUnit);
    }
    else
    {
       TL_DEBUG_PRINT(tl_out,"\n");
    }
    return flOK;
}
#endif /* CHECK_MOUNT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\mdocplus.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/MDOCPLUS.H_V  $
 * 
 *    Rev 1.14   Apr 15 2002 07:37:48   oris
 * Added OUT_CNTRL_STICKY_BIT_ENABLE definition.
 * Added FOUNDRY_WRITE_ENABLE definition.
 * Changed OUT_CNTRL_BSY_EN_MASK to OUT_CNTRL_BSY_DISABLE_MASK and used the complimentary value.
 * 
 *    Rev 1.13   Jan 29 2002 20:09:50   oris
 * Added IPL_SA_MODE_MARK and IPL_XSCALE_MODE_MARK definitions.
 * Changed DPS1_COPY0_16 to unit 3 instead of unit 2.
 * Changed IPL_SA_MARK_OFFSET1 to IPL_MODE_MARK_OFFSET.
 * 
 *    Rev 1.12   Jan 17 2002 23:03:12   oris
 * Changed flash addresses to interleave-1 to fit both 32MB and 16MB Plus DiskOnChip devices
 * include docsys file instead of docsysp.
 * Add 16MB Plus DiskOnChip ID 0x41
 * 
 *    Rev 1.11   Nov 22 2001 19:48:56   oris
 * Changed FLS__SEL_WP_MASK and FLS__SEL_CE_MASK to MPLUS_SEL_CE and MPLUS_SEL_WP.
 * 
 *    Rev 1.10   Sep 15 2001 23:47:26   oris
 * Include docsysp.h instead of docsys.h
 *
 *    Rev 1.9   Jul 13 2001 01:08:20   oris
 * Added BBT_MEDIA_OFFSET definition.
 * Moved VERIFY_WRITE and VERIFY_ERASE compilation flag to flcustom.h.
 *
 *    Rev 1.8   May 16 2001 21:20:44   oris
 * Added busy delay for download operation DOWNLOAD_BUSY_DELAY.
 * Moved SYNDROM_BYTES definition to flflash.h.
 *
 *    Rev 1.7   May 09 2001 00:33:24   oris
 * Removed the IPL_CODE and READ_BBT_CODE defintion.
 *
 *    Rev 1.6   May 06 2001 22:42:12   oris
 * redundant was misspelled.
 *
 *    Rev 1.5   Apr 30 2001 18:02:40   oris
 * Added READ_BBT_CODE defintion.
 *
 *    Rev 1.4   Apr 24 2001 17:11:40   oris
 * Bug fix - otp start address definition did not take interleave into acount.
 *
 *    Rev 1.3   Apr 18 2001 21:25:58   oris
 * Added OTPLockStruct record.
 *
 *    Rev 1.2   Apr 16 2001 13:55:20   oris
 * Removed warrnings.
 *
 *    Rev 1.1   Apr 09 2001 15:08:22   oris
 * End with an empty line.
 *
 *    Rev 1.0   Apr 01 2001 07:42:32   oris
 * Initial revision.
 *
 */

/*******************************************************************
 *
 *    DESCRIPTION: basic mtd functions for the MDOC32
 *
 *    AUTHOR: arie tamam
 *
 *    HISTORY: created november 14, 2000
 *
 *******************************************************************/
/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/
#ifndef MDOCPLUS_H
#define MDOCPLUS_H

/** include files **/
#include "docsys.h"

/** public functions **/
extern FLStatus changeInterleave(FLFlash vol, byte interNum);
extern FLStatus chkASICmode (FLFlash vol);

#ifndef MTD_STANDALONE
extern FLBoolean checkWinForDOCPLUS(unsigned driveNo, NDOC2window memWinPtr);
#endif /* MTD_STANDALONE */

      /*.*/
      /*    Feature list            */
      /*.*/

/* #define MULTI_ERASE   */  /* use multiple block erase feature */
/* #define WIN_FROM_SS   */  /* call Socket Services to get window location */
/* #define LOG_FILE      */  /* log edc errors                              */

/*----------------------------------------------------------------------*/
/*                          s e t F l o o r                             */
/*                                                                      */
/* Set the specified floor as the active floor.                         */
/*                                                                      */
/* Parameters:                                                          */
/*      vol     : Pointer identifying drive                             */
/*      floor   : The new active floor                                  */
/*                                                                      */
/*----------------------------------------------------------------------*/

#define setFloor(volume,floor) flWrite8bitRegPlus(volume,NASICselect,floor); /* select ASIC */


/* The first page of the customer OTP area */
typedef struct {
byte    lockByte[4];
LEulong usedSize;
} OTPLockStruct;

#define DOWNLOAD_BUSY_DELAY 300000L
#define BUSY_DELAY          30000
#define START_ADR           0xC8000L
#define STOP_ADR            0xF0000L

#define MDOCP_PAGES_PER_BLOCK 0x20    /* 16 pages per block on a single chip */
#define CHIP_PAGE_SIZE        0x100   /* Page Size of 2 Mbyte Flash */
#define IPL_MAX_SIZE          1024l   /* IPL maximum media size     */
#define CHIP_TOTAL_SIZE       0x1000000L
#define SIZE_OF_DPS           0x12
#define NO_OF_DPS             2
#define SECTOR_SIZE_MASK      0xff
#define BBT_MEDIA_OFFSET      2048L
     /* Flash page area sizes */

#define SECTOR_FLAG_SIZE            2
#define UNIT_DATA_SIZE              8
#define EDC_SIZE                    6
#define EDC_PLUS_SECTOR_FLAGS       8
#define END_OF_SECOND_SECTOR_DATA   10
#define START_OF_SECOND_SECTOR_DATA 10
#define UNIT_DATA_OFFSET            16
#define UNIT_DATA_OFFSET_MINUS_8    8
#define SECOND_SECTOR_FLAGS_OFFSET  8
#define TOTAL_EXTRA_AREA            16

     /* OTP defintions */

#define OTP_LOCK_MARK       0
#define CUSTOMER_OTP_SIZE   6*1024
#define CUSTOMER_OTP_START  SECTOR_SIZE*6L
#define UNIQUE_ID_OFFSET    0x10
#define UNIQUE_ID_SIZE      16

     /* IPL flash media offsets */

#define IPL_START_OFFSET    (SECTOR_SIZE<<1)
#define IPL_HIGH_SECTOR     (SECTOR_SIZE<<1)

#define IPL0_COPY0_32 (flash->erasableBlockSize << 1) + IPL_START_OFFSET/* Unit 2 + 1024 */
#define IPL1_COPY0_32 IPL0_COPY0_32 + IPL_HIGH_SECTOR                   /* Unit 2 + 2048 */

#define IPL0_COPY0_16 (flash->erasableBlockSize * 3) + IPL_START_OFFSET /* Unit 3 + 1024 */
#define IPL1_COPY0_16 IPL0_COPY0_16 + IPL_HIGH_SECTOR                   /* Unit 3 + 2048 */


     /* DPS flash media offsets */

#define REDUNDANT_DPS_OFFSET (SECTOR_SIZE+0x80)
#define DPS0_COPY0    flash->erasableBlockSize       /* Unit 1 */
#define DPS1_COPY0_32 (flash->erasableBlockSize<<1L) /* Unit 2 */
#define DPS1_COPY0_16 (flash->erasableBlockSize*3L)  /* Unit 3 */


#define DPS0_UNIT_NO    1
#define DPS1_UNIT_NO_32 2
#define DPS1_UNIT_NO_16 3

     /* Strong arm mark offset */

#define IPL_MODE_MARK_OFFSET    IPL1_COPY0_16+8

#define IPL_SA_MODE_MARK        0xF8 /* Strong Arm */
#define IPL_XSCALE_MODE_MARK    0X8F /* X-Scale    */

     /* miscellaneous limits */

#define MAX_FLASH_DEVICES_MDOCP 1 /* maximum flash inside one MDOC */
#define MAX_FLOORS              4
#define CHIP_ID_MDOCP          0x40  /* MDOCP 32MB chip identification value */
#define CHIP_ID_MDOCP16        0x41  /* MDOCP 16MB chip identification value */
#define MDOC_ALIAS_RANGE       0x100
#define ALIAS_RESOLUTION       (MAX_FLASH_DEVICES_MDOCP + 10)

  /*
     Definition for writing boot image  
    */

#define SPL_SIZE           0x2000 /* 8 KBytes */
#define MAX_CODE_MODULES   6      /* max number of code modules in boot area (incl. SPL) */

   /*-----------------------------------------
    | Definition of MDOC32 memory window  |
    ----------------------------------------*/

/*        MDOC32 memory window layout :

         0000 .... 07FF    RAM ( 1KB aliased across 2KB)
         0800 .... 0FFF    Flash Data Register (2KB alias of address 1028H-1029H)
               1000    Chip Identification register
               1002     NOP register
               1004     Alias Resolution register
               1006     DOC Control register
               1008     Device ID select register
               100a     Configuration Input register
               100c     Output Control register
               100e     Interrupt Control register
               1012     Output Enable Delay  register
            101E - 101F Flash Slow Read register[1:0]
               1020     Flash Control Register
               1022     Flash Select register
               1024     Flash Command register
               1026     Flash Address register
            1028-1029   Flash Data Register
               102A     Read Pipeline Initialization register
            102C-102D   Last Data Read register
               102E     Write Pipeline Termination register
            1040-1045   ECC Syndrome register[5:0]
               1046     ECC Control register
               1048     Customer OTP Pointer register
               105A     Flash Geometry register
            105C-105D   Data Protect Structure Status register[1:0]
            105E-105f   Data Protect Structure Pointer register[1:0]
            1060-1063   Data Protect Lower Address register 0 [3:0]
            1064-1067   Data Protect Upper Address register 0 [3:0]
            1068-106B   Data Protect Lower Address register 1 [3:0]
            106C-106F   Data Protect Upper Address register 1 [3:0]
               1070     Data Protect Key register[0]
               1072     Data Protect Key register[1]
               1074     Download status register
               1076     DOC Control Confirmation register
               1078     Protection Status register
               107E     Foundry Test register
            1800-1FFE   RAM (1KB aliased across 2KB)
               1FFF     Release from power down mode

*/

#define Nio              0x800      /* Flash Data Register (2KB alias of address 1028H-1029H) read/write  */
#define NIPLpart2        0x800      /* Flash Data Register (2KB alias of address 1028H-1029H) read/write */

#define NchipId          0x1000     /* Chip Identification register. read       */
#define ID_FAMILY_MASK      0xf0    /* family .  */
#define ID_VERSION_MASK     0x7     /* version.  */

#define NNOPreg          0x1002     /* NOP register. read/write    */

#define NaliasResolution 0x1004     /* Alias Resolution register. read write  */

/* Asic controll register  */

#define NDOCcontrol         0x1006  /* DOC Control register.  read/write */
#define NDOCcontrolConfirm  0x1076  /*DOC Control Confirmation register.read only*/
#define DOC_CNTRL_RAM_WE_MASK   0x20    /* ram write enable. 1=allow write to RAM. */
#define DOC_CNTRL_RST_LAT_MASK  0x10    /* reset mode latched. */
#define DOC_CNTRL_BDETCT_MASK   0x8     /* boot detect. */
#define DOC_CNTRL_MDWREN_MASK   0x4     /* mode write enable. */
#define DOC_CNTRL_MODE_MASK     0x3     /* mode of operation. 00=reset, 01=normal, 1x=power down */
#define DOC_CNTRL_MODE_RESET    0x0     /* Reset mode + MDWREN      */
#define DOC_CNTRL_MODE_NORMAL   0x1     /* Normal mode + MDWREN     */
#define DOC_CNTRL_MODE_PWR_DWN  0x2     /* Power down mode + MDWREN */
/* The modes are ORed with the following state:
   a) Do not enable ram write.       ~0x20
   b) Reset the reset mode latche.   0x10
   c) Reset the boot detect latche   0x08
   d) Enable writing new mode        0x04
   e) Clear mode bits                2 LSB             */
#define DOC_CNTRL_DEFAULT       0x1c

#define NASICselect      0x1008     /* Device ID select register. read/ write */
#define ASIC_SELECT_ID_MASK 0x3     /* identification */

#define NconfigInput     0x100A     /* Configuration Input register. read/write  */
#define CONFIG_IF_CFG_MASK  0x80    /* state of IF_CFG input pin. */
#define CONFIG_MAX_ID_MASK  0x30    /* maximum device ID */
#define CONFIG_BD_IHN_MASK  0x8     /* boot detector inhibit */
#define CONFIG_INTLV_MASK   0x4     /* interleave. 0=interleave-1, 1=interleave-2  */

#define NoutputControl   0x100C     /* Output Control register. read/write */
#define OUT_CNTRL_BSY_DISABLE_MASK  0xfe /* busy enable . 1=enable assertion of the BUSY# output */
#define OUT_CNTRL_STICKY_BIT_ENABLE 0x8  /* sticky bit  . 8=prevent key insertion */

#define NinterruptControl   0x100E  /* Interrupt Control register. read/write */
#define INTR_IRQ_P_MASK     0x40    /* interrupt request on protection violation */
#define INTR_IRQ_F_MASK     0x20    /* interrupt request on FREADY */
#define INTR_EDGE_MASK      0x10    /* edge/level interrupt. 1=edge */
#define INTR_PROT_T_MASK    0x8 /* protection trigger */
#define INTR_FRDY_T_MASK    0x7 /* flash ready trigger */

#define NoutputEnableDelay  0x1012  /* Output Enable Delay  register. read/write */

#define NslowIO             0x101E     /* Flash Slow Read register[1:0]. read only */

#define NflashControl       0x1020     /* Flash Control Register. read write */
#define FLS_FR_B_MASK       0xc0    /* flash ready/busy for 2 byte lanes*/
#define FLS_FR_B_EVEN_MASK  0x40    /* flash ready/busy for even lane*/
#define FLS_FR_B_ODD_MASK   0x80    /* flash ready/busy for odd lane*/
#define FLS_ALE_MASK        0x4     /* address latch enable */
#define FLS_CLE_MASK        0x2     /* command latch enable */

#define NflashSelect        0x1022  /* Flash Select register. read write */
#define MPLUS_SEL_CE        0x80    /* chip enable */
#define MPLUS_SEL_WP        0x60    /* write protect*/
#define FLS_SEL_BANK_MASK   0x2 /* select flash bank to access */
#define FLS_SEL_BYTE_L_MASK 0x1 /* select flash device of the bankbyte lane*/
/* The default for MDOCP is the following combination:
   a) Send chip enable.          - 0x80
   b) Lower write protect.       - 0x40
   c) Select chip bank 0 chip 0  - 0 for bits 0-5 */
#define FLS_SEL_DEFAULT  0x80

#define NflashCommand    0x1024     /*Flash Command register. write only */

#define NflashAddress    0x1026     /* Flash Address register. write only */

#define NflashData       0x1028     /* Flash Data Register[1:0]. read/write */

#define NreadPipeInit    0x102A     /* Read Pipeline Initialization register. read only */

#define NreadLastData_1  0x102C     /* Last Data Read register. read only */

#define NreadLastData_2  0x102D     /* Last Data Read register. read only */

#define NwritePipeTerm   0x102E     /*Write Pipeline Termination register. write  only */

#define Nsyndrom         0x1040     /*ECC Syndrome register[5:0]. read only       */

#define NECCcontrol       0x1046     /*ECC Control register. read/write  */
#define ECC_CNTRL_ERROR_MASK    0x80    /*EDC error detection */
#define ECC_CNTRL_ECC_RW_MASK   0x20    /* ECC read/write. 1=ECC in write mode*/
#define ECC_CNTRL_ECC_EN_MASK   0x8 /* ECC enable */
#define ECC_CNTRL_TOGGLE_MASK   0x4 /* identify presence of MDOC*/
#define ECC_CNTRL_IGNORE_MASK   0x1 /* ignore the ECC unit*/
#define ECC_RESET   0   /* reset the ECC */

#define NcustomerOTPptr  0x1048     /* Customer OTP Pointer register. read only*/

#define NflashGeometry   0x105A     /* Flash Geometry register. read only */

#define NdownloadStatus         0x1074  /*Download status register. read only*/
#define DWN_STAT_IPL_ERR        0x30
#define DWN_STAT_IPL_INVALID    0x20
#define DWN_STAT_IPL_1_ERR      0x10
#define DWN_STAT_OTP_ERR        0x40    /* */
#define DWN_STAT_DPS1_ERR       0xc
#define DWN_STAT_DPS0_ERR       0x3
#define DWN_STAT_DPS10_ERR      0x4
#define DWN_STAT_DPS11_ERR      0x8
#define DWN_STAT_DPS00_ERR      0x1
#define DWN_STAT_DPS01_ERR      0x2
#define DWN_STAT_DWLD_ERR       0x4a    /* otp + all 4 copies of dps */

#define NprotectionStatus       0x1078  /*Protection Status register. read only*/
#define PROTECT_STAT_ACCERR     0x80
#define PROTECT_STAT_LOCK_INPUT_MASK 0x10
#define PROTECT_STAT_4BA_MASK   0x8
#define PROTECT_STAT_COTPL_MASK 0x4
#define PROTECT_STAT_BUC_MASK   0x2
#define PROTECT_STAT_FOTPL_MASK 0x1

#define NfoudaryTest            0x107E  /* Foundry Test register. write only */
#define FOUNDRY_WRITE_ENABLE    0xc3
#define FOUNDRY_DNLD_MASK       0x80
#define NreleasePowerDown       0x1FFF  /* Release from power down. */

#endif /* MDOCPLUS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\mtdsa.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/MTDSA.H_V  $
 *
 *    Rev 1.22   Apr 15 2002 08:31:12   oris
 * Added USE_TFFS_COPY compilation flag.
 * This flag is used by bios driver a Boot SDK in order to improove performance.
 *
 *    Rev 1.21   Apr 15 2002 07:38:02   oris
 * Moved system types from flBase.h
 * Moved compilation flag validations for TrueFFS to flchkdfs.h
 *
 *    Rev 1.20   Feb 19 2002 21:00:48   oris
 * Added include of "flchkfds.h"
 *
 *    Rev 1.19   Jan 28 2002 21:26:14   oris
 * Removed the use of back-slashes in macro definitions.
 *
 *    Rev 1.18   Jan 17 2002 23:03:38   oris
 * Commented out all compilation flags.
 * Replaced USE_FUNC with FL_NO_USE_FUNC so that memory access routines  uses routines by default.
 * MTD_NO_READ_BBT_CODE was separated to MTD_READ_BBT and  MTD_RECONSTRUCT_BBT
 * Added windows CE predefined system customization.
 * Changed FAR_LEVEL default - always 0 unless DOS
 * Join delay routine with matching OS definition.
 * If NULL pointers are not defined (or DOS OS) defined NULL as ((void  FAR0*)0)
 *
 *    Rev 1.17   Nov 29 2001 20:54:12   oris
 * CURRECT_OS was changed to CURRENT_OS
 * Added default FAR_LEVEL for VxWorks
 *
 *    Rev 1.16   Sep 15 2001 23:47:42   oris
 * Changed BIG_ENDIAN to FL_BIG_ENDIAN
 *
 *    Rev 1.15   Jul 29 2001 16:41:18   oris
 * Added CUR_NO_OS definition
 * Remove USE_STD_FUNC defintion when using big_endian. since memcpy function can cause memory access problems (buffers are copied from the end).
 *
 *    Rev 1.14   Jul 15 2001 21:08:02   oris
 * Changed DFORMAT_PRINT syntax to be similar to DEBUG_PRINT.
 *
 *    Rev 1.13   Jul 13 2001 01:07:28   oris
 * Bug fix - Use different memory H file include for vxWorks and DOS for memory handling (memcpy, memset and memcmp)/.
 * Added DFORMAT_PRINT macro.
 * Changed default configuration.
 *
 *    Rev 1.12   Jun 17 2001 22:30:12   oris
 * Comment NO_??? defintions.
 *
 *    Rev 1.11   Jun 17 2001 18:57:04   oris
 * Improved documentation and remove warnings.
 *
 *    Rev 1.10   Jun 17 2001 08:17:42   oris
 * Removed warnings.
 *
 *    Rev 1.9   May 21 2001 18:24:14   oris
 * Removed BDK_IMAGE_TO_FILE as a default definition.
 * Change physicalToPointer macro when FAR_LEVEL = 0.
 *
 *    Rev 1.8   May 21 2001 16:11:14   oris
 * Added  USE_STD_FUNC defintion.
 * Added memcpy memset and memcmp as defaults for tffscpy tffsset and tffscmp.
 * Removed naming conventions.
 * Removed DRIVES definition.
 *
 *    Rev 1.7   May 20 2001 14:36:14   oris
 * Reorganized header file.
 *
 *    Rev 1.6   May 16 2001 21:21:00   oris
 * Restored the SOCKETS and BINARY_PARTITIONS definitions.
 *
 *    Rev 1.5   May 09 2001 00:32:56   oris
 * Changed IPL_CODE to NO_IPL_CODE , READ_BBT_CODE to NO_READ_BBT_CODE.
 * Moved BINARY_PARTITIONS and SOCKETS to docbdk.h.
 * Removed the DOC2000_FAMILY and DOCPLUS_FAMILY.
 * Uncommented the HW_OTP compilation flag as a default for the BDK.
 *
 *    Rev 1.4   Apr 30 2001 18:03:06   oris
 * Added READ_BBT_CODE definition and IPL_CODE defintion.
 *
 *    Rev 1.3   Apr 09 2001 15:03:26   oris
 * Changed default settings to no verify write and no checksum calculation.
 *
 *    Rev 1.2   Apr 01 2001 07:53:44   oris
 * copywrite notice.
 * Alligned left all # directives.
 * Added the following compilation flag:
 *   HW_OTP
 *   MTD_FOR_EXB
 *
 *    Rev 1.1   Feb 07 2001 17:32:48   oris
 * Added SOCKETS defintion for standalone mode
 *
 *    Rev 1.0   Feb 04 2001 12:25:00   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE, OR CONTACT M-SYSTEMS         */
/*      FOR LICENSE ASSISTANCE: E-MAIL = info@m-sys.com                            */
/***********************************************************************************/


/************************************************************************/
/* TrueFFS and Standalone MTD                                           */
/************************************************************************/

/************************************************************************/
/* File Header                                                          */
/* -----------                                                          */
/* Name : mtdsa.h                                                       */
/*                                                                      */
/* Description : This file contains neccesary definition and            */
/*                 customization                                        */
/*               for the MTD standalone mode. It also contains the      */
/*               compilation flag determining the mode of operation     */
/*                 either                                               */
/*               TrueFFS or MTD standalone                              */
/*                                                                      */
/* Warning :     TrueFFS application must keep the MTD_STANDALONE       */
/*                 definition                                           */
/*               commented.                                             */
/*                                                                      */
/************************************************************************/


#ifndef MTD_SA_H
#define MTD_SA_H

/************************************************************************/
/* Uncomment the following line when using the MTD in standalone mode   */
/************************************************************************/

/* #define        MTD_STANDALONE */


/************************************************************************/
/* The rest of the file is for the BDK standalone package only          */
/************************************************************************/

#ifdef        MTD_STANDALONE

/************************************************************************/
/*                                                                      */
/*       Binary Development Kit Stand Alone Customization Area          */
/*                                                                      */
/************************************************************************/

/************************************************************************/
/* Section 1.                                                           */
/*                                                                      */
/* Customize the features to be compiled in your standalone             */
/* application. Each required feature will add to your final executable */
/* code.                                                                */
/*                                                                      */
/* Simply uncomment the required feature directive.                     */
/*                                                                      */
/************************************************************************/

/* #define ACCESS_BDK_IMAGE  */ /* Compile the binary read  routines       */
/* #define UPDATE_BDK_IMAGE  */ /* Compile the binary write routines       */
/* #define ERASE_BDK_IMAGE   */ /* Compile the binary erase routine        */
/* #define CREATE_BDK_IMAGE  */ /* Compile the binary create routine       */
/* #define PROTECT_BDK_IMAGE */ /* Compile the binary protection routines  */
/* #define HW_OTP            */ /* Compile the binary OTP routines         */
/* #define EDC_MODE          */ /* Use the EDC\ECC mechanizm               */
/* #define BDK_IMAGE_TO_FILE */ /* Compile the files related routines         */
/* #define BDK_CHECK_SUM     */ /* Calculate checksum on read operation       */
/* #define BDK_VERIFY_WRITE  */ /* Read and compare after every write         */
/* #define FL_NO_USE_FUNC    */ /* Do not use function for register access    */
/* #define D2TST             */ /* Exports the EDC syndrome with the global   */
                                /* variable saveSyndromForDumping             */
/* #define FL_BIG_ENDIAN     */ /* Used for big endian architectures          */
/* #define NO_IPL_CODE       */ /* Do not compile code for IPL read and write */
/* #define MTD_READ_BBT      */ /* Compile the read BBT routine code          */
/* #define MTD_RECONSTRUCT_BBT *//* Compile code to scan virgin cards for BBT */
/* #define DEBUG             */ /* Include debug messages                     */
/* #define USE_STD_FUNC      */ /* Use standard 'C' memcpy\memset and memcmp  */
                                /* This define must be commented out when     */
                                /* working with big endian archtechtures. The */
                                /* problem is that some implementations of    */
                                /* memcpy, copy the data from the end of the  */
                                /* buffer, therefore bad implementation for   */
                                /* DiskOnChip memory windows access routines  */
/* #define USE_TFFS_COPY     */ /* Use tffscpy/tffsset for DiskOnChip access  */

/************************************************************************/
/* General Customized constants                                         */
/* The total number of Binary partitions on the DiskOnChip              */
/************************************************************************/

#define BINARY_PARTITIONS 3
#define SOCKETS           1   /* Currently the only option */


/************************************************************************/
/*   Section 2.                                                         */
/*                                                                      */
/*   Includes OS/CPU-specific resources and customization               */
/*                                                                      */
/*   1) Uncomment relevant CURRENT_OS directive below for predefined    */
/*      customization for majore OS'es.                                 */
/*   2) Define the far level of your application's pointers.            */
/*   3) Customize pointer arithmetic routines.                          */
/*   4) Customize debug messages routine.                               */
/*   5) Default calling convention.                                     */
/*   6) NULL constant.                                                  */
/*   7) Signed/unsigned char.                                           */
/*   8) CPU target.                                                     */
/*                                                                      */
/************************************************************************/

#define CUR_NO_OS        0  /* Do not include any OS resources */
#define CUR_OS_PSOS      1  /* Include PSOS          resources */
#define CUR_OS_DOS       2  /* Include DOS           resources */
#define CUR_OS_VX_WORKS  3  /* Include VX_WORKS      resources */
#define CUR_OS_WINCE     4  /* Include Windows CE    resources */

/* #define CURRENT_OS  CUR_OS_PSOS     */  /* uncomment for pSOS    */
/* #define CURRENT_OS  CUR_OS_VX_WORKS */  /* uncomment for VxWorks */
/* #define CURRENT_OS  CUR_OS_DOS      */  /* uncomment for DOS     */
/* #define CURRENT_OS  CUR_OS_WINCE    */  /* uncomment for WINCE   */
/* #define CURRENT_OS  CUR_NO_OS       */  /* uncomment for NO OS   */

/************************************************************************/
/* Far pointers                                                         */
/*                                                                      */
/* Specify here which pointers can be far, if any.                      */
/* Far pointers are usually relevant only to 80x86 architectures.       */
/*                                                                      */
/* Specify FAR_LEVEL:                                                   */
/*   0 - If using a flat memory model or having no far pointers.        */
/*   1 - If only the DiskOnChip window may be far                       */
/*   2 - If only the DiskOnChip window and RAM window may be far.       */
/*   3 - If DiskOnChip window, RAM window and pointer(s)                */
/*       transferred to the entry-point function may be far             */
/************************************************************************/

#if (CURRENT_OS==CUR_OS_DOS)
#define FAR_LEVEL  2
#else
#define FAR_LEVEL  0
#endif /* CURRENT_OS == CUR_OS_DOS */

/************************************************************************/
/* Pointer arithmetic                                                   */
/*                                                                      */
/* The following macros define machine- and compiler-dependent macros   */
/* for handling pointers to physical bdkWindow addresses. The           */
/* definitions below are for PC real-mode Borland-C.                    */
/*                                                                      */
/* 'physicalToPointer' translates a physical flat address to a (far)    */
/* pointer. Note that if when your processor uses virtual memory, the   */
/* code should map the physical address to virtual memory, and return a */
/* pointer to that memory (the size parameter tells how much memory     */
/* should be mapped).                                                   */
/*                                                                      */
/* 'addToFarPointer' adds an increment to a pointer and returns a new   */
/* pointer. The increment may be as large as your window size. The code */
/* below assumes that the increment is larger than 64 KB and so         */
/* performs huge pointer arithmetic.                                    */
/*                                                                      */
/* 'freePointer' frees an allocated pointer. This is useful in          */
/* architectures using virtual memory.                                  */
/*                                                                      */
/* The example bellow is relevant for DOS OS                            */
/************************************************************************/

#if FAR_LEVEL > 0

#define physicalToPointer(physical,size,driveNo)          \
        MK_FP((int) ((physical) >> 4),(int) (physical) & 0xF)

#define pointerToPhysical(ptr)                  \
        (((unsigned long) FP_SEG(ptr) << 4) + FP_OFF(ptr))

#define freePointer(ptr,size) 1

#define addToFarPointer(base,increment)                \
        MK_FP(FP_SEG(base) +                        \
        ((unsigned short) ((FP_OFF(base) + (unsigned long)(increment)) >> 16) << 12), \
        FP_OFF(base) + (int) (increment))
#else

#define physicalToPointer(physical,size,driveNo) ((void *) (physical))

#define pointerToPhysical(ptr)  ((unsigned long)(ptr))

#define addToFarPointer(base,increment) ((void *) ((unsigned char *) (base) + (increment)))

#define freePointer(ptr,size) 1
#endif

/************************************************************************/
/* Debug mode                                                           */
/*                                                                      */
/* Uncomment the following lines if you want debug messages to be       */
/* printed out. Messages will be printed at initialization key points,  */
/* and when low-level errors occur.                                     */
/* You may choose to use 'printf' or provide your own routine.          */
/************************************************************************/

#if DBG
#include <stdio.h>
#define DEBUG_PRINT(p) printf p
#define DFORMAT_PRINT(p) printf p
#else
#define DEBUG_PRINT(str)
#define DFORMAT_PRINT(str)
#endif

/************************************************************************/
/* Default calling convention                                           */
/*                                                                      */
/* C compilers usually use the C calling convention to routines (cdecl),*/
/* but often can also use the pascal calling convention, which is       */
/* somewhat more economical in code size. Some compilers also have      */
/* specialized calling conventions which may be suitable. Use compiler  */
/* switches or insert a  #pragma here to select your favorite calling   */
/* convention.                                                          */
/************************************************************************/

#if (CURRENT_OS == CUR_OS_DOS)
#pragma option -p        /* Default pascal calling convention */
#endif /* CURRENT_OS == CUR_OS_DOS */

/************************************************************************/
/* NULL constant                                                        */
/*                                                                      */
/* Some compilers require a different definition for the NULL pointer   */
/************************************************************************/

#if (CURRENT_OS == CUR_OS_DOS)
#include <_null.h>
#else
#ifndef NULL
#define NULL ((void FAR0*)0)
#endif /* NULL */
#endif /* CURRENT_OS == CUR_OS_DOS */

/************************************************************************/
/* signed/unsigned char                                                 */
/*                                                                      */
/* It is assumed that 'char' is signed. If this is not your compiler    */
/* default, use compiler switches, or insert a #pragma here to define   */
/* this.                                                                */
/************************************************************************/

#if (CURRENT_OS == CUR_OS_DOS)
#pragma option -K-        /* default char is signed */
#endif /* CURRENT_OS == CUR_OS_DOS */

/************************************************************************/
/* CPU target                                                           */
/*                                                                      */
/* Use compiler switches or insert a #pragma here to select the CPU     */
/* type you are targeting.                                              */
/*                                                                      */
/* If the target is an Intel 80386 or above, also uncomment the         */
/* CPU_i386 definition.                                                 */
/************************************************************************/

#if (CURRENT_OS == CUR_OS_DOS)
#pragma option -3        /* Select 80386 CPU */
#endif /* CURRENT_OS == CUR_OS_DOS */

/***********************************************************************/
/*                    End of Customization Area                        */
/***********************************************************************/

/* Replacement for various TrueFFS definitions */

#define SECTOR_SIZE_BITS 9  /* defines the log2 of a sector size (512) */
#define        MTDS      2  /* Maximum number of registred MTDS        */

/***********************************************************************/
/* Check for missing defines dependencies Do not customized            */
/***********************************************************************/
/* 1) Update routines require the functionalities of the read routine. */
/* 2) Removal of the binary read or write routines does not remove the */
/*    flash read and write routines. In order to save on the TEXT code */
/***********************************************************************/

#ifdef UPDATE_BDK_IMAGE
#ifndef ACCESS_BDK_IMAGE
#define ACCESS_BDK_IMAGE
#endif /* !ACCESS_BDK_IMAGE */
#endif /* UPDATE_BDK_IMAGE */


/***********************************************************************/
/* Custom the MTD definitions to meet the above definitions            */
/***********************************************************************/
/* 1) EDC_MODE             -> ~ NO_EDC_MODE                            */
/* 2) BDK_VERIFY_WRITE     -> VERIFY_WRITE                             */
/* 3) USE_FUNC_FOR_ACCESS  -> ~ FL_NO_USE_FUNC                         */
/* 4) UPDATE_BDK_IMAGE     -> ~ FL_READ_ONLY                           */
/* 5) ~DOCPLUS_FAMILY      -> ~ PROTECT_BDK_IMAGE                      */
/* 6) PROTECT_BDK_IMAGE    -> HW_PROTECTION                            */
/* 7) DOS                  -> CUR_OS                                   */
/* 8) FL_BIG_ENDIAN        -> ~ USE_STD_FUNC                           */
/* 9) MTD_NO_READ_BBT_CODE -> ~ MTD_READ_BBT + ~ MTD_RECONSTRUCT_BBT   */
/***********************************************************************/

#ifdef        EDC_MODE
#ifdef        NO_EDC_MODE
#undef        NO_EDC_MODE
#endif        /* NO_EDC_MODE */
#else         /* EDC_MODE */
#define       NO_EDC_MODE
#endif        /* EDC_MODE */

#ifdef        BDK_VERIFY_WRITE
#define       VERIFY_WRITE
#endif        /* BDK_VERIFY_WRITE */

#ifdef        USE_FUNC_FOR_ACCESS
#undef        FL_NO_USE_FUNC
#endif        /* USE_FUNC_FOR_ACCESS */

#ifndef       UPDATE_BDK_IMAGE
#define       FL_READ_ONLY
#endif        /* UPDATE_BDK_IMAGE */

#if (defined(PROTECT_BDK_IMAGE) && !defined(HW_PROTECTION))
#define HW_PROTECTION
#endif  /* PRTOECTION_BDK_IMAGE */

#if (defined(FL_BIG_ENDIAN) && defined(USE_STD_FUNC))
#undef USE_STD_FUNC
#endif /* FL_BIG_ENDIAN */

#ifdef MTD_NO_READ_BBT_CODE
#undef MTD_READ_BBT
#undef MTD_RECONSTRUCT_BBT
#endif /* MTD_NO_READ_BBT_CODE */

/*********************************/
/* Include specific OS resources */
/*********************************/

#if (CURRECT_OS == CUR_OS_WINCE)
#include <windows.h>
#include "pkfuncs.h"
#include <memory.h>
#include <stdio.h>
#endif /*CUR_OS_WINCE*/


#if (CURRENT_OS == CUR_OS_VX_WORKS)
/* OS-specific includes */
#include <vxWorks.h>
#include <tickLib.h>
#include <sysLib.h>

#ifdef USE_STD_FUNC
#include "memLib.h"
#endif /* USE_STD_FUNC */
#define VXW_DELAY  /* uncomment for VxWorks delay */
#endif /* CURRENT_OS == CUR_OS_VX_WORKS */

#if (CURRENT_OS == CUR_OS_PSOS)
/* OS-specific includes */
#include <psos.h>
#include <bspfuncs.h>
#include "sys_conf.h"

#ifdef USE_STD_FUNC
#include "memLib.h"
#endif /* USE_STD_FUNC */
#define PSS_DELAY   /* uncomment for pSOS    delay */
#endif /* CURRENT_OS == CUR_PSOS */

#if (CURRENT_OS == CUR_OS_DOS)
/* OS-specific includes */
#include <dos.h>

#ifdef USE_STD_FUNC
#include "mem.h"
#endif /* USE_STD_FUNC */
#define DOS_DELAY        /* uncomment for DOS     delay */
#endif /* CURRENT_OS == CUR_OS_DOS */

/*******************************************/
/* Declare memcpy, memset, memcmp routines */
/*******************************************/

#ifdef USE_STD_FUNC
#if FAR_LEVEL > 0
#define tffscpy _fmemcpy
#define tffscmp _fmemcmp
#define tffsset _fmemset
#else
#define tffscpy memcpy
#define tffscmp memcmp
#define tffsset memset
#endif /* FAR_LEVEL */
#endif /* USE_STD_FUNC */
#endif /* MTD_STANDALONE */
#endif /* MTD_SA_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\makefile.inc ===
clean: cleanup

cleanup:
    del $(O)\trueffs.bmf
    del obj\$(TARGET_DIRECTORY)\trueffs.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\mdocplus.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/MDOCPLUS.C_V  $
 *
 *    Rev 1.45   Apr 15 2002 07:37:38   oris
 * Changed usage and logic of checkToggle to be more intuitive.
 * Added support for new access layer (docsys). MTD now initializes the access layer accessing the DiskOnChip registers.
 * Added macro's for several special DiskOnChip registers.
 * Remove interleave if statement since new access layer simply uses different routine for int-1 and int-2.
 * Bug fix - setAsicMode routine should first exit power down before checking for access error.
 * Bug fix - forceDownload routine did not issue the download command to all DiskOnChip floors.
 * Bug fix - added verify write support for uneven address and length.
 * Bug fix - doc2write routine might not report flHWProtection when in FL_OFF mode.
 * Bug fix - readBBT when reading less then 8 bytes.
 * Bug fix - writeIPL routine did not write all copies of IPL
 * Bug fix - readIPL routine did not set Max Id properly.
 *
 *    Rev 1.44   Feb 19 2002 21:00:40   oris
 * Replaced flTimeOut status with flTimedOut.
 * Bug fix - missing initialization of returned status in otpSize routine.
 * Bug fix - read OTP routine when offset != 0
 * Bug fix - unique ID is now read with EDC.
 *
 *    Rev 1.43   Jan 29 2002 20:09:40   oris
 * Switched arguments sent to docPlusSet.
 * Added support for FL_IPL_MODE_XSCALE and changed support for FL_IPL_MODE_SA in writeIPL routine acording to new spec.
 * Added sanity check for write IPL modes.
 *
 *    Rev 1.42   Jan 28 2002 21:26:06   oris
 * Removed the use of back-slashes in macro definitions.
 * Changed docwrite and docset calls to separate DiskOnChip base window pointer and IO registers offset (for address shifting).
 * Replaced FLFlash argument with DiskOnChip memory base pointer in calls to docwrite , docset , docread, wrBuf and wrSet.
 * Removed win_io initialization (one of FLFlash record fields).
 * Improved check for flSuspend.
 * Added FL_IPL_DOWNLOAD flag to writeIPL routine in order to control whether the IPL will be reloaded after the update.
 * Removed wrBuf and wrSet macros.
 *
 *    Rev 1.41   Jan 23 2002 23:33:38   oris
 * Bug fix - checkErase routine was unreasonably slow.
 * Changed DFORMAT_PRINT syntax
 * Bug fix - bad offset of writeIPL routine caused only first 512 bytes to be written.
 * Changed readOTP not to use PARTIAL_EDC code.
 *
 *    Rev 1.40   Jan 21 2002 20:45:12   oris
 * Compilation errors for MTD_STANDALONE with BDK_VERIFY_WRITE.
 * Missing casting causes compilation error in readIPL.
 *
 *    Rev 1.39   Jan 20 2002 20:57:02   oris
 * physicalToPointer was called with wrong size argument.
 *
 *    Rev 1.38   Jan 20 2002 20:28:58   oris
 * Removed warnings.
 * Restored readIPL function initialization.
 *
 *    Rev 1.37   Jan 20 2002 12:12:26   oris
 * Removed warnings.
 *
 *    Rev 1.36   Jan 20 2002 10:10:52   oris
 * Moved mtdVars to docsoc.c (common with diskonc.c)
 * Removed warnings.
 * Replaced vol with *flash.
 * Removed flPreInitXXXX  memory access routines.
 * Added new memory access routine implementation.
 * Simplified docsys interleave-1 operations (interleave-1 operations use only 1 byte per operation. The if was made in docsys and is now a part of the MTD)
 * Bug in implementation of VERIFY_ERASE  extra area was fixed.
 * Added support for flSuspendMode environment variable.
 * Added support for 16MB Plus DiskOnChip :
 *  - Revised write IPL code
 *  - Revised read IPL code - now reads from SRAM and not flash causes download of protection logic.
 *  - OTP / Unique ID offsets were updated to be interleave dependent.
 *  - readBBT routine was changed to support DiskOnChip Millennium Plus.
 *  - Identification routine was changed.
 * Changed checkStatus with if != flOK
 * Added interrupt support under ifdef (ENABLE_EDGE__INTERRUPT /  ENABLE_LEVEL__INTERRUPT)
 * Changed NO_READ_BBT_CODE ifdef to MTD_READ_BBT.
 * Big fix in erasable Block Size Bits field of the flash record when changing interleave.
 * Added force remmapping of internal sector buffer.
 *
 *    Rev 1.35   Nov 22 2001 19:48:46   oris
 * Power consumption bug fix - chip select to the flash was remained open causing the power down mode to be ignored and the ideal current consumption to be twice the normal current.
 * Made sure that when preventing the BUSY# signal to be asserted by the download operation all other bits of the output controll register remain as they were.
 *
 *    Rev 1.34   Nov 21 2001 11:38:14   oris
 * Changed FL_WITH_VERIFY_WRITE and FL_WITHOUT_VERIFY_WRITE to FL_ON and  FL_OFF.
 *
 *    Rev 1.33   Nov 20 2001 20:25:36   oris
 * Bug fix - deep power down mode was released after access due to check of access error.
 * Bug fix - download operation did assert the BUSY#.
 *
 *    Rev 1.32   Nov 16 2001 00:23:04   oris
 * Restored byte (if_cfg=8) access for reading syndrome registers.
 *
 *    Rev 1.31   Nov 08 2001 10:49:48   oris
 * Removed warnings.
 * Added run-time control over verify write mode buffers.
 *
 *    Rev 1.30   Oct 18 2001 22:17:22   oris
 * Bug fix - incorrect read and write when performed from the middle of the page, incomplete pages , more then 1k when EDC is not requested.
 *
 *    Rev 1.29   Oct 11 2001 23:55:10   oris
 * Bug fix - Read operation to the MTD from 2 different pages (for example read operation to BDK with length > 1K) the logic that determined whether to read the last data from the pipeline is incorrect.
 *
 * 1) When reading with EDC data will be read from the I/O registers and not from the pipeline - This is not a problem, since the pipeline is not necessary.
 * 2) When reading without EDC data will be read both from the I/O registers and from the pipeline casing overwriting the last 2 bytes with 0xff.
 *
 *    Rev 1.28   Oct 10 2001 19:48:02   oris
 * Bug fix - WORD_ADD_FAR macro was misused using casing bad casting to unaligned buffers. Replaced it with read operation to an intermidiate variable and then copy byte after byte.
 *
 *    Rev 1.27   Sep 24 2001 18:24:08   oris
 * Removed warnings.
 * Added support for readBBT call for less then 8 bytes.
 * Removed DOC_PLUS_ACCESS_TYPE ifdef.
 *
 *    Rev 1.26   Sep 15 2001 23:47:20   oris
 * Placed YIELD_CPU definition under ifdef to prevent redeclaration.
 * Changed doc2erase to support up to 64K erase blocks.
 * Added reconstruct flag to readBBT routine - stating whether to reconstruct BBT if it is not available.
 * Changed all memory access routine to DiskOnChip Millennium Plus dedicated routines.
 * Changed recoverFromAccessError and setAsicMode routine to use standard memory access routines and not preInit routines.
 * Bug fix - read\write from uneven address.
 * Bug fix - read full 1k with no EDC.
 * Bug fix - first 4 blocks are not reported correctly by the readBBT()
 * Added debug print when BBT is not read well.
 *
 *    Rev 1.25   Jul 29 2001 19:15:30   oris
 * Changed file calls to macros.
 *
 *    Rev 1.24   Jul 13 2001 01:08:08   oris
 * Bug fix - rewritten VERIFY_WRITE compilation option.
 * Prevent calls to docPlusRead with 0 length.
 * Bug fix - added support for platforms that can not access single bytes.
 * Added PARTIAL_EDC read flag to the read routine.
 * Revised checkErase routine to include extra area.
 * Bug fix - missing check of write protection in doc2erase.
 * Bug fix - read bbt .
 * Insert key before writing IPL since it might be protected with the default protection.
 * Bug fix - set floor to 0 in all OTP calls.
 * Use PARTIAL_EDC in read OTP routine.
 * Added initialization of max erase cycles FLFlash field.
 *
 *    Rev 1.23   Jun 17 2001 16:39:10   oris
 * Improved documentation and remove warnings.
 *
 *    Rev 1.22   Jun 17 2001 08:17:52   oris
 * Bug fix - caused changing to interleave 1 even if already in this mode.
 * Changed NO_READ_BBT_CODE  to MTD_NO_READ_BBT_CODE.
 *
 *    Rev 1.21   May 30 2001 21:16:06   oris
 * Bug fix - pages per blocks might be used uninitialized.
 *
 *    Rev 1.20   May 17 2001 19:21:10   oris
 * Removed warnings.
 *
 *    Rev 1.19   May 16 2001 21:20:34   oris
 * Added failsafe mechanism for the download operation.
 * Changed code variable name to flCode (avoid name clashes).
 * Bug fix - read operation from extra area of second sector of page starting from offset 6 reading more then 2 bytes.
 * Bug fix - write OTP and read OTP routines  - Wrong usage of buffers.
 * Removed warnings.
 * Bug fix - enable power down routine while in MTD_STANDALONE mode.
 *
 *    Rev 1.18   May 09 2001 00:33:12   oris
 * Changed IPL_CODE to NO_IPL_CODE , READ_BBT_CODE to NO_READ_BBT_CODE.
 * Made sure that forceddownload is active when HW_OTP compilation flag is defined.
 * Removed 2 redundant ALE down calls.
 * Change all 2 consequative read operation to for in order to prevent compiler optimizations.
 *
 *    Rev 1.17   May 06 2001 22:41:52   oris
 * Bug fix - checking for access error was moved. After every set address operation and after erase confirm.
 * Bug fix - readBBT for unaligned units.
 * Removed warnings.
 * redundant was misspelled.
 *
 *    Rev 1.16   May 02 2001 07:29:50   oris
 * flInterleaveError was misspelled.
 * Added the BBT_UNAVAIL_UNIT defintion.
 *
 *    Rev 1.15   May 01 2001 14:22:56   oris
 * Bug fix - reading BBT of cascaded device.
 *
 *    Rev 1.14   Apr 30 2001 18:01:54   oris
 * Bug fix - Several ifdef caused exception since MTD buffer was not allocated.
 * Use erasableBlockSizeBits instead of erasableBlockSize when posible.
 * Added EDC check when reading the BBT.
 * Removed warrnings.
 *
 *    Rev 1.13   Apr 24 2001 17:11:14   oris
 * Bug fix - Wrong data when reading 2 bytes from data area.
 * Removed compilation problems when USE_FUNC is defined.
 * Bug fix - read\write operation with the EDC flags ignored the EXTRA flag.
 * Bug fix - ipl and otp routines causes exception in MTD_STANDALONE mode.
 * Rebuild OTP routine.
 *
 *    Rev 1.12   Apr 18 2001 21:24:54   oris
 * Bug fix - bad status code when writting in interleave - 1 fails, because changeInterleave routine is called while in access error.
 * Bug fix - removed download operation after write IPL.
 * Bug fix - Fixed casting problem in flash type identification.
 * Bug fix - Bad status code in doc2erase.
 * Bug fix - OTP area written\ read in interleave - 1
 * Bug fix - bad endian handling in OTP routines.
 * Moved forced download routine from under the MTD_STANDALONE compilation flag.
 * Removed warrnings.
 *
 *    Rev 1.11   Apr 18 2001 11:17:30   oris
 * Bug fix in getUniqueId routine.
 *
 *    Rev 1.10   Apr 18 2001 09:27:38   oris
 * Removed warrnings.
 *
 *    Rev 1.9   Apr 16 2001 21:46:58   oris
 * Bug fix - aliasing mechanism fixed.
 *
 *    Rev 1.8   Apr 16 2001 13:54:34   oris
 * Removed warrnings.
 * Bug fix - uninitialized buffer in read operation from uneven address.
 * Bug fix - report hw protection fault on write and erase operations.
 *
 *    Rev 1.7   Apr 12 2001 06:52:06   oris
 * Added setFloor in chkAsicMode in order to make sure floor does not change.
 * Added powerDown routine and registration.
 * Added download routine registration.
 * Added support for reading and writing uneven address or length.
 * Removed warrnings.
 * Bug fix for memory lick in readBBT.
 * Changed several routines to static.
 *
 *    Rev 1.6   Apr 10 2001 23:55:30   oris
 * Bug fix - in readbbt routine buffer was not incremented correctly.
 *
 *    Rev 1.5   Apr 10 2001 16:43:14   oris
 * Added multiple floor support for readbbt routine.
 * Added call for docSocketInit which initializes the socket routines.
 * Added validity check after flMap call in order to support pccard premoutn routine.
 *
 *    Rev 1.4   Apr 09 2001 19:02:34   oris
 * Removed unused variables.
 * Bug fix on erase operation to more then 1 unit.
 * Comment forced download in device identification routine.
 *
 */

/*********************************************************************/
/*                                                                   */
/*            FAT-FTL Lite Software Development Kit                  */
/*            Copyright (C) M-Systems Ltd. 1995-2001                 */
/*                                                                   */
/*********************************************************************/

/*********************************************************************
 *                                                                   *
 *    DESCRIPTION: basic mtd functions for MDOC32                    *
 *     interleave 1                                                  *
 *    page organization :                                            *
 *      512 bytes data sector 0,                                     *
 *       6 bytes ecc sector 0,                                       *
 *       2 bytes sector 0 flag,                                      *
 *       8 bytes unit data sector 0,                                 *
 *     interleave 2                                                  *
 *    page organization :                                            *
 *      512 bytes data sector 0,                                     *
 *       6 bytes ecc sector 0,                                       *
 *       2 bytes sector 0 flag,                                      *
 *       2 bytes sector 1 flags,                                     *
 *       512 bytes data sector 1 ,                                   *
 *       6 bytes ecc sector 1,                                       *
 *       8 bytes unit data sector 0,                                 *
 *       8 bytes unit data sector 1                                  *
 *                                                                   *
 *    AUTHOR: arie tamam                                             *
 *                                                                   *
 *    HISTORY: created november 14 2000                              *
 *                                                                   *
 *********************************************************************/

/*********************************************************************/
/*              | Physical address of interleave - 2 page            */
/*   Area       -----------------------------------------------------*/
/*              | First Sector       | Second Sector                 */
/*-------------------------------------------------------------------*/
/* Extra:       | 512-519, 1040-1047 | 1034-1039, 520-521, 1048-1055 */
/* Sector data  | 0-511              | 522-1033                      */
/* Sector flags | 518-519            | 520-521                       */
/* Unit data    | 1040-1047          | 1048-1055                     */
/* Edc          | 512-517            | 1034-1039                     */
/*********************************************************************/
/* Note: The address is given as a page offset 0-n where n is the    */
/* number of bytes the area has fo a sector (16 for extra , 2 for    */
/* sector flags, 8 for unit data and 512 for sector data). The       */
/* second sector address is given in a simmilar fation + 512.        */
/* Note: Extra area is exported in the floowing order:               */
/*       sector data , edc , sector flags , unit data.               */
/*********************************************************************/
/* Area A : 0 - 511  |  Area B : 512 - 1023  |  Area C : 1024 - 1055 */
/*********************************************************************/

/*********************************************************************/
/*   Area       | Physical address of interleave - 1 page            */
/*-------------------------------------------------------------------*/
/* Extra:       | 512 - 517 , 518 - 519 , 520 - 527                  */
/* Sector data  | 0   - 511                                          */
/* Edc          | 512 - 517                                          */
/* Sector flags | 518 - 519                                          */
/* Unit data    | 520 - 527                                          */
/*********************************************************************/
/* Note: The address is given as a page offset 0-n where n is the    */
/* number of bytes the area has for a sector (16 for extra , 2 for   */
/* sector flags, 8 for unit data and 512 for sector data).           */
/* Note: Extra area is exported in the floowing order:               */
/*       sector data , edc , sector flags , unit data.               */
/*********************************************************************/
/* Area A : 0 - 255  |  Area B : 256 - 511  |  Area C : 512 - 528    */
/*********************************************************************/

/** include files **/
#include "mdocplus.h"
#include "reedsol.h"
#ifdef HW_PROTECTION
#include "protectp.h"
#endif /* HW_PROTECTION */

/* Yield CPU time in msecs */
#ifndef YIELD_CPU
#define YIELD_CPU 10
#endif /* YIELD_CPU */

/* maximum waiting time in msecs */
#define MAX_WAIT  30

extern NFDC21Vars docMtdVars[SOCKETS];

/* When the MTD is used as a standalone package some of the routine     */
/* are replaced with the following macroes                              */

#ifdef MTD_STANDALONE

#define flReadBackBufferOf(a) &(globalReadBack[a][0])

#define flSocketNoOf(socket) 0 /* currently we support only a single device */

#define flMap(socket,address) addToFarPointer(socket->base, address & (socket->size - 1));
#endif /* MTD_STANDALONE */

#ifndef FL_NO_USE_FUNC

/*----------------------------------------------------------------------*/
/*              c h o o s e D e f a u l t I F _ C F G                   */
/*                                                                      */
/* Choose the default IF_CFG to use before is can actually be detected  */
/*                                                                      */
/* Parameters:                                                          */
/*     busConfig           : Socket access discriptor                   */
/*                                                                      */
/* Returns:                                                             */
/*     Suspected IF_CFG configuration (either 8 or 16).                 */
/*----------------------------------------------------------------------*/
static byte chooseDefaultIF_CFG(dword busConfig)
{
   if(( busConfig & FL_BUS_HAS_8BIT_ACCESS                    )&&
      ((busConfig & FL_XX_ADDR_SHIFT_MASK) == FL_NO_ADDR_SHIFT)  )
   {
      /* Assume if_cfg was set to 0. Interleave is irelevant */
      return 8;
   }
   /* Assume if_cfg was set to 1. Interleave is irelevant */
   return 16;
}

/*----------------------------------------------------------------------*/
/*                  s e t D O C P l u s B u s T y p e                   */
/*                                                                      */
/* Check validity and set the proper memory access routines for MTD.    */
/*                                                                      */
/* Parameters:                                                          */
/*     flash               : Pointer identifying drive                  */
/*     busConfig           : Socket access discriptor                   */
/*     interleave          : Interleave factor (1,2)                    */
/*     if_cfg              : if_cfg state:                              */
/*                              8  - 8 bit                              */
/*                              16 - 16 bit                             */
/*                                                                      */
/* Returns:                                                             */
/*      TRUE if routines are available and fit the DiskOnChip           */
/*      configuration otherwise FALSE.                                  */
/*                                                                      */
/*      The variable pointer to by busConfig is added TrueFFS private   */
/*      MTD descriptors.                                                */
/*----------------------------------------------------------------------*/

static FLBoolean setDOCPlusBusType(FLFlash * flash,
                   dword busConfig,
                   byte interleave,
                   byte if_cfg)
{
   switch(interleave)
   {
      case 1: /* No interleave */
         busConfig |= FL_8BIT_FLASH_ACCESS;
         break;
      case 2: /* 2 flashes are interleaved */
     busConfig |= FL_16BIT_FLASH_ACCESS;
     break;
      default:
         DEBUG_PRINT(("ERROR: No such interleave factor (setDOCPlusBusType).\r\n"));
          return FALSE;
   }

   switch(if_cfg)
   {
      case 8:  /* No interleave */
          busConfig |= FL_8BIT_DOC_ACCESS;
      break;
      case 16: /* 2 flashes are interleaved */
      busConfig |= FL_16BIT_DOC_ACCESS;
      break;
      default:
          DEBUG_PRINT(("ERROR: Invalid if_cfg value (setDOCPlusBusType).\r\n"));
          return FALSE;
   }

   if(setBusTypeOfFlash(flash, busConfig) != flOK)
       return FALSE;
    return TRUE;
}
#endif /* FL_NO_USE_FUNC */

#ifndef NO_EDC_MODE

      /*.*/
      /*            EDC control     */
      /*.*/

/*----------------------------------------------------------------------*/
/*                        e c c E r r o r                               */
/*                                                                      */
/* Check for EDC error.                                                 */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Pointer identifying drive                     */
/*                                                                      */
/* Returns TRUE if an EDC detected an error, otherwise FALSE.           */
/*----------------------------------------------------------------------*/

static FLBoolean  eccError (FLFlash * flash)
{
  register int i;

  for(i=0;( i < 2 ); i++)
    flWrite8bitRegPlus(flash,NNOPreg, 0);

  return ((FLBoolean)flRead8bitRegPlus(flash,NECCcontrol) & ECC_CNTRL_ERROR_MASK);
}

/*----------------------------------------------------------------------*/
/*                        e c c O F F                                   */
/*                                                                      */
/* Disable ECC.                                                         */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Pointer identifying drive                     */
/*                                                                      */
/*----------------------------------------------------------------------*/

#define eccOFF(vol) flWrite8bitRegPlus(vol,NECCcontrol,ECC_CNTRL_IGNORE_MASK)

/*----------------------------------------------------------------------*/
/*                        e c c O N r e a d                             */
/*                                                                      */
/* Enable ECC in read mode and reset it.                                */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Pointer identifying drive                     */
/*                                                                      */
/*----------------------------------------------------------------------*/

#define eccONread(flash) flWrite8bitRegPlus(flash,NECCcontrol,ECC_RESET); flWrite8bitRegPlus(flash,NECCcontrol,ECC_CNTRL_ECC_EN_MASK)

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                        e c c O n w r i t e                           */
/*                                                                      */
/* Enable ECC in write mode and reset it.                               */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Pointer identifying drive                     */
/*                                                                      */
/*----------------------------------------------------------------------*/

#define eccONwrite(flash) flWrite8bitRegPlus(flash,NECCcontrol,ECC_RESET); flWrite8bitRegPlus(flash,NECCcontrol,ECC_CNTRL_ECC_RW_MASK | ECC_CNTRL_ECC_EN_MASK);
#endif  /* FL_READ_ONLY */
#endif  /* NO_EDC_MODE */


        /**/
        /*    Auxiliary methods   */
        /**/

/*----------------------------------------------------------------------*/
/*                        s e l e c t C h i p                           */
/*                                                                      */
/* Write to deviceSelector register.                                    */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*      wp      : FLS_SEL_WP_MASK to write protect the flashes 0 to     */
/*                remove write protection.                              */
/*      dev     : Chip to select.(not used in mdocp).                   */
/*                                                                      */
/* NOTE: write protection signal is common for all of the flash devices.*/
/*----------------------------------------------------------------------*/

#define selectChip(flash, writeProtect) flWrite8bitRegPlus(flash,NflashSelect, writeProtect)

/*----------------------------------------------------------------------*/
/*                        c h k I n t e r l e v e                       */
/*                                                                      */
/* Check the current intelreave mode.                                   */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*                                                                      */
/* Returns: Returns 1 for interleave-1 or 2 interleave-2.               */
/*----------------------------------------------------------------------*/

#define chkInterleave(flash) (byte)(((flRead8bitRegPlus(flash,NconfigInput) & CONFIG_INTLV_MASK) == CONFIG_INTLV_MASK) ? 2 : 1)

/*----------------------------------------------------------------------*/
/*                        c h k I F _ C F G                             */
/*                                                                      */
/* Check the current if_cfg mode (number of active DiskOnChip data bits */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*                                                                      */
/* Returns: Either 8 or 16.                                             */
/*----------------------------------------------------------------------*/

#define chkIF_CFG(flash) (byte)((flRead8bitRegPlus(flash,NconfigInput) & CONFIG_IF_CFG_MASK) ? 16 : 8)

/*----------------------------------------------------------------------*/
/*                         s e t I p l S i z e                          */
/*                                                                      */
/* Open the extended IPL of cascaded DiskOnChip and return previous     */
/* max ID number.                                                       */
/*                                                                      */
/* Note floor 0 resides of offset 0                                     */
/*      floor 1 resides of offset 0x400                                 */
/*      floor 2 resides of offset 0x1800                                */
/*      floor 3 resides of offset 0x1c00                                */
/*                                                                      */
/* Parameters:                                                          */
/*      flash      : Pointer identifying drive                          */
/*      noOfFloors : Number of floors to open                           */
/*                                                                      */
/*                                                                      */
/* Returns: The previous max ID number.                                 */
/*----------------------------------------------------------------------*/

static byte setIplSize(FLFlash * flash, byte noOfFloors)
{
   byte prevMaxId = flRead8bitRegPlus(flash,NconfigInput);
   flWrite8bitRegPlus(flash,NconfigInput,(byte)((prevMaxId & (~CONFIG_MAX_ID_MASK))|((noOfFloors-1)<<4)));
   return (prevMaxId & CONFIG_MAX_ID_MASK);
}

/*----------------------------------------------------------------------*/
/*                    g e t C o n t r o l l e r I D                     */
/*                                                                      */
/* Get the controller (ASIC) indetification byte from offset 0x1000.    */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*                                                                      */
/* Returns: One of the following values.                                */
/*       CHIP_ID_MDOCP - 0x40 - DiskOnChip Millennium Plus 32MB         */
/*       CHIP_ID_MDOCP - 0x41 - DiskOnChip Millennium Plus 16MB         */
/*       other         - Unknown DiskOnChip                             */
/*----------------------------------------------------------------------*/

#define getControllerID(flash) flRead8bitRegPlus(flash,NchipId)

/*----------------------------------------------------------------------*/
/*                             b u s y                                  */
/*                                                                      */
/* Pole the selected flash busy signal.                                 */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Pointer identifying drive                     */
/*                                                                      */
/* Returns TRUE if the flash is busy, otherwise FALSE.                  */
/*----------------------------------------------------------------------*/

#define busy(flash) (((flRead8bitRegPlus(flash,NflashControl) & (Reg8bitType)FLS_FR_B_MASK) == FLS_FR_B_MASK) ? FALSE:TRUE)

/*----------------------------------------------------------------------*/
/*                        w a i t F o r R e a d y                       */
/*                                                                      */
/* Wait until flash device is ready or timeout.                         */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Pointer identifying drive                     */
/* Returns:                                                             */
/*      FALSE if timeout error, otherwise TRUE.                         */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLBoolean  waitForReady (FLFlash * flash)
{
  volatile Reg8bitType junk = 0;
  int i;

  /* before polling for BUSY status perform 4 read operations from
     NNOPreg */
  for(i=0;( i < 4 ); i++ )
    junk += flRead8bitRegPlus(flash,NNOPreg);

  for(i=0;( i < BUSY_DELAY ); i++)
  {
    if( busy(flash) )
    {
      continue;  /* it's not ready */
    }
    return( TRUE );                     /* ready at last.. */
  }

  DEBUG_PRINT(("Debug: timeout error in waitForReady routine.\r\n"));

  /* Restore write proection to reduce power consumption */
  selectChip(flash,MPLUS_SEL_WP);
  return( FALSE );
}

#ifndef MTD_STANDALONE
#ifndef DO_NOT_YIELD_CPU
/*----------------------------------------------------------------------*/
/*              w a i t F o r R e a d y W i t h Y i e l d C P U         */
/*                                                                      */
/* Wait until flash device is ready or timeout.                         */
/* The function yields CPU while it waits till flash is ready           */
/*                                                                      */
/* Parameters:                                                          */
/*  flash : Pointer identifying drive                                   */
/*                                                                      */
/* Returns:                                                             */
/*  FALSE if timeout error, otherwise TRUE.                             */
/*----------------------------------------------------------------------*/

static FLBoolean  waitForReadyWithYieldCPU (FLFlash * flash, word millisecToSleep)
{
   int i;

   for (i=0;  i < (millisecToSleep / YIELD_CPU); i++)
   {
  #ifndef NT5PORT
      flsleep(YIELD_CPU);
    #endif /*NT5PORT*/
      if( busy(flash) )
         continue;
      return( TRUE );                     /* ready at last.. */
   }
   return( FALSE );
}
#endif /* DO_NOT_YIELD_CPU */
#endif /* MTD_STANDALONE */

/*----------------------------------------------------------------------*/
/*                        s e l e c t F l o o r                         */
/*                                                                      */
/* Change the floor according to the given address.                     */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*      address : Address of the new floor                              */
/*                                                                      */
/* Note - global variable NFDC21thisVars->currentFloor is updated       */
/*----------------------------------------------------------------------*/

static void selectFloor (FLFlash * flash, CardAddress address)
{
  if( flash->noOfFloors > 1 )
  {
    NFDC21thisVars->currentFloor = (byte)(address >> NFDC21thisVars->floorSizeBits);
    setFloor(flash,NFDC21thisVars->currentFloor);  /* select ASIC */
  }
}

/*----------------------------------------------------------------------*/
/*                  r e l e a s e P o w e r D o w n                     */
/*                                                                      */
/* Release the controller (ASIC) from power down mode.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*                                                                      */
/* Note - While in power down the registers can not be read or written  */
/*        to.                                                           */
/*----------------------------------------------------------------------*/

void releasePowerDown(FLFlash * flash)
{
  int i;
  volatile Reg8bitType junk = 0;

  /*  perform 3 reads + 1 from 0x1fff */
  for(i = 0;( i < 4 ); i++ )
    junk += flRead8bitRegPlus(flash,NreleasePowerDown);
}

/*----------------------------------------------------------------------*/
/*                  i s A c c e s s E r r o r                           */
/*                                                                      */
/* Check if protection violation had accured.                           */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*                                                                      */
/* Note - While in protection violation state, the registers can not be */
/* read or written to.                                                  */
/*                                                                      */
/* Returns: TRUE on protection violation, otherwise FALSE.              */
/*----------------------------------------------------------------------*/

#define isAccessError(flash) ((flRead8bitRegPlus(flash,NprotectionStatus) & PROTECT_STAT_ACCERR) ? TRUE:FALSE)

/*----------------------------------------------------------------------*/
/*              r e c o v e r A c c e s s E r r o r                     */
/*                                                                      */
/* Recover from protection violation.                                   */
/*                                                                      */
/* Note : DiskOnChip must already be in Normal mode.                    */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*                                                                      */
/* Note : If the device was indeed in access error the routine will     */
/*        force the device into reset mode.                             */
/*                                                                      */
/* Returns: flOK on success, otherwise flHWProtection.                  */
/*----------------------------------------------------------------------*/

static FLStatus recoverFromAccessError(FLFlash * flash)
{
    int i = 0;

    /* Check if there realy is an access error if not return */
    if(isAccessError(flash)==FALSE)
        return flOK;

    /* Folloing is the sequance to remove the protection violation */
    /* Write 0xff to the flash command register                    */
    /* Write twice to the write pipeline termination register      */
    /* Write once to the NOop register                             */

    flWrite8bitRegPlus(flash,NflashCommand,(Reg8bitType)RESET_FLASH);
    for(i = 0; i< 2; i++)
       flWrite8bitRegPlus(flash,NwritePipeTerm,(Reg8bitType)0);
    flWrite8bitRegPlus(flash,NNOPreg,(Reg8bitType)0);

    /* Check if access error was removed */
    if (flRead8bitRegPlus(flash,NprotectionStatus) & PROTECT_STAT_ACCERR)
    {
        DEBUG_PRINT(("Can't recover from protection violation\r\n"));
        return flHWProtection;
    }
    return flOK;
}

/*----------------------------------------------------------------------*/
/*                       s e t A S I C m o d e                          */
/*                                                                      */
/* Set the controller (ASIC) operation mode.                            */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*      mode    : One of the modes below:                               */
/*                 DOC_CNTRL_MODE_RESET    - Reset mode                 */
/*                 DOC_CNTRL_MODE_NORMAL   - Normal mode                */
/*                 DOC_CNTRL_MODE_PWR_DWN  - Power down mode            */
/*                                                                      */
/* Note: The mode is common to all cascaded floors.                     */
/*                                                                      */
/* Returns: flOK on success, otherwise flHWProtection.                  */
/*----------------------------------------------------------------------*/

static FLStatus setASICmode (FLFlash * flash, Reg8bitType mode)
{
   volatile Reg8bitType stat = 0;

   /* Get out of power down mode - just in case */
   releasePowerDown(flash);

   /* Set ASIC state
    * Use default bit values to all bits but the last 2 mode bits
    * ORed with the given mode. The mode is written to the the
    * NDOCcontrol register and its complement to the
    * NDOCcontrolConfirm register
    */

   stat = DOC_CNTRL_DEFAULT | mode;
   flWrite8bitRegPlus(flash,NDOCcontrol,stat); /* the control data */
   flWrite8bitRegPlus(flash,NDOCcontrolConfirm, (Reg8bitType)~stat);  /* confirm */

   if (mode & DOC_CNTRL_MODE_PWR_DWN)
     return flOK;

   /* Read Controller's (ASIC) modes register */
   stat = flRead8bitRegPlus(flash,NDOCcontrol);

   /* Check for power down mode      */
   if (stat & DOC_CNTRL_MODE_NORMAL)
   {
      /* Check for protection violation */
      return recoverFromAccessError(flash);
   }
   return flOK;
}

/*----------------------------------------------------------------------*/
/*                       c h k A S I C m o d e                          */
/*                                                                      */
/* Check the controller (ASIC) mode and change it to normal.            */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*                                                                      */
/* Note: The mode is common to all cascaded floors.                     */
/* Note: This routine is called by each of the MTD exported routine.    */
/*                                                                      */
/* Returns: flOK on success, otherwise flHWProtection.                  */
/*----------------------------------------------------------------------*/

FLStatus chkASICmode (FLFlash * flash)
{
   volatile Reg8bitType stat;
   FLStatus status = flOK;

   stat = flRead8bitRegPlus(flash,NDOCcontrol);

   if ((isAccessError(flash) == TRUE) ||       /* Protection violation   */
       (!(stat & DOC_CNTRL_MODE_NORMAL))) /* already in normal mode */
   {
      status = setASICmode(flash,DOC_CNTRL_MODE_NORMAL);
      setFloor (flash, NFDC21thisVars->currentFloor);
   }
   return status;
}

/*----------------------------------------------------------------------*/
/*                     c h k I P L D o w n l o a d                      */
/*                                                                      */
/* Check if IPL was downloaded without an IPL dwonload error.           */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Pointer identifying drive                     */
/*                                                                      */
/* Returns: TRUE if download was succesfull on both copies.             */
/*----------------------------------------------------------------------*/

#define chkIPLDownload(flash) ((flRead8bitRegPlus(flash, NdownloadStatus) & (DWN_STAT_IPL0 | DWN_STAT_IPL1)) ?  FALSE : TRUE)

/*----------------------------------------------------------------------*/
/*                     c h k A S I C D o w n l o a d                    */
/*                                                                      */
/* Check if DPS and OTP were downloaded without any error from the      */
/* specified floor.                                                     */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Pointer identifying drive                     */
/*      floor           : The floor to check                            */
/*                                                                      */
/* Note - The routine changes the controller (ASIC) mode to normal.     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, flBadDownload on download error */
/*                        and flHWProtection if controller mode could   */
/*                        not be changed.                               */
/*----------------------------------------------------------------------*/

static FLStatus chkASICDownload (FLFlash * flash,byte floorNo)
{
   FLStatus status;
   status = setASICmode(flash, DOC_CNTRL_MODE_NORMAL);
   if(status != flOK)
      return status;
   setFloor(flash,floorNo);
   if(flRead8bitRegPlus(flash,NdownloadStatus) & DWN_STAT_DWLD_ERR)
     return flBadDownload;
   return flOK;
}

/*----------------------------------------------------------------------*/
/*                       p o w e r D o w n                              */
/*                                                                      */
/* Change the device mode to minimal power consumption (but not active) */
/* and back to normal mode.                                             */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Pointer identifying drive                     */
/*      state           : DEEP_POWER_DOWN flag for entering power down  */
/*                        otherwise return to normal mode.              */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise fail.                 */
/*----------------------------------------------------------------------*/

static FLStatus powerDown(FLFlash * flash, word state)
{
   if (state & DEEP_POWER_DOWN)
   {
     return setASICmode (flash, DOC_CNTRL_MODE_PWR_DWN);
   }
   else
   {
     return chkASICmode (flash);
   }
}

#if (defined(HW_PROTECTION) || !defined(NO_IPL_CODE) || defined (HW_OTP))
/*----------------------------------------------------------------------*/
/*                       f o r c e D o w n l o a d                      */
/*                                                                      */
/* Force download of protection mechanism and IPL code.                 */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Pointer identifying drive                     */
/*                                                                      */
/* Note - The routine changes the controller (ASIC) mode to normal.     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, flBadDownload on download error */
/*                        and flHWProtection if controller mode could   */
/*                        not be changed.                               */
/*----------------------------------------------------------------------*/

static FLStatus forceDownLoad(FLFlash * flash)
{
   volatile Reg8bitType val;
   register byte        i;
   dword                counter = 0;
   FLStatus             status;

   /* Prevent assertion of the BUSY# signal */
   for(i=0;i<flash->noOfFloors;i++)
   {
      /* Select floor */
      setFloor(flash,i);
      /* Remove last bit */
      val = flRead8bitRegPlus(flash, NoutputControl) & OUT_CNTRL_BSY_DISABLE_MASK;
      flWrite8bitRegPlus(flash, NoutputControl, val);
   }

   /* Force download */
   flWrite8bitRegPlus(flash, NfoudaryTest, FOUNDRY_WRITE_ENABLE);
   flWrite8bitRegPlus(flash, NfoudaryTest, FOUNDRY_DNLD_MASK);
   flDelayMsecs(100);

   /* Check that the download is really over. The Device does not
      respond while in download state therfore we try to write and
      read to a harmless register 10 times assuming if all 10 times
      are good then the download is over */
   do
   {
      /* Set device to normal mode */
      flWrite8bitRegPlus(flash,NDOCcontrol,DOC_CNTRL_DEFAULT | DOC_CNTRL_MODE_NORMAL);
      flWrite8bitRegPlus(flash,NDOCcontrolConfirm,(byte)(~(DOC_CNTRL_DEFAULT | DOC_CNTRL_MODE_NORMAL)));

      for (i=0; i<10; i++,counter++) /* must get expecetd result 10 times in a row */
      {
        val = (i & 1 ? 0x55 : 0xAA) + i;           /* generate various data for the test pattern */
        flWrite8bitRegPlus(flash,NaliasResolution,(byte)val); /* write the test data                        */
        flWrite8bitRegPlus(flash,NNOPreg,(byte)~val);         /* put the complement on the data bus         */
        if (flRead8bitRegPlus(flash,NaliasResolution) != (byte)val) /* verify test data                     */
           break;                                 /* still downloading so start over            */
       }
   } while ((i < 10) && (counter < DOWNLOAD_BUSY_DELAY)); /* i==10 only when download has completed */

   /* Check for download errors on all floors */
   for (i=0;i<flash->noOfFloors;i++)
   {
     status = chkASICDownload(flash,i);
     if(status != flOK)
       return status;
   }

   return flOK;
}

#endif /* HW_PROTECTION or !NO_IPL_CODE or HW_OTP */

/*----------------------------------------------------------------------*/
/*                      c h e c k T o g g l e                           */
/*                                                                      */
/* Read the toggle bit twice making sure it toggles.                    */
/*                                                                      */
/* Note : This routine assumes that the memory access routines have     */
/* already been initialized by the called routine.                      */
/*                                                                      */
/* Parameters:                                                          */
/*      FLFlash      : Pointer to flash structure.                      */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus: TRUE if the bit toggles verifing that this is indeed  */
/*                a DiskOnChip device, otherwise FALSE.                 */
/*----------------------------------------------------------------------*/

static FLBoolean checkToggle(FLFlash * flash)
{
   volatile Reg8bitType toggle1;
   volatile Reg8bitType toggle2;

   toggle1 = flRead8bitRegPlus(flash,NECCcontrol);
   toggle2 = toggle1 ^ flRead8bitRegPlus(flash,NECCcontrol);

   if( (toggle2 & ECC_CNTRL_TOGGLE_MASK) == 0 )
   {
      return FALSE;
   }
   return TRUE;
}

#ifndef MTD_STANDALONE

/*----------------------------------------------------------------------*/
/*                c h e c k W i n F o r D O C P L U S                   */
/*                                                                      */
/* Send commands to release MDOCP from power down, reset it and set it  */
/* normal mode. Then make sure this is an MDOCP by reading chip ID and  */
/* check the toggle bit.                                                */
/*                                                                      */
/* Parameters:                                                          */
/*      socketNo            : Device number                             */
/*      memWinPtr           : Pointer to DiskOnChip window              */
/*                                                                      */
/* Returns: TRUE if this is an MDOCP, otherwise FALSE.                  */
/*----------------------------------------------------------------------*/

FLBoolean checkWinForDOCPLUS(unsigned socketNo, NDOC2window memWinPtr)
{
   register int i;
   volatile Reg8bitType junk = 0;
   Reg8bitType prevNDOCcontrol, prevNDOCcontrolConfirm;
   FLFlash * flash = flFlashOf(socketNo);

   /* Initialize socket memory access routine */
   flash->win = memWinPtr;

#ifndef FL_NO_USE_FUNC
   if(setDOCPlusBusType(flash, flBusConfig[socketNo] , 1,
      chooseDefaultIF_CFG(flBusConfig[socketNo])) == FALSE)
      return FALSE;
#endif /* FL_NO_USE_FUNC */

   /* release from Power Down Mode                   */
   /*  perform 3 reads from anywhere + 1 from 0x1fff */
   for(i = 0;( i < 4 ); i++ )
     junk += flRead8bitRegPlus(flash,NreleasePowerDown);

   /* Save memory data before writting it */
   prevNDOCcontrol = flRead8bitRegPlus(flash,NDOCcontrol);
   prevNDOCcontrolConfirm = flRead8bitRegPlus(flash,NDOCcontrolConfirm);

   /* set ASIC to RESET MODE */
   junk = DOC_CNTRL_DEFAULT | DOC_CNTRL_MODE_RESET;
   flWrite8bitRegPlus(flash,NDOCcontrol,junk); /* the control data */
   flWrite8bitRegPlus(flash,NDOCcontrolConfirm,(Reg8bitType)~junk);  /* confirm */

   /* set ASIC to NORMAL MODE */
   junk |= DOC_CNTRL_MODE_NORMAL; /* write normal mode */
   flWrite8bitRegPlus(flash,NDOCcontrol,junk); /* the control data */
   flWrite8bitRegPlus(flash,NDOCcontrolConfirm,(Reg8bitType)~junk);  /* confirm */

   /* check if it's MDOCP ID + check the toggle bit */
   junk = getControllerID(flash);
   if((junk == CHIP_ID_MDOCP) || (junk == CHIP_ID_MDOCP16))
   {
#ifndef FL_NO_USE_FUNC
     /* Check if_cfg before checking toggle bit */
     if(setDOCPlusBusType(flash,flBusConfig[socketNo],1,chkIF_CFG(flash)) == FALSE)
     {
        setDOCPlusBusType(flash,flBusConfig[socketNo],1,
                          chooseDefaultIF_CFG(flBusConfig[socketNo]));
     }
     else
#endif /* FL_NO_USE_FUNC */
     {
        if(checkToggle(flash))
           return TRUE;
     }
   }

   /* If this is not a MDOCP return the previous values */
   flWrite8bitRegPlus(flash,NDOCcontrol,prevNDOCcontrol);
   flWrite8bitRegPlus(flash,NDOCcontrolConfirm,prevNDOCcontrolConfirm);
   return FALSE;
}
#endif /* MTD_STANDALONE */

/*----------------------------------------------------------------------*/
/*                f l D o c W i n d o w B a s e A d d r e s s           */
/*                                                                      */
/* Return the host base address of the window.                          */
/* If the window base address is programmable, this routine selects     */
/* where the base address will be programmed to.                        */
/*                                                                      */
/* Parameters:                                                          */
/*      socketNo    :    FLite socket No (0..SOCKETS-1)                 */
/*      lowAddress,                                                     */
/*      highAddress :   host memory range to search for DiskOnChip Plus */
/*                      memory window                                   */
/*                                                                      */
/* Returns:                                                             */
/*      Host physical address of window divided by 4 KB                 */
/*      nextAddress :   The address of the next DiskOnChip.             */
/*----------------------------------------------------------------------*/

static unsigned flDocWindowBaseAddress(byte socketNo, dword lowAddress,
                                dword highAddress, dword *nextAddress)
{
#ifndef NT5PORT

  dword                winSize;
  FLFlash              *flash;
  FLBoolean            stopSearch = FALSE;
  volatile Reg8bitType junk       = 0;

  /* if memory range to search for DiskOnChip window is not specified      */
  /* assume the standard x86 PC architecture where DiskOnChip Plus appears */
  /* in a memory range reserved for BIOS expansions                        */
  if (lowAddress == 0x0L)
  {
    lowAddress  = START_ADR;
    highAddress = STOP_ADR;
  }

  /* Initialize socket memory access routine */
  flash = flFlashOf(socketNo);

#ifndef FL_NO_USE_FUNC
   if(setDOCPlusBusType(flash, flBusConfig[socketNo], 1,
      chooseDefaultIF_CFG(flBusConfig[socketNo])) == FALSE)
      return ( 0 );
#endif /* FL_NO_USE_FUNC */

  winSize = DOC_WIN;

  /* set all possible controllers (ASIC) to RESET MODE */
  for(*nextAddress = lowAddress; *nextAddress <= highAddress;
      *nextAddress += winSize)
  {
     flash->win = (NDOC2window)physicalToPointer(*nextAddress,winSize,socketNo);

     junk = DOC_CNTRL_DEFAULT | DOC_CNTRL_MODE_RESET;
     flWrite8bitRegPlus(flash,NDOCcontrol,junk); /* the control data */
     flWrite8bitRegPlus(flash,NDOCcontrolConfirm,(Reg8bitType)~junk);  /* confirm */
  }

  /* current address initialization */
  for(*nextAddress = lowAddress ; *nextAddress <= highAddress ;
      *nextAddress += winSize)
  {
      flash->win = (NDOC2window)physicalToPointer(*nextAddress,winSize,socketNo);
      /* set controller (ASIC) to NORMAL MODE */
      junk = DOC_CNTRL_DEFAULT | DOC_CNTRL_MODE_NORMAL; /* write normal mode */
      flWrite8bitRegPlus(flash,NDOCcontrol,junk); /* the control data */
      flWrite8bitRegPlus(flash,NDOCcontrolConfirm,(Reg8bitType)~junk);  /* confirm */
      junk = getControllerID(flash);
      if((junk != CHIP_ID_MDOCP) && (junk != CHIP_ID_MDOCP16))
      {
         if( stopSearch == TRUE )  /* DiskOnChip was found */
           break;
         else
           continue;
      }
      if( stopSearch == FALSE )
      {
         /* detect card - identify bit toggles on consequitive reads */
#ifndef FL_NO_USE_FUNC
         /* Check if_cfg before checking toggle bit */
         if(setDOCPlusBusType(flash,flBusConfig[socketNo],1,chkIF_CFG(flash)) == FALSE)
         {
            setDOCPlusBusType(flash,flBusConfig[socketNo], 1,
                              chooseDefaultIF_CFG(flBusConfig[socketNo]));
            continue;
         }
#endif /* FL_NO_USE_FUNC */
         if(checkToggle(flash) == FALSE)
            continue;

         /* DiskOnChip found, mark alias resolution register */
         flWrite8bitRegPlus(flash,NaliasResolution,(Reg8bitType)ALIAS_RESOLUTION);
         stopSearch = TRUE;
         lowAddress = *nextAddress;   /* save DiskOnChip address */
      }
      else  /* DiskOnChip found, continue to skip aliases */
      {
         /* skip Aliases that have the mark */
         if(flRead8bitRegPlus(flash,NaliasResolution) != ALIAS_RESOLUTION)
            break;
      }
  }
  if( stopSearch == FALSE )  /* DiskOnChip  memory window not found */
    return( 0 );

  return((unsigned)(lowAddress >> 12));

#else /*NT5PORT*/
        DEBUG_PRINT(("Tffsport mdocplus.c :flDocWindowBaseAddress(): Before returning baseAddress()\n"));
        return (unsigned)(((ULONG_PTR)pdriveInfo[socketNo].winBase)>> 12);
#endif /*NT5PORT*/

}

/*----------------------------------------------------------------------*/
/*                         s e t A d d r e s s                          */
/*                                                                      */
/* Latch address to selected flash device.                              */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Pointer identifying drive                     */
/*      address         : byte address to latch.                        */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus setAddress (FLFlash * flash, CardAddress address)
{
  /*
   *  bits  0..7     stays as are
   *  bit      8     is thrown away from address
   *  bits 31..9 ->  bits 30..8
   */

  address &= NFDC21thisVars->floorSizeMask;            /* Convert to floor offset        */
  address = address >> (flash->interleaving-1);        /* Convert to interleaved address */
  address = ((address >> 9) << 8)  |  ((byte)address); /* Remove bit 8                   */

  /* Send 3 bytes addres */
  flWrite8bitRegPlus(flash,NflashAddress,(byte)address);
  flWrite8bitRegPlus(flash,NflashAddress,(byte)(address >> 8));
  flWrite8bitRegPlus(flash,NflashAddress,(byte)(address >> 16));

  /* write twice to pipeline termination register */
  flWrite8bitRegPlus(flash,NwritePipeTerm,(Reg8bitType)0);
  flWrite8bitRegPlus(flash,NwritePipeTerm,(Reg8bitType)0);

  if (waitForReady(flash)==FALSE)     /* wait for ready */
    return flTimedOut;

  if (isAccessError(flash) == TRUE)  /* Protection violation   */
  {
    /* Restore write proection to reduce power consumption */
    selectChip(flash,MPLUS_SEL_WP);
    return flHWProtection;
  }
  return flOK;
}

/*----------------------------------------------------------------------*/
/*                        c o m m a n d                                 */
/*                                                                      */
/* Latch command byte to selected flash device.                         */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*      code    : Command to set.                                       */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void command(FLFlash * flash, Reg8bitType flCode)
{
    /* write the command to the flash */
    flWrite8bitRegPlus(flash,NflashCommand,flCode);
    /* write twice to pipline termination register */
    flWrite8bitRegPlus(flash,NwritePipeTerm,flCode);
    flWrite8bitRegPlus(flash,NwritePipeTerm,flCode);
}

/*----------------------------------------------------------------------*/
/*                        r d B u f                                     */
/*                                                                      */
/* Auxiliary routine for reading from flash I\O registers.              */
/* It can be data,status or flash ID.                                   */
/*                                                                      */
/* Note - The read procedure is devided into 3 parts:                   */
/*          1) pipeline initialization.                                 */
/*          2) read data from aliased I\O registers.                    */
/*          3) read the last 2 bytes from the last data read register.  */
/* Note - Only the last 2 bytes are read from the pipeline (not 4).     */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*      buf     : Buffer to read into.                                  */
/*      howmany : Number of bytes to read.                              */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void rdBuf (FLFlash * flash, void FAR1 *buf, word howmany)
{
    volatile Reg16bitType junkWord = 0;
    register int i;
    word length = TFFSMAX(0,(Sword)howmany-2);

    switch(NFDC21thisVars->if_cfg)
    {
       case 16:     /* Host access type is 16 bit */
           switch (flash->interleaving)
           {
              case 1:
                 /* Pineline init */
                 for (i = 0; i < ((howmany == 1) ? 1 : 2); i++)
                    junkWord = flRead16bitRegPlus(flash, NreadPipeInit);
                 /* Read data */
                 if (length > 0) /* Can use only one byte (int1 operation) */
                 {
                    docPlusRead(flash->win,NFDC21thisIO,(byte FAR1 *)buf,length);
                 }
                 /* Before reading the last data perform dummy read cycles */
                 for (i=0; i< ((howmany > 1) ? 0 : 2 ); i++)
                    junkWord = flRead16bitRegPlus(flash, NreadLastData_1);
                 /* Read last data from last data read registers */
                 for (i = length ; i < howmany ; i++)
                    *BYTE_ADD_FAR(buf,i) = flRead8bitRegPlus(flash, NreadLastData_1);
                 break;

              case 2:
                 /* Pineline init */
                 for (i=0; i< ((howmany < 4) ? 1 : 2); i++)
                    junkWord = flRead16bitRegPlus(flash, NreadPipeInit);
                 /* Read data */
                 if (length > 0)
                 {
                    docPlusRead(flash->win,NFDC21thisIO,(byte FAR1 *)buf,length);
                 }
                 /* Before reading the last data perform dummy read cycles */
                 for (i = 0; i < ((howmany > 3) ? 0 : 2) ; i++)
                    junkWord = flRead16bitRegPlus(flash, NreadLastData_1);
                 /* Read last data from last data read registers */
                 for (i = length ; i < howmany ; i += flash->interleaving)
                 {
                    junkWord = flRead16bitRegPlus(flash, NreadLastData_1);
                    *BYTE_ADD_FAR(buf,i)   = ((byte FAR1*)(&junkWord))[0];
                    *BYTE_ADD_FAR(buf,i+1) = ((byte FAR1*)(&junkWord))[1];
                 }
           }
           break;

       case 8:      /* Host access type is 8 bit */
          /* Pineline init */
          for (i=0; i< ((howmany >> (flash->interleaving -1)) ==1 ?1:2); i++)
            junkWord += flRead8bitRegPlus(flash, NreadPipeInit);
          /* Read data */
          if (length > 0)
             docPlusRead(flash->win,NFDC21thisIO,(byte FAR1 *)buf,length);
          /* Before reading the last data perform dummy read cycles */
          for (i=0; ( i < ((howmany >> (flash->interleaving -1)) > 1 ?
               0 : ((flash->interleaving == 2) ? 4:2)));i++)
             junkWord = flRead8bitRegPlus(flash, NreadLastData_1);
          /* Read last data from last data read registers */
          for (i=length ; i< howmany ; i++)
          {
             *BYTE_ADD_FAR(buf,i) = flRead8bitRegPlus(flash, NreadLastData_1);
          }
          break;
     }
}

/*----------------------------------------------------------------------*/
/*                        r d B u f S                                   */
/*                                                                      */
/* Auxiliary routine for reading from flash I\O registers.              */
/* This routine is the pipeline initialization of the full rdBuf func'. */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*      howmany : Number of bytes to read.                              */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void rdBufS (FLFlash * flash, word howmany)
{
    volatile Reg16bitType junkWord = 0;
    register int i;

    switch(NFDC21thisVars->if_cfg)
    {
       case 16:     /* Host access type is 16 bit */
          /* Pineline init */
          for (i=0; i< ((howmany >> (flash->interleaving -1)) ==1 ?1:2); i++)
            junkWord = flRead16bitRegPlus(flash, NreadPipeInit);
          break;

       case 8:      /* Host access type is 8 bit */
          /* Pineline init */
          for (i=0; i< ((howmany >> (flash->interleaving -1)) ==1 ?1:2); i++)
            junkWord += flRead8bitRegPlus(flash, NreadPipeInit);
          break;
    }
}


/*----------------------------------------------------------------------*/
/*                        r e a d C o m m a n d                         */
/*                                                                      */
/* Issue read command.                                                  */
/*                                                                      */
/* Note - The routine also checks that the controller is in normal mode */
/* , latches the address and waits for the ready signal.                */
/*                                                                      */
/* Parametes:                                                           */
/*      flash   : Pointer identifying drive                             */
/*      cmd     : Command to issue (AREA_A, AREA_B or AREA_C).          */
/*      addr    : address to read from.                                 */
/*                                                                      */
/* Returns: flOK on success, flTimedOut or flHWProtection on failures.  */
/*----------------------------------------------------------------------*/

static FLStatus readCommand (FLFlash * flash, CardAddress addr, Reg8bitType cmd)
{
  FLStatus status;

  selectFloor(flash,addr);
  /* Check mode of ASIC and set to NORMAL.*/
  status = chkASICmode(flash);
  if(status != flOK)
    return status;
  /* Select the device and remove flash write protection */
  selectChip(flash,MPLUS_SEL_CE|MPLUS_SEL_WP);
  /* Move flash pointer to respective area of the page */
  command (flash, cmd);
  /* Latche the address */
  status = setAddress (flash, addr);
  if(status != flOK)
    return status;

  /* ALE down */
  flWrite8bitRegPlus(flash,NflashControl, 0x0);
  /* Write twice to NOP */
  flWrite8bitRegPlus(flash,NNOPreg, 0x0);
  flWrite8bitRegPlus(flash,NNOPreg, 0x0);

  return flOK;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                        r e a d S t a t u s                           */
/*                                                                      */
/* Read status of selected flash device.                                */
/*                                                                      */
/* Note - The status indicated success of write and erase operations.   */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*                                                                      */
/* Returns: TRUE for failed status, FALSE for success.                  */
/*----------------------------------------------------------------------*/

static FLBoolean readStatus (FLFlash * flash)
{
  word  status;

  /* send command to read status */
  command(flash,READ_STATUS);

  rdBuf(flash, &status,2);

  return ((status & 1) ? TRUE:FALSE);
}

/*----------------------------------------------------------------------*/
/*                        w r i t e C o m m a n d                       */
/*                                                                      */
/* Issue write command.                                                 */
/*                                                                      */
/* Note - The routine also checks that the controller is in normal mode */
/* , latches the address and waits for the ready signal.                */
/*                                                                      */
/* Parametes:                                                           */
/*      flash   : Pointer identifying drive                             */
/*      cmd     : Command to issue (AREA_A, AREA_B or AREA_C).          */
/*      addr    : address to read from.                                 */
/*                                                                      */
/* Returns: flOK on success, flTimedOut or flHWProtection on failures.  */
/*----------------------------------------------------------------------*/

static FLStatus writeCommand (FLFlash * flash, CardAddress addr, Reg8bitType cmd)
{
  FLStatus status;

  selectFloor(flash,addr);
  /* Check mode of ASIC and set to NORMAL.*/
  status = chkASICmode(flash);
  if(status != flOK)
    return status;

  /* Select the device and remove flash write protection */
  selectChip(flash,MPLUS_SEL_CE);
  /* Prepare flash for write operation */
  command (flash, RESET_FLASH);   /* Reset flash */
  if (waitForReady(flash)==FALSE)   /* always wait after flash reset */
    return flTimedOut;

  /* Move flash pointer to respective area of the page */
  flWrite8bitRegPlus(flash,NflashCommand, (Reg8bitType)cmd); /* page area */
  command (flash,SERIAL_DATA_INPUT);        /* data input stream type */
  /* Latche the address */
  return setAddress(flash, addr);    /* set page pointer       */
}

/*----------------------------------------------------------------------*/
/*                        w r i t e E x e c u t e                       */
/*                                                                      */
/* Execute write.                                                       */
/*                                                                      */
/* Parametes:                                                           */
/*      flash   : Pointer identifying drive                             */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed.               */
/*----------------------------------------------------------------------*/

static FLStatus writeExecute (FLFlash * flash)
{
  /* Pipe termination to preceeding write cycle */

  flWrite8bitRegPlus(flash,NwritePipeTerm,(byte)0);
  flWrite8bitRegPlus(flash,NwritePipeTerm,(byte)0);
  command (flash, SETUP_WRITE);             /* execute page program */
  if (waitForReady(flash)==FALSE)   /* wait for ready signal */
    return flTimedOut;

  if( readStatus(flash) )
  {
    DEBUG_PRINT(("Debug: NFDC MDOCP write failed.\r\n"));
    return( flWriteFault );
  }
  selectChip(flash,MPLUS_SEL_WP);
  return( flOK );
}

#ifndef NO_EDC_MODE
/*----------------------------------------------------------------------*/
/*                  w r i t e D a t a P l u s E D C                     */
/*                                                                      */
/* Write 512 bytes data with edc                                        */
/*                                                                      */
/* Parameters:                                                          */
/*   flash          : Pointer identifying drive                         */
/*   buffer         : Pointer to user buffer to write from              */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void writeDataPlusEDC(FLFlash * flash, const byte FAR1 *buffer)
{
   register int i;
   static byte  syndrom[SYNDROM_BYTES];

   eccONwrite(flash); /* ECC ON for write    */

   docPlusWrite(flash->win,NFDC21thisIO, (byte FAR1 *)buffer, SECTOR_SIZE); /* user data */

   /* clock data thru pipeline prior reading ECC syndrome*/
   for(i=0; i<3; i++)
      flWrite8bitRegPlus(flash,NNOPreg, 0);

   /* read the syndrom bits */

   if (NFDC21thisVars->if_cfg == 8)
   {
      for(i=0; i<SYNDROM_BYTES; i++)
        syndrom[i] = flRead8bitRegPlus(flash,(word)(Nsyndrom+i));
   }
   else
   {
      for(i=0; i<SYNDROM_BYTES; i+=2)
         *(word *)(syndrom + i) = flRead16bitRegPlus(flash,(word)(Nsyndrom+i));
   }

#ifdef D2TST
   tffscpy(saveSyndromForDumping,syndrom,SYNDROM_BYTES);
#endif
   eccOFF(flash);                           /* ECC OFF  */

   docPlusWrite(flash->win,NFDC21thisIO,(byte FAR1 *)syndrom,SYNDROM_BYTES);
}
#endif /* NO_EDC_MODE */
#endif /* FL_READ_ONLY */

#ifndef NO_EDC_MODE
/*----------------------------------------------------------------------*/
/*                  r e a d D a t a P l u s E D C                       */
/*                                                                      */
/* Read 512 bytes data with edc                                         */
/*                                                                      */
/* Parameters:                                                          */
/*   flash          : Pointer identifying drive                         */
/*   buffer         : Pointer to user buffer to read into               */
/*   length         : Length to read                                    */
/*   modes          : With or without second try option                 */
/*   address        : Address to read from                              */
/*   cmd            : Area command to read from                         */
/*   endhere        : Flag indicating if more bytes are needed from     */
/*                    this page. Importent for last byte read operation */
/*                                                                      */
/* Return: flOK on success, otherwise flDataError.                      */
/*----------------------------------------------------------------------*/

static FLStatus readDataPlusEDC(FLFlash * flash, const byte FAR1 *buffer,
                word length, word modes, CardAddress address,
                byte cmd,FLBoolean endHere)
{
  byte          syndrom[SYNDROM_BYTES];
  word          unreadBytes = SECTOR_SIZE - length;
  volatile word tmp;
  FLStatus      status;
#ifdef LOG_FILE
  FILE *out;
#endif /* LOG_FILE */

  /* To avoid page fault, read first and last bytes of the page */
  if (length > 0)
  {
     ((byte FAR1 *)buffer)[0]        = 0;
     ((byte FAR1 *)buffer)[length-1] = 0;
  }

  /* activate ecc mechanism */
  eccONread(flash);

  /* read the sector data */
  docPlusRead(flash->win,NFDC21thisIO, (byte FAR1 *)buffer, length);


  /* read syndrom to let it through the ECC unit */
  if ((NFDC21thisVars->if_cfg == 16) && (flash->interleaving == 2))
  {
     /* Partial page read with EDC must let rest of page through
        the HW edc mechanism */

     for (;unreadBytes > 0;unreadBytes -=2)
     {
        tmp = flRead16bitRegPlus(flash, NFDC21thisIO);
     }

     /* read syndrom using 16 bits access */

     for (tmp=0; tmp<SYNDROM_BYTES-2; tmp+=2)               /* read the 4 syndrome */
        *(word *)(syndrom+tmp) = flRead16bitRegPlus(flash, NFDC21thisIO);   /* bytes & store them  */

     /* If this is the last data read from this page read the last 2 bytes
        from a dedicated register otherwise from NFDC IO register */
     *(word *)(syndrom + SYNDROM_BYTES - 2) = (endHere == TRUE) ?
           flRead16bitRegPlus(flash, NreadLastData_1):
           flRead16bitRegPlus(flash, NFDC21thisIO);
  }
  else
  {
     /* Partial page read with EDC must let rest of page through
        the HW edc mechanism */

     for (;unreadBytes > 0;unreadBytes--)
     {
        tmp = flRead8bitRegPlus(flash, NFDC21thisIO);
     }

     /* read syndrom using 8 bits access */

     for (tmp=0; tmp<SYNDROM_BYTES-2; tmp++)               /* read the 4 syndrome */
        syndrom[tmp] = flRead8bitRegPlus(flash, NFDC21thisIO);   /* bytes & store them  */

     /* If this is the last data read from this page read the last 2 bytes
        from a dedicated register */

     for (tmp=SYNDROM_BYTES-2;tmp<SYNDROM_BYTES;tmp++)
       syndrom[tmp] = flRead8bitRegPlus(flash, (word)(((endHere == TRUE) ?
                        NreadLastData_1 : NFDC21thisIO)));
  }

  if( eccError(flash) )
  {     /* try to fix ECC error */
#ifdef LOG_FILE
      out=FL_FOPEN("EDCerr.txt","a");
      FL_FPRINTF(out,"error on address %lx\n",address);
      FL_FCLOSE(out);
#endif /* LOG_FILE */
      if ( modes & NO_SECOND_TRY )             /* 2nd try */
      {
#ifdef LOG_FILE
         out=FL_FOPEN("EDCerr.txt","a");
         FL_FPRINTF(out,"second read failed as well on address %lx",address);
#endif /* LOG_FILE */

        if (NFDC21thisVars->if_cfg != 16)
        {
           /* read syndrom using 8 bits access */

           for(modes=0; modes<SYNDROM_BYTES; modes++)
              syndrom[modes] = flRead8bitRegPlus(flash,(word)(Nsyndrom+modes));
        }
        else
        {
           /* read syndrom using 16 bits access */

           for(modes=0; modes<SYNDROM_BYTES; modes+=2)
              *(word *)(syndrom + modes) = flRead16bitRegPlus(flash,(word)(Nsyndrom+modes));
        }

        tmp        = (word)syndrom[0]; /* Swap 1 and 3 words */
        syndrom[0] = syndrom[4];
        syndrom[4] = (byte)tmp;
        tmp        = (word)syndrom[1];
        syndrom[1] = syndrom[5];
        syndrom[5] = (byte)tmp;

        if(flCheckAndFixEDC((char FAR1 *)buffer,(char*)syndrom, 1) !=
                            NO_EDC_ERROR)
        {
#ifdef LOG_FILE
            FL_FPRINTF(out," Could not be fixed\n");
            FL_FCLOSE(out);
#endif /* LOG_FILE */
           DEBUG_PRINT(("Debug: EDC error for NFDC MDOCP.\r\n"));
           return flDataError;
        }
#ifdef LOG_FILE
        FL_FPRINTF(out," But is was fixed\n");
        FL_FCLOSE(out);
#endif /* LOG_FILE */
      }
      else                                  /* 1st try - try once more */
      {
        status = readCommand(flash, address, cmd);
        if(status != flOK)
          return status;
        rdBufS(flash, SECTOR_SIZE);
        return readDataPlusEDC(flash,buffer,length,(word)(modes | NO_SECOND_TRY),address,cmd,endHere);
      }
  }
  eccOFF(flash);
  return flOK;
}

#endif /* NO_EDC_MODE */

/*----------------------------------------------------------------------*/
/*                        s e t E x t r a P t r                         */
/*                                                                      */
/* Calculate the physical address and page offset according to the      */
/* logical address given with an EXTRA mode flag                        */
/*                                                                      */
/* Parameters:                                                          */
/*              flash   : Pointer identifying drive                     */
/*              offset  : Logical page offset given to the MTD          */
/*              length  : Size to write\read (migh have implication)    */
/*                                                                      */
/* Return:                                                              */
/*              cmd     : Returns the page area.                        */
/*              offset  : Physical offset of the page.                  */
/*----------------------------------------------------------------------*/
/*****************************************************************************/
/* 0-5   |     6-7       |   518-519     |512-517|    8-15     |   520-527   */
/*****************************************************************************/
/* 0-2   |      3        |      4        |  5-7  |    8-11     |      12-15  */
/* edc 0 | sector flag 0 | sector flag 1 | edc 1 | unit data 0 | unit data 1 */
/*****************************************************************************/
/*            AREA_B                     |               AREA_C              */
/*****************************************************************************/

static void setExtraPtr(FLFlash * flash, word * offset, dword length,
                        Reg8bitType * cmd)
{
   *cmd = AREA_C;
   if (*offset >= SECTOR_SIZE)  /* Second sector */
   {
      *offset &= SECTOR_SIZE_MASK; /* sector offset */
      if (*offset < EDC_PLUS_SECTOR_FLAGS )       /* not unit data */
      {
         if ((*offset >= EDC_SIZE) ||        /* start after edc area */
             (*offset + length > EDC_SIZE))  /* or with sector flags */
         {
            *offset = SECOND_SECTOR_FLAGS_OFFSET; /* sector flags    */
            *cmd = AREA_B;
         }
         else /* Only edc of second sector */
         {
            *offset += END_OF_SECOND_SECTOR_DATA; /* area c + 10 */
         }
      }
      else  /* unit data */
      {
         *offset += UNIT_DATA_OFFSET; /* after first sector unit data (area c) */
      }
   }
   else                         /* First sector */
   {
      if (flash->interleaving==2) /* otherwise do not change offset */
      {
         if (*offset < EDC_PLUS_SECTOR_FLAGS)      /* not unit data */
         {
            *cmd = AREA_B;    /* start from edc */
         } /* if it is unit data keep offset as is in area c */
         else
         {
            *offset += UNIT_DATA_OFFSET_MINUS_8; /* minus current offset */
         }
      }
   }
}

/*----------------------------------------------------------------------*/
/*                s e t S e c t o r D a t a P t r                       */
/*                                                                      */
/* Calculate the physical area and offset according to the logical      */
/* address given when no area mode flags was given (sector data area).  */
/*                                                                      */
/* Parameters:                                                          */
/*          flash    : Pointer identifying drive                        */
/*          offset   : Logical offset send to the MTD                   */
/*          markFlag : True if the sector flags need to be addressed    */
/*                                                                      */
/* Return:                                                              */
/*          cmd      : Returns the page area.                           */
/*          offset   : Physical offset of the page.                     */
/*----------------------------------------------------------------------*/
static void setSectorDataPtr(FLFlash * flash,word * offset,Reg8bitType * cmd,
                 FLBoolean markFlag)
{
    if (*offset >= SECTOR_SIZE) /* second sector */
    {
       if ((markFlag)&&(*offset == SECTOR_SIZE)) /* write operation */
       {
          *offset = SECOND_SECTOR_FLAGS_OFFSET; /* Write sector flags first */
          *cmd = AREA_B;
          return;
       }
       else
       {
          *offset += START_OF_SECOND_SECTOR_DATA; /* Start from actual data */
       }
    }
    if (*offset < NFDC21thisVars->pageAreaSize)
    {
       *cmd = AREA_A;
    }
    else if (*offset < flash->pageSize)
    {
       *cmd = AREA_B;
    }
    else
    {
       *cmd = AREA_C;
    }
    *offset &= (NFDC21thisVars->pageAreaSize-1);
}

/*----------------------------------------------------------------------*/
/*                    r e a d E x t r a A r e a                         */
/*                                                                      */
/* Read from the extra area.                                            */
/*                                                                      */
/* Note - Only the last 2 bytes are read from the pipeline (not 4).     */
/*                                                                      */
/* Parameters:                                                          */
/*          flash    : Pointer identifying drive                        */
/*          address  : Physical flash address                           */
/*          buffer   : Buffer to write from                             */
/*          length   : Size to write                                    */
/*                                                                      */
/* Return:                                                              */
/*      FLStatus        : 0 on success, otherwise failed.               */
/*----------------------------------------------------------------------*/

static FLStatus readExtraArea  (FLFlash * flash, dword address,
                void FAR1 *buffer, dword length)
{
   FLStatus status;
   word     offset = (word)(address & NFDC21thisVars->pageMask);
   word     savedOffset = (word)(offset & (SECTOR_SIZE-1));
   word     readNow;
   byte     cmd;

   /* Arg check */
   if (length + savedOffset > 16)
      return flBadLength;

   /* Calculate page offset and address */
   setExtraPtr(flash, &offset, length , &cmd);
   address = (address & ~NFDC21thisVars->pageMask) + offset;

   /* Set flash to write mode and pointer to repective page ofset */
   status = readCommand(flash, address, cmd);
   if(status != flOK)
     return status;

   if (flash->interleaving == 1)
   {
       readNow = (word)TFFSMIN((word)(TOTAL_EXTRA_AREA - savedOffset), length);
       rdBuf (flash, buffer, readNow);
       length -= readNow;
   }
   else
   {
      if (cmd == AREA_C) /* unit data / second sector edc */
      {
         if (offset >= EDC_PLUS_SECTOR_FLAGS) /* either sectors unit data */
         {
            readNow = (word)TFFSMIN((word)(TOTAL_EXTRA_AREA - savedOffset), length);
         }
         else /* only edc data (already verified in setExtraAreaPtr */
         {
            readNow = (word)TFFSMIN((word)(EDC_SIZE - savedOffset), length);
         }
         rdBuf (flash, buffer, readNow);
         length -= readNow;
      }
      else  /* first sector edc / both sectors sector flags */
      {
         if (offset < EDC_PLUS_SECTOR_FLAGS) /* start from first sector */
         {
            readNow = (word)TFFSMIN((word)(EDC_PLUS_SECTOR_FLAGS - savedOffset), length);
            rdBuf (flash, buffer, readNow);
            length -= readNow;
            if (length > 0)  /* continue to sector unit data area */
            {
                return readExtraArea(flash,address - offset +
                                     EDC_PLUS_SECTOR_FLAGS,
                                     addToFarPointer(buffer,readNow),length);
            }
         }
         else /* Start form sector flags of second sector */
         {
            /* Switch sector flags to be compatible with interleave 2 */

            rdBuf (flash, BYTE_ADD_FAR(buffer,EDC_SIZE - savedOffset), SECTOR_FLAG_SIZE);
            length -= SECTOR_FLAG_SIZE;

            if (length > 0) /* continue with edc data of second sector */
            {
               readNow = (EDC_SIZE - savedOffset);
               address = address - offset + savedOffset + SECTOR_SIZE;
               if (readNow > 0)
               {
                  status = readExtraArea(flash,address,buffer,readNow);
                  if(status != flOK)
                     return status;
                  length -= readNow;
               }
               if (length > 0) /* continue with unit data of second sector */
               {
                  readNow = (word)TFFSMIN(UNIT_DATA_SIZE, length);
                  return readExtraArea(flash,address - savedOffset +
                            UNIT_DATA_SIZE,addToFarPointer(buffer,
                            EDC_PLUS_SECTOR_FLAGS - savedOffset),readNow);
               }
            }
         }
      }
   }
   selectChip(flash,MPLUS_SEL_WP);
   return flOK;
}

/*----------------------------------------------------------------------*/
/*                    r e a d S e c t o r D a t a                       */
/*                                                                      */
/* Read sector data from the page.                                      */
/*                                                                      */
/* Parameters:                                                          */
/*          flash    : Pointer identifying drive                        */
/*          address  : Physical flash address                           */
/*          buffer   : Buffer to write from                             */
/*          length   : Size to write                                    */
/*          edc      : EDC to add edc after data and write sector flags */
/*                                                                      */
/* Note: Sector flags area written automaticly as 0x55 , 0x55.          */
/* Note: Sector flags are written only if edc is on.                    */
/*                                                                      */
/* Note - Only the last 2 bytes are read from the pipeline (not 4).     */
/*                                                                      */
/* Return:                                                              */
/*      FLStatus        : 0 on success, otherwise failed.               */
/*----------------------------------------------------------------------*/
static FLStatus readSectorData(FLFlash * flash, CardAddress address,
                       byte FAR1 *buffer, dword length, word modes)
{
   word     offset      = (word)(address & NFDC21thisVars->pageMask);
   word     savedOffset = offset;
   word     lenInPage   = (word)TFFSMIN(length, (dword)(flash->pageSize - savedOffset));
   word     readNow     = 0; /* Initialized to remove warrnings */
   byte     cmd;
   FLStatus status;
   register int i;

  /******************************************************/
  /* Loop over pages while reading the proper area data */
  /******************************************************/

  setSectorDataPtr(flash,&offset , &cmd,0);
  address = (address & ~NFDC21thisVars->pageMask) + offset;
  while (length > 0)
  {
     /* Set flash to write mode and pointer to repective page offset */
     status = readCommand(flash, address, cmd);
     if(status != flOK)
        return status;

     /* Calculate the bytes neaded to be read from this page */
     length -= lenInPage;

     /* Send read pipeline init */
     rdBufS(flash, lenInPage);

      /* Read First sector of page */

     if ((cmd == AREA_A) || (flash->interleaving == 1))
     {
        readNow = (word)TFFSMIN((word)(SECTOR_SIZE - savedOffset), lenInPage);

        /* EDC and sector flags 0x5555 are written only if EDC is required.
         * and a full 512 bytes area written */

#ifndef NO_EDC_MODE
        if ( /* Full 512 bytes + EDC requested */
            ((readNow == SECTOR_SIZE) && (modes & EDC))  ||
             /* Partial page with EDC requested */
            ((modes   == PARTIAL_EDC) && (savedOffset == 0)))
        {
           status = readDataPlusEDC(flash,buffer,readNow,modes,address,
                       cmd,(lenInPage == readNow) ? TRUE:FALSE);
           if(status != flOK)
              return status;
        }
        else
#endif /* NO_EDC_MODE */
        {
           /* user data (the last 2 bytes are read from a diffrent register */
           word realyReadNow = (word)((lenInPage == readNow) ?
                                      (readNow - 2) : readNow);

           docPlusRead(flash->win,NFDC21thisIO,buffer,realyReadNow);
        }
        lenInPage -= readNow;
     }

      /* Read Second sector of page */

     if ((lenInPage > 0)&&(flash->interleaving==2))
     {
        if (cmd == AREA_A)  /* Started from first sector */
        {
           byte tmpBuf[10];
#ifndef NO_EDC_MODE
           if ((readNow != SECTOR_SIZE) || /* not Full 512 bytes  */
               !(modes & EDC))             /* or EDC not requesed */
#endif /* NO_EDC_MODE */
           {
              docPlusRead(flash->win,NFDC21thisIO,tmpBuf, EDC_SIZE); /* skip edc and sector flags */
           }
           docPlusRead(flash->win,NFDC21thisIO,tmpBuf, SECTOR_FLAG_SIZE<<1); /* skip 2 sector flags  */
           buffer      = BYTE_ADD_FAR(buffer,readNow);
           savedOffset = SECTOR_SIZE;
           address    += (readNow+START_OF_SECOND_SECTOR_DATA);
           cmd         = AREA_B;
        }
        readNow = lenInPage;
#ifndef NO_EDC_MODE
        if ( /* Full 512 bytes + EDC requested */
            ((readNow == SECTOR_SIZE)     && (modes & EDC)) ||
             /* Partial page with EDC requested */
            ((savedOffset == SECTOR_SIZE) && (modes & PARTIAL_EDC)) )

        {
           status = readDataPlusEDC(flash,buffer,readNow,modes,address,
                       cmd,(lenInPage == readNow) ? TRUE:FALSE);
           if(status != flOK)
              return status;
        }
        else
#endif /* NO_EDC_MODE */
        {
           /* user data (the last 2 bytes are read from a diffrent register */
           docPlusRead(flash->win,NFDC21thisIO,buffer, (word)((lenInPage == readNow) ?
                       (readNow - 2) : readNow));
        }
     }

#ifndef NO_EDC_MODE
     /* If no EDC, Read last data from dedicated register */
     if (((modes & EDC) == 0)      ||      /* EDC not requesed      */
         ((readNow != SECTOR_SIZE) &&      /* not Full 512 bytes       */
          ((modes   & PARTIAL_EDC) == 0))) /* And not PARTIAL page EDC */
#endif /* NO_EDC_MODE */
     {
        if ((NFDC21thisVars->if_cfg == 16) && (flash->interleaving == 2))
        {
           volatile Reg16bitType junkWord;

           /* Before reading the last data perform dummy read cycles */
           for (i=0; i< ((readNow >> (flash->interleaving -1)) > 1 ?0:2); i++)
              offset = flRead16bitRegPlus(flash, NreadLastData_1); /* junk */
           /* Now read the data from the last data read register make
              sure not to cast pointer to word since it might not be
              word aligned */
           junkWord = flRead16bitRegPlus(flash, NreadLastData_1);
           *BYTE_ADD_FAR(buffer,readNow-2) = ((byte FAR1*)(&junkWord))[0];
           *BYTE_ADD_FAR(buffer,readNow-1) = ((byte FAR1*)(&junkWord))[1];
        }
        else
        {
           /* Before reading the last data perform dummy read cycles */
           for (i=0; ( i < ((readNow >> (flash->interleaving -1)) > 1 ?
               0 : ((flash->interleaving == 2) ? 4:2)));i++)
              cmd = flRead8bitRegPlus(flash, NreadLastData_1); /* junk */
           /* Now read the data from the last data read register */
           for (i=2;i>0;i--)
           {
              *BYTE_ADD_FAR(buffer,readNow-i) = flRead8bitRegPlus(flash, NreadLastData_1);
           }
        }
     }

     /* Calculate next address and page offset */
     if (length > 0)
     {
        buffer = BYTE_ADD_FAR(buffer,readNow);
        address = (address & (~NFDC21thisVars->pageMask)) + flash->pageSize;
        lenInPage = (word)TFFSMIN(length,flash->pageSize);
        savedOffset = 0;
        cmd = AREA_A;
     }
     selectChip(flash,MPLUS_SEL_WP);
  }
  return flOK;
}

/*----------------------------------------------------------------------*/
/*                       d o c 2 R e a d                                */
/*                                                                      */
/* Read some data from the flash. This routine will be registered as    */
/* the read routine for this MTD.                                       */
/*                                                                      */
/* Note - address + length must reside inside media.                    */
/* Note - global variables changed:                                     */
/*    global variable NFDC21thisVars->currentFloor is updated           */
/*    flash->socket.window.currentPage = pageToMap;                     */
/*    flash->socket.remapped = TRUE;                                    */
/*                                                                      */
/* Note - PARTIAL_EDC mode must not be called with an uneven number of  */
/*        bytes.                                                        */
/*                                                                      */
/* Parameters:                                                          */
/*    flash     : Pointer identifying drive                             */
/*    address   : Address of sector to write to.                        */
/*    buffer    : buffer to write from.                                 */
/*    length    : number of bytes to write.                             */
/*    modes     : EDC / EXTRA flags.                                    */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, otherwise failed.                     */
/*----------------------------------------------------------------------*/

static FLStatus doc2Read(FLFlash * flash, CardAddress address,
                         void FAR1 *buffer, dword length, word modes)
{
  FLStatus status;
  byte     align[2];

#ifdef ENVIRONMENT_VARS
  if((flSuspendMode & FL_SUSPEND_IO) == FL_SUSPEND_IO)
     return flIOCommandBlocked;
#endif /* ENVIRONMENT_VARS */

  if (address & 1) /* Start from uneven address */
  {
     status = doc2Read(flash,address-1,align,2,0);
     if(status != flOK)
        return status;

     *(byte FAR1*)buffer = align[1];
     buffer = BYTE_ADD_FAR(buffer,1);
     address++;
     length--;
  }

  if (length & 1) /* Read an uneven length */
  {
     length--;
     status = doc2Read(flash,address+length,align,2,modes);
     if(status != flOK)
        return status;

     *BYTE_ADD_FAR(buffer,length) = align[0];
  }

  if(modes & EXTRA) /* EXTRA AREA */
  {
     return readExtraArea(flash,address, buffer , length);
  }
  else
  {
     return readSectorData(flash,address, (byte FAR1 *)buffer, length , modes);
  }
}

#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                    w r i t e E x t r a A r e a                       */
/*                                                                      */
/* Write to the extra area.                                             */
/*                                                                      */
/* Parameters:                                                          */
/*          flash    : Pointer identifying drive                        */
/*          address  : Physical flash address                           */
/*          buffer   : Buffer to write from                             */
/*          length   : Size to write                                    */
/*                                                                      */
/* Return:                                                              */
/*      FLStatus        : 0 on success, otherwise failed.               */
/*----------------------------------------------------------------------*/

static FLStatus writeExtraArea  (FLFlash * flash, dword address,
                 const void FAR1 *buffer, dword length)
{
   word     offset      = (word)(address & NFDC21thisVars->pageMask);
   word     savedOffset = (word)(offset & (SECTOR_SIZE-1));
   word     writeNow    = 0;
   FLStatus status;
   byte     sectorFlags [2];
   byte     cmd;

   /* Calculate page offset */
   setExtraPtr(flash, &offset, length , &cmd);
   address = (address & ~NFDC21thisVars->pageMask) + offset;
   /* Set flash to write mode and pointer to repective page ofset */
   status = writeCommand(flash, address, cmd);
   if(status != flOK)
      return status;

   if (flash->interleaving == 1)
   {
       writeNow = (word)TFFSMIN((byte)(TOTAL_EXTRA_AREA - savedOffset), length);
       docPlusWrite(flash->win,NFDC21thisIO, (byte FAR1 *)buffer, writeNow);
       length -= writeNow;
   }
   else
   {
      if (cmd == AREA_C) /* unit data / second sector edc */
      {
         if (offset >= EDC_PLUS_SECTOR_FLAGS) /* either sectors unit data */
         {
            writeNow = (word)TFFSMIN((byte)(TOTAL_EXTRA_AREA - savedOffset), length);
         }
         else /* only edc data (already verified in setExtraAreaPtr */
         {
            writeNow = (word)TFFSMIN((byte)(EDC_PLUS_SECTOR_FLAGS - savedOffset), length);
         }
         docPlusWrite(flash->win,NFDC21thisIO, (byte FAR1 *)buffer, writeNow);
         length -= writeNow;
      }
      else  /* first sector edc + both sectors sector flags */
      {
         if (offset < EDC_PLUS_SECTOR_FLAGS)
         {
            /* start from first sector edc and sector flags */
            writeNow = (word)TFFSMIN((byte)(EDC_PLUS_SECTOR_FLAGS - savedOffset), length);
            docPlusWrite(flash->win,NFDC21thisIO, (byte FAR1 *)buffer, writeNow);
            length -= writeNow;
            if (length > 0)  /* continue to sector unit data area */
            {
               buffer = addToFarPointer(buffer,writeNow);
               /* skip second sector to reach the unit data area */
               docPlusSet(flash->win,NFDC21thisIO,SECTOR_SIZE+EDC_PLUS_SECTOR_FLAGS,0xff);
               /* unit data */
               writeNow = (word)TFFSMIN(UNIT_DATA_SIZE , length);
               docPlusWrite(flash->win,NFDC21thisIO, (byte FAR1 *)buffer, writeNow);
               length -= writeNow;
            }
         }
         else /* Start form sector flags of second sector */
         {
            /* Switch sector flags to be compatible with interleave 2 */
            sectorFlags[0] = *BYTE_ADD_FAR(buffer,6 - savedOffset);
            sectorFlags[1] = *BYTE_ADD_FAR(buffer,7 - savedOffset);
#ifndef NT5PORT
            docPlusWrite(flash->win,NFDC21thisIO, (byte FAR1 *)&sectorFlags, SECTOR_FLAG_SIZE);
#else /*NT5PORT*/
            docPlusWrite(flash->win,NFDC21thisIO, sectorFlags, SECTOR_FLAG_SIZE);
#endif /*NT5PORT*/
            length -= SECTOR_FLAG_SIZE;

            if (length > 0) /* continue with edc data of second sector */
            {
               docPlusSet (flash->win,NFDC21thisIO, (word)(SECTOR_SIZE + savedOffset), 0xff); /* skip second sector data */
                 /* + offset in edc         */
               writeNow = EDC_SIZE - savedOffset;
               docPlusWrite(flash->win, NFDC21thisIO, (byte FAR1 *)buffer, writeNow);
               length -= writeNow;
               if (length > 0) /* continue with unit data of second sector */
               {
                  buffer = addToFarPointer(buffer,writeNow+SECTOR_FLAG_SIZE);
                  docPlusSet (flash->win, NFDC21thisIO, UNIT_DATA_SIZE, 0xff); /* skip second sector unit data */
                  writeNow = (word)TFFSMIN(UNIT_DATA_SIZE, length);
                  docPlusWrite(flash->win,NFDC21thisIO, (byte FAR1 *)buffer, writeNow);
                  length -= writeNow;
               }
            }
         }
      }
   }
   /* Exit nicly */
   if (length > 0 )
   {
      return flBadLength;
   }
   else     /* Commit data to flash */
   {
      return writeExecute (flash);
   }
}

/*----------------------------------------------------------------------*/
/*                    w r i t e S e c t o r D a t a                     */
/*                                                                      */
/* Write sector data of the page.                                       */
/*                                                                      */
/* Parameters:                                                          */
/*          flash    : Pointer identifying drive                        */
/*          address  : Physical flash address                           */
/*          buffer   : Buffer to write from                             */
/*          length   : Size to write                                    */
/*          edc      : EDC to add edc after data and write sector flags */
/*                                                                      */
/* Return:                                                              */
/*      FLStatus        : 0 on success, otherwise failed.               */
/*----------------------------------------------------------------------*/

static FLStatus writeSectorData(FLFlash * flash, CardAddress address,
                const byte FAR1 *buffer, dword length,
                unsigned edc)
{
   static byte anandMark[2] = { 0x55, 0x55 };
   FLStatus    status;
   word        offset       = (word)(address & NFDC21thisVars->pageMask);
   word        savedOffset  = offset;
   word        writeNow     = 0;    /* Initialized to remove warrnings */
   byte        cmd;

  /*******************************************************/
  /* Loop over pages while writting the proper area data */
  /*******************************************************/

  setSectorDataPtr(flash,&offset , &cmd, ((edc & EDC) &&
                       (length >= SECTOR_SIZE)) ? TRUE:FALSE);
  address = (address & ~NFDC21thisVars->pageMask) + offset;

  while (length > 0)
  {
     /* Set flash to write mode and pointer to repective page ofset */
     status = writeCommand(flash, address, cmd);
     if(status != flOK)
        return status;

     /* Write First sector of page */

     if ((cmd == AREA_A)||(flash->interleaving==1))
     {
        writeNow = (word)TFFSMIN((word)(SECTOR_SIZE - savedOffset), length);
        length -= writeNow;

        /* EDC and sector flags 0x5555 are written only if EDC is required.
         * and a full 512 bytes area written */
#ifndef NO_EDC_MODE
        if ((writeNow == SECTOR_SIZE) && /* Full 512 bytes      */
            (edc == EDC))               /* And EDC is requesed */
        {
           writeDataPlusEDC(flash,buffer);
           docPlusWrite(flash->win,NFDC21thisIO, (byte FAR1 *)anandMark, sizeof(anandMark)); /* sector used */
        }
        else
#endif /* NO_EDC_MODE */
        {
           docPlusWrite(flash->win,NFDC21thisIO, (byte FAR1 *)buffer, writeNow);            /* user data */
        }
     }

     /* Write Second sector of page */

     if ((length > 0)&&(flash->interleaving==2))
     {
        /* Skip to begining of sector */

        if (cmd == AREA_A)  /* Started from first sector */
        {
#ifndef NO_EDC_MODE
           if ((writeNow != SECTOR_SIZE) || /* not Full 512 bytes  */
               (edc != EDC))                /* or EDC not requesed */
#endif /* NO_EDC_MODE */
           {
              docPlusSet (flash->win, NFDC21thisIO, EDC_PLUS_SECTOR_FLAGS, 0xff); /* skip edc and sector flags */
           }
           buffer = BYTE_ADD_FAR(buffer,writeNow);
           savedOffset = SECTOR_SIZE;
        }

        /* Read sector data */

        writeNow = (word)TFFSMIN((word)(flash->pageSize - savedOffset) , length);
#ifndef NO_EDC_MODE
        if ((writeNow == SECTOR_SIZE) && /* Full 512 bytes      */
            (edc == EDC))               /* And EDC is requesed */
        {
           docPlusWrite(flash->win,NFDC21thisIO, (byte FAR1 *)anandMark, sizeof(anandMark)); /* sector used */
           writeDataPlusEDC(flash,buffer);
        }
        else
#endif /* NO_EDC_MODE */
        {
           if ((savedOffset == SECTOR_SIZE)&&(cmd==AREA_A))
              docPlusSet(flash->win, NFDC21thisIO,sizeof(anandMark),0xff);  /* Skip sector flags */
           docPlusWrite(flash->win,NFDC21thisIO, (byte FAR1 *)buffer, writeNow);         /* user data */
        }
        length -= writeNow;
     }
     /* Incremeant buffer and address */
     buffer      = BYTE_ADD_FAR(buffer,writeNow);
     address     = (address & (~NFDC21thisVars->pageMask)) + flash->pageSize;
     savedOffset = 0;
     cmd         = AREA_A;
     /* Commit operation */
     status = writeExecute(flash);
     if(status != flOK)
        return status;
  }
  return flOK;
}

/*----------------------------------------------------------------------*/
/*                  d o c 2 W r i t e                                   */
/*                                                                      */
/* Write some data to the flash. This routine will be registered as the */
/* write routine for this MTD.                                          */
/*                                                                      */
/* Note - address + length must reside inside media.                    */
/* Note - global variables changed:                                     */
/*    global variable NFDC21thisVars->currentFloor is updated           */
/*    flash->socket.window.currentPage = pageToMap;                     */
/*    flash->socket.remapped = TRUE;                                    */
/*                                                                      */
/* Parameters:                                                          */
/*    flash     : Pointer identifying drive                             */
/*    address   : Address of sector to write to.                        */
/*    buffer    : buffer to write from.                                 */
/*    length    : number of bytes to write.                             */
/*    modes     : EDC flags.                                            */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, otherwise failed.                     */
/*----------------------------------------------------------------------*/

static FLStatus doc2Write(FLFlash * flash, CardAddress address,
                          const void FAR1 *buffer, dword length, word modes)
{
  FLStatus status;
  byte align[2];

#ifdef ENVIRONMENT_VARS
  if(flSuspendMode & FL_SUSPEND_WRITE)
     return flIOCommandBlocked;
#endif /* ENVIRONMENT_VARS */

#ifndef MTD_STANDALONE
  /* Check if socket is software write protected */
  if (flWriteProtected(flash->socket))
    return( flWriteProtect );
#endif /* MTD_STANDALONE */

  if (address & 1) /* Start from uneven address */
  {
     align[1] = *(byte FAR1*)buffer;
     align[0] = 0xff;
#ifdef VERIFY_WRITE
     if (modes & EXTRA) /* EXTRA AREA */
     {
        status = writeExtraArea(flash,address-1, align , 2);
     }
     else
     {
        status = writeSectorData(flash,address-1,
                                (const byte FAR1 *)align,2,modes);
     }
     if(status != flOK)
     {
        /* Restore flash write protection */
        selectChip(flash,MPLUS_SEL_WP); /* write protect all chips */
     }
     checkStatus(doc2Read(flash,address-1,align,2,modes));

     if(align[1] != *(byte FAR1*)buffer)
     {
        DEBUG_PRINT(("reading back data failure of first unaligned byte\r\n"));
        return flWriteFault;
     }
#else
     checkStatus(doc2Write(flash,address-1,align,2,modes));
#endif /* VERIFY_WRITE */
     buffer = BYTE_ADD_FAR(buffer,1);
     address++;
     length--;
  }
  if (length & 1) /* Write an uneven length */
  {
     length--;
     align[0] = *BYTE_ADD_FAR(buffer,length);
     align[1] = 0xff;
#ifdef VERIFY_WRITE
     if (modes & EXTRA) /* EXTRA AREA */
     {
        status = writeExtraArea(flash,address+length, align , 2);
     }
     else
     {
        status = writeSectorData(flash,address+length,
                                (const byte FAR1 *)align,2,modes);
     }
     if(status != flOK)
     {
        /* Restore flash write protection */
        selectChip(flash,MPLUS_SEL_WP); /* write protect all chips */
     }
     checkStatus(doc2Read(flash,address+length,align,2,modes));
     if(align[0] != *BYTE_ADD_FAR(buffer,length))
     {
        DEBUG_PRINT(("reading back data failure of last unaligned byte\r\n"));
        return flWriteFault;
     }
#else
     checkStatus(doc2Write(flash,address+length,align,2,modes));
#endif /* VERIFY_WRITE */
  }

  if (modes & EXTRA) /* EXTRA AREA */
  {
     status = writeExtraArea(flash,address, buffer , length);
  }
  else
  {
     status = writeSectorData(flash,address, (const byte FAR1 *)buffer, length , modes);
  }

  /* Restore flash write protection */
  selectChip(flash,MPLUS_SEL_WP); /* write protect all chips */

#ifdef VERIFY_WRITE

  /* Read back after write and verify */

  if(
#ifndef MTD_STANDALONE
     (flash->socket->verifyWrite==FL_ON) &&
#endif /* MTD_STANDALONE */
     (status==flOK) )
  {
     word curRead = 0;
     void FAR1* bufPtr = (void FAR1*)buffer;
     for (;length > 0;length -= curRead,
          bufPtr = BYTE_ADD_FAR(bufPtr,curRead),address+=curRead)
     {
        curRead = (word)TFFSMIN(length , READ_BACK_BUFFER_SIZE);
        status = doc2Read(flash,address,NFDC21thisVars->readBackBuffer,curRead,modes);
        if ((status != flOK) ||
            (tffscmp(bufPtr,NFDC21thisVars->readBackBuffer,curRead)))
        {
            DEBUG_PRINT(("reading back data failure\r\n"));
            return flWriteFault;
        }
     }
  }
#endif /* VERIFY_WRITE */
  return status;
}

#ifdef VERIFY_ERASE

/*----------------------------------------------------------------------*/
/*                        c h e c k E r a s e                           */
/*                                                                      */
/* Check if media is truly erased (main areas of page only).            */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*      address : Address of page to check.                             */
/*                                                                      */
/* Note - global variables changed at doc2Read:                         */
/*      global variable NFDC21thisVars->currentFloor is updated         */
/*      flash->socket.window.currentPage = pageToMap;                   */
/*      flash->socket.remapped = TRUE;                                  */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 if page is erased, otherwise writeFault.    */
/*----------------------------------------------------------------------*/

static FLStatus checkErase( FLFlash * flash, CardAddress address)
{
  register int i, j;
  word inc = READ_BACK_BUFFER_SIZE;
  dword * bufPtr = (dword *)NFDC21thisVars->readBackBuffer;
  CardAddress curAddress = address;
  word block = (word)(flash->erasableBlockSize / inc);
  dword * endBufPtr = bufPtr+(inc / sizeof(dword));
  dword * curBufPtr;

  /* Check main area */
  for ( i = 0 ; i < block ; i++, curAddress += inc )
  {
    if ( doc2Read(flash,curAddress,(void FAR1 *)bufPtr,(dword)inc,0) != flOK )
      return( flWriteFault );

    for ( curBufPtr = bufPtr ;
          curBufPtr < endBufPtr ; curBufPtr++)
      if ( *bufPtr != 0xFFFFFFFFL )
        return( flWriteFault );
  }

  /* Check extra area */
  for ( i = 0 ; i < NFDC21thisVars->pagesPerBlock ; i++)
  {
    if ( doc2Read(flash,address,(void FAR1 *)bufPtr,
                  NFDC21thisVars->tailSize, EXTRA) !=  flOK )
      return( flWriteFault );

    for (j=0;j<(NFDC21thisVars->tailSize>>2);j++)
    {
       if (bufPtr[j] != 0xFFFFFFFFL)
         return( flWriteFault );
    }
  }

  return( flOK );
}

#endif /* VERIFY_ERASE */

/*----------------------------------------------------------------------*/
/*                        d o c 2 E r a s e                             */
/*                                                                      */
/* Erase number of blocks. This routine will be registered as the       */
/* erase routine for this MTD.                                          */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Pointer identifying drive                     */
/*      blockNo         : First block to erase.                         */
/*      blocksToErase   : Number of blocks to erase.                    */
/*                                                                      */
/* Note - The amount of blocks to erase must be inside media.           */
/* Note - global variables changed at checkErase:                       */
/*      global variable NFDC21thisVars->currentFloor is updated         */
/*      flash->socket.window.currentPage = pageToMap                    */
/*      flash->socket.remapped = TRUE                                   */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus                : 0 on success, otherwise failed.       */
/*----------------------------------------------------------------------*/

static FLStatus doc2Erase(FLFlash * flash, word blockNo, word blocksToErase)
{
  CardAddress  startAddress = (CardAddress)blockNo * flash->erasableBlockSize;
  FLStatus     status;
  dword        pageNo;
  byte         floorToUse = (byte)(startAddress / NFDC21thisVars->floorSize);
  dword        i;
  word         nextFloorBlockNo = (word) (((floorToUse + 1) *
               NFDC21thisVars->floorSize) / flash->erasableBlockSize);

#ifdef ENVIRONMENT_VARS
  if(flSuspendMode & FL_SUSPEND_WRITE)
     return flIOCommandBlocked;
#endif /* ENVIRONMENT_VARS */

#ifndef MTD_STANDALONE
  if (flWriteProtected(flash->socket))
    return( flWriteProtect );
#endif /* MTD_STANDALONE */

  /* Arg check (out of media) */
  if( blockNo + blocksToErase > NFDC21thisVars->noOfBlocks * flash->noOfChips)
    return( flWriteFault );

  /* First erase higher floors units */
  if( blockNo + blocksToErase > nextFloorBlockNo )
  {           /* erase on higher floors */
    status = doc2Erase(flash, nextFloorBlockNo,(word)(blocksToErase -
                       (nextFloorBlockNo - blockNo)));
    if(status != flOK)
       return status;

    blocksToErase = nextFloorBlockNo - blockNo;
  }

  /* Selet Floor */
  selectFloor(flash,startAddress);

  pageNo = ((dword)(blockNo % (4096 >> flash->interleaving)) * NFDC21thisVars->pagesPerBlock);

  for (i = 0; (word)i < blocksToErase ; i++, pageNo+=NFDC21thisVars->pagesPerBlock)
  {
     /* Make sure Asic is in normal mode */
     status = chkASICmode(flash);
     if(status != flOK)
        return status;

     /* Select chip and remove write protection */
     selectChip(flash,MPLUS_SEL_CE);

     command (flash,RESET_FLASH);      /* reset flashes         */
     if (waitForReady(flash)==FALSE)   /* wait for ready signal */
        return flTimedOut;

     /* enable EDGE or LEVEL MDOC+ interrupt before the erase command */
#ifdef ENABLE_EDGE_INTERRUPT
     /* enable interrupt: EDGE, clear previous interrupt, FREADY source */
     flWrite8bitRegPlus(flash,NinterruptControl ,
                   (INTR_EDGE_MASK | INTR_IRQ_P_MASK | INTR_IRQ_F_MASK | 0x1));
#else
#ifdef ENABLE_LEVEL_INTERRUPT
     /* enable interrupt: LEVEL, clear previous interrupt, FREADY source */
     flWrite8bitRegPlus(flash,NinterruptControl ,
                   (INTR_IRQ_P_MASK | INTR_IRQ_F_MASK | 0x1));
#endif /* ENABLE_LEVEL_INTERRUPT */
#endif /* ENABLE_EDGE_INTERRUPT */

     command (flash,SETUP_ERASE);      /* send erase command    */

     /* Set address */

     flWrite8bitRegPlus(flash,NflashAddress,(Reg8bitType)(pageNo));
     flWrite8bitRegPlus(flash,NflashAddress,(Reg8bitType)(pageNo >> 8));

     flWrite8bitRegPlus(flash,NwritePipeTerm,(Reg8bitType)0);
     flWrite8bitRegPlus(flash,NwritePipeTerm,(Reg8bitType)0);

     /* send the confirm erase command */
     command(flash, CONFIRM_ERASE);
#ifndef MTD_STANDALONE
#ifndef DO_NOT_YIELD_CPU
     if(waitForReadyWithYieldCPU(flash,MAX_WAIT)==FALSE)
#endif /* DO_NOT_YIELD_CPU */
#endif /* MTD_STANDALONE */
     {
        if (waitForReady(flash)==FALSE)   /* wait for ready signal */
          return flTimedOut;
     }

     if(isAccessError(flash))
     {
        /* Restore write proection to reduce power consumption */
        selectChip(flash,MPLUS_SEL_WP);
        return flHWProtection;
     }

     /* Validate erase command status */
     if ( readStatus(flash)  ) /* erase operation failed */
     {
        DEBUG_PRINT(("Debug: doc2Erase - erase failed.\r\n"));
        /* reset flash device write protect them and abort */
        command(flash, RESET_FLASH);
        if (waitForReady(flash)==FALSE)   /* wait for ready signal */
           return flTimedOut;
        selectChip(flash,MPLUS_SEL_WP);
        return flWriteFault;
     }

     /* no failure reported */
#ifdef VERIFY_ERASE
     if ( checkErase( flash, startAddress ) != flOK )
     {
        DEBUG_PRINT(("Debug: doc2Erase- erase failed in verification.\r\n"));
        return flWriteFault ;
     }
#else
     /* Restore write proection */
     selectChip(flash,MPLUS_SEL_WP);
#endif  /* VERIFY_ERASE */
  }
  return flOK;
}
#endif   /* FL_READ_ONLY */

#ifndef MTD_STANDALONE
/*----------------------------------------------------------------------*/
/*                        d o c 2 M a p                                 */
/*                                                                      */
/* Map through buffer. This routine will be registered as the map       */
/* routine for this MTD.                                                */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*      address : Flash address to be mapped.                           */
/*      length  : number of bytes to map.                               */
/*                                                                      */
/* Note - Size must not be greater then 512 bytes                       */
/*                                                                      */
/* Returns:                                                             */
/*      Pointer to the buffer data was mapped to.                       */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void FAR0 *doc2Map ( FLFlash * flash, CardAddress address, int length )
{
  doc2Read(flash,address,NFDC21thisBuffer,length, 0);
  /* Force remapping of internal catched sector */
  flash->socket->remapped = TRUE;
  return( (void FAR0 *)NFDC21thisBuffer );
}
#endif /* MTD_STANDALONE */

#ifdef MTD_READ_BBT

/*----------------------------------------------------------------------*/
/*                           R e a d B B T                              */
/*                                                                      */
/*  Read the media Bad Blocks Table to a user buffer.                   */
/*                                                                      */
/*  Parameters:                                                         */
/*  flash       : Pointer identifying drive                             */
/*  unitNo      : indicated which unit number to start checking from.   */
/*  unitToRead  : indicating how many units to check                    */
/*  buffer      : buffer to read into.                                  */
/*  reconstruct : Ignored, irelevant for DiskOnChip Millennium Plus     */
/*                                                                      */
/*  Note: blocks is a minimal flash erasable area.                      */
/*  Note: unit can contain several blocks.                              */
/*  Note: There is no current implementation of a unit that contains    */
/*        more then a single block.                                     */
/*  Note: The format of the BBT is byte per unit 0 for bad any other    */
/*        value for good.                                               */
/*  Note: global variables changed at doc2Read:                         */
/*      global variable NFDC21thisVars->currentFloor is updated         */
/*      flash->socket.window.currentPage = pageToMap;                   */
/*      flash->socket.remapped = TRUE;                                  */
/*  Note: At least 4 bytes must be read                                 */
/*                                                                      */
/*  RETURNS:                                                            */
/*     flOK on success                                                  */
/*     flBadLength if one of the units is out of the units range        */
/*     flBadBBT on read fault                                           */
/*----------------------------------------------------------------------*/
/* BBT format (in interleave-1)                                         */
/* ----------                                                           */
/* Offset 512 of the floor holds the BBT of the entire floor in the     */
/* following format:                                                    */
/*                 (even district)   (odd  district)                    */
/* byte 0 bit 0,1     block 0           block 1024                      */
/*        bit 2,3     block 1           block 1025                      */
/*        bit 4,5     block 2           block 1026                      */
/*        bit 6,7     block 3           block 1027                      */
/* byte 1 bit 0,1     block 4           block 1028                      */
/*        bit 2,3     block 5           block 1029                      */
/*        bit 4,5     block 6           block 1030                      */
/*        bit 6,7     block 7           block 1031                      */
/* and so on. The data is protected by EDC.                             */
/*----------------------------------------------------------------------*/

static FLStatus readBBT(FLFlash * flash, dword unitNo, dword unitsToRead,
                        byte blockMultiplier, byte FAR1 * buffer,
                        FLBoolean reconstruct)
{
   register    Sword i;
   FLStatus    status;
   byte        tmp;
   dword       addr;
   Sdword      bufPtr = unitsToRead - 1; /* Point to last byte of user buffer */
   word        bytesPerFloor;
   byte        firstBlocks;
   byte        smallBBT[8];
   dword       start;
   dword       last;
   word        length;
   byte  FAR1* tmpBuffer;
   CardAddress floorInc;                  /* floor address incrementor */
   word        actualRead;
   dword       alignAddr;
   word        curRead;    /* Number of bytes to read from this floor BBT */
   /* Interleave-2 has 2 block entries for each combined block. This variable */
   /* is used to shift the bbt size. 0 for int-1 1 for int-2                  */
   dword       shift = (flash->interleaving - 1);

   /* Arg sanity check */
   if ((((unitNo + unitsToRead) << blockMultiplier) <<
       flash->erasableBlockSizeBits) > (flash->noOfChips * flash->chipSize))
     return flBadParameter;  /* Too many blocks  */

   if (unitsToRead == 0)     /* No blocks at all */
      return flOK;

   if(unitsToRead < 8) /* Algorithm does not fit */
   {
      status = readBBT(flash,unitNo,8,blockMultiplier,smallBBT,FALSE);
      tffscpy(buffer,smallBBT,unitsToRead);
      return status;
   }

#ifndef MTD_STANDALONE
   /* Force remapping of internal catched sector */
   flash->socket->remapped = TRUE;
#endif /* MTD_STANDALONE */

   bytesPerFloor = (word)(NFDC21thisVars->floorSize >>
                          flash->erasableBlockSizeBits) >>
                         ((flash->mediaType == MDOCP_TYPE) ? 1 : 2);

   if(blockMultiplier == 0) /* 2 blocks per byte */
   {
      /* Calculate the first and last bytes of BBT to read. There area 4
         interleave-1 blocks per byte, so interleave-2 has 4 blocks per 2
         bytes */

      start     = ((unitNo >> 2)<<shift);                     /* in bytes  */
      last      = (((unitNo+unitsToRead-1) >> 2)<<shift);     /* in bytes  */
      length    = (word)(last - start + flash->interleaving); /* in bytes  */
      tmpBuffer = buffer;                     /* bbt buffer pointer        */

      for (floorInc = (start / bytesPerFloor) * NFDC21thisVars->floorSize +
           BBT_MEDIA_OFFSET, last = (dword) length,
           start = start % bytesPerFloor; last > 0 ;
           floorInc += NFDC21thisVars->floorSize)
      {
         curRead   = (word)TFFSMIN(bytesPerFloor - start,last);
         last     -= curRead;       /* bytes left to read */
         alignAddr = (start >> SECTOR_SIZE_BITS)<<SECTOR_SIZE_BITS;

         /* Not in Millennium plus but there might be 1024 BBT bytes
            per floor */

         for ( ;curRead > 0 ; alignAddr+=SECTOR_SIZE,start = 0)
         {
            if (doc2Read(flash,alignAddr + floorInc, NFDC21thisBuffer,
                SECTOR_SIZE , EDC) != flOK)
            {
               DEBUG_PRINT(("Debug: Error reading DiskOnChip Millennium Plus BBT.\r\n"));
               return flBadBBT;
            }
            actualRead = (word)TFFSMIN((word)(SECTOR_SIZE - start),curRead);
            tffscpy(tmpBuffer,NFDC21thisBuffer + start, actualRead);
            tmpBuffer = BYTE_ADD_FAR(tmpBuffer,actualRead); /* increament buffer */
            curRead  -= actualRead;
         }
      }

      /* Convert last byte if only some of the blocks represented by it
         are needed and if it is not the only byte read */

      /* Save first the first byte - 1 for int-1 2 for int-2 */
      if(shift)
      {
         firstBlocks = buffer[0] & buffer[1];
         /* Convert last 2 bytes */
         tmp = (*BYTE_ADD_FAR(buffer,length-1)) & /* lower lane   */
               (*BYTE_ADD_FAR(buffer,length-2));  /* higher lane  */
      }
      else
      {
         firstBlocks = buffer[0];
         /* Convert last bytes */
         tmp = *BYTE_ADD_FAR(buffer,length-1);
      }

      switch ((unitNo+unitsToRead) & 3)  /* Last block number byte offset */
      {
         case 3:
            *BYTE_ADD_FAR(buffer,bufPtr) = tmp | 0xCF;
            bufPtr--;
         case 2:
            *BYTE_ADD_FAR(buffer,bufPtr) = tmp | 0xF3;
            bufPtr--;
         case 1:
            *BYTE_ADD_FAR(buffer,bufPtr) = tmp | 0xFC;
            bufPtr--;
            length -= 2; /* Point to last bbt byte */
         default:
            break;
      }

      /* Convert all aligned blocks */
      while (bufPtr > flash->interleaving)
      {
        if(shift)
        {
           tmp = (*BYTE_ADD_FAR(buffer,length-1)) & /* lower lane  */
                 (*BYTE_ADD_FAR(buffer,length-2));  /* higher lane */
        }
        else
        {
           tmp = *BYTE_ADD_FAR(buffer,length-1);
        }
        *BYTE_ADD_FAR(buffer,bufPtr  ) = tmp | 0x3f;
        *BYTE_ADD_FAR(buffer,bufPtr-1) = tmp | 0xcf;
        *BYTE_ADD_FAR(buffer,bufPtr-2) = tmp | 0xf3;
        *BYTE_ADD_FAR(buffer,bufPtr-3) = tmp | 0xfc;
        bufPtr -= 4;
        length -= flash->interleaving;
      }

      /* Convert first unaligned blocks (0,1,2) */
      bufPtr=0;
      switch(unitNo & 3)
      {
         case 1:
            *BYTE_ADD_FAR(buffer,bufPtr) = firstBlocks | 0xF3;
            bufPtr++;
         case 2:
            *BYTE_ADD_FAR(buffer,bufPtr) = firstBlocks | 0xCF;
            bufPtr++;
         case 3:
            *BYTE_ADD_FAR(buffer,bufPtr) = firstBlocks | 0x3F;
         default:
            break;
      }

      /* Mark all bad blocks with 0 */
      for (bufPtr=0;bufPtr<(Sdword)unitsToRead;bufPtr++)
      {
         if (*BYTE_ADD_FAR(buffer,bufPtr) != BBT_GOOD_UNIT)
         {
            *BYTE_ADD_FAR(buffer,bufPtr) = 0;
         }
      }

      /* Add OTP and 2 DPS for all floors */
      for (tmp=0,addr=0;tmp<flash->noOfFloors;tmp++,addr=tmp<<10)
      {
         for (i=0;i<((shift) ? 3 : 5);i++) /* reserved units */
           if ((addr+i >= unitNo)&&(addr+i <= unitNo+unitsToRead))
              *BYTE_ADD_FAR(buffer,addr+i-unitNo) = BBT_UNAVAIL_UNIT;
      }
   }
   else /* several blocks per unit */
   {
      return flBadBBT;
   }
   return flOK;
}
#endif /* MTD_READ_BBT */

/*----------------------------------------------------------------------*/
/*                   c h a n g e I n t e r l e a v e                    */
/*                                                                      */
/* Change to new interleave mode.                                       */
/*                                                                      */
/* Note : DiskOnChip Millennium Plus 16MB always reports flOK           */
/*                                                                      */
/* Parameters:                                                          */
/*      flash    : Pointer identifying drive.                           */
/*      interNum : New interleave factor.                               */
/*                                                                      */
/* Note - Devices that were HW configured to interleave 1 can not       */
/*        change to interleave - 2.                                     */
/* Note - Global variables changed:                                     */
/*    flash->interleaving                                               */
/*    NFDC21thisVars->pageAreaSize                                      */
/*    flash->pageSize                                                   */
/*    NFDC21thisVars->tailSize                                          */
/*    NFDC21thisVars->pageMask                                          */
/*    flash->erasableBlockSize                                          */
/*    NFDC21thisVars->noOfBlocks                                        */
/*                                                                      */
/* Returns:                                                             */
/*      flOK on success, otherwise flInterlreavError.                   */
/*----------------------------------------------------------------------*/

FLStatus    changeInterleave(FLFlash * flash, byte interNum)
{
    Reg8bitType prevInterleaveReg;

    if(setDOCPlusBusType(flash,flBusConfig[flSocketNoOf(flash->socket)],
                         interNum,NFDC21thisVars->if_cfg) == FALSE)
        return flGeneralFailure;

    if(flash->mediaType == MDOCP_TYPE) /* DiskOnChip Millennium Plus 32MB */
    {

       /* Save current configuration */
       prevInterleaveReg = flRead8bitRegPlus(flash,NconfigInput);

       /* check if we need to change interleave */
       if ((prevInterleaveReg & CONFIG_INTLV_MASK) == ((interNum-1)<<2))
          return flOK;

       if(interNum == 1)
       {
          flWrite8bitRegPlus(flash,NconfigInput,(byte)(prevInterleaveReg & ~CONFIG_INTLV_MASK)); /* interleave 1 */
          if((flRead8bitRegPlus(flash,NconfigInput) & CONFIG_INTLV_MASK) != 0)
              return(flInterleaveError); /* could not change interleave */
       }
       else
       {
          flWrite8bitRegPlus(flash,NconfigInput,(byte)(prevInterleaveReg | CONFIG_INTLV_MASK)); /* interleave 2 */
          if((flRead8bitRegPlus(flash,NconfigInput) & CONFIG_INTLV_MASK) != CONFIG_INTLV_MASK)
             return(flInterleaveError); /* could not change interleave */
       }
    }
    else
    {
       interNum = 1;
    }

    /* change structure elements values */

    flash->interleaving          = interNum-1 ;
    NFDC21thisVars->pageAreaSize = 0x100 << flash->interleaving;
    flash->pageSize              = 0X200 << flash->interleaving;
    NFDC21thisVars->tailSize     = EXTRA_LEN << flash->interleaving; /* 8 in interleave-1, 16 in interleave-2 */
    NFDC21thisVars->pageMask     = (unsigned short)(flash->pageSize - 1);
    flash->erasableBlockSize     = NFDC21thisVars->pagesPerBlock * flash->pageSize;
    NFDC21thisVars->noOfBlocks   = (unsigned short)( flash->chipSize / flash->erasableBlockSize );
    flash->interleaving++;
    for(flash->erasableBlockSizeBits = 0 ;
        (1UL << flash->erasableBlockSizeBits) < flash->erasableBlockSize;
        flash->erasableBlockSizeBits++);

    return(flOK);
}

#if (!defined(NO_IPL_CODE) && defined (HW_PROTECTION))

/*----------------------------------------------------------------------*/
/*                            r e a d I P L                             */
/*                                                                      */
/* Find a good copy of the IPL and read it to user buffer.              */
/*                                                                      */
/* Parameters:                                                          */
/*      vol     : Pointer identifying drive.                            */
/*      buffer  : buffer to read to.                                    */
/*      length  : number of bytes to read.                              */
/*                                                                      */
/* Note - Length must be an integer number of 512 bytes.                */
/*                                                                      */
/* Returns:                                                             */
/*      flOK on success, none zero otherwise.                           */
/*----------------------------------------------------------------------*/

static FLStatus readIPL(FLFlash  * flash, void FAR1 * buffer, word length)
{
  byte FAR1 *      bufPtr            = (byte FAR1 *)buffer;
  const void FAR0* winPtr            = (const void FAR1*)flash->win;
  word             tmpLength         = 0;
  int              i;
  volatile byte    prevMaxId;

  /* IPL must be read using full 512 bytes sector */
  if ((length % SECTOR_SIZE != 0)&&(length > flash->noOfFloors*IPL_MAX_SIZE))
    return flBadLength;

  /* Force IPL to be loaded */
  checkStatus(forceDownLoad(flash));
  /* Force NORMAL mode */
  checkStatus(chkASICmode(flash));
  if(flash->win == NULL)
    return flGeneralFailure;

  /* Store max ID and open IPL of high floors */
  prevMaxId = setIplSize(flash, flash->noOfFloors);

  for(i = 0 ; length > 0 ; length -= tmpLength,i++)
  {
     tmpLength = TFFSMIN(length,IPL_MAX_SIZE);

     tffscpy(bufPtr , (void FAR1*)winPtr , tmpLength);
     bufPtr = BYTE_ADD_FAR(bufPtr,tmpLength);
     switch(i)
     {
        case 1:
           winPtr = BYTE_ADD_FAR(winPtr,5*IPL_MAX_SIZE);
           break;
        case 0:
        case 2:
           winPtr = BYTE_ADD_FAR(winPtr,IPL_MAX_SIZE);
        default:
           break;
     }
  }

  /* Restore MAX id */
  prevMaxId = setIplSize(flash, prevMaxId);
  return flOK;
}

#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                        w r i t e I P L                               */
/*                                                                      */
/* Write new IPL.                                                       */
/*                                                                      */
/* Note : When write operation starts from the middle of the IPL, it    */
/*        not erase the previous content. Therefore you should use the  */
/*        use offset != 0 only after an operation that did start from 0.*/
/*                                                                      */
/* Note : Offset parameter is given in sector (512 bytes).              */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive.                            */
/*      buffer  : buffer to write from.                                 */
/*      length  : number of bytes to write.                             */
/*      offset  : sector number to start from.                          */
/*      flags   : Modes to write IPL :                                  */
/*                FL_IPL_MODE_NORMAL - Normal mode.                     */
/*                FL_IPL_DOWNLOAD    - Download new IPL when done       */
/*                FL_IPL_MODE_SA     - Strong Arm IPL mode              */
/*                FL_IPL_MODE_XSCALE - X-Scale IPL mode                 */
/*                                                                      */
/* Returns:                                                             */
/*      flOK on success, none zero otherwise.                           */
/*----------------------------------------------------------------------*/

static FLStatus writeIPL(FLFlash * flash, const void FAR1 * buffer,
                         word length,byte offset, unsigned flags)
{
  FLBoolean   restoreInterleave = FALSE;
  FLStatus    status;
  FLStatus    secondStatus;
  int         i;
  byte FAR1 * tmpPtr            = (byte FAR0 *)buffer;
  byte        dps[NO_OF_DPS][SIZE_OF_DPS];
  CardAddress iplOffset[4];
  byte        floor;
  byte        downloadStatus;
  dword       floorInc;
  word        curWrite;
  word        redundantUnit; /* First unit to erase - might have bad data */
  word        goodUnit;      /* Second unit to erase - has valid DPS      */
  dword       goodDPS;       /* Where to read DPS - in second unit        */
  dword       redundantDPS;  /* Where to write DPS - in first unit        */
  dword       dps1Copy0;     /* Offset to DPS1 copy 0                     */
  word        dps1UnitNo;    /* Offset to redundant DPS unit              */
  dword       copyOffset;    /* Offset to redundant units                 */
  unsigned    iplModeFlags;  /* IPL Strong Arm and\or XScale mode flags.  */

  /* Check IPL requested size against the real IPL size */
  if (length + (offset<<SECTOR_SIZE_BITS) > flash->noOfFloors*IPL_MAX_SIZE)
    return flBadLength;

  /* Check mode of ASIC and set to NORMAL.*/
  status = chkASICmode(flash);
  if(status != flOK)
    return status;

  /* Check IPL mode flags */
  iplModeFlags = flags & (FL_IPL_MODE_SA|FL_IPL_MODE_XSCALE);
  if(iplModeFlags) /* Write MODE mark */
  {
     if(iplModeFlags == (FL_IPL_MODE_SA|FL_IPL_MODE_XSCALE))
     {
        DEBUG_PRINT(("ERROR - Can write IPL with both Strong Arm and X-Scale modes\r\n"));
        return flBadParameter;
     }

     if(flash->mediaType == MDOCP_TYPE) /* DiskOnChip Millennium Plus 32MB */
     {
        DEBUG_PRINT(("ERROR - DiskOnChip Millennium Plus 32MB does not support special IPL modes\r\n"));
        return flFeatureNotSupported;
     }
  }

  /* Send default key for unprotected partitions */
  if (flash->protectionKeyInsert != NULL)
  {
     status = flash->protectionKeyInsert(flash,1, (byte *)DEFAULT_KEY);
     if(status != flOK)
        return status;
  }

  /* make sure to be in interleave 1 mode */
  if (flash->interleaving==2)  /* store previous */
  {
     restoreInterleave = TRUE;
     status = changeInterleave(flash, 1); /* change to interleave 1. abort if failed */
     if(status != flOK)
       return status;
  }

#ifndef MTD_STANDALONE
  /* Force remapping of internal catched sector */
  flash->socket->remapped = TRUE;
#endif /* MTD_STANDALONE */

  if(flash->mediaType == MDOCP_TYPE) /* DiskOnChip Millennium Plus 32MB */
  {
    copyOffset   = flash->chipSize>>1; /* The chips are consequtive */
    dps1UnitNo   = DPS1_UNIT_NO_32;
    dps1Copy0    = DPS1_COPY0_32;
    iplOffset[0] = IPL0_COPY0_32;
    iplOffset[2] = IPL1_COPY0_32;
  }
  else                               /* DiskOnChip Millennium Plus 16MB */
  {
    /* DPS0 / DPS1 / DPS0 copy / DPS 1 copy */
    copyOffset   = flash->erasableBlockSize;
    dps1UnitNo   = DPS1_UNIT_NO_16;
    dps1Copy0    = DPS1_COPY0_16;
    iplOffset[0] = IPL0_COPY0_16;
    iplOffset[2] = IPL1_COPY0_16;
  }
  iplOffset[1] = iplOffset[0]+SECTOR_SIZE;
  iplOffset[3] = iplOffset[2]+SECTOR_SIZE;

  floor   = offset >> 1;  /* Skip to proper floor (2 * 512 per floor) */
  offset -= floor << 1;   /* Update offset                            */

  /* Reading IPL starting from 1k of floor 0 and up */
  for (floorInc=floor * NFDC21thisVars->floorSize;
       (floor<flash->noOfFloors)&&(length>0);
       floor++,floorInc+=NFDC21thisVars->floorSize)
  {
     setFloor(flash,floor); /* Set the floor to use */
     /* Prepare inernal write buffer */
     /* Note - buffer and NFDC21thisBuffer might be the same buffer */
     curWrite = (word)TFFSMIN(length,SECTOR_SIZE);
     tffscpy(NFDC21thisBuffer,(void *)tmpPtr,curWrite);
     tffsset(NFDC21thisBuffer+curWrite,0xff,SECTOR_SIZE-curWrite);

     /* When starting from the second sector do not erase the units */
     if (offset != 0)
     {
        status = doc2Write(flash,iplOffset[2]+floorInc,NFDC21thisBuffer,SECTOR_SIZE,EDC);
        if(status!=flOK) goto END_WRITE_IPL;
        status = doc2Write(flash,iplOffset[2]+SECTOR_SIZE+floorInc,NFDC21thisBuffer,SECTOR_SIZE,EDC);
        if(status!=flOK) goto END_WRITE_IPL;
        status = doc2Write(flash,iplOffset[2]+copyOffset+floorInc,NFDC21thisBuffer,SECTOR_SIZE,EDC);
        if(status!=flOK) goto END_WRITE_IPL;
        status = doc2Write(flash,iplOffset[2]+SECTOR_SIZE+copyOffset+floorInc,NFDC21thisBuffer,SECTOR_SIZE,EDC);
        if(status!=flOK) goto END_WRITE_IPL;
        offset = 0;
        goto WRITE_IPL_NEXT_FLOOR;
     }

     /* Decide which copy to use acording to the previous download */
     downloadStatus = flRead8bitRegPlus(flash,NdownloadStatus);

     switch (downloadStatus & DWN_STAT_DPS1_ERR)
     {
        case DWN_STAT_DPS1_ERR:  /* Both copies are invalid */
           status = flBadDownload;
           goto END_WRITE_IPL;

        case DWN_STAT_DPS10_ERR: /* First copy is bad */
           if(flash->mediaType == MDOCP_TYPE)
           {
              redundantUnit = (word)(dps1UnitNo + floor*(NFDC21thisVars->floorSize>>flash->erasableBlockSizeBits));
              goodUnit      = (word)(redundantUnit + (copyOffset>>flash->erasableBlockSizeBits));
              redundantDPS  = dps1Copy0 + floorInc;
              goodDPS       = redundantDPS + copyOffset;
           }
           else
           {
              redundantUnit = (word)(dps1UnitNo + floor*(NFDC21thisVars->floorSize>>flash->erasableBlockSizeBits));
              goodUnit      = (word)(redundantUnit + (copyOffset>>flash->erasableBlockSizeBits));
              redundantDPS  = dps1Copy0 + floorInc;
              goodDPS       = redundantDPS + copyOffset;
           }

           break;

        default:                 /* Both copies are good */
           goodUnit      = (word)(dps1UnitNo + floor*(NFDC21thisVars->floorSize>>flash->erasableBlockSizeBits));
           redundantUnit = (word)(goodUnit + (copyOffset>>flash->erasableBlockSizeBits));
           goodDPS       = dps1Copy0 + floorInc;
           redundantDPS  = goodDPS + copyOffset;
     }
     /* Read previous dps */
     status = doc2Read(flash,goodDPS,&(dps[0][0]),SIZE_OF_DPS,0);
     if(status!=flOK) goto END_WRITE_IPL;
     status = doc2Read(flash,goodDPS + REDUNDANT_DPS_OFFSET,
                       &(dps[1][0]),SIZE_OF_DPS,0);
     if(status!=flOK) goto END_WRITE_IPL;
     /* Erase the other unit - not the one we downloaded from */
     status = flash->erase(flash,redundantUnit,1);
     if(status!=flOK) goto END_WRITE_IPL;
     /* Write DPS */
     status = doc2Write(flash,redundantDPS,&(dps[0][0]),SIZE_OF_DPS,0);
     if(status!=flOK) goto END_WRITE_IPL;
     status = doc2Write(flash,redundantDPS + REDUNDANT_DPS_OFFSET,
                        &(dps[1][0]),SIZE_OF_DPS,0);
     if(status!=flOK) goto END_WRITE_IPL;
     /* Erase the unit that we downloaded from */
     status = flash->erase(flash,goodUnit,1);
     if(status!=flOK) goto END_WRITE_IPL;
     /* Write DPS */
     status = doc2Write(flash,goodDPS, &(dps[0][0]),SIZE_OF_DPS,0);
     if(status!=flOK) goto END_WRITE_IPL;
     status = doc2Write(flash,goodDPS + REDUNDANT_DPS_OFFSET,
                        &(dps[1][0]),SIZE_OF_DPS,0);


     /* Write IPL - 2 copies of first unit */
     for(i=0;i<2;i++)
     {
        status = doc2Write(flash,iplOffset[i]+floorInc,NFDC21thisBuffer,SECTOR_SIZE,EDC);
        if(status!=flOK) goto END_WRITE_IPL;
        status = doc2Write(flash,iplOffset[i]+floorInc+copyOffset,NFDC21thisBuffer,SECTOR_SIZE,EDC);
        if(status!=flOK) goto END_WRITE_IPL;
     }

     /* Write next 512 bytes of IPL if needed */
     length -= curWrite;
     if (length > 0)
     {
        /* Prepare next buffer */
        tmpPtr = BYTE_ADD_FAR(tmpPtr,SECTOR_SIZE);
        curWrite = (word)TFFSMIN(length,SECTOR_SIZE);
        tffscpy(NFDC21thisBuffer,tmpPtr,curWrite);
        tffsset(NFDC21thisBuffer+curWrite,0x0,SECTOR_SIZE-curWrite);

        for(;i<4;i++)
        {
           status = doc2Write(flash,iplOffset[i]+floorInc,NFDC21thisBuffer,SECTOR_SIZE,EDC);
           if(status!=flOK) goto END_WRITE_IPL;
           status = doc2Write(flash,iplOffset[i]+floorInc+copyOffset,NFDC21thisBuffer,SECTOR_SIZE,EDC);
           if(status!=flOK) goto END_WRITE_IPL;
        }
     }
WRITE_IPL_NEXT_FLOOR:
     length -= curWrite;
     if(length>0)
       tmpPtr = BYTE_ADD_FAR(tmpPtr,SECTOR_SIZE);
     if(iplModeFlags) /* Write MODE mark */
     {
        byte  mark = IPL_SA_MODE_MARK; /* Strong arm is the default */

        if(flags & FL_IPL_MODE_XSCALE) /* Unless X-Scale wase asked for */
           mark = IPL_XSCALE_MODE_MARK;

        status = doc2Write(flash,IPL_MODE_MARK_OFFSET+floorInc,&mark,1,EXTRA);
        if(status!=flOK) goto END_WRITE_IPL;
     }
  } /* End for loop over floors */
END_WRITE_IPL:
  if ( restoreInterleave == TRUE)
  {
     chkASICmode(flash); /* Release posible access error */
     secondStatus = changeInterleave(flash, 2); /* change to interleave 2. */
     if(secondStatus != flOK)
        return secondStatus;
  }
  if(status == flOK)
  {
     if((flags & FL_IPL_DOWNLOAD) == 0)
        return flOK;

     if(flash->download != NULL)
         return flash->download(flash);
     DFORMAT_PRINT(("ERROR - IPL was not downloaded since MTD does not support the feature\r\n"));
  }
  return status;
}
#endif /* FL_READ_ONLY */
#endif /* not NO_IPL_CODE & HW_PROTECTION */

#ifdef  HW_OTP
#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                        w r i t e O T P                               */
/*                                                                      */
/* Write and lock the customer OTP.                                     */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive.                            */
/*      buffer  : buffer to write from.                                 */
/*      length  : number of bytes to write.                             */
/*                                                                      */
/* Note - customer OTP memory structure: (flash pages 6-31              */
/*          byte  0      - Indicates the lock state (0 for locked).     */
/*          bytes 3-7    - OTP used size.                               */
/*          page  7-19   - 6K of the unit - customer data.              */
/*                                                                      */
/* Returns:                                                             */
/*      flOK on success, none zero otherwise.                           */
/*----------------------------------------------------------------------*/

static FLStatus writeOTP(FLFlash * flash , const void FAR1 * buffer, word length)
{
  word          lastSectorSize = (word)(length % SECTOR_SIZE);
  OTPLockStruct lock;
  FLStatus      status;
  int           shift = flash->interleaving-1;

  selectFloor(flash,0);
  /* Check mode of ASIC and set to NORMAL.*/
  status = chkASICmode(flash);
  if(status != flOK)
     return status;

  if (length > CUSTOMER_OTP_SIZE)
     return flBadLength;

  /* write the data with EDC */
  status = doc2Write(flash, (CUSTOMER_OTP_START<<shift)+flash->pageSize, buffer,
                     length-lastSectorSize, EDC);
  if(status != flOK)
     return status;

  /* Write last partial sector */
  if (lastSectorSize > 0)
  {
     /* Force remapping of internal catched sector */
#ifndef MTD_STANDALONE
     flash->socket->remapped = TRUE;
#endif /* MTD_STANDALONE */

     tffsset(NFDC21thisBuffer,0,sizeof(NFDC21thisBuffer));
     tffscpy(NFDC21thisBuffer,BYTE_ADD_FAR(buffer,length-lastSectorSize),lastSectorSize);
     status = doc2Write(flash, (CUSTOMER_OTP_START<<shift) + flash->pageSize +
         length-lastSectorSize, NFDC21thisBuffer, SECTOR_SIZE, EDC);
     if(status != flOK)
        return status;
  }

  /* Lock area */
  tffsset((void FAR1 *)&lock,0,sizeof(lock));
  lock.lockByte[0] = OTP_LOCK_MARK;

  toLE4(lock.usedSize,(dword)length); /* store size of data */
  status = doc2Write(flash, (CUSTOMER_OTP_START<<shift), &lock, sizeof(lock), 0);

  if(status == flOK)
     status = forceDownLoad(flash);

  return status;
}
#endif /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                        o t p S i z e                                 */
/*                                                                      */
/* Returns the size and state of the OTP area.                          */
/*                                                                      */
/* Parameters:                                                          */
/*      flash       : Pointer identifying drive.                        */
/*      sectionSize : Total OTP size.                                   */
/*      usedSize    : Used OTP size.                                    */
/*      locked      : Lock state (LOCKED_OTP for locked).               */
/*                                                                      */
/* Returns:                                                             */
/*      flOK on success, none zero otherwise.                           */
/*----------------------------------------------------------------------*/

static FLStatus otpSize(FLFlash * flash,  dword FAR2* sectionSize,
                        dword FAR2* usedSize, word FAR2* locked)
{
  OTPLockStruct lock;
  FLStatus      status = flOK;
  int           shift = flash->interleaving-1;

  selectFloor(flash,0);
  if (flRead8bitRegPlus(flash,NprotectionStatus) & PROTECT_STAT_COTPL_MASK)
  {
     status = doc2Read(flash,(CUSTOMER_OTP_START<<shift) , &lock, sizeof(lock), 0);
     *usedSize = LE4(lock.usedSize);
     *locked   = LOCKED_OTP;
  }
  else
  {
     *locked = 0;
     *usedSize = 0;
  }
  /* return the maximum capacity available */
  *sectionSize = CUSTOMER_OTP_SIZE;
  return status;
}

/*----------------------------------------------------------------------*/
/*                        r e a d O T P                                 */
/*                                                                      */
/* Read data from the customer OTP.                                     */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive.                            */
/*      offset  : Offset from the beginning of OTP area to read from.   */
/*      buffer  : buffer to read into.                                  */
/*      length  : number of bytes to read.                              */
/*                                                                      */
/* Returns:                                                             */
/*      flOK on success, none zero otherwise.                           */
/*----------------------------------------------------------------------*/

static FLStatus readOTP(FLFlash * flash, word offset, void FAR1 * buffer, word length)
{
  dword       usedSize;
  dword       tmp;
  word        locked;
  FLStatus    status;
  CardAddress otpStartAddr,startReadAddr,endReadAddr,remainder;

  byte FAR1*  bufPtr = (byte FAR1*) buffer;
  int         shift = flash->interleaving-1;

  selectFloor(flash,0);
  /* Check mode of ASIC and set to NORMAL.*/
  status = chkASICmode(flash);
  /* Check otp area written size */
  if(status==flOK)
    status = otpSize(flash,&tmp,&usedSize,&locked);
  if(status != flOK)
    return status;

  if (locked != LOCKED_OTP)
    return flNoSpaceInVolume; /* Area not locked    */
  if ((dword)(offset+length) > usedSize)
    return flBadLength;       /* Exceeds used space */

#ifndef MTD_STANDALONE
  /* Force remapping of internal catched sector */
  flash->socket->remapped = TRUE;
#endif /* MTD_STANDALONE */

  /**************************/
  /* read the data with EDC */
  /**************************/

  otpStartAddr  = (CUSTOMER_OTP_START<<shift) + flash->pageSize;
  /* tmp - OTP offset rounded down to sectors */
  tmp           = (dword)((offset >> SECTOR_SIZE_BITS) << SECTOR_SIZE_BITS);
  /* startReadAddr - Physical address of first sector to read */
  startReadAddr = otpStartAddr + tmp;
  /* remainder - size of last partial sector to read */
  remainder     = (offset+length) % SECTOR_SIZE;
  /* endReadAddr - Physical address of the last OTP sector to be read */
  endReadAddr   = otpStartAddr + offset + length - remainder;

  if (tmp != offset) /* Start at unaligned address */
  {
     checkStatus(doc2Read(flash, startReadAddr, NFDC21thisBuffer, SECTOR_SIZE, EDC));
     usedSize       = TFFSMIN(SECTOR_SIZE + tmp - offset,length);
     tffscpy(bufPtr,NFDC21thisBuffer + offset - tmp,(word)usedSize);
     bufPtr         = BYTE_ADD_FAR(bufPtr,usedSize);
     startReadAddr += usedSize;
     length        -= (word)usedSize;
  }
  /* Start at aligned address */
  if(length > 0)
  {
    checkStatus(doc2Read(flash, startReadAddr, bufPtr,
                         endReadAddr-startReadAddr , EDC));
    /* Read last sector partial page */
    if(remainder)
    {
       bufPtr   = BYTE_ADD_FAR(bufPtr,endReadAddr-startReadAddr);
       checkStatus(doc2Read(flash, endReadAddr, NFDC21thisBuffer, SECTOR_SIZE, EDC));
       tffscpy(bufPtr,NFDC21thisBuffer,remainder);
    }
  }
  return flOK;
}

/*----------------------------------------------------------------------*/
/*                    g e t U n i q u e I d                             */
/*                                                                      */
/* Retreave the device 16 bytes unique ID.                              */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive.                            */
/*      buffer  : buffer to read into.                                  */
/*                                                                      */
/* Returns:                                                             */
/*      flOK on success, none zero otherwise.                           */
/*----------------------------------------------------------------------*/

static FLStatus getUniqueId(FLFlash * flash,void FAR1 * buffer)
{
  /* Make sure contorller is set to NORMAL. */
  FLStatus status = chkASICmode(flash);

  if(status != flOK)
    return status;

#ifndef MTD_STANDALONE
  /* Force remapping of internal catched sector */
  flash->socket->remapped = TRUE;
#endif /* MTD_STANDALONE */

  /* read unit 0 sector 0 with ecc */
  checkStatus(doc2Read(flash, 0 , NFDC21thisBuffer, SECTOR_SIZE, EDC));

  /* copy relevant unique ID from 512 bytes buffer to user buffer */
  tffscpy(buffer ,
          NFDC21thisBuffer+(UNIQUE_ID_OFFSET << (flash->interleaving - 1)) ,
          UNIQUE_ID_SIZE);

  return flOK;

}
#endif  /* HW_OTP */


/*----------------------------------------------------------------------*/
/*                  d o c P l u s I d e n t i f y                       */
/*                                                                      */
/* Identify flash. This routine will be registered as the               */
/* identification routine for this MTD.                                 */
/*                                                                      */
/* Parameters:                                                          */
/*    flash      : Pointer identifying drive                            */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, otherwise failed.                     */
/*----------------------------------------------------------------------*/

FLStatus docPlusIdentify(FLFlash * flash)
{
  FLStatus status;
  int      maxDevs, dev;
  byte     floor;

#ifdef NT5PORT
  byte     socketNo = (byte)flSocketNoOf(flash->socket);
#else
  byte     socketNo = flSocketNoOf(flash->socket);
#endif NT5PORT


  DEBUG_PRINT(("Debug: entering NFDC MDOCP identification routine.\r\n"));

  flash->mtdVars = &docMtdVars[socketNo];

#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASE))
  /* Get pointer to read back buffer */
  NFDC21thisVars->readBackBuffer = flReadBackBufferOf(socketNo);
#endif /* VERIFY_WRITE || VERIFY_ERASE */

#ifndef MTD_STANDALONE
  /* get pointer to buffer (we assume SINGLE_BUFFER is not defined) */
  NFDC21thisVars->buffer = flBufferOf(socketNo);

  flSetWindowBusWidth(flash->socket, 16);/* use 16-bits */
  flSetWindowSpeed(flash->socket, 120);  /* 120 nsec. */
#else

#if (defined (HW_PROTECTION) || defined (HW_OTP) || !defined (NO_IPL_CODE) || defined (MTD_READ_BBT))
  NFDC21thisVars->buffer = &globalMTDBuffer;
#endif /* HW_PROTECTION || HW_OTP || !NO_IPL_CODE || MTD_READ_BBT */
#endif /* MTD_STANDALONE */

  /* detect card - identify bit toggles on consequitive reads */
  NFDC21thisWin = (NDOC2window)flMap(flash->socket, 0);
  flash->win    = NFDC21thisWin;
  if (NFDC21thisWin == NULL)
     return flUnknownMedia;

#ifndef FL_NO_USE_FUNC
  /* Set default access routines */
  if(setDOCPlusBusType(flash,flBusConfig[socketNo],1,
     chooseDefaultIF_CFG(flBusConfig[socketNo])) == FALSE)
     return flUnknownMedia;
#endif /* FL_NO_USE_FUNC */

  /* Change controller to normal mode */
  status = setASICmode (flash, DOC_CNTRL_MODE_NORMAL);
  if(status != flOK)
    return status;

#ifndef FL_NO_USE_FUNC
  /* Set permenant access routines accoring to if_cfg and interleave */
  if(setDOCPlusBusType(flash,flBusConfig[socketNo],
                       chkInterleave(flash),chkIF_CFG(flash)) == FALSE)
     return flUnknownMedia;
#endif /* FL_NO_USE_FUNC */

  dev = getControllerID(flash); /* Read chip ID */
  switch (dev)
  {
     case CHIP_ID_MDOCP:    /* Millennium Plus 32MB */
        flash->chipSize                  = CHIP_TOTAL_SIZE<<1;
        flash->mediaType                 = MDOCP_TYPE;
        flash->changeableProtectedAreas  = 1;
        NFDC21thisVars->floorSizeBits    = 25;
        flash->firstUsableBlock          = 3;
        break;
     case CHIP_ID_MDOCP16:  /* Millennium Plus 16MB */
        flash->chipSize                  = CHIP_TOTAL_SIZE;
        flash->mediaType                 = MDOCP_16_TYPE;
        flash->changeableProtectedAreas  = 2;
        NFDC21thisVars->floorSizeBits    = 24;
        flash->firstUsableBlock          = 5;
        break;
     default:
        DEBUG_PRINT(("Debug: failed to identify NFDC MDOCP.\r\n"));
        return( flUnknownMedia );
  }
  NFDC21thisVars->win_io = NIPLpart2; /* NFDC21thisIO */

  /* select flash device. change the address according floor!! */
  setFloor   (flash, 0);      /* Map window to selected controler.   */
  selectChip (flash, MPLUS_SEL_CE|MPLUS_SEL_WP);  /* Map window to selected flash device.*/

  if (checkToggle(flash) == FALSE)
  {
    DEBUG_PRINT(("Debug: failed to identify NFDC MDOCP.\r\n"));
    return( flUnknownMedia );
  }

  /* find the interleave value */
  flash->interleaving = chkInterleave(flash);

  /* reset all flash devices */
  maxDevs = MAX_FLASH_DEVICES_MDOCP;

  for ( floor = 0 ;floor < MAX_FLOORS ;floor++)
  {
    /* select floor */
    setFloor(flash,floor);

    /* select device */
    for ( dev = 0 ; dev < maxDevs ; dev++ )
    {
      selectChip(flash, MPLUS_SEL_CE|MPLUS_SEL_WP );
      command(flash, RESET_FLASH);
    }
  }

  /* Set MDOCP flash parameters */
  NFDC21thisVars->vendorID          = 0x98;  /* remember for next chips */
  NFDC21thisVars->chipID            = 0x75;
  flash->type                       = TC58256_FLASH;
  NFDC21thisVars->pagesPerBlock     = MDOCP_PAGES_PER_BLOCK;
  NFDC21thisVars->floorSize         = flash->chipSize;
  NFDC21thisVars->pageAreaSize      = CHIP_PAGE_SIZE * flash->interleaving;
  flash->pageSize                   = NFDC21thisVars->pageAreaSize << 1;
  flash->erasableBlockSize          = NFDC21thisVars->pagesPerBlock * flash->pageSize;
  NFDC21thisVars->tailSize          = EXTRA_LEN * flash->interleaving;/* 8 in interleave-1, 16 in interleave-2 */
  NFDC21thisVars->pageMask          = (word)(flash->pageSize - 1);
  NFDC21thisVars->noOfBlocks        = (word)(flash->chipSize / flash->erasableBlockSize);

  /* Try changing to interleave 2 */
  changeInterleave(flash, 2);

    /* identify and count flash chips, figure out flash parameters */

  flash->noOfChips = 0; /* One floor already found    */
  for( floor = 0; floor < MAX_FLOORS;  floor++ )
  {
    setFloor(flash,floor);

    /* check floor for MDOCP ID + check the toggle bit */

    dev = getControllerID(flash); /* Read chip ID */

    if(((dev != CHIP_ID_MDOCP  ) &&
        (dev != CHIP_ID_MDOCP16)   ) ||
       (checkToggle(flash) == FALSE)    )
       break;

    /* check for DPS and OTP download errors */

    if (chkASICDownload (flash,floor))
    {
      DEBUG_PRINT(("Debug: failed to download OTP/DPS.\r\n"));
      return( flBadDownload );
    }
    selectChip (flash, MPLUS_SEL_WP);  /* Map window to selected flash device.*/
  }

  /* update total floors in structure and ASIC configuration register */
  flash->noOfChips  = floor;
  flash->noOfFloors = floor;

  /* back to ground floor */
  NFDC21thisVars->currentFloor = (byte)0;
  setFloor(flash,NFDC21thisVars->currentFloor);

  if (flash->noOfChips == 0) {
    DEBUG_PRINT(("Debug: failed to identify NFDC MDOCP.\r\n"));
    return( flUnknownMedia );
  }

 /*
  *  Open IPL of high floors
  *
  *  dev = setIplSize(flash, flash->noOfFloors);
  */

  /* Get host access type (8  bit or 16 bit data access if_cfg */
  NFDC21thisVars->if_cfg = chkIF_CFG(flash);

  /* Register our flash handlers and flash parameters */
#ifndef FL_READ_ONLY
  flash->write                  = doc2Write;
  flash->erase                  = doc2Erase;
#else
  flash->erase                  = NULL;
  flash->write                  = NULL;
#endif
  flash->read                   = doc2Read;
#ifndef MTD_STANDALONE
  flash->map                    = doc2Map;
#endif /* MTD_STANDALONE */
  flash->enterDeepPowerDownMode = powerDown;
#if (defined(HW_PROTECTION) || !defined(NO_IPL_CODE) || defined (HW_OTP))
  flash->download               = forceDownLoad;
#endif /* HW_PROTECTION or !NO_IPL_CODE */

#ifdef MTD_READ_BBT
  flash->readBBT                = readBBT;
#endif /* MTD_READ_BBT */

#if (!defined(NO_IPL_CODE) && defined (HW_PROTECTION))
#ifndef FL_READ_ONLY
  flash->writeIPL               = writeIPL;
#endif /* FL_READ_ONLY */
  flash->readIPL                = readIPL;
#endif /* not NO_IPL_CODE & HW_PROTECTION */

#ifdef HW_OTP
  flash->otpSize                = otpSize;
  flash->readOTP                = readOTP;
#ifndef FL_READ_ONLY
  flash->writeOTP               = writeOTP;
#endif /* FL_READ_ONLY */
  flash->getUniqueId            = getUniqueId;
#endif /* HW_OTP */
#ifdef  HW_PROTECTION
  flash->protectionBoundries    = protectionBoundries;
  flash->protectionKeyInsert    = protectionKeyInsert;
  flash->protectionKeyRemove    = protectionKeyRemove;
  flash->protectionType         = protectionType;
#ifndef FL_READ_ONLY
  flash->protectionSet          = protectionSet;
#endif /* FL_READ_ONLY */
#endif /* HW_PROTECTION */
  flash->totalProtectedAreas       = 2;
  flash->ppp                       = 5;
  flash->flags                     = INFTL_ENABLED;
  flash->maxEraseCycles            = 1000000L;
  NFDC21thisVars->floorSizeMask    = NFDC21thisVars->floorSize-1;
/*  checkStatus(forceDownLoad(flash)); *//* For testing purposes only @@*/

  DEBUG_PRINT(("Debug: identified NFDC MDOCP.\r\n"));
  return( flOK );
}

#ifndef MTD_STANDALONE

/*----------------------------------------------------------------------*/
/*              f l R e g i s t e r D O C P L U S S O C                 */
/*                                                                      */
/* Installs routines for DiskOnChip Plus family.                        */
/*                                                                      */
/* Parameters:                                                          */
/*      lowAddress,                                                     */
/*      highAddress     : host memory range to search for DiskOnChip    */
/*                        PLUS memory window                            */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, otherwise failure                     */
/*----------------------------------------------------------------------*/
#ifndef NT5PORT

FLStatus flRegisterDOCPLUSSOC(dword lowAddress, dword highAddress)
{
  int serialNo;

  if( noOfSockets >= SOCKETS )
    return flTooManyComponents;

  /* Try to register DiskOnChip using */
  for(serialNo=0;( noOfSockets < SOCKETS );serialNo++,noOfSockets++)
  {
        FLSocket * socket = flSocketOf(noOfSockets);

        socket->volNo = noOfSockets;

        docSocketInit(socket);

        /* call DiskOnChip MTD's routine to search for memory window */

        flSetWindowSize(socket, 2);  /* 4 KBytes */

        socket->window.baseAddress = flDocWindowBaseAddress
             ((byte)(socket->volNo), lowAddress, highAddress, &lowAddress);

        if (socket->window.baseAddress == 0)   /* DiskOnChip not detected */
          break;
  }
  if( serialNo == 0 )
    return flAdapterNotFound;

  return flOK;
}
#endif /* NT5PORT*/
#else /* MTD_STANDALONE */

/*----------------------------------------------------------------------*/
/*            d o c P l u s S e a r c h F o r W i n d o w               */
/*                                                                      */
/* Search for the DiskOnChip ASIC in a given memory range and           */
/* initialize the given socket record.                                  */
/*                                                                      */
/* Parameters:                                                          */
/*      socket      :   Record used to store the sockets parameters     */
/*      lowAddress  :   host memory range to search for DiskOnChip Plus */
/*      highAddress :   memory window                                   */
/*                                                                      */
/* Output:  initialize the following fields in the FLFlash record:      */
/*                                                                      */
/*      base  -  Pointer to DiskOnChip window                           */
/*      size  -  DiskOnChip window size usualy 8K                       */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus    : 0 on success, flDriveNotAvailable on failure.     */
/*                                                                      */
/* NOTE: This routine is not used by OSAK. It is used by standalone     */
/*       applications using the MTD (BDK for example) as a replacement  */
/*       for the OSAK DOCSOC.C file.                                    */
/*       The FLSocket record used by this function is not the one used  */
/*       by OSAK defined in flsocket.h but a replacement record defined */
/*       in flflash.h.                                                  */
/*                                                                      */
/*----------------------------------------------------------------------*/

FLStatus docPlusSearchForWindow(FLSocket * socket,
             dword lowAddress,
             dword highAddress)
{
    dword baseAddress;   /* Physical base as a 4K page */

    socket->size = 2 * 0x1000L;         /* 4 KBytes */
    baseAddress = (dword) flDocWindowBaseAddress(0, lowAddress, highAddress,&lowAddress);
    socket->base = physicalToPointer(baseAddress << 12, socket->size,0);
    if (baseAddress)    /* DiskOnChip detected */
      return flOK;
    else                        /* DiskOnChip not detected */
      return flDriveNotAvailable;
}

#ifndef MTD_FOR_EXB
/*----------------------------------------------------------------------*/
/*                d o c P l u s F r e e W i n d o w                     */
/*                                                                      */
/* Free any resources used for the DiskOnChip window                    */
/*                                                                      */
/* Parameters:                                                          */
/*      socket      :   Record used to store the sockets parameters     */
/*                                                                      */
/* Returns: None                                                        */
/*                                                                      */
/* NOTE: This routine is used only by virtual memory systems in order   */
/*       to unmap the DiskOnChip window.                                */
/*                                                                      */
/*----------------------------------------------------------------------*/

void docPlusFreeWindow(FLSocket * socket)
{
   freePointer(socket->base,DOC_WIN);
}
#endif /* MTD_FOR_EXB */
#endif /* MTD_STANDALONE */

#ifndef MTD_FOR_EXB
/*----------------------------------------------------------------------*/
/*                      f l R e g i s t e r D O C P L U S               */
/*                                                                      */
/* Registers this MTD for use                                           */
/*                                                                      */
/* Parameters:                                                          */
/*      None                                                            */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failure               */
/*----------------------------------------------------------------------*/

FLStatus flRegisterDOCPLUS(void)
{
  if (noOfMTDs >= MTDS)
    return( flTooManyComponents );

#ifdef MTD_STANDALONE
  socketTable[noOfMTDs] = docPlusSearchForWindow;
  freeTable[noOfMTDs]   = docPlusFreeWindow;
#endif /* MTD_STANDALONE */

  mtdTable[noOfMTDs++]  = docPlusIdentify;

  return( flOK );
}
#endif /* MTD_FOR_EXB */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\mtdsa.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/MTDSA.C_V  $
 * 
 *    Rev 1.14   Apr 15 2002 07:37:56   oris
 * flBusConfig array was changed from byte variables to dword.
 * 
 *    Rev 1.13   Jan 23 2002 23:33:48   oris
 * Bad include directive to flBuffer.h
 * 
 *    Rev 1.12   Jan 17 2002 23:03:24   oris
 * Changed flbase.h include with docsys.h and nanddefs.h
 * Moved boot SDK MTD related variables from docbdk.c
 * Define flSocketOf and flFlashOf routines.
 * 
 *    Rev 1.11   Jul 13 2001 01:07:40   oris
 * Added readback buffer allocation and flBuffer.h include directive.
 * 
 *    Rev 1.10   Jun 17 2001 22:29:52   oris
 * Removed typo *
 * 
 *    Rev 1.9   Jun 17 2001 16:39:12   oris
 * Improved documentation and remove warnings.
 * 
 *    Rev 1.8   May 29 2001 19:48:32   oris
 * Compilation problem when using the default delay routine.
 * 
 *    Rev 1.7   May 21 2001 16:11:02   oris
 * Added USE_STD_FUNC ifdef.
 * 
 *    Rev 1.6   May 20 2001 14:36:00   oris
 * Added delay routines for vx_works and psos OS.
 * 
 *    Rev 1.5   May 16 2001 21:20:54   oris
 * Bug fix - delay routine did not support delay milliseconds that did not fit into 
 * a 2 bytes variable.
 * 
 *    Rev 1.4   Apr 24 2001 17:10:30   oris
 * Removed warnings.
 * 
 *    Rev 1.3   Apr 10 2001 23:55:58   oris
 * Added flAddLongToFarPointer routine for the standalone version.
 * 
 *    Rev 1.2   Apr 09 2001 15:08:36   oris
 * End with an empty line.
 * 
 *    Rev 1.1   Apr 01 2001 07:53:24   oris
 * copywrite notice.
 * Removed nested comments.
 *
 *    Rev 1.0   Feb 04 2001 12:19:56   oris
 * Initial revision.
 *
 */

/*************************************************************************/
/*                        M-Systems Confidential                         */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001  */
/*                         All Rights Reserved                           */
/*************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                    */
/*                           SOFTWARE LICENSE AGREEMENT                  */
/*                                                                       */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE       */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                    */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                     */
/*      E-MAIL = info@m-sys.com                                          */
/*************************************************************************/

/************************************************************************/
/*                                                                      */
/* Standalone MTD Kit                                                   */
/*                                                                      */
/************************************************************************/

/************************************************************************/
/* File Header                                                          */
/* -----------                                                          */
/* Name : mtdsa.c                                                       */
/*                                                                      */
/* Description : This file contains auxiliary routines for the MTD      */
/*               standalone package, replacing TrueFFS routines.        */
/*                                                                      */
/* Note : This file should be added to the project only if the          */
/*        MTS_STANDALONE compilation flag is defined in the file mtdsa.h*/
/*        IT HAS NO PART IN A TrueFFS project                           */
/*                                                                      */
/************************************************************************/

#include "flbase.h"
#include "nanddefs.h"
#include "docsys.h"

#ifdef MTD_STANDALONE
#include "flbuffer.h" /* defintion for READ_BACK_BUFFER_SIZE */

#if (defined (VERIFY_WRITE) || defined(VERIFY_ERASE) || defined(MTD_RECONSTRUCT_BBT))
byte globalReadBack[SOCKETS][READ_BACK_BUFFER_SIZE];
#endif /* VERIFY_WRITE */

#if (defined (HW_PROTECTION) || defined (HW_OTP) || defined (MTD_READ_BBT_CODE) || !defined (NO_IPL_CODE) || defined(MTD_READ_BBT))
FLBuffer globalMTDBuffer;
#endif /* HW_PROTECTION || HW_OTP || NO_IPL_CODE || MTD_READ_BBT */

#ifndef FL_NO_USE_FUNC
dword      flBusConfig[SOCKETS] = {FL_NO_ADDR_SHIFT        |
                                   FL_BUS_HAS_8BIT_ACCESS  |
                                   FL_BUS_HAS_16BIT_ACCESS |
                                   FL_BUS_HAS_32BIT_ACCESS};
#endif /* FL_NO_USE_FUNC */
FLFlash    flash[SOCKETS];  /* flash record for the stand alone version  */
FLSocket   socket[SOCKETS]; /* socket record for the stand alone version */
NFDC21Vars docMtdVars[SOCKETS]; /* flash internal record */
MTDidentifyRoutine    mtdTable   [MTDS];
SOCKETidentifyRoutine socketTable[MTDS];
FREEmtd               freeTable  [MTDS];
int                   noOfMTDs   = 0;


/************************************************************************/
/*                    f l F l a s h O f                                 */
/*                                                                      */
/* Gets the flash connected to a volume no.                             */
/*                                                                      */
/* Parameters:                                                          */
/*    volNo        : Volume no. for which to get flash                  */
/*                                                                      */
/* Returns:                                                             */
/*     flash of volume no.                                              */
/************************************************************************/

FLFlash *flFlashOf(unsigned volNo)
{
  return &flash[volNo];
}

/************************************************************************/
/*                        f l S o c k e t O f                           */
/*                                                                      */
/* Gets the socket connected to a volume no.                            */
/*                                                                      */
/* Parameters:                                                          */
/*        volNo                : Volume no. for which to get socket     */
/*                                                                      */
/* Returns:                                                             */
/*         socket of volume no.                                         */
/************************************************************************/

FLSocket *flSocketOf(unsigned volNo)
{
  return &socket[volNo];
}

/************************************************************************/
/************************************************************************/
/****     P l a t f o r m   D e p e n d e n t    R o u t i n e s     ****/
/************************************************************************/
/************************************************************************/

/************************************************************************/
/* Delay                                                                */
/*-------                                                               */
/* Delay for the specified amount of milliseconds, Scaled by CPU speed. */
/* The function below can be customized to one of the follwing OS:      */
/*    VXWORKS                                                           */
/*    PSOS                                                              */
/*    DOS                                                               */
/************************************************************************/

#ifdef DOS_DELAY
#include <dos.h>
#endif /* DOS */

#ifdef PSS_DELAY
/* ticks per second */
#include <bspfuncs.h>

static unsigned long  flSysClkRate = (unsigned long) KC_TICKS2SEC;

#define MILLISEC2TICKS(msec)  ((flSysClkRate * (msec)) / 1000L)


/************************************************************************/
/* p s s D e l a y M s e c s                                            */
/*                                                                      */
/* Wait for specified number of milliseconds                            */
/*                                                                      */
/* Parameters:                                                          */
/*      milliseconds    : Number of milliseconds to wait                */
/*                                                                      */
/************************************************************************/

void  pssDelayMsecs (unsigned milliseconds)
{
  unsigned long  ticksToWait = MILLISEC2TICKS(milliseconds);

  tm_wkafter (ticksToWait ? ticksToWait : 0x1L );        /* go to sleep */
}

#endif /* PSS_DELAY */

#ifdef VXW_DELAY
#include <vxWorks.h>
#include <tickLib.h>
#include <sysLib.h>

void vxwDelayMsecs (unsigned milliseconds)
{
  unsigned long stop, ticksToWait;

  ticksToWait = (milliseconds * sysClkRateGet()) / 500;
  if( ticksToWait == 0x0l )
    ticksToWait++;

  stop = tickGet() + ticksToWait;
  while( tickGet() <= stop );
}

#endif

void flDelayMsecs(unsigned long msec)
{
  unsigned curDelay;

#ifdef DOS_DELAY 
  while (msec>0)
  {
     curDelay = (unsigned)msec;
     delay( curDelay );
     msec -= curDelay;
  }
#elif defined PSS_DELAY
  while (msec>0)
  {
     curDelay = (unsigned)msec;
     pssDelayMsecs (curDelay);
     msec -= curDelay;
  }
#elif defined VXW_DELAY
  while (msec>0)
  {
     curDelay = (unsigned)msec;
     vxwDelayMsecs(curDelay);
     msec -= curDelay;
  }
#else
  while( msec-- > 0 ) curDelay += (unsigned)msec;
#endif /* DOS_DELAY */
}

/************************************************************************/
/* Use customized tffscpy, tffsset and tffscmp routines.                */
/************************************************************************/

#ifndef USE_STD_FUNC

/************************************************************************/
/* tffscpy - copy one memory block to the other.                        */
/************************************************************************/
void tffscpy(void FAR1 *dest, void FAR1 *src, unsigned length)
{
  while( length-- )
    *(((char FAR1 *)dest)++) = *(((char FAR1 *)src)++);
}

/************************************************************************/
/* tffscmp - compare two memory blocks.                                 */
/************************************************************************/
int tffscmp(void FAR1 *src1, void FAR1 *src2, unsigned length)
{
  while( length-- )
    if (*(((char FAR1 *)src1)++) != *(((char FAR1 *)src2)++))
      return(TRUE);
  return(FALSE);
}

/************************************************************************/
/* tffsset - set a memory blocks to a certain value.                    */
/************************************************************************/
void tffsset(void FAR1 *dest, unsigned char value, unsigned length)
{
  while( length-- )
    *(((char FAR1 *)dest)++) = value;
}

#endif /* USE_STD_FUNC */

/************************************************************************/
/* f l A d d L o n g T o F a r P o i n t e r                            */
/*                                                                      */
/* Add unsigned long offset to the far pointer                          */
/*                                                                      */
/* Parameters:                                                          */
/*      ptr             : far pointer                                   */
/*      offset          : offset in bytes                               */
/*                                                                      */
/************************************************************************/

void FAR0 *flAddLongToFarPointer(void FAR0 *ptr, unsigned long offset)
{
  return physicalToPointer( pointerToPhysical(ptr) + offset, 0,0 );
}

#endif /* MTD_STANDALONE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\nfdc2148.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/NFDC2148.H_V  $
 * 
 *    Rev 1.1   Apr 01 2001 07:46:42   oris
 * Updated copywrite notice
 * 
 *    Rev 1.0   Feb 04 2001 12:40:46   oris
 * Initial revision.
 *
 */

/************************************************************************/
/*                                                                      */
/*		FAT-FTL Lite Software Development Kit			*/
/*              Copyright (C) M-Systems Ltd. 1995-2001                  */
/*									*/
/************************************************************************/
#ifndef NFDC2148_H
#define NFDC2148_H

#include "diskonc.h"

#endif /* NFDC2148_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\nanddefs.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/NANDDEFS.H_V  $
 * 
 *    Rev 1.9   Apr 15 2002 07:38:10   oris
 * Added 2 additional fields to mtdVars record for backwards compatibility (under RAM_MTD compilation flag) 
 *  -  unsigned short        pageSize;
 *  -  unsigned short        pageAndTailSize;
 * 
 *    Rev 1.8   Jan 20 2002 20:29:14   oris
 * Changed doc2000FreeWindow prototype to remove warnings.
 * Changed docPlusFreeWindow  prototype to remove warnings.
 * 
 *    Rev 1.7   Jan 17 2002 23:03:52   oris
 * Definitions for the new memory access routine mechanism
 *  - NDOC2window was moved from docsys.h
 *  - Add pointer to read back buffer when MTD_RECONSTRUCT_BBT and VERIFY_VOLUME compilation flags are defined.
 * Replaced flbuffer.h include with flflash.h
 * Changed win_io from unsigned to word.
 * Changed the use of vol (macro *pVol) to *flash in NFDC21thisVars.
 * 
 *    Rev 1.6   Sep 15 2001 23:47:50   oris
 * Added 128MB flash support
 * 
 *    Rev 1.5   Jul 13 2001 01:08:58   oris
 * Added readBackBuffer pointer for the VERIFY_WRITE Compilation flag.
 * 
 *    Rev 1.4   May 16 2001 21:21:14   oris
 * Change "data" named variables to flData to avoid name clashes.
 * 
 *    Rev 1.3   Apr 10 2001 16:43:40   oris
 * Added prototype of docSocketInit.
 * 
 *    Rev 1.2   Apr 01 2001 07:48:26   oris
 * Revised in order to support both  diskonchip 2000 family and doc plus family.
 * 
 *    Rev 1.1   Feb 07 2001 17:42:24   oris
 * removed MAX_FLASH_DEVICES_MDOC define since alone can support 16 chips
 *
 *    Rev 1.0   Feb 04 2001 12:26:10   oris
 * Initial revision.
 *
 */

/************************************************************************/
/*                                                                      */
/*                FAT-FTL Lite Software Development Kit                 */
/*                Copyright (C) M-Systems Ltd. 1995-2001                */
/*                                                                      */
/************************************************************************/
#ifndef NANDDEFS_H
#define NANDDEFS_H

#include "flflash.h"

typedef byte Reg8bitType;
typedef word Reg16bitType;

typedef struct {
#ifdef RAM_MTD
  unsigned short        pageSize;
  unsigned short        pageAndTailSize;
#endif /* RAM_MTD */
  unsigned short        vendorID;
  unsigned short        chipID;
  dword                 pageMask;        /* ...these............... */
  unsigned short        pageAreaSize;    /* .......variables....... */
  unsigned short        tailSize;        /* .............interleave */
  unsigned short        noOfBlocks;      /* total erasable blocks in flash device*/
  unsigned short        pagesPerBlock;
  unsigned char         currentFloor;    /*    0 .. totalFloors-1   */
  long                  floorSize;       /*    in bytes             */
  long                  floorSizeMask;
  byte                  floorSizeBits;
  byte                  if_cfg;          /* host access type        */
  unsigned short        flags;           /* bitwise: BIG_PAGE, SLOW_IO etc. */
  FLBuffer*             buffer;          /* buffer for map through buffer */
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASE) || defined(MTD_RECONSTRUCT_BBT) || defined(VERIFY_VOLUME))
  byte*                 readBackBuffer;  /* buffer for map through buffer */
#endif /* VERIFY_WRITE || VERIFY_ERASE || VERIFY_VOLUME */
  word                  win_io;          /* pointer to DOC CDSN_IO          */
  NDOC2window           win;             /* pointer to DOC memory window    */
} NFDC21Vars;

#define NFDC21thisVars   ((NFDC21Vars *) flash->mtdVars)
#define NFDC21thisWin    (NFDC21thisVars->win)
#define NFDC21thisIO     (NFDC21thisVars->win_io)
#define NFDC21thisBuffer (NFDC21thisVars->buffer->flData)

     /* Flash commands */

#define SERIAL_DATA_INPUT   0x80
#define READ_MODE           0x00
#define READ_MODE_2         0x50
#define RESET_FLASH         0xff
#define SETUP_WRITE         0x10
#define SETUP_ERASE         0x60
#define CONFIRM_ERASE       0xd0
#define READ_STATUS         0x70
#define READ_ID             0x90
#define SUSPEND_ERASE       0xb0
#define REGISTER_READ       0xe0

/* commands for moving flash pointer to areeas A,B or C of page */
typedef enum { AREA_A = READ_MODE, AREA_B = 0x1, AREA_C = READ_MODE_2 } PointerOp;

#define FAIL        0x01    /* error in block erase   */
#define EXTRA_LEN   8       /* In memory of 4MB chips */ 
#define SECTOR_EXTRA_LEN 16 

     /* Flash IDs*/

#define KM29N16000_FLASH    0xec64
#define KM29N32000_FLASH    0xece5
#define KM29V64000_FLASH    0xece6
#define KM29V128000_FLASH   0xec73
#define KM29V256000_FLASH   0xec75
#define KM29V512000_FLASH   0xec76

#define NM29N16_FLASH       0x8f64
#define NM29N32_FLASH       0x8fe5
#define NM29N64_FLASH       0x8fe6
#define TC5816_FLASH        0x9864
#define TC5832_FLASH        0x98e5
#define TC5864_FLASH        0x98e6
#define TC58128_FLASH       0x9873
#define TC58256_FLASH       0x9875
#define TC58512_FLASH       0x9876
#define TC581024_FLASH       0x9877

   /*******************************/
   /****   Exported routines   ****/
   /*******************************/

/* DiskOnChip 2000 family registration routines */
#ifndef MTD_STANDALONE
  extern FLBoolean checkWinForDOC(unsigned driveNo, NDOC2window memWinPtr);
#endif /* MTD_STANDALONE */
#ifndef MTD_FOR_EXB
  extern FLStatus flRegisterDOC2000(void);
  extern FLStatus flRegisterDOCSOC(dword lowAddress, dword highAddress);
#else
  FLStatus doc2000SearchForWindow(FLSocket * socket, dword lowAddress,
                                  dword highAddress);
  FLStatus doc2000Identify(FLFlash vol);
  void doc2000FreeWindow(FLSocket * socket);
#endif /* MTD_FOR_EXB */

/* DiskOnChip Plus family registration routines */ 
#ifndef MTD_STANDALONE
  extern FLBoolean checkWinForDOCPLUS(unsigned driveNo, NDOC2window memWinPtr);
  extern void docSocketInit(FLSocket vol);
#endif /* MTD_STANDALONE */
#ifndef MTD_FOR_EXB
  extern FLStatus flRegisterDOCPLUS(void);
  extern FLStatus flRegisterDOCPLUSSOC(dword lowAddress, dword highAddress);
#else
  FLStatus docPlusSearchForWindow(FLSocket * socket, dword lowAddress,
                                  dword highAddress);
  FLStatus docPlusIdentify(FLFlash vol);
  void docPlusFreeWindow(FLSocket * socket);
#endif /* MTD_FOR_EXB */

#endif /* NANDDEFS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\ntioctl.h ===
#ifndef _NTIOCTL_H_
#define _NTIOCTL_H_

#include <ntddk.h>
#include "flioctl.h"

#define FILE_DEVICE_TFFS_IOCTL		0x8000
#define ACCESS_DEVICE_TFFS_IOCTL	0x800


#define IOCTL_TFFS_GET_INFO										\
	CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_GET_INFO),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_DEFRAGMENT									\
	CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_DEFRAGMENT),		\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_WRITE_PROTECT								\
	CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_WRITE_PROTECT),	\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_MOUNT_VOLUME									\
	CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_MOUNT_VOLUME),		\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_FORMAT_VOLUME								\
	CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_FORMAT_VOLUME),	\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_BDK_OPERATION								\
	CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_BDK_OPERATION),	\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_DELETE_SECTORS								\
	CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_DELETE_SECTORS),	\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_READ_SECTORS									\
	CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_READ_SECTORS),		\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_WRITE_SECTORS								\
	CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_WRITE_SECTORS),	\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_NUMBER_OF_PARTITIONS									\
	CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_NUMBER_OF_PARTITIONS),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_CUSTOMER_ID									\
	CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_CUSTOMER_ID),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_EXTENDED_WRITE_IPL									\
CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_EXTENDED_WRITE_IPL),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_EXTENDED_ENVIRONMENT_VARIABLES									\
CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_EXTENDED_ENVIRONMENT_VARIABLES),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFSFL_UNIQUE_ID									\
CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_UNIQUE_ID),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFSFL_INQUIRE_CAPABILITIES									\
CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_INQUIRE_CAPABILITIES),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_DEEP_POWER_DOWN_MODE									\
CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_DEEP_POWER_DOWN_MODE),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_FORMAT_PHYSICAL_DRIVE									\
CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_FORMAT_PHYSICAL_DRIVE),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_BDTL_HW_PROTECTION									\
CTL_CODE( FILE_DEVICE_TFFS_IOCTL,												\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_BDTL_HW_PROTECTION),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_BINARY_HW_PROTECTION									\
CTL_CODE( FILE_DEVICE_TFFS_IOCTL,												\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_BINARY_HW_PROTECTION),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_OTP									\
CTL_CODE( FILE_DEVICE_TFFS_IOCTL,												\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_OTP),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_PLACE_EXB_BY_BUFFER									\
CTL_CODE( FILE_DEVICE_TFFS_IOCTL,												\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_PLACE_EXB_BY_BUFFER),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_EXTENDED_ENVIRONMENT_VARIABLES				\
CTL_CODE( FILE_DEVICE_TFFS_IOCTL,												\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_EXTENDED_ENVIRONMENT_VARIABLES),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_VERIFY_VOLUME				\
CTL_CODE( FILE_DEVICE_TFFS_IOCTL,												\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_VERIFY_VOLUME),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#endif /* _NTIOCTL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\osak.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/OSAK.H_V  $
 * 
 *    Rev 1.1   Apr 01 2001 07:46:32   oris
 * Updated copywrite notice
 * 
 *    Rev 1.0   Feb 04 2001 12:35:48   oris
 * Initial revision.
 *
 */

/************************************************************************/
/*                                                                      */
/*		DiskOnChip 2000 O/S Adaptation Kit			*/
/*		Copyright (C) M-Systems Ltd. 1998			*/
/*									*/
/************************************************************************/


#ifndef OSAK_H
#define OSAK_H

#include "blockdev.h"
#include "dosformt.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\nftllite.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/NFTLLITE.H_V  $
 * 
 *    Rev 1.6   Apr 15 2002 07:38:34   oris
 * Added the following fields to Anand record - 
 *  - verifyBuffer pointer.
 *  - invalidReplacement.
 * Added support for VERIFY_ERASED_SECTOR compilation flag.
 * 
 *    Rev 1.5   Jan 28 2002 21:26:20   oris
 * Removed the use of back-slashes in macro definitions.
 * 
 *    Rev 1.4   Jan 17 2002 23:04:34   oris
 * Added SECTORS_VERIFIED_PER_FOLDING - defines the number of sectors  verified per folding when using FL_OFF verify write mode
 * Added DOUBLE_MAX_UNIT_CHAIN instead of MAX_UNIT_CHAIN*2
 * Added MAX_FOLDING_TRIES - For improved power failures algorithm
 * Added S_CACHE_4_SECTORS_FREE for quicker cache initialization.
 * Added new macros :
 *  - distanceOf : Counting bit difference between 2 bytes.
 *  - isValidSectorFlags : one of the valid sector flags (not including  IGNORE)
 * Changed Anand record :
 *  - Added socketNo field storing the socket number used by the TL.
 *  - Changed RAM tables pointer to FAR1 for BIOS driver far malloc.
 *  - Changed FLFlash record to a pointer (TrueFFS now uses a single  FLFlash record per socket).
 *  - Added verifiedSectorNo and curSectorWrite fields for FL_OFF verify  write mode.
 * 
 *    Rev 1.3   May 16 2001 21:21:34   oris
 * Added the FL_ prefix to the following defines: MALLOC and FREE.
 * Changed wear level counter from 0xFF to 0xFFF0
 * Change "data" named variables to flData to avoid name clashes.
 * 
 *    Rev 1.2   Apr 01 2001 07:52:36   oris
 * copywrite notice.
 * Alligned left all # directives.
 * 
 *    Rev 1.1   Feb 14 2001 02:05:30   oris
 * Changed MAX_CHAIN_LENGTH to an environment variable.
 *
 *    Rev 1.0   Feb 05 2001 12:26:30   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/


#ifndef NFTLLITE_H
#define NFTLLITE_H

#include "flbuffer.h"
#include "flflash.h"
#include "fltl.h"

typedef long int ANANDVirtualAddress;
typedef unsigned char ANANDPhysUnit;
typedef unsigned short ANANDUnitNo;

#define ANAND_UNASSIGNED_ADDRESS     0xffffffffl
#define ANAND_SPARE_SIZE             16

#define UNIT_DATA_OFFSET             8
#define SECTOR_DATA_OFFSET           6
#define UNIT_TAILER_OFFSET           (SECTOR_SIZE + 8)
#define FOLD_MARK_OFFSET             (2 * SECTOR_SIZE + 8)

#define ERASE_MARK                   0x3c69

#ifdef ENVIRONMENT_VARS
#define SECTORS_VERIFIED_PER_FOLDING flSectorsVerifiedPerFolding
#define MAX_UNIT_CHAIN               flMaxUnitChain
#else
#define SECTORS_VERIFIED_PER_FOLDING 64
#define MAX_UNIT_CHAIN               20
#endif /* ENVIRONMENT_VARS */
#define DOUBLE_MAX_UNIT_CHAIN        64 /* Double max unit chain */
#define MAX_FOLDING_TRIES            20

#define ANAND_UNIT_FREE 0xff
#define UNIT_REPLACED   0x80
#define UNIT_COUNT      0x7f
#define UNIT_ORPHAN     0x10

#define UNIT_UNAVAIL    0x6a    /* Illegal count denoting unit not available */
#define UNIT_BAD_MOUNT  0x6b    /* Bad unit sign after mount */

#define UNIT_MAX_COUNT  0x40    /* Largest valid count */

#define IS_BAD(u)       ( u == UNIT_BAD_MOUNT )

#define UNIT_BAD_ORIGINAL 0

#define distanceOf(read, expected) (onesCount((byte)(read ^ expected)))
#define isValidSectorFlag(sectorFlag) ((sectorFlag==SECTOR_FREE)||(sectorFlag==SECTOR_USED)||(sectorFlag==SECTOR_DELETED))
#define countOf(unitNo)     (vol.physicalUnits[unitNo] & UNIT_COUNT)
#define isAvailable(unitNo) ((vol.physicalUnits[unitNo] == ANAND_UNIT_FREE) || (vol.physicalUnits[unitNo] == (ANAND_UNIT_FREE & ~UNIT_ORPHAN)) || (countOf(unitNo) <= UNIT_MAX_COUNT))
#define setUnavail(unitNo)  {vol.physicalUnits[unitNo] &= ~UNIT_COUNT; vol.physicalUnits[unitNo] |= UNIT_UNAVAIL; }
#define isReplaced(unitNo)  (vol.physicalUnits[unitNo] & UNIT_REPLACED)
#define setUnitCount(unitNo,unitCount) { vol.physicalUnits[unitNo] &= ~UNIT_COUNT; vol.physicalUnits[unitNo] |= (ANANDPhysUnit)unitCount; }
#define isLegalUnit(unitNo)  ((unitNo < vol.noOfUnits) || (unitNo == ANAND_NO_UNIT))

#define MAX_UNIT_SIZE_BITS      15
#define MORE_UNIT_BITS_MASK     3
#define ANAND_BAD_PERCENTAGE    2
#define ANAND_NO_UNIT           0xffff
#define ANAND_REPLACING_UNIT    0x8000

#define MAX_UNIT_NUM            (12 * 1024)


/* Block flags */

#define SECTOR_FREE             0xff
#define SECTOR_USED             0x55
#define SECTOR_IGNORE           0x11
#define SECTOR_DELETED          0x00


#ifdef NFTL_CACHE
/* values for 2-bit entries in Sector Flags cache */
#define S_CACHE_SECTOR_DELETED  0x00
#define S_CACHE_SECTOR_IGNORE   0x01
#define S_CACHE_SECTOR_USED     0x02
#define S_CACHE_SECTOR_FREE     0x03
#define S_CACHE_4_SECTORS_FREE  0xff
#endif /* NFTL_CACHE */


#define FOLDING_IN_PROGRESS     0x5555
#define FOLDING_COMPLETE        0x1111

#define ERASE_NOT_IN_PROGRESS   -1

#ifdef NFTL_CACHE
/* Unit Header cache entry, close relative of struct UnitHeader */
typedef struct {
  unsigned short virtualUnitNo;
  unsigned short replacementUnitNo;
} ucacheEntry;

#endif /* NFTL_CACHE */

/* erase record */
typedef struct {
  LEulong  eraseCount;
  LEushort eraseMark;
  LEushort eraseMark1;
} UnitTailer;

/* unit header  */
typedef struct {
  LEushort virtualUnitNo;
  LEushort replacementUnitNo;
  LEushort spareVirtualUnitNo;
  LEushort spareReplacementUnitNo;
} ANANDUnitHeader;

/* Medium Boot Record */

typedef struct {
  char      bootRecordId[6];          /* = "ANAND" */
  LEushort  noOfUnits;
  LEushort  bootUnits;
  Unaligned4 virtualMediumSize;
#ifdef EXTRA_LARGE
  unsigned char anandFlags;
#endif /* EXTRA_LARGE */
} ANANDBootRecord;

#ifndef FL_MALLOC

#define ANAND_HEAP_SIZE    (0x100000l / ASSUMED_NFTL_UNIT_SIZE) * (sizeof(ANANDUnitNo) + sizeof(ANANDPhysUnit)) * MAX_VOLUME_MBYTES

#ifdef NFTL_CACHE
#define U_CACHE_SIZE    ((MAX_VOLUME_MBYTES * 0x100000l) / ASSUMED_NFTL_UNIT_SIZE)
#define S_CACHE_SIZE    ((MAX_VOLUME_MBYTES * 0x100000l) / (SECTOR_SIZE * 4))
#endif

#endif /* FL_MALLOC */

#define WLnow           0xfff0

typedef struct {
  unsigned short alarm;
  ANANDUnitNo currUnit;
} WLdata;

struct tTLrec{
  byte            socketNo;
  FLBoolean       badFormat;             /* true if TFFS format is bad  */

  ANANDUnitNo     orgUnit,               /* Unit no. of boot record     */
                  spareOrgUnit;          /* ... and spare copy of it    */
  ANANDUnitNo     freeUnits;             /* Free units on media         */
  unsigned int    erasableBlockSizeBits; /* log2 of erasable block size */
  ANANDUnitNo     noOfVirtualUnits;
  ANANDUnitNo     noOfTransferUnits;
  unsigned long   unitOffsetMask;        /* = 1 << unitSizeBits - 1 */
  unsigned int    sectorsPerUnit;

  ANANDUnitNo     noOfUnits,
                  bootUnits;
  unsigned int    unitSizeBits;
  SectorNo        virtualSectors;

  ANANDUnitNo     roverUnit,   /* Starting point for allocation search  */
                  countsValid; /* Number of units with valid unit count */
  ANANDPhysUnit FAR1 *physicalUnits;    /* unit table by physical no. */
  ANANDUnitNo   FAR1 *virtualUnits;     /* unit table by logical no.  */

#ifdef NFTL_CACHE
  ucacheEntry   FAR1 *ucache;            /* Unit Header cache  */
  byte          FAR1 *scache;            /* Sector Flags cache */
#endif

  SectorNo        mappedSectorNo;
  const void FAR0 *mappedSector;
  CardAddress     mappedSectorAddress;
#if (defined(VERIFY_WRITE) || defined(VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
  SectorNo        verifiedSectorNo;   /* Largest sector verified so far */
  SectorNo        curSectorWrite;
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */

  /* Accumulated statistics. */
  long int        sectorsRead,
                  sectorsWritten,
                  sectorsDeleted,
                  parasiteWrites,
                  unitsFolded;

  FLFlash         *flash;
  FLBuffer        *buffer;
  dword           *verifyBuffer;  /* Pointer to socket verify buffer */

#ifndef FL_MALLOC
  char            heap[ANAND_HEAP_SIZE];
#ifdef NFTL_CACHE
  ucacheEntry     ucacheBuf[U_CACHE_SIZE];
  unsigned char   scacheBuf[S_CACHE_SIZE];
#endif
#endif /* FL_MALLOC */

  WLdata          wearLevel;
  unsigned long   eraseSum;
  ANANDUnitNo     invalidReplacement; /* Unit with bad header - for mount */
};

typedef TLrec Anand;

#define nftlBuffer  vol.buffer->flData

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\nfdc2048.c ===
/*
 * $Log:   P:/user/amir/lite/vcs/nfdc2048.c_v  $
 *
 *    Rev 1.28   19 Oct 1997 15:41:54   danig
 * Changed tffscpy16 and tffsset16 for far pointers &
 * cast to FAR0 in mapContInterface
 *
 *    Rev 1.27   06 Oct 1997 18:37:34   ANDRY
 * no COBUX
 *
 *    Rev 1.26   06 Oct 1997 18:04:34   ANDRY
 * 16-bit access only for interleave 2 cards, COBUX
 *
 *    Rev 1.25   05 Oct 1997 12:02:32   danig
 * Support chip ID 0xEA
 *
 *    Rev 1.24   10 Sep 1997 16:14:08   danig
 * Got rid of generic names
 *
 *    Rev 1.23   08 Sep 1997 17:47:00   danig
 * fixed setAddress for big-endian
 *
 *    Rev 1.22   04 Sep 1997 13:59:44   danig
 * Debug messages
 *
 *    Rev 1.21   31 Aug 1997 15:18:04   danig
 * Registration routine return status
 *
 *    Rev 1.20   28 Aug 1997 17:47:08   danig
 * Buffer\remapped per socket
 *
 *    Rev 1.19   28 Jul 1997 15:10:36   danig
 * setPowerOnCallback & moved standard typedefs to flbase.h
 *
 *    Rev 1.18   24 Jul 1997 18:04:12   amirban
 * FAR to FAR0
 *
 *    Rev 1.17   21 Jul 1997 18:56:00   danig
 * nandBuffer static
 *
 *    Rev 1.16   20 Jul 1997 18:21:14   danig
 * Moved vendorID and chipID to Vars
 *
 *    Rev 1.15   20 Jul 1997 17:15:06   amirban
 * Added Toshiba 8MB
 *
 *    Rev 1.14   07 Jul 1997 15:22:26   amirban
 * Ver 2.0
 *
 *    Rev 1.13   02 Jul 1997 14:59:22   danig
 * More wait for socket to power up
 *
 *    Rev 1.12   01 Jul 1997 13:39:54   danig
 * Wait for socket to power up
 *
 *    Rev 1.11   22 Jun 1997 18:34:32   danig
 * Documentation
 *
 *    Rev 1.10   12 Jun 1997 17:22:24   amirban
 * Allow LONG extra read/writes
 *
 *    Rev 1.9   08 Jun 1997 19:18:06   danig
 * BIG_PAGE & FULL_PAGE moved to flash.h
 *
 *    Rev 1.8   08 Jun 1997 17:03:40   amirban
 * Fast Toshiba and power on callback
 *
 *    Rev 1.7   05 Jun 1997 12:31:38   amirban
 * Write corrections, and att reg changes
 *
 *    Rev 1.6   03 Jun 1997 18:45:14   danig
 * powerUp()
 *
 *    Rev 1.5   01 Jun 1997 13:42:52   amirban
 * Rewrite of read/write extra + major reduction
 *
 *    Rev 1.4   25 May 1997 16:41:38   amirban
 * Bg-endian, Toshiba fix & simplifications
 *
 *    Rev 1.3   18 May 1997 17:34:50   amirban
 * Use 'dataError'
 *
 *    Rev 1.2   23 Apr 1997 11:02:14   danig
 * Update to TFFS revision 1.12
 *
 *    Rev 1.1   15 Apr 1997 18:48:02   danig
 * Fixed FAR pointer issues.
 *
 *    Rev 1.0   08 Apr 1997 18:29:28   danig
 * Initial revision.
 */

/************************************************************************/
/*                                                                      */
/*              FAT-FTL Lite Software Development Kit                   */
/*              Copyright (C) M-Systems Ltd. 1995-1997                  */
/*                                                                      */
/************************************************************************/

#include "ntddk.h"

#include "flflash.h"
#include "reedsol.h"

#define NFDC2048        /* Support NFDC2048 ASIC controller */

#define MAX_FLASH_DEVICES   16

#define PAGES_PER_BLOCK     16          /* 16 pages per block on a single chip*/
#define SYNDROM_BYTES       6            /* Number of syndrom bytes: 5 + 1 parity*/

/* Flash IDs*/
#define KM29N16000_FLASH    0xec64
#define KM29N32000_FLASH    0xece5
#define KM29V64000_FLASH    0xece6
#define KM29V128000_FLASH   0xec73
#define KM29V256000_FLASH   0xec75
#define NM29N16_FLASH       0x8f64
#define NM29N32_FLASH       0x8fe5
#define NM29N64_FLASH       0x8fe6
#define TC5816_FLASH        0x9864
#define TC5832_FLASH        0x98e5
#define TC5864_FLASH        0x98e6
#define TC58128_FLASH       0x9873
#define TC58256_FLASH       0x9875

/* Flash commands:*/
#define SERIAL_DATA_INPUT   0x80
#define READ_MODE           0x00
#define READ_MODE_2         0x50
#define RESET_FLASH         0xff
#define SETUP_WRITE         0x10
#define SETUP_ERASE         0x60
#define CONFIRM_ERASE       0xd0
#define READ_STATUS         0x70
#define READ_ID             0x90
#define SUSPEND_ERASE       0xb0
#define REGISTER_READ       0xe0

/* commands for moving flash pointer to areeas A,B or C of page*/
typedef enum  { AREA_A = READ_MODE, AREA_B = 0x1, AREA_C = READ_MODE_2 } PointerOp;

typedef union {  USHORT w ; UCHAR b ;  } WordByte;


        /*
             Memory window to cards common memory    
          */

typedef struct
{
  volatile WordByte             signals;            /* CDSN control register*/

          #define CE                  0x01
          #define CLE                 0x02
          #define ALE                 0x04
          #define NOT_WP              0x08
          #define RB                  0x80

          #define FAIL                0x01
          #define SUSPENDED           0x20
          #define READY               0x40
          #define NOT_PROTECTED       0x80

           UCHAR        fillerA[1024 - sizeof(WordByte)];
  volatile LEushort             deviceSelector;
  volatile WordByte             eccConfig;  /* EDC configuration register*/

        #define TOGGLE    0x04              /* Read*/
#ifdef NFDC2048
        #define ECC_RST   0x04              /* Write*/
        #define ECC_EN    0x08              /* Read / Write*/
        #define PAR_DIS   0x10              /* Read / Write*/
        #define ECC_RW    0x20              /* Read / Write*/
        #define ECC_RDY   0x40              /* Read */
        #define ECC_ERROR 0x80              /* Read*/

  volatile USHORT       syndrom[3];
           UCHAR        fillerC[1024-10];   /* 1kbytes minus 10 bytes*/
#else
           UCHAR        fillerC[1024-4];    /* 1kbytes minus 3 words */
#endif  /* NFDC2048 */
  volatile WordByte             io[1024];
} ContComWin;

/* #defines for writing to ContComWin.eccConfig */  /* HOOK - added */
#define SET_ECC_CONFIG(win,val) tffsWriteByteFlash(&((win)->eccConfig.b), (UCHAR)(val))
#define CHK_ECC_ERROR(win)      (tffsReadByteFlash(&((win)->eccConfig.b)) & (UCHAR)ECC_ERROR)

typedef ContComWin FAR0 * Interface;

#define  DBL(x)   ( (UCHAR)(x) * 0x101u )
#define  SECOND_TRY 0x8000

#ifdef NFDC2048

/* Controller registers: Addresses & values */

#define ATTRIBUTE_MEM_START 0x8000000L  /* Attribute memory starts at 128MB    */

/* Controller configuration register */
#define CONFIG1         ATTRIBUTE_MEM_START + 0x3ffc

        #define PWR_DN     0x01              /* Read / Write*/
        #define PWR_DN2    0x02              /* Read / Write*/
        #define STOP_CDSN  0x04              /* Read / Write*/
        #define STOP_CDSNS 0x08              /* Read / Write*/
        #define C_CDSN     0x10              /* Read / Write*/
        #define R_CDSN     0x20              /* Read / Write*/
        #define WP_C       0x40              /* Read / Write*/
        #define WP_A       0x80              /* Read / Write*/

/* board's jumper settings*/
#define JUMPERS         ATTRIBUTE_MEM_START + 0x3ffe

        #define JMPER_INLV      0x08
        #define JMPER_CDSNS     0x10
        #define JMPER_EXT_CIS   0x20
        #define JMPER_LDR_MASK  0x40
        #define JMPER_MAX_MODE  0x80

/* PCMCIA register #0*/
#define CONFIG_OPTION   ATTRIBUTE_MEM_START + 0x4000

        #define CONFIGIDX 0x3F              /* Read / Write*/
        #define SREST     0x80              /* Read / Write*/

/* PCMCIA register #1*/
#define CARD_CONFIG     ATTRIBUTE_MEM_START + 0x4002

        #define PWRDWN    0x04              /* Read / Write*/

#else

#define INLV 2          /* Must define interleaving statically */

#endif /* NFDC2048 */

/* customization for this MTD*/
/*#define MULTI_ERASE  */   /* use multiple block erase feature*/
#define USE_EDC             /* use Error Detection /Correction Code */
/* #define VERIFY_AFTER_WRITE */

typedef struct {
  USHORT        vendorID;
  USHORT        chipID;
  USHORT        pageSize ;              /* all....................*/
  USHORT        pageMask ;              /* ...these...............*/
  USHORT        pageAreaSize ;          /* .......variables.......*/
  USHORT        tailSize ;              /* .............interleave*/
  USHORT        noOfBlocks ;            /* total erasable blocks in flash device*/
  USHORT        pagesPerBlock;          /* number of pages per block */
  FLBuffer              *buffer;                /* buffer for map through buffer */
} Vars;

Vars mtdVars_nfdc2048[SOCKETS];

#define thisVars   ((Vars *) vol.mtdVars)
#define thisBuffer (thisVars->buffer->flData)

                    /*
                        Auxiliary methods  
                      */

/*----------------------------------------------------------------------*/
/*              t f f s c p y 1 6                                       */
/*                                                                      */
/* Move data in 16-bit words.                                           */
/*                                                                      */
/* Parameters:                                                          */
/*      dst             : destination buffer                            */
/*      src             : source buffer                                 */
/*      len             : bytes to move                                 */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID tffscpy16fromMedia (UCHAR FAR0       *dst,
                       const UCHAR FAR0 *src,
                       LONG                      len)
{
  register LONG i;
  USHORT FAR0 *dstPtr = (USHORT FAR0 *) dst;
  const USHORT FAR0 *srcPtr = (USHORT FAR0 *) src;

  /* move data in 16-bit words */
  for (i = len;  i > 0; i -= 2)
    *dstPtr++ = tffsReadWordFlash(srcPtr++);
}

VOID tffscpy16toMedia (UCHAR FAR0       *dst,
                       const UCHAR FAR0 *src,
                       LONG                      len)
{
  register LONG i;
  USHORT FAR0 *dstPtr = (USHORT FAR0 *) dst;
  const USHORT FAR0 *srcPtr = (USHORT FAR0 *) src;

  /* move data in 16-bit words */
  for (i = len;  i > 0; i -= 2)
    tffsWriteWordFlash(dstPtr++,*srcPtr++);
}


/*----------------------------------------------------------------------*/
/*              t f f s s e t 1 6                                       */
/*                                                                      */
/* Set data buffer in 16-bit words.                                     */
/*                                                                      */
/* Parameters:                                                          */
/*      dst             : destination buffer                            */
/*      val             : byte value tofill the buffer                  */
/*      len             : setination buffer size in bytes               */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID tffsset16 (UCHAR FAR0 *dst,
                       UCHAR      val,
                       LONG                len)
{
  register USHORT  wval = ((USHORT)val << 8) | val;
  register LONG   i = 0;
  USHORT FAR0 *dstPtr;

  /* set data in 16-bit words */
  for (i = 0;  i < len - 1; i += 2) {
    dstPtr = (USHORT FAR0 *)addToFarPointer(dst, i);
    tffsWriteWordFlash(dstPtr,wval);
  }

  /* set last byte (if any) */
  if (len & 1) {
    dstPtr = (USHORT FAR0 *)addToFarPointer(dst, len - 1);
    tffsWriteByteFlash(dstPtr,wval);
  }
}



#ifdef NFDC2048

/*----------------------------------------------------------------------*/
/*                      r e a d S y n d r o m                           */
/*                                                                      */
/* Read ECC syndrom and swap words to prepare it for writing to flash.  */
/*                                                                      */
/* Parameters:                                                          */
/*      Interface       : Pointer to window.                            */
/*      to              : buffer to read to.                            */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID readSyndrom_nfdc2048( Interface interface, USHORT *to )
{
  to[0] = tffsReadWordFlash(&(interface->syndrom[2]));
  to[1] = tffsReadWordFlash(&(interface->syndrom[1]));
  to[2] = tffsReadWordFlash(&(interface->syndrom[0]));
}

#ifdef USE_EDC

/*----------------------------------------------------------------------*/
/*                      r e a d S y n d r o m O n S y n d r o m         */
/*                                                                      */
/* Read ECC syndrom.                                                    */
/*                                                                      */
/* Parameters:                                                          */
/*      Interface       : Pointer to window.                            */
/*      to              : buffer to read to.                            */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID readSyndromOnSyndrom ( Interface interface, USHORT *to )
{
  to[0] = tffsReadWordFlash(&(interface->syndrom[0]));
  to[1] = tffsReadWordFlash(&(interface->syndrom[1]));
  to[2] = tffsReadWordFlash(&(interface->syndrom[2]));
}

#endif  /* USE_EDC */


              /*
                  Miscellaneous routines   
                */

/*----------------------------------------------------------------------*/
/*                      g e t A t t R e g                               */
/*                                                                      */
/* Get ASIC register residing in card's Attribute memory.               */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      address         : Address of register.                          */
/*                                                                      */
/* Returns:                                                             */
/*      Value of register.                                              */
/*                                                                      */
/*----------------------------------------------------------------------*/

UCHAR getAttReg(FLFlash vol, CardAddress reg)
{
  return (UCHAR) (tffsReadByteFlash((USHORT FAR0 *) flMap(vol.socket,reg)));
}



/*----------------------------------------------------------------------*/
/*                      s e t A t t R e g                               */
/*                                                                      */
/* Set ASIC register residing in card's Attribute memory.               */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      address         : Address of register.                          */
/*      value           : Value to set                                  */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID setAttReg(FLFlash vol, CardAddress reg, UCHAR value)
{
  tffsWriteWordFlash((USHORT FAR0 *) flMap(vol.socket,reg), DBL(value));
}


/*----------------------------------------------------------------------*/
/*                      p o w e r U p                                   */
/*                                                                      */
/* Power up the controller.                                             */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID powerUp(VOID *pVol)
{
  flDelayMsecs(1);
  setAttReg ((FLFlash *) pVol, CONFIG1, WP_C);  /* Power up the controller */
}

#endif  /* NFDC2048 */


/*----------------------------------------------------------------------*/
/*                      m a p C o n t I n t e r f a c e                 */
/*                                                                      */
/* Select flash device.                                                 */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      address         : Address in flash.                             */
/*                                                                      */
/* Returns:                                                             */
/*      Pointer to the mapped window.                                   */
/*                                                                      */
/*----------------------------------------------------------------------*/

Interface mapContInterface(FLFlash vol, CardAddress address)
{
  Interface interface = (Interface) flMap(vol.socket,(CardAddress)0);
  LEushort  tmp;

  toLE2(*((LEushort FAR0 *) &tmp), (USHORT)(address / (vol.chipSize * vol.interleaving)));

  /* Select flash device with 16-bit write */
  tffsWriteWordFlash(((USHORT FAR0 *) &interface->deviceSelector), *((USHORT *) &tmp));

  return interface;
}


/*----------------------------------------------------------------------*/
/*                      w a i t F o r R e a d y                         */
/*                                                                      */
/* Wait for the selected device to be ready.                            */
/*                                                                      */
/* Parameters:                                                          */
/*      Interface       : Pointer tot the window.                       */
/*                                                                      */
/* Returns:                                                             */
/*      TRUE if device is ready, FALSE if timeout error.                */
/*                                                                      */
/*----------------------------------------------------------------------*/

FLBoolean waitForReady_nfdc2048 (Interface interface)
{
  LONG i;

  for( i = 0;  i < 20000;  i++)
  {
    if( (~(tffsReadWordFlash(&(interface->signals.w))) & DBL(RB)) == 0)
      return TRUE ;                     /* ready at last..*/
    flDelayMsecs(1);
  }

  DEBUG_PRINT(("Debug: timeout error in NFDC 2048.\n"));

  return FALSE;                       /* timeout error  */
}



/*----------------------------------------------------------------------*/
/*                        m a k e C o m m a n d                         */
/*                                                                      */
/* Set Page Pointer to Area A, B or C in page.                          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      cmd     : receives command relevant to area                     */
/*      addr    : receives the address to the right area.               */
/*      modes   : mode of operation (EXTRA ...)                         */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID makeCommand_nfdc2048 (FLFlash vol, PointerOp *cmd, CardAddress *addr , LONG modes )
{
  USHORT offset;

  if ( !(vol.flags & BIG_PAGE) ) {
    if (modes & EXTRA) {
      offset = (USHORT) (*addr & (SECTOR_SIZE - 1));
      *cmd = AREA_C;
      if (vol.interleaving == 1) {
        if (offset < 8)         /* First half of extra area */
          *addr += 0x100;       /* ... assigned to 2nd page */
        else                    /* Second half of extra area */
          *addr -= 8;           /* ... assigned to 1st page */
      }
    }
    else
      *cmd = AREA_A;
  }
  else {
    offset = (USHORT)(*addr) & thisVars->pageMask ;   /* offset within device Page */

    *addr -= offset;            /* align at device Page*/

    if (vol.interleaving == 2 && offset >= 512)
      offset += 16;             /* leave room for 1st extra area */
    if (modes & EXTRA)
      offset += SECTOR_SIZE;

    if ( offset < thisVars->pageAreaSize )  /* starting in area A*/
      *cmd = AREA_A ;
    else if ( offset < thisVars->pageSize )    /* starting in area B */
      *cmd = AREA_B ;
    else                                  /* got into area C*/
      *cmd = AREA_C ;

    offset &= (thisVars->pageAreaSize - 1) ;          /* offset within area of device Page*/
    *addr += offset ;
  }
}



/*----------------------------------------------------------------------*/
/*                        c o m m a n d                                 */
/*                                                                      */
/* Latch command byte to selected flash device.                         */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      Interface       : Pointer to window.                            */
/*      code            : Command to set.                               */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID command2048(FLFlash vol, Interface interface, UCHAR code)
{
  tffsWriteWordFlash(&(interface->signals.w), DBL( CLE | NOT_WP | CE ));

  if ( vol.interleaving == 1 ) {                         /* 8-bit */
      tffsWriteByteFlash(&(interface->io[0].b), code);
  } else {                                             /* 16-bit */
      tffsWriteWordFlash(&(interface->io[0].w), DBL( code ));
  }

  tffsWriteWordFlash(&(interface->signals.w), DBL(       NOT_WP ));
}


/*----------------------------------------------------------------------*/
/*                        s e t A d d r e s s                           */
/*                                                                      */
/* Latch address to selected flash device.                              */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      Interface       : Pointer to window.                            */
/*      address         : address to set.                               */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID setAddress2048(FLFlash vol, Interface interface, CardAddress address )
{
  address &= (vol.chipSize * vol.interleaving - 1) ;  /* address within flash device*/
  address /= vol.interleaving ;                         /* .................... chip */

  if ( vol.flags & BIG_PAGE )
  {
    /*
       bits  0..7     stays as are
       bit      8     is thrown away from address
       bits 31..9 ->  bits 30..8
    */
    address = ((address >> 9) << 8)  |  ((UCHAR)address) ;
  }

  tffsWriteWordFlash(&(interface->signals.w), DBL(ALE | NOT_WP | CE));

  /* send address to flash in the following sequence: */
  /*      bits  7...0 first                           */
  /*      bits 15...8 next                            */
  /*      bits 23..16 finally                         */
  if ( vol.interleaving == 1 )
  {
    tffsWriteByteFlash(&(interface->io[0].b), (UCHAR)address );
    tffsWriteByteFlash(&(interface->io[0].b), (UCHAR)(address >> 8));
    tffsWriteByteFlash(&(interface->io[0].b), (UCHAR)(address >> 16));
  }
  else
  {
    tffsWriteWordFlash(&(interface->io[0].w), (USHORT)DBL(address));
    tffsWriteWordFlash(&(interface->io[0].w), (USHORT)DBL(address >> 8));
    tffsWriteWordFlash(&(interface->io[0].w), (USHORT)DBL(address >> 16));
  }

  tffsWriteWordFlash(&(interface->signals.w), DBL(      NOT_WP | CE));
}


/*----------------------------------------------------------------------*/
/*                        r e a d C o m m a n d                         */
/*                                                                      */
/* Issue read command.                                                  */
/*                                                                      */
/* Parametes:                                                           */
/*      vol             : Pointer identifying drive                     */
/*      Interface       : Pointer to window.                            */
/*      cmd             : Command to issue (according to area).         */
/*      addr            : address to read from.                         */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID readCommand2048 (FLFlash vol, Interface interface, PointerOp  cmd, CardAddress addr)
{
  command2048 (&vol, interface, (UCHAR) cmd) ;       /* move flash pointer to respective area of the page*/
  setAddress2048 (&vol, interface, addr) ;

  waitForReady_nfdc2048(interface) ;
}


/*----------------------------------------------------------------------*/
/*                        w r i t e C o m m a n d                       */
/*                                                                      */
/* Issue write command.                                                 */
/*                                                                      */
/* Parametes:                                                           */
/*      vol             : Pointer identifying drive                     */
/*      interface       : Pointer to window.                            */
/*      cmd             : Command to issue (according to area).         */
/*      addr            : address to write to.                          */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID writeCommand2048 (FLFlash vol, Interface interface, PointerOp  cmd, CardAddress addr)
{
  if (vol.flags & FULL_PAGE) {
    command2048 (&vol, interface, RESET_FLASH); /* Clear page buffer */
    waitForReady_nfdc2048(interface);
  }
  command2048 (&vol, interface, (UCHAR) cmd) ;       /* move flash pointer to respective area of the page  */
  command2048 (&vol, interface, SERIAL_DATA_INPUT);       /* start data loading for write  */
  setAddress2048 (&vol, interface, addr) ;
}


/*----------------------------------------------------------------------*/
/*                        r e a d S t a t u s                           */
/*                                                                      */
/* Read status of selected flash device.                                */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      interface       : Pointer to window.                            */
/*                                                                      */
/* Returns:                                                             */
/*      Chip status.                                                    */
/*                                                                      */
/*----------------------------------------------------------------------*/

USHORT readStatus2048(FLFlash vol, Interface interface)
{
  USHORT chipStatus ;

  command2048(&vol, interface, READ_STATUS);

  tffsWriteWordFlash(&(interface->signals.w), DBL( NOT_WP | CE ));

  if ( vol.interleaving == 1 )                    /* 8-bit*/
    chipStatus = DBL(tffsReadByteFlash(&(interface->io[0].b)));
  else                                              /* 16-bit  */
    chipStatus = tffsReadWordFlash(&(interface->io[0].w));

  tffsWriteWordFlash(&(interface->signals.w), DBL( NOT_WP ));

  return chipStatus;
}


/*----------------------------------------------------------------------*/
/*                        w r i t e E x e c u t e                       */
/*                                                                      */
/* Execute write.                                                       */
/*                                                                      */
/* Parametes:                                                           */
/*      vol             : Pointer identifying drive                     */
/*      interface       : Pointer to window.                            */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed.               */
/*                                                                      */
/*----------------------------------------------------------------------*/

FLStatus writeExecute2048 (FLFlash vol, Interface interface)
{
  command2048 (&vol, interface, SETUP_WRITE);             /* execute page program*/
  if (!waitForReady_nfdc2048(interface)) {
    return flTimedOut;
  }
  if( readStatus2048(&vol, interface) & DBL(FAIL) )
    return flWriteFault ;

  return flOK ;
}



/*----------------------------------------------------------------------*/
/*                        r e a d O n e S e c t o r                     */
/*                                                                      */
/* Read up to one 512-byte block from flash.                            */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      address : Address to read from.                                 */
/*      buffer  : buffer to read to.                                    */
/*      length  : number of bytes to read (up to sector size).          */
/*      modes   : EDC flag etc.                                         */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus: 0 on success, otherwise failed.                       */
/*                                                                      */
/*----------------------------------------------------------------------*/

FLStatus readOneSector_nfdc2048 (FLFlash vol,
                             CardAddress address,  /* starting flash address*/
                             CHAR FAR1 *buffer,     /* target buffer */
                             LONG length,           /* bytes to read */
                             LONG modes)            /* EDC flag etc.*/
{
  FLStatus  status = flOK;
  PointerOp   cmd;
  CardAddress addr  = address ;

  Interface interface = mapContInterface(&vol, address);  /* select flash device */


           /* move flash pointer to areas A,B or C of page*/

  makeCommand_nfdc2048 (&vol, &cmd, &addr, modes) ;

  readCommand2048 (&vol, interface, cmd, addr);

#ifdef NFDC2048
  if(modes & EDC) {
      SET_ECC_CONFIG(interface, ECC_RST | ECC_EN); /*ECC reset and ON for read*/
  }
#endif  /* NFDC2048 */

  if ((vol.interleaving == 1) && !(vol.flags & BIG_PAGE) )        /* 8-bit */
  {
              /* read up to two pages separately, starting page.. */

    LONG toFirstPage, toSecondPage;

    toFirstPage = (cmd == AREA_C ? 8 : 0x100) -
                    ((USHORT)address & (cmd == AREA_C ? 7 : 0xff));
    if (toFirstPage > length)
      toFirstPage = length;
    toSecondPage = length - toFirstPage ;

    tffscpy16fromMedia ((UCHAR*)buffer, (const UCHAR FAR0 *) interface->io, toFirstPage ) ;

    if ( toSecondPage > 0 )
    {
              /* next page*/

      readCommand2048 (&vol, interface, AREA_A, address + toFirstPage) ;

      tffscpy16fromMedia( (UCHAR*)(buffer + toFirstPage),
                 (const UCHAR FAR0 *) interface->io,
                 toSecondPage ) ;
    }
  }
  else                            /* interleaving == 2 so 16-bit read*/
    tffscpy16fromMedia( (UCHAR*)buffer, (const UCHAR FAR0 *) interface->io, length );

#ifdef NFDC2048
  if( modes & EDC )
  {
    UCHAR    extraBytes[SYNDROM_BYTES];
          /* read syndrom to let it through the ECC unit*/

    SET_ECC_CONFIG(interface, ECC_EN | PAR_DIS); /* parity off in ECC*/

    tffscpy16fromMedia( extraBytes, (const UCHAR FAR0 *) interface->io, SYNDROM_BYTES ) ;

    if( CHK_ECC_ERROR(interface) )             /* ECC error*/
    {
      if( (vol.interleaving == 1) && !(vol.flags & BIG_PAGE) )
        {  /* HOOK : make ECC working on 2M /INLV 1 */ }
      else
      {
#ifdef USE_EDC
                  /* try to fix ECC error*/

        if ( modes & SECOND_TRY )             /* 2nd try*/
        {
          UCHAR syndrom[SYNDROM_BYTES];

                  /* read syndrom-on-syndrom from ASIC*/

          readSyndromOnSyndrom(interface, (USHORT*)syndrom );

          if (flCheckAndFixEDC(buffer, (CHAR FAR1 *)syndrom, vol.interleaving == 2) != NO_EDC_ERROR) {
            DEBUG_PRINT(("Debug: ECC error in NFDC 2048.\n"));
            status = flDataError;
          }
        }
        else                                  /* 1st try - try once more*/
        {
          SET_ECC_CONFIG(interface,  PAR_DIS); /* reset ECC*/

          return  readOneSector_nfdc2048(&vol, address, buffer, length, modes | SECOND_TRY ) ;
        }
#endif /* USE_EDC*/
      }
    }

    SET_ECC_CONFIG(interface,  PAR_DIS);      /* ECC off*/
  }
#endif  /* NFDC2048 */

  interface->signals.w = DBL(NOT_WP) ;

  return status;
}



/*----------------------------------------------------------------------*/
/*                        w r i t e O n e S e c t o r                   */
/*                                                                      */
/* Write data in one 512-byte block to flash.                           */
/* Assuming that EDC mode never requested on partial block writes.      */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      address : Address of sector to write to.                        */
/*      buffer  : buffer to write from.                                 */
/*      length  : number of bytes to write (up to sector size).         */
/*      modes   : OVERWRITE, EDC flags etc.                             */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus: 0 on success, otherwise failed.                       */
/*                                                                      */
/*----------------------------------------------------------------------*/

FLStatus writeOneSector_nfdc2048(FLFlash vol,
                             CardAddress address,    /* target flash addres  */
                             const CHAR FAR1 *buffer, /* source RAM buffer   */
                             LONG length,             /* bytes to write (up to BLOCK) */
                             LONG modes)              /* OVERWRITE, EDC flags etc.  */
{
  FLStatus    status;
  PointerOp cmd;

  Interface interface = mapContInterface(&vol, address);  /* select flash device*/

  if (flWriteProtected(vol.socket))
    return flWriteProtect;

  /* move flash pointer to areas A,B or C of page  */

  makeCommand_nfdc2048 (&vol, &cmd, &address, modes) ;

  if ((vol.flags & FULL_PAGE) && cmd == AREA_B) {
    ULONG prePad = 2 + ((USHORT) address & thisVars->pageMask);

    writeCommand2048(&vol, interface, AREA_A, address + thisVars->pageAreaSize - prePad);
    tffsset16( (UCHAR FAR0 *) interface->io, 0xff, prePad);
  }
  else
    writeCommand2048(&vol, interface, cmd, address);

#ifdef NFDC2048
  if (modes & EDC)
    SET_ECC_CONFIG(interface, ECC_EN | ECC_RW); /* ECC ON for write*/
#endif

           /* load data and syndrom*/

  if( (vol.interleaving == 1) && !(vol.flags & BIG_PAGE) )    /* 8-bit*/
  {
    LONG toFirstPage, toSecondPage ;
                    /* write up to two pages separately*/

    toFirstPage = (modes & EXTRA ? 8 : 0x100) -
                    ((USHORT)address & (modes & EXTRA ? 7 : 0xff));
    if (toFirstPage > length)
      toFirstPage = length;
    toSecondPage = length - toFirstPage ;

    tffscpy16toMedia( (UCHAR FAR0 *) interface->io,            /* user data */
                (const UCHAR *)buffer,
                toFirstPage);

    if ( toSecondPage > 0 )
    {
      checkStatus( writeExecute2048(&vol, interface) ) ;          /* done with 1st page  */

      writeCommand2048(&vol, interface, AREA_A, address + toFirstPage);
                                                 /* user data*/
      tffscpy16toMedia( (UCHAR FAR0 *) interface->io,
                  (const UCHAR *)(buffer + toFirstPage),
                  toSecondPage);
    }
  }
  else                                                  /* 16-bit*/
    tffscpy16toMedia( (UCHAR FAR0 *) interface->io,             /* user data*/
               (const UCHAR *)buffer,
               length );

  if(modes & EDC)
  {
    USHORT extraBytes[SYNDROM_BYTES / sizeof(USHORT) + 1];
               /* Read the ECC syndrom*/

#ifdef NFDC2048
    tffsWriteWordFlash(&(interface->signals.w), DBL(NOT_WP));
    SET_ECC_CONFIG(interface, ECC_EN | PAR_DIS | ECC_RW); /* ECC parity off*/

    readSyndrom_nfdc2048( interface, (USHORT*)extraBytes) ;

               /* Write ECC syndrom and ANAND mark to the tail*/

    SET_ECC_CONFIG(interface, PAR_DIS);                   /* ECC off*/
    interface->signals.w = DBL(NOT_WP | CE);
#else
    extraBytes[0] = extraBytes[1] = extraBytes[2] = 0xffff;
#endif  /* NFDC2048 */

    extraBytes[SYNDROM_BYTES / sizeof(USHORT)] = 0x5555;        /* Anand mark */

    tffscpy16toMedia((UCHAR FAR0 *) interface->io, (const UCHAR *)extraBytes,
                                            sizeof extraBytes);
  }

  status = writeExecute2048(&vol, interface);

  tffsWriteWordFlash(&(interface->signals.w), DBL(NOT_WP));

  return status;
}


    /*
        Core MTD methods - read, write and erase  
      */

/*----------------------------------------------------------------------*/
/*                        c d s n R e a d                               */
/*                                                                      */
/* Read some data from the flash. This routine will be registered as    */
/* the read routine for this MTD.                                       */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      address : Address to read from.                                 */
/*      buffer  : buffer to read to.                                    */
/*      length  : number of bytes to read (up to sector size).          */
/*      modes   : EDC flag etc.                                         */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus: 0 on success, otherwise failed.                       */
/*                                                                      */
/*----------------------------------------------------------------------*/

FLStatus cdsnRead(  FLFlash vol,
                         CardAddress address, /* target flash address */
                         VOID FAR1 *buffer,    /* source RAM buffer  */
                         dword length,          /* bytes to write      */
                         word modes)           /* Overwrite, EDC flags etc. */
{
  CHAR FAR1 *temp;
  ULONG readNow;

              /* read in sectors; first and last might be partial*/

  ULONG block = modes & EXTRA ? 8 : SECTOR_SIZE;

  readNow = block - ((USHORT)address & (block - 1));
  temp = (CHAR FAR1 *)buffer;
  for ( ; length > 0 ; )
  {
    if (readNow > length)
      readNow = length;

    /* turn off EDC on partial block read*/
    checkStatus( readOneSector_nfdc2048(&vol, address, temp, readNow,
                                (readNow != SECTOR_SIZE ? (modes & ~EDC) : modes)) );

    length -= readNow;
    address += readNow;
    temp += readNow;

    /* align at sector */
    readNow = block;
  }

  return flOK ;
}


/*----------------------------------------------------------------------*/
/*                        c d s n W r i t e                             */
/*                                                                      */
/* Write some data to the flash. This routine will be registered as the */
/* write routine for this MTD.                                          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      address : Address of sector to write to.                        */
/*      buffer  : buffer to write from.                                 */
/*      length  : number of bytes to write (up to sector size).         */
/*      modes   : OVERWRITE, EDC flags etc.                             */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus: 0 on success, otherwise failed.                       */
/*                                                                      */
/*----------------------------------------------------------------------*/

FLStatus cdsnWrite( FLFlash vol,
                         CardAddress address,       /* target flash address*/
                         const VOID FAR1 *buffer,    /* source RAM buffer  */
                         dword length,                /* bytes to write      */
                         word modes)                 /* Overwrite, EDC flags etc.*/
{
  ULONG writeNow;
  const CHAR FAR1 *temp;
  FLStatus      status = flOK;
#ifdef VERIFY_AFTER_WRITE
  CardAddress  saveAddress = address;
  USHORT flReadback[SECTOR_SIZE / sizeof(USHORT)];
#endif

  /* write in sectors; first and last might be partial*/
  LONG block = modes & EXTRA ? 8 : SECTOR_SIZE;

  writeNow = block - ((USHORT)address & (block - 1));
  temp = (const CHAR FAR1 *)buffer;
  for ( ; length > 0 ; )
  {
    if (writeNow > length)
      writeNow = length;

    /* turn off EDC on partial block write*/
    status = writeOneSector_nfdc2048(&vol, address, temp, writeNow,
                 writeNow != SECTOR_SIZE ? (modes & ~EDC) : modes);

    if (status != flOK)
      break;

#ifdef VERIFY_AFTER_WRITE
    status = readOneSector_nfdc2048 (&vol, address, (CHAR FAR1 *)flReadback,
                 writeNow, (writeNow != SECTOR_SIZE ? (modes & ~EDC) : modes));

    if((status != flOK) || (tffscmp(temp, flReadback, writeNow) != 0))
      { status = flWriteFault;  break; }
#endif

    length -= writeNow;
    address += writeNow;
    temp += writeNow;

    /* align at sector */
    writeNow = block;
  }

  return flOK ;
}


/*----------------------------------------------------------------------*/
/*                        c d s n E r a s e                             */
/*                                                                      */
/* Erase number of blocks. This routine will be registered as the       */
/* erase routine for this MTD.                                          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      blockNo         : First block to erase.                         */
/*      blocksToErase   : Number of blocks to erase.                    */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed.               */
/*                                                                      */
/*----------------------------------------------------------------------*/

FLStatus cdsnErase( FLFlash vol,
                         word blockNo,              /* start' block (0 .. chipNoOfBlocks-1)*/
                         word blocksToErase)        /* Number of blocks to be erased */
{
  LONG i;
  FLStatus status   = flOK;

  Interface interface =
     mapContInterface(&vol, (LONG)blockNo * vol.erasableBlockSize ) ;    /* select device*/

  if (flWriteProtected(vol.socket))
    return flWriteProtect;

  blockNo %= thisVars->noOfBlocks ;                        /* within flash device  */

  if ( blockNo + blocksToErase > thisVars->noOfBlocks )    /* accross device boundary */
    return flBadParameter;

  for ( i=0 ; i < blocksToErase ; i++, blockNo++ )
  {
    USHORT pageNo = (USHORT) (blockNo * thisVars->pagesPerBlock);

    command2048(&vol, interface, SETUP_ERASE);

    tffsWriteWordFlash(&(interface->signals.w), DBL(ALE | NOT_WP | CE));

    /* send 'pageNo' to the flash in the following sequence: */
    /*   bits  7..0  first                                   */
    /*   bits 15..8  next                                    */
    if (vol.interleaving == 1)
    {
      tffsWriteByteFlash(&(interface->io[0].b),(UCHAR)pageNo);
      tffsWriteByteFlash(&(interface->io[0].b),(UCHAR)(pageNo >> 8));
    }
    else
    {
      tffsWriteWordFlash(&(interface->io[0].w), DBL(pageNo));
      tffsWriteWordFlash(&(interface->io[0].w), DBL(pageNo >> 8));
    }

    tffsWriteWordFlash(&(interface->signals.w), DBL(NOT_WP | CE));

              /* if only one block may be erase at a time then do it
                 otherwise leave it for later*/

    command2048(&vol, interface, CONFIRM_ERASE);

    if (!waitForReady_nfdc2048(interface))
      status = flTimedOut;

    if ( readStatus2048(&vol, interface) & DBL(FAIL)) {    /* erase operation failed*/
      status = flWriteFault ;
    }

    if (status != flOK) {                              /* reset flash device and abort */
      DEBUG_PRINT(("Debug: erase failed in NFDC 2048.\n"));
      command2048(&vol, interface, RESET_FLASH ) ;
      waitForReady_nfdc2048(interface) ;

      break ;
    }
  }       /* block loop */

#ifdef MULTI_ERASE
        /* do multiple block erase as was promised*/

    command2048(&vol, interface, CONFIRM_ERASE);
    if (!waitForReady_nfdc2048(interface))
      status = flTimedOut;

    if ( readStatus2048(interface) & DBL(FAIL)) {   /* erase operation failed*/
      status = flWriteFault ;
    }

    if (status != flOK) {                       /* reset flash device and abort*/
      DEBUG_PRINT(("Debug: erase failed in NFDC 2048.\n"));
      command2048(&vol, interface, RESET_FLASH ) ;
      waitForReady_nfdc2048(interface) ;
    }
#endif   /* MULTI_ERASE*/

  if(status == flOK)
    if ( readStatus2048(&vol, interface) & DBL(FAIL) ) {
      DEBUG_PRINT(("Debug: erase failed in NFDC 2048.\n"));
      status = flWriteFault;
    }

  return status;
}


/*----------------------------------------------------------------------*/
/*                        c d s n M a p                                 */
/*                                                                      */
/* Map through buffer. This routine will be registered as the map       */
/* routine for this MTD.                                                */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      address : Flash address to be mapped.                           */
/*      length  : number of bytes to map.                               */
/*                                                                      */
/* Returns:                                                             */
/*      Pointer to the buffer data was mapped to.                       */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID FAR0 * cdsnMap ( FLFlash vol,
                            CardAddress address,
                            int length )
{
  cdsnRead(&vol,address,thisBuffer,length, 0);
  vol.socket->remapped = TRUE;
  return (VOID FAR0 *)thisBuffer;
}

#ifdef NFDC2048
/*----------------------------------------------------------------------*/
/*                        c d s n S e t C a l l b a c k                 */
/*                                                                      */
/* Register a routine (powerUp()) for power on callback.                */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID cdsnSetCallback(FLFlash vol)
{
  flSetPowerOnCallback(vol.socket, powerUp, &vol);
}
#endif /* NFDC2048 */

/*----------------------------------------------------------------------*/
/*                        i s K n o w n M e d i a                       */
/*                                                                      */
/* Check if this flash media is supported. Initialize relevant fields   */
/* in data structures.                                                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      vendorId_P      : vendor ID read from chip.                     */
/*      chipId_p        : chip ID read from chip.                       */
/*      dev             : dev chips were accessed before this one.      */
/*                                                                      */
/* Returns:                                                             */
/*      TRUE if this media is supported, FALSE otherwise.               */
/*                                                                      */
/*----------------------------------------------------------------------*/

FLBoolean isKnownMedia_nfdc2048( FLFlash vol,
                         USHORT vendorId_p,
                         USHORT chipId_p,
                         LONG dev )
{
#ifdef NFDC2048
  if ((chipId_p & 0xff00) == 0x6400)
    chipId_p = DBL(0x64);   /* Workaround for TC5816/NFDC2048 problem */
#endif /* NFDC2048 */

  if (dev == 0)
  {
    thisVars->vendorID = vendorId_p;  /* remember for next chips */
    thisVars->chipID = chipId_p;
    thisVars->pagesPerBlock = PAGES_PER_BLOCK;

    if (vendorId_p == DBL(0xEC))                  /* Samsung */
    {
      switch (chipId_p)
      {
        case DBL(0x64):                         /* 2M */
        case DBL(0xEA) :
          vol.type = KM29N16000_FLASH ;
          vol.chipSize = 0x200000L;
          return TRUE;

        case DBL(0xE5):
        case DBL(0xE3):                         /* 4M */
          vol.type = KM29N32000_FLASH;
          vol.flags |= BIG_PAGE;
          vol.chipSize = 0x400000L;
          return TRUE;

        case DBL(0xE6):                         /* 8M */
          vol.type = KM29V64000_FLASH;
          vol.flags |= BIG_PAGE;
          vol.chipSize = 0x800000L;
          return TRUE;

	case DBL(0x73): 		        /* 16 Mb */
	  vol.type = KM29V128000_FLASH;
          vol.flags |= BIG_PAGE;
	  vol.chipSize = 0x1000000L;
          thisVars->pagesPerBlock *= 2;
          return TRUE;

        case DBL(0x75):           		/* 32 Mb */
	  vol.type = KM29V256000_FLASH;
          vol.flags |= BIG_PAGE;
          vol.chipSize = 0x2000000L;
          thisVars->pagesPerBlock *= 2;
	  return TRUE;
      }
    }
    else
    if (vendorId_p == DBL(0x8F))                /* National */
    {
      switch (chipId_p)
      {
        case DBL(0x64):                         /* 2M */
          vol.type = NM29N16_FLASH;
          vol.chipSize = 0x200000L;
          return TRUE;
      }
    }
    else
    if (vendorId_p == DBL(0x98))                        /* Toshiba */
    {
      vol.flags |= FULL_PAGE;             /* no partial page programming */

      switch (chipId_p)
      {
        case DBL(0x64):                         /* 2M */
        case DBL(0xEA) :
          vol.type = TC5816_FLASH;
          vol.chipSize = 0x200000L;
          return TRUE;

        case DBL(0x6B):                         /* 4M */
        case DBL(0xE5):
          vol.type = TC5832_FLASH;
          vol.flags |= BIG_PAGE;
          vol.chipSize = 0x400000L;
          return TRUE;

        case DBL(0xE6):                         /* 8M */
          vol.type = TC5816_FLASH;
          vol.flags |= BIG_PAGE;
          vol.chipSize = 0x800000L;
          return TRUE;

	case DBL(0x73): 		        /* 16 Mb */
	  vol.type = TC58128_FLASH;
          vol.flags |= BIG_PAGE;
	  vol.chipSize = 0x1000000L;
          thisVars->pagesPerBlock *= 2;
          return TRUE;

        case DBL(0x75):           		/* 32 Mb */
	  vol.type = TC58256_FLASH;
          vol.flags |= BIG_PAGE;
          vol.chipSize = 0x2000000L;
          thisVars->pagesPerBlock *= 2;
	  return TRUE;
      }
    }
  }
  else               /* dev != 0*/
  if( (vendorId_p == thisVars->vendorID) && (chipId_p == thisVars->chipID) )
    return TRUE ;

  return FALSE ;
}


/*----------------------------------------------------------------------*/
/*                        r e a d F l a s h I D                         */
/*                                                                      */
/* Read vendor and chip IDs, count flash devices. Initialize relevant   */
/* fields in data structures.                                           */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      interface       : Pointer to window.                            */
/*      dev             : dev chips were accessed before this one.      */
/*                                                                      */
/* Returns:                                                             */
/*      TRUE if this media is supported, FALSE otherwise.               */
/*                                                                      */
/*----------------------------------------------------------------------*/

LONG readFlashID2048 (FLFlash vol, Interface interface, LONG dev)
{
  USHORT vendorId_p, chipId_p  ;

  KeStallExecutionProcessor(250 * 1000);
  command2048(&vol, interface, RESET_FLASH ) ;
  flDelayMsecs(10);
  command2048(&vol, interface, READ_ID);
  
  tffsWriteWordFlash(&(interface->signals.w), DBL(ALE | NOT_WP | CE));

  if (vol.interleaving == 1) {
      tffsWriteByteFlash(&(interface->io[0].b), 0);    /* Read ID from*/
  } else {                            /* address 0. */
      tffsWriteWordFlash(&(interface->io[0].w), 0);
  }

  tffsWriteWordFlash(&(interface->signals.w), DBL(NOT_WP | CE));

            /* read vendor and chip IDs */

  vendorId_p = (vol.interleaving == 1 ? DBL(tffsReadByteFlash(&(interface->io[0].b))) : tffsReadWordFlash(&(interface->io[0].w))) ;
  chipId_p   = (vol.interleaving == 1 ? DBL(tffsReadByteFlash(&(interface->io[0].b))) : tffsReadWordFlash(&(interface->io[0].w)));

  tffsWriteWordFlash(&(interface->signals.w), DBL(NOT_WP));

  if ( isKnownMedia_nfdc2048(&vol, vendorId_p, chipId_p, dev) != TRUE )    /* no chip or diff.*/
    return  FALSE ;                                         /* type of flash  */

            /* set flash parameters*/

  if ( dev == 0 )
  {
    thisVars->pageAreaSize = (USHORT) (0x100 * vol.interleaving);
    thisVars->pageSize = (USHORT) ((vol.flags & BIG_PAGE ? 0x200 : 0x100) * vol.interleaving);
    thisVars->tailSize = (USHORT) ((vol.flags & BIG_PAGE ? 16 : 8) * vol.interleaving);
    thisVars->pageMask = thisVars->pageSize - 1 ;
    vol.erasableBlockSize = thisVars->pagesPerBlock * thisVars->pageSize;
    thisVars->noOfBlocks = (USHORT)( (vol.chipSize * vol.interleaving)
                                / vol.erasableBlockSize ) ;
  }

  return TRUE ;
}


/*----------------------------------------------------------------------*/
/*                        c d s n I d e n t i f y                       */
/*                                                                      */
/* Identify flash. This routine will be registered as the               */
/* identification routine for this MTD.                                 */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus: 0 on success, otherwise failed.                       */
/*                                                                      */
/*----------------------------------------------------------------------*/

FLStatus cdsnIdentify(FLFlash vol)
{
  LONG addr = 0L ;
  Interface interface;

  DEBUG_PRINT(("Debug: Entering NFDC 2048 identification routine\n"));

  flDelayMsecs(10);       /* wait for socket to power up */

  flSetWindowBusWidth(vol.socket,16);/* use 16-bits */
  flSetWindowSpeed(vol.socket,250);  /* 250 nsec. */
  flSetWindowSize(vol.socket,2);        /* 4 KBytes */

  vol.mtdVars = &mtdVars_nfdc2048[flSocketNoOf(vol.socket)];
  /* get pointer to buffer (we assume SINGLE_BUFFER is not defined) */
  thisVars->buffer = flBufferOf(flSocketNoOf(vol.socket));

          /* detect card - identify bit toggles on consequitive reads*/

  vol.chipSize = 0x200000L ;    /* Assume something ... */
  vol.interleaving = 1;       /* unimportant for now  */
  interface = mapContInterface(&vol, 0);
  KeStallExecutionProcessor(250 * 1000);

  if((tffsReadByteFlash(&(interface->eccConfig.b)) & TOGGLE) == (tffsReadByteFlash(&(interface->eccConfig.b)) & TOGGLE))
    return flUnknownMedia;

          /* read interleave from the card*/

#ifdef NFDC2048
  vol.interleaving = ( (getAttReg(&vol, JUMPERS ) & JMPER_INLV) ? 1 : 2 );

  powerUp((VOID *) &vol);
  interface = mapContInterface(&vol, 0);
  KeStallExecutionProcessor(250 * 1000);

  if (vol.interleaving == 1)
    flSetWindowBusWidth(vol.socket, 8);

 #else
  vol.interleaving = INLV;
#endif  /* NFDC2048 */

          /* reset all flash devices*/

  tffsWriteWordFlash(&(interface->signals.w), DBL(NOT_WP));

           /* identify and count flash chips, figure out flash parameters*/

  for (vol.noOfChips = 0 ;
       vol.noOfChips < MAX_FLASH_DEVICES;
       vol.noOfChips += vol.interleaving,
       addr += vol.chipSize * vol.interleaving)
  {
    interface = mapContInterface(&vol, addr) ;
    if ( readFlashID2048(&vol, interface, vol.noOfChips) != TRUE )       /* no chip or different type of flash*/
      break ;
  }

  if ( vol.noOfChips == 0 )                        /* no chips were found */
    return flUnknownMedia;

            /* ECC off*/

  interface = mapContInterface(&vol, 0);
  KeStallExecutionProcessor(250 * 1000);

#ifdef NFDC2048
  SET_ECC_CONFIG(interface, PAR_DIS); /* disable ECC and parity*/
  setAttReg(&vol, CARD_CONFIG, PWRDWN);
#endif  /* NFDC2048 */

  /* Register our flash handlers */
  vol.write = cdsnWrite;
  vol.erase = cdsnErase;
  vol.read = cdsnRead;
  vol.map = cdsnMap;
#ifdef NFDC2048
  vol.setPowerOnCallback = cdsnSetCallback;
#endif

  vol.flags |= NFTL_ENABLED;

  DEBUG_PRINT(("Debug: Identified NFDC 2048.\n"));

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                      f l R e g i s t e r C D S N                     */
/*                                                                      */
/* Registers this MTD for use                                           */
/*                                                                      */
/* Parameters:                                                          */
/*      None                                                            */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failure               */
/*----------------------------------------------------------------------*/

FLStatus flRegisterCDSN(VOID)
{
  if (noOfMTDs >= MTDS)
    return flTooManyComponents;

  mtdTable[noOfMTDs++] = cdsnIdentify;

  return flOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\protectp.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/PROTECTP.C_V  $
 * 
 *    Rev 1.18   Apr 15 2002 07:38:44   oris
 * Added static qualifier for private functions (findChecksum and makeDPS).
 * Removed readDPS and writeDPS routine prototypes (no longer exist).
 * Added setStickyBit routine for DiskOnChip Plus 128Mbit.
 * 
 *    Rev 1.17   Jan 28 2002 21:26:24   oris
 * Removed the use of back-slashes in macro definitions.
 * 
 *    Rev 1.16   Jan 17 2002 23:04:54   oris
 * Replaced docsysp include directive with docsys.
 * Changed the use of vol (macro *pVol) to *flash.
 * Add support for DiskOnChip Millennium Plus 16MB :
 *  - Copy extra area of IPL independently of the EDC to copy Strong arm  mark.
 *  - DPS 0 and 1 location where changed  - affects protectionSet routine.
 * Bug fix - Wrong usage of findChecksum, caused the use of the second  copy of the DPS instead of the first.
 * 
 *    Rev 1.15   Sep 24 2001 18:24:18   oris
 * removed ifdef and forced using flRead8bitRegPlus instead of reading with flRead16bitRegPlus.
 * 
 *    Rev 1.14   Sep 15 2001 23:47:56   oris
 * Remove all 8-bit access to uneven addresses.
 *
 *    Rev 1.13   Jul 16 2001 17:41:54   oris
 * Ignore write protection of the DPSs.
 *
 *    Rev 1.12   Jul 13 2001 01:09:26   oris
 * Bug fix for protection boundaries when using Millennium Plus devices that can not access a single byte.
 * Added send default key before trying a protection violation command.
 * Bug fix - bad IPL second copy offset.
 *
 *    Rev 1.11   May 16 2001 21:21:42   oris
 * Removed warnings.
 *
 *    Rev 1.10   May 09 2001 00:35:48   oris
 * Bug fix - Lock asserted was reported opposite of the real state.
 * Bug fix - Make sure to return "key inserted" if the partition is not read\write protected.
 * This is to enable a partition that does not span over all of the media floors to return "key inserted".
 *
 *    Rev 1.9   May 06 2001 22:42:18   oris
 * Bug fix - insert key does not try to insert key to a floor that is not read\write protected.
 * Bug fix - protection type does not return key inserted is one of the floors key is not inserted.
 * Bug fix - set protection no longer clears the IPL.
 * redundant was misspelled.
 *
 *    Rev 1.8   May 01 2001 14:24:56   oris
 * Bug fix - CHANGEABLE_PRTOECTION was never reported.
 *
 *    Rev 1.7   Apr 18 2001 17:19:02   oris
 * Bug fix - bad status code returned by protection set routine du to  calling changaInterleave while in access error.
 *
 *    Rev 1.6   Apr 18 2001 09:29:32   oris
 * Bug fix - remove key routine always return bad status code.
 *
 *    Rev 1.5   Apr 16 2001 13:58:28   oris
 * Removed warrnings.
 *
 *    Rev 1.4   Apr 12 2001 06:52:32   oris
 * Changed protectionBounries and protectionSet routine to be floor specific.
 *
 *    Rev 1.3   Apr 10 2001 23:56:30   oris
 * Bug fix - protectionBounries routine - floor did not change.
 * Bug fix - protectionSet routine - floors with no protected areas were not updated.
 * Bug fix - protectionBounries routine - bad paranthesis in MAX calculation.
 *
 *    Rev 1.2   Apr 09 2001 19:04:24   oris
 * Removed warrnings.
 *
 */

/*******************************************************************
 *
 *    DESCRIPTION:  MTD protection mechanism routines for the MDOC32
 *
 *    AUTHOR:  arie tamam
 *
 *    HISTORY:  created november 14, 2000
 *
 *******************************************************************/


/** include files **/
#include "mdocplus.h"
#include "protectp.h"
#include "docsys.h"

/** local definitions **/

/* default settings */

/** external functions **/

/** external data **/

/** internal functions **/
static byte findChecksum(byte * buffer, word size);
static void makeDPS(CardAddress addressLow, CardAddress addressHigh,
             byte FAR1*  key , word flag, byte* buffer);

#define MINUS_FLOORSIZE(arg) ((arg > NFDC21thisVars->floorSize) ? arg - NFDC21thisVars->floorSize : 0)

/** public data **/

/** private data **/

/** public functions **/

#ifdef  HW_PROTECTION

/**********/
/* Macros */
/**********/

/* check if key is correct */
#define isArea0Protected(flash) (((flRead8bitRegPlus(flash,NdataProtect0Status) & PROTECT_STAT_KEY_OK_MASK) != PROTECT_STAT_KEY_OK_MASK) ? TRUE : FALSE)

#define isArea1Protected(flash) (((flRead8bitRegPlus(flash,NdataProtect1Status) & PROTECT_STAT_KEY_OK_MASK) != PROTECT_STAT_KEY_OK_MASK) ? TRUE : FALSE)

/*----------------------------------------------------------------------*/
/*                    s e t S t i c k y B i t                           */
/*                                                                      */
/* Set the sticky bit to prevent the insertion of the protection key.   */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive.                            */
/*                                                                      */
/* Returns:                                                             */
/*      flOK on success, none zero otherwise.                           */
/*----------------------------------------------------------------------*/

FLStatus setStickyBit(FLFlash * flash)
{
   volatile Reg8bitType val;
   register int         i;

   /* Raise the sticky bit, while keeping the other bits of the register */
   for(i=0;i<flash->noOfFloors;i++)
   {
      /* Remove last bit */
      val = flRead8bitRegPlus(flash, NoutputControl) |
            OUT_CNTRL_STICKY_BIT_ENABLE;
      flWrite8bitRegPlus(flash, NoutputControl, val);
   }
   return flOK;
}


/*
 ** protectBoundries
 *
 *
 *  PARAMETERS:
 *  flash       : Pointer identifying drive
 *  area        : indicated which protection area to work on.  0 or 1.
 *  AddressLow  : address of lower boundary of protected area
 *  AddressHigh : address of upper boundary of protected area
 *
 *  DESCRIPTION:  Gets protection boundaries from registers
 *
 *  NOTE : protection areas are assumed to be consequtive although they
 *         may skip DPS , OTP and header units.
 *
 *  RETURNS:
 *           flOK on success
 *
 */

FLStatus protectionBoundries(FLFlash * flash, byte area,CardAddress* addressLow,
                             CardAddress* addressHigh, byte floorNo)
{
  /* Check mode of ASIC and set to NORMAL.*/
  FLStatus status = chkASICmode(flash);

  if(status != flOK)
    return status;

  setFloor(flash,floorNo);
  switch (area)
  {
     case 0: /* data protect structure 0 */

        /* read the data protect 0 addresses */

        *addressLow = ((dword)flRead8bitRegPlus(flash,NdataProtect0LowAddr)   << 10)| /* ADDR_1 */
                      ((dword)flRead8bitRegPlus(flash,NdataProtect0LowAddr+1) << 18); /* ADDR_2 */
        *addressHigh = ((dword)flRead8bitRegPlus(flash,NdataProtect0UpAddr)   << 10)| /* ADDR_1 */
                       ((dword)flRead8bitRegPlus(flash,NdataProtect0UpAddr+1) << 18); /* ADDR_2 */
        break;

     case 1: /* data protect structure 1 */

        /* read the data protect 1 addresses */
        *addressLow = ((dword)flRead8bitRegPlus(flash,NdataProtect1LowAddr)   << 10)| /* ADDR_1 */
                      ((dword)flRead8bitRegPlus(flash,NdataProtect1LowAddr+1) << 18); /* ADDR_2 */
        *addressHigh = ((dword)flRead8bitRegPlus(flash,NdataProtect1UpAddr)   << 10)| /* ADDR_1 */
                       ((dword)flRead8bitRegPlus(flash,NdataProtect1UpAddr+1) << 18); /* ADDR_2 */
        break;

     default: /* No such protection area */

        return flGeneralFailure;
  }

  return(flOK);
}

/*
 ** tryKey
 *
 *
 *  PARAMETERS:
 *  flash   : Pointer identifying drive
 *  area    : indicated which protection area to work on. 0 or 1.
 *  Key     : an 8 byte long array containing the protection password.
 *            unsigned char * is an 8 bytes unsigned char array
 *
 *  DESCRIPTION: Sends protection key
 *
 *  RETURNS:
 *           flOK on success otherwise flWrongKey
 *
 */

FLStatus  tryKey(FLFlash * flash, byte area, unsigned char FAR1* key)
{
   int i;

   switch (area)
   {
      case 0: /* data protect structure 0 */

         for(i=0; i<PROTECTION_KEY_LENGTH; i++)  /* Send key */
            flWrite8bitRegPlus(flash,NdataProtect0Key, key[i]);

         /* check if key is valid */
         if (isArea0Protected(flash) == TRUE)
         {
            return flWrongKey;
         }
         else
         {
            return flOK;
         }

      case 1: /* data protect structure 0 */

         for(i=0; i<PROTECTION_KEY_LENGTH; i++)  /* Send key */
            flWrite8bitRegPlus(flash,NdataProtect1Key, key[i]);

         /* check if key is valid */
         if (isArea1Protected(flash) == TRUE)
         {
            return flWrongKey;
         }
         else
         {
            return flOK;
         }

      default: /* No such protection area */

         return flGeneralFailure;
   }
}

/*
 ** protectKeyInsert
 *
 *
 *  PARAMETERS:
 *  flash   : Pointer identifying drive
 *  area    : indicated which protection area to work on. 0 or 1.
 *  Key     : an 8 byte long array containing the protection password.
 *      unsigned char * is an 8 bytes unsigned char array
 *
 *  DESCRIPTION: Sends protection key only to protected areas.
 *
 *  NOTE : If key is already inserted the given key will not be sent.
 *  NOTE : The key will be sent to all the devices floors even if a key
 *         did not fit one of them.
 *  NOTE : This 2 notes above allow inserting diffrent key to
 *         diffrent floors in the case of power failure while formmating
 *         the device.
 *
 *  RETURNS:
 *           flOK on success otherwise flWrongKey
 *
 */

FLStatus  protectionKeyInsert(FLFlash * flash, byte area, unsigned char FAR1* key)
{
  byte floor;
  FLStatus status;
  FLStatus tmpStatus;

  /* Check mode of ASIC and set to NORMAL.*/
  status = chkASICmode(flash);
  if(status != flOK)
    return status;

  /* Send key to all floors */
  for (floor = 0;floor<flash->noOfFloors;floor++)
  {
    setFloor(flash,floor);

    switch (area)
    {
      case 0: /* data protect structure 0 */

     /* check if key is already inserted */
     if ((isArea0Protected(flash) == FALSE) || /* Key is in */
         ((flRead8bitRegPlus(flash,NdataProtect0Status) &   /* Or not protected */
          (PROTECT_STAT_WP_MASK | PROTECT_STAT_RP_MASK)) == 0))
        continue;

     break;

      case 1: /* data protect structure 1 */

     /* check if key is already inserted */
     if ((isArea1Protected(flash) == FALSE) || /* Key is in */
         ((flRead8bitRegPlus(flash,NdataProtect1Status) &   /* Or not protected */
          (PROTECT_STAT_WP_MASK | PROTECT_STAT_RP_MASK)) == 0))
        continue;
         break;

      default: /* No such protection area */

        return flGeneralFailure;
    }
    tmpStatus = tryKey(flash,area,key);
    if (tmpStatus == flOK)
       continue;

    /* Try default key */
    tmpStatus = tryKey(flash,area,(byte *)DEFAULT_KEY);
    if (tmpStatus != flOK)
       status = tmpStatus;
  }
  return(status);
}

/*
 ** protectKeyRemove
 *
 *
 *  PARAMETERS:
 *  flash       : Pointer identifying drive
 *  area        : indicated which protection area to work on. 0 or 1.
 *
 *  DESCRIPTION:  Removes protection key
 *
 *  RETURNS:
 *           Return flOK 
 *
 */

FLStatus    protectionKeyRemove(FLFlash * flash, byte area)
{
  byte     tmpKey[8];
  byte     floor;
  FLStatus status;

  for (floor = 0;floor < flash->noOfFloors;floor++)
  {
    setFloor(flash,floor);
    status = tryKey(flash,area,tmpKey);
    if (status == flOK) /* Unfortunatly the key was fine */
    {
       tmpKey[0]++;
       status = tryKey(flash,area,tmpKey);
    }
  }
  return flOK;
}

/*
 ** protectType
 *
 *
 *  PARAMETERS:
 *  flash       : Pointer identifying drive.
 *  area        : indicated which protection area to work on. 0 or 1.
 *  flag        : returns any combination of
 *      LOCK_ENABLED    - The LOCK signal is enabled.
 *      LOCK_ASSERTED   - The LOCK signal input pin is asserted.
 *      KEY_INSERTED    - The key has been correctly written
 *      READ_PROTECTED  - The area is protected against read operations
 *      WRITE_PROTECTED - The area is protected against write operations
 *
 *  DESCRIPTION: Gets protection type
 *
 *  NOTE: The type is checked for all floors. The attributes are ored
 *        giving the harshest protection attributes.
 *
 *  RETURNS:
 *       flOK on success
 */

FLStatus protectionType(FLFlash * flash, byte area,  word* flag)
{
  volatile Reg8bitType protectData;
  byte        floor;
  FLBoolean   curFlag; /* Indicated if the floor has r/w protection */
  CardAddress addressLow,addressHigh;
  FLStatus    status;

  status = chkASICmode(flash);
  if(status != flOK)
    return status;

  *flag = KEY_INSERTED | LOCK_ASSERTED; /* initiate the flags */

  for (floor = 0;floor < flash->noOfFloors;floor++)
  {
     setFloor(flash,floor);

     /* read data protect structure status */

     switch (area)
     {
        case 0: /* data protect structure 0 */

           protectData = flRead8bitRegPlus(flash,NdataProtect0Status) ;
           break;

        case 1: /* data protect structure 1 */

           protectData = flRead8bitRegPlus(flash,NdataProtect1Status) ;
           *flag      |= CHANGEABLE_PROTECTION;
           break;

        default: /* No such protection area */

           return flGeneralFailure;
     }
     curFlag = FALSE;
     /* Check if area is write protected */
     if((protectData & PROTECT_STAT_WP_MASK) ==PROTECT_STAT_WP_MASK)
     {
        status = protectionBoundries(flash, area, &addressLow,
                                         &addressHigh, floor);
        if(status != flOK)
           return status;

        if ((addressLow != addressHigh) ||
            (addressLow != ((CardAddress)(area + 1)<<flash->erasableBlockSizeBits)))
        {
           *flag |= WRITE_PROTECTED;
           curFlag = TRUE;
        }
     }
     /* Check if area is read protected */
     if((protectData & PROTECT_STAT_RP_MASK) ==PROTECT_STAT_RP_MASK)
     {
        *flag |= READ_PROTECTED;
        curFlag = TRUE;
     }
     /* Check if key is corrently inserted */
     if(((protectData & PROTECT_STAT_KEY_OK_MASK) !=
         PROTECT_STAT_KEY_OK_MASK) && (curFlag == TRUE))
        *flag &= ~KEY_INSERTED;
     /* Check if HW signal is enabled */
     if((protectData & PROTECT_STAT_LOCK_MASK) == PROTECT_STAT_LOCK_MASK)
        *flag |=LOCK_ENABLED ;
     /* Check if HW signal is asserted */
     if((flRead8bitRegPlus(flash,NprotectionStatus) &
        PROTECT_STAT_LOCK_INPUT_MASK) ==  PROTECT_STAT_LOCK_INPUT_MASK)
        *flag &= ~LOCK_ASSERTED;
  }
  return(flOK);
}

#ifndef FL_READ_ONLY

static byte findChecksum(byte * buffer, word size)
{
   register int i;
   byte answer;

   answer = 0xff;
   for(i=0 ; i<size ; i++)
     answer -= buffer[i];
   return answer;
}

/*
 ** SetProtection
 *
 *
 *  PARAMETERS:
 *  flash       : Pointer identifying drive
 *  area        : indicated which protection area to work on.  0 or 1.
 *  AddressLow  : sets address of lower boundary of protected area. 0 - floor size.
 *  AddressHigh : sets address of upper boundary of protected area. AddressLow - floor size.
 *  Key         : an 8 byte long array containing the protection password.
 *  flag        : any combination of the following flags:
 *      LOCK_ENABLED    - The LOCK signal is enabled.
 *      READ_PROTECTED - The area is protected against read operations
 *      WRITE_PROTECTED - The area is protected against write operations
 *  modes       : Either COMMIT_PROTECTION will cause the new values to
 *                take affect immidiatly or DO_NOT_COMMIT_PROTECTION for
 *                delaying the new values to take affect only after the
 *                next reset.
 *
 *  DESCRIPTION:  Sets the definitions of a protected area: location, key and protection type
 *
 *  RETURNS:
 *    flOK           - success
 *    FlWriteProtect - protection violetion,
 *    FlReadProtect  - protection violetion.
 *    FlDataError    - any other read failure.
 *    FlWriteFault   - any other write error.
 *    flBadLength    - if the length of the protected area exceeds
 *                     allowed length
 */

FLStatus protectionSet ( FLFlash * flash, byte area, word flag,
                         CardAddress addressLow, CardAddress addressHigh,
                         byte FAR1*  key , byte modes, byte floorNo)
{
  FLBoolean restoreInterleave = FALSE;
  byte      downloadStatus;
  DPSStruct dps;
  dword     floorInc = floorNo * NFDC21thisVars->floorSize;
  word      goodUnit,redundantUnit;
  dword     goodDPS,redundantDPS;
  FLStatus  status;
  dword     goodIPL      = 0; /* Initialized to remove warrnings */
  dword     redundantIPL = 0; /* Initialized to remove warrnings */
  dword     copyOffset;       /* Offset to redundant DPS unit    */
  dword     ipl0Copy0;     /* Offset to IPL second 512 bytes copy 0     */
  dword     dps1Copy0;     /* Offset to DPS1 copy 0                     */
  word      dps1UnitNo;    /* Offset to redundant DPS unit              */


  status = chkASICmode(flash);
  if(status != flOK)
    return status;

  /* check if exceeds the size */
  if( (addressLow > addressHigh) ||
      (addressHigh - addressLow >= (dword)NFDC21thisVars->floorSize))
     return( flBadLength );

  /* change to interleave 1 */
  if ( flash->interleaving == 2)
  {
     restoreInterleave = TRUE;
     status = changeInterleave(flash,1);
     if(status != flOK)
       return status;
  }

  if(flash->mediaType == MDOCP_TYPE) /* DiskOnChip Millennium Plus 32MB */
  {
    copyOffset   = flash->chipSize>>1; /* The chips are consequtive */
    dps1Copy0    = DPS1_COPY0_32;
    dps1UnitNo   = DPS1_UNIT_NO_32;
    ipl0Copy0    = IPL0_COPY0_32;
  }
  else
  {
    copyOffset   = flash->chipSize>>1; /* The chips are consequtive */
    dps1Copy0    = DPS1_COPY0_16;
    dps1UnitNo   = DPS1_UNIT_NO_16;
    ipl0Copy0    = IPL0_COPY0_16;
  }

  /* find if previous download */
  downloadStatus = flRead8bitRegPlus(flash,NdownloadStatus);

  /* prepare buffer */

  switch (area)
  {
     case 0: /* data protect structure 0 */

        switch (downloadStatus & DWN_STAT_DPS0_ERR)
        {
           case DWN_STAT_DPS01_ERR: /* Both  are bad */
              return flBadDownload;

           case DWN_STAT_DPS00_ERR: /* First is  bad */
              redundantUnit = (word)(DPS0_UNIT_NO + floorNo * (NFDC21thisVars->floorSize>>flash->erasableBlockSizeBits));
              goodUnit      = (word)(redundantUnit + (copyOffset>>flash->erasableBlockSizeBits));
              goodDPS       = DPS0_COPY0+floorInc + copyOffset;
              redundantDPS  = DPS0_COPY0+floorInc;
              break;

           default:                 /* Both copies are good */
              goodUnit      = (word)(DPS0_UNIT_NO + floorNo*(NFDC21thisVars->floorSize>>flash->erasableBlockSizeBits));
              redundantUnit = (word)(goodUnit + (copyOffset>>flash->erasableBlockSizeBits));
              goodDPS       = DPS0_COPY0+floorInc;
              redundantDPS  = DPS0_COPY0+floorInc + copyOffset;
        }
        break;

     case 1: /* data protect structure 0 */

        switch (downloadStatus & DWN_STAT_DPS1_ERR)
        {
           case DWN_STAT_DPS11_ERR: /* Both  are bad */
              return flBadDownload;

           case DWN_STAT_DPS10_ERR: /* First is  bad */
              redundantUnit = (word)(dps1UnitNo + floorNo*(NFDC21thisVars->floorSize>>flash->erasableBlockSizeBits));
              goodUnit      = (word)(redundantUnit + (copyOffset>>flash->erasableBlockSizeBits));
              goodDPS       = dps1Copy0+floorInc + copyOffset;
              redundantDPS  = dps1Copy0+floorInc;
              redundantIPL  = ipl0Copy0 + floorInc;
              goodIPL       = redundantIPL + copyOffset;
              break;

           default :                /* First is good */
              goodUnit      = (word)(dps1UnitNo + floorNo*(NFDC21thisVars->floorSize>>flash->erasableBlockSizeBits));
              redundantUnit = (word)(goodUnit + (copyOffset>>flash->erasableBlockSizeBits));
              goodDPS       = dps1Copy0+floorInc;
              redundantDPS  = dps1Copy0+floorInc + copyOffset;
              goodIPL       = ipl0Copy0 + floorInc;
              redundantIPL  = goodIPL + copyOffset;
        }
        break;

     default: /* No such protection area */

        return flGeneralFailure;
  }

  /* Build new DPS */
  if (key==NULL) /* key must be retreaved from previous structure */
  {
     status = flash->read(flash,goodDPS,(void FAR1 *)&dps,SIZE_OF_DPS,0);
     if(status!=flOK) goto END_WRITE_DPS;
     if(findChecksum((byte *)&dps,SIZE_OF_DPS)!=0) /* bad copy */
        status = flash->read(flash,goodDPS+REDUNDANT_DPS_OFFSET,
                          (void FAR1*)&dps,SIZE_OF_DPS,0);
     makeDPS(addressLow,addressHigh,(byte FAR1*)(dps.key),flag,(byte *)&dps);
  }
  else           /* key is given as a parameter */
  {
     makeDPS(addressLow,addressHigh,(byte FAR1*)key,flag,(byte *)&dps);
  }

  /* Erase redundant unit       */
  status = flash->erase(flash,redundantUnit,1);
  if(status!=flOK) goto END_WRITE_DPS;

  /* Write new DPS              */
  status = flash->write(flash,redundantDPS,&dps,SIZE_OF_DPS,0);
  if(status!=flOK) goto END_WRITE_DPS;
  status = flash->write(flash,redundantDPS + REDUNDANT_DPS_OFFSET,
                     &dps,SIZE_OF_DPS,0);
  if(status!=flOK) goto END_WRITE_DPS;

  if (area == 1) /* copy the IPL */
  {
#ifndef MTD_STANDALONE
     /* Force remapping of internal catched sector */
     flash->socket->remapped = TRUE;
#endif /* MTD_STANDALONE */

     /* Read first 512 bytes IPL   */
     status = flash->read(flash,goodIPL,NFDC21thisBuffer,SECTOR_SIZE,0);
     if(status!=flOK) goto END_WRITE_DPS;

     /* Write first 512 bytes IPL  */
     status = flash->write(flash,redundantIPL,NFDC21thisBuffer,SECTOR_SIZE,EDC);
     if(status!=flOK) goto END_WRITE_DPS;
     status = flash->write(flash,redundantIPL + SECTOR_SIZE,
                        NFDC21thisBuffer,SECTOR_SIZE,EDC);
     if(status!=flOK) goto END_WRITE_DPS;

     /* Read second 512 bytes IPL  */
     status = flash->read(flash,goodIPL + IPL_HIGH_SECTOR,
                       NFDC21thisBuffer,SECTOR_SIZE,0);
     if(status!=flOK) goto END_WRITE_DPS;

     /* Write second 512 bytes IPL */
     status = flash->write(flash,redundantIPL + IPL_HIGH_SECTOR,
                        NFDC21thisBuffer,SECTOR_SIZE,EDC);
     if(status!=flOK) goto END_WRITE_DPS;
     status = flash->write(flash,redundantIPL + IPL_HIGH_SECTOR +
            SECTOR_SIZE, NFDC21thisBuffer,SECTOR_SIZE,EDC);
     if(status!=flOK) goto END_WRITE_DPS;
     /* Read Srong Arm mark */
     status = flash->read(flash,goodIPL + IPL_HIGH_SECTOR + 8,
                       NFDC21thisBuffer,1,EXTRA);
     if(status!=flOK) goto END_WRITE_DPS;
     /* Write Srong Arm mark */
     status = flash->write(flash,redundantIPL + IPL_HIGH_SECTOR + 8 +
            SECTOR_SIZE, NFDC21thisBuffer,1,EXTRA);
     if(status!=flOK) goto END_WRITE_DPS;
     status = flash->write(flash,redundantIPL + IPL_HIGH_SECTOR + 8,
                        NFDC21thisBuffer,1,EXTRA);
     if(status!=flOK) goto END_WRITE_DPS;
  }

  /* Erase good unit         */
  status = flash->erase(flash,goodUnit,1);
  if(status!=flOK) goto END_WRITE_DPS;

  /* Write over previous DPS */
  status = flash->write(flash,goodDPS,&dps,SIZE_OF_DPS,0);
  if(status!=flOK) goto END_WRITE_DPS;
  status = flash->write(flash,goodDPS + REDUNDANT_DPS_OFFSET,
                     &dps,SIZE_OF_DPS,0);
  if(status!=flOK) goto END_WRITE_DPS;

  if (area == 1) /* copy the IPL */
  {
     /* Read first 512 bytes IPL   */
     status = flash->read(flash,redundantIPL,NFDC21thisBuffer,SECTOR_SIZE,0);
     if(status!=flOK) goto END_WRITE_DPS;

     /* Write first 512 bytes IPL  */
     status = flash->write(flash,goodIPL,NFDC21thisBuffer,SECTOR_SIZE,EDC);
     if(status!=flOK) goto END_WRITE_DPS;
     status = flash->write(flash,goodIPL + SECTOR_SIZE,
                        NFDC21thisBuffer,SECTOR_SIZE,EDC);
     if(status!=flOK) goto END_WRITE_DPS;

     /* Read second 512 bytes IPL  */
     status = flash->read(flash,redundantIPL + IPL_HIGH_SECTOR,
                       NFDC21thisBuffer,SECTOR_SIZE,0);
     if(status!=flOK) goto END_WRITE_DPS;

     /* Write second 512 bytes IPL */
     status = flash->write(flash,goodIPL + IPL_HIGH_SECTOR,
                        NFDC21thisBuffer,SECTOR_SIZE,EDC);
     if(status!=flOK) goto END_WRITE_DPS;
     status = flash->write(flash,goodIPL + IPL_HIGH_SECTOR +
                        SECTOR_SIZE, NFDC21thisBuffer,
                        SECTOR_SIZE,EDC);
     if(status!=flOK) goto END_WRITE_DPS;
  }

END_WRITE_DPS:
  if ( restoreInterleave == TRUE)
  {
     FLStatus status2;

     chkASICmode(flash);                   /* Release posible access error */
     status2 = changeInterleave(flash, 2); /* change back to interleave 2 */
     if(status2 != flOK)
        return status2;
  }
  if (status == flOK)
  {
     if ((modes & COMMIT_PROTECTION) && /* The new values will take affect now */
         (flash->download != NULL))
        status = flash->download(flash);
  }
  return status;

}

/*
 ** makeDataProtectStruct
 *
 *
 *  PARAMETERS:
 *  AddressLow  : sets address of lower boundary of protected area
 *  AddressHigh: sets address of upper boundary of protected area
 *  Key     : an 8 byte long array containing the protection password.
 *  flag        : any combination of the following flags:
 *      LOCK_ENABLED    - The LOCK signal is enabled.
 *      READ_PROTECTED - The area is protected against read operations
 *      WRITE_PROTECTED - The area is protected against write operations
 *  buffer - buffer pointer of the returned structure.
 *
 *  DESCRIPTION:  Sets the definitions of a protected structure: location, key and protection type
 *
 *  RETURNS:
 *
 */

static void makeDPS(CardAddress addressLow, CardAddress addressHigh,
             byte FAR1* key , word flag, byte* buffer)
{
    int i;
    DPSStruct* dps = (DPSStruct *)buffer;

    /* convert to little endien and store */
    toLE4(dps->addressLow,addressLow >>10);
    toLE4(dps->addressHigh,addressHigh >>10);

    /*insert protection key */
    for(i=0; i<PROTECTION_KEY_LENGTH; i++)
        dps->key[i] = key[i];

    /* insert flags */
    dps->protectionType = 0;
    if((flag & LOCK_ENABLED)==LOCK_ENABLED)
        dps->protectionType |= DPS_LOCK_ENABLED;
    if((flag & READ_PROTECTED)==READ_PROTECTED)
        dps->protectionType |= DPS_READ_PROTECTED;
    if((flag & WRITE_PROTECTED)==WRITE_PROTECTED)
        dps->protectionType |= DPS_WRITE_PROTECTED;

    /* calculate and store checksum */
    dps->checksum = findChecksum(buffer,SIZE_OF_DPS-1);
}
#endif /* FL_READ_ONLY */
#endif   /*  HW_PROTECTION */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\protectp.h ===
/*******************************************************************
 *
 *    DESCRIPTION: protection header file
 *
 *    AUTHOR: arie tamam
 *
 *    HISTORY: created november 14, 2000   
 *
 *******************************************************************/

#ifndef PROTECT_MDOCP_H
#define PROTECT_MDOCP_H

/** include files **/

/** local definitions **/
/* protection types */

/* default settings */

/** external functions **/
extern FLStatus protectionBoundries(FLFlash vol, byte area ,
                                    CardAddress* addressLow ,
                                    CardAddress* addressHigh ,
                                    byte floorNo);
extern FLStatus protectionKeyInsert(FLFlash  vol, byte area, byte FAR1* key);
extern FLStatus protectionKeyRemove(FLFlash  vol, byte area);
extern FLStatus protectionType(FLFlash vol, byte area,  word* flag);
extern FLStatus setStickyBit(FLFlash * flash);
#ifndef FL_READ_ONLY
extern FLStatus protectionSet ( FLFlash vol, byte area, word flag,
                                CardAddress addressLow,
                                CardAddress addressHigh,
                                byte FAR1* key , byte modes, byte floorNo);
#endif /* FL_READ_ONLY */
/** external data **/

/** internal functions **/

/** public data **/

/** private data **/

/** public functions **/

/** private functions **/
typedef byte HWKey[8];

typedef struct {
     LEulong addressLow;
     LEulong addressHigh;
     HWKey   key;
     byte    protectionType;
     byte    checksum;
}DPSStruct;

#define NdataProtect0Status 0x105C  /* Data Protect Structure Status register[0].read only */
#define NdataProtect1Status 0x105D  /* Data Protect Structure Status register[1].read only */
#define PROTECT_STAT_KEY_OK_MASK    0x10    /* 1=key correctly written */
#define PROTECT_STAT_LOCK_MASK      0x8     /* value of this bit in data protect structure */
#define PROTECT_STAT_WP_MASK        0x4     /* write protect. value of this bit in data protect structure */
#define PROTECT_STAT_RP_MASK        0x2     /* read protect. value of this bit in data protect structure */

#define NdataProtect0Pointer    0x105E  /*Data Protect Structure Pointer register[0]. read only */
#define NdataProtect1Pointer    0x105F  /*Data Protect Structure Pointer register[1]. read only */
#define PROTECT_POINTER_HN_MASK 0xf0    /* high nibble. */
#define PROTECT_POINTER_LN_MASK 0xf0    /* low nibble. */

#define NdataProtect0LowAddr    0x1060  /*Data Protect Lower Address register 0 [3:0].read only*/
#define NdataProtect0UpAddr     0x1064  /*Data Protect Upper Address register 0 [3:0].read only*/

#define NdataProtect1LowAddr    0x1068  /*Data Protect Lower Address register 1 [3:0].read only*/
#define NdataProtect1UpAddr     0x106C  /*Data Protect Upper Address register 1 [3:0].read only*/

#define NdataProtect0Key        0x1070  /*Data Protect Key register[0]. write only*/
#define NdataProtect1Key        0x1072  /*Data Protect Key register[1]. write only*/

/* DPS values */
#define DPS_READ_PROTECTED   0x2
#define DPS_WRITE_PROTECTED  0x4
#define DPS_LOCK_ENABLED     0x8
#endif /* PROTECT_MDOCP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\reedsol.c ===
/* HOOK. Fixed comments; otherwise impossible to compile */
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/REEDSOL.C_V  $
 * 
 *    Rev 1.3   Jul 13 2001 01:10:00   oris
 * Moved saved syndrome array definition (used by d2tst).
 *
 *    Rev 1.2   Apr 09 2001 15:10:20   oris
 * End with an empty line.
 *
 *    Rev 1.1   Apr 01 2001 08:00:14   oris
 * copywrite notice.
 *
 *    Rev 1.0   Feb 04 2001 12:37:38   oris
 * Initial revision.
 *
 */

/************************************************************************/
/*                                                                      */
/*		FAT-FTL Lite Software Development Kit			*/
/*		Copyright (C) M-Systems Ltd. 1995-2001			*/
/*									*/
/************************************************************************/


#include "reedsol.h"

#define T 2			 /* Number of recoverable errors */
#define SYND_LEN (T*2)           /* length of syndrom vector */
#define K512  (((512+1)*8+6)/10) /* number of inf symbols for record
				    of 512 bytes (K512=411) */
#define N512  (K512 + SYND_LEN)  /* code word length for record of 512 bytes */
#define INIT_DEG 510
#define MOD 1023

#define BLOCK_SIZE 512

#ifdef D2TST
byte    saveSyndromForDumping[SYNDROM_BYTES];
#endif /* D2TST */

static short  gfi(short val);
static short  gfmul( short f, short s );
static short  gfdiv( short f, short s );
static short  flog(short val);
static short  alog(short val);

/*------------------------------------------------------------------------------*/
/* Function Name: RTLeightToTen                                                 */
/* Purpose......: convert an array of five 8-bit values into an array of        */
/*                four 10-bit values, from right to left.                       */
/* Returns......: Nothing                                                       */
/*------------------------------------------------------------------------------*/
static void RTLeightToTen(char *reg8, unsigned short reg10[])
{
	reg10[0] =  (reg8[0] & 0xFF)       | ((reg8[1] & 0x03) << 8);
	reg10[1] = ((reg8[1] & 0xFC) >> 2) | ((reg8[2] & 0x0F) << 6);
	reg10[2] = ((reg8[2] & 0xF0) >> 4) | ((reg8[3] & 0x3F) << 4);
	reg10[3] = ((reg8[3] & 0xC0) >> 6) | ((reg8[4] & 0xFF) << 2);
}




/*----------------------------------------------------------------------------*/
static void unpack( short word, short length, short vector[] )
/*                                                                            */
/*   Function unpacks word into vector                                        */
/*                                                                            */
/*   Parameters:                                                              */
/*     word   - word to be unpacked                                           */
/*     vector - array to be filled                                            */
/*     length - number of bits in word                                        */

{
  short i, *ptr;

  ptr = vector + length - 1;
  for( i = 0; i < length; i++ )
  {
    *ptr-- = word & 1;
    word >>= 1;
  }
}


/*----------------------------------------------------------------------------*/
static short pack( short *vector, short length )
/*                                                                            */
/*   Function packs vector into word                                          */
/*                                                                            */
/*   Parameters:                                                              */
/*     vector - array to be packed                                            */
/*     length - number of bits in word                                        */

{
  short tmp, i;

  vector += length - 1;
  tmp = 0;
  i = 1;
  while( length-- > 0 )
  {
    if( *vector-- )
      tmp |= i;
    i <<= 1;
  }
  return( tmp );
}


/*----------------------------------------------------------------------------*/
static short gfi( short val)		/* GF inverse */
{
  return alog((short)(MOD-flog(val)));
}


/*----------------------------------------------------------------------------*/
static short gfmul( short f, short s ) /* GF multiplication */
{
  short i;
  if( f==0 || s==0 )
     return 0;
  else
  {
    i = flog(f) + flog(s);
    if( i > MOD ) i -= MOD;
    return( alog(i) );
  }
}


/*----------------------------------------------------------------------------*/
static short gfdiv( short f, short s ) /* GF division */
{
  return gfmul(f,gfi(s));
}




/*----------------------------------------------------------------------------*/
static void residue_to_syndrom( short reg[], short realsynd[] )
{
   short i,l,alpha,x,s,x4;
   short deg,deg4;


   for(i=0,deg=INIT_DEG;i<SYND_LEN;i++,deg++)
   {
      s = reg[0];
      alpha = x = alog(deg);
      deg4 = deg+deg;
      if( deg4 >= MOD ) deg4 -= MOD;
      deg4 += deg4;
      if( deg4 >= MOD ) deg4 -= MOD;
      x4 = alog(deg4);

      for(l=1;l<SYND_LEN;l++)
      {
	s ^= gfmul( reg[l], x );
	x  = gfmul( alpha, x );
      }

      realsynd[i] = gfdiv( s, x4 );
   }
}


/*----------------------------------------------------------------------------*/
static short alog(short i)
{
  short j=0, val=1;

  for( ; j < i ; j++ )
  {
    val <<= 1 ;

    if ( val > 0x3FF )
    {
      if ( val & 8 )   val -= (0x400+7);
      else             val -= (0x400-9);
    }
  }

  return val ;
}


static short flog(short val)
{
  short j, val1;

  if (val == 0)
    return (short)0xFFFF;

  j=0;
  val1=1;

  for( ; j <= MOD ; j++ )
  {
    if (val1 == val)
      return j;

    val1 <<= 1 ;

    if ( val1 > 0x3FF )
    {
      if ( val1 & 8 )   val1 -= (0x400+7);
      else              val1 -= (0x400-9);
    }

  }

  return 0;
}



/*----------------------------------------------------------------------------*/
static short convert_to_byte_patterns( short *locators, short *values,
				short noferr, short *blocs, short *bvals )
{
  static short mask[] = { 0x0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff };

  short i,j,n, n0, n1, tmp;
  short n_bit, n_byte, k_bit, nb;

  for( i = 0, nb = 0; i< noferr; i++)
  {
    n = locators[i];
    tmp = values[i];
    n_bit = n *10 - 6 ;
    n_byte = n_bit >> 3;
    k_bit  = n_bit - (n_byte<<3);
    n_byte++;
    if( k_bit == 7 )
    {
      /* 3 corrupted bytes */
      blocs[nb] = n_byte+1;
      bvals[nb++] = tmp & 1 ? 0x80 : 0;

      tmp >>= 1;
      blocs[nb] = n_byte;
      bvals[nb++] = tmp & 0xff;

      tmp >>= 8;
      bvals[nb++] = tmp & 0xff;
    }
    else
    {
      n0 = 8 - k_bit;
      n1 = 10 - n0;

      blocs[nb] = n_byte;
      bvals[nb++] = (tmp & mask[n1]) << (8 - n1);

      tmp >>= n1;
      blocs[nb] = n_byte - 1;
      bvals[nb++] = (tmp & mask[n0]);
    }
  }

  for( i = 0, j = -1; i < nb; i++ )
  {
    if( bvals[i] == 0 ) continue;
    if( (blocs[i] == blocs[j]) && ( j>= 0 ) )
    {
      bvals[j] |= bvals[i];
    }
    else
    {
      j++;
      blocs[j] = blocs[i];
      bvals[j] = bvals[i];
    }
  }
  return j+1;
}


/*----------------------------------------------------------------------------*/
static short deg512( short x )
{
  short i;
  short l,m;

  l = flog(x);
  for( i=0;i<9;i++)
  {
    m = 0;
    if( (l & 0x200) )
      m = 1;
    l =  ( ( l << 1 ) & 0x3FF  ) | m;
  }
  return alog(l);
}


/*----------------------------------------------------------------------------*/
static short decoder_for_2_errors( short s[], short lerr[], short verr[] )
{
  /* decoder for correcting up to 2 errors */
  short i,j,k,temp,delta;
  short ind, x1, x2;
  short r1, r2, r3, j1, j2;
  short sigma1, sigma2;
  short xu[10], ku[10];
  short yd, yn;

  ind = 0;
  for(i=0;i<SYND_LEN;i++)
    if( s[i] != 0 )
      ind++;                /* ind = number of nonzero syndrom symbols */

  if( ind == 0 ) return 0;  /* no errors */

  if( ind < 4 )
    goto two_or_more_errors;


/* checking s1/s0 = s2/s1 = s3/s2 = alpha**j for some j */

  r1 = gfdiv( s[1], s[0] );
  r2 = gfdiv( s[2], s[1] );
  r3 = gfdiv( s[3], s[2] );

  if( r1 != r2 || r2 != r3)
    goto two_or_more_errors;

  j = flog(r1);
  if( j > 414 )
    goto two_or_more_errors;

  lerr[0] = j;

/*  pattern = (s0/s1)**(510+1) * s1

	  or

    pattern = (s0/s1)**(512 - 1 )  * s1 */

  temp = gfi( r1 );

#ifndef NT5PORT
  {
    int i;

    for (i = 0; i < 9; i++)
      temp = gfmul( temp, temp );  /* deg = 512 */
  }
#else /*NT5PORT*/
  for (i = 0; i < 9; i++)
  {
      temp = gfmul( temp, temp );  /* deg = 512 */
  }
#endif /*NT5PORT*/

  verr[0] = gfmul( gfmul(temp, r1), s[1] );

  return 1;    /* 1 error */

two_or_more_errors:

  delta = gfmul( s[0], s[2] ) ^ gfmul( s[1], s[1] );

  if( delta == 0 )
    return -1;  /* uncorrectable error */

  temp = gfmul( s[1], s[3] ) ^ gfmul( s[2], s[2] );

  if( temp == 0 )
    return -1;  /* uncorrectable error */

  sigma2 = gfdiv( temp, delta );

  temp = gfmul( s[1], s[2] ) ^ gfmul( s[0], s[3] );

  if( temp == 0 )
    return -1;  /* uncorrectable error */

  sigma1 = gfdiv( temp, delta );

  k = gfdiv( sigma2, gfmul( sigma1, sigma1 ) );

  unpack( k, 10, ku );

  if( ku[2] != 0 )
    return -1;

  xu[4] = ku[9];
  xu[5] = ku[0] ^ ku[1];
  xu[6] = ku[6] ^ ku[9];
  xu[3] = ku[4] ^ ku[9];
  xu[1] = ku[3] ^ ku[4] ^ ku[6];
  xu[0] = ku[0] ^ xu[1];
  xu[8] = ku[8] ^ xu[0];
  xu[7] = ku[7] ^ xu[3] ^ xu[8];
  xu[2] = ku[5] ^ xu[7] ^ xu[5] ^ xu[0];
  xu[9] = 0;

  x1 = pack( xu, 10 );
  x2 = x1 | 1;

  x1 = gfmul( sigma1, x1 );
  x2 = gfmul( sigma1, x2 );


  j1 = flog(x1);
  j2 = flog(x2);

  if( (j1 > 414) || (j2 > 414) )
    return -1;


  r1 = x1 ^ x2;
  r2 = deg512( x1 );
  temp = gfmul( x1, x1 );
  r2 = gfdiv( r2, temp );
  yd = gfmul( r2, r1 );

  if( yd == 0 )
    return -1;

  yn = gfmul( s[0], x2 ) ^ s[1];
  if( yn == 0 )
    return -1;

  verr[0] = gfdiv( yn, yd );

  r2 = deg512( x2 );
  temp = gfmul( x2, x2 );
  r2 = gfdiv( r2, temp );
  yd = gfmul( r2, r1 );

  if( yd == 0 )
    return -1;

  yn = gfmul( s[0], x1 ) ^ s[1];
  if( yn == 0 )
    return -1;

  verr[1] = gfdiv( yn, yd );

  if( j1 > j2 ) {
    lerr[0] = j2;
    lerr[1] = j1;
    temp = verr[0];
    verr[0] = verr[1];
    verr[1] = temp;
  }
  else
  {
    lerr[0] = j1;
    lerr[1] = j2;
  }

  return 2;
}


/*------------------------------------------------------------------------------*/
/* Function Name: flDecodeEDC                                                   */
/* Purpose......: Trys to correct errors.                                       */
/*                errorSyndrom[] should contain the syndrom as 5 bytes and one  */
/*                parity byte. (identical to the output of calcEDCSyndrom()).   */
/*                Upon returning, errorNum will contain the number of errors,   */
/*                errorLocs[] will contain error locations, and                 */
/*                errorVals[] will contain error values (to be XORed with the   */
/*                data).                                                        */
/*                Parity error is relevant only if there are other errors, and  */
/*                the EDC code fails parity check.                              */
/*                NOTE! Only the first errorNum indexes of the above two arrays */
/*                      are relevant. The others contain garbage.               */
/* Returns......: The error status.                                             */
/*                NOTE! If the error status is NO_EDC_ERROR upon return, ignore */
/*                      the value of the arguments.                             */
/*------------------------------------------------------------------------------*/
EDCstatus flDecodeEDC(char *errorSyndrom, char *errorsNum,
		    short errorLocs[3*T],  short errorVals[3*T])
{
  short noferr;                         /* number of errors */
  short dec_parity;                     /* parity byte of decoded word */
  short rec_parity;                     /* parity byte of received word */
  short realsynd[SYND_LEN];             /* real syndrom calculated from residue */
  short locators[T],                    /* error locators */
  values[T];                            /* error values */
  short reg[SYND_LEN];                  /* register for main division procedure */
  int i;

  RTLeightToTen(errorSyndrom, (unsigned short *)reg);
  rec_parity = errorSyndrom[5] & 0xFF;  /* The parity byte */

  residue_to_syndrom(reg, realsynd);
  noferr = decoder_for_2_errors(realsynd, locators, values);

  if(noferr == 0)
    return NO_EDC_ERROR;                /* No error found */

  if(noferr < 0)                        /* If an uncorrectable error was found */
    return UNCORRECTABLE_ERROR;

  for (i=0;i<noferr;i++)
    locators[i] = N512 - 1 - locators[i];

  *errorsNum = (char)convert_to_byte_patterns(locators, values, noferr, errorLocs, errorVals);

  for(dec_parity=i=0; i < *errorsNum; i++)/* Calculate the parity for all the */
  {                                       /*   errors found: */
    if(errorLocs[i] <= 512)
      dec_parity ^= errorVals[i];
  }

  if(dec_parity != rec_parity)
    return UNCORRECTABLE_ERROR;         /* Parity error */
  else
    return CORRECTABLE_ERROR;
}


/*------------------------------------------------------------------------------*/
/* Function Name: flCheckAndFixEDC                                              */
/* Purpose......: Decodes the EDC syndrom and fixs the errors if possible.      */
/*                block[] should contain 512 bytes of data.                     */
/*                NOTE! Call this function only if errors where detected by     */
/*                      syndCalc or by the ASIC module.                         */
/* Returns......: The error status.                                             */
/*------------------------------------------------------------------------------*/
EDCstatus flCheckAndFixEDC(char FAR1 *block, char *syndrom, FLBoolean byteSwap)
{
  char errorsNum;
  short errorLocs[3*T];
  short errorVals[3*T];
  EDCstatus status;

  status = flDecodeEDC(syndrom, &errorsNum, errorLocs, errorVals);

  if(status == CORRECTABLE_ERROR)       /* Fix the errors if possible */
  {
    int i;

    for (i=0; i < errorsNum; i++)
      if( (errorLocs[i] ^ byteSwap) < BLOCK_SIZE )  /* Fix only in Data Area */
        block[errorLocs[i] ^ byteSwap] ^= errorVals[i];

    return NO_EDC_ERROR;                /* All errors are fixed */
  }
  else
    return status;                      /* Uncorrectable error */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\reedsol.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/REEDSOL.H_V  $
 * 
 *    Rev 1.2   Jul 13 2001 01:10:10   oris
 * Moved syndrome byte length definition (SYNDROM_BYTES).
 * Moved saved syndrome array forward definition (used by d2tst).
 *
 *    Rev 1.1   Apr 01 2001 08:00:20   oris
 * copywrite notice.
 *
 *    Rev 1.0   Feb 04 2001 12:37:48   oris
 * Initial revision.
 *
 */

/************************************************************************/
/*                                                                      */
/*		FAT-FTL Lite Software Development Kit			*/
/*		Copyright (C) M-Systems Ltd. 1995-2001		*/
/*									*/
/************************************************************************/


#ifndef FLEDC_H
#define FLEDC_H

#include "flbase.h"

#define SYNDROM_BYTES            6

/* Global variable containing the EDC/ECC of the last operation */

#ifdef D2TST
extern byte    saveSyndromForDumping[SYNDROM_BYTES];
#endif /* D2TST */

typedef enum { NO_EDC_ERROR, CORRECTABLE_ERROR, UNCORRECTABLE_ERROR, EDC_ERROR } EDCstatus;

EDCstatus flCheckAndFixEDC(char FAR1 *block, char *syndrom, FLBoolean byteSwap);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\nftllite.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/NFTLLITE.C_V  $
 * 
 *    Rev 1.27   Apr 15 2002 07:38:22   oris
 * Added support for RAM based MTD power failure tests.
 * Remove cache allocation checks - They are not needed since the cache routine itself check for proper allocation.
 * Improved power failure resistant:
 *  - Added support for VERIFY_ERASED_SECTOR compilation flag - make sure a sector is free before writing it.
 *  - writeAndCheck() - 
 *    1) Added an option to verify that the sector is erased before writing. 
 *    It subject to the FL_UPS/FL_OFF/FL_ON modes of the flVerifyWrite environment variable.
 *    2) Added support for partition > 0.
 *  - getUnitData() - Bug fix - in case of invalid replacement unit if we are mounting or formatting store physical unit number in
 *    invalidReplacement field of the Anand record otherwise mark head of chain as frozen and not the unit itself.
 *  - Bug fix - Added logic to find end of endless loops - findEndOfEndlessLoop()
 *  - virtual2Physical() - Added call to findEndOfEndlessLoop() if needed and return address of next free sector (used verifySector()).
 *  - initNFTL() - Added initialization of TL verifyBuffer buffer and invalidReplacement fields.
 *  - Separated the search for a free unit in physical table from allocateUnit() into dedicated routine findFreeUnit().
 *  - foldUnit()
 *    1) Added support for partition > 0.
 *    2) Prevent a recursive call to foldUnit by changing allocateUnit() with findFreeUnit().
 *    3) Added logic for endless loops.
 *    4) Added check that last sector of chain can be used.
 *  - foldBestChain() - revised the entire routine
 *    1) If folding not in place was forced free all frozen units.
 *    2) Validate that a unit was actually freed.
 *  - mountUnit() -
 *    1) In case of bad virtual unit number format the unit . An invalid virtual unit might be a result of power failures.
 *  - allocateAndWrite() - Bug fix - sector count might be incorrectly updated in case folding found a sector with bad EDC.
 *  - mountNFTL -
 *    1) Moved badFormat initialization to the end of the routine so that getUnitData() might know if it was called by mount routine.
 *    2) Made sure there is at least 1 free unit.
 *    3) Fold chains with invalid pointer in their end of chain - caused by power failures.
 *  - Added MAKE_SURE_IGNORE_HAS_BAD_EDC compilation flag - make sure that the sector is really marked
 *  - verifySector() - was completely revised.
 * 
 *    Rev 1.26   Feb 19 2002 21:00:56   oris
 * Compilation errors - NO_READ_BBT_CODE
 * Removed warnings.
 * Replaced TL_LEAVE_BINARY_AREA with FL_LEAVE_BINARY_AREA
 * 
 *    Rev 1.25   Jan 29 2002 20:09:58   oris
 * Bug fix - if an invalid sector flag is found in getSectorFlags routine and read operation failed, SECTOR_IGNORED should have been returned.
 * 
 *    Rev 1.24   Jan 23 2002 23:33:56   oris
 * Improved markAsIgnored routine.
 * Changed DFORMAT_PRINT syntax.
 * 
 *    Rev 1.23   Jan 20 2002 20:29:26   oris
 * Remove warnings
 * Bug fix - Missing cache buffers allocation check in formatUnit.
 * 
 *    Rev 1.22   Jan 17 2002 23:04:22   oris
 * Added onesCount routine - number of bits in a byte.
 * Improved FL_READ_ONLY compilation mode.
 * Flash field of the TL was changed to a pointer.
 * Added check verifyVolume routine to issue a longer, but safer mount.
 * Moved RAM tables to far heap to allow BIOS driver to allocate far  memory heap even when compiled as tiny model:
 *  - InitTables : allocation was change from FL_MALLOC to FL_FAR_MALLOC.
 *  - mountUnit : changes pointer to virtual table to be FAR. 
 *  - mountNFTL : 
 *    - changes pointer to virtual table to be FAR.
 *    - allocation of cache tables was change from FL_MALLOC to  FL_FAR_MALLOC.
 *  - dismount : use FL_FAR_FREE instead of FL_FREE
 * formatUnit routine improved re-initialization of sector cache.
 * Changed flPolicy to be socket specific.
 * Added \r to all DEBUG_PRINT.
 * writeSector routine if this sector is the cached sector then force  re-mapping.
 * Bug fix in formatNFTL :
 *  - Add binary length to percentage of bad blocks.
 *  - Report error if there is not enough good blocks.
 *  - Report error if block 0 is bad.
 * New power failures protection algorithm
 *  - setUnitData : When verify write is on , no need to reread unit data
 *  - getSectorFlags : if flags is not valid (including SECTOR_IGNORE)  check EDC and bit distance instead of simple or.
 *  - virtual2Physical : Added endAddress parameter to allow retrieval of  not the newest sector.
 *  - writeAndCheck : 
 *    - Toggle socket verify write mode according to global verify write  mode.
 *    - Moved the marking of the sector as bad into a dedicated routine  (markAsIgnored)
 *  - initNftl : 
 *    - Init FLFlash pointer (and not structure) 
 *    - Init socket number of the TL
 *    - Init verifiedSectorNo for FL_OFF verify write mode
 *  - swapUnits : Catch failed folding operation
 *  - Moved copySector routine into foldUnit.
 *  - Changed chain bound for all chains "for loops" to the constant  DOUBLE_MAX_UNIT_CHAIN (support MAX_UNIT_CHAIN of 1 in case of folding  not in place).
 *  - foldUnit : 
 *    - When verify write is set to FL_OFF call verifySectors routine to  gradually scan the entire media
 *    - Force re-mapping of cached sector
 *    - Add force folding parameter
 *    - Toggle socket verify write mode according to verify write mode and  currently scanned sector number
 *    - Verify copied sector EDC even for last sector of chain (no need to  copy it) and if bad freeze chain and return flCanNotFold (unless forced  folding is issued)
 *    - In case of bad EDC use older sector.
 *    - In case write operation failed (could be partially written sector  that was discovered by verify write mode) freeze chain and return  flCanNotFold (unless forced folding is issued)
 *  - foldBestChain : if folding of the chosen unit failed, freeze and try  another unit MAX_FOLDING_TRIES times.
 *  - allocateUnit : free media space even if there is  a free unit  available 
 *  - mapSector : if sector has bad EDC read older sector until no sectors  were found or chain bound has been reached
 *  - allocateAndWriteSector : 
 *    - Catch failed folding operation.
 *    - Set curSectorWrite to current sector so that writeAndCheck routine  will be able to decide whether to verify this sector or not while in  FL_OFF verify mode.
 *  - deleteSectors : Catch failed folding operation.
 *  - mountNFTL : 
 *    - Set default verify write policy to FL_UPS.
 *    - Set checkVolme routine pointer.
 *  - Added checkVolume / checkFolding / verifySectors and markAsIgnored  routines. 
 *
 *    Rev 1.21   Nov 21 2001 11:38:04   oris
 * Changed FL_MARK_DELETE to FL_ON.
 *
 *    Rev 1.20   15 Nov 2001 16:28:24   dimitrys
 * Fix Big BDK partition with Bad Units problem in formatNFTL()
 *
 *    Rev 1.19   Sep 25 2001 15:39:58   oris
 * Removed warnings.
 *
 *    Rev 1.18   Jul 29 2001 18:48:50   oris
 * Bug fix - unit 0 of floors > 0 were not marked as bad blocks therefore future write operation might force the device into external eprom mode.
 *
 *    Rev 1.17   Jul 15 2001 20:45:26   oris
 * Changed DFORMAT_PRINT syntax to be similar to DEBUG_PRINT.
 *
 *    Rev 1.16   Jul 13 2001 01:08:38   oris
 * Removed EDC for media header.
 * Added dformat debug print for virgin media.
 *
 *    Rev 1.15   Jun 17 2001 16:39:12   oris
 * Improved documentation and remove warnings.
 *
 *    Rev 1.14   Jun 17 2001 08:17:34   oris
 * Removed warnings.
 * Changed erase routine to formatUnit.
 * Bug fix - original meida header was not written.
 * Added NO_READ_BBT_CODE compilation flag to reduce code size.
 *
 *    Rev 1.13   May 29 2001 23:12:28   oris
 * Added EDC check of the media header both in the mount and format routines.
 *
 *    Rev 1.12   May 16 2001 21:21:26   oris
 * Added EDC check for media header.
 * Added the FL_ prefix to the following defines: ON , OFF, MALLOC and FREE.
 * Changed wear level counter from 0xFF to 0xFFF0
 *
 *    Rev 1.11   May 06 2001 22:42:26   oris
 * Removed warnings.
 *
 *    Rev 1.10   May 01 2001 16:33:46   oris
 * Bug fix - readBBT routine returned used blocks as bad.
 *
 *    Rev 1.9   Apr 30 2001 18:03:30   oris
 * Bug fix - marking binary partition blocks of devices that use artifitial large erase blocks (units).
 * Added support for the flMarkDeleteOnFlash environment variable.
 *
 *    Rev 1.8   Apr 24 2001 17:10:14   oris
 * Bug fix - readBBT routine missing casting.
 *
 *    Rev 1.7   Apr 16 2001 13:56:46   oris
 * Removed warrnings.
 *
 *    Rev 1.6   Apr 09 2001 15:04:42   oris
 * End with an empty line.
 *
 *    Rev 1.5   Apr 01 2001 07:55:42   oris
 * copywrite notice.
 * changed SEPERATED to SEPARATED.
 * Changed SEPARATED_CASCADED ifdef to a runtime if.
 *
 *    Rev 1.3   Feb 14 2001 02:03:38   oris
 * Changed readBBT to return media size.
 *
 *    Rev 1.2   Feb 12 2001 12:10:56   oris
 * Moved SEPARATED cascaded to include more uneeded code.
 * Rewritten readBBT to support far pointers.
 *
 *    Rev 1.1   Feb 07 2001 17:46:26   oris
 * Added SEPARATED_CASCADED compilation flag
 *
 *    Rev 1.0   Feb 05 2001 12:24:18   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#include "nftllite.h"
#include "nanddefs.h"

#ifndef FL_READ_ONLY
#if (defined(VERIFY_WRITE) || defined (VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
static FLStatus checkVolume(Anand vol);
static FLStatus verifySectors(Anand vol, dword sectorCount);
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */
static void markAsIgnored(Anand vol,CardAddress addr);
static FLStatus foldBestChain(Anand vol, ANANDUnitNo *unitNo);
static FLStatus foldUnit(Anand vol, ANANDUnitNo virtualUnitNo, FLBoolean);
static FLStatus checkFolding(Anand vol, ANANDUnitNo virtualUnitNo);
static FLStatus allocateUnit(Anand vol, ANANDUnitNo *);
#endif /* FL_READ_ONLY */
static Anand vols[VOLUMES];

#ifdef NFTL_CACHE
/* translation table for Sector Flags cache */
static unsigned char scacheTable[4] = { SECTOR_DELETED, /* 0 */
                    SECTOR_IGNORE,  /* 1 */
                    SECTOR_USED,    /* 2 */
                    SECTOR_FREE };  /* 3 */
#endif /* NFTL_CACHE */
#ifdef FORMAT_VOLUME
byte ff[ANAND_SPARE_SIZE];
#endif /* FORMAT_VOLUME */

/*------------------------------------------------------*/
/*                o n e s C o u n t                     */
/*                                                      */
/*  counts number of bits that valued 1 in a given byte */
/*------------------------------------------------------*/

static byte onesCount(byte flag)
{
   byte counter;

   for (counter = 0; flag; flag >>= 1)
          if (flag & 1)
           counter++;

   return counter;
}


/*----------------------------------------------------------------------*/
/*                 u n i t B a s e A d d r e s s                        */
/*                                                                      */
/* Returns the physical address of a unit.                              */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo        : Physical unit number                              */
/*                                                                      */
/* Returns:                                                             */
/*    physical address of unitNo                                        */
/*----------------------------------------------------------------------*/

static CardAddress unitBaseAddress(Anand vol, ANANDUnitNo unitNo)
{
  return (CardAddress)unitNo << vol.unitSizeBits;
}


/*----------------------------------------------------------------------*/
/*                 g e t U n i t D a t a                                */
/*                                                                      */
/* Get virtual unit No. and replacement unit no. of a unit.             */
/*                                                                      */
/* Parameters:                                                          */
/*    vol               : Pointer identifying drive                     */
/*    unitNo            : Physical unit number                          */
/*    virtualUnitNo     : Receives the virtual unit no.                 */
/*    replacementUnitNo : Receives the replacement unit no.             */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void getUnitData(Anand vol,
            ANANDUnitNo unitNo,
            ANANDUnitNo *virtualUnitNo,
            ANANDUnitNo *replacementUnitNo)
{
  ANANDUnitHeader unitData;

#ifdef NFTL_CACHE
  /* check ANANDUnitHeader cache first */
  if (vol.ucache != NULL) {
      /* on cache miss read ANANDUnitHeader from flash and re-fill cache */
      if((vol.ucache[unitNo].virtualUnitNo == 0xDEAD) &&
      (vol.ucache[unitNo].replacementUnitNo == 0xDEAD)) {
          vol.flash->read(vol.flash,
                     unitBaseAddress(&vol,unitNo) + UNIT_DATA_OFFSET,
                 &unitData,
                 sizeof(ANANDUnitHeader),
                 EXTRA);

      vol.ucache[unitNo].virtualUnitNo =
          LE2(unitData.virtualUnitNo) | LE2(unitData.spareVirtualUnitNo);
      vol.ucache[unitNo].replacementUnitNo =
          LE2(unitData.replacementUnitNo) | LE2(unitData.spareReplacementUnitNo);
      }

      *virtualUnitNo     = vol.ucache[unitNo].virtualUnitNo;
      *replacementUnitNo = vol.ucache[unitNo].replacementUnitNo;
  }
  else
#endif /* NFTL_CACHE */
  {   /* no ANANDUnitHeader cache */
      vol.flash->read(vol.flash,
                      unitBaseAddress(&vol,unitNo) + UNIT_DATA_OFFSET,
                      &unitData,
                      sizeof(ANANDUnitHeader),
                      EXTRA);

      /* Mask out any 1 -> 0 bit faults by or'ing with spare data */
      *virtualUnitNo = LE2(unitData.virtualUnitNo) |
                   LE2(unitData.spareVirtualUnitNo);
      *replacementUnitNo = LE2(unitData.replacementUnitNo) |
                       LE2(unitData.spareReplacementUnitNo);
  }
  if( !isLegalUnit(*replacementUnitNo) ) {
    vol.invalidReplacement = unitNo; 
    if(vol.badFormat == FALSE) /* Not called by mount operation */
    {
       ANANDUnitNo firstUnits = vol.virtualUnits[*virtualUnitNo];
       if(firstUnits != ANAND_NO_UNIT)
          setUnavail(firstUnits & (~ANAND_REPLACING_UNIT));      /* freeze unit chain */
    }
    *replacementUnitNo = ANAND_NO_UNIT;
  }
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                 s e t U n i t D a t a                                */
/*                                                                      */
/* Set virtual unit No. and replacement unit no. of a unit.             */
/*                                                                      */
/* Parameters:                                                          */
/*    vol               : Pointer identifying drive                     */
/*    unitNo            : Physical unit number                          */
/*    virtualUnitNo     : Virtual unit no.                              */
/*    replacementUnitNo : Replacement unit no.                          */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus      : 0 on success, failed otherwise                    */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus setUnitData(Anand vol,
              ANANDUnitNo unitNo,
              ANANDUnitNo virtualUnitNo,
              ANANDUnitNo replacementUnitNo)
{
  ANANDUnitHeader unitData;
  ANANDUnitNo newVirtualUnitNo, newReplacementUnitNo;

  if( replacementUnitNo == unitNo )              /* prevent chain loop */
    return flGeneralFailure;

  toLE2(unitData.virtualUnitNo,virtualUnitNo);
  toLE2(unitData.spareVirtualUnitNo,virtualUnitNo);
  toLE2(unitData.replacementUnitNo,replacementUnitNo);
  toLE2(unitData.spareReplacementUnitNo,replacementUnitNo);

  checkStatus(vol.flash->write(vol.flash,
                   unitBaseAddress(&vol,unitNo) + UNIT_DATA_OFFSET,
                   &unitData,
                   sizeof(ANANDUnitHeader),
                   EXTRA));

#ifdef VERIFY_WRITE
  if (vol.flash->socket->verifyWrite==FL_ON)
  {
#ifdef NFTL_CACHE
    /* Set new entries for ANANDUnitHeader cache */
     if (vol.ucache != NULL) {
         vol.ucache[unitNo].virtualUnitNo     = virtualUnitNo;
         vol.ucache[unitNo].replacementUnitNo = replacementUnitNo;
     }
#endif /* NFTL_CACHE */
     return flOK;
  }
#endif /* VERIFY_WRITE */


#ifdef NFTL_CACHE
  /* purge ANANDUnitHeader cache to force re-filling from flash */
  if (vol.ucache != NULL) {
      vol.ucache[unitNo].virtualUnitNo     = 0xDEAD;
      vol.ucache[unitNo].replacementUnitNo = 0xDEAD;
  }
#endif /* NFTL_CACHE */

  /* Verify the new unit data */
  getUnitData(&vol,unitNo,&newVirtualUnitNo, &newReplacementUnitNo);
  if (virtualUnitNo != newVirtualUnitNo ||
      replacementUnitNo != newReplacementUnitNo)
    return flWriteFault;
  else
    return flOK;
}

#endif /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                 g e t N e x t U n i t                                */
/*                                                                      */
/* Get next unit in chain.                                              */
/*                                                                      */
/* Parameters:                                                          */
/*    vol             : Pointer identifying drive                       */
/*    unitNo          : Physical unit number                            */
/*    virUnitNo       : Virtual unit number of the chain.               */
/*                                                                      */
/* Returns:                                                             */
/*     Physical unit number of the unit following unitNo in the chain.  */
/*     If such unit do not exist, return ANAND_NO_UNIT.                 */
/*----------------------------------------------------------------------*/

static ANANDUnitNo getNextUnit(Anand vol, ANANDUnitNo unitNo, ANANDUnitNo virUnitNo)
{
  ANANDUnitNo virtualUnitNo, replacementUnitNo;

  if (!(vol.physicalUnits[unitNo] & UNIT_REPLACED))
    return ANAND_NO_UNIT;

  getUnitData(&vol,unitNo,&virtualUnitNo,&replacementUnitNo);
  if( virUnitNo != (virtualUnitNo & ~ANAND_REPLACING_UNIT) ) {
    unitNo = vol.virtualUnits[virUnitNo];
    setUnavail(unitNo); /* freeze unit chain */
    return ANAND_NO_UNIT;
  }

  return replacementUnitNo;
}


#ifdef NFTL_CACHE

/*----------------------------------------------------------------------*/
/*         g e t S e c t o r F l a g s F r o m C a c h e                */
/*                                                                      */
/* Get sector flags from Sector Cache.                                  */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    address        : starting address of the sector                   */
/*                                                                      */
/* Returns:                                                             */
/*    sector flags (SECTOR_USED, SECTOR_DELETED etc.)                   */
/*----------------------------------------------------------------------*/
static unsigned char getSectorFlagsFromCache(Anand vol, CardAddress address)
{
  return scacheTable[(vol.scache[address >> (SECTOR_SIZE_BITS+2)] >>
             (((unsigned int)address >> 8) & 0x7)) & 0x3];
}


/*----------------------------------------------------------------------*/
/*             s e t S e c t o r F l a g s C a c h e                    */
/*                                                                      */
/* Get sector flags from Sector Cache.                                  */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    address        : starting address of the sector                   */
/*    sectorFlags    : one of SECTOR_USED, SECTOR_DELETED etc.          */
/*                                                                      */
/*----------------------------------------------------------------------*/
static void setSectorFlagsCache(Anand vol, CardAddress address,
                unsigned char sectorFlags)
{
  register unsigned char tmp, val;

  if (vol.scache == NULL)
    return;

  tmp = vol.scache[address >> (SECTOR_SIZE_BITS+2)];

  switch(sectorFlags) {
    case SECTOR_USED:          val = S_CACHE_SECTOR_USED;    break;
    case SECTOR_FREE:          val = S_CACHE_SECTOR_FREE;    break;
    case SECTOR_DELETED:       val = S_CACHE_SECTOR_DELETED; break;
    default:/* SECTOR_IGNORE */val = S_CACHE_SECTOR_IGNORE;  break;
  }

  switch (((unsigned int)address >> 8) & 0x7) {
    case 0: tmp = (tmp & 0xfc) | (val     ); break;  /* update bits 0..1 */
    case 2: tmp = (tmp & 0xf3) | (val << 2); break;  /*        bits 2..3 */
    case 4: tmp = (tmp & 0xcf) | (val << 4); break;  /*        bits 4..5 */
    case 6: tmp = (tmp & 0x3f) | (val << 6); break;  /*        bits 6..7 */
  }

  vol.scache[address >> (SECTOR_SIZE_BITS+2)] = tmp;
}

#endif /* NFTL_CACHE */



/*----------------------------------------------------------------------*/
/*                  g e t S e c t o r F l a g s                         */
/*                                                                      */
/* Get sector status.                                                   */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*     sectorAddress        : Physical address of the sector            */
/*                                                                      */
/* Returns:                                                             */
/*    Return the OR of the two bytes in the sector status area (the     */
/*    bytes should contain the same data).                              */
/*----------------------------------------------------------------------*/

static unsigned char getSectorFlags(Anand vol, CardAddress sectorAddress)
{
  byte     flags[2];
  byte     blockFlag = SECTOR_IGNORE;
  byte     index,tmpSector;
  FLStatus status;

#ifdef NFTL_CACHE
  if (vol.scache != NULL) {  /* check for Sector Flags cache hit */

    blockFlag = getSectorFlagsFromCache(&vol, sectorAddress);
    if (blockFlag != SECTOR_IGNORE)
      return blockFlag;
  }
#endif /* NFTL_CACHE */

  vol.flash->read(vol.flash, sectorAddress + SECTOR_DATA_OFFSET,
                  flags, sizeof flags, EXTRA);

  if((flags[0] == flags[1]) && (isValidSectorFlag(flags[0])))
  {
     blockFlag = flags[0];
  }
  else /* Sector flags that were read are not legal */
  {
     /* Force remapping of internal catched sector */
     vol.flash->socket->remapped = TRUE;

     /* Check for ignored sector using the EDC */
     status = vol.flash->read(vol.flash, sectorAddress,
                              nftlBuffer, SECTOR_SIZE, EDC);

     if(status == flOK)
     {
        /* Check if distance is less then 2 bits failure since */
        /* 2 bits failure can be either delete or used         */
        for (index=0 , tmpSector = (byte)SECTOR_USED ; index < 2 ;
             index++ , tmpSector = (byte)SECTOR_DELETED)
        {
           if (distanceOf(flags[0], tmpSector) +
               distanceOf(flags[1], tmpSector) <= 2)
           {
              blockFlag = tmpSector;
              break;
           }
        }
        if(index>=2)
           return SECTOR_IGNORE;
     }
     else
     {
        return SECTOR_IGNORE;
     }
  }

#ifdef NFTL_CACHE
  /* update Sector Flags cache */
  setSectorFlagsCache(&vol, sectorAddress, blockFlag);
#endif /* NFTL_CACHE */

  return blockFlag;
}

/*----------------------------------------------------------------------*/
/*            f i n d E n d O f E n d l e s s C h a i n                 */
/*                                                                      */
/* Find end of endless chain - last unit of unit chain that points to   */
/* itself.                                                              */
/*                                                                      */
/* Parameters:                                                          */
/*    vol          : Pointer identifying drive                          */
/*    virUnitNo    : Virtual unit number                                */ 
/*                                                                      */
/* Returns:                                                             */
/*    Physical unit number of oldest unit of the chain                  */ 
/*----------------------------------------------------------------------*/

static ANANDUnitNo findEndOfEndlessChain(Anand vol, ANANDUnitNo virUnitNo)
{  
  ANANDUnitNo chainsUnit[DOUBLE_MAX_UNIT_CHAIN/2+2];
  ANANDUnitNo unitNo;
  int         i;
  int         chainBound;

  for (unitNo    = vol.virtualUnits[virUnitNo] , chainBound = 0 ;  
       chainBound < MAX_UNIT_CHAIN ;
       unitNo    = getNextUnit(&vol,unitNo,virUnitNo) , chainBound++) 
  {
     chainsUnit[chainBound] = unitNo; /* Save location of current unit */
    
     for(i = 0 ; i < chainBound ; i++) /* Check if already been to this unit */
     {
        if(chainsUnit[chainBound] == unitNo) /* Bad next unit number pointer */
            break;
     }
  }
  return chainsUnit[chainBound-1];  
}

/*----------------------------------------------------------------------*/
/*                 v i r t u a l 2 P h y s i c a l                      */
/*                                                                      */
/* Translate virtual sector number to physical address.                 */
/*                                                                      */
/* Parameters:                                                          */
/*    vol          : Pointer identifying drive                          */
/*    sectorNo     : Virtual sector number                              */
/*    endAddress   : End address for sector search. NULL for no end     */
/*                                                                      */
/* Returns:                                                             */
/*    endAddress   : Next free sector address                           */
/*    physical address of sectorNo                                      */
/*----------------------------------------------------------------------*/

static CardAddress virtual2Physical(Anand vol, SectorNo sectorNo , CardAddress* endAddress)
{
  unsigned unitOffset = (unsigned)((sectorNo % vol.sectorsPerUnit) << SECTOR_SIZE_BITS);
  CardAddress prevSectorAddress = ANAND_UNASSIGNED_ADDRESS;
  CardAddress sectorAddress;
  CardAddress *freeSectorAddressPtr;
  ANANDUnitNo unitNo, virUnitNo;
  ANANDUnitNo chainBound = 0;
  ANANDUnitNo endUnit;
  byte        sectorFlags;
  FLBoolean   badPointerFound = FALSE;

  /* Set end unit and nextFreeSectorAddress */
  if(endAddress == NULL)
  {
     endUnit = ANAND_NO_UNIT;
  }
  else
  {
     endUnit = (ANANDUnitNo)(*endAddress>>vol.unitSizeBits);
     *endAddress = ANAND_UNASSIGNED_ADDRESS;
  }

  /* follow the chain */
  virUnitNo = (ANANDUnitNo)(sectorNo / vol.sectorsPerUnit);
  for (unitNo = vol.virtualUnits[virUnitNo];
       ( (unitNo != endUnit) && (chainBound < DOUBLE_MAX_UNIT_CHAIN) );
       unitNo = getNextUnit(&vol,unitNo,virUnitNo)) 
  {
    sectorAddress = unitBaseAddress(&vol,unitNo) + unitOffset;
    sectorFlags   = getSectorFlags(&vol,sectorAddress);

    if (sectorFlags == SECTOR_FREE)
    {
      if(endAddress != NULL)
         *endAddress = sectorAddress;
      break;
    }

    if (sectorFlags != SECTOR_IGNORE)
      prevSectorAddress = sectorFlags != SECTOR_DELETED ? sectorAddress :
                            ANAND_UNASSIGNED_ADDRESS;
    chainBound++;
  }

  if(chainBound < DOUBLE_MAX_UNIT_CHAIN) 
     return prevSectorAddress;

  /* Infint loop caused by power failure */
  if(endAddress == NULL)
  {
     freeSectorAddressPtr = &sectorAddress;
  }
  else
  {
      freeSectorAddressPtr = endAddress;
  }
  *freeSectorAddressPtr = unitOffset + 
                          unitBaseAddress(&vol,
                          findEndOfEndlessChain(&vol,virUnitNo));
  return virtual2Physical(&vol, sectorNo , freeSectorAddressPtr);
}


/*----------------------------------------------------------------------*/
/*                 g e t F o l d M a r k                                */
/*                                                                      */
/* Get the fold mark a unit.                                            */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo        : Physical unit number                              */
/*                                                                      */
/* Returns:                                                             */
/*    Return the OR of the two words in the fold mark area (the words   */
/*    should be identical)                                              */
/*----------------------------------------------------------------------*/

static unsigned short getFoldMark(Anand vol, ANANDUnitNo unitNo)
{
  unsigned short foldMark[2];

  vol.flash->read(vol.flash,
          unitBaseAddress(&vol,unitNo) + FOLD_MARK_OFFSET,
          foldMark, sizeof foldMark,
          EXTRA);

  return foldMark[0] | foldMark[1];
}


/*----------------------------------------------------------------------*/
/*                 g e t U n i t T a i l e r                            */
/*                                                                      */
/* Get the erase record of a unit.                                      */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo        : Physical unit number                              */
/*    eraseMark    : Receives the erase mark of the unit                */
/*    eraseCount    : Receives the erase count of the unit              */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void getUnitTailer(Anand vol,
              ANANDUnitNo unitNo,
              unsigned short *eraseMark,
              unsigned long *eraseCount)
{
  UnitTailer unitTailer;

  vol.flash->read(vol.flash,
          unitBaseAddress(&vol,unitNo) + UNIT_TAILER_OFFSET,
          &unitTailer,
          sizeof(UnitTailer),
          EXTRA);

  /* Mask out any 1 -> 0 bit faults by or'ing with spare data */
  *eraseMark = LE2(unitTailer.eraseMark) | LE2(unitTailer.eraseMark1);
  *eraseCount = LE4(unitTailer.eraseCount);
}

/*----------------------------------------------------------------------*/
/*                        s e t U n i t T a i l e r                     */
/*                                                                      */
/* Set the erase record of a unit.                                      */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo        : Physical unit number                              */
/*    eraseMark    : Erase mark to set                                  */
/*    eraseCount    : Erase count to set                                */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus setUnitTailer(Anand vol,
                ANANDUnitNo unitNo,
                unsigned short eraseMark,
                unsigned long eraseCount)
{
  UnitTailer unitTailer;

  toLE2(unitTailer.eraseMark,eraseMark);
  toLE2(unitTailer.eraseMark1,eraseMark);
  toLE4(unitTailer.eraseCount,eraseCount);

  return vol.flash->write(vol.flash,
              unitBaseAddress(&vol,unitNo) + UNIT_TAILER_OFFSET,
              &unitTailer,
              sizeof(UnitTailer),
              EXTRA);
}

/*----------------------------------------------------------------------*/
/*                       i n i t N F T L                                */
/*                                                                      */
/* Initializes essential volume data as a preparation for mount or      */
/* format.                                                              */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    flash        : Flash media mounted on this socket                 */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus initNFTL(Anand vol, FLFlash *flash)
{
  dword size = 1;

  if (flash == NULL || !(flash->flags & NFTL_ENABLED)) {
    DEBUG_PRINT(("Debug: media is not fit for NFTL format.\r\n"));
    return flUnknownMedia;
  }

  vol.flash = flash;

#ifdef NT5PORT
  vol.socketNo = (byte)(flSocketNoOf(vol.flash->socket));
#else
	vol.socketNo = flSocketNoOf(vol.flash->socket);
#endif NT5PORT

  vol.physicalUnits = NULL;
  vol.virtualUnits = NULL;

#ifdef NFTL_CACHE
  vol.ucache = NULL;
  vol.scache = NULL;
#endif

  for (vol.erasableBlockSizeBits = 0; size < vol.flash->erasableBlockSize;
       vol.erasableBlockSizeBits++, size <<= 1);
  vol.unitSizeBits = vol.erasableBlockSizeBits;

  vol.noOfUnits = (unsigned short)((vol.flash->noOfChips * vol.flash->chipSize) >> vol.unitSizeBits);

  /* Adjust unit size so header unit fits in one unit */
  while (vol.noOfUnits * sizeof(ANANDPhysUnit) + SECTOR_SIZE > (1UL << vol.unitSizeBits)) {
    vol.unitSizeBits++;
    vol.noOfUnits >>= 1;
  }
  /* Bound number of units to find room in 64 Kbytes Segment */
  if( (vol.noOfUnits >= MAX_UNIT_NUM) && (vol.unitSizeBits < MAX_UNIT_SIZE_BITS) ) {
    vol.unitSizeBits++;
    vol.noOfUnits >>= 1;
  }

  vol.badFormat      = TRUE;    /* until mount completes*/
  vol.mappedSectorNo = UNASSIGNED_SECTOR;
  vol.countsValid    = 0;          /* No units have a valid count yet */

  /*get pointer to buffer (we assume SINGLE_BUFFER is not defined) */
  vol.buffer       = flBufferOf(flSocketNoOf(vol.flash->socket));
#ifdef VERIFY_ERASED_SECTOR
  vol.verifyBuffer = (dword *)flReadBackBufferOf(flSocketNoOf(flash->socket));
#endif /* VERIFY_ERASED_SECTOR */

#if (defined(VERIFY_WRITE) || defined(VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
  vol.verifiedSectorNo = 0;    /* Largest sector verified so far     */
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */
  vol.invalidReplacement = ANAND_NO_UNIT; /* a unit with bad RUN */

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                     i n i t T a b l e s                              */
/*                                                                      */
/* Allocates and initializes the dynamic volume table, including the    */
/* unit tables and secondary virtual map.                               */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus initTables(Anand vol)
{
  /* Allocate the conversion tables */
#ifdef FL_MALLOC
  vol.physicalUnits = (ANANDPhysUnit FAR1*) FL_FAR_MALLOC (vol.noOfUnits * sizeof(ANANDPhysUnit));
  vol.virtualUnits = (ANANDUnitNo FAR1*) FL_FAR_MALLOC (vol.noOfVirtualUnits * sizeof(ANANDUnitNo));
  if (vol.physicalUnits == NULL ||
      vol.virtualUnits == NULL) {
    DEBUG_PRINT(("Debug: failed allocating conversion tables for NFTL.\r\n"));
    return flNotEnoughMemory;
  }
#else
  char *heapPtr;

  heapPtr = vol.heap;
  vol.physicalUnits = (ANANDPhysUnit *) heapPtr;
  heapPtr += vol.noOfUnits * sizeof(ANANDPhysUnit);
  vol.virtualUnits = (ANANDUnitNo *) heapPtr;
  heapPtr += vol.noOfVirtualUnits * sizeof(ANANDUnitNo);
  if (heapPtr > vol.heap + sizeof vol.heap) {
    DEBUG_PRINT(("Debug: not enough memory for NFTL conversion tables.\r\n"));
    return flNotEnoughMemory;
  }
#endif

  return flOK;
}

/*----------------------------------------------------------------------*/
/*                      m a r k U n i t B a d                           */
/*                                                                      */
/* Mark a unit as bad in the conversion table and the bad units table.  */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo        : Physical number of bad unit                       */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus markUnitBad(Anand vol, ANANDUnitNo unitNo)
{
  unsigned short eraseMark;
  unsigned long eraseCount;

  vol.physicalUnits[unitNo] = UNIT_BAD_MOUNT;

  getUnitTailer(&vol,unitNo,&eraseMark,&eraseCount);

  return setUnitTailer(&vol,unitNo,0,eraseCount);
}


/*----------------------------------------------------------------------*/
/*                  f o r m a t U n i t                                 */
/*                                                                      */
/* Format one unit. Erase the unit, and mark the physical units table.  */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo        : Unit to format                                    */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus formatUnit(Anand vol, ANANDUnitNo unitNo)
{
  unsigned short eraseMark;
  unsigned long eraseCount;
  FLStatus status;

  if (!isAvailable(unitNo))
    return flWriteFault;

  if (vol.physicalUnits[unitNo] == ANAND_UNIT_FREE)
    vol.freeUnits--;
  setUnavail(unitNo);

  getUnitTailer(&vol,unitNo,&eraseMark,&eraseCount);

#ifdef NFTL_CACHE
  /* purge ANANDUnitHeader cache to force re-filling from flash */
  if (vol.ucache != NULL) {
      vol.ucache[unitNo].virtualUnitNo     = 0xDEAD;
      vol.ucache[unitNo].replacementUnitNo = 0xDEAD;
  }

  /*
   * Purge the Sector Flags cache (set entries for all the unit's
   * sectors to SECTOR_FREE).
   */
  if (vol.scache != NULL) {
    tffsset(&(vol.scache[unitNo << (vol.unitSizeBits - SECTOR_SIZE_BITS-2)]),
    S_CACHE_4_SECTORS_FREE, 1 << (vol.unitSizeBits - SECTOR_SIZE_BITS - 2));
  }
#endif /* NFTL_CACHE */

  status = vol.flash->erase(vol.flash,
                (word)(unitNo << (vol.unitSizeBits - vol.erasableBlockSizeBits)),
                (word)(1 << (vol.unitSizeBits - vol.erasableBlockSizeBits)));
  if (status != flOK) {
    markUnitBad(&vol,unitNo);    /* make sure unit format is not valid */
    return status;
  }

  vol.eraseSum++;
  eraseCount++;
  if (eraseCount == 0)        /* was hex FF's */
    eraseCount++;

  checkStatus(setUnitTailer(&vol,unitNo,ERASE_MARK,eraseCount));

  vol.physicalUnits[unitNo] = ANAND_UNIT_FREE;
  vol.freeUnits++;

  return flOK;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                  w r i t e A n d C h e c k                           */
/*                                                                      */
/* Write one sector.                                                    */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    address        : Physical address of the sector to write to       */
/*    fromAddress    : Buffer of data to write                          */
/*    flags        : Write flags (ECC, overwrite etc.)                  */
/*                                                                      */
/* Returns:                                                             */
/*     Status         : 0 on success, failed otherwise.                 */
/*----------------------------------------------------------------------*/

static FLStatus writeAndCheck(Anand vol,
                CardAddress address,
                void FAR1 *fromAddress,
                unsigned flags)
{
  FLStatus status;
#ifdef VERIFY_ERASED_SECTOR
  register int noOfDword;
  int i;
#endif /* VERIFY_ERASED_SECTOR */

  /* Toggle verify write flag */
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
  switch (flVerifyWrite[vol.socketNo][vol.flash->socket->curPartition])
  {
     case FL_OFF:
        if (vol.verifiedSectorNo>vol.curSectorWrite)
           break;
     case FL_ON:
#ifdef VERIFY_WRITE
        vol.flash->socket->verifyWrite = FL_ON;
#endif /* VERIFY_WRITE */
#ifdef VERIFY_ERASED_SECTOR
        /* Make sure all of the sectors are really free */
        checkStatus(vol.flash->read(vol.flash,address,vol.verifyBuffer,SECTOR_SIZE,0));
        noOfDword = SECTOR_SIZE/sizeof(dword);
        for(i = 0;i<noOfDword;i++)          /* Loop over sector data */
        {
           if(vol.verifyBuffer[i]!=0xffffffffL)
           {
              markAsIgnored(&vol,address);
              DEBUG_PRINT(("writeAndCheck : The sector was not erased and is ignored\r\n"));
              return flWriteFault;
           }
        }
#endif /* VERIFY_ERASED_SECTOR */
     default:
        break;
  }
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

  /* Write sector */
  status = vol.flash->write(vol.flash,address,fromAddress,SECTOR_SIZE,(word)flags);

  if (status == flWriteFault) {  /* write failed, ignore this sector */
    markAsIgnored(&vol,address);
  }
#ifdef NFTL_CACHE
  else  {
     setSectorFlagsCache(&vol, address, SECTOR_USED);
  }
#endif

#ifdef VERIFY_WRITE
  /* Restore verify write mode */
  if(flVerifyWrite[flSocketNoOf(vol.flash->socket)][vol.flash->socket->curPartition] != FL_ON)
     vol.flash->socket->verifyWrite = FL_OFF;
#endif /* VERIFY_WRITE */

  return status;
}

#endif /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                  l a s t I n C h a i n                               */
/*                                                                      */
/* Find last unit in chain.                                             */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*     unitNo        : Start the search from this unit                  */
/*                                                                      */
/* Returns:                                                             */
/*     Physical unit number of the last unit in chain.                  */
/*----------------------------------------------------------------------*/

static ANANDUnitNo lastInChain(Anand vol, ANANDUnitNo unitNo)
{
  ANANDUnitNo firstVirtualUnitNo, firstReplacementUnitNo;
  ANANDUnitNo lastUnit = unitNo, nextUnitNo;
  ANANDUnitNo chainBound = 0;

  if(unitNo == ANAND_NO_UNIT)
    return ANAND_NO_UNIT;

  getUnitData(&vol,unitNo,&firstVirtualUnitNo,&firstReplacementUnitNo);
  nextUnitNo = firstReplacementUnitNo;

  while( (nextUnitNo < vol.noOfUnits) &&  /* Validate replacement unit no. */
     (chainBound < DOUBLE_MAX_UNIT_CHAIN) ) {
    ANANDUnitNo nextVirtualUnitNo, nextReplacementUnitNo;

    if( !isAvailable(nextUnitNo) )
      break;
    getUnitData(&vol,nextUnitNo,&nextVirtualUnitNo,&nextReplacementUnitNo);
    if( nextVirtualUnitNo != (firstVirtualUnitNo | ANAND_REPLACING_UNIT) )
      break;        /* Virtual unit no. not validated */
    lastUnit = nextUnitNo;
    nextUnitNo = nextReplacementUnitNo;
    chainBound++;
  }

  return lastUnit;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                   a s s i g n U n i t                                */
/*                                                                      */
/* Assigns a virtual unit no. to a unit                                 */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo        : Physical unit number                              */
/*    virtualUnitNo    : Virtual unit number to assign                  */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus assignUnit(Anand vol, ANANDUnitNo unitNo, ANANDUnitNo virtualUnitNo)
{
  ANANDUnitNo newVirtualUnitNo, newReplacementUnitNo;
  ANANDUnitNo oldVirtualUnitNo, oldReplacementUnitNo;
  FLStatus status;
  ANANDUnitNo newestUnitNo = vol.virtualUnits[virtualUnitNo];
  ANANDUnitNo oldUnitNo;

  /* Assign the new unit */
  newVirtualUnitNo = virtualUnitNo;
  if (newestUnitNo != ANAND_NO_UNIT)
    newVirtualUnitNo |= ANAND_REPLACING_UNIT;
  newReplacementUnitNo = ANAND_NO_UNIT;
  vol.physicalUnits[unitNo] = 0;
  vol.freeUnits--;
  status = setUnitData(&vol,unitNo,newVirtualUnitNo,newReplacementUnitNo);
  if (status != flOK)
  {
    markUnitBad(&vol,unitNo);
    return status;
  }

  /* Add unit to chain */
  if (newestUnitNo != ANAND_NO_UNIT)
  {
    /* If unit is frozen, don't attempt to chain (folding not-in-place) */
    if (!isAvailable(newestUnitNo))
      return flOK;

    oldUnitNo = lastInChain(&vol,newestUnitNo);
    getUnitData(&vol,oldUnitNo,&oldVirtualUnitNo,&oldReplacementUnitNo);
    if (oldReplacementUnitNo != ANAND_NO_UNIT)
      status = flWriteFault;    /* can't write here, so assume failure */
    else {
      vol.physicalUnits[oldUnitNo] |= UNIT_REPLACED;
      status = setUnitData(&vol,oldUnitNo,oldVirtualUnitNo,unitNo);
    }
    if (status != flOK) {
      formatUnit(&vol,unitNo); /* Get rid of the allocated unit quickly */
      setUnavail(newestUnitNo); /* freeze the chain */

      return status;
    }
    if (vol.countsValid > virtualUnitNo && newestUnitNo != oldUnitNo){
      if (countOf(newestUnitNo) + countOf(oldUnitNo) <= UNIT_MAX_COUNT)
        vol.physicalUnits[newestUnitNo] += countOf(oldUnitNo);
      else
        return flGeneralFailure;
    }
  }
  else
    vol.virtualUnits[virtualUnitNo] = unitNo;

  return flOK;
}

#endif /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                   f o r m a t C h a i n                              */
/*                                                                      */
/* Format all the units in a chain. Start from the last one and go      */
/* backwards until unitNo is reached.                                   */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo        : Format the chain from this unit onwards           */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus formatChain(Anand vol, ANANDUnitNo unitNo)
{
  /* Erase the chain from end to start */
  ANANDUnitNo chainBound;

  setUnitCount(unitNo,0);    /* Reenable erase of this unit */
  for (chainBound=0;( chainBound < DOUBLE_MAX_UNIT_CHAIN ); chainBound++) {
    /* Find last unit in chain */
    ANANDUnitNo unitToErase = lastInChain(&vol,unitNo);

    if( formatUnit(&vol,unitToErase) != flOK )
      break;

    if (unitToErase == unitNo)
      break;    /* Erased everything */
  }

  return flOK;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                        S w a p U n i t s                             */
/*                                                                      */
/* Applies wear leveling.                                               */
/* A rover unit dictates the current unit to level. If a unit chain     */
/* fold, if single unit chain , append a unit and then fold.            */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

FLStatus swapUnits(Anand vol)
{
  ANANDUnitNo i,unitNo,virtualUnitNo,replacementUnitNo;
  FLStatus    status;

  if(vol.wearLevel.currUnit>=vol.noOfVirtualUnits)
    return flOK;

  for(i=0,unitNo=vol.virtualUnits[vol.wearLevel.currUnit];
      (unitNo==ANAND_NO_UNIT) && (i<vol.noOfVirtualUnits);i++) {

    vol.wearLevel.currUnit++;
    if(vol.wearLevel.currUnit>=vol.noOfVirtualUnits)
      vol.wearLevel.currUnit = 0;

    unitNo=vol.virtualUnits[vol.wearLevel.currUnit];
  }

  if(unitNo==ANAND_NO_UNIT) /*The media is empty*/
    return flOK;

  virtualUnitNo = vol.wearLevel.currUnit;

  vol.wearLevel.currUnit++;
  if(vol.wearLevel.currUnit>=vol.noOfVirtualUnits)
    vol.wearLevel.currUnit = 0;

  if((vol.physicalUnits[unitNo] & UNIT_REPLACED) ||
     (!isAvailable(unitNo)                     )   )
  {
     status = foldUnit(&vol,virtualUnitNo,FALSE);
  }
  else 
  {
     checkStatus(allocateUnit(&vol,&replacementUnitNo));
     return assignUnit(&vol,replacementUnitNo,virtualUnitNo);
  }

  /* If folding failed make sure there are enough units and call again */
  if(status == flCanNotFold)
    return checkFolding(&vol,virtualUnitNo);

  return status;
}


/*----------------------------------------------------------------------*/
/*                       f i n d F r e e U n i t                        */
/*                                                                      */
/* Find a free unit from the physical unit pool.                        */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo     : Receives the physical unit no.                       */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus findFreeUnit(Anand vol, ANANDUnitNo *unitNo)
{
   ANANDUnitNo originalUnit = vol.roverUnit;
   unsigned short eraseMark;
   unsigned long eraseCount;

   do 
   {
       if (++vol.roverUnit >= vol.noOfUnits)
          vol.roverUnit = vol.bootUnits;

       if (vol.physicalUnits[vol.roverUnit] == ANAND_UNIT_FREE) 
	    { 
          /* found a free unit, if not erased, */
          getUnitTailer(&vol,vol.roverUnit,&eraseMark,&eraseCount);
          if (eraseMark != ERASE_MARK) 
		    {
             if (formatUnit(&vol,vol.roverUnit) != flOK)
                continue;    /* this unit is bad, find another */
		    }
          *unitNo = vol.roverUnit;
          return flOK;
       }
   } while (vol.roverUnit != originalUnit);
   return flNotEnoughMemory;      /* Report no space at all  */  
}


/*----------------------------------------------------------------------*/
/*                       f o l d U n i t                                */
/*                                                                      */
/* Copy all the sectors that hold valid data in the chain to the last   */
/* unit of the chain and erase the chain.                               */
/*                                                                      */
/* Parameters:                                                          */
/*    vol           : Pointer identifying drive                         */
/*    virtualUnitNo : Virtual unit number of the first unit in chain.   */
/*    forceFolding  : Boolean flag stating wether to force folding even */
/*                    at the cost of loosing sector data.               */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus foldUnit(Anand vol, ANANDUnitNo virtualUnitNo, FLBoolean forceFolding)
{
  ANANDUnitNo unitNo = vol.virtualUnits[virtualUnitNo];
  ANANDUnitNo targetUnitNo, chainBound;
  unsigned long foldMark;
  SectorNo    virtualSectorNo = (SectorNo)virtualUnitNo * vol.sectorsPerUnit;
  CardAddress endSectorAddress;
  CardAddress targetSectorAddress;
  CardAddress sourceSectorAddress;
  unsigned    newSectorCount, i;
  FLBoolean   partialFoldingFlag = FALSE;
  FLStatus    status;

  /* Force remapping of internal catched sector */
  vol.flash->socket->remapped = TRUE;
  vol.unitsFolded++;

/* When using FL_OFF option the media is scanned in the folding operation */
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
  if(flVerifyWrite[flSocketNoOf(vol.flash->socket)][vol.flash->socket->curPartition]==FL_OFF)
  {
     checkStatus(verifySectors(&vol,SECTORS_VERIFIED_PER_FOLDING));
     vol.curSectorWrite = virtualSectorNo;
  }
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

/* Find target unit */
  if (!isAvailable(unitNo)) /* If this unit is frozen, */
  {
     if(vol.freeUnits > 0)
     {
         /* allocate a new unit to fold into */
         checkStatus(findFreeUnit(&vol,&targetUnitNo));
         checkStatus(assignUnit(&vol,targetUnitNo,virtualUnitNo));
     }
     else
     {
        if(forceFolding==FALSE)
           return flCanNotFold;        
        partialFoldingFlag = TRUE;
     }
  }
 
  if((isAvailable(unitNo)) || (partialFoldingFlag == TRUE))
  {        /* Default. Fold into end of chain */
    targetUnitNo = unitNo;

    for (chainBound=0;( chainBound < DOUBLE_MAX_UNIT_CHAIN );chainBound++) 
    {
      ANANDUnitNo nextUnitNo = getNextUnit(&vol,targetUnitNo,virtualUnitNo);
      if (nextUnitNo == ANAND_NO_UNIT)
         break;
      targetUnitNo = nextUnitNo;
    }
    if(chainBound == DOUBLE_MAX_UNIT_CHAIN)
    {
      targetUnitNo = findEndOfEndlessChain(&vol, virtualUnitNo);
    }
  }

  /***********************************/
  /* Copy all sectors to target unit */
  /***********************************/

  /* Mark unit as currently folded */
  foldMark = FOLDING_IN_PROGRESS * 0x10001l;

  if( getFoldMark(&vol,unitNo) != FOLDING_IN_PROGRESS )
    vol.flash->write(vol.flash,
                     unitBaseAddress(&vol,unitNo) + FOLD_MARK_OFFSET,
                     &foldMark,
                     sizeof foldMark,
                     EXTRA);

  setUnavail(unitNo);    /* Freeze this unit chain */

  /* Copy all sectors to target unit */
  targetSectorAddress = unitBaseAddress(&vol,targetUnitNo);
  newSectorCount = 0;

  for (i = 0; i < vol.sectorsPerUnit; i++, virtualSectorNo++,
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
       vol.curSectorWrite++,
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
       targetSectorAddress += SECTOR_SIZE)
  {
     endSectorAddress = ANAND_UNASSIGNED_ADDRESS;
     for(chainBound=0;chainBound<DOUBLE_MAX_UNIT_CHAIN;chainBound++)
     {        
        sourceSectorAddress = virtual2Physical(&vol,virtualSectorNo,&endSectorAddress);        
        if(sourceSectorAddress == targetSectorAddress)
        {
           /* Sector resides on the last unit of the virtual chain and */
           /* does not need to be copied                               */
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
           switch(flVerifyWrite[flSocketNoOf(vol.flash->socket)][vol.flash->socket->curPartition])
           {
              case FL_UPS:
                 newSectorCount++;
                 goto nextSectorLable;

              case FL_OFF:
                 if(vol.verifiedSectorNo > virtualSectorNo)
                 {
                    newSectorCount++;
                    goto nextSectorLable;
                 }
              default: /* FL_ON */
                 break;
           }

           /* Validate the sector has valid EDC/ECC */
           status = vol.flash->read(vol.flash,sourceSectorAddress,nftlBuffer,SECTOR_SIZE,EDC);
           if(status!=flOK)
           {  /* Last sector of chain has EDC errors - can not fold there */
              if(forceFolding!=TRUE)
              {
                 return flCanNotFold;
              }
              else
              {
                 goto nextSectorLable;
              }
           }
           newSectorCount++;
           goto nextSectorLable;
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
        }
        else if(sourceSectorAddress != ANAND_UNASSIGNED_ADDRESS)
        {
           /* Check that area is free (ignore flag) */
           if(getSectorFlags(&vol,targetSectorAddress) != SECTOR_FREE)
           {
              if(forceFolding!=TRUE) 
              {
                 return flCanNotFold;
              }
              else
              {
                 break;
              }
           }          

           /* Copy sector to target sector */
           status = vol.flash->read(vol.flash,sourceSectorAddress,nftlBuffer,SECTOR_SIZE,EDC);
           if (status != flOK) /* Try reading previous sector */
           {
              endSectorAddress = sourceSectorAddress;
              continue; 
           }
           status = writeAndCheck(&vol,targetSectorAddress,nftlBuffer,EDC);
           switch (status)
           {
              case flOK:         /* Success */
                 vol.parasiteWrites++;
                 newSectorCount++;
                 goto nextSectorLable;

              case flWriteFault: /* Faild in verify write */
                 if (forceFolding == FALSE)
                    return flCanNotFold;
                 goto nextSectorLable;

              default :          /* Protection error or any other */
                 return status;
           }
        }
        else /* ANAND_UNASSIGNED_ADDRESS - Sector not used */
        {
            goto nextSectorLable;
        }
     }
     return flGeneralFailure;
nextSectorLable:;
  } /* End of copy sector loop */

  /*****************************/
  /* Add unit to virtual chain */
  /*****************************/

  if (newSectorCount > 0) {    /* Some sectors remaining*/
    /* Mark target unit as original */
    if( (setUnitData(&vol,targetUnitNo,virtualUnitNo,ANAND_NO_UNIT) != flOK ) ||
        (partialFoldingFlag == TRUE))
    {
      setUnavail(targetUnitNo);  /* freeze this unit */
    }
    else
    {
      setUnitCount(targetUnitNo,newSectorCount);
    }
    /* Set target unit in virtual unit table */
    vol.virtualUnits[virtualUnitNo] = targetUnitNo;
  }
  else {
    if (unitNo != targetUnitNo) {
/*    If there is a chain to delete ... */
/*    mark unit as completed folding, pending erase */
#ifndef NT5PORT
	  unsigned long foldMark = FOLDING_COMPLETE * 0x10001l;
#else /*NT5PORT*/
      foldMark = FOLDING_COMPLETE * 0x10001l;
#endif /*NT5PORT*/
      
	  vol.flash->write(vol.flash,
               unitBaseAddress(&vol,unitNo) + FOLD_MARK_OFFSET,
               &foldMark,
               sizeof foldMark,
               EXTRA);
    }

    vol.virtualUnits[virtualUnitNo] = ANAND_NO_UNIT;
  }

  /* Erase source units */

  return formatChain(&vol,unitNo);

}


/*----------------------------------------------------------------------*/
/*                 c r e a t e U n i t C o u n t                        */
/*                                                                      */
/* Count the number of sectors in a unit that hold valid data.          */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo        : Physical unit number                              */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void createUnitCount(Anand vol, ANANDUnitNo unitNo)
{
  unsigned int i;
  SectorNo sectorNo;
  CardAddress sectorAddress;
  ANANDUnitNo physicalUnitNo = vol.virtualUnits[unitNo];

  if (physicalUnitNo == ANAND_NO_UNIT)
    return;

  if (!isAvailable(physicalUnitNo))
    return;

  /* Get a count of the valid sector in this unit */
  setUnitCount(physicalUnitNo,0);

  sectorNo = (SectorNo)unitNo * vol.sectorsPerUnit;
  for (i = 0; i < vol.sectorsPerUnit; i++, sectorNo++) {
    sectorAddress = virtual2Physical(&vol,sectorNo,NULL);
    if (sectorAddress != ANAND_UNASSIGNED_ADDRESS) {
      ANANDUnitNo currUnitNo = (ANANDUnitNo)(sectorAddress >> vol.unitSizeBits);
      if (vol.physicalUnits[currUnitNo] & UNIT_REPLACED)
         currUnitNo = physicalUnitNo;
      /* Increament sector count - Assumed EDC OK , was not verified */
      vol.physicalUnits[currUnitNo]++; 
    }
  }
}


/*----------------------------------------------------------------------*/
/*                       f o l d B e s t C h a i n                      */
/*                                                                      */
/* Find the best chain to fold and fold it.A good chain to fold is a    */
/* long chain with a small number of sectors that hold valid data.      */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo        : Receives the physical unit no. of the first       */
/*              unit in the chain that was folded.                      */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus foldBestChain(Anand vol, ANANDUnitNo *unitNo)
{
  unsigned     leastCount;
  unsigned     longestChain;
  unsigned     unitCount;
  ANANDUnitNo  virtualUnitNo;
  ANANDUnitNo  u;  
  ANANDUnitNo  firstUnitNo;  
  unsigned int maxCounter;
  FLStatus     status = flCanNotFold;

  /* Loop as long as can not fold in place or until MAX_FOLDING_TRIES time */

  for (maxCounter = 0 ; maxCounter < MAX_FOLDING_TRIES ; maxCounter++)
  {   
	 leastCount    = vol.sectorsPerUnit + 1; /* Set to invalid sector count   */
	 longestChain  = 0;                      /* Set to invalid unit length    */
	 virtualUnitNo = ANAND_NO_UNIT;

	 /*************************************************************/
     /* Loop over all virtual units until best candidate is found */
	 /*************************************************************/

     for (u = 0; u < vol.noOfVirtualUnits; u++) 
	  {
       /* If virtual unit does not exist continue to next unit */
       firstUnitNo = vol.virtualUnits[u]; 
		 if( firstUnitNo == ANAND_NO_UNIT )
			continue;

		/* Make sure sector count of unit is valid */
        if (vol.countsValid <= u) 
		{
            createUnitCount(&vol,u); /* Update sector count */
            vol.countsValid = u + 1;
		}
  
        if( isAvailable(firstUnitNo) )     /* store sector count */
		{ 
           unitCount = countOf(firstUnitNo);
		}
        else
		{
         unitCount         = vol.sectorsPerUnit;    /* set low priority */
		}

		/* This is an empty unit. We can simply erase it */
        if (unitCount == 0)
		{
		   leastCount    = 0;
		   virtualUnitNo = u;
           break;
		}

        if(/* Smallest sector count found so far */
		   (leastCount >= unitCount                       ) &&   
		   /* And this unit is not a single unit chain  */
           (vol.physicalUnits[firstUnitNo] & UNIT_REPLACED)   )
		{
            unsigned chainLength = 0;

            /* Compare chain length */
            ANANDUnitNo nextUnitNo = getNextUnit(&vol,firstUnitNo,u);
            if(isAvailable(firstUnitNo)) 
			{
                while((nextUnitNo != ANAND_NO_UNIT        ) &&
                      (chainLength < DOUBLE_MAX_UNIT_CHAIN)) 
				{
                    chainLength++;
                    nextUnitNo = getNextUnit(&vol,nextUnitNo,u);
				}
			}
            else 
			{
                chainLength = 0; /* Set lowest priority to frozen chain */
			}

			/* set low priority to neverending loop chain */
            if(chainLength == DOUBLE_MAX_UNIT_CHAIN) 
               chainLength = 0;         
            if((leastCount == unitCount ) && (longestChain >= chainLength))
               continue;
            longestChain = chainLength;
		    leastCount = unitCount;
            virtualUnitNo = u;
		} /* End - unit has less (or eqaul) no' of used sectors found so far */
	 } /* End - Loop over all virtual units and find best candidate */

	 /*************************************************************/
     /* Candidate virtual chain has been chosen - try and fold it */
	 /*************************************************************/     

     if ((leastCount > vol.sectorsPerUnit) || 
         (virtualUnitNo == ANAND_NO_UNIT))
     {
	     /* Only single units chains were found */

	     if(maxCounter==0) /* And no chain was frozen while searching */
		     return flNotEnoughMemory;      /* Report no space at all  */
	     break; /* Try and fold the frozen units that have been found */
	  }
     else /* Try and fold the candidate unit */
	  {
        if(!isAvailable(vol.virtualUnits[virtualUnitNo])) /* This is a frozen unit */
        {
           /* Frozen chains have the lowest priority - stop searching */
		     break; 
        }
	     else                          /* Try and fold the unit */
		  {
           /* Store the first unit as the new free unit */
           *unitNo = vol.virtualUnits[virtualUnitNo]; 
           /* Store number of free Units */
            u = vol.freeUnits;
	        /* Fold the candidate unit */
           status = foldUnit(&vol,virtualUnitNo,FALSE);           
           switch(status)
           { 
              case flOK:
                 if(vol.freeUnits == u) /* Did not free any units */
                    continue;
                 break;          
              case flCanNotFold: /* Need to fold not in place */                 
                 continue;
              default:
                 return status;
           }
           break;
		  }
	  }
  } /* End MAX_FOLDING_TRIES loop */

  /***************************************************************/
  /* Check folding status - might need a special kind of folding */
  /***************************************************************/
  
  if(maxCounter)
  {
     *unitNo = ANAND_NO_UNIT;
     /* Unfreeze  all units */
     for (u = vol.spareOrgUnit + 1; u < vol.noOfUnits; u++)
     {         
        if(!isAvailable(u)) /* This is a frozen unit */
        {
           /* Get virtual unit of frozen physical unit */
           getUnitData(&vol,u,&virtualUnitNo,&firstUnitNo);           
           if(virtualUnitNo < vol.noOfVirtualUnits)  
           {
              /* Store the first unit as the new free unit */
              firstUnitNo = vol.virtualUnits[virtualUnitNo];
              /* Force folding no matter what */
              if(firstUnitNo != ANAND_NO_UNIT)
              {
                 checkStatus(foldUnit(&vol,virtualUnitNo,TRUE));
                 /* Recalculate sector count */
                 createUnitCount(&vol, virtualUnitNo);
                 *unitNo = firstUnitNo;
              }
           }
        }      
     }
  }
  if((*unitNo!= ANAND_NO_UNIT) &&  (vol.freeUnits > 0)) /* A unit was freed */
     return flOK;
  else
     return flGeneralFailure;
}


/*----------------------------------------------------------------------*/
/*                       a l l o c a t e U n i t                        */
/*                                                                      */
/* Find a free unit to allocate, erase it if necessary.                 */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*     unitNo        : Receives the physical number of the allocated    */
/*              unit                                                    */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus allocateUnit(Anand vol, ANANDUnitNo *unitNo)
{
  ANANDUnitNo originalUnit = vol.roverUnit;
  FLStatus status;

  if (vol.freeUnits < 2) /* Try to make sure not to use the last unit */
  {
     status = foldBestChain(&vol,unitNo);  
     if(status != flNotEnoughMemory)
		 return status;
  }

  return findFreeUnit(&vol, unitNo);
}

#endif /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                       m a p S e c t o r                              */
/*                                                                      */
/* Maps and returns location of a given sector no.                      */
/* NOTE: This function is used in place of a read-sector operation.     */
/*                                                                      */
/* A one-sector cache is maintained to save on map operations.          */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    sectorNo    : Sector no. to read                                  */
/*    physAddress    : Optional pointer to receive sector address       */
/*                                                                      */
/* Returns:                                                             */
/*    Pointer to physical sector location. NULL returned if sector      */
/*    does not exist.                                                   */
/*----------------------------------------------------------------------*/

static const void FAR0 *mapSector(Anand vol, SectorNo sectorNo, CardAddress *physAddress)
{
  if (sectorNo != vol.mappedSectorNo || vol.flash->socket->remapped) 
  {
    if (sectorNo >= vol.virtualSectors)
    {
      vol.mappedSector = NULL;
    }
    else 
    {
       int chainBound = 0;

       for(vol.mappedSectorAddress=ANAND_UNASSIGNED_ADDRESS;
           chainBound<DOUBLE_MAX_UNIT_CHAIN;chainBound++)
       {
           CardAddress endSectorAddress = vol.mappedSectorAddress; 
           vol.mappedSectorAddress = virtual2Physical(&vol,sectorNo,&endSectorAddress);

           if (vol.mappedSectorAddress == ANAND_UNASSIGNED_ADDRESS)
           {
              vol.mappedSector = NULL;    /* no such sector */
              break;
           }
           else 
           {
              vol.mappedSector = nftlBuffer;
              if (vol.flash->read(vol.flash,vol.mappedSectorAddress,nftlBuffer,SECTOR_SIZE,EDC) == flOK)
                 break;
           }
       }
       vol.mappedSectorNo = sectorNo;
       vol.flash->socket->remapped = FALSE;
    }
  }
  if (physAddress)
    *physAddress = vol.mappedSectorAddress;

  return vol.mappedSector;
}


/* Mounting and formatting */

/*----------------------------------------------------------------------*/
/*                   m o u n t U n i t                                  */
/*                                                                      */
/* Mount one unit. Read the relevant data from the unit header and      */
/* update the conversion tables.                                        */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo        : Unit to mount                                     */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus mountUnit(Anand vol, ANANDUnitNo unitNo,
                          unsigned long* eraseCount)
{
  ANANDUnitNo virtualUnitNo, replacementUnitNo;
  unsigned short eraseMark;
  ANANDPhysUnit FAR1 *pU = &vol.physicalUnits[unitNo];

  getUnitData(&vol,unitNo,&virtualUnitNo,&replacementUnitNo);
  getUnitTailer(&vol,unitNo,&eraseMark,eraseCount);

  if (virtualUnitNo == ANAND_NO_UNIT ||
      eraseMark != ERASE_MARK) {  /* this unit is not assigned */
    *pU = ANAND_UNIT_FREE;
  }
  else {  /* this unit is assigned */
    *pU &= UNIT_ORPHAN;
    if (replacementUnitNo < vol.noOfUnits) {
      *pU |= UNIT_REPLACED;
      if (isAvailable(replacementUnitNo) ||
      isReplaced(replacementUnitNo))
    /* Mark replacement unit as non-orphan */
    vol.physicalUnits[replacementUnitNo] &= ~UNIT_ORPHAN;
    }
    if (!(virtualUnitNo & ANAND_REPLACING_UNIT)) {
      unsigned short foldMark;
      ANANDUnitNo physUnitNo;

      if (virtualUnitNo >= vol.noOfVirtualUnits)
        return formatUnit(&vol,unitNo);

      foldMark = getFoldMark(&vol,unitNo);
      physUnitNo = vol.virtualUnits[virtualUnitNo];
      if (foldMark == FOLDING_COMPLETE)
    formatChain(&vol,unitNo);
      else if (physUnitNo == ANAND_NO_UNIT || !isAvailable(physUnitNo)) {
    /* If we have duplicates, it's OK if one of them is currently folded */
    vol.virtualUnits[virtualUnitNo] = unitNo;
    *pU &= ~UNIT_ORPHAN;

    if (foldMark == FOLDING_IN_PROGRESS) {
          setUnavail(unitNo);
    }
    if (physUnitNo != ANAND_NO_UNIT)
      formatChain(&vol,physUnitNo);    /* Get rid of old chain */
      }
      else if (foldMark == FOLDING_IN_PROGRESS)
    formatChain(&vol,unitNo);
      else
    return flBadFormat;    /* We have a duplicate to a unit that */
                /* is not currently folded. That's bad. */
    }
  }

  return flOK;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*               a l l o c a t e A n d W r i t e S e c t o r            */
/*                                                                      */
/* Write to sectorNo. if necessary, allocate a free sector first.       */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    sectorNo    : Virtual sector no. to write                         */
/*    fromAddress    : Address of sector data.                          */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus allocateAndWriteSector(void* rec,
                     SectorNo sectorNo,
                     void FAR1 *fromAddress)
{
  Anand vol = (Anand*)rec;
  ANANDUnitNo virtualUnitNo = (ANANDUnitNo)(sectorNo / vol.sectorsPerUnit);
  ANANDUnitNo firstUnitNo = vol.virtualUnits[virtualUnitNo];
  ANANDUnitNo unitNo;
  unsigned  unitOffset = (unsigned)((sectorNo % vol.sectorsPerUnit) << SECTOR_SIZE_BITS);
  unsigned  unitChainLength = 0;
  FLBoolean sectorExists = FALSE;
  FLBoolean unitWasFoldedOutOfPlace = FALSE;
  FLStatus  status;

  /* If we can't write to this unit, must fold it first */
  if (firstUnitNo != ANAND_NO_UNIT && !isAvailable(firstUnitNo)) {
    status = foldUnit(&vol,virtualUnitNo,FALSE);
    switch(status)
    {
       case  flOK:
          break;
       case  flCanNotFold:
          checkStatus(checkFolding(&vol,virtualUnitNo));
          break;
       default:
          return status;
    }
    firstUnitNo = vol.virtualUnits[virtualUnitNo];
  }

  /* Find a unit to write this sector */

  unitNo = firstUnitNo;
  while ((unitNo != ANAND_NO_UNIT) && (unitChainLength < DOUBLE_MAX_UNIT_CHAIN)) {
    unsigned char sectorFlags = getSectorFlags(&vol,unitBaseAddress(&vol,unitNo) + unitOffset);
    if (sectorFlags == SECTOR_FREE)
      break;
    if (sectorFlags != SECTOR_IGNORE)
      sectorExists = sectorFlags == SECTOR_USED;
    unitNo = getNextUnit(&vol,unitNo,virtualUnitNo);
    unitChainLength++;
  }

  if (unitChainLength == DOUBLE_MAX_UNIT_CHAIN) { /* unit points to itself */
    unitNo = ANAND_NO_UNIT;                  /* force folding not in place */
    setUnavail(firstUnitNo);
  }

  if (unitNo == ANAND_NO_UNIT) { /* Can not write in chain - must add a unit */    
    firstUnitNo = vol.virtualUnits[virtualUnitNo];
    if (unitChainLength >= MAX_UNIT_CHAIN)
    {
      status = foldUnit(&vol,virtualUnitNo,FALSE);
      switch(status)
      {
         case  flOK:
            break;
         case  flCanNotFold:
            checkStatus(checkFolding(&vol,virtualUnitNo));
            break;
         default:
            return status;
      }
    }
    if(vol.virtualUnits[virtualUnitNo] != firstUnitNo)
    {
       firstUnitNo = vol.virtualUnits[virtualUnitNo];
       unitWasFoldedOutOfPlace = TRUE;
    }
    checkStatus(allocateUnit(&vol,&unitNo));
    checkStatus(assignUnit(&vol,unitNo,virtualUnitNo));
    if(vol.virtualUnits[virtualUnitNo] != firstUnitNo)
    {
       firstUnitNo = vol.virtualUnits[virtualUnitNo];
       unitWasFoldedOutOfPlace = TRUE;
    }
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))        
    /* Folding might have discovered that the sector we are using is invalid */
    if(sectorExists) {
       if( unitWasFoldedOutOfPlace ) {
          /* Unit was folded out of place, so if sector exists it must be in 
           * the first unit of the chain 
           */
          if(getSectorFlags(&vol,unitBaseAddress(&vol,firstUnitNo) + unitOffset)
             != SECTOR_USED) {
             /* The sector we saw before had bad EDC */
             sectorExists = FALSE;
             unitNo = firstUnitNo;  
          } 
       }
    }
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
  }

#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
  vol.curSectorWrite = sectorNo;
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

  checkStatus(writeAndCheck(&vol,unitBaseAddress(&vol,unitNo) + unitOffset,fromAddress,EDC));

  if (vol.countsValid > virtualUnitNo) {
    if (unitNo != firstUnitNo && !(vol.physicalUnits[unitNo] & UNIT_REPLACED)) {
      if (countOf(unitNo) < UNIT_MAX_COUNT)    /* Increment block count */
         vol.physicalUnits[unitNo]++;
      else
         return flGeneralFailure;

      if (sectorExists)    /* Decrement block count */
      {
         if (countOf(firstUnitNo) > 0)
            vol.physicalUnits[firstUnitNo]--;
         else
            return flGeneralFailure;
      }
    }
    else if (!sectorExists) {
      if (countOf(firstUnitNo) < UNIT_MAX_COUNT)  /* Increment block count */
         vol.physicalUnits[firstUnitNo]++;
      else
    return flGeneralFailure;
    }
  }

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                         w r i t e S e c t o r                        */
/*                                                                      */
/* Writes a sector.                                                     */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    sectorNo    : Virtual sector no. to write                         */
/*    fromAddress    : Data to write                                    */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus writeSector(Anand vol, SectorNo sectorNo, void FAR1 *fromAddress)
{
  FLStatus status = flWriteFault;
  int i;

  if (vol.badFormat)
    return flBadFormat;
  if (sectorNo >= vol.virtualSectors)
    return flSectorNotFound;

  if(vol.wearLevel.currUnit!=ANAND_NO_UNIT) {
    vol.wearLevel.alarm++;
    if(vol.wearLevel.alarm>=WLnow) {
      vol.wearLevel.alarm = 0;
      checkStatus(swapUnits(&vol));
    }
  }

  if (sectorNo == vol.mappedSectorNo)    
  {
    /* Force remapping of internal catched sector */
    vol.flash->socket->remapped = TRUE;
  }
 
  vol.sectorsWritten++;
  for (i = 0; i < 4 && status == flWriteFault; i++) {
    if (vol.mappedSectorNo == sectorNo)
      vol.mappedSectorNo = UNASSIGNED_SECTOR;
    status = allocateAndWriteSector(&vol,sectorNo,fromAddress);
  }

  return status;
}


/*----------------------------------------------------------------------*/
/*                   d e l e t e S e c t o r                            */
/*                                                                      */
/* Marks contiguous sectors as deleted.                                 */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    sectorNo    : First sector no. to delete                          */
/*    noOfSectors    : No. of sectors to delete                         */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus deleteSector(Anand vol, SectorNo sectorNo, SectorNo noOfSectors)
{
  SectorNo iSector;
  FLStatus status;

  if (vol.badFormat)
    return flBadFormat;
  if (sectorNo + noOfSectors > vol.virtualSectors)
    return flSectorNotFound;

  for (iSector = 0; iSector < noOfSectors; iSector++, sectorNo++,
       vol.sectorsDeleted++) {

    CardAddress sectorAddress = virtual2Physical(&vol,sectorNo,NULL);
    if (sectorAddress != ANAND_UNASSIGNED_ADDRESS) {
      byte sectorFlags[2];
      ANANDUnitNo currUnitNo;

      /* Check that the unit is writable, and if not, fold it first */
      ANANDUnitNo virtualUnitNo = (ANANDUnitNo)(sectorNo / vol.sectorsPerUnit);
      ANANDUnitNo unitNo = vol.virtualUnits[virtualUnitNo];
      if (!isAvailable(unitNo)) {
         status = foldUnit(&vol,virtualUnitNo,FALSE);
         switch(status)
         {
            case  flOK:
               break;
            case  flCanNotFold:
               checkStatus(checkFolding(&vol,virtualUnitNo));
               break;
            default:
               return status;
         }
         sectorAddress = virtual2Physical(&vol,sectorNo,NULL);
      }

      /* Mark sector deleted */
      sectorFlags[0] = sectorFlags[1] = SECTOR_DELETED;
#ifdef NFTL_CACHE
      setSectorFlagsCache(&vol, sectorAddress, SECTOR_DELETED);
#ifdef ENVIRONMENT_VARS
      if (((flMarkDeleteOnFlash == FL_ON) &&
       (flPolicy[vol.socketNo][vol.flash->socket->curPartition]  != FL_COMPLETE_ASAP)) ||
      (vol.scache == NULL))
#endif /* ENVIRONMENT_VARS */
#endif
     vol.flash->write(vol.flash,
             sectorAddress + SECTOR_DATA_OFFSET,

#ifndef NT5PORT             
			 &sectorFlags,
#else /*NT5PORT*/
			 sectorFlags,
#endif /*NT5PORT*/       
			 
			 sizeof sectorFlags,
             EXTRA);

      currUnitNo = (ANANDUnitNo)(sectorAddress >> vol.unitSizeBits);
      if ( isAvailable(currUnitNo) ) {
         if (vol.physicalUnits[currUnitNo] & UNIT_REPLACED)
            currUnitNo = vol.virtualUnits[virtualUnitNo];
         if (vol.countsValid > virtualUnitNo) {
            if (countOf(currUnitNo) > 0)
               vol.physicalUnits[currUnitNo]--; /* Decrement block count */
            else
               return flGeneralFailure;
         }
      }
    }
  }

  return flOK;
}

#endif /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                    t l S e t B u s y                                 */
/*                                                                      */
/* Notifies the start and end of a file-system operation.               */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*      state        : FL_ON (1) = operation entry                      */
/*                      FL_OFF(0) = operation exit                      */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus tlSetBusy(Anand vol, FLBoolean state)
{
  return flOK;
}

#ifndef FL_READ_ONLY 

#ifdef DEFRAGMENT_VOLUME

/*----------------------------------------------------------------------*/
/*                      d e f r a g m e n t                             */
/*                                                                      */
/* Performs unit allocations to arrange a minimum number of writable    */
/* sectors.                                                             */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    sectorsNeeded    : Minimum required sectors                       */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus defragment(Anand vol, long FAR2 *sectorsNeeded)
{
  ANANDUnitNo dummyUnitNo, firstFreeUnit = ANAND_NO_UNIT;
  FLBoolean firstRound = TRUE;
  FLStatus status = flOK;

  if( (*sectorsNeeded) == -1 ) { /* fold single chain */
    if (vol.badFormat)
      return flBadFormat;

    status = foldBestChain(&vol,&dummyUnitNo);
    if( (status != flOK) && (vol.freeUnits == 0) )
      return status;
    *sectorsNeeded = vol.freeUnits * vol.sectorsPerUnit;
    return flOK;
  }
  while ((SectorNo)vol.freeUnits * vol.sectorsPerUnit < ((SectorNo)(*sectorsNeeded))) {
    if (vol.badFormat)
      return flBadFormat;

    status = allocateUnit(&vol,&dummyUnitNo);
    if( status != flOK )
      break;
    if (firstRound) {              /* remember the first free unit */
      firstFreeUnit = dummyUnitNo;
      firstRound = FALSE;
    }
    else if (firstFreeUnit == dummyUnitNo) {
      /* We have wrapped around, all the units that were marked as free  */
      /* are now erased, and we still don't have enough space.           */
      status = foldBestChain(&vol,&dummyUnitNo); /* make more free units */
      if( status != flOK )
        break;
    }
  }

  *sectorsNeeded = (long)vol.freeUnits * vol.sectorsPerUnit;

  return status;
}

#endif /* DEFRAGMENT_VOLUME */
#endif /* FL_READ_ONLY */


/*----------------------------------------------------------------------*/
/*                  s e c t o r s I n V o l u m e                       */
/*                                                                      */
/* Gets the total number of sectors in the volume                       */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*                                                                      */
/* Returns:                                                             */
/*    Number of sectors in the volume                                   */
/*----------------------------------------------------------------------*/

static SectorNo sectorsInVolume(Anand vol)
{
  return vol.virtualSectors;
}

/*----------------------------------------------------------------------*/
/*                   d i s m o u n t N F T L                            */
/*                                                                      */
/* Dismount NFTL volume                                                 */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void dismountNFTL(Anand vol)
{
#ifdef FL_MALLOC
  if( vol.physicalUnits != NULL )
    FL_FAR_FREE (vol.physicalUnits);
  if( vol.virtualUnits != NULL )
    FL_FAR_FREE (vol.virtualUnits);
  vol.physicalUnits = NULL;
  vol.virtualUnits = NULL;

#ifdef NFTL_CACHE
  if( vol.ucache != NULL )
    FL_FAR_FREE (vol.ucache);
  if( vol.scache != NULL )
    FL_FAR_FREE (vol.scache);
  vol.ucache = NULL;
  vol.scache = NULL;
#endif /* NFTL_CACHE */
#endif /* FL_MALLOC */
}


Anand* getAnandRec(unsigned driveNo)
{
  return (&vols[driveNo]);
}


#ifdef FORMAT_VOLUME

/*----------------------------------------------------------------------*/
/*                         i s E r a s e d U n i t                      */
/*                                                                      */
/* Check if a unit is erased.                                           */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo        : unit to check                                     */
/*                                                                      */
/* Returns:                                                             */
/*    TRUE if unit is erased, FALSE otherwise                           */
/*----------------------------------------------------------------------*/

static FLBoolean isErased(Anand vol, ANANDUnitNo unitNo)
{

  CardAddress addr;
  CardAddress endAddr;
  word        offset;

  /* Force remapping of internal catched sector */
  vol.flash->socket->remapped = TRUE;
  addr    = unitBaseAddress(&vol,unitNo);
  endAddr = addr + (1L << vol.unitSizeBits);

  for (;addr < endAddr; addr += SECTOR_SIZE)
  {

    /* Check area a and b */

    vol.flash->read(vol.flash, addr, nftlBuffer,SECTOR_SIZE, 0);
    for (offset=0;offset<SECTOR_SIZE;offset+=ANAND_SPARE_SIZE)
       if (tffscmp(nftlBuffer+offset, ff, ANAND_SPARE_SIZE))
          return FALSE;

    /* Check area c */

    vol.flash->read(vol.flash, addr, nftlBuffer,ANAND_SPARE_SIZE, EXTRA);
    if (tffscmp( nftlBuffer, ff, ANAND_SPARE_SIZE ))
      return FALSE;
  }
  return TRUE;
}

/*----------------------------------------------------------------------*/
/*                      f o r m a t    N F T L                          */
/*                                                                      */
/* Perform NFTL Format.                                                 */
/*                                                                      */
/* Parameters:                                                          */
/*    volNo        : Volume serial no.                                  */
/*    formatParams    : Address of FormatParams structure to use        */
/*    flash        : Flash media mounted on this socket                 */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus formatNFTL(unsigned volNo, TLFormatParams *formatParams, FLFlash *flash)
{
  Anand vol = &vols[volNo];
  long int unitSize;
  unsigned long prevVirtualSize;
  ANANDUnitNo iUnit, prevOrgUnit;
  ANANDUnitNo noOfBootUnits=0;
  ANANDBootRecord bootRecord;
  int noOfBadUnits = 0;
  FLStatus status = flOK;
  FLBoolean forceHeaderUpdate = FALSE;
  static unsigned char checkSum[EXTRA_LEN] =
       { 0x4B, 0x00, 0xE2, 0x0E, 0x93, 0xF7, 0x55, 0x55 };
#ifdef EXTRA_LARGE
  int moreUnitBits;
  unsigned char anandFlagsTmp;
#endif /* EXTRA_LARGE */

  DEBUG_PRINT(("Debug: starting NFTL format.\r\n"));

  checkStatus(initNFTL(&vol,flash));

  tffsset(&bootRecord,0,sizeof(ANANDBootRecord));

  /* Find the medium boot record */
  for (vol.orgUnit = 0; vol.orgUnit < vol.noOfUnits; vol.orgUnit++)
  {
    vol.flash->read(vol.flash,
           unitBaseAddress(&vol,vol.orgUnit),
           &bootRecord,
           sizeof bootRecord,
           0);
    if (tffscmp(bootRecord.bootRecordId,"ANAND",sizeof bootRecord.bootRecordId) == 0)
       break;
  }

#ifdef EXTRA_LARGE
  if (vol.orgUnit >= vol.noOfUnits) {    /* first time formatting */
    bootRecord.anandFlags = 0xFF;
    moreUnitBits = 0;
    while( ((vol.noOfUnits >> moreUnitBits) > 4096) &&
       ((vol.unitSizeBits + moreUnitBits) < MAX_UNIT_SIZE_BITS) &&
       (bootRecord.anandFlags > 0xFC) ) {
      moreUnitBits++;
      bootRecord.anandFlags--;
    }
  }

  moreUnitBits = ~bootRecord.anandFlags & MORE_UNIT_BITS_MASK;
  if (moreUnitBits > 0) {
    vol.unitSizeBits += moreUnitBits;
    vol.noOfUnits >>= moreUnitBits;
    vol.orgUnit >>= moreUnitBits;
  }
#endif /* EXTRA_LARGE */

  /* adjust number of boot area units include the EXB area */

  if (formatParams->flags & FL_LEAVE_BINARY_AREA)
  {
     /* Leave binary area (except for the area between the old
        original unit and the new one */
     if (formatParams->bootImageLen >= 0)
     {
        noOfBootUnits += (ANANDUnitNo)((formatParams->bootImageLen - 1) >> vol.unitSizeBits) + 1;
     }
     else /* Leave binary area excatly as it was */
     {
    if (vol.orgUnit >= vol.noOfUnits)  /* first time formatting */
        {
           noOfBootUnits = 0;
        }
        else
        {
       if (LE2(bootRecord.bootUnits) > noOfBootUnits )
          noOfBootUnits = LE2(bootRecord.bootUnits);
        }
     }
  }
  else /* Actualy format binary area with a signature */
  {
#ifdef WRITE_EXB_IMAGE
     if (formatParams->exbLen > 0)
     {
        noOfBootUnits = (ANANDUnitNo)((formatParams->exbLen - 1)
                        >> vol.unitSizeBits) + 1;
        formatParams->exbLen = noOfBootUnits;
     }
     else
     {
        formatParams->exbLen = 0;
     }
#endif /* WRITE_EXB_IMAGE */

     if(formatParams->noOfBinaryPartitions > 0)
     {
        noOfBootUnits += (ANANDUnitNo)((formatParams->binaryPartitionInfo
                         ->length - 1) >> vol.unitSizeBits) + 1;
     }
  }
  prevOrgUnit = vol.orgUnit;           /* save previous Original Unit */
  prevVirtualSize = UNAL4(bootRecord.virtualMediumSize);
  vol.bootUnits = noOfBootUnits;
  vol.unitOffsetMask = (1L << vol.unitSizeBits) - 1;
  vol.sectorsPerUnit = 1 << (vol.unitSizeBits - SECTOR_SIZE_BITS);
  /* Add 'percentUse'% of bootUnits to transfer units */
  formatParams->percentUse -= (unsigned)(((long)(100 - formatParams->percentUse) * (vol.bootUnits)) / (vol.noOfUnits - vol.bootUnits));

  vol.noOfTransferUnits = (ANANDUnitNo)formatParams->noOfSpareUnits;

  vol.noOfTransferUnits += (ANANDUnitNo)((long)(vol.noOfUnits - vol.bootUnits) *
                 (100 - formatParams->percentUse) / 100);

  if (vol.noOfUnits <= vol.bootUnits + vol.noOfTransferUnits)
    return flVolumeTooSmall;

  unitSize = 1L << vol.unitSizeBits;
  vol.noOfVirtualUnits = vol.noOfUnits-vol.bootUnits;

  checkStatus(initTables(&vol));

  for (iUnit = 0; iUnit < (vol.noOfUnits-vol.bootUnits); iUnit++)
    vol.virtualUnits[iUnit] = ANAND_NO_UNIT;


  if (vol.orgUnit >= vol.noOfUnits)
  {
    /* no boot record - virgin card, scan it for bad blocks */
    DFORMAT_PRINT(("Virgin card rebuilding unit map.\r\n"));
    prevVirtualSize = 0L;
    tffsset(ff,0xff,ANAND_SPARE_SIZE);

        /* Generate the bad unit table */
    /* if a unit is not erased it is marked as bad */
    for (iUnit = 0; iUnit < vol.noOfUnits; iUnit++)
    {
      vol.physicalUnits[iUnit] = (unsigned char)(isErased(&vol,iUnit) ? ANAND_UNIT_FREE : UNIT_BAD_ORIGINAL);
#ifndef NT5PORT
      DFORMAT_PRINT(("Checking unit %ld\r",(CardAddress)iUnit));
#endif/*NT5PORT*/
    }
    DFORMAT_PRINT(("\rMedia has been scanned\r\n"));
  }
  else /* Read bad unit table from boot record */
  {
    status = vol.flash->read(vol.flash,
                   unitBaseAddress(&vol,vol.orgUnit) + SECTOR_SIZE,
                   vol.physicalUnits,
                   vol.noOfUnits * sizeof(ANANDPhysUnit),
                   EDC);
    if( status != flOK ) {
      dismountNFTL(&vol);  /*Free tables must be done after call to initTables*/
      return status;
    }
  }

  if(vol.physicalUnits[0] == UNIT_BAD_ORIGINAL)
  {
     DFORMAT_PRINT(("ERROR - IPL block is bad.\r\n"));
     return flBadIPLBlock;
  }

  /*  count bad units */
  vol.noOfTransferUnits += 2;           /* include orgUnit & spareOrgUnit */

  /* Convert first unit of MDOC of any floor > 0 to BAD in order to make it
   *  unchangeable and force internal EEprom mode  */
  if(flash->flags & EXTERNAL_EPROM)
  {
    long docFloorSize;
    int  iFloor, iPage;

    docFloorSize = (flash->chipSize * flash->noOfChips) / flash->noOfFloors;

    for(iFloor=1;( iFloor < flash->noOfFloors ); iFloor++)
    {
      iUnit = (ANANDUnitNo)((docFloorSize * (long)iFloor) >> vol.unitSizeBits);
      if( vol.physicalUnits[iUnit] == ANAND_UNIT_FREE )
      {
         forceHeaderUpdate = TRUE;           /* force writing of NFTL Header */
         vol.physicalUnits[iUnit] = UNIT_BAD_ORIGINAL; /* mark as BAD */
      }
      status = vol.flash->erase(vol.flash,
               (word)(iUnit << (vol.unitSizeBits - vol.erasableBlockSizeBits)),
                 (word)(1 << (vol.unitSizeBits - vol.erasableBlockSizeBits)));
      if( status != flOK ) {
        dismountNFTL(&vol);  /*Free tables must be done after call to initTables*/
        return status;
      }

      for(iPage=0;( iPage < 2 ); iPage++) {
        status = vol.flash->write(vol.flash,
               unitBaseAddress(&vol,iUnit) + iPage * SECTOR_SIZE,
           (const void FAR1 *)checkSum, EXTRA_LEN, EXTRA);
        if( status != flOK ) {
          dismountNFTL(&vol);  /*Free tables must be done after call to initTables*/
          return status;
        }
      }
    }
  }

  /* Translate physicalUnits[] to internal representation */
  for (iUnit = 0; iUnit < vol.noOfUnits; iUnit++) {
    if (vol.physicalUnits[iUnit] != ANAND_UNIT_FREE)
      vol.physicalUnits[iUnit] = UNIT_BAD_MOUNT;
  }

  /* extend bootimage area if there are bad units in it */
  for( iUnit = vol.bootUnits = 0;
       (vol.bootUnits < noOfBootUnits)  &&  (iUnit < vol.noOfUnits);
       iUnit++ )
    if (isAvailable(iUnit))
      vol.bootUnits++;

  if (vol.bootUnits < noOfBootUnits) {
    dismountNFTL(&vol);  /*Free tables must be done after call to initTables*/
    return flVolumeTooSmall;
  }

  vol.bootUnits = iUnit;

  /* Discount transfer units taken by the boot image */
  for (iUnit = 0; iUnit < vol.bootUnits; iUnit++)
    if (!isAvailable(iUnit)) {
      if( vol.noOfTransferUnits <= (ANANDUnitNo)formatParams->noOfSpareUnits ) {
        dismountNFTL(&vol);  /*Free tables must be done after call to initTables*/
        return flVolumeTooSmall;
      }
      vol.noOfTransferUnits--;
    }
    if (vol.noOfUnits <= vol.bootUnits + vol.noOfTransferUnits) {
    dismountNFTL(&vol);  /*Free tables must be done after call to initTables*/
    return flVolumeTooSmall;
  }

  vol.virtualSectors = (SectorNo)((vol.noOfUnits - vol.bootUnits - vol.noOfTransferUnits) *
               (unitSize / SECTOR_SIZE));
  vol.noOfVirtualUnits = (unsigned short)((vol.virtualSectors + vol.sectorsPerUnit - 1) / vol.sectorsPerUnit);

  /* Find a place for the boot records and protect them */
  /* NOTE : We don't erase the old orgUnits, this might cause a problem
     when formatting with bootImageLen = 0 and then formatting with
     bootImageLen = 44Kbyte */
  for (vol.orgUnit = vol.bootUnits; vol.orgUnit < vol.noOfUnits; vol.orgUnit++)
    if (vol.physicalUnits[vol.orgUnit] == ANAND_UNIT_FREE)
      break;
  vol.physicalUnits[vol.orgUnit] = UNIT_UNAVAIL;
  for (vol.spareOrgUnit = vol.orgUnit + 1;
       vol.spareOrgUnit < vol.noOfUnits;
       vol.spareOrgUnit++)
    if (vol.physicalUnits[vol.spareOrgUnit] == ANAND_UNIT_FREE)
      break;
  vol.physicalUnits[vol.spareOrgUnit] = UNIT_UNAVAIL;

  for (iUnit = vol.bootUnits; iUnit < vol.noOfUnits; iUnit++)
  {
    status = formatUnit(&vol,iUnit);
    if(status == flWriteFault)
    {
      if ((iUnit != vol.orgUnit) && (iUnit != vol.spareOrgUnit))
      {
    noOfBadUnits++;
    vol.physicalUnits[iUnit] = UNIT_BAD_MOUNT;  /* Mark it bad in table */
    if ((noOfBadUnits+2) >= vol.noOfTransferUnits)
    {
      dismountNFTL(&vol);  /*Free tables must be done after call to initTables*/
      return status;
    }
      }
    }
    else if (status != flOK)
    {
      dismountNFTL(&vol);  /*Free tables must be done after call to initTables*/
      return status;
    }

    if (formatParams->progressCallback)
    {
      status = (*formatParams->progressCallback)
          ((word)(vol.noOfUnits - vol.bootUnits),
           (word)((iUnit + 1) - vol.bootUnits));
      if(status!=flOK)
      {
    dismountNFTL(&vol);  /*Free tables must be done after call to initTables*/
        return status;
      }
    }
  }

  /* Prepare the boot record header */
  for(iUnit = 0; iUnit < vol.noOfUnits; iUnit++) {  /* Convert Bad Block table to previous state */
    if( vol.physicalUnits[iUnit] == UNIT_BAD_MOUNT )
      vol.physicalUnits[iUnit] = UNIT_BAD_ORIGINAL;
  }
#ifdef EXTRA_LARGE
  anandFlagsTmp = bootRecord.anandFlags;
#endif /* EXTRA_LARGE */
  tffsset(&bootRecord,0xff,sizeof bootRecord);
#ifdef EXTRA_LARGE
  bootRecord.anandFlags = anandFlagsTmp;
#endif /* EXTRA_LARGE */
  toLE2(bootRecord.noOfUnits,vol.noOfUnits - vol.bootUnits);
  toLE2(bootRecord.bootUnits,vol.bootUnits);
  tffscpy(bootRecord.bootRecordId,"ANAND",sizeof bootRecord.bootRecordId);
  toUNAL4(bootRecord.virtualMediumSize,(CardAddress) vol.virtualSectors * SECTOR_SIZE);

  /* Write boot records, spare unit first */
  vol.physicalUnits[vol.orgUnit] = ANAND_UNIT_FREE;    /* Unprotect it */
  vol.physicalUnits[vol.spareOrgUnit] = ANAND_UNIT_FREE;    /* Unprotect it */

  if( ((prevOrgUnit != vol.orgUnit) || (forceHeaderUpdate == TRUE)) ||
      (prevVirtualSize != UNAL4(bootRecord.virtualMediumSize)) )
  {
     /* Copy boot Record to 512 bytes buffer in order to add EDC */
     tffsset(nftlBuffer,0,sizeof nftlBuffer);
     tffscpy(nftlBuffer,&bootRecord,sizeof bootRecord);

     /* Loop over the original unit and the spare (spare first) */
     for (iUnit = vol.spareOrgUnit, prevOrgUnit = 0;
        prevOrgUnit < 2 ; prevOrgUnit ++)
     {
        status = formatUnit(&vol,iUnit);    /* Erase unit */

        if(status==flOK)     /* Write BBT */
        {
           status = vol.flash->write(vol.flash,
              unitBaseAddress(&vol,iUnit) + SECTOR_SIZE,
              vol.physicalUnits,
              vol.noOfUnits * sizeof(ANANDPhysUnit), EDC);
        }

        if(status==flOK)    /* Write header */
        {
           status = vol.flash->write(vol.flash,
                    unitBaseAddress(&vol,iUnit),
                    nftlBuffer, sizeof (nftlBuffer), EDC);
        }

        if(status!=flOK)
        {
           dismountNFTL(&vol);  /*Free tables must be done after call to initTables*/
           return status;
        }
        iUnit = vol.orgUnit;
     }
  }

  /* Mark Binary partition with the proper signature */

  if (!(formatParams->flags & FL_LEAVE_BINARY_AREA)&&
       (vol.bootUnits > 0))
  {
     byte sign[BINARY_SIGNATURE_LEN];

     /* Add SPL special Signature */

#ifdef WRITE_EXB_IMAGE
     byte signOffset = 8;
     tffscpy(sign,SIGN_SPL,BINARY_SIGNATURE_NAME);
#else
     byte signOffset = formatParams->binaryPartitionInfo->signOffset;
     tffscpy(sign,formatParams->binaryPartitionInfo->sign,
              BINARY_SIGNATURE_NAME);
#endif /* WRITE_EXB_IMAGE */

     tffsset(sign+BINARY_SIGNATURE_NAME,'F',BINARY_SIGNATURE_NAME);
     unitSize = 1L << vol.unitSizeBits;

     for (iUnit=0;iUnit<vol.bootUnits;iUnit++)
     {
        if ( vol.physicalUnits[iUnit] == ANAND_UNIT_FREE )
        {
           status = formatUnit(&vol,iUnit);
           if(status != flOK)
              break;

#ifdef WRITE_EXB_IMAGE
           if (iUnit == formatParams->exbLen)
           {
              signOffset = formatParams->binaryPartitionInfo->signOffset;
              tffscpy(sign,formatParams->binaryPartitionInfo->sign,
              BINARY_SIGNATURE_NAME);
           }
#endif /* WRITE_EXB_IMAGE */
       /* Each logical unit might contain several physical blocks */
           for (noOfBootUnits = 0 ;
               (noOfBootUnits < unitSize) && (status == flOK) ;
               noOfBootUnits += (ANANDUnitNo)vol.flash->erasableBlockSize)
           {
              status = vol.flash->write(vol.flash, unitBaseAddress(&vol,iUnit) +
              noOfBootUnits + signOffset, sign,
              BINARY_SIGNATURE_LEN,EXTRA);
           }
           if(status != flOK)
              break;
        }
#ifdef WRITE_EXB_IMAGE
       else
       {
           formatParams->exbLen++;
       }
#endif /* WRITE_EXB_IMAGE */
     }
  }
  else /* Erase previous Original and SpareOriginal Unit */
  {
     for (iUnit = prevOrgUnit; iUnit < vol.orgUnit; iUnit++)
       if( vol.physicalUnits[iUnit] != UNIT_BAD_ORIGINAL )
     formatUnit(&vol,iUnit);
  }

  if (status != flOK)
  {
     DEBUG_PRINT(("Debug: NFTL failed while formating the binary partition.\r\n"));
  }
  else
  {
     DEBUG_PRINT(("Debug: finished NFTL format.\r\n"));
  }

  dismountNFTL(&vol);  /*Free tables must be done after call to initTables*/
  return status;
}

#endif /* FORMAT_VOLUME */

/*----------------------------------------------------------------------*/
/*                      N F T L I n f o                                 */
/*                                                                      */
/* get NFTL information.                                                */
/*                                                                      */
/* Parameters:                                                          */
/*  volNo       : Volume serial no.                                     */
/*  tlInfo      : Address of TLInfo record                              */
/*                                                                      */
/* Returns:                                                             */
/*  FLStatus    : 0 on success, failed otherwise                        */
/*----------------------------------------------------------------------*/

static FLStatus  NFTLInfo(Anand vol, TLInfo *tlInfo)
{
  tlInfo->sectorsInVolume = vol.virtualSectors;
  tlInfo->bootAreaSize    = (unsigned long)vol.bootUnits << vol.unitSizeBits;
  tlInfo->eraseCycles     = vol.eraseSum;
  tlInfo->tlUnitBits      = vol.unitSizeBits;
  return flOK;
}

#ifndef NO_READ_BBT_CODE

/*----------------------------------------------------------------------*/
/*                      r e a d B B T                                   */
/*                                                                      */
/* Returns a pointer to the BBT of the device.                          */
/* Note: Bad unit are marked with a 4 bytes address of the unit.        */
/* Note: A unit can contain several blocks                              */
/*                                                                      */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive                                 */
/*  buf     : pointer to buffer to read into                            */
/*                                                                      */
/* Returns:                                                             */
/*  FLStatus    : 0 on success, failed otherwise                        */
/*  noOfBB      : returns the number of bad unit of the media           */
/*  meidaSize   : returns the media size in bytes                       */
/*----------------------------------------------------------------------*/
static FLStatus  readBBT(Anand vol, CardAddress FAR1 * buf,
               long FAR2 * mediaSize, unsigned FAR2 * noOfBB)
{
   ANANDUnitNo iUnit;
   ANANDUnitNo maxBad = vol.noOfUnits * ANAND_BAD_PERCENTAGE / 100;
   CardAddress FAR1* ptr = (CardAddress FAR1*) buf;

   *noOfBB = 0;

   for (iUnit=0;(iUnit<vol.noOfUnits);iUnit++)
   {
      if (vol.physicalUnits[iUnit] == UNIT_BAD_MOUNT)
      {
         if (*noOfBB <= maxBad)
         {
            *ptr = (CardAddress) iUnit << vol.unitSizeBits;
            (*noOfBB)++;
            ptr = (CardAddress FAR1*)flAddLongToFarPointer((byte FAR1 *)ptr,
                                     sizeof(CardAddress));
         }
         else
         {
            DEBUG_PRINT(("Debug: ERROR to many bad blocks.\r\n"));
            return flVolumeTooSmall;
         }
      }
   }
   *mediaSize = vol.noOfUnits << vol.unitSizeBits;
   return flOK;
}

#endif /* NO_READ_BBT_CODE */

/*----------------------------------------------------------------------*/
/*                      m o u n t N F T L                               */
/*                                                                      */
/* Mount the volume. Initialize data structures and conversion tables   */
/*                                                                      */
/* Parameters:                                                          */
/*    volNo           : Volume serial no.                               */
/*    tl              : Mounted translation layer on exit               */
/*    flash           : Flash media mounted on this socket              */
/*    volForCallback  : Pointer to FLFlash structure for power on       */
/*                      callback routine.                               */
/*                                                                      */
/* update the tlType field of the TL record to NFTL                     */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus mountNFTL(unsigned volNo, TL *tl, FLFlash *flash, FLFlash **volForCallback)
{
  Anand vol = &vols[volNo];
  ANANDUnitNo iUnit,virUnit,nextUnit;
  unsigned long currEraseCount=0;
  ANANDBootRecord bootRecord,spareBootRecord;
  FLStatus status;
#ifdef NFTL_CACHE
  unsigned long scacheSize = 0;
#endif /* NFTL_CACHE */
#ifdef EXTRA_LARGE
  int moreUnitBits;
#endif /* EXTRA_LARGE */

#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
  /* Default for NFTL is FL_UPS */
  flVerifyWrite[vol.socketNo][tl->partitionNo] = FL_UPS;
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

  tffsset(&bootRecord,0,sizeof(ANANDBootRecord));

  DEBUG_PRINT(("Debug: starting NFTL mount.\r\n"));

  checkStatus(initNFTL(&vol,flash));
  *volForCallback = vol.flash;
  vol.eraseSum = 0;
  /* Find the medium boot record */
  for (vol.orgUnit = 0; vol.orgUnit < vol.noOfUnits; vol.orgUnit++) {
    vol.flash->read(vol.flash,
           unitBaseAddress(&vol,vol.orgUnit),
           &bootRecord,
           sizeof bootRecord,
           0);
    if (tffscmp(bootRecord.bootRecordId,"ANAND",sizeof bootRecord.bootRecordId) == 0)
       break;
  }
  if (vol.orgUnit >= vol.noOfUnits) {
    DEBUG_PRINT(("Debug: not NFTL format.\r\n"));
    return flUnknownMedia;
  }

  for (vol.spareOrgUnit = vol.orgUnit + 1;
       vol.spareOrgUnit < vol.noOfUnits;
       vol.spareOrgUnit++) {
    vol.flash->read(vol.flash,
           unitBaseAddress(&vol,vol.spareOrgUnit),
           &spareBootRecord,
           sizeof spareBootRecord,
           0);
    if (tffscmp(spareBootRecord.bootRecordId,"ANAND",sizeof spareBootRecord.bootRecordId) == 0)
      break;
  }
  if (vol.spareOrgUnit >= vol.noOfUnits)
    vol.spareOrgUnit = ANAND_NO_UNIT;

  /* Get media information from unit header */
  vol.noOfUnits = LE2(bootRecord.noOfUnits);
  vol.bootUnits = LE2(bootRecord.bootUnits);
  vol.virtualSectors = (SectorNo)(UNAL4(bootRecord.virtualMediumSize) >> SECTOR_SIZE_BITS);
  vol.noOfUnits += vol.bootUnits;

#ifdef EXTRA_LARGE
  moreUnitBits = ~bootRecord.anandFlags & MORE_UNIT_BITS_MASK;
  if (moreUnitBits > 0) {
    vol.unitSizeBits += moreUnitBits;
    vol.orgUnit >>= moreUnitBits;
    if (vol.spareOrgUnit != ANAND_NO_UNIT)
      vol.spareOrgUnit >>= moreUnitBits;
  }
#endif /* EXTRA_LARGE */

  vol.unitOffsetMask = (1L << vol.unitSizeBits) - 1;
  vol.sectorsPerUnit = 1 << (vol.unitSizeBits - SECTOR_SIZE_BITS);
  vol.noOfVirtualUnits = (ANANDUnitNo)((vol.virtualSectors + vol.sectorsPerUnit - 1) / vol.sectorsPerUnit);

  if(((ANANDUnitNo)(vol.virtualSectors >> (vol.unitSizeBits - SECTOR_SIZE_BITS)) >
      (vol.noOfUnits - vol.bootUnits)) ) {

    if( vol.spareOrgUnit != ANAND_NO_UNIT ) {
       vol.noOfUnits = LE2(spareBootRecord.noOfUnits);
       vol.bootUnits = LE2(spareBootRecord.bootUnits);
       vol.virtualSectors = (SectorNo)(UNAL4(spareBootRecord.virtualMediumSize) >> SECTOR_SIZE_BITS);
       vol.noOfUnits += vol.bootUnits;

#ifdef EXTRA_LARGE
       moreUnitBits = ~spareBootRecord.anandFlags & MORE_UNIT_BITS_MASK;
       if (moreUnitBits > 0) {
     vol.unitSizeBits += moreUnitBits;
     vol.orgUnit >>= moreUnitBits;
     if (vol.spareOrgUnit != ANAND_NO_UNIT)
        vol.spareOrgUnit >>= moreUnitBits;
       }
#endif /* EXTRA_LARGE */

       vol.unitOffsetMask = (1L << vol.unitSizeBits) - 1;
       vol.sectorsPerUnit = 1 << (vol.unitSizeBits - SECTOR_SIZE_BITS);
       vol.noOfVirtualUnits = (ANANDUnitNo)((vol.virtualSectors + vol.sectorsPerUnit - 1) / vol.sectorsPerUnit);

       if ((ANANDUnitNo)(vol.virtualSectors >> (vol.unitSizeBits - SECTOR_SIZE_BITS)) >
       (vol.noOfUnits - vol.bootUnits))
     return flBadFormat;
    }
    else
      return flBadFormat;
  }

  checkStatus(initTables(&vol));


  /* Read bad unit table from boot record */
  status = vol.flash->read(vol.flash,
              unitBaseAddress(&vol,vol.orgUnit) + SECTOR_SIZE,
              vol.physicalUnits,
              vol.noOfUnits * sizeof(ANANDPhysUnit),
              EDC);
  if( status != flOK ) {
    if( vol.spareOrgUnit != ANAND_NO_UNIT ) {
      status = vol.flash->read(vol.flash,
              unitBaseAddress(&vol,vol.spareOrgUnit) + SECTOR_SIZE,
              vol.physicalUnits,
              vol.noOfUnits * sizeof(ANANDPhysUnit),
              EDC);
      if( status != flOK ) {
    dismountNFTL(&vol); /* Free tables must be done after call to initTables */
    return status;
      }
    }
    else
      return status;
  }
  /* Exclude boot-image units */
  for (iUnit = 0; iUnit < vol.noOfVirtualUnits; iUnit++)
    vol.virtualUnits[iUnit] = ANAND_NO_UNIT;

  /* Translate bad unit table to internal representation */
  for (iUnit = 0; iUnit < vol.noOfUnits; iUnit++) {
    /* Exclude bad & protected units */
    if (iUnit < vol.bootUnits || iUnit == vol.orgUnit || iUnit == vol.spareOrgUnit ||
        vol.physicalUnits[iUnit] != ANAND_UNIT_FREE) {
      if (vol.physicalUnits[iUnit] != ANAND_UNIT_FREE) {
        vol.physicalUnits[iUnit] = UNIT_BAD_MOUNT;
            }
      else {
        vol.physicalUnits[iUnit] = UNIT_UNAVAIL;
            }
        }
  }

  /* Mount all units */
  for (iUnit = 0; iUnit < vol.noOfUnits; iUnit++) {
    if ((vol.physicalUnits[iUnit] != UNIT_UNAVAIL) && (vol.physicalUnits[iUnit] != UNIT_BAD_MOUNT)) {
      status = mountUnit(&vol,iUnit,&currEraseCount);
      if(status!=flOK) {
        dismountNFTL(&vol);  /*Free tables must be done after call to initTables*/
        return status;
      }
      vol.eraseSum+=currEraseCount;
    }
  }

  /* Scan for orphan units, and count free units */
  vol.freeUnits = 0;
  for (iUnit = vol.bootUnits; iUnit < vol.noOfUnits; iUnit++) {
    ANANDPhysUnit FAR1 *pU = &vol.physicalUnits[iUnit];

    if (*pU == UNIT_ORPHAN ||
    *pU == (UNIT_REPLACED | UNIT_ORPHAN)) {
       formatChain(&vol,iUnit);                 /* Get rid of orphan */
       if(iUnit == vol.invalidReplacement)
          vol.invalidReplacement = ANAND_NO_UNIT;
    }
    else
      if (*pU == (ANAND_UNIT_FREE & ~UNIT_ORPHAN))
    *pU = ANAND_UNIT_FREE;    /* Reference to free unit. That's OK */
  }
  /* Calculate Free Units again after formatChain */
  vol.freeUnits = 0;
  for (iUnit = vol.bootUnits; iUnit < vol.noOfUnits; iUnit++) {
    if( vol.physicalUnits[iUnit] == ANAND_UNIT_FREE )
      vol.freeUnits++;
  }

  /* Initialize allocation rover */
  vol.roverUnit = vol.bootUnits;

  /* Initialize statistics */
  vol.sectorsRead = vol.sectorsWritten = vol.sectorsDeleted = 0;
  vol.parasiteWrites = vol.unitsFolded = 0;

#ifndef FL_READ_ONLY
  /* 
   * Make sure no unit chain with an invalid replacemenet unit 
   * pointer on the last unit 
   */
   
  if(vol.invalidReplacement != ANAND_NO_UNIT)
  {
     getUnitData(&vol,vol.invalidReplacement,&virUnit,&nextUnit);
     virUnit = virUnit&(~ANAND_REPLACING_UNIT);
     if(virUnit >= vol.noOfVirtualUnits)
     {
         DEBUG_PRINT(("ERROR - a bad unit header encountered.\r\n"));
         dismountNFTL(&vol);
         return  flBadFormat;
     }

     iUnit = vol.virtualUnits[virUnit];
     if(iUnit >= vol.noOfUnits)
     {
         DEBUG_PRINT(("ERROR - a bad unit header encountered.\r\n"));
         dismountNFTL(&vol);
         return  flBadFormat;
     }
     setUnavail(iUnit);
     checkStatus(foldUnit(&vol,virUnit,TRUE));
  }

  /* Make sure there is at least 1 free unit */ 
  if(vol.freeUnits == 0)
     foldBestChain(&vol,&iUnit);  /* make free units by folding the best chain */

#endif /* FL_READ_ONLY */

  /* Set TL routine */
  tl->rec = &vol;
  tl->mapSector = mapSector;
#ifndef FL_READ_ONLY
  tl->writeSector = writeSector;
  tl->deleteSector = deleteSector;
#ifdef DEFRAGMENT_VOLUME
  tl->defragment = defragment;
#endif
#if (defined(VERIFY_WRITE) || defined (VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
  tl->checkVolume      = checkVolume;
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */
#endif /* FL_READ_ONLY */
  tl->sectorsInVolume = sectorsInVolume;
  tl->getTLInfo = NFTLInfo;
  tl->tlSetBusy = tlSetBusy;
  tl->dismount  = dismountNFTL;
#ifndef NO_READ_BBT_CODE
  tl->readBBT   = readBBT;
#endif /* NO_READ_BBT_CODE */
  tl->writeMultiSector = NULL;
  tl->readSectors = NULL;

  DEBUG_PRINT(("Debug: finished NFTL mount.\r\n"));

#ifdef NFTL_CACHE

  /* create and initialize ANANDUnitHeader cache */
#ifdef ENVIRONMENT_VARS
  if( flUseNFTLCache == 1 ) /* behave according to the value of env variable */
#endif
  {
#ifdef FL_MALLOC
  vol.ucache = (ucacheEntry FAR1*) FL_FAR_MALLOC (vol.noOfUnits * sizeof(ucacheEntry));
#else
  vol.ucache = vol.ucacheBuf;
#endif /* FL_MALLOC */
  }
#ifdef ENVIRONMENT_VARS
  else
    vol.ucache = NULL;
#endif
  if (vol.ucache != NULL) {
    for (iUnit = 0; iUnit < vol.noOfUnits; iUnit++) {
      vol.ucache[iUnit].virtualUnitNo     = 0xDEAD;
      vol.ucache[iUnit].replacementUnitNo = 0xDEAD;
    }
  }
  else {
    DEBUG_PRINT(("Debug: NFTL runs without U-cache\r\n"));
  }

  /* create and initialize SectorFlags cache */
#ifdef ENVIRONMENT_VARS
  if( flUseNFTLCache == 1 ) /* behave according to the value of env variable */
#endif
  {
  scacheSize = (unsigned long)vol.noOfUnits << (vol.unitSizeBits - SECTOR_SIZE_BITS - 2);
#ifdef FL_MALLOC
  if( (sizeof(unsigned) < sizeof(scacheSize)) &&
      (scacheSize >= 0x10000L) )            /* Out of Segment Boundary */
    vol.scache = NULL;
  else
    vol.scache = (unsigned char FAR1*) FL_FAR_MALLOC (scacheSize);
#else
  vol.scache = vol.scacheBuf;
#endif /* FL_MALLOC */
  }
#ifdef ENVIRONMENT_VARS
  else
    vol.scache = NULL;
#endif
  if (vol.scache != NULL) {
    /*
     * Whenever SECTOR_IGNORE is found in Sector Flags cache it is double
     * checked by reading actual sector flags from flash-> This is way
     * all the cache entries are initially set to SECTOR_IGNORE.
     */
    unsigned char val = (S_CACHE_SECTOR_IGNORE << 6) | (S_CACHE_SECTOR_IGNORE << 4) |
            (S_CACHE_SECTOR_IGNORE << 2) |  S_CACHE_SECTOR_IGNORE;
    unsigned long iC;

    for(iC=0;( iC < scacheSize );iC++)
      vol.scache[iC] = val;
  }
  else {
    DEBUG_PRINT(("Debug: NFTL runs without S-cache\r\n"));
  }

#endif /* NFTL_CACHE */

  vol.badFormat = FALSE;
  vol.wearLevel.alarm = (unsigned char)(vol.eraseSum % WLnow);
  vol.wearLevel.currUnit = (ANANDUnitNo)(vol.eraseSum % vol.noOfVirtualUnits);

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                   f l R e g i s t e r N F T L                        */
/*                                                                      */
/* Register this translation layer                                      */
/*                                                                      */
/* Parameters:                                                          */
/*    None                                                              */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, otherwise failure                     */
/*----------------------------------------------------------------------*/

FLStatus flRegisterNFTL(void)
{
#ifdef FL_MALLOC
  unsigned i;
#endif

  if (noOfTLs >= TLS)
    return flTooManyComponents;

  tlTable[noOfTLs].mountRoutine = mountNFTL;

#ifdef FORMAT_VOLUME
  tlTable[noOfTLs].formatRoutine = formatNFTL;
#else
  tlTable[noOfTLs].formatRoutine = noFormat;
#endif
  noOfTLs++;

#ifdef FL_MALLOC
  for(i=0;( i < VOLUMES );i++) {
    vols[i].physicalUnits = NULL;
    vols[i].virtualUnits = NULL;
#ifdef NFTL_CACHE
    vols[i].ucache = NULL;
    vols[i].scache = NULL;
#endif /* NFTL_CACHE */
  }
#endif /* FL_MALLOC */
  return flOK;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                      m a r k A s I g n o r e d                       */
/*                                                                      */
/* Mark sector at given address as ignored.                             */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      addr            : Physical address of the sector                */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void markAsIgnored(Anand vol,CardAddress addr)
{
#ifndef RAM_MTD
    static const 
#endif /* RAM_MTD */
    byte sectorFlags[2] = {SECTOR_IGNORE,SECTOR_IGNORE};

    DEBUG_PRINT(("markAsIgnored : A sector is being marked as ignored\r\n"));

    /* Force remapping of internal catched sector */
    vol.flash->socket->remapped = TRUE;

#ifdef NFTL_CACHE
    setSectorFlagsCache(&vol, addr, SECTOR_IGNORE);
#endif /* NFTL_CACHE */
     vol.flash->write(vol.flash,addr+SECTOR_DATA_OFFSET,sectorFlags,sizeof(sectorFlags),EXTRA);

#if MAKE_SURE_IGNORE_HAS_BAD_EDC
     /* Force remapping of internal catched sector */
     vol.flash->socket->remapped = TRUE;

     /* Make sure EDC is wrong - a slite problem with PPP */
     if(vol.flash->read(vol.flash,addr,nftlBuffer,sizeof(nftlBuffer),EDC)==flOK)
     {
        tffsset(nftlBuffer,0,sizeof(nftlBuffer));
        vol.flash->write(vol.flash,addr,nftlBuffer,sizeof(nftlBuffer),0);
#if (defined(VERIFY_WRITE) || defined (VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
        /* Set all ff's for verifySector routine */
        tffsset(nftlBuffer,0xff,sizeof(nftlBuffer)); 
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */
     }
#endif /* MAKE_SURE_IGNORE_HAS_BAD_EDC */
}


#if (defined(VERIFY_WRITE) || defined (VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))

/*----------------------------------------------------------------------*/
/*                        v e r i f y S e c t o r s                     */
/*                                                                      */
/* Verify sectors for power failures simptoms and fix if neccesary.     */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorCount     : No of sectors to verify                       */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

FLStatus verifySectors(Anand vol, dword sectorCount)
{
   FLStatus    status;
   
   ANANDUnitNo virUnitNo;
   ANANDUnitNo unitNo;
   dword       curRead;
   CardAddress unitOffset;
   CardAddress startSectorAddress;
   CardAddress sourceSectorAddress;
   CardAddress nextFreeSectorAddress;
   byte        index,sectorFlags;
   byte FAR1*  buffer;

   if (vol.verifiedSectorNo >= vol.virtualSectors)
      return flOK;

   /* Initialize variables */
   buffer      = flReadBackBufferOf(vol.socketNo);
   if(buffer==NULL)
   {
       DEBUG_PRINT(("\nDebug : Can not verify sectors since no buffer was allocated\r\n"));
       return flOK;
   }
   virUnitNo   = (ANANDUnitNo)(vol.verifiedSectorNo / vol.sectorsPerUnit);
   sectorCount = TFFSMIN(vol.virtualSectors - vol.verifiedSectorNo,sectorCount);
   /* Force remapping of internal catched sector */
   vol.flash->socket->remapped = TRUE;
   tffsset(nftlBuffer,0xff,sizeof(nftlBuffer));

   /* Run over required number of virtual sectors */
   for (; sectorCount > 0 ; virUnitNo++ ,sectorCount -= curRead)
   {
      /* Calculate needed number of sector in this unit */
      unitOffset = (word)((vol.verifiedSectorNo % vol.sectorsPerUnit) << SECTOR_SIZE_BITS);
      curRead    = TFFSMIN(sectorCount,((1UL<<vol.unitSizeBits)-unitOffset)>>SECTOR_SIZE_BITS);
      unitNo     = vol.virtualUnits[virUnitNo];

      if(unitNo == ANAND_NO_UNIT) /* Unit is empty */
      {
         vol.verifiedSectorNo += ((1<<vol.unitSizeBits)-unitOffset)>>SECTOR_SIZE_BITS;
         continue;
      }

      /* Check all sector of unit or until required sectors */
      startSectorAddress  = unitBaseAddress(&vol,unitNo)+unitOffset;

      for (index = 0 ; index < curRead ; 
           index++, vol.verifiedSectorNo++)
      {
         nextFreeSectorAddress = ANAND_UNASSIGNED_ADDRESS; /* Search end addr */
         sourceSectorAddress = virtual2Physical(&vol,
                                                vol.verifiedSectorNo,
                                                &nextFreeSectorAddress);

         if(sourceSectorAddress == ANAND_UNASSIGNED_ADDRESS) /* No written sector */
            sourceSectorAddress = startSectorAddress + 
                                  ((CardAddress)index << SECTOR_SIZE_BITS);

         sectorFlags = getSectorFlags(&vol,sourceSectorAddress);
         if(sectorFlags == SECTOR_FREE)
         {
            checkStatus(vol.flash->read(vol.flash,sourceSectorAddress,buffer,SECTOR_SIZE,0));
            if (tffscmp(nftlBuffer,buffer,SECTOR_SIZE)!=0)
               markAsIgnored(&vol,sourceSectorAddress);     
            continue;
         } 
         else /* Used sector */
         {
            status = vol.flash->read(vol.flash,sourceSectorAddress,buffer,SECTOR_SIZE,EDC);
            switch (status)
            {
               case flDataError:
                  markAsIgnored(&vol,sourceSectorAddress);
                  createUnitCount(&vol,virUnitNo);
                  break;         /* Mark as ignored   */
               case flOK:
                  break;         /* Sector OK         */
               default:
                  return status; /* Report error      */
            }
         }
         /* Check the next free sector to make sure it is erased */
         if(nextFreeSectorAddress != ANAND_UNASSIGNED_ADDRESS)
         {
            checkStatus(vol.flash->read(vol.flash,nextFreeSectorAddress,buffer,SECTOR_SIZE,0));
            if (tffscmp(nftlBuffer,buffer,SECTOR_SIZE)!=0)
               markAsIgnored(&vol,nextFreeSectorAddress);     
         }
      } /* Loop over all sector of unit or until required sectors */
   } /* Loop over all required sectors */
   return flOK;
}


/*----------------------------------------------------------------------*/
/*                        c h e c k V o l u m e                         */
/*                                                                      */
/* Scanthe entire media for partialy written sectors.                   */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus checkVolume(Anand vol)
{
   return verifySectors(&vol, 0xffffffff);
}

#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */

/*----------------------------------------------------------------------*/
/*                     c h e c k F o l d i n g                          */
/*                                                                      */
/* Check folding status and if needed fold again.                       */
/*                                                                      */
/* Parameters:                                                          */
/*    vol           : Pointer identifying drive                         */
/*    virtualUnitNo : Virtual unit number to re-fold                    */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus checkFolding(Anand vol, ANANDUnitNo virtualUnitNo)
{
   ANANDUnitNo tmp;

   if(vol.freeUnits == 0)
      checkStatus(foldBestChain(&vol, &tmp));
   return foldUnit(&vol,virtualUnitNo,TRUE);
}


#endif /* FL_READ_ONLY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\tffsport.h ===
#ifndef TFFSPORT_H
#define TFFSPORT_H

#include "wmilib.h"
#include "wmistr.h"

#define VENDORSTRING    "MSystems"
#define PRODUCTSTRING   "DiskOnChip2000  "
#define REVISIONSTRING  "1.00"
#define SERIALSTRING    "0001"

#define VENDORSTRINGSIZE    8
#define PRODUCTSTRINGSIZE   16
#define REVISIONSTRINGSIZE  4
#define SERIALSTRINGSIZE    4

#define DISKONCHIP_WINDOW_SIZE  0x2000
#define START_SEARCH_ADDRESS    0xc8000L
#define END_SEARCH_ADDRESS      0xda000L
#define DISKONCHIP_INTERFACE    Isa
#define DISKONCHIP_BUSNUMBER    0

#define d_SEARCH_ADDRESS    0xd0000L
#define dd_SEARCH_ADDRESS      0xd4000L

#define TFFS_MEMORY_SPACE    0
#define TFFS_IO_SPACE        1

#define MAX_TRANSFER_SIZE_PER_SRB   (0x10000)
#define MODE_DATA_SIZE              192

#define DEVICE_DEFAULT_IDLE_TIMEOUT   0xffffffff
#define DEVICE_VERY_LONG_IDLE_TIMEOUT 0xfffffffe

// Device state flags
#define DEVICE_FLAG_STOPPED                 0x00000001
#define DEVICE_FLAG_REMOVED                 0x00000002
#define DEVICE_FLAG_CLAIMED                 0x00000004
#define DEVICE_FLAG_QUERY_STOP_REMOVE       0x00000008
#define DEVICE_FLAG_STARTED                 0x00000010
#define DEVICE_FLAG_HOLD_IRPS               0x00000020
#define DEVICE_FLAG_CHILD_REMOVED           0x00000040

// Removed WE DONT NEED THIS FLAG
// instead examine the threadObject .. that object gets nulled
// when the thread has exited.
// #define DEVICE_FLAG_THREAD                  0x00000080

#define DRIVER_PARAMETER_SUBKEY     "Parameters"
#define LEGACY_DETECTION            L"LegacyDetection"
#define DRIVER_OBJECT_EXTENSION_ID  DriverEntry

#define NUM_WMI_MINOR_FUNCTION      (0xa)



typedef struct _TempINFO{
    long baseAddress;
    unsigned char nextPartition;
}TempINFO;

typedef struct      /*  represents DOC 2000 & Millenium memory window  */
{
           UCHAR   IPLpart1[0x800];     /* read   not used here */
  volatile UCHAR   IPLpart2[0x800];     /* read     IO for MDOC */
  volatile UCHAR   chipId;              /* read       */
  volatile UCHAR   DOCstatus;           /* read       */
  volatile UCHAR   DOCcontrol;          /*      write */
  volatile UCHAR   ASICselect;          /* read write */
  volatile UCHAR   signals;             /* read write */
  volatile UCHAR   deviceSelector;      /* read write */
  volatile UCHAR   ECCconfig;           /*      write */
  volatile UCHAR   ECCstatus;           /* read       */
  volatile UCHAR   test[5];             /*        not used here */
  volatile UCHAR   slowIO;              /* read write */
           UCHAR   filler1[2];          /*  --    --  */
  volatile UCHAR   syndrom[6];          /* read       */
           UCHAR   filler2[5];          /*  --    --  */
  volatile UCHAR   aliasResolution;     /* read write MDOC only */
  volatile UCHAR   configInput;         /* read write   - || -  */
  volatile UCHAR   readPipeInit;        /* read         - || -  */
  volatile UCHAR   writePipeTerm;       /*      write   - || -  */
  volatile UCHAR   readLastData;        /* read write   - || -  */
  volatile UCHAR   NOPreg;              /* read write   - || -  */
           UCHAR   filler3[0x1D];       /*  --    --  */
  volatile UCHAR   ROMwriteEnable;      /*      write DOC only  */
  volatile UCHAR   foudaryTest;         /*      write */
           UCHAR   filler4[0x800-0x40]; /*  --    --  */
  volatile UCHAR   io[0x800];           /* read write */
} DOC2window;

typedef struct      /*  represents MDOC PLUS memory window  */
{
           unsigned char   IPLpart1[0x800];     /* 0000-07ff    */
  volatile unsigned char   io1[0x800];          /* 0800-0fff    */
  volatile unsigned char   chipId;              /* 1000         */
           unsigned char   filler1;             /*  --    --    */
  volatile unsigned char   NopReg;              /* 1002         */
           unsigned char   filler2;             /*  --    --    */
  volatile unsigned char   AliasResolution;     /* 1004         */
           unsigned char   filler3;             /*  --    --    */
  volatile unsigned char   DOCcontrol;          /* 1006         */
           unsigned char   filler4;             /*  --    --    */
  volatile unsigned char   DeviceIDselect;      /* 1008         */
           unsigned char   filler5;             /*  --    --    */
  volatile unsigned char   ConfigReg;           /* 100A         */
           unsigned char   filler6;             /*  --    --    */
  volatile unsigned char   OutputReg;           /* 100C         */
           unsigned char   filler7;             /*  --    --    */
  volatile unsigned char   IntCntReg;           /* 100E         */
           unsigned char   filler8;             /*  --    --    */
  volatile unsigned char   IntVecReg;           /* 1010         */
           unsigned char   filler9;             /*  --    --    */
  volatile unsigned char   OutputEnableReg;     /* 1012         */
           unsigned char   filler10[0xB];       /*  --    --    */
  volatile unsigned char   FlSlowReg[2];        /* 101E - 101F  */
  volatile unsigned char   FlCntReg;            /* 1020         */
           unsigned char   filler11;            /*  --    --    */
  volatile unsigned char   FlSelectReg;         /* 1022         */
           unsigned char   filler12;            /*  --    --    */
  volatile unsigned char   FlCmdReg;            /* 1024         */
           unsigned char   filler13;            /*  --    --    */
  volatile unsigned char   FlAddressReg;        /* 1026         */
           unsigned char   filler14;            /*  --    --    */
  volatile unsigned char   FlDataReg[2];        /* 1028-1029    */
  volatile unsigned char   readPipeInit;        /* 102A         */
           unsigned char   filler15;            /*  --    --    */
  volatile unsigned char   readLastData[2];     /* 102C-102D    */
  volatile unsigned char   WritePipeTerm;       /* 102E         */
           unsigned char   filler16[17];       /*  --    -- */
  volatile unsigned char   syndrom[6];          /* 1040-1045    */
  volatile unsigned char   EccCntReg;           /* 1046         */
           unsigned char   filler17;            /*  --    --    */
  volatile unsigned char   CotpReg;             /* 1048         */
           unsigned char   filler18[17];        /*  --    --    */
  volatile unsigned char   FlGeometryReg;       /* 105A         */
           unsigned char   filler19;            /*  --    --    */
  volatile unsigned char   DataProtect[0x17];   /* 105C-1072    */
           unsigned char   filler20;            /*  --    --    */
  volatile unsigned char   DownloadReg;         /* 1074         */
           unsigned char   filler21;            /*  --    --    */
  volatile unsigned char   DocCntConfirmReg;    /* 1076         */
           unsigned char   filler22;            /*  --    --    */
  volatile unsigned char   ProtectionReg;       /* 1078         */
           unsigned char   filler23[0x6];       /*  --    --    */
  volatile unsigned char   foundryTest;         /* 107E         */
           unsigned char   filler24;            /*  --    --    */
           unsigned char   filler25[0x77F];         /*  --    --    */
  volatile unsigned char   io2[0x7FF];          /* 1800-1FFF    */
  volatile unsigned char   PowerDownReg;         /* 1FFF            */
} MDOCPwindow;
/* MDOC PLUS */


typedef struct _NTpcicParams {
    PHYSICAL_ADDRESS phWindowBase;
    ULONGLONG        physWindow;
    ULONG            windowSize;
    ULONG            addressSpace;
    PVOID            windowBase;
    INTERFACE_TYPE   InterfaceType;
    ULONG            BusNumber;
}  NTpcicParams;

typedef struct _TRUEFFSDRIVER_EXTENSION {

    UNICODE_STRING RegistryPath;

} TRUEFFSDRIVER_EXTENSION, *PTRUEFFSDRIVER_EXTENSION;


#define EXTENSION_COMMON_HEADER     PDEVICE_OBJECT DeviceObject; \
                                    PDEVICE_OBJECT LowerDeviceObject; \
                                    PDRIVER_OBJECT DriverObject; \
                                    DEVICE_POWER_STATE DevicePowerState; \
                                    SYSTEM_POWER_STATE SystemPowerState; \
                                    ULONG PagingPathCount; \
                                    ULONG HiberPathCount; \
                                    ULONG CrashDumpPathCount; \
                                    WMILIB_CONTEXT WmiLibInfo

typedef struct _DEVICE_EXTENSION_HEADER {

    EXTENSION_COMMON_HEADER;

} DEVICE_EXTENSION_HEADER, * PDEVICE_EXTENSION_HEADER;

typedef struct _DEVICE_EXTENSION {
    EXTENSION_COMMON_HEADER;
    PDEVICE_OBJECT MainPdo;
    PDEVICE_OBJECT ChildPdo;
    ULONG DeviceFlags;
    ULONG Cylinders;
    ULONG NumberOfHeads;
    ULONG SectorsPerTrack;
    ULONG BytesPerSector;
    ULONG noOfHiddenSectors;
    ULONG totalSectors;
    PSCSI_REQUEST_BLOCK CurrentSrb;
    PUSHORT DataBuffer;
    BOOLEAN SymbolicLinkCreated;
    ULONG TrueffsDeviceNumber;
    ULONG UnitNumber;
    ULONG ScsiPortNumber;
    UCHAR ScsiDeviceType;
    KSPIN_LOCK ExtensionDataSpinLock;
    LIST_ENTRY listEntry;
    KSEMAPHORE requestSemaphore;
    KSPIN_LOCK listSpinLock;
    LONG threadReferenceCount;
    KEVENT PendingIRPEvent;
    BOOLEAN removableMedia;
    ULONG NumberOfDisksPoweredUp;
    NTpcicParams pcmciaParams;
    PKTHREAD TffsportThreadObject;
        BOOLEAN  IsPartitonTableWritten;
        BOOLEAN  IsWriteProtected;
        UCHAR        PartitonTable[0x200];
        BOOLEAN  IsSWWriteProtected;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

typedef struct _PDO_EXTENSION {
    EXTENSION_COMMON_HEADER;
    PDEVICE_EXTENSION Pext;    // parent device extension
    PIRP PendingPowerIrp;
    PULONG IdleCounter;
} PDO_EXTENSION, *PPDO_EXTENSION;

typedef struct _TFFS_DEVICE_TYPE {
    PCSTR DeviceTypeString;
    PCSTR CompatibleIdString;
    PCSTR PeripheralIdString;
} TFFS_DEVICE_TYPE, * PTFFS_DEVICE_TYPE;

typedef struct _FDO_POWER_CONTEXT {
   POWER_STATE_TYPE   PowerType;
   POWER_STATE        PowerState;
} FDO_POWER_CONTEXT, *PFDO_POWER_CONTEXT;

#define IS_FDO(devExtension)  (devExtension->LowerDeviceObject != NULL)

typedef
VOID
(*PSTALL_ROUTINE) (
    IN ULONG Delay
    );

typedef
BOOLEAN
(*PDUMP_DRIVER_OPEN) (
    IN LARGE_INTEGER PartitionOffset
    );

typedef
NTSTATUS
(*PDUMP_DRIVER_WRITE) (
    IN PLARGE_INTEGER DiskByteOffset,
    IN PMDL Mdl
    );


typedef
VOID
(*PDUMP_DRIVER_FINISH) (
    VOID
    );

struct _ADAPTER_OBJECT;

//
// This is the information passed from the system to the disk dump driver
// during the driver's initialization.
//

typedef struct _INITIALIZATION_CONTEXT {
    ULONG Length;
    ULONG DiskSignature;
    PVOID MemoryBlock;
    PVOID CommonBuffer[2];
    PHYSICAL_ADDRESS PhysicalAddress[2];
    PSTALL_ROUTINE StallRoutine;
    PDUMP_DRIVER_OPEN OpenRoutine;
    PDUMP_DRIVER_WRITE WriteRoutine;
    PDUMP_DRIVER_FINISH FinishRoutine;
    struct _ADAPTER_OBJECT *AdapterObject;
    PVOID MappedRegisterBase;
    PVOID PortConfiguration;
    BOOLEAN CrashDump;
    ULONG MaximumTransferSize;
    ULONG CommonBufferSize;
    PVOID TargetAddress; //Opaque pointer to target address structure
} INITIALIZATION_CONTEXT, *PINITIALIZATION_CONTEXT;

typedef struct _CRASHDUMP_INIT_DATA {

    PDEVICE_EXTENSION cdFdoExtension;

} CRASHDUMP_INIT_DATA, *PCRASHDUMP_INIT_DATA;

typedef struct _CRASHDUMP_DATA {
    PCRASHDUMP_INIT_DATA    CrashInitData;
    LARGE_INTEGER           PartitionOffset;
    PSTALL_ROUTINE          StallRoutine;
    SCSI_REQUEST_BLOCK      Srb;
    DEVICE_EXTENSION        fdoExtension;
    ULONG                   MaxBlockSize;
} CRASHDUMP_DATA, *PCRASHDUMP_DATA;

typedef struct _WMI_FLASH_DISK_INFO {
    ULONG Number;
    ULONG Address;
    ULONG Size;
} WMI_FLASH_DISK_INFO, *PWMI_FLASH_DISK_INFO;

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

NTSTATUS
TrueffsFetchKeyValue(
    IN PDRIVER_OBJECT       DriverObject,
    IN PUNICODE_STRING  RegistryPath,
        IN PWSTR                        KeyName,
        IN OUT ULONG*               KeyValue
);

NTSTATUS
TrueffsDetectRegistryValues(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
);

NTSTATUS
TrueffsDetectDiskOnChip(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
TrueffsTranslateAddress(
    IN INTERFACE_TYPE     InterfaceType,
    IN ULONG              BusNumber,
    IN PHYSICAL_ADDRESS   StartAddress,
    IN LONG               Length,
    IN OUT PULONG         AddressSpace,
    OUT PVOID             *TranslatedAddress,
    OUT PPHYSICAL_ADDRESS TranslatedMemoryAddress
    );

VOID
TrueffsFreeTranslatedAddress(
    IN PVOID TranslatedAddress,
    IN LONG  Length,
    IN ULONG AddressSpace
    );

NTSTATUS
TrueffsAddDevice(
    PDRIVER_OBJECT DriverObject,
    PDEVICE_OBJECT Pdo
    );

NTSTATUS
TrueffsCreateDevObject(
    IN PDRIVER_OBJECT     DriverObject,
    IN PDEVICE_OBJECT     Pdo,
    OUT PDEVICE_EXTENSION *FdoExtension
    );

NTSTATUS
TrueffsStartDevice(
    IN PDEVICE_EXTENSION deviceExtension,
    IN PCM_RESOURCE_LIST ResourceList,
    IN BOOLEAN           CheckResources
    );

NTSTATUS
TrueffsMountMedia(
     IN PDEVICE_EXTENSION deviceExtension
    );

NTSTATUS
TrueffsStopRemoveDevice(
    PDEVICE_EXTENSION deviceExtension
    );

NTSTATUS
TrueffsCreateSymblicLinks (
    PDEVICE_EXTENSION FdoExtension
    );

NTSTATUS
TrueffsDeleteSymblicLinks (
    PDEVICE_EXTENSION FdoExtension
    );

NTSTATUS
TrueffsDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TrueffsDispatchSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
TrueffsQueryProperty(
    IN PDEVICE_EXTENSION deviceExtension,
    IN PIRP QueryIrp
    );

NTSTATUS
TrueffsScsiRequests(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TrueffsCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TrueffsPnpDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
TrueffsPowerControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

VOID
TrueffsUnload(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
TrueffsStartIo (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
TrueffsThread(
    PVOID Context
    );

NTSTATUS
QueueIrpToThread(
    IN OUT PIRP Irp,
    IN OUT PDEVICE_EXTENSION deviceExtension
    );

NTSTATUS
TrueffsTranslateSRBStatus(
    ULONG status
    );

NTSTATUS
TrueffsDeviceQueryId (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    BOOLEAN Fdo
    );

PWSTR
DeviceBuildBusId(
    IN PDEVICE_EXTENSION deviceExtension,
    BOOLEAN Fdo
    );

PWSTR
DeviceBuildInstanceId(
    IN PDEVICE_EXTENSION deviceExtension,
    BOOLEAN Fdo
    );
PWSTR
DeviceBuildCompatibleId(
    IN PDEVICE_EXTENSION deviceExtension,
    BOOLEAN Fdo
);

PWSTR
DeviceBuildHardwareId(
    IN PDEVICE_EXTENSION deviceExtension,
    BOOLEAN Fdo
    );

VOID
CopyField(
    IN PUCHAR Destination,
    IN PUCHAR Source,
    IN ULONG  Count,
    IN UCHAR  Change
    );

PCSTR
TrueffsGetDeviceTypeString (
    IN ULONG DeviceType
    );

PCSTR
TrueffsGetCompatibleIdString (
    IN ULONG DeviceType
    );

PCSTR
TrueffsGetPeripheralIdString (
    IN ULONG DeviceType
    );

PCSTR
TrueffsGetDeviceTypeStringFDO (
    IN ULONG DeviceType
    );

PCSTR
TrueffsGetCompatibleIdStringFDO (
    IN ULONG DeviceType
    );

PCSTR
TrueffsGetPeripheralIdStringFDO (
    IN ULONG DeviceType
    );

NTSTATUS
TrueffsQueryDeviceRelations (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    BOOLEAN Fdo
    );

BOOLEAN
TrueffsOkToDetectLegacy (
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
TrueffsGetParameterFromServiceSubKey (
    IN  PDRIVER_OBJECT DriverObject,
    IN  PWSTR          ParameterName,
    IN  ULONG          ParameterType,
    IN  BOOLEAN        Read,
    OUT PVOID          *ParameterValue,
    IN  ULONG          ParameterValueWriteSize
    );

NTSTATUS
TrueffsRegQueryRoutine (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

HANDLE
TrueffsOpenServiceSubKey (
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING SubKeyPath
    );

VOID
TrueffsCloseServiceSubKey (
    IN HANDLE SubServiceKey
    );

NTSTATUS
TrueffsFindDiskOnChip(
    IN INTERFACE_TYPE   InterfaceType,
    IN ULONG            BusNumber,
    IN ULONG            StartSearchAddress,
    IN LONG             WindowSize,
    IN BOOLEAN          StartSearch,
    OUT PVOID           *WindowBase
    );

NTSTATUS
TrueffsCheckDiskOnChip(
    IN INTERFACE_TYPE   InterfaceType,
    IN ULONG            BusNumber,
    IN ULONG            StartSearchAddress,
    IN LONG             WindowSize,
    OUT PVOID           *WindowBase,
    OUT PULONG          AddressSpace
    );

VOID
TrueffsResetDiskOnChip(
    IN INTERFACE_TYPE   InterfaceType,
    IN ULONG            BusNumber,
    IN ULONG            StartSearchAddress,
    IN LONG             WindowSize
    );

PPDO_EXTENSION
AllocatePdo(
    IN PDEVICE_EXTENSION FdoExtension
    );

NTSTATUS
FreePdo(
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

VOID
flBuildGeometry(dword capacity,
                                dword FAR2 *cylinders,
                                dword FAR2 *heads,
                                dword FAR2 *sectors,
                                FLBoolean oldFormat);

NTSTATUS
TrueffsSetPdoDevicePowerState( IN PDEVICE_OBJECT Pdo,
                               IN OUT PIRP Irp
                              );

NTSTATUS
TrueffsSetPdoSystemPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
TrueffsSetPdoPowerState(
                      IN PDEVICE_OBJECT Pdo,
                      IN OUT PIRP Irp
                      );

NTSTATUS
TrueffsSetFdoPowerState (
                       IN PDEVICE_OBJECT DeviceObject,
                       IN OUT PIRP Irp
                       );

NTSTATUS
TrueffsFdoDevicePowerIrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID contextIrp,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
TrueffsFdoPowerCompletionRoutine (
                                IN PDEVICE_OBJECT DeviceObject,
                                IN PIRP Irp,
                                IN PVOID Context
                                );

VOID
TrueffsPdoCompletePowerIrp (
                          IN PDEVICE_OBJECT DeviceObject,
                          IN PIRP Irp
                          );

VOID
TrueffsPdoRequestPowerCompletionRoutine(
                                      IN PDEVICE_OBJECT Pdo,
                                      IN UCHAR MinorFunction,
                                      IN POWER_STATE PowerState,
                                      IN PVOID Context,
                                      IN PIO_STATUS_BLOCK IoStatus
                                      );
NTSTATUS
TrueffsFdoChildRequestPowerUp (
                             IN PDEVICE_EXTENSION FdoExtension,
                             IN PPDO_EXTENSION    PdoExtension,
                             IN PIRP              Irp
                             );

NTSTATUS
TrueffsFdoChildRequestPowerUpCompletionRoutine (
                                              IN PDEVICE_OBJECT   DeviceObject,
                                              IN UCHAR            MinorFunction,
                                              IN POWER_STATE      PowerState,
                                              IN PVOID            Context,
                                              IN PIO_STATUS_BLOCK IoStatus
                                              );

NTSTATUS
TrueffsParentPowerUpCompletionRoutine(
                                    IN PVOID Context,
                                    IN NTSTATUS FdoStatus
                                    );

VOID
TrueffsFdoChildReportPowerDown (
                              IN PDEVICE_EXTENSION FdoExtension
                              );

NTSTATUS
TrueffsDeviceQueryCapabilities(IN PDEVICE_EXTENSION    deviceExtension,
                               IN PDEVICE_CAPABILITIES Capabilities
                                 );

NTSTATUS
updateDocSocketParams(PDEVICE_EXTENSION fdoExtension);

NTSTATUS updatePcmciaSocketParams(PDEVICE_EXTENSION fdoExtension);


NTSTATUS
TrueffsSyncSendIrp (
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT OPTIONAL PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
TrueffsSyncSendIrpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
TrueffsCallDriverSync(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
TrueffsCallDriverSyncCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

ULONG
TrueffsCrashDumpDriverEntry (
    PVOID Context
    );

BOOLEAN
TrueffsCrashDumpOpen (
    IN LARGE_INTEGER PartitionOffset
    );

NTSTATUS
TrueffsCrashDumpWrite (
    IN PLARGE_INTEGER DiskByteOffset,
    IN PMDL Mdl
    );

VOID
TrueffsCrashDumpFinish (
    VOID
    );

VOID
TrueffsWmiInit (
    VOID
    );

NTSTATUS
TrueffsWmiRegister(
    PDEVICE_EXTENSION_HEADER DevExtension
    );

NTSTATUS
TrueffsWmiDeregister(
    PDEVICE_EXTENSION_HEADER DevExtension
    );

NTSTATUS
TrueffsWmiSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
TrueffsQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            OutBufferSize,
    OUT PUCHAR          Buffer
    );

NTSTATUS
TrueffsQueryWmiRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
TrueffsSetWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    );

NTSTATUS
TrueffsSetWmiDataItem(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            DataItemId,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    );


#if DBG

#define TffsDebugPrint(X) TrueffsDebugPrint X

#define TFFS_DEB_ALL       0x0000FFFF
#define TFFS_DEB_INFO      0x00000001
#define TFFS_DEB_WARN      0x00000002
#define TFFS_DEB_ERROR     0x00000004

VOID
TrueffsDebugPrint(ULONG DebugPrintLevel, PCHAR DebugMessage, ...);

#else

#define TffsDebugPrint(X)

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\stdcomp.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/STDCOMP.H_V  $
 * 
 *    Rev 1.3   Jul 31 2001 22:29:36   oris
 * Improved documentation.
 * 
 *    Rev 1.2   Jun 17 2001 16:40:04   oris
 * Improved documentation.
 * 
 *    Rev 1.1   Apr 01 2001 07:55:24   oris
 * Copywrite notice.
 * flRegisterDOC2400 was changed to flRegisterDOCPLUS.
 * flRegisterDOCSOC2400 was changed to flRegisterDOCPLUSSOC.
 * 
 *    Rev 1.0   Feb 04 2001 12:39:10   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#ifndef STDCOMP_H
#define STDCOMP_H

#include "flbase.h"

/************************************************************************/
/* Registration routines for MTDs supplied with TrueFFS			*/
/************************************************************************/

FLStatus    flRegisterI28F008(void);                  /* see I28F008.C  */
FLStatus    flRegisterI28F016(void);                  /* see I28F016.C  */
FLStatus    flRegisterAMDMTD(void);                   /* see AMDMTD.C   */
FLStatus    flRegisterWAMDMTD(void);                  /* see WAMDMTD.C  */
FLStatus    flRegisterCDSN(void);                     /* see NFDC2048.C */
FLStatus    flRegisterCFISCS(void);                   /* see CFISCS.C   */
FLStatus    flRegisterDOC2000(void); 	              /* see DISKONC.C  */
FLStatus    flRegisterDOCPLUS(void); 	              /* see MDOCPLUS.C */

/************************************************************************/
/* Registration routines for socket I/F supplied with TrueFFS		*/
/************************************************************************/

FLStatus    flRegisterPCIC(unsigned int, unsigned int, unsigned char);
						      /* see PCIC.C     */
FLStatus    flRegisterElanPCIC(unsigned int, unsigned int, unsigned char);
						      /* see PCICELAN.C */
FLStatus    flRegisterLFDC(FLBoolean);                /* see LFDC.C     */

FLStatus    flRegisterElanRFASocket(int, int);        /* see ELRFASOC.C */
FLStatus    flRegisterElanDocSocket(long, long, int); /* see ELDOCSOC.C */
FLStatus    flRegisterVME177rfaSocket(unsigned long, unsigned long);
						      /* FLVME177.C */
FLStatus    flRegisterCobuxSocket(void);              /* see COBUXSOC.C */
FLStatus    flRegisterCEDOCSOC(void);                 /* see CEDOCSOC.C */
FLStatus    flRegisterCS(void);                       /* see CSwinCE.C */

FLStatus    flRegisterDOCSOC(unsigned long, unsigned long);
						      /* see DOCSOC.C */
FLStatus    flRegisterDOCPLUSSOC(unsigned long, unsigned long);
						      /* see DOCSOC.C */

#ifdef NT5PORT
FLStatus		flRegisterNT5PCIC();											/* see SOCKETNT.C */
#endif /*NT5PORT*/

/************************************************************************/
/* Registration routines for translation layers supplied with TrueFFS	*/
/************************************************************************/

FLStatus    flRegisterFTL(void);                      /* see FTLLITE.C  */
FLStatus    flRegisterNFTL(void);                     /* see NFTLLITE.C */
FLStatus    flRegisterINFTL(void);                    /* see INFTL.C */
FLStatus    flRegisterSSFDC(void);                    /* see SSFDC.C    */
FLStatus    flRegisterATAtl(void);                    /* see atatl.c    */
FLStatus    flRegisterZIP(void);		      /* see ZIP.C	*/

/************************************************************************/
/* Multi-TL also known as Multi-DOC: Combine different devices into a   */
/* single big device allowing each of the devices to be formatted with  */
/* any kind of the TL mentioned above                                   */
/************************************************************************/

FLStatus    flRegisterMTL(void);                      /* see FLMTL.C    */

/************************************************************************/
/* Component registration routine in FLCUSTOM.C				*/
/************************************************************************/

FLStatus    flRegisterComponents(void);

#endif /* STDCOMP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\socketnt.c ===
/*
 * $Log: $
 */

/************************************************************************/
/*                                                                      */
/*      FAT-FTL Lite Software Development Kit           */
/*      Copyright (C) M-Systems Ltd. 1995-1996          */
/*                                  */
/************************************************************************/


#include "flsocket.h"
#include "scsi.h"
#include "tffsport.h"
#include "INITGUID.H"
#include "ntddpcm.h"

#define ANTI_CRASH_WINDOW

#ifdef ANTI_CRASH_WINDOW
CHAR antiCrashWindow_socketnt[0x2000];
#endif

/*NTsocketParams driveInfo[SOCKETS];
NTsocketParams * pdriveInfo = driveInfo;
*/
extern NTsocketParams driveInfo[SOCKETS];
extern NTsocketParams * pdriveInfo;
PCMCIA_INTERFACE_STANDARD driveContext[SOCKETS];

NTSTATUS queryInterfaceCompletionRoutine (
                         IN PDEVICE_OBJECT DeviceObject,
                         IN PIRP Irp,
                         IN PVOID Context
                         )
{
  PKEVENT event = Context;
  KeSetEvent(event, EVENT_INCREMENT, FALSE);
  return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
updatePcmciaSocketParams(PDEVICE_EXTENSION fdoExtension)
{
    PIRP irp = NULL;
    NTSTATUS status;

    //
    // Setup a query interface request for the pcmcia pdo
    //
    irp = IoAllocateIrp(fdoExtension->LowerDeviceObject->StackSize, FALSE);

    if (irp)
    {
        PIO_STACK_LOCATION irpSp;
        KEVENT event;
        ULONG device = fdoExtension->UnitNumber;

        irpSp = IoGetNextIrpStackLocation(irp);

        irpSp->MajorFunction = IRP_MJ_PNP;
        irpSp->MinorFunction = IRP_MN_QUERY_INTERFACE;
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        irpSp->Parameters.QueryInterface.InterfaceType = &GUID_PCMCIA_INTERFACE_STANDARD;
        irpSp->Parameters.QueryInterface.Size          = sizeof(PCMCIA_INTERFACE_STANDARD);
        irpSp->Parameters.QueryInterface.Version       = 1;
        irpSp->Parameters.QueryInterface.Interface     = (PINTERFACE) &driveContext[device];
        irpSp->Parameters.QueryInterface.InterfaceSpecificData = NULL;

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoSetCompletionRoutine(irp, queryInterfaceCompletionRoutine, &event, TRUE, TRUE, TRUE);
        status = IoCallDriver(fdoExtension->LowerDeviceObject, irp);

        if (status == STATUS_PENDING)
        {
            status = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        }

        status = irp->IoStatus.Status;
        IoFreeIrp (irp);

        if (NT_SUCCESS(status))
        {
            driveInfo[device].windowSize   = fdoExtension->pcmciaParams.windowSize;
            driveInfo[device].physWindow   = fdoExtension->pcmciaParams.physWindow;
            driveInfo[device].winBase      = fdoExtension->pcmciaParams.windowBase;
            driveInfo[device].fdoExtension = (PVOID) fdoExtension;
            driveInfo[device].interfAlive  = 1;
        }
    }
    else
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


/************************************************************************/
/*                                                                      */
/*      Beginning of controller-customizable code               */
/*                                                                      */
/* The function prototypes and interfaces in this section are standard  */
/* and are used in this form by the non-customizable code. However, the */
/* function implementations are specific to the 82365SL controller. */
/*                                  */
/* You should replace the function bodies here with the implementation  */
/* that is appropriate for your controller.             */
/*                                  */
/* All the functions in this section have no parameters. This is    */
/* because the parameters needed for an operation may be themselves */
/* depend on the controller. Instead, you should use the value in the   */
/* 'vol' structure as parameters.                   */
/* If you need socket-state variables specific to your implementation,  */
/* it is recommended to add them to the 'vol' structure rather than */
/* define them as separate static variables.                */
/*                                  */
/************************************************************************/

/*----------------------------------------------------------------------*/
/*                    c a r d D e t e c t e d           */
/*                                  */
/* Detect if a card is present (inserted)               */
/*                                  */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive         */
/*                                                                      */
/* Returns:                                                             */
/*  0 = card not present, other = card present          */
/*----------------------------------------------------------------------*/

FLBoolean cardDetected_socketnt(FLSocket vol)
{
  return TRUE;    /* we will know when card is removed */
  /*Implemented by upper layers*/
}


/*----------------------------------------------------------------------*/
/*                         V c c O n                */
/*                                  */
/* Turns on Vcc (3.3/5 Volts). Vcc must be known to be good on exit.    */
/*                                  */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive         */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID VccOn_socketnt(FLSocket vol)
{
}


/*----------------------------------------------------------------------*/
/*                       V c c O f f                */
/*                                  */
/* Turns off Vcc.                           */
/*                                  */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive         */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID VccOff_socketnt(FLSocket vol)
{
}


#ifdef SOCKET_12_VOLTS

/*----------------------------------------------------------------------*/
/*                         V p p O n                */
/*                                  */
/* Turns on Vpp (12 Volts. Vpp must be known to be good on exit.    */
/*                                  */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive         */
/*                                                                      */
/* Returns:                                                             */
/*  FLStatus    : 0 on success, failed otherwise        */
/*----------------------------------------------------------------------*/

FLStatus VppOn_socketnt(FLSocket vol)
{

  if (driveInfo[vol.volNo].fdoExtension != NULL) {
    if (((PDEVICE_EXTENSION)driveInfo[vol.volNo].fdoExtension)->DeviceFlags & DEVICE_FLAG_REMOVED) {
        return flVppFailure;
    }
  }
  else
      return flVppFailure;

  if (driveContext[vol.volNo].SetVpp(driveContext[vol.volNo].Context, PCMCIA_VPP_12V)) {
      return flOK;
  }
  else {
    return flVppFailure;
  }
}


/*----------------------------------------------------------------------*/
/*                       V p p O f f                */
/*                                  */
/* Turns off Vpp.                           */
/*                                  */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive         */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID VppOff_socketnt(FLSocket vol)
{
  if (driveInfo[vol.volNo].fdoExtension != NULL) {
    if (((PDEVICE_EXTENSION)driveInfo[vol.volNo].fdoExtension)->DeviceFlags & DEVICE_FLAG_REMOVED) {
          return;
    }
  }
  else
      return;

  if (driveInfo[vol.volNo].interfAlive) {
      driveContext[vol.volNo].SetVpp(driveContext[vol.volNo].Context, PCMCIA_VPP_IS_VCC);
  }
}

#endif  /* SOCKET_12_VOLTS */


/*----------------------------------------------------------------------*/
/*                    i n i t S o c k e t                   */
/*                                  */
/* Perform all necessary initializations of the socket or controller    */
/*                                  */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive         */
/*                                                                      */
/* Returns:                                                             */
/*  FLStatus    : 0 on success, failed otherwise        */
/*----------------------------------------------------------------------*/

FLStatus initSocket_socketnt(FLSocket vol)
{
  return flOK;  /* nothing to initialize */
}


/*----------------------------------------------------------------------*/
/*                      s e t W i n d o w               */
/*                                  */
/* Sets in hardware all current window parameters: Base address, size,  */
/* speed and bus width.                         */
/* The requested settings are given in the 'vol.window' structure.  */
/*                                  */
/* If it is not possible to set the window size requested in        */
/* 'vol.window.size', the window size should be set to a larger value,  */
/* if possible. In any case, 'vol.window.size' should contain the   */
/* actual window size (in 4 KB units) on exit.              */
/*                                  */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive         */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID setWindow_socketnt(FLSocket vol)
{
  vol.window.size = driveInfo[vol.volNo].windowSize;
  vol.window.base = driveInfo[vol.volNo].winBase;
}

/*----------------------------------------------------------------------*/
/*             s e t M a p p i n g C o n t e x t            */
/*                                  */
/* Sets the window mapping register to a card address.          */
/*                                  */
/* The window should be set to the value of 'vol.window.currentPage',   */
/* which is the card address divided by 4 KB. An address over 128KB,    */
/* (page over 32K) specifies an attribute-space address.        */
/*                                  */
/* The page to map is guaranteed to be on a full window-size boundary.  */
/*                                  */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive         */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID setMappingContext_socketnt(FLSocket vol, unsigned page)
{
  UCHAR winSpeed;
  if (driveInfo[vol.volNo].fdoExtension != NULL) {
    if (((PDEVICE_EXTENSION)driveInfo[vol.volNo].fdoExtension)->DeviceFlags & DEVICE_FLAG_REMOVED) {
#ifdef ANTI_CRASH_WINDOW
          vol.window.base = antiCrashWindow_socketnt;
#else
        vol.window.base = NULL;
#endif
        return;
    }
  }
  else {
#ifdef ANTI_CRASH_WINDOW
      vol.window.base = antiCrashWindow_socketnt;
#else
      vol.window.base = NULL;
#endif
      return;
  }
  winSpeed = (UCHAR)(4 - ((vol.window.speed - 100) % 50));

  driveContext[vol.volNo].ModifyMemoryWindow(driveContext[vol.volNo].Context,
                                                   driveInfo[vol.volNo].physWindow,
                                                   ((ULONGLONG)page << 12),
                                                   FALSE,
                                                   vol.window.size,
                                                   winSpeed,
                                                   (UCHAR)((vol.window.busWidth == 16) ? PCMCIA_MEMORY_16BIT_ACCESS : PCMCIA_MEMORY_8BIT_ACCESS),
                                                   FALSE);

  if (!(driveContext[vol.volNo].ModifyMemoryWindow(driveContext[vol.volNo].Context,
                                                   driveInfo[vol.volNo].physWindow,
                                                   ((ULONGLONG)page << 12),
                                                   TRUE,
                                                   vol.window.size,
                                                   winSpeed,
                                                   (UCHAR)((vol.window.busWidth == 16) ? PCMCIA_MEMORY_16BIT_ACCESS : PCMCIA_MEMORY_8BIT_ACCESS),
                                                   FALSE))) {

#ifdef ANTI_CRASH_WINDOW
    vol.window.base = antiCrashWindow_socketnt;
#else
    vol.window.base = NULL;
#endif
  }
}


/*----------------------------------------------------------------------*/
/*       g e t A n d C l e a r C a r d C h a n g e I n d i c a t o r    */
/*                                  */
/* Returns the hardware card-change indicator and clears it if set. */
/*                                  */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive         */
/*                                                                      */
/* Returns:                                                             */
/*  0 = Card not changed, other = card changed          */
/*----------------------------------------------------------------------*/

FLBoolean getAndClearCardChangeIndicator_socketnt(FLSocket vol)
{
  return FALSE;
}


/*----------------------------------------------------------------------*/
/*                    w r i t e P r o t e c t e d           */
/*                                  */
/* Returns the write-protect state of the media             */
/*                                  */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive         */
/*                                                                      */
/* Returns:                                                             */
/*  0 = not write-protected, other = write-protected        */
/*----------------------------------------------------------------------*/

FLBoolean writeProtected_socketnt(FLSocket vol)
{
  if (driveInfo[vol.volNo].fdoExtension != NULL) {
    if (((PDEVICE_EXTENSION)driveInfo[vol.volNo].fdoExtension)->DeviceFlags & DEVICE_FLAG_REMOVED) {
          return TRUE;
    }
  }
  else
      return TRUE;

  return driveContext[vol.volNo].IsWriteProtected(driveContext[vol.volNo].Context);
}

#ifdef EXIT
/*----------------------------------------------------------------------*/
/*                    f r e e S o c k e t               */
/*                                  */
/* Free resources that were allocated for this socket.          */
/* This function is called when FLite exits.                */
/*                                  */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive         */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID freeSocket_socketnt(FLSocket vol)
{
}
#endif /* EXIT */

/*----------------------------------------------------------------------*/
/*                  f l R e g i s t e r P C I C         */
/*                                  */
/* Installs routines for the PCIC socket controller.            */
/*                                  */
/* Returns:                             */
/*  FLStatus    : 0 on success, otherwise failure       */
/*----------------------------------------------------------------------*/

FLStatus flRegisterNT5PCIC()
{
  LONG serialNo = 0;

  for (; noOfSockets < SOCKETS; noOfSockets++) {
    FLSocket vol = flSocketOf(noOfSockets);

        vol.volNo = noOfSockets;
    vol.serialNo = serialNo;
    vol.cardDetected = cardDetected_socketnt;
    vol.VccOn = VccOn_socketnt;
    vol.VccOff = VccOff_socketnt;
#ifdef SOCKET_12_VOLTS
    vol.VppOn = VppOn_socketnt;
    vol.VppOff = VppOff_socketnt;
#endif
    vol.initSocket = initSocket_socketnt;
    vol.setWindow = setWindow_socketnt;
    vol.setMappingContext = setMappingContext_socketnt;
    vol.getAndClearCardChangeIndicator = getAndClearCardChangeIndicator_socketnt;
    vol.writeProtected = writeProtected_socketnt;
#ifdef EXIT
    vol.freeSocket = freeSocket_socketnt;
#endif
    PRINTF("Debug: flRegisterNT5PCIC():Socket No %d is register.\n", noOfSockets);
  }
  if (noOfSockets == 0)
    return flAdapterNotFound;
  return flOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tools\scsi\inquire\inquire.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    getsn.c

Abstract:

    A tool for retreiving serial numbers and other identifiers from a scsi
    device

Environment:

    User mode only

Revision History:

    03-26-96 : Created

--*/


#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include <assert.h>

#include <windows.h>
#include <devioctl.h>

#include <ntddscsi.h>

#define _NTSRB_     // to keep srb.h from being included
#include <scsi.h>

#ifdef DBG
#define dbg(x) x
#define HELP_ME() printf("Reached line %4d\n", __LINE__);
#else
#define dbg(x)    /* x */
#define HELP_ME() /* printf("Reached line %4d\n", __LINE__); */
#endif

#define ARGUMENT_USED(x)    (x == NULL)

typedef struct {
    char *Name;
    char *Description;
    DWORD (*Function)(HANDLE device, int argc, char *argv[]);
} COMMAND;

typedef struct  {
    SCSI_PASS_THROUGH   Spt;
    UCHAR               SenseInfoBuffer[18];
    UCHAR               DataBuffer[0];          // Allocate buffer space
                                                // after this
} SPT_WITH_BUFFERS, *PSPT_WITH_BUFFERS;

DWORD SupportCommand(HANDLE device, int argc, char *argv[]);
DWORD InquireCommand(HANDLE device, int argc, char *argv[]);
DWORD SerialCommand(HANDLE device, int argc, char *argv[]);
DWORD IdCommand(HANDLE device, int argc, char *argv[]);

DWORD TestCommand(HANDLE device, int argc, char *argv[]);
DWORD ListCommand(HANDLE device, int argc, char *argv[]);

BOOL
SendCdbToDevice(
    IN      HANDLE  DeviceHandle,
    IN      PCDB    Cdb,
    IN      UCHAR   CdbSize,
    IN      PVOID   Buffer,
    IN OUT  PDWORD  BufferSize,
    IN      BOOLEAN DataIn
    );

VOID
PrintBuffer(
    IN  PUCHAR Buffer,
    IN  DWORD  Size
    );

//
// List of commands
// all command names are case sensitive
// arguments are passed into command routines
// list must be terminated with NULL command
// command will not be listed in help if description == NULL
//

COMMAND CommandArray[] = {
    {"help",    "help for all commands", ListCommand},
    {"id",      "gets identification descriptors", IdCommand},
    {"serial",  "gets serial numbers", SerialCommand},
    {"support", "gets list of supported VPD pages ", SupportCommand},
    {"test",    "tests the command engine", TestCommand},
    {NULL, NULL, NULL}
    };

#define STATUS_SUCCESS 0

#define LO_PTR        PtrToUlong
#define HI_PTR(_ptr_) ((DWORD)(((DWORDLONG)(ULONG_PTR)(_ptr_)) >> 32))

int __cdecl main(int argc, char *argv[])
{
    int i = 0;
    HANDLE h;
    char buffer[32];

    if(argc < 3) {
        printf("Usage: cdp <command> <drive> [parameters]\n");
        printf("possible commands: \n");
        ListCommand(NULL, argc, argv);
        printf("\n");
        return -1;
    }

    sprintf(buffer, "\\\\.\\%s", argv[2]);
    dbg(printf("Sending command %s to drive %s\n", argv[1], buffer));

    h = CreateFile(buffer,
                   GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL,
                   OPEN_EXISTING,
                   FILE_ATTRIBUTE_NORMAL,
                   NULL);

    if(h == INVALID_HANDLE_VALUE) {
        printf("Error %d opening device %s\n", GetLastError(), buffer);
        return -2;
    }

    //
    // Iterate through the command array and find the correct function to
    // call.
    //

    while(CommandArray[i].Name != NULL) {

        if(strcmp(argv[1], CommandArray[i].Name) == 0) {

            (CommandArray[i].Function)(h, (argc - 1), &(argv[1]));

            break;
        }

        i++;
    }

    if(CommandArray[i].Name == NULL) {
        printf("Unknown command %s\n", argv[2]);
    }

    CloseHandle(h);

    return 0;
}

//
// TRUE if success
// FALSE if failed
// call GetLastError() for reason
//

BOOL
SendCdbToDevice(
    IN      HANDLE  DeviceHandle,
    IN      PCDB    Cdb,
    IN      UCHAR   CdbSize,
    IN      PVOID   Buffer,
    IN OUT  PDWORD  BufferSize,
    IN      BOOLEAN DataIn
    )
{
    PSPT_WITH_BUFFERS p;
    DWORD packetSize;
    DWORD returnedBytes;
    BOOL returnValue;

    if (Cdb == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ((*BufferSize != 0) && (Buffer == NULL)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ((*BufferSize == 0) && (DataIn == 1)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    packetSize = sizeof(SPT_WITH_BUFFERS) + (*BufferSize);
    p = (PSPT_WITH_BUFFERS)malloc(packetSize);

    if (p == NULL) {

        if (DataIn && (*BufferSize)) {
            memset(Buffer, 0, (*BufferSize));
        }
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    //
    // this has the side effect of pre-zeroing the output buffer
    // if DataIn is TRUE
    //

    memset(p, 0, packetSize);
    memcpy(p->Spt.Cdb, Cdb, CdbSize);

    p->Spt.Length             = sizeof(SCSI_PASS_THROUGH);
    p->Spt.CdbLength          = CdbSize;
    p->Spt.SenseInfoLength    = 12;
    p->Spt.DataIn             = (DataIn ? 1 : 0);
    p->Spt.DataTransferLength = (*BufferSize);
    p->Spt.TimeOutValue       = 20;
    p->Spt.SenseInfoOffset =
        FIELD_OFFSET(SPT_WITH_BUFFERS, SenseInfoBuffer[0]);
    p->Spt.DataBufferOffset =
        FIELD_OFFSET(SPT_WITH_BUFFERS, DataBuffer[0]);

    //
    // If this is a data-out command copy from the caller's buffer into the
    // one in the SPT block.
    //

    if(!DataIn) {
        memcpy(p->DataBuffer, Buffer, *BufferSize);
    }

    //
    //
    //
    printf("Sending command using new method\n");


    returnedBytes = *BufferSize;
    returnValue = DeviceIoControl(DeviceHandle,
                                  IOCTL_SCSI_PASS_THROUGH,
                                  p,
                                  packetSize,
                                  p,
                                  packetSize,
                                  &returnedBytes,
                                  FALSE);

    //
    // if successful, need to copy the buffer to caller's buffer
    //

    if(returnValue && DataIn) {
        ULONG t = min(returnedBytes, *BufferSize);
        *BufferSize = returnedBytes;
        memcpy(Buffer, p->DataBuffer, t);
    }

    if(p->Spt.ScsiStatus != SCSISTAT_GOOD) {
        printf("ScsiStatus: %x\n", p->Spt.ScsiStatus);

        if(p->Spt.ScsiStatus == SCSISTAT_CHECK_CONDITION) {
            printf("SenseData: \n");
            PrintBuffer(p->SenseInfoBuffer, sizeof(p->SenseInfoBuffer));
        }
    }

    free(p);
    return returnValue;
}

VOID
PrintBuffer(
    IN  PUCHAR Buffer,
    IN  DWORD  Size
    )
{
    UCHAR s[17];
    UCHAR i;
    DWORD offset = 0;

    s[0x10] = 0;

    while (Size > 0x10) {

        printf("%08x:", offset);

        for(i = 0; i < 0x10; i++) {
            printf(" %02x", Buffer[i]);
            if(i == 7) printf(" -");

            if(isprint(Buffer[i])) {
                s[i] = Buffer[i];
            } else {
                s[i] = '.';
            }
        }

        printf(" : %s\n", s);

        Size -= 0x10;
        offset += 0x10;
        Buffer += 0x10;
    }

    if (Size != 0) {

        DWORD spaceIt;

        memset(s, 0, sizeof(s));

        printf("%08x:", offset);
        for (spaceIt = 0; Size != 0; Size--) {

            if ((spaceIt) && ((spaceIt%8)==0)) {
                printf(" -"); // extra space every eight chars
            }
            printf(" %02x", *Buffer);

            if(isprint(*Buffer)) {
                s[spaceIt] = *Buffer;
            } else {
                s[spaceIt] = '.';
            }
            spaceIt++;
            Buffer++;
        }
        for(i = 0; i < 16 - spaceIt; i++) {
            printf("   ");
        }
        if(spaceIt < 8) {
            printf("  ");
        }
        printf(" : %s\n", s);

    }
    return;


}

DWORD TestCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Tests the command "parsing"

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  should be zero

    argv - the additional arguments

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/

{
    int i;
    printf("Test - %d additional arguments\n", argc);

    printf("got handle %#08lp\n", device);

    for(i = 0; i < argc; i++) {
        printf("arg %d: %s\n", i, argv[i]);
    }

    return STATUS_SUCCESS;
}

DWORD ListCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Prints out the command list

Arguments:
    device - unused

    argc - unused

    argv - unused

Return Value:

    STATUS_SUCCESS

--*/

{
    int i = 0;

    while(CommandArray[i].Name != NULL) {

        if(CommandArray[i].Description != NULL) {

            printf("\t%s - %s\n",
                   CommandArray[i].Name,
                   CommandArray[i].Description);
        }

        i++;
    }

    return STATUS_SUCCESS;
}

DWORD SupportCommand(HANDLE device, int argc, char *argv[])
{
    CDB cdb;
    USHORT allocationLength;
    ULONG returnedBytes;

    UCHAR b[255];
    PVPD_SUPPORTED_PAGES_PAGE page = (PVPD_SUPPORTED_PAGES_PAGE) &(b);

    UCHAR i;

    BOOL ok;

    memset(&cdb, 0, sizeof(CDB));

    cdb.CDB6INQUIRY3.OperationCode = SCSIOP_INQUIRY;
    cdb.CDB6INQUIRY3.EnableVitalProductData = 1;
    cdb.CDB6INQUIRY3.PageCode = VPD_SUPPORTED_PAGES;
    cdb.CDB6INQUIRY3.AllocationLength = 255;

    returnedBytes = 255;

    ok = SendCdbToDevice(device,
                         &cdb,
                         sizeof(cdb.CDB6INQUIRY3),
                         page,
                         &returnedBytes,
                         TRUE);

    if(!ok) return GetLastError();

    printf("%x bytes returned.\n", returnedBytes);
    printf("additional length is %x\n", page->PageLength);

    printf("deviceType (%x,%x)   ",
           page->DeviceType,
           page->DeviceTypeQualifier);

    printf("pageCode: %x\n", page->PageCode);

    printf("Pages Supported: %x", page->SupportedPageList[0]);
    for(i = 1; i < page->PageLength; i++) {
        printf(", %x", page->SupportedPageList[i]);
    }

    return 0;
}

DWORD SerialCommand(HANDLE device, int argc, char *argv[])
{
    CDB cdb;
    USHORT allocationLength;
    ULONG returnedBytes;

    UCHAR b[256];
    PVPD_SERIAL_NUMBER_PAGE page = (PVPD_SERIAL_NUMBER_PAGE) &(b);

    UCHAR i;

    BOOL ok;

    memset(&cdb, 0, sizeof(CDB));

    cdb.CDB6INQUIRY3.OperationCode = SCSIOP_INQUIRY;
    cdb.CDB6INQUIRY3.EnableVitalProductData = 1;
    cdb.CDB6INQUIRY3.PageCode = VPD_SERIAL_NUMBER;
    cdb.CDB6INQUIRY3.AllocationLength = 255;

    returnedBytes = 255;

    ok = SendCdbToDevice(device,
                         &cdb,
                         sizeof(cdb.CDB6INQUIRY3),
                         page,
                         &returnedBytes,
                         TRUE);

    if(!ok) return GetLastError();

    printf("%x bytes returned.\n", returnedBytes);
    printf("additional length is %x\n", page->PageLength);

    printf("deviceType (%x,%x)   ",
           page->DeviceType,
           page->DeviceTypeQualifier);

    printf("pageCode: %x\n", page->PageCode);

    printf("serialNumber: %s\n", page->SerialNumber);

    printf("raw:\n");
    PrintBuffer(page->SerialNumber, page->PageLength);
    return 0;
}

DWORD IdCommand(HANDLE device, int argc, char *argv[])
{
    CDB cdb;
    USHORT allocationLength;
    ULONG returnedBytes;

    UCHAR b[256];
    PVPD_IDENTIFICATION_PAGE page = (PVPD_IDENTIFICATION_PAGE) &(b);
    PVPD_IDENTIFICATION_DESCRIPTOR descriptor;

    UCHAR i;
    UCHAR j;

    BOOL ok;

    memset(&cdb, 0, sizeof(CDB));

    cdb.CDB6INQUIRY3.OperationCode = SCSIOP_INQUIRY;
    cdb.CDB6INQUIRY3.EnableVitalProductData = 1;
    cdb.CDB6INQUIRY3.PageCode = VPD_DEVICE_IDENTIFIERS;
    cdb.CDB6INQUIRY3.AllocationLength = 255;

    returnedBytes = 255;

    ok = SendCdbToDevice(device,
                         &cdb,
                         sizeof(cdb.CDB6INQUIRY3),
                         page,
                         &returnedBytes,
                         TRUE);

    if(!ok) return GetLastError();

    printf("%x bytes returned.\n", returnedBytes);
    printf("additional length is %x\n", page->PageLength);

    printf("deviceType (%x,%x)   ",
           page->DeviceType,
           page->DeviceTypeQualifier);

    printf("pageCode: %x\n", page->PageCode);

    for(i = 0, j = 0; i < page->PageLength; j++) {
        descriptor = (PVPD_IDENTIFICATION_DESCRIPTOR) &(page->Descriptors[i]);

        printf("%d: Descriptor %d: ", i, j);

        switch(descriptor->CodeSet) {
            case VpdCodeSetReserved:
                printf("Reserved ");
                break;
            case VpdCodeSetAscii:
                printf("ASCII ");
                break;
            case VpdCodeSetBinary:
                printf("Binary ");
                break;
            default:
                printf("CodeSet%d ", descriptor->CodeSet);
                break;
        }

        switch(descriptor->IdentifierType) {
            case VpdIdentifierTypeVendorSpecific:
                printf("VendorSpecific ");
                break;
            case VpdIdentifierTypeVendorId:
                printf("VendorId+ ");
                break;
            case VpdIdentifierTypeEUI64:
                printf("IEEE_UID ");
                break;
            case VpdIdentifierTypeFCPHName:
                printf("FC-PC_Name ");
                break;
            default:
                printf("IdType%d ", descriptor->IdentifierType);
                break;
        }

        printf("%d bytes\n", descriptor->IdentifierLength);
        PrintBuffer(descriptor->Identifier, descriptor->IdentifierLength);

        printf("\n");

        i += descriptor->IdentifierLength;
        i += FIELD_OFFSET(VPD_IDENTIFICATION_DESCRIPTOR, IdentifierLength);
        i += 1;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tffsport\tffsport.c ===
/*

Copyright (c) 1997 M-Systems

Module Name:

    tffsport.c

Author:

    Alexander Geller

Environment:

    Kernel mode

--*/

#include "ntddk.h"
#include "scsi.h"
#include "ntdddisk.h"
#include "ntddscsi.h"
#include "string.h"
#include "stdio.h"
#include "stdarg.h"
#include "ntddstor.h"
#include "initguid.h"
#include "ntddscsi.h"

#include "blockdev.h"
#include "nfdc2148.h"
//#include "mdocplus.h"
#include "tffsport.h"
#include "ntioctl.h"

#define TFFSPORT_POOL_TAG   'dffT' // - Tffd    Tffsport Driver Tag

KTIMER  timerObject;
KDPC    timerDpc;
BOOLEAN timerWasStarted = FALSE;
BOOLEAN patitionTwo = FALSE;




/* Private GUID for WMI */
DEFINE_GUID(WmiTffsportAddressGuid,
    0xd9a8f150,
    0xf830,
    0x11d2,
    0xb5, 0x72, 0x00, 0xc0, 0x4f, 0x65, 0xb3, 0xd9
);

TempINFO info[VOLUMES];

ULONG TrueffsNextDeviceNumber_tffsport = 0;
CRASHDUMP_DATA DumpData;
extern NTsocketParams driveInfo[SOCKETS];
ULONG VerifyWriteState[SOCKETS];
FAST_MUTEX driveInfoReferenceMutex;

const TFFS_DEVICE_TYPE TffsDeviceType_tffsport[] = {
    {"Disk",    "GenDisk",    "DiskPeripheral"}
};

const TFFS_DEVICE_TYPE TffsDeviceTypeFDO_tffsport[] = {
    {"Controller",    "FlashDiskController",    "FlashDiskPeripheral"}
};


BOOLEAN
DebugLogEvent(IN PDRIVER_OBJECT DriverObject, IN ULONG Value);


NTSTATUS
TrueffsStartDeviceOnDetect(IN PDEVICE_EXTENSION deviceExtension, IN PCM_RESOURCE_LIST ResourceList, IN BOOLEAN CheckResources);


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, TrueffsThread)
#endif


NTSTATUS
DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)

/*++

Routine Description:

    This routine is called at system initialization time so we can fill in the basic dispatch points

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    STATUS_SUCCESS

--*/

{
    PTRUEFFSDRIVER_EXTENSION trueffsDriverExtension;
    NTSTATUS status;
    ULONG i;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DriverEntry\n"));
    DebugLogEvent(DriverObject, 1);
    DebugLogEvent(DriverObject, 2);
    DebugLogEvent(DriverObject, 3);

    for (i = 0; i < SOCKETS; i++) {
        driveInfo[i].interfAlive = 0;
        driveInfo[i].fdoExtension = NULL;
    }

    for (i = 0; i < VOLUMES; i++) {
        info[i].baseAddress= 0;
        info[i].nextPartition= 0;
    }

    ExInitializeFastMutex(&driveInfoReferenceMutex);

    if (!DriverObject) {

        return TrueffsCrashDumpDriverEntry(RegistryPath);
    }

    // Allocate Driver Object Extension for storing the RegistryPath
    status = IoAllocateDriverObjectExtension(
                 DriverObject,
                 DRIVER_OBJECT_EXTENSION_ID,
                 sizeof (DRIVER_EXTENSION),
                 &trueffsDriverExtension
                 );

    if (!NT_SUCCESS(status)) {

        TffsDebugPrint ((TFFS_DEB_ERROR,"Trueffs: DriverEntry: Unable to create driver extension\n"));
        return status;
    }

    RtlZeroMemory (
        trueffsDriverExtension,
        sizeof (DRIVER_EXTENSION)
        );

    // make copy of the RegistryPath
    trueffsDriverExtension->RegistryPath.Buffer = ExAllocatePoolWithTag (NonPagedPool, RegistryPath->Length * sizeof(WCHAR), TFFSPORT_POOL_TAG);
    if (trueffsDriverExtension->RegistryPath.Buffer == NULL) {
        TffsDebugPrint ((TFFS_DEB_ERROR,"Trueffs: DriverEntry: Unable to allocate memory for registry path\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    trueffsDriverExtension->RegistryPath.Length = 0;
    trueffsDriverExtension->RegistryPath.MaximumLength = RegistryPath->Length;
    RtlCopyUnicodeString (&trueffsDriverExtension->RegistryPath, RegistryPath);

    // Initialize the Driver Object with driver's entry points
    DriverObject->MajorFunction[IRP_MJ_CREATE] = TrueffsCreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = TrueffsCreateClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = TrueffsDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_SCSI] = TrueffsScsiRequests;

    DriverObject->DriverExtension->AddDevice = TrueffsAddDevice;
    DriverObject->MajorFunction[IRP_MJ_PNP] = TrueffsPnpDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_POWER] = TrueffsPowerControl;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = TrueffsDispatchSystemControl;

    DriverObject->DriverStartIo = TrueffsStartIo;
    DriverObject->DriverUnload = TrueffsUnload;

    TrueffsWmiInit();
    TrueffsDetectDiskOnChip(DriverObject, RegistryPath);

    return STATUS_SUCCESS;
}

NTSTATUS
TrueffsFetchKeyValue(
    IN PDRIVER_OBJECT       DriverObject,
    IN PUNICODE_STRING  RegistryPath,
        IN PWSTR                        KeyName,
        IN OUT ULONG*               KeyValue
)
    {
    RTL_QUERY_REGISTRY_TABLE    Table[3]; //must be parmaters + 2
    UNICODE_STRING                      SubPath;
    WCHAR                                           PathNameBuffer[30];
    NTSTATUS                                    ntStatus;

    //TffsDebugPrint(("Trueffs: TrueffsFetchKeyValue Start\n"));

    // Prepare Table - Must be Zero Terminated
    RtlZeroMemory(Table, sizeof(Table));

    // Create name string for the query Table
    SubPath.Buffer = PathNameBuffer;
    SubPath.MaximumLength = sizeof(PathNameBuffer);
    SubPath.Length = 0;

    RtlAppendUnicodeToString(&SubPath,L"Parameters");

    // 0 - just move us to the correct place under "Parameters" subkey
    Table[0].Name       = SubPath.Buffer;
    Table[0].Flags  = RTL_QUERY_REGISTRY_SUBKEY;

    Table[1].Name                   = KeyName;
    Table[1].Flags              = RTL_QUERY_REGISTRY_DIRECT;
    Table[1].EntryContext = KeyValue;

    *KeyValue = -1;

    ntStatus = RtlQueryRegistryValues(
                                    RTL_REGISTRY_ABSOLUTE,
                                    RegistryPath->Buffer,
                                    Table,
                                    NULL,NULL);

    if ( ((*KeyValue)==-1) || (!NT_SUCCESS(ntStatus)) )
        {
        //TffsDebugPrint(("Trueffs: TrueffsFetchKeyValue End, Key Not Found\n"));
        return STATUS_OBJECT_NAME_NOT_FOUND;
        }
    else
        {
        //TffsDebugPrint(("Trueffs: TrueffsFetchKeyValue End, Key Found\n"));
        return ntStatus;
        }

    }

NTSTATUS
TrueffsDetectRegistryValues(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
)
    {
        RTL_QUERY_REGISTRY_TABLE    Table[14]; //must be parmaters + 2


        NTSTATUS                                    ntStatus;
        ULONG                                           prevValue;
        ULONG                                           keyValue;
        FLStatus                    status = flOK;
        ULONG                                           CurrVerifyWriteState;
        ULONG                                           currSocket = 0;



        //TffsDebugPrint(("Trueffs: TrueffsDetectRegistryValues Start\n"));
#ifdef ENVIRONMENT_VARS
        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_ISRAM_CHECK_ENABLED",&keyValue);
        if (NT_SUCCESS(ntStatus))
            status = flSetEnvAll(FL_IS_RAM_CHECK_ENABLED,keyValue,&prevValue);

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_TL_CACHE_ENABLED",&keyValue);
        if (NT_SUCCESS(ntStatus))
            status = flSetEnvAll(FL_TL_CACHE_ENABLED,keyValue,&prevValue);

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_DOC_8BIT_ACCESS",&keyValue);
        if (NT_SUCCESS(ntStatus))
            status = flSetEnvAll(FL_DOC_8BIT_ACCESS,keyValue,&prevValue);

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_SUSPEND_MODE",&keyValue);
        if (NT_SUCCESS(ntStatus))
            status = flSetEnvAll(FL_SUSPEND_MODE,keyValue,&prevValue);

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_MTD_BUS_ACCESS_TYPE",&keyValue);
        if (NT_SUCCESS(ntStatus))
            status = flSetEnvAll(FL_MTD_BUS_ACCESS_TYPE,keyValue,&prevValue);

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_SET_POLICY",&keyValue);
        if (NT_SUCCESS(ntStatus))
            status = flSetEnvAll(FL_SET_POLICY,keyValue,&prevValue);



        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_VERIFY_WRITE_BDTL0",&CurrVerifyWriteState);
        if (NT_SUCCESS(ntStatus) && currSocket++<SOCKETS)
                VerifyWriteState[0] = CurrVerifyWriteState;

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_VERIFY_WRITE_BDTL1",&CurrVerifyWriteState);
        if (NT_SUCCESS(ntStatus)&& currSocket++<SOCKETS)
                VerifyWriteState[1] = CurrVerifyWriteState;

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_VERIFY_WRITE_BDTL2",&CurrVerifyWriteState);
        if (NT_SUCCESS(ntStatus)&& currSocket++<SOCKETS)
                VerifyWriteState[2] = CurrVerifyWriteState;

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_VERIFY_WRITE_BDTL3",&CurrVerifyWriteState);
        if (NT_SUCCESS(ntStatus)&& currSocket++<SOCKETS)
                VerifyWriteState[3] = CurrVerifyWriteState;

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_VERIFY_WRITE_BDTL4",&CurrVerifyWriteState);
        if (NT_SUCCESS(ntStatus)&& currSocket++<SOCKETS)
                VerifyWriteState[4] = CurrVerifyWriteState;

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_VERIFY_WRITE_BDTL5",&CurrVerifyWriteState);
        if (NT_SUCCESS(ntStatus)&& currSocket++<SOCKETS)
                VerifyWriteState[5] = CurrVerifyWriteState;

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_VERIFY_WRITE_BDTL6",&CurrVerifyWriteState);
        if (NT_SUCCESS(ntStatus)&& currSocket++<SOCKETS)
                VerifyWriteState[6] = CurrVerifyWriteState;

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_VERIFY_WRITE_BDTL7",&CurrVerifyWriteState);
        if (NT_SUCCESS(ntStatus)&& currSocket++<SOCKETS)
                VerifyWriteState[7] = CurrVerifyWriteState;

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_SECTORS_VERIFIED_PER_FOLDING",&keyValue);
        if (NT_SUCCESS(ntStatus))
            status = flSetEnvAll(FL_SECTORS_VERIFIED_PER_FOLDING,keyValue,&prevValue);

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_VERIFY_WRITE_BINARY",&keyValue);
        if (NT_SUCCESS(ntStatus))
            status = flSetEnvAll(FL_VERIFY_WRITE_BINARY,keyValue,&prevValue);

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_VERIFY_WRITE_OTHER",&keyValue);
        if (NT_SUCCESS(ntStatus))
            status = flSetEnvAll(FL_VERIFY_WRITE_OTHER,keyValue,&prevValue);

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_SET_MAX_CHAIN",&keyValue);
        if (NT_SUCCESS(ntStatus))
            status = flSetEnvAll(FL_SET_MAX_CHAIN,keyValue,&prevValue);

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_MARK_DELETE_ON_FLASH",&keyValue);
        if (NT_SUCCESS(ntStatus))
            status = flSetEnvAll(FL_MARK_DELETE_ON_FLASH,keyValue,&prevValue);

        return ntStatus;
#endif /* ENVIRONMENT_VARS*/
        //TffsDebugPrint(("Trueffs: TrueffsDetectRegistryValues End\n"));


        return STATUS_SUCCESS;
    }

ULONG
TrueffsCrashDumpDriverEntry (
    PVOID Context
    )
/*++

Routine Description:

    dump driver entry point

Arguments:

    Context - PCRASHDUMP_INIT_DATA

Return Value:

    NT Status

--*/
{
    PINITIALIZATION_CONTEXT context = Context;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: CrashDumpDriverEntry\n"));

    DumpData.CrashInitData = (PCRASHDUMP_INIT_DATA) context->PortConfiguration;
    DumpData.StallRoutine  = context->StallRoutine;

    context->OpenRoutine    = TrueffsCrashDumpOpen;
    context->WriteRoutine   = TrueffsCrashDumpWrite;
    context->FinishRoutine  = TrueffsCrashDumpFinish;

    return STATUS_SUCCESS;
}


BOOLEAN
TrueffsCrashDumpOpen (
    IN LARGE_INTEGER PartitionOffset
    )
{
    TffsDebugPrint((TFFS_DEB_INFO, "Trueffs: CrashDumpOpen: PartitionOffset = 0x%x%08x...\n", PartitionOffset.HighPart, PartitionOffset.LowPart));
    DumpData.PartitionOffset = PartitionOffset;
    RtlMoveMemory (&DumpData.fdoExtension,DumpData.CrashInitData->cdFdoExtension,sizeof (DEVICE_EXTENSION));
    DumpData.MaxBlockSize = DumpData.fdoExtension.BytesPerSector * 256;
    return TRUE;
}


NTSTATUS
TrueffsCrashDumpWrite (
    IN PLARGE_INTEGER DiskByteOffset,
    IN PMDL Mdl
    )
{
    NTSTATUS    status;
    ULONG       blockSize;
    ULONG       bytesWritten = 0;
    ULONG       startingSector;
    FLStatus    tffsStatus;
    IOreq       ioreq;

    TffsDebugPrint((TFFS_DEB_INFO,
               "TrueffsCrashDumpWrite: Write memory at 0x%x for 0x%x bytes\n",
                Mdl->MappedSystemVa,
                Mdl->ByteCount));

    if (Mdl->ByteCount % DumpData.fdoExtension.BytesPerSector) {
        // must be complete sectors
        TffsDebugPrint((TFFS_DEB_ERROR, "TrueffsCrashDumpWrite ERROR: not writing full sectors\n"));
        return STATUS_INVALID_PARAMETER;
    }
    if ((Mdl->ByteCount / DumpData.fdoExtension.BytesPerSector) > 256) {
        // need code to split request up
        TffsDebugPrint((TFFS_DEB_ERROR, "TrueffsCrashDumpWrite ERROR: can't handle large write\n"));
        return STATUS_INVALID_PARAMETER;
    }
    do {
        if ((Mdl->ByteCount - bytesWritten) > DumpData.MaxBlockSize) {
            blockSize = DumpData.MaxBlockSize;
            TffsDebugPrint((TFFS_DEB_INFO, "Trueffs: TrueffsCrashDumpWrite: can't do a single write\n"));

        } else {
            blockSize = Mdl->ByteCount - bytesWritten;
        }
        status = STATUS_UNSUCCESSFUL;
        startingSector = (ULONG)((DumpData.PartitionOffset.QuadPart +
                        (*DiskByteOffset).QuadPart +
                        (ULONGLONG) bytesWritten) / DumpData.fdoExtension.BytesPerSector);

        ioreq.irHandle = DumpData.fdoExtension.UnitNumber;
        ioreq.irSectorNo = startingSector;
        ioreq.irSectorCount = blockSize / DumpData.fdoExtension.BytesPerSector;
        ioreq.irData = ((PUCHAR) Mdl->MappedSystemVa) + bytesWritten;
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: CrashDumpWrite: Starting sector is %x, Number of bytes %x\n",
                            startingSector,
                            blockSize));
        tffsStatus = flAbsWrite(&ioreq);
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: CrashDumpWrite: Write status %Xh\n", tffsStatus));

        if (tffsStatus == flOK) {
            status = STATUS_SUCCESS;
            bytesWritten += blockSize;
        }
    } while (bytesWritten < Mdl->ByteCount);
    return status;
}


VOID
TrueffsCrashDumpFinish (
    VOID
    )
{
    TffsDebugPrint((TFFS_DEB_INFO, "Trueffs: TrueffsCrashDumpFinish\n"));
    return;
}


NTSTATUS
TrueffsDispatchSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for IRP_MJ_SYSTEM_CONTROL (WMI) IRPs

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION thisIrpSp;
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension;
    PPDO_EXTENSION pdoExtension;
    PDEVICE_EXTENSION_HEADER devExtension;

    thisIrpSp = IoGetCurrentIrpStackLocation(Irp);
    devExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;
    if (IS_FDO(devExtension)) {

        TffsDebugPrint((TFFS_DEB_WARN,"Trueffs: DispatchSystemControl: WMI IRP (FDO) %Xh not handled. Passing it down.\n",thisIrpSp->MinorFunction));
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(devExtension->LowerDeviceObject, Irp);
    }
    else {

        if (thisIrpSp->MinorFunction < NUM_WMI_MINOR_FUNCTION) {

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DispatchSystemControl (WMI) %Xh PDO\n",thisIrpSp->MinorFunction));
            status = TrueffsWmiSystemControl(DeviceObject, Irp);
        } else {

            TffsDebugPrint((TFFS_DEB_WARN,"Trueffs: DispatchSystemControl (WMI) %Xh PDO unsupported\n",thisIrpSp->MinorFunction));
            status = Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
    }
    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DispatchSystemControl status %Xh\n", status));
    return status;
}


NTSTATUS
TrueffsFindDiskOnChip(
    IN INTERFACE_TYPE   InterfaceType,
    IN ULONG            BusNumber,
    IN ULONG            StartSearchAddress,
    IN LONG             WindowSize,
    IN BOOLEAN          StartSearch,
    OUT PVOID           *WindowBase
    )

{
    ULONG                           DOCAddressSpace = TFFS_MEMORY_SPACE;
    PVOID                           DOCAddressBase = NULL;
    PHYSICAL_ADDRESS                DOCAddressMemoryBase;
    NTSTATUS                        status;
    ULONG                           winBase;
    volatile UCHAR                  chipId;
    volatile UCHAR                  toggle1;
    volatile UCHAR                  toggle2;
    volatile UCHAR                  deviceSearch;

    DOC2window                      *memDOC2000WinPtr = NULL;
        MDOCPwindow                                         *memWinPtr = NULL;

    status = TrueffsTranslateAddress(InterfaceType,
                          BusNumber,
                          RtlConvertLongToLargeInteger(StartSearchAddress),
                          WindowSize,
                          &DOCAddressSpace,
                          &DOCAddressBase,
                              &DOCAddressMemoryBase);

    if (!NT_SUCCESS(status)) {
       if (status == STATUS_NOT_IMPLEMENTED) {
           status = STATUS_UNSUCCESSFUL;
       }

             TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c :TrueffsFindDiskOnChip():Failed to alloc memory\n"));
       return status;
    }

        /* DOC2000*/
    memDOC2000WinPtr = (DOC2window *) DOCAddressBase;

    tffsWriteByte(memDOC2000WinPtr->DOCcontrol, ASIC_NORMAL_MODE);
    tffsWriteByte(memDOC2000WinPtr->DOCcontrol, ASIC_NORMAL_MODE);

    chipId = tffsReadByte(memDOC2000WinPtr->chipId);

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c :TrueffsFindDiskOnChip():After read DOC2000 chipID\n"));
        if ((chipId == CHIP_ID_DOC) || (chipId == CHIP_ID_MDOC)) {
            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c :TrueffsFindDiskOnChip():In chip ID  DOC2000 or MDOC\n"));
      if (chipId == CHIP_ID_MDOC) {
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c :TrueffsFindDiskOnChip():In the MDOC\n"));
          toggle1 = tffsReadByte(memDOC2000WinPtr->ECCconfig);
          toggle2 = toggle1 ^ tffsReadByte(memDOC2000WinPtr->ECCconfig);
      }
      else {
                  TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c :TrueffsFindDiskOnChip():In the DOC2000\n"));
          toggle1 = tffsReadByte(memDOC2000WinPtr->ECCstatus);
          toggle2 = toggle1 ^ tffsReadByte(memDOC2000WinPtr->ECCstatus);
      }

      if (!StartSearch) {
         if ((toggle2 & TOGGLE) != 0) {
             if (chipId == CHIP_ID_MDOC) {
                 tffsWriteByte(memDOC2000WinPtr->aliasResolution, ALIAS_RESOLUTION);
             }
             else {
                                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c :TrueffsFindDiskOnChip():Failed  Toggle\n"));
                 tffsWriteByte(memDOC2000WinPtr->deviceSelector, ALIAS_RESOLUTION);
             }
             *WindowBase = DOCAddressBase;
             TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DiskOnChip detected on %Xh\n",StartSearchAddress));
             return STATUS_SUCCESS;
         }
      }
      else {
         deviceSearch = ( chipId == CHIP_ID_MDOC ) ? tffsReadByte(memDOC2000WinPtr->aliasResolution) :
                                                     tffsReadByte(memDOC2000WinPtr->deviceSelector);
         if (((toggle2 & TOGGLE) != 0) && (deviceSearch == ALIAS_RESOLUTION)) {
                     TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c :TrueffsFindDiskOnChip():Free Window pointer\n"));
              TrueffsFreeTranslatedAddress(
                   DOCAddressBase,
                   WindowSize,
                   DOCAddressSpace
                   );

              TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Alias detected on %Xh\n",StartSearchAddress));
              return STATUS_NOT_IMPLEMENTED;
         }
      }
    }

        //Start MDOCP code
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c :TrueffsFindDiskOnChip():Start looking for MDOCP\n"));
        memWinPtr = (MDOCPwindow *) DOCAddressBase;

        memWinPtr->DOCcontrol       =  (unsigned char)0x05; /* Set RESET Mode */
        memWinPtr->DocCntConfirmReg = (unsigned char)0xfa;

        chipId = memWinPtr->chipId;


        if (chipId == 0x40)
        {
                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c :TrueffsFindDiskOnChip():Identify as MDOCP\n"));
                toggle1 = tffsReadByte(memWinPtr->EccCntReg);
        toggle2 = toggle1 ^ tffsReadByte(memWinPtr->EccCntReg);

        if (!StartSearch)
        {
            //if ((toggle2 & ECC_CNTRL_TOGGLE_MASK) != 0)
            if ((toggle2 & 0x4) != 0)
            {
                tffsWriteByte(memWinPtr->AliasResolution, ALIAS_RESOLUTION);
                *WindowBase = DOCAddressBase;
                 TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: MDOCP detected on %Xh\n",StartSearchAddress));
                return STATUS_SUCCESS;
            }
            else
            {

                deviceSearch = tffsReadByte(memWinPtr->AliasResolution);
                //if (((toggle2 & ECC_CNTRL_TOGGLE_MASK) != 0) && (deviceSearch == ALIAS_RESOLUTION))
                if (((toggle2 & 0x4) != 0) && (deviceSearch == ALIAS_RESOLUTION))

                {
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c :TrueffsFindDiskOnChip():MDOCP Failed togfle  - Free memory\n"));
                    TrueffsFreeTranslatedAddress(
                        DOCAddressBase,
                        WindowSize,
                        DOCAddressSpace
                        );
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Alias detected on %Xh\n",StartSearchAddress));
                    return STATUS_NOT_IMPLEMENTED;
                }

            }
        }
    }





    TrueffsFreeTranslatedAddress(
                DOCAddressBase,
                WindowSize,
                DOCAddressSpace
                );

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DiskOnChip not detected on %Xh\n", StartSearchAddress));
    return STATUS_UNSUCCESSFUL;
}


NTSTATUS
TrueffsCheckDiskOnChip(
    IN INTERFACE_TYPE   InterfaceType,
    IN ULONG            BusNumber,
    IN ULONG            StartSearchAddress,
    IN LONG             WindowSize,
    OUT PVOID           *WindowBase,
    OUT PULONG          AddressSpace
    )

{
    ULONG                           DOCAddressSpace = TFFS_MEMORY_SPACE;
    PVOID                           DOCAddressBase = NULL;
    PHYSICAL_ADDRESS                DOCAddressMemoryBase;
    NTSTATUS                        status;
    volatile UCHAR                  chipId;
    volatile UCHAR                  toggle1;
    volatile UCHAR                  toggle2;

    DOC2window                      *memDOC2000WinPtr;
        MDOCPwindow                     *memWinPtr;


        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c: TrueffsCheckDiskOnChip() Started ...\n"));
    status = TrueffsTranslateAddress(InterfaceType,
                      BusNumber,
                      RtlConvertLongToLargeInteger(StartSearchAddress),
                      WindowSize,
                      &DOCAddressSpace,
                      &DOCAddressBase,
                      &DOCAddressMemoryBase);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    memDOC2000WinPtr = (DOC2window *) DOCAddressBase;

    tffsWriteByte(memDOC2000WinPtr->DOCcontrol, 0x84);
    tffsWriteByte(memDOC2000WinPtr->DOCcontrol, 0x84);
    tffsWriteByte(memDOC2000WinPtr->DOCcontrol, 0x85);
    tffsWriteByte(memDOC2000WinPtr->DOCcontrol, 0x85);

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c: TrueffsCheckDiskOnChip() DOC2000 read chip ID\n"));
    chipId = tffsReadByte(memDOC2000WinPtr->chipId);
        if ((chipId == CHIP_ID_DOC) || (chipId == CHIP_ID_MDOC)) {
            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c: TrueffsCheckDiskOnChip() DOC2000 chipID = 0x%x\n", chipId));
        if (chipId == CHIP_ID_MDOC) {
            toggle1 = tffsReadByte(memDOC2000WinPtr->ECCconfig);
            toggle2 = toggle1 ^ tffsReadByte(memDOC2000WinPtr->ECCconfig);
        }
        else {
            toggle1 = tffsReadByte(memDOC2000WinPtr->ECCstatus);
            toggle2 = toggle1 ^ tffsReadByte(memDOC2000WinPtr->ECCstatus);
        }
        if ((toggle2 & TOGGLE) != 0) {
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c: TrueffsCheckDiskOnChip() DOC2000 Finished toggle successfuly\n"));
            *WindowBase = DOCAddressBase;
            *AddressSpace = DOCAddressSpace;
            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DiskOnChip2000 found on %Xh\n",StartSearchAddress));
            return STATUS_SUCCESS;
        }
    }


        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c: TrueffsCheckDiskOnChip() MDOCPLUS Start....\n"));
        memWinPtr = (MDOCPwindow *) DOCAddressBase;
        tffsWriteByte(memWinPtr->DOCcontrol, (unsigned char)0x04);
    tffsWriteByte(memWinPtr->DocCntConfirmReg, (unsigned char)0xfb);
    tffsWriteByte(memWinPtr->DOCcontrol, (unsigned char)0x05);
    tffsWriteByte(memWinPtr->DocCntConfirmReg, (unsigned char)0xfa);
        chipId = tffsReadByte(memWinPtr->chipId);

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c: TrueffsCheckDiskOnChip() MDOCPLUS chipID = 0x%x\n", chipId));

        //if (chipId == CHIP_ID_MDOCP)
        if (chipId == 0x40)
        {
                toggle1 = tffsReadByte(memWinPtr->EccCntReg);
        toggle2 = toggle1 ^ tffsReadByte(memWinPtr->EccCntReg);

                //if ((toggle2 & ECC_CNTRL_TOGGLE_MASK) != 0)
                if ((toggle2 & 0x4) != 0)
                {
                    *WindowBase = DOCAddressBase;
                    *AddressSpace = DOCAddressSpace;
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: MDOCPLUS found on %Xh\n",StartSearchAddress));
                    return STATUS_SUCCESS;
                }
        }


    TrueffsFreeTranslatedAddress(
            DOCAddressBase,
            WindowSize,
            DOCAddressSpace
            );
    return STATUS_UNSUCCESSFUL;
}


VOID
TrueffsResetDiskOnChip(
    IN INTERFACE_TYPE   InterfaceType,
    IN ULONG            BusNumber,
    IN ULONG            StartSearchAddress,
    IN LONG             WindowSize
    )

{
    ULONG                           DOCAddressSpace = TFFS_MEMORY_SPACE;
    PVOID                           DOCAddressBase = NULL;
    PHYSICAL_ADDRESS                DOCAddressMemoryBase;
    NTSTATUS                        status;

    DOC2window                      *memDOC2000WinPtr;

        MDOCPwindow                     *memWinPtr;


        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c:TrueffsResetDiskOnChip()b start\n"));
    status = TrueffsTranslateAddress(InterfaceType,
                          BusNumber,
                          RtlConvertLongToLargeInteger(StartSearchAddress),
                          WindowSize,
                          &DOCAddressSpace,
                          &DOCAddressBase,
                          &DOCAddressMemoryBase);

    if (!NT_SUCCESS(status)) {
        return;
    }
        /* DOC2000 CHANGES*/
    memDOC2000WinPtr = (DOC2window *) DOCAddressBase;
    tffsWriteByte(memDOC2000WinPtr->DOCcontrol, 0x84);
    tffsWriteByte(memDOC2000WinPtr->DOCcontrol, 0x84);

        memWinPtr = (MDOCPwindow *) DOCAddressBase;
    tffsWriteByte(memWinPtr->DOCcontrol,(unsigned char)0x04 );
    tffsWriteByte(memWinPtr->DocCntConfirmReg,(unsigned char)0xfb );

        TrueffsFreeTranslatedAddress(
            DOCAddressBase,
            WindowSize,
            DOCAddressSpace
            );
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c:TrueffsResetDiskOnChip()b End\n"));
    return;
}

NTSTATUS
TrueffsStartSubDevice(
    IN UCHAR                deviceNo,
    IN UCHAR                partitionNumber,
    IN PDEVICE_EXTENSION    deviceExtension,
    IN PCM_RESOURCE_LIST    ResourceList,
    IN BOOLEAN              CheckResources
)
{
    NTSTATUS    status = STATUS_UNSUCCESSFUL;

    ExAcquireFastMutex(&driveInfoReferenceMutex);

    deviceExtension->UnitNumber = (partitionNumber << 4) + deviceNo;
    if (!(deviceExtension->DeviceFlags & DEVICE_FLAG_STARTED)) {
        status = TrueffsCreateSymblicLinks(deviceExtension);
        if (!NT_SUCCESS(status)) {
            return STATUS_UNSUCCESSFUL;
        }
    }
    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartDevice OK\n"));
    ExReleaseFastMutex(&driveInfoReferenceMutex);
    return STATUS_SUCCESS;
}


NTSTATUS
TrueffsDetectDiskOnChip(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
)

{
    ULONG                           cmResourceListSize;
    PCM_RESOURCE_LIST               cmResourceList = NULL;
    PCM_FULL_RESOURCE_DESCRIPTOR    cmFullResourceDescriptor;
    PCM_PARTIAL_RESOURCE_LIST       cmPartialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmPartialDescriptors;
    BOOLEAN                         conflictDetected;
    PDEVICE_OBJECT                  detectedPhysicalDeviceObject;
    PDEVICE_EXTENSION               fdoExtensions[VOLUMES];
    NTSTATUS                        status;
    ULONG                           legacyDetection = 0;
    ULONG                           searchBase, aliasSearchBase, aliasCounter;
    PVOID                           mappedWindowBase = NULL;
    KIRQL                           cIrql;
    BOOLEAN                         startSearch = FALSE;
    int noOfDevices = 0;
    int deviceNo    = 0;
    UCHAR currSockets = 0;
    int index = 0;
    CM_RESOURCE_LIST               arrayResourceList[VOLUMES];
    ULONG prevValue;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DetectDiskOnChip\n"));

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DetectDiskOnChip, go to Registry\n"));
        // Set Registry Vars to TrueFFS
        TrueffsDetectRegistryValues(DriverObject,RegistryPath);
    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DetectDiskOnChip, back from Registry\n"));


    if (!TrueffsOkToDetectLegacy(DriverObject)) {
        // legacy detection is not enabled
        TffsDebugPrint((TFFS_DEB_WARN,"Trueffs: DetectDiskOnChip: detection is not enabled\n"));
        return STATUS_SUCCESS;
    }

    // disable legacy detection for next boot
    TrueffsGetParameterFromServiceSubKey (
            DriverObject,
            LEGACY_DETECTION,
            REG_DWORD,
            FALSE,
            (PVOID) &legacyDetection,
            sizeof (legacyDetection)
            );

    cmResourceListSize = sizeof (CM_RESOURCE_LIST);
    cmResourceList = ExAllocatePoolWithTag (PagedPool, cmResourceListSize, TFFSPORT_POOL_TAG);
    if (cmResourceList == NULL){
        status = STATUS_NO_MEMORY;
        goto GetOut;
    }

    RtlZeroMemory(cmResourceList, cmResourceListSize);

    for(index = 0; index < VOLUMES; index++){
        fdoExtensions[index] = NULL;
        //arrayResourceList[index] = ExAllocatePoolWithTag (PagedPool, cmResourceListSize, TFFSPORT_POOL_TAG);
        //RtlZeroMemory(arrayResourceList[index], cmResourceListSize );

    }
    RtlZeroMemory(arrayResourceList, cmResourceListSize * VOLUMES);

    // Build resource requirement list
    cmResourceList->Count = 1;
    cmFullResourceDescriptor = cmResourceList->List;
    cmFullResourceDescriptor->InterfaceType = DISKONCHIP_INTERFACE;
    cmFullResourceDescriptor->BusNumber = DISKONCHIP_BUSNUMBER;
    cmPartialResourceList = &cmFullResourceDescriptor->PartialResourceList;
    cmPartialResourceList->Version = 1;
    cmPartialResourceList->Revision = 1;
    cmPartialResourceList->Count = 1;
    cmPartialDescriptors = cmPartialResourceList->PartialDescriptors;

    cmPartialDescriptors[0].Type             = CmResourceTypeMemory;
    cmPartialDescriptors[0].ShareDisposition = CmResourceShareShared;
    cmPartialDescriptors[0].Flags            = CM_RESOURCE_MEMORY_READ_ONLY;
    cmPartialDescriptors[0].u.Memory.Length  = DISKONCHIP_WINDOW_SIZE;


    for(searchBase = START_SEARCH_ADDRESS; searchBase < END_SEARCH_ADDRESS ; searchBase += DISKONCHIP_WINDOW_SIZE) {
        cmPartialDescriptors[0].u.Memory.Start.QuadPart = searchBase;

          // check to see if the resource is available
        status = IoReportResourceForDetection (
                         DriverObject,
                         cmResourceList,
                         cmResourceListSize,
                         NULL,
                         NULL,
                         0,
                         &conflictDetected
                         );
        if (!NT_SUCCESS(status) || conflictDetected) {
            if (NT_SUCCESS(status)) {
                IoReportResourceForDetection (
                                 DriverObject,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 0,
                                 &conflictDetected
                                 );
                status = STATUS_UNSUCCESSFUL;
            }
        }
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: IoReportResourceForDetection with status %Xh\n",status));

        if (!NT_SUCCESS (status)) {
            continue;
        }


        TrueffsResetDiskOnChip(cmFullResourceDescriptor->InterfaceType,cmFullResourceDescriptor->BusNumber,searchBase,DISKONCHIP_WINDOW_SIZE);

        // release the resources
        IoReportResourceForDetection (
                     DriverObject,
                     NULL,
                     0,
                     NULL,
                     NULL,
                     0,
                     &conflictDetected
                     );



        // check to see if the resource is available
        status = IoReportResourceForDetection (
                         DriverObject,
                         cmResourceList,
                         cmResourceListSize,
                         NULL,
                         NULL,
                         0,
                         &conflictDetected
                         );
        if (!NT_SUCCESS(status) || conflictDetected) {
            if (NT_SUCCESS(status)) {
                IoReportResourceForDetection (
                                 DriverObject,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 0,
                                 &conflictDetected
                                 );
                status = STATUS_UNSUCCESSFUL;
            }
        }
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: IoReportResourceForDetection with status %Xh\n",status));

     //   if (!NT_SUCCESS (status)) {
     //       continue;
     //   }

        if (NT_SUCCESS (status)) {
            status = TrueffsFindDiskOnChip(cmFullResourceDescriptor->InterfaceType,cmFullResourceDescriptor->BusNumber,searchBase,DISKONCHIP_WINDOW_SIZE, startSearch,&mappedWindowBase);
        }
        else{
            continue;
        }

                // release the resources we have grab, IoReportDetectedDevice()
        // will grab them for us again when we call and it will grab them
        // on behalf of the detected PDO.
        IoReportResourceForDetection (
                     DriverObject,
                     NULL,
                     0,
                     NULL,
                     NULL,
                     0,
                     &conflictDetected
                     );

        if (NT_SUCCESS (status)) {
            detectedPhysicalDeviceObject = NULL;

            status = IoReportDetectedDevice(DriverObject,
                                            Isa,
                                            0,
                                            0,
                                            cmResourceList,
                                            NULL,
                                            FALSE,
                                            &detectedPhysicalDeviceObject);

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: IoReportDetectedDevice returned status %Xh\n",status));

            if (NT_SUCCESS (status)) {

            // create a FDO and attach it to the detected PDO
                status = TrueffsCreateDevObject(
                             DriverObject,
                             detectedPhysicalDeviceObject,
                             &fdoExtensions[noOfDevices]
                             );
            }
            if (NT_SUCCESS (status)) {
                status = TrueffsStartDeviceOnDetect(fdoExtensions[noOfDevices],cmResourceList,TRUE);
                if (NT_SUCCESS (status)) {
                    memcpy(&arrayResourceList[noOfDevices++],cmResourceList, cmResourceListSize);
                    //moti tffscpy(&arrayResourceList[noOfDevices++],cmResourceList, cmResourceListSize);
                    //tffscpy(arrayResourceList[noOfDevices++],cmResourceList, cmResourceListSize);
                }
            }
        }
    }


    //Mounting all devices includes sub handles
    for(deviceNo = 0;deviceNo < noOfDevices;deviceNo++) {
        FLStatus flStatus = flOK;
        status = STATUS_SUCCESS;
        status = TrueffsMountMedia(fdoExtensions[deviceNo]);
        if (!NT_SUCCESS (status)) {
            // go through the remove sequence
            if (fdoExtensions[deviceNo]) {
                IoDetachDevice(fdoExtensions[deviceNo]->LowerDeviceObject);
                IoDeleteDevice(fdoExtensions[deviceNo]->DeviceObject);
            }
            continue;
        }
        else {
            IOreq ioreq;
            int partitionNumber = 0;
            int noOfPartitions = 0;
            ioreq.irHandle =  deviceNo;
            flStatus= flCountVolumes(&ioreq);
            if(flStatus == flOK)
                noOfPartitions = ioreq.irFlags;
            else
                noOfPartitions = 1;
            KeAcquireSpinLock(&fdoExtensions[deviceNo]->ExtensionDataSpinLock,&cIrql);
            fdoExtensions[deviceNo]->DeviceFlags &= ~DEVICE_FLAG_STOPPED;
            fdoExtensions[deviceNo]->DeviceFlags |= DEVICE_FLAG_STARTED;
            KeReleaseSpinLock(&fdoExtensions[deviceNo]->ExtensionDataSpinLock,cIrql);

            //Handle sub partitions
            for(partitionNumber = 1;partitionNumber < noOfPartitions;partitionNumber++){
                PDEVICE_EXTENSION               fdoExtension = NULL;
                status = STATUS_SUCCESS;

                // release the resources we have grab, IoReportDetectedDevice()
                // will grab them for us again when we call and it will grab them
                // on behalf of the detected PDO.
/*              IoReportResourceForDetection (
                             DriverObject,
                             NULL,
                             0,
                             NULL,
                             NULL,
                             0,
                             &conflictDetected
                             );
*/

                detectedPhysicalDeviceObject = NULL;
                status = IoReportDetectedDevice(DriverObject,
                                                Isa,
                                                0,
                                                0,
                                                &arrayResourceList[deviceNo],
                                                //arrayResourceList[deviceNo],
                                                NULL,
                                                FALSE,
                                                &detectedPhysicalDeviceObject);

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: IoReportDetectedDevice returned status %Xh\n",status));

                if (NT_SUCCESS (status)) {

                // create a FDO and attach it to the detected PDO

                    status = TrueffsCreateDevObject(
                                 DriverObject,
                                 detectedPhysicalDeviceObject,
                                 &fdoExtension
                                 );
                }
                if (NT_SUCCESS (status)) {
                    status = TrueffsStartSubDevice((unsigned char)deviceNo,
                                                    (unsigned char)partitionNumber,
                                                    fdoExtension,
                                                    &arrayResourceList[deviceNo],
                                                    //arrayResourceList[deviceNo],
                                                    TRUE);
                }
                if (NT_SUCCESS (status)) {
                    status = TrueffsMountMedia(fdoExtension);
                    if (!NT_SUCCESS (status)) {
                    // go through the remove sequence
                        if (fdoExtension) {
                            IoDetachDevice(fdoExtension->LowerDeviceObject);
                            IoDeleteDevice(fdoExtension->DeviceObject);
                        }
                        continue;
                    }
                    else{
                        KeAcquireSpinLock(&fdoExtension->ExtensionDataSpinLock,&cIrql);
                        fdoExtension->DeviceFlags &= ~DEVICE_FLAG_STOPPED;
                        fdoExtension->DeviceFlags |= DEVICE_FLAG_STARTED;
                        KeReleaseSpinLock(&fdoExtension->ExtensionDataSpinLock,cIrql);
                    }
                }
            }
        }
    }
GetOut:

    if (cmResourceList) {
        ExFreePool (cmResourceList);
        cmResourceList = NULL;
    }

    for(index = 0; index < VOLUMES; index++){
        fdoExtensions[index] = NULL;
    }


#ifdef ENVIRONMENT_VARS

      for ( currSockets = 0; currSockets < SOCKETS; currSockets++) {
            if (VerifyWriteState[currSockets])
                status = flSetEnvSocket(FL_VERIFY_WRITE_BDTL,currSockets,VerifyWriteState[currSockets],&prevValue);
    }

#endif /*ENVIRONMENT_VARS       */


        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DetectDiskOnChip with status %Xh\n",status));

    return status;
}

NTSTATUS
TrueffsTranslateAddress(
    IN INTERFACE_TYPE      InterfaceType,
    IN ULONG               BusNumber,
    IN PHYSICAL_ADDRESS    StartAddress,
    IN LONG                Length,
    IN OUT PULONG          AddressSpace,
    OUT PVOID              *TranslatedAddress,
    OUT PPHYSICAL_ADDRESS  TranslatedMemoryAddress
    )
/*++

Routine Description:

    translate i/o address

Arguments:

    InterfaceType - bus interface

    BusNumber - bus number

    StartAddress - address to translate

    Length - number of byte to translate

    AddressSpace - address space for the given address

Return Value:

    AddressSpace - address space for the translated address

    TranslatedAddress - translated address

    TranslatedMemoryAddress - tranlated memory address if translated to memory space

    NT Status

--*/
{
    PHYSICAL_ADDRESS       translatedAddress;

    *TranslatedAddress = NULL;
    TranslatedMemoryAddress->QuadPart = (ULONGLONG) NULL;

    if (HalTranslateBusAddress(InterfaceType,
                               BusNumber,
                               StartAddress,
                               AddressSpace,
                               &translatedAddress)) {


        if (*AddressSpace == TFFS_IO_SPACE) {
            *TranslatedMemoryAddress = translatedAddress;
            *TranslatedAddress = (PVOID) translatedAddress.QuadPart;

        } else if (*AddressSpace == TFFS_MEMORY_SPACE) {

            // translated address is in memory space,
            *TranslatedMemoryAddress = translatedAddress;

            *TranslatedAddress = MmMapIoSpace(
                                    translatedAddress,
                                    Length,
                                    FALSE);
        }
    }
    if (*TranslatedAddress) {
        return STATUS_SUCCESS;

    } else {
        return STATUS_INVALID_PARAMETER;
    }
}


VOID
TrueffsFreeTranslatedAddress(
    IN PVOID               TranslatedAddress,
    IN LONG                Length,
    IN ULONG               AddressSpace
    )
/*++

Routine Description:

    free resources created for a translated address

Arguments:

    TranslatedAddress - translated address

    Length - number of byte to translated

    AddressSpace - address space for the translated address

Return Value:

    None

--*/
{
    if (TranslatedAddress) {
        if (AddressSpace == TFFS_MEMORY_SPACE) {
            MmUnmapIoSpace (
                TranslatedAddress,
                Length
                );
        }
    }
    return;
}


NTSTATUS
TrueffsAddDevice(
    PDRIVER_OBJECT  DriverObject,
    PDEVICE_OBJECT  Pdo
    )

/*++

Routine Description:

    This is our PNP AddDevice called with the PDO ejected from the bus driver

Arguments:

    Argument1          - Driver Object.
    Argument2          - PDO.


Return Value:

    A valid return code for a DriverEntry routine.

--*/

{

    NTSTATUS            status;
    PDEVICE_EXTENSION   fdoExtension;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: AddDevice\n"));
    status = TrueffsCreateDevObject (DriverObject,Pdo,&fdoExtension);
    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: AddDevice with status %Xh\n", status));
    return status;
}


NTSTATUS
TrueffsCreateDevObject(
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           Pdo,
    OUT PDEVICE_EXTENSION       *FdoExtension
    )

/*++

Routine Description:

    This routine creates an object for the physical device specified and
    sets up the deviceExtension.

Arguments:

    DriverObject - Pointer to driver object created by system.

    PhysicalDeviceObject = PDO we should attach to.


Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          status;
    PDEVICE_OBJECT    deviceObject = NULL;
    STRING            deviceName;
    CCHAR             deviceNameBuffer[64];
    UNICODE_STRING    unicodeDeviceNameString;
    UNICODE_STRING    driverName;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: CreateDevObject\n"));

    sprintf(deviceNameBuffer, "\\Device\\TffsPort%d",TrueffsNextDeviceNumber_tffsport);
    RtlInitString(&deviceName, deviceNameBuffer);
    status = RtlAnsiStringToUnicodeString(&unicodeDeviceNameString,
                                          &deviceName,
                                          TRUE);
    if (!NT_SUCCESS (status)) {
        return status;
    }
    status = IoCreateDevice(DriverObject,
                            sizeof(DEVICE_EXTENSION),
                            &unicodeDeviceNameString,   // our name
                            FILE_DEVICE_CONTROLLER,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &deviceObject);

    RtlFreeUnicodeString (&unicodeDeviceNameString);

    if (!NT_SUCCESS(status)) {
        TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: CreateDevObject: IoCreateDevice failed with status %Xh\n",status));
        return status;
    }
    else {
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Created FDO %Xh\n",deviceObject));
    }

    deviceExtension = deviceObject->DeviceExtension;
    RtlZeroMemory(deviceExtension,sizeof(DEVICE_EXTENSION));

    if (Pdo != NULL) {
        if ((deviceExtension->LowerDeviceObject =
            IoAttachDeviceToDeviceStack(deviceObject,Pdo))==NULL){
            TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: CreateDevObject: cannot attach device\n"));

            IoDeleteDevice(deviceObject);
            return status;
        }
    }

    KeInitializeSemaphore(&deviceExtension->requestSemaphore,0L,MAXLONG);

    KeInitializeSpinLock(&deviceExtension->listSpinLock);

    InitializeListHead(&deviceExtension->listEntry);

    KeInitializeSpinLock(&deviceExtension->ExtensionDataSpinLock);

    KeInitializeEvent(&deviceExtension->PendingIRPEvent, SynchronizationEvent, FALSE);

    deviceExtension->threadReferenceCount = -1;

    deviceExtension->pcmciaParams.physWindow = 0;
    deviceExtension->pcmciaParams.windowSize = 0;
    deviceExtension->pcmciaParams.windowBase = NULL;

    deviceObject->Flags |= DO_DIRECT_IO;
    deviceExtension->DeviceObject = deviceObject;
    deviceExtension->MainPdo = Pdo;
    deviceExtension->DriverObject = DriverObject;
    deviceObject->AlignmentRequirement = FILE_WORD_ALIGNMENT;
    deviceObject->Flags &=~DO_DEVICE_INITIALIZING;
    deviceExtension->DeviceFlags |= DEVICE_FLAG_STOPPED;

#if 0 //Pcmcia cards don't have removable media
    RtlInitUnicodeString(&driverName, L"\\Driver\\Pcmcia");
    if (!RtlCompareUnicodeString(&Pdo->DriverObject->DriverName,&driverName,TRUE)) {
        deviceExtension->removableMedia = TRUE;
    }
#endif

    deviceExtension->TrueffsDeviceNumber = TrueffsNextDeviceNumber_tffsport;
    TrueffsNextDeviceNumber_tffsport++;
    deviceExtension->ScsiDeviceType = DIRECT_ACCESS_DEVICE;

    *FdoExtension = deviceExtension;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: CreateDevObject with status %Xh\n",status));
    return status;
}



NTSTATUS
TrueffsStartDeviceOnDetect(
    IN PDEVICE_EXTENSION    deviceExtension,
    IN PCM_RESOURCE_LIST    ResourceList,
    IN BOOLEAN              CheckResources
)
/*++

Routine Description:

    This is our START_DEVICE, called when we get an IPR_MN_START_DEVICE.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/

{
    PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceList;
    PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptors;
    NTSTATUS    status = STATUS_UNSUCCESSFUL;
    ULONG       i;
    ULONG       j;
    PVOID       mappedWindowBase =  NULL;
    ULONG       addressSpace;

    // assume we have DOC
        ExAcquireFastMutex(&driveInfoReferenceMutex);
    if (!(deviceExtension->DeviceFlags & DEVICE_FLAG_STARTED)) {
        for (i = 0; i < DOC_DRIVES; i++) {
            if (driveInfo[i].fdoExtension == NULL) {
                deviceExtension->UnitNumber = i;
                break;
            }
        }
    }
    // Check resources
    if (CheckResources) {
        if (ResourceList == NULL || ResourceList->List == NULL) {
            TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: StartDevice: No resources !\n"));
            goto exitStartDevice;
        }
        fullResourceList = ResourceList->List;
        for (i = 0; i < ResourceList->Count; i++) {

            partialResourceList = &(fullResourceList->PartialResourceList);
            partialDescriptors  = fullResourceList->PartialResourceList.PartialDescriptors;

            for (j = 0; j < partialResourceList->Count; j++) {

                if (partialDescriptors[j].Type == CmResourceTypeMemory) {
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Memory %Xh Size %Xh Interf %Xh Bus %Xh\n",
                                    partialDescriptors[j].u.Memory.Start.LowPart,
                                    partialDescriptors[j].u.Memory.Length,
                                    fullResourceList->InterfaceType,
                                    fullResourceList->BusNumber));
                    status = TrueffsCheckDiskOnChip(
                        fullResourceList->InterfaceType,
                        fullResourceList->BusNumber,
                        partialDescriptors[j].u.Memory.Start.LowPart,
                        partialDescriptors[j].u.Memory.Length,
                        &mappedWindowBase,
                        &addressSpace
                        );
                    if (NT_SUCCESS(status)) {
                        deviceExtension->pcmciaParams.windowBase = mappedWindowBase;
                        deviceExtension->pcmciaParams.windowSize = partialDescriptors[j].u.Memory.Length;
                        deviceExtension->pcmciaParams.addressSpace = addressSpace;
                        deviceExtension->pcmciaParams.phWindowBase = RtlConvertLongToLargeInteger(partialDescriptors[j].u.Memory.Start.LowPart);
                        deviceExtension->pcmciaParams.physWindow = partialDescriptors[j].u.Memory.Start.QuadPart;
                        deviceExtension->pcmciaParams.InterfaceType = fullResourceList->InterfaceType;
                        deviceExtension->pcmciaParams.BusNumber = fullResourceList->BusNumber;
                        updateDocSocketParams(deviceExtension);
                        goto goodResources;
                    }
                }
            }
            fullResourceList = (PCM_FULL_RESOURCE_DESCRIPTOR) (partialDescriptors + partialResourceList->Count);
        }

        // DiskOnChip was not found, assume this is PCMCIA
        if (!(deviceExtension->DeviceFlags & DEVICE_FLAG_STARTED)) {
            for (i = DOC_DRIVES; i < SOCKETS; i++) {
                if (driveInfo[i].fdoExtension == NULL) {
                    deviceExtension->UnitNumber = i;
                    break;
                }
            }
        }

        fullResourceList = ResourceList->List;
        for (i = 0; i < ResourceList->Count; i++) {

            partialResourceList = &(fullResourceList->PartialResourceList);
            partialDescriptors  = fullResourceList->PartialResourceList.PartialDescriptors;

            for (j = 0; j < partialResourceList->Count; j++) {

                if (partialDescriptors[j].Type == CmResourceTypeMemory) {
                    PHYSICAL_ADDRESS AddressMemoryBase;
                    ULONG PcmciaAddressSpace = TFFS_MEMORY_SPACE;
                    deviceExtension->pcmciaParams.windowSize = partialDescriptors[j].u.Memory.Length;
                    deviceExtension->pcmciaParams.phWindowBase = RtlConvertLongToLargeInteger(partialDescriptors[j].u.Memory.Start.LowPart);
                    deviceExtension->pcmciaParams.physWindow = partialDescriptors[j].u.Memory.Start.QuadPart;
                    deviceExtension->pcmciaParams.InterfaceType = fullResourceList->InterfaceType;
                    deviceExtension->pcmciaParams.BusNumber = fullResourceList->BusNumber;
                    mappedWindowBase = NULL;
                    status = TrueffsTranslateAddress(
                                        deviceExtension->pcmciaParams.InterfaceType,
                                        deviceExtension->pcmciaParams.BusNumber,
                                        deviceExtension->pcmciaParams.phWindowBase,
                                        deviceExtension->pcmciaParams.windowSize,
                                        &PcmciaAddressSpace,
                                        &mappedWindowBase,
                                        &AddressMemoryBase);
                    deviceExtension->pcmciaParams.windowBase = mappedWindowBase;
                    deviceExtension->pcmciaParams.addressSpace = PcmciaAddressSpace;
                    if (!NT_SUCCESS(status)) {
                        goto exitStartDevice;
                                    }
                                    status = updatePcmciaSocketParams(deviceExtension);
                    if (NT_SUCCESS(status)) {
                                                goto goodResources;
                    }
                            }
                    }
                    fullResourceList = (PCM_FULL_RESOURCE_DESCRIPTOR) (partialDescriptors + partialResourceList->Count);
            }
        TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: StartDevice: pnp manager gave me bad resources!\n"));
        status = STATUS_INVALID_PARAMETER;
        goto exitStartDevice;
    }

goodResources:

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Window at %Xh\n",mappedWindowBase));
    if (!(deviceExtension->DeviceFlags & DEVICE_FLAG_STARTED)) {

        // Create legacy object names
        status = TrueffsCreateSymblicLinks(deviceExtension);
        if (!NT_SUCCESS(status)) {
            goto exitStartDevice;
        }
    }
        ExReleaseFastMutex(&driveInfoReferenceMutex);
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartDevice OK\n"));
    return STATUS_SUCCESS;

exitStartDevice:

    if (!NT_SUCCESS(status)) {
        TrueffsStopRemoveDevice(deviceExtension);
        TrueffsDeleteSymblicLinks(deviceExtension);
    }
        ExReleaseFastMutex(&driveInfoReferenceMutex);
    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartDevice: exit with status %Xh\n",status));
    return status;
}
//==============================================
NTSTATUS
TrueffsStartDevice(
    IN PDEVICE_EXTENSION    deviceExtension,
    IN PCM_RESOURCE_LIST    ResourceList,
    IN BOOLEAN              CheckResources
)
/*++

Routine Description:

    This is our START_DEVICE, called when we get an IPR_MN_START_DEVICE.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/

{
    PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceList;
    PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptors;
    NTSTATUS    status = STATUS_UNSUCCESSFUL;
    ULONG       i;
    ULONG       j;
    PVOID       mappedWindowBase =  NULL;
    ULONG       addressSpace;

    // assume we have DOC
     ExAcquireFastMutex(&driveInfoReferenceMutex);

    // Check resources
    if (CheckResources) {
        if (ResourceList == NULL || ResourceList->List == NULL) {
            TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: StartDevice: No resources !\n"));
            goto exitStartDevice;
        }
        fullResourceList = ResourceList->List;
        for (i = 0; i < ResourceList->Count; i++) {

            partialResourceList = &(fullResourceList->PartialResourceList);
            partialDescriptors  = fullResourceList->PartialResourceList.PartialDescriptors;

            for (j = 0; j < partialResourceList->Count; j++) {

                if (partialDescriptors[j].Type == CmResourceTypeMemory) {
                                    //Get handle here
                                    int  deviceIndex = 0;
                                    long baseAddress = partialDescriptors[j].u.Memory.Start.LowPart;

                                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Memory %Xh Size %Xh Interf %Xh Bus %Xh\n",
                                                                                        partialDescriptors[j].u.Memory.Start.LowPart,
                                                                                        partialDescriptors[j].u.Memory.Length,
                                                                                        fullResourceList->InterfaceType,
                                                                                        fullResourceList->BusNumber));

                                    status = TrueffsCheckDiskOnChip(
                                        fullResourceList->InterfaceType,
                                        fullResourceList->BusNumber,
                                        partialDescriptors[j].u.Memory.Start.LowPart,
                                        partialDescriptors[j].u.Memory.Length,
                                        &mappedWindowBase,
                                        &addressSpace
                                        );

                                    if (NT_SUCCESS(status)) {
                                        for(deviceIndex = 0; deviceIndex < DOC_DRIVES; deviceIndex++) {
                                            //If Main partition exists
                                             if(info[deviceIndex].baseAddress == baseAddress){
                                                deviceExtension->UnitNumber = deviceIndex + (info[deviceIndex].nextPartition << 4);
                                                info[deviceIndex].nextPartition++;
                                                break;
                                             }
                                             //In case of Main partition doesn't exist
                                             else if((info[deviceIndex].baseAddress == 0) && (baseAddress != 0)){
                                                 info[deviceIndex].baseAddress = baseAddress;
                                                deviceExtension->UnitNumber = deviceIndex;
                                                info[deviceIndex].nextPartition++;
                                                break;
                                            }
                                        }
                                        if(deviceIndex == DOC_DRIVES){
                                            goto pcmciaResources;
                                        }
                                    }
                                    if (NT_SUCCESS(status)) {
                                        deviceExtension->pcmciaParams.windowBase = mappedWindowBase;
                                        deviceExtension->pcmciaParams.windowSize = partialDescriptors[j].u.Memory.Length;
                                        deviceExtension->pcmciaParams.addressSpace = addressSpace;
                                        deviceExtension->pcmciaParams.phWindowBase = RtlConvertLongToLargeInteger(partialDescriptors[j].u.Memory.Start.LowPart);
                                        deviceExtension->pcmciaParams.physWindow = partialDescriptors[j].u.Memory.Start.QuadPart;
                                        deviceExtension->pcmciaParams.InterfaceType = fullResourceList->InterfaceType;
                                        deviceExtension->pcmciaParams.BusNumber = fullResourceList->BusNumber;

                                        //In case of Main partition
                                        if((deviceExtension->UnitNumber & 0xf0) == 0)
                                            updateDocSocketParams(deviceExtension);
                                        goto goodResources;
                                    }
                }
            }
            fullResourceList = (PCM_FULL_RESOURCE_DESCRIPTOR) (partialDescriptors + partialResourceList->Count);
        }


pcmciaResources:
        // DiskOnChip was not found, assume this is PCMCIA
        if (!(deviceExtension->DeviceFlags & DEVICE_FLAG_STARTED)) {
            for (i = DOC_DRIVES; i < SOCKETS; i++) {
                if (driveInfo[i].fdoExtension == NULL) {
                    deviceExtension->UnitNumber = i;
                    break;
                }
            }
        }

        fullResourceList = ResourceList->List;
        for (i = 0; i < ResourceList->Count; i++) {

            partialResourceList = &(fullResourceList->PartialResourceList);
            partialDescriptors  = fullResourceList->PartialResourceList.PartialDescriptors;

            for (j = 0; j < partialResourceList->Count; j++) {

                if (partialDescriptors[j].Type == CmResourceTypeMemory) {
                    PHYSICAL_ADDRESS AddressMemoryBase;
                    ULONG PcmciaAddressSpace = TFFS_MEMORY_SPACE;
                    deviceExtension->pcmciaParams.windowSize = partialDescriptors[j].u.Memory.Length;
                    deviceExtension->pcmciaParams.phWindowBase = RtlConvertLongToLargeInteger(partialDescriptors[j].u.Memory.Start.LowPart);
                    deviceExtension->pcmciaParams.physWindow = partialDescriptors[j].u.Memory.Start.QuadPart;
                    deviceExtension->pcmciaParams.InterfaceType = fullResourceList->InterfaceType;
                    deviceExtension->pcmciaParams.BusNumber = fullResourceList->BusNumber;
                    mappedWindowBase = NULL;
                    status = TrueffsTranslateAddress(
                                        deviceExtension->pcmciaParams.InterfaceType,
                                        deviceExtension->pcmciaParams.BusNumber,
                                        deviceExtension->pcmciaParams.phWindowBase,
                                        deviceExtension->pcmciaParams.windowSize,
                                        &PcmciaAddressSpace,
                                        &mappedWindowBase,
                                        &AddressMemoryBase);
                    deviceExtension->pcmciaParams.windowBase = mappedWindowBase;
                    deviceExtension->pcmciaParams.addressSpace = PcmciaAddressSpace;
                    if (!NT_SUCCESS(status)) {
                        goto exitStartDevice;
                    }
                    status = updatePcmciaSocketParams(deviceExtension);

                    if (NT_SUCCESS(status)) {
                        goto goodResources;
                    }
                }
             }
             fullResourceList = (PCM_FULL_RESOURCE_DESCRIPTOR) (partialDescriptors + partialResourceList->Count);
        }
        TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: StartDevice: pnp manager gave me bad resources!\n"));
        status = STATUS_INVALID_PARAMETER;
        goto exitStartDevice;
    }

goodResources:

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Window at %Xh\n",mappedWindowBase));
    if (!(deviceExtension->DeviceFlags & DEVICE_FLAG_STARTED)) {

        // Create legacy object names
        status = TrueffsCreateSymblicLinks(deviceExtension);
        if (!NT_SUCCESS(status)) {
            goto exitStartDevice;
        }
    }
        ExReleaseFastMutex(&driveInfoReferenceMutex);
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartDevice OK\n"));
    return STATUS_SUCCESS;

exitStartDevice:

    if (!NT_SUCCESS(status)) {
        TrueffsStopRemoveDevice(deviceExtension);
        TrueffsDeleteSymblicLinks(deviceExtension);
    }
        ExReleaseFastMutex(&driveInfoReferenceMutex);
    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartDevice: exit with status %Xh\n",status));
    return status;
}


NTSTATUS
TrueffsMountMedia(
    IN PDEVICE_EXTENSION    deviceExtension
)
/*++

Routine Description:

    This is a part of START_DEVICE, called when we get an IPR_MN_START_DEVICE.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS       status;
    FLStatus       flStatus = flOK;
        FLStatus       flStatusProt = flOK;
    IOreq          ioreq;
        IOreq          ioreqProt;
    HANDLE         threadHandle;
        ULONG          heads, sectors, cylinders;
        ULONG                    prevValue;
        UCHAR currSockets = 0;


    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: MountMedia\n"));

    ioreq.irHandle = deviceExtension->UnitNumber;
    flStatus = flAbsMountVolume(&ioreq);

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: MountMedia: flMountVolume returned status %Xh\n",flStatus));

    if (flStatus != flOK) {
        status = STATUS_UNRECOGNIZED_MEDIA;
        goto exitMountMedia;
    }

    //Identify Write Protected Disk
    ioreqProt.irHandle = ioreq.irHandle;
    ioreqProt.irFlags = 0;
    flStatusProt = flIdentifyProtection(&ioreqProt);
    if(flStatusProt == flOK){
        if(ioreqProt.irFlags& WRITE_PROTECTED){

            deviceExtension->IsWriteProtected = TRUE;
            deviceExtension->IsPartitonTableWritten = FALSE;
            RtlZeroMemory (deviceExtension->PartitonTable, sizeof(deviceExtension->PartitonTable));
        }
        else{
            deviceExtension->IsWriteProtected = FALSE;
            deviceExtension->IsPartitonTableWritten = FALSE;
        }
    }
    else{

        deviceExtension->IsWriteProtected = FALSE;
        deviceExtension->IsPartitonTableWritten = FALSE;
    }

    //Identify SW Write Protected Disk
    deviceExtension->IsSWWriteProtected = FALSE;

/*      flStatusProt = flIdentifySWProtection(&ioreqProt);
    if(flStatusProt == flOK){
        if(ioreqProt.irFlags& WRITE_PROTECTED){

            deviceExtension->IsSWWriteProtected = TRUE;
        }
        else{
            deviceExtension->IsSWWriteProtected = FALSE;
        }
    }
    else{

        deviceExtension->IsSWWriteProtected = FALSE;
    }
*/
    //In case of protection allocate Partiton table
    flSectorsInVolume(&ioreq);
    deviceExtension->totalSectors    = ioreq.irLength;
    deviceExtension->BytesPerSector  = SECTOR_SIZE;
    flBuildGeometry(deviceExtension->totalSectors, &cylinders, &heads, &sectors,0);
    deviceExtension->SectorsPerTrack = sectors;
    deviceExtension->NumberOfHeads   = heads;
    deviceExtension->Cylinders       = cylinders;

    deviceExtension->totalSectors    = deviceExtension->SectorsPerTrack *
                                       deviceExtension->NumberOfHeads *
                                       deviceExtension->Cylinders;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: internal geometry #sectors %x, #heads %x, #cylinders %x #total %x\n",
                                        deviceExtension->SectorsPerTrack,
                                        deviceExtension->NumberOfHeads,
                                        deviceExtension->Cylinders,
                                        deviceExtension->totalSectors));

    if (!(deviceExtension->DeviceFlags & DEVICE_FLAG_STARTED)) {

        if (AllocatePdo(deviceExtension) == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exitMountMedia;
        }

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Created PDO %Xh\n",deviceExtension->ChildPdo));

        if (++(deviceExtension->threadReferenceCount) == 0) {
            deviceExtension->threadReferenceCount++;

            // Create the thread
            status = PsCreateSystemThread(&threadHandle,
                        (ACCESS_MASK) 0L,
                        NULL,
                        (HANDLE) 0L,
                        NULL,
                        TrueffsThread,
                        deviceExtension);

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PsCreateSystemThread returned status %Xh\n", status));

            if (!NT_SUCCESS(status)) {
                deviceExtension->threadReferenceCount = -1;
                goto exitMountMedia;
            }
            else {
                status = ObReferenceObjectByHandle( threadHandle,
                                                    SYNCHRONIZE,
                                                    NULL,
                                                    KernelMode,
                                                    &deviceExtension->TffsportThreadObject,
                                                    NULL );

                ASSERT(NT_SUCCESS(status));

                // Not needed.. we have the TffsportThreadObject
                // deviceExtension->DeviceFlags |= DEVICE_FLAG_THREAD;
            }

            ZwClose(threadHandle);
        }
    }

#ifdef ENVIRONMENT_VARS

      for ( currSockets = 0; currSockets < SOCKETS; currSockets++) {
            if (VerifyWriteState[currSockets])
                status = flSetEnvSocket(FL_VERIFY_WRITE_BDTL,currSockets,VerifyWriteState[currSockets],&prevValue);
    }

#endif /*ENVIRONMENT_VARS       */

    return STATUS_SUCCESS;

exitMountMedia:

    if (!NT_SUCCESS(status)) {
        TrueffsStopRemoveDevice(deviceExtension);
        TrueffsDeleteSymblicLinks(deviceExtension);
    }
    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: MountMedia: exit with status %Xh\n",status));
    return status;
}

UCHAR
TrueffsGetInfoNumber
(
     PDEVICE_EXTENSION    deviceExtension
    )
{
    UCHAR unitNumber;
    UCHAR i = 0;
    for(; i < (UCHAR)DOC_DRIVES;i++){
        if(info[i].baseAddress == (long)deviceExtension->pcmciaParams.phWindowBase.LowPart)
                break;
    }

    return i;
}

NTSTATUS
TrueffsStopRemoveDevice(
    PDEVICE_EXTENSION    deviceExtension
    )
{
    IOreq ioreq;
    UCHAR deviceIndex;

    TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: StopRemoveDevice: removed deviceExtension->UnitNumber = %0x\n", deviceExtension->UnitNumber));
    if (deviceExtension->pcmciaParams.windowBase == NULL &&
            deviceExtension->pcmciaParams.physWindow == 0 &&
            driveInfo[deviceExtension->UnitNumber].fdoExtension == NULL) {
               TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StopRemoveDevice: Device was already stopped or removed\n"));
                return STATUS_SUCCESS;
    }
    ioreq.irHandle = deviceExtension->UnitNumber;
    flDismountVolume(&ioreq);

    deviceIndex = TrueffsGetInfoNumber(deviceExtension);
    //In case of DiskOnChip (especially MDOCP)
    if( deviceIndex < DOC_DRIVES){

/*      TrueffsFreeTranslatedAddress(deviceExtension->pcmciaParams.windowBase,
                                     deviceExtension->pcmciaParams.windowSize,
                                     deviceExtension->pcmciaParams.addressSpace
                                     );
                                     */

        deviceExtension->pcmciaParams.windowBase = NULL;
        deviceExtension->pcmciaParams.physWindow = 0;

        //In case of MainPartition
        if((deviceExtension->UnitNumber & 0xf0) == 0){
            driveInfo[deviceExtension->UnitNumber].fdoExtension = NULL;
            driveInfo[deviceExtension->UnitNumber].interfAlive = 0;
            info[deviceIndex].baseAddress = 0;
        }
        info[deviceIndex].nextPartition  = (unsigned char)(((deviceExtension->UnitNumber & 0xf0) )>>4);
            //  info[deviceIndex].nextPartition--;

    }
    //PCMCIA
    else{
        TrueffsFreeTranslatedAddress(deviceExtension->pcmciaParams.windowBase,
                                         deviceExtension->pcmciaParams.windowSize,
                                         deviceExtension->pcmciaParams.addressSpace
                                         );
        deviceExtension->pcmciaParams.windowBase = NULL;
        deviceExtension->pcmciaParams.physWindow = 0;
        driveInfo[deviceExtension->UnitNumber].fdoExtension = NULL;
        driveInfo[deviceExtension->UnitNumber].interfAlive = 0;
    }
    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: RemoveDevice\n"));
    return STATUS_SUCCESS;
}


NTSTATUS
TrueffsCreateSymblicLinks (
    PDEVICE_EXTENSION FdoExtension
    )
{
    NTSTATUS            status;
    ULONG               i;
    PULONG              scsiportNumber;

    STRING              deviceName;
    CCHAR               deviceNameBuffer[64];
    WCHAR               deviceSymbolicNameBuffer[64];
    UNICODE_STRING      unicodeDeviceNameString;
    UNICODE_STRING      unicodeDeviceSymbolicNameString;
    UNICODE_STRING      unicodeDeviceArcNameString;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: CreateSymblicLinks\n"));

    sprintf(deviceNameBuffer, "\\Device\\TffsPort%d", FdoExtension->TrueffsDeviceNumber);
    RtlInitString(&deviceName, deviceNameBuffer);
    status = RtlAnsiStringToUnicodeString(&unicodeDeviceNameString,
                                          &deviceName,
                                          TRUE);
    if (!NT_SUCCESS (status)) {

        return status;
    }

    scsiportNumber = &IoGetConfigurationInformation()->ScsiPortCount;

    unicodeDeviceSymbolicNameString.Length = 0;
    unicodeDeviceSymbolicNameString.MaximumLength = 64 * sizeof(WCHAR);
    unicodeDeviceSymbolicNameString.Buffer = deviceSymbolicNameBuffer;

    for (i=0; i <= (*scsiportNumber); i++) {

        sprintf(deviceNameBuffer, "\\Device\\ScsiPort%d", i);
        RtlInitString(&deviceName, deviceNameBuffer);
        status = RtlAnsiStringToUnicodeString(&unicodeDeviceSymbolicNameString,
                                              &deviceName,
                                              FALSE);

        if (!NT_SUCCESS (status)) {

            break;
        }

        status = IoCreateSymbolicLink(
                     &unicodeDeviceSymbolicNameString,
                     &unicodeDeviceNameString
                     );

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: IoCreateSymbolicLink returned status %Xh\n",status));

        if (NT_SUCCESS (status)) {

            sprintf(deviceNameBuffer, "\\DosDevices\\Scsi%d:", i);
            RtlInitString(&deviceName, deviceNameBuffer);
            status = RtlAnsiStringToUnicodeString(&unicodeDeviceArcNameString,
                                                  &deviceName,
                                                  TRUE);

            if (!NT_SUCCESS (status)) {

                break;
            }

            IoAssignArcName (
                &unicodeDeviceArcNameString,
                &unicodeDeviceNameString
                );

            RtlFreeUnicodeString (&unicodeDeviceArcNameString);

            break;
        }
    }


    if (NT_SUCCESS(status)) {

        FdoExtension->SymbolicLinkCreated = TRUE;
        FdoExtension->ScsiPortNumber = i;
        (*scsiportNumber)++;
    }

    RtlFreeUnicodeString (&unicodeDeviceNameString);

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: CreateSymblicLinks exit with status %Xh\n",status));

    return status;
}


NTSTATUS
TrueffsDeleteSymblicLinks (
    PDEVICE_EXTENSION FdoExtension
    )
{
    NTSTATUS            status;
    ULONG               i;
    STRING              deviceName;
    CCHAR               deviceNameBuffer[64];
    UNICODE_STRING      unicodeDeviceSymbolicNameString;
    UNICODE_STRING      unicodeDeviceArcNameString;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeleteSymblicLinks\n"));

    if (!FdoExtension->SymbolicLinkCreated) {

        return STATUS_SUCCESS;
    }

    sprintf(deviceNameBuffer, "\\Device\\ScsiPort%d", FdoExtension->ScsiPortNumber);
    RtlInitString(&deviceName, deviceNameBuffer);
    status = RtlAnsiStringToUnicodeString(&unicodeDeviceSymbolicNameString,
                                          &deviceName,
                                          TRUE);
    if (NT_SUCCESS (status)) {

        sprintf(deviceNameBuffer, "\\DosDevices\\Scsi%d:", FdoExtension->ScsiPortNumber);
        RtlInitString(&deviceName, deviceNameBuffer);
        status = RtlAnsiStringToUnicodeString(&unicodeDeviceArcNameString,
                                              &deviceName,
                                              TRUE);

        if (NT_SUCCESS (status)) {

            status = IoDeleteSymbolicLink(
                         &unicodeDeviceSymbolicNameString
                         );

            if (NT_SUCCESS (status)) {

                IoDeassignArcName(&unicodeDeviceArcNameString);
                FdoExtension->SymbolicLinkCreated = FALSE;

                IoGetConfigurationInformation()->ScsiPortCount--;
            }

            RtlFreeUnicodeString (&unicodeDeviceArcNameString);
        }

        RtlFreeUnicodeString (&unicodeDeviceSymbolicNameString);
    }

    return status;
}


VOID
TrueffsUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Does nothing really...

Arguments:

    DriverObject - the driver being unloaded

Return Value:

    none

--*/

{
    PTRUEFFSDRIVER_EXTENSION trueffsDriverExtension;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Unload\n"));
    flExit();
    trueffsDriverExtension = IoGetDriverObjectExtension(
                                DriverObject,
                                DRIVER_OBJECT_EXTENSION_ID
                                );
    if (trueffsDriverExtension->RegistryPath.Buffer != NULL) {
        ExFreePool (trueffsDriverExtension->RegistryPath.Buffer);
    }
    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Exitting Unload\n"));
    return;
}


NTSTATUS
TrueffsDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the device control dispatcher.

Arguments:

    DeviceObject
    Irp

Return Value:


    NTSTATUS

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSTORAGE_PROPERTY_QUERY query;
    //Amir
    PGET_MEDIA_TYPES getMediaTypes;
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension;
    PPDO_EXTENSION pdoExtension;
    PDEVICE_EXTENSION_HEADER devExtension;
    BOOLEAN Fdo = FALSE;
        //Amir
        FLStatus    tffsStatus;
    IOreq       ioreq;
        flIOctlRecord flIoctlRec;
        //End Amir
    devExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;
    if (IS_FDO(devExtension)) {
        deviceExtension = DeviceObject->DeviceExtension;
        Fdo = TRUE;
    }
    else {
        pdoExtension = DeviceObject->DeviceExtension;
        deviceExtension = pdoExtension->Pext;
    }

    Irp->IoStatus.Information = 0;
    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: Code %Xh\n",irpStack->Parameters.DeviceIoControl.IoControlCode));

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_DISK_GET_DRIVE_GEOMETRY: {

        PDISK_GEOMETRY  pDiskGeometry = NULL;

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: GET_DISK_GEOMETRY\n"));

        // Check size of return buffer
        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(DISK_GEOMETRY)) {

            status = Irp->IoStatus.Status = STATUS_INFO_LENGTH_MISMATCH;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
        }

        pDiskGeometry = (PDISK_GEOMETRY)Irp->AssociatedIrp.SystemBuffer;

        // Trueffs is always Fixed Media
        pDiskGeometry->MediaType = FixedMedia;

        // All the fields neccesary are filled in during mount-media
        pDiskGeometry->TracksPerCylinder = deviceExtension->NumberOfHeads;
        pDiskGeometry->SectorsPerTrack = deviceExtension->SectorsPerTrack;
        pDiskGeometry->BytesPerSector = deviceExtension->BytesPerSector;
        pDiskGeometry->Cylinders.QuadPart =
            (LONGLONG)(deviceExtension->totalSectors /
                (pDiskGeometry->TracksPerCylinder * pDiskGeometry->SectorsPerTrack));

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TracksPerCylinder 0x%x, "
                        "SectorsPerTrack 0x%x, BytesPerSector: 0x%x, Cylinders 0x%x\n",
                        pDiskGeometry->TracksPerCylinder, pDiskGeometry->SectorsPerTrack,
                        pDiskGeometry->BytesPerSector, pDiskGeometry->Cylinders.QuadPart
                        ));

        status = Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = sizeof(DISK_GEOMETRY);

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        break;
    }

     //AmirM
    /*case IOCTL_STORAGE_GET_MEDIA_TYPES: {
        PGET_MEDIA_TYPES  mediaTypes = Irp->AssociatedIrp.SystemBuffer;
        PDEVICE_MEDIA_INFO mediaInfo = &mediaTypes->MediaInfo[0];


        TffsDebugPrint((TFFS_DEB_INFO,"$$$$$$$$$$$$$IOCTL_STORAGE_GET_MEDIA_TYPES_EX \n"));

        //
        // Ensure that buffer is large enough.
        //

        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(GET_MEDIA_TYPES)) {

            //
            // Buffer too small.
            //

            Irp->IoStatus.Information = 0;
            status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        mediaTypes->DeviceType =  FILE_DEVICE_DISK;
        mediaTypes->MediaInfoCount = 1;
        mediaInfo->DeviceSpecific.RemovableDiskInfo.Cylinders.QuadPart = (LONGLONG)(deviceExtension->totalSectors /
                                                                            (deviceExtension->NumberOfHeads * deviceExtension->SectorsPerTrack));
        mediaInfo->DeviceSpecific.RemovableDiskInfo.TracksPerCylinder = deviceExtension->NumberOfHeads;
        mediaInfo->DeviceSpecific.RemovableDiskInfo.SectorsPerTrack = deviceExtension->SectorsPerTrack;
        mediaInfo->DeviceSpecific.RemovableDiskInfo.BytesPerSector = deviceExtension->BytesPerSector;

        //
        // Set the type.
        //
        mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaType = FixedMedia;
        mediaInfo->DeviceSpecific.RemovableDiskInfo.NumberMediaSides = 1;
        mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaCharacteristics = MEDIA_WRITE_PROTECTED;

        status = Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = sizeof(GET_MEDIA_TYPES);
        IoCompleteRequest(Irp, 0);
        break;
        }
*/
      case IOCTL_STORAGE_QUERY_PROPERTY: {

        // Validate the query
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: StorageQueryProperty\n"));

        query = Irp->AssociatedIrp.SystemBuffer;

        if(irpStack->Parameters.DeviceIoControl.InputBufferLength <
           sizeof(STORAGE_PROPERTY_QUERY)) {

            status = Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, 0);
            break;
        }

        status = TrueffsQueryProperty(deviceExtension, Irp);
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: QueryProperty returned status %Xh\n", status));
        break;
        }

      case IOCTL_SCSI_GET_DUMP_POINTERS:

          DebugLogEvent(DeviceObject->DriverObject, 300);
          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: ScsiGetDumpPointers\n"));

          if (Fdo) {
            status = Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, 0);
            return status;
          }
          if (Irp->RequestorMode != KernelMode) {
              status = Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;

          } else if (irpStack->Parameters.DeviceIoControl.OutputBufferLength
                    < sizeof(DUMP_POINTERS)) {
              status = Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;

          } else {
              PCRASHDUMP_INIT_DATA dumpInitData;

              dumpInitData = ExAllocatePoolWithTag (NonPagedPool, sizeof (CRASHDUMP_INIT_DATA), TFFSPORT_POOL_TAG);
              if (dumpInitData) {
                  PDUMP_POINTERS dumpPointers;
                  dumpPointers = (PDUMP_POINTERS)Irp->AssociatedIrp.SystemBuffer;

                  RtlZeroMemory (dumpInitData, sizeof (CRASHDUMP_INIT_DATA));
                  dumpInitData->cdFdoExtension = pdoExtension->Pext;
                  dumpPointers->AdapterObject      = NULL;
                  dumpPointers->MappedRegisterBase = NULL;
                  dumpPointers->DumpData           = dumpInitData;
                  dumpPointers->CommonBufferVa     = NULL;
                  dumpPointers->CommonBufferPa.QuadPart = 0;
                  dumpPointers->CommonBufferSize      = 0;
                  dumpPointers->DeviceObject          = pdoExtension->DeviceObject;
                  dumpPointers->AllocateCommonBuffers = FALSE;

                  status = Irp->IoStatus.Status = STATUS_SUCCESS;
                  Irp->IoStatus.Information = sizeof(DUMP_POINTERS);
              } else {
                  status = Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
              }
          }
          IoCompleteRequest(Irp, 0);
          break;
            case IOCTL_TFFSFL_UNIQUE_ID:
                    DebugLogEvent(DeviceObject->DriverObject, 200);
          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsGetUniqueId\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: TffsGetUniqueId Completed\n"));
                    Irp->IoStatus.Status = status;
          break;

            case IOCTL_TFFS_FORMAT_PHYSICAL_DRIVE:
                    DebugLogEvent(DeviceObject->DriverObject, 200);
          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_FORMAT_PHYSICAL_DRIVE\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: MOTIR: IOCTL_TFFS_FORMAT_PHYSICAL_DRIVE Completed\n"));
                    Irp->IoStatus.Status = status;
          break;

    #ifdef HW_PROTECTION
            case IOCTL_TFFS_BDTL_HW_PROTECTION:
                    DebugLogEvent(DeviceObject->DriverObject, 200);
          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_BDTL_HW_PROTECTION\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: MOTIR: IOCTL_TFFS_BDTL_HW_PROTECTION Completed\n"));
                    Irp->IoStatus.Status = status;
          break;
            case IOCTL_TFFS_BINARY_HW_PROTECTION:
                    DebugLogEvent(DeviceObject->DriverObject, 200);
          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_BINARY_HW_PROTECTION\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: MOTIR: IOCTL_TFFS_BINARY_HW_PROTECTION Completed\n"));
                    Irp->IoStatus.Status = status;
          break;
    #endif /*HW_PROTECTION*/
    #ifdef HW_OTP
            case IOCTL_TFFS_OTP:
                    DebugLogEvent(DeviceObject->DriverObject, 200);
          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_OTP\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: MOTIR: IOCTL_TFFS_OTP Completed\n"));
                    Irp->IoStatus.Status = status;
          break;
    #endif /*HW_OTP*/
    #ifdef WRITE_EXB_IMAGE
            case IOCTL_TFFS_PLACE_EXB_BY_BUFFER:
                    DebugLogEvent(DeviceObject->DriverObject, 200);
          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_PLACE_EXB_BY_BUFFER\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: MOTIR: IOCTL_TFFS_PLACE_EXB_BY_BUFFER Completed\n"));
                    Irp->IoStatus.Status = status;
          break;
    #endif /*WRITE_EXB_IMAGE*/
            case IOCTL_TFFS_DEEP_POWER_DOWN_MODE:
                    DebugLogEvent(DeviceObject->DriverObject, 200);
          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_DEEP_POWER_DOWN_MODE\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: MOTIR: IOCTL_TFFS_DEEP_POWER_DOWN_MODE Completed\n"));
                    Irp->IoStatus.Status = status;
          break;
            case IOCTL_TFFSFL_INQUIRE_CAPABILITIES:
                    DebugLogEvent(DeviceObject->DriverObject, 200);
          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsGetInquireCapabilities\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: MOTIR: TffsGetInquireCapabilities Completed\n"));
                    Irp->IoStatus.Status = status;
          break;

            case IOCTL_TFFS_GET_INFO:           // User TFFS IOCTL - FL_GET_INFO

                    DebugLogEvent(DeviceObject->DriverObject, 200);
          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsGetInfo\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: TffsGetInfo start get info\n"));
                    Irp->IoStatus.Status = status;
          break;

      case IOCTL_TFFS_DEFRAGMENT:       // User TFFS IOCTL - FL_DEFRAGMENT

          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsDefragment\n"));
          status = QueueIrpToThread(Irp, deviceExtension);
          Irp->IoStatus.Status = status;
          break;
#ifdef VERIFY_VOLUME
            case IOCTL_TFFS_VERIFY_VOLUME:

          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsVerifyVolume\n"));
          status = QueueIrpToThread(Irp, deviceExtension);
          Irp->IoStatus.Status = status;
          break;
#endif VERIFY_VOLUME

      case IOCTL_TFFS_WRITE_PROTECT:    // User TFFS IOCTL - FL_WRITE_PROTECT

          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsWriteProtect\n"));
          status = QueueIrpToThread(Irp, deviceExtension);
          Irp->IoStatus.Status = status;
          break;

      case IOCTL_TFFS_MOUNT_VOLUME:     // User TFFS IOCTL - FL_MOUNT_VOLUME

          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsMountVolume\n"));
          status = QueueIrpToThread(Irp, deviceExtension);
          Irp->IoStatus.Status = status;
          break;

      case IOCTL_TFFS_FORMAT_VOLUME:    // User TFFS IOCTL - FL_FORMAT_VOLUME

          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsFormatVolume\n"));
          status = QueueIrpToThread(Irp, deviceExtension);
          Irp->IoStatus.Status = status;
          break;

      case IOCTL_TFFS_BDK_OPERATION:    // User TFFS IOCTL - FL_BDK_OPERATION

          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_BDK_OPERATION\n"));
                    status = QueueIrpToThread(Irp, deviceExtension);
                    Irp->IoStatus.Status = status;
                    break;

      case IOCTL_TFFS_DELETE_SECTORS:   // User TFFS IOCTL - FL_DELETE_SECTORS

          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsDeleteSectors\n"));
                    status = QueueIrpToThread(Irp, deviceExtension);
                    Irp->IoStatus.Status = status;
                    break;
        case IOCTL_TFFS_CUSTOMER_ID:            // User TFFS IOCTL - FL_IOCTL_NUMBER_OF_PARTITIONS

          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_CUSTOMER_ID\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : start IOCTL_TFFS_CUSTOMER_ID\n"));
                    Irp->IoStatus.Status = status;
          break;

            case IOCTL_TFFS_EXTENDED_WRITE_IPL:         // User TFFS IOCTL -

          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_EXTENDED_WRITE_IPL\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : start IOCTL_TFFS_EXTENDED_WRITE_IPL\n"));
                    Irp->IoStatus.Status = status;
          break;

#ifdef ENVIRONMENT_VARS
            case IOCTL_TFFS_EXTENDED_ENVIRONMENT_VARIABLES:         // User TFFS IOCTL -

          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_EXTENDED_ENVIRONMENT_VARIABLES\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : start IOCTL_TFFS_EXTENDED_ENVIRONMENT_VARIABLES\n"));
                    Irp->IoStatus.Status = status;
          break;
#endif /* ENVIRONMENT_VARS */

            case IOCTL_TFFS_NUMBER_OF_PARTITIONS:           // User TFFS IOCTL - FL_IOCTL_NUMBER_OF_PARTITIONS

          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: FL_IOCTL_NUMBER_OF_PARTITIONS\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : start FL_IOCTL_NUMBER_OF_PARTITIONS\n"));
                    Irp->IoStatus.Status = status;
          break;

/*      case IOCTL_DISK_IS_WRITABLE:
            TffsDebugPrint((TFFS_DEB_ERROR,"#$$%^%$%#%$#%#%$#%#%#%#%#%#%#%$#%#%\n"));
            status = Irp->IoStatus.Status = STATUS_MEDIA_WRITE_PROTECTED;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, 0);
            break;
            */
      default:

        TffsDebugPrint((TFFS_DEB_WARN,"Trueffs: DeviceControl: not suported\n"));
        status = Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, 0);
        break;

    }

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: exit with status %Xh\n", status));

    return status;
}

NTSTATUS
TrueffsQueryProperty(
    IN PDEVICE_EXTENSION deviceExtension,
    IN PIRP QueryIrp
    )

/*++

Routine Description:

    This routine will handle a property query request.

Arguments:

    DeviceObject - a pointer to the device object being queried

    QueryIrp - a pointer to the irp for the query

Return Value:

    STATUS_SUCCESS if the query was successful

    other error values as applicable

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(QueryIrp);
    PSTORAGE_PROPERTY_QUERY query = QueryIrp->AssociatedIrp.SystemBuffer;
    STORAGE_DEVICE_DESCRIPTOR deviceDescriptor;
    STORAGE_ADAPTER_DESCRIPTOR adapterDescriptor;
    PSTORAGE_DEVICE_DESCRIPTOR storageDeviceDescriptor;
    ULONG outBufferSize;
    ULONG numBytesToCopy;
    PUCHAR outBuffer;
    PUCHAR outBufferBegin;
    CHAR vendorString[] = VENDORSTRING;
    CHAR productString[] = PRODUCTSTRING;
    CHAR revisionString[] = REVISIONSTRING;
    CHAR serialString[] = SERIALSTRING;
    NTSTATUS status;


    if(query->QueryType >= PropertyMaskQuery) {

        status = STATUS_NOT_IMPLEMENTED;
        QueryIrp->IoStatus.Status = status;
        QueryIrp->IoStatus.Information = 0;
        IoCompleteRequest(QueryIrp, IO_NO_INCREMENT);
        return status;
    }

    if(query->QueryType == PropertyExistsQuery) {

        status = STATUS_SUCCESS;
        QueryIrp->IoStatus.Status = status;
        IoCompleteRequest(QueryIrp, IO_DISK_INCREMENT);
        return status;
    }

    switch(query->PropertyId) {

        case StorageDeviceProperty: {

            outBufferSize = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
            RtlZeroMemory (&deviceDescriptor, sizeof(STORAGE_DEVICE_DESCRIPTOR));

            //
            // The buffer needs to be large enough to hold the base
            // structure and  all  the  strings [ null terminated ]
            //
            deviceDescriptor.Version = sizeof(STORAGE_DEVICE_DESCRIPTOR);
            deviceDescriptor.Size    = sizeof(STORAGE_DEVICE_DESCRIPTOR) + 1 + VENDORSTRINGSIZE + 1 + PRODUCTSTRINGSIZE + 1 + REVISIONSTRINGSIZE + 1 + SERIALSTRINGSIZE + 1;

            deviceDescriptor.DeviceType = deviceExtension->ScsiDeviceType;

            if (deviceExtension->removableMedia)
            {
                deviceDescriptor.RemovableMedia = TRUE;
            }

            deviceDescriptor.BusType = BusTypeAta;

            if (outBufferSize >= deviceDescriptor.Size)
            {
                numBytesToCopy = deviceDescriptor.Size;
            }
            else
            {
                numBytesToCopy = outBufferSize;
            }

            QueryIrp->IoStatus.Information = numBytesToCopy;
            outBuffer = QueryIrp->AssociatedIrp.SystemBuffer;
            outBufferBegin = outBuffer;
            status = STATUS_SUCCESS;

            storageDeviceDescriptor = (PSTORAGE_DEVICE_DESCRIPTOR) QueryIrp->AssociatedIrp.SystemBuffer;

            if (numBytesToCopy > sizeof(STORAGE_DEVICE_DESCRIPTOR))
            {
                RtlCopyMemory (outBuffer, &deviceDescriptor, sizeof(STORAGE_DEVICE_DESCRIPTOR));

                numBytesToCopy -= sizeof(STORAGE_DEVICE_DESCRIPTOR);
                outBuffer      += sizeof(STORAGE_DEVICE_DESCRIPTOR);
            }
            else
            {
                RtlCopyMemory (outBuffer, &deviceDescriptor, numBytesToCopy);
                break;
            }

            storageDeviceDescriptor->VendorIdOffset = (ULONG) (outBuffer - outBufferBegin);

            if (numBytesToCopy > VENDORSTRINGSIZE + 1)
            {
                RtlCopyMemory (outBuffer, vendorString, VENDORSTRINGSIZE);
                outBuffer[VENDORSTRINGSIZE] = '\0';

                numBytesToCopy -= VENDORSTRINGSIZE + 1;
                outBuffer      += VENDORSTRINGSIZE + 1;
            }
            else
            {
                RtlCopyMemory (outBuffer, vendorString, numBytesToCopy);
                break;
            }

            storageDeviceDescriptor->ProductIdOffset = (ULONG) (outBuffer - outBufferBegin);

            if (numBytesToCopy > PRODUCTSTRINGSIZE + 1)
            {
                RtlCopyMemory (outBuffer, productString, PRODUCTSTRINGSIZE);
                outBuffer[PRODUCTSTRINGSIZE] = '\0';

                numBytesToCopy -= PRODUCTSTRINGSIZE + 1;
                outBuffer      += PRODUCTSTRINGSIZE + 1;
            }
            else
            {
                RtlCopyMemory (outBuffer, productString, numBytesToCopy);
                break;
            }

            storageDeviceDescriptor->ProductRevisionOffset = (ULONG) (outBuffer - outBufferBegin);

            if (numBytesToCopy > REVISIONSTRINGSIZE + 1)
            {
                RtlCopyMemory (outBuffer, revisionString, REVISIONSTRINGSIZE);
                outBuffer[REVISIONSTRINGSIZE] = '\0';

                numBytesToCopy -= REVISIONSTRINGSIZE + 1;
                outBuffer      += REVISIONSTRINGSIZE + 1;
            }
            else
            {
                RtlCopyMemory (outBuffer, revisionString, numBytesToCopy);
                break;
            }

            storageDeviceDescriptor->SerialNumberOffset = (ULONG) (outBuffer - outBufferBegin);

            if (numBytesToCopy > SERIALSTRINGSIZE + 1)
            {
                RtlCopyMemory (outBuffer, serialString, SERIALSTRINGSIZE);
                outBuffer[SERIALSTRINGSIZE] = '\0';
            }
            else
            {
                RtlCopyMemory (outBuffer, serialString, numBytesToCopy);
            }

            break;
        }

        case StorageAdapterProperty: {

            RtlZeroMemory (&adapterDescriptor, sizeof(adapterDescriptor));

            adapterDescriptor.Version                = sizeof (STORAGE_ADAPTER_DESCRIPTOR);
            adapterDescriptor.Size                   = sizeof (STORAGE_ADAPTER_DESCRIPTOR);
            adapterDescriptor.MaximumTransferLength  = MAX_TRANSFER_SIZE_PER_SRB;
            adapterDescriptor.MaximumPhysicalPages   = 0xffffffff;
            adapterDescriptor.AlignmentMask          = 0x1;
            adapterDescriptor.AdapterUsesPio         = TRUE;
            adapterDescriptor.AdapterScansDown       = FALSE;
            adapterDescriptor.CommandQueueing        = FALSE;
            adapterDescriptor.AcceleratedTransfer    = FALSE;
            adapterDescriptor.BusType                = BusTypeAta;
            adapterDescriptor.BusMajorVersion        = 1;
            adapterDescriptor.BusMinorVersion        = 0;

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                                sizeof(STORAGE_ADAPTER_DESCRIPTOR)) {

                outBufferSize = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

            } else {

                outBufferSize = sizeof(STORAGE_ADAPTER_DESCRIPTOR);
            }

            RtlCopyMemory (QueryIrp->AssociatedIrp.SystemBuffer,
                           &adapterDescriptor,
                           outBufferSize);

            QueryIrp->IoStatus.Information = outBufferSize;
            status = STATUS_SUCCESS;
            break;
        }

        default: {

            status = STATUS_NOT_IMPLEMENTED;
            QueryIrp->IoStatus.Information = 0;
            break;
        }
    }

    QueryIrp->IoStatus.Status = status;
    IoCompleteRequest(QueryIrp, IO_DISK_INCREMENT);

    return status;
}


NTSTATUS
TrueffsCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    create and close routine.  This is called by the I/O system
    when the device is opened or closed.

Arguments:

    DeviceObject - Pointer to device object
    Irp - IRP involved.

Return Value:

    STATUS_SUCCESS.

--*/

{
    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: CreateClose\n"));
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;

}


NTSTATUS
TrueffsPnpDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION  deviceExtension;
    PPDO_EXTENSION pdoExtension = NULL;
    PDEVICE_EXTENSION_HEADER devExtension;
    NTSTATUS status;
    KIRQL cIrql;
    KEVENT event;
    BOOLEAN Fdo = FALSE;
    BOOLEAN processHeldRequests = FALSE;

    devExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    if (IS_FDO(devExtension))
    {
        deviceExtension = DeviceObject->DeviceExtension;
        Fdo = TRUE;
    }
    else
    {
        pdoExtension = DeviceObject->DeviceExtension;
        deviceExtension = pdoExtension->Pext;
    }

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl: Function %Xh %cDO.\n",irpStack->MinorFunction, Fdo ? 'F':'P'));

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    switch (irpStack->MinorFunction)
    {

    case IRP_MN_START_DEVICE:

        TffsDebugPrint((TFFS_DEB_INFO, "Trueffs: PnpDeviceControl: START_DEVICE\n"));

        if (Fdo)
        {
            KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
            deviceExtension->DeviceFlags |= DEVICE_FLAG_STOPPED;
            if (deviceExtension->DeviceFlags & DEVICE_FLAG_STARTED)
            {
                processHeldRequests = TRUE;
            }
            KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

            status = TrueffsStartDevice(deviceExtension, irpStack->Parameters.StartDevice.AllocatedResourcesTranslated, TRUE);

            if (NT_SUCCESS(status))
            {
                //
                // Forward this request down synchronously, so that the lower drivers can be started
                //
                IoCopyCurrentIrpStackLocationToNext(Irp);
                status = TrueffsCallDriverSync(deviceExtension->LowerDeviceObject, Irp);

                if (NT_SUCCESS(status))
                {
                    status = TrueffsMountMedia(deviceExtension);

                    KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
                    deviceExtension->DeviceFlags &= ~DEVICE_FLAG_STOPPED;
                    deviceExtension->DeviceFlags |=  DEVICE_FLAG_STARTED;
                    KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

                    if (processHeldRequests && !KeReadStateSemaphore(&deviceExtension->requestSemaphore))
                    {
                        KeReleaseSemaphore(&deviceExtension->requestSemaphore, (KPRIORITY) 0, 1, FALSE);
                    }
                }
            }

            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
        else
        {
            status = STATUS_SUCCESS;

            if (!pdoExtension->CrashDumpPathCount)
            {
                DEVICE_POWER_STATE devicePowerState = PowerDeviceD3;

                pdoExtension->IdleCounter = PoRegisterDeviceForIdleDetection(pdoExtension->DeviceObject,
                                                                             DEVICE_DEFAULT_IDLE_TIMEOUT,
                                                                             DEVICE_DEFAULT_IDLE_TIMEOUT,
                                                                             devicePowerState);
            }

            KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
            deviceExtension->DeviceFlags &= ~DEVICE_FLAG_CHILD_REMOVED;
            KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

            TrueffsWmiRegister ((PDEVICE_EXTENSION_HEADER)pdoExtension);

            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp,IO_NO_INCREMENT);
        }
        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl: QUERY_STOP_DEVICE\n"));

        status = STATUS_SUCCESS;

        if (Fdo)
        {
            if (deviceExtension->PagingPathCount || deviceExtension->CrashDumpPathCount)
            {
                status = STATUS_UNSUCCESSFUL;
            }
        }
        else
        {
            if (pdoExtension->PagingPathCount || pdoExtension->CrashDumpPathCount)
            {
                status = STATUS_UNSUCCESSFUL;
            }
        }

        if (!NT_SUCCESS(status))
        {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp,IO_NO_INCREMENT);

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl: Failing QUERY_STOP: we are in PagingPath or CrashDumpPath\n"));
            break;
        }

        KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
        deviceExtension->DeviceFlags |= DEVICE_FLAG_QUERY_STOP_REMOVE;
        KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

        if (Fdo)
        {
            if (deviceExtension->TffsportThreadObject)
            {
                KeWaitForSingleObject(&deviceExtension->PendingIRPEvent, Executive, KernelMode, FALSE, NULL);
            }

            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);
        }
        else
        {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp,IO_NO_INCREMENT);
        }
        break;

    case IRP_MN_STOP_DEVICE:

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl: STOP_DEVICE\n"));

        status = STATUS_SUCCESS;

        if (Fdo)
        {
            TrueffsStopRemoveDevice(deviceExtension);

            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);

            KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
            deviceExtension->DeviceFlags |= DEVICE_FLAG_STOPPED;
            deviceExtension->DeviceFlags |= DEVICE_FLAG_QUERY_STOP_REMOVE;
            KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);
        }
        else
        {
            DEVICE_POWER_STATE devicePowerState = PowerDeviceD3;

            if (pdoExtension->IdleCounter)
            {
                PoRegisterDeviceForIdleDetection(pdoExtension->DeviceObject, 0, 0, devicePowerState);
                pdoExtension->IdleCounter = NULL;
            }

            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp,IO_NO_INCREMENT);
        }
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl: QUERY_REMOVE_DEVICE\n"));

        status = STATUS_SUCCESS;

        if (Fdo)
        {
            if (deviceExtension->PagingPathCount || deviceExtension->CrashDumpPathCount)
            {
                status = STATUS_UNSUCCESSFUL;
            }
        }
        else
        {
            if (pdoExtension->PagingPathCount || pdoExtension->CrashDumpPathCount)
            {
                status = STATUS_UNSUCCESSFUL;
            }
        }

        if (!NT_SUCCESS(status))
        {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp,IO_NO_INCREMENT);

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl: Failing QUERY_REMOVE: we are in PagingPath or CrashDumpPath\n"));
            break;
        }

        //
        // We're not going to queue irps during remove device
        // KLUDGE
        //
        //
        // KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
        // deviceExtension->DeviceFlags |= DEVICE_FLAG_QUERY_STOP_REMOVE;
        // KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);
        //

        if (Fdo)
        {
            // No need to wait for the thread to become idle
            // KLUDGE
            // if (deviceExtension->DeviceFlags & DEVICE_FLAG_THREAD) {
            //    KeWaitForSingleObject(&deviceExtension->PendingIRPEvent,
            //                            Executive, KernelMode, FALSE, NULL);
            // }
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);
        }
        else
        {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp,IO_NO_INCREMENT);
        }
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl: CANCEL_STOP_DEVICE\n"));

        status = STATUS_SUCCESS;

        if (Fdo)
        {
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);
        }
        else
        {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }

        KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
        deviceExtension->DeviceFlags &= ~DEVICE_FLAG_QUERY_STOP_REMOVE;
        KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

        if (!KeReadStateSemaphore(&deviceExtension->requestSemaphore))
        {
            KeReleaseSemaphore(&deviceExtension->requestSemaphore,(KPRIORITY) 0, 1, FALSE);
        }
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl: CANCEL_REMOVE_DEVICE\n"));

        status = STATUS_SUCCESS;

        if (Fdo)
        {
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);
        }
        else
        {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }

        //
        // This flas was never set by QUERY_REMOVE
        // due to the KLUDGE we added, for not queuing IRPS's during QUERY_REMOVE
        //
        // KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
        // deviceExtension->DeviceFlags &= ~DEVICE_FLAG_QUERY_STOP_REMOVE;
        // KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

        if (!KeReadStateSemaphore(&deviceExtension->requestSemaphore))
        {
            KeReleaseSemaphore(&deviceExtension->requestSemaphore,(KPRIORITY) 0, 1, FALSE);
        }
        break;

    case IRP_MN_REMOVE_DEVICE:

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl: REMOVE_DEVICE\n"));

        status = STATUS_SUCCESS;

        if (Fdo)
        {
            if (!(deviceExtension->DeviceFlags & DEVICE_FLAG_REMOVED))
            {
               // Set the QUERY_STOP_REMOVE FLAG
               // Part of the KLUDGE, we had removed this from the QUERY_REMOVE IRP
               // processing
               KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
               deviceExtension->DeviceFlags |= DEVICE_FLAG_QUERY_STOP_REMOVE;
               KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

               // Now wait for the thread to complete any work its doing
               // Better wait for the thread to complete the current IRP it may be
               // working on
               //
               // if (deviceExtension->DeviceFlags & DEVICE_FLAG_THREAD) {
               //
               if (deviceExtension->TffsportThreadObject)
               {
                   KeWaitForSingleObject(&deviceExtension->PendingIRPEvent, Executive, KernelMode, FALSE, NULL);
               }

               KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
               deviceExtension->DeviceFlags |=  DEVICE_FLAG_REMOVED;
               deviceExtension->DeviceFlags &= ~DEVICE_FLAG_QUERY_STOP_REMOVE;
               deviceExtension->DeviceFlags &= ~DEVICE_FLAG_HOLD_IRPS;
               KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

               while (ExInterlockedRemoveHeadList(&deviceExtension->listEntry, &deviceExtension->listSpinLock))
               {
                   ;
               }

               KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
               deviceExtension->threadReferenceCount = 0;
               KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

               if (!KeReadStateSemaphore(&deviceExtension->requestSemaphore))
               {
                  KeReleaseSemaphore(&deviceExtension->requestSemaphore,(KPRIORITY) 0,1,FALSE);
               }

               //
               // if (deviceExtension->DeviceFlags & DEVICE_FLAG_THREAD) {
               //
               if (deviceExtension->TffsportThreadObject)
               {
                   KeWaitForSingleObject(deviceExtension->TffsportThreadObject, Executive, KernelMode, FALSE, NULL);
                   ObDereferenceObject(deviceExtension->TffsportThreadObject);
                   deviceExtension->TffsportThreadObject = NULL;
               }

               TrueffsStopRemoveDevice(deviceExtension);
            }

            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);

            //
            // Clean up resources here
            //
            if (deviceExtension->ChildPdo != NULL)
            {
                IoDeleteDevice(deviceExtension->ChildPdo);
            }

            TrueffsDeleteSymblicLinks(deviceExtension);
            IoDetachDevice(deviceExtension->LowerDeviceObject);
            IoDeleteDevice(DeviceObject);
        }
        else
        {
            if (!(deviceExtension->DeviceFlags & DEVICE_FLAG_CHILD_REMOVED))
            {
                DEVICE_POWER_STATE devicePowerState;

                KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
                deviceExtension->DeviceFlags |= DEVICE_FLAG_CHILD_REMOVED;
                deviceExtension->DeviceFlags &= ~DEVICE_FLAG_QUERY_STOP_REMOVE;
                deviceExtension->DeviceFlags &= ~DEVICE_FLAG_HOLD_IRPS;
                KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

                while (ExInterlockedRemoveHeadList(&deviceExtension->listEntry, &deviceExtension->listSpinLock))
                {
                    ;
                }

                devicePowerState = PowerDeviceD3;

                if (pdoExtension->IdleCounter)
                {
                    PoRegisterDeviceForIdleDetection(pdoExtension->DeviceObject, 0, 0, devicePowerState);
                    pdoExtension->IdleCounter = NULL;
                }

                TrueffsWmiDeregister((PDEVICE_EXTENSION_HEADER)pdoExtension);
            }

            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp,IO_NO_INCREMENT);
        }
        break;

    case IRP_MN_SURPRISE_REMOVAL:

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl: SURPRISE_REMOVAL\n"));

        status = STATUS_SUCCESS;

        if (Fdo)
        {
            KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
            deviceExtension->DeviceFlags |= DEVICE_FLAG_REMOVED;
            deviceExtension->DeviceFlags &= ~DEVICE_FLAG_QUERY_STOP_REMOVE;
            deviceExtension->DeviceFlags &= ~DEVICE_FLAG_HOLD_IRPS;
            KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

            while (ExInterlockedRemoveHeadList(&deviceExtension->listEntry,&deviceExtension->listSpinLock))
            {
                ;
            }

            KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
            deviceExtension->threadReferenceCount = 0;
            KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

            if (!KeReadStateSemaphore(&deviceExtension->requestSemaphore))
            {
                KeReleaseSemaphore(&deviceExtension->requestSemaphore,(KPRIORITY) 0, 1, FALSE);
            }

            //
            // if (deviceExtension->DeviceFlags & DEVICE_FLAG_THREAD) {
            //
            if (deviceExtension->TffsportThreadObject)
            {
                KeWaitForSingleObject(deviceExtension->TffsportThreadObject, Executive, KernelMode, FALSE, NULL);
                ObDereferenceObject(deviceExtension->TffsportThreadObject);
                deviceExtension->TffsportThreadObject = NULL;
            }

            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);

            TrueffsStopRemoveDevice(deviceExtension);
            TrueffsDeleteSymblicLinks(deviceExtension);
        }
        else
        {
            DEVICE_POWER_STATE devicePowerState;

            IoInvalidateDeviceRelations(deviceExtension->MainPdo,BusRelations);

            KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
            deviceExtension->DeviceFlags |= DEVICE_FLAG_CHILD_REMOVED;
            KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

            devicePowerState = PowerDeviceD3;

            if (pdoExtension->IdleCounter)
            {
                PoRegisterDeviceForIdleDetection(pdoExtension->DeviceObject, 0, 0, devicePowerState);
                pdoExtension->IdleCounter = NULL;
            }

            TrueffsWmiDeregister((PDEVICE_EXTENSION_HEADER)pdoExtension);

            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp,IO_NO_INCREMENT);
        }
        break;

    case IRP_MN_QUERY_ID:

        status = TrueffsDeviceQueryId(DeviceObject, Irp, Fdo);
        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:

        status = TrueffsQueryDeviceRelations(DeviceObject, Irp, Fdo);
        break;

    case IRP_MN_QUERY_CAPABILITIES:

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl: QUERY_CAPABILITIES\n"));

        if (Fdo)
        {
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);
        }
        else
        {
            status = TrueffsDeviceQueryCapabilities(deviceExtension, irpStack->Parameters.DeviceCapabilities.Capabilities);

            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
        break;

    case IRP_MN_DEVICE_USAGE_NOTIFICATION:

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl: DEVICE_USAGE_NOTIFICATION, Type %Xh\n", irpStack->Parameters.UsageNotification.Type));

        if (Fdo)
        {
            PULONG deviceUsageCount = NULL;

            if (!(deviceExtension->DeviceFlags & DEVICE_FLAG_STARTED))
            {
                status = STATUS_DEVICE_NOT_READY;

                Irp->IoStatus.Status = status;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                break;
            }

            switch (irpStack->Parameters.UsageNotification.Type)
            {
                case DeviceUsageTypePaging:
                    deviceUsageCount = &deviceExtension->PagingPathCount;
                    break;

                case DeviceUsageTypeHibernation:
                    deviceUsageCount = &deviceExtension->HiberPathCount;
                    break;

                case DeviceUsageTypeDumpFile:
                    deviceUsageCount = &deviceExtension->CrashDumpPathCount;
                    break;

                default:
                    deviceUsageCount = NULL;
                    break;
            }

            //
            // Forward this request down synchronously, in case a lower driver wants to veto it
            //
            IoCopyCurrentIrpStackLocationToNext(Irp);
            status = TrueffsCallDriverSync(deviceExtension->LowerDeviceObject, Irp);

            if (NT_SUCCESS(status))
            {
                if (deviceUsageCount)
                {
                    IoAdjustPagingPathCount(deviceUsageCount, irpStack->Parameters.UsageNotification.InPath);
                }
            }

            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
        else
        {
            PULONG deviceUsageCount = NULL;

            if (pdoExtension)
            {
                PDEVICE_OBJECT targetDeviceObject;
                IO_STATUS_BLOCK  ioStatus = { 0 };

                switch (irpStack->Parameters.UsageNotification.Type)
                {
                    case DeviceUsageTypePaging:
                        deviceUsageCount = &pdoExtension->PagingPathCount;
                        break;

                    case DeviceUsageTypeHibernation:
                        deviceUsageCount = &pdoExtension->HiberPathCount;
                        break;

                    case DeviceUsageTypeDumpFile:
                        deviceUsageCount = &pdoExtension->CrashDumpPathCount;
                        break;

                    default:
                        deviceUsageCount = NULL;
                        break;
                }

                targetDeviceObject = IoGetAttachedDeviceReference(deviceExtension->DeviceObject);

                ioStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
                status = TrueffsSyncSendIrp(targetDeviceObject, irpStack, &ioStatus);

                ObDereferenceObject(targetDeviceObject);

                if (NT_SUCCESS(status))
                {
                    if (deviceUsageCount)
                    {
                        IoAdjustPagingPathCount(deviceUsageCount, irpStack->Parameters.UsageNotification.InPath);
                    }

                    if (irpStack->Parameters.UsageNotification.Type == DeviceUsageTypeDumpFile)
                    {

                        POWER_STATE powerState;
                        DEVICE_POWER_STATE devicePowerState = PowerDeviceD3;

                        //
                        // Reset the idle timeout to "forever"
                        //
                        pdoExtension->IdleCounter = PoRegisterDeviceForIdleDetection(pdoExtension->DeviceObject,
                                                                                     DEVICE_VERY_LONG_IDLE_TIMEOUT,
                                                                                     DEVICE_VERY_LONG_IDLE_TIMEOUT,
                                                                                     devicePowerState);
                        if (pdoExtension->IdleCounter)
                        {
                            PoSetDeviceBusy(pdoExtension->IdleCounter);
                        }

                        powerState.DeviceState = PowerDeviceD0;

                        PoRequestPowerIrp(pdoExtension->DeviceObject, IRP_MN_SET_POWER, powerState, NULL, NULL, NULL);
                    }
                }
            }
            else
            {

                status = STATUS_NO_SUCH_DEVICE;
            }

            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
        break;

    default:

        if (Fdo)
        {
            //
            // Forward this request down, in case a lower driver understands it
            //
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);
        }
        else
        {
            //
            // Complete this request without altering its status
            //
            status = Irp->IoStatus.Status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
        break;
    }

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl status %Xh\n", status));
    return status;
}


NTSTATUS
TrueffsSyncSendIrp (
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT OPTIONAL PIO_STATUS_BLOCK IoStatus
    )
{
    PIO_STACK_LOCATION  newIrpSp;
    PIRP                newIrp;
    KEVENT              event;
    NTSTATUS            status;

    newIrp = IoAllocateIrp (TargetDeviceObject->StackSize, FALSE);
    if (newIrp == NULL) {
        TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: SyncSendIrp: Unable to allocate an irp\n"));
        return STATUS_NO_MEMORY;
    }
    newIrpSp = IoGetNextIrpStackLocation(newIrp);
    RtlMoveMemory (newIrpSp, IrpSp, sizeof (*IrpSp));

    if (IoStatus) {
        newIrp->IoStatus.Status = IoStatus->Status;
    } else {
        newIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    IoSetCompletionRoutine (
        newIrp,
        TrueffsSyncSendIrpCompletionRoutine,
        &event,
        TRUE,
        TRUE,
        TRUE);
    status = IoCallDriver (TargetDeviceObject, newIrp);
    if (status == STATUS_PENDING) {

        status = KeWaitForSingleObject(&event,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);
    }
    status = newIrp->IoStatus.Status;
    if (IoStatus) {
        *IoStatus = newIrp->IoStatus;
    }
    IoFreeIrp (newIrp);
    return status;
}


NTSTATUS
TrueffsSyncSendIrpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PKEVENT event = Context;
    KeSetEvent(event, EVENT_INCREMENT,FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
TrueffsCallDriverSync(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(Irp, TrueffsCallDriverSyncCompletion, &event, TRUE, TRUE, TRUE);

    status = IoCallDriver(DeviceObject, Irp);

    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    status = Irp->IoStatus.Status;

    return status;
}


NTSTATUS
TrueffsCallDriverSyncCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PKEVENT event = (PKEVENT)Context;

    ASSERT(Irp->IoStatus.Status != STATUS_IO_TIMEOUT);

    KeSetEvent(event, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
TrueffsPowerControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_EXTENSION_HEADER devExtension;
    BOOLEAN Fdo = FALSE;
    NTSTATUS status;

    devExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    if (IS_FDO(devExtension))
    {
        deviceExtension = DeviceObject->DeviceExtension;
        Fdo = TRUE;
    }
    else
    {
        PPDO_EXTENSION pdoExtension = DeviceObject->DeviceExtension;
        deviceExtension = pdoExtension->Pext;
    }

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PowerControl: Function %Xh %cDO.\n", irpStack->MinorFunction,Fdo ? 'F':'P'));

    switch (irpStack->MinorFunction)
    {

    case IRP_MN_SET_POWER:

        if (Fdo)
        {
            status = TrueffsSetFdoPowerState(DeviceObject, Irp);
        }
        else
        {
            status = TrueffsSetPdoPowerState(DeviceObject, Irp);
        }
        break;

    case IRP_MN_QUERY_POWER:

        status = STATUS_SUCCESS;
        PoStartNextPowerIrp(Irp);

        if (Fdo)
        {
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(deviceExtension->LowerDeviceObject, Irp);
        }
        else
        {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
        break;

    default:

        PoStartNextPowerIrp(Irp);

        if (Fdo)
        {
            //
            // Forward this request down, in case a lower driver understands it
            //
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(deviceExtension->LowerDeviceObject, Irp);
        }
        else
        {
            //
            // Complete this request without altering its status
            //
            status = Irp->IoStatus.Status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
        break;
    }

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PowerControl status %Xh\n", status));
    return status;
}


NTSTATUS
TrueffsSetFdoPowerState (
                       IN PDEVICE_OBJECT DeviceObject,
                       IN OUT PIRP Irp
                       )
/*++

Routine Description

   Dispatches the IRP based on whether a system power state
   or device power state transition is requested

Arguments

   DeviceObject      - Pointer to the functional device object for the pcmcia controller
   Irp               - Pointer to the Irp for the power dispatch

Return value

   status

--*/
{
   PDEVICE_EXTENSION  fdoExtension;
   PIO_STACK_LOCATION irpStack;
   NTSTATUS           status = STATUS_SUCCESS;
   PFDO_POWER_CONTEXT context = NULL;
   BOOLEAN            passItDown;

   fdoExtension = DeviceObject->DeviceExtension;

   context = ExAllocatePoolWithTag (NonPagedPool, sizeof(FDO_POWER_CONTEXT), TFFSPORT_POOL_TAG);
   if (context == NULL) {

      status = STATUS_INSUFFICIENT_RESOURCES;
   } else {

      RtlZeroMemory (context, sizeof(FDO_POWER_CONTEXT));
      irpStack = IoGetCurrentIrpStackLocation (Irp);

      passItDown = TRUE;
      context->PowerType  = irpStack->Parameters.Power.Type;
      context->PowerState = irpStack->Parameters.Power.State;

      if (irpStack->Parameters.Power.Type == SystemPowerState) {

         if (fdoExtension->SystemPowerState == irpStack->Parameters.Power.State.SystemState) {

            // We are already in the given state
            passItDown = FALSE;
         }

      } else if (irpStack->Parameters.Power.Type == DevicePowerState) {

         if (fdoExtension->DevicePowerState != irpStack->Parameters.Power.State.DeviceState) {

            if (fdoExtension->DevicePowerState == PowerDeviceD0) {

               // getting out of D0 state, better call PoSetPowerState now
               PoSetPowerState (
                               DeviceObject,
                               DevicePowerState,
                               irpStack->Parameters.Power.State
                               );
            }

         } else {

            // We are already in the given state
            passItDown = FALSE;
         }
      } else {

          status = STATUS_INVALID_DEVICE_REQUEST;
      }
   }

   if (NT_SUCCESS(status) && passItDown) {

      if ((irpStack->Parameters.Power.Type == DevicePowerState) &&
          (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD3)) {

          // Getting out of D0 - cancel the timer
          if (timerWasStarted) {
              KeCancelTimer(&timerObject);
              timerWasStarted = FALSE;
          }
      }

      if (irpStack->Parameters.Power.Type == SystemPowerState) {

          //
          // When we get a System Power IRP (S IRP) the correct thing to do
          // is to request a D, and pass the S IRP as context to the D IRP
          // completion routine.  Once the D IRP completes we can pass
          // down the S IRP
          //

          POWER_STATE powerState;

          // Switch to the appropriate device power state
          if (context->PowerState.SystemState == PowerSystemWorking) {

              powerState.DeviceState = PowerDeviceD0;

          } else {

              // We don't need to take special care of leaving the device
              // in powered state in case of hibernation, because it cannot
              // be switched off. Since the device is always on it is enough
              // to send PowerDeviceD3 thus simulating power off.

              powerState.DeviceState = PowerDeviceD3;
          }

          // Transitioned to system state
          fdoExtension->SystemPowerState = context->PowerState.SystemState;

          // Request the IRP for D Power
          status = PoRequestPowerIrp (
              DeviceObject,
              IRP_MN_SET_POWER,
              powerState,
              TrueffsFdoDevicePowerIrpCompletionRoutine,
              Irp,
              NULL
              );

          if (NT_SUCCESS(status)) {
              status = STATUS_PENDING;
          }

          // In this case we should free the context pool because it wont
          // reach the completion callback routine
          ExFreePool(context);


      } else {

          //
          // Its a D irp, we just want to pass down (device power)
          //
          // Send the IRP to the pdo
          IoCopyCurrentIrpStackLocationToNext (Irp);

          IoSetCompletionRoutine(Irp,
                              TrueffsFdoPowerCompletionRoutine,
                              context,
                              TRUE,
                              TRUE,
                              TRUE);

          status = PoCallDriver(fdoExtension->LowerDeviceObject, Irp);

      }

      return (status);


   } else {

      // Unblock the power IRPs and complete the current IRP
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = status;
      PoStartNextPowerIrp (Irp);
      IoCompleteRequest(Irp, IO_NO_INCREMENT);

      if (context) {
         ExFreePool (context);
      }
      return status;
   }
}


NTSTATUS
TrueffsFdoDevicePowerIrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID contextIrp,
    IN PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description

    Completion routine for Device Power IRPS.  The context will be the S power IRP
    that was received, and we can now send down the stack

Parameters

    DeviceObject    -   Pointer to FDO for the controller
    Irp             -   Pointer to the D power irp which is completing
    context  -   Pointer to the S power irp that can now be sent down the stack

--*/
{
    PIRP                systemPowerIrp = (PIRP) contextIrp;
    PDEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    NTSTATUS            status;
    PFDO_POWER_CONTEXT  context = NULL;
    PIO_STACK_LOCATION  irpStack = NULL;

    if (!NT_SUCCESS(IoStatus->Status)) {
        // The D IRP is not allowed to fail
        ASSERT(0);
    }

    //
    // Allocate space for the context of the S IRP completion routine
    //
    context = ExAllocatePoolWithTag (NonPagedPool, sizeof(FDO_POWER_CONTEXT), TFFSPORT_POOL_TAG);
    if (context == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;

        // Unblock the power IRPs and complete the current IRP
        systemPowerIrp->IoStatus.Information = 0;
        systemPowerIrp->IoStatus.Status = status;
        PoStartNextPowerIrp (systemPowerIrp);
        IoCompleteRequest(systemPowerIrp, IO_NO_INCREMENT);

    } else {

        // Clear the memory we just allocated
        RtlZeroMemory (context, sizeof(FDO_POWER_CONTEXT));

        // Get current IRP Stack for S-IRP
        irpStack = IoGetCurrentIrpStackLocation (systemPowerIrp);
        ASSERT(irpStack);

        context->PowerType  = irpStack->Parameters.Power.Type;
        context->PowerState = irpStack->Parameters.Power.State;

        // The D IRP has completed, now we can send the S IRP down
        IoCopyCurrentIrpStackLocationToNext (systemPowerIrp);
        IoSetCompletionRoutine(systemPowerIrp,
                            TrueffsFdoPowerCompletionRoutine,
                            context,
                            TRUE,
                            TRUE,
                            TRUE);

        status = PoCallDriver(fdoExtension->LowerDeviceObject, systemPowerIrp);
    }

    return (status);
}


NTSTATUS
TrueffsFdoPowerCompletionRoutine (
                                IN PDEVICE_OBJECT DeviceObject,
                                IN PIRP Irp,
                                IN PVOID Context
                                )
/*++

Routine Description

   Completion routine for the power IRP sent down to the PDO for the
   controller. If we are getting out of a working system state,
   requests a power IRP to put the device in an appropriate device power state.

Parameters

   DeviceObject   -    Pointer to FDO for the controller
   Irp            -    Pointer to the IRP for the power request
   Context        -    Pointer to the FDO_POWER_CONTEXT which is
                       filled in when the IRP is passed down
Return Value

   Status

--*/
{
   PFDO_POWER_CONTEXT context = Context;
   BOOLEAN            callPoSetPowerState;
   PDEVICE_EXTENSION  fdoExtension;

   fdoExtension = DeviceObject->DeviceExtension;

   if ((NT_SUCCESS(Irp->IoStatus.Status))) {

      callPoSetPowerState = TRUE;

      if (context->PowerType == SystemPowerState) {
          // Do Nothing

      } else if (context->PowerType == DevicePowerState) {

         if (fdoExtension->DevicePowerState == PowerDeviceD0) {

            // PoSetPowerState is called before we get out of D0
            callPoSetPowerState = FALSE;

         }
         else if (context->PowerState.DeviceState == PowerDeviceD0) {

             // Getting back to D0, set the timer on
             startIntervalTimer();

         }
         fdoExtension->DevicePowerState = context->PowerState.DeviceState;
      } else {
          // How did we not get either a SystemPowerState or a DevicePowerState
          ASSERT(0);
      }

      if (callPoSetPowerState) {

         PoSetPowerState (
                         DeviceObject,
                         context->PowerType,
                         context->PowerState
                         );
      }

   }
   ExFreePool(Context);

   PoStartNextPowerIrp (Irp);
   return Irp->IoStatus.Status;
}


NTSTATUS
TrueffsSetPdoDevicePowerState( IN PDEVICE_OBJECT Pdo,
                           IN OUT PIRP Irp
                              )
{
   PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
   PDEVICE_EXTENSION deviceExtension;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   DEVICE_POWER_STATE newDevicePowerState;
   NTSTATUS status;
   BOOLEAN setPowerRequest, powerUp, powerUpParent;
   KIRQL cIrql;

   status = STATUS_SUCCESS;
   newDevicePowerState = irpStack->Parameters.Power.State.DeviceState;

   deviceExtension = pdoExtension->Pext;

   TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Transition to device power state: %d\n", newDevicePowerState));

   setPowerRequest = FALSE;
   powerUp = FALSE;
   powerUpParent=FALSE;

   if (pdoExtension->DevicePowerState == newDevicePowerState) {
      return STATUS_SUCCESS;
   }

   if (pdoExtension->DevicePowerState == PowerDeviceD0) {

      // Getting out of D0 -  Call PoSetPowerState first
      POWER_STATE newPowerState;

      newPowerState.DeviceState = newDevicePowerState;
      PoSetPowerState(Pdo,
                      DevicePowerState,
                      newPowerState);
   }

   if (newDevicePowerState == PowerDeviceD0 ||
       newDevicePowerState == PowerDeviceD1 ||
       newDevicePowerState == PowerDeviceD2) {

      if (pdoExtension->DevicePowerState == PowerDeviceD3) {
         // D3 --> D0, D1 or D2 .. Wake up
         powerUpParent = TRUE;
         setPowerRequest = TRUE;
         powerUp = TRUE;
      }
   }
   else {  /* newDevicePowerState == D3 */
      if (pdoExtension->DevicePowerState != PowerDeviceD3) {
        // We need to power down now.
        setPowerRequest=TRUE;
      }
   }

   if (setPowerRequest && NT_SUCCESS(status)) {
      // Parent might have to be powered up..
      if (powerUpParent) {
         status = TrueffsFdoChildRequestPowerUp(pdoExtension->Pext,
                                               pdoExtension,
                                               Irp);
      } else {

          if (powerUp) {
                            /* MDOC PLUS */
                            /*
              DOC2window *memWinPtr;
              memWinPtr = (DOC2window *) pdoExtension->Pext->pcmciaParams.windowBase;
              tffsWriteByte(memWinPtr->DOCcontrol, ASIC_RESET_MODE);
              tffsWriteByte(memWinPtr->DOCcontrol, ASIC_RESET_MODE);
              tffsWriteByte(memWinPtr->DOCcontrol, ASIC_NORMAL_MODE);
              tffsWriteByte(memWinPtr->DOCcontrol, ASIC_NORMAL_MODE);
                            */

              MDOCPwindow *memWinPtr;
              memWinPtr = (MDOCPwindow *) pdoExtension->Pext->pcmciaParams.windowBase;
                            tffsWriteByte(memWinPtr->DOCcontrol, (unsigned char)0x04);
                            tffsWriteByte(memWinPtr->DocCntConfirmReg, (unsigned char)0xfb);
                            tffsWriteByte(memWinPtr->DOCcontrol, (unsigned char)0x05);
                            tffsWriteByte(memWinPtr->DocCntConfirmReg, (unsigned char)0xfa);


              KeAcquireSpinLock(&pdoExtension->Pext->ExtensionDataSpinLock,&cIrql);
              pdoExtension->Pext->DeviceFlags &= ~DEVICE_FLAG_HOLD_IRPS;
              KeReleaseSpinLock(&pdoExtension->Pext->ExtensionDataSpinLock,cIrql);
                          if (!KeReadStateSemaphore(&pdoExtension->Pext->requestSemaphore)) {
                                  KeReleaseSemaphore(&pdoExtension->Pext->requestSemaphore,(KPRIORITY) 0,1,FALSE);
                          }
          } else {

              KeAcquireSpinLock(&pdoExtension->Pext->ExtensionDataSpinLock,&cIrql);
              pdoExtension->Pext->DeviceFlags |= DEVICE_FLAG_HOLD_IRPS;
              KeReleaseSpinLock(&pdoExtension->Pext->ExtensionDataSpinLock,cIrql);

              //
              // if (pdoExtension->Pext->DeviceFlags & DEVICE_FLAG_THREAD) {
              //
              if (deviceExtension->TffsportThreadObject) {
                KeWaitForSingleObject(&pdoExtension->Pext->PendingIRPEvent, Executive, KernelMode, FALSE, NULL);
              }
          }
      }
   }
   return status;
}


NTSTATUS
TrueffsSetPdoSystemPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS           status;
    PIO_STACK_LOCATION irpStack;
    PPDO_EXTENSION     pdoExtension;
    SYSTEM_POWER_STATE newSystemState;
    POWER_STATE        powerState;

    pdoExtension = DeviceObject->DeviceExtension;
    status = STATUS_SUCCESS;

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    newSystemState = irpStack->Parameters.Power.State.SystemState;

    if (pdoExtension->SystemPowerState != newSystemState) {
        if (pdoExtension->SystemPowerState == PowerSystemWorking) {

            // Getting out of working state.
            if ((newSystemState == PowerSystemHibernate) &&
                        pdoExtension->HiberPathCount) {

                // spin up for the hiber dump driver
                powerState.DeviceState = PowerDeviceD0;

            } else {

                // put the device to D3
                // Issue a D3 to top of my drive stack
                powerState.DeviceState = PowerDeviceD3;
            }
            status = PoRequestPowerIrp (
                         DeviceObject,
                         IRP_MN_SET_POWER,
                         powerState,
                         TrueffsPdoRequestPowerCompletionRoutine,
                         Irp,
                         NULL
                         );

            if (NT_SUCCESS(status)) {

                status = STATUS_PENDING;
            }
        } else {
            if (newSystemState == PowerSystemWorking) {
                powerState.DeviceState = PowerDeviceD0;
            } else {
                powerState.DeviceState = PowerDeviceD3;
            }

            status = PoRequestPowerIrp (
                        DeviceObject,
                        IRP_MN_SET_POWER,
                        powerState,
                        TrueffsPdoRequestPowerCompletionRoutine,
                        Irp,
                        NULL
                        );

            if (NT_SUCCESS(status)) {
                status = STATUS_PENDING;
            }
        }
    }
    return status;
}


NTSTATUS
TrueffsSetPdoPowerState(
                      IN PDEVICE_OBJECT Pdo,
                      IN OUT PIRP Irp
                      )
{
   NTSTATUS status;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

   IoMarkIrpPending(Irp);

   if (irpStack->Parameters.Power.Type == DevicePowerState) {
      status = TrueffsSetPdoDevicePowerState(Pdo, Irp);
   } else if (irpStack->Parameters.Power.Type == SystemPowerState) {
      status = TrueffsSetPdoSystemPowerState(Pdo, Irp);
   } else {
      status = STATUS_NOT_IMPLEMENTED;
   }

   if (status != STATUS_PENDING) {
      Irp->IoStatus.Status = status;
      TrueffsPdoCompletePowerIrp(Pdo, Irp);
   }
   return status;
}


VOID
TrueffsPdoCompletePowerIrp (
                          IN PDEVICE_OBJECT DeviceObject,
                          IN PIRP Irp
                          )
{
   PPDO_EXTENSION          pdoExtension;
   PDEVICE_EXTENSION       fdoExtension;
   PIO_STACK_LOCATION      irpStack;
   BOOLEAN                 callPoSetPowerState;

   irpStack = IoGetCurrentIrpStackLocation (Irp);
   pdoExtension = DeviceObject->DeviceExtension;
   fdoExtension = pdoExtension->Pext;

   if (NT_SUCCESS(Irp->IoStatus.Status)) {

      callPoSetPowerState = TRUE;

      Irp->IoStatus.Information = irpStack->Parameters.Power.State.DeviceState;

      if (irpStack->Parameters.Power.Type == SystemPowerState) {

         if (pdoExtension->SystemPowerState != irpStack->Parameters.Power.State.SystemState) {

            pdoExtension->SystemPowerState = Irp->IoStatus.Information;
         }

      } else { /* if (irpStack->Parameters.Power.Type == DevicePowerState) */

         if (pdoExtension->DevicePowerState == PowerDeviceD0) {

            // PoSetPowerState is called before we power down
            callPoSetPowerState = FALSE;
         }

         if (pdoExtension->DevicePowerState != irpStack->Parameters.Power.State.DeviceState) {
            if (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD3) {

               // tell parent that we just fell to sleep
               TrueffsFdoChildReportPowerDown(fdoExtension);
            }

            pdoExtension->DevicePowerState = Irp->IoStatus.Information;
         }
      }

      if (callPoSetPowerState) {

         // we didn't get out of device D0 state. calling PoSetPowerState now
         PoSetPowerState (
                         pdoExtension->DeviceObject,
                         irpStack->Parameters.Power.Type,
                         irpStack->Parameters.Power.State
                         );
      }

   }

   PoStartNextPowerIrp (Irp);
   IoCompleteRequest(Irp, IO_NO_INCREMENT);
}


VOID
TrueffsPdoRequestPowerCompletionRoutine(
                                      IN PDEVICE_OBJECT Pdo,
                                      IN UCHAR MinorFunction,
                                      IN POWER_STATE PowerState,
                                      IN PVOID Context,
                                      IN PIO_STATUS_BLOCK IoStatus
                                      )
{
   PIO_STACK_LOCATION irpStack;
   PIRP               irp = Context;

   irp->IoStatus.Status = IoStatus->Status;
   TrueffsPdoCompletePowerIrp (Pdo,irp);
   return;
}


NTSTATUS
TrueffsParentPowerUpCompletionRoutine(
                                    IN PVOID Context,
                                    IN NTSTATUS FdoStatus
                                    )
/*++

Routine Description

   Completion routine for powering up the controller.

Arguments

   Context   -  Context passed in - this is a pointer to the device extension of
                the disk which originally triggered the power-up of the controller

   FdoStatus - Status of the power up operation of the controller

Return Value

   status

--*/
{

   PPDO_EXTENSION pdoExtension = Context;
   PIRP           irp;
   NTSTATUS       status = FdoStatus;
   KIRQL cIrql;

   if (NT_SUCCESS(FdoStatus)) {

       // Parent woke up..
       /* MDOC PLUS */
    MDOCPwindow *memWinPtr;
        DOC2window *memDOC2000WinPtr;
        volatile  UCHAR chipId = 0;

        memDOC2000WinPtr = (DOC2window *) pdoExtension->Pext->pcmciaParams.windowBase;
        tffsWriteByte(memDOC2000WinPtr->DOCcontrol, ASIC_RESET_MODE);
        tffsWriteByte(memDOC2000WinPtr->DOCcontrol, ASIC_RESET_MODE);
        tffsWriteByte(memDOC2000WinPtr->DOCcontrol, ASIC_NORMAL_MODE);
        tffsWriteByte(memDOC2000WinPtr->DOCcontrol, ASIC_NORMAL_MODE);
        chipId = tffsReadByte(memDOC2000WinPtr->chipId);
        if((chipId == 0x20) || (chipId == 0x30)){

        }
        else{
             /* MDOC PLUS */
        memWinPtr = (MDOCPwindow *) pdoExtension->Pext->pcmciaParams.windowBase;
            tffsWriteByte(memWinPtr->DOCcontrol, (unsigned char)0x04);
            tffsWriteByte(memWinPtr->DocCntConfirmReg, (unsigned char)0xfb);
            tffsWriteByte(memWinPtr->DOCcontrol, (unsigned char)0x05);
            tffsWriteByte(memWinPtr->DocCntConfirmReg, (unsigned char)0xfa);
        }


         KeAcquireSpinLock(&pdoExtension->Pext->ExtensionDataSpinLock,&cIrql);
         pdoExtension->Pext->DeviceFlags &= ~DEVICE_FLAG_HOLD_IRPS;
         KeReleaseSpinLock(&pdoExtension->Pext->ExtensionDataSpinLock,cIrql);
     if (!KeReadStateSemaphore(&pdoExtension->Pext->requestSemaphore)) {
             KeReleaseSemaphore(&pdoExtension->Pext->requestSemaphore,(KPRIORITY) 0,1,FALSE);
     }
   }

   if ((irp = pdoExtension->PendingPowerIrp)!=NULL) {

        // This is the IRP (for the pdo) that originally caused us to power up the parent
        // Complete it now
        irp->IoStatus.Status = status;
        pdoExtension->PendingPowerIrp = NULL;
        TrueffsPdoCompletePowerIrp(pdoExtension->DeviceObject, irp);
   }
   return status;
}


NTSTATUS
TrueffsFdoChildRequestPowerUp (
                             IN PDEVICE_EXTENSION         FdoExtension,
                             IN PPDO_EXTENSION            PdoExtension,
                             IN PIRP                      Irp
                             )
/*++

Routine Description

   This routine is called whenever a disk needs to be powered up due to
   a device state change. This routine would then  check if the controller
   is powered down and if so, it would request a power IRP to power up the
   controller

Arguments

   FdoExtension   - Pointer to the device extension for the FDO of the
                    controller

   PdoExtension   - Pointer to the device extension for the PDO of the
                    disk. This is required so that this routine can
                    call a completion routine on behalf of the PDO when
                    the controller is powered up with the appropriate context

   Irp            - Irp that needs to be completed when the controller is
                    powered up

Return Value:

   status

--*/
{
   NTSTATUS    status;
   POWER_STATE powerState;


   status = STATUS_SUCCESS;

   if (InterlockedCompareExchange(&FdoExtension->NumberOfDisksPoweredUp, 0, 0) == 0) {

      // One of the children is coming out of sleep,
      // we need to power up the parent (the controller)
      powerState.DeviceState = PowerDeviceD0;

      // Passed in IRP needs to be completed after
      // parent powers up
      PdoExtension->PendingPowerIrp = Irp;

      status = PoRequestPowerIrp (FdoExtension->DeviceObject,
                                  IRP_MN_SET_POWER,
                                  powerState,
                                  TrueffsFdoChildRequestPowerUpCompletionRoutine,
                                  PdoExtension,          // Context
                                  NULL
                                 );
      if (!NT_SUCCESS(status)) {
         return status;
      }
      status = STATUS_PENDING;
   } else {
      InterlockedIncrement(&FdoExtension->NumberOfDisksPoweredUp);
      TrueffsParentPowerUpCompletionRoutine(
                                            PdoExtension,
                                            (NTSTATUS) STATUS_SUCCESS
                                            );
   }
   return status;
}


NTSTATUS
TrueffsFdoChildRequestPowerUpCompletionRoutine (
                                              IN PDEVICE_OBJECT       DeviceObject,
                                              IN UCHAR                MinorFunction,
                                              IN POWER_STATE          PowerState,
                                              IN PVOID                Context,
                                              IN PIO_STATUS_BLOCK     IoStatus
                                              )
/*++

Routine Description

   Completion routine for a request by a disk to power-up the parent controller.

Arguments

   DeviceObject   -  Pointer to the Fdo for the controller
   MinorFunction  -  Minor function of the IRP_MJ_POWER request
   PowerState     -  Power state requested (should be D0)
   Context        -  Context passed in to the completion routine
   IoStatus       -  Pointer to the status block which will contain
                     the returned status

Return Value:

   status

--*/
{
   PDEVICE_EXTENSION fdoExtension;
   fdoExtension = DeviceObject->DeviceExtension;

   if (NT_SUCCESS(IoStatus->Status)) {
      InterlockedIncrement(&fdoExtension->NumberOfDisksPoweredUp);
   }

   TrueffsParentPowerUpCompletionRoutine(
                                         Context,
                                         (NTSTATUS) IoStatus->Status
                                         );
   return IoStatus->Status;
}


VOID
TrueffsFdoChildReportPowerDown (
                              IN PDEVICE_EXTENSION FdoExtension
                              )
/*++

Routine Description

   This routine is called whenever a disk is powered down due to
   a device state change. This routine would then determine if ALL
   disks controlled by the controller are powered down, and  if
   so, it would request a power IRP to power the controller itself down

Arguments

   FdoExtension   - Pointer to the device extension for the FDO of the controller

Return Value:

   None

--*/
{
   POWER_STATE powerState;

   InterlockedDecrement(&FdoExtension->NumberOfDisksPoweredUp);

   if (InterlockedCompareExchange(&FdoExtension->NumberOfDisksPoweredUp, 0, 0) == 0) {

      // All the children are powered down, we can now power down
      // the parent (the controller)
      powerState.DeviceState = PowerDeviceD3;
      PoRequestPowerIrp (
                        FdoExtension->DeviceObject,
                        IRP_MN_SET_POWER,
                        powerState,
                        NULL,
                        NULL,
                        NULL
                        );
   }
   return;
}


NTSTATUS
TrueffsScsiRequests(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION_HEADER devExtension;
    PDEVICE_EXTENSION deviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    NTSTATUS status;
    KIRQL cIrql;

    devExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    if (IS_FDO(devExtension))
    {
        deviceExtension = DeviceObject->DeviceExtension;
    }
    else
    {
        PPDO_EXTENSION pdoExtension = DeviceObject->DeviceExtension;
        deviceExtension = pdoExtension->Pext;
    }

    //
    // Get a pointer to the scsi request block
    //
    srb = irpStack->Parameters.Scsi.Srb;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: ScsiRequests for %Xh device object, function %Xh\n", DeviceObject, srb->Function));

    if (deviceExtension->DeviceFlags & DEVICE_FLAG_REMOVED)
    {
        TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: ScsiRequests: Device does not exist\n"));

        status = STATUS_DEVICE_DOES_NOT_EXIST;
        srb->SrbStatus = SRB_STATUS_NO_DEVICE;

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);

        return status;
    }

    if (srb->Function == SRB_FUNCTION_CLAIM_DEVICE)
    {
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: ScsiRequests: ClaimDevice\n"));

        KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
        if (deviceExtension->DeviceFlags & DEVICE_FLAG_CLAIMED)
        {
            status = STATUS_DEVICE_BUSY;
            srb->SrbStatus = SRB_STATUS_BUSY;
        }
        else
        {
            deviceExtension->DeviceFlags |= DEVICE_FLAG_CLAIMED;
            srb->DataBuffer = DeviceObject;

            status = STATUS_SUCCESS;
            srb->SrbStatus = SRB_STATUS_SUCCESS;
        }
        KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);

        return status;
    }

    if (srb->Function == SRB_FUNCTION_RELEASE_DEVICE)
    {
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: ScsiRequests: ReleaseDevice\n"));

        KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
        deviceExtension->DeviceFlags &= ~DEVICE_FLAG_CLAIMED;
        KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

        status = STATUS_SUCCESS;
        srb->SrbStatus = SRB_STATUS_SUCCESS;

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);

        return status;

    }

    if ((srb->Function == SRB_FUNCTION_FLUSH_QUEUE) || (srb->Function == SRB_FUNCTION_FLUSH))
    {
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: ScsiRequests: Flush or FlushQueue\n"));

        srb->SrbStatus = SRB_STATUS_SUCCESS;
        status = STATUS_SUCCESS;

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);

        return STATUS_SUCCESS;
    }

    if (srb->Function == SRB_FUNCTION_RESET_BUS)
    {
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: ScsiRequests: ResetBus\n"));

        srb->SrbStatus = SRB_STATUS_SUCCESS;
        status = STATUS_SUCCESS;

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);

        return status;
    }

    if (srb->Function != SRB_FUNCTION_EXECUTE_SCSI)
    {
        TffsDebugPrint((TFFS_DEB_WARN,"Trueffs: ScsiRequests: unsupported function\n"));

        status = STATUS_NOT_SUPPORTED;
        srb->SrbStatus = SRB_STATUS_ERROR;

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);

        return status;
    }

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: ScsiRequests: ExecuteScsi\n"));

    IoMarkIrpPending(Irp);
    IoStartPacket(DeviceObject, Irp, NULL, NULL);

    return STATUS_PENDING;
}


VOID
TrueffsStartIo (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

Arguments:

    DeviceObject - Supplies pointer to Adapter device object.
    Irp - Supplies a pointer to an IRP.

Return Value:

    Nothing.

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;
    PDEVICE_EXTENSION_HEADER devExtension;
    PPDO_EXTENSION pdoExtension;
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS status;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo\n"));

    devExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;
    if (IS_FDO(devExtension)) {
        deviceExtension = DeviceObject->DeviceExtension;
        pdoExtension = deviceExtension->ChildPdo->DeviceExtension;
    }
    else {
        pdoExtension = DeviceObject->DeviceExtension;
        deviceExtension = pdoExtension->Pext;
    }

    if (deviceExtension->DeviceFlags & DEVICE_FLAG_REMOVED) {

        // we got REMOVE_DEVICE, we can't accept any more requests...
        TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: StartIo: Device does not exist\n"));
        status = STATUS_DEVICE_DOES_NOT_EXIST;
        srb->SrbStatus = SRB_STATUS_NO_DEVICE;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
        IoStartNextPacket(DeviceObject,FALSE);
        return;

    }

    status = QueueIrpToThread(Irp, deviceExtension);

    if (status != STATUS_PENDING) {
        TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: StartIo: QueueIrpToThread failed with status %Xh\n", status));
        Irp->IoStatus.Status = status;
        srb->SrbStatus = SRB_STATUS_ERROR;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return;
    }
    if (pdoExtension->IdleCounter) {

        PoSetDeviceBusy(pdoExtension->IdleCounter);
    }
    if (pdoExtension->DevicePowerState != PowerDeviceD0 &&
        pdoExtension->SystemPowerState == PowerSystemWorking) {

        // We are not powered up.
        // issue an power up
        POWER_STATE powerState;

        powerState.DeviceState = PowerDeviceD0;
        PoRequestPowerIrp (
                    pdoExtension->DeviceObject,
                    IRP_MN_SET_POWER,
                    powerState,
                    NULL,
                    NULL,
                    NULL
                    );
    }

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: Irp queued\n"));
    Irp->IoStatus.Status = STATUS_PENDING;
    srb->SrbStatus = SRB_STATUS_PENDING;
    IoStartNextPacket(DeviceObject,FALSE);
    return;
}


VOID
TrueffsThread(
    PVOID Context
    )

/*++

Routine Description:

    This is the code executed by the system thread created when the
    Trueffs driver initializes.  This thread loops forever (or until a
    flag is set telling the thread to kill itself) processing packets
    put into the queue by the dispatch routines.

Arguments:

    Context - not used.

Return Value:

    None.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PLIST_ENTRY request;
    PDEVICE_EXTENSION deviceExtension = Context;
    PSCSI_REQUEST_BLOCK Srb;
    NTSTATUS ntStatus;
    NTSTATUS waitStatus;
    LARGE_INTEGER queueWait;
    ULONG status;
    ULONG i;
    ULONG startingSector;
    PUCHAR dataOffset;
    PVOID   storedSrbDataBuffer = NULL;
    FLStatus tffsStatus = flOK;
    FLStatus flStatusProt = flOK;
    IOreq ioreq;
    IOreq ioreqProt;

    flIOctlRecord flIoctlRec;
        int l;

    CHAR vendorString[8];// = VENDORSTRING;
    CHAR productString[16];// = PRODUCTSTRING;
    CHAR revisionString[4];// = REVISIONSTRING;

    PCHAR pageData;
    ULONG parameterHeaderLength;
    ULONG blockDescriptorLength;
    PCDB  cdb;
    BOOLEAN transferForbidden;
    flFormatPhysicalInput flFp;
    flBDKOperationInput bdkOperationInput;
    flOtpInput otpInput;
    flIplInput iplInput;
    flProtectionInput protectionInput;
    void * userInput  = NULL;
    void * userOutput = NULL;

    PAGED_CODE();

    queueWait.QuadPart = -(3 * 1000 * 10000);

    do {

    KeSetEvent(&deviceExtension->PendingIRPEvent, 0, FALSE);

    // Wait for a request from the dispatch routines.
    waitStatus = KeWaitForSingleObject(
        (PVOID) &deviceExtension->requestSemaphore,
        Executive,
        KernelMode,
        FALSE,
        &queueWait );

    if (waitStatus == STATUS_SUCCESS && !(deviceExtension->DeviceFlags & DEVICE_FLAG_QUERY_STOP_REMOVE)
                                     && !(deviceExtension->DeviceFlags & DEVICE_FLAG_HOLD_IRPS)) {
        if(deviceExtension->threadReferenceCount == 0) {
            //TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Thread: going to kill the thread\n"));
            deviceExtension->threadReferenceCount = -1;
            PsTerminateSystemThread( STATUS_SUCCESS );
        }
    }
    else
        continue;

    while (request = ExInterlockedRemoveHeadList(&deviceExtension->listEntry,&deviceExtension->listSpinLock)) {

        KeClearEvent(&deviceExtension->PendingIRPEvent);
        irp = CONTAINING_RECORD( request, IRP, Tail.Overlay.ListEntry );

        irpSp = IoGetCurrentIrpStackLocation( irp );
        //TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Thread: Irp %Xh, IrpSp %Xh\n", irp, irpSp));

        Srb = irpSp->Parameters.Scsi.Srb;
        //TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Thread: Srb %Xh DataBuffer %Xh MdlAddress %Xh\n", Srb, Srb->DataBuffer, irp->MdlAddress));

                transferForbidden = FALSE;
        if (irp->MdlAddress != NULL) {
            PVOID   tmpDataBuffer = NULL;
            MM_PAGE_PRIORITY tffsPriority =
                (deviceExtension->PagingPathCount || deviceExtension->CrashDumpPathCount) ?
                    HighPagePriority : NormalPagePriority;

            storedSrbDataBuffer = Srb->DataBuffer;

            dataOffset = MmGetSystemAddressForMdlSafe(irp->MdlAddress, tffsPriority);
            if (dataOffset != NULL) {
                tmpDataBuffer = dataOffset + (ULONG)((PUCHAR)Srb->DataBuffer -
                                  (PCCHAR)MmGetMdlVirtualAddress(irp->MdlAddress));

                //TffsDebugPrint((TFFS_DEB_INFO, "Trueffs: TmpDataBuffer= 0x%x Srb->DataBuffer= 0x%x\n", tmpDataBuffer, Srb->DataBuffer));
                Srb->DataBuffer = tmpDataBuffer;
            }
            else {
                transferForbidden = TRUE;
                TffsDebugPrint ((TFFS_DEB_ERROR,"Trueffs: MmGetSystemAddressForMdlSafe Failed\n"));
            }
        }

        switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
                case IOCTL_TFFS_EXTENDED_WRITE_IPL:
                    {
                    if( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(flOutputStatusRecord)) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
                }
                    else if ( irpSp->Parameters.DeviceIoControl.InputBufferLength >
              sizeof(flUserIplInput)){
                            status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
                    }
                else {

                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo start get info\n"));

                    ioreq.irHandle = deviceExtension->UnitNumber;
                    ioreq.irFlags  = FL_IOCTL_EXTENDED_WRITE_IPL;
                    ioreq.irData   = &flIoctlRec;

                            iplInput.buf = ((flUserIplInput *)(irp->AssociatedIrp.SystemBuffer))->buf;
                            iplInput.bufLen = ((flUserIplInput *)(irp->AssociatedIrp.SystemBuffer))->bufLen;
                            flIoctlRec.inputRecord = &iplInput;
                            flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo before flioctl\n"));
                    tffsStatus = flIOctl(&ioreq);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo after flioctl\n"));

                    if( tffsStatus == flOK ) {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo FLOK\n"));
                        irp->IoStatus.Information = sizeof(flOutputStatusRecord);
                        status = STATUS_SUCCESS;

                    }
                    else {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo !FLOK!\n"));
                        irp->IoStatus.Information = 0;
                        status = STATUS_UNSUCCESSFUL;
                    }
                }

                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }

#ifdef ENVIRONMENT_VARS
                case IOCTL_TFFS_EXTENDED_ENVIRONMENT_VARIABLES:
                    {
                    if( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(flOutputStatusRecord)) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
                }
                    else if ( irpSp->Parameters.DeviceIoControl.InputBufferLength >
              sizeof(flExtendedEnvVarsInput)){
                            status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
                    }
                else {

                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_EXTENDED_ENVIRONMENT_VARIABLES\n"));

                    ioreq.irHandle = deviceExtension->UnitNumber;
                    ioreq.irFlags  = FL_IOCTL_EXTENDED_ENVIRONMENT_VARIABLES;
                    ioreq.irData   = &flIoctlRec;

                            flIoctlRec.inputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);
                            flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_EXTENDED_ENVIRONMENT_VARIABLES before flioctl\n"));
                            tffsStatus = flIOctl(&ioreq);
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_EXTENDED_ENVIRONMENT_VARIABLES after flioctl\n"));

                    if( tffsStatus == flOK ) {
                                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_EXTENDED_ENVIRONMENT_VARIABLES FLOK\n"));
                        irp->IoStatus.Information = sizeof(flExtendedEnvVarsOutput);
                        status = STATUS_SUCCESS;

                    }
                    else {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_EXTENDED_ENVIRONMENT_VARIABLES !FLOK!\n"));
                        irp->IoStatus.Information = 0;
                        status = STATUS_UNSUCCESSFUL;
                    }
                }

                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }
#endif /* ENVIRONMENT_VARS */

                case IOCTL_TFFS_CUSTOMER_ID:
                {
                    if( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                        sizeof(flCustomerIdOutput)) {

                        status = STATUS_INVALID_PARAMETER;
                        irp->IoStatus.Information = 0;
                    }
                    else {

                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo start get info\n"));

                    ioreq.irHandle = deviceExtension->UnitNumber;
                    ioreq.irFlags  = FL_IOCTL_CUSTOMER_ID;
                    ioreq.irData   = &flIoctlRec;
                    flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo before flioctl\n"));
                    tffsStatus = flIOctl(&ioreq);
                    //tffsStatus = flOK;
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo after flioctl\n"));

                    if( tffsStatus == flOK ) {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo FLOK\n"));
                        irp->IoStatus.Information = sizeof(flCustomerIdOutput);
                        status = STATUS_SUCCESS;

                    }
                    else {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo !FLOK!\n"));
                        irp->IoStatus.Information = 0;
                        status = STATUS_UNSUCCESSFUL;
                    }
                }

                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }

                case IOCTL_TFFS_NUMBER_OF_PARTITIONS:   {       // User TFFS IOCTL - FL_GET_INFO

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsGetInfo\n"));

                if( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(flCountPartitionsOutput)) {

                    status = STATUS_INVALID_PARAMETER;
                    irp->IoStatus.Information = 0;
                }
                else {

                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo start get info\n"));

                    ioreq.irHandle = deviceExtension->UnitNumber;
                    ioreq.irFlags  = FL_IOCTL_NUMBER_OF_PARTITIONS;
                    ioreq.irData   = &flIoctlRec;
                    flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo before flioctl\n"));
                    tffsStatus = flIOctl(&ioreq);
                    //tffsStatus  = flOK;
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo after flioctl\n"));

                    if( tffsStatus == flOK ) {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo FLOK\n"));
                        irp->IoStatus.Information = sizeof(flCountPartitionsOutput);
                        status = STATUS_SUCCESS;

                    }
                    else {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo !FLOK!\n"));
                        irp->IoStatus.Information = 0;
                        status = STATUS_UNSUCCESSFUL;
                    }
                }

                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }
            case IOCTL_TFFSFL_UNIQUE_ID:
                {       // User TFFS IOCTL -

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: FL_IOCTL_UNIQUE_ID \n"));

                if( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(flUniqueIdOutput)) {

                    status = STATUS_INVALID_PARAMETER;
                    irp->IoStatus.Information = 0;
                }
                else {

                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : FL_IOCTL_UNIQUE_ID Start\n"));

                    ioreq.irHandle = deviceExtension->UnitNumber;
                    ioreq.irFlags  = FL_IOCTL_UNIQUE_ID;
                    ioreq.irData   = &flIoctlRec;
                    flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo before flioctl\n"));
                    tffsStatus = flIOctl(&ioreq);
                    //tffsStatus = flOK;
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo after flioctl\n"));

                    if( tffsStatus == flOK ) {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo FLOK\n"));
                        irp->IoStatus.Information = sizeof(flUniqueIdOutput);
                        status = STATUS_SUCCESS;

                    }
                    else {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo !FLOK!\n"));
                        irp->IoStatus.Information = 0;
                        status = STATUS_UNSUCCESSFUL;
                    }
                }

                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }

            case IOCTL_TFFS_FORMAT_PHYSICAL_DRIVE:
                {       // User TFFS IOCTL - IOCTL_TFFSFL_INQUIRE_CAPABILITIES

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_FORMAT_PHYSICAL_DRIVE\n"));

          if( (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(flOutputStatusRecord)) ||
                            (irpSp->Parameters.DeviceIoControl.InputBufferLength <
              sizeof(flUserFormatPhysicalInput))) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
                }
                else {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_FORMAT_PHYSICAL_DRIVE Start\n"));
                        userInput = (VOID *)(irp->AssociatedIrp.SystemBuffer); //Get input parameters

                        flFp.formatType = ((flUserFormatPhysicalInput *)userInput)->formatType;
                        TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: formatType:%Xh \n",flFp.formatType));

                        flFp.fp.percentUse = (unsigned char)((flUserFormatPhysicalInput *)userInput)->fp.percentUse;
                        TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: percentUse:%Xh \n",flFp.fp.percentUse));

                        flFp.fp.noOfBDTLPartitions = ((flUserFormatPhysicalInput *)userInput)->fp.noOfBDTLPartitions;
                        TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: noOfBDTLPartitions:%Xh \n",flFp.fp.noOfBDTLPartitions));
                        flFp.fp.noOfBinaryPartitions = ((flUserFormatPhysicalInput *)userInput)->fp.noOfBinaryPartitions;
                        TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: noOfBinaryPartitions:%Xh \n",flFp.fp.noOfBinaryPartitions));
                        flFp.fp.BDTLPartitionInfo = ((flUserFormatPhysicalInput *)userInput)->fp.BDTLPartitionInfo;
                        TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: BDTLPartitionInfo:%Xh \n",flFp.fp.BDTLPartitionInfo));
                        flFp.fp.binaryPartitionInfo = ((flUserFormatPhysicalInput *)userInput)->fp.binaryPartitionInfo;
                        TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: binaryPartitionInfo:%Xh \n",flFp.fp.binaryPartitionInfo));

                        #ifdef WRITE_EXB_IMAGE
                          flFp.fp.exbBuffer = ((flUserFormatPhysicalInput *)userInput)->fp.exbBuffer;
                            TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: exbBuffer:%Xh \n",flFp.fp.exbBuffer));
                            flFp.fp.exbBufferLen = ((flUserFormatPhysicalInput *)userInput)->fp.exbBufferLen;
                            TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: exbBufferLen:%Xh \n",flFp.fp.exbBufferLen));
                            flFp.fp.exbLen = ((flUserFormatPhysicalInput *)userInput)->fp.exbLen;
                            TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: exbLen:%Xh \n",flFp.fp.exbLen));
                            flFp.fp.exbWindow = ((flUserFormatPhysicalInput *)userInput)->fp.exbWindow;
                            TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: exbWindow:%Xh \n",flFp.fp.exbWindow));
                            flFp.fp.exbFlags = ((flUserFormatPhysicalInput *)userInput)->fp.exbFlags;
                            TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: exbFlags:%Xh \n",flFp.fp.exbFlags));
                        #endif /*WRITE_EXB_IMAGE*/

                        flFp.fp.cascadedDeviceNo = ((flUserFormatPhysicalInput *)userInput)->fp.cascadedDeviceNo;
                        TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: cascadedDeviceNo:%Xh \n",flFp.fp.cascadedDeviceNo));
                        flFp.fp.noOfCascadedDevices = ((flUserFormatPhysicalInput *)userInput)->fp.noOfCascadedDevices;
                        TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: noOfCascadedDevices:%Xh \n",flFp.fp.noOfCascadedDevices));
                        flFp.fp.progressCallback = NULL;
                        flFp.fp.vmAddressingLimit = ((flUserFormatPhysicalInput *)userInput)->fp.vmAddressingLimit;
                        TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: vmAddressingLimit:%Xh \n",flFp.fp.vmAddressingLimit));
                        flFp.fp.embeddedCISlength = (unsigned short)((flUserFormatPhysicalInput *)userInput)->fp.embeddedCISlength;
                        TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: embeddedCISlength:%Xh \n",flFp.fp.embeddedCISlength));
                        flFp.fp.embeddedCIS = ((flUserFormatPhysicalInput *)userInput)->fp.embeddedCIS;
                        TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: embeddedCIS:%Xh \n",flFp.fp.embeddedCIS));

                  ioreq.irHandle = deviceExtension->UnitNumber;
                  ioreq.irFlags  = FL_IOCTL_FORMAT_PHYSICAL_DRIVE;
                        ioreq.irData   = &flIoctlRec;
                  flIoctlRec.inputRecord = &flFp;//(VOID *)(irp->AssociatedIrp.SystemBuffer);
                        flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_FORMAT_PHYSICAL_DRIVE before flioctl\n"));
                  tffsStatus = flIOctl(&ioreq);
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_FORMAT_PHYSICAL_DRIVE after flioctl\n"));
                        userInput = NULL;


                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_FORMAT_PHYSICAL_DRIVE after flioctl  - clean userPointer\n"));
                  if( tffsStatus == flOK ) {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_FORMAT_PHYSICAL_DRIVE FLOK\n"));
                        irp->IoStatus.Information = sizeof(flOutputStatusRecord);
                        status = STATUS_SUCCESS;

                  }
                  else {
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_FORMAT_PHYSICAL_DRIVE Failed!\n"));
                      irp->IoStatus.Information = 0;
                       status = STATUS_UNSUCCESSFUL;
                   }
                }

                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }

        #ifdef VERIFY_VOLUME
            case IOCTL_TFFS_VERIFY_VOLUME:
            {
                  TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_VERIFY_VOLUME\n"));

                  if( (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                      sizeof(flOutputStatusRecord)) ||
                                    (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                      sizeof(flVerifyVolumeInput))) {

                      status = STATUS_INVALID_PARAMETER;
                      irp->IoStatus.Information = 0;
                    }
                    else {

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: IOCTL_TFFS_VERIFY_VOLUME Start\n"));

                        ioreq.irHandle = deviceExtension->UnitNumber;
                        ioreq.irFlags  = IOCTL_TFFS_VERIFY_VOLUME;
                        ioreq.irData   = &flIoctlRec;
                        flIoctlRec.inputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);
                        flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: IOCTL_TFFS_VERIFY_VOLUME before flioctl\n"));
                        tffsStatus = flIOctl(&ioreq);
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: IOCTL_TFFS_VERIFY_VOLUME after flioctl\n"));

                        if( tffsStatus == flOK ) {
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: IOCTL_TFFS_VERIFY_VOLUME FLOK\n"));
                            irp->IoStatus.Information = sizeof(flVerifyVolumeOutput);
                            status = STATUS_SUCCESS;


                  }//if( tffsStatus == flOK )
                  else {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: IOCTL_TFFS_VERIFY_VOLUME Failed!\n"));
                        irp->IoStatus.Information = 0;
                        status = STATUS_UNSUCCESSFUL;
                  }//else( tffsStatus == flOK )

                }//if( (irpSp->Parameters
                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }

        #endif /* VERIFY_VOLUME */


        #ifdef HW_PROTECTION
            case IOCTL_TFFS_BDTL_HW_PROTECTION:
                {       // User TFFS IOCTL - IOCTL_TFFS_BDTL_HW_PROTECTION

                  TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_BDTL_HW_PROTECTION\n"));

                  if( (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                      sizeof(flOutputStatusRecord)) ||
                                    (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                      sizeof(flProtectionInput))) {

                      status = STATUS_INVALID_PARAMETER;
                      irp->IoStatus.Information = 0;
                    }
                    else {

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BDTL_HW_PROTECTION Start\n"));

                        ioreq.irHandle = deviceExtension->UnitNumber;
                        ioreq.irFlags  = FL_IOCTL_BDTL_HW_PROTECTION;
                        ioreq.irData   = &flIoctlRec;
                        flIoctlRec.inputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);
                        flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BDTL_HW_PROTECTION before flioctl\n"));
                        tffsStatus = flIOctl(&ioreq);
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BDTL_HW_PROTECTION after flioctl\n"));

                        if( tffsStatus == flOK ) {
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BDTL_HW_PROTECTION FLOK\n"));
                            irp->IoStatus.Information = sizeof(flOutputStatusRecord);
                            status = STATUS_SUCCESS;

                        //Change if protection has been changed
                            /*
                            //If key inserted
                            if(((flProtectionInput *)flIoctlRec.inputRecord)->type == PROTECTION_INSERT_KEY){
                                deviceExtension->IsWriteProtected = FALSE;
                            }
                            //If type changed to protected
                            else if((((flProtectionInput *)flIoctlRec.inputRecord)->type == PROTECTION_CHANGE_TYPE) &&
                                ((flProtectionInput *)flIoctlRec.inputRecord)->type & (READ_PROTECTED|WRITE_PROTECTED))){
                                deviceExtension->IsWriteProtected = TRUE;
                            }
                            //If type changed to unprotected
                            else if((((flProtectionInput *)flIoctlRec.inputRecord)->type == PROTECTION_CHANGE_TYPE) &&
                                ((flProtectionInput *)flIoctlRec.inputRecord)->type  == PROTECTABLE)){
                                deviceExtension->IsWriteProtected = FALSE;
                            }
                            //If remove key - ask if we are in protectable state.
                            else if(((flProtectionInput *)flIoctlRec.inputRecord)->type == PROTECTION_REMOVE_KEY){
                            */

                                flStatusProt = flOK;
                                ioreqProt.irHandle = ioreq.irHandle;
                                ioreqProt.irFlags = 0;
                                flStatusProt = flIdentifyProtection(&ioreqProt);
                                if(flStatusProt == flOK){
                                    if((ioreqProt.irFlags & (WRITE_PROTECTED |READ_PROTECTED))
                                        && !(ioreqProt.irFlags & KEY_INSERTED )){
                                        deviceExtension->IsWriteProtected = TRUE;
                                    }
                                    else{
                                        deviceExtension->IsWriteProtected = FALSE;
                                    }
                                }
                                else{
                                    deviceExtension->IsWriteProtected = FALSE;
                                }//(flStatusProt == flOK)

                  }//if( tffsStatus == flOK )
                  else {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BDTL_HW_PROTECTION Failed!\n"));
                        irp->IoStatus.Information = 0;
                        status = STATUS_UNSUCCESSFUL;
                  }//else( tffsStatus == flOK )

                }//if( (irpSp->Parameters
                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }
            case IOCTL_TFFS_BINARY_HW_PROTECTION:
                {       // User TFFS IOCTL - IOCTL_TFFS_BDTL_HW_PROTECTION

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_BINARY_HW_PROTECTION\n"));

          if( (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(flOutputStatusRecord)) ||
                            (irpSp->Parameters.DeviceIoControl.InputBufferLength <
              sizeof(flProtectionInput))) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
                }
                else {

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BINARY_HW_PROTECTION Start\n"));

                  //ioreq.irHandle = deviceExtension->UnitNumber;
                  ioreq.irFlags  = FL_IOCTL_BINARY_HW_PROTECTION;
                  ioreq.irData   = &flIoctlRec;

                        //Update protectionInput with flBDKProtectionInput members
                        protectionInput.protectionType  = ((flBDKProtectionInput *)(irp->AssociatedIrp.SystemBuffer))->protectionType;
                        protectionInput.type  = ((flBDKProtectionInput *)(irp->AssociatedIrp.SystemBuffer))->type;
                        tffscpy(protectionInput.key  , ((flBDKProtectionInput *)(irp->AssociatedIrp.SystemBuffer))->key, sizeof(protectionInput.key));
                        ioreq.irHandle = (deviceExtension->UnitNumber & 0x0f) + (((flBDKProtectionInput *)(irp->AssociatedIrp.SystemBuffer))->partitionNumber << 4);

                  //flIoctlRec.inputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);
                        flIoctlRec.inputRecord = &protectionInput;
                        flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BINARY_HW_PROTECTION before flioctl\n"));
                  tffsStatus = flIOctl(&ioreq);
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BINARY_HW_PROTECTION after flioctl\n"));

                  if( tffsStatus == flOK ) {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BINARY_HW_PROTECTION FLOK\n"));
                        irp->IoStatus.Information = sizeof(flOutputStatusRecord);
                        status = STATUS_SUCCESS;

                  }
                  else {
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BINARY_HW_PROTECTION Failed!\n"));
                      irp->IoStatus.Information = 0;
                       status = STATUS_UNSUCCESSFUL;
                   }
                }

                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }

            #endif /*HW_PROTECTION*/
            #ifdef WRITE_EXB_IMAGE
            case IOCTL_TFFS_PLACE_EXB_BY_BUFFER:
                {
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_PLACE_EXB_BY_BUFFER\n"));

          if( (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(flOutputStatusRecord) )
                            || (irpSp->Parameters.DeviceIoControl.InputBufferLength <
              sizeof(flUserPlaceExbInput) )) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
                }
                else {

                        flPlaceExbInput placeExbInput;
                        ioreq.irHandle = deviceExtension->UnitNumber;
                        ioreq.irFlags  = FL_IOCTL_PLACE_EXB_BY_BUFFER;
                        ioreq.irData   = &flIoctlRec;
                        flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);
                        flIoctlRec.inputRecord = &placeExbInput;

                        //Update placeExbInput  with flUserPlaceExbInput memebers
                        placeExbInput.buf  = ((flUserPlaceExbInput *)(irp->AssociatedIrp.SystemBuffer))->buf;
                        placeExbInput.bufLen  = ((flUserPlaceExbInput *)(irp->AssociatedIrp.SystemBuffer))->bufLen;
                        placeExbInput.exbFlags  = ((flUserPlaceExbInput *)(irp->AssociatedIrp.SystemBuffer))->exbFlags;
                        placeExbInput.exbWindow  = ((flUserPlaceExbInput *)(irp->AssociatedIrp.SystemBuffer))->exbWindow;
                        tffsStatus = flIOctl(&ioreq);

                        if( tffsStatus == flOK ) {
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo FLOK\n"));
                            irp->IoStatus.Information = sizeof(flCountPartitionsOutput);
                            status = STATUS_SUCCESS;

                        }
                        else {
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo !FLOK!\n"));
                            irp->IoStatus.Information = 0;
                            status = STATUS_UNSUCCESSFUL;
                        }
                }

                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
                }
            #endif /*WRITE_EXB_IMAGE*/

            #ifdef HW_OTP
            case IOCTL_TFFS_OTP:
                {       // User TFFS IOCTL - IOCTL_TFFS_BDTL_HW_PROTECTION

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_OTP\n"));

          if( (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(UserOtpOutput)) ||
                            (irpSp->Parameters.DeviceIoControl.InputBufferLength <
              sizeof(UserOtpInput))) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
                }
                else {

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_OTP Start\n"));
                        userInput = (VOID *)(irp->AssociatedIrp.SystemBuffer);
                        userOutput  = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                        otpInput.type = ((UserOtpInput *)userInput)->type;
                        if(otpInput.type != OTP_SIZE){
                            otpInput.length     = ((UserOtpInput *)userInput)->length;
                            if(otpInput.type != OTP_WRITE_LOCK)
                                otpInput.usedSize = ((UserOtpInput *)userInput)->usedSize;
                        }

                        //Updating OTP i/o buffer
                        if(otpInput.type == OTP_WRITE_LOCK)
                            otpInput.buffer = ((UserOtpInput *)userInput)->buffer;
                        else
                            otpInput.buffer = ((UserOtpOutput *)userOutput)->buffer;

                  ioreq.irHandle = deviceExtension->UnitNumber;
                  ioreq.irFlags  = FL_IOCTL_OTP;
                  ioreq.irData   = &flIoctlRec;

                        flIoctlRec.inputRecord = (VOID *)&otpInput;
                        flIoctlRec.outputRecord = (VOID *)(&(((UserOtpOutput *)userOutput)->statusRec));

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_OTP before flioctl\n"));
                  tffsStatus = flIOctl(&ioreq);
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_OTP after flioctl\n"));

                  if( tffsStatus == flOK ) {
                                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_OTP FLOK\n"));
                        irp->IoStatus.Information = sizeof(UserOtpInput);
                        status = STATUS_SUCCESS;
                                if(otpInput.type == OTP_SIZE){
                                    ((UserOtpOutput *)userOutput)->length           = otpInput.length;
                                    ((UserOtpOutput *)userOutput)->usedSize     = otpInput.usedSize;
                                    ((UserOtpOutput *)userOutput)->lockedFlag   = otpInput.lockedFlag;
                                    ((UserOtpOutput *)userOutput)->statusRec.status = tffsStatus;
                                }

                  }
                  else {
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_OTP Failed!\n"));
                      irp->IoStatus.Information = 0;
                       status = STATUS_UNSUCCESSFUL;
                   }
                }
                    userInput = NULL;
                    userOutput = NULL;
                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }
                #endif /* HW_OTP*/
            case IOCTL_TFFS_DEEP_POWER_DOWN_MODE:
                {       // User TFFS IOCTL - IOCTL_TFFSFL_INQUIRE_CAPABILITIES

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: FL_IOCTL_DEEP_POWER_DOWN_MODE\n"));

          if( (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(flOutputStatusRecord)) ||
                            (irpSp->Parameters.DeviceIoControl.InputBufferLength <
              sizeof(flPowerDownInput))) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
                }
                else {

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : FL_IOCTL_DEEP_POWER_DOWN_MODE Start\n"));

                  ioreq.irHandle = deviceExtension->UnitNumber;
                  ioreq.irFlags  = FL_IOCTL_DEEP_POWER_DOWN_MODE;
                  ioreq.irData   = &flIoctlRec;
                  flIoctlRec.inputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);
                        flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : FL_IOCTL_DEEP_POWER_DOWN_MODE before flioctl\n"));
                  tffsStatus = flIOctl(&ioreq);
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : FL_IOCTL_DEEP_POWER_DOWN_MODE after flioctl\n"));

                  if( tffsStatus == flOK ) {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : FL_IOCTL_DEEP_POWER_DOWN_MODE FLOK\n"));
                        irp->IoStatus.Information = sizeof(flOutputStatusRecord);
                        status = STATUS_SUCCESS;

                  }
                  else {
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : FL_IOCTL_DEEP_POWER_DOWN_MODE Failed!\n"));
                      irp->IoStatus.Information = 0;
                       status = STATUS_UNSUCCESSFUL;
                   }
                }

                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }

            case IOCTL_TFFSFL_INQUIRE_CAPABILITIES:
                {       // User TFFS IOCTL - IOCTL_TFFSFL_INQUIRE_CAPABILITIES

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: FL_IOCTL_UNIQUE_ID \n"));

          if( (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(flCapabilityOutput)) ||
                            (irpSp->Parameters.DeviceIoControl.InputBufferLength <
              sizeof(flCapabilityInput))) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
                }
                else {

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : FL_IOCTL_INQUIRE_CAPABILITIES Start\n"));

                  ioreq.irHandle = deviceExtension->UnitNumber;
                  ioreq.irFlags  = FL_IOCTL_INQUIRE_CAPABILITIES;
                  ioreq.irData   = &flIoctlRec;
                  flIoctlRec.inputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);
                        flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : FL_IOCTL_INQUIRE_CAPABILITIES before flioctl\n"));
                  tffsStatus = flIOctl(&ioreq);
                        //tffsStatus = flOK;
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : FL_IOCTL_INQUIRE_CAPABILITIES after flioctl\n"));

                  if( tffsStatus == flOK ) {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : FL_IOCTL_INQUIRE_CAPABILITIES FLOK\n"));
                        irp->IoStatus.Information = sizeof(flCapabilityInput);
                        status = STATUS_SUCCESS;

                  }
                  else {
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : FL_IOCTL_INQUIRE_CAPABILITIES Failed!\n"));
                      irp->IoStatus.Information = 0;
                        status = STATUS_UNSUCCESSFUL;
                   }
                }

                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }

            case IOCTL_TFFS_GET_INFO:   {       // User TFFS IOCTL - FL_GET_INFO

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsGetInfo\n"));

          if( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(flDiskInfoOutput)) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
                }
                else {

                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo start get info\n"));

                    ioreq.irHandle = deviceExtension->UnitNumber;
                    ioreq.irFlags  = FL_IOCTL_GET_INFO;
                    ioreq.irData   = &flIoctlRec;
                    flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo before flioctl\n"));
                    tffsStatus = flIOctl(&ioreq);
                    //tffsStatus = flOK;
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo after flioctl\n"));

                    if( tffsStatus == flOK ) {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo FLOK\n"));
                        irp->IoStatus.Information = sizeof(flDiskInfoOutput);
                        status = STATUS_SUCCESS;

                    }
                    else {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo !FLOK!\n"));
                        irp->IoStatus.Information = 0;
                        status = STATUS_UNSUCCESSFUL;
                    }
                }

                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }

            case IOCTL_TFFS_DEFRAGMENT: {       // User TFFS IOCTL - FL_DEFRAGMENT
                flDefragInput iDefrag;

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsDefragment\n"));

                if( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(flDefragOutput)) {

                    status = STATUS_INVALID_PARAMETER;
                    irp->IoStatus.Information = 0;
                }
                else {
                    if( irpSp->Parameters.DeviceIoControl.InputBufferLength == 0 )
                        iDefrag.requiredNoOfSectors = -1;
                    else
                        iDefrag.requiredNoOfSectors = *((LONG *)(irp->AssociatedIrp.SystemBuffer));

                    ioreq.irHandle = deviceExtension->UnitNumber;
                    ioreq.irFlags  = FL_IOCTL_DEFRAGMENT;
                    ioreq.irData   = &flIoctlRec;
                    flIoctlRec.inputRecord = (VOID *)&iDefrag;
                    flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                    tffsStatus = flIOctl(&ioreq);
                    //tffsStatus = flOK;

                    if( tffsStatus == flOK ) {
                        irp->IoStatus.Information = sizeof(flDefragOutput);
                        status = STATUS_SUCCESS;
                    }
                    else {
                        irp->IoStatus.Information = 0;
                        status = STATUS_UNSUCCESSFUL;
                    }
                }
                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }

          case IOCTL_TFFS_WRITE_PROTECT: {  // User TFFS IOCTL - FL_WRITE_PROTECT

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsWriteProtect\n"));

            if( irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(flWriteProtectInput)) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
            }
            else {
              ioreq.irHandle = deviceExtension->UnitNumber;
              ioreq.irFlags  = FL_IOCTL_WRITE_PROTECT;
              ioreq.irData   = &flIoctlRec;
              flIoctlRec.inputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);
              flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);
              tffsStatus = flIOctl(&ioreq);

              if( tffsStatus == flOK ) {
                irp->IoStatus.Information = sizeof(flOutputStatusRecord);
                status = STATUS_SUCCESS;

                //Handling Enable and disable of write portected media
                if(((flWriteProtectInput *)flIoctlRec.inputRecord)->type == FL_PROTECT){
                    deviceExtension->IsSWWriteProtected = TRUE;
                }
                else if(((flWriteProtectInput *)flIoctlRec.inputRecord)->type == FL_UNPROTECT){
                    deviceExtension->IsSWWriteProtected = FALSE;
                }
                else if(((flWriteProtectInput *)flIoctlRec.inputRecord)->type == FL_UNLOCK){
                    deviceExtension->IsSWWriteProtected = FALSE;
                }
              }
              else {
                irp->IoStatus.Information = 0;
                status = STATUS_UNSUCCESSFUL;
              }
            }
            irp->IoStatus.Status = status;
            IoCompleteRequest( irp, IO_DISK_INCREMENT );
            continue;
          }

        case IOCTL_TFFS_MOUNT_VOLUME:       // User TFFS IOCTL - FL_MOUNT_VOLUME

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsMountVolume\n"));

            if( (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                 sizeof(flMountInput)) ||
                (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                 sizeof(flOutputStatusRecord)) ) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
            }
            else {
              ioreq.irHandle = deviceExtension->UnitNumber;
              ioreq.irFlags  = FL_IOCTL_MOUNT_VOLUME;
              ioreq.irData   = &flIoctlRec;
              flIoctlRec.inputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);
              flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

              tffsStatus = flIOctl(&ioreq);

              if( tffsStatus == flOK ) {
                irp->IoStatus.Information = sizeof(flOutputStatusRecord);
                status = STATUS_SUCCESS;
              }
              else {
                irp->IoStatus.Information = 0;
                status = STATUS_UNSUCCESSFUL;
              }
            }
            irp->IoStatus.Status = status;
            IoCompleteRequest( irp, IO_DISK_INCREMENT );
            continue;

          case IOCTL_TFFS_FORMAT_VOLUME:    // User TFFS IOCTL - FL_FORMAT_VOLUME

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsFormatVolume\n"));

            if( (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                 sizeof(flFormatInput)) ||
                (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                 sizeof(flOutputStatusRecord)) ) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
            }
            else {
              ioreq.irHandle = deviceExtension->UnitNumber;
              ioreq.irFlags  = FL_IOCTL_FORMAT_VOLUME;
              ioreq.irData   = &flIoctlRec;
              flIoctlRec.inputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);
              flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

              tffsStatus = flIOctl(&ioreq);

              if( tffsStatus == flOK ) {
                irp->IoStatus.Information = sizeof(flOutputStatusRecord);
                status = STATUS_SUCCESS;
              }
              else {
                irp->IoStatus.Information = 0;
                status = STATUS_UNSUCCESSFUL;
              }
            }
            irp->IoStatus.Status = status;
            IoCompleteRequest( irp, IO_DISK_INCREMENT );
            continue;

            case IOCTL_TFFS_BDK_OPERATION:
                {       // User TFFS IOCTL - IOCTL_TFFSFL_INQUIRE_CAPABILITIES

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_BDK_OPERATION\n"));

          if( (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(flUserBDKOperationOutput)) ||
                            (irpSp->Parameters.DeviceIoControl.InputBufferLength <
              sizeof(flUserBDKOperationInput))) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
                }
                else {

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : FL_IOCTL_DEEP_POWER_DOWN_MODE Start\n"));
                        userInput = (VOID *)(irp->AssociatedIrp.SystemBuffer);
                        userOutput = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                        bdkOperationInput.type = ((flUserBDKOperationInput *)userInput)->type;
                        //Copy new and old signature
                        for(i = 0; i < BDK_SIGNATURE_NAME; i++){
                            bdkOperationInput.bdkStruct.oldSign[i]  = ((flUserBDKOperationInput *)userInput)->bdkStruct.oldSign[i];
                            bdkOperationInput.bdkStruct.newSign[i]  = ((flUserBDKOperationInput *)userInput)->bdkStruct.newSign[i];
                        }


                        bdkOperationInput.bdkStruct.signOffset      = ((flUserBDKOperationInput *)userInput)->bdkStruct.signOffset;
                        bdkOperationInput.bdkStruct.startingBlock = ((flUserBDKOperationInput *)userInput)->bdkStruct.startingBlock;
                        bdkOperationInput.bdkStruct.length              = ((flUserBDKOperationInput *)userInput)->bdkStruct.length;
                        bdkOperationInput.bdkStruct.flags                   = ((flUserBDKOperationInput *)userInput)->bdkStruct.flags;


                        if(bdkOperationInput.type != BDK_READ)
                            bdkOperationInput.bdkStruct.bdkBuffer = ((flUserBDKOperationInput *)userInput)->bdkStruct.bdkBuffer;
                        else
                            bdkOperationInput.bdkStruct.bdkBuffer = ((flUserBDKOperationOutput *)userOutput)->bdkStruct.bdkBuffer;

                  ioreq.irHandle = (deviceExtension->UnitNumber & 0x0f) + (((flUserBDKOperationInput *)userOutput)->partitionNumber << 4);
                  ioreq.irFlags  = FL_IOCTL_BDK_OPERATION;
                  ioreq.irData   = &flIoctlRec;
                  flIoctlRec.inputRecord = &bdkOperationInput;
                        flIoctlRec.outputRecord = (VOID *) (&(((flUserBDKOperationOutput *)userOutput)->statusRec));

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BDK_OPERATION before flioctl\n"));
                  tffsStatus = flIOctl(&ioreq);
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BDK_OPERATION after flioctl\n"));

                  if( tffsStatus == flOK ) {
                            if(bdkOperationInput.type == BDK_GET_INFO){
                                ((flUserBDKOperationOutput *)userOutput)->bdkStruct.signOffset      = bdkOperationInput.bdkStruct.signOffset;
                                ((flUserBDKOperationOutput *)userOutput)->bdkStruct.startingBlock = bdkOperationInput.bdkStruct.startingBlock;
                                ((flUserBDKOperationOutput *)userOutput)->bdkStruct.length              = bdkOperationInput.bdkStruct.length;
                                ((flUserBDKOperationOutput *)userOutput)->bdkStruct.flags                   = bdkOperationInput.bdkStruct.flags;
                            }
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BDK_OPERATION FLOK\n"));
                      irp->IoStatus.Information = sizeof(flUserBDKOperationOutput);
                      status = STATUS_SUCCESS;

                  }
                  else {
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BDK_OPERATION Failed!\n"));
                      irp->IoStatus.Information = 0;
                       status = STATUS_UNSUCCESSFUL;
                   }
                }

                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }
          case IOCTL_TFFS_DELETE_SECTORS:   // User TFFS IOCTL - FL_DELETE_SECTORS

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsDeleteSectors\n"));

            if( irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(flDeleteSectorsInput) ) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
            }
            else {
              ioreq.irHandle = deviceExtension->UnitNumber;
              ioreq.irFlags  = FL_IOCTL_DELETE_SECTORS;
              ioreq.irData   = &flIoctlRec;
              flIoctlRec.inputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);
              flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

              tffsStatus = flIOctl(&ioreq);

              if( tffsStatus == flOK ) {
                irp->IoStatus.Information = sizeof(flOutputStatusRecord);
                status = STATUS_SUCCESS;
              }
              else {
                irp->IoStatus.Information = 0;
                status = STATUS_UNSUCCESSFUL;
              }
            }
            irp->IoStatus.Status = status;
            IoCompleteRequest( irp, IO_DISK_INCREMENT );
            continue;
        }

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: SrbFunction %Xh Command %Xh Unit %Xh\n",Srb->Function, Srb->Cdb[0], deviceExtension->UnitNumber));
        switch (Srb->Function) {

          case SRB_FUNCTION_EXECUTE_SCSI:

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: ExecuteScsi\n"));

            // Sanity check. Only one request can be outstanding on a
            // controller.
            if (deviceExtension->CurrentSrb) {

                // Restore the srb->DataBuffer if necesary
                if (irp->MdlAddress != NULL) {
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Restoration of Srb->DataBuffer done\n"));
                    Srb->DataBuffer = storedSrbDataBuffer;
                }


                TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: StartIo: Already have a request!\n"));
                Srb->SrbStatus = SRB_STATUS_BUSY;
                irp->IoStatus.Information = 0;
                irp->IoStatus.Status = STATUS_DEVICE_BUSY;
                IoCompleteRequest(irp,IO_NO_INCREMENT);

                return;

            }

            // Indicate that a request is active
            deviceExtension->CurrentSrb = Srb;

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: Command %x to device %d\n",
                    Srb->Cdb[0],
                    Srb->TargetId));

            switch (Srb->Cdb[0]) {
              case SCSIOP_INQUIRY:

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: Inquiry\n"));

                if (Srb->Lun != 0 || Srb->TargetId != 0) {

                    status = SRB_STATUS_SELECTION_TIMEOUT;
                    break;

                } else {

                    PINQUIRYDATA    inquiryData  = Srb->DataBuffer;

                    if (transferForbidden) {
                        status = SRB_STATUS_ERROR;
                        break;
                    }
                    // Zero INQUIRY data structure.
                    for (i = 0; i < Srb->DataTransferLength; i++) {
                        ((PUCHAR)Srb->DataBuffer)[i] = 0;
                    }

                    inquiryData->DeviceType = deviceExtension->ScsiDeviceType;

                    if (deviceExtension->removableMedia) {
                        inquiryData->RemovableMedia = 1;
                    }

                    for (i = 0; i < 8; i++)
                        inquiryData->VendorId[i] = vendorString[i];

                    for (i = 0; i < 16; i++)
                        inquiryData->ProductId[i] = productString[i];

                    for (i = 0; i < 4; i++)
                        inquiryData->ProductRevisionLevel[i] = revisionString[i];

                    status = SRB_STATUS_SUCCESS;
                }

                break;

              case SCSIOP_MODE_SENSE:

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: ModeSense\n"));

                                cdb = (PCDB) Srb->Cdb;

                if ((cdb->MODE_SENSE.PageCode           != MODE_SENSE_RETURN_ALL) ||
                    (cdb->MODE_SENSE.AllocationLength   != MODE_DATA_SIZE )) {

                    status = SRB_STATUS_INVALID_REQUEST;
                    break;
                }

                if (transferForbidden) {
                    status = SRB_STATUS_ERROR;
                    break;
                }

                // Set mode page data(only a geometry) for DISK class driver.
                // DISK class driver get the geometry of all media(scsi ata) by mode sense.
                pageData = Srb->DataBuffer;

                ((PMODE_PARAMETER_HEADER) pageData)->ModeDataLength = MODE_DATA_SIZE;
                parameterHeaderLength = sizeof(MODE_PARAMETER_HEADER);
                blockDescriptorLength = ((PMODE_PARAMETER_HEADER) pageData)->BlockDescriptorLength = 0x8;

                pageData += parameterHeaderLength + blockDescriptorLength;

                // MODE_PAGE_ERROR_RECOVERY data.
                ((PMODE_DISCONNECT_PAGE) pageData)->PageCode    = MODE_PAGE_ERROR_RECOVERY;
                ((PMODE_DISCONNECT_PAGE) pageData)->PageLength  = 0x6;

                // Advance to the next page.
                pageData += ((PMODE_DISCONNECT_PAGE) pageData)->PageLength + 2;

                // MODE_PAGE_FORMAT_DEVICE data set.
                ((PMODE_DISCONNECT_PAGE) pageData)->PageCode    = MODE_PAGE_FORMAT_DEVICE;
                ((PMODE_DISCONNECT_PAGE) pageData)->PageLength  = 0x16;

                // SectorsPerTrack
                ((PFOUR_BYTE)&((PMODE_FORMAT_PAGE) pageData)->SectorsPerTrack[0])->Byte1
                    = ((PFOUR_BYTE)&deviceExtension->SectorsPerTrack)->Byte0;

                ((PFOUR_BYTE)&((PMODE_FORMAT_PAGE) pageData)->SectorsPerTrack[0])->Byte0
                    = ((PFOUR_BYTE)&deviceExtension->SectorsPerTrack)->Byte1;

                // Advance to the next page.
                pageData += ((PMODE_DISCONNECT_PAGE) pageData)->PageLength + 2;

                // MODE_PAGE_RIGID_GEOMETRY data set.
                ((PMODE_DISCONNECT_PAGE) pageData)->PageCode = MODE_PAGE_RIGID_GEOMETRY;
                ((PMODE_DISCONNECT_PAGE) pageData)->PageLength  = 0x12;

                // NumberOfHeads
                ((PMODE_RIGID_GEOMETRY_PAGE) pageData)->NumberOfHeads
                    = (UCHAR)deviceExtension->NumberOfHeads;

                // NumberOfCylindersfahjbbjknz
                ((PFOUR_BYTE)&((PMODE_RIGID_GEOMETRY_PAGE) pageData)->NumberOfCylinders)->Byte2
                    = ((PFOUR_BYTE)&deviceExtension->Cylinders)->Byte0;
                ((PFOUR_BYTE)&((PMODE_RIGID_GEOMETRY_PAGE) pageData)->NumberOfCylinders)->Byte1
                    = ((PFOUR_BYTE)&deviceExtension->Cylinders)->Byte1;
                ((PFOUR_BYTE)&((PMODE_RIGID_GEOMETRY_PAGE) pageData)->NumberOfCylinders)->Byte0
                    = ((PFOUR_BYTE)&deviceExtension->Cylinders)->Byte2;
                Srb->DataTransferLength = MODE_DATA_SIZE;
                status = SRB_STATUS_SUCCESS;

                break;

              case SCSIOP_TEST_UNIT_READY:

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: TestUnitReady\n"));
                status = SRB_STATUS_SUCCESS;
                break;

              case SCSIOP_READ_CAPACITY:

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: ReadCapacity\n"));

                if (transferForbidden) {
                    status = SRB_STATUS_ERROR;
                    break;
                }

                // Claim 512 byte blocks (big-endian).
                ((PREAD_CAPACITY_DATA)Srb->DataBuffer)->BytesPerBlock = 0x20000;

                // Calculate last sector.
                i = deviceExtension->totalSectors - 1;

                ((PFOUR_BYTE)& ((PREAD_CAPACITY_DATA)Srb->DataBuffer)->LogicalBlockAddress)->Byte0 =
                    ((PFOUR_BYTE)&i)->Byte3;
                ((PFOUR_BYTE)& ((PREAD_CAPACITY_DATA)Srb->DataBuffer)->LogicalBlockAddress)->Byte1 =
                    ((PFOUR_BYTE)&i)->Byte2;
                ((PFOUR_BYTE)& ((PREAD_CAPACITY_DATA)Srb->DataBuffer)->LogicalBlockAddress)->Byte2 =
                    ((PFOUR_BYTE)&i)->Byte1;
                ((PFOUR_BYTE)& ((PREAD_CAPACITY_DATA)Srb->DataBuffer)->LogicalBlockAddress)->Byte3 =
                    ((PFOUR_BYTE)&i)->Byte0;

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: DiskOnChip %x - #sectors %x, #heads %x, #cylinders %x #total %x\n",
                    Srb->TargetId,
                    deviceExtension->SectorsPerTrack,
                    deviceExtension->NumberOfHeads,
                    deviceExtension->Cylinders,
                    i));

                status = SRB_STATUS_SUCCESS;
                break;

              case SCSIOP_VERIFY:

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: Verify\n"));
                status = SRB_STATUS_SUCCESS;
                break;

              case SCSIOP_READ:
              case SCSIOP_WRITE:

                deviceExtension->DataBuffer = (PUSHORT)Srb->DataBuffer;
                startingSector = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3 |
                            ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2 << 8 |
                            ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1 << 16 |
                            ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 << 24;

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: ReadWrite: Starting sector is %x, Number of bytes %x\n",startingSector,Srb->DataTransferLength));

                if (transferForbidden) {
                    status = SRB_STATUS_ERROR;
                    break;
                }

                ioreq.irHandle = deviceExtension->UnitNumber;
                ioreq.irSectorNo = startingSector;
                ioreq.irSectorCount = Srb->DataTransferLength >> SECTOR_SIZE_BITS;
                ioreq.irData = deviceExtension->DataBuffer;

                                if (startingSector >= deviceExtension->totalSectors) {
                                    tffsStatus = flSectorNotFound;
                                }
                else {
                    if (Srb->SrbFlags & SRB_FLAGS_DATA_IN) {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: Read\n"));

                        if(deviceExtension->IsWriteProtected && deviceExtension->IsPartitonTableWritten && (ioreq.irSectorNo == 0)){
                            tffscpy(deviceExtension->DataBuffer, deviceExtension->PartitonTable, sizeof(deviceExtension->PartitonTable));
                            tffsStatus = flOK;
                            status = (UCHAR)(tffsStatus == flOK) ? SRB_STATUS_SUCCESS : SRB_STATUS_ERROR;

                        }
                        else{
                            tffsStatus = flAbsRead(&ioreq);
                            if (irp->MdlAddress) {
                                KeFlushIoBuffers(irp->MdlAddress, TRUE, FALSE);
                            }
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: Read status %Xh\n", tffsStatus));
                            status = (UCHAR)(tffsStatus == flOK) ? SRB_STATUS_SUCCESS : SRB_STATUS_ERROR;
                        }
                    }
                    else {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: Write\n"));
                        //Handle partiton table - simulate write to sector 0 (Volume Manager signature - write it to buffer in RAM) only once.
                        if((deviceExtension->IsWriteProtected || deviceExtension->IsSWWriteProtected) && (ioreq.irSectorNo == 0) && (deviceExtension->IsPartitonTableWritten == FALSE)){
                            tffscpy(deviceExtension->PartitonTable, deviceExtension->DataBuffer, sizeof(deviceExtension->PartitonTable));
                            deviceExtension->IsPartitonTableWritten = TRUE;
                            status = tffsStatus = STATUS_MEDIA_WRITE_PROTECTED;
                            //tffsStatus = flOK;
                            //status = SRB_STATUS_SUCCESS;
                        }//In case of writing to Write Protected Device
                        else if(deviceExtension->IsWriteProtected || deviceExtension->IsSWWriteProtected){
                            status = tffsStatus = STATUS_MEDIA_WRITE_PROTECTED;
                        }
                        else{
                            tffsStatus = flAbsWrite(&ioreq);
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: Write status %Xh\n", tffsStatus));
                            //For the first time trying to write to SW protected media
                            if(tffsStatus==flWriteProtect){
                                deviceExtension->IsSWWriteProtected = TRUE;
                                if((ioreq.irSectorNo == 0) && (deviceExtension->IsPartitonTableWritten == FALSE)){
                                    tffscpy(deviceExtension->PartitonTable, deviceExtension->DataBuffer, sizeof(deviceExtension->PartitonTable));
                                    deviceExtension->IsPartitonTableWritten = TRUE;
                                }
                                status = tffsStatus = STATUS_MEDIA_WRITE_PROTECTED;
                            }
                            else
                                {
                                //status = (UCHAR)(tffsStatus == flOK) ? SRB_STATUS_SUCCESS : SRB_STATUS_ERROR;
                                if(tffsStatus==flOK)
                                    status = SRB_STATUS_SUCCESS;
                                else
                                    status = SRB_STATUS_ERROR;
                                }
                        }
                    }
                }
                //TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: ReadWrite status %Xh\n", tffsStatus));
                //status = (UCHAR)(tffsStatus == flOK) ? SRB_STATUS_SUCCESS : SRB_STATUS_ERROR;
                break;

              case SCSIOP_START_STOP_UNIT:

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: StartStopUnit\n"));
                status = SRB_STATUS_SUCCESS;
                break;

              case SCSIOP_REQUEST_SENSE:

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: RequestSense\n"));
                // this function makes sense buffers to report the results
                // of the original GET_MEDIA_STATUS command
                // status = SRB_STATUS_SUCCESS;
                break;

              default:

                TffsDebugPrint((TFFS_DEB_WARN,"Trueffs: StartIo: Unsupported command %Xh\n",Srb->Cdb[0]));

                status = SRB_STATUS_INVALID_REQUEST;

            } // end switch

            break;

          case SRB_FUNCTION_ABORT_COMMAND:

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: AbortCommand\n"));

            // Verify that SRB to abort is still outstanding.
            if (!deviceExtension->CurrentSrb) {

                TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: StartIo: SRB to abort already completed\n"));
                status = SRB_STATUS_ABORT_FAILED;
                break;
            }

          case SRB_FUNCTION_RESET_BUS:

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: Reset bus request received\n"));
            status = SRB_STATUS_SUCCESS;
            break;

          default:

            // Indicate unsupported command.
            TffsDebugPrint((TFFS_DEB_WARN,"Trueffs: StartIo: unsupported function\n"));
            status = SRB_STATUS_INVALID_REQUEST;
            break;

        } // end switch

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: Srb %Xh complete with status %Xh\n", Srb, status));

        // Clear current SRB.
        deviceExtension->CurrentSrb = NULL;

        Srb->SrbStatus = (UCHAR)status;

        if (status == SRB_STATUS_SUCCESS) {
            irp->IoStatus.Information = Srb->DataTransferLength;
        }
        else {
            irp->IoStatus.Information = 0;
        }

        // Restore the srb->DataBuffer if necesary
        if (irp->MdlAddress != NULL) {
            TffsDebugPrint((TFFS_DEB_INFO, "Trueffs: Restoration of Srb->DataBuffer done\n"));
            Srb->DataBuffer = storedSrbDataBuffer;
        }

        irp->IoStatus.Status =  TrueffsTranslateSRBStatus(status);
        IoCompleteRequest( irp, IO_DISK_INCREMENT );

    } // while there's packets to process

    } while ( TRUE );
}

NTSTATUS
QueueIrpToThread(
    IN OUT PIRP              Irp,
    IN OUT PDEVICE_EXTENSION deviceExtension
    )

/*++

Routine Description:

    This routine queues the given irp to be serviced by the Trueffs
    thread.  If the thread is down then this routine creates the thread.

Arguments:

    Irp         - Supplies the IRP to queue to the thread.

Return Value:

    May return an error if PsCreateSystemThread fails.
    Otherwise returns STATUS_PENDING and marks the IRP pending.

--*/

{
    NTSTATUS    status;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: QueueIrpToThread\n"));

    IoMarkIrpPending(Irp);

    ExInterlockedInsertTailList(&deviceExtension->listEntry,&Irp->Tail.Overlay.ListEntry,&deviceExtension->listSpinLock);

    if (!KeReadStateSemaphore(&deviceExtension->requestSemaphore)) {
        KeReleaseSemaphore(&deviceExtension->requestSemaphore,(KPRIORITY) 0,1,FALSE);
    }

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: QueueIrpToThread: Irp %Xh queued\n", Irp));
    return STATUS_PENDING;
}

NTSTATUS
TrueffsTranslateSRBStatus(
    ULONG    status
    )
/*++

Routine Description:

    This routine translates an srb status into an ntstatus.

Arguments:

    SRB status

Return Value:

    An nt status approprate for the error.

--*/

{
    switch (status) {
      case SRB_STATUS_INTERNAL_ERROR:
           return(STATUS_MEDIA_WRITE_PROTECTED); //(STATUS_WMI_READ_ONLY);
      case SRB_STATUS_SELECTION_TIMEOUT:
        return(STATUS_DEVICE_NOT_CONNECTED);
      case SRB_STATUS_SUCCESS:
        return (STATUS_SUCCESS);
      case SRB_STATUS_INVALID_REQUEST:
        return(STATUS_INVALID_DEVICE_REQUEST);
      case SRB_STATUS_ABORT_FAILED:
      default:
        return(STATUS_DISK_OPERATION_FAILED);
    }
    return(STATUS_DISK_OPERATION_FAILED);
}


NTSTATUS
TrueffsDeviceQueryId(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    BOOLEAN Fdo
    )
{
    PIO_STACK_LOCATION thisIrpSp = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION deviceExtension;
    PWSTR idString   = NULL;
    BOOLEAN bHandled = TRUE;
    NTSTATUS status;

    if (Fdo)
    {
        deviceExtension = DeviceObject->DeviceExtension;
    }
    else
    {
        PPDO_EXTENSION pdoExtension = DeviceObject->DeviceExtension;
        deviceExtension = pdoExtension->Pext;
    }

    switch (thisIrpSp->Parameters.QueryId.IdType)
    {
        case BusQueryDeviceID:

            TffsDebugPrint ((TFFS_DEB_INFO, "Trueffs: QueryDeviceID\n"));

            idString = DeviceBuildBusId(deviceExtension, Fdo);
            break;

        case BusQueryInstanceID:

            TffsDebugPrint ((TFFS_DEB_INFO, "Trueffs: QueryInstanceID\n"));

            idString = DeviceBuildInstanceId(deviceExtension, Fdo);
            break;

        case BusQueryCompatibleIDs:

            TffsDebugPrint ((TFFS_DEB_INFO, "Trueffs: QueryCompatibleIDs\n"));

            idString = DeviceBuildCompatibleId(deviceExtension, Fdo);
            break;

        case BusQueryHardwareIDs:

            TffsDebugPrint ((TFFS_DEB_INFO, "Trueffs: QueryHardwareIDs\n"));

            idString = DeviceBuildHardwareId(deviceExtension, Fdo);
            break;

        default:

            //
            // The PDO should complete this request without altering its status
            //
            status = Irp->IoStatus.Status;

            bHandled = FALSE;
            break;
    }

    if (bHandled)
    {
        if (idString == NULL)
        {
            status   = STATUS_INSUFFICIENT_RESOURCES;
            bHandled = FALSE;
        }
    }

    if (bHandled)
    {
        if (Fdo)
        {
            //
            // Forward this request down synchronously, in case a lower driver wants to handle it
            //
            IoCopyCurrentIrpStackLocationToNext(Irp);
            status = TrueffsCallDriverSync(deviceExtension->LowerDeviceObject, Irp);

            if (status == STATUS_NOT_SUPPORTED)
            {
                Irp->IoStatus.Information = (UINT_PTR) idString;
                status = STATUS_SUCCESS;
            }
            else
            {
                //
                // Someone lower down took care of this request
                //
                ExFreePool(idString);
            }
        }
        else
        {
            Irp->IoStatus.Information = (UINT_PTR) idString;
            status = STATUS_SUCCESS;
        }
    }
    else
    {
        if (Fdo)
        {
            //
            // Forward this request down synchronously, in case a lower driver understands it
            //
            IoCopyCurrentIrpStackLocationToNext(Irp);
            status = TrueffsCallDriverSync(deviceExtension->LowerDeviceObject, Irp);
        }
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}


PWSTR
DeviceBuildBusId(
    IN PDEVICE_EXTENSION deviceExtension,
    BOOLEAN Fdo
    )
{
    PUCHAR      idString;
    PCSTR       compatibleIdString;
    CCHAR       compatibleId[10];
    ULONG       compatibleIdLen;
    USHORT      idStringBufLen;
    NTSTATUS    status;
    UCHAR       tffsBusIdFormat[] = "FlashMedia\\%s_%s_%s%s_%s";
    PWCHAR      typeString;
    ANSI_STRING     ansiBusIdString;
    UNICODE_STRING  unicodeIdString;

    if (Fdo) {
        compatibleIdString = TrueffsGetCompatibleIdStringFDO (
                             deviceExtension->ScsiDeviceType
                             );
    }
        else {
        compatibleIdString = TrueffsGetCompatibleIdString (
                             deviceExtension->ScsiDeviceType
                             );
        }

    if (compatibleIdString == NULL) {
        sprintf (compatibleId,
                 "Type%d",
                 deviceExtension->ScsiDeviceType);
        compatibleIdString = compatibleId;
    }
    compatibleIdLen = strlen(compatibleIdString);

    idStringBufLen = (USHORT) (( strlen( tffsBusIdFormat ) +
                       compatibleIdLen +
                       VENDORSTRINGSIZE +
                       PRODUCTSTRINGSIZE +
                       REVISIONSTRINGSIZE +
                       SERIALSTRINGSIZE    +
                        1) * sizeof( WCHAR ));

    idString = ExAllocatePoolWithTag( PagedPool, idStringBufLen * 2, TFFSPORT_POOL_TAG);

    if (idString){

        sprintf (idString + idStringBufLen,
                 tffsBusIdFormat,
                 compatibleIdString,
                 VENDORSTRING,
                 PRODUCTSTRING,
                 REVISIONSTRING,
                 SERIALSTRING
                 );

        RtlInitAnsiString (
            &ansiBusIdString,
            idString + idStringBufLen
            );

        unicodeIdString.Length        = 0;
        unicodeIdString.MaximumLength = idStringBufLen;
        unicodeIdString.Buffer        = (PWSTR) idString;

        RtlAnsiStringToUnicodeString(
            &unicodeIdString,
            &ansiBusIdString,
            FALSE
            );

        unicodeIdString.Buffer[unicodeIdString.Length/2 + 0] = L'\0';
    }

    return (PWSTR) idString;
}

PWSTR
DeviceBuildInstanceId(
    IN PDEVICE_EXTENSION deviceExtension,
    BOOLEAN Fdo
    )
{
    PWSTR       idString;
    ULONG       idStringBufLen;
    NTSTATUS    status;
    WCHAR       tffsUniqueIdFormat[] = L"%x.%x.%x";
    UCHAR       firstId = 'A';
    UCHAR       secondId = 'G';

    idStringBufLen = 50 * sizeof( WCHAR );
    idString = ExAllocatePoolWithTag (PagedPool, idStringBufLen, TFFSPORT_POOL_TAG);
    if( idString == NULL ){

        return NULL;
    }

    // Form the string and return it.
    swprintf( idString,
              tffsUniqueIdFormat,
              firstId,
              secondId,
              deviceExtension->TrueffsDeviceNumber);

    return idString;
}


PWSTR
DeviceBuildCompatibleId(
    IN PDEVICE_EXTENSION deviceExtension,
    BOOLEAN Fdo
    )
{
    NTSTATUS        status;

    ULONG           idStringBufLen;
    PCSTR           compatibleIdString;

    ANSI_STRING     ansiCompatibleIdString;
    UNICODE_STRING  unicodeIdString;

    if (Fdo) {
        compatibleIdString = TrueffsGetCompatibleIdStringFDO (deviceExtension->ScsiDeviceType);
    }
    else {
        compatibleIdString = TrueffsGetCompatibleIdString (deviceExtension->ScsiDeviceType);
    }


    RtlInitAnsiString (
        &ansiCompatibleIdString,
        compatibleIdString
        );

    idStringBufLen = RtlAnsiStringToUnicodeSize (
                         &ansiCompatibleIdString
                         );

    unicodeIdString.Length = 0;
    unicodeIdString.MaximumLength = (USHORT) idStringBufLen;

    idStringBufLen += 2 * sizeof (WCHAR);

    unicodeIdString.Buffer = ExAllocatePoolWithTag (PagedPool, idStringBufLen, TFFSPORT_POOL_TAG);

    if (unicodeIdString.Buffer) {

            RtlAnsiStringToUnicodeString(
            &unicodeIdString,
            &ansiCompatibleIdString,
            FALSE
            );

        unicodeIdString.Buffer[unicodeIdString.Length/2 + 0] = L'\0';
        unicodeIdString.Buffer[unicodeIdString.Length/2 + 1] = L'\0';
    }

    return unicodeIdString.Buffer;
}

PWSTR
DeviceBuildHardwareId(
    IN PDEVICE_EXTENSION deviceExtension,
    BOOLEAN Fdo
    )
{
#define NUMBER_HARDWARE_STRINGS 5

    ULONG           i;
    PWSTR           idMultiString;
    PWSTR           idString;
    UCHAR           scratch[64] = { 0 };
    ULONG           idStringLen;
    NTSTATUS        status;
    ANSI_STRING     ansiCompatibleIdString;
    UNICODE_STRING  unicodeIdString;

    PCSTR           deviceTypeCompIdString;
    UCHAR           deviceTypeCompId[20];
    PCSTR           deviceTypeIdString;
    UCHAR           deviceTypeId[20];

    UCHAR           ScsiDeviceType;

    ScsiDeviceType = deviceExtension->ScsiDeviceType;

    idStringLen = (64 * NUMBER_HARDWARE_STRINGS + sizeof (UCHAR)) * sizeof (WCHAR);
    idMultiString = ExAllocatePoolWithTag (PagedPool, idStringLen, TFFSPORT_POOL_TAG);
    if (idMultiString == NULL) {

        return NULL;
    }

    if (Fdo) {
        deviceTypeIdString = TrueffsGetDeviceTypeStringFDO(ScsiDeviceType);
    }
    else {
        deviceTypeIdString = TrueffsGetDeviceTypeString(ScsiDeviceType);
    }

    if (deviceTypeIdString == NULL) {

        sprintf (deviceTypeId,
                 "Type%d",
                 ScsiDeviceType);

        deviceTypeIdString = deviceTypeId;
    }

    if (Fdo)
        deviceTypeCompIdString = TrueffsGetCompatibleIdStringFDO (ScsiDeviceType);
    else
        deviceTypeCompIdString = TrueffsGetCompatibleIdString (ScsiDeviceType);

    if (deviceTypeCompIdString == NULL) {

        sprintf (deviceTypeCompId,
                 "GenType%d",
                 ScsiDeviceType);

        deviceTypeCompIdString = deviceTypeCompId;
    }

    // Zero out the string buffer
    RtlZeroMemory(idMultiString, idStringLen);
    idString = idMultiString;

    for(i = 0; i < NUMBER_HARDWARE_STRINGS; i++) {

        // Build each of the hardware id's
        switch(i) {

            // Bus + Dev Type + Vendor + Product + Revision
            case 0: {

                sprintf(scratch, "FlashMedia\\%s", deviceTypeIdString);

                CopyField(scratch + strlen(scratch),
                          VENDORSTRING,
                          VENDORSTRINGSIZE,
                          '_');
                CopyField(scratch + strlen(scratch),
                          PRODUCTSTRING,
                          PRODUCTSTRINGSIZE,
                          '_');
                CopyField(scratch + strlen(scratch),
                          REVISIONSTRING,
                          REVISIONSTRINGSIZE,
                          '_');
                break;
            }

            // bus + vendor + product + revision[0]
            case 1: {

                sprintf(scratch, "FlashMedia\\");

                CopyField(scratch + strlen(scratch),
                          VENDORSTRING,
                          VENDORSTRINGSIZE,
                          '_');
                CopyField(scratch + strlen(scratch),
                          PRODUCTSTRING,
                          PRODUCTSTRINGSIZE,
                          '_');
                CopyField(scratch + strlen(scratch),
                          REVISIONSTRING,
                          REVISIONSTRINGSIZE,
                          '_');
                break;
            }

            // bus + device + vendor + product
            case 2: {

                sprintf(scratch, "FlashMedia\\%s", deviceTypeIdString);

                CopyField(scratch + strlen(scratch),
                          VENDORSTRING,
                          VENDORSTRINGSIZE,
                          '_');
                break;
            }

            // vendor + product + revision[0] (win9x)
            case 3: {

                CopyField(scratch,
                          VENDORSTRING,
                          VENDORSTRINGSIZE,
                          '_');
                CopyField(scratch + strlen(scratch),
                          PRODUCTSTRING,
                          PRODUCTSTRINGSIZE,
                          '_');
                CopyField(scratch + strlen(scratch),
                          REVISIONSTRING,
                          REVISIONSTRINGSIZE,
                          '_');
                break;
            }

            case 4: {

                strncpy(scratch, deviceTypeCompIdString, sizeof(scratch) - 1);
                break;
            }

            default: {

                break;
            }
        }

        RtlInitAnsiString (
            &ansiCompatibleIdString,
            scratch
            );

        unicodeIdString.Length        = 0;
        unicodeIdString.MaximumLength = (USHORT) RtlAnsiStringToUnicodeSize(
                                                     &ansiCompatibleIdString
                                                     );
        unicodeIdString.Buffer        = idString;

        RtlAnsiStringToUnicodeString(
            &unicodeIdString,
            &ansiCompatibleIdString,
            FALSE
            );

        idString[unicodeIdString.Length / 2] = L'\0';
        idString += unicodeIdString.Length / 2+ 1;
    }
    idString[0] = L'\0';

    return idMultiString;

#undef NUMBER_HARDWARE_STRINGS
}


VOID
CopyField(
    IN PUCHAR Destination,
    IN PUCHAR Source,
    IN ULONG Count,
    IN UCHAR Change
    )

/*++

Routine Description:

    This routine will copy Count string bytes from Source to Destination.  If
    it finds a nul byte in the Source it will translate that and any subsequent
    bytes into Change.  It will also replace spaces with the specified character.

Arguments:

    Destination - the location to copy bytes

    Source - the location to copy bytes from

    Count - the number of bytes to be copied

Return Value:

    none

--*/

{
    ULONG i = 0;
    BOOLEAN pastEnd = FALSE;

    for(i = 0; i < Count; i++) {
        if(!pastEnd) {
            if(Source[i] == 0) {
                pastEnd = TRUE;
                Destination[i] = Change;
            } else if(Source[i] == L' ') {
                Destination[i] = Change;
            } else {
                Destination[i] = Source[i];
            }
        } else {
            Destination[i] = Change;
        }
    }
    Destination[i] = L'\0';
    return;
}


PCSTR
TrueffsGetDeviceTypeString (
    IN ULONG DeviceType
    )
/*++

Routine Description:

    look up SCSI device type string

Arguments:

    DeviceType - SCSI device type

Return Value:

    device type string

--*/
{
    if (DeviceType < (sizeof (TffsDeviceType_tffsport) / sizeof (TFFS_DEVICE_TYPE))) {
        return TffsDeviceType_tffsport[DeviceType].DeviceTypeString;
    } else {
        return NULL;
    }
}

PCSTR
TrueffsGetDeviceTypeStringFDO (
    IN ULONG DeviceType
    )
/*++

Routine Description:

    look up SCSI device type string

Arguments:

    DeviceType - SCSI device type

Return Value:

    device type string

--*/
{
    if (DeviceType < (sizeof (TffsDeviceType_tffsport) / sizeof (TFFS_DEVICE_TYPE))) {
        return TffsDeviceTypeFDO_tffsport[DeviceType].DeviceTypeString;
    } else {
        return NULL;
    }
}


PCSTR
TrueffsGetCompatibleIdString (
    IN ULONG DeviceType
    )
/*++

Routine Description:

    look up compatible ID string

Arguments:

    DeviceType - SCSI device type

Return Value:

    compatible ID string

--*/
{
    if (DeviceType < (sizeof (TffsDeviceType_tffsport) / sizeof (TFFS_DEVICE_TYPE))) {
        return TffsDeviceType_tffsport[DeviceType].CompatibleIdString;
    } else {
        return NULL;
    }
}

PCSTR
TrueffsGetCompatibleIdStringFDO (
    IN ULONG DeviceType
    )
/*++

Routine Description:

    look up compatible ID string

Arguments:

    DeviceType - SCSI device type

Return Value:

    compatible ID string

--*/
{
    if (DeviceType < (sizeof (TffsDeviceType_tffsport) / sizeof (TFFS_DEVICE_TYPE))) {
        return TffsDeviceTypeFDO_tffsport[DeviceType].CompatibleIdString;
    } else {
        return NULL;
    }
}


PCSTR
TrueffsGetPeripheralIdString (
    IN ULONG DeviceType
    )
/*++

Routine Description:

    look up peripheral ID string

Arguments:

    DeviceType - SCSI device type

Return Value:

    Peripheral ID string

--*/
{
    if (DeviceType < (sizeof (TffsDeviceType_tffsport) / sizeof (TFFS_DEVICE_TYPE))) {
        return TffsDeviceType_tffsport[DeviceType].PeripheralIdString;
    } else {
        return NULL;
    }
}

PCSTR
TrueffsGetPeripheralIdStringFDO (
    IN ULONG DeviceType
    )
/*++

Routine Description:

    look up peripheral ID string

Arguments:

    DeviceType - SCSI device type

Return Value:

    Peripheral ID string

--*/
{
    if (DeviceType < (sizeof (TffsDeviceType_tffsport) / sizeof (TFFS_DEVICE_TYPE))) {
        return TffsDeviceTypeFDO_tffsport[DeviceType].PeripheralIdString;
    } else {
        return NULL;
    }
}


NTSTATUS
TrueffsQueryDeviceRelations (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    BOOLEAN Fdo
    )
{
    PIO_STACK_LOCATION thisIrpSp = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_RELATIONS deviceRelations;
    NTSTATUS  status = STATUS_SUCCESS;

    if (Fdo)
    {
        PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

        switch (thisIrpSp->Parameters.QueryDeviceRelations.Type)
        {
            case BusRelations:

                TffsDebugPrint ((TFFS_DEB_INFO,"Trueffs: QueryDeviceRelations: bus relations\n"));

                if (deviceExtension->ChildPdo != NULL)
                {
                    deviceRelations = ExAllocatePoolWithTag(NonPagedPool, sizeof(DEVICE_RELATIONS), TFFSPORT_POOL_TAG);

                    if (deviceRelations)
                    {
                        ObReferenceObject(deviceExtension->ChildPdo);

                        deviceRelations->Objects[0] = deviceExtension->ChildPdo;
                        deviceRelations->Count      = 1;

                        Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
                    }
                    else
                    {
                        TffsDebugPrint ((TFFS_DEB_ERROR,"Trueffs: QueryDeviceRelations: Unable to allocate DeviceRelations structures\n"));

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        Irp->IoStatus.Information = (ULONG_PTR) NULL;
                    }
                }

                Irp->IoStatus.Status = status;

                if (NT_SUCCESS(status))
                {
                    //
                    // Send the request down in case a lower driver wants to append to the device relations
                    //
                    IoCopyCurrentIrpStackLocationToNext(Irp);
                    status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);
                }
                else
                {
                    IoCompleteRequest(Irp, IO_NO_INCREMENT);
                }
                break;

            default:

                //
                // Forward this request down, in case a lower driver understands it
                //
                IoSkipCurrentIrpStackLocation(Irp);
                status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);
                break;
        }
    }
    else
    {
        switch (thisIrpSp->Parameters.QueryDeviceRelations.Type)
        {
            case TargetDeviceRelation:

                TffsDebugPrint ((TFFS_DEB_INFO,"Trueffs: QueryDeviceRelations: target relations\n"));

                deviceRelations = ExAllocatePoolWithTag(NonPagedPool, sizeof(DEVICE_RELATIONS), TFFSPORT_POOL_TAG);

                if (deviceRelations)
                {
                    ObReferenceObject(DeviceObject);

                    deviceRelations->Objects[0] = DeviceObject;
                    deviceRelations->Count      = 1;

                    Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
                }
                else
                {
                    TffsDebugPrint ((TFFS_DEB_ERROR,"Trueffs: QueryDeviceRelations: Unable to allocate DeviceRelations structures\n"));

                    status = STATUS_INSUFFICIENT_RESOURCES;
                    Irp->IoStatus.Information = (ULONG_PTR) NULL;
                }

                Irp->IoStatus.Status = status;
                break;

            default:

                //
                // Complete this request without altering its status
                //
                status = Irp->IoStatus.Status;
                break;
        }

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;
}


BOOLEAN
TrueffsOkToDetectLegacy (
    IN PDRIVER_OBJECT DriverObject
    )
{
    NTSTATUS status;
    ULONG legacyDetection;

    status = TrueffsGetParameterFromServiceSubKey (
                 DriverObject,
                 LEGACY_DETECTION,
                 REG_DWORD,
                 TRUE,
                 (PVOID) &legacyDetection,
                 0
                 );

    if (!NT_SUCCESS(status) || legacyDetection) {
        return TRUE;
    }
    else {
        return FALSE;
    }

}

NTSTATUS
TrueffsGetParameterFromServiceSubKey (
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PWSTR           ParameterName,
    IN  ULONG           ParameterType,
    IN  BOOLEAN         Read,
    OUT PVOID           *ParameterValue,
    IN  ULONG           ParameterValueWriteSize
    )
{
    NTSTATUS                 status;
    HANDLE                   deviceParameterHandle;
    RTL_QUERY_REGISTRY_TABLE queryTable[2] = { 0 };
    ULONG                    defaultParameterValue;

    CCHAR                   deviceBuffer[50];
    ANSI_STRING             ansiString;
    UNICODE_STRING          subKeyPath;
    HANDLE                  subServiceKey;

    UNICODE_STRING          unicodeParameterName;

    RtlZeroMemory(ParameterValue, ParameterValueWriteSize);

    sprintf (deviceBuffer, DRIVER_PARAMETER_SUBKEY);
    RtlInitAnsiString(&ansiString, deviceBuffer);
    status = RtlAnsiStringToUnicodeString(&subKeyPath, &ansiString, TRUE);

    if (NT_SUCCESS(status)) {

        subServiceKey = TrueffsOpenServiceSubKey (
                            DriverObject,
                            &subKeyPath
                            );

        RtlFreeUnicodeString (&subKeyPath);

        if (subServiceKey) {

            if (Read) {

                queryTable->QueryRoutine  = TrueffsRegQueryRoutine;
                queryTable->Flags         = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
                queryTable->Name          = ParameterName;
                queryTable->EntryContext  = ParameterValue;
                queryTable->DefaultType   = 0;
                queryTable->DefaultData   = NULL;
                queryTable->DefaultLength = 0;
                status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                                (PWSTR) subServiceKey,
                                                queryTable,
                                                ULongToPtr( ParameterType ),
                                                NULL);

            } else {

                RtlInitUnicodeString (&unicodeParameterName, ParameterName);
                status = ZwSetValueKey(
                             subServiceKey,
                             &unicodeParameterName,
                             0,
                             ParameterType,
                             ParameterValue,
                             ParameterValueWriteSize
                             );
            }

            // close what we open
            TrueffsCloseServiceSubKey (
                subServiceKey
                );
        }
    }
    return status;
}


NTSTATUS
TrueffsRegQueryRoutine (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    PVOID *parameterValue = EntryContext;
    ULONG parameterType = PtrToUlong(Context);

    if (ValueType == parameterType) {

        if (ValueType == REG_MULTI_SZ) {

            *parameterValue = ExAllocatePoolWithTag(PagedPool, ValueLength, TFFSPORT_POOL_TAG);
            if (*parameterValue) {

                RtlMoveMemory(*parameterValue, ValueData, ValueLength);
                return STATUS_SUCCESS;
            }

        } else if (ValueType == REG_DWORD) {

            PULONG ulongValue;

            ulongValue = (PULONG) parameterValue;
            *ulongValue = *((PULONG) ValueData);
            return STATUS_SUCCESS;
        }
    }
    return STATUS_UNSUCCESSFUL;
}


HANDLE
TrueffsOpenServiceSubKey (
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING SubKeyPath
    )
{
    PTRUEFFSDRIVER_EXTENSION trueffsDriverExtension;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE serviceKey;
    HANDLE subServiceKey;
    NTSTATUS status;
    ULONG disposition;

    trueffsDriverExtension = IoGetDriverObjectExtension(
                             DriverObject,
                             DRIVER_OBJECT_EXTENSION_ID
                             );
    if (!trueffsDriverExtension) {

        return NULL;
    }
    InitializeObjectAttributes(&objectAttributes,
                               &trueffsDriverExtension->RegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey(&serviceKey,
                       KEY_ALL_ACCESS,
                       &objectAttributes);
    if (!NT_SUCCESS(status)) {

        return NULL;
    }
    InitializeObjectAttributes(&objectAttributes,
                               SubKeyPath,
                               OBJ_CASE_INSENSITIVE,
                               serviceKey,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwCreateKey(&subServiceKey,
                        KEY_READ | KEY_WRITE,
                        &objectAttributes,
                        0,
                        (PUNICODE_STRING) NULL,
                        REG_OPTION_NON_VOLATILE,
                        &disposition);

    ZwClose(serviceKey);
    if (NT_SUCCESS(status)) {

        return subServiceKey;
    } else {

        return NULL;
    }
}


VOID
TrueffsCloseServiceSubKey (
    IN HANDLE SubServiceKey
    )
{
    ZwClose(SubServiceKey);
}


PPDO_EXTENSION
AllocatePdo(
    IN PDEVICE_EXTENSION FdoExtension
    )
/*++

Routine Description:

    Create physical device object

Arguments:

    DeviceExtension

Return Value:

    Physical device object


--*/
{
    PDEVICE_OBJECT physicalDeviceObject = NULL;
    PPDO_EXTENSION pdoExtension;
    NTSTATUS       status;
    STRING         deviceName;
    CCHAR          deviceNameBuffer[64];
    UNICODE_STRING unicodeDeviceNameString;

    sprintf(deviceNameBuffer, "\\Device\\TrueffsDevice%d",
            FdoExtension->TrueffsDeviceNumber
            );
    RtlInitString(&deviceName, deviceNameBuffer);
    status = RtlAnsiStringToUnicodeString(&unicodeDeviceNameString,
                                          &deviceName,
                                          TRUE);
    if (!NT_SUCCESS (status)) {

        return NULL;
    }

    status = IoCreateDevice(
                FdoExtension->DriverObject, // our driver object
                sizeof(PDO_EXTENSION),      // size of our extension
                &unicodeDeviceNameString,   // our name
                FILE_DEVICE_DISK,           // device type
                FILE_DEVICE_SECURE_OPEN,    // device characteristics
                FALSE,                      // not exclusive
                &physicalDeviceObject       // store new device object here
                );

    if (NT_SUCCESS(status)) {

        pdoExtension = physicalDeviceObject->DeviceExtension;
        RtlZeroMemory (pdoExtension, sizeof(PDO_EXTENSION));
        pdoExtension->DeviceObject = physicalDeviceObject;
        pdoExtension->DriverObject = FdoExtension->DriverObject;
        pdoExtension->Pext = FdoExtension;
        pdoExtension->SystemPowerState = PowerSystemWorking;
        pdoExtension->DevicePowerState = PowerDeviceD0;

    }
    RtlFreeUnicodeString (&unicodeDeviceNameString);

    if (physicalDeviceObject == NULL) {

        return NULL;
    }
    FdoExtension->ChildPdo = physicalDeviceObject;
    physicalDeviceObject->Flags |= DO_DIRECT_IO;
    physicalDeviceObject->AlignmentRequirement = FILE_WORD_ALIGNMENT;
    physicalDeviceObject->Flags &=~DO_DEVICE_INITIALIZING;

    return pdoExtension;
}

NTSTATUS
TrueffsDeviceQueryCapabilities(IN PDEVICE_EXTENSION    deviceExtension,
                               IN PDEVICE_CAPABILITIES Capabilities
                              )
{

  Capabilities->UniqueID          = FALSE;
  Capabilities->LockSupported     = FALSE;
  Capabilities->EjectSupported    = FALSE;
  Capabilities->DockDevice        = FALSE;
  Capabilities->SilentInstall     = FALSE;
  Capabilities->RawDeviceOK       = FALSE;

  Capabilities->Removable = deviceExtension->removableMedia;
  Capabilities->DeviceState[PowerSystemSleeping1] = PowerDeviceD3;
  Capabilities->DeviceState[PowerSystemSleeping2] = PowerDeviceD3;
  Capabilities->DeviceState[PowerSystemSleeping3] = PowerDeviceD3;
  Capabilities->DeviceState[PowerSystemHibernate] = PowerDeviceD3;

  Capabilities->SystemWake = PowerSystemUnspecified;
  Capabilities->DeviceWake = PowerDeviceUnspecified;
  Capabilities->D1Latency = 0;
  Capabilities->D2Latency = 0;
  Capabilities->D3Latency = 10; // 1ms

  return STATUS_SUCCESS;
}

typedef enum {
    FlashDiskInfo = 0
} WMI_DATA_BLOCK_TYPE;

#define MOFRESOURCENAME L"MofResourceName"

#define NUMBER_OF_WMI_GUID 1
WMIGUIDREGINFO TrueffsWmiGuidList[NUMBER_OF_WMI_GUID];


VOID
TrueffsWmiInit (VOID)
{
    TrueffsWmiGuidList[FlashDiskInfo].Guid  = &WmiTffsportAddressGuid;
    TrueffsWmiGuidList[FlashDiskInfo].InstanceCount = 1;
    TrueffsWmiGuidList[FlashDiskInfo].Flags = 0;
    return;
}


NTSTATUS
TrueffsWmiRegister(
    PDEVICE_EXTENSION_HEADER DevExtension
    )
{
    NTSTATUS status;

    DevExtension->WmiLibInfo.GuidCount = NUMBER_OF_WMI_GUID;
    DevExtension->WmiLibInfo.GuidList  = TrueffsWmiGuidList;

    DevExtension->WmiLibInfo.QueryWmiDataBlock  = TrueffsQueryWmiDataBlock;
    DevExtension->WmiLibInfo.QueryWmiRegInfo    = TrueffsQueryWmiRegInfo;
    DevExtension->WmiLibInfo.SetWmiDataBlock    = TrueffsSetWmiDataBlock;
    DevExtension->WmiLibInfo.SetWmiDataItem     = TrueffsSetWmiDataItem;
    DevExtension->WmiLibInfo.ExecuteWmiMethod   = NULL;
    DevExtension->WmiLibInfo.WmiFunctionControl = NULL;

    status = IoWMIRegistrationControl(DevExtension->DeviceObject,WMIREG_ACTION_REGISTER);

    if (!NT_SUCCESS(status)) {
        TffsDebugPrint((TFFS_DEB_ERROR,
            "TrueffsWmiRegister: IoWMIRegistrationControl(%x, WMI_ACTION_REGISTER) failed\n",
            DevExtension->DeviceObject));
    }
    return status;
}


NTSTATUS
TrueffsWmiDeregister(
    PDEVICE_EXTENSION_HEADER DevExtension
    )
{
    NTSTATUS status;

    status = IoWMIRegistrationControl(DevExtension->DeviceObject,WMIREG_ACTION_DEREGISTER);

    if (!NT_SUCCESS(status)) {
        TffsDebugPrint((TFFS_DEB_ERROR,
            "TrueffsWmiRegister: IoWMIRegistrationControl(%x, WMIREG_ACTION_DEREGISTER) failed\n",
            DevExtension->DeviceObject));
    }
    return status;
}


NTSTATUS
TrueffsWmiSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
Routine Description

    We have just received a System Control IRP.

    Assume that this is a WMI IRP and call into the WMI system library and let
    it handle this IRP for us.

--*/
{
    PPDO_EXTENSION pdoExtension;
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;

    pdoExtension = DeviceObject->DeviceExtension;
    if (pdoExtension) {

        status = WmiSystemControl(&pdoExtension->WmiLibInfo,
                                  DeviceObject,
                                  Irp,
                                  &disposition);
        switch(disposition)
        {
            case IrpProcessed:
            {
                // This irp has been processed and may be completed or pending.
                break;
            }

            case IrpNotCompleted:
            {
                // This irp has not been completed, but has been fully
                // processed. We will complete it now
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                break;
            }

            case IrpForward:
            case IrpNotWmi:
            default:
            {
                Irp->IoStatus.Status = status = STATUS_NOT_SUPPORTED;
                IoCompleteRequest( Irp, IO_NO_INCREMENT );
                break;
            }
        }

    } else {

        Irp->IoStatus.Status = status = STATUS_UNSUCCESSFUL;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }
    return status;
}


NTSTATUS
TrueffsQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            OutBufferSize,
    OUT PUCHAR          Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    InstanceCount is the number of instances expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PPDO_EXTENSION pdoExtension;
    NTSTATUS status;
    ULONG numBytesReturned = sizeof(WMI_FLASH_DISK_INFO);

    pdoExtension = DeviceObject->DeviceExtension;

    if (!pdoExtension) {

        Irp->IoStatus.Status = status = STATUS_UNSUCCESSFUL;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;
    }

    switch (GuidIndex) {
    case FlashDiskInfo: {

        PWMI_FLASH_DISK_INFO flashDiskInfo;

        if (OutBufferSize < sizeof(WMI_FLASH_DISK_INFO)) {
            status = STATUS_BUFFER_TOO_SMALL;

        } else {

            flashDiskInfo = (PWMI_FLASH_DISK_INFO) Buffer;

            flashDiskInfo->Number = pdoExtension->Pext->TrueffsDeviceNumber;
            flashDiskInfo->Address = (ULONG) pdoExtension->Pext->pcmciaParams.physWindow;
            flashDiskInfo->Size = pdoExtension->Pext->pcmciaParams.windowSize;

            *InstanceLengthArray = sizeof(WMI_FLASH_DISK_INFO);
            status = STATUS_SUCCESS;
        }
        break;
    }

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  numBytesReturned,
                                  IO_NO_INCREMENT
                                  );

    return status;
}


NTSTATUS
TrueffsQueryWmiRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    ClassWmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{
    PTRUEFFSDRIVER_EXTENSION trueffsDriverExtension;
    PPDO_EXTENSION pdoExtension;
    NTSTATUS status;

    pdoExtension = DeviceObject->DeviceExtension;

    if (!pdoExtension) {

        status = STATUS_UNSUCCESSFUL;
    } else {

        trueffsDriverExtension = IoGetDriverObjectExtension(
                                 pdoExtension->DriverObject,
                                 DRIVER_OBJECT_EXTENSION_ID
                                 );

        if (!trueffsDriverExtension) {

            status = STATUS_UNSUCCESSFUL;

        } else {

            *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
            *RegistryPath = &trueffsDriverExtension->RegistryPath;
            *Pdo = pdoExtension->DeviceObject;
            RtlInitUnicodeString(MofResourceName, MOFRESOURCENAME);
            status = STATUS_SUCCESS;
        }
    }
    return status;
}


NTSTATUS
TrueffsSetWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being set.

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PPDO_EXTENSION pdoExtension;
    NTSTATUS status;

    pdoExtension = DeviceObject->DeviceExtension;

    if (!pdoExtension) {

        status = STATUS_UNSUCCESSFUL;
    } else {

        switch (GuidIndex) {
        case FlashDiskInfo: {
                        status = /*STATUS_WMI_READ_ONLY;*/ STATUS_INVALID_DEVICE_REQUEST;
                        break;
                }

        default:
            status = STATUS_WMI_GUID_NOT_FOUND;
        }
        status = WmiCompleteRequest(  DeviceObject,
                                      Irp,
                                      status,
                                      0,
                                      IO_NO_INCREMENT
                                      );

    }
    return status;
}


NTSTATUS
TrueffsSetWmiDataItem(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            DataItemId,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being set.

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PPDO_EXTENSION pdoExtension;
    NTSTATUS status;

    pdoExtension = DeviceObject->DeviceExtension;

    if (!pdoExtension) {

        status = STATUS_UNSUCCESSFUL;
    } else {

        switch(GuidIndex) {

        case FlashDiskInfo: {
                        status = /*STATUS_WMI_READ_ONLY;*/ STATUS_INVALID_DEVICE_REQUEST;
                        break;
                }

        default:
            status = STATUS_WMI_GUID_NOT_FOUND;
            break;
        }
        status = WmiCompleteRequest(  DeviceObject,
                                      Irp,
                                      status,
                                      0,
                                      IO_NO_INCREMENT
                                      );

    }
    return status;
}


BOOLEAN
DebugLogEvent(IN PDRIVER_OBJECT DriverObject, IN ULONG Value)
{
    NTSTATUS status;
    ULONG DebugValue = Value;

    DebugValue++;

    // write registry debug value
    status = TrueffsGetParameterFromServiceSubKey(DriverObject,
                                                  L"DebugValue",
                                                  REG_DWORD,
                                                  FALSE,
                                                  (PVOID) &DebugValue,
                                                  sizeof(DebugValue));
    return STATUS_SUCCESS;
}


#if DBG

ULONG TffsDebugPrintLevel = TFFS_DEB_ERROR;

VOID
TrueffsDebugPrint(ULONG DebugPrintLevel, PCHAR DebugMessage, ...)
{
   va_list ap;

   va_start(ap, DebugMessage);

   if (DebugPrintLevel & TffsDebugPrintLevel)
   {
      DbgPrint(DebugMessage, ap);
   }

   va_end(ap);
}

VOID
PRINTF(PCHAR DebugMessage, ...)
{
    va_list ap;

    va_start(ap, DebugMessage);

    TrueffsDebugPrint(TFFS_DEB_INFO, DebugMessage, ap);

    va_end(ap);
}

#else

VOID
PRINTF(PCHAR DebugMessage, ...)
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tools\scsi\sensecli\sensecli.cxx ===
#include <windows.h>
#include <objbase.h>
#include <stdio.h>
#include <malloc.h>
#include <wbemidl.h>
#include <oleauto.h>

class CMySink : public IWbemObjectSink 
{ 
    UINT m_cRef; 

public: 
    CMySink() { m_cRef = 1; } 
   ~CMySink() { } 

    STDMETHODIMP         QueryInterface(REFIID, LPVOID *); 
    STDMETHODIMP_(ULONG) AddRef(void); 
    STDMETHODIMP_(ULONG) Release(void); 

    virtual HRESULT STDMETHODCALLTYPE Indicate( 
            long lObjectCount, 
            IWbemClassObject **ppObjArray 
            ); 

    virtual HRESULT STDMETHODCALLTYPE SetStatus( 
            long lFlags, 
            HRESULT hResult, 
            BSTR strParam, 
            IWbemClassObject *pObjParam 
            ); 
}; 

STDMETHODIMP 
CMySink::QueryInterface(
    REFIID riid, 
    LPVOID * ppv
    ) 
{ 
    *ppv = 0; 
    if (IID_IUnknown==riid || IID_IWbemObjectSink == riid) { 
        *ppv = (IWbemObjectSink *) this; 
        AddRef(); 
        return NOERROR; 
    } 
    return E_NOINTERFACE; 
} 

ULONG 
CMySink::AddRef() 
{
    return InterlockedIncrement((PLONG)&m_cRef);
} 

ULONG 
CMySink::Release() 
{ 
    ULONG ref = (ULONG)InterlockedDecrement((PLONG)&m_cRef);
    if (0 != ref) { 
        return m_cRef; 
    }
    delete this; 
    return 0; 
} 

HRESULT 
CMySink::Indicate( 
    long lObjectCount, 
    IWbemClassObject **ppObjArray 
    ) 
{ 
    HRESULT hr;

    // Get the info from the object. 
    // ============================= 
     
    for (long i = 0; i < lObjectCount; i++) { 
        IWbemClassObject *pObj = ppObjArray[i]; 
        VARIANT v; 
        SAFEARRAY *psa;
        BSTR prop;
        SYSTEMTIME sysTime;
        
        GetSystemTime(&sysTime);

        //
        // Dump header.
        //
        
        printf("\n");
        printf("* * * * * * * * * * %d/%d/%d %d:%d:%d.%d * * * * * * * * * *\n\n",
               sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour,
               sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);

        printf("H E A D E R\n");
        printf("- - - - - -\n");

        prop = SysAllocString(L"AdapterDeviceName");
        hr = pObj->Get(prop, 0, &v, 0, 0);
        SysFreeString(prop);
        if (hr == WBEM_S_NO_ERROR) {
            psa = v.parray;
            WCHAR *s;
            SafeArrayAccessData(psa, (void**)&s);
            wprintf(L"Adapter/Port: %s/", s);
            VariantClear(&v);
        } else {
            printf("Port: ");
        }

        prop = SysAllocString(L"Port");
        hr = pObj->Get(prop, 0, &v, 0, 0);
        SysFreeString(prop);
        if (hr == WBEM_S_NO_ERROR) {
            printf("%d\n", V_I4(&v));
            VariantClear(&v);
        }

        prop = SysAllocString(L"SrbFunction");
        hr = pObj->Get(prop, 0, &v, 0, 0);
        SysFreeString(prop);
        if (hr == WBEM_S_NO_ERROR) {
            printf("Srb Function: 0x%02x\n", (BYTE)V_I1(&v));
            VariantClear(&v);
        }

        prop = SysAllocString(L"SrbStatus");
        hr = pObj->Get(prop, 0, &v, 0, 0);
        SysFreeString(prop);
        if (hr == WBEM_S_NO_ERROR) {
            printf("Srb Status: 0x%02x\n", (BYTE)V_I1(&v));
            VariantClear(&v);
        }

        prop = SysAllocString(L"PathId");
        hr = pObj->Get(prop, 0, &v, 0, 0);
        SysFreeString(prop);
        if (hr == WBEM_S_NO_ERROR) {
            printf("Path/Target/Lun: ");
            printf("0x%02x/", (BYTE)V_I1(&v));
            VariantClear(&v);
        }

        prop = SysAllocString(L"TargetId");
        hr = pObj->Get(prop, 0, &v, 0, 0);
        SysFreeString(prop);
        if (hr == WBEM_S_NO_ERROR) {
            printf("0x%02x/", (BYTE)V_I1(&v));
            VariantClear(&v);
        }

        prop = SysAllocString(L"Lun");
        hr = pObj->Get(prop, 0, &v, 0, 0);
        SysFreeString(prop);
        if (hr == WBEM_S_NO_ERROR) {
            printf("0x%02x\n", (BYTE)V_I1(&v));
            VariantClear(&v);
        }

        printf("\n");

        //
        // Dump the CDB.
        //

        printf("C O M M A N D  D E S C R I P T O R  B L O C K\n");
        printf("- - - - - - -  - - - - - - - - - -  - - - - -\n");
        
        prop = SysAllocString(L"CmdDescriptorBlock");
        hr = pObj->Get(prop, 0, &v, 0, 0);
        SysFreeString(prop);

        if (hr == WBEM_S_NO_ERROR) {
            psa = v.parray;
            PBYTE elem;

            hr = SafeArrayAccessData(psa, (void **)&elem); 
            if (!FAILED(hr)) {
                printf("%02x %02x %02x %02x %02x %02x %02x %02x  ", 
                       elem[0], elem[1], elem[2], elem[3], 
                       elem[4], elem[5], elem[6], elem[7]);
                printf("%02x %02x %02x %02x %02x %02x %02x %02x\n", 
                       elem[8], elem[9], elem[10], elem[11], 
                       elem[12], elem[13], elem[14], elem[15]);
                printf("\n");
            }

            VariantClear(&v);
        } else {
            printf("failed to get CDB %08x\n", hr);
        }

        //
        // Dump the Sense Data.
        //
        
        printf("S E N S E  D A T A\n");
        printf("- - - - -  - - - -\n");

        prop = SysAllocString(L"SenseData");
        hr = pObj->Get(prop, 0, &v, 0, 0);
        SysFreeString(prop);

        if (hr == WBEM_S_NO_ERROR) {
            SAFEARRAY *psa = v.parray;
            PBYTE elem;

            hr = SafeArrayAccessData(psa, (void **)&elem); 
            if (!FAILED(hr)) {
                int i;                
                for (int j = 0; j < 15; j++) {
                    i = j*16;
                    printf("%02x %02x %02x %02x %02x %02x %02x %02x  ", 
                           elem[i+0], elem[i+1], elem[i+2], elem[i+3], 
                           elem[i+4], elem[i+5], elem[i+6], elem[i+7]);
                    printf("%02x %02x %02x %02x %02x %02x %02x %02x\n", 
                           elem[i+8], elem[i+9], elem[i+10], elem[i+11], 
                           elem[i+12], elem[i+13], elem[i+14], elem[i+15]);
                }
                i = j*16;
                printf("%02x %02x %02x %02x %02x %02x %02x %02x  ", 
                       elem[i+0], elem[i+1], elem[i+2], elem[i+3], 
                       elem[i+4], elem[i+5], elem[i+6], elem[i+7]);
                printf("%02x %02x %02x %02x %02x %02x %02x\n", 
                       elem[i+8], elem[i+9], elem[i+10], elem[i+11], 
                       elem[i+12], elem[i+13], elem[i+14]);
                printf("\n");
            }

            VariantClear(&v);
        } else {
            printf("failed to get CDB %08x\n", hr);
        }
        
    } 

    return WBEM_NO_ERROR; 
} 

HRESULT 
CMySink::SetStatus( 
    long lFlags, 
    HRESULT hResult, 
    BSTR strParam, 
    IWbemClassObject *pObjParam 
    ) 
{ 
    // Not called during event delivery. 
         
    return WBEM_NO_ERROR; 
} 

BOOL 
ExecuteQuery( 
    IWbemObjectSink *pDestSink, 
    IWbemServices *pSvc 
    ) 
{ 
    BSTR Language(L"WQL"); 
    BSTR Query(L"select * from ScsiPort_SenseData"); 

    HRESULT hRes = pSvc->ExecNotificationQueryAsync( 
        Language, 
        Query, 
        0,                  // Flags 
        0,                  // Context 
        pDestSink 
        ); 

    if (hRes != 0) { 
        printf("query failed %08x\n", hRes);
        return FALSE; 
    }

    return TRUE; 
} 

int __cdecl main(
    int     argc, 
    char*   argv[]
    )
{
    IWbemServices *iWbemServices = NULL;
    IWbemLocator *iWbemLocator = NULL;

    //
    // Initialize COM.
    //

    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (hr != 0) {
        printf( "CoInitializeEx failed (%08X)\n", hr );
        return -1;
    }

    hr = CoCreateInstance(CLSID_WbemLocator,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *)&iWbemLocator);

    CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_NONE, 
                         RPC_C_IMP_LEVEL_IDENTIFY, NULL, EOAC_NONE, 0);

    if (hr == S_OK) {

        BSTR nameSpace = SysAllocString(L"\\\\.\\root\\wmi");

        hr = iWbemLocator->ConnectServer(nameSpace,
                                         NULL,
                                         NULL,
                                         0L,
                                         0L,
                                         NULL,
                                         NULL,
                                         &iWbemServices);
        if (hr == S_OK) {
            
            //
            // Switch the security level to IMPERSONATE so that provider(s) 
            // will grant access to system-level objects, and so that CALL
            // authorization will be used. 
            //
            
            CoSetProxyBlanket(iWbemServices,    // proxy 
                RPC_C_AUTHN_WINNT,              // authentication service 
                RPC_C_AUTHZ_NONE,               // authorization service 
                NULL,                           // server principle name 
                RPC_C_AUTHN_LEVEL_CALL,         // authentication level 
                RPC_C_IMP_LEVEL_IMPERSONATE,    // impersonation level 
                NULL,                           // identity of the client 
                EOAC_NONE);                     // capability flags 

            //
            // Create an instance of the notification sink object.  This guy
            // handles the notifications.
            //

            CMySink *sink = new CMySink;
            
            if (ExecuteQuery(sink, iWbemServices)) {

                //
                // Hang out here until the user is finished.
                //

                char buf[8];
                gets(buf);

                //
                // We're done.  Cancel any outstanding calls before quitting.
                //

                iWbemServices->CancelAsyncCall(sink);
            }

            //
            // Release the server.
            //

            iWbemServices->Release();
            iWbemServices = NULL;
            
        } else {
            printf("failed to connect server (%08X)\n", hr);
        }

        if (nameSpace != NULL) {
            SysFreeString(nameSpace);
            nameSpace = NULL;
        }

        iWbemLocator->Release();
        iWbemLocator = NULL;
    } else {
        printf("failed to create locator (%08X)\n", hr);
    }
                                   
    CoUninitialize();
    
    printf( "\nFini\n" );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tools\spti\spti.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    spti.c

Abstract:

    Win32 application that can communicate directly with SCSI devices via
    IOCTLs.  

Author:


Environment:

    User mode.

Notes:


Revision History:

--*/

#include <windows.h>
#include <devioctl.h>
#include <ntdddisk.h>
#include <ntddscsi.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include "spti.h"

VOID
__cdecl
main(
    int argc,
    char *argv[]
    )

{
    BOOL status = 0;
    DWORD accessMode = 0, shareMode = 0;
    HANDLE fileHandle = NULL;
    IO_SCSI_CAPABILITIES capabilities;
    PUCHAR dataBuffer = NULL;
    SCSI_PASS_THROUGH_WITH_BUFFERS sptwb;
    SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER sptdwb;
    UCHAR buffer[2048];
    UCHAR string[25];
    ULONG length = 0,
          errorCode = 0,
          returned = 0,
          sectorSize = 512;

    if ((argc < 2) || (argc > 3)) {
       printf("Usage:  %s <port-name> [-mode]\n", argv[0] );
       printf("Examples:\n");
       printf("    spti g:       (open the SCSI disk class driver in SHARED READ/WRITE mode)\n");    
       printf("    spti Scsi2:   (open the SCSI miniport driver for the 3rd host adapter)\n");
       printf("    spti Tape0 w  (open the SCSI tape class driver in SHARED WRITE mode)\n");
       printf("    spti i: c     (open the SCSI CD-ROM class driver in SHARED READ mode)\n");
       return;
    }

    strcpy(string,"\\\\.\\");
    strcat(string,argv[1]);

    shareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;  // default
    accessMode = GENERIC_WRITE | GENERIC_READ;       // default

    if (argc == 3) {
       if (!_stricmp("r", argv[2])) {
          shareMode = FILE_SHARE_READ;
          }
       if (!_stricmp("w", argv[2])) {
          shareMode = FILE_SHARE_WRITE;
          }
       if (!_stricmp("c",argv[2])) {
          shareMode = FILE_SHARE_READ;
          sectorSize = 2048;
          }
       }

    fileHandle = CreateFile(string,
       accessMode,
       shareMode,
       NULL,
       OPEN_EXISTING,
       0,
       NULL);

    if (fileHandle == INVALID_HANDLE_VALUE) {
       printf("Error opening %s. Error: %d\n",
          argv[1], errorCode = GetLastError());
       PrintError(errorCode);
       return;
    }

    //
    // Get the inquiry data.
    //

    status = DeviceIoControl(fileHandle,
                             IOCTL_SCSI_GET_INQUIRY_DATA,
                             NULL,
                             0,
                             buffer,
                             sizeof(buffer),
                             &returned,
                             FALSE);

    if (!status) {
       printf( "Error reading inquiry data information; error was %d\n",
          errorCode = GetLastError());
       PrintError(errorCode);
       return;
    }

    printf("Read %Xh bytes of inquiry data Information.\n\n",returned);

    PrintInquiryData(buffer);

    //
    // Get the capabilities structure.
    //

    status = DeviceIoControl(fileHandle,
                             IOCTL_SCSI_GET_CAPABILITIES,
                             NULL,
                             0,
                             &capabilities,
                             sizeof(IO_SCSI_CAPABILITIES),
                             &returned,
                             FALSE);

    if (!status ) {
       printf( "Error in io control; error was %d\n",
          errorCode = GetLastError() );
       PrintError(errorCode);
       return;
    }
    printf("            ***** MODE SENSE -- return all pages *****\n");
    printf("            *****      with SenseInfo buffer     *****\n\n");

    ZeroMemory(&sptwb,sizeof(SCSI_PASS_THROUGH_WITH_BUFFERS));

    sptwb.spt.Length = sizeof(SCSI_PASS_THROUGH);
    sptwb.spt.PathId = 0;
    sptwb.spt.TargetId = 1;
    sptwb.spt.Lun = 0;
    sptwb.spt.CdbLength = CDB6GENERIC_LENGTH;
    sptwb.spt.SenseInfoLength = 24;
    sptwb.spt.DataIn = SCSI_IOCTL_DATA_IN;
    sptwb.spt.DataTransferLength = 192;
    sptwb.spt.TimeOutValue = 2;
    sptwb.spt.DataBufferOffset =
       offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucDataBuf);
    sptwb.spt.SenseInfoOffset = 
       offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucSenseBuf);
    sptwb.spt.Cdb[0] = SCSIOP_MODE_SENSE;
    sptwb.spt.Cdb[2] = MODE_SENSE_RETURN_ALL;
    sptwb.spt.Cdb[4] = 192;
    length = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucDataBuf) +
       sptwb.spt.DataTransferLength;

    status = DeviceIoControl(fileHandle,
                             IOCTL_SCSI_PASS_THROUGH,
                             &sptwb,
                             sizeof(SCSI_PASS_THROUGH),
                             &sptwb,
                             length,
                             &returned,
                             FALSE);

    PrintStatusResults(status,returned,&sptwb,length);

    printf("            ***** MODE SENSE -- return all pages *****\n");
    printf("            *****    without SenseInfo buffer    *****\n\n");

    ZeroMemory(&sptwb,sizeof(SCSI_PASS_THROUGH_WITH_BUFFERS));

    sptwb.spt.Length = sizeof(SCSI_PASS_THROUGH);
    sptwb.spt.PathId = 0;
    sptwb.spt.TargetId = 1;
    sptwb.spt.Lun = 0;
    sptwb.spt.CdbLength = CDB6GENERIC_LENGTH;
    sptwb.spt.SenseInfoLength = 0;
    sptwb.spt.DataIn = SCSI_IOCTL_DATA_IN;
    sptwb.spt.DataTransferLength = 192;
    sptwb.spt.TimeOutValue = 2;
    sptwb.spt.DataBufferOffset =
       offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucDataBuf);
    sptwb.spt.SenseInfoOffset = 
       offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucSenseBuf);
    sptwb.spt.Cdb[0] = SCSIOP_MODE_SENSE;
    sptwb.spt.Cdb[2] = MODE_SENSE_RETURN_ALL;
    sptwb.spt.Cdb[4] = 192;
    length = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucDataBuf) +
       sptwb.spt.DataTransferLength;

    status = DeviceIoControl(fileHandle,
                             IOCTL_SCSI_PASS_THROUGH,
                             &sptwb,
                             sizeof(SCSI_PASS_THROUGH),
                             &sptwb,
                             length,
                             &returned,
                             FALSE);

    PrintStatusResults(status,returned,&sptwb,length);
    
    printf("            *****      TEST UNIT READY      *****\n");
    printf("            *****    DataBufferLength = 0   *****\n\n");


    ZeroMemory(&sptwb,sizeof(SCSI_PASS_THROUGH_WITH_BUFFERS));

    sptwb.spt.Length = sizeof(SCSI_PASS_THROUGH);
    sptwb.spt.PathId = 0;
    sptwb.spt.TargetId = 1;
    sptwb.spt.Lun = 0;
    sptwb.spt.CdbLength = CDB6GENERIC_LENGTH;
    sptwb.spt.SenseInfoLength = 24;
    sptwb.spt.DataIn = SCSI_IOCTL_DATA_IN;
    sptwb.spt.DataTransferLength = 0;
    sptwb.spt.TimeOutValue = 2;
    sptwb.spt.DataBufferOffset =
       offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucDataBuf);
    sptwb.spt.SenseInfoOffset =
       offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucSenseBuf);
    sptwb.spt.Cdb[0] = SCSIOP_TEST_UNIT_READY;
    length = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucDataBuf);

    status = DeviceIoControl(fileHandle,
                             IOCTL_SCSI_PASS_THROUGH,
                             &sptwb,
                             sizeof(SCSI_PASS_THROUGH),
                             &sptwb,
                             length,
                             &returned,
                             FALSE);

    PrintStatusResults(status,returned,&sptwb,length);

    //
    //  Do a mode sense with a bad data buffer offset.  This should fail.
    //
    printf("            *****      MODE SENSE -- return all pages      *****\n");
    printf("            *****   bad DataBufferOffset -- should fail    *****\n\n");

    ZeroMemory(&sptwb,sizeof(SCSI_PASS_THROUGH_WITH_BUFFERS));

    sptwb.spt.Length = sizeof(SCSI_PASS_THROUGH);
    sptwb.spt.PathId = 0;
    sptwb.spt.TargetId = 1;
    sptwb.spt.Lun = 0;
    sptwb.spt.CdbLength = CDB6GENERIC_LENGTH;
    sptwb.spt.SenseInfoLength = 0;
    sptwb.spt.DataIn = SCSI_IOCTL_DATA_IN;
    sptwb.spt.DataTransferLength = 192;
    sptwb.spt.TimeOutValue = 2;
    sptwb.spt.DataBufferOffset = 0;
    sptwb.spt.SenseInfoOffset =
       offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucSenseBuf);
    sptwb.spt.Cdb[0] = SCSIOP_MODE_SENSE;
    sptwb.spt.Cdb[2] = MODE_SENSE_RETURN_ALL;
    sptwb.spt.Cdb[4] = 192;
    length = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucDataBuf) +
       sptwb.spt.DataTransferLength;
    status = DeviceIoControl(fileHandle,
                             IOCTL_SCSI_PASS_THROUGH,
                             &sptwb,
                             sizeof(SCSI_PASS_THROUGH),
                             &sptwb,
                             length,
                             &returned,
                             FALSE);

    PrintStatusResults(status,returned,&sptwb,length);


    //
    // Get caching mode sense page.
    //
    printf("            *****               MODE SENSE                  *****\n");
    printf("            *****     return caching mode sense page        *****\n\n");

    ZeroMemory(&sptwb,sizeof(SCSI_PASS_THROUGH_WITH_BUFFERS));

    sptwb.spt.Length = sizeof(SCSI_PASS_THROUGH);
    sptwb.spt.PathId = 0;
    sptwb.spt.TargetId = 1;
    sptwb.spt.Lun = 0;
    sptwb.spt.CdbLength = CDB6GENERIC_LENGTH;
    sptwb.spt.SenseInfoLength = 24;
    sptwb.spt.DataIn = SCSI_IOCTL_DATA_IN;
    sptwb.spt.DataTransferLength = 192;
    sptwb.spt.TimeOutValue = 2;
    sptwb.spt.DataBufferOffset =
       offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucDataBuf);
    sptwb.spt.SenseInfoOffset = 
       offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucSenseBuf);
    sptwb.spt.Cdb[0] = SCSIOP_MODE_SENSE;
    sptwb.spt.Cdb[1] = 0x08; // target shall not return any block descriptors
    sptwb.spt.Cdb[2] = MODE_PAGE_CACHING;
    sptwb.spt.Cdb[4] = 192;
    length = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucDataBuf) +
       sptwb.spt.DataTransferLength;
    status = DeviceIoControl(fileHandle,
                             IOCTL_SCSI_PASS_THROUGH,
                             &sptwb,
                             sizeof(SCSI_PASS_THROUGH),
                             &sptwb,
                             length,
                             &returned,
                             FALSE);

    PrintStatusResults(status,returned,&sptwb,length);

    printf("            *****       WRITE DATA BUFFER operation         *****\n");

    ZeroMemory(&sptdwb, sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER));
    dataBuffer = AllocateAlignedBuffer(sectorSize,capabilities.AlignmentMask);
    FillMemory(dataBuffer,sectorSize/2,'N');
    FillMemory(dataBuffer + sectorSize/2,sectorSize/2,'T');

    sptdwb.sptd.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
    sptdwb.sptd.PathId = 0;
    sptdwb.sptd.TargetId = 1;
    sptdwb.sptd.Lun = 0;
    sptdwb.sptd.CdbLength = CDB10GENERIC_LENGTH;
    sptdwb.sptd.SenseInfoLength = 24;
    sptdwb.sptd.DataIn = SCSI_IOCTL_DATA_OUT;
    sptdwb.sptd.DataTransferLength = sectorSize;
    sptdwb.sptd.TimeOutValue = 2;
    sptdwb.sptd.DataBuffer = dataBuffer;
    sptdwb.sptd.SenseInfoOffset =
       offsetof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER,ucSenseBuf);
    sptdwb.sptd.Cdb[0] = SCSIOP_WRITE_DATA_BUFF;
    sptdwb.sptd.Cdb[1] = 2;                         // Data mode
    sptdwb.sptd.Cdb[7] = (UCHAR)(sectorSize >> 8);  // Parameter List length
    sptdwb.sptd.Cdb[8] = 0;
    length = sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER);
    status = DeviceIoControl(fileHandle,
                             IOCTL_SCSI_PASS_THROUGH_DIRECT,
                             &sptdwb,
                             length,
                             &sptdwb,
                             length,
                             &returned,
                             FALSE);

    PrintStatusResults(status,returned,
       (PSCSI_PASS_THROUGH_WITH_BUFFERS)&sptdwb,length);
    if ((sptdwb.sptd.ScsiStatus == 0) && (status != 0)) {
       PrintDataBuffer(dataBuffer,sptdwb.sptd.DataTransferLength);
       }

    printf("            *****       READ DATA BUFFER operation         *****\n");

    ZeroMemory(&sptdwb, sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER));
    ZeroMemory(dataBuffer,sectorSize);

    sptdwb.sptd.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
    sptdwb.sptd.PathId = 0;
    sptdwb.sptd.TargetId = 1;
    sptdwb.sptd.Lun = 0;
    sptdwb.sptd.CdbLength = CDB10GENERIC_LENGTH;
    sptdwb.sptd.DataIn = SCSI_IOCTL_DATA_IN;
    sptdwb.sptd.SenseInfoLength = 24;
    sptdwb.sptd.DataTransferLength = sectorSize;
    sptdwb.sptd.TimeOutValue = 2;
    sptdwb.sptd.DataBuffer = dataBuffer;
    sptdwb.sptd.SenseInfoOffset =
       offsetof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER,ucSenseBuf);
    sptdwb.sptd.Cdb[0] = SCSIOP_READ_DATA_BUFF;
    sptdwb.sptd.Cdb[1] = 2;                         // Data mode
    sptdwb.sptd.Cdb[7] = (UCHAR)(sectorSize >> 8);  // Parameter List length
    sptdwb.sptd.Cdb[8] = 0;
    length = sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER);
    status = DeviceIoControl(fileHandle,
                             IOCTL_SCSI_PASS_THROUGH_DIRECT,
                             &sptdwb,
                             length,
                             &sptdwb,
                             length,
                             &returned,
                             FALSE);

    PrintStatusResults(status,returned,
       (PSCSI_PASS_THROUGH_WITH_BUFFERS)&sptdwb,length);
    if ((sptdwb.sptd.ScsiStatus == 0) && (status != 0)) {
       PrintDataBuffer(dataBuffer,sptdwb.sptd.DataTransferLength);
       }
}

VOID
PrintError(ULONG ErrorCode)
{
    UCHAR errorBuffer[80];
    ULONG count;

    count = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                  NULL,
                  ErrorCode,
                  0,
                  errorBuffer,
                  sizeof(errorBuffer),
                  NULL
                  );

    if (count != 0) {
        printf("%s\n", errorBuffer);
    } else {
        printf("Format message failed.  Error: %d\n", GetLastError());
    }
}

VOID
PrintDataBuffer(PUCHAR DataBuffer, ULONG BufferLength)
{
    ULONG Cnt;

    printf("      00  01  02  03  04  05  06  07   08  09  0A  0B  0C  0D  0E  0F\n");
    printf("      ---------------------------------------------------------------\n");
    for (Cnt = 0; Cnt < BufferLength; Cnt++) {
       if ((Cnt) % 16 == 0) {
          printf(" %03X  ",Cnt);
          }
       printf("%02X  ", DataBuffer[Cnt]);
       if ((Cnt+1) % 8 == 0) {
          printf(" ");
          }
       if ((Cnt+1) % 16 == 0) {
          printf("\n");
          }
       }
    printf("\n\n");
}

VOID
PrintInquiryData(PCHAR  DataBuffer)
{
    PSCSI_ADAPTER_BUS_INFO  adapterInfo;
    PSCSI_INQUIRY_DATA inquiryData;
    ULONG i,
          j;

    adapterInfo = (PSCSI_ADAPTER_BUS_INFO) DataBuffer;
    
    printf("Bus\n");
    printf("Num TID LUN Claimed String                       Inquiry Header\n");
    printf("--- --- --- ------- ---------------------------- -----------------------\n");

    for (i = 0; i < adapterInfo->NumberOfBuses; i++) {
       inquiryData = (PSCSI_INQUIRY_DATA) (DataBuffer +
          adapterInfo->BusData[i].InquiryDataOffset);
       while (adapterInfo->BusData[i].InquiryDataOffset) {
          printf(" %d   %d  %3d    %s    %.28s ",
             i,
             inquiryData->TargetId,
             inquiryData->Lun,
             (inquiryData->DeviceClaimed) ? "Y" : "N",
             &inquiryData->InquiryData[8]);
          for (j = 0; j < 8; j++) {
             printf("%02X ", inquiryData->InquiryData[j]);
             }
          printf("\n");
          if (inquiryData->NextInquiryDataOffset == 0) {
             break;
             }
          inquiryData = (PSCSI_INQUIRY_DATA) (DataBuffer +
             inquiryData->NextInquiryDataOffset);
          }
       }

    printf("\n\n");
}

PUCHAR
AllocateAlignedBuffer(ULONG size, ULONG Align)
{
    PUCHAR ptr;

    UINT_PTR    Align64 = (UINT_PTR)Align;
    
    if (!Align) {
       ptr = malloc(size);
       }
    else {
       ptr = malloc(size + Align);
       ptr = (PUCHAR)(((UINT_PTR)ptr + Align64) & ~Align64);
       }
    if (ptr == NULL) {
       printf("Memory allocation error.  Terminating program\n");
       exit(1);
       }
    else {
       return ptr;
       }
}

VOID
PrintStatusResults(
    BOOL status,DWORD returned,PSCSI_PASS_THROUGH_WITH_BUFFERS psptwb,
    ULONG length)
{
    ULONG errorCode;

    if (!status ) {
       printf( "Error: %d  ",
          errorCode = GetLastError() );
       PrintError(errorCode);
       return;
       }
    if (psptwb->spt.ScsiStatus) {
       PrintSenseInfo(psptwb);
       return;
       }
    else {
       printf("Scsi status: %02Xh, Bytes returned: %Xh, ",
          psptwb->spt.ScsiStatus,returned);
       printf("Data buffer length: %Xh\n\n\n",
          psptwb->spt.DataTransferLength);
       PrintDataBuffer((PUCHAR)psptwb,length);
       }
}

VOID
PrintSenseInfo(PSCSI_PASS_THROUGH_WITH_BUFFERS psptwb)
{
    int i;

    printf("Scsi status: %02Xh\n\n",psptwb->spt.ScsiStatus);
    if (psptwb->spt.SenseInfoLength == 0) {
       return;
       }
    printf("Sense Info -- consult SCSI spec for details\n");
    printf("-------------------------------------------------------------\n");
    for (i=0; i < psptwb->spt.SenseInfoLength; i++) {
       printf("%02X ",psptwb->ucSenseBuf[i]);
       }
    printf("\n\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tools\scsi\reserve\reserve.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    reserve.c

Abstract:

    A tool for issuing persistent reserve commands to a device to see how
    it behaves.

Environment:

    User mode only

Revision History:

    03-26-96 : Created

--*/


#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include <assert.h>

#include <windows.h>
#include <devioctl.h>

#include <ntddscsi.h>

#define _NTSRB_     // to keep srb.h from being included
#include <scsi.h>

#ifdef DBG
#define dbg(x) x
#define HELP_ME() printf("Reached line %4d\n", __LINE__);
#else
#define dbg(x)    /* x */
#define HELP_ME() /* printf("Reached line %4d\n", __LINE__); */
#endif

#define ARGUMENT_USED(x)    (x == NULL)

typedef struct {
    char *Name;
    char *Description;
    DWORD (*Function)(HANDLE device, int argc, char *argv[]);
} COMMAND;

typedef struct  {
    SCSI_PASS_THROUGH   Spt;
    UCHAR               SenseInfoBuffer[18];
    UCHAR               DataBuffer[0];          // Allocate buffer space
                                                // after this
} SPT_WITH_BUFFERS, *PSPT_WITH_BUFFERS;

DWORD ReadReservations(HANDLE device, int argc, char *argv[]);
DWORD ReadKeys(HANDLE device, int argc, char *argv[]);
DWORD RegisterCommand(HANDLE device, int argc, char *argv[]);
DWORD ClearCommand(HANDLE device, int argc, char *argv[]);
DWORD ReleaseCommand(HANDLE device, int argc, char *argv[]);
DWORD ReserveCommand(HANDLE device, int argc, char *argv[]);
DWORD PreemptCommand(HANDLE device, int argc, char *argv[]);

DWORD TestCommand(HANDLE device, int argc, char *argv[]);
DWORD ListCommand(HANDLE device, int argc, char *argv[]);

BOOL
SendCdbToDevice(
    IN      HANDLE  DeviceHandle,
    IN      PCDB    Cdb,
    IN      UCHAR   CdbSize,
    IN      PVOID   Buffer,
    IN OUT  PDWORD  BufferSize,
    IN      BOOLEAN DataIn
    );

HANDLE
ParseDevicePath(
    IN PUCHAR Path
    );

VOID
PrintBuffer(
    IN  PUCHAR Buffer,
    IN  DWORD  Size
    );

//
// List of commands
// all command names are case sensitive
// arguments are passed into command routines
// list must be terminated with NULL command
// command will not be listed in help if description == NULL
//

COMMAND CommandArray[] = {
    {"help", "help for all commands", ListCommand},
    {"test", "tests the command engine", TestCommand},
    {"clear", "clears the specified registration", ClearCommand},
    {"preempt", "preempts the reservations of another registrant\n", PreemptCommand},
    {"read-reservations", "reads the current reservation info", ReadReservations},
    {"read-keys", "reads the list of registered reservation keys", ReadKeys},
    {"register", "registers the initiator using a specified key value", RegisterCommand},
    {"release", "releases the specified device", ReleaseCommand},
    {"reserve", "reserves the target using a specified key value", ReserveCommand},
    {NULL, NULL, NULL}
    };

#define STATUS_SUCCESS 0

#define LO_PTR        PtrToUlong
#define HI_PTR(_ptr_) ((DWORD)(((DWORDLONG)(ULONG_PTR)(_ptr_)) >> 32))

ULONG PortId = 0xffffffff;
UCHAR PathId = 0xff;
UCHAR TargetId = 0xff;
UCHAR Lun = 0xff;

int __cdecl main(int argc, char *argv[])
{
    int i = 0;
    HANDLE h;

    if(argc < 3) {
        printf("Usage: cdp <command> <drive> [parameters]\n");
        printf("possible commands: \n");
        ListCommand(NULL, argc, argv);
        printf("\n");
        return -1;
    }

    h = ParseDevicePath(argv[2]);

    //
    // Iterate through the command array and find the correct function to
    // call.
    //

    while(CommandArray[i].Name != NULL) {

        if(strcmp(argv[1], CommandArray[i].Name) == 0) {

            (CommandArray[i].Function)(h, (argc - 1), &(argv[1]));

            break;
        }

        i++;
    }

    if(CommandArray[i].Name == NULL) {
        printf("Unknown command %s\n", argv[2]);
    }

    CloseHandle(h);

    return 0;
}

//
// TRUE if success
// FALSE if failed
// call GetLastError() for reason
//

BOOL
SendCdbToDevice(
    IN      HANDLE  DeviceHandle,
    IN      PCDB    Cdb,
    IN      UCHAR   CdbSize,
    IN      PVOID   Buffer,
    IN OUT  PDWORD  BufferSize,
    IN      BOOLEAN DataIn
    )
{
    PSPT_WITH_BUFFERS p;
    DWORD packetSize;
    DWORD returnedBytes;
    BOOL returnValue;
    ULONG i;

    if (Cdb == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ((*BufferSize != 0) && (Buffer == NULL)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ((*BufferSize == 0) && (DataIn == 1)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    packetSize = sizeof(SPT_WITH_BUFFERS) + (*BufferSize);
    p = (PSPT_WITH_BUFFERS)malloc(packetSize);

    if (p == NULL) {

        if (DataIn && (*BufferSize)) {
            memset(Buffer, 0, (*BufferSize));
        }
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    //
    // this has the side effect of pre-zeroing the output buffer
    // if DataIn is TRUE
    //

    memset(p, 0, packetSize);
    memcpy(p->Spt.Cdb, Cdb, CdbSize);

    p->Spt.Length             = sizeof(SCSI_PASS_THROUGH);
    p->Spt.CdbLength          = CdbSize;
    p->Spt.SenseInfoLength    = 12;
    p->Spt.DataIn             = (DataIn ? 1 : 0);
    p->Spt.DataTransferLength = (*BufferSize);
    p->Spt.TimeOutValue       = 20;
    p->Spt.SenseInfoOffset =
        FIELD_OFFSET(SPT_WITH_BUFFERS, SenseInfoBuffer[0]);
    p->Spt.DataBufferOffset =
        FIELD_OFFSET(SPT_WITH_BUFFERS, DataBuffer[0]);

    //
    // Set the address fields in the spt.  If this is being sent to a lun then 
    // the values will be overwritten.  If it's being sent to the controller
    // then they're a requirement.
    //

    p->Spt.PathId = PathId;
    p->Spt.TargetId = TargetId;
    p->Spt.Lun = Lun;

    //
    // If this is a data-out command copy from the caller's buffer into the
    // one in the SPT block.
    //

    if(!DataIn) {
        memcpy(p->DataBuffer, Buffer, *BufferSize);
    }

    printf("Sending command: ");
    for(i = 0; i < p->Spt.CdbLength; i++) {
        printf("%02x ", p->Spt.Cdb[i]);
    }
    printf("\n");

    if(!DataIn) {
        printf("Data Buffer:\n    ");
        for(i = 0; i < *BufferSize; i++) {
            printf("%02x ", p->DataBuffer[i]);

            if((i + 1) % 16 == 0) {
                printf("\n    ");
            } else if((i + 1) % 8 == 0) {
                printf("- ");
            }
        }
        printf("\n");
    }

    returnedBytes = *BufferSize;
    returnValue = DeviceIoControl(DeviceHandle,
                                  IOCTL_SCSI_PASS_THROUGH,
                                  p,
                                  packetSize,
                                  p,
                                  packetSize,
                                  &returnedBytes,
                                  FALSE);

    //
    // if successful, need to copy the buffer to caller's buffer
    //

    if(returnValue && DataIn) {
        ULONG t = min(returnedBytes, *BufferSize);
        *BufferSize = returnedBytes;
        memcpy(Buffer, p->DataBuffer, t);
    }

    if(p->Spt.ScsiStatus != SCSISTAT_GOOD) {
        printf("ScsiStatus: %x\n", p->Spt.ScsiStatus);

        if(p->Spt.ScsiStatus == SCSISTAT_CHECK_CONDITION) {
            printf("SenseData: \n");
            PrintBuffer(p->SenseInfoBuffer, sizeof(p->SenseInfoBuffer));
        }
    }

    free(p);
    return returnValue;
}

VOID
PrintBuffer(
    IN  PUCHAR Buffer,
    IN  DWORD  Size
    )
{
    DWORD offset = 0;

    while (Size > 0x10) {
        printf( "%08x:"
                "  %02x %02x %02x %02x %02x %02x %02x %02x"
                "  %02x %02x %02x %02x %02x %02x %02x %02x"
                "\n",
                offset,
                *(Buffer +  0), *(Buffer +  1), *(Buffer +  2), *(Buffer +  3),
                *(Buffer +  4), *(Buffer +  5), *(Buffer +  6), *(Buffer +  7),
                *(Buffer +  8), *(Buffer +  9), *(Buffer + 10), *(Buffer + 11),
                *(Buffer + 12), *(Buffer + 13), *(Buffer + 14), *(Buffer + 15)
                );
        Size -= 0x10;
        offset += 0x10;
        Buffer += 0x10;
    }

    if (Size != 0) {

        DWORD spaceIt;

        printf("%08x:", offset);
        for (spaceIt = 0; Size != 0; Size--) {

            if ((spaceIt%8)==0) {
                printf(" "); // extra space every eight chars
            }
            printf(" %02x", *Buffer);
            spaceIt++;
            Buffer++;
        }
        printf("\n");

    }
    return;


}

DWORD TestCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Tests the command "parsing"

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  should be zero

    argv - the additional arguments

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/

{
    int i;
    ULONGLONG dest;
    ULONGLONG src = 0x70;

    printf("Test - %d additional arguments\n", argc);

    printf("got handle %#p\n", device);

    for(i = 0; i < argc; i++) {
        printf("arg %d: %s\n", i, argv[i]);
    }

    printf("src = %#I64x\n", src);
    REVERSE_BYTES_QUAD(&dest, &src);
    printf("dest = %#I64x\n", src);

    return STATUS_SUCCESS;
}

DWORD ListCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Prints out the command list

Arguments:
    device - unused

    argc - unused

    argv - unused

Return Value:

    STATUS_SUCCESS

--*/

{
    int i = 0;

    while(CommandArray[i].Name != NULL) {

        if(CommandArray[i].Description != NULL) {

            printf("\t%s - %s\n",
                   CommandArray[i].Name,
                   CommandArray[i].Description);
        }

        i++;
    }

    return STATUS_SUCCESS;
}

DWORD ReadKeys(HANDLE device, int argc, char *argv[])
{
    CDB cdb;
    USHORT allocationLength;
    ULONG returnedBytes;
    ULONG additionalLength;

    PRI_REGISTRATION_LIST b1;
    PPRI_REGISTRATION_LIST registrationList = &(b1);

    BOOL ok;

    ULONG i;

    memset(&cdb, 0, sizeof(CDB));

    cdb.PERSISTENT_RESERVE_IN.OperationCode = SCSIOP_PERSISTENT_RESERVE_IN;
    cdb.PERSISTENT_RESERVE_IN.ServiceAction = RESERVATION_ACTION_READ_KEYS;

    allocationLength = sizeof(PRI_REGISTRATION_LIST);
    REVERSE_BYTES_SHORT(&(cdb.PERSISTENT_RESERVE_IN.AllocationLength),
                        &(allocationLength));

    returnedBytes = allocationLength;
    ok = SendCdbToDevice(device,
                         &cdb,
                         sizeof(cdb.PERSISTENT_RESERVE_IN),
                         registrationList,
                         &returnedBytes,
                         TRUE);

    if(!ok) return GetLastError();

    printf("%x bytes returned.\n", returnedBytes);

    REVERSE_BYTES(&returnedBytes, &(registrationList->Generation));
    printf("Generation number %#08lx\n", returnedBytes);

    REVERSE_BYTES(&additionalLength, &(registrationList->AdditionalLength));
    printf("additional length is %x\n", additionalLength);

    if(additionalLength > 0) {

        USHORT size = (USHORT) additionalLength + sizeof(PRI_REGISTRATION_LIST);

        registrationList = malloc(size);
        if(registrationList == NULL) {
            printf("Unable to allocate %d bytes for data buffer\n", size);
            return -1;
        }

        REVERSE_BYTES_SHORT(&(cdb.PERSISTENT_RESERVE_IN.AllocationLength),
                            &(size));

        returnedBytes = size;

        ok = SendCdbToDevice(device,
                             &cdb,
                             sizeof(cdb.PERSISTENT_RESERVE_IN),
                             registrationList,
                             &returnedBytes,
                             TRUE);

        if(!ok) return GetLastError();

        printf("%x bytes returned\n", returnedBytes);

        for(i = 0; i < additionalLength / sizeof(ULONGLONG); i++) {
            ULONGLONG key;
    
            REVERSE_BYTES_QUAD(&key, registrationList->ReservationKeyList[i]);
            printf("\tKey %d: %#I64x\n", i, key);
        }
    }

    return 0;
}

DWORD RegisterCommand(HANDLE device, int argc, char *argv[])
{
    CDB cdb;
    ULONGLONG newKey, oldKey;

    USHORT allocationLength;
    ULONG returnedBytes;

    PRO_PARAMETER_LIST parameters;

    BOOL ok;

    memset(&cdb, 0, sizeof(CDB));

    printf("argc = %d\n", argc);

    if(argc < 3) {
        goto usage;
    }

    //
    // Pick the registration key out of the parameters.
    //

    returnedBytes = sscanf(argv[2], "%I64x", &newKey);
    if(returnedBytes == 0) {
        goto usage;
    }

    if(argc >= 4) {
        returnedBytes = sscanf(argv[3], "%I64x", &oldKey);
        if(returnedBytes == 0) {
            goto usage;
        }
    } else {
        oldKey = 0;
    }

    printf("new-key value %#I64x (%I64dd) will be used\n", newKey, newKey);
    printf("old-key value %#I64x (%I64dd) will be used\n", oldKey, oldKey);

    cdb.PERSISTENT_RESERVE_OUT.OperationCode = SCSIOP_PERSISTENT_RESERVE_OUT;
    cdb.PERSISTENT_RESERVE_OUT.ServiceAction = RESERVATION_ACTION_REGISTER;

    allocationLength = sizeof(PRO_PARAMETER_LIST);
    returnedBytes = allocationLength;
    REVERSE_BYTES_SHORT(&(cdb.PERSISTENT_RESERVE_OUT.ParameterListLength),
                        &(allocationLength));

    memset(&parameters, 0, sizeof(PRO_PARAMETER_LIST));
    REVERSE_BYTES_QUAD(&(parameters.ReservationKey), &oldKey);
    REVERSE_BYTES_QUAD(&(parameters.ServiceActionReservationKey), &newKey);

    ok = SendCdbToDevice(device,
                         &cdb,
                         sizeof(cdb.PERSISTENT_RESERVE_OUT),
                         &parameters,
                         &returnedBytes,
                         FALSE);

    if(!ok) {
        printf("Error %d returned\n", GetLastError());
    } else {
        printf("Command succeeded\n");
    }

    return GetLastError();

usage:
    printf("reserve register <new-key> <old-key>\n");
    printf("\tKeys are 64-bit values in hex notation\n");
    return -1;
}

DWORD ClearCommand(HANDLE device, int argc, char *argv[])
{
    CDB cdb;
    ULONGLONG key;

    USHORT allocationLength;
    ULONG returnedBytes;

    PRO_PARAMETER_LIST parameters;

    BOOL ok;

    memset(&cdb, 0, sizeof(CDB));

    if(argc < 3) {
        goto usage;
    }

    //
    // Pick the registration key out of the parameters.
    //

    returnedBytes = sscanf(argv[2], "%I64x", &key);
    if(returnedBytes == 0) {
        goto usage;
    }

    printf("key value %#I64x (%I64dd) will be cleared\n", key, key);

    cdb.PERSISTENT_RESERVE_OUT.OperationCode = SCSIOP_PERSISTENT_RESERVE_OUT;
    cdb.PERSISTENT_RESERVE_OUT.ServiceAction = RESERVATION_ACTION_CLEAR;

    allocationLength = sizeof(PRO_PARAMETER_LIST);
    returnedBytes = allocationLength;
    REVERSE_BYTES_SHORT(&(cdb.PERSISTENT_RESERVE_OUT.ParameterListLength),
                        &(allocationLength));

    memset(&parameters, 0, sizeof(PRO_PARAMETER_LIST));
    REVERSE_BYTES_QUAD(&(parameters.ReservationKey), &key);

    ok = SendCdbToDevice(device,
                         &cdb,
                         sizeof(cdb.PERSISTENT_RESERVE_OUT),
                         &parameters,
                         &returnedBytes,
                         FALSE);

    if(!ok) {
        printf("Error %d returned\n", GetLastError());
    } else {
        printf("Command succeeded\n");
    }

    return GetLastError();

usage:
    printf("reserve clear <key>\n");
    printf("\tKeys are 64-bit values in hex notation\n");
    return -1;
}

DWORD ReserveCommand(HANDLE device, int argc, char *argv[])
{
    CDB cdb;

    ULONGLONG key;
    ULONG type;

    USHORT allocationLength;
    ULONG returnedBytes;

    PRO_PARAMETER_LIST parameters;

    BOOL ok;

    memset(&cdb, 0, sizeof(CDB));

    //
    // Pick the registration key out of the parameters.
    //

    returnedBytes = sscanf(argv[2], "%I64x", &key);
    if(returnedBytes == 0) {
        goto usage;
    } else {
        printf("key value %#I64x (%I64dd) will be used\n", key, key);
    }

    if(argc >= 4) {
        type = atoi(argv[3]);
    } else {
        type = RESERVATION_TYPE_EXCLUSIVE;
    }

    printf("Reservation type %#x will be used\n", type);

/*
typedef struct {
    UCHAR ReservationKey[8];
    UCHAR ServiceActionReservationKey[8];
    UCHAR ScopeSpecificAddress[4];
    UCHAR ActivatePersistThroughPowerLoss : 1;
    UCHAR Reserved1 : 7;
    UCHAR Reserved2;
    UCHAR ExtentLength[2];
} PRO_PARAMETER_LIST, *PPRO_PARAMETER_LIST;
*/

    cdb.PERSISTENT_RESERVE_OUT.OperationCode = SCSIOP_PERSISTENT_RESERVE_OUT;
    cdb.PERSISTENT_RESERVE_OUT.ServiceAction = RESERVATION_ACTION_RESERVE;
    cdb.PERSISTENT_RESERVE_OUT.Scope = RESERVATION_SCOPE_LU;
    cdb.PERSISTENT_RESERVE_OUT.Type = (UCHAR) type;

    allocationLength = sizeof(PRO_PARAMETER_LIST);
    returnedBytes = allocationLength;
    REVERSE_BYTES_SHORT(&(cdb.PERSISTENT_RESERVE_OUT.ParameterListLength),
                        &(allocationLength));

    memset(&parameters, 0, sizeof(PRO_PARAMETER_LIST));
    REVERSE_BYTES_QUAD(&(parameters.ReservationKey), &key);

    ok = SendCdbToDevice(device,
                         &cdb,
                         sizeof(cdb.PERSISTENT_RESERVE_OUT),
                         &parameters,
                         &returnedBytes,
                         FALSE);

    if(!ok) {
        printf("Error %d returned\n", GetLastError());
    } else {
        printf("Command succeeded\n");
    }

    return GetLastError();

usage:
    printf("reserve reserve <key> [type]\n");
    printf("\tKeys are 64-bit values in hex notation\n");
    return -1;
}

HANDLE
ParseDevicePath(
    IN PUCHAR Path
    )
{
    UCHAR buffer[32];
    HANDLE h;

    if(Path[0] == '(') {
        PUCHAR seps = ", ";
        PUCHAR tokens[4];
        tokens[0] = strtok(Path, seps);
        tokens[1] = strtok(NULL, seps);
        tokens[2] = strtok(NULL, seps);
        tokens[3] = strtok(NULL, seps);

        if(!tokens[0] || !tokens[1] || !tokens[2] || !tokens[3]) {
            printf("%s is not a valid scsi address\n", Path);
            return INVALID_HANDLE_VALUE;
        }

        PortId = atoi(tokens[0]);
        PathId = (UCHAR) atoi(tokens[1]);
        TargetId = (UCHAR) atoi(tokens[2]);
        Lun = (UCHAR) atoi(tokens[3]);

        printf("Device address is Port%d Path%d Target%d Lun%d\n", 
               PortId, PathId, TargetId, Lun);

        sprintf(buffer, "\\\\.\\scsi%d:", PortId);
    } else {
        sprintf(buffer, "\\\\.\\%s", Path);
    }

    h = CreateFile(buffer,
                   GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL,
                   OPEN_EXISTING,
                   FILE_ATTRIBUTE_NORMAL,
                   NULL);

    if(h == INVALID_HANDLE_VALUE) {
        printf("Error %d opening device %s\n", GetLastError(), buffer);
    }

    return h;
}

DWORD ReadReservations(HANDLE device, int argc, char *argv[])
{
    CDB cdb;
    USHORT allocationLength;
    ULONG returnedBytes;
    ULONG additionalLength;

    PRI_RESERVATION_LIST b1;
    PPRI_RESERVATION_LIST registrationList = &(b1);

    BOOL ok;

    ULONG i;

    memset(&cdb, 0, sizeof(CDB));

    cdb.PERSISTENT_RESERVE_IN.OperationCode = SCSIOP_PERSISTENT_RESERVE_IN;
    cdb.PERSISTENT_RESERVE_IN.ServiceAction = RESERVATION_ACTION_READ_RESERVATIONS;

    allocationLength = sizeof(PRI_RESERVATION_LIST);
    REVERSE_BYTES_SHORT(&(cdb.PERSISTENT_RESERVE_IN.AllocationLength),
                        &(allocationLength));

    returnedBytes = allocationLength;
    ok = SendCdbToDevice(device,
                         &cdb,
                         sizeof(cdb.PERSISTENT_RESERVE_IN),
                         registrationList,
                         &returnedBytes,
                         TRUE);

    if(!ok) return GetLastError();

    printf("%x bytes returned.\n", returnedBytes);

    REVERSE_BYTES(&returnedBytes, &(registrationList->Generation));
    printf("Generation number %#08lx\n", returnedBytes);

    REVERSE_BYTES(&additionalLength, &(registrationList->AdditionalLength));
    printf("additional length is %x\n", additionalLength);

    if(additionalLength > 0) {

        USHORT size = (USHORT) additionalLength + sizeof(PRI_RESERVATION_LIST);

        registrationList = malloc(size);
        if(registrationList == NULL) {
            printf("Unable to allocate %d bytes for data buffer\n", size);
            return -1;
        }

        REVERSE_BYTES_SHORT(&(cdb.PERSISTENT_RESERVE_IN.AllocationLength),
                            &(size));

        returnedBytes = size;

        ok = SendCdbToDevice(device,
                             &cdb,
                             sizeof(cdb.PERSISTENT_RESERVE_IN),
                             registrationList,
                             &returnedBytes,
                             TRUE);

        if(!ok) return GetLastError();

        printf("%x bytes returned\n", returnedBytes);

        for(i = 0; i < additionalLength / sizeof(PRI_RESERVATION_DESCRIPTOR); i++) {
            PPRI_RESERVATION_DESCRIPTOR r;
            ULONGLONG key;
            ULONG address;
    
            r = &(registrationList->Reservations[i]);
            REVERSE_BYTES_QUAD(&key, &(r->ReservationKey));
            REVERSE_BYTES(&address, &(r->ScopeSpecificAddress));

            printf("  %02d: key %#I64x  addr %#08lx  type %#x  scope %#x\n",
                   i, key, address, r->Type, r->Scope);
        }
    }

    return 0;
}

DWORD ReleaseCommand(HANDLE device, int argc, char *argv[])
{
    CDB cdb;
    ULONGLONG key;
    ULONG type;

    USHORT allocationLength;
    ULONG returnedBytes;

    PRO_PARAMETER_LIST parameters;

    BOOL ok;

    memset(&cdb, 0, sizeof(CDB));

    if(argc < 4) {
        goto usage;
    }

    //
    // Pick the registration key out of the parameters.
    //

    returnedBytes = sscanf(argv[2], "%I64x", &key);
    if(returnedBytes == 0) {
        goto usage;
    }

    type = atoi(argv[3]);

    printf("Reservation type %#x will be used\n", type);

    printf("key value %#I64x (%I64dd) will be cleared\n", key, key);

    cdb.PERSISTENT_RESERVE_OUT.OperationCode = SCSIOP_PERSISTENT_RESERVE_OUT;
    cdb.PERSISTENT_RESERVE_OUT.ServiceAction = RESERVATION_ACTION_RELEASE;
    cdb.PERSISTENT_RESERVE_OUT.Scope = RESERVATION_SCOPE_LU;
    cdb.PERSISTENT_RESERVE_OUT.Type = (UCHAR) type;

    allocationLength = sizeof(PRO_PARAMETER_LIST);
    returnedBytes = allocationLength;
    REVERSE_BYTES_SHORT(&(cdb.PERSISTENT_RESERVE_OUT.ParameterListLength),
                        &(allocationLength));

    memset(&parameters, 0, sizeof(PRO_PARAMETER_LIST));
    REVERSE_BYTES_QUAD(&(parameters.ReservationKey), &key);

    ok = SendCdbToDevice(device,
                         &cdb,
                         sizeof(cdb.PERSISTENT_RESERVE_OUT),
                         &parameters,
                         &returnedBytes,
                         FALSE);

    if(!ok) {
        printf("Error %d returned\n", GetLastError());
    } else {
        printf("Command succeeded\n");
    }

    return GetLastError();

usage:
    printf("reserve release <key> <type>\n");
    printf("\tKeys are 64-bit values in hex notation\n");
    return -1;
}


DWORD PreemptCommand(HANDLE device, int argc, char *argv[])
{
    CDB cdb;

    ULONGLONG ourKey;
    ULONGLONG preemptKey;
    UCHAR type;
    UCHAR scope;

    BOOLEAN abort = FALSE;

    USHORT allocationLength;
    ULONG returnedBytes;

    PRO_PARAMETER_LIST parameters;

    BOOL ok;

    memset(&cdb, 0, sizeof(CDB));

    if(argc < 6) {
        goto usage;
    }

    //
    // Pick the registration key out of the parameters.
    //

    returnedBytes = sscanf(argv[2], "%I64x", &ourKey);
    if(returnedBytes == 0) {
        goto usage;
    }

    returnedBytes = sscanf(argv[3], "%I64x", &preemptKey);
    if(returnedBytes == 0) {
        goto usage;
    }

    //
    // Get the reservation type and scope.
    //

    returnedBytes = sscanf(argv[4], "%hx", &type);
    if(returnedBytes == 0) {
        goto usage;
    }

    returnedBytes = sscanf(argv[5], "%hx", &scope);
    if(returnedBytes == 0) {
        goto usage;
    }

    if(argc >= 7) {
        if(_stricmp("abort", argv[6]) == 0) {
            abort = TRUE;
        }
    }

    printf("Preempt %sof reservation of %#I64x by %#I64x.  Type %#hx, Scope %#hx\n", 
           (abort ? "and abort " : ""),
           preemptKey,
           ourKey,
           type,
           scope);

/*
typedef struct {
    UCHAR ReservationKey[8];
    UCHAR ServiceActionReservationKey[8];
    UCHAR ScopeSpecificAddress[4];
    UCHAR ActivatePersistThroughPowerLoss : 1;
    UCHAR Reserved1 : 7;
    UCHAR Reserved2;
    UCHAR ExtentLength[2];
} PRO_PARAMETER_LIST, *PPRO_PARAMETER_LIST;
*/

    cdb.PERSISTENT_RESERVE_OUT.OperationCode = SCSIOP_PERSISTENT_RESERVE_OUT;

    if(abort) {
        cdb.PERSISTENT_RESERVE_OUT.ServiceAction = RESERVATION_ACTION_PREEMPT_ABORT;
    } else {
        cdb.PERSISTENT_RESERVE_OUT.ServiceAction = RESERVATION_ACTION_PREEMPT;
    }

    cdb.PERSISTENT_RESERVE_OUT.Scope = scope;
    cdb.PERSISTENT_RESERVE_OUT.Type = type;

    allocationLength = sizeof(PRO_PARAMETER_LIST);
    returnedBytes = allocationLength;
    REVERSE_BYTES_SHORT(&(cdb.PERSISTENT_RESERVE_OUT.ParameterListLength),
                        &(allocationLength));

    memset(&parameters, 0, sizeof(PRO_PARAMETER_LIST));
    REVERSE_BYTES_QUAD(&(parameters.ReservationKey), &ourKey);
    REVERSE_BYTES_QUAD(&(parameters.ServiceActionReservationKey), &preemptKey);

    ok = SendCdbToDevice(device,
                         &cdb,
                         sizeof(cdb.PERSISTENT_RESERVE_OUT),
                         &parameters,
                         &returnedBytes,
                         FALSE);

    if(!ok) {
        printf("Error %d returned\n", GetLastError());
    } else {
        printf("Command succeeded\n");
    }

    return GetLastError();

usage:
    printf("reserve preempt <key> <key-to-preempt> <type> <scope> [abort]\n");
    printf("\tKeys are 64-bit values in hex notation\n");
    printf("\tType & scope are single byte values in hex notation\n");
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\driver\volsnap.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    volsnap.cxx

Abstract:

    This driver provides volume snapshot capabilities.

Author:

    Norbert P. Kusters  (norbertk)  22-Jan-1999

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {

#define RTL_USE_AVL_TABLES 0

#include <stdio.h>
#include <ntosp.h>
#include <zwapi.h>
#include <snaplog.h>
#include <ntddsnap.h>
#include <initguid.h>
#include <volsnap.h>
#include <mountdev.h>
#include <ntddvol.h>
#include <ntdddisk.h>
#include <ioevent.h>
#include <wdmguid.h>

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

}

ULONG VsErrorLogSequence = 0;

VOID
VspWriteVolume(
    IN  PVOID   Context
    );

NTSTATUS
VspSetIgnorableBlocksInBitmap(
    IN  PVOID   Extension
    );

VOID
VspWorkerThread(
    IN  PVOID   RootExtension
    );

VOID
VspCleanupInitialSnapshot(
    IN  PVOLUME_EXTENSION   Extension,
    IN  BOOLEAN             NeedLock
    );

VOID
VspDestroyAllSnapshots(
    IN  PFILTER_EXTENSION               Filter,
    IN  PTEMP_TRANSLATION_TABLE_ENTRY   TableEntry
    );

VOID
VspWriteVolumePhase1(
    IN  PVOID   TableEntry
    );

VOID
VspFreeCopyIrp(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                CopyIrp
    );

NTSTATUS
VspMarkFileAllocationInBitmap(
    IN  PVOLUME_EXTENSION   Extension,
    IN  HANDLE              FileHandle,
    IN  PVSP_DIFF_AREA_FILE DiffAreaFile,
    IN  BOOLEAN             OnlyDiffAreaFile,
    IN  BOOLEAN             ClearBits,
    IN  PRTL_BITMAP         BitmapToSet
    );

NTSTATUS
VspAbortPreparedSnapshot(
    IN  PFILTER_EXTENSION   Filter,
    IN  BOOLEAN             NeedLock
    );

VOID
VspCleanupBitsSetInOtherPreparedSnapshots(
    IN  PVOLUME_EXTENSION   Extension
    );

NTSTATUS
VspReleaseWrites(
    IN  PFILTER_EXTENSION   Filter
    );

NTSTATUS
VspSetApplicationInfo(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    );

NTSTATUS
VspRefCountCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Filter
    );

VOID
VspCleanupFilter(
    IN  PFILTER_EXTENSION   Filter
    );

VOID
VspDecrementRefCount(
    IN  PFILTER_EXTENSION   Filter
    );

NTSTATUS
VspSignalCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Event
    );

NTSTATUS
VspMarkFreeSpaceInBitmap(
    IN  PVOLUME_EXTENSION   Extension,
    IN  HANDLE              UseThisHandle,
    IN  PRTL_BITMAP         BitmapToSet
    );

VOID
VspAndBitmaps(
    IN OUT  PRTL_BITMAP BaseBitmap,
    IN      PRTL_BITMAP FactorBitmap
    );

NTSTATUS
VspDeleteOldestSnapshot(
    IN      PFILTER_EXTENSION   Filter,
    IN OUT  PLIST_ENTRY         ListOfDiffAreaFilesToClose,
    IN OUT  PLIST_ENTRY         LisfOfDeviceObjectsToDelete
    );

VOID
VspCloseDiffAreaFiles(
    IN  PLIST_ENTRY ListOfDiffAreaFilesToClose,
    IN  PLIST_ENTRY ListOfDeviceObjectsToDelete
    );

NTSTATUS
VspComputeIgnorableProduct(
    IN  PVOLUME_EXTENSION   Extension
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#endif

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif


VOID
VspAcquire(
    IN  PDO_EXTENSION   RootExtension
    )

{
    KeWaitForSingleObject(&RootExtension->Semaphore, Executive, KernelMode,
                          FALSE, NULL);
}

VOID
VspRelease(
    IN  PDO_EXTENSION   RootExtension
    )

{
    KeReleaseSemaphore(&RootExtension->Semaphore, IO_NO_INCREMENT, 1, FALSE);
}

PVSP_CONTEXT
VspAllocateContext(
    IN  PDO_EXTENSION   RootExtension
    )

{
    PVSP_CONTEXT    context;

    context = (PVSP_CONTEXT) ExAllocateFromNPagedLookasideList(
              &RootExtension->ContextLookasideList);

    return context;
}

VOID
VspFreeContext(
    IN  PDO_EXTENSION   RootExtension,
    IN  PVSP_CONTEXT    Context
    )

{
    KIRQL               irql;
    PLIST_ENTRY         l;
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;

    if (RootExtension->EmergencyContext == Context) {
        KeAcquireSpinLock(&RootExtension->ESpinLock, &irql);
        RootExtension->EmergencyContextInUse = FALSE;
        if (IsListEmpty(&RootExtension->IrpWaitingList)) {
            InterlockedExchange(&RootExtension->IrpWaitingListNeedsChecking,
                                FALSE);
            KeReleaseSpinLock(&RootExtension->ESpinLock, irql);
            return;
        }
        l = RemoveHeadList(&RootExtension->IrpWaitingList);
        KeReleaseSpinLock(&RootExtension->ESpinLock, irql);

        irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);
        irpSp = IoGetCurrentIrpStackLocation(irp);
        RootExtension->DriverObject->MajorFunction[irpSp->MajorFunction](
                irpSp->DeviceObject, irp);
        return;
    }

    ExFreeToNPagedLookasideList(&RootExtension->ContextLookasideList,
                                Context);

    if (!RootExtension->IrpWaitingListNeedsChecking) {
        return;
    }

    KeAcquireSpinLock(&RootExtension->ESpinLock, &irql);
    if (IsListEmpty(&RootExtension->IrpWaitingList)) {
        InterlockedExchange(&RootExtension->IrpWaitingListNeedsChecking,
                            FALSE);
        KeReleaseSpinLock(&RootExtension->ESpinLock, irql);
        return;
    }
    l = RemoveHeadList(&RootExtension->IrpWaitingList);
    KeReleaseSpinLock(&RootExtension->ESpinLock, irql);

    irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);
    irpSp = IoGetCurrentIrpStackLocation(irp);
    RootExtension->DriverObject->MajorFunction[irpSp->MajorFunction](
            irpSp->DeviceObject, irp);
}

PVOID
VspAllocateTempTableEntry(
    IN  PDO_EXTENSION   RootExtension
    )

{
    PVOID   tempTableEntry;

    tempTableEntry = ExAllocateFromNPagedLookasideList(
                     &RootExtension->TempTableEntryLookasideList);

    return tempTableEntry;
}

VOID
VspQueueWorkItem(
    IN  PDO_EXTENSION       RootExtension,
    IN  PWORK_QUEUE_ITEM    WorkItem,
    IN  ULONG               QueueNumber
    )

{
    KIRQL   irql;

    ASSERT(QueueNumber < NUMBER_OF_THREAD_POOLS);

    KeAcquireSpinLock(&RootExtension->SpinLock[QueueNumber], &irql);
    InsertTailList(&RootExtension->WorkerQueue[QueueNumber], &WorkItem->List);
    KeReleaseSpinLock(&RootExtension->SpinLock[QueueNumber], irql);

    KeReleaseSemaphore(&RootExtension->WorkerSemaphore[QueueNumber],
                       IO_NO_INCREMENT, 1, FALSE);
}

VOID
VspFreeTempTableEntry(
    IN  PDO_EXTENSION   RootExtension,
    IN  PVOID           TempTableEntry
    )

{
    KIRQL               irql;
    PLIST_ENTRY         l;
    PWORK_QUEUE_ITEM    workItem;

    if (RootExtension->EmergencyTableEntry == TempTableEntry) {
        KeAcquireSpinLock(&RootExtension->ESpinLock, &irql);
        RootExtension->EmergencyTableEntryInUse = FALSE;
        if (IsListEmpty(&RootExtension->WorkItemWaitingList)) {
            InterlockedExchange(
                    &RootExtension->WorkItemWaitingListNeedsChecking, FALSE);
            KeReleaseSpinLock(&RootExtension->ESpinLock, irql);
            return;
        }
        l = RemoveHeadList(&RootExtension->WorkItemWaitingList);
        KeReleaseSpinLock(&RootExtension->ESpinLock, irql);

        workItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
        VspQueueWorkItem(RootExtension, workItem, 2);
        return;
    }

    ExFreeToNPagedLookasideList(&RootExtension->TempTableEntryLookasideList,
                                TempTableEntry);

    if (!RootExtension->WorkItemWaitingListNeedsChecking) {
        return;
    }

    KeAcquireSpinLock(&RootExtension->ESpinLock, &irql);
    if (IsListEmpty(&RootExtension->WorkItemWaitingList)) {
        InterlockedExchange(&RootExtension->WorkItemWaitingListNeedsChecking,
                            FALSE);
        KeReleaseSpinLock(&RootExtension->ESpinLock, irql);
        return;
    }
    l = RemoveHeadList(&RootExtension->WorkItemWaitingList);
    KeReleaseSpinLock(&RootExtension->ESpinLock, irql);

    workItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
    VspQueueWorkItem(RootExtension, workItem, 2);
}

VOID
VspLogErrorWorker(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT            context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION       extension = context->ErrorLog.Extension;
    PFILTER_EXTENSION       diffAreaFilter = context->ErrorLog.DiffAreaFilter;
    PFILTER_EXTENSION       filter;
    NTSTATUS                status;
    UNICODE_STRING          filterDosName, diffAreaFilterDosName;
    ULONG                   extraSpace;
    PIO_ERROR_LOG_PACKET    errorLogPacket;
    PWCHAR                  p;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_ERROR_LOG);

    if (extension) {
        filter = extension->Filter;
    } else {
        filter = diffAreaFilter;
        diffAreaFilter = NULL;
    }

    status = IoVolumeDeviceToDosName(filter->DeviceObject, &filterDosName);
    if (!NT_SUCCESS(status)) {
        goto Cleanup;
    }
    extraSpace = filterDosName.Length + sizeof(WCHAR);

    if (diffAreaFilter) {
        status = IoVolumeDeviceToDosName(diffAreaFilter->DeviceObject,
                                         &diffAreaFilterDosName);
        if (!NT_SUCCESS(status)) {
            ExFreePool(filterDosName.Buffer);
            goto Cleanup;
        }
        extraSpace += diffAreaFilterDosName.Length + sizeof(WCHAR);
    }
    extraSpace += sizeof(IO_ERROR_LOG_PACKET);

    if (extraSpace > 0xFF) {
        if (diffAreaFilter) {
            ExFreePool(diffAreaFilterDosName.Buffer);
        }
        ExFreePool(filterDosName.Buffer);
        goto Cleanup;
    }

    errorLogPacket = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(extension ?
                     extension->DeviceObject : filter->DeviceObject,
                     (UCHAR) extraSpace);
    if (!errorLogPacket) {
        if (diffAreaFilter) {
            ExFreePool(diffAreaFilterDosName.Buffer);
        }
        ExFreePool(filterDosName.Buffer);
        goto Cleanup;
    }

    errorLogPacket->ErrorCode = context->ErrorLog.SpecificIoStatus;
    errorLogPacket->SequenceNumber = VsErrorLogSequence++;
    errorLogPacket->FinalStatus = context->ErrorLog.FinalStatus;
    errorLogPacket->UniqueErrorValue = context->ErrorLog.UniqueErrorValue;
    errorLogPacket->DumpDataSize = 0;
    errorLogPacket->RetryCount = 0;

    errorLogPacket->NumberOfStrings = 1;
    errorLogPacket->StringOffset = sizeof(IO_ERROR_LOG_PACKET);
    p = (PWCHAR) ((PCHAR) errorLogPacket + sizeof(IO_ERROR_LOG_PACKET));
    RtlCopyMemory(p, filterDosName.Buffer, filterDosName.Length);
    p[filterDosName.Length/sizeof(WCHAR)] = 0;

    if (diffAreaFilter) {
        errorLogPacket->NumberOfStrings = 2;
        p = (PWCHAR) ((PCHAR) errorLogPacket + sizeof(IO_ERROR_LOG_PACKET) +
                      filterDosName.Length + sizeof(WCHAR));
        RtlCopyMemory(p, diffAreaFilterDosName.Buffer,
                      diffAreaFilterDosName.Length);
        p[diffAreaFilterDosName.Length/sizeof(WCHAR)] = 0;
    }

    IoWriteErrorLogEntry(errorLogPacket);

    if (diffAreaFilter) {
        ExFreePool(diffAreaFilterDosName.Buffer);
    }

    ExFreePool(filterDosName.Buffer);

Cleanup:
    VspFreeContext(filter->Root, context);
    if (extension) {
        ObDereferenceObject(extension->DeviceObject);
    }
    ObDereferenceObject(filter->DeviceObject);
    if (diffAreaFilter) {
        ObDereferenceObject(diffAreaFilter->DeviceObject);
    }
}

VOID
VspLogError(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PFILTER_EXTENSION   DiffAreaFilter,
    IN  NTSTATUS            SpecificIoStatus,
    IN  NTSTATUS            FinalStatus,
    IN  ULONG               UniqueErrorValue
    )

{
    PDO_EXTENSION   root;
    PVSP_CONTEXT    context;

    if (Extension) {
        root = Extension->Root;
    } else {
        root = DiffAreaFilter->Root;
    }

    context = VspAllocateContext(root);
    if (!context) {
        return;
    }

    context->Type = VSP_CONTEXT_TYPE_ERROR_LOG;
    context->ErrorLog.Extension = Extension;
    context->ErrorLog.DiffAreaFilter = DiffAreaFilter;
    context->ErrorLog.SpecificIoStatus = SpecificIoStatus;
    context->ErrorLog.FinalStatus = FinalStatus;
    context->ErrorLog.UniqueErrorValue = UniqueErrorValue;

    if (Extension) {
        ObReferenceObject(Extension->DeviceObject);
        ObReferenceObject(Extension->Filter->DeviceObject);
    }

    if (DiffAreaFilter) {
        ObReferenceObject(DiffAreaFilter->DeviceObject);
    }

    ExInitializeWorkItem(&context->WorkItem, VspLogErrorWorker, context);
    ExQueueWorkItem(&context->WorkItem, DelayedWorkQueue);
}

VOID
VspWaitForWorkerThreadsToExit(
    IN  PDO_EXTENSION   RootExtension
    )

{
    PVOID   threadObject;
    CCHAR   i, j;

    if (!RootExtension->WorkerThreadObjects) {
        return;
    }

    threadObject = RootExtension->WorkerThreadObjects[0];
    KeWaitForSingleObject(threadObject, Executive, KernelMode, FALSE, NULL);
    ObDereferenceObject(threadObject);

    for (i = 1; i < NUMBER_OF_THREAD_POOLS; i++) {
        for (j = 0; j < KeNumberProcessors; j++) {
            threadObject = RootExtension->WorkerThreadObjects[
                           (i - 1)*KeNumberProcessors + j + 1];
            KeWaitForSingleObject(threadObject, Executive, KernelMode, FALSE,
                                  NULL);
            ObDereferenceObject(threadObject);
        }
    }

    ExFreePool(RootExtension->WorkerThreadObjects);
    RootExtension->WorkerThreadObjects = NULL;
}

NTSTATUS
VspCreateWorkerThread(
    IN  PDO_EXTENSION   RootExtension
    )

/*++

Routine Description:

    This routine will create a new thread for a new volume snapshot.  Since
    a minimum of 2 threads are needed to prevent deadlocks, if there are
    no threads then 2 threads will be created by this routine.

Arguments:

    RootExtension   - Supplies the root extension.

Return Value:

    NTSTATUS

Notes:

    The caller must be holding 'Root->Semaphore'.

--*/

{
    OBJECT_ATTRIBUTES   oa;
    PVSP_CONTEXT        context;
    NTSTATUS            status;
    HANDLE              handle;
    PVOID               threadObject;
    CCHAR               i, j, k;

    KeWaitForSingleObject(&RootExtension->ThreadsRefCountSemaphore,
                          Executive, KernelMode, FALSE, NULL);

    if (RootExtension->ThreadsRefCount) {
        RootExtension->ThreadsRefCount++;
        KeReleaseSemaphore(&RootExtension->ThreadsRefCountSemaphore,
                           IO_NO_INCREMENT, 1, FALSE);
        return STATUS_SUCCESS;
    }

    VspWaitForWorkerThreadsToExit(RootExtension);

    InitializeObjectAttributes(&oa, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

    context = VspAllocateContext(RootExtension);
    if (!context) {
        KeReleaseSemaphore(&RootExtension->ThreadsRefCountSemaphore,
                           IO_NO_INCREMENT, 1, FALSE);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    context->Type = VSP_CONTEXT_TYPE_THREAD_CREATION;
    context->ThreadCreation.RootExtension = RootExtension;
    context->ThreadCreation.QueueNumber = 0;

    ASSERT(!RootExtension->WorkerThreadObjects);
    RootExtension->WorkerThreadObjects = (PVOID*)
            ExAllocatePoolWithTag(NonPagedPool,
                                  (KeNumberProcessors*2 + 1)*sizeof(PVOID),
                                  VOLSNAP_TAG_IO_STATUS);
    if (!RootExtension->WorkerThreadObjects) {
        VspFreeContext(RootExtension, context);
        KeReleaseSemaphore(&RootExtension->ThreadsRefCountSemaphore,
                           IO_NO_INCREMENT, 1, FALSE);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = PsCreateSystemThread(&handle, 0, &oa, 0, NULL, VspWorkerThread,
                                  context);
    if (!NT_SUCCESS(status)) {
        ExFreePool(RootExtension->WorkerThreadObjects);
        RootExtension->WorkerThreadObjects = NULL;
        VspFreeContext(RootExtension, context);
        KeReleaseSemaphore(&RootExtension->ThreadsRefCountSemaphore,
                           IO_NO_INCREMENT, 1, FALSE);
        return status;
    }

    status = ObReferenceObjectByHandle(handle, THREAD_ALL_ACCESS, NULL,
                                       KernelMode, &threadObject, NULL);
    if (!NT_SUCCESS(status)) {
        KeReleaseSemaphore(&RootExtension->WorkerSemaphore[0],
                           IO_NO_INCREMENT, 1, FALSE);
        ZwWaitForSingleObject(handle, FALSE, NULL);
        ExFreePool(RootExtension->WorkerThreadObjects);
        RootExtension->WorkerThreadObjects = NULL;
        KeReleaseSemaphore(&RootExtension->ThreadsRefCountSemaphore,
                           IO_NO_INCREMENT, 1, FALSE);
        return status;
    }
    RootExtension->WorkerThreadObjects[0] = threadObject;
    ZwClose(handle);

    for (i = 1; i < NUMBER_OF_THREAD_POOLS; i++) {
        for (j = 0; j < KeNumberProcessors; j++) {
            context = VspAllocateContext(RootExtension);
            if (!context) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                handle = NULL;
                break;
            }

            context->Type = VSP_CONTEXT_TYPE_THREAD_CREATION;
            context->ThreadCreation.RootExtension = RootExtension;
            context->ThreadCreation.QueueNumber = i;

            status = PsCreateSystemThread(&handle, 0, &oa, 0, NULL,
                                          VspWorkerThread, context);
            if (!NT_SUCCESS(status)) {
                VspFreeContext(RootExtension, context);
                handle = NULL;
                break;
            }

            status = ObReferenceObjectByHandle(
                     handle, THREAD_ALL_ACCESS, NULL, KernelMode,
                     &threadObject, NULL);

            if (!NT_SUCCESS(status)) {
                break;
            }

            RootExtension->WorkerThreadObjects[
                    KeNumberProcessors*(i - 1) + j + 1] = threadObject;
            ZwClose(handle);
        }
        if (j < KeNumberProcessors) {
            KeReleaseSemaphore(&RootExtension->WorkerSemaphore[i],
                               IO_NO_INCREMENT, j, FALSE);
            if (handle) {
                KeReleaseSemaphore(&RootExtension->WorkerSemaphore[i],
                                   IO_NO_INCREMENT, 1, FALSE);
                ZwWaitForSingleObject(handle, FALSE, NULL);
                ZwClose(handle);
            }
            for (k = 0; k < j; k++) {
                threadObject = RootExtension->WorkerThreadObjects[
                               KeNumberProcessors*(i - 1) + k + 1];
                KeWaitForSingleObject(threadObject, Executive, KernelMode,
                                      FALSE, NULL);
                ObDereferenceObject(threadObject);
            }
            break;
        }
    }
    if (i < NUMBER_OF_THREAD_POOLS) {
        for (k = 1; k < i; k++) {
            KeReleaseSemaphore(&RootExtension->WorkerSemaphore[k],
                               IO_NO_INCREMENT, KeNumberProcessors, FALSE);
            for (j = 0; j < KeNumberProcessors; j++) {
                threadObject = RootExtension->WorkerThreadObjects[
                               KeNumberProcessors*(k - 1) + j + 1];
                KeWaitForSingleObject(threadObject, Executive, KernelMode,
                                      FALSE, NULL);
                ObDereferenceObject(threadObject);
            }
        }

        KeReleaseSemaphore(&RootExtension->WorkerSemaphore[0],
                           IO_NO_INCREMENT, 1, FALSE);
        threadObject = RootExtension->WorkerThreadObjects[0];
        KeWaitForSingleObject(threadObject, Executive, KernelMode, FALSE, NULL);
        ObDereferenceObject(threadObject);

        ExFreePool(RootExtension->WorkerThreadObjects);
        RootExtension->WorkerThreadObjects = NULL;

        KeReleaseSemaphore(&RootExtension->ThreadsRefCountSemaphore,
                           IO_NO_INCREMENT, 1, FALSE);

        return status;
    }

    RootExtension->ThreadsRefCount++;

    KeReleaseSemaphore(&RootExtension->ThreadsRefCountSemaphore,
                       IO_NO_INCREMENT, 1, FALSE);

    return STATUS_SUCCESS;
}

VOID
VspWaitForWorkerThreadsToExitWorker(
    IN  PVOID   RootExtension
    )

{
    PDO_EXTENSION   rootExtension = (PDO_EXTENSION) RootExtension;

    KeWaitForSingleObject(&rootExtension->ThreadsRefCountSemaphore,
                          Executive, KernelMode, FALSE, NULL);
    VspWaitForWorkerThreadsToExit(rootExtension);
    rootExtension->WaitForWorkerThreadsToExitWorkItemInUse = FALSE;
    KeReleaseSemaphore(&rootExtension->ThreadsRefCountSemaphore,
                       IO_NO_INCREMENT, 1, FALSE);
}

NTSTATUS
VspDeleteWorkerThread(
    IN  PDO_EXTENSION   RootExtension
    )

/*++

Routine Description:

    This routine will delete a worker thread.

Arguments:

    RootExtension   - Supplies the root extension.

Return Value:

    NTSTATUS

Notes:

    The caller must be holding 'Root->Semaphore'.

--*/

{
    CCHAR   i, j;

    KeWaitForSingleObject(&RootExtension->ThreadsRefCountSemaphore,
                          Executive, KernelMode, FALSE, NULL);

    RootExtension->ThreadsRefCount--;
    if (RootExtension->ThreadsRefCount) {
        KeReleaseSemaphore(&RootExtension->ThreadsRefCountSemaphore,
                           IO_NO_INCREMENT, 1, FALSE);
        return STATUS_SUCCESS;
    }

    KeReleaseSemaphore(&RootExtension->WorkerSemaphore[0], IO_NO_INCREMENT, 1,
                       FALSE);

    for (i = 1; i < NUMBER_OF_THREAD_POOLS; i++) {
        KeReleaseSemaphore(&RootExtension->WorkerSemaphore[i], IO_NO_INCREMENT,
                           KeNumberProcessors, FALSE);
    }

    if (RootExtension->WaitForWorkerThreadsToExitWorkItemInUse) {
        KeReleaseSemaphore(&RootExtension->ThreadsRefCountSemaphore,
                           IO_NO_INCREMENT, 1, FALSE);
        return STATUS_SUCCESS;
    }

    RootExtension->WaitForWorkerThreadsToExitWorkItemInUse = TRUE;
    ExInitializeWorkItem(&RootExtension->WaitForWorkerThreadsToExitWorkItem,
                         VspWaitForWorkerThreadsToExitWorker, RootExtension);
    ExQueueWorkItem(&RootExtension->WaitForWorkerThreadsToExitWorkItem,
                    DelayedWorkQueue);

    KeReleaseSemaphore(&RootExtension->ThreadsRefCountSemaphore,
                       IO_NO_INCREMENT, 1, FALSE);

    return STATUS_SUCCESS;
}

VOID
VspQueryDiffAreaFileIncrease(
    IN  PVOLUME_EXTENSION   Extension,
    OUT PULONG              Increase
    )

{
    LONGLONG    r;

    r = (LONGLONG) Extension->MaximumNumberOfTempEntries;
    r <<= BLOCK_SHIFT;
    if (r < NOMINAL_DIFF_AREA_FILE_GROWTH) {
        r = NOMINAL_DIFF_AREA_FILE_GROWTH;
    } else if (r > MAXIMUM_DIFF_AREA_FILE_GROWTH) {
        r = MAXIMUM_DIFF_AREA_FILE_GROWTH;
    }

    *Increase = (ULONG) r;
}

NTSTATUS
VolSnapDefaultDispatch(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the default dispatch which passes down to the next layer.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status;

    if (filter->DeviceExtensionType == DEVICE_EXTENSION_FILTER) {
        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver(filter->TargetObject, Irp);
    }

    ASSERT(filter->DeviceExtensionType == DEVICE_EXTENSION_VOLUME);

    if (irpSp->MajorFunction == IRP_MJ_SYSTEM_CONTROL) {
        status = Irp->IoStatus.Status;
    } else {
        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

BOOLEAN
VspAreBitsSet(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    LONGLONG            start;
    ULONG               startBlock, endBlock;
    BOOLEAN             b;

    if (!Extension->VolumeBlockBitmap) {
        return FALSE;
    }

    start = irpSp->Parameters.Read.ByteOffset.QuadPart;
    if (start < 0) {
        return FALSE;
    }

    startBlock = (ULONG) (start >> BLOCK_SHIFT);
    endBlock = (ULONG) ((start + irpSp->Parameters.Read.Length - 1) >>
                        BLOCK_SHIFT);

    b = RtlAreBitsSet(Extension->VolumeBlockBitmap, startBlock,
                      endBlock - startBlock + 1);

    return b;
}

VOID
VspDecrementVolumeRefCount(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    KIRQL   irql;

    if (InterlockedDecrement(&Extension->RefCount)) {
        return;
    }

    ASSERT(Extension->HoldIncomingRequests);

    KeSetEvent(&Extension->ZeroRefEvent, IO_NO_INCREMENT, FALSE);
}

NTSTATUS
VspIncrementVolumeRefCount(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp,
    IN  PWORK_QUEUE_ITEM    WorkItem
    )

{
    KIRQL   irql;

    ASSERT(Irp || WorkItem);
    ASSERT(!Irp || !WorkItem);

    InterlockedIncrement(&Extension->RefCount);

    if (Extension->IsDead) {
        VspDecrementVolumeRefCount(Extension);
        return STATUS_NO_SUCH_DEVICE;
    }

    if (!Extension->HoldIncomingRequests) {
        return STATUS_SUCCESS;
    }

    VspDecrementVolumeRefCount(Extension);

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    if (!Extension->HoldIncomingRequests) {
        InterlockedIncrement(&Extension->RefCount);
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        return STATUS_SUCCESS;
    }
    if (Irp) {
        IoMarkIrpPending(Irp);
        InsertTailList(&Extension->HoldIrpQueue, &Irp->Tail.Overlay.ListEntry);
    } else {
        InsertTailList(&Extension->HoldWorkerQueue, &WorkItem->List);
    }
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    return STATUS_PENDING;
}

VOID
VspSignalContext(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT    context = (PVSP_CONTEXT) Context;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_EVENT);

    KeSetEvent(&context->Event.Event, IO_NO_INCREMENT, FALSE);
}

VOID
VspAcquireNonPagedResource(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PWORK_QUEUE_ITEM    WorkItem
    )

{
    PFILTER_EXTENSION   filter = Extension->Filter;
    KIRQL               irql;
    VSP_CONTEXT         context;
    BOOLEAN             synchronousCall;

    if (WorkItem) {
        synchronousCall = FALSE;
    } else {
        WorkItem = &context.WorkItem;
        context.Type = VSP_CONTEXT_TYPE_EVENT;
        KeInitializeEvent(&context.Event.Event, NotificationEvent, FALSE);
        ExInitializeWorkItem(&context.WorkItem, VspSignalContext, &context);
        synchronousCall = TRUE;
    }

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    if (filter->NonPagedResourceInUse) {
        InsertTailList(&filter->NonPagedResourceList, &WorkItem->List);
        KeReleaseSpinLock(&filter->SpinLock, irql);
        if (synchronousCall) {
            KeWaitForSingleObject(&context.Event.Event, Executive, KernelMode,
                                  FALSE, NULL);
        }
        return;
    }
    filter->NonPagedResourceInUse = TRUE;
    KeReleaseSpinLock(&filter->SpinLock, irql);

    if (!synchronousCall) {
        WorkItem->WorkerRoutine(WorkItem->Parameter);
    }
}

VOID
VspReleaseNonPagedResource(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    PFILTER_EXTENSION   filter = Extension->Filter;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PWORK_QUEUE_ITEM    workItem;

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    if (IsListEmpty(&filter->NonPagedResourceList)) {
        filter->NonPagedResourceInUse = FALSE;
        KeReleaseSpinLock(&filter->SpinLock, irql);
        return;
    }
    l = RemoveHeadList(&filter->NonPagedResourceList);
    KeReleaseSpinLock(&filter->SpinLock, irql);

    workItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
    VspQueueWorkItem(Extension->Root, workItem, 2);
}

VOID
VspAcquirePagedResource(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PWORK_QUEUE_ITEM    WorkItem
    )

{
    PFILTER_EXTENSION   filter = Extension->Filter;
    KIRQL               irql;
    VSP_CONTEXT         context;
    BOOLEAN             synchronousCall;

    if (WorkItem) {
        synchronousCall = FALSE;
    } else {
        WorkItem = &context.WorkItem;
        context.Type = VSP_CONTEXT_TYPE_EVENT;
        KeInitializeEvent(&context.Event.Event, NotificationEvent, FALSE);
        ExInitializeWorkItem(&context.WorkItem, VspSignalContext, &context);
        synchronousCall = TRUE;
    }

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    if (filter->PagedResourceInUse) {
        InsertTailList(&filter->PagedResourceList, &WorkItem->List);
        KeReleaseSpinLock(&filter->SpinLock, irql);
        if (synchronousCall) {
            KeWaitForSingleObject(&context.Event.Event, Executive, KernelMode,
                                  FALSE, NULL);
        }
        return;
    }
    filter->PagedResourceInUse = TRUE;
    KeReleaseSpinLock(&filter->SpinLock, irql);

    if (!synchronousCall) {
        VspQueueWorkItem(filter->Root, WorkItem, 1);
    }
}

VOID
VspReleasePagedResource(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    PFILTER_EXTENSION   filter = Extension->Filter;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PWORK_QUEUE_ITEM    workItem;

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    if (IsListEmpty(&filter->PagedResourceList)) {
        filter->PagedResourceInUse = FALSE;
        KeReleaseSpinLock(&filter->SpinLock, irql);
        return;
    }
    l = RemoveHeadList(&filter->PagedResourceList);
    KeReleaseSpinLock(&filter->SpinLock, irql);

    workItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
    VspQueueWorkItem(filter->Root, workItem, 1);
}

NTSTATUS
VspQueryListOfExtents(
    IN  HANDLE              FileHandle,
    IN  LONGLONG            FileOffset,
    OUT PLIST_ENTRY         ExtentList
    )

{
    NTSTATUS                    status;
    IO_STATUS_BLOCK             ioStatus;
    FILE_FS_SIZE_INFORMATION    fsSize;
    ULONG                       bpc;
    STARTING_VCN_INPUT_BUFFER   input;
    RETRIEVAL_POINTERS_BUFFER   output;
    LONGLONG                    start, length, delta;
    PDIFF_AREA_FILE_ALLOCATION  diffAreaFileAllocation;
    PLIST_ENTRY                 l;

    InitializeListHead(ExtentList);

    status = ZwQueryVolumeInformationFile(FileHandle, &ioStatus,
                                          &fsSize, sizeof(fsSize),
                                          FileFsSizeInformation);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    bpc = fsSize.BytesPerSector*fsSize.SectorsPerAllocationUnit;
    input.StartingVcn.QuadPart = FileOffset/bpc;

    for (;;) {

        status = ZwFsControlFile(FileHandle, NULL, NULL, NULL, &ioStatus,
                                 FSCTL_GET_RETRIEVAL_POINTERS, &input,
                                 sizeof(input), &output, sizeof(output));

        if (!NT_SUCCESS(status) && status != STATUS_BUFFER_OVERFLOW) {
            break;
        }

        delta = input.StartingVcn.QuadPart - output.StartingVcn.QuadPart;
        start = (output.Extents[0].Lcn.QuadPart + delta)*bpc;
        length = (output.Extents[0].NextVcn.QuadPart -
                  input.StartingVcn.QuadPart)*bpc;

        diffAreaFileAllocation = (PDIFF_AREA_FILE_ALLOCATION)
                                 ExAllocatePoolWithTag(NonPagedPool,
                                 sizeof(DIFF_AREA_FILE_ALLOCATION),
                                 VOLSNAP_TAG_BIT_HISTORY);
        if (!diffAreaFileAllocation) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        diffAreaFileAllocation->Offset = start;
        diffAreaFileAllocation->Length = length;
        InsertTailList(ExtentList, &diffAreaFileAllocation->ListEntry);

        if (status != STATUS_BUFFER_OVERFLOW) {
            break;
        }
        input.StartingVcn.QuadPart = output.Extents[0].NextVcn.QuadPart;
    }

    if (!NT_SUCCESS(status)) {
        while (!IsListEmpty(ExtentList)) {
            l = RemoveHeadList(ExtentList);
            diffAreaFileAllocation = CONTAINING_RECORD(l,
                                     DIFF_AREA_FILE_ALLOCATION, ListEntry);
            ExFreePool(diffAreaFileAllocation);
        }
    }

    return status;
}

NTSTATUS
VspSetFileSizes(
    IN  HANDLE              FileHandle,
    IN  LONGLONG            FileSize
    )

{
    FILE_ALLOCATION_INFORMATION allocInfo;
    NTSTATUS                    status;
    IO_STATUS_BLOCK             ioStatus;

    allocInfo.AllocationSize.QuadPart = FileSize;

    status = ZwSetInformationFile(FileHandle, &ioStatus,
                                  &allocInfo, sizeof(allocInfo),
                                  FileAllocationInformation);

    return status;
}

VOID
VspGrowDiffArea(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT                context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION           extension = context->GrowDiffArea.Extension;
    PVSP_DIFF_AREA_FILE         diffAreaFile = context->GrowDiffArea.DiffAreaFile;
    PFILTER_EXTENSION           filter = extension->Filter;
    LONGLONG                    usableSpace = 0;
    HANDLE                      handle;
    NTSTATUS                    status;
    KIRQL                       irql;
    LIST_ENTRY                  extentList;
    PLIST_ENTRY                 l;
    PDIFF_AREA_FILE_ALLOCATION  diffAreaFileAllocation;
    ULONG                       s, n, i, increase;
    LONGLONG                    offset, endOffset, current;
    PVOLUME_EXTENSION           bitmapExtension;
    LIST_ENTRY                  listOfDiffAreaFilesToClose;
    LIST_ENTRY                  listOfDeviceObjectsToDelete;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_GROW_DIFF_AREA);
    VspFreeContext(extension->Root, context);

DoOver:

    VspAcquire(extension->Root);
    if (extension->IsDead) {
        VspRelease(extension->Root);
        ObDereferenceObject(extension->DeviceObject);
        return;
    }

    handle = diffAreaFile->FileHandle;
    current = diffAreaFile->AllocatedFileSize;
    increase = extension->DiffAreaFileIncrease;
    ObReferenceObject(filter->DeviceObject);
    VspRelease(extension->Root);

    for (;;) {

        KeAcquireSpinLock(&filter->SpinLock, &irql);
        if (filter->MaximumVolumeSpace &&
            filter->AllocatedVolumeSpace + increase >
            filter->MaximumVolumeSpace) {

            KeReleaseSpinLock(&filter->SpinLock, irql);
            status = STATUS_DISK_FULL;
        } else {
            KeReleaseSpinLock(&filter->SpinLock, irql);
            status = VspSetFileSizes(handle, current + increase);
            if (NT_SUCCESS(status)) {
                break;
            }
        }

        if (increase > NOMINAL_DIFF_AREA_FILE_GROWTH) {
            increase = NOMINAL_DIFF_AREA_FILE_GROWTH;
            continue;
        }

        VspAcquire(extension->Root);
        if (extension->IsDead) {
            VspRelease(extension->Root);
            ObDereferenceObject(extension->DeviceObject);
            ObDereferenceObject(filter->DeviceObject);
            return;
        }

        if (status != STATUS_DISK_FULL) {
            VspLogError(extension, diffAreaFile->Filter,
                        VS_GROW_DIFF_AREA_FAILED, status, 0);
            VspRelease(extension->Root);
            ObDereferenceObject(extension->DeviceObject);
            ObDereferenceObject(filter->DeviceObject);
            return;
        }

        if (extension->ListEntry.Blink == &filter->VolumeList) {
            VspLogError(extension, diffAreaFile->Filter,
                        VS_GROW_DIFF_AREA_FAILED_LOW_DISK_SPACE,
                        STATUS_DISK_FULL, 0);
            VspRelease(extension->Root);
            ObDereferenceObject(extension->DeviceObject);
            ObDereferenceObject(filter->DeviceObject);
            return;
        }

        InitializeListHead(&listOfDiffAreaFilesToClose);
        InitializeListHead(&listOfDeviceObjectsToDelete);
        status = VspDeleteOldestSnapshot(filter,
                                         &listOfDiffAreaFilesToClose,
                                         &listOfDeviceObjectsToDelete);
        if (!NT_SUCCESS(status)) {
            VspLogError(extension, diffAreaFile->Filter,
                        VS_GROW_DIFF_AREA_FAILED_LOW_DISK_SPACE,
                        STATUS_DISK_FULL, 0);
            VspRelease(extension->Root);
            VspCloseDiffAreaFiles(&listOfDiffAreaFilesToClose,
                                  &listOfDeviceObjectsToDelete);
            ObDereferenceObject(extension->DeviceObject);
            ObDereferenceObject(filter->DeviceObject);
            return;
        }
        VspRelease(extension->Root);

        VspCloseDiffAreaFiles(&listOfDiffAreaFilesToClose,
                              &listOfDeviceObjectsToDelete);
    }

    status = VspQueryListOfExtents(handle, current, &extentList);
    if (!NT_SUCCESS(status)) {
        ObDereferenceObject(extension->DeviceObject);
        ObDereferenceObject(filter->DeviceObject);
        return;
    }

    VspAcquire(extension->Root);

    if (extension->IsDead) {
        VspRelease(extension->Root);
        while (!IsListEmpty(&extentList)) {
            l = RemoveHeadList(&extentList);
            diffAreaFileAllocation = CONTAINING_RECORD(l,
                                     DIFF_AREA_FILE_ALLOCATION, ListEntry);
            ExFreePool(diffAreaFileAllocation);
        }
        ObDereferenceObject(extension->DeviceObject);
        ObDereferenceObject(filter->DeviceObject);
        return;
    }

    if (diffAreaFile->Filter->PreparedSnapshot) {
        status = VspMarkFileAllocationInBitmap(
                 diffAreaFile->Filter->PreparedSnapshot,
                 diffAreaFile->FileHandle, NULL, FALSE, FALSE, NULL);
        if (!NT_SUCCESS(status)) {
            VspLogError(extension, diffAreaFile->Filter,
                        VS_CANT_MAP_DIFF_AREA_FILE, status, 1);
            VspAbortPreparedSnapshot(diffAreaFile->Filter, FALSE);
        }
    }

    if (IsListEmpty(&diffAreaFile->Filter->VolumeList)) {
        bitmapExtension = NULL;
    } else {
        bitmapExtension = CONTAINING_RECORD(
                          diffAreaFile->Filter->VolumeList.Blink,
                          VOLUME_EXTENSION, ListEntry);
        if (bitmapExtension->IsDead) {
            bitmapExtension = NULL;
        }
    }

    VspAcquireNonPagedResource(extension, NULL);

    while (!IsListEmpty(&extentList)) {
        l = RemoveHeadList(&extentList);
        InsertTailList(&diffAreaFile->UnusedAllocationList, l);
        diffAreaFileAllocation = CONTAINING_RECORD(l,
                                 DIFF_AREA_FILE_ALLOCATION, ListEntry);
        s = (ULONG) ((diffAreaFileAllocation->Offset + BLOCK_SIZE - 1)>>
                     BLOCK_SHIFT);
        offset = ((LONGLONG) s)<<BLOCK_SHIFT;
        endOffset = diffAreaFileAllocation->Offset +
                    diffAreaFileAllocation->Length;
        if (endOffset < offset) {
            continue;
        }

        n = (ULONG) ((endOffset - offset)>>BLOCK_SHIFT);
        if (!n) {
            continue;
        }

        if (bitmapExtension) {
            KeAcquireSpinLock(&bitmapExtension->SpinLock, &irql);
            for (i = 0; i < n; i++) {
                if (RtlCheckBit(bitmapExtension->VolumeBlockBitmap, s + i)) {
                    usableSpace += BLOCK_SIZE;
                }
            }
            KeReleaseSpinLock(&bitmapExtension->SpinLock, irql);
        } else {
            usableSpace += n<<BLOCK_SHIFT;
        }
    }

    diffAreaFile->AllocatedFileSize += increase;

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    filter->AllocatedVolumeSpace += increase;
    KeReleaseSpinLock(&filter->SpinLock, irql);

    VspReleaseNonPagedResource(extension);

    VspRelease(extension->Root);

    ObDereferenceObject(filter->DeviceObject);

    if (usableSpace < increase) {
        goto DoOver;
    }

    ObDereferenceObject(extension->DeviceObject);
}

NTSTATUS
VspAllocateDiffAreaSpace(
    IN  PVOLUME_EXTENSION               Extension,
    OUT PVSP_DIFF_AREA_FILE*            DiffAreaFile,
    OUT PLONGLONG                       TargetOffset
    )

/*++

Routine Description:

    This routine allocates file space in a diff area file.  The algorithm
    for this allocation is round robin which means that different size
    allocations can make the various files grow to be different sizes.  The
    earmarked file is used and grown as necessary to get the space desired.
    Only if it is impossible to use the current file would the allocator go
    to the next one.  If a file needs to be grown, the allocator will
    try to grow by 10 MB.

Arguments:

    Extension       - Supplies the volume extension.

    DiffAreaFile    - Returns the diff area file used in the allocation.

    FileOffset      - Returns the file offset in the diff area file used.

Return Value:

    NTSTATUS

Notes:

    Callers of this routine must be holding 'NonPagedResource'.

--*/

{
    PFILTER_EXTENSION           filter = Extension->Filter;
    NTSTATUS                    status = STATUS_SUCCESS;
    PVSP_DIFF_AREA_FILE         firstDiffAreaFile, diffAreaFile;
    ULONG                       i;
    PLIST_ENTRY                 l;
    LONGLONG                    remainder, delta;
    KIRQL                       irql;
    PVSP_CONTEXT                context;
    PDIFF_AREA_FILE_ALLOCATION  diffAreaFileAllocation;
    PVOLUME_EXTENSION           targetExtension;
    LONGLONG                    targetOffset;
    ULONG                       bitToCheck;

    firstDiffAreaFile = Extension->NextDiffAreaFile;
    i = 0;
    targetOffset = 0;

    for (;;) {

        diffAreaFile = Extension->NextDiffAreaFile;
        if (diffAreaFile == firstDiffAreaFile) {
            if (i) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            i++;
        }

        l = Extension->NextDiffAreaFile->VolumeListEntry.Flink;
        if (l == &Extension->ListOfDiffAreaFiles) {
            l = l->Flink;
        }
        Extension->NextDiffAreaFile = CONTAINING_RECORD(l, VSP_DIFF_AREA_FILE,
                                                        VolumeListEntry);

        if (IsListEmpty(&diffAreaFile->Filter->VolumeList)) {
            targetExtension = NULL;
        } else {
            targetExtension = CONTAINING_RECORD(
                              diffAreaFile->Filter->VolumeList.Blink,
                              VOLUME_EXTENSION, ListEntry);
        }

        delta = 0;
        while (!IsListEmpty(&diffAreaFile->UnusedAllocationList)) {

            l = diffAreaFile->UnusedAllocationList.Flink;
            diffAreaFileAllocation = CONTAINING_RECORD(l,
                                     DIFF_AREA_FILE_ALLOCATION, ListEntry);

            remainder = BLOCK_SIZE -
                        (diffAreaFileAllocation->Offset&(BLOCK_SIZE - 1));
            if (remainder < BLOCK_SIZE) {
                if (diffAreaFileAllocation->Length < remainder) {
                    delta += diffAreaFileAllocation->Length;
                    RemoveEntryList(l);
                    ExFreePool(diffAreaFileAllocation);
                    continue;
                }

                delta += remainder;
                diffAreaFileAllocation->Offset += remainder;
                diffAreaFileAllocation->Length -= remainder;
            }

            for (;;) {

                if (diffAreaFileAllocation->Length < BLOCK_SIZE) {
                    delta += diffAreaFileAllocation->Length;
                    RemoveEntryList(l);
                    ExFreePool(diffAreaFileAllocation);
                    break;
                }

                if (targetExtension) {
                    bitToCheck = (ULONG)
                                 (diffAreaFileAllocation->Offset>>BLOCK_SHIFT);
                    KeAcquireSpinLock(&targetExtension->SpinLock, &irql);
                    if (!RtlCheckBit(targetExtension->VolumeBlockBitmap,
                                     bitToCheck)) {

                        KeReleaseSpinLock(&targetExtension->SpinLock, irql);
                        delta += BLOCK_SIZE;
                        diffAreaFileAllocation->Offset += BLOCK_SIZE;
                        diffAreaFileAllocation->Length -= BLOCK_SIZE;
                        continue;
                    }
                    KeReleaseSpinLock(&targetExtension->SpinLock, irql);
                }

                targetOffset = diffAreaFileAllocation->Offset;
                diffAreaFileAllocation->Offset += BLOCK_SIZE;
                diffAreaFileAllocation->Length -= BLOCK_SIZE;
                break;
            }

            if (targetOffset) {
                break;
            }
        }

        if (!targetOffset) {
            continue;
        }

        if (diffAreaFile->NextAvailable + delta + BLOCK_SIZE +
            Extension->DiffAreaFileIncrease <=
            diffAreaFile->AllocatedFileSize) {

            break;
        }

        if (diffAreaFile->NextAvailable + Extension->DiffAreaFileIncrease >
            diffAreaFile->AllocatedFileSize) {

            break;
        }

        if (!Extension->OkToGrowDiffArea) {
            VspLogError(Extension, diffAreaFile->Filter,
                        VS_GROW_BEFORE_FREE_SPACE, STATUS_SUCCESS, 0);
            break;
        }

        context = VspAllocateContext(Extension->Root);
        if (!context) {
            break;
        }

        context->Type = VSP_CONTEXT_TYPE_GROW_DIFF_AREA;
        context->GrowDiffArea.Extension  = Extension;
        context->GrowDiffArea.DiffAreaFile = diffAreaFile;
        ObReferenceObject(Extension->DeviceObject);
        ExInitializeWorkItem(&context->WorkItem, VspGrowDiffArea, context);
        VspQueueWorkItem(Extension->Root, &context->WorkItem, 0);

        break;
    }

    if (NT_SUCCESS(status)) {
        *DiffAreaFile = diffAreaFile;
        if (TargetOffset) {
            *TargetOffset = targetOffset;
        }

        diffAreaFile->NextAvailable += delta + BLOCK_SIZE;
        KeAcquireSpinLock(&filter->SpinLock, &irql);
        filter->UsedVolumeSpace += delta + BLOCK_SIZE;
        KeReleaseSpinLock(&filter->SpinLock, irql);
    }

    return status;
}

VOID
VspDecrementVolumeIrpRefCount(
    IN  PVOID   Irp
    )

{
    PIRP                irp = (PIRP) Irp;
    PIO_STACK_LOCATION  nextSp = IoGetNextIrpStackLocation(irp);
    PIO_STACK_LOCATION  irpSp;
    PVOLUME_EXTENSION   extension;

    if (InterlockedDecrement((PLONG) &nextSp->Parameters.Read.Length)) {
        return;
    }

    irpSp = IoGetCurrentIrpStackLocation(irp);
    extension = (PVOLUME_EXTENSION) irpSp->DeviceObject->DeviceExtension;
    ASSERT(extension->DeviceExtensionType == DEVICE_EXTENSION_VOLUME);

    IoCompleteRequest(irp, IO_DISK_INCREMENT);
    VspDecrementVolumeRefCount(extension);
}

VOID
VspDecrementIrpRefCount(
    IN  PVOID   Irp
    )

{
    PIRP                irp = (PIRP) Irp;
    PIO_STACK_LOCATION  nextSp = IoGetNextIrpStackLocation(irp);
    PIO_STACK_LOCATION  irpSp;
    PFILTER_EXTENSION   filter;
    PVOLUME_EXTENSION   extension;
    PLIST_ENTRY         l;
    PVSP_DIFF_AREA_FILE diffAreaFile;

    if (InterlockedDecrement((PLONG) &nextSp->Parameters.Read.Length)) {
        return;
    }

    irpSp = IoGetCurrentIrpStackLocation(irp);
    filter = (PFILTER_EXTENSION) irpSp->DeviceObject->DeviceExtension;
    ASSERT(filter->DeviceExtensionType == DEVICE_EXTENSION_FILTER);
    extension = CONTAINING_RECORD(filter->VolumeList.Blink,
                                  VOLUME_EXTENSION, ListEntry);

    for (l = extension->ListOfDiffAreaFiles.Flink;
         l != &extension->ListOfDiffAreaFiles; l = l->Flink) {

        diffAreaFile = CONTAINING_RECORD(l, VSP_DIFF_AREA_FILE,
                                         VolumeListEntry);

        VspDecrementRefCount(diffAreaFile->Filter);
    }

    IoCopyCurrentIrpStackLocationToNext(irp);
    IoSetCompletionRoutine(irp, VspRefCountCompletionRoutine, filter,
                           TRUE, TRUE, TRUE);
    IoCallDriver(filter->TargetObject, irp);
}

VOID
VspDecrementIrpRefCountWorker(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION   extension = context->Extension.Extension;
    PIRP                irp = context->Extension.Irp;

    if (context->Type == VSP_CONTEXT_TYPE_WRITE_VOLUME) {
        ExInitializeWorkItem(&context->WorkItem, VspWriteVolume, context);
        VspAcquireNonPagedResource(extension, &context->WorkItem);
    } else {
        ASSERT(context->Type == VSP_CONTEXT_TYPE_EXTENSION);
        VspFreeContext(extension->Root, context);
    }

    VspDecrementIrpRefCount(irp);
}

VOID
VspSignalCallback(
    IN  PFILTER_EXTENSION   Filter
    )

{
    KeSetEvent((PKEVENT) Filter->ZeroRefContext, IO_NO_INCREMENT, FALSE);
}

VOID
VspCleanupVolumeSnapshot(
    IN      PVOLUME_EXTENSION   Extension,
    IN OUT  PLIST_ENTRY         ListOfDiffAreaFilesToClose
    )

/*++

Routine Description:

    This routine kills an existing volume snapshot.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    NTSTATUS

Notes:

    Root->Semaphore required for calling this routine.

--*/

{
    PFILTER_EXTENSION           filter = Extension->Filter;
    PLIST_ENTRY                 l, ll;
    PVSP_DIFF_AREA_FILE         diffAreaFile;
    KIRQL                       irql;
    POLD_HEAP_ENTRY             oldHeapEntry;
    NTSTATUS                    status;
    PDIFF_AREA_FILE_ALLOCATION  diffAreaFileAllocation;
    PVOID                       p;

    VspAcquirePagedResource(Extension, NULL);

    if (Extension->DiffAreaFileMap) {
        status = ZwUnmapViewOfSection(Extension->DiffAreaFileMapProcess,
                                      Extension->DiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        Extension->DiffAreaFileMap = NULL;
    }

    if (Extension->NextDiffAreaFileMap) {
        status = ZwUnmapViewOfSection(Extension->DiffAreaFileMapProcess,
                                      Extension->NextDiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        Extension->NextDiffAreaFileMap = NULL;
    }

    while (!IsListEmpty(&Extension->OldHeaps)) {

        l = RemoveHeadList(&Extension->OldHeaps);
        oldHeapEntry = CONTAINING_RECORD(l, OLD_HEAP_ENTRY, ListEntry);

        status = ZwUnmapViewOfSection(Extension->DiffAreaFileMapProcess,
                                      oldHeapEntry->DiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        ExFreePool(oldHeapEntry);
    }

    VspReleasePagedResource(Extension);

    VspCleanupBitsSetInOtherPreparedSnapshots(Extension);

    while (!IsListEmpty(&Extension->ListOfDiffAreaFiles)) {

        l = RemoveHeadList(&Extension->ListOfDiffAreaFiles);
        diffAreaFile = CONTAINING_RECORD(l, VSP_DIFF_AREA_FILE,
                                         VolumeListEntry);

        if (diffAreaFile->FilterListEntryBeingUsed) {
            RemoveEntryList(&diffAreaFile->FilterListEntry);
            diffAreaFile->FilterListEntryBeingUsed = FALSE;
        }

        KeAcquireSpinLock(&filter->SpinLock, &irql);
        filter->AllocatedVolumeSpace -= diffAreaFile->AllocatedFileSize;
        filter->UsedVolumeSpace -= diffAreaFile->NextAvailable;
        KeReleaseSpinLock(&filter->SpinLock, irql);

        while (!IsListEmpty(&diffAreaFile->UnusedAllocationList)) {
            ll = RemoveHeadList(&diffAreaFile->UnusedAllocationList);
            diffAreaFileAllocation = CONTAINING_RECORD(ll,
                                     DIFF_AREA_FILE_ALLOCATION, ListEntry);
            ExFreePool(diffAreaFileAllocation);
        }

        InsertTailList(ListOfDiffAreaFilesToClose,
                       &diffAreaFile->VolumeListEntry);
    }

    Extension->NextDiffAreaFile = NULL;

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    if (Extension->VolumeBlockBitmap) {
        ExFreePool(Extension->VolumeBlockBitmap->Buffer);
        ExFreePool(Extension->VolumeBlockBitmap);
        Extension->VolumeBlockBitmap = NULL;
    }
    if (Extension->IgnorableProduct) {
        ExFreePool(Extension->IgnorableProduct->Buffer);
        ExFreePool(Extension->IgnorableProduct);
        Extension->IgnorableProduct = NULL;
    }
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    VspAcquirePagedResource(Extension, NULL);

    if (Extension->ApplicationInformation) {
        Extension->ApplicationInformationSize = 0;
        ExFreePool(Extension->ApplicationInformation);
        Extension->ApplicationInformation = NULL;
    }

    VspReleasePagedResource(Extension);

    if (Extension->EmergencyCopyIrp) {
        ExFreePool(MmGetMdlVirtualAddress(
                   Extension->EmergencyCopyIrp->MdlAddress));
        IoFreeMdl(Extension->EmergencyCopyIrp->MdlAddress);
        IoFreeIrp(Extension->EmergencyCopyIrp);
        Extension->EmergencyCopyIrp = NULL;
    }

    VspDeleteWorkerThread(filter->Root);
}

VOID
VspEmptyIrpQueue(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PLIST_ENTRY     IrpQueue
    )

{
    PLIST_ENTRY         l;
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;

    while (!IsListEmpty(IrpQueue)) {
        l = RemoveHeadList(IrpQueue);
        irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);
        irpSp = IoGetCurrentIrpStackLocation(irp);
        DriverObject->MajorFunction[irpSp->MajorFunction](irpSp->DeviceObject,
                                                          irp);
    }
}

VOID
VspEmptyWorkerQueue(
    IN  PLIST_ENTRY     WorkerQueue
    )

{
    PLIST_ENTRY         l;
    PWORK_QUEUE_ITEM    workItem;

    while (!IsListEmpty(WorkerQueue)) {
        l = RemoveHeadList(WorkerQueue);
        workItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
        workItem->WorkerRoutine(workItem->Parameter);
    }
}

VOID
VspResumeSnapshotIo(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    KIRQL       irql;
    BOOLEAN     emptyQueue, eQQ;
    LIST_ENTRY  q, qq;

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    if (IsListEmpty(&Extension->HoldIrpQueue)) {
        emptyQueue = FALSE;
    } else {
        emptyQueue = TRUE;
        q = Extension->HoldIrpQueue;
        InitializeListHead(&Extension->HoldIrpQueue);
    }
    if (IsListEmpty(&Extension->HoldWorkerQueue)) {
        eQQ = FALSE;
    } else {
        eQQ = TRUE;
        qq = Extension->HoldWorkerQueue;
        InitializeListHead(&Extension->HoldWorkerQueue);
    }
    InterlockedIncrement(&Extension->RefCount);
    InterlockedExchange(&Extension->HoldIncomingRequests, FALSE);
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    if (emptyQueue) {
        q.Blink->Flink = &q;
        q.Flink->Blink = &q;
        VspEmptyIrpQueue(Extension->Root->DriverObject, &q);
    }

    if (eQQ) {
        qq.Blink->Flink = &qq;
        qq.Flink->Blink = &qq;
        VspEmptyWorkerQueue(&qq);
    }
}

VOID
VspPauseSnapshotIo(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    KIRQL   irql;

    VspReleaseWrites(Extension->Filter);

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    ASSERT(!Extension->HoldIncomingRequests);
    KeInitializeEvent(&Extension->ZeroRefEvent, NotificationEvent, FALSE);
    InterlockedExchange(&Extension->HoldIncomingRequests, TRUE);
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    VspDecrementVolumeRefCount(Extension);

    KeWaitForSingleObject(&Extension->ZeroRefEvent, Executive, KernelMode,
                          FALSE, NULL);
}

VOID
VspResumeVolumeIo(
    IN  PFILTER_EXTENSION   Filter
    )

{
    KIRQL       irql;
    BOOLEAN     emptyQueue;
    LIST_ENTRY  q;

    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    InterlockedIncrement(&Filter->RefCount);
    InterlockedExchange(&Filter->HoldIncomingWrites, FALSE);
    if (IsListEmpty(&Filter->HoldQueue)) {
        emptyQueue = FALSE;
    } else {
        emptyQueue = TRUE;
        q = Filter->HoldQueue;
        InitializeListHead(&Filter->HoldQueue);
    }
    KeReleaseSpinLock(&Filter->SpinLock, irql);

    if (emptyQueue) {
        q.Blink->Flink = &q;
        q.Flink->Blink = &q;
        VspEmptyIrpQueue(Filter->Root->DriverObject, &q);
    }
}

VOID
VspPauseVolumeIo(
    IN  PFILTER_EXTENSION   Filter
    )

{
    KEVENT  event;
    KIRQL   irql;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    ASSERT(!Filter->HoldIncomingWrites);
    InterlockedExchange(&Filter->HoldIncomingWrites, TRUE);
    Filter->ZeroRefCallback = VspSignalCallback;
    Filter->ZeroRefContext = &event;
    KeReleaseSpinLock(&Filter->SpinLock, irql);

    VspDecrementRefCount(Filter);

    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
}

NTSTATUS
VspDeleteOldestSnapshot(
    IN      PFILTER_EXTENSION   Filter,
    IN OUT  PLIST_ENTRY         ListOfDiffAreaFilesToClose,
    IN OUT  PLIST_ENTRY         LisfOfDeviceObjectsToDelete
    )

/*++

Routine Description:

    This routine deletes the oldest volume snapshot on the given volume.

Arguments:

    Filter   - Supplies the filter extension.

Return Value:

    NTSTATUS

Notes:

    This routine assumes that Root->Semaphore is being held.

--*/

{
    PFILTER_EXTENSION   filter = Filter;
    PLIST_ENTRY         l;
    PVOLUME_EXTENSION   extension;
    KIRQL               irql;

    if (IsListEmpty(&filter->VolumeList)) {
        return STATUS_INVALID_PARAMETER;
    }

    l = filter->VolumeList.Flink;
    extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

    KeAcquireSpinLock(&extension->SpinLock, &irql);
    InterlockedExchange(&extension->IsDead, TRUE);
    InterlockedExchange(&extension->IsStarted, FALSE);
    KeReleaseSpinLock(&extension->SpinLock, irql);

    VspPauseSnapshotIo(extension);
    VspResumeSnapshotIo(extension);

    VspPauseVolumeIo(filter);

    ObReferenceObject(extension->DeviceObject);

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    RemoveEntryList(&extension->ListEntry);
    if (IsListEmpty(&filter->VolumeList)) {
        InterlockedExchange(&filter->SnapshotsPresent, FALSE);
    }
    KeReleaseSpinLock(&filter->SpinLock, irql);

    VspResumeVolumeIo(filter);

    VspCleanupVolumeSnapshot(extension, ListOfDiffAreaFilesToClose);

    if (extension->AliveToPnp) {
        InsertTailList(&filter->DeadVolumeList, &extension->ListEntry);
        IoInvalidateDeviceRelations(filter->Pdo, BusRelations);
    } else {
        IoDeleteDevice(extension->DeviceObject);
    }

    InsertTailList(LisfOfDeviceObjectsToDelete, &extension->HoldIrpQueue);

    return STATUS_SUCCESS;
}

VOID
VspCloseDiffAreaFiles(
    IN  PLIST_ENTRY ListOfDiffAreaFilesToClose,
    IN  PLIST_ENTRY ListOfDeviceObjectsToDelete
    )

{
    PLIST_ENTRY         l;
    PVSP_DIFF_AREA_FILE diffAreaFile;
    PVOLUME_EXTENSION   extension;

    while (!IsListEmpty(ListOfDiffAreaFilesToClose)) {

        l = RemoveHeadList(ListOfDiffAreaFilesToClose);
        diffAreaFile = CONTAINING_RECORD(l, VSP_DIFF_AREA_FILE,
                                         VolumeListEntry);

        ZwClose(diffAreaFile->FileHandle);

        ExFreePool(diffAreaFile);
    }

    while (!IsListEmpty(ListOfDeviceObjectsToDelete)) {

        l = RemoveHeadList(ListOfDeviceObjectsToDelete);
        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, HoldIrpQueue);

        ObDereferenceObject(extension->DeviceObject);
    }
}

VOID
VspDestroyAllSnapshotsWorker(
    IN  PVOID   Context
    )

/*++

Routine Description:

    This routine will delete all of the snapshots in the system.

Arguments:

    Filter  - Supplies the filter extension.

Return Value:

    None.

--*/

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PFILTER_EXTENSION   filter = context->Filter.Filter;
    LIST_ENTRY          listOfDiffAreaFilesToClose;
    LIST_ENTRY          listOfDeviceObjectToDelete;

    KeWaitForSingleObject(&filter->EndCommitProcessCompleted, Executive,
                          KernelMode, FALSE, NULL);

    InitializeListHead(&listOfDiffAreaFilesToClose);
    InitializeListHead(&listOfDeviceObjectToDelete);

    VspAcquire(filter->Root);

    while (!IsListEmpty(&filter->VolumeList)) {
        VspDeleteOldestSnapshot(filter, &listOfDiffAreaFilesToClose,
                                &listOfDeviceObjectToDelete);
    }

    InterlockedExchange(&filter->DestroyAllSnapshotsPending, FALSE);

    VspRelease(filter->Root);

    VspCloseDiffAreaFiles(&listOfDiffAreaFilesToClose,
                          &listOfDeviceObjectToDelete);

    ObDereferenceObject(filter->DeviceObject);
}

VOID
VspAbortTableEntryWorker(
    IN  PVOID   TableEntry
    )

{
    PTEMP_TRANSLATION_TABLE_ENTRY   tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY) TableEntry;
    PVOLUME_EXTENSION               extension = tableEntry->Extension;

    RtlDeleteElementGenericTable(&extension->TempVolumeBlockTable, tableEntry);
    VspReleaseNonPagedResource(extension);
    ObDereferenceObject(extension->Filter->DeviceObject);
    ObDereferenceObject(extension->DeviceObject);
}

VOID
VspDestroyAllSnapshots(
    IN  PFILTER_EXTENSION               Filter,
    IN  PTEMP_TRANSLATION_TABLE_ENTRY   TableEntry
    )

/*++

Routine Description:

    This routine will delete all of the snapshots in the system.

Arguments:

    Filter  - Supplies the filter extension.

Return Value:

    None.

--*/

{
    PVOLUME_EXTENSION   extension;
    PIRP                irp;
    KIRQL               irql;
    PWORK_QUEUE_ITEM    workItem;
    NTSTATUS            status;
    PVSP_CONTEXT        context;

    if (TableEntry) {

        extension = TableEntry->Extension;
        irp = TableEntry->WriteIrp;
        TableEntry->WriteIrp = NULL;

        if (TableEntry->CopyIrp) {
            VspFreeCopyIrp(extension, TableEntry->CopyIrp);
            TableEntry->CopyIrp = NULL;
        }

        KeAcquireSpinLock(&extension->SpinLock, &irql);
        RtlSetBit(extension->VolumeBlockBitmap,
                  (ULONG) (TableEntry->VolumeOffset>>BLOCK_SHIFT));
        TableEntry->IsComplete = TRUE;
        KeReleaseSpinLock(&extension->SpinLock, irql);

        VspEmptyWorkerQueue(&TableEntry->WaitingQueueDpc);

        ObReferenceObject(extension->DeviceObject);
        ObReferenceObject(extension->Filter->DeviceObject);

        if (irp) {
            VspDecrementIrpRefCount(irp);
        }

        workItem = &TableEntry->WorkItem;
        ExInitializeWorkItem(workItem, VspAbortTableEntryWorker, TableEntry);
        VspAcquireNonPagedResource(extension, workItem);
    }

    if (InterlockedExchange(&Filter->DestroyAllSnapshotsPending, TRUE)) {
        return;
    }

    context = &Filter->DestroyContext;
    context->Type = VSP_CONTEXT_TYPE_FILTER;
    context->Filter.Filter = Filter;

    ObReferenceObject(Filter->DeviceObject);
    ExInitializeWorkItem(&context->WorkItem, VspDestroyAllSnapshotsWorker,
                         context);
    VspQueueWorkItem(Filter->Root, &context->WorkItem, 0);
}

VOID
VspWriteVolumePhase5(
    IN  PVOID   TableEntry
    )

{
    PTEMP_TRANSLATION_TABLE_ENTRY   tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY) TableEntry;
    PVOLUME_EXTENSION               extension = tableEntry->Extension;

    RtlDeleteElementGenericTable(&extension->TempVolumeBlockTable, tableEntry);
    VspReleaseNonPagedResource(extension);
    VspDecrementVolumeRefCount(extension);
}

VOID
VspWriteVolumePhase4(
    IN  PVOID   TableEntry
    )

/*++

Routine Description:

    This routine is queued from the completion of writting a block to
    make up a table entry for the write.  This routine will create and
    insert the table entry.

Arguments:

    Context - Supplies the context.

Return Value:

    None.

--*/

{
    PTEMP_TRANSLATION_TABLE_ENTRY   tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY) TableEntry;
    PVOLUME_EXTENSION               extension = tableEntry->Extension;
    PFILTER_EXTENSION               filter = extension->Filter;
    TRANSLATION_TABLE_ENTRY         keyTableEntry;
    PVOID                           r;
    KIRQL                           irql;

    RtlZeroMemory(&keyTableEntry, sizeof(TRANSLATION_TABLE_ENTRY));
    keyTableEntry.VolumeOffset = tableEntry->VolumeOffset;
    keyTableEntry.TargetObject = tableEntry->TargetObject;
    keyTableEntry.TargetOffset = tableEntry->TargetOffset;

    _try {
        r = RtlInsertElementGenericTable(&extension->VolumeBlockTable,
                                         &keyTableEntry,
                                         sizeof(TRANSLATION_TABLE_ENTRY),
                                         NULL);
    } _except (EXCEPTION_EXECUTE_HANDLER) {
        r = NULL;
    }

    VspReleasePagedResource(extension);

    if (!r) {
        KeAcquireSpinLock(&extension->SpinLock, &irql);
        if (extension->PageFileSpaceCreatePending) {
            ExInitializeWorkItem(&tableEntry->WorkItem, VspWriteVolumePhase4,
                                 tableEntry);
            InsertTailList(&extension->WaitingForPageFileSpace,
                           &tableEntry->WorkItem.List);
            KeReleaseSpinLock(&extension->SpinLock, irql);
            return;
        }
        KeReleaseSpinLock(&extension->SpinLock, irql);

        if (!filter->DestroyAllSnapshotsPending) {
            VspLogError(extension, NULL, VS_ABORT_SNAPSHOTS_NO_HEAP,
                        STATUS_SUCCESS, 0);
        }
        VspDestroyAllSnapshots(filter, tableEntry);
        VspDecrementVolumeRefCount(extension);
        return;
    }

    ExInitializeWorkItem(&tableEntry->WorkItem, VspWriteVolumePhase5,
                         tableEntry);
    VspAcquireNonPagedResource(extension, &tableEntry->WorkItem);
}

VOID
VspWriteVolumeRefCount(
    IN  PVOID   TableEntry
    )

{
    PTEMP_TRANSLATION_TABLE_ENTRY   tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY) TableEntry;
    PVOLUME_EXTENSION               extension = tableEntry->Extension;
    PWORK_QUEUE_ITEM                workItem;
    NTSTATUS                        status;

    workItem = &tableEntry->WorkItem;
    status = VspIncrementVolumeRefCount(extension, NULL, workItem);
    if (!NT_SUCCESS(status)) {
        VspDestroyAllSnapshots(extension->Filter, tableEntry);
        return;
    }
    if (status == STATUS_PENDING) {
        return;
    }

    ExInitializeWorkItem(&tableEntry->WorkItem, VspWriteVolumePhase4,
                         tableEntry);
    VspAcquirePagedResource(extension, &tableEntry->WorkItem);
}

NTSTATUS
VspWriteVolumePhase3(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           TableEntry
    )

/*++

Routine Description:

    This routine is the completion for a write to the diff area file.

Arguments:

    Context - Supplies the context.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    PTEMP_TRANSLATION_TABLE_ENTRY   tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY) TableEntry;
    PVOLUME_EXTENSION               extension = tableEntry->Extension;
    PFILTER_EXTENSION               filter = extension->Filter;
    NTSTATUS                        status = Irp->IoStatus.Status;
    KIRQL                           irql;
    BOOLEAN                         emptyQueue;
    PLIST_ENTRY                     l;
    PWORK_QUEUE_ITEM                workItem;
    PVSP_CONTEXT                    context;
    PIRP                            irp;

    if (!NT_SUCCESS(status)) {
        if (!filter->DestroyAllSnapshotsPending) {
            VspLogError(extension, NULL, VS_ABORT_SNAPSHOTS_IO_FAILURE,
                        status, 1);
        }
        VspDestroyAllSnapshots(filter, tableEntry);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    VspFreeCopyIrp(extension, Irp);
    tableEntry->CopyIrp = NULL;

    KeAcquireSpinLock(&extension->SpinLock, &irql);
    RtlSetBit(extension->VolumeBlockBitmap,
              (ULONG) (tableEntry->VolumeOffset>>BLOCK_SHIFT));
    tableEntry->IsComplete = TRUE;
    KeReleaseSpinLock(&extension->SpinLock, irql);

    while (!IsListEmpty(&tableEntry->WaitingQueueDpc)) {
        l = RemoveHeadList(&tableEntry->WaitingQueueDpc);
        workItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
        context = (PVSP_CONTEXT) workItem->Parameter;
        if (context->Type == VSP_CONTEXT_TYPE_READ_SNAPSHOT) {
            context->ReadSnapshot.TargetObject = tableEntry->TargetObject;
            context->ReadSnapshot.TargetOffset = tableEntry->TargetOffset;
        }
        workItem->WorkerRoutine(workItem->Parameter);
    }

    irp = tableEntry->WriteIrp;
    tableEntry->WriteIrp = NULL;

    ExInitializeWorkItem(&tableEntry->WorkItem, VspWriteVolumeRefCount,
                         tableEntry);
    status = VspIncrementVolumeRefCount(extension, NULL,
                                        &tableEntry->WorkItem);
    if (!NT_SUCCESS(status)) {
        VspDestroyAllSnapshots(filter, tableEntry);
        VspDecrementIrpRefCount(irp);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    VspDecrementIrpRefCount(irp);

    if (status != STATUS_PENDING) {
        ExInitializeWorkItem(&tableEntry->WorkItem, VspWriteVolumePhase4,
                             tableEntry);
        VspAcquirePagedResource(extension, &tableEntry->WorkItem);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
VspWriteVolumePhase2(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           TableEntry
    )

/*++

Routine Description:

    This routine is the completion for a read who's data will create
    the table entry for the block that is being written to.

Arguments:

    Context - Supplies the context.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    NTSTATUS                        status = Irp->IoStatus.Status;
    PIO_STACK_LOCATION              nextSp = IoGetNextIrpStackLocation(Irp);
    PTEMP_TRANSLATION_TABLE_ENTRY   tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY) TableEntry;

    if (!NT_SUCCESS(status)) {
        if (!tableEntry->Extension->Filter->DestroyAllSnapshotsPending) {
            VspLogError(tableEntry->Extension, NULL,
                        VS_ABORT_SNAPSHOTS_IO_FAILURE, status, 2);
        }
        VspDestroyAllSnapshots(tableEntry->Extension->Filter, tableEntry);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    Irp->Tail.Overlay.Thread = PsGetCurrentThread();
    nextSp = IoGetNextIrpStackLocation(Irp);
    nextSp->Parameters.Write.ByteOffset.QuadPart = tableEntry->TargetOffset;
    nextSp->Parameters.Write.Length = BLOCK_SIZE;
    nextSp->MajorFunction = IRP_MJ_WRITE;
    nextSp->DeviceObject = tableEntry->TargetObject;
    nextSp->Flags = SL_OVERRIDE_VERIFY_VOLUME;

    IoSetCompletionRoutine(Irp, VspWriteVolumePhase3, tableEntry, TRUE, TRUE,
                           TRUE);

    IoCallDriver(tableEntry->TargetObject, Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
VspWriteVolumePhase1(
    IN  PVOID   TableEntry
    )

/*++

Routine Description:

    This routine is the first phase of copying volume data to the diff
    area file.  An irp and buffer are created for the initial read of
    the block.

Arguments:

    Context - Supplies the context.

Return Value:

    None.

--*/

{
    PTEMP_TRANSLATION_TABLE_ENTRY   tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY) TableEntry;
    PVOLUME_EXTENSION               extension = tableEntry->Extension;
    PFILTER_EXTENSION               filter = extension->Filter;
    PIRP                            irp = tableEntry->CopyIrp;
    PIO_STACK_LOCATION              nextSp;

    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    nextSp = IoGetNextIrpStackLocation(irp);
    nextSp->Parameters.Read.ByteOffset.QuadPart = tableEntry->VolumeOffset;
    nextSp->Parameters.Read.Length = BLOCK_SIZE;
    nextSp->MajorFunction = IRP_MJ_READ;
    nextSp->DeviceObject = filter->TargetObject;
    nextSp->Flags = SL_OVERRIDE_VERIFY_VOLUME;

    if (tableEntry->VolumeOffset + BLOCK_SIZE > extension->VolumeSize) {
        if (extension->VolumeSize > tableEntry->VolumeOffset) {
            nextSp->Parameters.Read.Length = (ULONG) (extension->VolumeSize -
                                                      tableEntry->VolumeOffset);
        }
    }

    IoSetCompletionRoutine(irp, VspWriteVolumePhase2, tableEntry, TRUE, TRUE,
                           TRUE);

    IoCallDriver(filter->TargetObject, irp);
}

VOID
VspUnmapNextDiffAreaFileMap(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION   extension = context->Extension.Extension;
    NTSTATUS            status;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_EXTENSION);

    VspFreeContext(extension->Root, context);

    if (extension->NextDiffAreaFileMap) {
        status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                      extension->NextDiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        extension->NextDiffAreaFileMap = NULL;
    }

    VspReleasePagedResource(extension);
    ObDereferenceObject(extension->Filter->DeviceObject);
    ObDereferenceObject(extension->DeviceObject);
}

NTSTATUS
VspTruncatePreviousDiffArea(
    IN  PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine takes the snapshot that occurred before this one and
    truncates its diff area file to the current used size since diff
    area files can't grow after a new snapshot is added on top.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    NTSTATUS

--*/

{
    PFILTER_EXTENSION           filter = Extension->Filter;
    PLIST_ENTRY                 l, ll;
    PVOLUME_EXTENSION           extension;
    PVSP_DIFF_AREA_FILE         diffAreaFile;
    NTSTATUS                    status;
    LONGLONG                    diff;
    KIRQL                       irql;
    PDIFF_AREA_FILE_ALLOCATION  diffAreaFileAllocation;
    PVSP_CONTEXT                context;

    l = Extension->ListEntry.Blink;
    if (l == &filter->VolumeList) {
        return STATUS_SUCCESS;
    }

    extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

    for (l = extension->ListOfDiffAreaFiles.Flink;
         l != &extension->ListOfDiffAreaFiles; l = l->Flink) {

        diffAreaFile = CONTAINING_RECORD(l, VSP_DIFF_AREA_FILE,
                                         VolumeListEntry);

        status = VspSetFileSizes(diffAreaFile->FileHandle,
                                 diffAreaFile->NextAvailable);

        if (NT_SUCCESS(status)) {

            VspAcquireNonPagedResource(extension, NULL);
            diff = diffAreaFile->AllocatedFileSize -
                   diffAreaFile->NextAvailable;
            diffAreaFile->AllocatedFileSize -= diff;
            VspReleaseNonPagedResource(extension);

            KeAcquireSpinLock(&filter->SpinLock, &irql);
            filter->AllocatedVolumeSpace -= diff;
            KeReleaseSpinLock(&filter->SpinLock, irql);
        }

        while (!IsListEmpty(&diffAreaFile->UnusedAllocationList)) {
            ll = RemoveHeadList(&diffAreaFile->UnusedAllocationList);
            diffAreaFileAllocation = CONTAINING_RECORD(ll,
                                     DIFF_AREA_FILE_ALLOCATION, ListEntry);
            ExFreePool(diffAreaFileAllocation);
        }
    }

    if (extension->EmergencyCopyIrp) {
        ExFreePool(MmGetMdlVirtualAddress(
                   extension->EmergencyCopyIrp->MdlAddress));
        IoFreeMdl(extension->EmergencyCopyIrp->MdlAddress);
        IoFreeIrp(extension->EmergencyCopyIrp);
        extension->EmergencyCopyIrp = NULL;
    }

    context = VspAllocateContext(Extension->Root);
    if (context) {
        context->Type = VSP_CONTEXT_TYPE_EXTENSION;
        context->Extension.Extension = extension;
        ExInitializeWorkItem(&context->WorkItem, VspUnmapNextDiffAreaFileMap,
                             context);
        ObReferenceObject(extension->DeviceObject);
        ObReferenceObject(extension->Filter->DeviceObject);
        VspAcquirePagedResource(extension, &context->WorkItem);
    }

    return STATUS_SUCCESS;
}

VOID
VspOrBitmaps(
    IN OUT  PRTL_BITMAP BaseBitmap,
    IN      PRTL_BITMAP FactorBitmap
    )

{
    ULONG   n, i;
    PULONG  p, q;

    n = (BaseBitmap->SizeOfBitMap + 8*sizeof(ULONG) - 1)/(8*sizeof(ULONG));
    p = BaseBitmap->Buffer;
    q = FactorBitmap->Buffer;

    for (i = 0; i < n; i++) {
        *p++ |= *q++;
    }
}

VOID
VspAdjustBitmap(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT            context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION       extension = context->Extension.Extension;
    NTSTATUS                status;
    KIRQL                   irql;
    PLIST_ENTRY             l;
    PWORK_QUEUE_ITEM        workItem;
    PWORKER_THREAD_ROUTINE  workerRoutine;
    PVOID                   parameter;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_EXTENSION);

    VspFreeContext(extension->Root, context);

    status = VspComputeIgnorableProduct(extension);

    KeAcquireSpinLock(&extension->SpinLock, &irql);
    if (extension->IgnorableProduct) {
        if (NT_SUCCESS(status) && extension->VolumeBlockBitmap) {
            VspOrBitmaps(extension->VolumeBlockBitmap,
                         extension->IgnorableProduct);
        }

        ExFreePool(extension->IgnorableProduct->Buffer);
        ExFreePool(extension->IgnorableProduct);
        extension->IgnorableProduct = NULL;
    }
    KeReleaseSpinLock(&extension->SpinLock, irql);

    KeAcquireSpinLock(&extension->Root->ESpinLock, &irql);
    ASSERT(extension->Root->AdjustBitmapInProgress);
    if (IsListEmpty(&extension->Root->AdjustBitmapQueue)) {
        extension->Root->AdjustBitmapInProgress = FALSE;
        KeReleaseSpinLock(&extension->Root->ESpinLock, irql);
    } else {
        l = RemoveHeadList(&extension->Root->AdjustBitmapQueue);
        KeReleaseSpinLock(&extension->Root->ESpinLock, irql);

        workItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);

        workerRoutine = workItem->WorkerRoutine;
        parameter = workItem->Parameter;
        ExInitializeWorkItem(workItem, workerRoutine, parameter);

        ExQueueWorkItem(workItem, DelayedWorkQueue);
    }

    ObDereferenceObject(extension->Filter->DeviceObject);
    ObDereferenceObject(extension->DeviceObject);
}

VOID
VspSetIgnorableBlocksInBitmapWorker(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION   extension = context->Extension.Extension;
    NTSTATUS            status;
    KIRQL               irql;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_EXTENSION);

    status = VspSetIgnorableBlocksInBitmap(extension);

    if (NT_SUCCESS(status)) {
        InterlockedExchange(&extension->OkToGrowDiffArea, TRUE);
    } else {
        if (!extension->Filter->DestroyAllSnapshotsPending) {
            VspLogError(extension, NULL,
                        VS_ABORT_SNAPSHOTS_FAILED_FREE_SPACE_DETECTION,
                        status, 0);
        }
        VspDestroyAllSnapshots(extension->Filter, NULL);
    }

    KeSetEvent(&extension->Filter->EndCommitProcessCompleted, IO_NO_INCREMENT,
               FALSE);

    ExInitializeWorkItem(&context->WorkItem, VspAdjustBitmap, context);

    KeAcquireSpinLock(&extension->Root->ESpinLock, &irql);
    if (extension->Root->AdjustBitmapInProgress) {
        InsertTailList(&extension->Root->AdjustBitmapQueue,
                       &context->WorkItem.List);
        KeReleaseSpinLock(&extension->Root->ESpinLock, irql);
    } else {
        extension->Root->AdjustBitmapInProgress = TRUE;
        KeReleaseSpinLock(&extension->Root->ESpinLock, irql);
        ExQueueWorkItem(&context->WorkItem, DelayedWorkQueue);
    }
}

VOID
VspFreeCopyIrp(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                CopyIrp
    )

{
    KIRQL                           irql;
    PLIST_ENTRY                     l;
    PWORK_QUEUE_ITEM                workItem;
    PTEMP_TRANSLATION_TABLE_ENTRY   tableEntry;

    if (Extension->EmergencyCopyIrp == CopyIrp) {
        KeAcquireSpinLock(&Extension->SpinLock, &irql);
        if (IsListEmpty(&Extension->EmergencyCopyIrpQueue)) {
            Extension->EmergencyCopyIrpInUse = FALSE;
            KeReleaseSpinLock(&Extension->SpinLock, irql);
            return;
        }
        l = RemoveHeadList(&Extension->EmergencyCopyIrpQueue);
        KeReleaseSpinLock(&Extension->SpinLock, irql);

        workItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
        tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY) workItem->Parameter;
        tableEntry->CopyIrp = CopyIrp;

        VspWriteVolumePhase1(tableEntry);
        return;
    }

    if (!Extension->EmergencyCopyIrpInUse) {
        ExFreePool(MmGetMdlVirtualAddress(CopyIrp->MdlAddress));
        IoFreeMdl(CopyIrp->MdlAddress);
        IoFreeIrp(CopyIrp);
        return;
    }

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    if (IsListEmpty(&Extension->EmergencyCopyIrpQueue)) {
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        ExFreePool(MmGetMdlVirtualAddress(CopyIrp->MdlAddress));
        IoFreeMdl(CopyIrp->MdlAddress);
        IoFreeIrp(CopyIrp);
        return;
    }
    l = RemoveHeadList(&Extension->EmergencyCopyIrpQueue);
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    workItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
    tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY) workItem->Parameter;
    tableEntry->CopyIrp = CopyIrp;

    VspWriteVolumePhase1(tableEntry);
}

VOID
VspApplyThresholdDelta(
    IN  PVOLUME_EXTENSION   Extension,
    IN  ULONG               IncreaseDelta
    )

{
    PLIST_ENTRY         l;
    PVSP_DIFF_AREA_FILE diffAreaFile;
    PVSP_CONTEXT        context;

    for (l = Extension->ListOfDiffAreaFiles.Flink;
         l != &Extension->ListOfDiffAreaFiles; l = l->Flink) {

        diffAreaFile = CONTAINING_RECORD(l, VSP_DIFF_AREA_FILE,
                                         VolumeListEntry);

        if (diffAreaFile->NextAvailable + Extension->DiffAreaFileIncrease <=
            diffAreaFile->AllocatedFileSize) {

            continue;
        }

        if (diffAreaFile->NextAvailable + Extension->DiffAreaFileIncrease -
            IncreaseDelta > diffAreaFile->AllocatedFileSize) {

            continue;
        }

        if (!Extension->OkToGrowDiffArea) {
            VspLogError(Extension, diffAreaFile->Filter,
                        VS_GROW_BEFORE_FREE_SPACE, STATUS_SUCCESS, 0);
            continue;
        }

        context = VspAllocateContext(Extension->Root);
        if (!context) {
            continue;
        }

        context->Type = VSP_CONTEXT_TYPE_GROW_DIFF_AREA;
        context->GrowDiffArea.Extension  = Extension;
        context->GrowDiffArea.DiffAreaFile = diffAreaFile;
        ObReferenceObject(Extension->DeviceObject);
        ExInitializeWorkItem(&context->WorkItem, VspGrowDiffArea, context);
        VspQueueWorkItem(Extension->Root, &context->WorkItem, 0);
    }
}

VOID
VspWriteVolume(
    IN  PVOID   Context
    )

/*++

Routine Description:

    This routine performs a volume write, making sure that all of the
    parts of the volume write have an old version of the data placed
    in the diff area for the snapshot.

Arguments:

    Irp - Supplies the I/O request packet.

Return Value:

    None.

--*/

{
    PVSP_CONTEXT                    context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION               extension = context->WriteVolume.Extension;
    PIRP                            irp = (PIRP) context->WriteVolume.Irp;
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(irp);
    PIO_STACK_LOCATION              nextSp = IoGetNextIrpStackLocation(irp);
    PFILTER_EXTENSION               filter = extension->Filter;
    LONGLONG                        start, end, roundedStart, roundedEnd;
    ULONG                           irpLength, increase, increaseDelta;
    TEMP_TRANSLATION_TABLE_ENTRY    keyTableEntry;
    PTEMP_TRANSLATION_TABLE_ENTRY   tableEntry;
    PVOID                           nodeOrParent;
    TABLE_SEARCH_RESULT             searchResult;
    KIRQL                           irql;
    NTSTATUS                        status;
    CCHAR                           stackSize;
    PVSP_DIFF_AREA_FILE             diffAreaFile;
    PDO_EXTENSION                   rootExtension;
    PVOID                           buffer;
    PMDL                            mdl;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_WRITE_VOLUME);

    start = irpSp->Parameters.Read.ByteOffset.QuadPart;
    irpLength = irpSp->Parameters.Read.Length;
    end = start + irpLength;
    if (context->WriteVolume.RoundedStart) {
        roundedStart = context->WriteVolume.RoundedStart;
    } else {
        roundedStart = start&(~(BLOCK_SIZE - 1));
    }
    roundedEnd = end&(~(BLOCK_SIZE - 1));
    if (roundedEnd != end) {
        roundedEnd += BLOCK_SIZE;
    }

    ASSERT(extension->VolumeBlockBitmap);

    for (; roundedStart < roundedEnd; roundedStart += BLOCK_SIZE) {

        KeAcquireSpinLock(&extension->SpinLock, &irql);
        if (RtlCheckBit(extension->VolumeBlockBitmap,
                        (ULONG) (roundedStart>>BLOCK_SHIFT))) {

            KeReleaseSpinLock(&extension->SpinLock, irql);
            continue;
        }
        KeReleaseSpinLock(&extension->SpinLock, irql);

        keyTableEntry.VolumeOffset = roundedStart;

        tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY)
                     RtlLookupElementGenericTableFull(
                     &extension->TempVolumeBlockTable, &keyTableEntry,
                     &nodeOrParent, &searchResult);

        if (tableEntry) {

            context = VspAllocateContext(extension->Root);
            if (context) {
                context->Type = VSP_CONTEXT_TYPE_EXTENSION;
                context->Extension.Extension = extension;
                context->Extension.Irp = irp;
            } else {
                context = (PVSP_CONTEXT) Context;
                ASSERT(context->Type == VSP_CONTEXT_TYPE_WRITE_VOLUME);
                context->WriteVolume.RoundedStart = roundedStart;
            }
            ExInitializeWorkItem(&context->WorkItem,
                                 VspDecrementIrpRefCountWorker, context);

            KeAcquireSpinLock(&extension->SpinLock, &irql);
            if (tableEntry->IsComplete) {
                KeReleaseSpinLock(&extension->SpinLock, irql);
                if (context->Type == VSP_CONTEXT_TYPE_EXTENSION) {
                    VspFreeContext(extension->Root, context);
                }
                continue;
            }
            InterlockedIncrement((PLONG) &nextSp->Parameters.Write.Length);
            InsertTailList(&tableEntry->WaitingQueueDpc,
                           &context->WorkItem.List);
            KeReleaseSpinLock(&extension->SpinLock, irql);

            if (context == Context) {
                VspReleaseNonPagedResource(extension);
                return;
            }

            continue;
        }

        RtlZeroMemory(&keyTableEntry, sizeof(TEMP_TRANSLATION_TABLE_ENTRY));
        keyTableEntry.VolumeOffset = roundedStart;

        ASSERT(!extension->TempTableEntry);
        extension->TempTableEntry = VspAllocateTempTableEntry(extension->Root);
        if (!extension->TempTableEntry) {
            rootExtension = extension->Root;
            KeAcquireSpinLock(&rootExtension->ESpinLock, &irql);
            if (rootExtension->EmergencyTableEntryInUse) {
                context = (PVSP_CONTEXT) Context;
                ASSERT(context->Type == VSP_CONTEXT_TYPE_WRITE_VOLUME);
                context->WriteVolume.RoundedStart = roundedStart;
                InsertTailList(&rootExtension->WorkItemWaitingList,
                               &context->WorkItem.List);
                if (!rootExtension->WorkItemWaitingListNeedsChecking) {
                    InterlockedExchange(
                            &rootExtension->WorkItemWaitingListNeedsChecking,
                            TRUE);
                }
                KeReleaseSpinLock(&rootExtension->ESpinLock, irql);
                VspReleaseNonPagedResource(extension);
                return;
            }
            rootExtension->EmergencyTableEntryInUse = TRUE;
            KeReleaseSpinLock(&rootExtension->ESpinLock, irql);

            extension->TempTableEntry = rootExtension->EmergencyTableEntry;
        }

        tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY)
                     RtlInsertElementGenericTableFull(
                     &extension->TempVolumeBlockTable, &keyTableEntry,
                     sizeof(TEMP_TRANSLATION_TABLE_ENTRY), NULL,
                     nodeOrParent, searchResult);
        ASSERT(tableEntry);

        if (extension->TempVolumeBlockTable.NumberGenericTableElements >
            extension->MaximumNumberOfTempEntries) {

            extension->MaximumNumberOfTempEntries =
                    extension->TempVolumeBlockTable.NumberGenericTableElements;
            VspQueryDiffAreaFileIncrease(extension, &increase);
            ASSERT(increase >= extension->DiffAreaFileIncrease);
            increaseDelta = increase - extension->DiffAreaFileIncrease;
            if (increaseDelta) {
                InterlockedExchange((PLONG) &extension->DiffAreaFileIncrease,
                                    (LONG) increase);
                VspApplyThresholdDelta(extension, increaseDelta);
            }
        }

        tableEntry->Extension = extension;
        tableEntry->WriteIrp = irp;

        status = VspAllocateDiffAreaSpace(extension, &diffAreaFile,
                                          &tableEntry->TargetOffset);

        if (!NT_SUCCESS(status)) {
            if (!filter->DestroyAllSnapshotsPending) {
                VspLogError(extension, NULL,
                            VS_ABORT_SNAPSHOTS_OUT_OF_DIFF_AREA,
                            STATUS_SUCCESS, 0);
            }
            RtlDeleteElementGenericTable(&extension->TempVolumeBlockTable,
                                         tableEntry);
            VspDestroyAllSnapshots(filter, NULL);
            break;
        }
        tableEntry->TargetObject = diffAreaFile->Filter->TargetObject;

        tableEntry->IsComplete = FALSE;

        InitializeListHead(&tableEntry->WaitingQueueDpc);

        tableEntry->CopyIrp = IoAllocateIrp(
                              (CCHAR) extension->Root->StackSize, FALSE);
        buffer = ExAllocatePoolWithTagPriority(NonPagedPool, BLOCK_SIZE,
                                               VOLSNAP_TAG_BUFFER,
                                               LowPoolPriority);
        mdl = IoAllocateMdl(buffer, BLOCK_SIZE, FALSE, FALSE, NULL);

        if (!tableEntry->CopyIrp || !buffer || !mdl) {
            if (tableEntry->CopyIrp) {
                IoFreeIrp(tableEntry->CopyIrp);
                tableEntry->CopyIrp = NULL;
            }
            if (buffer) {
                ExFreePool(buffer);
            }
            if (mdl) {
                IoFreeMdl(mdl);
            }
            KeAcquireSpinLock(&extension->SpinLock, &irql);
            if (extension->EmergencyCopyIrpInUse) {
                InterlockedIncrement((PLONG) &nextSp->Parameters.Write.Length);
                ExInitializeWorkItem(&tableEntry->WorkItem,
                                     VspWriteVolumePhase1, tableEntry);
                InsertTailList(&extension->EmergencyCopyIrpQueue,
                               &tableEntry->WorkItem.List);
                KeReleaseSpinLock(&extension->SpinLock, irql);
                continue;
            }
            extension->EmergencyCopyIrpInUse = TRUE;
            KeReleaseSpinLock(&extension->SpinLock, irql);

            tableEntry->CopyIrp = extension->EmergencyCopyIrp;

        } else {
            MmBuildMdlForNonPagedPool(mdl);
            tableEntry->CopyIrp->MdlAddress = mdl;
        }

        InterlockedIncrement((PLONG) &nextSp->Parameters.Write.Length);

        VspWriteVolumePhase1(tableEntry);
    }

    context = (PVSP_CONTEXT) Context;
    VspFreeContext(filter->Root, context);

    VspReleaseNonPagedResource(extension);
    VspDecrementIrpRefCount(irp);
}

VOID
VspIrpsTimerDpc(
    IN  PKDPC   TimerDpc,
    IN  PVOID   Context,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
    )

{
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) Context;
    KIRQL               irql;
    LIST_ENTRY          q;
    PLIST_ENTRY         l;
    PIRP                irp;
    BOOLEAN             emptyQueue;

    VspLogError(NULL, filter, VS_FLUSH_AND_HOLD_IRP_TIMEOUT, STATUS_SUCCESS,
                0);

    IoStopTimer(filter->DeviceObject);

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    InterlockedIncrement(&filter->RefCount);
    InterlockedExchange(&filter->TimerIsSet, FALSE);
    InterlockedExchange(&filter->HoldIncomingWrites, FALSE);
    if (IsListEmpty(&filter->HoldQueue)) {
        emptyQueue = FALSE;
    } else {
        emptyQueue = TRUE;
        q = filter->HoldQueue;
        InitializeListHead(&filter->HoldQueue);
    }
    KeReleaseSpinLock(&filter->SpinLock, irql);

    if (emptyQueue) {
        q.Blink->Flink = &q;
        q.Flink->Blink = &q;
        VspEmptyIrpQueue(filter->Root->DriverObject, &q);
    }
}

VOID
VspEndCommitDpc(
    IN  PKDPC   TimerDpc,
    IN  PVOID   Context,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
    )

{
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) Context;

    VspLogError(NULL, filter, VS_END_COMMIT_TIMEOUT, STATUS_CANCELLED, 0);
    KeSetEvent(&filter->EndCommitProcessCompleted, IO_NO_INCREMENT, FALSE);
    ObDereferenceObject(filter->DeviceObject);
}

NTSTATUS
VspCheckForMemoryPressure(
    IN  PFILTER_EXTENSION   Filter
    )

/*++

Routine Description:

    This routine will allocate 256 K of paged and non paged pool.  If these
    allocs succeed, it indicates that the system is not under memory pressure
    and so it is ok to hold write irps for the next second.

Arguments:

    Filter  - Supplies the filter extension.

Return Value:

    NTSTATUS

--*/

{
    PVOID   p, np;

    p = ExAllocatePoolWithTagPriority(PagedPool,
            MEMORY_PRESSURE_CHECK_ALLOC_SIZE, VOLSNAP_TAG_SHORT_TERM,
            LowPoolPriority);
    if (!p) {
        VspLogError(NULL, Filter, VS_MEMORY_PRESSURE_DURING_LOVELACE,
                    STATUS_INSUFFICIENT_RESOURCES, 1);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    np = ExAllocatePoolWithTagPriority(NonPagedPool,
            MEMORY_PRESSURE_CHECK_ALLOC_SIZE, VOLSNAP_TAG_SHORT_TERM,
            LowPoolPriority);
    if (!np) {
        ExFreePool(p);
        VspLogError(NULL, Filter, VS_MEMORY_PRESSURE_DURING_LOVELACE,
                    STATUS_INSUFFICIENT_RESOURCES, 2);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ExFreePool(np);
    ExFreePool(p);

    return STATUS_SUCCESS;
}

VOID
VspOneSecondTimerWorker(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PVOID           WorkItem
    )

{
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;
    PIO_WORKITEM        workItem = (PIO_WORKITEM) WorkItem;
    NTSTATUS            status;

    status = VspCheckForMemoryPressure(filter);
    if (!NT_SUCCESS(status)) {
        VspReleaseWrites(filter);
    }

    IoFreeWorkItem(workItem);
}

VOID
VspOneSecondTimer(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PVOID           Filter
    )

/*++

Routine Description:

    This routine will get called once every second after an IoStartTimer.
    This routine checks for memory pressure and aborts the lovelace operation
    if any memory pressure is detected.

Arguments:

    DeviceObject    - Supplies the device object.

    Filter          - Supplies the filter extension.

Return Value:

    None.

--*/

{
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) Filter;
    PIO_WORKITEM        workItem;

    workItem = IoAllocateWorkItem(filter->DeviceObject);
    if (!workItem) {
        VspLogError(NULL, filter, VS_MEMORY_PRESSURE_DURING_LOVELACE,
                    STATUS_INSUFFICIENT_RESOURCES, 3);
        VspReleaseWrites(filter);
        return;
    }

    IoQueueWorkItem(workItem, VspOneSecondTimerWorker, CriticalWorkQueue,
                    workItem);
}

NTSTATUS
VolSnapAddDevice(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PDEVICE_OBJECT  PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine creates and initializes a new FILTER for the corresponding
    volume PDO.

Arguments:

    DriverObject            - Supplies the VOLSNAP driver object.

    PhysicalDeviceObject    - Supplies the volume PDO.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_OBJECT          attachedDevice;
    NTSTATUS                status;
    PDEVICE_OBJECT          deviceObject;
    PDO_EXTENSION           rootExtension;
    PFILTER_EXTENSION       filter;
    PVSP_DIFF_AREA_VOLUME   diffAreaVolume;

    attachedDevice = IoGetAttachedDeviceReference(PhysicalDeviceObject);
    if (attachedDevice) {
        if (attachedDevice->Characteristics&FILE_REMOVABLE_MEDIA) {
            ObDereferenceObject(attachedDevice);
            return STATUS_SUCCESS;
        }
        ObDereferenceObject(attachedDevice);
    }

    status = IoCreateDevice(DriverObject, sizeof(FILTER_EXTENSION),
                            NULL, FILE_DEVICE_DISK, 0, FALSE, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    rootExtension = (PDO_EXTENSION)
                    IoGetDriverObjectExtension(DriverObject, VolSnapAddDevice);
    if (!rootExtension) {
        IoDeleteDevice(deviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }

    filter = (PFILTER_EXTENSION) deviceObject->DeviceExtension;
    RtlZeroMemory(filter, sizeof(FILTER_EXTENSION));
    filter->DeviceObject = deviceObject;
    filter->Root = rootExtension;
    filter->DeviceExtensionType = DEVICE_EXTENSION_FILTER;
    KeInitializeSpinLock(&filter->SpinLock);

    filter->TargetObject =
            IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);
    if (!filter->TargetObject) {
        IoDeleteDevice(deviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }

    filter->Pdo = PhysicalDeviceObject;
    filter->RefCount = 1;
    InitializeListHead(&filter->HoldQueue);
    KeInitializeTimer(&filter->HoldWritesTimer);
    KeInitializeDpc(&filter->HoldWritesTimerDpc, VspIrpsTimerDpc, filter);
    KeInitializeEvent(&filter->EndCommitProcessCompleted, NotificationEvent,
                      TRUE);
    InitializeListHead(&filter->VolumeList);
    InitializeListHead(&filter->DeadVolumeList);
    InitializeListHead(&filter->DiffAreaFilesOnThisFilter);

    InitializeListHead(&filter->DiffAreaVolumes);
    diffAreaVolume = (PVSP_DIFF_AREA_VOLUME)
                     ExAllocatePoolWithTag((POOL_TYPE)(PagedPool | POOL_COLD_ALLOCATION),
                     sizeof(VSP_DIFF_AREA_VOLUME), VOLSNAP_TAG_DIFF_VOLUME);

    if (!diffAreaVolume) {
        IoDetachDevice(filter->TargetObject);
        IoDeleteDevice(deviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    diffAreaVolume->Filter = filter;
    InsertTailList(&filter->DiffAreaVolumes, &diffAreaVolume->ListEntry);

    KeInitializeTimer(&filter->EndCommitTimer);
    KeInitializeDpc(&filter->EndCommitTimerDpc, VspEndCommitDpc, filter);

    InitializeListHead(&filter->NonPagedResourceList);
    InitializeListHead(&filter->PagedResourceList);

    status = IoInitializeTimer(deviceObject, VspOneSecondTimer, filter);
    if (!NT_SUCCESS(status)) {
        IoDetachDevice(filter->TargetObject);
        IoDeleteDevice(deviceObject);
        return status;
    }

    deviceObject->Flags |= DO_DIRECT_IO;
    if (filter->TargetObject->Flags & DO_POWER_PAGABLE) {
        deviceObject->Flags |= DO_POWER_PAGABLE;
    }
    if (filter->TargetObject->Flags & DO_POWER_INRUSH) {
        deviceObject->Flags |= DO_POWER_INRUSH;
    }

    VspAcquire(filter->Root);
    if (filter->TargetObject->StackSize > filter->Root->StackSize) {
        InterlockedExchange(&filter->Root->StackSize,
                            (LONG) filter->TargetObject->StackSize);
    }
    InsertTailList(&filter->Root->FilterList, &filter->ListEntry);
    VspRelease(filter->Root);

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return STATUS_SUCCESS;
}

NTSTATUS
VolSnapCreate(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_CREATE.

Arguments:

    DeviceObject - Supplies the device object.

    Irp          - Supplies the IO request block.

Return Value:

    NTSTATUS

--*/

{
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;

    if (filter->DeviceExtensionType == DEVICE_EXTENSION_FILTER) {
        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver(filter->TargetObject, Irp);
    }

    ASSERT(filter->DeviceExtensionType == DEVICE_EXTENSION_VOLUME);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

NTSTATUS
VspReadSnapshotPhase2(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION   extension = context->ReadSnapshot.Extension;
    PIRP                irp = context->ReadSnapshot.OriginalReadIrp;
    PIO_STACK_LOCATION  nextSp = IoGetNextIrpStackLocation(irp);

    ASSERT(context->Type == VSP_CONTEXT_TYPE_READ_SNAPSHOT);

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        irp->IoStatus = Irp->IoStatus;
    }

    IoFreeMdl(Irp->MdlAddress);
    IoFreeIrp(Irp);

    VspFreeContext(extension->Root, context);

    VspDecrementVolumeIrpRefCount(irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
VspReadSnapshotPhase1(
    IN  PVOID   Context
    )

/*++

Routine Description:

    This routine is called when a read snapshot routine is waiting for
    somebody else to finish updating the public area of a table entry.
    When this routine is called, the public area of the table entry is
    valid.

Arguments:

    Context - Supplies the context.

Return Value:

    None.

--*/

{
    PVSP_CONTEXT                    context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION               extension = context->ReadSnapshot.Extension;
    TEMP_TRANSLATION_TABLE_ENTRY    keyTempTableEntry;
    PTEMP_TRANSLATION_TABLE_ENTRY   tempTableEntry;
    TRANSLATION_TABLE_ENTRY         keyTableEntry;
    PTRANSLATION_TABLE_ENTRY        tableEntry;
    NTSTATUS                        status;
    PIRP                            irp;
    PIO_STACK_LOCATION              nextSp;
    PCHAR                           vp;
    PMDL                            mdl;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_READ_SNAPSHOT);

    if (!context->ReadSnapshot.TargetObject) {
        irp = context->ReadSnapshot.OriginalReadIrp;
        irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        irp->IoStatus.Information = 0;
        VspFreeContext(extension->Root, context);
        VspDecrementVolumeIrpRefCount(irp);
        return;
    }

    irp = IoAllocateIrp(context->ReadSnapshot.TargetObject->StackSize, FALSE);
    if (!irp) {
        irp = context->ReadSnapshot.OriginalReadIrp;
        irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        irp->IoStatus.Information = 0;
        VspFreeContext(extension->Root, context);
        VspDecrementVolumeIrpRefCount(irp);
        return;
    }

    vp = (PCHAR) MmGetMdlVirtualAddress(
                 context->ReadSnapshot.OriginalReadIrp->MdlAddress) +
         context->ReadSnapshot.OriginalReadIrpOffset;
    mdl = IoAllocateMdl(vp, context->ReadSnapshot.Length, FALSE, FALSE, NULL);
    if (!mdl) {
        IoFreeIrp(irp);
        irp = context->ReadSnapshot.OriginalReadIrp;
        irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        irp->IoStatus.Information = 0;
        VspFreeContext(extension->Root, context);
        VspDecrementVolumeIrpRefCount(irp);
        return;
    }

    IoBuildPartialMdl(context->ReadSnapshot.OriginalReadIrp->MdlAddress, mdl,
                      vp, context->ReadSnapshot.Length);

    irp->MdlAddress = mdl;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    nextSp = IoGetNextIrpStackLocation(irp);
    nextSp->Parameters.Read.ByteOffset.QuadPart =
            context->ReadSnapshot.TargetOffset +
            context->ReadSnapshot.BlockOffset;
    nextSp->Parameters.Read.Length = context->ReadSnapshot.Length;
    nextSp->MajorFunction = IRP_MJ_READ;
    nextSp->DeviceObject = context->ReadSnapshot.TargetObject;
    nextSp->Flags = SL_OVERRIDE_VERIFY_VOLUME;

    IoSetCompletionRoutine(irp, VspReadSnapshotPhase2, context, TRUE, TRUE,
                           TRUE);

    IoCallDriver(context->ReadSnapshot.TargetObject, irp);
}

VOID
VspReadSnapshot(
    IN  PVOID   Context
    )

/*++

Routine Description:

    This routine kicks off a read snapshot.  First the table is searched
    to see if any of the data for this IRP resides in the diff area.  If not,
    then the Irp is sent directly to the original volume and then the diff
    area is checked again when it returns to fill in any gaps that may
    have been written while the IRP was in transit.

Arguments:

    Irp     - Supplies the I/O request packet.

Return Value:

    None.

--*/

{
    PVSP_CONTEXT                    context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION               extension = context->Extension.Extension;
    PIRP                            irp = context->Extension.Irp;
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(irp);
    PIO_STACK_LOCATION              nextSp = IoGetNextIrpStackLocation(irp);
    PFILTER_EXTENSION               filter = extension->Filter;
    LONGLONG                        start, end, roundedStart, roundedEnd;
    ULONG                           irpOffset, irpLength, length, blockOffset;
    TRANSLATION_TABLE_ENTRY         keyTableEntry;
    TEMP_TRANSLATION_TABLE_ENTRY    keyTempTableEntry;
    PVOLUME_EXTENSION               e;
    PTRANSLATION_TABLE_ENTRY        tableEntry;
    PTEMP_TRANSLATION_TABLE_ENTRY   tempTableEntry;
    KIRQL                           irql;
    NTSTATUS                        status;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_EXTENSION);

    VspFreeContext(extension->Root, context);

    start = irpSp->Parameters.Read.ByteOffset.QuadPart;
    irpLength = irpSp->Parameters.Read.Length;
    end = start + irpLength;
    roundedStart = start&(~(BLOCK_SIZE - 1));
    roundedEnd = end&(~(BLOCK_SIZE - 1));
    if (roundedEnd != end) {
        roundedEnd += BLOCK_SIZE;
    }
    irpOffset = 0;

    RtlZeroMemory(&keyTableEntry, sizeof(keyTableEntry));

    for (; roundedStart < roundedEnd; roundedStart += BLOCK_SIZE) {

        if (roundedStart < start) {
            blockOffset = (ULONG) (start - roundedStart);
        } else {
            blockOffset = 0;
        }

        length = BLOCK_SIZE - blockOffset;
        if (irpLength < length) {
            length = irpLength;
        }

        keyTableEntry.VolumeOffset = roundedStart;
        e = extension;
        status = STATUS_SUCCESS;
        for (;;) {

            _try {
                tableEntry = (PTRANSLATION_TABLE_ENTRY)
                             RtlLookupElementGenericTable(&e->VolumeBlockTable,
                                                          &keyTableEntry);
            } _except (EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
                tableEntry = NULL;
            }

            if (tableEntry) {
                break;
            }

            if (!NT_SUCCESS(status)) {
                irp->IoStatus.Status = status;
                irp->IoStatus.Information = 0;
                break;
            }

            KeAcquireSpinLock(&filter->SpinLock, &irql);
            if (e->ListEntry.Flink == &filter->VolumeList) {
                KeReleaseSpinLock(&filter->SpinLock, irql);
                break;
            }
            e = CONTAINING_RECORD(e->ListEntry.Flink,
                                  VOLUME_EXTENSION, ListEntry);
            KeReleaseSpinLock(&filter->SpinLock, irql);
        }

        if (!tableEntry) {
            if (!NT_SUCCESS(status)) {
                break;
            }

            keyTempTableEntry.VolumeOffset = roundedStart;

            VspAcquireNonPagedResource(e, NULL);

            tempTableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY)
                             RtlLookupElementGenericTable(
                             &e->TempVolumeBlockTable, &keyTempTableEntry);

            if (!tempTableEntry) {
                VspReleaseNonPagedResource(e);
                irpOffset += length;
                irpLength -= length;
                continue;
            }
        }

        context = VspAllocateContext(extension->Root);
        if (!context) {
            if (!tableEntry) {
                VspReleaseNonPagedResource(e);
            }

            irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            irp->IoStatus.Information = 0;
            break;
        }

        context->Type = VSP_CONTEXT_TYPE_READ_SNAPSHOT;
        context->ReadSnapshot.Extension = extension;
        context->ReadSnapshot.OriginalReadIrp = irp;
        context->ReadSnapshot.OriginalReadIrpOffset = irpOffset;
        context->ReadSnapshot.OriginalVolumeOffset = roundedStart;
        context->ReadSnapshot.BlockOffset = blockOffset;
        context->ReadSnapshot.Length = length;
        context->ReadSnapshot.TargetObject = NULL;
        context->ReadSnapshot.TargetOffset = 0;

        if (!tableEntry) {

            KeAcquireSpinLock(&e->SpinLock, &irql);
            if (!tempTableEntry->IsComplete) {
                InterlockedIncrement((PLONG) &nextSp->Parameters.Read.Length);
                ExInitializeWorkItem(&context->WorkItem, VspReadSnapshotPhase1,
                                     context);
                InsertTailList(&tempTableEntry->WaitingQueueDpc,
                               &context->WorkItem.List);
                KeReleaseSpinLock(&e->SpinLock, irql);

                VspReleaseNonPagedResource(e);

                irpOffset += length;
                irpLength -= length;
                continue;
            }
            KeReleaseSpinLock(&e->SpinLock, irql);

            context->ReadSnapshot.TargetObject = tempTableEntry->TargetObject;
            context->ReadSnapshot.TargetOffset = tempTableEntry->TargetOffset;

            VspReleaseNonPagedResource(e);

            InterlockedIncrement((PLONG) &nextSp->Parameters.Read.Length);
            VspReadSnapshotPhase1(context);

            irpOffset += length;
            irpLength -= length;
            continue;
        }

        context->ReadSnapshot.TargetObject = tableEntry->TargetObject;
        context->ReadSnapshot.TargetOffset = tableEntry->TargetOffset;

        InterlockedIncrement((PLONG) &nextSp->Parameters.Read.Length);
        VspReadSnapshotPhase1(context);

        irpOffset += length;
        irpLength -= length;
    }

    VspReleasePagedResource(extension);
    VspDecrementVolumeIrpRefCount(irp);
}

NTSTATUS
VspReadCompletionForReadSnapshot(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Extension
    )

/*++

Routine Description:

    This routine is the completion to a read of the filter in
    response to a snapshot read.  This completion routine queues
    a worker routine to look at the diff area table and fill in
    any parts of the original that have been invalidated.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

    Extension       - Supplies the volume extension.

Return Value:

    NTSTATUS

--*/

{
    PVOLUME_EXTENSION   extension = (PVOLUME_EXTENSION) Extension;
    PIO_STACK_LOCATION  nextSp = IoGetNextIrpStackLocation(Irp);
    PVSP_CONTEXT        context;

    nextSp->Parameters.Read.Length = 1; ; // Use this for a ref count.

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        VspDecrementVolumeIrpRefCount(Irp);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    context = VspAllocateContext(extension->Root);
    if (!context) {
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        Irp->IoStatus.Information = 0;
        VspDecrementVolumeIrpRefCount(Irp);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    context->Type = VSP_CONTEXT_TYPE_EXTENSION;
    context->Extension.Extension = extension;
    context->Extension.Irp = Irp;
    ExInitializeWorkItem(&context->WorkItem, VspReadSnapshot, context);
    VspAcquirePagedResource(extension, &context->WorkItem);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

RTL_GENERIC_COMPARE_RESULTS
VspTableCompareRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  PVOID               First,
    IN  PVOID               Second
    )

{
    PTRANSLATION_TABLE_ENTRY    first = (PTRANSLATION_TABLE_ENTRY) First;
    PTRANSLATION_TABLE_ENTRY    second = (PTRANSLATION_TABLE_ENTRY) Second;

    if (first->VolumeOffset < second->VolumeOffset) {
        return GenericLessThan;
    } else if (first->VolumeOffset > second->VolumeOffset) {
        return GenericGreaterThan;
    }

    return GenericEqual;
}

VOID
VspCreateHeap(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION   extension = context->Extension.Extension;
    ULONG               increase;
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status;
    SIZE_T              size;
    LARGE_INTEGER       sectionSize, sectionOffset;
    HANDLE              h;
    PVOID               mapPointer;
    KIRQL               irql;
    BOOLEAN             emptyQueue;
    LIST_ENTRY          q;
    PLIST_ENTRY         l;
    PWORK_QUEUE_ITEM    workItem;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_EXTENSION);
    VspFreeContext(extension->Root, context);

    increase = extension->DiffAreaFileIncrease;
    increase >>= BLOCK_SHIFT;

    size = increase*(sizeof(TRANSLATION_TABLE_ENTRY) +
                     sizeof(RTL_BALANCED_LINKS));
    size = (size + 0xFFFF)&(~0xFFFF);
    ASSERT(size >= MINIMUM_TABLE_HEAP_SIZE);

    InitializeObjectAttributes(&oa, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

DoOver:
    sectionSize.QuadPart = size;
    status = ZwCreateSection(&h, STANDARD_RIGHTS_REQUIRED | SECTION_QUERY |
                             SECTION_MAP_READ | SECTION_MAP_WRITE, &oa,
                             &sectionSize, PAGE_READWRITE, SEC_COMMIT,
                             NULL);
    if (!NT_SUCCESS(status)) {
        if (size > MINIMUM_TABLE_HEAP_SIZE) {
            size = MINIMUM_TABLE_HEAP_SIZE;
            goto DoOver;
        }
        VspLogError(extension, NULL, VS_CANT_CREATE_HEAP, status, 1);
        goto Finish;
    }

    sectionOffset.QuadPart = 0;
    mapPointer = NULL;
    status = ZwMapViewOfSection(h, NtCurrentProcess(), &mapPointer, 0, 0,
                                &sectionOffset, &size, ViewShare, 0,
                                PAGE_READWRITE);
    ZwClose(h);
    if (!NT_SUCCESS(status)) {
        if (size > MINIMUM_TABLE_HEAP_SIZE) {
            size = MINIMUM_TABLE_HEAP_SIZE;
            goto DoOver;
        }
        VspLogError(extension, NULL, VS_CANT_CREATE_HEAP, status, 2);
        goto Finish;
    }

    VspAcquire(extension->Root);

    if (extension->IsDead) {
        VspRelease(extension->Root);
        status = ZwUnmapViewOfSection(NtCurrentProcess(), mapPointer);
        ASSERT(NT_SUCCESS(status));
        goto Finish;
    }

    VspAcquirePagedResource(extension, NULL);
    extension->NextDiffAreaFileMap = mapPointer;
    extension->NextDiffAreaFileMapSize = (ULONG) size;
    extension->DiffAreaFileMapProcess = NtCurrentProcess();
    VspReleasePagedResource(extension);

    VspRelease(extension->Root);

Finish:
    KeAcquireSpinLock(&extension->SpinLock, &irql);
    if (extension->PageFileSpaceCreatePending) {
        extension->PageFileSpaceCreatePending = FALSE;
        if (IsListEmpty(&extension->WaitingForPageFileSpace)) {
            emptyQueue = FALSE;
        } else {
            emptyQueue = TRUE;
            q = extension->WaitingForPageFileSpace;
            InitializeListHead(&extension->WaitingForPageFileSpace);
        }
    } else {
        emptyQueue = FALSE;
    }
    KeReleaseSpinLock(&extension->SpinLock, irql);

    if (emptyQueue) {
        q.Flink->Blink = &q;
        q.Blink->Flink = &q;
        while (!IsListEmpty(&q)) {
            l = RemoveHeadList(&q);
            workItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
            VspAcquirePagedResource(extension, workItem);
        }
    }

    ObDereferenceObject(extension->DeviceObject);
}

PVOID
VspTableAllocateRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  CLONG               Size
    )

{
    PVOLUME_EXTENSION   extension = (PVOLUME_EXTENSION) Table->TableContext;
    PVOID               p;
    POLD_HEAP_ENTRY     oldHeap;
    PVSP_CONTEXT        context;
    KIRQL               irql;

    if (extension->NextAvailable + Size <= extension->DiffAreaFileMapSize) {
        p = (PCHAR) extension->DiffAreaFileMap + extension->NextAvailable;
        extension->NextAvailable += Size;
        return p;
    }

    if (!extension->NextDiffAreaFileMap) {
        return NULL;
    }

    oldHeap = (POLD_HEAP_ENTRY)
              ExAllocatePoolWithTag(PagedPool, sizeof(OLD_HEAP_ENTRY),
                                    VOLSNAP_TAG_OLD_HEAP);
    if (!oldHeap) {
        return NULL;
    }

    context = VspAllocateContext(extension->Root);
    if (!context) {
        ExFreePool(oldHeap);
        return NULL;
    }

    KeAcquireSpinLock(&extension->SpinLock, &irql);
    ASSERT(!extension->PageFileSpaceCreatePending);
    ASSERT(IsListEmpty(&extension->WaitingForPageFileSpace));
    extension->PageFileSpaceCreatePending = TRUE;
    KeReleaseSpinLock(&extension->SpinLock, irql);

    oldHeap->DiffAreaFileMap = extension->DiffAreaFileMap;
    InsertTailList(&extension->OldHeaps, &oldHeap->ListEntry);

    extension->DiffAreaFileMap = extension->NextDiffAreaFileMap;
    extension->DiffAreaFileMapSize = extension->NextDiffAreaFileMapSize;
    extension->NextAvailable = 0;
    extension->NextDiffAreaFileMap = NULL;

    context->Type = VSP_CONTEXT_TYPE_EXTENSION;
    context->Extension.Extension = extension;
    context->Extension.Irp = NULL;

    ObReferenceObject(extension->DeviceObject);
    ExInitializeWorkItem(&context->WorkItem, VspCreateHeap, context);
    VspQueueWorkItem(extension->Root, &context->WorkItem, 0);

    p = extension->DiffAreaFileMap;
    extension->NextAvailable += Size;

    return p;
}

VOID
VspTableFreeRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  PVOID               Buffer
    )

{
}

PVOID
VspTempTableAllocateRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  CLONG               Size
    )

{
    PVOLUME_EXTENSION   extension = (PVOLUME_EXTENSION) Table->TableContext;
    PVOID               r;

    ASSERT(Size <= sizeof(RTL_BALANCED_LINKS) +
           sizeof(TEMP_TRANSLATION_TABLE_ENTRY));

    r = extension->TempTableEntry;
    extension->TempTableEntry = NULL;

    return r;
}

VOID
VspTempTableFreeRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  PVOID               Buffer
    )

{
    PVOLUME_EXTENSION   extension = (PVOLUME_EXTENSION) Table->TableContext;

    VspFreeTempTableEntry(extension->Root, Buffer);
}

PFILTER_EXTENSION
VspFindFilter(
    IN  PDO_EXTENSION       RootExtension,
    IN  PFILTER_EXTENSION   Filter,
    IN  PUNICODE_STRING     VolumeName,
    IN  PFILE_OBJECT        FileObject
    )

{
    NTSTATUS            status;
    PDEVICE_OBJECT      deviceObject, d;
    PLIST_ENTRY         l;
    PFILTER_EXTENSION   filter;

    if (VolumeName) {
        status = IoGetDeviceObjectPointer(VolumeName, FILE_READ_ATTRIBUTES,
                                          &FileObject, &deviceObject);
        if (!NT_SUCCESS(status)) {
            if (Filter) {
                VspLogError(NULL, Filter, VS_FAILURE_ADDING_DIFF_AREA, status,
                            1);
            }
            return NULL;
        }
    }

    deviceObject = IoGetAttachedDeviceReference(FileObject->DeviceObject);

    for (l = RootExtension->FilterList.Flink;
         l != &RootExtension->FilterList; l = l->Flink) {

        filter = CONTAINING_RECORD(l, FILTER_EXTENSION, ListEntry);
        d = IoGetAttachedDeviceReference(filter->DeviceObject);
        ObDereferenceObject(d);

        if (d == deviceObject) {
            break;
        }
    }

    ObDereferenceObject(deviceObject);

    if (VolumeName) {
        ObDereferenceObject(FileObject);
    }

    if (l != &RootExtension->FilterList) {
        return filter;
    }

    if (Filter) {
        VspLogError(NULL, Filter, VS_FAILURE_ADDING_DIFF_AREA,
                    STATUS_NOT_FOUND, 2);
    }

    return NULL;
}

NTSTATUS
VspIsNtfs(
    IN  HANDLE      FileHandle,
    OUT PBOOLEAN    IsNtfs
    )

{
    ULONG                           size;
    PFILE_FS_ATTRIBUTE_INFORMATION  fsAttributeInfo;
    NTSTATUS                        status;
    IO_STATUS_BLOCK                 ioStatus;

    size = FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName) +
           4*sizeof(WCHAR);

    fsAttributeInfo = (PFILE_FS_ATTRIBUTE_INFORMATION)
                      ExAllocatePoolWithTag(PagedPool, size,
                                            VOLSNAP_TAG_SHORT_TERM);
    if (!fsAttributeInfo) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = ZwQueryVolumeInformationFile(FileHandle, &ioStatus,
                                          fsAttributeInfo, size,
                                          FileFsAttributeInformation);
    if (status == STATUS_BUFFER_OVERFLOW) {
        *IsNtfs = FALSE;
        ExFreePool(fsAttributeInfo);
        return STATUS_SUCCESS;
    }
    if (!NT_SUCCESS(status)) {
        ExFreePool(fsAttributeInfo);
        return status;
    }

    if (fsAttributeInfo->FileSystemNameLength == 8 &&
        fsAttributeInfo->FileSystemName[0] == 'N' &&
        fsAttributeInfo->FileSystemName[1] == 'T' &&
        fsAttributeInfo->FileSystemName[2] == 'F' &&
        fsAttributeInfo->FileSystemName[3] == 'S') {

        ExFreePool(fsAttributeInfo);
        *IsNtfs = TRUE;

        return STATUS_SUCCESS;
    }

    ExFreePool(fsAttributeInfo);
    *IsNtfs = FALSE;

    return STATUS_SUCCESS;
}

LONGLONG
VspQueryVolumeSize(
    IN  PFILTER_EXTENSION   Filter
    )

{
    PDEVICE_OBJECT              targetObject;
    KEVENT                      event;
    PIRP                        irp;
    GET_LENGTH_INFORMATION      lengthInfo;
    IO_STATUS_BLOCK             ioStatus;
    NTSTATUS                    status;

    targetObject = Filter->TargetObject;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_LENGTH_INFO,
                                        targetObject, NULL, 0, &lengthInfo,
                                        sizeof(lengthInfo), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        return 0;
    }

    status = IoCallDriver(targetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return 0;
    }

    return lengthInfo.Length.QuadPart;
}

NTSTATUS
VspQueryVolumeNumber(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLUME_NUMBER      output;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(VOLUME_NUMBER)) {

        return STATUS_INVALID_PARAMETER;
    }

    output = (PVOLUME_NUMBER) Irp->AssociatedIrp.SystemBuffer;
    output->VolumeNumber = Extension->VolumeNumber;
    RtlCopyMemory(output->VolumeManagerName, L"VOLSNAP ", 16);

    Irp->IoStatus.Information = sizeof(VOLUME_NUMBER);

    return STATUS_SUCCESS;
}

VOID
VspCancelRoutine(
    IN OUT  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine is called on when the given IRP is cancelled.  It
    will dequeue this IRP off the work queue and complete the
    request as CANCELLED.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IRP.

Return Value:

    None.

--*/

{
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;

    ASSERT(Irp == filter->FlushAndHoldIrp);

    filter->FlushAndHoldIrp = NULL;
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}

VOID
VspFsTimerDpc(
    IN  PKDPC   TimerDpc,
    IN  PVOID   Context,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
    )

{
    PDO_EXTENSION               rootExtension = (PDO_EXTENSION) Context;
    KIRQL                       irql;
    PIRP                        irp;
    PFILTER_EXTENSION           filter;

    IoAcquireCancelSpinLock(&irql);

    while (!IsListEmpty(&rootExtension->HoldIrps)) {
        irp = CONTAINING_RECORD(rootExtension->HoldIrps.Flink, IRP,
                                Tail.Overlay.ListEntry);
        irp->CancelIrql = irql;
        IoSetCancelRoutine(irp, NULL);
        filter = (PFILTER_EXTENSION) IoGetCurrentIrpStackLocation(irp)->
                                     DeviceObject->DeviceExtension;
        ObReferenceObject(filter->DeviceObject);
        VspCancelRoutine(filter->DeviceObject, irp);
        VspLogError(NULL, filter, VS_FLUSH_AND_HOLD_FS_TIMEOUT,
                    STATUS_CANCELLED, 0);
        ObDereferenceObject(filter->DeviceObject);
        IoAcquireCancelSpinLock(&irql);
    }

    rootExtension->HoldRefCount = 0;

    IoReleaseCancelSpinLock(irql);
}

VOID
VspZeroRefCallback(
    IN  PFILTER_EXTENSION   Filter
    )

{
    PIRP            irp = (PIRP) Filter->ZeroRefContext;
    LARGE_INTEGER   timeout;

    timeout.QuadPart = -10*1000*1000*((LONGLONG) Filter->HoldWritesTimeout);
    KeSetTimer(&Filter->HoldWritesTimer, timeout, &Filter->HoldWritesTimerDpc);
    InterlockedExchange(&Filter->TimerIsSet, TRUE);

    irp->IoStatus.Status = STATUS_SUCCESS;
    irp->IoStatus.Information = 0;
    IoCompleteRequest(irp, IO_SOUND_INCREMENT);
}

VOID
VspFlushAndHoldWriteIrps(
    IN  PIRP    Irp,
    IN  ULONG   HoldWritesTimeout
    )

/*++

Routine Description:

    This routine waits for outstanding write requests to complete while
    holding incoming write requests.  This IRP will complete when all
    outstanding IRPs have completed.  A timer will be set for the given
    timeout value and held writes irps will be released after that point or
    when IOCTL_VOLSNAP_RELEASE_WRITES comes in, whichever is sooner.

Arguments:

    Irp                 - Supplies the I/O request packet.

    HoldWritesTimeout   - Supplies the maximum length of time in seconds that a
                          write IRP will be held up.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) irpSp->DeviceObject->DeviceExtension;
    KIRQL               irql;
    NTSTATUS            status;

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    if (filter->HoldIncomingWrites) {
        KeReleaseSpinLock(&filter->SpinLock, irql);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return;
    }

    filter->HoldWritesTimeout = HoldWritesTimeout;
    InterlockedExchange(&filter->HoldIncomingWrites, TRUE);
    filter->ZeroRefCallback = VspZeroRefCallback;
    filter->ZeroRefContext = Irp;
    KeReleaseSpinLock(&filter->SpinLock, irql);

    VspDecrementRefCount(filter);

    IoStartTimer(filter->DeviceObject);

    status = VspCheckForMemoryPressure(filter);
    if (!NT_SUCCESS(status)) {
        VspReleaseWrites(filter);
    }
}

NTSTATUS
VspFlushAndHoldWrites(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine is called for multiple volumes at once.  On the first
    call the GUID is checked and if it is different than the current one
    then the current set is aborted.  If the GUID is new then subsequent
    calls are compared to the GUID passed in here until the required
    number of calls is completed.  A timer is used to wait until all
    of the IRPs have reached this driver and then another time out is used
    after all of these calls complete to wait for IOCTL_VOLSNAP_RELEASE_WRITES
    to be sent to all of the volumes involved.

Arguments:

    Filter  - Supplies the filter device extension.

    Irp     - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PDO_EXTENSION                   rootExtension = Filter->Root;
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLSNAP_FLUSH_AND_HOLD_INPUT   input;
    KIRQL                           irql;
    LARGE_INTEGER                   timeout;
    LIST_ENTRY                      q;
    PLIST_ENTRY                     l;
    PIRP                            irp;
    PFILTER_EXTENSION               filter;
    ULONG                           irpTimeout;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLSNAP_FLUSH_AND_HOLD_INPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PVOLSNAP_FLUSH_AND_HOLD_INPUT) Irp->AssociatedIrp.SystemBuffer;

    if (!input->NumberOfVolumesToFlush ||
        !input->SecondsToHoldFileSystemsTimeout ||
        !input->SecondsToHoldIrpsTimeout) {

        return STATUS_INVALID_PARAMETER;
    }

    IoAcquireCancelSpinLock(&irql);

    if (Filter->FlushAndHoldIrp) {
        IoReleaseCancelSpinLock(irql);
        VspLogError(NULL, Filter, VS_TWO_FLUSH_AND_HOLDS,
                    STATUS_INVALID_PARAMETER, 1);
        return STATUS_INVALID_PARAMETER;
    }

    if (rootExtension->HoldRefCount) {

        if (!IsEqualGUID(rootExtension->HoldInstanceGuid, input->InstanceId)) {
            IoReleaseCancelSpinLock(irql);
            VspLogError(NULL, Filter, VS_TWO_FLUSH_AND_HOLDS,
                        STATUS_INVALID_PARAMETER, 2);
            return STATUS_INVALID_PARAMETER;
        }

    } else {

        if (IsEqualGUID(rootExtension->HoldInstanceGuid, input->InstanceId)) {
            IoReleaseCancelSpinLock(irql);
            VspLogError(NULL, Filter, VS_TWO_FLUSH_AND_HOLDS,
                        STATUS_INVALID_PARAMETER, 3);
            return STATUS_INVALID_PARAMETER;
        }

        rootExtension->HoldRefCount = input->NumberOfVolumesToFlush + 1;
        rootExtension->HoldInstanceGuid = input->InstanceId;
        rootExtension->SecondsToHoldFsTimeout =
                input->SecondsToHoldFileSystemsTimeout;
        rootExtension->SecondsToHoldIrpTimeout =
                input->SecondsToHoldIrpsTimeout;

        timeout.QuadPart = -10*1000*1000*
                           ((LONGLONG) rootExtension->SecondsToHoldFsTimeout);

        KeSetTimer(&rootExtension->HoldTimer, timeout,
                   &rootExtension->HoldTimerDpc);
    }

    Filter->FlushAndHoldIrp = Irp;
    InsertTailList(&rootExtension->HoldIrps, &Irp->Tail.Overlay.ListEntry);
    IoSetCancelRoutine(Irp, VspCancelRoutine);
    IoMarkIrpPending(Irp);

    rootExtension->HoldRefCount--;

    if (rootExtension->HoldRefCount != 1) {
        IoReleaseCancelSpinLock(irql);
        return STATUS_PENDING;
    }

    InitializeListHead(&q);
    while (!IsListEmpty(&rootExtension->HoldIrps)) {
        l = RemoveHeadList(&rootExtension->HoldIrps);
        irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);
        filter = (PFILTER_EXTENSION)
                 IoGetCurrentIrpStackLocation(irp)->DeviceObject->
                 DeviceExtension;
        InsertTailList(&q, l);
        filter->FlushAndHoldIrp = NULL;
        IoSetCancelRoutine(irp, NULL);
    }

    irpTimeout = rootExtension->SecondsToHoldIrpTimeout;

    if (KeCancelTimer(&rootExtension->HoldTimer)) {
        IoReleaseCancelSpinLock(irql);

        VspFsTimerDpc(&rootExtension->HoldTimerDpc,
                      rootExtension->HoldTimerDpc.DeferredContext,
                      rootExtension->HoldTimerDpc.SystemArgument1,
                      rootExtension->HoldTimerDpc.SystemArgument2);

    } else {
        IoReleaseCancelSpinLock(irql);
    }

    while (!IsListEmpty(&q)) {
        l = RemoveHeadList(&q);
        irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);
        VspFlushAndHoldWriteIrps(irp, irpTimeout);
    }

    return STATUS_PENDING;
}

NTSTATUS
VspCreateDiffAreaFileName(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  ULONG               VolumeSnapshotNumber,
    OUT PUNICODE_STRING     DiffAreaFileName
    )

/*++

Routine Description:

    This routine builds the diff area file name for the given diff area
    volume and the given volume snapshot number.  The name formed will
    look like <Diff Area Volume Name>\<Volume Snapshot Number><GUID>.

Arguments:

    Filter                  - Supplies the filter extension.

    VolumeSnapshotNumber    - Supplies the volume snapshot number.

    DiffAreaFileName        - Returns the name of the diff area file.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_OBJECT              targetObject = DeviceObject;
    KEVENT                      event;
    PMOUNTDEV_NAME              name;
    UCHAR                       buffer[512];
    PIRP                        irp;
    IO_STATUS_BLOCK             ioStatus;
    NTSTATUS                    status;
    UNICODE_STRING              sysvol, guidString, numberString, string;
    WCHAR                       numberBuffer[20];

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    name = (PMOUNTDEV_NAME) buffer;
    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTDEV_QUERY_DEVICE_NAME,
                                        targetObject, NULL, 0, name,
                                        512, FALSE, &event, &ioStatus);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(targetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    RtlInitUnicodeString(&sysvol, RTL_SYSTEM_VOLUME_INFORMATION_FOLDER);

    if (VolumeSnapshotNumber == (ULONG) -1) {
        swprintf(numberBuffer, L"\\*");
    } else {
        swprintf(numberBuffer, L"\\%d", VolumeSnapshotNumber);
    }
    RtlInitUnicodeString(&numberString, numberBuffer);

    status = RtlStringFromGUID(VSP_DIFF_AREA_FILE_GUID, &guidString);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    string.MaximumLength = name->NameLength + sizeof(WCHAR) + sysvol.Length +
                           numberString.Length + guidString.Length +
                           sizeof(WCHAR);
    string.Length = 0;
    string.Buffer = (PWCHAR)
                    ExAllocatePoolWithTag(PagedPool, string.MaximumLength,
                                          VOLSNAP_TAG_SHORT_TERM);
    if (!string.Buffer) {
        ExFreePool(guidString.Buffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    string.Length = name->NameLength;
    RtlCopyMemory(string.Buffer, name->Name, string.Length);
    string.Buffer[string.Length/sizeof(WCHAR)] = '\\';
    string.Length += sizeof(WCHAR);

    if (VolumeSnapshotNumber != (ULONG) -1) {
        RtlCreateSystemVolumeInformationFolder(&string);
    }

    RtlAppendUnicodeStringToString(&string, &sysvol);
    RtlAppendUnicodeStringToString(&string, &numberString);
    RtlAppendUnicodeStringToString(&string, &guidString);
    ExFreePool(guidString.Buffer);

    string.Buffer[string.Length/sizeof(WCHAR)] = 0;

    *DiffAreaFileName = string;

    return STATUS_SUCCESS;
}

NTSTATUS
VspCreateSecurityDescriptor(
    OUT PSECURITY_DESCRIPTOR*   SecurityDescriptor,
    OUT PACL*                   Acl
    )

{
    PSECURITY_DESCRIPTOR    sd;
    NTSTATUS                status;
    ULONG                   aclLength;
    PACL                    acl;

    sd = (PSECURITY_DESCRIPTOR)
         ExAllocatePoolWithTag(PagedPool, sizeof(SECURITY_DESCRIPTOR),
                               VOLSNAP_TAG_SHORT_TERM);
    if (!sd) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = RtlCreateSecurityDescriptor(sd, SECURITY_DESCRIPTOR_REVISION);
    if (!NT_SUCCESS(status)) {
        ExFreePool(sd);
        return status;
    }

    aclLength = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) +
                RtlLengthSid(SeExports->SeWorldSid) - sizeof(ULONG);

    acl = (PACL) ExAllocatePoolWithTag(PagedPool, aclLength,
                                       VOLSNAP_TAG_SHORT_TERM);
    if (!acl) {
        ExFreePool(sd);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = RtlCreateAcl(acl, aclLength, ACL_REVISION);
    if (!NT_SUCCESS(status)) {
        ExFreePool(acl);
        ExFreePool(sd);
        return status;
    }

    status = RtlAddAccessAllowedAce(acl, ACL_REVISION, DELETE,
                                    SeExports->SeWorldSid);
    if (!NT_SUCCESS(status)) {
        ExFreePool(acl);
        ExFreePool(sd);
        return status;
    }

    status = RtlSetDaclSecurityDescriptor(sd, TRUE, acl, FALSE);
    if (!NT_SUCCESS(status)) {
        ExFreePool(acl);
        ExFreePool(sd);
        return status;
    }

    *SecurityDescriptor = sd;
    *Acl = acl;

    return STATUS_SUCCESS;
}

NTSTATUS
VspPinFile(
    IN  PVSP_DIFF_AREA_FILE DiffAreaFile
    )

/*++

Routine Description:

    This routine pins down the extents of the given diff area file so that
    defrag operations are disabled.

Arguments:

    DiffAreaFile    - Supplies the diff area file.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS            status;
    UNICODE_STRING      volumeName;
    OBJECT_ATTRIBUTES   oa;
    HANDLE              h;
    IO_STATUS_BLOCK     ioStatus;
    MARK_HANDLE_INFO    markHandleInfo;

    status = VspCreateDiffAreaFileName(DiffAreaFile->Filter->TargetObject,
                                       (ULONG) -1, &volumeName);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    volumeName.Length -= 66*sizeof(WCHAR);
    volumeName.Buffer[volumeName.Length/sizeof(WCHAR)] = 0;

    InitializeObjectAttributes(&oa, &volumeName, OBJ_CASE_INSENSITIVE, NULL,
                               NULL);

    status = ZwOpenFile(&h, FILE_GENERIC_READ, &oa, &ioStatus,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_NONALERT);

    ExFreePool(volumeName.Buffer);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    RtlZeroMemory(&markHandleInfo, sizeof(MARK_HANDLE_INFO));
    markHandleInfo.VolumeHandle = h;
    markHandleInfo.HandleInfo = MARK_HANDLE_PROTECT_CLUSTERS;

    status = ZwFsControlFile(DiffAreaFile->FileHandle, NULL, NULL, NULL,
                             &ioStatus, FSCTL_MARK_HANDLE, &markHandleInfo,
                             sizeof(markHandleInfo), NULL, 0);

    ZwClose(h);

    return status;
}

NTSTATUS
VspOptimizeDiffAreaFileLocation(
    IN  PFILTER_EXTENSION   Filter,
    IN  HANDLE              FileHandle,
    IN  PVOLUME_EXTENSION   BitmapExtension,
    IN  LONGLONG            StartingOffset,
    IN  LONGLONG            FileSize
    )

/*++

Routine Description:

    This routine optimizes the location of the diff area file so that more
    of it can be used.

Arguments:

    Filter          - Supplies the filter extension where the diff area resides.

    FileHandle      - Provides a handle to the diff area.

    BitmapExtension - Supplies the extension of the active snapshot on the
                        given filter, if any.

    StartingOffset  - Supplies the starting point of where to optimize
                        the file.

    FileSize        - Supplies the allocated size of the file.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                    status;
    IO_STATUS_BLOCK             ioStatus;
    FILE_FS_SIZE_INFORMATION    fsSize;
    ULONG                       bitmapSize;
    PVOID                       bitmapBuffer;
    RTL_BITMAP                  bitmap;
    PMOUNTDEV_NAME              mountdevName;
    UCHAR                       buffer[200];
    KEVENT                      event;
    PIRP                        irp;
    UNICODE_STRING              fileName;
    OBJECT_ATTRIBUTES           oa;
    HANDLE                      h;
    KIRQL                       irql;
    ULONG                       numBitsToFind, bitIndex, bpc, bitsFound;
    MOVE_FILE_DATA              moveFileData;

    // Align the given file and if 'BitmapExtension' is available, try to
    // confine the file to the bits already set in the bitmap in
    // 'BitmapExtension'.

    status = ZwQueryVolumeInformationFile(FileHandle, &ioStatus, &fsSize,
                                          sizeof(fsSize),
                                          FileFsSizeInformation);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    bitmapSize = (ULONG) (fsSize.TotalAllocationUnits.QuadPart*
                          fsSize.SectorsPerAllocationUnit*
                          fsSize.BytesPerSector/BLOCK_SIZE);
    bitmapBuffer = ExAllocatePoolWithTag(NonPagedPool,
                   (bitmapSize + 8*sizeof(ULONG) - 1)/
                   (8*sizeof(ULONG))*sizeof(ULONG), VOLSNAP_TAG_BITMAP);
    if (!bitmapBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlInitializeBitMap(&bitmap, (PULONG) bitmapBuffer, bitmapSize);
    RtlClearAllBits(&bitmap);

    mountdevName = (PMOUNTDEV_NAME) buffer;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTDEV_QUERY_DEVICE_NAME,
                                        Filter->TargetObject, NULL, 0,
                                        mountdevName, 200, FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        ExFreePool(bitmapBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(Filter->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        ExFreePool(bitmapBuffer);
        return status;
    }

    mountdevName->Name[mountdevName->NameLength/sizeof(WCHAR)] = 0;
    RtlInitUnicodeString(&fileName, mountdevName->Name);

    InitializeObjectAttributes(&oa, &fileName, OBJ_CASE_INSENSITIVE, NULL,
                               NULL);

    status = ZwOpenFile(&h, FILE_GENERIC_READ, &oa, &ioStatus,
                        FILE_SHARE_READ | FILE_SHARE_WRITE |
                        FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_NONALERT);
    if (!NT_SUCCESS(status)) {
        ExFreePool(bitmapBuffer);
        return status;
    }

    status = VspMarkFreeSpaceInBitmap(NULL, h, &bitmap);
    if (!NT_SUCCESS(status)) {
        ZwClose(h);
        ExFreePool(bitmapBuffer);
        return status;
    }

    if (BitmapExtension) {
        VspAcquire(BitmapExtension->Root);
        if (!BitmapExtension->IsDead) {
            KeAcquireSpinLock(&BitmapExtension->SpinLock, &irql);
            if (BitmapExtension->VolumeBlockBitmap) {

                if (BitmapExtension->VolumeBlockBitmap->SizeOfBitMap <
                    bitmap.SizeOfBitMap) {

                    bitmap.SizeOfBitMap =
                            BitmapExtension->VolumeBlockBitmap->SizeOfBitMap;
                }

                VspAndBitmaps(&bitmap, BitmapExtension->VolumeBlockBitmap);

                if (bitmap.SizeOfBitMap < bitmapSize) {
                    bitmap.SizeOfBitMap = bitmapSize;
                    RtlClearBits(&bitmap,
                            BitmapExtension->VolumeBlockBitmap->SizeOfBitMap,
                            bitmapSize -
                            BitmapExtension->VolumeBlockBitmap->SizeOfBitMap);
                }
            }
            KeReleaseSpinLock(&BitmapExtension->SpinLock, irql);
        }
        VspRelease(BitmapExtension->Root);
    }

    numBitsToFind = (ULONG) ((FileSize - StartingOffset)/BLOCK_SIZE);
    bpc = fsSize.SectorsPerAllocationUnit*fsSize.BytesPerSector;

    while (numBitsToFind) {

        bitsFound = numBitsToFind;
        if (bitsFound > 64) {
            bitsFound = 64;
        }
        bitIndex = RtlFindSetBits(&bitmap, bitsFound, 0);
        if (bitIndex == (ULONG) -1) {
            ZwClose(h);
            ExFreePool(bitmapBuffer);
            return STATUS_UNSUCCESSFUL;
        }

        moveFileData.FileHandle = FileHandle;
        moveFileData.StartingVcn.QuadPart = StartingOffset/bpc;
        moveFileData.StartingLcn.QuadPart =
                (((LONGLONG) bitIndex)<<BLOCK_SHIFT)/bpc;
        moveFileData.ClusterCount = (ULONG) ((((LONGLONG) bitsFound)<<
                                              BLOCK_SHIFT)/bpc);

        status = ZwFsControlFile(h, NULL, NULL, NULL, &ioStatus,
                                 FSCTL_MOVE_FILE, &moveFileData,
                                 sizeof(moveFileData), NULL, 0);

        RtlClearBits(&bitmap, bitIndex, bitsFound);

        if (!NT_SUCCESS(status)) {
            continue;
        }

        numBitsToFind -= bitsFound;
        StartingOffset += ((LONGLONG) bitsFound)<<BLOCK_SHIFT;
    }

    ZwClose(h);
    ExFreePool(bitmapBuffer);

    return STATUS_SUCCESS;
}

NTSTATUS
VspOpenDiffAreaFile(
    IN OUT  PVSP_DIFF_AREA_FILE DiffAreaFile
    )

{
    LARGE_INTEGER                       diffAreaFileSize;
    NTSTATUS                            status;
    UNICODE_STRING                      diffAreaFileName;
    PSECURITY_DESCRIPTOR                securityDescriptor;
    PACL                                acl;
    OBJECT_ATTRIBUTES                   oa;
    IO_STATUS_BLOCK                     ioStatus;
    BOOLEAN                             isNtfs;
    PVOLUME_EXTENSION                   bitmapExtension;

    diffAreaFileSize.QuadPart = DiffAreaFile->AllocatedFileSize;

    status = VspCreateDiffAreaFileName(DiffAreaFile->Filter->TargetObject,
                                       DiffAreaFile->Extension->VolumeNumber,
                                       &diffAreaFileName);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = VspCreateSecurityDescriptor(&securityDescriptor, &acl);
    if (!NT_SUCCESS(status)) {
        ExFreePool(diffAreaFileName.Buffer);
        return status;
    }

    InitializeObjectAttributes(&oa, &diffAreaFileName,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL, securityDescriptor);

    status = ZwCreateFile(&DiffAreaFile->FileHandle, FILE_GENERIC_READ |
                          FILE_GENERIC_WRITE, &oa, &ioStatus,
                          &diffAreaFileSize, FILE_ATTRIBUTE_HIDDEN |
                          FILE_ATTRIBUTE_SYSTEM, 0, FILE_OVERWRITE_IF,
                          FILE_SYNCHRONOUS_IO_NONALERT |
                          FILE_NON_DIRECTORY_FILE | FILE_DELETE_ON_CLOSE |
                          FILE_NO_COMPRESSION, NULL, 0);

    ExFreePool(acl);
    ExFreePool(securityDescriptor);
    ExFreePool(diffAreaFileName.Buffer);

    if (!NT_SUCCESS(status)) {
        if (status == STATUS_DISK_FULL) {
            VspLogError(DiffAreaFile->Extension, DiffAreaFile->Filter,
                        VS_DIFF_AREA_CREATE_FAILED_LOW_DISK_SPACE, status, 0);
        } else {
            VspLogError(DiffAreaFile->Extension, DiffAreaFile->Filter,
                        VS_DIFF_AREA_CREATE_FAILED, status, 0);
        }
        return status;
    }

    status = VspIsNtfs(DiffAreaFile->FileHandle, &isNtfs);
    if (!NT_SUCCESS(status) || !isNtfs) {
        VspLogError(DiffAreaFile->Extension, DiffAreaFile->Filter,
                    VS_NOT_NTFS, status, 0);
        ZwClose(DiffAreaFile->FileHandle);
        return STATUS_INVALID_PARAMETER;
    }

    VspAcquire(DiffAreaFile->Filter->Root);
    if (IsListEmpty(&DiffAreaFile->Filter->VolumeList)) {
        bitmapExtension = NULL;
    } else {
        bitmapExtension = CONTAINING_RECORD(
                          DiffAreaFile->Filter->VolumeList.Blink,
                          VOLUME_EXTENSION, ListEntry);
        if (bitmapExtension->IsDead) {
            bitmapExtension = NULL;
        } else {
            ObReferenceObject(bitmapExtension->DeviceObject);
        }
    }
    VspRelease(DiffAreaFile->Filter->Root);

    VspOptimizeDiffAreaFileLocation(DiffAreaFile->Filter,
                                    DiffAreaFile->FileHandle,
                                    bitmapExtension, 0,
                                    DiffAreaFile->AllocatedFileSize);

    if (bitmapExtension) {
        ObDereferenceObject(bitmapExtension->DeviceObject);
    }

    status = VspPinFile(DiffAreaFile);
    if (!NT_SUCCESS(status)) {
        VspLogError(DiffAreaFile->Extension, DiffAreaFile->Filter,
                    VS_PIN_DIFF_AREA_FAILED, status, 0);
        ZwClose(DiffAreaFile->FileHandle);
        return status;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VspCreateInitialDiffAreaFiles(
    IN  PVOLUME_EXTENSION   Extension,
    IN  LONGLONG            InitialDiffAreaAllocation
    )

/*++

Routine Description:

    This routine creates the initial diff area file entries for the
    given device extension.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    NTSTATUS

--*/

{
    PFILTER_EXTENSION                   filter = Extension->Filter;
    NTSTATUS                            status;
    PLIST_ENTRY                         l;
    PVSP_DIFF_AREA_VOLUME               diffAreaVolume;
    PVSP_DIFF_AREA_FILE                 diffAreaFile;
    KIRQL                               irql;

    VspAcquire(Extension->Root);

    if (IsListEmpty(&filter->DiffAreaVolumes)) {
        VspRelease(Extension->Root);
        return STATUS_INVALID_PARAMETER;
    }

    status = STATUS_SUCCESS;
    InitializeListHead(&Extension->ListOfDiffAreaFiles);
    for (l = filter->DiffAreaVolumes.Flink; l != &filter->DiffAreaVolumes;
         l = l->Flink) {

        diffAreaVolume = CONTAINING_RECORD(l, VSP_DIFF_AREA_VOLUME, ListEntry);

        diffAreaFile = (PVSP_DIFF_AREA_FILE)
                       ExAllocatePoolWithTag(NonPagedPool,
                       sizeof(VSP_DIFF_AREA_FILE), VOLSNAP_TAG_DIFF_FILE);
        if (!diffAreaFile) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        diffAreaFile->Extension = Extension;
        diffAreaFile->Filter = diffAreaVolume->Filter;
        diffAreaFile->FileHandle = NULL;
        diffAreaFile->NextAvailable = 0;
        diffAreaFile->AllocatedFileSize = InitialDiffAreaAllocation;
        InsertTailList(&Extension->ListOfDiffAreaFiles,
                       &diffAreaFile->VolumeListEntry);

        diffAreaFile->FilterListEntryBeingUsed = FALSE;

        KeAcquireSpinLock(&filter->SpinLock, &irql);
        filter->AllocatedVolumeSpace += diffAreaFile->AllocatedFileSize;
        KeReleaseSpinLock(&filter->SpinLock, irql);

        InitializeListHead(&diffAreaFile->UnusedAllocationList);
    }

    VspRelease(Extension->Root);

    for (l = Extension->ListOfDiffAreaFiles.Flink;
         l != &Extension->ListOfDiffAreaFiles; l = l->Flink) {

        diffAreaFile = CONTAINING_RECORD(l, VSP_DIFF_AREA_FILE,
                                         VolumeListEntry);

        status = VspOpenDiffAreaFile(diffAreaFile);
        if (!NT_SUCCESS(status)) {
            break;
        }
    }

    if (!NT_SUCCESS(status)) {

        while (!IsListEmpty(&Extension->ListOfDiffAreaFiles)) {
            l = RemoveHeadList(&Extension->ListOfDiffAreaFiles);
            diffAreaFile = CONTAINING_RECORD(l, VSP_DIFF_AREA_FILE,
                                             VolumeListEntry);

            if (diffAreaFile->FileHandle) {
                ZwClose(diffAreaFile->FileHandle);
            }

            KeAcquireSpinLock(&filter->SpinLock, &irql);
            filter->AllocatedVolumeSpace -= diffAreaFile->AllocatedFileSize;
            KeReleaseSpinLock(&filter->SpinLock, irql);

            ASSERT(!diffAreaFile->FilterListEntryBeingUsed);
            ExFreePool(diffAreaFile);
        }

        return status;
    }

    Extension->NextDiffAreaFile =
            CONTAINING_RECORD(Extension->ListOfDiffAreaFiles.Flink,
                              VSP_DIFF_AREA_FILE, VolumeListEntry);

    return status;
}

VOID
VspDeleteInitialDiffAreaFiles(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    PFILTER_EXTENSION           filter = Extension->Filter;
    PLIST_ENTRY                 l, ll;
    PVSP_DIFF_AREA_FILE         diffAreaFile;
    KIRQL                       irql;
    PDIFF_AREA_FILE_ALLOCATION  diffAreaFileAllocation;

    while (!IsListEmpty(&Extension->ListOfDiffAreaFiles)) {
        l = RemoveHeadList(&Extension->ListOfDiffAreaFiles);
        diffAreaFile = CONTAINING_RECORD(l, VSP_DIFF_AREA_FILE,
                                         VolumeListEntry);

        ZwClose(diffAreaFile->FileHandle);

        KeAcquireSpinLock(&filter->SpinLock, &irql);
        filter->AllocatedVolumeSpace -= diffAreaFile->AllocatedFileSize;
        KeReleaseSpinLock(&filter->SpinLock, irql);

        while (!IsListEmpty(&diffAreaFile->UnusedAllocationList)) {
            ll = RemoveHeadList(&diffAreaFile->UnusedAllocationList);
            diffAreaFileAllocation = CONTAINING_RECORD(ll,
                                     DIFF_AREA_FILE_ALLOCATION, ListEntry);
            ExFreePool(diffAreaFileAllocation);
        }

        if (diffAreaFile->FilterListEntryBeingUsed) {
            RemoveEntryList(&diffAreaFile->FilterListEntry);
            diffAreaFile->FilterListEntryBeingUsed = FALSE;
        }

        ExFreePool(diffAreaFile);
    }

    Extension->NextDiffAreaFile = NULL;
}

NTSTATUS
VspMarkFileAllocationInBitmap(
    IN  PVOLUME_EXTENSION   Extension,
    IN  HANDLE              FileHandle,
    IN  PVSP_DIFF_AREA_FILE DiffAreaFile,
    IN  BOOLEAN             OnlyDiffAreaFile,
    IN  BOOLEAN             ClearBits,
    IN  PRTL_BITMAP         BitmapToSet
    )

{
    NTSTATUS                    status;
    BOOLEAN                     isNtfs;
    IO_STATUS_BLOCK             ioStatus;
    FILE_FS_SIZE_INFORMATION    fsSize;
    ULONG                       bpc;
    STARTING_VCN_INPUT_BUFFER   input;
    RETRIEVAL_POINTERS_BUFFER   output;
    LONGLONG                    start, length, end, roundedStart, roundedEnd;
    ULONG                       startBit, numBits, i;
    KIRQL                       irql;
    PDIFF_AREA_FILE_ALLOCATION  diffAreaFileAllocation;

    status = VspIsNtfs(FileHandle, &isNtfs);
    if (!NT_SUCCESS(status) || !isNtfs) {
        return status;
    }

    status = ZwQueryVolumeInformationFile(FileHandle, &ioStatus,
                                          &fsSize, sizeof(fsSize),
                                          FileFsSizeInformation);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    bpc = fsSize.BytesPerSector*fsSize.SectorsPerAllocationUnit;
    input.StartingVcn.QuadPart = 0;

    for (;;) {

        status = ZwFsControlFile(FileHandle, NULL, NULL, NULL, &ioStatus,
                                 FSCTL_GET_RETRIEVAL_POINTERS, &input,
                                 sizeof(input), &output, sizeof(output));

        if (!NT_SUCCESS(status) && status != STATUS_BUFFER_OVERFLOW) {
            if (status == STATUS_END_OF_FILE) {
                status = STATUS_SUCCESS;
            }
            break;
        }

        start = output.Extents[0].Lcn.QuadPart*bpc;
        length = output.Extents[0].NextVcn.QuadPart -
                 output.StartingVcn.QuadPart;
        length *= bpc;
        end = start + length;

        if (DiffAreaFile) {
            diffAreaFileAllocation = (PDIFF_AREA_FILE_ALLOCATION)
                                     ExAllocatePoolWithTag(NonPagedPool,
                                     sizeof(DIFF_AREA_FILE_ALLOCATION),
                                     VOLSNAP_TAG_BIT_HISTORY);
            if (!diffAreaFileAllocation) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            diffAreaFileAllocation->Offset = start;
            diffAreaFileAllocation->Length = length;
            InsertTailList(&DiffAreaFile->UnusedAllocationList,
                           &diffAreaFileAllocation->ListEntry);
        }

        if (OnlyDiffAreaFile) {
            if (status != STATUS_BUFFER_OVERFLOW) {
                break;
            }
            input.StartingVcn.QuadPart = output.Extents[0].NextVcn.QuadPart;
            continue;
        }

        roundedStart = start&(~(BLOCK_SIZE - 1));
        roundedEnd = end&(~(BLOCK_SIZE - 1));

        if (start != roundedStart) {
            roundedStart += BLOCK_SIZE;
        }

        if (roundedStart >= roundedEnd) {
            if (status != STATUS_BUFFER_OVERFLOW) {
                break;
            }
            input.StartingVcn.QuadPart = output.Extents[0].NextVcn.QuadPart;
            continue;
        }

        startBit = (ULONG) (roundedStart>>BLOCK_SHIFT);
        numBits = (ULONG) ((roundedEnd - roundedStart)>>BLOCK_SHIFT);

        if (BitmapToSet) {
            ASSERT(!ClearBits);
            RtlSetBits(BitmapToSet, startBit, numBits);
        } else {
            KeAcquireSpinLock(&Extension->SpinLock, &irql);
            if (ClearBits) {
                RtlClearBits(Extension->VolumeBlockBitmap, startBit, numBits);
            } else if (Extension->IgnorableProduct) {
                for (i = 0; i < numBits; i++) {
                    if (RtlCheckBit(Extension->IgnorableProduct, i + startBit)) {
                        RtlSetBit(Extension->VolumeBlockBitmap, i + startBit);
                    }
                }
            } else {
                RtlSetBits(Extension->VolumeBlockBitmap, startBit, numBits);
            }
            KeReleaseSpinLock(&Extension->SpinLock, irql);
        }

        if (status != STATUS_BUFFER_OVERFLOW) {
            break;
        }

        input.StartingVcn.QuadPart = output.Extents[0].NextVcn.QuadPart;
    }

    return status;
}

NTSTATUS
VspSetDiffAreaBlocksInBitmap(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    NTSTATUS            status, status2;
    PLIST_ENTRY         l, ll;
    PVSP_DIFF_AREA_FILE diffAreaFile;

    for (l = Extension->ListOfDiffAreaFiles.Flink;
         l != &Extension->ListOfDiffAreaFiles; l = l->Flink) {

        diffAreaFile = CONTAINING_RECORD(l, VSP_DIFF_AREA_FILE,
                                         VolumeListEntry);

        ASSERT(!diffAreaFile->FilterListEntryBeingUsed);
        InsertTailList(&diffAreaFile->Filter->DiffAreaFilesOnThisFilter,
                       &diffAreaFile->FilterListEntry);
        diffAreaFile->FilterListEntryBeingUsed = TRUE;

        if (diffAreaFile->Filter == Extension->Filter) {
            status = VspMarkFileAllocationInBitmap(Extension,
                                                   diffAreaFile->FileHandle,
                                                   diffAreaFile, FALSE, FALSE,
                                                   NULL);
            if (!NT_SUCCESS(status)) {
                VspLogError(Extension, diffAreaFile->Filter,
                            VS_CANT_MAP_DIFF_AREA_FILE, status, 2);
            }
        } else {
            if (diffAreaFile->Filter->PreparedSnapshot) {
                status = VspMarkFileAllocationInBitmap(
                         diffAreaFile->Filter->PreparedSnapshot,
                         diffAreaFile->FileHandle, diffAreaFile, FALSE, FALSE,
                         NULL);
                if (!NT_SUCCESS(status)) {
                    VspLogError(Extension, diffAreaFile->Filter,
                                VS_CANT_MAP_DIFF_AREA_FILE, status, 3);
                }
            } else {
                status = VspMarkFileAllocationInBitmap(
                         Extension, diffAreaFile->FileHandle, diffAreaFile,
                         TRUE, FALSE, NULL);
                if (!NT_SUCCESS(status)) {
                    VspLogError(Extension, diffAreaFile->Filter,
                                VS_CANT_MAP_DIFF_AREA_FILE, status, 4);
                }
            }
        }

        if (!NT_SUCCESS(status)) {
            for (ll = Extension->ListOfDiffAreaFiles.Flink; l != ll;
                 ll = ll->Flink) {

                diffAreaFile = CONTAINING_RECORD(ll, VSP_DIFF_AREA_FILE,
                                                 VolumeListEntry);
                if (diffAreaFile->FilterListEntryBeingUsed) {
                    RemoveEntryList(&diffAreaFile->FilterListEntry);
                    diffAreaFile->FilterListEntryBeingUsed = FALSE;
                }

                if (diffAreaFile->Filter != Extension->Filter &&
                    diffAreaFile->Filter->PreparedSnapshot) {

                    status2 = VspMarkFileAllocationInBitmap(
                              diffAreaFile->Filter->PreparedSnapshot,
                              diffAreaFile->FileHandle, NULL, FALSE, TRUE,
                              NULL);
                    if (!NT_SUCCESS(status2)) {
                        VspLogError(Extension, diffAreaFile->Filter,
                                    VS_CANT_MAP_DIFF_AREA_FILE, status, 5);
                        VspAbortPreparedSnapshot(diffAreaFile->Filter, FALSE);
                    }
                }
            }

            return status;
        }
    }

    for (l = Extension->Filter->DiffAreaFilesOnThisFilter.Flink;
         l != &Extension->Filter->DiffAreaFilesOnThisFilter; l = l->Flink) {

        diffAreaFile = CONTAINING_RECORD(l, VSP_DIFF_AREA_FILE,
                                         FilterListEntry);
        if (diffAreaFile->Extension == Extension) {
            continue;
        }

        status = VspMarkFileAllocationInBitmap(
                 Extension, diffAreaFile->FileHandle, NULL, FALSE, FALSE,
                 NULL);
        if (!NT_SUCCESS(status)) {
            VspLogError(Extension, diffAreaFile->Filter,
                        VS_CANT_MAP_DIFF_AREA_FILE, status, 6);
            VspCleanupBitsSetInOtherPreparedSnapshots(Extension);
            return status;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VspCreateInitialHeap(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    PVSP_CONTEXT    context;
    NTSTATUS        status;

    context = VspAllocateContext(Extension->Root);
    if (!context) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    context->Type = VSP_CONTEXT_TYPE_EXTENSION;
    context->Extension.Extension = Extension;
    context->Extension.Irp = NULL;

    ObReferenceObject(Extension->DeviceObject);
    VspCreateHeap(context);

    if (!Extension->NextDiffAreaFileMap) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT(!Extension->DiffAreaFileMap);
    Extension->DiffAreaFileMap = Extension->NextDiffAreaFileMap;
    Extension->DiffAreaFileMapSize = Extension->NextDiffAreaFileMapSize;
    Extension->NextAvailable = 0;
    Extension->NextDiffAreaFileMap = NULL;

    context = VspAllocateContext(Extension->Root);
    if (!context) {
        status = ZwUnmapViewOfSection(Extension->DiffAreaFileMapProcess,
                                      Extension->DiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        Extension->DiffAreaFileMap = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    context->Type = VSP_CONTEXT_TYPE_EXTENSION;
    context->Extension.Extension = Extension;
    context->Extension.Irp = NULL;

    ObReferenceObject(Extension->DeviceObject);
    VspCreateHeap(context);

    if (!Extension->NextDiffAreaFileMap) {
        status = ZwUnmapViewOfSection(Extension->DiffAreaFileMapProcess,
                                      Extension->DiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        Extension->DiffAreaFileMap = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VspComputeIgnorableBitmap(
    IN      PVOLUME_EXTENSION   Extension,
    IN OUT  PRTL_BITMAP         Bitmap
    )

{
    PFILTER_EXTENSION           filter = Extension->Filter;
    WCHAR                       nameBuffer[150];
    UNICODE_STRING              name, guidString;
    OBJECT_ATTRIBUTES           oa;
    NTSTATUS                    status;
    HANDLE                      h, fileHandle;
    IO_STATUS_BLOCK             ioStatus;
    CHAR                        buffer[200];
    PFILE_NAMES_INFORMATION     fileNamesInfo;
    BOOLEAN                     restartScan;
    PLIST_ENTRY                 l;
    PVOLUME_EXTENSION           e;
    PTRANSLATION_TABLE_ENTRY    p;

    swprintf(nameBuffer, L"\\Device\\HarddiskVolumeShadowCopy%d\\pagefile.sys",
             Extension->VolumeNumber);
    RtlInitUnicodeString(&name, nameBuffer);
    InitializeObjectAttributes(&oa, &name, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = ZwOpenFile(&h, FILE_GENERIC_READ, &oa, &ioStatus,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_NONALERT);
    if (NT_SUCCESS(status)) {
        VspMarkFileAllocationInBitmap(NULL, h, NULL, FALSE, FALSE, Bitmap);
        ZwClose(h);
    }

    swprintf(nameBuffer, L"\\Device\\HarddiskVolumeShadowCopy%d\\System Volume Information\\",
             Extension->VolumeNumber);
    RtlInitUnicodeString(&name, nameBuffer);
    InitializeObjectAttributes(&oa, &name, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = ZwOpenFile(&h, FILE_LIST_DIRECTORY | SYNCHRONIZE, &oa, &ioStatus,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);
    if (!NT_SUCCESS(status)) {
        if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
            status = STATUS_SUCCESS;
        }
        return status;
    }

    status = RtlStringFromGUID(VSP_DIFF_AREA_FILE_GUID, &guidString);
    if (!NT_SUCCESS(status)) {
        ZwClose(h);
        return status;
    }

    name.Buffer = nameBuffer;
    name.Length = sizeof(WCHAR) + guidString.Length;
    name.MaximumLength = name.Length + sizeof(WCHAR);

    name.Buffer[0] = '*';
    RtlCopyMemory(&name.Buffer[1], guidString.Buffer, guidString.Length);
    name.Buffer[name.Length/sizeof(WCHAR)] = 0;
    ExFreePool(guidString.Buffer);

    fileNamesInfo = (PFILE_NAMES_INFORMATION) buffer;

    restartScan = TRUE;
    for (;;) {

        status = ZwQueryDirectoryFile(h, NULL, NULL, NULL, &ioStatus,
                                      fileNamesInfo, 200, FileNamesInformation,
                                      TRUE, restartScan ? &name : NULL,
                                      restartScan);

        if (!NT_SUCCESS(status)) {
            break;
        }

        name.Length = name.MaximumLength =
                (USHORT) fileNamesInfo->FileNameLength;
        name.Buffer = fileNamesInfo->FileName;

        InitializeObjectAttributes(&oa, &name, OBJ_CASE_INSENSITIVE, h, NULL);

        status = ZwOpenFile(&fileHandle, FILE_GENERIC_READ, &oa, &ioStatus,
                            FILE_SHARE_DELETE | FILE_SHARE_READ |
                            FILE_SHARE_WRITE, FILE_SYNCHRONOUS_IO_NONALERT);
        if (!NT_SUCCESS(status)) {
            continue;
        }

        VspMarkFileAllocationInBitmap(NULL, fileHandle, NULL, FALSE, FALSE,
                                      Bitmap);

        ZwClose(fileHandle);
        restartScan = FALSE;
    }

    ZwClose(h);

    status = VspMarkFreeSpaceInBitmap(Extension, NULL, Bitmap);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    VspAcquire(Extension->Root);
    if (Extension->IsDead) {
        VspRelease(Extension->Root);
        return STATUS_UNSUCCESSFUL;
    }

    for (l = &Extension->ListEntry; l != &filter->VolumeList; l = l->Flink) {

        e = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

        VspAcquirePagedResource(e, NULL);

        p = (PTRANSLATION_TABLE_ENTRY)
            RtlEnumerateGenericTable(&e->VolumeBlockTable, TRUE);

        while (p) {

            RtlSetBit(Bitmap, (ULONG) (p->VolumeOffset>>BLOCK_SHIFT));

            p = (PTRANSLATION_TABLE_ENTRY)
                RtlEnumerateGenericTable(&e->VolumeBlockTable, FALSE);
        }

        VspReleasePagedResource(e);
    }

    VspRelease(Extension->Root);

    return STATUS_SUCCESS;
}

VOID
VspAndBitmaps(
    IN OUT  PRTL_BITMAP BaseBitmap,
    IN      PRTL_BITMAP FactorBitmap
    )

{
    ULONG   n, i;
    PULONG  p, q;

    n = (BaseBitmap->SizeOfBitMap + 8*sizeof(ULONG) - 1)/(8*sizeof(ULONG));
    p = BaseBitmap->Buffer;
    q = FactorBitmap->Buffer;

    for (i = 0; i < n; i++) {
        *p++ &= *q++;
    }
}

NTSTATUS
VspComputeIgnorableProduct(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    PFILTER_EXTENSION   filter = Extension->Filter;
    ULONG               bitmapSize;
    PVOID               bitmapBuffer;
    RTL_BITMAP          bitmap;
    ULONG               i, j;
    PLIST_ENTRY         l;
    PVOLUME_EXTENSION   e;
    NTSTATUS            status;
    KIRQL               irql;

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    if (!Extension->IgnorableProduct) {
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        return STATUS_INVALID_PARAMETER;
    }
    bitmapSize = Extension->IgnorableProduct->SizeOfBitMap;
    RtlSetAllBits(Extension->IgnorableProduct);
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    bitmapBuffer = ExAllocatePoolWithTag(
                   NonPagedPool, (bitmapSize + 8*sizeof(ULONG) - 1)/
                   (8*sizeof(ULONG))*sizeof(ULONG), VOLSNAP_TAG_BITMAP);
    if (!bitmapBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlInitializeBitMap(&bitmap, (PULONG) bitmapBuffer, bitmapSize);

    for (i = 1; ; i++) {

        RtlClearAllBits(&bitmap);

        VspAcquire(Extension->Root);

        l = filter->VolumeList.Blink;
        if (l != &Extension->ListEntry) {
            VspRelease(Extension->Root);
            ExFreePool(bitmapBuffer);
            return STATUS_INVALID_PARAMETER;
        }

        j = 0;
        for (;;) {
            if (l == &filter->VolumeList) {
                break;
            }
            j++;
            if (j == i) {
                break;
            }
            l = l->Blink;
        }

        if (j < i) {
            VspRelease(Extension->Root);
            break;
        }

        e = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        ObReferenceObject(e->DeviceObject);

        VspRelease(Extension->Root);

        status = VspComputeIgnorableBitmap(e, &bitmap);

        if (!NT_SUCCESS(status)) {
            VspAcquire(Extension->Root);
            if (e->IsDead) {
                VspRelease(Extension->Root);
                ObDereferenceObject(e->DeviceObject);
                ExFreePool(bitmapBuffer);
                return STATUS_SUCCESS;
            }
            VspRelease(Extension->Root);
            ObDereferenceObject(e->DeviceObject);
            ExFreePool(bitmapBuffer);
            return status;
        }

        ObDereferenceObject(e->DeviceObject);

        KeAcquireSpinLock(&Extension->SpinLock, &irql);
        if (Extension->IgnorableProduct) {
            VspAndBitmaps(Extension->IgnorableProduct, &bitmap);
        }
        KeReleaseSpinLock(&Extension->SpinLock, irql);
    }

    ExFreePool(bitmapBuffer);

    return STATUS_SUCCESS;
}

VOID
VspQueryMinimumDiffAreaFileSize(
    IN  PDO_EXTENSION   RootExtension,
    OUT PLONGLONG       MinDiffAreaFileSize
    )

{
    ULONG                       zero, size;
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    NTSTATUS                    status;

    zero = 0;

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[0].Name = L"MinDiffAreaFileSize";
    queryTable[0].EntryContext = &size;
    queryTable[0].DefaultType = REG_DWORD;
    queryTable[0].DefaultData = &zero;
    queryTable[0].DefaultLength = sizeof(ULONG);

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                    RootExtension->RegistryPath.Buffer,
                                    queryTable, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        size = zero;
    }

    *MinDiffAreaFileSize = ((LONGLONG) size)*1024*1024;
}

VOID
VspPrepareForSnapshotWorker(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PVOID           Context
    )

{
    PVSP_CONTEXT            context = (PVSP_CONTEXT) Context;
    PFILTER_EXTENSION       Filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;
    PIRP                    Irp = context->Dispatch.Irp;
    PDO_EXTENSION           rootExtension = Filter->Root;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLSNAP_PREPARE_INFO   input = (PVOLSNAP_PREPARE_INFO) Irp->AssociatedIrp.SystemBuffer;
    LONGLONG                minDiffAreaFileSize;
    KIRQL                   irql;
    ULONG                   volumeNumber;
    WCHAR                   buffer[100];
    UNICODE_STRING          volumeName;
    NTSTATUS                status;
    PDEVICE_OBJECT          deviceObject;
    PVOLUME_EXTENSION       extension, e;
    ULONG                   bitmapSize, n;
    PVOID                   bitmapBuffer, p;
    PVOID                   buf;
    PMDL                    mdl;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_DISPATCH);

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLSNAP_PREPARE_INFO)) {

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        goto Finish;
    }

    if (input->Attributes&(~VOLSNAP_ALL_ATTRIBUTES)) {
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        goto Finish;
    }

    if (input->Attributes&VOLSNAP_ATTRIBUTE_PERSISTENT) {
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        goto Finish;
    }

    KeWaitForSingleObject(&Filter->EndCommitProcessCompleted, Executive,
                          KernelMode, FALSE, NULL);

    VspQueryMinimumDiffAreaFileSize(Filter->Root, &minDiffAreaFileSize);

    if (input->InitialDiffAreaAllocation < 2*NOMINAL_DIFF_AREA_FILE_GROWTH) {
        input->InitialDiffAreaAllocation = 2*NOMINAL_DIFF_AREA_FILE_GROWTH;
    }

    if (input->InitialDiffAreaAllocation < minDiffAreaFileSize) {
        input->InitialDiffAreaAllocation = minDiffAreaFileSize;
    }

    for (volumeNumber = 1;; volumeNumber++) {
        swprintf(buffer, L"\\Device\\HarddiskVolumeShadowCopy%d", volumeNumber);
        RtlInitUnicodeString(&volumeName, buffer);
        status = IoCreateDevice(rootExtension->DriverObject,
                                sizeof(VOLUME_EXTENSION), &volumeName,
                                FILE_DEVICE_DISK, 0, FALSE, &deviceObject);
        if (status != STATUS_OBJECT_NAME_COLLISION) {
            break;
        }
    }

    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        goto Finish;
    }

    extension = (PVOLUME_EXTENSION) deviceObject->DeviceExtension;
    RtlZeroMemory(extension, sizeof(VOLUME_EXTENSION));
    extension->DeviceObject = deviceObject;
    extension->Root = Filter->Root;
    extension->DeviceExtensionType = DEVICE_EXTENSION_VOLUME;
    KeInitializeSpinLock(&extension->SpinLock);
    extension->Filter = Filter;
    extension->RefCount = 1;
    InitializeListHead(&extension->HoldIrpQueue);
    InitializeListHead(&extension->HoldWorkerQueue);
    KeInitializeEvent(&extension->ZeroRefEvent, NotificationEvent, FALSE);

    extension->VolumeNumber = volumeNumber;

    RtlInitializeGenericTable(&extension->VolumeBlockTable,
                              VspTableCompareRoutine,
                              VspTableAllocateRoutine,
                              VspTableFreeRoutine, extension);

    RtlInitializeGenericTable(&extension->TempVolumeBlockTable,
                              VspTableCompareRoutine,
                              VspTempTableAllocateRoutine,
                              VspTempTableFreeRoutine, extension);

    extension->DiffAreaFileIncrease = NOMINAL_DIFF_AREA_FILE_GROWTH;

    status = VspCreateInitialDiffAreaFiles(extension,
                                           input->InitialDiffAreaAllocation);
    if (!NT_SUCCESS(status)) {
        IoDeleteDevice(deviceObject);
        Irp->IoStatus.Status = status;
        goto Finish;
    }

    status = VspCreateWorkerThread(rootExtension);
    if (!NT_SUCCESS(status)) {
        VspLogError(extension, NULL, VS_CREATE_WORKER_THREADS_FAILED, status,
                    0);
        VspDeleteInitialDiffAreaFiles(extension);
        IoDeleteDevice(deviceObject);
        Irp->IoStatus.Status = status;
        goto Finish;
    }

    extension->VolumeBlockBitmap = (PRTL_BITMAP)
                                   ExAllocatePoolWithTag(
                                   NonPagedPool, sizeof(RTL_BITMAP),
                                   VOLSNAP_TAG_BITMAP);
    if (!extension->VolumeBlockBitmap) {
        VspDeleteWorkerThread(rootExtension);
        VspDeleteInitialDiffAreaFiles(extension);
        IoDeleteDevice(deviceObject);
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }

    extension->VolumeSize = VspQueryVolumeSize(Filter);
    if (!extension->VolumeSize) {
        ExFreePool(extension->VolumeBlockBitmap);
        extension->VolumeBlockBitmap = NULL;
        VspDeleteWorkerThread(rootExtension);
        VspDeleteInitialDiffAreaFiles(extension);
        IoDeleteDevice(deviceObject);
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }

    bitmapSize = (ULONG) ((extension->VolumeSize + BLOCK_SIZE - 1)>>
                          BLOCK_SHIFT);
    bitmapBuffer = ExAllocatePoolWithTag(NonPagedPool,
                   (bitmapSize + 8*sizeof(ULONG) - 1)/
                   (8*sizeof(ULONG))*sizeof(ULONG), VOLSNAP_TAG_BITMAP);

    if (!bitmapBuffer) {
        VspLogError(extension, NULL, VS_CANT_ALLOCATE_BITMAP,
                    STATUS_INSUFFICIENT_RESOURCES, 0);
        ExFreePool(extension->VolumeBlockBitmap);
        extension->VolumeBlockBitmap = NULL;
        VspDeleteWorkerThread(rootExtension);
        VspDeleteInitialDiffAreaFiles(extension);
        IoDeleteDevice(deviceObject);
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }

    RtlInitializeBitMap(extension->VolumeBlockBitmap, (PULONG) bitmapBuffer,
                        bitmapSize);
    RtlClearAllBits(extension->VolumeBlockBitmap);

    status = VspCreateInitialHeap(extension);
    if (!NT_SUCCESS(status)) {
        ExFreePool(bitmapBuffer);
        ExFreePool(extension->VolumeBlockBitmap);
        extension->VolumeBlockBitmap = NULL;
        VspDeleteWorkerThread(rootExtension);
        VspDeleteInitialDiffAreaFiles(extension);
        IoDeleteDevice(deviceObject);
        Irp->IoStatus.Status = status;
        goto Finish;
    }

    InitializeListHead(&extension->OldHeaps);

    extension->EmergencyCopyIrp =
            IoAllocateIrp((CCHAR) extension->Root->StackSize, FALSE);
    if (!extension->EmergencyCopyIrp) {
        status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                      extension->DiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                      extension->NextDiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        ExFreePool(bitmapBuffer);
        ExFreePool(extension->VolumeBlockBitmap);
        extension->VolumeBlockBitmap = NULL;
        VspDeleteWorkerThread(rootExtension);
        VspDeleteInitialDiffAreaFiles(extension);
        IoDeleteDevice(deviceObject);
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }

    buf = ExAllocatePoolWithTag(NonPagedPool, BLOCK_SIZE, VOLSNAP_TAG_BUFFER);
    if (!buf) {
        IoFreeIrp(extension->EmergencyCopyIrp);
        status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                      extension->DiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                      extension->NextDiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        ExFreePool(bitmapBuffer);
        ExFreePool(extension->VolumeBlockBitmap);
        extension->VolumeBlockBitmap = NULL;
        VspDeleteWorkerThread(rootExtension);
        VspDeleteInitialDiffAreaFiles(extension);
        IoDeleteDevice(deviceObject);
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }

    mdl = IoAllocateMdl(buf, BLOCK_SIZE, FALSE, FALSE, NULL);
    if (!mdl) {
        ExFreePool(buf);
        IoFreeIrp(extension->EmergencyCopyIrp);
        status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                      extension->DiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                      extension->NextDiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        ExFreePool(bitmapBuffer);
        ExFreePool(extension->VolumeBlockBitmap);
        extension->VolumeBlockBitmap = NULL;
        VspDeleteWorkerThread(rootExtension);
        VspDeleteInitialDiffAreaFiles(extension);
        IoDeleteDevice(deviceObject);
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }

    MmBuildMdlForNonPagedPool(mdl);
    extension->EmergencyCopyIrp->MdlAddress = mdl;

    InitializeListHead(&extension->EmergencyCopyIrpQueue);
    InitializeListHead(&extension->WaitingForPageFileSpace);

    VspAcquire(rootExtension);

    if (!IsListEmpty(&Filter->VolumeList)) {
        extension->IgnorableProduct = (PRTL_BITMAP)
                ExAllocatePoolWithTag(NonPagedPool, sizeof(RTL_BITMAP),
                                      VOLSNAP_TAG_BITMAP);
        if (!extension->IgnorableProduct) {
            VspRelease(rootExtension);
            ExFreePool(buf);
            IoFreeIrp(extension->EmergencyCopyIrp);
            IoFreeMdl(mdl);
            status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                          extension->DiffAreaFileMap);
            ASSERT(NT_SUCCESS(status));
            status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                          extension->NextDiffAreaFileMap);
            ASSERT(NT_SUCCESS(status));
            ExFreePool(bitmapBuffer);
            ExFreePool(extension->VolumeBlockBitmap);
            extension->VolumeBlockBitmap = NULL;
            VspDeleteWorkerThread(rootExtension);
            VspDeleteInitialDiffAreaFiles(extension);
            IoDeleteDevice(deviceObject);
            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Finish;
        }

        p = ExAllocatePoolWithTag(NonPagedPool,
                (bitmapSize + 8*sizeof(ULONG) - 1)/
                (8*sizeof(ULONG))*sizeof(ULONG), VOLSNAP_TAG_BITMAP);
        if (!p) {
            ExFreePool(extension->IgnorableProduct);
            extension->IgnorableProduct = NULL;
            VspRelease(rootExtension);
            ExFreePool(buf);
            IoFreeMdl(mdl);
            IoFreeIrp(extension->EmergencyCopyIrp);
            status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                          extension->DiffAreaFileMap);
            ASSERT(NT_SUCCESS(status));
            status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                          extension->NextDiffAreaFileMap);
            ASSERT(NT_SUCCESS(status));
            ExFreePool(bitmapBuffer);
            ExFreePool(extension->VolumeBlockBitmap);
            extension->VolumeBlockBitmap = NULL;
            VspDeleteWorkerThread(rootExtension);
            VspDeleteInitialDiffAreaFiles(extension);
            IoDeleteDevice(deviceObject);
            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Finish;
        }

        RtlInitializeBitMap(extension->IgnorableProduct, (PULONG) p,
                            bitmapSize);
        RtlSetAllBits(extension->IgnorableProduct);

        e = CONTAINING_RECORD(Filter->VolumeList.Blink, VOLUME_EXTENSION,
                              ListEntry);
        KeAcquireSpinLock(&e->SpinLock, &irql);
        if (e->VolumeBlockBitmap) {
            n = extension->IgnorableProduct->SizeOfBitMap;
            extension->IgnorableProduct->SizeOfBitMap =
                    e->VolumeBlockBitmap->SizeOfBitMap;
            VspAndBitmaps(extension->IgnorableProduct, e->VolumeBlockBitmap);
            extension->IgnorableProduct->SizeOfBitMap = n;
        }
        KeReleaseSpinLock(&e->SpinLock, irql);
    }

    status = VspSetDiffAreaBlocksInBitmap(extension);
    if (!NT_SUCCESS(status)) {
        if (extension->IgnorableProduct) {
            ExFreePool(extension->IgnorableProduct->Buffer);
            ExFreePool(extension->IgnorableProduct);
            extension->IgnorableProduct = NULL;
        }
        VspRelease(rootExtension);
        ExFreePool(buf);
        IoFreeMdl(mdl);
        IoFreeIrp(extension->EmergencyCopyIrp);
        status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                      extension->DiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                      extension->NextDiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        ExFreePool(bitmapBuffer);
        ExFreePool(extension->VolumeBlockBitmap);
        extension->VolumeBlockBitmap = NULL;
        VspDeleteWorkerThread(rootExtension);
        VspDeleteInitialDiffAreaFiles(extension);
        IoDeleteDevice(deviceObject);
        Irp->IoStatus.Status = status;
        goto Finish;
    }

    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    e = Filter->PreparedSnapshot;
    Filter->PreparedSnapshot = extension;
    KeReleaseSpinLock(&Filter->SpinLock, irql);

    VspRelease(rootExtension);

    if (e) {
        VspCleanupInitialSnapshot(e, TRUE);
    }

    deviceObject->Flags |= DO_DIRECT_IO;
    deviceObject->StackSize = Filter->DeviceObject->StackSize;
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

Finish:
    IoFreeWorkItem(context->Dispatch.IoWorkItem);
    VspFreeContext(rootExtension, context);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}

NTSTATUS
VspPrepareForSnapshot(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine prepares a snapshot device object to be used later
    for a snapshot.  This phase is distict from commit snapshot because
    it can be called before IRPs are held.

    Besides creating the device object, this routine will also pre
    allocate some of the diff area.

Arguments:

    Filter  - Supplies the filter extension.

    Irp     - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PVSP_CONTEXT    context;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    context = VspAllocateContext(Filter->Root);
    if (!context) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    context->Type = VSP_CONTEXT_TYPE_DISPATCH;
    context->Dispatch.IoWorkItem = IoAllocateWorkItem(Filter->DeviceObject);
    if (!context->Dispatch.IoWorkItem) {
        VspFreeContext(Filter->Root, context);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IoMarkIrpPending(Irp);
    context->Dispatch.Irp = Irp;

    IoQueueWorkItem(context->Dispatch.IoWorkItem, VspPrepareForSnapshotWorker,
                    DelayedWorkQueue, context);

    return STATUS_PENDING;
}

VOID
VspCleanupBitsSetInOtherPreparedSnapshots(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    PLIST_ENTRY         l;
    PVSP_DIFF_AREA_FILE diffAreaFile;
    NTSTATUS            status;

    for (l = Extension->ListOfDiffAreaFiles.Flink;
         l != &Extension->ListOfDiffAreaFiles; l = l->Flink) {

        diffAreaFile = CONTAINING_RECORD(l, VSP_DIFF_AREA_FILE,
                                         VolumeListEntry);

        if (diffAreaFile->FilterListEntryBeingUsed) {
            RemoveEntryList(&diffAreaFile->FilterListEntry);
            diffAreaFile->FilterListEntryBeingUsed = FALSE;
        }

        if (diffAreaFile->Filter != Extension->Filter &&
            diffAreaFile->Filter->PreparedSnapshot) {

            status = VspMarkFileAllocationInBitmap(
                     diffAreaFile->Filter->PreparedSnapshot,
                     diffAreaFile->FileHandle, NULL, FALSE, TRUE, NULL);
            if (!NT_SUCCESS(status)) {
                VspLogError(Extension, diffAreaFile->Filter,
                            VS_CANT_MAP_DIFF_AREA_FILE, status, 7);
                VspAbortPreparedSnapshot(diffAreaFile->Filter, FALSE);
            }
        }
    }
}

VOID
VspCleanupInitialMaps(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION   extension = context->Extension.Extension;
    NTSTATUS            status;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_EXTENSION);

    status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                  extension->DiffAreaFileMap);
    ASSERT(NT_SUCCESS(status));
    status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                  extension->NextDiffAreaFileMap);
    ASSERT(NT_SUCCESS(status));

    VspFreeContext(extension->Root, context);

    VspReleasePagedResource(extension);

    ObDereferenceObject(extension->DeviceObject);
}

VOID
VspCleanupInitialSnapshot(
    IN  PVOLUME_EXTENSION   Extension,
    IN  BOOLEAN             NeedLock
    )

{
    PVSP_CONTEXT    context;
    NTSTATUS        status;
    KIRQL           irql;

    context = VspAllocateContext(Extension->Root);
    if (context) {
        context->Type = VSP_CONTEXT_TYPE_EXTENSION;
        context->Extension.Extension = Extension;
        context->Extension.Irp = NULL;
        ExInitializeWorkItem(&context->WorkItem, VspCleanupInitialMaps,
                             context);
        ObReferenceObject(Extension->DeviceObject);
        VspAcquirePagedResource(Extension, &context->WorkItem);
    } else {
        status = ZwUnmapViewOfSection(Extension->DiffAreaFileMapProcess,
                                      Extension->DiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        status = ZwUnmapViewOfSection(Extension->DiffAreaFileMapProcess,
                                      Extension->NextDiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
    }

    if (NeedLock) {
        VspAcquire(Extension->Root);
    }

    VspDeleteWorkerThread(Extension->Root);
    VspCleanupBitsSetInOtherPreparedSnapshots(Extension);
    VspDeleteInitialDiffAreaFiles(Extension);

    if (NeedLock) {
        VspRelease(Extension->Root);
    }

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    ExFreePool(Extension->VolumeBlockBitmap->Buffer);
    ExFreePool(Extension->VolumeBlockBitmap);
    Extension->VolumeBlockBitmap = NULL;
    if (Extension->IgnorableProduct) {
        ExFreePool(Extension->IgnorableProduct->Buffer);
        ExFreePool(Extension->IgnorableProduct);
        Extension->IgnorableProduct = NULL;
    }
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    ExFreePool(MmGetMdlVirtualAddress(
               Extension->EmergencyCopyIrp->MdlAddress));
    IoFreeMdl(Extension->EmergencyCopyIrp->MdlAddress);
    IoFreeIrp(Extension->EmergencyCopyIrp);

    IoDeleteDevice(Extension->DeviceObject);
}

NTSTATUS
VspAbortPreparedSnapshot(
    IN  PFILTER_EXTENSION   Filter,
    IN  BOOLEAN             NeedLock
    )

/*++

Routine Description:

    This routine aborts the prepared snapshot.

Arguments:

    Filter  - Supplies the filter extension.

Return Value:

    NTSTATUS

--*/

{
    KIRQL               irql;
    PVOLUME_EXTENSION   extension;

    if (NeedLock) {
        VspAcquire(Filter->Root);
    }

    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    extension = Filter->PreparedSnapshot;
    Filter->PreparedSnapshot = NULL;
    KeReleaseSpinLock(&Filter->SpinLock, irql);

    if (NeedLock) {
        VspRelease(Filter->Root);
    }

    if (!extension) {
        return STATUS_INVALID_PARAMETER;
    }

    VspCleanupInitialSnapshot(extension, NeedLock);

    return STATUS_SUCCESS;
}

NTSTATUS
VspMarkFreeSpaceInBitmap(
    IN  PVOLUME_EXTENSION   Extension,
    IN  HANDLE              UseThisHandle,
    IN  PRTL_BITMAP         BitmapToSet
    )

/*++

Routine Description:

    This routine opens the snapshot volume and marks off the free
    space in the NTFS bitmap as 'ignorable'.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    NTSTATUS

--*/

{
    WCHAR                       buffer[100];
    KEVENT                      event;
    IO_STATUS_BLOCK             ioStatus;
    UNICODE_STRING              fileName;
    OBJECT_ATTRIBUTES           oa;
    NTSTATUS                    status;
    HANDLE                      h;
    LARGE_INTEGER               timeout;
    BOOLEAN                     isNtfs;
    FILE_FS_SIZE_INFORMATION    fsSize;
    ULONG                       bitmapSize;
    STARTING_LCN_INPUT_BUFFER   input;
    PVOLUME_BITMAP_BUFFER       output;
    RTL_BITMAP                  freeSpaceBitmap;
    ULONG                       bpc, f, numBits, startBit, s, n, i;
    KIRQL                       irql;
    ULONG                       r;

    if (UseThisHandle) {
        h = UseThisHandle;
    } else {

        swprintf(buffer, L"\\Device\\HarddiskVolumeShadowCopy%d",
                 Extension->VolumeNumber);
        RtlInitUnicodeString(&fileName, buffer);

        InitializeObjectAttributes(&oa, &fileName, OBJ_CASE_INSENSITIVE, NULL,
                                   NULL);

        KeInitializeEvent(&event, NotificationEvent, FALSE);
        timeout.QuadPart = -10*1000; // 1 millisecond.

        for (i = 0; i < 5000; i++) {
            status = ZwOpenFile(&h, FILE_GENERIC_READ, &oa, &ioStatus,
                                FILE_SHARE_READ | FILE_SHARE_WRITE |
                                FILE_SHARE_DELETE,
                                FILE_SYNCHRONOUS_IO_NONALERT);
            if (NT_SUCCESS(status)) {
                break;
            }
            if (status != STATUS_NO_SUCH_DEVICE) {
                return status;
            }
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                  &timeout);
        }

        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    status = VspIsNtfs(h, &isNtfs);
    if (!NT_SUCCESS(status) || !isNtfs) {
        if (!UseThisHandle) {
            ZwClose(h);
        }
        return status;
    }

    status = ZwQueryVolumeInformationFile(h, &ioStatus, &fsSize,
                                          sizeof(fsSize),
                                          FileFsSizeInformation);
    if (!NT_SUCCESS(status)) {
        if (!UseThisHandle) {
            ZwClose(h);
        }
        return status;
    }

    bitmapSize = (ULONG) ((fsSize.TotalAllocationUnits.QuadPart+7)/8 +
                          FIELD_OFFSET(VOLUME_BITMAP_BUFFER, Buffer) + 3);
    input.StartingLcn.QuadPart = 0;

    output = (PVOLUME_BITMAP_BUFFER)
             ExAllocatePoolWithTag(PagedPool, bitmapSize, VOLSNAP_TAG_BITMAP);
    if (!output) {
        if (!UseThisHandle) {
            ZwClose(h);
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = ZwFsControlFile(h, NULL, NULL, NULL, &ioStatus,
                             FSCTL_GET_VOLUME_BITMAP, &input,
                             sizeof(input), output, bitmapSize);
    if (!UseThisHandle) {
        ZwClose(h);
    }
    if (!NT_SUCCESS(status)) {
        ExFreePool(output);
        return status;
    }

    ASSERT(output->BitmapSize.HighPart == 0);
    RtlInitializeBitMap(&freeSpaceBitmap, (PULONG) output->Buffer,
                        output->BitmapSize.LowPart);
    bpc = fsSize.BytesPerSector*fsSize.SectorsPerAllocationUnit;
    if (bpc < BLOCK_SIZE) {
        f = BLOCK_SIZE/bpc;
    } else {
        f = bpc/BLOCK_SIZE;
    }

    startBit = 0;
    for (;;) {

        if (startBit < freeSpaceBitmap.SizeOfBitMap) {
            numBits = RtlFindNextForwardRunClear(&freeSpaceBitmap, startBit,
                                                 &startBit);
        } else {
            numBits = 0;
        }
        if (!numBits) {
            break;
        }

        if (bpc == BLOCK_SIZE) {
            s = startBit;
            n = numBits;
        } else if (bpc < BLOCK_SIZE) {
            s = (startBit + f - 1)/f;
            r = startBit%f;
            if (r) {
                if (numBits > f - r) {
                    n = numBits - (f - r);
                } else {
                    n = 0;
                }
            } else {
                n = numBits;
            }
            n /= f;
        } else {
            s = startBit*f;
            n = numBits*f;
        }

        if (n) {
            if (BitmapToSet) {
                RtlSetBits(BitmapToSet, s, n);
            } else {
                KeAcquireSpinLock(&Extension->SpinLock, &irql);
                if (Extension->VolumeBlockBitmap) {
                    if (Extension->IgnorableProduct) {
                        for (i = 0; i < n; i++) {
                            if (RtlCheckBit(Extension->IgnorableProduct, i + s)) {
                                RtlSetBit(Extension->VolumeBlockBitmap, i + s);
                            }
                        }
                    } else {
                        RtlSetBits(Extension->VolumeBlockBitmap, s, n);
                    }
                }
                KeReleaseSpinLock(&Extension->SpinLock, irql);
            }
        }

        startBit += numBits;
    }

    ExFreePool(output);

    return STATUS_SUCCESS;
}

NTSTATUS
VspSetIgnorableBlocksInBitmap(
    IN  PVOID   Extension
    )

/*++

Routine Description:

    This routine opens all of the Diff Area files on the given volume
    and marks them off as ignorable in the bitmap to avoid bad
    recursions and to improve performance.  The free space is also marked
    off.  If a diff area file for this snapshot was allocated on this
    volume then its diff area was pre marked off on the bitmap.  This
    routine will check make sure that the location has not moved.  This
    routine will eventually mark the pagefile too but that is just pure
    performance and not required.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    NTSTATUS

--*/

{
    PVOLUME_EXTENSION   extension = (PVOLUME_EXTENSION) Extension;
    WCHAR               nameBuffer[100];
    UNICODE_STRING      name;
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status, status2;
    HANDLE              h;
    IO_STATUS_BLOCK     ioStatus;
    KIRQL               irql;

    status = VspMarkFreeSpaceInBitmap(extension, NULL, NULL);

    swprintf(nameBuffer, L"\\Device\\HarddiskVolumeShadowCopy%d\\pagefile.sys",
             extension->VolumeNumber);
    RtlInitUnicodeString(&name, nameBuffer);
    InitializeObjectAttributes(&oa, &name, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status2 = ZwOpenFile(&h, FILE_GENERIC_READ, &oa, &ioStatus,
                         FILE_SHARE_READ | FILE_SHARE_WRITE |
                         FILE_SHARE_DELETE, FILE_SYNCHRONOUS_IO_NONALERT);
    if (NT_SUCCESS(status2)) {
        VspMarkFileAllocationInBitmap(extension, h, NULL, FALSE, FALSE, NULL);
        ZwClose(h);
    }

    return status;
}

NTSTATUS
VspCommitSnapshot(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine commits the prepared snapshot.

Arguments:

    Filter  - Supplies the filter extension.

    Irp     - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    KIRQL                   irql;
    PVOLUME_EXTENSION       extension, previousExtension;
    PLIST_ENTRY             l;
    PVSP_DIFF_AREA_FILE     diffAreaFile;

    VspAcquire(Filter->Root);

    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    extension = Filter->PreparedSnapshot;
    Filter->PreparedSnapshot = NULL;
    KeReleaseSpinLock(&Filter->SpinLock, irql);

    if (!extension) {
        VspRelease(Filter->Root);
        return STATUS_INVALID_PARAMETER;
    }

    if (!Filter->HoldIncomingWrites) {
        VspRelease(Filter->Root);
        VspCleanupInitialSnapshot(extension, TRUE);
        return STATUS_INVALID_PARAMETER;
    }

    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    InterlockedExchange(&Filter->SnapshotsPresent, TRUE);
    InsertTailList(&Filter->VolumeList, &extension->ListEntry);
    KeReleaseSpinLock(&Filter->SpinLock, irql);

    l = extension->ListEntry.Blink;
    if (l != &Filter->VolumeList) {
        previousExtension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

        KeAcquireSpinLock(&previousExtension->SpinLock, &irql);
        ExFreePool(previousExtension->VolumeBlockBitmap->Buffer);
        ExFreePool(previousExtension->VolumeBlockBitmap);
        previousExtension->VolumeBlockBitmap = NULL;
        KeReleaseSpinLock(&previousExtension->SpinLock, irql);
    }

    KeQuerySystemTime(&extension->CommitTimeStamp);

    VspRelease(Filter->Root);

    return STATUS_SUCCESS;
}

NTSTATUS
VspEndCommitSnapshot(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine commits the prepared snapshot.

Arguments:

    Filter  - Supplies the filter extension.

    Irp     - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PLIST_ENTRY         l;
    PVOLUME_EXTENSION   extension;
    WCHAR               buffer[100];
    UNICODE_STRING      volumeName;
    PVOLSNAP_NAME       output;
    NTSTATUS            status;
    LARGE_INTEGER       timeout;

    VspAcquire(Filter->Root);

    l = Filter->VolumeList.Blink;
    if (l == &Filter->VolumeList) {
        VspRelease(Filter->Root);
        return STATUS_INVALID_PARAMETER;
    }

    extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

    if (extension->HasEndCommit) {
        VspRelease(Filter->Root);
        return STATUS_INVALID_PARAMETER;
    }

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength) {
        status = VspSetApplicationInfo(extension, Irp);
        if (!NT_SUCCESS(status)) {
            VspRelease(Filter->Root);
            return status;
        }
    }

    swprintf(buffer, L"\\Device\\HarddiskVolumeShadowCopy%d",
             extension->VolumeNumber);
    RtlInitUnicodeString(&volumeName, buffer);

    Irp->IoStatus.Information = FIELD_OFFSET(VOLSNAP_NAME, Name) +
                                volumeName.Length + sizeof(WCHAR);
    if (Irp->IoStatus.Information >
        irpSp->Parameters.DeviceIoControl.OutputBufferLength) {

        VspRelease(Filter->Root);
        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    output = (PVOLSNAP_NAME) Irp->AssociatedIrp.SystemBuffer;
    output->NameLength = volumeName.Length;
    RtlCopyMemory(output->Name, volumeName.Buffer,
                  output->NameLength + sizeof(WCHAR));

    extension->HasEndCommit = TRUE;

    VspTruncatePreviousDiffArea(extension);

    if (!KeCancelTimer(&Filter->EndCommitTimer)) {
        ObReferenceObject(Filter->DeviceObject);
    }
    KeResetEvent(&Filter->EndCommitProcessCompleted);
    timeout.QuadPart = (LONGLONG) -10*1000*1000*120*10;   // 20 minutes.
    KeSetTimer(&Filter->EndCommitTimer, timeout, &Filter->EndCommitTimerDpc);

    VspRelease(Filter->Root);

    IoInvalidateDeviceRelations(Filter->Pdo, BusRelations);

    return STATUS_SUCCESS;
}

NTSTATUS
VspVolumeRefCountCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Extension
    )

{
    PVOLUME_EXTENSION   extension = (PVOLUME_EXTENSION) Extension;

    VspDecrementVolumeRefCount(extension);
    return STATUS_SUCCESS;
}

NTSTATUS
VspQueryNamesOfSnapshots(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns the names of all of the snapshots for this filter.

Arguments:

    Filter  - Supplies the filter extension.

    Irp     - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLSNAP_NAMES      output;
    PLIST_ENTRY         l;
    PVOLUME_EXTENSION   extension;
    WCHAR               buffer[100];
    UNICODE_STRING      name;
    PWCHAR              buf;

    Irp->IoStatus.Information = FIELD_OFFSET(VOLSNAP_NAMES, Names);

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    KeWaitForSingleObject(&Filter->EndCommitProcessCompleted, Executive,
                          KernelMode, FALSE, NULL);

    output = (PVOLSNAP_NAMES) Irp->AssociatedIrp.SystemBuffer;

    VspAcquire(Filter->Root);

    output->MultiSzLength = sizeof(WCHAR);

    for (l = Filter->VolumeList.Flink; l != &Filter->VolumeList;
         l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

        swprintf(buffer, L"\\Device\\HarddiskVolumeShadowCopy%d",
                 extension->VolumeNumber);
        RtlInitUnicodeString(&name, buffer);

        output->MultiSzLength += name.Length + sizeof(WCHAR);
    }

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information + output->MultiSzLength) {

        VspRelease(Filter->Root);
        return STATUS_BUFFER_OVERFLOW;
    }

    Irp->IoStatus.Information += output->MultiSzLength;
    buf = output->Names;

    for (l = Filter->VolumeList.Flink; l != &Filter->VolumeList;
         l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

        swprintf(buf, L"\\Device\\HarddiskVolumeShadowCopy%d",
                 extension->VolumeNumber);
        RtlInitUnicodeString(&name, buf);

        buf += name.Length/sizeof(WCHAR) + 1;
    }

    *buf = 0;

    VspRelease(Filter->Root);

    return STATUS_SUCCESS;
}

NTSTATUS
VspClearDiffArea(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine clears the list of diff areas used by this filter.  This
    call will fail if there are any snapshots in flight.

Arguments:

    Filter  - Supplies the filter extension.

    Irp     - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PLIST_ENTRY             l;
    PVSP_DIFF_AREA_VOLUME   diffAreaVolume;

    VspAcquire(Filter->Root);

    if (Filter->SnapshotsPresent) {
        VspRelease(Filter->Root);
        return STATUS_INVALID_PARAMETER;
    }

    while (!IsListEmpty(&Filter->DiffAreaVolumes)) {
        l = RemoveHeadList(&Filter->DiffAreaVolumes);
        diffAreaVolume = CONTAINING_RECORD(l, VSP_DIFF_AREA_VOLUME, ListEntry);
        ExFreePool(diffAreaVolume);
    }

    VspRelease(Filter->Root);

    return STATUS_SUCCESS;
}

VOID
VspAddVolumeToDiffAreaWorker(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PVOID           Context
    )

/*++

Routine Description:

    This routine adds the given volume to the diff area for this volume.
    All snapshots get a new diff area file.

Arguments:

    Filter  - Supplies the filter extension.

    Irp     - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PVSP_CONTEXT            context = (PVSP_CONTEXT) Context;
    PFILTER_EXTENSION       Filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;
    PIRP                    Irp = context->Dispatch.Irp;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLSNAP_NAME           input;
    UNICODE_STRING          volumeName;
    PFILTER_EXTENSION       filter;
    PVSP_DIFF_AREA_VOLUME   diffAreaVolume;
    PLIST_ENTRY             l, ll;
    PVOLUME_EXTENSION       extension;
    LONGLONG                newDiffAreaFileSize, diff;
    PVSP_DIFF_AREA_FILE     diffAreaFile;
    NTSTATUS                status;
    KIRQL                   irql;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLSNAP_NAME)) {

        VspLogError(NULL, Filter, VS_FAILURE_ADDING_DIFF_AREA,
                    STATUS_INVALID_PARAMETER, 3);
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        goto Finish;
    }

    input = (PVOLSNAP_NAME) Irp->AssociatedIrp.SystemBuffer;
    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        (ULONG) FIELD_OFFSET(VOLSNAP_NAME, Name) + input->NameLength) {

        VspLogError(NULL, Filter, VS_FAILURE_ADDING_DIFF_AREA,
                    STATUS_INVALID_PARAMETER, 4);
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        goto Finish;
    }

    volumeName.Length = volumeName.MaximumLength = input->NameLength;
    volumeName.Buffer = input->Name;

    VspAcquire(Filter->Root);

    filter = VspFindFilter(Filter->Root, Filter, &volumeName, NULL);
    if (!filter ||
        (filter->TargetObject->Characteristics&FILE_REMOVABLE_MEDIA)) {

        VspRelease(Filter->Root);
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        goto Finish;
    }

    for (l = Filter->DiffAreaVolumes.Flink; l != &Filter->DiffAreaVolumes;
         l = l->Flink) {

        diffAreaVolume = CONTAINING_RECORD(l, VSP_DIFF_AREA_VOLUME, ListEntry);
        if (filter == diffAreaVolume->Filter) {
            break;
        }
    }

    if (l != &Filter->DiffAreaVolumes) {
        VspRelease(Filter->Root);
        VspLogError(NULL, Filter, VS_FAILURE_ADDING_DIFF_AREA,
                    STATUS_DUPLICATE_OBJECTID, 5);
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        goto Finish;
    }

    diffAreaVolume = (PVSP_DIFF_AREA_VOLUME)
                     ExAllocatePoolWithTag(PagedPool,
                     sizeof(VSP_DIFF_AREA_VOLUME), VOLSNAP_TAG_DIFF_VOLUME);
    if (!diffAreaVolume) {
        VspRelease(Filter->Root);
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }

    diffAreaVolume->Filter = filter;
    InsertTailList(&Filter->DiffAreaVolumes, &diffAreaVolume->ListEntry);

    l = Filter->VolumeList.Blink;
    if (l == &Filter->VolumeList) {
        VspRelease(Filter->Root);
        Irp->IoStatus.Status = STATUS_SUCCESS;
        goto Finish;
    }

    VspRelease(Filter->Root);

    extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

    newDiffAreaFileSize = 2*extension->DiffAreaFileIncrease;
    VspAcquireNonPagedResource(extension, NULL);
    for (ll = extension->ListOfDiffAreaFiles.Flink;
         ll != &extension->ListOfDiffAreaFiles; ll = ll->Flink) {

        diffAreaFile = CONTAINING_RECORD(ll, VSP_DIFF_AREA_FILE,
                                         VolumeListEntry);

        diff = diffAreaFile->AllocatedFileSize - diffAreaFile->NextAvailable;
        if (diff > newDiffAreaFileSize) {
            newDiffAreaFileSize = diff;
        }
    }
    VspReleaseNonPagedResource(extension);

    diffAreaFile = (PVSP_DIFF_AREA_FILE)
                   ExAllocatePoolWithTag(NonPagedPool,
                                         sizeof(VSP_DIFF_AREA_FILE),
                                         VOLSNAP_TAG_DIFF_FILE);
    if (!diffAreaFile) {
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }

    diffAreaFile->Extension = extension;
    diffAreaFile->Filter = filter;
    diffAreaFile->NextAvailable = 0;
    diffAreaFile->AllocatedFileSize = newDiffAreaFileSize;

    status = VspOpenDiffAreaFile(diffAreaFile);
    if (!NT_SUCCESS(status)) {
        ExFreePool(diffAreaFile);
        Irp->IoStatus.Status = status;
        goto Finish;
    }

    InitializeListHead(&diffAreaFile->UnusedAllocationList);
    status = VspMarkFileAllocationInBitmap(extension,
                                           diffAreaFile->FileHandle,
                                           diffAreaFile, TRUE, FALSE, NULL);
    if (!NT_SUCCESS(status)) {
        VspLogError(extension, diffAreaFile->Filter,
                    VS_CANT_MAP_DIFF_AREA_FILE, status, 8);
        ZwClose(diffAreaFile->FileHandle);
        ExFreePool(diffAreaFile);
        Irp->IoStatus.Status = status;
        goto Finish;
    }

    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    Filter->AllocatedVolumeSpace += diffAreaFile->AllocatedFileSize;
    KeReleaseSpinLock(&Filter->SpinLock, irql);

    VspAcquire(Filter->Root);

    diffAreaFile->FilterListEntryBeingUsed = TRUE;
    InsertTailList(&diffAreaFile->Filter->DiffAreaFilesOnThisFilter,
                   &diffAreaFile->FilterListEntry);

    VspPauseSnapshotIo(extension);
    VspPauseVolumeIo(extension->Filter);

    VspAcquireNonPagedResource(extension, NULL);
    InsertTailList(&extension->ListOfDiffAreaFiles,
                   &diffAreaFile->VolumeListEntry);
    VspReleaseNonPagedResource(extension);

    VspResumeVolumeIo(extension->Filter);
    VspResumeSnapshotIo(extension);

    VspRelease(Filter->Root);

Finish:
    VspFreeContext(Filter->Root, context);
    IoFreeWorkItem(context->Dispatch.IoWorkItem);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}

NTSTATUS
VspAddVolumeToDiffArea(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine adds the given volume to the diff area for this volume.
    All snapshots get a new diff area file.

Arguments:

    Filter  - Supplies the filter extension.

    Irp     - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PVSP_CONTEXT    context;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    context = VspAllocateContext(Filter->Root);
    if (!context) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    context->Type = VSP_CONTEXT_TYPE_DISPATCH;
    context->Dispatch.IoWorkItem = IoAllocateWorkItem(Filter->DeviceObject);
    if (!context->Dispatch.IoWorkItem) {
        VspFreeContext(Filter->Root, context);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IoMarkIrpPending(Irp);
    context->Dispatch.Irp = Irp;

    IoQueueWorkItem(context->Dispatch.IoWorkItem, VspAddVolumeToDiffAreaWorker,
                    DelayedWorkQueue, context);

    return STATUS_PENDING;
}

NTSTATUS
VspQueryDiffArea(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine the list of volumes that make up the diff area for this
    volume.

Arguments:

    Filter  - Supplies the filter extension.

    Irp     - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLSNAP_NAMES          output;
    PLIST_ENTRY             l;
    PFILTER_EXTENSION       filter;
    KEVENT                  event;
    PMOUNTDEV_NAME          name;
    CHAR                    buffer[512];
    PIRP                    irp;
    IO_STATUS_BLOCK         ioStatus;
    NTSTATUS                status;
    PWCHAR                  buf;

    Irp->IoStatus.Information = FIELD_OFFSET(VOLSNAP_NAMES, Names);

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    output = (PVOLSNAP_NAMES) Irp->AssociatedIrp.SystemBuffer;

    VspAcquire(Filter->Root);

    output->MultiSzLength = sizeof(WCHAR);

    for (l = Filter->DiffAreaVolumes.Flink; l != &Filter->DiffAreaVolumes;
         l = l->Flink) {

        filter = CONTAINING_RECORD(l, VSP_DIFF_AREA_VOLUME, ListEntry)->Filter;

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        name = (PMOUNTDEV_NAME) buffer;
        irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTDEV_QUERY_DEVICE_NAME,
                                            filter->TargetObject, NULL, 0,
                                            name, 512, FALSE, &event,
                                            &ioStatus);
        if (!irp) {
            VspRelease(Filter->Root);
            Irp->IoStatus.Information = 0;
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        status = IoCallDriver(filter->TargetObject, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }

        if (!NT_SUCCESS(status)) {
            VspRelease(Filter->Root);
            Irp->IoStatus.Information = 0;
            return status;
        }

        output->MultiSzLength += name->NameLength + sizeof(WCHAR);
    }

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information + output->MultiSzLength) {

        VspRelease(Filter->Root);
        return STATUS_BUFFER_OVERFLOW;
    }

    Irp->IoStatus.Information += output->MultiSzLength;
    buf = output->Names;

    for (l = Filter->DiffAreaVolumes.Flink; l != &Filter->DiffAreaVolumes;
         l = l->Flink) {

        filter = CONTAINING_RECORD(l, VSP_DIFF_AREA_VOLUME, ListEntry)->Filter;

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        name = (PMOUNTDEV_NAME) buffer;
        irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTDEV_QUERY_DEVICE_NAME,
                                            filter->TargetObject, NULL, 0,
                                            name, 512, FALSE, &event,
                                            &ioStatus);
        if (!irp) {
            VspRelease(Filter->Root);
            Irp->IoStatus.Information = 0;
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        status = IoCallDriver(filter->TargetObject, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }

        if (!NT_SUCCESS(status)) {
            VspRelease(Filter->Root);
            Irp->IoStatus.Information = 0;
            return status;
        }

        RtlCopyMemory(buf, name->Name, name->NameLength);
        buf += name->NameLength/sizeof(WCHAR);

        *buf++ = 0;
    }

    *buf = 0;

    VspRelease(Filter->Root);

    return STATUS_SUCCESS;
}

NTSTATUS
VspQueryDiffAreaSize(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns the diff area sizes for this volume.

Arguments:

    Filter  - Supplies the filter extension.

    Irp     - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION          irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLSNAP_DIFF_AREA_SIZES    output = (PVOLSNAP_DIFF_AREA_SIZES) Irp->AssociatedIrp.SystemBuffer;
    KIRQL                       irql;

    Irp->IoStatus.Information = sizeof(VOLSNAP_DIFF_AREA_SIZES);

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    output->UsedVolumeSpace = Filter->UsedVolumeSpace;
    output->AllocatedVolumeSpace = Filter->AllocatedVolumeSpace;
    output->MaximumVolumeSpace = Filter->MaximumVolumeSpace;
    KeReleaseSpinLock(&Filter->SpinLock, irql);

    return STATUS_SUCCESS;
}

NTSTATUS
VspQueryOriginalVolumeName(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns the original volume name for the given volume
    snapshot.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PFILTER_EXTENSION   filter = Extension->Filter;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLSNAP_NAME       output = (PVOLSNAP_NAME) Irp->AssociatedIrp.SystemBuffer;
    PMOUNTDEV_NAME      name;
    CHAR                buffer[512];
    KEVENT              event;
    PIRP                irp;
    IO_STATUS_BLOCK     ioStatus;
    NTSTATUS            status;

    Irp->IoStatus.Information = FIELD_OFFSET(VOLSNAP_NAME, Name);

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    name = (PMOUNTDEV_NAME) buffer;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTDEV_QUERY_DEVICE_NAME,
                                        filter->TargetObject, NULL, 0,
                                        name, 512, FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        Irp->IoStatus.Information = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(filter->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Information = 0;
        return status;
    }

    output->NameLength = name->NameLength;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information + output->NameLength) {

        return STATUS_BUFFER_OVERFLOW;
    }

    RtlCopyMemory(output->Name, name->Name, output->NameLength);

    Irp->IoStatus.Information += output->NameLength;

    return STATUS_SUCCESS;
}

NTSTATUS
VspQueryConfigInfo(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns the configuration information for this volume
    snapshot.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLSNAP_CONFIG_INFO    output = (PVOLSNAP_CONFIG_INFO) Irp->AssociatedIrp.SystemBuffer;

    Irp->IoStatus.Information = sizeof(ULONG);

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        return STATUS_INVALID_PARAMETER;
    }

    output->Attributes = 0;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength >=
        sizeof(VOLSNAP_CONFIG_INFO)) {

        Irp->IoStatus.Information = sizeof(VOLSNAP_CONFIG_INFO);

        output->Reserved = 0;
        output->SnapshotCreationTime = Extension->CommitTimeStamp;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VspSetApplicationInfo(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine sets the application info.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION          irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLSNAP_APPLICATION_INFO   input = (PVOLSNAP_APPLICATION_INFO) Irp->AssociatedIrp.SystemBuffer;
    PVOID                       newAppInfo, oldAppInfo;

    Irp->IoStatus.Information = 0;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLSNAP_APPLICATION_INFO)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        (LONGLONG) FIELD_OFFSET(VOLSNAP_APPLICATION_INFO, Information) +
        input->InformationLength) {

        return STATUS_INVALID_PARAMETER;
    }

    newAppInfo = ExAllocatePoolWithQuotaTag((POOL_TYPE) (PagedPool |
                 POOL_QUOTA_FAIL_INSTEAD_OF_RAISE),
                 input->InformationLength, VOLSNAP_TAG_APP_INFO);
    if (!newAppInfo) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(newAppInfo, input->Information, input->InformationLength);

    KeEnterCriticalRegion();
    VspAcquirePagedResource(Extension, NULL);

    Extension->ApplicationInformationSize = input->InformationLength;
    oldAppInfo = Extension->ApplicationInformation;
    Extension->ApplicationInformation = newAppInfo;

    VspReleasePagedResource(Extension);
    KeLeaveCriticalRegion();

    if (oldAppInfo) {
        ExFreePool(oldAppInfo);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VspQueryApplicationInfo(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine queries the application info.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION          irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLSNAP_APPLICATION_INFO   output = (PVOLSNAP_APPLICATION_INFO) Irp->AssociatedIrp.SystemBuffer;
    PVOID                       appInfo;

    Irp->IoStatus.Information = FIELD_OFFSET(VOLSNAP_APPLICATION_INFO,
                                             Information);

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        return STATUS_INVALID_PARAMETER;
    }

    VspAcquirePagedResource(Extension, NULL);

    output->InformationLength = Extension->ApplicationInformationSize;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information + output->InformationLength) {

        VspReleasePagedResource(Extension);
        return STATUS_BUFFER_OVERFLOW;
    }

    Irp->IoStatus.Information += output->InformationLength;

    RtlCopyMemory(output->Information, Extension->ApplicationInformation,
                  output->InformationLength);

    VspReleasePagedResource(Extension);

    return STATUS_SUCCESS;
}

NTSTATUS
VspCheckSecurity(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

{
    SECURITY_SUBJECT_CONTEXT    securityContext;
    BOOLEAN                     accessGranted;
    NTSTATUS                    status;
    ACCESS_MASK                 grantedAccess;

    SeCaptureSubjectContext(&securityContext);
    SeLockSubjectContext(&securityContext);

    accessGranted = FALSE;
    status = STATUS_ACCESS_DENIED;

    _try {

        accessGranted = SeAccessCheck(
                        Filter->Pdo->SecurityDescriptor,
                        &securityContext, TRUE, FILE_READ_DATA, 0, NULL,
                        IoGetFileObjectGenericMapping(), Irp->RequestorMode,
                        &grantedAccess, &status);

    } _finally {
        SeUnlockSubjectContext(&securityContext);
        SeReleaseSubjectContext(&securityContext);
    }

    if (!accessGranted) {
        return status;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VspAutoCleanup(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine remembers the given File Object so that when it is
    cleaned up, all snapshots will be cleaned up with it.

Arguments:

    Filter  - Supplies the filter extension.

    Irp     - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status;
    KIRQL               irql;

    status = VspCheckSecurity(Filter, Irp);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    IoAcquireCancelSpinLock(&irql);
    if (Filter->AutoCleanupFileObject) {
        IoReleaseCancelSpinLock(irql);
        return STATUS_INVALID_PARAMETER;
    }
    Filter->AutoCleanupFileObject = irpSp->FileObject;
    IoReleaseCancelSpinLock(irql);

    return STATUS_SUCCESS;
}

VOID
VspDeleteSnapshotWorker(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PVOID           Context
    )

{
    PFILTER_EXTENSION       filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;
    PVSP_CONTEXT            context = (PVSP_CONTEXT) Context;
    PIRP                    irp = context->Dispatch.Irp;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(irp);
    PVOLUME_EXTENSION       oldestExtension;
    PVOLSNAP_NAME           name;
    WCHAR                   buffer[100];
    UNICODE_STRING          name1, name2;
    LIST_ENTRY              listOfDiffAreaFileToClose;
    LIST_ENTRY              listOfDeviceObjectsToDelete;
    NTSTATUS                status;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_DISPATCH);

    KeWaitForSingleObject(&filter->EndCommitProcessCompleted, Executive,
                          KernelMode, FALSE, NULL);

    InitializeListHead(&listOfDiffAreaFileToClose);
    InitializeListHead(&listOfDeviceObjectsToDelete);

    VspAcquire(filter->Root);

    if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
        IOCTL_VOLSNAP_DELETE_SNAPSHOT) {

        if (IsListEmpty(&filter->VolumeList)) {
            status = STATUS_INVALID_PARAMETER;
        } else {

            oldestExtension = CONTAINING_RECORD(filter->VolumeList.Flink,
                                                VOLUME_EXTENSION, ListEntry);
            swprintf(buffer, L"\\Device\\HarddiskVolumeShadowCopy%d",
                     oldestExtension->VolumeNumber);
            RtlInitUnicodeString(&name1, buffer);

            name = (PVOLSNAP_NAME) irp->AssociatedIrp.SystemBuffer;

            name2.Length = name2.MaximumLength = name->NameLength;
            name2.Buffer = name->Name;

            if (RtlEqualUnicodeString(&name1, &name2, TRUE)) {
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_NOT_SUPPORTED;
            }
        }
    } else {
        status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(status)) {
        status = VspDeleteOldestSnapshot(filter, &listOfDiffAreaFileToClose,
                                         &listOfDeviceObjectsToDelete);
    }

    VspRelease(filter->Root);

    VspCloseDiffAreaFiles(&listOfDiffAreaFileToClose,
                          &listOfDeviceObjectsToDelete);

    IoFreeWorkItem(context->Dispatch.IoWorkItem);
    VspFreeContext(filter->Root, context);

    irp->IoStatus.Status = status;
    IoCompleteRequest(irp, IO_NO_INCREMENT);
}

NTSTATUS
VspDeleteSnapshotPost(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVSP_CONTEXT        context;
    PVOLSNAP_NAME       name;

    Irp->IoStatus.Information = 0;

    if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
        IOCTL_VOLSNAP_DELETE_SNAPSHOT) {

        if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(VOLSNAP_NAME)) {

            return STATUS_INVALID_PARAMETER;
        }

        name = (PVOLSNAP_NAME) Irp->AssociatedIrp.SystemBuffer;

        if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
            (ULONG) FIELD_OFFSET(VOLSNAP_NAME, Name) + name->NameLength) {

            return STATUS_INVALID_PARAMETER;
        }
    }

    context = VspAllocateContext(Filter->Root);
    if (!context) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    context->Type = VSP_CONTEXT_TYPE_DISPATCH;
    context->Dispatch.IoWorkItem = IoAllocateWorkItem(Filter->DeviceObject);
    if (!context->Dispatch.IoWorkItem) {
        VspFreeContext(Filter->Root, context);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IoMarkIrpPending(Irp);
    context->Dispatch.Irp = Irp;

    IoQueueWorkItem(context->Dispatch.IoWorkItem,
                    VspDeleteSnapshotWorker, DelayedWorkQueue, context);

    return STATUS_PENDING;
}

VOID
VspCheckCodeLocked(
    IN  PDO_EXTENSION   RootExtension
    )

{
    if (RootExtension->IsCodeLocked) {
        return;
    }

    VspAcquire(RootExtension);
    if (RootExtension->IsCodeLocked) {
        VspRelease(RootExtension);
        return;
    }

    MmLockPagableCodeSection(VspCheckCodeLocked);
    InterlockedExchange(&RootExtension->IsCodeLocked, TRUE);
    VspRelease(RootExtension);
}

NTSTATUS
VspSetMaxDiffAreaSize(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

{
    PIO_STACK_LOCATION          irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLSNAP_DIFF_AREA_SIZES    input = (PVOLSNAP_DIFF_AREA_SIZES) Irp->AssociatedIrp.SystemBuffer;
    KIRQL                       irql;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLSNAP_DIFF_AREA_SIZES)) {

        return STATUS_INVALID_PARAMETER;
    }

    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    Filter->MaximumVolumeSpace = input->MaximumVolumeSpace;
    KeReleaseSpinLock(&Filter->SpinLock, irql);

    return STATUS_SUCCESS;
}

NTSTATUS
VolSnapDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_DEVICE_CONTROL.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status;
    PVOLUME_EXTENSION   extension;

    if (filter->DeviceExtensionType == DEVICE_EXTENSION_FILTER) {

        if (filter->TargetObject->Characteristics&FILE_REMOVABLE_MEDIA) {
            IoSkipCurrentIrpStackLocation(Irp);
            return IoCallDriver(filter->TargetObject, Irp);
        }

        switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

            case IOCTL_VOLSNAP_FLUSH_AND_HOLD_WRITES:
                VspCheckCodeLocked(filter->Root);
                status = VspFlushAndHoldWrites(filter, Irp);
                break;

            case IOCTL_VOLSNAP_RELEASE_WRITES:
                VspCheckCodeLocked(filter->Root);
                status = VspReleaseWrites(filter);
                break;

            case IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT:
                VspCheckCodeLocked(filter->Root);
                status = VspPrepareForSnapshot(filter, Irp);
                break;

            case IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT:
                VspCheckCodeLocked(filter->Root);
                status = VspAbortPreparedSnapshot(filter, TRUE);
                break;

            case IOCTL_VOLSNAP_COMMIT_SNAPSHOT:
                VspCheckCodeLocked(filter->Root);
                status = VspCommitSnapshot(filter, Irp);
                break;

            case IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT:
                VspCheckCodeLocked(filter->Root);
                status = VspEndCommitSnapshot(filter, Irp);
                break;

            case IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS:
                VspCheckCodeLocked(filter->Root);
                status = VspQueryNamesOfSnapshots(filter, Irp);
                break;

            case IOCTL_VOLSNAP_CLEAR_DIFF_AREA:
                VspCheckCodeLocked(filter->Root);
                status = VspClearDiffArea(filter, Irp);
                break;

            case IOCTL_VOLSNAP_ADD_VOLUME_TO_DIFF_AREA:
                VspCheckCodeLocked(filter->Root);
                status = VspAddVolumeToDiffArea(filter, Irp);
                break;

            case IOCTL_VOLSNAP_QUERY_DIFF_AREA:
                VspCheckCodeLocked(filter->Root);
                status = VspQueryDiffArea(filter, Irp);
                break;

            case IOCTL_VOLSNAP_SET_MAX_DIFF_AREA_SIZE:
                VspCheckCodeLocked(filter->Root);
                status = VspSetMaxDiffAreaSize(filter, Irp);
                break;

            case IOCTL_VOLSNAP_QUERY_DIFF_AREA_SIZES:
                VspCheckCodeLocked(filter->Root);
                status = VspQueryDiffAreaSize(filter, Irp);
                break;

            case IOCTL_VOLSNAP_DELETE_OLDEST_SNAPSHOT:
            case IOCTL_VOLSNAP_DELETE_SNAPSHOT:
                VspCheckCodeLocked(filter->Root);
                status = VspDeleteSnapshotPost(filter, Irp);
                break;

            case IOCTL_VOLSNAP_AUTO_CLEANUP:
                VspCheckCodeLocked(filter->Root);
                status = VspAutoCleanup(filter, Irp);
                break;

            default:
                IoSkipCurrentIrpStackLocation(Irp);
                return IoCallDriver(filter->TargetObject, Irp);

        }

        if (status == STATUS_PENDING) {
            return status;
        }

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    ASSERT(filter->DeviceExtensionType == DEVICE_EXTENSION_VOLUME);

    extension = (PVOLUME_EXTENSION) filter;

    if (!extension->IsStarted) {
        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NO_SUCH_DEVICE;
    }

    status = VspIncrementVolumeRefCount(extension, Irp, NULL);
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    if (status == STATUS_PENDING) {
        return status;
    }

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME:
            status = VspQueryOriginalVolumeName(extension, Irp);
            break;

        case IOCTL_VOLSNAP_QUERY_CONFIG_INFO:
            status = VspQueryConfigInfo(extension, Irp);
            break;

        case IOCTL_VOLSNAP_SET_APPLICATION_INFO:
            status = VspSetApplicationInfo(extension, Irp);
            break;

        case IOCTL_VOLSNAP_QUERY_APPLICATION_INFO:
            status = VspQueryApplicationInfo(extension, Irp);
            break;

        case IOCTL_VOLUME_QUERY_VOLUME_NUMBER:
            status = VspQueryVolumeNumber(extension, Irp);
            break;

        case IOCTL_DISK_SET_PARTITION_INFO:
            status = STATUS_SUCCESS;
            break;

        case IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS:
        case IOCTL_DISK_VERIFY:
        case IOCTL_DISK_GET_PARTITION_INFO:
        case IOCTL_DISK_GET_PARTITION_INFO_EX:
        case IOCTL_DISK_GET_LENGTH_INFO:
        case IOCTL_DISK_GET_DRIVE_GEOMETRY:
        case IOCTL_DISK_CHECK_VERIFY:
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp, VspVolumeRefCountCompletionRoutine,
                                   extension, TRUE, TRUE, TRUE);
            IoMarkIrpPending(Irp);

            IoCallDriver(extension->Filter->TargetObject, Irp);

            return STATUS_PENDING;

        case IOCTL_DISK_IS_WRITABLE:
            status = STATUS_MEDIA_WRITE_PROTECTED;
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;

    }

    VspDecrementVolumeRefCount(extension);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS
VspQueryBusRelations(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

{
    ULONG               numVolumes;
    PLIST_ENTRY         l;
    NTSTATUS            status;
    PDEVICE_RELATIONS   deviceRelations, newRelations;
    ULONG               size, i;
    PVOLUME_EXTENSION   extension;

    numVolumes = 0;
    for (l = Filter->VolumeList.Flink; l != &Filter->VolumeList;
         l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        if (!extension->HasEndCommit) {
            continue;
        }
        InterlockedExchange(&extension->AliveToPnp, TRUE);
        numVolumes++;
    }

    status = Irp->IoStatus.Status;

    if (!numVolumes) {
        if (NT_SUCCESS(status)) {
            return status;
        }

        newRelations = (PDEVICE_RELATIONS)
                       ExAllocatePoolWithTag(PagedPool,
                                             sizeof(DEVICE_RELATIONS),
                                             VOLSNAP_TAG_RELATIONS);
        if (!newRelations) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(newRelations, sizeof(DEVICE_RELATIONS));
        newRelations->Count = 0;
        Irp->IoStatus.Information = (ULONG_PTR) newRelations;

        while (!IsListEmpty(&Filter->DeadVolumeList)) {
            l = RemoveHeadList(&Filter->DeadVolumeList);
            extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
            InterlockedExchange(&extension->DeadToPnp, TRUE);
        }

        return STATUS_SUCCESS;
    }

    if (NT_SUCCESS(status)) {
        deviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;
        size = FIELD_OFFSET(DEVICE_RELATIONS, Objects) +
               (numVolumes + deviceRelations->Count)*sizeof(PDEVICE_OBJECT);
        newRelations = (PDEVICE_RELATIONS)
                       ExAllocatePoolWithTag(PagedPool, size,
                                             VOLSNAP_TAG_RELATIONS);
        if (!newRelations) {
            for (i = 0; i < deviceRelations->Count; i++) {
                ObDereferenceObject(deviceRelations->Objects[i]);
            }
            ExFreePool(deviceRelations);
            Irp->IoStatus.Information = 0;
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        newRelations->Count = numVolumes + deviceRelations->Count;
        RtlCopyMemory(newRelations->Objects, deviceRelations->Objects,
                      deviceRelations->Count*sizeof(PDEVICE_OBJECT));
        i = deviceRelations->Count;
        ExFreePool(deviceRelations);

    } else {

        size = sizeof(DEVICE_RELATIONS) + numVolumes*sizeof(PDEVICE_OBJECT);
        newRelations = (PDEVICE_RELATIONS)
                       ExAllocatePoolWithTag(PagedPool, size,
                                             VOLSNAP_TAG_RELATIONS);
        if (!newRelations) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        newRelations->Count = numVolumes;
        i = 0;
    }

    numVolumes = 0;
    for (l = Filter->VolumeList.Flink; l != &Filter->VolumeList;
         l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        if (!extension->HasEndCommit) {
            continue;
        }
        newRelations->Objects[i + numVolumes++] = extension->DeviceObject;
        ObReferenceObject(extension->DeviceObject);
    }

    Irp->IoStatus.Information = (ULONG_PTR) newRelations;

    while (!IsListEmpty(&Filter->DeadVolumeList)) {
        l = RemoveHeadList(&Filter->DeadVolumeList);
        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        InterlockedExchange(&extension->DeadToPnp, TRUE);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VspQueryId(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    UNICODE_STRING      string;
    NTSTATUS            status;
    WCHAR               buffer[100];
    PWSTR               id;

    switch (irpSp->Parameters.QueryId.IdType) {

        case BusQueryDeviceID:
            RtlInitUnicodeString(&string, L"STORAGE\\VolumeSnapshot");
            break;

        case BusQueryHardwareIDs:
            RtlInitUnicodeString(&string, L"STORAGE\\VolumeSnapshot");
            break;

        case BusQueryInstanceID:
            swprintf(buffer, L"HarddiskVolumeSnapshot%d",
                     Extension->VolumeNumber);
            RtlInitUnicodeString(&string, buffer);
            break;

        default:
            return STATUS_NOT_SUPPORTED;

    }

    id = (PWSTR) ExAllocatePoolWithTag(PagedPool,
                                       string.Length + 2*sizeof(WCHAR),
                                       VOLSNAP_TAG_PNP_ID);
    if (!id) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(id, string.Buffer, string.Length);
    id[string.Length/sizeof(WCHAR)] = 0;
    id[string.Length/sizeof(WCHAR) + 1] = 0;

    Irp->IoStatus.Information = (ULONG_PTR) id;

    return STATUS_SUCCESS;
}

VOID
VspDeleteDiffAreaFilesWorker(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PVOID           WorkItem
    )

{
    NTSTATUS                        status;
    UNICODE_STRING                  name, fileName;
    OBJECT_ATTRIBUTES               oa;
    HANDLE                          h, fileHandle;
    IO_STATUS_BLOCK                 ioStatus;
    PFILE_NAMES_INFORMATION         fileNamesInfo;
    CHAR                            buffer[200];
    FILE_DISPOSITION_INFORMATION    dispInfo;
    BOOLEAN                         restartScan;
    LARGE_INTEGER                   timeout;

    status = VspCreateDiffAreaFileName(DeviceObject, (ULONG) -1, &name);
    if (!NT_SUCCESS(status)) {
        IoFreeWorkItem((PIO_WORKITEM) WorkItem);
        return;
    }

    name.Length -= 39*sizeof(WCHAR);
    InitializeObjectAttributes(&oa, &name, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = ZwOpenFile(&h, FILE_LIST_DIRECTORY | SYNCHRONIZE, &oa, &ioStatus,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);
    if (!NT_SUCCESS(status)) {
        ExFreePool(name.Buffer);
        IoFreeWorkItem((PIO_WORKITEM) WorkItem);
        return;
    }

    fileName.Buffer = &name.Buffer[name.Length/sizeof(WCHAR)];
    fileName.Length = 39*sizeof(WCHAR);
    fileName.MaximumLength = fileName.Length + sizeof(WCHAR);

    fileNamesInfo = (PFILE_NAMES_INFORMATION) buffer;
    dispInfo.DeleteFile = TRUE;

    restartScan = TRUE;
    for (;;) {

        status = ZwQueryDirectoryFile(h, NULL, NULL, NULL, &ioStatus,
                                      fileNamesInfo, 200, FileNamesInformation,
                                      TRUE, restartScan ? &fileName : NULL,
                                      restartScan);

        if (!NT_SUCCESS(status)) {
            break;
        }

        fileName.Length = fileName.MaximumLength =
                (USHORT) fileNamesInfo->FileNameLength;
        fileName.Buffer = fileNamesInfo->FileName;

        InitializeObjectAttributes(&oa, &fileName, OBJ_CASE_INSENSITIVE, h,
                                   NULL);

        status = ZwOpenFile(&fileHandle, DELETE, &oa, &ioStatus,
                            FILE_SHARE_DELETE | FILE_SHARE_READ |
                            FILE_SHARE_WRITE, FILE_NON_DIRECTORY_FILE);
        if (!NT_SUCCESS(status)) {
            continue;
        }

        ZwSetInformationFile(fileHandle, &ioStatus, &dispInfo,
                             sizeof(dispInfo), FileDispositionInformation);

        ZwClose(fileHandle);
        restartScan = FALSE;
    }

    ZwClose(h);
    ExFreePool(name.Buffer);
    IoFreeWorkItem((PIO_WORKITEM) WorkItem);
}

NTSTATUS
VolSnapPnp(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_PNP.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PFILTER_EXTENSION       filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_OBJECT          targetObject;
    KEVENT                  event;
    NTSTATUS                status;
    PVOLUME_EXTENSION       extension;
    BOOLEAN                 deletePdo;
    PDEVICE_RELATIONS       deviceRelations;
    PDEVICE_CAPABILITIES    capabilities;
    KIRQL                   irql;
    PIRP                    irp;
    DEVICE_INSTALL_STATE    deviceInstallState;
    ULONG                   bytes;
    PVSP_CONTEXT            context;

    if (filter->DeviceExtensionType == DEVICE_EXTENSION_FILTER) {

        switch (irpSp->MinorFunction) {

            case IRP_MN_REMOVE_DEVICE:
            case IRP_MN_SURPRISE_REMOVAL:

                VspCleanupFilter(filter);

                targetObject = filter->TargetObject;
                if (irpSp->MinorFunction == IRP_MN_REMOVE_DEVICE) {
                    IoDetachDevice(targetObject);
                    IoDeleteDevice(filter->DeviceObject);
                }

                IoSkipCurrentIrpStackLocation(Irp);
                return IoCallDriver(targetObject, Irp);

            case IRP_MN_QUERY_DEVICE_RELATIONS:
                switch (irpSp->Parameters.QueryDeviceRelations.Type) {
                    case BusRelations:
                        break;

                    default:
                        IoSkipCurrentIrpStackLocation(Irp);
                        return IoCallDriver(filter->TargetObject, Irp);
                }

                KeInitializeEvent(&event, NotificationEvent, FALSE);
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp, VspSignalCompletion,
                                       &event, TRUE, TRUE, TRUE);
                IoCallDriver(filter->TargetObject, Irp);
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                      NULL);

                VspAcquire(filter->Root);
                switch (irpSp->Parameters.QueryDeviceRelations.Type) {
                    case BusRelations:
                        status = VspQueryBusRelations(filter, Irp);
                        break;

                }
                VspRelease(filter->Root);
                break;

            default:
                IoSkipCurrentIrpStackLocation(Irp);
                return IoCallDriver(filter->TargetObject, Irp);

        }

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    ASSERT(filter->DeviceExtensionType == DEVICE_EXTENSION_VOLUME);
    extension = (PVOLUME_EXTENSION) filter;

    switch (irpSp->MinorFunction) {

        case IRP_MN_START_DEVICE:
            filter = extension->Filter;
            if (extension->IsDead) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }
            InterlockedExchange(&extension->IsStarted, TRUE);

            status = IoGetDeviceProperty(extension->DeviceObject,
                                         DevicePropertyInstallState,
                                         sizeof(deviceInstallState),
                                         &deviceInstallState, &bytes);
            if (!NT_SUCCESS(status) ||
                deviceInstallState != InstallStateInstalled) {

                status = STATUS_SUCCESS;
                break;
            }

            VspAcquire(extension->Root);
            extension->IsInstalled = TRUE;
            if (extension->ListEntry.Flink != &filter->VolumeList) {
                KeAcquireSpinLock(&extension->SpinLock, &irql);
                if (extension->IgnorableProduct) {
                    ExFreePool(extension->IgnorableProduct->Buffer);
                    ExFreePool(extension->IgnorableProduct);
                    extension->IgnorableProduct = NULL;
                }
                KeReleaseSpinLock(&extension->SpinLock, irql);
                VspRelease(extension->Root);
                break;
            }

            if (!KeCancelTimer(&filter->EndCommitTimer)) {
                VspRelease(extension->Root);
                break;
            }
            VspRelease(extension->Root);

            context = VspAllocateContext(filter->Root);
            if (!context) {
                KeSetEvent(&filter->EndCommitProcessCompleted, IO_NO_INCREMENT,
                           FALSE);
                ObDereferenceObject(filter->DeviceObject);
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            ObReferenceObject(extension->DeviceObject);

            context->Type = VSP_CONTEXT_TYPE_EXTENSION;
            context->Extension.Extension = extension;
            context->Extension.Irp = NULL;
            ExInitializeWorkItem(&context->WorkItem,
                                 VspSetIgnorableBlocksInBitmapWorker, context);
            VspQueueWorkItem(filter->Root, &context->WorkItem, 0);
            break;

        case IRP_MN_QUERY_REMOVE_DEVICE:
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_STOP_DEVICE:
            status = STATUS_UNSUCCESSFUL;
            break;

        case IRP_MN_CANCEL_STOP_DEVICE:
        case IRP_MN_QUERY_RESOURCES:
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            status = STATUS_SUCCESS;
            break;

        case IRP_MN_REMOVE_DEVICE:
        case IRP_MN_SURPRISE_REMOVAL:
            InterlockedExchange(&extension->IsStarted, FALSE);

            if (irpSp->MinorFunction == IRP_MN_REMOVE_DEVICE) {
                if (extension->DeadToPnp && !extension->DeviceDeleted) {
                    InterlockedExchange(&extension->DeviceDeleted, TRUE);
                    deletePdo = TRUE;
                } else {
                    deletePdo = FALSE;
                }
            } else {
                deletePdo = FALSE;
            }

            if (deletePdo) {
                IoDeleteDevice(extension->DeviceObject);
            }
            status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:
            if (irpSp->Parameters.QueryDeviceRelations.Type !=
                TargetDeviceRelation) {

                status = STATUS_NOT_SUPPORTED;
                break;
            }

            deviceRelations = (PDEVICE_RELATIONS)
                              ExAllocatePoolWithTag(PagedPool,
                                                    sizeof(DEVICE_RELATIONS),
                                                    VOLSNAP_TAG_RELATIONS);
            if (!deviceRelations) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            ObReferenceObject(DeviceObject);
            deviceRelations->Count = 1;
            deviceRelations->Objects[0] = DeviceObject;
            Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
            status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_CAPABILITIES:
            capabilities = irpSp->Parameters.DeviceCapabilities.Capabilities;
            capabilities->SilentInstall = 1;
            capabilities->SurpriseRemovalOK = 1;
            capabilities->RawDeviceOK = 1;
            capabilities->Address = extension->VolumeNumber;
            status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_ID:
            status = VspQueryId(extension, Irp);
            break;

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            Irp->IoStatus.Information = PNP_DEVICE_DONT_DISPLAY_IN_UI;
            status = STATUS_SUCCESS;
            break;

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        default:
            status = STATUS_NOT_SUPPORTED;
            break;

    }

    if (status == STATUS_NOT_SUPPORTED) {
        status = Irp->IoStatus.Status;
    } else {
        Irp->IoStatus.Status = status;
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

VOID
VspWorkerThread(
    IN  PVOID   Context
    )

/*++

Routine Description:

    This is a worker thread to process work queue items.

Arguments:

    RootExtension   - Supplies the root device extension.

Return Value:

    None.

--*/

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PDO_EXTENSION       rootExtension = context->ThreadCreation.RootExtension;
    ULONG               queueNumber = context->ThreadCreation.QueueNumber;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PWORK_QUEUE_ITEM    queueItem;

    ASSERT(queueNumber < NUMBER_OF_THREAD_POOLS);
    ASSERT(context->Type == VSP_CONTEXT_TYPE_THREAD_CREATION);

    VspFreeContext(rootExtension, context);

    if (!queueNumber) {
        KeSetPriorityThread(KeGetCurrentThread(), 20);
    }

    for (;;) {

        KeWaitForSingleObject(&rootExtension->WorkerSemaphore[queueNumber],
                              Executive, KernelMode, FALSE, NULL);

        KeAcquireSpinLock(&rootExtension->SpinLock[queueNumber], &irql);
        if (IsListEmpty(&rootExtension->WorkerQueue[queueNumber])) {
            KeReleaseSpinLock(&rootExtension->SpinLock[queueNumber], irql);
            ASSERT(!rootExtension->ThreadsRefCount);
            PsTerminateSystemThread(STATUS_SUCCESS);
            return;
        }
        l = RemoveHeadList(&rootExtension->WorkerQueue[queueNumber]);
        KeReleaseSpinLock(&rootExtension->SpinLock[queueNumber], irql);

        queueItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
        queueItem->WorkerRoutine(queueItem->Parameter);
    }
}

NTSTATUS
VolSnapTargetDeviceNotification(
    IN  PVOID   NotificationStructure,
    IN  PVOID   Filter
    )

{
    PTARGET_DEVICE_REMOVAL_NOTIFICATION notification = (PTARGET_DEVICE_REMOVAL_NOTIFICATION) NotificationStructure;
    PFILTER_EXTENSION                   filter = (PFILTER_EXTENSION) Filter;
    PLIST_ENTRY                         l;
    PVSP_DIFF_AREA_FILE                 diffAreaFile;
    PFILTER_EXTENSION                   f;
    LIST_ENTRY                          listOfDiffAreaFilesToClose;
    LIST_ENTRY                          listOfDeviceObjectsToDelete;

    if (IsEqualGUID(notification->Event,
                    GUID_TARGET_DEVICE_REMOVE_COMPLETE)) {

        if (filter->TargetDeviceNotificationEntry) {
            IoUnregisterPlugPlayNotification(
                    filter->TargetDeviceNotificationEntry);
            filter->TargetDeviceNotificationEntry = NULL;
        }
        return STATUS_SUCCESS;
    }

    if (!IsEqualGUID(notification->Event, GUID_IO_VOLUME_DISMOUNT)) {
        return STATUS_SUCCESS;
    }

    InitializeListHead(&listOfDiffAreaFilesToClose);
    InitializeListHead(&listOfDeviceObjectsToDelete);

    VspAcquire(filter->Root);

    while (!IsListEmpty(&filter->DiffAreaFilesOnThisFilter)) {

        l = filter->DiffAreaFilesOnThisFilter.Flink;
        diffAreaFile = CONTAINING_RECORD(l, VSP_DIFF_AREA_FILE,
                                         FilterListEntry);

        f = diffAreaFile->Extension->Filter;

        VspLogError(diffAreaFile->Extension, diffAreaFile->Filter,
                    VS_ABORT_SNAPSHOTS_DISMOUNT, STATUS_SUCCESS, 0);

        VspAbortPreparedSnapshot(f, FALSE);

        while (!IsListEmpty(&f->VolumeList)) {
            VspDeleteOldestSnapshot(f, &listOfDiffAreaFilesToClose,
                                    &listOfDeviceObjectsToDelete);
        }
    }

    VspRelease(filter->Root);

    VspCloseDiffAreaFiles(&listOfDiffAreaFilesToClose,
                          &listOfDeviceObjectsToDelete);

    return STATUS_SUCCESS;
}

NTSTATUS
VolSnapVolumeDeviceNotification(
    IN  PVOID   NotificationStructure,
    IN  PVOID   RootExtension
    )

/*++

Routine Description:

    This routine is called whenever a volume comes or goes.

Arguments:

    NotificationStructure   - Supplies the notification structure.

    RootExtension           - Supplies the root extension.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_INTERFACE_CHANGE_NOTIFICATION   notification = (PDEVICE_INTERFACE_CHANGE_NOTIFICATION) NotificationStructure;
    PDO_EXTENSION                           root = (PDO_EXTENSION) RootExtension;
    BOOLEAN                                 errorMode;
    NTSTATUS                                status;
    PFILE_OBJECT                            fileObject;
    PDEVICE_OBJECT                          deviceObject;
    PIO_WORKITEM                            workItem;
    PFILTER_EXTENSION                       filter;

    if (!IsEqualGUID(notification->Event, GUID_DEVICE_INTERFACE_ARRIVAL)) {
        return STATUS_SUCCESS;
    }

    errorMode = PsGetThreadHardErrorsAreDisabled(PsGetCurrentThread());
    PsSetThreadHardErrorsAreDisabled(PsGetCurrentThread(), TRUE);

    status = IoGetDeviceObjectPointer(notification->SymbolicLinkName,
                                      FILE_READ_ATTRIBUTES, &fileObject,
                                      &deviceObject);
    if (!NT_SUCCESS(status)) {
        PsSetThreadHardErrorsAreDisabled(PsGetCurrentThread(), errorMode);
        return STATUS_SUCCESS;
    }

    if (fileObject->DeviceObject->Characteristics&FILE_REMOVABLE_MEDIA) {
        ObDereferenceObject(fileObject);
        PsSetThreadHardErrorsAreDisabled(PsGetCurrentThread(), errorMode);
        return STATUS_SUCCESS;
    }

    VspAcquire(root);

    filter = VspFindFilter(root, NULL, NULL, fileObject);
    if (!filter || filter->TargetDeviceNotificationEntry) {
        ObDereferenceObject(fileObject);
        PsSetThreadHardErrorsAreDisabled(PsGetCurrentThread(), errorMode);
        VspRelease(root);
        return STATUS_SUCCESS;
    }

    ObReferenceObject(filter->DeviceObject);

    VspRelease(root);

    status = IoRegisterPlugPlayNotification(
             EventCategoryTargetDeviceChange, 0, fileObject,
             root->DriverObject, VolSnapTargetDeviceNotification, filter,
             &filter->TargetDeviceNotificationEntry);

    ObDereferenceObject(filter->DeviceObject);

    if (!NT_SUCCESS(status)) {
        ObDereferenceObject(fileObject);
        PsSetThreadHardErrorsAreDisabled(PsGetCurrentThread(), errorMode);
        return STATUS_SUCCESS;
    }

    workItem = IoAllocateWorkItem(deviceObject);
    if (workItem) {
        IoQueueWorkItem(workItem, VspDeleteDiffAreaFilesWorker,
                        DelayedWorkQueue, workItem);
    }

    ObDereferenceObject(fileObject);
    PsSetThreadHardErrorsAreDisabled(PsGetCurrentThread(), errorMode);

    return STATUS_SUCCESS;
}

VOID
VspWaitToRegisterWorker(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PDO_EXTENSION       rootExtension = context->RootExtension.RootExtension;
    UNICODE_STRING      volumeSafeEventName;
    OBJECT_ATTRIBUTES   oa;
    KEVENT              event;
    LARGE_INTEGER       timeout;
    ULONG               i;
    NTSTATUS            status;
    HANDLE              volumeSafeEvent;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_ROOT_EXTENSION);

    VspFreeContext(rootExtension, context);

    RtlInitUnicodeString(&volumeSafeEventName,
                         L"\\Device\\VolumesSafeForWriteAccess");
    InitializeObjectAttributes(&oa, &volumeSafeEventName,
                               OBJ_CASE_INSENSITIVE, NULL, NULL);
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    timeout.QuadPart = -10*1000*1000;   // 1 second

    for (i = 0; i < 1000; i++) {
        status = ZwOpenEvent(&volumeSafeEvent, EVENT_ALL_ACCESS, &oa);
        if (NT_SUCCESS(status)) {
            break;
        }
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, &timeout);
    }
    if (i == 1000) {
        return;
    }

    ZwWaitForSingleObject(volumeSafeEvent, FALSE, NULL);
    ZwClose(volumeSafeEvent);

    if (rootExtension->NotificationEntry) {
        return;
    }

    IoRegisterPlugPlayNotification(
            EventCategoryDeviceInterfaceChange,
            PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES,
            (PVOID) &GUID_IO_VOLUME_DEVICE_INTERFACE,
            rootExtension->DriverObject, VolSnapVolumeDeviceNotification,
            rootExtension, &rootExtension->NotificationEntry);
}

VOID
VspDriverReinit(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PVOID           RootExtension,
    IN  ULONG           Count
    )

/*++

Routine Description:

    This routine is called after all of the boot drivers are loaded and it
    checks to make sure that we did not boot off of the stale half of a
    mirror.

Arguments:

    DriverObject    - Supplies the drive object.

    RootExtension   - Supplies the root extension.

    Count           - Supplies the count.

Return Value:

    None.

--*/

{
    PDO_EXTENSION   rootExtension = (PDO_EXTENSION) RootExtension;
    PVSP_CONTEXT    context;

    context = VspAllocateContext(rootExtension);
    if (!context) {
        return;
    }

    context->Type = VSP_CONTEXT_TYPE_ROOT_EXTENSION;
    context->RootExtension.RootExtension = rootExtension;
    ExInitializeWorkItem(&context->WorkItem, VspWaitToRegisterWorker, context);

    ExQueueWorkItem(&context->WorkItem, DelayedWorkQueue);
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif

#if DBG

#define NUMBER_OF_TRACE_ENTRIES (0x100)

VSP_TRACE_STRUCTURE TraceStructures[NUMBER_OF_TRACE_ENTRIES];
LONG CurrentTraceStructure;

PVSP_TRACE_STRUCTURE
VspAllocateTraceStructure(
    )

{
    LONG    next;

    next = InterlockedIncrement(&CurrentTraceStructure);

    return &TraceStructures[next&0xFF];
}

#endif // DBG

NTSTATUS
VspSignalCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Event
    )

{
    KeSetEvent((PKEVENT) Event, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
VspReleaseWrites(
    IN  PFILTER_EXTENSION   Filter
    )

/*++

Routine Description:

    This routine releases previously queued writes.  If the writes have
    already been dequeued by a timeout of have never actually been queued
    for some other reason then this routine fails.

Arguments:

    Filter  - Supplies the filter extension.

    Irp     - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    KIRQL               irql;
    LIST_ENTRY          q;
    PLIST_ENTRY         l;
    PIRP                irp;
    BOOLEAN             emptyQueue;

    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    if (!Filter->HoldIncomingWrites || !Filter->TimerIsSet) {
        KeReleaseSpinLock(&Filter->SpinLock, irql);
        return STATUS_INVALID_PARAMETER;
    }

    if (!KeCancelTimer(&Filter->HoldWritesTimer)) {
        KeReleaseSpinLock(&Filter->SpinLock, irql);
        return STATUS_INVALID_PARAMETER;
    }

    IoStopTimer(Filter->DeviceObject);

    InterlockedIncrement(&Filter->RefCount);
    InterlockedExchange(&Filter->TimerIsSet, FALSE);
    InterlockedExchange(&Filter->HoldIncomingWrites, FALSE);
    if (IsListEmpty(&Filter->HoldQueue)) {
        emptyQueue = FALSE;
    } else {
        emptyQueue = TRUE;
        q = Filter->HoldQueue;
        InitializeListHead(&Filter->HoldQueue);
    }
    KeReleaseSpinLock(&Filter->SpinLock, irql);

    if (emptyQueue) {
        q.Blink->Flink = &q;
        q.Flink->Blink = &q;
        VspEmptyIrpQueue(Filter->Root->DriverObject, &q);
    }

    return STATUS_SUCCESS;
}

VOID
VspDecrementRefCount(
    IN  PFILTER_EXTENSION   Filter
    )

{
    KIRQL               irql;
    ZERO_REF_CALLBACK   callback;

    if (InterlockedDecrement(&Filter->RefCount)) {
        return;
    }

    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    callback = Filter->ZeroRefCallback;
    Filter->ZeroRefCallback = NULL;
    KeReleaseSpinLock(&Filter->SpinLock, irql);

    if (callback) {
        callback(Filter);
    }
}

VOID
VspCleanupFilter(
    IN  PFILTER_EXTENSION   Filter
    )

/*++

Routine Description:

    This routine cleans up filter extension data because of an IRP_MN_REMOVE.

Arguments:

    Filter  - Supplies the filter extension.

Return Value:

    None.

--*/

{
    KIRQL                   irql;
    PIRP                    irp;
    PVOLUME_EXTENSION       extension;
    PLIST_ENTRY             l, ll;
    PVSP_DIFF_AREA_FILE     diffAreaFile;
    PVSP_DIFF_AREA_VOLUME   diffAreaVolume;
    PFILTER_EXTENSION       f;
    LIST_ENTRY              listOfDiffAreaFilesToClose;
    LIST_ENTRY              listOfDeviceObjectsToDelete;
    PVSP_CONTEXT            context;

    IoAcquireCancelSpinLock(&irql);
    irp = Filter->FlushAndHoldIrp;
    if (irp) {
        irp->CancelIrql = irql;
        IoSetCancelRoutine(irp, NULL);
        VspCancelRoutine(Filter->DeviceObject, irp);
    } else {
        IoReleaseCancelSpinLock(irql);
    }

    VspReleaseWrites(Filter);

    VspAcquire(Filter->Root);
    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    extension = Filter->PreparedSnapshot;
    Filter->PreparedSnapshot = NULL;
    KeReleaseSpinLock(&Filter->SpinLock, irql);
    VspRelease(Filter->Root);

    if (extension) {
        VspCleanupInitialSnapshot(extension, TRUE);
    }

    KeWaitForSingleObject(&Filter->Root->ThreadsRefCountSemaphore, Executive,
                          KernelMode, FALSE, NULL);
    if (Filter->Root->ThreadsRefCount) {
        if (Filter->SnapshotsPresent) {
            context = VspAllocateContext(Filter->Root);
            if (context) {
                context->Type = VSP_CONTEXT_TYPE_ERROR_LOG;
                context->ErrorLog.Extension = NULL;
                context->ErrorLog.DiffAreaFilter = Filter;
                context->ErrorLog.SpecificIoStatus =
                        VS_ABORT_SNAPSHOT_VOLUME_REMOVED;
                context->ErrorLog.FinalStatus = STATUS_SUCCESS;
                context->ErrorLog.UniqueErrorValue = 0;

                ObReferenceObject(Filter->DeviceObject);

                VspLogErrorWorker(context);
            }
        }
        VspDestroyAllSnapshots(Filter, NULL);
    }
    KeReleaseSemaphore(&Filter->Root->ThreadsRefCountSemaphore,
                       IO_NO_INCREMENT, 1, FALSE);

    InitializeListHead(&listOfDiffAreaFilesToClose);
    InitializeListHead(&listOfDeviceObjectsToDelete);

    VspAcquire(Filter->Root);

    if (!Filter->NotInFilterList) {
        RemoveEntryList(&Filter->ListEntry);
        Filter->NotInFilterList = TRUE;
    }

    while (!IsListEmpty(&Filter->DiffAreaVolumes)) {
        l = RemoveHeadList(&Filter->DiffAreaVolumes);
        diffAreaVolume = CONTAINING_RECORD(l, VSP_DIFF_AREA_VOLUME, ListEntry);
        ExFreePool(diffAreaVolume);
    }

    for (l = Filter->Root->FilterList.Flink;
         l != &Filter->Root->FilterList; l = l->Flink) {

        f = CONTAINING_RECORD(l, FILTER_EXTENSION, ListEntry);

        for (ll = f->DiffAreaVolumes.Flink;
             ll != &f->DiffAreaVolumes; ll = ll->Flink) {

            diffAreaVolume = CONTAINING_RECORD(ll, VSP_DIFF_AREA_VOLUME,
                                               ListEntry);
            if (diffAreaVolume->Filter == Filter) {
                RemoveEntryList(ll);
                ExFreePool(diffAreaVolume);
                break;
            }
        }
    }

    while (!IsListEmpty(&Filter->DiffAreaFilesOnThisFilter)) {

        l = Filter->DiffAreaFilesOnThisFilter.Flink;
        diffAreaFile = CONTAINING_RECORD(l, VSP_DIFF_AREA_FILE,
                                         FilterListEntry);

        f = diffAreaFile->Extension->Filter;

        VspLogError(diffAreaFile->Extension, diffAreaFile->Filter,
                    VS_ABORT_SNAPSHOTS_DISMOUNT, STATUS_SUCCESS, 0);

        VspAbortPreparedSnapshot(f, FALSE);

        while (!IsListEmpty(&f->VolumeList)) {
            VspDeleteOldestSnapshot(f, &listOfDiffAreaFilesToClose,
                                    &listOfDeviceObjectsToDelete);
        }
    }

    VspRelease(Filter->Root);

    VspCloseDiffAreaFiles(&listOfDiffAreaFilesToClose,
                          &listOfDeviceObjectsToDelete);
}

NTSTATUS
VolSnapPower(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_POWER.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status;


    if (filter->DeviceExtensionType == DEVICE_EXTENSION_FILTER) {
        PoStartNextPowerIrp(Irp);
        IoSkipCurrentIrpStackLocation(Irp);
        return PoCallDriver(filter->TargetObject, Irp);
    }

    ASSERT(filter->DeviceExtensionType == DEVICE_EXTENSION_VOLUME);

    switch (irpSp->MinorFunction) {
        case IRP_MN_WAIT_WAKE:
        case IRP_MN_POWER_SEQUENCE:
        case IRP_MN_SET_POWER:
        case IRP_MN_QUERY_POWER:
            status = STATUS_SUCCESS;
            break;

        default:
            status = Irp->IoStatus.Status;
            break;

    }

    Irp->IoStatus.Status = status;
    PoStartNextPowerIrp(Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS
VolSnapRead(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_READ.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;
    NTSTATUS            status;
    PVOLUME_EXTENSION   extension;
    KIRQL               irql;

    if (filter->DeviceExtensionType == DEVICE_EXTENSION_FILTER) {
        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver(filter->TargetObject, Irp);
    }

    ASSERT(filter->DeviceExtensionType == DEVICE_EXTENSION_VOLUME);

    extension = (PVOLUME_EXTENSION) filter;
    filter = extension->Filter;

    if (!extension->IsStarted) {
        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NO_SUCH_DEVICE;
    }

    status = VspIncrementVolumeRefCount(extension, Irp, NULL);
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    if (status == STATUS_PENDING) {
        return status;
    }

    IoMarkIrpPending(Irp);

    KeAcquireSpinLock(&extension->SpinLock, &irql);
    if (VspAreBitsSet(extension, Irp)) {
        KeReleaseSpinLock(&extension->SpinLock, irql);

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = IoGetCurrentIrpStackLocation(Irp)->
                                    Parameters.Read.Length;
        VspReadCompletionForReadSnapshot(DeviceObject, Irp, extension);
        return STATUS_PENDING;
    }
    KeReleaseSpinLock(&extension->SpinLock, irql);

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, VspReadCompletionForReadSnapshot,
                           extension, TRUE, TRUE, TRUE);
    IoCallDriver(filter->TargetObject, Irp);

    return STATUS_PENDING;
}

NTSTATUS
VspIncrementRefCount(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

{
    KIRQL   irql;

    InterlockedIncrement(&Filter->RefCount);
    if (!Filter->HoldIncomingWrites) {
        return STATUS_SUCCESS;
    }

    VspDecrementRefCount(Filter);

    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    if (!Filter->HoldIncomingWrites) {
        InterlockedIncrement(&Filter->RefCount);
        KeReleaseSpinLock(&Filter->SpinLock, irql);
        return STATUS_SUCCESS;
    }
    IoMarkIrpPending(Irp);
    InsertTailList(&Filter->HoldQueue, &Irp->Tail.Overlay.ListEntry);
    KeReleaseSpinLock(&Filter->SpinLock, irql);

    return STATUS_PENDING;
}

NTSTATUS
VspRefCountCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Filter
    )

{
    VspDecrementRefCount((PFILTER_EXTENSION) Filter);
    return STATUS_SUCCESS;
}

NTSTATUS
VolSnapWrite(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_WRITE.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;
    NTSTATUS            status;
    PVOLUME_EXTENSION   extension;
    KIRQL               irql;
    PLIST_ENTRY         l, ll;
    PVSP_DIFF_AREA_FILE diffAreaFile;
    PIO_STACK_LOCATION  nextSp;
    PVSP_CONTEXT        context;
    PDO_EXTENSION       rootExtension;

    if (filter->DeviceExtensionType == DEVICE_EXTENSION_VOLUME) {
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    ASSERT(filter->DeviceExtensionType == DEVICE_EXTENSION_FILTER);

    IoMarkIrpPending(Irp);

    status = VspIncrementRefCount(filter, Irp);
    if (status == STATUS_PENDING) {
        return status;
    }

    if (!filter->SnapshotsPresent) {
        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, VspRefCountCompletionRoutine, filter,
                               TRUE, TRUE, TRUE);
        IoCallDriver(filter->TargetObject, Irp);
        return STATUS_PENDING;
    }

    extension = CONTAINING_RECORD(filter->VolumeList.Blink,
                                  VOLUME_EXTENSION, ListEntry);

    KeAcquireSpinLock(&extension->SpinLock, &irql);
    if (VspAreBitsSet(extension, Irp)) {
        KeReleaseSpinLock(&extension->SpinLock, irql);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, VspRefCountCompletionRoutine, filter,
                               TRUE, TRUE, TRUE);
        IoCallDriver(filter->TargetObject, Irp);
        return STATUS_PENDING;
    }
    KeReleaseSpinLock(&extension->SpinLock, irql);

    context = VspAllocateContext(extension->Root);
    if (!context) {
        rootExtension = extension->Root;
        KeAcquireSpinLock(&rootExtension->ESpinLock, &irql);
        if (rootExtension->EmergencyContextInUse) {
            InsertTailList(&rootExtension->IrpWaitingList,
                           &Irp->Tail.Overlay.ListEntry);
            if (!rootExtension->IrpWaitingListNeedsChecking) {
                InterlockedExchange(
                        &rootExtension->IrpWaitingListNeedsChecking, TRUE);
            }
            KeReleaseSpinLock(&rootExtension->ESpinLock, irql);
            VspDecrementRefCount(filter);
            return STATUS_PENDING;
        }
        rootExtension->EmergencyContextInUse = TRUE;
        KeReleaseSpinLock(&rootExtension->ESpinLock, irql);

        context = rootExtension->EmergencyContext;
    }

    for (l = extension->ListOfDiffAreaFiles.Flink;
         l != &extension->ListOfDiffAreaFiles; l = l->Flink) {

        diffAreaFile = CONTAINING_RECORD(l, VSP_DIFF_AREA_FILE,
                                         VolumeListEntry);

        status = VspIncrementRefCount(diffAreaFile->Filter, Irp);
        if (status == STATUS_PENDING) {
            break;
        }
    }

    if (l != &extension->ListOfDiffAreaFiles) {

        for (ll = extension->ListOfDiffAreaFiles.Flink; ll != l;
             ll = ll->Flink) {

            diffAreaFile = CONTAINING_RECORD(ll, VSP_DIFF_AREA_FILE,
                                             VolumeListEntry);

            VspDecrementRefCount(diffAreaFile->Filter);
        }

        VspFreeContext(extension->Root, context);
        VspDecrementRefCount(filter);
        return STATUS_PENDING;
    }

    nextSp = IoGetNextIrpStackLocation(Irp);
    nextSp->Parameters.Write.Length = 1; // Use this for a ref count.

    context->Type = VSP_CONTEXT_TYPE_WRITE_VOLUME;
    context->WriteVolume.Extension = extension;
    context->WriteVolume.Irp = Irp;
    context->WriteVolume.RoundedStart = 0;
    ExInitializeWorkItem(&context->WorkItem, VspWriteVolume, context);
    VspAcquireNonPagedResource(extension, &context->WorkItem);

    return STATUS_PENDING;
}

NTSTATUS
VolSnapCleanup(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_CLEANUP.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    KEVENT              event;
    KIRQL               irql;
    PIRP                irp;
    PVSP_CONTEXT        context;

    if (filter->DeviceExtensionType == DEVICE_EXTENSION_VOLUME) {
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    ASSERT(filter->DeviceExtensionType == DEVICE_EXTENSION_FILTER);

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, VspSignalCompletion, &event, TRUE, TRUE, TRUE);
    IoCallDriver(filter->TargetObject, Irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    IoAcquireCancelSpinLock(&irql);
    if (filter->FlushAndHoldIrp) {
        irp = filter->FlushAndHoldIrp;
        if (IoGetCurrentIrpStackLocation(irp)->FileObject ==
            irpSp->FileObject) {

            irp->CancelIrql = irql;
            IoSetCancelRoutine(irp, NULL);
            VspCancelRoutine(DeviceObject, irp);
        } else {
            IoReleaseCancelSpinLock(irql);
        }
    } else {
        IoReleaseCancelSpinLock(irql);
    }

    IoAcquireCancelSpinLock(&irql);
    if (filter->AutoCleanupFileObject == irpSp->FileObject) {
        filter->AutoCleanupFileObject = NULL;
        IoReleaseCancelSpinLock(irql);

        if (!InterlockedExchange(&filter->DestroyAllSnapshotsPending, TRUE)) {
            context = &filter->DestroyContext;
            context->Type = VSP_CONTEXT_TYPE_FILTER;
            context->Filter.Filter = filter;
            ObReferenceObject(filter->DeviceObject);
            ExInitializeWorkItem(&context->WorkItem,
                                 VspDestroyAllSnapshotsWorker, context);
            ExQueueWorkItem(&context->WorkItem, DelayedWorkQueue);
        }

    } else {
        IoReleaseCancelSpinLock(irql);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is called when the driver loads loads.

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path.

Return Value:

    NTSTATUS

--*/

{
    ULONG               i;
    PDEVICE_OBJECT      deviceObject;
    NTSTATUS            status;
    PDO_EXTENSION       rootExtension;

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = VolSnapDefaultDispatch;
    }

    DriverObject->DriverExtension->AddDevice = VolSnapAddDevice;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = VolSnapCreate;
    DriverObject->MajorFunction[IRP_MJ_READ] = VolSnapRead;
    DriverObject->MajorFunction[IRP_MJ_WRITE] = VolSnapWrite;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = VolSnapDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = VolSnapCleanup;
    DriverObject->MajorFunction[IRP_MJ_PNP] = VolSnapPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = VolSnapPower;

    status = IoAllocateDriverObjectExtension(DriverObject, VolSnapAddDevice,
                                             sizeof(DO_EXTENSION),
                                             (PVOID*) &rootExtension);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    RtlZeroMemory(rootExtension, sizeof(DO_EXTENSION));
    rootExtension->DriverObject = DriverObject;
    InitializeListHead(&rootExtension->FilterList);
    InitializeListHead(&rootExtension->HoldIrps);
    KeInitializeTimer(&rootExtension->HoldTimer);
    KeInitializeDpc(&rootExtension->HoldTimerDpc, VspFsTimerDpc,
                    rootExtension);
    KeInitializeSemaphore(&rootExtension->Semaphore, 1, 1);

    for (i = 0; i < NUMBER_OF_THREAD_POOLS; i++) {
        InitializeListHead(&rootExtension->WorkerQueue[i]);
        KeInitializeSemaphore(&rootExtension->WorkerSemaphore[i], 0, MAXLONG);
        KeInitializeSpinLock(&rootExtension->SpinLock[i]);
    }

    KeInitializeSemaphore(&rootExtension->ThreadsRefCountSemaphore, 1, 1);

    IoRegisterDriverReinitialization(DriverObject, VspDriverReinit,
                                     rootExtension);

    ExInitializeNPagedLookasideList(&rootExtension->ContextLookasideList,
                                    NULL, NULL, 0, sizeof(VSP_CONTEXT),
                                    VOLSNAP_TAG_CONTEXT, 32);

    rootExtension->EmergencyContext = VspAllocateContext(rootExtension);
    if (!rootExtension->EmergencyContext) {
        ExDeleteNPagedLookasideList(&rootExtension->ContextLookasideList);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    InitializeListHead(&rootExtension->IrpWaitingList);
    KeInitializeSpinLock(&rootExtension->ESpinLock);

    ExInitializeNPagedLookasideList(&rootExtension->TempTableEntryLookasideList,
                                    NULL, NULL, 0, sizeof(RTL_BALANCED_LINKS) +
                                    sizeof(TEMP_TRANSLATION_TABLE_ENTRY),
                                    VOLSNAP_TAG_TEMP_TABLE, 32);

    rootExtension->EmergencyTableEntry =
            VspAllocateTempTableEntry(rootExtension);
    if (!rootExtension->EmergencyTableEntry) {
        ExFreeToNPagedLookasideList(&rootExtension->ContextLookasideList,
                                    rootExtension->EmergencyContext);
        ExDeleteNPagedLookasideList(
                &rootExtension->TempTableEntryLookasideList);
        ExDeleteNPagedLookasideList(&rootExtension->ContextLookasideList);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    InitializeListHead(&rootExtension->WorkItemWaitingList);

    rootExtension->RegistryPath.Length = RegistryPath->Length;
    rootExtension->RegistryPath.MaximumLength =
            rootExtension->RegistryPath.Length + sizeof(WCHAR);
    rootExtension->RegistryPath.Buffer = (PWSTR)
                                         ExAllocatePoolWithTag(PagedPool,
                                         rootExtension->RegistryPath.MaximumLength,
                                         VOLSNAP_TAG_SHORT_TERM);
    if (rootExtension->RegistryPath.Buffer) {
        RtlCopyMemory(rootExtension->RegistryPath.Buffer,
                      RegistryPath->Buffer, RegistryPath->Length);
        rootExtension->RegistryPath.Buffer[RegistryPath->Length/
                                           sizeof(WCHAR)] = 0;
    }

    InitializeListHead(&rootExtension->AdjustBitmapQueue);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\tools\spti\spti.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    spti.h

Abstract:

    These are the structures and defines that are used in the
    SPTI.C. 

Author:

Revision History:

--*/

typedef struct _SCSI_PASS_THROUGH_WITH_BUFFERS {
    SCSI_PASS_THROUGH spt;
    ULONG             Filler;      // realign buffers to double word boundary
    UCHAR             ucSenseBuf[32];
    UCHAR             ucDataBuf[512];
    } SCSI_PASS_THROUGH_WITH_BUFFERS, *PSCSI_PASS_THROUGH_WITH_BUFFERS;

typedef struct _SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER {
    SCSI_PASS_THROUGH_DIRECT sptd;
    ULONG             Filler;      // realign buffer to double word boundary
    UCHAR             ucSenseBuf[32];
    } SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER, *PSCSI_PASS_THROUGH_DIRECT_WITH_BUFFER;

VOID
PrintError(ULONG);

VOID
PrintDataBuffer(PUCHAR, ULONG);

VOID
PrintInquiryData(PVOID);

PUCHAR
AllocateAlignedBuffer(ULONG, ULONG);

VOID
PrintStatusResults(BOOL, DWORD, PSCSI_PASS_THROUGH_WITH_BUFFERS, ULONG);

VOID
PrintSenseInfo(PSCSI_PASS_THROUGH_WITH_BUFFERS);

//
// Command Descriptor Block constants.
//

#define CDB6GENERIC_LENGTH                   6
#define CDB10GENERIC_LENGTH                  10

#define SETBITON                             1
#define SETBITOFF                            0
//
// Mode Sense/Select page constants.
//

#define MODE_PAGE_ERROR_RECOVERY        0x01
#define MODE_PAGE_DISCONNECT            0x02
#define MODE_PAGE_FORMAT_DEVICE         0x03
#define MODE_PAGE_RIGID_GEOMETRY        0x04
#define MODE_PAGE_FLEXIBILE             0x05
#define MODE_PAGE_VERIFY_ERROR          0x07
#define MODE_PAGE_CACHING               0x08
#define MODE_PAGE_PERIPHERAL            0x09
#define MODE_PAGE_CONTROL               0x0A
#define MODE_PAGE_MEDIUM_TYPES          0x0B
#define MODE_PAGE_NOTCH_PARTITION       0x0C
#define MODE_SENSE_RETURN_ALL           0x3f
#define MODE_SENSE_CURRENT_VALUES       0x00
#define MODE_SENSE_CHANGEABLE_VALUES    0x40
#define MODE_SENSE_DEFAULT_VAULES       0x80
#define MODE_SENSE_SAVED_VALUES         0xc0
#define MODE_PAGE_DEVICE_CONFIG         0x10
#define MODE_PAGE_MEDIUM_PARTITION      0x11
#define MODE_PAGE_DATA_COMPRESS         0x0f

//
// SCSI CDB operation codes
//

#define SCSIOP_TEST_UNIT_READY     0x00
#define SCSIOP_REZERO_UNIT         0x01
#define SCSIOP_REWIND              0x01
#define SCSIOP_REQUEST_BLOCK_ADDR  0x02
#define SCSIOP_REQUEST_SENSE       0x03
#define SCSIOP_FORMAT_UNIT         0x04
#define SCSIOP_READ_BLOCK_LIMITS   0x05
#define SCSIOP_REASSIGN_BLOCKS     0x07
#define SCSIOP_READ6               0x08
#define SCSIOP_RECEIVE             0x08
#define SCSIOP_WRITE6              0x0A
#define SCSIOP_PRINT               0x0A
#define SCSIOP_SEND                0x0A
#define SCSIOP_SEEK6               0x0B
#define SCSIOP_TRACK_SELECT        0x0B
#define SCSIOP_SLEW_PRINT          0x0B
#define SCSIOP_SEEK_BLOCK          0x0C
#define SCSIOP_PARTITION           0x0D
#define SCSIOP_READ_REVERSE        0x0F
#define SCSIOP_WRITE_FILEMARKS     0x10
#define SCSIOP_FLUSH_BUFFER        0x10
#define SCSIOP_SPACE               0x11
#define SCSIOP_INQUIRY             0x12
#define SCSIOP_VERIFY6             0x13
#define SCSIOP_RECOVER_BUF_DATA    0x14
#define SCSIOP_MODE_SELECT         0x15
#define SCSIOP_RESERVE_UNIT        0x16
#define SCSIOP_RELEASE_UNIT        0x17
#define SCSIOP_COPY                0x18
#define SCSIOP_ERASE               0x19
#define SCSIOP_MODE_SENSE          0x1A
#define SCSIOP_START_STOP_UNIT     0x1B
#define SCSIOP_STOP_PRINT          0x1B
#define SCSIOP_LOAD_UNLOAD         0x1B
#define SCSIOP_RECEIVE_DIAGNOSTIC  0x1C
#define SCSIOP_SEND_DIAGNOSTIC     0x1D
#define SCSIOP_MEDIUM_REMOVAL      0x1E
#define SCSIOP_READ_CAPACITY       0x25
#define SCSIOP_READ                0x28
#define SCSIOP_WRITE               0x2A
#define SCSIOP_SEEK                0x2B
#define SCSIOP_LOCATE              0x2B
#define SCSIOP_WRITE_VERIFY        0x2E
#define SCSIOP_VERIFY              0x2F
#define SCSIOP_SEARCH_DATA_HIGH    0x30
#define SCSIOP_SEARCH_DATA_EQUAL   0x31
#define SCSIOP_SEARCH_DATA_LOW     0x32
#define SCSIOP_SET_LIMITS          0x33
#define SCSIOP_READ_POSITION       0x34
#define SCSIOP_SYNCHRONIZE_CACHE   0x35
#define SCSIOP_COMPARE             0x39
#define SCSIOP_COPY_COMPARE        0x3A
#define SCSIOP_WRITE_DATA_BUFF     0x3B
#define SCSIOP_READ_DATA_BUFF      0x3C
#define SCSIOP_CHANGE_DEFINITION   0x40
#define SCSIOP_READ_SUB_CHANNEL    0x42
#define SCSIOP_READ_TOC            0x43
#define SCSIOP_READ_HEADER         0x44
#define SCSIOP_PLAY_AUDIO          0x45
#define SCSIOP_PLAY_AUDIO_MSF      0x47
#define SCSIOP_PLAY_TRACK_INDEX    0x48
#define SCSIOP_PLAY_TRACK_RELATIVE 0x49
#define SCSIOP_PAUSE_RESUME        0x4B
#define SCSIOP_LOG_SELECT          0x4C
#define SCSIOP_LOG_SENSE           0x4D
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\driver\volsnap.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    volsnap.h

Abstract:

    This file provides the internal data structures for the volume snapshot
    driver.

Author:

    Norbert P. Kusters  (norbertk)  22-Jan-1999

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#ifdef POOL_TAGGING
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#define ExAllocatePool #assert(FALSE)
#define ExAllocatePoolWithQuota #assert(FALSE)
#endif

#define VOLSNAP_TAG_APP_INFO    'aSoV'  // VoSa - Application information allocations
#define VOLSNAP_TAG_BUFFER      'bSoV'  // VoSb - Buffer allocations
#define VOLSNAP_TAG_CONTEXT     'cSoV'  // VoSc - Snapshot context allocations
#define VOLSNAP_TAG_DIFF_VOLUME 'dSoV'  // VoSd - Diff area volume allocations
#define VOLSNAP_TAG_DIFF_FILE   'fSoV'  // VoSf - Diff area file allocations
#define VOLSNAP_TAG_BIT_HISTORY 'hSoV'  // VoSh - Bit history allocations
#define VOLSNAP_TAG_IO_STATUS   'iSoV'  // VoSi - Io status block allocations
#define VOLSNAP_TAG_BITMAP      'mSoV'  // VoSm - Bitmap allocations
#define VOLSNAP_TAG_OLD_HEAP    'oSoV'  // VoSo - Old heap entry allocations
#define VOLSNAP_TAG_PNP_ID      'pSoV'  // VoSp - Pnp id allocations
#define VOLSNAP_TAG_RELATIONS   'rSoV'  // VoSr - Device relations allocations
#define VOLSNAP_TAG_SHORT_TERM  'sSoV'  // VoSs - Short term allocations
#define VOLSNAP_TAG_TEMP_TABLE  'tSoV'  // VoSt - Temp table allocations
#define VOLSNAP_TAG_WORK_QUEUE  'wSoV'  // VoSw - Work queue allocations
#define VOLSNAP_TAG_DISPATCH    'xSoV'  // VoSx - Dispatch context allocations

#define NUMBER_OF_THREAD_POOLS  (3)

struct _VSP_CONTEXT;
typedef struct _VSP_CONTEXT VSP_CONTEXT, *PVSP_CONTEXT;

struct _TEMP_TRANSLATION_TABLE_ENTRY;
typedef struct _TEMP_TRANSLATION_TABLE_ENTRY TEMP_TRANSLATION_TABLE_ENTRY,
*PTEMP_TRANSLATION_TABLE_ENTRY;

typedef struct _DO_EXTENSION {

    //
    // Pointer to the driver object.
    //

    PDRIVER_OBJECT DriverObject;

    //
    // List of volume filters in they system.  Protect with 'Semaphore'.
    //

    LIST_ENTRY FilterList;

    //
    // HOLD/RELEASE Data.  Protect with cancel spin lock.
    //

    LONG HoldRefCount;
    GUID HoldInstanceGuid;
    ULONG SecondsToHoldFsTimeout;
    ULONG SecondsToHoldIrpTimeout;
    LIST_ENTRY HoldIrps;
    KTIMER HoldTimer;
    KDPC HoldTimerDpc;

    //
    // A semaphore for synchronization.
    //

    KSEMAPHORE Semaphore;

    //
    // Worker Thread.  Protect with 'SpinLock'.
    // Protect 'WorkerThreadObjects' and 'Wait*' with
    // 'ThreadsRefCountSemaphore'.
    //

    LIST_ENTRY WorkerQueue[NUMBER_OF_THREAD_POOLS];
    KSEMAPHORE WorkerSemaphore[NUMBER_OF_THREAD_POOLS];
    KSPIN_LOCK SpinLock[NUMBER_OF_THREAD_POOLS];
    PVOID* WorkerThreadObjects;
    BOOLEAN WaitForWorkerThreadsToExitWorkItemInUse;
    WORK_QUEUE_ITEM WaitForWorkerThreadsToExitWorkItem;

    //
    // The threads ref count.  Protect with 'ThreadsRefCountSemaphore'.
    //

    LONG ThreadsRefCount;
    KSEMAPHORE ThreadsRefCountSemaphore;

    //
    // Notification entry.
    //

    PVOID NotificationEntry;

    //
    // Lookaside list for contexts.
    //

    NPAGED_LOOKASIDE_LIST ContextLookasideList;

    //
    // Emergency Context.  Protect with 'ESpinLock'.
    //

    PVSP_CONTEXT EmergencyContext;
    BOOLEAN EmergencyContextInUse;
    LIST_ENTRY IrpWaitingList;
    LONG IrpWaitingListNeedsChecking;
    KSPIN_LOCK ESpinLock;

    //
    // Lookaside list for temp table entries.
    //

    NPAGED_LOOKASIDE_LIST TempTableEntryLookasideList;

    //
    // Emergency Temp Table Entry.  Protect with 'ESpinLock'.
    //

    PVOID EmergencyTableEntry;
    BOOLEAN EmergencyTableEntryInUse;
    LIST_ENTRY WorkItemWaitingList;
    LONG WorkItemWaitingListNeedsChecking;

    //
    // Stack count for allocating IRPs.  Use InterlockedExchange to update
    // along with Root->Semaphore.  Then, can be read for use in allocating
    // copy irps.
    //

    LONG StackSize;

    //
    // Is the code locked?  Protect with interlocked and 'Semaphore'.
    //

    LONG IsCodeLocked;

    //
    // Copy of registry path input to DriverEntry.
    //

    UNICODE_STRING RegistryPath;

    //
    // Queue for AdjustBitmap operations.  Just one at at time in the delayed
    // work queue.  Protect with 'ESpinLock'.
    //

    LIST_ENTRY AdjustBitmapQueue;
    BOOLEAN AdjustBitmapInProgress;

} DO_EXTENSION, *PDO_EXTENSION;

#define DEVICE_EXTENSION_VOLUME (0)
#define DEVICE_EXTENSION_FILTER (1)

struct DEVICE_EXTENSION {

    //
    // Pointer to the device object for this extension.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // Pointer to the root device extension.
    //

    PDO_EXTENSION Root;

    //
    // The type of device extension.
    //

    ULONG DeviceExtensionType;

    //
    // A spinlock for synchronization.
    //

    KSPIN_LOCK SpinLock;

};

typedef DEVICE_EXTENSION* PDEVICE_EXTENSION;

class FILTER_EXTENSION;
typedef FILTER_EXTENSION* PFILTER_EXTENSION;

struct _VSP_DIFF_AREA_FILE;
typedef struct _VSP_DIFF_AREA_FILE VSP_DIFF_AREA_FILE, *PVSP_DIFF_AREA_FILE;

class VOLUME_EXTENSION : public DEVICE_EXTENSION {

    public:

        //
        // A pointer to the filter for the volume that we are snapshotting.
        //

        PFILTER_EXTENSION Filter;

        //
        // Local state to handle PNP's START and REMOVE.
        // Protect 'IsStarted' with 'InterlockedExchange'.
        // Protect 'DeadToPnp' with 'InterlockedExchange'.
        // Protect 'DeviceDeleted' with 'InterlockedExchange'.
        // Write protect 'IsDead' with 'InterlockedExchange' and
        //     'Root->Semaphore.'.  'IsDead' indicates that this device is really
        //     dead now.  It is illegal to turn IsStarted to TRUE.
        // Protect 'AliveToPnp' with 'InterlockedExchange'.
        //

        LONG IsStarted;
        LONG DeadToPnp;
        LONG DeviceDeleted;
        LONG IsDead;
        LONG AliveToPnp;

        //
        // Keep track of all requests outstanding in order to support
        // remove.
        // Protect 'RefCount' with 'InterlockedIncrement/Decrement'.
        // Write protect 'HoldIncomingRequests' with 'SpinLock' and
        //  'InterlockedExchange'.
        // Protect 'HoldQueue' with 'SpinLock'.
        // Protect 'ZeroRefEvent' with the setting of 'HoldIncomingRequests'
        //  from 0 to 1.
        //

        LONG RefCount;
        LONG HoldIncomingRequests;
        LIST_ENTRY HoldIrpQueue;
        LIST_ENTRY HoldWorkerQueue;
        KEVENT ZeroRefEvent;

        //
        // Post Commit Processing has occurred.  Protect with 'Root->Semaphore'.
        // Don't return this device in BusRelations until this is TRUE.
        //

        BOOLEAN HasEndCommit;

        //
        // Indicates that this device has been installed.  Protect with
        // 'Root->Semaphore'.
        //

        BOOLEAN IsInstalled;

        //
        // Indicates that growing the diff area file is now safe.
        // Protect with 'InterlockedExchange'.
        //

        LONG OkToGrowDiffArea;

        //
        // Time stamp when commit took place.
        //

        LARGE_INTEGER CommitTimeStamp;

        //
        // A list entry for 'Filter->VolumeList'.
        // Write protect with 'Filter->SpinLock', 'Root->Semaphore', and
        //  'Filter->RefCount == 0'.
        // Blink points to an older snapshot.
        // Flink points to a newer snapshot.
        //

        LIST_ENTRY ListEntry;

        //
        // The volume number.
        //

        ULONG VolumeNumber;

        //
        // A table to translate volume offset to backing store offset.
        // Protect with 'PagedResource'.
        //

        RTL_GENERIC_TABLE VolumeBlockTable;

        //
        // A table to store entries in flight.  This table is non-paged.
        // Protect with 'NonPagedResource'.
        //

        RTL_GENERIC_TABLE TempVolumeBlockTable;
        ULONG MaximumNumberOfTempEntries;
        ULONG DiffAreaFileIncrease;

        //
        // A list of Diff Area Files that are used.
        // Write protect 'ListOfDiffAreaFiles' with 'NonPagedResource',
        //      'Root->Semaphore', 'RefCount == 0', and
        //      'extension->Filter->RefCount == 0'.
        // Protect 'NextDiffAreaFile' with 'NonPagedResource'.
        //

        LIST_ENTRY ListOfDiffAreaFiles;
        PVSP_DIFF_AREA_FILE NextDiffAreaFile;

        //
        // Memory mapped section of a diff area file to be used for a heap.
        // Protect with 'PagedResource'.
        //

        PVOID DiffAreaFileMap;
        ULONG DiffAreaFileMapSize;
        PVOID DiffAreaFileMapProcess;
        ULONG NextAvailable;
        PVOID NextDiffAreaFileMap;
        ULONG NextDiffAreaFileMapSize;
        LIST_ENTRY OldHeaps;

        //
        // A bitmap of blocks that do not need to be copy on writed.
        // Protect with 'SpinLock'.
        //

        PRTL_BITMAP VolumeBlockBitmap;

        //
        // A bitmap product of ignorable blocks from previous snapshots.
        // Protect with 'SpinLock'.
        //

        PRTL_BITMAP IgnorableProduct;

        //
        // Application Information.  Protect with 'PagedResource'.
        //

        ULONG ApplicationInformationSize;
        PVOID ApplicationInformation;

        //
        // Volume size.
        //

        LONGLONG VolumeSize;

        //
        // Emergency copy irp.  Protect with 'SpinLock'.
        //

        PIRP EmergencyCopyIrp;
        LONG EmergencyCopyIrpInUse;
        LIST_ENTRY EmergencyCopyIrpQueue;

        //
        // This field is used to pass a buffer to the TempTableAllocateRoutine.
        // Protect with 'NonPagedResource'.
        //

        PVOID TempTableEntry;

        //
        // These fields are there to help with the lag in creating new
        // page file space.  Non paged pool can be used until the page file
        // space can be acquired.  Protect 'PageFileSpaceCreatePending' and
        // 'WaitingForPageFileSpace' with 'SpinLock'.
        //

        LONG PageFileSpaceCreatePending;
        LIST_ENTRY WaitingForPageFileSpace;

};

typedef
VOID
(*ZERO_REF_CALLBACK)(
    IN  PFILTER_EXTENSION   Filter
    );

typedef VOLUME_EXTENSION* PVOLUME_EXTENSION;

struct _VSP_CONTEXT {

    ULONG           Type;
    WORK_QUEUE_ITEM WorkItem;

    union {
        struct {
            PVOLUME_EXTENSION   Extension;
            PIRP                OriginalReadIrp;
            ULONG_PTR           OriginalReadIrpOffset;
            LONGLONG            OriginalVolumeOffset;
            ULONG               BlockOffset;
            ULONG               Length;
            PDEVICE_OBJECT      TargetObject;
            LONGLONG            TargetOffset;
        } ReadSnapshot;

        struct {
            PDO_EXTENSION   RootExtension;
            ULONG           QueueNumber;
        } ThreadCreation;

        struct {
            PIO_WORKITEM    IoWorkItem;
            PIRP            Irp;
        } Dispatch;

        struct {
            PVOLUME_EXTENSION   Extension;
            PIRP                Irp;
        } Extension;

        struct {
            PFILTER_EXTENSION   Filter;
        } Filter;

        struct {
            PVOLUME_EXTENSION   Extension;
            PVSP_DIFF_AREA_FILE DiffAreaFile;
        } GrowDiffArea;

        struct {
            KEVENT  Event;
        } Event;

        struct {
            PVOLUME_EXTENSION   Extension;
            PFILTER_EXTENSION   DiffAreaFilter;
            NTSTATUS            SpecificIoStatus;
            NTSTATUS            FinalStatus;
            ULONG               UniqueErrorValue;
        } ErrorLog;

        struct {
            PDO_EXTENSION   RootExtension;
        } RootExtension;

        struct {
            PVOLUME_EXTENSION   Extension;
            PIRP                Irp;
            LONGLONG            RoundedStart;
        } WriteVolume;
    };
};

#define VSP_CONTEXT_TYPE_READ_SNAPSHOT      (1)
#define VSP_CONTEXT_TYPE_THREAD_CREATION    (2)
#define VSP_CONTEXT_TYPE_DISPATCH           (3)
#define VSP_CONTEXT_TYPE_EXTENSION          (4)
#define VSP_CONTEXT_TYPE_FILTER             (5)
#define VSP_CONTEXT_TYPE_GROW_DIFF_AREA     (6)
#define VSP_CONTEXT_TYPE_EVENT              (7)
#define VSP_CONTEXT_TYPE_ERROR_LOG          (8)
#define VSP_CONTEXT_TYPE_ROOT_EXTENSION     (9)
#define VSP_CONTEXT_TYPE_WRITE_VOLUME       (10)

class FILTER_EXTENSION : public DEVICE_EXTENSION {

    public:

        //
        // The target object for this filter.
        //

        PDEVICE_OBJECT TargetObject;

        //
        // The PDO for this filter.
        //

        PDEVICE_OBJECT Pdo;

        //
        // Do we have any snapshots?
        // Write protect with 'InterlockedExchange' and 'Root->Semaphore'.
        //

        LONG SnapshotsPresent;

        //
        // Keep track of I/Os so that freeze/thaw is possible.
        // Protect 'RefCount' with 'InterlockedIncrement/Decrement'.
        // Write Protect 'HoldIncomingWrites' with InterlockedExchange and
        //  'SpinLock'.
        // Protect 'HoldQueue' with 'SpinLock'.
        // Protect 'ZeroRefCallback', 'ZeroRefContext',
        //  and 'TimerIsSet' are for use by the thread that sets
        //  'HoldIncomingWrites' to 1 from 0.
        // Write protect 'ZeroRefCallback' with 'SpinLock'.
        // Protect 'TimerIsSet' with InterlockedExchange.
        //

        LONG RefCount;
        LONG HoldIncomingWrites;
        LIST_ENTRY HoldQueue;
        ZERO_REF_CALLBACK ZeroRefCallback;
        PVOID ZeroRefContext;

        KTIMER HoldWritesTimer;
        KDPC HoldWritesTimerDpc;
        ULONG HoldWritesTimeout;
        LONG TimerIsSet;

        //
        // The flush and hold irp is kept here while it is cancellable.
        // Protect with the cancel spin lock.
        //

        PIRP FlushAndHoldIrp;

        //
        // This event indicates that the end commit process is completed.
        // This means that PNP has kicked into gear and that the ignorable
        // bitmap computation has taken place.
        //

        KEVENT EndCommitProcessCompleted;

        //
        // Keep a notification entry on this object to watch for a
        // dismount.  Protect with 'Root->Semaphore'.
        //

        PVOID TargetDeviceNotificationEntry;

        //
        // A list entry for 'Root->FilterList'.
        // Protect these with 'Root->Semaphore'.
        //

        LIST_ENTRY ListEntry;
        BOOLEAN NotInFilterList;

        //
        // Keep a list of snapshot volumes.
        // Write protect with 'Root->Semaphore', 'RefCount == 0', and
        //   'SpinLock'.
        // Flink points to the oldest snapshot.
        // Blink points to the newest snapshot.
        //

        LIST_ENTRY VolumeList;

        //
        // Cache the prepared snapshot for committing later.
        // Write protect with 'SpinLock' and 'Root->Semaphore'.
        //

        PVOLUME_EXTENSION PreparedSnapshot;

        //
        // List of dead snapshot volumes.  Protect with 'Root->Semaphore'.
        //

        LIST_ENTRY DeadVolumeList;

        //
        // List of volume snapshots which depend on this filter for
        // diff area support.  This will serve as removal relations.
        // Protect with 'Root->Semaphore'.
        //

        LIST_ENTRY DiffAreaFilesOnThisFilter;

        //
        // List of volumes that make up the Diff Area for this volume.
        // Protect with 'Root->Semaphore'.
        //

        LIST_ENTRY DiffAreaVolumes;

        //
        // Diff area sizes information total for all diff area files.
        // Protect with 'SpinLock'.
        //

        LONGLONG UsedVolumeSpace;
        LONGLONG AllocatedVolumeSpace;
        LONGLONG MaximumVolumeSpace;

        //
        // Timer for completing END_COMMIT if device doesn't install.
        //

        KTIMER EndCommitTimer;
        KDPC EndCommitTimerDpc;

        //
        // File object for AUTO_CLEANUP.  Protect with cancel spin lock.
        //

        PFILE_OBJECT AutoCleanupFileObject;

        //
        // Is a delete all snapshots pending.  Protect with
        // InterlockedExchange.
        //

        LONG DestroyAllSnapshotsPending;
        VSP_CONTEXT DestroyContext;

        //
        // Resource to use for protection.  Don't page when holding this
        // resource.  Protect the queueing with 'SpinLock'.
        //

        LIST_ENTRY NonPagedResourceList;
        BOOLEAN NonPagedResourceInUse;

        //
        // Page resource to use for protection.  It is ok to page when
        // holding this resource.  Protect the queueing with 'SpinLock'.
        //

        LIST_ENTRY PagedResourceList;
        BOOLEAN PagedResourceInUse;

};

#define BLOCK_SIZE                          (0x4000)
#define BLOCK_SHIFT                         (14)
#define MINIMUM_TABLE_HEAP_SIZE             (0x20000)
#define MEMORY_PRESSURE_CHECK_ALLOC_SIZE    (0x40000)

#define NOMINAL_DIFF_AREA_FILE_GROWTH   (50*1024*1024)
#define MAXIMUM_DIFF_AREA_FILE_GROWTH   (1000*1024*1024)

typedef struct _TRANSLATION_TABLE_ENTRY {
    LONGLONG            VolumeOffset;
    PDEVICE_OBJECT      TargetObject;
    LONGLONG            TargetOffset;
} TRANSLATION_TABLE_ENTRY, *PTRANSLATION_TABLE_ENTRY;

//
// The structure below is used in the non-paged temp table.  'IsComplete' and
// 'WaitingQueue*' are protected with 'extension->SpinLock'.
//

struct _TEMP_TRANSLATION_TABLE_ENTRY {
    LONGLONG            VolumeOffset;
    PVOLUME_EXTENSION   Extension;
    PIRP                WriteIrp;
    PIRP                CopyIrp;
    PDEVICE_OBJECT      TargetObject;
    LONGLONG            TargetOffset;
    BOOLEAN             IsComplete;
    LIST_ENTRY          WaitingQueueDpc;    // These can run in arbitrary context.
    WORK_QUEUE_ITEM     WorkItem;
};

//
// Write protect 'VolumeListEntry' with 'NonPagedResource' and
//      'Root->Semaphore'.
// Protect 'FilterListEntry*' with 'Root->Semaphore'.
// Protect 'NextAvailable' with 'NonPagedResource'
// Write Protect 'AllocatedFileSize' with 'NonPagedResource' and
//      'Root->Semaphore'.
// Protect 'UnusedAllocationList' with 'NonPagedResource'.
//

struct _VSP_DIFF_AREA_FILE {
    LIST_ENTRY          VolumeListEntry;
    LIST_ENTRY          FilterListEntry;
    BOOLEAN             FilterListEntryBeingUsed;
    PVOLUME_EXTENSION   Extension;
    PFILTER_EXTENSION   Filter;
    HANDLE              FileHandle;
    LONGLONG            NextAvailable;
    LONGLONG            AllocatedFileSize;
    LIST_ENTRY          UnusedAllocationList;
};

typedef struct _DIFF_AREA_FILE_ALLOCATION {
    LIST_ENTRY  ListEntry;
    LONGLONG    Offset;
    LONGLONG    Length;
} DIFF_AREA_FILE_ALLOCATION, *PDIFF_AREA_FILE_ALLOCATION;

typedef struct _OLD_HEAP_ENTRY {
    LIST_ENTRY  ListEntry;
    PVOID       DiffAreaFileMap;
} OLD_HEAP_ENTRY, *POLD_HEAP_ENTRY;

typedef struct _VSP_DIFF_AREA_VOLUME {
    LIST_ENTRY          ListEntry;
    PFILTER_EXTENSION   Filter;
} VSP_DIFF_AREA_VOLUME, *PVSP_DIFF_AREA_VOLUME;

//
// {3808876B-C176-4e48-B7AE-04046E6CC752}
// This GUID is used to decorate the names of the diff area files for
// uniqueness.  This GUID has been included in the list of files not to be
// backed up by NTBACKUP.  If this GUID is changed, or if other GUIDs are
// added, then this change should also be reflected in the NTBACKUP file
// not to be backed up.
//

DEFINE_GUID(VSP_DIFF_AREA_FILE_GUID, 0x3808876b, 0xc176, 0x4e48, 0xb7, 0xae, 0x4, 0x4, 0x6e, 0x6c, 0xc7, 0x52);

#if DBG

//
// Tracing definitions.
//

typedef struct _VSP_TRACE_STRUCTURE {
    ULONG       EventNumber;
    ULONG_PTR   Arg1;
    ULONG_PTR   Arg2;
    ULONG_PTR   Arg3;
} VSP_TRACE_STRUCTURE, *PVSP_TRACE_STRUCTURE;

PVSP_TRACE_STRUCTURE
VspAllocateTraceStructure(
    );

#define VSP_TRACE_IT(A0, A1, A2, A3)            \
        { PVSP_TRACE_STRUCTURE moo;             \
          moo = VspAllocateTraceStructure();    \
          moo->EventNumber = (A0);              \
          moo->Arg1 = (ULONG_PTR) (A1);         \
          moo->Arg2 = (ULONG_PTR) (A2);         \
          moo->Arg3 = (ULONG_PTR) (A3); }

#else   // DBG

#define VSP_TRACE_IT(A0, A1, A2, A3)

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\utils\vsclrda\vsclrda.c ===
#include <windows.h>
#include <winioctl.h>
#include <ntddsnap.h>
#include <stdio.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    WCHAR                   driveName[10];
    HANDLE                  handle;
    BOOL                    b;
    DWORD                   bytes;

    if (argc != 2) {
        printf("usage: %s drive:\n", argv[0]);
        return;
    }

    swprintf(driveName, L"\\\\?\\%c:", toupper(argv[1][0]));

    handle = CreateFile(driveName, GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                        INVALID_HANDLE_VALUE);
    if (handle == INVALID_HANDLE_VALUE) {
        printf("Could not open the given volume %d\n", GetLastError());
        return;
    }

    b = DeviceIoControl(handle, IOCTL_VOLSNAP_CLEAR_DIFF_AREA,
                        NULL, 0, NULL, 0, &bytes, NULL);
    if (!b) {
        printf("Clear diff area failed with %d\n", GetLastError());
        return;
    }

    printf("Diff Area Cleared.\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\utils\vscreate\vscreate.c ===
#include <windows.h>
#include <winioctl.h>
#include <ntddsnap.h>
#include <stdio.h>
#include <objbase.h>

typedef struct _VSP_CONTEXT {
    HANDLE                          Handle;
    PVOLSNAP_FLUSH_AND_HOLD_INPUT   FlushInput;
} VSP_CONTEXT, *PVSP_CONTEXT;

DWORD
FlushAndHoldRoutine(
    PVOID   Context
    )

{
    PVSP_CONTEXT    context = Context;
    BOOL            b;
    DWORD           bytes;

    b = DeviceIoControl(context->Handle, IOCTL_VOLSNAP_FLUSH_AND_HOLD_WRITES,
                        context->FlushInput,
                        sizeof(VOLSNAP_FLUSH_AND_HOLD_INPUT), NULL, 0, &bytes,
                        NULL);

    if (!b) {
        printf("Flush and hold failed with %d\n", GetLastError());
        return GetLastError();
    }

    return 0;
}

void __cdecl
main(
    int argc,
    char** argv
    )

{
    WCHAR                           driveName[10];
    HANDLE                          handle[100];
    VOLSNAP_PREPARE_INFO            prepareInfo;
    BOOL                            b;
    DWORD                           bytes;
    int                             i, j;
    VOLSNAP_FLUSH_AND_HOLD_INPUT    flushInput;
    PVOLSNAP_NAME                   name;
    WCHAR                           buffer[100];
    HANDLE                          threads[100];
    DWORD                           threadid;
    VSP_CONTEXT                     context[100];

    if (argc < 2) {
        printf("usage: %s drive: drive: ...\n", argv[0]);
        return;
    }

    for (i = 1; i < argc; i++) {
        swprintf(driveName, L"\\\\?\\%c:", toupper(argv[i][0]));

        handle[i] = CreateFile(driveName, GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                               INVALID_HANDLE_VALUE);
        if (handle[i] == INVALID_HANDLE_VALUE) {
            printf("Could not open volume %c:, error = %d\n", argv[i][0],
                   GetLastError());
            break;
        }

        prepareInfo.Attributes = 0;
        prepareInfo.InitialDiffAreaAllocation = 100*1024*1024;

        b = DeviceIoControl(handle[i], IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT,
                            &prepareInfo, sizeof(prepareInfo), NULL, 0, &bytes,
                            NULL);
        if (!b) {
            printf("Prepare failed with %d\n", GetLastError());
            break;
        }

        CloseHandle(handle[i]);

        handle[i] = CreateFile(driveName, GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                               INVALID_HANDLE_VALUE);
        if (handle == INVALID_HANDLE_VALUE) {
            printf("Could not open volume %c:, error = %d\n", argv[i][0],
                   GetLastError());
            break;
        }
    }

    if (i < argc) {
        for (j = 1; j < i; j++) {
            b = DeviceIoControl(handle[j],
                                IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT,
                                NULL, 0, NULL, 0, &bytes, NULL);
            if (!b) {
                printf("Abort of Prepared snapshot failed with %d\n", GetLastError());
            }
        }
        return;
    }

    CoCreateGuid(&flushInput.InstanceId);
    flushInput.NumberOfVolumesToFlush = argc - 1;
    flushInput.SecondsToHoldFileSystemsTimeout = 60;
    flushInput.SecondsToHoldIrpsTimeout = 10;

    for (i = 1; i < argc; i++) {
        context[i].Handle = handle[i];
        context[i].FlushInput = &flushInput;
        threads[i] = CreateThread(NULL, 0, FlushAndHoldRoutine, &context[i],
                                  0, &threadid);
    }

    WaitForMultipleObjects(argc - 1, &threads[1], TRUE, INFINITE);

    for (i = 1; i < argc; i++) {

        b = DeviceIoControl(handle[i], IOCTL_VOLSNAP_COMMIT_SNAPSHOT, NULL, 0,
                            NULL, 0, &bytes, NULL);

        if (!b) {
            printf("Commit failed with %d\n", GetLastError());
            break;
        }
    }

    name = (PVOLSNAP_NAME) buffer;

    if (i < argc) {
        for (j = 1; j < argc; j++) {
            b = DeviceIoControl(handle[j], IOCTL_VOLSNAP_RELEASE_WRITES,
                                NULL, 0, NULL, 0, &bytes, NULL);
        }

        for (j = 1; j < i; j++) {
            b = DeviceIoControl(handle[j], IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT,
                                NULL, 0, name, 200, &bytes, NULL);
        }

        for (; j < argc; j++) {
            b = DeviceIoControl(handle[j],
                                IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT,
                                NULL, 0, NULL, 0, &bytes, NULL);
        }
    }

    for (i = 1; i < argc; i++) {
        b = DeviceIoControl(handle[i], IOCTL_VOLSNAP_RELEASE_WRITES, NULL, 0, NULL,
                            0, &bytes, NULL);

        if (!b) {
            printf("Release writes failed with %d\n", GetLastError());
        }
    }

    for (i = 1; i < argc; i++) {
        b = DeviceIoControl(handle[i], IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT, NULL, 0,
                            name, 200, &bytes, NULL);

        if (!b) {
            printf("End commit failed with %d\n", GetLastError());
        } else {
            name->Name[name->NameLength/sizeof(WCHAR)] = 0;
            printf("%ws  created.\n", name->Name);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\utils\vsdelete\vsdelete.c ===
#include <windows.h>
#include <winioctl.h>
#include <ntddsnap.h>
#include <stdio.h>
#include <objbase.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    WCHAR                           driveName[10];
    HANDLE                          handle;
    BOOL                            b;
    DWORD                           bytes;

    if (argc != 2) {
        printf("usage: %s drive:\n", argv[0]);
        return;
    }

    swprintf(driveName, L"\\\\?\\%c:", toupper(argv[1][0]));

    handle = CreateFile(driveName, GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                        INVALID_HANDLE_VALUE);
    if (handle == INVALID_HANDLE_VALUE) {
        printf("Could not open the given volume %d\n", GetLastError());
        return;
    }

    b = DeviceIoControl(handle, IOCTL_VOLSNAP_DELETE_OLDEST_SNAPSHOT,
                        NULL, 0, NULL, 0, &bytes, NULL);
    if (!b) {
        printf("Kill failed with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\utils\vsda\vsda.c ===
#include <windows.h>
#include <winioctl.h>
#include <ntddsnap.h>
#include <stdio.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    WCHAR                   driveName[10];
    HANDLE                  handle;
    BOOL                    b;
    DWORD                   bytes;
    PVOLSNAP_NAME           name;
    CHAR                    buffer[100];

    if (argc != 3) {
        printf("usage: %s drive: <diff area drive>:\n", argv[0]);
        return;
    }

    swprintf(driveName, L"\\\\?\\%c:", toupper(argv[1][0]));

    handle = CreateFile(driveName, GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                        INVALID_HANDLE_VALUE);
    if (handle == INVALID_HANDLE_VALUE) {
        printf("Could not open the given volume %d\n", GetLastError());
        return;
    }

    name = (PVOLSNAP_NAME) buffer;
    name->NameLength = 12;
    name->Name[0] = '\\';
    name->Name[1] = '?';
    name->Name[2] = '?';
    name->Name[3] = '\\';
    name->Name[4] = (WCHAR) toupper(argv[2][0]);
    name->Name[5] = ':';
    name->Name[6] = 0;

    b = DeviceIoControl(handle, IOCTL_VOLSNAP_ADD_VOLUME_TO_DIFF_AREA,
                        name, 100, NULL, 0, &bytes, NULL);
    if (!b) {
        printf("Add to diff area failed with %d\n", GetLastError());
        return;
    }

    printf("Added %c: to Diff Area for %c:\n", toupper(argv[2][0]),
           toupper(argv[1][0]));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\utils\vsinfo\vsinfo.c ===
#include <windows.h>
#include <winioctl.h>
#include <ntddsnap.h>
#include <stdio.h>
#include <objbase.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    WCHAR                   driveName[10];
    HANDLE                  handle;
    BOOL                    b;
    DWORD                   bytes;
    PVOLSNAP_NAME           name;
    WCHAR                   buffer[MAX_PATH];
    WCHAR                   originalVolumeName[MAX_PATH];
    VOLSNAP_NAMES           names;
    PVOLSNAP_NAMES          pnames;
    PWCHAR                  p;
    VOLSNAP_DIFF_AREA_SIZES sizes;

    if (argc != 2) {
        printf("usage: %s drive:\n", argv[0]);
        return;
    }

    swprintf(driveName, L"\\\\?\\%c:", toupper(argv[1][0]));

    handle = CreateFile(driveName, GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                        INVALID_HANDLE_VALUE);
    if (handle == INVALID_HANDLE_VALUE) {
        printf("Could not open the given volume %d\n", GetLastError());
        return;
    }

    pnames = &names;
    b = DeviceIoControl(handle, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS,
                        NULL, 0, &names, sizeof(names), &bytes, NULL);
    if (!b && GetLastError() == ERROR_MORE_DATA) {
        pnames = LocalAlloc(0, names.MultiSzLength + sizeof(VOLSNAP_NAMES));
        b = DeviceIoControl(handle, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS,
                            NULL, 0, pnames, names.MultiSzLength +
                            sizeof(VOLSNAP_NAMES), &bytes, NULL);
    }

    if (!b) {
        printf("Query names of snapshots failed with %d\n", GetLastError());
        return;
    }

    printf("Snapshots of this volume:\n");

    p = pnames->Names;
    while (*p) {
        printf("    %ws\n", p);
        while (*p++) {
        }
    }

    printf("\n");

    pnames = &names;
    b = DeviceIoControl(handle, IOCTL_VOLSNAP_QUERY_DIFF_AREA,
                        NULL, 0, &names, sizeof(names), &bytes, NULL);
    if (!b && GetLastError() == ERROR_MORE_DATA) {
        pnames = LocalAlloc(0, names.MultiSzLength + sizeof(VOLSNAP_NAMES));
        b = DeviceIoControl(handle, IOCTL_VOLSNAP_QUERY_DIFF_AREA,
                            NULL, 0, pnames, names.MultiSzLength +
                            sizeof(VOLSNAP_NAMES), &bytes, NULL);
    }

    if (!b) {
        printf("Query diff area failed with %d\n", GetLastError());
        return;
    }

    printf("Diff Area for this volume:\n");

    p = pnames->Names;
    while (*p) {
        printf("    %ws\n", p);
        while (*p++) {
        }
    }

    printf("\n");

    b = DeviceIoControl(handle, IOCTL_VOLSNAP_QUERY_DIFF_AREA_SIZES,
                        NULL, 0, &sizes, sizeof(sizes), &bytes, NULL);
    if (!b) {
        printf("Query diff area sizes failed with %d\n", GetLastError());
        return;
    }

    printf("UsedVolumeSpace = %I64d\n", sizes.UsedVolumeSpace);
    printf("AllocatedVolumeSpace = %I64d\n", sizes.AllocatedVolumeSpace);
    printf("MaximumVolumeSpace = %I64d\n", sizes.MaximumVolumeSpace);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\inc\build.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    build.h

Abstract:

    Declaration of the build number for VSS modules

Remark: 

    DO NOT edit this file!
    This file was generated by buildgen.pl. 
    Rerun buildgen for a new build version!

--*/

#define VSS_BUILD_NO 4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\inc\ijetwriter.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ijetwriter.h

Abstract:

    Definition of CVssIJetWriter class

	Brian Berkowitz  [brianb]  3/17/2000

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    brianb      03/17/2000  Created
    mikejohn    04/03/2000  Added extra methods for OnIdentify()
    mikejohn	08/21/2000  165913: Deallocate memory on class destruction
			    161899: Add methods for matching paths in exclude list
    mikejohn	09/18/2000  176860: Added calling convention methods where missing

--*/

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "INCIJWRH"
//
////////////////////////////////////////////////////////////////////////

class CVssIJetWriter;

typedef CVssIJetWriter *PVSSIJETWRITER;


// actual writer class
class CVssIJetWriter : public CVssWriter
	{

// Constructors and destructors
public:
	virtual STDMETHODCALLTYPE ~CVssIJetWriter();

	STDMETHODCALLTYPE CVssIJetWriter() :
		m_wszWriterName(NULL),
		m_wszFilesToInclude(NULL),
		m_wszFilesToExclude(NULL)
		{
		InitializeListHead (&m_leFilesToIncludeEntries);
		InitializeListHead (&m_leFilesToExcludeEntries);
		}
	
	static HRESULT STDMETHODCALLTYPE Initialize
		(
		IN VSS_ID idWriter,
		IN LPCWSTR wszWriterName,
		IN bool bSystemService,
		IN bool bBootableSystemState,
		LPCWSTR wszFilesToInclude,
		LPCWSTR wszFilesToExclude,
		IN CVssJetWriter *pWriter,
		OUT void **ppInstanceCreated
		);

	static void STDMETHODCALLTYPE Uninitialize(IN PVSSIJETWRITER pInstance);

	// callback for identify event
	virtual bool STDMETHODCALLTYPE OnIdentify(IN IVssCreateWriterMetadata *pMetadata);

	// callback for prepare backup event
	virtual bool STDMETHODCALLTYPE OnPrepareBackup(IN IVssWriterComponents *pComponent);

	// called at Prepare to freeze
	virtual bool STDMETHODCALLTYPE OnPrepareSnapshot();

	// called at freeze
	virtual bool STDMETHODCALLTYPE OnFreeze();

	// called at thaw
	virtual bool STDMETHODCALLTYPE OnThaw();

	// called at post snapshot
	virtual bool STDMETHODCALLTYPE OnPostSnapshot(IN IVssWriterComponents *pComponent);

	// called when timeout occurs
	virtual bool STDMETHODCALLTYPE OnAbort();

	// callback on backup complete event
	virtual bool STDMETHODCALLTYPE OnBackupComplete(IN IVssWriterComponents *pComponent);

	// callback on prerestore event
	virtual bool STDMETHODCALLTYPE OnPreRestore(IN IVssWriterComponents *pComponent);


	// callback on postrestore event
	virtual bool STDMETHODCALLTYPE OnPostRestore(IN IVssWriterComponents *pComponent);

private:

	HRESULT InternalInitialize
		(
		IN VSS_ID idWriter,
		IN LPCWSTR wszWriterName,
		IN bool bSystemService,
		IN bool bBootableSystemState,
		IN LPCWSTR wszFilesToInclude,
		IN LPCWSTR wszFilesToExclude
		);

	bool PreProcessIncludeExcludeLists  (bool bProcessingIncludeList);
	bool ProcessIncludeExcludeLists     (bool bProcessingIncludeList);
	void PostProcessIncludeExcludeLists (bool bProcessingIncludeList);

	bool ProcessJetInstance (JET_INSTANCE_INFO *pInstanceInfo);

	BOOL CheckExcludedFileListForMatch (LPCWSTR pwszDatabaseFilePath,
					    LPCWSTR pwszDatabaseFileSpec);

	bool FCheckInstanceVolumeDependencies
		(
		IN const JET_INSTANCE_INFO * pInstanceInfo
		) const;

	bool FCheckVolumeDependencies
		(
		IN unsigned long cInstanceInfo,
		IN JET_INSTANCE_INFO *aInstanceInfo
		) const;

	bool FCheckPathVolumeDependencies(IN const char * szPath) const;

	LPCWSTR GetApplicationName() const { return m_wszWriterName; }

	VSS_ID				 m_idWriter;
	LPWSTR				 m_wszWriterName;
	JET_OSSNAPID			 m_idJet;
	CVssJetWriter			*m_pwrapper;
	LPWSTR				 m_wszFilesToInclude;
	LPWSTR				 m_wszFilesToExclude;
	bool				 m_bSystemService;
	bool				 m_bBootableSystemState;
	IVssCreateWriterMetadata	*m_pIMetadata;
	LIST_ENTRY			 m_leFilesToIncludeEntries;
	LIST_ENTRY			 m_leFilesToExcludeEntries;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\inc\sqlsnap.h ===
//
// sqlsnap.h  Define the interface to the nt/sql snapshot handler.
//
//	The idea here is for a pure interface, making it easy to keep the
// abstraction maximized (can move to COM later, if we like).
//
//  No C++ exceptions will be thrown across the interfaces.
//
//  To use this interface, the calling process must invoke:
//	InitSQLEnvironment - once to setup the environment, establishing
//		the error and trace loggers.
//		The trace logger is optional, but an error logger must be provided.
//      The loggers are created by deriving from CLogFacility and implementing
//		a "WriteImplementation" method.
//
//	Thereafter,	calls to "CreateSqlSnapshot" are used to create snapshot objects
//  which encapsulate the operations needed to support storage snapshots.
//
//  *****************************************
//     LIMITATIONS
//
//	- only SIMPLE databases can be snapshot (trunc on checkpoint = 'true')
//  - there is no serialization of services starting or adding/changing file lists during the snapshot
//  - servers which are not started when the snapshot starts are skipped (non-torn databases will be
//      backed up fine, torn databases won't be detected).
//  - sql7.0 databases which are "un"-useable will prevent snapshots (the list of files can't be obtained).
//
#include <stdio.h>
#include <stdarg.h>
#include <windows.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "INCSQLSH"
//
////////////////////////////////////////////////////////////////////////

HRESULT InitSQLEnvironment();

// Caller must provide a path checker interface.
//
class CCheckPath
{
public:
	virtual bool IsPathInSnapshot (const WCHAR* path) throw () = 0;
};

//-------------------------------------------------------------
// A handler for snapshots.
//
class CSqlSnapshot
{
public:
	virtual ~CSqlSnapshot () throw () {};

	virtual HRESULT Prepare (
		CCheckPath*			checker) throw () = 0;

	virtual HRESULT Freeze () throw () = 0;

	virtual HRESULT Thaw () throw () = 0;

};

extern "C" CSqlSnapshot* CreateSqlSnapshot () throw ();

//-------------------------------------------------------------
// An enumerator for SQL objects.
//
// An object of this class can have only one active query at
// a time.  Requesting a new enumeration will close any previous
// partially fetched result.
//
#define MAX_SERVERNAME	128
#define MAX_DBNAME	128
struct ServerInfo
{
	bool	isOnline;				// true if the server is ready for connections
	WCHAR	name [MAX_SERVERNAME];	// null terminated name of server
};
struct DatabaseInfo
{
	bool	supportsFreeze;			// true if a freeze operation is supported
	WCHAR	name [MAX_DBNAME];		// null terminated name of database
};
struct DatabaseFileInfo
{
	bool	isLogFile;				// true if this is a log file
	WCHAR	name [MAX_PATH];
};


class CSqlEnumerator
{
public:
	virtual ~CSqlEnumerator () throw () {};

	virtual HRESULT FirstServer (
		ServerInfo*			pServer) throw () = 0;

	virtual HRESULT NextServer (
		ServerInfo*			pServer) throw () = 0;

	virtual HRESULT FirstDatabase (
		const WCHAR*		pServerName,
		DatabaseInfo*		pDbInfo) throw () = 0;

	virtual HRESULT NextDatabase (
		DatabaseInfo*		pDbInfo) throw () = 0;

	virtual HRESULT FirstFile (
		const WCHAR*		pServerName,
		const WCHAR*		pDbName,
		DatabaseFileInfo*	pFileInfo) throw () = 0;

	virtual HRESULT NextFile (
		DatabaseFileInfo*	pFileInfo) throw () = 0;
};

extern "C" CSqlEnumerator* CreateSqlEnumerator () throw ();


//------------------------------------------------------
// HRESULTS returned by the interface.
//
// WARNING: I used facility = x78 arbitrarily!
//
#define SQLLIB_ERROR(code) MAKE_HRESULT(SEVERITY_ERROR, 0x78, code)
#define SQLLIB_STATUS(code) MAKE_HRESULT(SEVERITY_SUCCESS, 0x78, code)

// Status codes
//
#define S_SQLLIB_NOSERVERS	SQLLIB_STATUS(1)	// no SQLServers of interest (from Prepare)

// Error codes
//
#define E_SQLLIB_GENERIC	SQLLIB_ERROR(1)		// something bad, check the errorlog

#define E_SQLLIB_TORN_DB	SQLLIB_ERROR(2)		// database would be torn by the snapshot

#define E_SQLLIB_NO_SUPPORT SQLLIB_ERROR(3)		// 6.5 doesn't support snapshots

#define E_SQLLIB_PROTO		SQLLIB_ERROR(4)		// protocol error (ex: freeze before prepare)

#define E_SQLLIB_NONSIMPLE	SQLLIB_ERROR(5)		// only simple databases are supported
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\backupext\cmxml.c ===
WCHAR g_ComponentMetadataXML[] = 
{L'<', L'r', L'o', L'o', L't', L'>', L'\n', L'<', L'S', L'c', 
L'h', L'e', L'm', L'a', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'V', L's', L's', L'C', L'o', L'm', L'p', L'o', L'n', 
L'e', L'n', L't', L'M', L'e', L't', L'a', L'd', L'a', L't', 
L'a', L'"', L' ', L'x', L'm', L'l', L'n', L's', L'=', L'"', 
L'u', L'r', L'n', L':', L's', L'c', L'h', L'e', L'm', L'a', 
L's', L'-', L'm', L'i', L'c', L'r', L'o', L's', L'o', L'f', 
L't', L'-', L'c', L'o', L'm', L':', L'x', L'm', L'l', L'-', 
L'd', L'a', L't', L'a', L'"', L' ', L'x', L'm', L'l', L'n', 
L's', L':', L'd', L't', L'=', L'"', L'u', L'r', L'n', L':', 
L's', L'c', L'h', L'e', L'm', L'a', L's', L'-', L'm', L'i', 
L'c', L'r', L'o', L's', L'o', L'f', L't', L'-', L'c', L'o', 
L'm', L':', L'd', L'a', L't', L'a', L't', L'y', L'p', L'e', 
L's', L'"', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'f', L'i', L'l', 
L'e', L's', L'p', L'e', L'c', L'"', L' ', L'd', L't', L':', 
L't', L'y', L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', 
L'n', L'g', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', 
L'e', L'd', L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L'F', L'i', L'l', L'e', L' ', L's', L'p', L'e', L'c', 
L'i', L'f', L'i', L'c', L'a', L't', L'i', L'o', L'n', L'.', 
L' ', L' ', L'C', L'a', L'n', L' ', L'i', L'n', L'c', L'l', 
L'u', L'd', L'e', L' ', L'w', L'i', L'l', L'd', L'c', L'a', 
L'r', L'd', L' ', L'c', L'h', L'a', L'r', L'a', L'c', L't', 
L'e', L'r', L's', L' ', L'?', L' ', L'a', L'n', L'd', L' ', 
L'*', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', 
L'\n', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', 
L'e', L'=', L'"', L'p', L'a', L't', L'h', L'"', L' ', L'd', 
L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L's', L't', 
L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', L'q', L'u', 
L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', L's', L'"', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L' ', L' ', L' ', L'P', L'a', L't', L'h', L' ', L't', L'o', 
L' ', L'a', L' ', L'f', L'i', L'l', L'e', L'.', L' ', L' ', 
L'T', L'h', L'e', L' ', L'p', L'a', L't', L'h', L' ', L'c', 
L'a', L'n', L' ', L'i', L'n', L'c', L'l', L'u', L'd', L'e', 
L' ', L'e', L'n', L'v', L'i', L'r', L'o', L'n', L'm', L'e', 
L'n', L't', L' ', L'v', L'a', L'r', L'i', L'a', L'b', L'l', 
L'e', L's', L' ', L'o', L'r', L'\r', L'\n', L' ', L' ', L' ', 
L'v', L'a', L'l', L'u', L'e', L's', L' ', L'e', L'x', L't', 
L'r', L'a', L'c', L't', L'e', L'd', L' ', L'f', L'r', L'o', 
L'm', L' ', L'r', L'e', L'g', L'i', L's', L't', L'r', L'y', 
L' ', L'k', L'e', L'y', L's', L'.', L'\r', L'\n', L' ', L' ', 
L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'r', L'e', 
L'c', L'u', L'r', L's', L'i', L'v', L'e', L'"', L' ', L'd', 
L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L'e', L'n', 
L'u', L'm', L'e', L'r', L'a', L't', L'i', L'o', L'n', L'"', 
L' ', L'd', L't', L':', L'v', L'a', L'l', L'u', L'e', L's', 
L'=', L'"', L'y', L'e', L's', L' ', L'n', L'o', L'"', L' ', 
L'd', L'e', L'f', L'a', L'u', L'l', L't', L'=', L'"', L'n', 
L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L'I', L's', L' ', L'p', L'a', 
L't', L'h', L' ', L's', L'p', L'e', L'c', L'i', L'f', L'i', 
L'e', L'd', L' ', L'r', L'e', L'c', L'u', L'r', L's', L'i', 
L'v', L'e', L' ', L'o', L'r', L' ', L'l', L'i', L'm', L'i', 
L't', L'e', L'd', L' ', L't', L'o', L' ', L't', L'h', L'e', 
L' ', L'd', L'i', L'r', L'e', L'c', L't', L'o', L'r', L'y', 
L' ', L't', L'h', L'a', L't', L' ', L'i', L's', L' ', L's', 
L'p', L'e', L'c', L'i', L'f', L'i', L'e', L'd', L'.', L'\r', 
L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'a', L'l', L't', L'e', L'r', L'n', L'a', L't', L'e', 
L'P', L'a', L't', L'h', L'"', L' ', L'd', L't', L':', L't', 
L'y', L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', L'n', 
L'g', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', 
L'd', L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'A', 
L'l', L't', L'e', L'r', L'n', L'a', L't', L'e', L' ', L'p', 
L'a', L't', L'h', L' ', L'i', L'n', L' ', L'w', L'h', L'i', 
L'c', L'h', L' ', L't', L'o', L' ', L'f', L'i', L'n', L'd', 
L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', L'e', L'.', 
L' ', L' ', L'F', L'i', L'l', L'e', L's', L' ', L'i', L'n', 
L' ', L'a', L' ', L'f', L'i', L'l', L'e', L' ', L'g', L'r', 
L'o', L'u', L'p', L' ', L'm', L'a', L'y', L'\r', L'\n', L' ', 
L' ', L' ', L'h', L'a', L'v', L'e', L' ', L'b', L'e', L'e', 
L'n', L' ', L'c', L'o', L'p', L'i', L'e', L'd', L' ', L't', 
L'o', L' ', L'a', L'n', L' ', L'a', L'l', L't', L'e', L'r', 
L'n', L'a', L't', L'i', L'v', L'e', L' ', L'l', L'o', L'c', 
L'a', L't', L'i', L'o', L'n', L' ', L'b', L'y', L' ', L't', 
L'h', L'e', L' ', L'w', L'r', L'i', L't', L'e', L'r', L'.', 
L' ', L' ', L'B', L'a', L'c', L'k', L'u', L'p', L' ', L's', 
L'h', L'o', L'u', L'l', L'd', L'\r', L'\n', L' ', L' ', L' ', 
L'p', L'i', L'c', L'k', L' ', L'u', L'p', L' ', L't', L'h', 
L'e', L' ', L'f', L'i', L'l', L'e', L's', L' ', L'f', L'r', 
L'o', L'm', L' ', L't', L'h', L'e', L' ', L'a', L'l', L't', 
L'e', L'r', L'n', L'a', L't', L'i', L'v', L'e', L' ', L'l', 
L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', L'i', L'n', 
L's', L't', L'e', L'a', L'd', L' ', L'o', L'f', L' ', L't', 
L'h', L'e', L' ', L'o', L'r', L'i', L'g', L'i', L'n', L'a', 
L'l', L'\r', L'\n', L' ', L' ', L' ', L'l', L'o', L'c', L'a', 
L't', L'i', L'o', L'n', L' ', L'b', L'u', L't', L' ', L's', 
L'h', L'o', L'u', L'l', L'd', L' ', L'r', L'e', L's', L't', 
L'o', L'r', L'e', L' ', L't', L'h', L'e', L' ', L'f', L'i', 
L'l', L'e', L's', L' ', L't', L'o', L' ', L't', L'h', L'e', 
L'i', L'r', L' ', L'o', L'r', L'i', L'g', L'i', L'n', L'a', 
L'l', L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', 
L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'l', L'o', L'g', L'i', L'c', L'a', L'l', L'P', 
L'a', L't', L'h', L'"', L' ', L'd', L't', L':', L't', L'y', 
L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', 
L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', 
L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'L', L'o', 
L'g', L'i', L'c', L'a', L'l', L' ', L'p', L'a', L't', L'h', 
L' ', L'f', L'o', L'r', L' ', L'a', L' ', L'd', L'a', L't', 
L'a', L'b', L'a', L's', L'e', L' ', L'o', L'r', L' ', L'f', 
L'i', L'l', L'e', L' ', L'g', L'r', L'o', L'u', L'p', L'.', 
L' ', L' ', L'T', L'h', L'i', L's', L' ', L'l', L'o', L'g', 
L'i', L'c', L'a', L'l', L' ', L'n', L'a', L'm', L'e', L' ', 
L'u', L's', L'e', L's', L' ', L'b', L'a', L'c', L'k', L's', 
L'l', L'a', L's', L'h', L'\r', L'\n', L' ', L' ', L' ', L'a', 
L's', L' ', L's', L'e', L'p', L'a', L'r', L'a', L't', L'o', 
L'r', L's', L' ', L't', L'o', L' ', L'f', L'o', L'r', L'm', 
L' ', L'a', L' ', L'l', L'o', L'g', L'i', L'c', L'a', L'l', 
L' ', L'n', L'a', L'm', L'e', L's', L'p', L'a', L'c', L'e', 
L' ', L'h', L'i', L'e', L'r', L'a', L'r', L'c', L'h', L'y', 
L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'c', L'o', L'm', L'p', L'o', L'n', L'e', L'n', 
L't', L'N', L'a', L'm', L'e', L'"', L' ', L'd', L't', L':', 
L't', L'y', L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', 
L'n', L'g', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', 
L'e', L'd', L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L'N', L'a', L'm', L'e', L' ', L'u', L's', L'e', L'd', 
L' ', L't', L'o', L' ', L'i', L'd', L'e', L'n', L't', L'i', 
L'f', L'y', L' ', L'a', L' ', L'd', L'a', L't', L'a', L'b', 
L'a', L's', L'e', L' ', L'o', L'r', L' ', L'f', L'i', L'l', 
L'e', L' ', L'g', L'r', L'o', L'u', L'p', L'.', L' ', L' ', 
L'M', L'a', L'y', L' ', L'b', L'e', L' ', L'q', L'u', L'a', 
L'l', L'i', L'f', L'i', L'e', L'd', L' ', L'b', L'y', L' ', 
L'a', L'\r', L'\n', L' ', L' ', L' ', L'l', L'o', L'g', L'i', 
L'c', L'a', L'l', L' ', L'p', L'a', L't', L'h', L'.', L'\r', 
L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'v', L'e', L'r', L's', L'i', L'o', L'n', L'"', L' ', 
L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L'e', 
L'n', L'u', L'm', L'e', L'r', L'a', L't', L'i', L'o', L'n', 
L'"', L' ', L'd', L't', L':', L'v', L'a', L'l', L'u', L'e', 
L's', L'=', L'"', L'1', L'.', L'0', L'"', L' ', L'r', L'e', 
L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', 
L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L'V', L'e', L'r', L's', L'i', 
L'o', L'n', L' ', L'o', L'f', L' ', L'a', L' ', L's', L'p', 
L'e', L'c', L'i', L'f', L'i', L'c', L' ', L'd', L'o', L'c', 
L'u', L'm', L'e', L'n', L't', L'\r', L'\n', L' ', L' ', L' ', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'w', L'r', L'i', 
L't', L'e', L'r', L'I', L'd', L'"', L' ', L'd', L't', L':', 
L't', L'y', L'p', L'e', L'=', L'"', L'u', L'u', L'i', L'd', 
L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', 
L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'U', 
L'n', L'i', L'q', L'u', L'e', L' ', L'i', L'd', L' ', L't', 
L'o', L' ', L'i', L'd', L'e', L'n', L't', L'i', L'f', L'y', 
L' ', L't', L'h', L'e', L' ', L'w', L'r', L'i', L't', L'e', 
L'r', L'.', L' ', L' ', L'N', L'o', L't', L'e', L' ', L't', 
L'h', L'a', L't', L' ', L't', L'h', L'i', L's', L' ', L'i', 
L'd', L'e', L'n', L't', L'i', L'f', L'i', L'e', L's', L' ', 
L't', L'h', L'e', L'\r', L'\n', L' ', L' ', L' ', L'w', L'r', 
L'i', L't', L'e', L'r', L' ', L'c', L'l', L'a', L's', L's', 
L' ', L'r', L'a', L't', L'h', L'e', L'r', L' ', L't', L'h', 
L'a', L'n', L' ', L'a', L' ', L's', L'p', L'e', L'c', L'i', 
L'f', L'i', L'c', L' ', L'i', L'n', L's', L't', L'a', L'n', 
L'c', L'e', L' ', L'o', L'f', L' ', L't', L'h', L'e', L' ', 
L'w', L'r', L'i', L't', L'e', L'r', L'.', L'\r', L'\n', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', 
L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'i', 
L'n', L's', L't', L'a', L'n', L'c', L'e', L'I', L'd', L'"', 
L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', 
L'u', L'u', L'i', L'd', L'"', L' ', L'r', L'e', L'q', L'u', 
L'i', L'r', L'e', L'd', L'=', L'"', L'n', L'o', L'"', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', 
L' ', L' ', L'U', L'n', L'i', L'q', L'u', L'e', L' ', L'i', 
L'd', L' ', L'i', L'd', L'e', L'n', L't', L'i', L'f', L'y', 
L'i', L'n', L'g', L' ', L't', L'h', L'e', L' ', L'i', L'n', 
L's', L't', L'a', L'n', L'c', L'e', L' ', L'o', L'f', L' ', 
L'a', L' ', L'w', L'r', L'i', L't', L'e', L'r', L' ', L'd', 
L'u', L'r', L'i', L'n', L'g', L' ', L'b', L'a', L'c', L'k', 
L'u', L'p', L'.', L' ', L' ', L'I', L't', L'\r', L'\n', L' ', 
L' ', L' ', L'h', L'a', L's', L' ', L'n', L'o', L' ', L'm', 
L'e', L'a', L'n', L'i', L'n', L'g', L' ', L'd', L'u', L'r', 
L'i', L'n', L'g', L' ', L'r', L'e', L's', L't', L'o', L'r', 
L'e', L'.', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', L'm', L'e', L'n', 
L't', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'B', L'A', L'C', L'K', L'U', L'P', L'_', L'C', 
L'O', L'M', L'P', L'O', L'N', L'E', L'N', L'T', L'S', L'"', 
L' ', L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', 
L'e', L'l', L't', L'O', L'n', L'l', L'y', L'"', L' ', L'm', 
L'o', L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', L's', 
L'e', L'd', L'"', L' ', L'o', L'r', L'd', L'e', L'r', L'=', 
L'"', L'm', L'a', L'n', L'y', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'C', 
L'o', L'm', L'p', L'o', L'n', L'e', L'n', L't', L's', L' ', 
L't', L'h', L'a', L't', L' ', L'a', L'r', L'e', L' ', L'b', 
L'a', L'c', L'k', L'e', L'd', L' ', L'u', L'p', L' ', L'o', 
L'r', L' ', L'r', L'e', L's', L't', L'o', L'r', L'e', L'd', 
L'.', L'\r', L'\n', L' ', L' ', L' ', L'U', L's', L'e', L'd', 
L' ', L't', L'o', L' ', L'c', L'o', L'm', L'm', L'u', L'n', 
L'i', L'c', L'a', L't', L'e', L' ', L'b', L'e', L't', L'w', 
L'e', L'e', L'n', L' ', L't', L'h', L'e', L' ', L'w', L'r', 
L'i', L't', L'e', L'r', L' ', L'a', L'n', L'd', L' ', L't', 
L'h', L'e', L' ', L'b', L'a', L'c', L'k', L'u', L'p', L' ', 
L'a', L'p', L'p', L'l', L'i', L'c', L'a', L't', L'i', L'o', 
L'n', L' ', L'd', L'u', L'r', L'i', L'n', L'g', L'\r', L'\n', 
L' ', L' ', L' ', L'b', L'a', L'c', L'k', L'u', L'p', L' ', 
L'a', L'n', L'd', L' ', L'r', L'e', L's', L't', L'o', L'r', 
L'e', L'.', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L's', L'e', L'l', L'e', 
L'c', L't', L'C', L'o', L'm', L'p', L'o', L'n', L'e', L'n', 
L't', L's', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', 
L'e', L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', 
L't', L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', 
L'a', L'l', L'u', L'e', L's', L'=', L'"', L'y', L'e', L's', 
L' ', L'n', L'o', L'"', L' ', L'd', L'e', L'f', L'a', L'u', 
L'l', L't', L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L'D', L'o', L'e', L's', L' ', L't', 
L'h', L'e', L' ', L'b', L'a', L'c', L'k', L'u', L'p', L' ', 
L'a', L'p', L'p', L'l', L'i', L'c', L'a', L't', L'i', L'o', 
L'n', L' ', L's', L'e', L'l', L'e', L'c', L't', L' ', L'i', 
L'n', L'd', L'i', L'v', L'i', L'd', L'u', L'a', L'l', L' ', 
L'c', L'o', L'm', L'p', L'o', L'n', L'e', L'n', L't', L's', 
L' ', L'o', L'r', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L'd', L'o', L'e', L's', L' ', L'i', L't', L' ', L'b', 
L'a', L'c', L'k', L'u', L'p', L' ', L'e', L'n', L't', L'i', 
L'r', L'e', L' ', L'v', L'o', L'l', L'u', L'm', L'e', L's', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'b', L'o', L'o', 
L't', L'a', L'b', L'l', L'e', L'S', L'y', L's', L't', L'e', 
L'm', L'S', L't', L'a', L't', L'e', L'B', L'a', L'c', L'k', 
L'u', L'p', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', 
L'e', L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', 
L't', L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', 
L'a', L'l', L'u', L'e', L's', L'=', L'"', L'y', L'e', L's', 
L' ', L'n', L'o', L'"', L' ', L'd', L'e', L'f', L'a', L'u', 
L'l', L't', L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L'I', L's', L' ', L'b', L'a', L'c', 
L'k', L'u', L'p', L' ', L's', L'a', L'v', L'i', L'n', L'g', 
L' ', L't', L'h', L'e', L' ', L'b', L'o', L'o', L't', L'a', 
L'b', L'l', L'e', L' ', L's', L't', L'a', L't', L'e', L' ', 
L'o', L'f', L' ', L't', L'h', L'e', L' ', L's', L'y', L's', 
L't', L'e', L'm', L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'b', L'a', L'c', L'k', L'u', L'p', L'T', L'y', L'p', 
L'e', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', 
L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', 
L'l', L'u', L'e', L's', L'=', L'"', L'f', L'u', L'l', L'l', 
L' ', L'd', L'i', L'f', L'f', L'e', L'r', L'e', L'n', L't', 
L'i', L'a', L'l', L' ', L'i', L'n', L'c', L'r', L'e', L'm', 
L'e', L'n', L't', L'a', L'l', L' ', L'o', L't', L'h', L'e', 
L'r', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', 
L'd', L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L'T', L'y', L'p', L'e', L' ', L'o', 
L'f', L' ', L'b', L'a', L'c', L'k', L'u', L'p', L' ', L'b', 
L'e', L'i', L'n', L'g', L' ', L'p', L'e', L'r', L'f', L'o', 
L'r', L'm', L'e', L'd', L'.', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'v', L'e', 
L'r', L's', L'i', L'o', L'n', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L's', 
L'e', L'l', L'e', L'c', L't', L'C', L'o', L'm', L'p', L'o', 
L'n', L'e', L'n', L't', L's', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'b', 
L'o', L'o', L't', L'a', L'b', L'l', L'e', L'S', L'y', L's', 
L't', L'e', L'm', L'S', L't', L'a', L't', L'e', L'B', L'a', 
L'c', L'k', L'u', L'p', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'b', L'a', 
L'c', L'k', L'u', L'p', L'T', L'y', L'p', L'e', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', 
L'e', L'n', L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'W', L'R', L'I', L'T', L'E', L'R', L'_', L'C', L'O', L'M', 
L'P', L'O', L'N', L'E', L'N', L'T', L'S', L'"', L'/', L'>', 
L'\r', L'\n', L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', 
L'n', L't', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', 
L'<', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', 
L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'W', 
L'R', L'I', L'T', L'E', L'R', L'_', L'C', L'O', L'M', L'P', 
L'O', L'N', L'E', L'N', L'T', L'S', L'"', L' ', L'c', L'o', 
L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', L'l', L't', 
L'O', L'n', L'l', L'y', L'"', L' ', L'm', L'o', L'd', L'e', 
L'l', L'=', L'"', L'c', L'l', L'o', L's', L'e', L'd', L'"', 
L' ', L'o', L'r', L'd', L'e', L'r', L'=', L'"', L'm', L'a', 
L'n', L'y', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L' ', L' ', L' ', L'C', L'o', L'm', L'p', 
L'o', L'n', L'e', L'n', L't', L's', L' ', L't', L'h', L'a', 
L't', L' ', L'a', L'r', L'e', L' ', L'b', L'a', L'c', L'k', 
L'e', L'd', L' ', L'u', L'p', L' ', L'a', L'n', L'd', L' ', 
L'r', L'e', L's', L't', L'o', L'r', L'e', L'd', L' ', L't', 
L'h', L'a', L't', L' ', L'a', L'r', L'e', L' ', L'a', L's', 
L's', L'o', L'c', L'i', L'a', L't', L'e', L'd', L' ', L'w', 
L'i', L't', L'h', L' ', L'a', L'\r', L'\n', L' ', L' ', L' ', 
L's', L'p', L'e', L'c', L'i', L'f', L'i', L'c', L' ', L'w', 
L'r', L'i', L't', L'e', L'r', L' ', L'i', L'n', L's', L't', 
L'a', L'n', L'c', L'e', L'\r', L'\n', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'w', L'r', L'i', L't', L'e', L'r', 
L'I', L'd', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'i', L'n', L's', L't', 
L'a', L'n', L'c', L'e', L'I', L'd', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', 
L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'C', L'O', 
L'M', L'P', L'O', L'N', L'E', L'N', L'T', L'"', L'/', L'>', 
L'\r', L'\n', L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', 
L'n', L't', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', 
L'<', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', 
L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'C', 
L'O', L'M', L'P', L'O', L'N', L'E', L'N', L'T', L'"', L' ', 
L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', 
L'l', L't', L'O', L'n', L'l', L'y', L'"', L' ', L'm', L'o', 
L'd', L'e', L'l', L'=', L'"', L'o', L'p', L'e', L'n', L'"', 
L' ', L'o', L'r', L'd', L'e', L'r', L'=', L'"', L'm', L'a', 
L'n', L'y', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'b', 
L'a', L'c', L'k', L'u', L'p', L'S', L'u', L'c', L'c', L'e', 
L'e', L'd', L'e', L'd', L'"', L' ', L'd', L't', L':', L't', 
L'y', L'p', L'e', L'=', L'"', L'e', L'n', L'u', L'm', L'e', 
L'r', L'a', L't', L'i', L'o', L'n', L'"', L' ', L'd', L't', 
L':', L'v', L'a', L'l', L'u', L'e', L's', L'=', L'"', L'y', 
L'e', L's', L' ', L'n', L'o', L'"', L' ', L'd', L'e', L'f', 
L'a', L'u', L'l', L't', L'=', L'"', L'n', L'o', L'"', L'>', 
L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L' ', L' ', L' ', L' ', L' ', L' ', L'I', L'n', L'd', L'i', 
L'c', L'a', L't', L'i', L'o', L'n', L' ', L'o', L'f', L' ', 
L'w', L'h', L'e', L't', L'h', L'e', L'r', L' ', L't', L'h', 
L'e', L' ', L'c', L'o', L'm', L'p', L'o', L'n', L'e', L'n', 
L't', L' ', L'w', L'a', L's', L' ', L'b', L'a', L'c', L'k', 
L'e', L'd', L' ', L'u', L'p', L' ', L's', L'u', L'c', L'c', 
L'e', L's', L's', L'f', L'u', L'l', L'l', L'y', L'\r', L'\n', 
L' ', L' ', L' ', L' ', L' ', L' ', L'o', L'r', L' ', L'n', 
L'o', L't', L'.', L' ', L' ', L'T', L'h', L'i', L's', L' ', 
L's', L'h', L'o', L'u', L'l', L'd', L' ', L'b', L'e', L' ', 
L's', L'e', L't', L' ', L'd', L'u', L'r', L'i', L'n', L'g', 
L' ', L't', L'h', L'e', L' ', L'B', L'a', L'c', L'k', L'u', 
L'p', L'C', L'o', L'm', L'p', L'l', L'e', L't', L'e', L' ', 
L'n', L'o', L't', L'i', L'f', L'i', L'c', L'a', L't', L'i', 
L'o', L'n', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'c', 
L'o', L'm', L'p', L'o', L'n', L'e', L'n', L't', L'T', L'y', 
L'p', L'e', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', 
L'e', L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', 
L't', L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', 
L'a', L'l', L'u', L'e', L's', L'=', L'"', L'd', L'a', L't', 
L'a', L'b', L'a', L's', L'e', L' ', L'f', L'i', L'l', L'e', 
L'g', L'r', L'o', L'u', L'p', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L'I', L'n', L'd', L'i', L'c', L'a', 
L't', L'i', L'o', L'n', L' ', L'o', L'f', L' ', L'w', L'h', 
L'e', L't', L'h', L'e', L'r', L' ', L'c', L'o', L'm', L'p', 
L'o', L'n', L'e', L'n', L't', L' ', L'i', L's', L' ', L'd', 
L'a', L't', L'a', L'b', L'a', L's', L'e', L' ', L'o', L'r', 
L' ', L'f', L'i', L'l', L'e', L' ', L'g', L'r', L'o', L'u', 
L'p', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'c', L'o', L'm', L'p', L'o', 
L'n', L'e', L'n', L't', L'T', L'y', L'p', L'e', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'l', L'o', L'g', L'i', L'c', L'a', L'l', L'P', 
L'a', L't', L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'c', L'o', L'm', 
L'p', L'o', L'n', L'e', L'n', L't', L'N', L'a', L'm', L'e', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'b', L'a', L'c', L'k', L'u', L'p', 
L'S', L'u', L'c', L'c', L'e', L'e', L'd', L'e', L'd', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', 
L'm', L'e', L'n', L't', L' ', L't', L'y', L'p', L'e', L'=', 
L'"', L'B', L'A', L'C', L'K', L'U', L'P', L'_', L'M', L'E', 
L'T', L'A', L'D', L'A', L'T', L'A', L'"', L' ', L'm', L'i', 
L'n', L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', 
L'"', L' ', L'm', L'a', L'x', L'O', L'c', L'c', L'u', L'r', 
L's', L'=', L'"', L'1', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'A', L'L', L'T', L'E', 
L'R', L'N', L'A', L'T', L'E', L'_', L'L', L'O', L'C', L'A', 
L'T', L'I', L'O', L'N', L'_', L'M', L'A', L'P', L'P', L'I', 
L'N', L'G', L'"', L' ', L'm', L'i', L'n', L'O', L'c', L'c', 
L'u', L'r', L's', L'=', L'"', L'0', L'"', L' ', L'm', L'a', 
L'x', L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'*', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'E', L'l', 
L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', L'm', L'e', L'n', 
L't', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'A', L'L', L'T', L'E', L'R', L'N', L'A', L'T', 
L'E', L'_', L'L', L'O', L'C', L'A', L'T', L'I', L'O', L'N', 
L'_', L'M', L'A', L'P', L'P', L'I', L'N', L'G', L'"', L' ', 
L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', 
L'm', L'p', L't', L'y', L'"', L' ', L'm', L'o', L'd', L'e', 
L'l', L'=', L'"', L'c', L'l', L'o', L's', L'e', L'd', L'"', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L' ', L' ', L' ', L' ', L' ', L'M', L'a', L'p', L'p', L'i', 
L'n', L'g', L' ', L'f', L'r', L'o', L'm', L' ', L'a', L' ', 
L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', L't', 
L'h', L'a', L't', L' ', L'w', L'a', L's', L' ', L'b', L'a', 
L'c', L'k', L'e', L'd', L' ', L'u', L'p', L' ', L't', L'o', 
L' ', L'a', L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', 
L'n', L' ', L't', L'o', L' ', L'r', L'e', L's', L't', L'o', 
L'r', L'e', L' ', L't', L'o', L'.', L'\r', L'\n', L' ', L' ', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'p', L'a', L't', L'h', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'f', L'i', L'l', L'e', L's', L'p', L'e', 
L'c', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'r', L'e', L'c', L'u', L'r', 
L's', L'i', L'v', L'e', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'a', L'l', 
L't', L'e', L'r', L'n', L'a', L't', L'e', L'P', L'a', L't', 
L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'E', 
L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', 
L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', L'm', L'e', 
L'n', L't', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', 
L'e', L'=', L'"', L'B', L'A', L'C', L'K', L'U', L'P', L'_', 
L'M', L'E', L'T', L'A', L'D', L'A', L'T', L'A', L'"', L' ', 
L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', 
L'm', L'p', L't', L'y', L'"', L' ', L'm', L'o', L'd', L'e', 
L'l', L'=', L'"', L'c', L'l', L'o', L's', L'e', L'd', L'"', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L' ', L' ', L' ', L'D', L'e', L'f', L'a', L'u', L'l', L't', 
L' ', L'm', L'e', L't', L'a', L'd', L'a', L't', L'a', L' ', 
L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', L'f', L'o', 
L'r', L' ', L'b', L'a', L'c', L'k', L'u', L'p', L'.', L' ', 
L' ', L'C', L'o', L'n', L't', L'e', L'n', L't', L' ', L'i', 
L's', L' ', L'a', L' ', L'b', L'i', L'n', L'a', L'r', L'y', 
L' ', L'h', L'e', L'x', L' ', L's', L't', L'r', L'i', L'n', 
L'g', L'.', L'\r', L'\n', L' ', L' ', L' ', L'N', L'o', L't', 
L'e', L' ', L't', L'h', L'a', L't', L' ', L't', L'h', L'e', 
L' ', L'w', L'r', L'i', L't', L'e', L'r', L' ', L'c', L'a', 
L'n', L' ', L's', L't', L'o', L'r', L'e', L' ', L'w', L'h', 
L'a', L't', L'e', L'v', L'e', L'r', L' ', L'h', L'e', L' ', 
L'w', L'a', L'n', L't', L's', L' ', L'i', L'n', L' ', L't', 
L'h', L'e', L' ', L'c', L'o', L'm', L'p', L'o', L'n', L'e', 
L'n', L't', L'.', L' ', L' ', L'T', L'h', L'i', L's', L'\r', 
L'\n', L' ', L' ', L' ', L'i', L's', L' ', L'j', L'u', L's', 
L't', L' ', L'a', L' ', L's', L'i', L'm', L'p', L'l', L'e', 
L' ', L'd', L'e', L'f', L'a', L'u', L'l', L't', L' ', L'm', 
L'e', L'c', L'h', L'a', L'n', L'i', L's', L'm', L'.', L'\r', 
L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', 
L'e', L'=', L'"', L'm', L'e', L't', L'a', L'd', L'a', L't', 
L'a', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', 
L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', 
L'y', L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', 
L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L'M', L'e', L't', L'a', L'd', L'a', L't', L'a', L' ', 
L't', L'o', L' ', L'b', L'e', L' ', L'p', L'a', L's', L's', 
L'e', L'd', L' ', L'o', L'n', L' ', L'r', L'e', L's', L't', 
L'o', L'r', L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'm', L'e', L't', L'a', 
L'd', L'a', L't', L'a', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'<', L'/', L'S', L'c', 
L'h', L'e', L'm', L'a', L'>', L'\r', L'\n', 
L'\n', L'<', L'/', L'r', L'o', L'o', L't', L'>', L'\n', L'\0'
};
const unsigned g_cwcComponentMetadataXML = 5626;


const unsigned g_iwcComponentMetadataXMLBegin = 7;


const unsigned g_iwcComponentMetadataXMLEnd = 5617;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\inc\version.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    version.h

Abstract:

    Declaration of the version numbers for VSS modules
	Used by version.rc2

Revision History:

    Name        Date        Comments
    aoltean     03/12/99    Created with version 0.1.1, build number 1
    aoltean     09/09/1999  dss -> vss
	aoltean		03/09/2000  Uniform versioning

--*/

// general purpose macros
#define EVAL_MACRO(X) X
#define STRINGIZE_ARG(X) #X
#define STRINGIZE(X) EVAL_MACRO(STRINGIZE_ARG(X))


// Version and build number defines
#define VSS_MAJOR_VERSION  1
#define VSS_MINOR_VERSION  0
#define VSS_FIX_VERSION    0

// Definition for VSS_BUILD_NO
#include "build.h"

// Macros used in resource files
#define VSS_FILEVERSION            VSS_MAJOR_VERSION, VSS_MINOR_VERSION, VSS_FIX_VERSION, VSS_BUILD_NO
#define VSS_PRODUCTVERSION         VSS_MAJOR_VERSION, VSS_MINOR_VERSION, VSS_FIX_VERSION, VSS_BUILD_NO

#define VSS_FILE_VERSION_STR           \
    STRINGIZE(VSS_MAJOR_VERSION) ", "  \
    STRINGIZE(VSS_MINOR_VERSION) ", "  \
    STRINGIZE(VSS_FIX_VERSION) ", "    \
    STRINGIZE(VSS_BUILD_NO)            \
	"\0"

#define VSS_PRODUCT_VERSION_STR        \
    STRINGIZE(VSS_MAJOR_VERSION) ", "  \
    STRINGIZE(VSS_MINOR_VERSION) ", "  \
    STRINGIZE(VSS_FIX_VERSION) ", "    \
    STRINGIZE(VSS_BUILD_NO)            \
	"\0"

#define VSS_COMPANY_NAME		"Microsoft Corporation\0"
#define VSS_LEGAL_COPYRIGHT		"Copyright  2000 by Microsoft Corporation\0"
#define VSS_LEGAL_TRADEMARKS	"Microsoft is a registered trademark of Microsoft Corporation. \0"
#define VSS_PRODUCT_NAME		"Microsoft Windows 2000 Operating System\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\inc\sqlwriter.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module sqlwriter.h | Declaration of the sql wrier
    @end

Author:

    Brian Berkowitz  [brianb]  04/17/2000

TBD:
	
	Add comments.

Revision History:

	Name		Date	    Comments
	brianb		04/17/2000  created
	brianb		05/05/2000  added OnIdentify support
	mikejohn	09/18/2000  176860: Added calling convention methods where missing

--*/

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "INCSQLWH"
//
////////////////////////////////////////////////////////////////////////

#ifndef __SQLWRITER_H_
#define __SQLWRITER_H_

class CSqlWriter :
	public CVssWriter,
	public CCheckPath
	{
public:
	STDMETHODCALLTYPE CSqlWriter() :
				m_pSqlSnapshot(NULL),
				m_fFrozen(false)
	    {
	    }

	STDMETHODCALLTYPE ~CSqlWriter()
	    {
	    delete m_pSqlSnapshot;
	    }

	bool STDMETHODCALLTYPE OnIdentify(IVssCreateWriterMetadata *pMetadata);

	bool STDMETHODCALLTYPE OnPrepareSnapshot();

	bool STDMETHODCALLTYPE OnFreeze();

	bool STDMETHODCALLTYPE OnThaw();

	bool STDMETHODCALLTYPE OnAbort();

	bool IsPathInSnapshot(const WCHAR *path) throw();

	HRESULT STDMETHODCALLTYPE Initialize();

	HRESULT STDMETHODCALLTYPE Uninitialize();
private:
	CSqlSnapshot *m_pSqlSnapshot;

	void TranslateWriterError(HRESULT hr);

	bool m_fFrozen;
	};

// wrapper class used to create and destroy the writer
// used by coordinator
class CVssSqlWriterWrapper
	{
public:
	__declspec(dllexport)
	CVssSqlWriterWrapper();
	
	__declspec(dllexport)
	~CVssSqlWriterWrapper();

	__declspec(dllexport)
	HRESULT CreateSqlWriter();

	__declspec(dllexport)
	void DestroySqlWriter();
private:
	// initialization function
	static DWORD InitializeThreadFunc(VOID *pv);

	CSqlWriter *m_pSqlWriter;

	// result of initialization
	HRESULT m_hrInitialize;
	};


	
	
#endif // _SQLWRITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\inc\vswrtimp.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Writer.h | Declaration of Writer
    @end

Author:

    Adi Oltean  [aoltean]  08/18/1999

TBD:
	
	Add comments.

Revision History:

	Name		Date        Comments
	aoltean		08/18/1999  Created
	brianb		05/03/2000  Changed for new security model
	brianb		05/09/2000  fix problem with autolocks
	mikejohn	06/23/2000  Add connection for SetWriterFailure()
--*/


#ifndef __CVSS_WRITER_IMPL_H_
#define __CVSS_WRITER_IMPL_H_


// forward declarations
class CVssWriterImplStateMachine;
class CVssCreateWriterMetadata;
class CVssWriterComponents;
class IVssWriterComponentsInt;

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "INCWRMPH"
//
////////////////////////////////////////////////////////////////////////


// implementation class for writers
class IVssWriterImpl : public IVssWriter
	{
public:
	// initialize writer
	virtual void Initialize
		(
		VSS_ID writerId,
		LPCWSTR wszWriterName,
		VSS_USAGE_TYPE ut,
		VSS_SOURCE_TYPE st,
		VSS_APPLICATION_LEVEL nLevel,
		DWORD dwTimeout
		) = 0;

    // subscribe to events
	virtual void Subscribe
		(
		) = 0;

    // unsubscribe from events
	virtual void Unsubscribe
		(
		) = 0;

    // get array of volume names
	virtual LPCWSTR *GetCurrentVolumeArray() const = 0;

	// get # of volumes in volume array
	virtual UINT GetCurrentVolumeCount() const = 0;

	// get id of snapshot set
	virtual VSS_ID GetCurrentSnapshotSetId() const = 0;

	// determine which Freeze event writer responds to
	virtual VSS_APPLICATION_LEVEL GetCurrentLevel() const = 0;

	// determine if path is included in the snapshot
	virtual bool IsPathAffected(IN LPCWSTR wszPath) const = 0;

	// determine if bootable state is backed up
	virtual bool IsBootableSystemStateBackedUp() const = 0;

	// determine if the backup application is selecting components
	virtual bool AreComponentsSelected() const = 0;

	// determine the backup type for the backup
	virtual VSS_BACKUP_TYPE GetBackupType() const = 0;

	// let writer pass back indication of reason for failure
    virtual HRESULT SetWriterFailure(HRESULT hr) = 0;
	};


/////////////////////////////////////////////////////////////////////////////
// CVssWriterImpl


class ATL_NO_VTABLE CVssWriterImpl :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IVssWriterImpl
	{

public:
	friend class CVssWriterImplLock;

	// Constructors & Destructors
	CVssWriterImpl();

	~CVssWriterImpl();

// Exposed operations
public:
	// create a writer implementation for a specific writer
	static void CreateWriter
		(
		CVssWriter *pWriter,
		IVssWriterImpl **ppImpl
		);

	// set external writer object
    void SetWriter(CVssWriter *pWriter)
		{
		BS_ASSERT(pWriter);
		m_pWriter = pWriter;
		}

	// initialize class
	void Initialize
		(
		IN VSS_ID WriterID,
		IN LPCWSTR wszWriterName,
		IN VSS_USAGE_TYPE ut,
		IN VSS_SOURCE_TYPE st,
		IN VSS_APPLICATION_LEVEL nLevel,
		IN DWORD dwTimeoutFreeze
		);

    // subscribe to writer events
	void Subscribe
		(
		);

	// unsubscribe from writer events
	void Unsubscribe
		(
		);

    // get array of volume names
	LPCWSTR* GetCurrentVolumeArray() const { return (LPCWSTR *) m_ppwszVolumesArray; };

	// get count of volumes in array
	UINT GetCurrentVolumeCount() const { return m_nVolumesCount; };

	// get id of snapshot
	VSS_ID GetCurrentSnapshotSetId() const { return m_CurrentSnapshotSetId; };

	// get level at which freeze takes place
	VSS_APPLICATION_LEVEL GetCurrentLevel() const { return m_nLevel; };

	// determine if path is included in the snapshot
	bool IsPathAffected(IN	LPCWSTR wszPath) const;

	// determine if the backup is including bootable system state
	bool IsBootableSystemStateBackedUp() const
		{ return m_bBootableSystemStateBackup ? true : false; }

    // determine if the backup selects components
	bool AreComponentsSelected() const
		{ return m_bComponentsSelected ? true : false; }

	// return the type of backup
	VSS_BACKUP_TYPE GetBackupType() const { return m_backupType; }

	// indicate why the writer failed
	HRESULT SetWriterFailure(HRESULT hr);

// IVssWriter ovverides
public:

BEGIN_COM_MAP(CVssWriterImpl)
	COM_INTERFACE_ENTRY(IVssWriter)
END_COM_MAP()

	// request WRITER_METADATA or writer state
    STDMETHOD(RequestWriterInfo)(
        IN  	BSTR bstrSnapshotSetId,
		IN  	BOOL bWriterMetadata,
		IN  	BOOL bWriterState,
		IN  	IDispatch* pWriterCallback		
        );

    // prepare for backup event
    STDMETHOD(PrepareForBackup)(
        IN  	BSTR bstrSnapshotSetId,					
		IN  	IDispatch* pWriterCallback
        );

	// prepare for snapshot event
    STDMETHOD(PrepareForSnapshot)(
        IN  	BSTR bstrSnapshotSetId,					
        IN  	BSTR VolumeNamesList
        );

    // freeze event
    STDMETHOD(Freeze)(
        IN      BSTR bstrSnapshotSetId,
        IN      INT nApplicationLevel
        );

    // thaw event
    STDMETHOD(Thaw)(
        IN      BSTR bstrSnapshotSetId
        );

    // backup complete event
    STDMETHOD(BackupComplete)(
        IN      BSTR bstrSnapshotSetId,
		IN  	IDispatch* pWriterCallback
        );

    // abort event
    STDMETHOD(Abort)(
        IN      BSTR bstrSnapshotSetId
        );

    STDMETHOD(PostRestore)(
		IN  	IDispatch* pWriterCallback
        );

    STDMETHOD(PreRestore)(
		IN  	IDispatch* pWriterCallback
        );


    STDMETHOD(PostSnapshot)(
		IN		BSTR bstrSnapshotSestId,
		IN		IDispatch* pWriterCallback
		);




// Implementation - methods
private:
	enum VSS_EVENT_MASK
		{
		VSS_EVENT_PREPAREBACKUP		= 0x00000001,
		VSS_EVENT_PREPARESNAPSHOT	= 0x00000002,
		VSS_EVENT_FREEZE			= 0x00000004,
		VSS_EVENT_THAW				= 0x00000008,
		VSS_EVENT_ABORT				= 0x00000010,
		VSS_EVENT_BACKUPCOMPLETE	= 0x00000020,
		VSS_EVENT_REQUESTINFO		= 0x00000040,
		VSS_EVENT_RESTORE			= 0x00000080,
		VSS_EVENT_ALL				= 0xff,
		};

    // get WRITER callback from IDispatch
	void GetCallback
		(
		IN IDispatch *pWriterCallback,
		OUT IVssWriterCallback **ppCallback
		);

    // reset state machine
	void ResetSequence
		(
		IN bool bCalledFromTimerThread
		);

    // abort the current snapshot sequence
	void DoAbort
		(
		IN bool bCalledFromTimerThread
		);

    // obtain components for this writer
    void InternalGetWriterComponents
		(
		IN IVssWriterCallback *pCallback,
		OUT IVssWriterComponentsInt **ppWriter,
		bool bWriteable
		);

    // create WRITER_METADATA XML document
	CVssCreateWriterMetadata *CreateBasicWriterMetadata
		(
		);

	// startup routine for timer thread
    static DWORD StartTimerThread(void *pv);

	// function to run in timer thread
	void TimerFunc(VSS_ID id);

	// enter a state
	bool EnterState
		(
		IN const CVssWriterImplStateMachine &vwsm,
		IN BSTR bstrSnapshotSetId
		) throw(HRESULT);

	// leave a state
	void LeaveState
		(
		IN const CVssWriterImplStateMachine &vwsm,
		IN bool fSuccessful
		);

    // create a Handle to an event
    void SetupEvent
		(
		IN HANDLE *phevt
		) throw(HRESULT);

    // begin a sequence to create a snapshot
    void BeginSequence
		(
		IN CVssID &SnapshotSetId
		) throw(HRESULT);

    INT SearchForPreviousSequence(
        IN  VSS_ID& idSnapshotSet
        );

    // terminate timer thread
	void TerminateTimerThread();

	// lock critical section
	inline void Lock()
		{
		m_cs.Lock();
		m_bLocked = true;
		}

	// unlock critical section
	inline void Unlock()
		{
		m_bLocked = false;
		m_cs.Unlock();
		}

	// assert that critical section is locked
	inline void AssertLocked()
		{
		BS_ASSERT(m_bLocked);
		}

// Implementation - members
private:
    enum VSS_TIMER_COMMAND
        {
        VSS_TC_UNDEFINED,
		VSS_TC_ABORT_CURRENT_SEQUENCE,
        VSS_TC_TERMINATE_THREAD,
		VSS_TIMEOUT_FREEZE = 60*1000,			// 30 seconds
		VSS_STACK_SIZE = 256 * 1024			// 256K
        };

    enum
		{
		x_MAX_SUBSCRIPTIONS = 32
		};



	// data related to writer

	// writer class id
	VSS_ID m_WriterID;

	// writer instance id
	VSS_ID m_InstanceID;

	// usage type for writer
	VSS_USAGE_TYPE m_usage;

	// data source type for writer
	VSS_SOURCE_TYPE m_source;

	// writer name
	LPWSTR m_wszWriterName;

	// Data related to the current sequence

	// snapshot set id
	VSS_ID m_CurrentSnapshotSetId;

	// volume array list passed in as a string
	LPWSTR m_pwszLocalVolumeNameList;

	// # of volumes in volume array
	INT m_nVolumesCount;

	// volume array
	LPWSTR* m_ppwszVolumesArray;

	// pointer to writer callback
	CComPtr<IVssWriterCallback> m_pWriterCallback;

	// are we currently in a sequence
	bool m_bSequenceInProgress;

	// current state of the writer
    VSS_WRITER_STATE m_state;

	// Subscription-related data
	CComBSTR m_bstrSubscriptionName;

	// actual subscription ids
	CComBSTR m_rgbstrSubscriptionId[x_MAX_SUBSCRIPTIONS];

	// number of allocated subscription ids
	UINT m_cbstrSubscriptionId;
	
	// Data related with the Writer object

	// which freeze event is handled
	VSS_APPLICATION_LEVEL m_nLevel;

	// what events are subscribed to
	DWORD m_dwEventMask;

	// count of subscriptions
	INT m_nSubscriptionsCount;

	// Critical section or avoiding race between tasks
	CVssSafeCriticalSection				m_cs;

	// was critical section initialized
	bool m_bLockCreated;

	// flag indicating if critical section is locked
	bool m_bLocked;

    // timeout and queuing mechanisms
    HANDLE m_hevtTimerThread;       // event used to signal timer thread if timer is aborted
    HANDLE m_hmtxTimerThread;  		// mutex used to guarantee only one timer thread exists at a time
	HANDLE m_hThreadTimerThread;	// handle to timer thread
	VSS_TIMER_COMMAND m_command;	// timer command when it exits the wait
	DWORD m_dwTimeoutFreeze;		// timeout for freeze

	// actual writer implementation
	CVssWriter *m_pWriter;


	// state of backup components
	BOOL m_bBootableSystemStateBackup;
	BOOL m_bComponentsSelected;
	VSS_BACKUP_TYPE m_backupType;

	// indication why the writer failed
	HRESULT m_hrWriterFailure;
	
	// structures to keep track of writer status from previous snapshots
	enum
		{
		MAX_PREVIOUS_SNAPSHOTS = 8,
		INVALID_SEQUENCE_INDEX = -1
		};

	// snapshot ids of previous snapshots
	VSS_ID m_rgidPreviousSnapshots[MAX_PREVIOUS_SNAPSHOTS];

	// status from previous snapshots
	VSS_WRITER_STATE m_rgstatePreviousSnapshots[MAX_PREVIOUS_SNAPSHOTS];

	// failure reasons from previous snapshots
	HRESULT m_rghrWriterFailurePreviousSnapshots[MAX_PREVIOUS_SNAPSHOTS];

	// current slot for dumping a previous snapshots result
	UINT m_iPreviousSnapshots;

    // TRUE if an OnPrepareForBackup/Freeze/Thaw
    // was sent and without a corresponding OnAbort
	bool m_bOnAbortPermitted;

    // FALSE if an previous OnIdentify failed
    // TRUE if OnIdentify succeeded or was not called at all
	bool m_bFailedAtIdentify;
	};


// auto class for locks
class CVssWriterImplLock
	{
public:
	CVssWriterImplLock(CVssWriterImpl *pImpl) :
		m_pImpl(pImpl)
		{
		m_pImpl->Lock();
		}

	~CVssWriterImplLock()
		{
		m_pImpl->Unlock();
		}

private:
	CVssWriterImpl *m_pImpl;
	};




#endif //__CVSS_WRITER_IMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\backupext\wmxml.c ===
WCHAR g_WriterMetadataXML[] = 
{
L'<', L'S', L'c', L'h', L'e', L'm', L'a', L' ', L'n', L'a', 
L'm', L'e', L'=', L'"', L'V', L's', L's', L'W', L'r', L'i', 
L't', L'e', L'r', L'M', L'e', L't', L'a', L'd', L'a', L't', 
L'a', L'I', L'n', L'f', L'o', L'"', L' ', L'x', L'm', L'l', 
L'n', L's', L'=', L'"', L'u', L'r', L'n', L':', L's', L'c', 
L'h', L'e', L'm', L'a', L's', L'-', L'm', L'i', L'c', L'r', 
L'o', L's', L'o', L'f', L't', L'-', L'c', L'o', L'm', L':', 
L'x', L'm', L'l', L'-', L'd', L'a', L't', L'a', L'"', L' ', 
L'x', L'm', L'l', L'n', L's', L':', L'd', L't', L'=', L'"', 
L'u', L'r', L'n', L':', L's', L'c', L'h', L'e', L'm', L'a', 
L's', L'-', L'm', L'i', L'c', L'r', L'o', L's', L'o', L'f', 
L't', L'-', L'c', L'o', L'm', L':', L'd', L'a', L't', L'a', 
L't', L'y', L'p', L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'f', L'i', L'l', L'e', L's', L'p', L'e', L'c', L'"', 
L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', 
L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', 
L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', 
L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L'F', L'i', L'l', L'e', L' ', 
L's', L'p', L'e', L'c', L'i', L'f', L'i', L'c', L'a', L't', 
L'i', L'o', L'n', L'.', L' ', L' ', L'C', L'a', L'n', L' ', 
L'i', L'n', L'c', L'l', L'u', L'd', L'e', L' ', L'w', L'i', 
L'l', L'd', L'c', L'a', L'r', L'd', L' ', L'c', L'h', L'a', 
L'r', L'a', L'c', L't', L'e', L'r', L's', L' ', L'?', L' ', 
L'a', L'n', L'd', L' ', L'*', L'\r', L'\n', L' ', L' ', L' ', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'p', L'a', L't', 
L'h', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', 
L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', 
L'y', L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'P', L'a', L't', 
L'h', L' ', L't', L'o', L' ', L'a', L' ', L'f', L'i', L'l', 
L'e', L'.', L' ', L' ', L'T', L'h', L'e', L' ', L'p', L'a', 
L't', L'h', L' ', L'c', L'a', L'n', L' ', L'i', L'n', L'c', 
L'l', L'u', L'd', L'e', L' ', L'e', L'n', L'v', L'i', L'r', 
L'o', L'n', L'm', L'e', L'n', L't', L' ', L'v', L'a', L'r', 
L'i', L'a', L'b', L'l', L'e', L's', L' ', L'o', L'r', L'\r', 
L'\n', L' ', L' ', L' ', L'v', L'a', L'l', L'u', L'e', L's', 
L' ', L'e', L'x', L't', L'r', L'a', L'c', L't', L'e', L'd', 
L' ', L'f', L'r', L'o', L'm', L' ', L'r', L'e', L'g', L'i', 
L's', L't', L'r', L'y', L' ', L'k', L'e', L'y', L's', L'.', 
L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'r', L'e', L'c', L'u', L'r', L's', L'i', L'v', 
L'e', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', 
L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', 
L'l', L'u', L'e', L's', L'=', L'"', L'y', L'e', L's', L' ', 
L'n', L'o', L'"', L' ', L'd', L'e', L'f', L'a', L'u', L'l', 
L't', L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'I', 
L's', L' ', L'p', L'a', L't', L'h', L' ', L's', L'p', L'e', 
L'c', L'i', L'f', L'i', L'e', L'd', L' ', L'r', L'e', L'c', 
L'u', L'r', L's', L'i', L'v', L'e', L' ', L'o', L'r', L' ', 
L'l', L'i', L'm', L'i', L't', L'e', L'd', L' ', L't', L'o', 
L' ', L't', L'h', L'e', L' ', L'd', L'i', L'r', L'e', L'c', 
L't', L'o', L'r', L'y', L' ', L't', L'h', L'a', L't', L' ', 
L'i', L's', L' ', L's', L'p', L'e', L'c', L'i', L'f', L'i', 
L'e', L'd', L'.', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L'a', L'l', L't', L'e', L'r', 
L'n', L'a', L't', L'e', L'P', L'a', L't', L'h', L'"', L' ', 
L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L's', 
L't', L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', L'q', 
L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'n', L'o', L'"', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L' ', L' ', L' ', L'A', L'l', L't', L'e', L'r', L'n', L'a', 
L't', L'e', L' ', L'p', L'a', L't', L'h', L' ', L'i', L'n', 
L' ', L'w', L'h', L'i', L'c', L'h', L' ', L't', L'o', L' ', 
L'f', L'i', L'n', L'd', L' ', L't', L'h', L'e', L' ', L'f', 
L'i', L'l', L'e', L'.', L' ', L' ', L'F', L'i', L'l', L'e', 
L's', L' ', L'i', L'n', L' ', L'a', L' ', L'f', L'i', L'l', 
L'e', L' ', L'g', L'r', L'o', L'u', L'p', L' ', L'm', L'a', 
L'y', L'\r', L'\n', L' ', L' ', L' ', L'h', L'a', L'v', L'e', 
L' ', L'b', L'e', L'e', L'n', L' ', L'c', L'o', L'p', L'i', 
L'e', L'd', L' ', L't', L'o', L' ', L'a', L'n', L' ', L'a', 
L'l', L't', L'e', L'r', L'n', L'a', L't', L'i', L'v', L'e', 
L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', 
L'b', L'y', L' ', L't', L'h', L'e', L' ', L'w', L'r', L'i', 
L't', L'e', L'r', L'.', L' ', L' ', L'B', L'a', L'c', L'k', 
L'u', L'p', L' ', L's', L'h', L'o', L'u', L'l', L'd', L'\r', 
L'\n', L' ', L' ', L' ', L'p', L'i', L'c', L'k', L' ', L'u', 
L'p', L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', L'e', 
L's', L' ', L'f', L'r', L'o', L'm', L' ', L't', L'h', L'e', 
L' ', L'a', L'l', L't', L'e', L'r', L'n', L'a', L't', L'i', 
L'v', L'e', L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', 
L'n', L' ', L'i', L'n', L's', L't', L'e', L'a', L'd', L' ', 
L'o', L'f', L' ', L't', L'h', L'e', L' ', L'o', L'r', L'i', 
L'g', L'i', L'n', L'a', L'l', L'\r', L'\n', L' ', L' ', L' ', 
L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', L'b', 
L'u', L't', L' ', L's', L'h', L'o', L'u', L'l', L'd', L' ', 
L'r', L'e', L's', L't', L'o', L'r', L'e', L' ', L't', L'h', 
L'e', L' ', L'f', L'i', L'l', L'e', L's', L' ', L't', L'o', 
L' ', L't', L'h', L'e', L'i', L'r', L' ', L'o', L'r', L'i', 
L'g', L'i', L'n', L'a', L'l', L' ', L'l', L'o', L'c', L'a', 
L't', L'i', L'o', L'n', L'\r', L'\n', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L'l', L'o', L'g', L'i', 
L'c', L'a', L'l', L'P', L'a', L't', L'h', L'"', L' ', L'd', 
L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L's', L't', 
L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', L'q', L'u', 
L'i', L'r', L'e', L'd', L'=', L'"', L'n', L'o', L'"', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', 
L' ', L' ', L'L', L'o', L'g', L'i', L'c', L'a', L'l', L' ', 
L'p', L'a', L't', L'h', L' ', L'f', L'o', L'r', L' ', L'a', 
L' ', L'd', L'a', L't', L'a', L'b', L'a', L's', L'e', L' ', 
L'o', L'r', L' ', L'f', L'i', L'l', L'e', L' ', L'g', L'r', 
L'o', L'u', L'p', L'.', L' ', L' ', L'T', L'h', L'i', L's', 
L' ', L'l', L'o', L'g', L'i', L'c', L'a', L'l', L' ', L'n', 
L'a', L'm', L'e', L' ', L'u', L's', L'e', L's', L' ', L'b', 
L'a', L'c', L'k', L's', L'l', L'a', L's', L'h', L'\r', L'\n', 
L' ', L' ', L' ', L'a', L's', L' ', L's', L'e', L'p', L'a', 
L'r', L'a', L't', L'o', L'r', L's', L' ', L't', L'o', L' ', 
L'f', L'o', L'r', L'm', L' ', L'a', L' ', L'l', L'o', L'g', 
L'i', L'c', L'a', L'l', L' ', L'n', L'a', L'm', L'e', L's', 
L'p', L'a', L'c', L'e', L' ', L'h', L'i', L'e', L'r', L'a', 
L'r', L'c', L'h', L'y', L'\r', L'\n', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L'c', L'o', L'm', L'p', 
L'o', L'n', L'e', L'n', L't', L'N', L'a', L'm', L'e', L'"', 
L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', 
L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', 
L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', 
L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L'N', L'a', L'm', L'e', L' ', 
L'u', L's', L'e', L'd', L' ', L't', L'o', L' ', L'i', L'd', 
L'e', L'n', L't', L'i', L'f', L'y', L' ', L'a', L' ', L'd', 
L'a', L't', L'a', L'b', L'a', L's', L'e', L' ', L'o', L'r', 
L' ', L'f', L'i', L'l', L'e', L' ', L'g', L'r', L'o', L'u', 
L'p', L'.', L' ', L' ', L'M', L'a', L'y', L' ', L'b', L'e', 
L' ', L'q', L'u', L'a', L'l', L'i', L'f', L'i', L'e', L'd', 
L' ', L'b', L'y', L' ', L'a', L'\r', L'\n', L' ', L' ', L' ', 
L'l', L'o', L'g', L'i', L'c', L'a', L'l', L' ', L'p', L'a', 
L't', L'h', L'.', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L'r', L'e', L's', L't', L'o', 
L'r', L'e', L'M', L'e', L't', L'a', L'd', L'a', L't', L'a', 
L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', 
L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', L'i', 
L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', L'l', 
L'u', L'e', L's', L'=', L'"', L'y', L'e', L's', L' ', L'n', 
L'o', L'"', L' ', L'd', L'e', L'f', L'a', L'u', L'l', L't', 
L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'R', L'e', 
L's', L't', L'o', L'r', L'e', L' ', L'm', L'e', L't', L'a', 
L'd', L'a', L't', L'a', L' ', L'e', L'x', L'i', L's', L't', 
L's', L' ', L'f', L'o', L'r', L' ', L't', L'h', L'i', L's', 
L' ', L'd', L'a', L't', L'a', L'b', L'a', L's', L'e', L' ', 
L'o', L'r', L' ', L'f', L'i', L'l', L'e', L' ', L'g', L'r', 
L'o', L'u', L'p', L'.', L' ', L' ', L'B', L'a', L'c', L'k', 
L'u', L'p', L'\r', L'\n', L' ', L' ', L' ', L'a', L'p', L'p', 
L'l', L'i', L'c', L'a', L't', L'i', L'o', L'n', L' ', L's', 
L'h', L'o', L'u', L'l', L'd', L' ', L'c', L'a', L'p', L't', 
L'u', L'r', L'e', L' ', L't', L'h', L'e', L' ', L'r', L'e', 
L's', L't', L'o', L'r', L'e', L' ', L'm', L'e', L't', L'a', 
L'd', L'a', L't', L'a', L' ', L'a', L'n', L'd', L' ', L'p', 
L'a', L's', L's', L' ', L'i', L't', L' ', L't', L'o', L' ', 
L't', L'h', L'e', L'\r', L'\n', L' ', L' ', L' ', L'w', L'r', 
L'i', L't', L'e', L'r', L' ', L'o', L'n', L' ', L'r', L'e', 
L's', L't', L'o', L'r', L'e', L'.', L'\r', L'\n', L' ', L' ', 
L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'n', L'o', 
L't', L'i', L'f', L'y', L'O', L'n', L'B', L'a', L'c', L'k', 
L'u', L'p', L'C', L'o', L'm', L'p', L'l', L'e', L't', L'e', 
L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', 
L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', L'i', 
L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', L'l', 
L'u', L'e', L's', L'=', L'"', L'y', L'e', L's', L' ', L'n', 
L'o', L'"', L' ', L'd', L'e', L'f', L'a', L'u', L'l', L't', 
L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'W', L'r', 
L'i', L't', L'e', L'r', L' ', L's', L'h', L'o', L'u', L'l', 
L'd', L' ', L'b', L'e', L' ', L'n', L'o', L't', L'i', L'f', 
L'i', L'e', L'd', L' ', L'w', L'h', L'e', L'n', L' ', L'b', 
L'a', L'c', L'k', L'u', L'p', L' ', L'i', L's', L' ', L'c', 
L'o', L'm', L'p', L'l', L'e', L't', L'e', L' ', L'w', L'h', 
L'e', L't', L'h', L'e', L'r', L' ', L't', L'h', L'i', L's', 
L'\r', L'\n', L' ', L' ', L' ', L'd', L'a', L't', L'a', L'b', 
L'a', L's', L'e', L' ', L'o', L'r', L' ', L'f', L'i', L'l', 
L'e', L' ', L'g', L'r', L'o', L'u', L'p', L' ', L'w', L'a', 
L's', L' ', L's', L'u', L'c', L'c', L'e', L's', L's', L'f', 
L'u', L'l', L'l', L'y', L' ', L'b', L'a', L'c', L'k', L'e', 
L'd', L' ', L'u', L'p', L' ', L'o', L'r', L' ', L'n', L'o', 
L't', L'.', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', 
L'm', L'e', L'=', L'"', L'c', L'a', L'p', L't', L'i', L'o', 
L'n', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', 
L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', 
L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L' ', L' ', L' ', L'T', L'e', L'x', L't', 
L'u', L'a', L'l', L' ', L'D', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L' ', L'o', L'f', L' ', L'd', 
L'a', L't', L'a', L'b', L'a', L's', L'e', L' ', L'o', L'r', 
L' ', L'f', L'i', L'l', L'e', L' ', L'g', L'r', L'o', L'u', 
L'p', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', 
L'\n', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', 
L'e', L'=', L'"', L'i', L'c', L'o', L'n', L'"', L' ', L'd', 
L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L's', L't', 
L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', L'q', L'u', 
L'i', L'r', L'e', L'd', L'=', L'"', L'n', L'o', L'"', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', 
L' ', L' ', L'I', L'c', L'o', L'n', L' ', L'a', L's', L's', 
L'o', L'c', L'i', L'a', L't', L'e', L'd', L' ', L'w', L'i', 
L't', L'h', L' ', L'd', L'a', L't', L'a', L'b', L'a', L's', 
L'e', L' ', L'o', L'r', L' ', L'f', L'i', L'l', L'e', L' ', 
L'g', L'r', L'o', L'u', L'p', L'\r', L'\n', L' ', L' ', L' ', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L's', L'e', L'l', 
L'e', L'c', L't', L'a', L'b', L'l', L'e', L'"', L' ', L'd', 
L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L'e', L'n', 
L'u', L'm', L'e', L'r', L'a', L't', L'i', L'o', L'n', L'"', 
L' ', L'd', L't', L':', L'v', L'a', L'l', L'u', L'e', L's', 
L'=', L'"', L'y', L'e', L's', L' ', L'n', L'o', L'"', L' ', 
L'd', L'e', L'f', L'a', L'u', L'l', L't', L'=', L'"', L'y', 
L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L' ', L' ', L' ', L'I', L's', L' ', L't', 
L'h', L'i', L's', L' ', L'c', L'o', L'm', L'p', L'o', L'n', 
L'e', L'n', L't', L' ', L's', L'e', L'l', L'e', L'c', L't', 
L'a', L'b', L'l', L'e', L' ', L'f', L'o', L'r', L' ', L'b', 
L'a', L'c', L'k', L'u', L'p', L' ', L'o', L'r', L' ', L'i', 
L's', L' ', L'i', L't', L' ', L'a', L'l', L'w', L'a', L'y', 
L's', L' ', L'b', L'a', L'c', L'k', L'e', L'd', L' ', L'u', 
L'p', L'.', L'\r', L'\n', L' ', L' ', L' ', L'I', L'f', L' ', 
L'n', L'o', L',', L' ', L't', L'h', L'e', L'n', L' ', L't', 
L'h', L'e', L' ', L'c', L'o', L'm', L'p', L'o', L'n', L'e', 
L'n', L't', L' ', L'i', L's', L' ', L'a', L'l', L'w', L'a', 
L'y', L's', L' ', L'b', L'a', L'c', L'k', L'e', L'd', L' ', 
L'u', L'p', L' ', L'i', L'f', L' ', L'a', L'n', L'y', L' ', 
L'o', L't', L'h', L'e', L'r', L' ', L'c', L'o', L'm', L'p', 
L'o', L'n', L'e', L'n', L't', L's', L' ', L'o', L'f', L'\r', 
L'\n', L' ', L' ', L' ', L't', L'h', L'e', L' ', L'a', L'p', 
L'p', L'l', L'i', L'c', L'a', L't', L'i', L'o', L'n', L'/', 
L's', L'e', L'r', L'v', L'i', L'c', L'e', L' ', L'a', L'r', 
L'e', L' ', L'b', L'a', L'c', L'k', L'e', L'd', L' ', L'u', 
L'p', L'.', L' ', L' ', L'I', L'f', L' ', L'y', L'e', L's', 
L',', L' ', L't', L'h', L'e', L'n', L' ', L't', L'h', L'e', 
L'\r', L'\n', L' ', L' ', L' ', L'c', L'o', L'm', L'p', L'o', 
L'n', L'e', L'n', L't', L' ', L'm', L'a', L'y', L' ', L'b', 
L'e', L' ', L's', L'e', L'l', L'e', L'c', L't', L'i', L'v', 
L'e', L'l', L'y', L' ', L'b', L'a', L'c', L'k', L'e', L'd', 
L' ', L'u', L'p', L'.', L'\r', L'\n', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L'v', L'e', L'r', L's', 
L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', L't', L'y', 
L'p', L'e', L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', 
L'a', L't', L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', 
L'v', L'a', L'l', L'u', L'e', L's', L'=', L'"', L'1', L'.', 
L'0', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', 
L'd', L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', 
L'V', L'e', L'r', L's', L'i', L'o', L'n', L' ', L'o', L'f', 
L' ', L'a', L' ', L's', L'p', L'e', L'c', L'i', L'f', L'i', 
L'c', L' ', L'd', L'o', L'c', L'u', L'm', L'e', L'n', L't', 
L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'w', L'r', L'i', L't', L'e', L'r', L'I', L'd', 
L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', 
L'"', L'u', L'u', L'i', L'd', L'"', L' ', L'r', L'e', L'q', 
L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', L's', 
L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L' ', L' ', L' ', L'U', L'n', L'i', L'q', L'u', L'e', 
L' ', L'i', L'd', L' ', L't', L'o', L' ', L'i', L'd', L'e', 
L'n', L't', L'i', L'f', L'y', L' ', L't', L'h', L'e', L' ', 
L'w', L'r', L'i', L't', L'e', L'r', L'.', L' ', L' ', L'N', 
L'o', L't', L'e', L' ', L't', L'h', L'a', L't', L' ', L't', 
L'h', L'i', L's', L' ', L'i', L'd', L'e', L'n', L't', L'i', 
L'f', L'i', L'e', L's', L' ', L't', L'h', L'e', L'\r', L'\n', 
L' ', L' ', L' ', L'w', L'r', L'i', L't', L'e', L'r', L' ', 
L'c', L'l', L'a', L's', L's', L' ', L'r', L'a', L't', L'h', 
L'e', L'r', L' ', L't', L'h', L'a', L'n', L' ', L'a', L' ', 
L's', L'p', L'e', L'c', L'i', L'f', L'i', L'c', L' ', L'i', 
L'n', L's', L't', L'a', L'n', L'c', L'e', L' ', L'o', L'f', 
L' ', L't', L'h', L'e', L' ', L'w', L'r', L'i', L't', L'e', 
L'r', L'.', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', 
L'm', L'e', L'=', L'"', L'i', L'n', L's', L't', L'a', L'n', 
L'c', L'e', L'I', L'd', L'"', L' ', L'd', L't', L':', L't', 
L'y', L'p', L'e', L'=', L'"', L'u', L'u', L'i', L'd', L'"', 
L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', 
L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'U', L'n', L'i', 
L'q', L'u', L'e', L' ', L'i', L'd', L' ', L'i', L'd', L'e', 
L'n', L't', L'i', L'f', L'y', L'i', L'n', L'g', L' ', L't', 
L'h', L'e', L' ', L'i', L'n', L's', L't', L'a', L'n', L'c', 
L'e', L' ', L'o', L'f', L' ', L'a', L' ', L'w', L'r', L'i', 
L't', L'e', L'r', L' ', L'd', L'u', L'r', L'i', L'n', L'g', 
L' ', L'b', L'a', L'c', L'k', L'u', L'p', L'.', L' ', L' ', 
L'I', L't', L'\r', L'\n', L' ', L' ', L' ', L'h', L'a', L's', 
L' ', L'n', L'o', L' ', L'm', L'e', L'a', L'n', L'i', L'n', 
L'g', L' ', L'd', L'u', L'r', L'i', L'n', L'g', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L'.', L'\r', L'\n', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', 
L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', 
L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'W', L'R', L'I', 
L'T', L'E', L'R', L'_', L'M', L'E', L'T', L'A', L'D', L'A', 
L'T', L'A', L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', 
L't', L'=', L'"', L'e', L'l', L't', L'O', L'n', L'l', L'y', 
L'"', L' ', L'm', L'o', L'd', L'e', L'l', L'=', L'"', L'o', 
L'p', L'e', L'n', L'"', L' ', L'o', L'r', L'd', L'e', L'r', 
L'=', L'"', L'o', L'n', L'e', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L'I', L'n', L'f', L'o', L'r', L'm', L'a', L't', 
L'i', L'o', L'n', L' ', L'u', L's', L'e', L'd', L' ', L'b', 
L'y', L' ', L'B', L'a', L'c', L'k', L'u', L'p', L' ', L'a', 
L'p', L'p', L'l', L'i', L'c', L'a', L't', L'i', L'o', L'n', 
L' ', L't', L'o', L' ', L'b', L'a', L'c', L'k', L'u', L'p', 
L'/', L'r', L'e', L's', L't', L'o', L'r', L'e', L' ', L'd', 
L'a', L't', L'a', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'v', L'e', L'r', L's', L'i', L'o', L'n', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'e', L'l', 
L'e', L'm', L'e', L'n', L't', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'I', L'D', L'E', L'N', L'T', L'I', L'F', L'I', 
L'C', L'A', L'T', L'I', L'O', L'N', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', 
L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'B', L'A', 
L'C', L'K', L'U', L'P', L'_', L'L', L'O', L'C', L'A', L'T', 
L'I', L'O', L'N', L'S', L'"', L' ', L'm', L'i', L'n', L'O', 
L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', 
L'e', L'n', L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'R', L'E', L'S', L'T', L'O', L'R', L'E', L'_', L'M', L'E', 
L'T', L'H', L'O', L'D', L'"', L' ', L'm', L'i', L'n', L'O', 
L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'<', L'/', L'E', L'l', L'e', L'm', 
L'e', L'n', L't', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'<', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', 
L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', 
L'I', L'D', L'E', L'N', L'T', L'I', L'F', L'I', L'C', L'A', 
L'T', L'I', L'O', L'N', L'"', L' ', L'c', L'o', L'n', L't', 
L'e', L'n', L't', L'=', L'"', L'e', L'm', L'p', L't', L'y', 
L'"', L' ', L'm', L'o', L'd', L'e', L'l', L'=', L'"', L'c', 
L'l', L'o', L's', L'e', L'd', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L'I', L'd', L'e', L'n', L't', L'i', L'f', L'i', 
L'c', L'a', L't', L'i', L'o', L'n', L' ', L'o', L'f', L' ', 
L'a', L' ', L's', L'e', L'r', L'v', L'i', L'c', L'e', L'/', 
L'a', L'p', L'p', L'l', L'i', L'c', L'a', L't', L'i', L'o', 
L'n', L' ', L'b', L'a', L'c', L'k', L'i', L'n', L'g', L' ', 
L'u', L'p', L' ', L'd', L'a', L't', L'a', L'\r', L'\n', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'f', L'r', L'i', L'e', L'n', L'd', L'l', L'y', L'N', 
L'a', L'm', L'e', L'"', L' ', L'd', L't', L':', L't', L'y', 
L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', 
L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', 
L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L'F', L'r', L'i', L'e', L'n', L'd', L'l', 
L'y', L' ', L'n', L'a', L'm', L'e', L' ', L'u', L's', L'e', 
L'd', L' ', L't', L'o', L' ', L'd', L'e', L's', L'c', L'r', 
L'i', L'b', L'e', L' ', L't', L'h', L'e', L' ', L's', L'e', 
L'r', L'v', L'i', L'c', L'e', L' ', L'o', L'r', L' ', L'a', 
L'p', L'p', L'l', L'i', L'c', L'a', L't', L'i', L'o', L'n', 
L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'u', L's', 
L'a', L'g', L'e', L'"', L' ', L'd', L't', L':', L't', L'y', 
L'p', L'e', L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', 
L'a', L't', L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', 
L'v', L'a', L'l', L'u', L'e', L's', L'=', L'"', L'U', L'S', 
L'E', L'R', L'_', L'D', L'A', L'T', L'A', L' ', L'B', L'O', 
L'O', L'T', L'A', L'B', L'L', L'E', L'_', L'S', L'Y', L'S', 
L'T', L'E', L'M', L'_', L'S', L'T', L'A', L'T', L'E', L' ', 
L'S', L'Y', L'S', L'T', L'E', L'M', L'_', L'S', L'E', L'R', 
L'V', L'I', L'C', L'E', L' ', L'O', L'T', L'H', L'E', L'R', 
L'"', L' ', L'd', L'e', L'f', L'a', L'u', L'l', L't', L'=', 
L'"', L'O', L'T', L'H', L'E', L'R', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L'H', L'o', L'w', L' ', L't', L'h', 
L'e', L' ', L'd', L'a', L't', L'a', L' ', L'a', L's', L's', 
L'o', L'c', L'i', L'a', L't', L'e', L'd', L' ', L'w', L'i', 
L't', L'h', L' ', L't', L'h', L'e', L' ', L'w', L'r', L'i', 
L't', L'e', L'r', L' ', L'i', L's', L' ', L'u', L's', L'e', 
L'd', L'.', L' ', L' ', L'F', L'o', L'r', L' ', L'n', L'o', 
L'w', L' ', L'w', L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L'd', L'i', L's', L't', L'i', L'n', L'g', L'u', 
L'i', L's', L'h', L' ', L'u', L's', L'e', L'r', L' ', L'd', 
L'a', L't', L'a', L' ', L'a', L'n', L'd', L' ', L's', L'y', 
L's', L't', L'e', L'm', L' ', L's', L't', L'a', L't', L'e', 
L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'd', L'a', 
L't', L'a', L'S', L'o', L'u', L'r', L'c', L'e', L'"', L' ', 
L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L'e', 
L'n', L'u', L'm', L'e', L'r', L'a', L't', L'i', L'o', L'n', 
L'"', L' ', L'd', L't', L':', L'v', L'a', L'l', L'u', L'e', 
L's', L'=', L'"', L'T', L'R', L'A', L'N', L'S', L'A', L'C', 
L'T', L'I', L'O', L'N', L'_', L'D', L'B', L' ', L'N', L'O', 
L'N', L'T', L'R', L'A', L'N', L'S', L'A', L'C', L'T', L'I', 
L'O', L'N', L'A', L'L', L'_', L'D', L'B', L' ', L'O', L'T', 
L'H', L'E', L'R', L'"', L' ', L'd', L'e', L'f', L'a', L'u', 
L'l', L't', L'=', L'"', L'O', L'T', L'H', L'E', L'R', L'"', 
L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'D', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L' ', L'o', 
L'f', L' ', L't', L'h', L'e', L' ', L'n', L'a', L't', L'u', 
L'r', L'e', L' ', L'o', L'f', L' ', L't', L'h', L'e', L' ', 
L'd', L'a', L't', L'a', L' ', L'm', L'a', L'n', L'a', L'g', 
L'e', L'r', L'.', L' ', L' ', L'C', L'u', L'r', L'r', L'e', 
L'n', L't', L'l', L'y', L' ', L'o', L'n', L'l', L'y', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'd', L'a', L't', 
L'a', L'b', L'a', L's', L'e', L's', L' ', L'a', L'r', L'e', 
L' ', L'i', L'd', L'e', L'n', L't', L'i', L'f', L'i', L'e', 
L'd', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'i', L'n', L's', L't', L'a', L'n', 
L'c', L'e', L'I', L'd', L'"', L' ', L'r', L'e', L'q', L'u', 
L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', L's', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'w', L'r', L'i', L't', L'e', L'r', L'I', 
L'd', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'f', L'r', L'i', L'e', L'n', 
L'd', L'l', L'y', L'N', L'a', L'm', L'e', L'"', L'/', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', 
L'"', L'u', L's', L'a', L'g', L'e', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'd', L'a', L't', L'a', L'S', L'o', L'u', L'r', L'c', L'e', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'E', L'l', 
L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', L'm', L'e', L'n', 
L't', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'B', L'A', L'C', L'K', L'U', L'P', L'_', L'L', 
L'O', L'C', L'A', L'T', L'I', L'O', L'N', L'S', L'"', L' ', 
L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', 
L'l', L't', L'O', L'n', L'l', L'y', L'"', L' ', L'm', L'o', 
L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', L's', L'e', 
L'd', L'"', L' ', L'o', L'r', L'd', L'e', L'r', L'=', L'"', 
L'm', L'a', L'n', L'y', L'"', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L'F', L'i', L'l', L'e', L's', L' ', L't', L'o', L' ', 
L'i', L'n', L'c', L'l', L'u', L'd', L'e', L' ', L'a', L'n', 
L'd', L' ', L'e', L'x', L'c', L'l', L'u', L'd', L'e', L' ', 
L'f', L'r', L'o', L'm', L' ', L't', L'h', L'e', L' ', L'b', 
L'a', L'c', L'k', L'u', L'p', L'\r', L'\n', L' ', L' ', L' ', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'e', 
L'l', L'e', L'm', L'e', L'n', L't', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'I', L'N', L'C', L'L', L'U', L'D', L'E', 
L'_', L'F', L'I', L'L', L'E', L'S', L'"', L' ', L'm', L'i', 
L'n', L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'e', L'l', 
L'e', L'm', L'e', L'n', L't', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'E', L'X', L'C', L'L', L'U', L'D', L'E', L'_', 
L'F', L'I', L'L', L'E', L'S', L'"', L' ', L'm', L'i', L'n', 
L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', 
L'm', L'e', L'n', L't', L' ', L't', L'y', L'p', L'e', L'=', 
L'"', L'D', L'A', L'T', L'A', L'B', L'A', L'S', L'E', L'"', 
L' ', L'm', L'i', L'n', L'O', L'c', L'c', L'u', L'r', L's', 
L'=', L'"', L'0', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'F', L'I', L'L', L'E', L'_', 
L'G', L'R', L'O', L'U', L'P', L'"', L' ', L'm', L'i', L'n', 
L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'E', L'l', L'e', 
L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L'>', L'\r', 
L'\n', L'\t', L'<', L'E', L'l', L'e', L'm', L'e', L'n', L't', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'I', L'N', L'C', L'L', L'U', L'D', L'E', L'_', L'F', 
L'I', L'L', L'E', L'S', L'"', L' ', L'c', L'o', L'n', L't', 
L'e', L'n', L't', L'=', L'"', L'e', L'm', L'p', L't', L'y', 
L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'F', L'i', L'l', 
L'e', L's', L' ', L't', L'o', L' ', L'i', L'n', L'c', L'l', 
L'u', L'd', L'e', L' ', L'i', L'n', L' ', L't', L'h', L'e', 
L' ', L'b', L'a', L'c', L'k', L'u', L'p', L',', L' ', L'e', 
L's', L's', L'e', L'n', L't', L'i', L'a', L'l', L'l', L'y', 
L' ', L'f', L'i', L'l', L'e', L's', L' ', L't', L'o', L' ', 
L'b', L'a', L'c', L'k', L'u', L'p', L' ', L'i', L'f', L' ', 
L'y', L'o', L'u', L' ', L'w', L'a', L'n', L't', L'\r', L'\n', 
L' ', L' ', L' ', L' ', L' ', L' ', L't', L'o', L' ', L'b', 
L'a', L'c', L'k', L'u', L'p', L' ', L't', L'h', L'i', L's', 
L' ', L'a', L'p', L'p', L'l', L'i', L'c', L'a', L't', L'i', 
L'o', L'n', L'/', L's', L'e', L'r', L'v', L'i', L'c', L'e', 
L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'p', L'a', L't', L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'f', L'i', 
L'l', L'e', L's', L'p', L'e', L'c', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'r', L'e', L'c', L'u', L'r', L's', L'i', L'v', L'e', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'a', L'l', L't', L'e', L'r', L'n', L'a', 
L't', L'e', L'P', L'a', L't', L'h', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', 
L't', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', 
L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', 
L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'E', L'X', 
L'C', L'L', L'U', L'D', L'E', L'_', L'F', L'I', L'L', L'E', 
L'S', L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', L't', 
L'=', L'"', L'e', L'm', L'p', L't', L'y', L'"', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L'F', L'i', L'l', L'e', L's', L' ', 
L't', L'h', L'a', L't', L' ', L's', L'h', L'o', L'u', L'l', 
L'd', L' ', L'a', L'l', L'w', L'a', L'y', L's', L' ', L'b', 
L'e', L' ', L'e', L'x', L'c', L'l', L'u', L'd', L'e', L'd', 
L' ', L'f', L'r', L'o', L'm', L' ', L't', L'h', L'e', L' ', 
L'b', L'a', L'c', L'k', L'u', L'p', L'\r', L'\n', L' ', L' ', 
L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'p', L'a', L't', L'h', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'f', L'i', L'l', L'e', L's', L'p', 
L'e', L'c', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'r', L'e', L'c', L'u', 
L'r', L's', L'i', L'v', L'e', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', 
L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'D', L'A', L'T', 
L'A', L'B', L'A', L'S', L'E', L'"', L' ', L'c', L'o', L'n', 
L't', L'e', L'n', L't', L'=', L'"', L'e', L'l', L't', L'O', 
L'n', L'l', L'y', L'"', L' ', L'm', L'o', L'd', L'e', L'l', 
L'=', L'"', L'c', L'l', L'o', L's', L'e', L'd', L'"', L' ', 
L'o', L'r', L'd', L'e', L'r', L'=', L'"', L'm', L'a', L'n', 
L'y', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'L', L'i', 
L's', L't', L' ', L'o', L'f', L' ', L'd', L'a', L't', L'a', 
L'b', L'a', L's', L'e', L's', L' ', L'o', L'f', L' ', L'i', 
L'n', L't', L'e', L'r', L'e', L's', L't', L'.', L' ', L' ', 
L'T', L'h', L'i', L's', L' ', L'i', L's', L' ', L'u', L's', 
L'e', L'd', L' ', L't', L'o', L' ', L'a', L'l', L'l', L'o', 
L'w', L' ', L's', L'e', L'l', L'e', L'c', L't', L'i', L'v', 
L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'b', 
L'a', L'c', L'k', L'u', L'p', L' ', L'a', L'n', L'd', L' ', 
L'r', L'e', L's', L't', L'o', L'r', L'e', L' ', L'o', L'f', 
L' ', L's', L'p', L'e', L'c', L'i', L'f', L'i', L'c', L' ', 
L'd', L'a', L't', L'a', L'b', L'a', L's', L'e', L's', L'.', 
L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'l', L'o', L'g', L'i', L'c', L'a', L'l', L'P', L'a', L't', 
L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'c', L'o', L'm', L'p', L'o', 
L'n', L'e', L'n', L't', L'N', L'a', L'm', L'e', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'c', L'a', L'p', L't', L'i', L'o', L'n', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'i', L'c', L'o', L'n', L'"', L'/', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', 
L'"', L'r', L'e', L's', L't', L'o', L'r', L'e', L'M', L'e', 
L't', L'a', L'd', L'a', L't', L'a', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'n', L'o', L't', L'i', L'f', L'y', L'O', L'n', L'B', L'a', 
L'c', L'k', L'u', L'p', L'C', L'o', L'm', L'p', L'l', L'e', 
L't', L'e', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L's', L'e', L'l', L'e', 
L'c', L't', L'a', L'b', L'l', L'e', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', 
L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'D', L'A', 
L'T', L'A', L'B', L'A', L'S', L'E', L'_', L'F', L'I', L'L', 
L'E', L'S', L'"', L' ', L'm', L'i', L'n', L'O', L'c', L'c', 
L'u', L'r', L's', L'=', L'"', L'1', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', 
L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'D', L'A', 
L'T', L'A', L'B', L'A', L'S', L'E', L'_', L'L', L'O', L'G', 
L'F', L'I', L'L', L'E', L'S', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', 
L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'D', L'A', L'T', 
L'A', L'B', L'A', L'S', L'E', L'_', L'F', L'I', L'L', L'E', 
L'S', L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', L't', 
L'=', L'"', L'e', L'm', L'p', L't', L'y', L'"', L' ', L'm', 
L'o', L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', L's', 
L'e', L'd', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'L', 
L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', L'o', L'f', 
L' ', L'a', L' ', L's', L'e', L't', L' ', L'o', L'f', L' ', 
L'd', L'a', L't', L'a', L'b', L'a', L's', L'e', L' ', L'f', 
L'i', L'l', L'e', L's', L'.', L' ', L' ', L'F', L'i', L'l', 
L'e', L's', L'p', L'e', L'c', L' ', L'c', L'a', L'n', L' ', 
L'i', L'n', L'c', L'l', L'u', L'd', L'e', L' ', L'w', L'i', 
L'l', L'd', L'c', L'a', L'r', L'd', L's', L'\r', L'\n', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'p', L'a', L't', 
L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'f', L'i', L'l', L'e', L's', 
L'p', L'e', L'c', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', 
L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', 
L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L'D', L'A', L'T', L'A', L'B', 
L'A', L'S', L'E', L'_', L'L', L'O', L'G', L'F', L'I', L'L', 
L'E', L'S', L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', 
L't', L'=', L'"', L'e', L'm', L'p', L't', L'y', L'"', L' ', 
L'm', L'o', L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', 
L's', L'e', L'd', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L'L', L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', L'o', 
L'f', L' ', L'a', L' ', L's', L'e', L't', L' ', L'o', L'f', 
L' ', L'd', L'a', L't', L'a', L'b', L'a', L's', L'e', L' ', 
L'l', L'o', L'g', L' ', L'f', L'i', L'l', L'e', L's', L'.', 
L' ', L' ', L'F', L'i', L'l', L'e', L's', L'p', L'e', L'c', 
L' ', L'c', L'a', L'n', L' ', L'i', L'n', L'c', L'l', L'u', 
L'd', L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L'w', L'i', L'l', L'd', L'c', L'a', L'r', L'd', L's', L'.', 
L' ', L' ', L'I', L'n', L'd', L'i', L'c', L'a', L't', L'i', 
L'o', L'n', L' ', L'o', L'f', L' ', L'w', L'h', L'e', L't', 
L'h', L'e', L'r', L' ', L'd', L'a', L't', L'a', L'b', L'a', 
L's', L'e', L' ', L'l', L'o', L'g', L' ', L'f', L'i', L'l', 
L'e', L's', L' ', L'a', L'r', L'e', L' ', L't', L'r', L'u', 
L'n', L'c', L'a', L't', L'e', L'd', L'.', L'\r', L'\n', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'p', L'a', L't', 
L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'f', L'i', L'l', L'e', L's', 
L'p', L'e', L'c', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', 
L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', 
L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L'F', L'I', L'L', L'E', L'_', 
L'G', L'R', L'O', L'U', L'P', L'"', L' ', L'c', L'o', L'n', 
L't', L'e', L'n', L't', L'=', L'"', L'e', L'l', L't', L'O', 
L'n', L'l', L'y', L'"', L' ', L'm', L'o', L'd', L'e', L'l', 
L'=', L'"', L'c', L'l', L'o', L's', L'e', L'd', L'"', L' ', 
L'o', L'r', L'd', L'e', L'r', L'=', L'"', L'm', L'a', L'n', 
L'y', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'A', L' ', 
L'n', L'a', L'm', L'e', L'd', L' ', L'g', L'r', L'o', L'u', 
L'p', L' ', L'o', L'f', L' ', L'f', L'i', L'l', L'e', L's', 
L'.', L' ', L' ', L'U', L's', L'e', L'd', L' ', L't', L'o', 
L' ', L'g', L'r', L'o', L'u', L'p', L' ', L's', L'e', L't', 
L's', L' ', L'o', L'f', L' ', L'f', L'i', L'l', L'e', L's', 
L' ', L'i', L'n', L't', L'o', L' ', L'a', L' ', L'g', L'r', 
L'o', L'u', L'p', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L't', L'h', L'a', L't', L' ', L'a', L'r', L'e', L' ', 
L'b', L'a', L'c', L'k', L'e', L'd', L' ', L'u', L'p', L' ', 
L't', L'o', L'g', L'e', L't', L'h', L'e', L'r', L'\r', L'\n', 
L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'l', L'o', 
L'g', L'i', L'c', L'a', L'l', L'P', L'a', L't', L'h', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'c', L'o', L'm', L'p', L'o', L'n', L'e', 
L'n', L't', L'N', L'a', L'm', L'e', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'c', L'a', L'p', L't', L'i', L'o', L'n', L'"', L'/', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', 
L'"', L'i', L'c', L'o', L'n', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L'M', L'e', L't', L'a', 
L'd', L'a', L't', L'a', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'n', L'o', 
L't', L'i', L'f', L'y', L'O', L'n', L'B', L'a', L'c', L'k', 
L'u', L'p', L'C', L'o', L'm', L'p', L'l', L'e', L't', L'e', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L's', L'e', L'l', L'e', L'c', L't', 
L'a', L'b', L'l', L'e', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'F', L'I', L'L', L'E', 
L'_', L'L', L'I', L'S', L'T', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', 
L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'F', L'I', L'L', 
L'E', L'_', L'L', L'I', L'S', L'T', L'"', L' ', L'c', L'o', 
L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', L'm', L'p', 
L't', L'y', L'"', L' ', L'm', L'o', L'd', L'e', L'l', L'=', 
L'"', L'c', L'l', L'o', L's', L'e', L'd', L'"', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L'L', L'o', L'c', L'a', L't', L'i', 
L'o', L'n', L' ', L'o', L'f', L' ', L'a', L' ', L's', L'e', 
L't', L' ', L'o', L'f', L' ', L'f', L'i', L'l', L'e', L's', 
L' ', L'i', L'n', L' ', L'a', L' ', L'F', L'I', L'L', L'E', 
L'_', L'G', L'R', L'O', L'U', L'P', L'.', L' ', L' ', L'F', 
L'i', L'l', L'e', L's', L'p', L'e', L'c', L' ', L'c', L'a', 
L'n', L' ', L'i', L'n', L'c', L'l', L'u', L'd', L'e', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'w', L'i', L'l', 
L'd', L'c', L'a', L'r', L'd', L's', L'.', L'\r', L'\n', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'p', L'a', L't', 
L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'f', L'i', L'l', L'e', L's', 
L'p', L'e', L'c', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'r', L'e', L'c', 
L'u', L'r', L's', L'i', L'v', L'e', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'a', L'l', L't', L'e', L'r', L'n', L'a', L't', L'e', L'P', 
L'a', L't', L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', 
L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', 
L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L'R', L'E', L'S', L'T', L'O', 
L'R', L'E', L'_', L'M', L'E', L'T', L'H', L'O', L'D', L'"', 
L' ', L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', 
L'e', L'l', L't', L'O', L'n', L'l', L'y', L'"', L' ', L'm', 
L'o', L'd', L'e', L'l', L'=', L'"', L'o', L'p', L'e', L'n', 
L'"', L' ', L'o', L'r', L'd', L'e', L'r', L'=', L'"', L'm', 
L'a', L'n', L'y', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L'H', L'o', L'w', L' ', 
L'r', L'e', L's', L't', L'o', L'r', L'e', L' ', L's', L'h', 
L'o', L'u', L'l', L'd', L' ', L'b', L'e', L' ', L'p', L'e', 
L'r', L'f', L'o', L'r', L'm', L'e', L'd', L'.', L' ', L' ', 
L'I', L'n', L'c', L'l', L'u', L'd', L'e', L's', L' ', L's', 
L'p', L'e', L'c', L'i', L'f', L'i', L'c', L'a', L't', L'i', 
L'o', L'n', L' ', L'o', L'f', L' ', L'h', L'o', L'w', L' ', 
L'f', L'i', L'l', L'e', L's', L'\r', L'\n', L' ', L' ', L's', 
L'h', L'o', L'u', L'l', L'd', L' ', L'b', L'e', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L'd', L' ', L'a', L's', 
L' ', L'w', L'e', L'l', L'l', L' ', L'a', L's', L' ', L's', 
L'p', L'e', L'c', L'i', L'a', L'l', L' ', L's', L't', L'e', 
L'p', L's', L' ', L't', L'h', L'a', L't', L' ', L's', L'h', 
L'o', L'u', L'l', L'd', L' ', L'o', L'c', L'c', L'u', L'r', 
L' ', L'i', L'n', L' ', L'o', L'r', L'd', L'e', L'r', L'\r', 
L'\n', L' ', L' ', L't', L'o', L' ', L'c', L'o', L'm', L'p', 
L'l', L'e', L't', L'e', L' ', L't', L'h', L'e', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L'.', L'\r', L'\n', L' ', 
L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', 
L'm', L'e', L't', L'h', L'o', L'd', L'"', L' ', L'd', L't', 
L':', L't', L'y', L'p', L'e', L'=', L'"', L'e', L'n', L'u', 
L'm', L'e', L'r', L'a', L't', L'i', L'o', L'n', L'"', L' ', 
L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', 
L'y', L'e', L's', L'"', L' ', L'd', L't', L':', L'v', L'a', 
L'l', L'u', L'e', L's', L'=', L'"', L'R', L'E', L'S', L'T', 
L'O', L'R', L'E', L'_', L'I', L'F', L'_', L'N', L'O', L'N', 
L'E', L'_', L'T', L'H', L'E', L'R', L'E', L'\r', L'\n', L'\t', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L'R', L'E', L'S', L'T', L'O', L'R', L'E', L'_', L'I', L'F', 
L'_', L'C', L'A', L'N', L'_', L'B', L'E', L'_', L'R', L'E', 
L'P', L'L', L'A', L'C', L'E', L'D', L'\r', L'\n', L'\t', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'S', 
L'T', L'O', L'P', L'_', L'R', L'E', L'S', L'T', L'A', L'R', 
L'T', L'_', L'S', L'E', L'R', L'V', L'I', L'C', L'E', L'\r', 
L'\n', L'\t', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'R', L'E', L'P', L'L', L'A', L'C', L'E', L'_', 
L'A', L'T', L'_', L'R', L'E', L'B', L'O', L'O', L'T', L'\r', 
L'\n', L'\t', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'R', L'E', L'S', L'T', L'O', L'R', L'E', L'_', 
L'T', L'O', L'_', L'A', L'L', L'T', L'E', L'R', L'N', L'A', 
L'T', L'E', L'_', L'L', L'O', L'C', L'A', L'T', L'I', L'O', 
L'N', L'\r', L'\n', L'\t', L'\t', L'\t', L' ', L' ', L' ', L' ', 
L'C', L'U', L'S', L'T', L'O', L'M', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L'R', L'E', L'S', L'T', L'O', 
L'R', L'E', L'_', L'I', L'F', L'_', L'N', L'O', L'N', L'E', 
L'_', L'T', L'H', L'E', L'R', L'E', L':', L' ', L'i', L'.', 
L'e', L'.', L',', L' ', L'c', L'a', L'n', L' ', L'r', L'e', 
L's', L't', L'o', L'r', L'e', L' ', L'd', L'a', L't', L'a', 
L' ', L'i', L'f', L' ', L'i', L't', L' ', L'i', L's', L' ', 
L'n', L'o', L't', L' ', L'a', L't', L' ', L't', L'h', L'e', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', 
L' ', L'w', L'h', L'e', L'r', L'e', L' ', L'i', L't', L' ', 
L'w', L'a', L's', L' ', L'b', L'a', L'c', L'k', L'e', L'd', 
L' ', L'u', L'p', L' ', L'f', L'r', L'o', L'm', L'.', L' ', 
L' ', L'T', L'h', L'i', L's', L' ', L'e', L's', L's', L'e', 
L'n', L't', L'i', L'a', L'l', L'l', L'y', L' ', L'a', L'l', 
L'l', L'o', L'w', L's', L'\r', L'\n', L'\t', L' ', L' ', L'd', 
L'a', L't', L'a', L' ', L't', L'o', L' ', L'b', L'e', L' ', 
L'r', L'e', L's', L't', L'o', L'r', L'e', L'd', L' ', L't', 
L'o', L' ', L'a', L' ', L'c', L'l', L'e', L'a', L'n', L' ', 
L's', L'y', L's', L't', L'e', L'm', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L'R', L'E', L'S', L'T', L'O', 
L'R', L'E', L'_', L'I', L'F', L'_', L'C', L'A', L'N', L'_', 
L'B', L'E', L'_', L'R', L'E', L'P', L'L', L'A', L'C', L'E', 
L'D', L':', L' ', L'R', L'e', L's', L't', L'o', L'r', L'e', 
L' ', L'd', L'a', L't', L'a', L' ', L'i', L'f', L' ', L'a', 
L'l', L'l', L' ', L'o', L'f', L' ', L't', L'h', L'e', L' ', 
L'f', L'i', L'l', L'e', L's', L' ', L'c', L'a', L'n', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L'b', L'e', L' ', L'r', L'e', L'p', L'l', L'a', L'c', 
L'e', L'd', L' ', L'i', L'n', L' ', L't', L'h', L'e', L' ', 
L'o', L'r', L'g', L'i', L'g', L'i', L'n', L'a', L'l', L' ', 
L'b', L'a', L'c', L'k', L'u', L'p', L' ', L'l', L'o', L'c', 
L'a', L't', L'i', L'o', L'n', L'.', L' ', L' ', L'F', L'a', 
L'i', L'l', L's', L' ', L'i', L'f', L' ', L'a', L'n', L'y', 
L' ', L'o', L'f', L'\r', L'\n', L'\t', L' ', L' ', L't', L'h', 
L'e', L' ', L'f', L'i', L'l', L'e', L's', L' ', L'a', L'r', 
L'e', L' ', L'o', L'p', L'e', L'n', L'.', L' ', L' ', L'I', 
L'f', L' ', L'a', L'n', L' ', L'a', L'l', L't', L'e', L'r', 
L'n', L'a', L't', L'e', L' ', L'l', L'o', L'c', L'a', L't', 
L'i', L'o', L'n', L' ', L'i', L's', L' ', L'p', L'r', L'o', 
L'v', L'i', L'd', L'e', L'd', L',', L' ', L'f', L'i', L'l', 
L'e', L's', L'\r', L'\n', L'\t', L' ', L' ', L'w', L'i', L'l', 
L'l', L' ', L'b', L'e', L' ', L'p', L'l', L'a', L'c', L'e', 
L'd', L' ', L't', L'h', L'e', L'r', L'e', L' ', L'i', L'f', 
L' ', L't', L'h', L'e', L'y', L' ', L'c', L'a', L'n', L'n', 
L'o', L't', L' ', L'b', L'e', L' ', L'r', L'e', L's', L't', 
L'o', L'r', L'e', L'd', L' ', L't', L'o', L' ', L't', L'h', 
L'e', L'i', L'r', L' ', L'o', L'r', L'i', L'g', L'i', L'n', 
L'a', L'l', L'\r', L'\n', L'\t', L' ', L' ', L'l', L'o', L'c', 
L'a', L't', L'i', L'o', L'n', L'.', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L'S', L'T', L'O', L'P', L'_', 
L'R', L'E', L'S', L'T', L'A', L'R', L'T', L'_', L'S', L'E', 
L'R', L'V', L'I', L'C', L'E', L':', L' ', L's', L't', L'o', 
L'p', L' ', L's', L'e', L'r', L'v', L'i', L'c', L'e', L' ', 
L'(', L's', L'e', L'r', L'v', L'i', L'c', L'e', L' ', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L'm', 
L'u', L's', L't', L' ', L'b', L'e', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L's', L'p', 
L'e', L'c', L'i', L'f', L'i', L'e', L'd', L')', L'.', L' ', 
L'R', L'e', L's', L't', L'o', L'r', L'e', L' ', L'f', L'i', 
L'l', L'e', L's', L' ', L't', L'o', L' ', L'o', L'r', L'i', 
L'g', L'i', L'n', L'a', L'l', L' ', L'b', L'a', L'c', L'k', 
L'u', L'p', L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', 
L'n', L'.', L'\r', L'\n', L'\t', L' ', L' ', L'R', L'e', L's', 
L't', L'a', L'r', L't', L' ', L's', L'e', L'r', L'v', L'i', 
L'c', L'e', L'.', L' ', L' ', L'F', L'a', L'i', L'l', L's', 
L' ', L'i', L'f', L' ', L'a', L'n', L'y', L' ', L'o', L'f', 
L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', L'e', L's', 
L' ', L'a', L'r', L'e', L' ', L'o', L'p', L'e', L'n', L' ', 
L'a', L'f', L't', L'e', L'r', L' ', L't', L'h', L'e', L'\r', 
L'\n', L'\t', L' ', L' ', L's', L'e', L'r', L'v', L'i', L'c', 
L'e', L' ', L'i', L's', L' ', L's', L't', L'o', L'p', L'p', 
L'e', L'd', L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'R', L'E', L'P', L'L', L'A', L'C', L'E', L'_', 
L'A', L'T', L'_', L'R', L'E', L'B', L'O', L'O', L'T', L':', 
L' ', L'R', L'e', L's', L't', L'o', L'r', L'e', L' ', L'f', 
L'i', L'l', L'e', L's', L' ', L't', L'o', L' ', L'a', L' ', 
L't', L'e', L'm', L'p', L'o', L'r', L'a', L'r', L'y', L' ', 
L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', L'.', L' ', 
L' ', L'U', L's', L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'M', L'o', L'v', L'e', 
L'F', L'i', L'l', L'e', L'E', L'x', L' ', L't', L'o', L' ', 
L'r', L'e', L'p', L'l', L'a', L'c', L'e', L' ', L't', L'h', 
L'e', L' ', L'f', L'i', L'l', L'e', L's', L' ', L'a', L't', 
L' ', L'r', L'e', L'b', L'o', L'o', L't', L'.', L'\r', L'\n', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'R', L'E', L'S', 
L'T', L'O', L'R', L'E', L'_', L'T', L'O', L'_', L'A', L'L', 
L'T', L'E', L'R', L'N', L'A', L'T', L'I', L'V', L'E', L'_', 
L'L', L'O', L'C', L'A', L'T', L'I', L'O', L'N', L':', L' ', 
L'R', L'e', L's', L't', L'o', L'r', L'e', L' ', L'f', L'i', 
L'l', L'e', L's', L' ', L't', L'o', L' ', L'a', L'n', L' ', 
L'a', L'l', L't', L'e', L'r', L'n', L'a', L't', L'e', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', L'.', 
L' ', L' ', L'T', L'y', L'p', L'i', L'c', L'a', L'l', L'l', 
L'y', L' ', L'w', L'r', L'i', L't', L'e', L'r', L'R', L'e', 
L's', L't', L'o', L'r', L'e', L' ', L'w', L'i', L'l', L'l', 
L' ', L'i', L'n', L'd', L'i', L'c', L'a', L't', L'e', L' ', 
L't', L'h', L'a', L't', L' ', L't', L'h', L'e', L' ', L'w', 
L'r', L'i', L't', L'e', L'r', L'\r', L'\n', L'\t', L' ', L' ', 
L'w', L'i', L'l', L'l', L' ', L'p', L'a', L'r', L't', L'i', 
L'c', L'i', L'p', L'a', L't', L'e', L' ', L'i', L'n', L' ', 
L't', L'h', L'e', L' ', L'r', L'e', L's', L't', L'o', L'r', 
L'e', L' ', L'p', L'r', L'o', L'c', L'e', L's', L's', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'C', L'U', 
L'S', L'T', L'O', L'M', L':', L' ', L'r', L'e', L's', L't', 
L'o', L'r', L'e', L' ', L'p', L'r', L'o', L'c', L'e', L's', 
L's', L' ', L'c', L'a', L'n', L'n', L'o', L't', L' ', L'b', 
L'e', L' ', L'e', L'x', L'p', L'r', L'e', L's', L's', L'e', 
L'd', L' ', L'u', L's', L'i', L'n', L'g', L' ', L't', L'h', 
L'i', L's', L' ', L's', L'p', L'e', L'c', L'i', L'f', L'i', 
L'c', L'a', L't', L'i', L'o', L'n', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', 
L'm', L'e', L'=', L'"', L's', L'e', L'r', L'v', L'i', L'c', 
L'e', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', 
L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', 
L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L'M', L'u', L's', L't', L' ', L'b', L'e', L' ', L's', L'p', 
L'e', L'c', L'i', L'f', L'i', L'e', L'd', L' ', L'i', L'f', 
L' ', L'm', L'e', L't', L'h', L'o', L'd', L'=', L'"', L'S', 
L'T', L'O', L'P', L'_', L'R', L'E', L'S', L'T', L'A', L'R', 
L'T', L'_', L'S', L'E', L'R', L'V', L'I', L'C', L'E', L'"', 
L',', L' ', L'i', L'n', L'd', L'i', L'c', L'a', L't', L'e', 
L's', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L's', 
L'e', L'r', L'v', L'i', L'c', L'e', L' ', L't', L'o', L' ', 
L'b', L'e', L' ', L's', L't', L'o', L'p', L'p', L'e', L'd', 
L' ', L'b', L'e', L'f', L'o', L'r', L'e', L' ', L'r', L'e', 
L's', L't', L'o', L'r', L'i', L'n', L'g', L' ', L'f', L'i', 
L'l', L'e', L's', L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'w', L'r', L'i', L't', L'e', L'r', L'R', L'e', L's', 
L't', L'o', L'r', L'e', L'"', L' ', L'd', L't', L':', L't', 
L'y', L'p', L'e', L'=', L'"', L'e', L'n', L'u', L'm', L'e', 
L'r', L'a', L't', L'i', L'o', L'n', L'"', L' ', L'd', L't', 
L':', L'v', L'a', L'l', L'u', L'e', L's', L'=', L'"', L'a', 
L'l', L'w', L'a', L'y', L's', L' ', L'n', L'e', L'v', L'e', 
L'r', L' ', L'i', L'f', L'R', L'e', L'p', L'l', L'a', L'c', 
L'e', L'F', L'a', L'i', L'l', L's', L'"', L' ', L'd', L'e', 
L'f', L'a', L'u', L'l', L't', L'=', L'"', L'n', L'e', L'v', 
L'e', L'r', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L'W', L'h', L'e', L't', L'h', L'e', L'r', L' ', L'w', L'r', 
L'i', L't', L'e', L'r', L' ', L's', L'h', L'o', L'u', L'l', 
L'd', L' ', L'b', L'e', L' ', L'i', L'n', L'v', L'o', L'k', 
L'e', L'd', L' ', L'a', L'f', L't', L'e', L'r', L' ', L'f', 
L'i', L'l', L'e', L's', L' ', L'a', L'r', L'e', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L'd', L' ', L't', L'o', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'd', L'i', 
L's', L'k', L'.', L' ', L' ', L'O', L'p', L't', L'i', L'o', 
L'n', L's', L' ', L'a', L'r', L'e', L' ', L'a', L'l', L'w', 
L'a', L'y', L's', L',', L' ', L'n', L'e', L'v', L'e', L'r', 
L',', L' ', L'a', L'n', L'd', L' ', L'i', L'f', L'R', L'e', 
L'p', L'l', L'a', L'c', L'e', L'F', L'a', L'i', L'l', L's', 
L'.', L' ', L' ', L'T', L'h', L'e', L' ', L'l', L'a', L't', 
L't', L'e', L'r', L' ', L'm', L'e', L'a', L'n', L's', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L't', L'h', L'a', 
L't', L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', L'e', 
L's', L' ', L'w', L'i', L'l', L'l', L' ', L'b', L'e', L' ', 
L'r', L'e', L's', L't', L'o', L'r', L'e', L'd', L' ', L't', 
L'o', L' ', L't', L'h', L'e', L'i', L'r', L' ', L'o', L'r', 
L'i', L'g', L'i', L'n', L'a', L'l', L' ', L'l', L'o', L'c', 
L'a', L't', L'i', L'o', L'n', L'.', L' ', L' ', L'I', L'f', 
L' ', L'o', L'n', L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L'o', L'r', L' ', L'm', L'o', L'r', L'e', L' ', 
L'o', L'f', L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', 
L'e', L's', L' ', L'c', L'a', L'n', L'n', L'o', L't', L' ', 
L'b', L'e', L' ', L'r', L'e', L'p', L'l', L'a', L'c', L'e', 
L'd', L',', L' ', L't', L'h', L'e', L'n', L' ', L't', L'h', 
L'e', L' ', L'f', L'i', L'l', L'e', L's', L' ', L'w', L'i', 
L'l', L'l', L' ', L'b', L'e', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L'r', L'e', L's', L't', L'o', L'r', L'e', 
L'd', L' ', L't', L'o', L' ', L'a', L'n', L' ', L'a', L'l', 
L't', L'e', L'r', L'n', L'a', L't', L'e', L' ', L'l', L'o', 
L'c', L'a', L't', L'i', L'o', L'n', L' ', L'(', L'm', L'u', 
L's', L't', L' ', L'b', L'e', L' ', L's', L'p', L'e', L'c', 
L'i', L'f', L'i', L'e', L'd', L' ', L'v', L'i', L'a', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'A', L'L', L'T', 
L'E', L'R', L'N', L'A', L'T', L'E', L'_', L'L', L'O', L'C', 
L'A', L'T', L'I', L'O', L'N', L'_', L'M', L'A', L'P', L'P', 
L'I', L'N', L'G', L'.', L' ', L' ', L'A', L'f', L't', L'e', 
L'r', L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', L'e', 
L's', L' ', L'a', L'r', L'e', L' ', L'r', L'e', L's', L't', 
L'o', L'r', L'e', L'd', L',', L' ', L't', L'h', L'e', L' ', 
L'w', L'r', L'i', L't', L'e', L'r', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L'i', L's', L' ', L'i', L'n', L'v', 
L'o', L'k', L'e', L'd', L'.', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'u', L's', L'e', L'r', L'P', L'r', L'o', L'c', 
L'e', L'd', L'u', L'r', L'e', L'"', L' ', L'd', L't', L':', 
L't', L'y', L'p', L'e', L'=', L'"', L'u', L'r', L'i', L'"', 
L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', 
L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', 
L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L'D', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L' ', L'o', L'f', L' ', L'a', L'c', L't', L'i', L'o', 
L'n', L's', L' ', L't', L'h', L'a', L't', L' ', L't', L'h', 
L'e', L' ', L'u', L's', L'e', L'r', L' ', L's', L'h', L'o', 
L'u', L'l', L'd', L' ', L'p', L'e', L'r', L'f', L'o', L'r', 
L'm', L' ', L't', L'o', L' ', L'r', L'e', L's', L't', L'o', 
L'r', L'e', L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', 
L'e', L's', L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L'T', L'h', L'e', L' ', L'f', L'o', L'r', L'm', L'a', L't', 
L' ', L'o', L'f', L' ', L't', L'h', L'i', L's', L' ', L's', 
L't', L'r', L'i', L'n', L'g', L' ', L'h', L'a', L's', L' ', 
L'y', L'e', L't', L' ', L't', L'o', L' ', L'b', L'e', L' ', 
L'd', L'e', L't', L'e', L'r', L'm', L'i', L'n', L'e', L'd', 
L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'r', L'e', L'b', 
L'o', L'o', L't', L'R', L'e', L'q', L'u', L'i', L'r', L'e', 
L'd', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', 
L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', 
L'l', L'u', L'e', L's', L'=', L'"', L'y', L'e', L's', L' ', 
L'n', L'o', L'"', L' ', L'd', L'e', L'f', L'a', L'u', L'l', 
L't', L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L'S', L'h', L'o', L'u', L'l', L'd', L' ', L'a', 
L' ', L'r', L'e', L'b', L'o', L'o', L't', L' ', L'b', L'e', 
L' ', L'p', L'e', L'r', L'f', L'o', L'r', L'm', L'e', L'd', 
L' ', L'a', L'f', L't', L'e', L'r', L' ', L'r', L'e', L's', 
L't', L'o', L'r', L'i', L'n', L'g', L' ', L't', L'h', L'e', 
L' ', L'd', L'a', L't', L'a', L' ', L'f', L'o', L'r', L' ', 
L't', L'h', L'i', L's', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L'w', L'r', L'i', L't', L'e', L'r', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'm', 
L'e', L't', L'h', L'o', L'd', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L's', 
L'e', L'r', L'v', L'i', L'c', L'e', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'w', L'r', L'i', L't', L'e', L'r', L'R', L'e', L's', L't', 
L'o', L'r', L'e', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'u', L's', L'e', 
L'r', L'P', L'r', L'o', L'c', L'e', L'd', L'u', L'r', L'e', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'r', L'e', L'b', L'o', L'o', L't', 
L'R', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', 
L'e', L'n', L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'A', L'L', L'T', L'E', L'R', L'N', L'A', L'T', L'E', L'_', 
L'L', L'O', L'C', L'A', L'T', L'I', L'O', L'N', L'_', L'M', 
L'A', L'P', L'P', L'I', L'N', L'G', L'"', L' ', L'm', L'i', 
L'n', L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', 
L'"', L' ', L'm', L'a', L'x', L'O', L'c', L'c', L'u', L'r', 
L's', L'=', L'"', L'*', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', 
L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L'A', L'L', L'T', L'E', 
L'R', L'N', L'A', L'T', L'E', L'_', L'L', L'O', L'C', L'A', 
L'T', L'I', L'O', L'N', L'_', L'M', L'A', L'P', L'P', L'I', 
L'N', L'G', L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', 
L't', L'=', L'"', L'e', L'm', L'p', L't', L'y', L'"', L' ', 
L'm', L'o', L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', 
L's', L'e', L'd', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L'M', 
L'a', L'p', L'p', L'i', L'n', L'g', L' ', L'f', L'r', L'o', 
L'm', L' ', L'a', L' ', L'l', L'o', L'c', L'a', L't', L'i', 
L'o', L'n', L' ', L't', L'h', L'a', L't', L' ', L'w', L'a', 
L's', L' ', L'b', L'a', L'c', L'k', L'e', L'd', L' ', L'u', 
L'p', L' ', L't', L'o', L' ', L'a', L' ', L'l', L'o', L'c', 
L'a', L't', L'i', L'o', L'n', L' ', L't', L'o', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L' ', L't', L'o', L'.', 
L'\r', L'\n', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'p', 
L'a', L't', L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'f', L'i', L'l', 
L'e', L's', L'p', L'e', L'c', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'r', 
L'e', L'c', L'u', L'r', L's', L'i', L'v', L'e', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'a', L'l', L't', L'e', L'r', L'n', L'a', L't', 
L'e', L'P', L'a', L't', L'h', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'<', L'/', L'S', 
L'c', L'h', L'e', L'm', L'a', L'>', L'\r', L'\n', L'\0'
};
const unsigned g_cwcWriterMetadataXML = 11978;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\backupext\vsxml\base64coder.h ===
// Base64Coder.h: interface for the Base64Coder class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BASE64CODER_H__B2E45717_0625_11D2_A80A_00C04FB6794C__INCLUDED_)
#define AFX_BASE64CODER_H__B2E45717_0625_11D2_A80A_00C04FB6794C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "BUEB64CH"
//
////////////////////////////////////////////////////////////////////////

class Base64Coder
	{
	// Internal bucket class.
	class TempBucket
	{
	public:
		BYTE		nData[4];
		BYTE		nSize;
		void		Clear()
			{
			::ZeroMemory(nData, sizeof(nData));
			nSize = 0;
			}
	};

	PBYTE					m_pDBuffer;
	LPWSTR					m_pEBuffer;
	UINT					m_nDBufLen;
	UINT					m_nEBufLen;
	UINT					m_nDDataLen;
	UINT					m_nEDataLen;

public:
	Base64Coder();
	virtual ~Base64Coder();

public:
	virtual void		Encode(const BYTE *, UINT);
	virtual void		Decode(LPCWSTR);

	virtual BYTE *		DecodedMessage() const;
	virtual LPCWSTR		EncodedMessage() const;

	virtual void		AllocEncode(UINT);
	virtual void		AllocDecode(UINT);
	virtual void		SetEncodeBuffer(LPCWSTR pBuffer, UINT nBufLen);
	virtual void		SetDecodeBuffer(const BYTE *pBuffer, UINT nBufLen);

protected:
	virtual void		_EncodeToBuffer(const TempBucket &Decode, LPWSTR pBuffer);
	virtual UINT		_DecodeToBuffer(const TempBucket &Decode, BYTE *pBuffer);
	virtual void		_EncodeRaw(TempBucket &, const TempBucket &);
	virtual void		_DecodeRaw(TempBucket &, const TempBucket &);
	virtual BOOL		_IsBadMimeChar(WCHAR);

	static  char		m_DecodeTable[256];
	static  BOOL		m_Init;
	void				_Init();
	};

#endif // !defined(AFX_BASE64CODER_H__B2E45717_0625_11D2_A80A_00C04FB6794C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\backupext\vsxml\base64coder.cpp ===
// Base64Coder.cpp: implementation of the Base64Coder class.
//
//////////////////////////////////////////////////////////////////////

#include <stdafx.hxx>
#include "Base64Coder.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "BUEB64CC"
//
////////////////////////////////////////////////////////////////////////

// Digits...
static char	Base64Digits[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";


BOOL Base64Coder::m_Init		= FALSE;
char Base64Coder::m_DecodeTable[256];

#ifndef PAGESIZE
#define PAGESIZE					4096
#endif

#ifndef ROUNDTOPAGE
#define ROUNDTOPAGE(a)			(((a/4096)+1)*4096)
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

Base64Coder::Base64Coder() :
	m_pDBuffer(NULL),
	m_pEBuffer(NULL),
	m_nDBufLen(0),
	m_nEBufLen(0)
	{
	}

Base64Coder::~Base64Coder()
	{
	if(m_pDBuffer != NULL)
		delete [] m_pDBuffer;

	if(m_pEBuffer != NULL)
		delete [] m_pEBuffer;
	}

BYTE *Base64Coder::DecodedMessage() const
	{
	return m_pDBuffer;
	}

LPCWSTR Base64Coder::EncodedMessage() const
	{
	return m_pEBuffer;
	}

void Base64Coder::AllocEncode(UINT nSize)
	{
	if(m_nEBufLen < nSize)
		{
		if(m_pEBuffer != NULL)
			delete [] m_pEBuffer;

		m_nEBufLen = ROUNDTOPAGE(nSize);
		m_pEBuffer = new WCHAR[m_nEBufLen];
		if (m_pEBuffer == NULL)
			{
			// reset allocated size to 0
			m_nEBufLen = 0;
			throw(E_OUTOFMEMORY);
			}
		}

	::ZeroMemory(m_pEBuffer, m_nEBufLen*sizeof(WCHAR));
	m_nEDataLen = 0;
	}

void Base64Coder::AllocDecode(UINT nSize)
	{
	if(m_nDBufLen < nSize)
		{
		if(m_pDBuffer != NULL)
			delete [] m_pDBuffer;

		m_nDBufLen = ROUNDTOPAGE(nSize);
		m_pDBuffer = new BYTE[m_nDBufLen];
		if (m_pDBuffer == NULL)
			{
			// reset allocated size to 0
			m_nDBufLen = 0;
			throw(E_OUTOFMEMORY);
			}
		}

	::ZeroMemory(m_pDBuffer, m_nDBufLen);

	m_nDDataLen = 0;
	}

void Base64Coder::SetEncodeBuffer(const LPCWSTR pBuffer, UINT nBufLen)
	{
	UINT	i = 0;

	AllocEncode(nBufLen);
	while(i < nBufLen)
		{
		if(!_IsBadMimeChar(pBuffer[i]))
			{
			m_pEBuffer[m_nEDataLen] = pBuffer[i];
			m_nEDataLen++;
			}

		i++;
		}
	}

void Base64Coder::SetDecodeBuffer(const BYTE *pBuffer, UINT nBufLen)
	{
	AllocDecode(nBufLen + sizeof(nBufLen));
    ::CopyMemory(m_pDBuffer, &nBufLen, sizeof(nBufLen));
	::CopyMemory(m_pDBuffer + sizeof(nBufLen), pBuffer, nBufLen);
	m_nDDataLen = nBufLen + sizeof(nBufLen);
	}

void Base64Coder::Encode(const BYTE *pBuffer, UINT nBufLen)
	{
	SetDecodeBuffer(pBuffer, nBufLen);
    // include length
    nBufLen += sizeof(nBufLen);
	AllocEncode(nBufLen * 2);

	TempBucket			Raw;
	UINT					nIndex	= 0;

	while((nIndex + 3) <= nBufLen)
		{
		Raw.Clear();
		::CopyMemory(&Raw, m_pDBuffer + nIndex, 3);
		Raw.nSize = 3;
		_EncodeToBuffer(Raw, m_pEBuffer + m_nEDataLen);
		nIndex		+= 3;
		m_nEDataLen	+= 4;
		}

	if(nBufLen > nIndex)
		{
		Raw.Clear();
		Raw.nSize = (BYTE) (nBufLen - nIndex);
		::CopyMemory(&Raw, m_pDBuffer + nIndex, nBufLen - nIndex);
		_EncodeToBuffer(Raw, m_pEBuffer + m_nEDataLen);
		m_nEDataLen += 4;
		}
	}
	
void Base64Coder::Decode(const LPCWSTR pBuffer)
	{
	UINT dwBufLen = (UINT) wcslen(pBuffer);

	if(!Base64Coder::m_Init)
		_Init();

	SetEncodeBuffer(pBuffer, dwBufLen);

	AllocDecode(dwBufLen);

	TempBucket			Raw;

	UINT		nIndex = 0;

	while((nIndex + 4) <= m_nEDataLen)
		{
		Raw.Clear();
		Raw.nData[0] = Base64Coder::m_DecodeTable[m_pEBuffer[nIndex]];
		Raw.nData[1] = Base64Coder::m_DecodeTable[m_pEBuffer[nIndex + 1]];
		Raw.nData[2] = Base64Coder::m_DecodeTable[m_pEBuffer[nIndex + 2]];
		Raw.nData[3] = Base64Coder::m_DecodeTable[m_pEBuffer[nIndex + 3]];

		if(Raw.nData[2] == 255)
			Raw.nData[2] = 0;
		if(Raw.nData[3] == 255)
			Raw.nData[3] = 0;
		
		Raw.nSize = 4;
		_DecodeToBuffer(Raw, m_pDBuffer + m_nDDataLen);
		nIndex += 4;
		m_nDDataLen += 3;
		}
	
   // If nIndex < m_nEDataLen, then we got a decode message without padding.
   // We may want to throw some kind of warning here, but we are still required
   // to handle the decoding as if it was properly padded.
	if(nIndex < m_nEDataLen)
		{
		Raw.Clear();
		for(UINT i = nIndex; i < m_nEDataLen; i++)
			{
			Raw.nData[i - nIndex] = Base64Coder::m_DecodeTable[m_pEBuffer[i]];
			Raw.nSize++;
			if(Raw.nData[i - nIndex] == 255)
				Raw.nData[i - nIndex] = 0;
			}

		_DecodeToBuffer(Raw, m_pDBuffer + m_nDDataLen);
		m_nDDataLen += (m_nEDataLen - nIndex);
		}
	}

UINT Base64Coder::_DecodeToBuffer(const TempBucket &Decode, BYTE *pBuffer)
	{
	TempBucket	Data;
	UINT			nCount = 0;

	_DecodeRaw(Data, Decode);

	for(int i = 0; i < 3; i++)
		{
		pBuffer[i] = Data.nData[i];
		if(pBuffer[i] != 255)
			nCount++;
		}

	return nCount;
	}


void Base64Coder::_EncodeToBuffer(const TempBucket &Decode, LPWSTR pBuffer)
	{
	TempBucket	Data;

	_EncodeRaw(Data, Decode);

	for(int i = 0; i < 4; i++)
		pBuffer[i] = Base64Digits[Data.nData[i]];

	switch(Decode.nSize)
		{
		case 1:
			pBuffer[2] = '=';
		case 2:
			pBuffer[3] = '=';
			}
		}

void Base64Coder::_DecodeRaw(TempBucket &Data, const TempBucket &Decode)
	{
	BYTE		nTemp;

	Data.nData[0] = Decode.nData[0];
	Data.nData[0] <<= 2;

	nTemp = Decode.nData[1];
	nTemp >>= 4;
	nTemp &= 0x03;
	Data.nData[0] |= nTemp;

	Data.nData[1] = Decode.nData[1];
	Data.nData[1] <<= 4;

	nTemp = Decode.nData[2];
	nTemp >>= 2;
	nTemp &= 0x0F;
	Data.nData[1] |= nTemp;

	Data.nData[2] = Decode.nData[2];
	Data.nData[2] <<= 6;
	nTemp = Decode.nData[3];
	nTemp &= 0x3F;
	Data.nData[2] |= nTemp;
	}

void Base64Coder::_EncodeRaw(TempBucket &Data, const TempBucket &Decode)
	{
	BYTE		nTemp;

	Data.nData[0] = Decode.nData[0];
	Data.nData[0] >>= 2;
	
	Data.nData[1] = Decode.nData[0];
	Data.nData[1] <<= 4;
	nTemp = Decode.nData[1];
	nTemp >>= 4;
	Data.nData[1] |= nTemp;
	Data.nData[1] &= 0x3F;

	Data.nData[2] = Decode.nData[1];
	Data.nData[2] <<= 2;

	nTemp = Decode.nData[2];
	nTemp >>= 6;

	Data.nData[2] |= nTemp;
	Data.nData[2] &= 0x3F;

	Data.nData[3] = Decode.nData[2];
	Data.nData[3] &= 0x3F;
	}

BOOL Base64Coder::_IsBadMimeChar(WCHAR nData)
	{
	switch(nData)
		{
		case L'\r': case L'\n': case L'\t': case L' ' :
		case L'\b': case L'\a': case L'\f': case L'\v':
			return TRUE;
		default:
			return FALSE;
		}
	}

void Base64Coder::_Init()
	{
	// Initialize Decoding table.
	int	i;

	for(i = 0; i < 256; i++)
		Base64Coder::m_DecodeTable[i] = -2;

	for(i = 0; i < 64; i++)
		{
		Base64Coder::m_DecodeTable[Base64Digits[i]]			= (char) i;
		Base64Coder::m_DecodeTable[Base64Digits[i]|0x80]	= (char) i;
		}

	Base64Coder::m_DecodeTable['=']				= -1;
	Base64Coder::m_DecodeTable['='|0x80]		= -1;

	Base64Coder::m_Init = TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\backupext\mkschema\main.cpp ===
#include "stdafx.hxx"
#include "vs_inc.hxx"

static unsigned s_iwcDocBegin;
static unsigned s_iwcDocEnd;


unsigned PrintStringToFile(FILE *file, LPCWSTR wsz, bool bPrintRootElement)
	{
	const WCHAR *pwc = wsz;
	fputc('{', file);
	unsigned ich = 0;

	if (bPrintRootElement)
		{
		fputs("L'<', L'r', L'o', L'o', L't', L'>', L'\\n', ", file);
		ich = 7;
		}

	s_iwcDocBegin = ich;


	while(*pwc != L'\0')
		{
		if ((ich++ % 10) == 0)
			fputc('\n', file);

		fprintf(file, "L'");

		if (*pwc == L'\\')
			{
			fputc('\\', file);
			fputc('\\', file);
			}
		else if (*pwc == L'\n')
			{
			fputc('\\', file);
			fputc('n', file);
			}
		else if (*pwc == L'\r')
			{
			fputc('\\', file);
			fputc('r', file);
			}
		else if (*pwc == L'\t')
			{
			fputc('\\', file);
			fputc('t', file);
			}
		else
			fputc((char) *pwc, file);

		fprintf(file, "', ");
		pwc++;
		}

	s_iwcDocEnd = ich;

	if (bPrintRootElement)
		{
		fputc('\n', file);
		fputs("L'\\n', L'<', L'/', L'r', L'o', L'o', L't', L'>', L'\\n', ", file);
		ich += 9;
		}


	fprintf(file, "L'\\0'\n};");

	return ich;
	}

extern "C" __cdecl wmain(int, WCHAR **)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"main");

	CXMLDocument doc;

	try
		{
		ft.hr = CoInitialize(NULL);
		if (ft.HrFailed())
			ft.Throw
				(
				VSSDBG_XML,
				E_UNEXPECTED,
				L"CoInitialize failed.  hr = 0x%08lx",
				ft.hr
				);

		if (!doc.LoadFromFile(L"writermetadata.xml"))
			{
			printf("Cannot load writermetadata.xml\n");
			exit(-1);
			}

		CComBSTR bstr = doc.SaveAsXML();
		FILE *f = fopen("wmxml.c", "w");
		if (f == NULL)
			{
			printf("create of wmxml.c failed\n");
			exit(-1);
			}

		fprintf(f, "WCHAR g_WriterMetadataXML[] = \n");
		unsigned cwc = PrintStringToFile(f, bstr, false);
		fprintf
			(
			f,
			"\nconst unsigned g_cwcWriterMetadataXML = %d;\n\n",
			cwc
			);

		bstr.Empty();
		fclose(f);

		if (!doc.LoadFromFile(L"componentmetadata.xml"))
			{
			printf("Cannot load componentmetadata.xml\n");
			exit(-1);
			}

		bstr = doc.SaveAsXML();
		f = fopen("cmxml.c", "w");
		if (f == NULL)
			{
			printf("create of cmxml.c failed\n");
			exit(-1);
			}

		fprintf(f, "WCHAR g_ComponentMetadataXML[] = \n");
		cwc = PrintStringToFile(f, bstr, true);
		fprintf
			(
			f,
			"\nconst unsigned g_cwcComponentMetadataXML = %d;\n\n",
			cwc
			);

		fprintf
			(
			f,
			"\nconst unsigned g_iwcComponentMetadataXMLBegin = %d;\n\n",
			s_iwcDocBegin
			);

		fprintf
			(
			f,
			"\nconst unsigned g_iwcComponentMetadataXMLEnd = %d;\n\n",
			s_iwcDocEnd
			);

		fclose(f);
		}
	VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed())
		{
		printf("Unexpected exception, hr = 0x%08lx", ft.hr);
		exit(-1);
		}

	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\backupext\vsxml\async.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module async.cxx | Implementation of CVssAsyncBackup object
    @end

Author:

    brian berkowitz  [brianb]  04/10/2000

Revision History:

    Name        Date        Comments
    brianb      04/10/2000  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"

#include "vs_inc.hxx"
#include "vs_sec.hxx"

#include "vs_idl.hxx"

#include "vswriter.h"
#include "vsbackup.h"
#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"

#include "worker.hxx"
#include "async.hxx"
#include "vssmsg.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "BUEASYNC"
//
////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
//  CVssAsyncBackup


// constructor
CVssAsyncBackup::CVssAsyncBackup():
	m_hrState(S_OK),
	m_state(VSS_AS_UNDEFINED),
	m_pBackupComponents(NULL),
	m_bOwned(NULL)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncBackup::CVssAsyncBackup");

	m_bcsInitialized = false;
	try
		{
		// Initialize the critical section
		m_cs.Init();
		m_bcsInitialized = true;
		}
	VSS_STANDARD_CATCH(ft)
	}


// destructor
CVssAsyncBackup::~CVssAsyncBackup()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncBackup::~CVssAsyncBackup");

	try
		{
		// Wait for the worker thread to finish, if running.
		// WARNING: FinalReleaseWorkerThreadObject uses virtual methods!
		// Virtual methods in classes derived from CVssAsync are now inaccessible!
		FinalReleaseWorkerThreadObject();
		}
	VSS_STANDARD_CATCH(ft)
	}


// do operation by creating a thread to do it and return an IVssAsync object
// for backup to use
IVssAsync* CVssAsyncBackup::CreateInstanceAndStartJob
	(
	IN	CVssBackupComponents *	pBackupComponents,
	VSS_ASYNC_STATE				state
	)
	{
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncBackup::CreateInstanceAndStartJob" );
	CComPtr<IVssAsync> pAsync;

    try
		{
		BS_ASSERT(state == VSS_AS_PREPARE_FOR_BACKUP ||
				  state == VSS_AS_BACKUP_COMPLETE ||
				  state == VSS_AS_RESTORE ||
				  state == VSS_AS_GATHER_WRITER_METADATA ||
				  state == VSS_AS_GATHER_WRITER_STATUS);

		BS_ASSERT(pBackupComponents);

        // Allocate the COM object.
        CComObject<CVssAsyncBackup>* pObject;
        ft.hr = CComObject<CVssAsyncBackup>::CreateInstance(&pObject);
        if (ft.HrFailed())
            ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Error creating the CVssAsync instance. hr = 0x%08lx", ft.hr
				);

        if (!pObject->m_bcsInitialized)
            ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Error initializing critical section"
				);


        BS_ASSERT(pObject);

		// Setting async object internal data
        pObject->m_pBackupComponents = pBackupComponents;
		pObject->m_pvbcReference = pBackupComponents;
		pObject->m_state = state;

        // Querying the IVssSnapshot interface. Now the ref count becomes 1.
        CComPtr<IUnknown> pUnknown = pObject->GetUnknown();
        BS_ASSERT(pUnknown);
        ft.hr = pUnknown->SafeQI(IVssAsync, &pAsync); // The ref count is 2.
        if (ft.HrFailed())
			{
			ft.LogError(VSS_ERROR_QI_IVSSASYNC_FAILED, VSSDBG_XML << ft.hr);
            ft.Throw
				(
				VSSDBG_XML,
				E_UNEXPECTED,
				L"Error querying the IVssAsync interface. hr = 0x%08lx",
				ft.hr
				);
            }

		BS_ASSERT(pAsync);

		// Prepare job (thread created in resume state)
		ft.hr = pObject->PrepareJob();
        if (ft.HrFailed())
            ft.Throw
				(
				VSSDBG_XML,
				ft.hr,
				L"CVssAsyncBackup::PrepareJob failed.  hr = 0x%08lx.",
				ft.hr
				);

		// increment reference count so that it lives throughout lifetime
		// of async thread
		pObject->GetUnknown()->AddRef();
		pObject->SetOwned();

		// Start job
		ft.hr = pObject->StartJob();
        if (ft.HrFailed())
			{
			// release reference held for thread
			pObject->ClearOwned();
			pObject->GetUnknown()->Release();
            ft.Throw
				(
				VSSDBG_XML,
				ft.hr,
				L"Error starting the job. hr = 0x%08lx",
				ft.hr
				);
			}

		// Now the background thread related members (m_hrState, m_nPercentDone) begin to update.
		}
    VSS_STANDARD_CATCH(ft)

	return pAsync.Detach();	  // The ref count remains 1.
	}


/////////////////////////////////////////////////////////////////////////////
//  CVssWorkerThread overrides


// do basic initialization
bool CVssAsyncBackup::OnInit()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncBackup::OnInit");

    try
		{
		if (m_pBackupComponents != NULL)
			{
			BS_ASSERT(m_hrState == S_OK);
			m_hrState = VSS_S_ASYNC_PENDING;
			}
		}
    VSS_STANDARD_CATCH(ft)

	return m_pBackupComponents != NULL;
	}


// execute PrepareForBackup or BackupComplete
void CVssAsyncBackup::OnRun()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncBackup::OnRun");

	bool bCoInitializeSucceeded = false;

	try
		{
		// Check if the backup components object is created.
		if (m_pBackupComponents == NULL)
			{
			ft.LogError(VSS_ERROR_BACKUPCOMPONENTS_NULL, VSSDBG_XML);
			ft.Throw(VSSDBG_XML, E_UNEXPECTED, L"BackupComponents object is NULL.");
			}

		ft.hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
		ft.CheckForError(VSSDBG_XML, L"CoInitializeEx");

        bCoInitializeSucceeded = true;
		// We assume that the async object is not yet released.
		// (the wait in destructor should ensure that).

		m_timestamp = m_pBackupComponents->m_timestampOperation + 1;

		
		// Call StartSnapshotSet on the given object.
		if (m_state == VSS_AS_PREPARE_FOR_BACKUP)
			{
			ft.hr = m_pBackupComponents->InternalPrepareForBackup();
			if (ft.HrFailed())
				ft.Trace
					(
					VSSDBG_XML,
					L"Internal PrepareBackup failed. 0x%08lx",
					ft.hr
					);
            }
		else if (m_state == VSS_AS_BACKUP_COMPLETE)
			{
			ft.hr = m_pBackupComponents->InternalBackupComplete();
			if (ft.hr != S_OK)
				ft.Trace
					(
					VSSDBG_XML,
					L"Internal BackupComplete failed. 0x%08lx",
					ft.hr
					);
			}
		else if (m_state == VSS_AS_RESTORE)
			{
			ft.hr = m_pBackupComponents->InternalPostRestore();
			if (ft.hr != S_OK)
				ft.Trace
					(
					VSSDBG_XML,
					L"Internal BackupComplete failed. 0x%08lx",
					ft.hr
					);
            }
		else if (m_state == VSS_AS_GATHER_WRITER_METADATA)
			{
			// save previous state and timestamp that will be used
			// for gather writer metadata.  It is passed into
			// PostGatherWriterMetadata if Cancel is called.
			m_stateSaved = m_pBackupComponents->m_state;
			ft.hr = m_pBackupComponents->InternalGatherWriterMetadata();
			if (ft.hr != S_OK)
				ft.Trace
					(
					VSSDBG_XML,
					L"Internal GatherWriterMetadata failed. 0x%08lx",
					ft.hr
					);
            }
		else
			{
			BS_ASSERT(m_state == VSS_AS_GATHER_WRITER_STATUS);

			// save previous state and timestamp that will be used
			// for gather writer metadata.  It is passed into
			// PostGatherWriterStatus if Cancel is called.
			m_stateSaved = m_pBackupComponents->m_state;

			ft.hr = m_pBackupComponents->InternalGatherWriterStatus();
			if (ft.hr != S_OK)
				ft.Trace
					(
					VSSDBG_XML,
					L"Internal GatherWriterStatus failed. 0x%08lx",
					ft.hr
					);
            }

		if (ft.hr != S_OK)
			// Put the error code into the
			m_hrState = ft.hr;
		}
	VSS_STANDARD_CATCH(ft)

	if (bCoInitializeSucceeded)
		CoUninitialize();
	}


void CVssAsyncBackup::OnFinish()	
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncBackup::OnFinish");

    try
		{
		if (m_hrState == VSS_S_ASYNC_PENDING)
			m_hrState = VSS_S_ASYNC_FINISHED;

        // Mark the thread as finished, as the last operation
		MarkAsFinished();
		}
	VSS_STANDARD_CATCH(ft)

	// release interface pointer owned by the thread
	BS_ASSERT(m_bOwned);
	m_bOwned = false;
	Release();
	}


void CVssAsyncBackup::OnTerminate()
    {
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsyncBackup::OnTerminate" );
    }



/////////////////////////////////////////////////////////////////////////////
//  IVssAsync implementation


STDMETHODIMP CVssAsyncBackup::Cancel()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncBackup::Cancel");

	try
		{
		// The critical section will be left automatically at the end of scope.
		CVssSafeAutomaticLock lock(m_cs);

		// Safety check
		if (m_pBackupComponents == NULL)
			{
			ft.LogError(VSS_ERROR_BACKUPCOMPONENTS_NULL, VSSDBG_XML);
			ft.Throw(VSSDBG_XML, E_UNEXPECTED, L"BackupComponents object is NULL");
			}

		// If thread is already finished, return correct code.
		if (m_hrState == VSS_S_ASYNC_FINISHED ||
			m_hrState == VSS_S_ASYNC_CANCELLED)
			ft.hr = m_hrState;
		else
			{
			m_hrState = VSS_S_ASYNC_CANCELLED;
			switch(m_state)
				{
				default:
					BS_ASSERT(FALSE && "Invalid ASYNC state");
					break;

				case VSS_AS_PREPARE_FOR_BACKUP:
					m_pBackupComponents->PostPrepareForBackup(m_timestamp);
					break;

				case VSS_AS_BACKUP_COMPLETE:
					m_pBackupComponents->PostBackupComplete(m_timestamp);
					break;

				case VSS_AS_RESTORE:
					m_pBackupComponents->PostPostRestore(m_timestamp);
					break;

				case VSS_AS_GATHER_WRITER_STATUS:
					m_pBackupComponents->PostGatherWriterStatus
						(
						m_timestamp,
						m_stateSaved
						);

					break;

				case VSS_AS_GATHER_WRITER_METADATA:
					ft.hr = m_pBackupComponents->PostGatherWriterMetadata
						(
						m_timestamp,
						m_stateSaved
						);

                    if (FAILED(ft.hr))
						m_hrState = ft.hr;

					break;
				}
			}
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


STDMETHODIMP CVssAsyncBackup::Wait()
{
	CVssFunctionTracer ft( VSSDBG_XML, L"CVssAsyncBackup::Wait" );

	try
		{
		// Safety check
		if (m_pBackupComponents == NULL)
			{
			BS_ASSERT(false);
			ft.LogError(VSS_ERROR_BACKUPCOMPONENTS_NULL, VSSDBG_XML);
			ft.Throw( VSSDBG_XML, E_UNEXPECTED, L"BackupComponents object is NULL.");
			}

		// wait for thread to terminate
		HANDLE hThread = GetThreadHandle();
		if (hThread == NULL)
			{
			ft.LogError(VSS_ERROR_THREADHANDLE_NULL, VSSDBG_XML);
			ft.Throw( VSSDBG_XML, E_UNEXPECTED, L"invalid hThread");
			}

		if (::WaitForSingleObject(hThread, INFINITE) == WAIT_FAILED)
			{
			ft.LogError(VSS_ERROR_WAITFORSINGLEOBJECT, VSSDBG_XML << HRESULT_FROM_WIN32(GetLastError()));
			ft.Throw( VSSDBG_XML, E_UNEXPECTED, L"Wait failed. [0x%08lx]", ::GetLastError());
			}
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


STDMETHODIMP CVssAsyncBackup::QueryStatus
	(
	OUT     HRESULT* pHrResult,
	OUT     INT* pnReserved
	)
	{
	CVssFunctionTracer ft( VSSDBG_XML, L"CVssAsyncBackup::QueryStatus" );

	try
		{
		VssZeroOut(pHrResult);
		VssZeroOut(pnReserved);
		// Argument check
		if (pHrResult == NULL)
			ft.Throw( VSSDBG_XML, E_INVALIDARG, L"Output parameter is NULL.");

		// The critical section will be left automatically at the end of scope.
		CVssSafeAutomaticLock lock(m_cs);

		// Safety check
		if (m_pBackupComponents == NULL)
			{
			ft.LogError(VSS_ERROR_BACKUPCOMPONENTS_NULL, VSSDBG_XML);
			ft.Throw( VSSDBG_XML, E_UNEXPECTED, L"BackupComponents object is NULL.");
			}

		(*pHrResult) = m_hrState;
		ft.Trace( VSSDBG_XML, L"Returning *pHrResult: 0x%08x", *pHrResult );		
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}



/////////////////////////////////////////////////////////////////////////////
//  IVssAsync Cover implementation


void CVssAsyncCover::CreateInstance(
    IN  CVssBackupComponents* pBackupComponents,
    IN  IVssAsync* pAsyncInternal,
    OUT IVssAsync** ppAsync
    ) throw(HRESULT)

/*++

Description:

    Creates a cover for a given IVssAsync and a backup components object.

Comments:

    This object is used to intercept all calls to the internal async QueryStatus

--*/

{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncCover::CreateInstance");

    BS_ASSERT(pBackupComponents);
    BS_ASSERT(pAsyncInternal);
    BS_ASSERT(ppAsync && (*ppAsync == NULL));
	
	// create cover async object
	CComObject<CVssAsyncCover>* pObject;
	ft.hr = CComObject<CVssAsyncCover>::CreateInstance(&pObject);
	if (ft.HrFailed())
		ft.Throw
		(
		VSSDBG_XML,
		E_OUTOFMEMORY,
		L"Error creating the CVssAsync instance. hr = 0x%08lx", ft.hr
		);

    // Fill out the data members (the ref counts are incremented)
	pObject->m_pvbc = pBackupComponents;
	pObject->m_pvbcReference = pBackupComponents;
	pObject->m_pAsync = pAsyncInternal;

	// Get the IVssAsync interface
	CComPtr<IUnknown> pUnknown = pObject->GetUnknown();
	BS_ASSERT(pUnknown);
	CComPtr<IVssAsync> ptrAsync;
	ft.hr = pUnknown->SafeQI(IVssAsync, &ptrAsync);
	if (ft.HrFailed())
		{
		BS_ASSERT(FALSE && "QI shouldn't fail");
		ft.LogError(VSS_ERROR_QI_IVSSASYNC_FAILED, VSSDBG_XML << ft.hr);
		ft.Throw
			(
			VSSDBG_XML,
			E_UNEXPECTED,
			L"Error querying the IVssAsync interface. hr = 0x%08lx",
			ft.hr
			);
		}

    // Copy the interface to the out parameter
    ptrAsync.CopyTo(ppAsync);
}


STDMETHODIMP CVssAsyncCover::Cancel()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncCover::Cancel");

	BS_ASSERT(m_pAsync);
	BS_ASSERT(m_pvbc);

	ft.hr = m_pAsync->Cancel();
	if (ft.hr == VSS_S_ASYNC_FINISHED)
		m_pvbc->m_state = x_StateDoSnapshotSucceeded;
	else
		m_pvbc->m_state = x_StateDoSnapshotFailed;

	return ft.hr;
	}


STDMETHODIMP CVssAsyncCover::Wait()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncCover::Wait");

	BS_ASSERT(m_pAsync);
	BS_ASSERT(m_pvbc);

	ft.hr = m_pAsync->Wait();

	return ft.hr;
	}


STDMETHODIMP CVssAsyncCover::QueryStatus
	(
	OUT     HRESULT* pHrResult,
	OUT     INT* pnPercentDone
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncCover::QueryStatus");

	if (pHrResult == NULL)
		return E_INVALIDARG;

	BS_ASSERT(m_pAsync);
	BS_ASSERT(m_pvbc);

	try
		{
		ft.hr = m_pAsync->QueryStatus(pHrResult, pnPercentDone);
		if (*pHrResult == VSS_E_BAD_STATE)
			m_pvbc->m_state = x_StateDoSnapshotFailedWithoutSendingAbort;
		else if (FAILED(ft.hr) ||
			FAILED(*pHrResult) ||
			*pHrResult == VSS_S_ASYNC_CANCELLED)
			m_pvbc->m_state = x_StateDoSnapshotFailed;
		else if (*pHrResult == VSS_S_ASYNC_FINISHED)
			 m_pvbc->m_state = x_StateDoSnapshotSucceeded;
		 }
	 VSS_STANDARD_CATCH(ft)

	 return ft.hr;
	 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\backupext\vsxml\helper.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vs_wmxml.cxx

Abstract:

    Implementation of CVssMetadataHelper class

	Brian Berkowitz  [brianb]  3/13/2000

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    brianb      03/30/2000  Created

--*/

#include "stdafx.hxx"
#include "vs_inc.hxx"

#include "vs_idl.hxx"

#include "vswriter.h"
#include "vsbackup.h"
#include "vs_wmxml.hxx"
#include "vssmsg.h"


#include "rpcdce.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "BUEHELPC"
//
////////////////////////////////////////////////////////////////////////

// boolean type string values
static LPCWSTR x_wszYes = L"yes";
static LPCWSTR x_wszNo = L"no";

// usage type string values
static LPCWSTR x_wszBOOTABLESYSTEMSTATE = L"BOOTABLE_SYSTEM_STATE";
static LPCWSTR x_wszSYSTEMSERVICE = L"SYSTEM_SERVICE";
static LPCWSTR x_wszUSERDATA = L"USER_DATA";
static LPCWSTR x_wszOTHER = L"OTHER";

// source type string values
static LPCWSTR x_wszTRANSACTEDDB = L"TRANSACTION_DB";
static LPCWSTR x_wszNONTRANSACTEDDB = L"NONTRANSACTIONAL_DB";

// component ELEMENT type strings
static LPCWSTR x_wszElementDatabase = L"DATABASE";
static LPCWSTR x_wszElementFilegroup = L"FILE_GROUP";

// component value type strings
static LPCWSTR x_wszValueDatabase = L"database";
static LPCWSTR x_wszValueFilegroup = L"filegroup";

// writerRestore value type strings
static LPCWSTR x_wszNever = L"never";
static LPCWSTR x_wszAlways = L"always";
static LPCWSTR x_wszIfReplaceFails = L"ifReplaceFails";

// string restore methods
static LPCWSTR x_wszRESTOREIFNOTTHERE = L"RESTORE_IF_NONE_THERE";
static LPCWSTR x_wszRESTOREIFCANREPLACE = L"RESTORE_IF_CAN_BE_REPLACED";
static LPCWSTR x_wszSTOPRESTORESTART = L"STOP_RESTART_SERVICE";
static LPCWSTR x_wszRESTORETOALTERNATE = L"RESTORE_TO_ALTERNATE_LOCATION";
static LPCWSTR x_wszRESTOREATREBOOT = L"REPLACE_AT_REBOOT";
static LPCWSTR x_wszCUSTOM = L"CUSTOM";

// string backup types
static LPCWSTR x_wszValueFull = L"full";
static LPCWSTR x_wszValueDifferential = L"differential";
static LPCWSTR x_wszValueIncremental = L"incremental";
static LPCWSTR x_wszValueOther = L"other";




// convert boolean value to "yes" or "no"
LPCWSTR CVssMetadataHelper::WszFromBoolean(IN bool b)
    {
    return b ? x_wszYes : x_wszNo;
    }

// convert from "yes", "no" to a boolean value
bool CVssMetadataHelper::ConvertToBoolean
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstr
	) throw(HRESULT)
	{
	if (wcscmp(bstr, x_wszYes) == 0)
		return true;
	else if (wcscmp(bstr, x_wszNo) == 0)
		return false;
	else
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"Value %s is neither yes nor no.",
			bstr
			);

    return false;
	}

// convert a string to a VSS_ID value
void CVssMetadataHelper::ConvertToVSS_ID
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstr,
	OUT VSS_ID *pId
	) throw(HRESULT)
	{
	RPC_STATUS status = UuidFromString(bstr, pId);
	if (status != RPC_S_OK)
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"Value %s is not a valid guid.",
			bstr
			);
	}

// convert from VSS_USAGE_TYPE to string value
LPCWSTR CVssMetadataHelper::WszFromUsageType
    (
    IN CVssFunctionTracer &ft,
    IN VSS_USAGE_TYPE usage
    ) throw(HRESULT)
    {
    switch(usage)
        {
        default:
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Invalid usage type");

        case VSS_UT_OTHER:
            return(x_wszOTHER);

        case VSS_UT_BOOTABLESYSTEMSTATE:
            return(x_wszBOOTABLESYSTEMSTATE);

        case VSS_UT_SYSTEMSERVICE:
			return(x_wszSYSTEMSERVICE);

        case VSS_UT_USERDATA:
			return(x_wszUSERDATA);
		}
    }


// convert from string to VSS_USAGE_TYPE
VSS_USAGE_TYPE CVssMetadataHelper::ConvertToUsageType
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstr
	) throw(HRESULT)
	{
	if (wcscmp(bstr, x_wszBOOTABLESYSTEMSTATE) == 0)
        return(VSS_UT_BOOTABLESYSTEMSTATE);
	else if (wcscmp(bstr, x_wszSYSTEMSERVICE) == 0)
		return(VSS_UT_SYSTEMSERVICE);
	else if (wcscmp(bstr, x_wszUSERDATA) == 0)
		return(VSS_UT_USERDATA);
	else if (wcscmp(bstr, x_wszOTHER) == 0)
		return(VSS_UT_OTHER);
	else
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"The string %s is not a valid usage type",
			bstr
			);

    return VSS_UT_UNDEFINED;
	}

// convert from a VSS_SOURCE_TYPE value to a string
LPCWSTR CVssMetadataHelper::WszFromSourceType
    (
    IN CVssFunctionTracer &ft,
    IN VSS_SOURCE_TYPE source
    ) throw(HRESULT)
    {
	switch(source)
		{
		default:
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Invalid data source type");

		case VSS_ST_OTHER:
			return(x_wszOTHER);

        case VSS_ST_TRANSACTEDDB:
			return(x_wszTRANSACTEDDB);

        case VSS_ST_NONTRANSACTEDDB:
            return(x_wszNONTRANSACTEDDB);
        }
    }

// convert from a string to a VSS_SOURCE_TYPE value
VSS_SOURCE_TYPE CVssMetadataHelper::ConvertToSourceType
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstr
	)
	{
	if (wcscmp(bstr, x_wszTRANSACTEDDB) == 0)
		return(VSS_ST_TRANSACTEDDB);
	else if (wcscmp(bstr, x_wszNONTRANSACTEDDB) == 0)
		return(VSS_ST_NONTRANSACTEDDB);
	else if (wcscmp(bstr, x_wszOTHER) == 0)
		return(VSS_ST_OTHER);
	else
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"The string %s is not a valid source type.",
			bstr
			);

    return VSS_ST_UNDEFINED;
	}


// convert from VSS_COMPONENT_TYPE to string value
LPCWSTR CVssMetadataHelper::WszFromComponentType
    (
    IN CVssFunctionTracer &ft,
    VSS_COMPONENT_TYPE ct,
	bool bValue
    ) throw(HRESULT)
    {
    switch(ct)
        {
        default:
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Invalid component type");

        case VSS_CT_DATABASE:
            return (bValue ? x_wszValueDatabase : x_wszElementDatabase);

        case VSS_CT_FILEGROUP:
            return(bValue ? x_wszValueDatabase : x_wszElementFilegroup);
        }
    }

// convert from string value to VSS_COMPONENT_TYPE
VSS_COMPONENT_TYPE CVssMetadataHelper::ConvertToComponentType
    (
    IN CVssFunctionTracer &ft,
    IN BSTR bstrName,
	bool bValue
    )
    {
	LPCWSTR wszDatabase = bValue ? x_wszValueDatabase : x_wszElementDatabase;
	LPCWSTR wszFilegroup = bValue ? x_wszValueFilegroup : x_wszElementFilegroup;
    if (wcscmp(bstrName, wszDatabase) == 0)
        return VSS_CT_DATABASE;
    else if (wcscmp(bstrName, wszFilegroup) == 0)
        return VSS_CT_FILEGROUP;
    else
        ft.Throw
            (
            VSSDBG_XML,
            E_INVALIDARG,
            L"The string %s is not a valid component type",
            bstrName
            );

    return VSS_CT_UNDEFINED;
    }


// convert from restore method to string
LPCWSTR CVssMetadataHelper::WszFromRestoreMethod
    (
    IN CVssFunctionTracer &ft,
    IN VSS_RESTOREMETHOD_ENUM method
    )
    {
    switch(method)
        {
        default:
            ft.Throw
                (
                VSSDBG_XML,
                E_INVALIDARG,
                L"Invalid method type %d",
                method
                );

        case VSS_RME_RESTORE_IF_NOT_THERE:
			return (x_wszRESTOREIFNOTTHERE);

		case VSS_RME_RESTORE_IF_CAN_REPLACE:
            return(x_wszRESTOREIFCANREPLACE);

		case VSS_RME_STOP_RESTORE_START:
            return(x_wszSTOPRESTORESTART);

        case VSS_RME_RESTORE_TO_ALTERNATE_LOCATION:
			return(x_wszRESTORETOALTERNATE);

		case VSS_RME_RESTORE_AT_REBOOT:
            return(x_wszRESTOREATREBOOT);

		case VSS_RME_CUSTOM:
            return(x_wszCUSTOM);
        }
    }


// convert from string to VSS_RESTOREMETHOD_ENUM
VSS_RESTOREMETHOD_ENUM CVssMetadataHelper::ConvertToRestoreMethod
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstr
	)
	{
	if (wcscmp(bstr, x_wszRESTOREIFNOTTHERE) == 0)
		return(VSS_RME_RESTORE_IF_NOT_THERE);
	else if (wcscmp(bstr, x_wszRESTOREIFCANREPLACE) == 0)
		return(VSS_RME_RESTORE_IF_CAN_REPLACE);
	else if (wcscmp(bstr, x_wszSTOPRESTORESTART) == 0)
		return(VSS_RME_STOP_RESTORE_START);
	else if (wcscmp(bstr, x_wszRESTORETOALTERNATE) == 0)
		return(VSS_RME_RESTORE_TO_ALTERNATE_LOCATION);
	else if (wcscmp(bstr, x_wszRESTOREATREBOOT) == 0)
		return(VSS_RME_RESTORE_AT_REBOOT);
	else if (wcscmp(bstr, x_wszCUSTOM) == 0)
		return(VSS_RME_CUSTOM);
	else
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"The string %s is not a valid restore method.",
			bstr
			);

    return VSS_RME_UNDEFINED;
	}

// convert from restore method to string
LPCWSTR CVssMetadataHelper::WszFromWriterRestore
    (
    IN CVssFunctionTracer &ft,
    IN VSS_WRITERRESTORE_ENUM method
    )
    {
    switch(method)
        {
        default:
            ft.Throw
                (
                VSSDBG_XML,
                E_INVALIDARG,
                L"Invalid writerRestore type %d",
                method
                );

        case VSS_WRE_NEVER:
			return x_wszNever;

		case VSS_WRE_IF_REPLACE_FAILS:
            return x_wszIfReplaceFails;

		case VSS_WRE_ALWAYS:
            return x_wszAlways;
        }
    }


// convert from string to VSS_RESTOREMETHOD_ENUM
VSS_WRITERRESTORE_ENUM CVssMetadataHelper::ConvertToWriterRestore
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstr
	)
	{
	if (wcscmp(bstr, x_wszNever) == 0)
		return VSS_WRE_NEVER;
	else if (wcscmp(bstr, x_wszIfReplaceFails) == 0)
		return VSS_WRE_IF_REPLACE_FAILS;
	else if (wcscmp(bstr, x_wszAlways) == 0)
		return VSS_WRE_ALWAYS;
	else
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"The string %s is not a valid restore method.",
			bstr
			);

    return VSS_WRE_UNDEFINED;
	}


// convert VSS_BACKUP_TYPE to string
LPCWSTR CVssMetadataHelper::WszFromBackupType
	(
	IN CVssFunctionTracer &ft,
	IN VSS_BACKUP_TYPE bt
	)
	{
	switch(bt)
		{
        default:
            ft.Throw
                (
                VSSDBG_XML,
                E_INVALIDARG,
                L"Invalid backupType %d",
                bt
                );

        case VSS_BT_INCREMENTAL:
			return x_wszValueIncremental;

		case VSS_BT_DIFFERENTIAL:
            return x_wszValueDifferential;

		case VSS_BT_FULL:
            return x_wszValueFull;

        case VSS_BT_OTHER:
			return x_wszValueOther;
        }
	}

// convert from string to backup type
VSS_BACKUP_TYPE CVssMetadataHelper::ConvertToBackupType
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstr
	)
	{
	if (wcscmp(bstr, x_wszValueIncremental) == 0)
		return VSS_BT_INCREMENTAL;
	else if (wcscmp(bstr, x_wszValueDifferential) == 0)
		return VSS_BT_DIFFERENTIAL;
	else if (wcscmp(bstr, x_wszValueFull) == 0)
		return VSS_BT_FULL;
	else if (wcscmp(bstr, x_wszValueOther) == 0)
		return VSS_BT_OTHER;
	else
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"The string %s is not a valid backup type.",
			bstr
			);

    return VSS_BT_UNDEFINED;
    }



// obtain the value of a string valued attribute.  Returns S_FALSE if
// attribute doesn't exist
HRESULT CVssMetadataHelper::GetStringAttributeValue
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszAttrName,
	IN bool bRequired,
	OUT BSTR *pbstrValue
	)
	{
	try
		{
		// check output parameter
		if (pbstrValue == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output pointer");

		// null output parameter
		*pbstrValue = NULL;

		// find attribute value
		if (m_doc.FindAttribute(wszAttrName, pbstrValue))
			return S_OK;
		else
			{
			if (bRequired)
				MissingAttribute(ft, wszAttrName);
			else
				return S_FALSE;
			}
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// obtain the value of a boolean ("yes", "no") attribute.  Return S_FALSE if
// attribute is not assigned a value.
HRESULT CVssMetadataHelper::GetBooleanAttributeValue
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszAttrName,
	IN bool bRequired,
	OUT bool *pbValue
	)
	{
	try
		{
		// check output parameter
		if (pbValue == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output pointer");

		// initialize output paramter
		*pbValue = false;

		CComBSTR bstrVal = NULL;
		// obtain string value of attribute
		if (!m_doc.FindAttribute(wszAttrName, &bstrVal))
			{
			if (bRequired)
				MissingAttribute(ft, wszAttrName);
			else
				return S_FALSE;
			}

		// convert attribute to a boolean value
        *pbValue = ConvertToBoolean(ft, bstrVal);
		return S_OK;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

bool CVssMetadataHelper::get_stringValue
	(
	IN LPCWSTR wszAttrName,
	OUT BSTR *pbstrValue
	)
	{
	// iniitialize value to null
	*pbstrValue = NULL;

	// obtain string value if exists
	return m_doc.FindAttribute(wszAttrName, pbstrValue);
	}

void CVssMetadataHelper::get_VSS_IDValue
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszAttrName,
	OUT VSS_ID *pidValue
	) throw(HRESULT)
	{
	// initialize id value to GUID_NULL
	*pidValue = GUID_NULL;

	CComBSTR bstrVal = NULL;

	// obtain string value if it exists and convert it to GUID
	if (m_doc.FindAttribute(wszAttrName, &bstrVal))
		ConvertToVSS_ID(ft, bstrVal, pidValue);
	else
		MissingAttribute(ft, wszAttrName);
	}


bool CVssMetadataHelper::get_boolValue
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszAttrName,
	OUT bool *pb
	)
	{
	// initialize boolean value
	*pb = FALSE;

	CComBSTR bstrVal = NULL;

	// find attribute if it exists and convert its value to a boolean
	if (!m_doc.FindAttribute( wszAttrName, &bstrVal))
		return false;

	*pb = ConvertToBoolean(ft, bstrVal);
	return true;
	}

void CVssMetadataHelper::MissingElement
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszElement
	)
	{
	ft.LogError(VSS_ERROR_CORRUPTXMLDOCUMENT_MISSING_ELEMENT, VSSDBG_XML << wszElement);
	ft.Throw
		(
		VSSDBG_XML,
		VSS_E_CORRUPT_XML_DOCUMENT,
		L"The %s element is missing.",
		wszElement
		);
    }

void CVssMetadataHelper::MissingAttribute
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszAttribute
	)
	{
	ft.LogError(VSS_ERROR_CORRUPTXMLDOCUMENT_MISSING_ATTRIBUTE, VSSDBG_XML << wszAttribute);
	ft.Throw
		(
		VSSDBG_XML,
		VSS_E_CORRUPT_XML_DOCUMENT,
		L"The %s attribute is missing.",
		wszAttribute
		);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\backupext\vsxml\vs_cmxml.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vs_cmxml.cxx

Abstract:

    Implementation of Backup Components Metadata XML wrapper classes

	Brian Berkowitz  [brianb]  3/13/2000

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    brianb		03/16/2000  Created
    brianb		03/22/2000  Added support for PrepareForBackup and BackupComplete
    brianb		04/04/2000  Added security checks for backup operator
    brianb		04/06/2000  Comment pass, remove callbacks from writer
    brianb		04/10/2000  add async support
    mikejohn	04/11/2000  Fix some loop iteration problems
	brianb  	04/21/2000  retool for passing WRITER_COMPONENTS as strings
	brianb		04/25/2000  added critical section support
	brianb		05/03/2000	new security model
	brianb		05/05/2000  fix bug in CVssWriterComponents::GetComponent
    brianb      05/16/2000  code review comments, remove Cancel stuff
	brianb		05/19/2000  code review comments

--*/

#include "stdafx.hxx"
#include "vs_inc.hxx"
#include "vs_sec.hxx"

#include "vs_idl.hxx"

#include "vswriter.h"
#include "vsbackup.h"
#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"

#include "cmxml.c"
#include "worker.hxx"
#include "async.hxx"
#include "vssmsg.h"
#include "vs_filter.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "BUECXMLC"
//
////////////////////////////////////////////////////////////////////////


// schema information
static LPCWSTR x_wszVersionNo = L"1.0";

// element strings
static LPCWSTR x_wszElementBackupComponents = L"BACKUP_COMPONENTS";
static LPCWSTR x_wszElementWriterComponents = L"WRITER_COMPONENTS";
static LPCWSTR x_wszElementBackupMetadata = L"BACKUP_METADATA";
static LPCWSTR x_wszElementAlternateMapping = L"ALTERNATE_LOCATION_MAPPING";
static LPCWSTR x_wszElementComponent = L"COMPONENT";
static LPCWSTR x_wszElementRoot = L"root";

// attribute strings
static LPCWSTR x_wszAttrVersion = L"version";
static LPCWSTR x_wszAttrXmlns = L"xmlns";
static LPCWSTR x_wszAttrBootableSystemStateBackup = L"bootableSystemStateBackup";
static LPCWSTR x_wszAttrWriterId = L"writerId";
static LPCWSTR x_wszAttrInstanceId = L"instanceId";
static LPCWSTR x_wszAttrComponentType = L"componentType";
static LPCWSTR x_wszAttrLogicalPath = L"logicalPath";
static LPCWSTR x_wszAttrComponentName = L"componentName";
static LPCWSTR x_wszAttrBackupSucceeded = L"backupSucceeded";
static LPCWSTR x_wszAttrPath = L"path";
static LPCWSTR x_wszAttrFilespec = L"filespec";
static LPCWSTR x_wszAttrRecursive = L"recursive";
static LPCWSTR x_wszAttrAlternatePath = L"alternatePath";
static LPCWSTR x_wszAttrMetadata = L"metadata";
static LPCWSTR x_wszAttrSelectComponents = L"selectComponents";
static LPCWSTR x_wszAttrBackupType = L"backupType";

// value strings
static LPCWSTR x_wszValueXmlns = L"x-schema:#VssComponentMetadata";



// return the logical path for a component
// implements IVssComponent::GetLogicalPath
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if there are no errors
//      S_FALSE if there is no logical path for the component
//		E_INVALIDARG if pbstrPath is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetLogicalPath(OUT BSTR *pbstrPath)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetLogicalPath"
		);

	// acquire lock to ensure single threaded access through DOM
    CVssSafeAutomaticLock lock(m_csDOM);

    // call internal function
    return GetStringAttributeValue(ft, x_wszAttrLogicalPath, false, pbstrPath);
	}

// return the type of a component
// implements IVssComponent::GetComponentType
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pct is NULL
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetComponentType(VSS_COMPONENT_TYPE *pct)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetComponentType"
		);

	try
		{
		// validate output argument
		if (pct == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output argument
		*pct = VSS_CT_UNDEFINED;
		CComBSTR bstrComponentType;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		// get component type as a string
		if (!get_stringValue(x_wszAttrComponentType, &bstrComponentType))
			MissingAttribute(ft, x_wszAttrComponentType);

		// convert it to VSS_COMPONENT_TYPE value
		*pct = ConvertToComponentType(ft, bstrComponentType, true);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// obtain the componentName attribute
// implements IVssComponent::GetComponentName
// caller responsible for calling SysFreeString on the output parameter
//
// Returns:
//    S_OK if the operation is successful
//    E_INVALIDARG if pbstrName == NULL
//	  VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//    E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetComponentName(OUT BSTR *pbstrName)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetComponentName"
		);

	// acquire lock to ensure single threaded access through DOM
    CVssSafeAutomaticLock lock(m_csDOM);

    // call internal implementation
    return GetStringAttributeValue(ft, x_wszAttrComponentName, true, pbstrName);
	}


// obtain the backupSucceeded attribute
// implements IVssComponent::GetBackupSucceeded
//
// Returns:
//		S_OK if the operation is successful
//		S_FALSE if the value of the attribute is not defined.
//		E_INVALIDARG if pbSucceeded == NULL
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetBackupSucceeded(OUT bool *pbSucceeded)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetBackupSucceeded"
		);

	// acquire lock to ensure single threaded access through DOM
    CVssSafeAutomaticLock lock(m_csDOM);

    // call internal implementation
    return GetBooleanAttributeValue(ft, x_wszAttrBackupSucceeded, false, pbSucceeded);
	}


// obtain the count of ALTERNATE_LOCATION_MAPPING elements
// implements IVssComponent::GetAlternateLocationMappingCount
//
// Returns
//		S_OK if the operation is successful
//		E_INVALIDARG if pcMappings is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetAlternateLocationMappingCount
	(
	OUT UINT *pcMappings
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetAlternateLocationMappingCount"
		);

    try
		{
		// validate output parameter
		if (pcMappings == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

		// initialize output parameter
		*pcMappings = 0;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		// reposition to top of document
		m_doc.ResetToDocument();

		// find first ALTERNATE_LOCATION_MAPPING element
		if (!m_doc.FindElement(x_wszElementAlternateMapping, TRUE))
			return S_OK;

        UINT cMappings = 0;
		// count elements
		do
			{
			cMappings++;
			} while(m_doc.FindElement(x_wszElementAlternateMapping, FALSE));

        // set return value
        *pcMappings = cMappings;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// obtain a specific ALTERNATE_LOCATION_MAPPING element
// implements IVssComponent::GetAlterateLocationMapping
// caller is responsible for calling IVssWMFiledesc::Release on the ouptut parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL
//		VSS_E_OBJECT_NOT_FOUND if the specific alternative location
//			mapping doesn't exist
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetAlternateLocationMapping
	(
	IN UINT iMapping,					// which mapping to select
	OUT IVssWMFiledesc **ppFiledesc		// output file descriptor
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetAlternativeLocationMapping"
		);

    CVssWMFiledesc *pFiledesc = NULL;
    try
		{
		// validate output parameter
		if (ppFiledesc == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output pointer");

		// initailize output parameter
		*ppFiledesc = NULL;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		// reposition to top of COMPONENT document
		m_doc.ResetToDocument();

		// find first ALTERNATE_LOCATION_MAPPING element
		if (!m_doc.FindElement(x_wszElementAlternateMapping, TRUE))
			ft.Throw(VSSDBG_XML, VSS_E_OBJECT_NOT_FOUND, L"Cannot find ALTERNATE_LOCATION_MAPPING");

		// skip to selected element
		for(UINT i = 0; i < iMapping; i++)
			{
			if (!m_doc.FindElement(x_wszElementAlternateMapping, FALSE))
				ft.Throw(VSSDBG_XML, VSS_E_OBJECT_NOT_FOUND, L"Cannot find ALTERNATE_LOCATION_MAPPING");
			}

		// create filedesc object
		pFiledesc = new CVssWMFiledesc(m_doc.GetCurrentNode());

		// validate that allocation succeeded
		if (pFiledesc == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Couldn't create CVssWMFiledesc due to allocation failure."
				);


		// 2nd phase of initialization
		pFiledesc->Initialize(ft);

		// transfer ownership of pointer
		*ppFiledesc = (IVssWMFiledesc *) pFiledesc;

		((IVssWMFiledesc *) pFiledesc)->AddRef();
		pFiledesc = NULL;
		}
	VSS_STANDARD_CATCH(ft)

	delete pFiledesc;

    return ft.hr;
	}


// set BACKUP_METADATA element within the component
// implements IVssComponent::SetBackupMetadata
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if this operation is called outside of
//			the context of OnPrepareBackup
//		E_INVALIDARG if wszData is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::SetBackupMetadata(IN LPCWSTR wszData)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::SetBackupMetadata"
		);

    try
		{
		if (wszData == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Required input paramter is NULL.");

		if (m_pWriterComponents == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Components document is not writeable"
				);

		// acquire lock to ensure single threaded access through DOM
        CVssSafeAutomaticLock lock(m_csDOM);

		m_doc.ResetToDocument();
		if (m_doc.FindElement(x_wszElementBackupMetadata, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_ALREADY_EXISTS,
				L"BackupMetadata already exists on the component"
				);

		// create BACKUP_METADATA node as child of COMPONENT node
		CXMLNode node = m_doc.CreateNode
			(
			x_wszElementBackupMetadata,
			NODE_ELEMENT
			);

        // set metadata attribute
        node.SetAttribute(x_wszAttrMetadata, wszData);
		m_pWriterComponents->SetChanged();

		// insert BACKUP_METADATA node under component node
		m_doc.InsertNode(node);
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}


// obtain value of BACKUP_METADATA element
// implements IVssComponent::GetBackupMetadata
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		S_FALSE if there is no backup metadata associated with the component
//		E_INVALIDARG if pbstrData is NULL
//		VSS_E_CORRUPTXMLDOCUMENT if the document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs
//
STDMETHODIMP CVssComponent::GetBackupMetadata
	(
	OUT BSTR *pbstrData
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetBackupMetadata"
		);

    try
		{
		// validate output parameters
		if (pbstrData == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameters
		*pbstrData = NULL;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		// reposition to top of COMPONENT document
		m_doc.ResetToDocument();

		// find BACKUP_METADATA element
		if (!m_doc.FindElement(x_wszElementBackupMetadata, TRUE))
			return S_FALSE;

		CComBSTR bstr;

		// extract string value
		if (!get_stringValue(x_wszAttrMetadata, &bstr))
			MissingAttribute(ft, x_wszAttrMetadata);

        *pbstrData = bstr.Detach();
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}



// IUnknown::QueryInterface method
// this method should never be callsed
STDMETHODIMP CVssComponent::QueryInterface(REFIID, void **)
	{
	return E_NOTIMPL;
	}

// IUnknown::AddRef method
STDMETHODIMP_(ULONG) CVssComponent::AddRef()
	{
	LONG cRef = InterlockedIncrement(&m_cRef);

	return (ULONG) cRef;
	}

// IUnknown::Release method
STDMETHODIMP_(ULONG) CVssComponent::Release()
	{
	LONG cRef = InterlockedDecrement(&m_cRef);
	BS_ASSERT(cRef >= 0);
	if (cRef == 0)
		{
		// reference count is 0, delete the object
		delete this;
		return 0;
		}
	else
		return (ULONG) cRef;
	}

// initilize document to make toplevel node WRITER_COMPONENTS node
// implements IVssWriterComponentsExt::Initialize
// fFindToplevel is called with FALSE if m_doc is already pointing at the
// WRITER_COMPONENTS element as in CVssBackupComponents::GetWriterComponents
// It is called with true if the writer components is buried a child of
// the root document as is the case when a Writer gets the WRITER_COMPONENTS
// node from the document returned by IVssWriterCallback::GetContent.
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWriterComponents::Initialize(bool fFindToplevel)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssWriterComponents::Initialize");

	try
		{
		InitializeHelper(ft);

		if (fFindToplevel)
			{
			if (!m_doc.FindElement(x_wszElementWriterComponents, true))
				MissingElement(ft, x_wszElementWriterComponents);

			m_doc.SetToplevel();
			}
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// get information about the writer of a compnent
// implements IVssWriterComponents::GetWriterInfo
// NOTE: pidInstance may be NULL (i.e., is optional)
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if either parameters is NULL
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWriterComponents::GetWriterInfo
	(
	OUT VSS_ID *pidInstance,
	OUT VSS_ID *pidWriter
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWriterComponents::GetWriterInfo"
		);

    try
		{
		VssZeroOut(pidInstance);

		// validate output parameters
		if (pidWriter == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameters
		*pidWriter = GUID_NULL;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		// reposition to top of WRITER_COMPONENTS document
		m_doc.ResetToDocument();
		if (pidInstance)
			// get instanceId attribute value
			get_VSS_IDValue(ft, x_wszAttrInstanceId, pidInstance);

        // get writerId attribute value
		get_VSS_IDValue(ft, x_wszAttrWriterId, pidWriter);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// get count of components associated with the writer
// implements IVssWriterComponents::GetComponentCount
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pcComponents is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWriterComponents::GetComponentCount(OUT UINT *pcComponents)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWriterComponents::GetComponentCount"
		);

    try
		{
		// validate output parameter
		if (pcComponents == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameter
		*pcComponents = 0;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		m_doc.ResetToDocument();

		// find first COMPONENT element
		if (!m_doc.FindElement(x_wszElementComponent, TRUE))
			return S_OK;

        UINT cComponents = 0;
        // count COMPONENT elements
		do
			{
			// increment component count
			cComponents++;
			} while(m_doc.FindElement(x_wszElementComponent, FALSE));

        *pcComponents = cComponents;
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}

// obtain a specific component
// implements IVssWriterComponents::GetComponent
// caller is responsible for calling IVssComponent::Release on the output parameter
//
// Returns:
//		S_OK if the operation is sucessful
//		E_INVALIDARG if ppComponent is NULL
//		VSS_E_OBJECT_NOT_FOUND if iComponent does not refer to a valid component
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWriterComponents::GetComponent
	(
	IN UINT iComponent,					// specify component to select
	OUT IVssComponent **ppComponent
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWriterComponents::GetComponent"
		);

    CVssComponent *pComponent = NULL;
    try
		{
		// validate output parameter
		if (ppComponent == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output paramter
		*ppComponent = NULL;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		// reset to top of document
		m_doc.ResetToDocument();

		// find first COMPONENT element
		if (!m_doc.FindElement(x_wszElementComponent, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"Cannot find %d COMPONENT.",
				iComponent
				);


        // skip to selected component
		for(UINT i = 0; i < iComponent; i++)
			{
			if (!m_doc.FindElement(x_wszElementComponent, FALSE))
				ft.Throw
					(
					VSSDBG_XML,
					VSS_E_OBJECT_NOT_FOUND,
					L"Cannot find %d COMPONENT.",
					iComponent
					);
			}

        // return the element as a CVssComponent object
		pComponent = new CVssComponent
						(
						m_doc.GetCurrentNode(),
						m_doc.GetInterface(),
						m_bWriteable ? this : NULL
						);

		// check for memory allocation failure
		if (pComponent == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Cannot create CVssComponent due to allocation failure"
				);

		// 2nd phase of initialization
		pComponent->Initialize(ft);

		// transfer ownership of pointer
		*ppComponent = (IVssComponent *) pComponent;
		((IVssComponent *) pComponent)->AddRef();
		pComponent = NULL;
		}
	VSS_STANDARD_CATCH(ft)

	delete pComponent;

    return ft.hr;
	}

// return whether any child component was modified
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbChanged is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWriterComponents::IsChanged(OUT bool *pbChanged)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssWriterComponents::IsChanged");

	try
		{
		if (pbChanged == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		BS_ASSERT(!m_bChanged || m_bWriteable);
		*pbChanged = m_bChanged;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// save components as XML
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbstrXML is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWriterComponents::SaveAsXML(OUT BSTR *pbstrXML)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssWriterComponents::SaveAsXML");

	try
		{
		// validate output parameter
		if (pbstrXML == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameter
		*pbstrXML = NULL;

		CVssSafeAutomaticLock lock(m_csDOM);
		*pbstrXML = m_doc.SaveAsXML();
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// implements IUnknown::AddRef
STDMETHODIMP_(ULONG) CVssWriterComponents::AddRef()
	{
	LONG cRef = InterlockedIncrement(&m_cRef);

	return (ULONG) cRef;
	}

// implements IUnknown::Release
STDMETHODIMP_(ULONG) CVssWriterComponents::Release()
	{
	LONG cRef = InterlockedDecrement(&m_cRef);
	BS_ASSERT(cRef >= 0);

	if (cRef == 0)
		{
		// reference count is 0, delete the object
		delete this;
		return 0;
		}
	else
		return (ULONG) cRef;
	}


// get information about the writer of a compnent
// implements IVssWriterComponents::GetWriterInfo
// NOTE: pidInstance may be NULL (i.e., is optional)
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if either parameters is NULL
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssNULLWriterComponents::GetWriterInfo
	(
	OUT VSS_ID *pidInstance,
	OUT VSS_ID *pidWriter
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssNULLWriterComponents::GetWriterInfo"
		);

    try
		{
		VssZeroOut(pidInstance);

		// validate output parameters
		if (pidWriter == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameters
		*pidWriter = m_idWriter;
		*pidInstance = m_idInstance;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// get count of components associated with the writer
// implements IVssWriterComponents::GetComponentCount
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pcComponents is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssNULLWriterComponents::GetComponentCount
	(
	OUT UINT *pcComponents
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssNULLWriterComponents::GetComponentCount"
		);

    try
		{
		// validate output parameter
		if (pcComponents == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameter
		*pcComponents = 0;
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}

// obtain a specific component
// implements IVssWriterComponents::GetComponent
// caller is responsible for calling IVssComponent::Release on the output parameter
//
// Returns:
//		S_OK if the operation is sucessful
//		E_INVALIDARG if ppComponent is NULL
//		VSS_E_OBJECT_NOT_FOUND if no other error is returned

STDMETHODIMP CVssNULLWriterComponents::GetComponent
	(
	IN UINT iComponent,					// specify component to select
	OUT IVssComponent **ppComponent
	)
	{
	UNREFERENCED_PARAMETER(iComponent);
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssNULLWriterComponents::GetComponent"
		);

    try
		{
		// validate output parameter
		if (ppComponent == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output paramter
		*ppComponent = NULL;

		ft.hr = VSS_E_OBJECT_NOT_FOUND;
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}

// return whether any child component was modified
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbChanged is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssNULLWriterComponents::IsChanged(OUT bool *pbChanged)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssNULLWriterComponents::IsChanged");

	try
		{
		if (pbChanged == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		*pbChanged = false;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// save components as XML
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbstrXML is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssNULLWriterComponents::SaveAsXML(OUT BSTR *pbstrXML)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssNULLWriterComponents::SaveAsXML");

	try
		{
		// validate output parameter
		if (pbstrXML == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameter
		*pbstrXML = NULL;

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// implements IUnknown::AddRef
STDMETHODIMP_(ULONG) CVssNULLWriterComponents::AddRef()
	{
	LONG cRef = InterlockedIncrement(&m_cRef);

	return (ULONG) cRef;
	}

// implements IUnknown::Release
STDMETHODIMP_(ULONG) CVssNULLWriterComponents::Release()
	{
	LONG cRef = InterlockedDecrement(&m_cRef);
	BS_ASSERT(cRef >= 0);

	if (cRef == 0)
		{
		// reference count is 0, delete the object
		delete this;
		return 0;
		}
	else
		return (ULONG) cRef;
	}



// constructor
CVssBackupComponents::CVssBackupComponents() :
	m_state(x_StateUndefined),
	m_cWriters(0),
	m_pDataFirst(NULL),
	m_rgWriterProp(NULL),
	m_bInitialized(false),
	m_bGatherWriterStatusComplete(false),
	m_bGatherWriterMetadataComplete(false),
	m_bSetBackupStateCalled(false),
	m_timestampOperation(0)
	{
	}

// destructor
CVssBackupComponents::~CVssBackupComponents()
	{
	if (m_bInitialized)
		{
		// abort backup in case caller failed to do so
		AbortBackup();

		// free any metadata that is hanging around
		FreeAllWriters();

		// free status associated with writers
		FreeWriterStatus();
		}
	}

// basic initialization
void CVssBackupComponents::BasicInit
	(
	IN CVssFunctionTracer &ft
	)
	{
	// note that there is a potenential race condition if someone tries
	// calling InitializeForBackup and/or InitializeForRestore from
	// multiple threads, but this is not a valid way to use this class and
	// the likelihood of this happening and not being caught is really
	// very slim.
	if (m_state != x_StateUndefined &&
		m_state != x_StateAborted)
		ft.Throw
			(
			VSSDBG_XML,
			VSS_E_BAD_STATE,
			L"CVssBackupComponents already initialized"
			);

    m_state = x_StateUndefined;

	m_bstrSnapshotSetId = GUID_NULL;
	if (m_bstrSnapshotSetId.Length() == 0)
		ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Failed to allocate BSTR.");

	m_csWriters.Init();
	m_csState.Init();

	// initialize XML document helper
	InitializeHelper(ft);
	}

// validate that object has been initialized
void CVssBackupComponents::ValidateInitialized(CVssFunctionTracer &ft)
	{
	if (!m_bInitialized)
		ft.Throw
			(
			VSSDBG_XML,
		    VSS_E_BAD_STATE,
			L"Initialization function was not called"
			);
    }



// initialize BACKUP_COMPONENTS document
// implements IVssBackupComponents::Initialize
// Returns:
//		S_OK if the operation is succesfsful
//		VSS_E_CORRUPTXMLDOCUMENT if the initial XML document is corrupt
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::InitializeForBackup(IN BSTR bstrXML)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::InitializeForBackup"
		);

	try
		{
		if (!IsProcessBackupOperator())
			ft.Throw(VSSDBG_XML, E_ACCESSDENIED, L"Access denied");

		BasicInit(ft);

		// protect state variable throughout this function
		CVssSafeAutomaticLock lock(m_csState);

		BS_ASSERT(m_state == x_StateUndefined);

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lockDOM(m_csDOM);

		// intialize document with <root><schema></root>
		m_doc.LoadFromXML(g_ComponentMetadataXML);

		// find toplevel <root> element
		if (!m_doc.FindElement(x_wszElementRoot, true))
			MissingElement(ft, x_wszElementRoot);

		// create BACKUP_COMPONENTS element under <root> element
		CXMLNode nodeRoot(m_doc.GetCurrentNode(), m_doc.GetInterface());

		// save root node.  It is modified in PrepareForBackup
		m_pNodeRoot = m_doc.GetCurrentNode();

		CXMLNode nodeBackup = m_doc.CreateNode	
				(
				x_wszElementBackupComponents,
				NODE_ELEMENT
				);

        // set schema and version attributes
		nodeBackup.SetAttribute(x_wszAttrXmlns, x_wszValueXmlns);
		nodeBackup.SetAttribute(x_wszAttrVersion, x_wszVersionNo);
		CXMLNode nodeToplevel = nodeRoot.InsertNode(nodeBackup);
		m_doc.SetToplevelNode(nodeToplevel);

		// indicate that CVssBackupComponents object is initialized
		m_state = x_StateInitialized;
		m_bRestore = false;
		m_bInitialized = true;
        }
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	UNREFERENCED_PARAMETER(bstrXML);
	}

// initialize BACKUP_COMPONENTS document
// implements IVssBackupComponents::SetBackupState
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::SetBackupState
	(
	IN bool bSelectComponents,			// does backup allow selective backup of components
	IN bool bBootableSystemStateBackup,	// is bootable system state being backed up
	IN VSS_BACKUP_TYPE backupType,		// backup type
	IN bool bPartialFileSupport			// partial file support
	)
	{
	UNREFERENCED_PARAMETER(bPartialFileSupport);

	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBacupComponents::SetBackupState"
		);

	try
		{
		LPCWSTR wszBackupType = WszFromBackupType(ft, backupType);

		// validate that initialization has been perfromed
		ValidateInitialized(ft);

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		m_doc.ResetToDocument();
		CXMLNode nodeBackup(m_doc.GetCurrentNode(), m_doc.GetInterface());

		// set bootableSystemStateBackup flag
		nodeBackup.SetAttribute
			(
			x_wszAttrBootableSystemStateBackup,
			WszFromBoolean(bBootableSystemStateBackup)
			);

		// set indication of whether backup is selecting drives or
		// components
		nodeBackup.SetAttribute
			(
			x_wszAttrSelectComponents,
			WszFromBoolean(bSelectComponents)
			);

		// set backup type
		nodeBackup.SetAttribute(x_wszAttrBackupType, wszBackupType);
		m_bSetBackupStateCalled = true;
        }
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}


// initialize BACKUP_COMPONENTS document
// implements IVssBackupComponents::Initialize
//
// Returns:
//		S_OK if the operation is successful
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::InitializeForRestore
	(
	IN BSTR bstrXML		 // components document
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBacupComponents::Initialize"
		);

    BSTR bstr = NULL;

	try
		{
		if (!IsProcessRestoreOperator())
			ft.Throw(VSSDBG_XML, E_ACCESSDENIED, L"Access denied");

		BasicInit(ft);

		// protect m_state member variable throughout this function
		CVssSafeAutomaticLock lock(m_csState);

		// state should indicate we are not initialized
		BS_ASSERT(m_state == x_StateUndefined);

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lockDOM(m_csDOM);

        		// compute length of constructed document consisting of
		// a root node, schema, and supplied document
		UINT cwcDoc = (UINT) g_cwcComponentMetadataXML + (UINT) wcslen(bstrXML);

        // allocate string
        bstr = SysAllocStringLen(NULL, cwcDoc);

		// check for allocation failure
		if (bstr == NULL)
			ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Couldn't allocate BSTR");

		// setup pointer to beginning of string
		WCHAR *pwc = bstr;

		// copy in <root> <schema>
	    memcpy(pwc, g_ComponentMetadataXML, g_iwcComponentMetadataXMLEnd * sizeof(WCHAR));
		pwc += g_iwcComponentMetadataXMLEnd;

		// copy in document
		wcscpy(pwc, bstrXML);
		pwc += wcslen(bstrXML);

		// copy in </root>
		wcscpy(pwc, g_ComponentMetadataXML + g_iwcComponentMetadataXMLEnd);

		// intialize document with <root><schema></root>
		if (!m_doc.LoadFromXML(bstr))
			{
			// reinitialize document
			m_doc.Initialize();
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_INVALID_XML_DOCUMENT,
				L"Load of Backup components document failed"
				);
            }

		// find toplevel <root> element
		if (!m_doc.FindElement(x_wszElementRoot, true))
			MissingElement(ft, x_wszElementRoot);

         // find BACKUP_COMPONENTS element
		if (!m_doc.FindElement(x_wszElementBackupComponents, true))
			MissingElement(ft, x_wszElementBackupComponents);

        // set BACKUP_COMPONENTS as toplevel element
        m_doc.SetToplevel();

		// indicate that CVssBackupComponents object is initialized
		m_state = x_StateInitialized;
		m_bRestore = true;
		m_bInitialized = true;
        }
	VSS_STANDARD_CATCH(ft)

	SysFreeString(bstr);

    return ft.hr;
	}


// add a specific component to the document
// implements IVssBackupComponents::AddComponent
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		VSS_E_OBJECT_ALREADY_EXISTS if a component with the same type, path
//			and name already exists
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::AddComponent
	(
	IN VSS_ID instanceId,
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::AddComponent"
		);

    try
		{
		// validate input parameters
		if (wszComponentName == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

		// validate that initialization has been perfromed
		ValidateInitialized(ft);

		// validate state
		CVssSafeAutomaticLock lock(m_csState);
		if (m_state != x_StateInitialized &&
			m_state != x_StateSnapshotSetCreated)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"CVssBackupComponents::AddComponent called at the wrong time"
				);

		// obtain component type as string
		LPCWSTR wszComponentType = WszFromComponentType(ft, ct, true);
		CComPtr<IXMLDOMNode> pNode;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lockDOM(m_csDOM);

		// create the COMPONENT
		FindComponent
			(
			ft,
			&instanceId,
			writerId,
			wszComponentType,
			wszLogicalPath,
			wszComponentName,
            true
			);
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}

// routine to obtain flags from the a BACKUP_COMPONENTS XML document
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::GetBackupState
	(
	OUT BOOL *pbSelectComponents,			// does backup allow selection of components
	OUT BOOL *pbBootableSystemStateBackup,	// is bootable system state being backed up
	OUT VSS_BACKUP_TYPE *pBackupType,		// backup type
	OUT BOOL *pbPartialFileSupport			// partial file support
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssBackupComponents::GetBackupState");

	try
		{
		if (pbBootableSystemStateBackup)
			*pbBootableSystemStateBackup = FALSE;

		if (pBackupType)
			*pBackupType = VSS_BT_UNDEFINED;

		if (pbPartialFileSupport)
			*pbPartialFileSupport = FALSE;

		// validate output parameters
		if (pbSelectComponents == NULL ||
			pbBootableSystemStateBackup == NULL ||
			pBackupType == NULL ||
			pbPartialFileSupport == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameters
		*pbSelectComponents = FALSE;

		// validate that initialization has been perfromed
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csDOM);

		// position to top of BACKUP_COMPONENTS document
		m_doc.ResetToDocument();

		// get bootableSystemState attribute value
		bool bBootableSystemStateBackup, bSelectComponents;
		if (!get_boolValue(ft, x_wszAttrBootableSystemStateBackup, &bBootableSystemStateBackup))
			MissingAttribute(ft, x_wszAttrBootableSystemStateBackup);

		// get selectComponents attribute value
		if (!get_boolValue(ft, x_wszAttrSelectComponents, &bSelectComponents))
			MissingAttribute(ft, x_wszAttrSelectComponents);

		CComBSTR bstrBackupType;

		if (!get_stringValue(x_wszAttrBackupType, &bstrBackupType))
			MissingAttribute(ft, x_wszAttrBackupType);


		*pBackupType = ConvertToBackupType(ft, bstrBackupType);
		*pbBootableSystemStateBackup = bBootableSystemStateBackup;
		*pbSelectComponents = bSelectComponents;
		}
	VSS_STANDARD_CATCH(ft)
	return ft.hr;
	}

// internal routine to find or create a specific WRITER_COMPONENTS element
CXMLNode CVssBackupComponents::PositionOnWriterComponents
	(
	IN CVssFunctionTracer &ft,
	IN VSS_ID *pinstanceId,		// NULL indicates that it is not specified
	IN VSS_ID writerId,			// writer class id
	IN bool bCreateIfNotThere,	// create WRITER_COMPONENTS element if it isn't there
	OUT bool &bCreated			// whether component was created or not
	) throw(HRESULT)
	{
	// initialize output parameter
	bCreated = false;

	CVssSafeAutomaticLock lock(m_csDOM);

	// position to top of BACKUP_COMPONENTS document
	m_doc.ResetToDocument();

	// set parent node to be BACKUP_COMPONENTS element
	CXMLNode nodeBackupComponents(m_doc.GetCurrentNode(), m_doc.GetInterface());
	bool bFound = false;

	// look for first WRITER_COMPONENTS element
	if (m_doc.FindElement(x_wszElementWriterComponents, TRUE))
		{
		do
			{
			VSS_ID writerIdFound;
			VSS_ID instanceIdFound;
			CComBSTR bstrVal;

			// get writerId attribute
			get_VSS_IDValue(ft, x_wszAttrWriterId, &writerIdFound);

			if (pinstanceId)
				{
				get_VSS_IDValue(ft, x_wszAttrInstanceId, &instanceIdFound);

				// if instanceId doesn't match, then skip this element
				if (*pinstanceId != instanceIdFound)
					continue;
				}

			// if writerId attribute matches, then we have found the target element
			if (writerId == writerIdFound)
				{
				bFound = true;
				break;
				}
			} while (m_doc.FindElement(x_wszElementWriterComponents, FALSE));
        }

	// if element is found, then return it
	if (bFound)
		return CXMLNode(m_doc.GetCurrentNode(), m_doc.GetInterface());

	if (!bCreateIfNotThere)
		ft.Throw
			(
			VSSDBG_XML,
			VSS_E_OBJECT_NOT_FOUND,
			L"WRITER_COMPONENTS element was not found."
			);

	// create element if requested
    CXMLNode node = m_doc.CreateNode
		(
		x_wszElementWriterComponents,
		NODE_ELEMENT
		);

    // assign instanceId if supplied
    if (pinstanceId)
		node.SetAttribute(x_wszAttrInstanceId, *pinstanceId);

	// assign writerId
	node.SetAttribute(x_wszAttrWriterId, writerId);

	// insert WRITER_COMPONENTS element under BACKUP_COMPONENTS node
	CXMLNode nodeRet = nodeBackupComponents.InsertNode(node);

	// element was created
	bCreated = true;

	// return node
	return nodeRet;
	}

// internal routine to return/create a specific COMPONENT
// assumes caller has already locked m_csDOM
CXMLNode CVssBackupComponents::FindComponent
	(
	IN CVssFunctionTracer &ft,
	IN VSS_ID *pinstanceId,			// NULL means instanceId is not specified(RESTORE)
	IN VSS_ID writerId,				// writer class id
	IN LPCWSTR wszComponentType,	// component type (DATABASE or FILE_GROUP)		
	IN LPCWSTR wszLogicalPath,		// logical path to component
	IN LPCWSTR wszComponentName,	// component name
	IN bool bCreate					// whether creation of element is allowed
	)
	{
	// both componentType and componentName should be specified
	BS_ASSERT(wszComponentType != NULL);
	BS_ASSERT(wszComponentName != NULL);

	// initialize state variables
	bool bFound = false;
	bool bCreated = false;

	// get WRITER_COMPONENTS node
	CXMLNode nodeWriter = PositionOnWriterComponents(ft, pinstanceId, writerId, true, bCreated);

	// find first child COMPONENT element under WRITER_COMPONENTS if
	// WRITER_COMPONENTS was found
	if (!bCreated && m_doc.FindElement(x_wszElementComponent, TRUE))
		{
		do
			{
			CComBSTR bstrComponentType;
			CComBSTR bstrLogicalPath;
			CComBSTR bstrComponentName;

			// get component type
			if (!get_stringValue(x_wszAttrComponentType, &bstrComponentType))
				MissingAttribute(ft, x_wszAttrComponentType);

            // if componentName doesn't match, then skip component
            if (wcscmp(wszComponentType, bstrComponentType) != 0)
				continue;

			bool fLogicalPath = get_stringValue(x_wszAttrLogicalPath, &bstrLogicalPath);
			if (wszLogicalPath != NULL && wcslen(wszLogicalPath) > 0)
				{
				// logical path doesn't exist, skip component
				if (!fLogicalPath)
					continue;
				else
					{
					// if logical path doesn't match, then skip component
					if (wcscmp(bstrLogicalPath, wszLogicalPath) != 0)
						continue;
					}
				}
			else
				{
				// if logical path exists, then skip component
				if (fLogicalPath)
					continue;
				}

			// get component name
			if (!get_stringValue(x_wszAttrComponentName, &bstrComponentName))
				MissingAttribute(ft, x_wszAttrComponentName);

            // if component name matches, then we are done
            if (wcscmp(wszComponentName, bstrComponentName) == 0)
				{
				bFound = true;
				break;
				}
			} while(m_doc.FindElement(x_wszElementComponent, FALSE));
        }

	if (bFound && bCreate)
		ft.Throw
			(
			VSSDBG_XML,
			VSS_E_OBJECT_ALREADY_EXISTS,
			L"Attempt to create a duplicate component."
			);


    // return node if found
	if (bFound && !bCreate)
		return CXMLNode(m_doc.GetCurrentNode(), m_doc.GetInterface());

	// if node not found and if we cannot create the node, then return an error
	if (!bCreate)
		ft.Throw
			(
			VSSDBG_XML,
			VSS_E_OBJECT_NOT_FOUND,
			L"Component was not found. %s\\%s",
			wszLogicalPath,
			wszComponentName
			);

	// create node if requested to
	CXMLNode node = m_doc.CreateNode
			(
			x_wszElementComponent,
			NODE_ELEMENT
			);

     // assign logicalPath attribute if supplied
    if (wszLogicalPath && wcslen(wszLogicalPath) > 0)
		node.SetAttribute(x_wszAttrLogicalPath, wszLogicalPath);

	// assign componentName attribute
	node.SetAttribute(x_wszAttrComponentName, wszComponentName);

	// assign componentType attribute
	node.SetAttribute(x_wszAttrComponentType, wszComponentType);

	// insert COMPONENT node under WRITER_COMPONENTS node
	return nodeWriter.InsertNode(node);
	}

// get a callback interface
void CVssBackupComponents::GetCallbackInterface
	(
	CVssFunctionTracer &ft,
	IDispatch **ppDispatch
	)
	{
	CComPtr<IUnknown> pUnknown = GetUnknown();
	CComPtr<IDispatch> pDispatch;
	ft.hr = pUnknown->SafeQI(IDispatch, &pDispatch);
	BS_ASSERT(!ft.HrFailed());
	if (ft.HrFailed())
		{
		ft.LogError(VSS_ERROR_QI_IDISPATCH_FAILED, VSSDBG_XML << ft.hr);
		ft.Throw
			(
			VSSDBG_XML,
            E_UNEXPECTED,
			L"Error querying for the IDispatch interface.  hr = 0x%08x",
			ft.hr
			);
        }

    *ppDispatch = pDispatch.Detach();
	}

// set up IVssWriters interface
void CVssBackupComponents::SetupWriter
	(
	CVssFunctionTracer &ft,
	IVssWriter **ppWriter
	)
	{
	CComPtr<IVssWriter> pWriter;
	ft.hr = pWriter.CoCreateInstance(CLSID_VssEvent);
	ft.CheckForError(VSSDBG_XML, L"CoCreateInstance");

	BS_ASSERT(pWriter);
	SetupPublisherFilter(pWriter);
	*ppWriter = pWriter.Detach();
	}

// signal PrepareForBackup event to writers
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::PrepareForBackup
	(
	OUT IVssAsync **ppAsync
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::PrepareForBackup"
		);

	try
		{
		if (ppAsync == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		*ppAsync = NULL;

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that initialization has been perfromed
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);

		if (m_state != x_StateSnapshotSetCreated ||
			!m_bSetBackupStateCalled)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Unexpected call to PrepareForBackup in state %d.",
				m_state
				);

        *ppAsync = CVssAsyncBackup::CreateInstanceAndStartJob
			(
			this,
			CVssAsyncBackup::VSS_AS_PREPARE_FOR_BACKUP
			);
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}

// internal PrepareForBackup call called from CVssAsyncBackup class
HRESULT CVssBackupComponents::InternalPrepareForBackup()
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::InternalPrepareForBackup"
		);

	// get lock serializing state changes
	m_csState.Lock();
	UINT timestamp = ++m_timestampOperation;
	try
		{
		if (m_state != x_StateSnapshotSetCreated)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Unexpected call to PrepareForBackup in state %d.",
				m_state
				);
	
		m_state = x_StatePrepareForBackup;

		// get IVssWriter event class
		CComPtr<IVssWriter> pWriter;

		SetupWriter(ft, &pWriter);
		CComPtr<IDispatch> pDispatch;
		GetCallbackInterface(ft, &pDispatch);


		CVssFunctionTracer ft1(VSSDBG_XML, L"CVssBackupComponents::InternalPrepareForBackup1");
		ft1.hr = pWriter->PrepareForBackup(m_bstrSnapshotSetId, pDispatch);
		ft.TranslateWriterReturnCode(VSSDBG_XML, L"IVssWriter::PrepareForBackup (%s)", m_bstrSnapshotSetId);

		if (timestamp == m_timestampOperation)
			{
			RebuildComponentData(ft);
			m_state = x_StatePrepareForBackupSucceeded;
			}

		ClearPublisherFilter(pWriter);
		}
	VSS_STANDARD_CATCH(ft)

	if (timestamp == m_timestampOperation)
		{
		if (ft.HrFailed())
			m_state = x_StatePrepareForBackupFailed;

		FreeWriterComponents();
		m_timestampOperation++;
		m_csState.Unlock();
		}

	return ft.hr;
	}

// called by IVssAsync::Cancel if a PrepareBackup operation is cancelled.
void CVssBackupComponents::PostPrepareForBackup(UINT timestamp)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::PostPrepareForBackup");

	if (timestamp == m_timestampOperation)
		{
		m_state = x_StatePrepareForBackupSucceeded;
		m_timestampOperation++;
		m_csState.Unlock();
		}
	}

// rebuild component metadata from data gotten from writers during
// prepare for backup
void CVssBackupComponents::RebuildComponentData
	(
	IN CVssFunctionTracer &ft
	)
	{
	CVssSafeAutomaticLock lock(m_csDOM);

	m_doc.ResetToDocument();
	CComPtr<IXMLDOMNode> pNodeParent = m_doc.GetCurrentNode();

	CComPtr<IXMLDOMNode> pNodeCloned;

	if (!m_doc.FindElement(x_wszElementWriterComponents, TRUE))
		return;

    ft.hr = pNodeParent->cloneNode(VARIANT_TRUE, &pNodeCloned);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode:cloneNode");

	CXMLDocument docCloned(pNodeCloned, m_doc.GetInterface());

	if (!docCloned.FindElement(x_wszElementWriterComponents, TRUE))
		{
		ft.LogError(VSS_ERROR_CLONE_MISSING_CHILDREN, VSSDBG_XML);
		ft.Throw
			(
            VSSDBG_XML,
			VSS_E_CORRUPT_XML_DOCUMENT,
			L"Cloned node has no children"
			);
        }			

	do
		{
		VSS_ID idInstance;

		CComBSTR bstrVal;

		if (!docCloned.FindAttribute(x_wszAttrInstanceId, &bstrVal))
			MissingAttribute(ft, x_wszAttrInstanceId);

        CVssMetadataHelper::ConvertToVSS_ID(ft, bstrVal, &idInstance);

		for
			(
			CInternalWriterData *pData = m_pDataFirst;
			pData != NULL;
			pData = pData->m_pDataNext
			)
			{
			if (pData->m_idInstance == idInstance)
				break;
			}

		if (pData != NULL && pData->m_bstrWriterComponents)
			{
			CXMLDocument doc;
			if (!doc.LoadFromXML(pData->m_bstrWriterComponents))
				{
				ft.LogError(VSS_ERROR_INVALID_XML_DOCUMENT_FROM_WRITER, VSSDBG_XML << pData->m_idInstance);
				ft.Throw
					(
					VSSDBG_XML,
					VSS_E_CORRUPT_XML_DOCUMENT,
					L"XML data from writer is not valid:" WSTR_GUID_FMT,
					GUID_PRINTF_ARG(pData->m_idInstance)
					);
                }

            if (!doc.FindElement(x_wszElementWriterComponents, TRUE))
				MissingElement(ft, x_wszElementWriterComponents);

	        ft.hr = pNodeCloned->replaceChild
				(
				doc.GetCurrentNode(),
				docCloned.GetCurrentNode(),
				NULL
				);
            ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::replaceChild");
			docCloned.SetCurrentNode(doc.GetCurrentNode());
			}

		} while(docCloned.FindElement(x_wszElementWriterComponents, FALSE));

	ft.hr = m_pNodeRoot->replaceChild
		(
		pNodeCloned,
		pNodeParent,
		NULL
		);

    ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::replaceChild");

    CXMLNode newToplevelNode(pNodeCloned, m_doc.GetInterface());
    m_doc.SetToplevelNode(newToplevelNode);
	}


// indicate that backup was aborted
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::AbortBackup()
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::AbortBackup"
		);

    try
		{
		// validate that object has been initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);


		if (m_state == x_StatePrepareForBackup ||
			m_state == x_StatePrepareForBackupFailed ||
			m_state == x_StatePrepareForBackupSucceeded ||
			m_state == x_StateDoSnapshotFailedWithoutSendingAbort)
			{
			m_state = x_StateAborting;

			// setup pointer to writer event class
			CComPtr <IVssWriter> pWriter;
			SetupWriter(ft, &pWriter);

			CComPtr<IDispatch> pDispatch;
			GetCallbackInterface(ft, &pDispatch);
			ft.hr = pWriter->Abort(m_bstrSnapshotSetId);
			ClearPublisherFilter(pWriter);
			}

		// release coordinator if we have a pointer to cause
		// it to abort anything in progress
		if (m_pCoordinator)
			m_pCoordinator = NULL;

		m_state = x_StateAborted;
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}




// gather status of the writers
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::GatherWriterStatus
	(
	OUT IVssAsync **ppAsync
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::GatherWriterStatus"
		);

    try
		{
		if (ppAsync == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

	    *ppAsync = NULL;

		// validate that object has been initialized
		ValidateInitialized(ft);

		m_bGatherWriterStatusComplete = false;

		*ppAsync = CVssAsyncBackup::CreateInstanceAndStartJob
			(
			this,
			CVssAsyncBackup::VSS_AS_GATHER_WRITER_STATUS
			);

		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}



// gather status of the writers
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs
//		VSS_E_WRITER_INFRASTRUCTURE: either the service state or bootable
//      	state writer failed to respond
//

HRESULT CVssBackupComponents::InternalGatherWriterStatus()
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::InternalGatherWriterStatus"
		);

	VSS_BACKUPCALL_STATE stateSaved = x_StateUndefined;
    bool bLocked = false;
	UINT timestamp = 0;

    try
		{
		// validate that object has been initialized
		ValidateInitialized(ft);

		m_csState.Lock();
		bLocked = true;
		stateSaved = m_state;
		timestamp = ++m_timestampOperation;

		FreeWriterStatus();

        m_state = x_StateGatheringWriterStatus;
		m_rgWriterProp = new VSS_WRITER_PROP[m_cWriters];
		if (m_rgWriterProp == NULL)
			ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Unable to allocate writer property array");

		CInternalWriterData *pData = m_pDataFirst;

		// initialize array with writers assuming that they didn't respond
		for(UINT iWriter = 0; iWriter < m_cWriters; iWriter++)
			{
			m_rgWriterProp[iWriter].m_InstanceId = pData->m_idInstance;
			m_rgWriterProp[iWriter].m_ClassId = pData->m_idWriter;
			m_rgWriterProp[iWriter].m_pwszName = pData->m_bstrWriterName;
			m_rgWriterProp[iWriter].m_hrWriterFailure = VSS_E_WRITER_NOT_RESPONDING;
			pData = pData->m_pDataNext;
			}

		CComPtr<IVssWriter> pWriter;
		SetupWriter(ft, &pWriter);
		CComPtr<IDispatch> pDispatch;
		GetCallbackInterface(ft, &pDispatch);

		CVssFunctionTracer ft1(VSSDBG_XML, L"CVssBackupComponents::InternalGatherWriterStatus1");
		ft1.hr = pWriter->RequestWriterInfo
			(
			m_bstrSnapshotSetId,
			false,
			true,
			pDispatch
			);

        ft1.TranslateWriterReturnCode(VSSDBG_XML, L"IVssWriter::RequestWriterInfo, Request Writer Status");

		ClearPublisherFilter(pWriter);
		}
	VSS_STANDARD_CATCH(ft)

	if (bLocked && timestamp == m_timestampOperation)
		{
		// look for writers that disappeared
		for(UINT iWriter = 0; iWriter < m_cWriters; iWriter++)
			{
			if (m_rgWriterProp[iWriter].m_hrWriterFailure == VSS_E_WRITER_NOT_RESPONDING)
				{
				m_rgWriterProp[iWriter].m_hrWriterFailure = VSS_E_WRITERERROR_RETRYABLE;

				// check to see if either bootable state or service state writers
				// are missing
				if (m_rgWriterProp[iWriter].m_ClassId == idWriterBootableState ||
					m_rgWriterProp[iWriter].m_ClassId == idWriterServiceState)
					{
					// a key writer is missing meaning that the entire
					// infrastructure must be broken
					ft.hr = VSS_E_WRITER_INFRASTRUCTURE;
					ft.LogError(VSS_ERROR_WRITER_INFRASTRUCTURE, VSSDBG_XML);
					m_bGatherWriterStatusComplete = false;
					break;
					}

				// compute writer state based on where we are in the backup
				// sequence
				switch(stateSaved)
					{
					default:
						m_rgWriterProp[iWriter].m_nState = VSS_WS_FAILED_AT_FREEZE;
						break;

					case x_StatePrepareForBackupSucceeded:
					case x_StatePrepareForBackupFailed:
						m_rgWriterProp[iWriter].m_nState = VSS_WS_FAILED_AT_PREPARE_BACKUP;
						break;

					case x_StateBackupCompleteSucceeded:
					case x_StateBackupCompleteFailed:
						m_rgWriterProp[iWriter].m_nState = VSS_WS_STABLE;
						break;
					}
				try
					{
					ft.LogError(VSS_ERROR_WRITER_NOT_RESPONDING, VSSDBG_XML << m_rgWriterProp[iWriter].m_pwszName);
					}
				catch(...)
					{
					}
				}
			}

		if (ft.HrFailed())
			{
			try
				{
				delete m_rgWriterProp;
				}
			catch(...)
				{
				}

			m_rgWriterProp = NULL;
			}
		else
			m_bGatherWriterStatusComplete = true;

		m_state = stateSaved;
		m_timestampOperation++;
		m_csState.Unlock();
		}

    return ft.hr;
	}

// routine to call to complete GatherWriterStatus when
// IVssAsync::Cancel is called
void CVssBackupComponents::PostGatherWriterStatus
	(
	UINT timestamp,
	VSS_BACKUPCALL_STATE stateSaved
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::PostGatherWriterStatus");

	if (timestamp == m_timestampOperation)
		{
		m_timestampOperation++;
		m_bGatherWriterStatusComplete = true;
		m_state = stateSaved;
		m_csState.Unlock();
		}
	}
	

// get count of writers with status
//
// Returns:
//		S_OK if the operation is successful
//      E_INVALIDARG if pcWriters is NULL
//		VSS_E_BAD_STATE if GatherWriterStatusAsync was not called or is not complete
//
STDMETHODIMP CVssBackupComponents::GetWriterStatusCount
	(
	OUT UINT *pcWriters
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::GetWriterStatusCount");

	try
		{
		if (pcWriters == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output pointer.");

		*pcWriters = NULL;

		if (!m_bGatherWriterStatusComplete)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"GatherWriterStatusAsync was not called or is not complete.");

		*pcWriters = m_cWriters;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}




// get status for a particular writer
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pStatus, pidWriter, pbstrWriter, or pidInstance is NULL
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		VSS_E_OBJECT_NOT_FOUND if iWriter specifies a non-existent writer
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::GetWriterStatus
	(
	IN UINT iWriter,
	OUT VSS_ID *pidInstance,
	OUT VSS_ID *pidWriter,
	OUT BSTR *pbstrWriter,
	OUT VSS_WRITER_STATE *pStatus,
	OUT HRESULT *phrWriterFailure
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::GetWriterStatus"
		);

    try
		{
		VssZeroOut(pidInstance);
		VssZeroOut(pbstrWriter);
		if (pStatus != NULL)
			*pStatus = VSS_WS_UNKNOWN;

		if (pidInstance == NULL ||
			pidWriter == NULL ||
			pbstrWriter == NULL ||
			pStatus == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

		*pidWriter = GUID_NULL;

		// validate that object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csWriters);
		if (iWriter >= m_cWriters)
			ft.Throw(VSSDBG_XML, VSS_E_OBJECT_NOT_FOUND, L"Invalid writer selection");

		CComBSTR bstrWriter = m_rgWriterProp[iWriter].m_pwszName;
		if (!bstrWriter)
			ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Failure to allocate Writer name");

		*pidInstance = m_rgWriterProp[iWriter].m_InstanceId;
		*pidWriter = m_rgWriterProp[iWriter].m_ClassId;

		*pStatus = m_rgWriterProp[iWriter].m_nState;
		if (phrWriterFailure)
			*phrWriterFailure = m_rgWriterProp[iWriter].m_hrWriterFailure;

		*pbstrWriter = bstrWriter.Detach();
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}

// free all writer status information
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::FreeWriterStatus()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::FreeWriterStatus");

	try
		{
		// validate that object is initialized
		ValidateInitialized(ft);
		CVssSafeAutomaticLock lock(m_csWriters);
		try
			{
			delete m_rgWriterProp;
			}
		catch(...)
			{
			}

		m_rgWriterProp = NULL;
        m_bGatherWriterStatusComplete = false;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// indicate that backupSucceded on a component
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wszComponentName is NULL or if the componentType is
//			not valid
//		VSS_E_OBJECT_NOT_FOUND if the specified component doesn't exist
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::SetBackupSucceeded
	(
	IN VSS_ID instanceId,
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN bool bSucceeded
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::SetBackupSucceeded"
		);

    try
		{
		// validate input parameters
		LPCWSTR wszComponentType = WszFromComponentType(ft, ct, true);
		if (wszComponentName == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_INVALIDARG,
				L"Required input string parameter is NULL."
				);

        // validate that object initialized
        ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csDOM);

        // find the specified component
		CXMLNode node = FindComponent
							(
							ft,
							&instanceId,
							writerId,
							wszComponentType,
							wszLogicalPath,
							wszComponentName,
							false
							);

        // set backupSucceeded attribute on COMPONENT
		node.SetAttribute
			(
			x_wszAttrBackupSucceeded,
			WszFromBoolean(bSucceeded)
			);
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}


// save document as an XML string
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbstrXML is NULL.
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::SaveAsXML(BSTR *pbstrXML)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::SaveAsXML"
		);

    try
		{
		// validate output parameter
		if (pbstrXML == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameter
		*pbstrXML = NULL;

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csDOM);

		*pbstrXML = m_doc.SaveAsXML();
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}


// signal BackupComplete event to the writers
HRESULT CVssBackupComponents::InternalBackupComplete()
	{
    CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::InternalBackupComplete"
		);


	// protect state transition
	m_csState.Lock();
	UINT timestamp = ++m_timestampOperation;

    try
		{
		if (m_state != x_StateDoSnapshotSucceeded)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Invalid state %d for call to BackupComplete.",
				m_state
				);

        m_state = x_StateBackupComplete;

		// setup pointer to Writer event class
		CComPtr<IVssWriter> pWriter;
		SetupWriter(ft, &pWriter);

		CComPtr<IDispatch> pDispatch;
		GetCallbackInterface(ft, &pDispatch);
		CVssFunctionTracer ft1(VSSDBG_XML, L"IVssWriter::InternalBackupComplete1");
		ft1.hr = pWriter->BackupComplete(m_bstrSnapshotSetId, pDispatch);
		ft1.TranslateWriterReturnCode(VSSDBG_XML, L"IVssWriter::BackupComplete(%s)", m_bstrSnapshotSetId);
		if (timestamp == m_timestampOperation)
			m_state = x_StateBackupCompleteSucceeded;

		ClearPublisherFilter(pWriter);
		}
	VSS_STANDARD_CATCH(ft)

	if (timestamp == m_timestampOperation)
		{
		if (ft.HrFailed())
			m_state = x_StateBackupCompleteFailed;

		m_timestampOperation++;
		m_csState.Unlock();
		}

    return ft.hr;
	}

// routine called by IVssAsync::Cancel to cancel a backup complete operation
void CVssBackupComponents::PostBackupComplete(UINT timestamp)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::PostBackupComplete");

	if (timestamp == m_timestampOperation)
		{
		m_state = x_StateBackupCompleteSucceeded;
		m_timestampOperation++;
		m_csState.Unlock();
		}
	}

// signal BackupComplete event to the writers
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppAsync is NULL
//		VSS_E_BAD_STATE if performing a restore or if the backup
//		components document is not initialized or if the stat is not
//		x_StateDoSnapshotSucceeded
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::BackupComplete(OUT IVssAsync **ppAsync)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::BackupComplete"
		);

    try
		{
		if (ppAsync == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		*ppAsync = NULL;

		// validate that the class is initialized
		ValidateInitialized(ft);
		
		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		CVssSafeAutomaticLock lock(m_csState);

		if (m_state != x_StateDoSnapshotSucceeded)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Invalid state %d for call to BackupComplete.",
				m_state
				);

        *ppAsync = CVssAsyncBackup::CreateInstanceAndStartJob
						(
						this,
						CVssAsyncBackup::VSS_AS_BACKUP_COMPLETE
						);
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}


// add an ALTERNATE_LOCATION_MAPPING to a component on restore.
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wsComponentName, wszPath, wszFilespec, or wszDestination
//			is NULL or if componentType is invalid	
//		VSS_E_BAD_STATE if the backup components document is not
//			initialized or if a backup is being performed.
//		VSS_E_OBJECT_NOT_FOUND if the specified component doesn't exist
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::AddAlternativeLocationMapping
	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE componentType,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN LPCWSTR wszPath,
	IN LPCWSTR wszFilespec,
	IN bool bRecursive,
	IN LPCWSTR wszDestination
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::AddAlternativeLocationMapping"
		);

    try
		{
		// validate input parameters
		LPCWSTR wszComponentType = WszFromComponentType(ft, componentType, true);
		if (wszComponentName == NULL ||
			wszFilespec == NULL ||
			wszPath == NULL ||
			wszDestination == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_INVALIDARG,
				L"Required input string parameter is NULL."
				);

		CVssSafeAutomaticLock lock(m_csDOM);

        // find COMPONENT
		CXMLNode nodeComponent = FindComponent
							(
							ft,
							NULL,
							writerId,
							wszComponentType,
							wszLogicalPath,
							wszComponentName,
							false
							);

        // create ALTERNATE_LOCATION_MAPPING node
		CXMLNode node = m_doc.CreateNode
							(
							x_wszElementAlternateMapping,
							NODE_ELEMENT
							);

        // set attributes
        node.SetAttribute(x_wszAttrPath, wszPath);
		node.SetAttribute(x_wszAttrFilespec, wszFilespec);
		node.SetAttribute(x_wszAttrRecursive, WszFromBoolean(bRecursive));
		node.SetAttribute(x_wszAttrAlternatePath, wszDestination);

		// insert ALTERNATE_LOCATION_MAPPING node under COMPONENT node
		nodeComponent.InsertNode(node);
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}

// signal BackupComplete event to the writers
HRESULT CVssBackupComponents::InternalPostRestore()
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::InternalPostRestore"
		);

	// protect state transition
	m_csState.Lock();
	LONGLONG timestamp = ++m_timestampOperation;
    try
		{
		if (m_state != x_StateInitialized)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Invalid state %d for call to BackupComplete.",
				m_state
				);

        m_state = x_StateRestore;

		// setup pointer to IVssWriter event class
		CComPtr<IVssWriter> pWriter;
		SetupWriter(ft, &pWriter);

		CComPtr<IDispatch> pDispatch;

		GetCallbackInterface(ft, &pDispatch);
		CVssFunctionTracer ft1(VSSDBG_XML, L"CVssBackupComponents::InternalRestore1");

		ft1.hr = pWriter->PostRestore(pDispatch);
		ft1.TranslateWriterReturnCode(VSSDBG_XML, L"IVssWriter::PostRestore");
		if (timestamp == m_timestampOperation)
            m_state = x_StateRestoreSucceeded;

		ClearPublisherFilter(pWriter);
		}
	VSS_STANDARD_CATCH(ft)

	if (timestamp == m_timestampOperation)
		{
		if (ft.HrFailed())
			m_state = x_StateRestoreFailed;

		m_timestampOperation++;
		m_csState.Unlock();
		}

    return ft.hr;
	}

void CVssBackupComponents::PostPostRestore(UINT timestamp)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::PostPostRestore");

	if (timestamp == m_timestampOperation)
		{
		m_state = x_StateRestoreSucceeded;
		m_timestampOperation++;
		m_csState.Unlock();
		}
	}



// signal restore event to writers
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppAsync is NULL
//		VSS_E_BAD_STATE if the backup components document is not
//			initialized or if a backup is being performed.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::PostRestore(OUT IVssAsync **ppAsync)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::PostRestore"
		);

    try
		{
		if (ppAsync == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		*ppAsync = NULL;

		ValidateInitialized(ft);
		if (!m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for backup");

		CVssSafeAutomaticLock lock(m_csState);
		if (m_state != x_StateInitialized)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Invalid state %d for call to BackupComplete.",
				m_state
				);

        *ppAsync = CVssAsyncBackup::CreateInstanceAndStartJob
						(
						this,
						CVssAsyncBackup::VSS_AS_RESTORE
						);
		}
	VSS_STANDARD_CATCH(ft)


    return ft.hr;
	}

void CVssBackupComponents::FindAndValidateWriterData
	(
	IN VSS_ID idInstance,
	OUT UINT *piWriter
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::FindAndValidateWriterData");

	// validate writer SID hasn't changed since GatherWriterMetadata
	// was called
	CInternalWriterData *pData = FindWriterData(idInstance, piWriter);
	if (pData == NULL)
		ft.Throw
			(
			VSSDBG_XML,
			E_ACCESSDENIED,
			L"Instance id was not discovered in Identify pass" WSTR_GUID_FMT,
			GUID_PRINTF_ARG(idInstance)
			);

	TOKEN_OWNER *pOwnerToken = GetClientTokenOwner(TRUE);

	if (!EqualSid(pData->m_pOwnerToken->Owner, pOwnerToken->Owner))
		{
		delete pOwnerToken;
		ft.Throw
			(
			VSSDBG_XML,
			E_ACCESSDENIED,
			L"SID for instance id does not match" WSTR_GUID_FMT,
			GUID_PRINTF_ARG(idInstance)
			);
		}

	delete pOwnerToken;
	}



// get content for a specific writer
// implements IVssWriterCallback::GetContent
//
// Returns:
//		S_OK if the operation is successful
//		S_FALSE if the object is not found
//		VSS_E_BAD_STATE if the caller is not responding to PrepareForBackup,
//			BackupComplete, or Restore
//		E_ACCESSDENIED if the caller is responding to Restore and is not
//			and administrator or if the writer is not participating in the
//			backup or is trying to impersonate another writer.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::GetContent
	(
	IN BSTR WriterInstanceId,
	OUT BSTR *pbstrXMLDocContent
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::GetContent"
		);

    try
		{
		// validate and initialize output parameter
		if (pbstrXMLDocContent == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameter
		*pbstrXMLDocContent = NULL;

		CVssID idInstance;
		idInstance.Initialize(ft, WriterInstanceId, E_INVALIDARG);

		// test state for validity
		// don't acquire m_csState as it is acquired by the call
		// to RequestWriterData in another thread.
		if (m_state != x_StatePrepareForBackup &&
			m_state != x_StateBackupComplete &&
			m_state != x_StateRestore)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Invalid state %d to request BACKUP_COMPONENTS content",
				m_state
				);


		// for now writers that participate in restore processing must
		// have administrative privileges
		if (m_state  == x_StateRestore)
			if (!IsAdministrator())
				ft.Throw
					(
					VSSDBG_XML,
					E_ACCESSDENIED,
					L"Caller must be Administrator to do a restore."
					);


		FindAndValidateWriterData(idInstance, NULL);
		CVssSafeAutomaticLock lockDOM(m_csDOM);
        m_doc.ResetToDocument();
        // find first WRITER_COMPONENTS element
        if (!m_doc.FindElement(x_wszElementWriterComponents, TRUE))
			return S_FALSE;

        // find specific WRITER_COMPONENTS element
		bool bFound = false;
		do
			{
			// get instanceId value
			CComBSTR bstrVal;

			VSS_ID idFound;

			get_VSS_IDValue(ft, x_wszAttrInstanceId, &idFound);
			if (idInstance == idFound)
				{
				bFound = true;
				break;
				}
			} while(m_doc.FindElement(x_wszElementWriterComponents, FALSE));

        if (!bFound)
			return S_FALSE;


		CXMLDocument doc(m_doc.GetCurrentNode(), m_doc.GetInterface());
		CComBSTR bstrXMLDocContent = doc.SaveAsXML();

		// a root node, schema, and supplied document
		UINT cwcDoc = (UINT) g_cwcComponentMetadataXML + (UINT) wcslen(bstrXMLDocContent);

        // allocate string
        BSTR bstr = *pbstrXMLDocContent = SysAllocStringLen(NULL, cwcDoc);

		// check for allocation failure
		if (bstr == NULL)
			ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Couldn't allocate BSTR");

		// setup pointer to beginning of string
		WCHAR *pwc = bstr;

		// copy in <root> <schema>
	    memcpy(pwc, g_ComponentMetadataXML, g_iwcComponentMetadataXMLEnd * sizeof(WCHAR));
		pwc += g_iwcComponentMetadataXMLEnd;

		// copy in document
		wcscpy(pwc, bstrXMLDocContent);
		pwc += wcslen(bstrXMLDocContent);

		// copy in </root>
		wcscpy(pwc, g_ComponentMetadataXML + g_iwcComponentMetadataXMLEnd);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// replace the contents of the backup components document
// implements IVssWriterCallback::SetContent
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the writer is not reponding to PrepareForBackup
//		E_ACCESSDENIED if the writer is not participating in the current
//			backup or another writer is trying to impersonate this writer.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::SetContent
	(
	IN BSTR WriterInstanceId,
	IN BSTR bstrXMLWriterComponents
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::SetContent"
		);

    // validate state
	// don't acquire m_csState as it is acquired by the call
	if (m_state != x_StatePrepareForBackup)
		ft.hr = VSS_E_BAD_STATE;
	else
		ft.hr = AddWriterData(WriterInstanceId, NULL, NULL, bstrXMLWriterComponents, false);


	return ft.hr;
	}


// expose state of writer in response to RequestWriterMetadata
// implements IVssWriterCallback::ExposeCurrentState
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if WriterClassId, WriterInstanceId, bstrWriterName are
//			NULL or if nCurrentState is not a valid writer state
//		E_ACCESSDENIED if the writer is not participating in the current
//			backup or is trying to impersonate another writer.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::ExposeCurrentState
	(
	IN BSTR WriterInstanceId,
	IN VSS_WRITER_STATE nCurrentState,
	IN HRESULT hrWriterFailure
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::ExposeCurrentState");

	try
		{
		if (WriterInstanceId == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

		if (nCurrentState != VSS_WS_STABLE &&
			nCurrentState != VSS_WS_WAITING_FOR_FREEZE &&
			nCurrentState != VSS_WS_WAITING_FOR_THAW &&
			nCurrentState != VSS_WS_WAITING_FOR_BACKUP_COMPLETE &&
			nCurrentState != VSS_WS_FAILED_AT_IDENTIFY &&
			nCurrentState != VSS_WS_FAILED_AT_PREPARE_BACKUP &&
			nCurrentState != VSS_WS_FAILED_AT_PREPARE_SNAPSHOT &&
			nCurrentState != VSS_WS_FAILED_AT_FREEZE &&
			nCurrentState != VSS_WS_FAILED_AT_THAW)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Invalid Writer state");


		CVssID idInstance;
		idInstance.Initialize(ft, WriterInstanceId, E_INVALIDARG);

		UINT iWriter;
		FindAndValidateWriterData(idInstance, &iWriter);
		CVssSafeAutomaticLock lock(m_csWriters);

		BS_ASSERT(iWriter < m_cWriters);
		VSS_WRITER_PROP *pProp = &m_rgWriterProp[iWriter];
		pProp->m_nState = nCurrentState;
		pProp->m_hrWriterFailure = hrWriterFailure;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// Called to set the context for subsequent snapshot-related operations
// Not defined in client SKU
STDMETHODIMP CVssBackupComponents::SetContext
	(
    IN LONG lContext
    )
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::SetContext");

	BS_ASSERT(false);
	return E_NOTIMPL;

	UNREFERENCED_PARAMETER(lContext);
    }
    

// start snapshot set
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pSnapshotSetId is NULL
//		E_ACCESSDENIED if the caller does not have backup privileges or
//			is not an adminstrator
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		VSS_E_SNAPSHOT_SET_IN_PROGRESS if a snapshot set is already started.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::StartSnapshotSet
	(
	OUT VSS_ID *pSnapshotSetId
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::StartSnapshotSet");

	try
		{
		if (pSnapshotSetId == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

		*pSnapshotSetId = GUID_NULL;

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);

		if (m_state != x_StateInitialized)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Unexpected call to PrepareForBackup in state %d.",
				m_state
				);

		SetupCoordinator(ft);
		ft.hr = m_pCoordinator->StartSnapshotSet(pSnapshotSetId);
		if (!ft.HrFailed())
			{
			m_bstrSnapshotSetId = *pSnapshotSetId;
			if (m_bstrSnapshotSetId.Length() == 0)
				ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Failed to allocate BSTR.");

			m_state = x_StateSnapshotSetCreated;
			}
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// internal routine to setup the coordinator
// note that the m_csState critical section should be acquired
// before calling this routine.  Access to this routine must be
// single threaded
void CVssBackupComponents::SetupCoordinator(IN CVssFunctionTracer &ft)
	{
	if (m_pCoordinator)
		return;

    ft.LogVssStartupAttempt();
	ft.hr = CoCreateInstance
				(
				CLSID_VSSCoordinator,
				NULL,
				CLSCTX_LOCAL_SERVER,
				IID_IVssCoordinator,
				(void **) &m_pCoordinator
			    );

    ft.CheckForError(VSSDBG_XML, L"CoCreateInstance");
    }

// add a volume to a snapshot set
//
// Returns:
//		S_OK if the operation is successful
//		E_ACCESSDENIED if the caller does not have backup privileges or
//			is not an adminstrator
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs
//		E_INVALIDARG if ppSnapshot is NULL

STDMETHODIMP CVssBackupComponents::AddToSnapshotSet
	(							
	IN VSS_PWSZ	pwszVolumeName, 			
	IN VSS_ID		ProviderId, 				
	OUT VSS_ID		*pSnapshotId
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::AddToSnapshot");

	try
		{
		if (pSnapshotId == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Output parameter is NULL");

		*pSnapshotId = GUID_NULL;

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);
		if (m_state != x_StateSnapshotSetCreated)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot call AddToSnapshotSet at this point");

		SetupCoordinator(ft);
		ft.hr = m_pCoordinator->AddToSnapshotSet
						(
						pwszVolumeName,
						ProviderId,
						pSnapshotId
						);

        }
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}
						
// create the snapshot set
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppAsync is NULL
//		E_ACCESSDENIED if the caller does not have backup privileges or
//			is not an adminstrator
//		VSS_E_BAD_STATE if the backup components object is not initialized,
//			if called during restore, or if not called after PrepareForBackup
//			was successful.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::DoSnapshotSet
	(								
	OUT IVssAsync** ppAsync 					
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::DoSnapshotSet");

	try
		{
		if (ppAsync == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL Output parameter.");

		*ppAsync = NULL;

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);
		if (m_state != x_StateSnapshotSetCreated &&
			m_state != x_StatePrepareForBackupSucceeded)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot call DoSnapshotSet at this point.");

        // Execute DoSnapshotSet
		m_state = x_StateDoSnapshot;
		SetupCoordinator(ft);
        CComPtr<IVssAsync> ptrAsyncInternal;
		ft.hr = m_pCoordinator->DoSnapshotSet(NULL, &ptrAsyncInternal);

   		// create cover async object
		CVssAsyncCover::CreateInstance(this, ptrAsyncInternal, ppAsync);
		}
	VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed())
		{

		AbortBackup();
		m_state = x_StateDoSnapshotFailed;
		}


	return ft.hr;
	}


// delete snapshots
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if eSourceObjectType is invalid, plDeletedSnapshots is
//			NULL, or pNonDeletedSnapshotID is NULL.
//		E_ACCESSDENIED if the caller does not have backup privileges or
//			is not an adminstrator
//		VSS_E_OBJECT_NOT_FOUND if the specified snapshot doesn't exist.
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::DeleteSnapshots
	(							
	IN VSS_ID			SourceObjectId, 		
	IN VSS_OBJECT_TYPE 	eSourceObjectType,		
	IN BOOL				bForceDelete,			
	OUT LONG*			plDeletedSnapshots,		
	OUT VSS_ID*			pNonDeletedSnapshotID	
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::DeleteSnapshots");
	try
		{
		VssZeroOut(plDeletedSnapshots);
		VssZeroOut(pNonDeletedSnapshotID);
		if (plDeletedSnapshots == NULL || pNonDeletedSnapshotID == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_INVALIDARG,
				L"Null output parameter"
				);

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);
		SetupCoordinator(ft);
		ft.hr = m_pCoordinator->DeleteSnapshots
			(
			SourceObjectId, 		
			eSourceObjectType,		
			bForceDelete,			
			plDeletedSnapshots,		
			pNonDeletedSnapshotID
			);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// query for either snapshot sets, snapshots, or providers
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if eQueriedObjectType is invalid, eReturnedObjectsType
//			is invalid or ppEnum is NULL.
//		E_ACCESSDENIED if the caller does not have backup privileges or
//			is not an adminstrator
//		VSS_E_OBJECT_NOT_FOUND if the queried object doesn't exist.
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs
//
STDMETHODIMP CVssBackupComponents::Query
	(										
	IN VSS_ID			QueriedObjectId,		
	IN VSS_OBJECT_TYPE eQueriedObjectType, 	
	IN VSS_OBJECT_TYPE eReturnedObjectsType,	
	OUT IVssEnumObject **ppEnum 				
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::Query");
	try
		{
		// validate and clear output parameter
		if (ppEnum == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		*ppEnum = NULL;

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);
		SetupCoordinator(ft);
		ft.hr = m_pCoordinator->Query
			(
			QueriedObjectId,		
			eQueriedObjectType, 	
			eReturnedObjectsType,	
			ppEnum
			);

		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// Remount the snapshot as read-write
STDMETHODIMP CVssBackupComponents::RemountReadWrite
	(
	IN VSS_ID SnapshotId,
	OUT IVssAsync**		pAsync
	)
{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::RemountReadWrite");

    return E_NOTIMPL;
    UNREFERENCED_PARAMETER(SnapshotId);
    UNREFERENCED_PARAMETER(pAsync);
}


// Break the snapshot set
STDMETHODIMP CVssBackupComponents::BreakSnapshotSet
	(
	IN VSS_ID			SnapshotSetId
	)
{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::BreakSnapshotSet");

    return E_NOTIMPL;
    UNREFERENCED_PARAMETER(SnapshotSetId);
}


// Import snapshots
STDMETHODIMP CVssBackupComponents::ImportSnapshots
	(
	OUT IVssAsync**		ppAsync
	)
{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::ImportSnapshots");

    return E_NOTIMPL;
    UNREFERENCED_PARAMETER(ppAsync);
}


// get interface to snapshot
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppSnap is NULL.
//		E_ACCESSDENIED if the caller does not have backup privileges or
//			is not an adminstrator
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		VSS_E_OBJECT_NOT_FOUND if the snapshot id is invalid
//		E_NOINTERFACE if the SnapshotInterfaceId is not valid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::GetSnapshotProperties
	(								
	IN VSS_ID		SnapshotId, 			
	OUT VSS_SNAPSHOT_PROP	*pProp
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::GetSnapshotProperties");

	try
		{
		if (pProp == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		::VssZeroOut(pProp);

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);
		SetupCoordinator(ft);
		ft.hr = m_pCoordinator->GetSnapshotProperties
					(
					SnapshotId,
					pProp
					);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// gather writer metadata
//
// Returns:
//		S_OK if the operation is successful.
//		E_INVAIDARG if pcWriters is NULL.
//		VSS_E_BAD_STATE if the backup components object is not initialized,
//			if called during a restore operation or if called while
//			PrepareForBackup is in progress.
//		E_OUTOFMEMORY if an allocation failure occurs.

STDMETHODIMP CVssBackupComponents::GatherWriterMetadata
	(
	OUT IVssAsync **ppAsync
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::GatherWriterMetadata"
		);

	try
		{
		if (ppAsync == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output paramter.");

		*ppAsync = NULL;

		// validate that the object is initialized
		ValidateInitialized(ft);

		*ppAsync = CVssAsyncBackup::CreateInstanceAndStartJob
			(
			this,
			CVssAsyncBackup::VSS_AS_GATHER_WRITER_METADATA
			);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// get count of writers supplying metadata
//
// Returns:
//     VSS_E_BAD_STATE: if called when GatherWriterMetadata was not called or is in progress
//	   E_INVALIDARG: if pcWriters is NULL
//
STDMETHODIMP CVssBackupComponents::GetWriterMetadataCount
	(
	OUT UINT *pcWriters
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::GetWriterMetadataCount"
		);

	try
		{
		if (pcWriters == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Output parameter is NULL");

		*pcWriters = NULL;

		if (!m_bGatherWriterMetadataComplete)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Gather writer metadata is not complete");

		*pcWriters = m_cWriters;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// internal routine to gather writer metadata
// Returns:
//	   S_OK: if there are no errors.
//	   VSS_E_WRITER_INFRASTRUCTURE: either the service state or bootable state
//			writer did not respond.
//	   E_UNEXPECTED: for an unexpected error
//	   E_OUTOFMEMORY: for out of resources
//

HRESULT CVssBackupComponents::InternalGatherWriterMetadata()
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::InternalGatherWriterMetadata"
		);

    bool bLocked = false;
	VSS_BACKUPCALL_STATE stateSaved = x_StateUndefined;
	UINT timestamp = 0;

	try
		{
		// acquire critical section to change state
		m_csState.Lock();
		stateSaved = m_state;
		bLocked = true;
		timestamp = ++m_timestampOperation;


		if (m_state == x_StatePrepareForBackup)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Can't call this function while PrepareForBackup is in progress");

		m_state = x_StateGatheringWriterMetadata;

		// free existing writer data
		FreeAllWriters();

    	// start VSS service since it contains the MSDE Writer
		CComPtr<IVssCoordinator> pCoordinator;

        ft.LogVssStartupAttempt();
       	ft.hr = CoCreateInstance
				(
				CLSID_VSSCoordinator,
				NULL,
				CLSCTX_LOCAL_SERVER,
				IID_IVssCoordinator,
				(void **) &pCoordinator
			    );

		ft.CheckForError(VSSDBG_XML, L"CoCreateInstance");

		CComPtr <IVssShim> pShim;
		// query interface for IVssShim interface
		ft.hr = pCoordinator->QueryInterface(IID_IVssShim, (void **) &pShim);
		if (ft.HrFailed())
			{
			BS_ASSERT(FALSE && "QI shouldn't fail");
			ft.LogError(VSS_ERROR_QI_IVSSSHIM_FAILED, VSSDBG_XML << ft.hr);
			ft.Throw
				(
                VSSDBG_XML,
				E_UNEXPECTED,
				L"QueryInterface failed.  hr = 0x%08lx", ft.hr
				);
			}

		// wait for subscriptions to complete
		ft.hr = pShim->WaitForSubscribingCompletion();
		if (ft.HrFailed())
			throw (HRESULT) (ft.hr);


		CComPtr<IVssWriter>pWriter;
		SetupWriter(ft, &pWriter);


        CComPtr<IUnknown> pUnknown = GetUnknown();
		CComPtr<IDispatch> pDispatch;
		ft.hr = pUnknown->SafeQI(IDispatch, &pDispatch);
		BS_ASSERT(!ft.HrFailed());
		if (ft.HrFailed())
			{
			ft.LogError(VSS_ERROR_QI_IDISPATCH_FAILED, VSSDBG_XML << ft.hr);
			ft.Throw
				(
				VSSDBG_XML,
				E_UNEXPECTED,
				L"Error querying the IDispatch interface.  hr = 0x%08lx",
				ft.hr
				);
            }

		CVssFunctionTracer ft1(VSSDBG_XML, L"CVssBackupComponents::InternalGatherWriterMetadata1");
        ft1.hr = pWriter->RequestWriterInfo(NULL, true, false, pDispatch);
		ft1.TranslateWriterReturnCode(VSSDBG_XML, L"IVssWriter::RequestWriterInfo, GatherWriterMetadata");
		if (!ft.HrFailed())
			{
			ft.hr = PostGatherWriterMetadata(timestamp, stateSaved);
			bLocked = false;
			}

		ClearPublisherFilter(pWriter);
		}
	VSS_STANDARD_CATCH(ft)

	if (bLocked && m_timestampOperation == timestamp)
		{
		// restore state to what it was upon entry to this routine.
		m_state = stateSaved;
		m_timestampOperation++;
		m_csState.Unlock();
		}

	return ft.hr;
	}

// work to do after gather writer metadata is complete.  This may
// be called by either InternalGatherWriterMetadata or IVssAsync::Cancel
HRESULT CVssBackupComponents::PostGatherWriterMetadata
	(
	UINT timestamp,
	VSS_BACKUPCALL_STATE stateSaved
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"PostGatherWriterMetadata");

	// only perform operation if timestamp matches, i.e., PostGatherWriterMetadata
	// was not already called on a different thread.

	CVssSafeAutomaticLock lock(m_csWriters);

	if (timestamp == m_timestampOperation)
		{
		bool fFoundBootableStateWriter = false;
		bool fFoundSystemServiceWriter = false;

		CInternalWriterData *pData = m_pDataFirst;
		
		for(UINT iWriter = 0; iWriter < m_cWriters; iWriter++)
			{
			if (pData->m_idWriter == idWriterBootableState)
				fFoundBootableStateWriter = true;

			if (pData->m_idWriter == idWriterServiceState)
				fFoundSystemServiceWriter = true;

			pData = pData->m_pDataNext;
			}

		// check that both the service state and bootable state writer
		// responded.  If not there is an error.
		if (!fFoundBootableStateWriter || !fFoundSystemServiceWriter)
			{
			ft.hr = VSS_E_WRITER_INFRASTRUCTURE;
			ft.LogError(VSS_ERROR_WRITER_INFRASTRUCTURE, VSSDBG_XML);
			}

		if (!ft.HrFailed())
			m_bGatherWriterMetadataComplete = true;

		m_timestampOperation++;
		m_state = stateSaved;
		m_csState.Unlock();
		}

	return ft.hr;
	}



// internal routine to add data to the writer data queue
HRESULT CVssBackupComponents::AddWriterData
	(
	IN BSTR WriterInstanceId,
	IN BSTR WriterClassId,
	IN BSTR bstrWriterName,
	IN BSTR bstrWriterXMLDocument,
	IN bool bReinitializing
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::AddWriterData");

	TOKEN_OWNER *pOwnerToken = GetClientTokenOwner(TRUE);
	try
		{
		CVssID idInstance, idWriter;
		idInstance.Initialize(ft, WriterInstanceId, E_INVALIDARG);
		if (bReinitializing)
			{
			idWriter.Initialize(ft, WriterClassId, E_INVALIDARG);
			if (bstrWriterName == NULL)
				ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL Required input parameter.");
			}

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csWriters);

		// caller must be backup operator or
		if (bReinitializing)
			{
			if (FindWriterData(idInstance))
				{
				ft.LogError(VSS_ERROR_DUPLICATE_WRITERS, VSSDBG_XML << idInstance);
				ft.Throw
					(
					VSSDBG_XML,
					E_UNEXPECTED,
					L"Two writers with identical instance ids. %s",
					WriterInstanceId
					);
                }

			CInternalWriterData *pData = new CInternalWriterData();
			if (pData == NULL)
				ft.Throw
					(
					VSSDBG_XML,
					E_OUTOFMEMORY,
					L"Cannot create CInternalWriterMetadata because of allocation failure"
					);

			pData->Initialize
				(
				idInstance,
				idWriter,
			    bstrWriterName,
				bstrWriterXMLDocument,
				pOwnerToken
				);

			pOwnerToken = NULL;
			pData->m_pDataNext = m_pDataFirst;
			m_pDataFirst = pData;
			m_cWriters++;
			}
		else
			{
			CInternalWriterData *pData = FindWriterData(idInstance);
			if (pData == NULL)
				ft.Throw
					(
					VSSDBG_GEN,
					E_ACCESSDENIED,
					L"Didn't find writer with instance id. %s",
					WriterInstanceId
					);

            if (!EqualSid(pData->m_pOwnerToken->Owner, pOwnerToken->Owner))
				ft.Throw
					(
					VSSDBG_XML,
					E_ACCESSDENIED,
					L"SID didn't match initialization sid"
					);

			BS_ASSERT(!pData->m_bstrWriterComponents);
			pData->SetComponents(bstrWriterXMLDocument);
			}
		}
	VSS_STANDARD_CATCH(ft)

	delete pOwnerToken;

	return ft.hr;
	}


// a single writer exposing its data
// implements IVssWriterCallback::ExposeWriterMetadata
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the oepration is not in response to
//			a GatherWriterMetadata call (called in OnIdentify)
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::ExposeWriterMetadata
	(
	IN BSTR WriterInstanceId,
	IN BSTR WriterClassId,
	IN BSTR bstrWriterName,
	IN BSTR bstrWriterXMLMetadata
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::ExposeWriterMetadata"
		);

    // note that the state is already locked by another thread holding
	// performing RequestWriterInfo.
	if (m_state != x_StateGatheringWriterMetadata)
		ft.hr = VSS_E_BAD_STATE;
	else
		// add data to writers list
		ft.hr = AddWriterData
			(
			WriterInstanceId,
			WriterClassId,
			bstrWriterName,
			bstrWriterXMLMetadata,
			true
			);

	return ft.hr;
	}
		
// get metadata for a specific writer
// implements IVssBackupComponents::GetWriterMetadata
// caller is responsible for calling IVssExineWriterMetadata::Release on the returned object
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pidInstance or ppMetadata is NULL.
//		VSS_E_BAD_STATE if the backup components object is not initialized
//			or this is performed during a RESTORE operation
//		VSS_E_OBJECT_NOT_FOUND if iWriter does not refer to a writer
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document from the writer is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::GetWriterMetadata
	(
	IN UINT iWriter,
	OUT VSS_ID *pidInstance,
	OUT IVssExamineWriterMetadata **ppMetadata
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::GetWriterMetadata"
		);

	CVssExamineWriterMetadata *pvem = NULL;
    try
		{
		if (pidInstance == NULL || ppMetadata == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameters to null
		*pidInstance = GUID_NULL;
		*ppMetadata = NULL;

		// validate that the object is initialized
		ValidateInitialized(ft);

		// protect writer information list
		CVssSafeAutomaticLock lock(m_csWriters);

		// check that writer # is within range
		if (iWriter > m_cWriters)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"iWriter %d > # of writers(%d)",
				iWriter,
				m_cWriters
				);

		// find specific element in list
        CInternalWriterData *pMetadata = m_pDataFirst;
		for(UINT i = 0; i < iWriter; i++)
			{
			BS_ASSERT(pMetadata != NULL);
			pMetadata = pMetadata->m_pDataNext;
			}

		BS_ASSERT(pMetadata != NULL);

		// allocate object
		pvem = new CVssExamineWriterMetadata;

		// check for allocation failure
		if (pvem == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Cannot create CVssExamineWriterMetadata due to allocation failure."
				);

        // 2nd phases of construction
        if (!pvem->Initialize(pMetadata->m_bstrWriterMetadata))
			{
			ft.LogError(VSS_ERROR_INVALID_XML_DOCUMENT_FROM_WRITER, VSSDBG_XML << pMetadata->m_idInstance);
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_CORRUPT_XML_DOCUMENT,
				L"Metadata supplied by writer {%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x} is invalid.",
				GUID_PRINTF_ARG(pMetadata->m_idInstance)
				);
            }

        // return instanceId
        *pidInstance = pMetadata->m_idInstance;

		// return IVssExamineWriterMetadata interface
		*ppMetadata = (IVssExamineWriterMetadata *) pvem;

		// set reference count to 1
		pvem->AddRef();
		}
	VSS_STANDARD_CATCH(ft)

	// delete object if failure after allocation
	if (ft.HrFailed())
		delete pvem;

	return ft.hr;
	}

// free writer metadata
// implements IVssBackupComponents::FreeWriterMetadata
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//			or if this is a Restore operation

STDMETHODIMP CVssBackupComponents::FreeWriterMetadata()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::FreeWriterMetadata");

	try
		{
		// validate that the object is initialized
		ValidateInitialized(ft);

		// secure writer list data structure
		CVssSafeAutomaticLock lock(m_csWriters);

		// loop through linked elements deleting each one
		CInternalWriterData *pMetadata;
		UINT iWriter = 0;
		for (pMetadata = m_pDataFirst; iWriter < m_cWriters; iWriter++)
			{
			BS_ASSERT(pMetadata != NULL);

			// free up bstring
			pMetadata->m_bstrWriterMetadata.Empty();
			pMetadata = pMetadata->m_pDataNext;
			}
		}
	VSS_STANDARD_CATCH(ft)

	m_bGatherWriterMetadataComplete = false;
	return ft.hr;
	}


// free component metadata, i.e., writer components associated with
// each writer in the backup
void CVssBackupComponents::FreeWriterComponents()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::FreeWriterMetadata");

	// secure writer list data structure
	CVssSafeAutomaticLock lock(m_csWriters);

	try
		{
		// loop through linked elements deleting each one
		CInternalWriterData *pMetadata;
		UINT iWriter = 0;
		for (pMetadata = m_pDataFirst; iWriter < m_cWriters; iWriter++)
			{
			BS_ASSERT(pMetadata != NULL);

			// free up bstring
			pMetadata->m_bstrWriterComponents.Empty();
			pMetadata = pMetadata->m_pDataNext;
			}
		}
	VSS_STANDARD_CATCH(ft)
	}





// free up writer metadata
// internal routine called during GatherWriterMetadata
void CVssBackupComponents::FreeAllWriters()
	{
	// secure writer list data structure
	CVssSafeAutomaticLock lock(m_csWriters);

	// loop through linked elements deleting each one
	CInternalWriterData *pMetadata, *pMetadataNext;
	for (pMetadata = m_pDataFirst; m_cWriters > 0; m_cWriters--)
		{
		BS_ASSERT(pMetadata != NULL);
		pMetadataNext = pMetadata->m_pDataNext;
		delete pMetadata;
		pMetadata = pMetadataNext;
		}

	// clear head of list
	m_pDataFirst = NULL;
	}

// find writer data for a writer with a specific instance id
CInternalWriterData *CVssBackupComponents::FindWriterData
	(
	VSS_ID idInstance,
	UINT *piWriter
	)
	{
	// secure writer list data structure
	CVssSafeAutomaticLock lock(m_csWriters);

	// loop through linked elements deleting each one
	CInternalWriterData *pMetadata;
	UINT iWriter = 0;
	for (pMetadata = m_pDataFirst; iWriter < m_cWriters ; iWriter++)
		{
		BS_ASSERT(pMetadata != NULL);
		if (pMetadata->m_idInstance == idInstance)
			{
			if (piWriter)
				*piWriter = iWriter;

			return pMetadata;
			}

		pMetadata = pMetadata->m_pDataNext;
		}

	return NULL;
	}



// get count of WRITER_COMPONENTS elements in a BACKUP_COMPONENTS document
// implements IVssBackupComponents::GetWriterComponentsCount
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pcComponents is NULL
//		VSS_E_BAD_STATE if the backup components document is not initialized
//	    E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::GetWriterComponentsCount
	(
	OUT UINT *pcComponents
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWriterComponents::GetWriterComponentsCount"
		);

    try
		{
		// validate output parameter
		if (pcComponents == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameter
		*pcComponents = 0;

		// validate that the object is initialized
		ValidateInitialized(ft);


		CVssSafeAutomaticLock lock(m_csDOM);
		// reposition to top of document
		m_doc.ResetToDocument();

        // find first WRITER_COMPONENTS element
        if (!m_doc.FindElement(x_wszElementWriterComponents, TRUE))
			return S_OK;

		UINT cComponents = 0;
        // count WRITER_COMPONENTS elements
		do
			{
			cComponents++;
			} while(m_doc.FindElement(x_wszElementWriterComponents, FALSE));

		*pcComponents = cComponents;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// obtain a specific WRITER_COMPONENTS element
// implements IVssBackupComponents::GetWriterComponents
// caller is responsible for calling IVssWriterComponents::Release
// on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppWriter is NULL
//		VSS_E_OBJECT_NOT_FOUND if the specified component is not found
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::GetWriterComponents
	(
	IN UINT iWriter,
	OUT IVssWriterComponentsExt **ppWriter
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponentsDoc::GetWriterComponents"
		);

	// object deleted in case of failure
    CVssWriterComponents *pWriterComponents = NULL;
	try
		{
		// validate output parameter
		if (ppWriter == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameter
		*ppWriter = NULL;

		// validate that the object is initialized
		ValidateInitialized(ft);

		// obtain lock to protect access to DOM document
		CVssSafeAutomaticLock lock(m_csDOM);

		// reposition to top of document
		m_doc.ResetToDocument();

        // find first WRITER_COMPONENTS element
        if (!m_doc.FindElement(x_wszElementWriterComponents, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"Couldn't find %d WRITER_COMPONENT.",
				iWriter
				);

        // skip to selected WRITER_COMPONENTS element
        for(UINT i = 0; i < iWriter; i++)
			{
			if (!m_doc.FindElement(x_wszElementWriterComponents, FALSE))
				ft.Throw
					(
					VSSDBG_XML,
					VSS_E_OBJECT_NOT_FOUND,
					L"Couldn't find %d WRITER_COMPONENT.",
					iWriter
					);
            }

		// allocate CVssWriterComponents object
	    pWriterComponents = new CVssWriterComponents
								(
								m_doc.GetCurrentNode(),
								m_doc.GetInterface(),
								false
								);

		// validate that memory allocation succeeded
		if (pWriterComponents == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Cannot create CVssWriterComponents due to allocation failure."
				);

        // 2nd phase of initialization
        pWriterComponents->Initialize(false);

		// transfer ownership of pointer
        *ppWriter = (IVssWriterComponentsExt *) pWriterComponents;

		// set reference count to 1
        ((IVssWriterComponentsExt *) pWriterComponents)->AddRef();

		// transfer ownership to output pointer
		pWriterComponents = NULL;
		}
	VSS_STANDARD_CATCH(ft)

	// delete object if failure after allocation
	delete pWriterComponents;

	return ft.hr;
	}

	// Called by the requestor to check if a certain volume is supported.
STDMETHODIMP CVssBackupComponents::IsVolumeSupported
		(										
		IN VSS_ID ProviderId,		
        IN VSS_PWSZ pwszVolumeName,
        IN BOOL * pbSupportedByThisProvider
		)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::IsVolumeSupported");

	try
		{
		if (pbSupportedByThisProvider == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Output parameter is NULL");

		*pbSupportedByThisProvider = NULL;

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);
		SetupCoordinator(ft);
		ft.hr = m_pCoordinator->IsVolumeSupported
			(
			ProviderId,		
			pwszVolumeName, 	
			pbSupportedByThisProvider
			);

        }
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// various not implemented methods

// indicate that only ranges in the file are to be backed up
STDMETHODIMP CVssComponent::AddPartialFile
	(
	IN LPCWSTR wszPath,
	IN LPCWSTR wszFilename,
	IN LPCWSTR wszRanges,
	IN LPCWSTR wszMetadata
	)
	{
	UNREFERENCED_PARAMETER(wszPath);
	UNREFERENCED_PARAMETER(wszFilename);
	UNREFERENCED_PARAMETER(wszRanges);
	UNREFERENCED_PARAMETER(wszMetadata);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::AddPartialFile");
	return E_NOTIMPL;
	}

// get count of partial file declarations
STDMETHODIMP CVssComponent::GetPartialFileCount
	(
	OUT UINT *pcPartialFiles
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetPartialFileCount");

	try
		{
		VssZeroOut(pcPartialFiles);
		if (pcPartialFiles == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// get a partial file declaration
STDMETHODIMP CVssComponent::GetPartialFile
	(
	IN UINT iPartialFile,
	OUT BSTR *pbstrPath,
	OUT BSTR *pbstrFilename,
	OUT BSTR *pbstrRange,
	OUT BSTR *pbstrMetadata
	)
	{
	UNREFERENCED_PARAMETER(iPartialFile);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetPartialFile");
	try
		{
		VssZeroOut(pbstrPath);
		VssZeroOut(pbstrFilename);
		VssZeroOut(pbstrRange);
		VssZeroOut(pbstrMetadata);

		if (pbstrPath == NULL ||
			pbstrFilename == NULL ||
            pbstrRange == NULL ||
			pbstrMetadata == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// determine if the component is selected to be restored
STDMETHODIMP CVssComponent::IsSelectedForRestore
	(
	OUT bool *pbSelectedForRestore
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::IsSelectedForRestore");

	try
		{
		VssZeroOut(pbSelectedForRestore);
		if (pbSelectedForRestore == NULL)
			ft.Throw(VSSDBG_XML, E_NOTIMPL, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

STDMETHODIMP CVssComponent::GetAdditionalRestores
	(
	OUT bool *pbAdditionalRestores
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetAdditionalRestores");
	try
		{
		VssZeroOut(pbAdditionalRestores);
		if (pbAdditionalRestores == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// add a new location target for a file to be restored
STDMETHODIMP CVssComponent::AddNewTarget
	(
	IN LPCWSTR wszPath,
	IN LPCWSTR wszFileName,
	IN bool bRecursive,
	IN LPCWSTR wszAlternatePath
	)
	{
	UNREFERENCED_PARAMETER(wszPath);
    UNREFERENCED_PARAMETER(wszFileName);
	UNREFERENCED_PARAMETER(bRecursive);
	UNREFERENCED_PARAMETER(wszAlternatePath);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::AddNewTarget");

	return E_NOTIMPL;
	}

// get count of new target specifications
STDMETHODIMP CVssComponent::GetNewTargetCount
	(
	OUT UINT *pcNewTarget
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetNewTargetCount");

	try
		{
		VssZeroOut(pcNewTarget);

		if (pcNewTarget == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

STDMETHODIMP CVssComponent::GetNewTarget
	(
	IN UINT iNewTarget,
	OUT IVssWMFiledesc **ppFiledesc
	)
	{
	UNREFERENCED_PARAMETER(iNewTarget);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetNewTarget");

	try
		{
		VssZeroOut(ppFiledesc);
		if (ppFiledesc == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// add a directed target specification
STDMETHODIMP CVssComponent::AddDirectedTarget
	(
	IN LPCWSTR wszSourcePath,
	IN LPCWSTR wszSourceFilename,
	IN LPCWSTR wszSourceRangeList,
	IN LPCWSTR wszDestinationPath,
	IN LPCWSTR wszDestinationFilename,
	IN LPCWSTR wszDestinationRangeList
	)
	{
	UNREFERENCED_PARAMETER(wszSourcePath);
	UNREFERENCED_PARAMETER(wszSourceFilename);
	UNREFERENCED_PARAMETER(wszSourceRangeList);
	UNREFERENCED_PARAMETER(wszDestinationPath);
	UNREFERENCED_PARAMETER(wszDestinationFilename);
	UNREFERENCED_PARAMETER(wszDestinationRangeList);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::AddDirectedTarget");

	return E_NOTIMPL;
	}

// get count of directed target specifications
STDMETHODIMP CVssComponent::GetDirectedTargetCount
	(
	OUT UINT *pcDirectedTarget
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetDirectedTargetCount");

	try
		{
		VssZeroOut(pcDirectedTarget);

		if (pcDirectedTarget == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output paramter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}
		
// obtain a particular directed target specification
STDMETHODIMP CVssComponent::GetDirectedTarget
	(
	IN UINT iDirectedTarget,
	OUT BSTR *pbstrSourcePath,
	OUT BSTR *pbstrSourceFileName,
	OUT BSTR *pbstrSourceRangeList,
	OUT BSTR *pbstrDestinationPath,
	OUT BSTR *pbstrDestinationFilename,
	OUT BSTR *pbstrDestinationRangeList
	)
	{
	UNREFERENCED_PARAMETER(iDirectedTarget);
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetDirectedTarget");

	try
		{
		VssZeroOut(pbstrSourcePath);
		VssZeroOut(pbstrSourceFileName);
		VssZeroOut(pbstrSourceRangeList);
		VssZeroOut(pbstrDestinationPath);
		VssZeroOut(pbstrDestinationFilename);
		VssZeroOut(pbstrDestinationRangeList);

		if (pbstrSourcePath == NULL ||
			pbstrSourceFileName == NULL ||
			pbstrSourceRangeList == NULL ||
			pbstrDestinationPath == NULL ||
			pbstrDestinationFilename == NULL ||
			pbstrDestinationRangeList == NULL)
			ft.Throw(VSSDBG_XML, E_NOTIMPL, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// set restore metadata associated with the component
STDMETHODIMP CVssComponent::SetRestoreMetadata
	(
	IN LPCWSTR wszRestoreMetadata
	)
	{
	UNREFERENCED_PARAMETER(wszRestoreMetadata);
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::SetRestoreMetadata");

	return E_NOTIMPL;
	}

// obtain restore metadata associated with the component
STDMETHODIMP CVssComponent::GetRestoreMetadata
	(
	OUT BSTR *pbstrRestoreMetadata
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetRestoreMetadata");

	try
		{
		VssZeroOut(pbstrRestoreMetadata);

		if (pbstrRestoreMetadata == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// set the restore target
STDMETHODIMP CVssComponent::SetRestoreTarget
	(
	IN VSS_RESTORE_TARGET target
	)
	{
	UNREFERENCED_PARAMETER(target);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::SetRestoreTarget");

	return E_NOTIMPL;
	}

// obtain the restore target
STDMETHODIMP CVssComponent::GetRestoreTarget
	(
	OUT VSS_RESTORE_TARGET *pTarget
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetRestoreTarget");
	try
		{
		VssZeroOut(pTarget);
		if (pTarget == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// set failure message during pre restore event
STDMETHODIMP CVssComponent::SetPreRestoreFailureMsg
	(
	IN LPCWSTR wszPreRestoreFailureMsg
	)
	{
    UNREFERENCED_PARAMETER(wszPreRestoreFailureMsg);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::SetPreRestoreFailureMsg");

	return E_NOTIMPL;
	}


// obtain failure message during pre restore event
STDMETHODIMP CVssComponent::GetPreRestoreFailureMsg
	(
	OUT BSTR *pbstrPreRestoreFailureMsg
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetPreRestoreFailureMsg");
	try
		{
		VssZeroOut(pbstrPreRestoreFailureMsg);

		if (pbstrPreRestoreFailureMsg == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// set the failure message during the post restore event
STDMETHODIMP CVssComponent::SetPostRestoreFailureMsg
	(
	IN LPCWSTR wszPostRestoreFailureMsg
	)
	{
	UNREFERENCED_PARAMETER(wszPostRestoreFailureMsg);
	CVssFunctionTracer(VSSDBG_XML, L"CVssComponent::SetPostRestoreFailureMsg");

	return E_NOTIMPL;
	}

// obtain the failure message set during the post restore event
STDMETHODIMP CVssComponent::GetPostRestoreFailureMsg
	(
	OUT BSTR *pbstrPostRestoreFailureMsg
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetPostRestoreFailureMsg");

	try
		{
		VssZeroOut(pbstrPostRestoreFailureMsg);

		if (pbstrPostRestoreFailureMsg == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft);

	return ft.hr;
	}

// set the backup stamp of the backup
STDMETHODIMP CVssComponent::SetBackupStamp
	(
	IN LPCWSTR wszBackupStamp
	)
	{
	UNREFERENCED_PARAMETER(wszBackupStamp);
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::SetBackupStamp");

	return E_NOTIMPL;
	}

// obtain the stamp of the backup
STDMETHODIMP CVssComponent::GetBackupStamp
	(
	OUT BSTR *pbstrBackupStamp
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetBackupStamp");

	try
		{
		VssZeroOut(pbstrBackupStamp);

		if (pbstrBackupStamp == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		ft.hr = E_INVALIDARG;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// obtain the backup stamp that the differential or incremental
// backup is baed on
STDMETHODIMP CVssComponent::GetPreviousBackupStamp
	(
	OUT BSTR *pbstrBackupStamp
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetPreviousBackupStamp");

	try
		{
		VssZeroOut(pbstrBackupStamp);
		if (pbstrBackupStamp == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// obtain backup options for the writer
STDMETHODIMP CVssComponent::GetBackupOptions
	(
	OUT BSTR *pbstrBackupOptions
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetBackupOptions");

	try
		{
		VssZeroOut(pbstrBackupOptions);
		if (pbstrBackupOptions == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// obtain the restore options
STDMETHODIMP CVssComponent::GetRestoreOptions
	(
	OUT BSTR *pbstrRestoreOptions
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetRestoreOptions");

	try
		{
		VssZeroOut(pbstrRestoreOptions);

		if (pbstrRestoreOptions == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// obtain count of subcomponents to be restored
STDMETHODIMP CVssComponent::GetRestoreSubcomponentCount
	(
	OUT UINT *pcRestoreSubcomponent
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetRestoreSubcomponentCount");

	try
		{
		VssZeroOut(pcRestoreSubcomponent);

		if (pcRestoreSubcomponent == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// obtain a particular subcomponent to be restored
STDMETHODIMP CVssComponent::GetRestoreSubcomponent
	(
	UINT iComponent,
	OUT BSTR *pbstrLogicalPath,
	OUT BSTR *pbstrComponentName,
	OUT bool *pbRepair
	)
	{
	UNREFERENCED_PARAMETER(iComponent);
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetRestoreSubcomponent");

	try
		{
		VssZeroOut(pbstrLogicalPath);
		VssZeroOut(pbstrComponentName);
		VssZeroOut(pbRepair);

		if (pbstrLogicalPath == NULL ||
			pbstrComponentName == NULL ||
			pbRepair == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// obtain whether files were successfully restored
STDMETHODIMP CVssComponent::GetFileRestoreStatus
	(
	OUT VSS_FILE_RESTORE_STATUS *pStatus
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetFileRestoreStatus");

	try
		{
		VssZeroOut(pStatus);

		if (pStatus == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// set backup options for the writer
STDMETHODIMP CVssBackupComponents::SetBackupOptions
	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN LPCWSTR wszBackupOptions
	)
	{
	UNREFERENCED_PARAMETER(writerId);
	UNREFERENCED_PARAMETER(ct);
	UNREFERENCED_PARAMETER(wszLogicalPath);
	UNREFERENCED_PARAMETER(wszComponentName);
	UNREFERENCED_PARAMETER(wszBackupOptions);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::SetBackupOptions");

	return E_NOTIMPL;
	}

// indicate that a given component is selected to be restored
STDMETHODIMP CVssBackupComponents::SetSelectedForRestore
	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN bool bSelectedForRestore
	)
	{
	UNREFERENCED_PARAMETER(writerId);
	UNREFERENCED_PARAMETER(ct);
	UNREFERENCED_PARAMETER(wszLogicalPath);
	UNREFERENCED_PARAMETER(wszComponentName);
	UNREFERENCED_PARAMETER(bSelectedForRestore);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::SetSelectedForRestore");

	return E_NOTIMPL;
	}



// set restore options for the writer
STDMETHODIMP CVssBackupComponents::SetRestoreOptions
	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN LPCWSTR wszRestoreOptions
	)
	{
	UNREFERENCED_PARAMETER(writerId);
	UNREFERENCED_PARAMETER(ct);
	UNREFERENCED_PARAMETER(wszLogicalPath);
	UNREFERENCED_PARAMETER(wszComponentName);
	UNREFERENCED_PARAMETER(wszRestoreOptions);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::SetRestoreOptions");

	return E_NOTIMPL;
	}

// indicate that additional restores will follow
STDMETHODIMP CVssBackupComponents::SetAdditionalRestores
	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN bool bAdditionalRestores
	)
	{
	UNREFERENCED_PARAMETER(writerId);
	UNREFERENCED_PARAMETER(ct);
	UNREFERENCED_PARAMETER(wszLogicalPath);
	UNREFERENCED_PARAMETER(wszComponentName);
	UNREFERENCED_PARAMETER(bAdditionalRestores);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::SetAdditionalRestores");

	return E_NOTIMPL;
	}

// requestor indicates whether files were successfully restored
STDMETHODIMP CVssBackupComponents::SetFileRestoreStatus
	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN VSS_FILE_RESTORE_STATUS status
	)
	{
	UNREFERENCED_PARAMETER(writerId);
	UNREFERENCED_PARAMETER(ct);
	UNREFERENCED_PARAMETER(wszLogicalPath);
	UNREFERENCED_PARAMETER(wszComponentName);
    UNREFERENCED_PARAMETER(status);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::SetFileRestoreStatus");

	return E_NOTIMPL;
	}

// set the backup stamp that the differential or incremental
// backup is based on
STDMETHODIMP CVssBackupComponents::SetPreviousBackupStamp
	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN LPCWSTR wszPreviousBackupStamp
	)
	{
	UNREFERENCED_PARAMETER(writerId);
	UNREFERENCED_PARAMETER(ct);
	UNREFERENCED_PARAMETER(wszLogicalPath);
	UNREFERENCED_PARAMETER(wszComponentName);
	UNREFERENCED_PARAMETER(wszPreviousBackupStamp);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::SetPreviousBackupStamp");

	return E_NOTIMPL;
	}

		
    // add a subcomponent to be restored
STDMETHODIMP CVssBackupComponents::AddRestoreSubcomponent
	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE componentType,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN LPCWSTR wszSubLogicalPath,
	IN LPCWSTR wszSubComponentName,
	IN bool bRepair
	)
	{
	UNREFERENCED_PARAMETER(writerId);
	UNREFERENCED_PARAMETER(componentType);
	UNREFERENCED_PARAMETER(wszLogicalPath);
	UNREFERENCED_PARAMETER(wszComponentName);
	UNREFERENCED_PARAMETER(wszSubLogicalPath);
	UNREFERENCED_PARAMETER(wszSubComponentName);
	UNREFERENCED_PARAMETER(bRepair);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::AddRestoreSubcomponent");

	return E_NOTIMPL;
	}



// signal PreRestore event to the writers
STDMETHODIMP CVssBackupComponents::PreRestore
	(
	OUT IVssAsync **ppAsync
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::PreRestore");

	try
		{
		if (ppAsync == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		*ppAsync = NULL;
		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// called to disable writer classes
STDMETHODIMP CVssBackupComponents::DisableWriterClasses
	(
	IN const VSS_ID *rgWriterClassId,
	IN UINT cClassId
	)
	{
	UNREFERENCED_PARAMETER(rgWriterClassId);
	UNREFERENCED_PARAMETER(cClassId);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::DisableWriterClasses");

	return E_NOTIMPL;
	}



// called to enable specific writer classes.  Note that once specific
// writer classes are enabled, only enabled classes are called.
STDMETHODIMP CVssBackupComponents::EnableWriterClasses
	(
	IN const VSS_ID *rgWriterClassId,
	IN UINT cClassId
	)
	{
	UNREFERENCED_PARAMETER(rgWriterClassId);
	UNREFERENCED_PARAMETER(cClassId);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::EnableWriterClasses");

	return E_NOTIMPL;
	}

// called to disable an event call to a writer instance
STDMETHODIMP CVssBackupComponents::DisableWriterInstances
	(
	IN const VSS_ID *rgWriterInstanceId,
	IN UINT cInstanceId
	)
	{
	UNREFERENCED_PARAMETER(rgWriterInstanceId);
	UNREFERENCED_PARAMETER(cInstanceId);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::DisableWriterInstances");

	return E_NOTIMPL;
	}

// called to expose a snapshot 
STDMETHODIMP CVssBackupComponents::ExposeSnapshot
	(
    IN VSS_ID SnapshotId,
    IN VSS_PWSZ wszPathFromRoot,
    IN LONG lAttributes,
    IN VSS_PWSZ wszExpose,
    OUT VSS_PWSZ *pwszExposed
    )
	{
	UNREFERENCED_PARAMETER(SnapshotId);
	UNREFERENCED_PARAMETER(wszPathFromRoot);
	UNREFERENCED_PARAMETER(lAttributes);
	UNREFERENCED_PARAMETER(wszExpose);
	UNREFERENCED_PARAMETER(pwszExposed);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::ExposeSnapshot");

    BS_ASSERT(false);   // Calling this method in the Client SKU is a bug.
	return E_NOTIMPL;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\backupext\vsxml\vs_wmxml.cxx ===
/*++
Module Name:

    vs_wmxml.cxx

Abstract:

    Implementation of Writer Metadata XML wrapper classes

	Brian Berkowitz  [brianb]  3/13/2000

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    brianb      03/13/2000  Created
    brianb      03/22/2000  Added support CVssGatherWriterMetadata
    brianb	04/04/2000  Removed debug printf
    mikejohn	04/11/2000  Fix some loop iteration problems
    brianb      04/21/2000  code cleanup
    mikejohn	06/13/2000  minor tracing changes

--*/

#include "stdafx.hxx"
#include "vs_inc.hxx"

#include "vs_idl.hxx"
#include "vssmsg.h"

#include "vswriter.h"
#include "vsbackup.h"
#include "vs_wmxml.hxx"
#include "base64coder.h"


#include "rpcdce.h"

#include "wmxml.c"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "BUEWXMLC"
//
////////////////////////////////////////////////////////////////////////

static LPCWSTR x_wszElementRoot = L"root";
static LPCWSTR x_wszElementWriterMetadata = L"WRITER_METADATA";
static LPCWSTR x_wszAttrXmlns = L"xmlns";
static LPCWSTR x_wszValueXmlns = L"x-schema:#VssWriterMetadataInfo";
static LPCWSTR x_wszDocProlog = L"<root>";
static LPCWSTR x_wszDocEpilog = L"</root>";

// identification element and its attributes
static LPCWSTR x_wszElementIdentification = L"IDENTIFICATION";
static LPCWSTR x_wszAttrWriterId = L"writerId";
static LPCWSTR x_wszAttrInstanceId = L"instanceId";
static LPCWSTR x_wszAttrFriendlyName = L"friendlyName";
static LPCWSTR x_wszAttrUsage = L"usage";
static LPCWSTR x_wszAttrDataSource = L"dataSource";

// backup location elements
static LPCWSTR x_wszElementBackupLocations = L"BACKUP_LOCATIONS";
static LPCWSTR x_wszElementIncludeFiles = L"INCLUDE_FILES";
static LPCWSTR x_wszElementExcludeFiles = L"EXCLUDE_FILES";
static LPCWSTR x_wszElementDatabase = L"DATABASE";
static LPCWSTR x_wszElementFilegroup = L"FILE_GROUP";

// RESTORE_METHOD element and it's attributes
static LPCWSTR x_wszElementRestoreMethod = L"RESTORE_METHOD";
static LPCWSTR x_wszAttrMethod = L"method";
static LPCWSTR x_wszAttrService = L"service";
static LPCWSTR x_wszAttrUserProcedure = L"userProcedure";
static LPCWSTR x_wszAttrWriterRestore = L"writerRestore";
static LPCWSTR x_wszAttrRebootRequired = L"rebootRequired";
static LPCWSTR x_wszElementAlternateMapping = L"ALTERNATE_LOCATION_MAPPING";

// attributes and elements associated with DATABASE and FILE_GROUP components
static LPCWSTR x_wszAttrLogicalPath = L"logicalPath";
static LPCWSTR x_wszAttrComponentName = L"componentName";
static LPCWSTR x_wszAttrCaption = L"caption";
static LPCWSTR x_wszAttrRestoreMetadata = L"restoreMetadata";
static LPCWSTR x_wszAttrNotifyOnBackupComplete = L"notifyOnBackupComplete";
static LPCWSTR x_wszAttrIcon = L"icon";
static LPCWSTR x_wszAttrSelectable = L"selectable";
static LPCWSTR x_wszElementDatabaseFiles = L"DATABASE_FILES";
static LPCWSTR x_wszElementDatabaseLogfiles = L"DATABASE_LOGFILES";
static LPCWSTR x_wszElementFilelist = L"FILE_LIST";

// attributes for a FILE_LIST, INCLUDE_FILES, EXCLUDE_FILES,
// or ALTERNATE_DESTINATION_MAPPING elements

static LPCWSTR x_wszAttrPath = L"path";
static LPCWSTR x_wszAttrFilespec = L"filespec";
static LPCWSTR x_wszAttrRecursive = L"recursive";
static LPCWSTR x_wszAttrAlternatePath = L"alternatePath";

// various attributes and values associated with toplevel WRITER_METADATA
// element
static LPCWSTR x_wszAttrVersion = L"version";
static LPCWSTR x_wszVersionNo = L"1.0";

bool CVssExamineWriterMetadata::LoadDocument(BSTR bstrXML)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssExamineWriterMetadata::LoadDocument");

	BSTR bstr = NULL;

	try
		{
		// compute length of supplied XML document
		UINT cwcXML = (UINT) wcslen(bstrXML);

		// compute length of constructed document consisting of
		// a root node, schema, and supplied document
		UINT cwcDoc = cwcXML +
						  (UINT) g_cwcWriterMetadataXML +
                          (UINT) wcslen(x_wszDocProlog) +
                          (UINT) wcslen(x_wszDocEpilog);

        // allocate string
        bstr = SysAllocStringLen(NULL, cwcDoc);

		// check for allocation failure
		if (bstr == NULL)
			ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Couldn't allocate BSTR");

		// setup pointer to beginning of string
		WCHAR *pwc = bstr;

		// copy in <root>
	    wcscpy(pwc, x_wszDocProlog);
		pwc += wcslen(x_wszDocProlog);

		// copy in schema
		memcpy(pwc, g_WriterMetadataXML, g_cwcWriterMetadataXML* sizeof(WCHAR));
		pwc += g_cwcWriterMetadataXML;

		// copy in supplied WRITER_METADATA element
		memcpy(pwc, bstrXML, cwcXML * sizeof(WCHAR));
		pwc += cwcXML;

		// copy in </root>
		wcscpy(pwc, x_wszDocEpilog);

		// load document from string
		bool bLoaded = m_doc.LoadFromXML(bstr);

		// free allocated string
		SysFreeString(bstr);
		bstr = NULL;

		// check load success
		if (!bLoaded)
			return false;

		// find root element
		if (!m_doc.FindElement(x_wszElementRoot, TRUE))
			return false;

		// find WRITER_METADATA element
		if (!m_doc.FindElement(x_wszElementWriterMetadata, TRUE))
			return false;

		// set toplevel node to WRITER_METADATA element
		m_doc.SetToplevel();
		return true;
		}
	catch(...)
		{
		// free allocated string
		if (bstr != NULL)
			SysFreeString(bstr);

		throw;
		}
	}




// initialize metadata document from an XML string.  Return S_FALSE if
// the document is not correctly formed.
bool CVssExamineWriterMetadata::Initialize
	(
	IN BSTR bstrXML					// WRITER_METADATA element
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssExamineWriterMetadata::Initialize");

	// temporary string containing XML document including schema
	InitializeHelper(ft);
	return LoadDocument(bstrXML);
	}

// obtain information from the IDENTIFICATION element
// implements IVssExamineWriterMetadata::GetIdentity
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if either pidInstance, pidWriter, pbstrWriterName, pUsage,
//			or pSource is NULL
//		VSS_CORRUPT_XML_DOCUMENT if the XML document is invalid.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::GetIdentity
	(
	OUT VSS_ID *pidInstance,		// instance id
	OUT VSS_ID *pidWriter,			// id of writer class
	OUT BSTR *pbstrWriterName,		// name of writer
	OUT VSS_USAGE_TYPE *pUsage,		// usage type for writer
	OUT VSS_SOURCE_TYPE *pSource    // type of data source for writer
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::GetIdentity"
		);

	try
		{
        // null output parameters
		if (pUsage)
			*pUsage = VSS_UT_UNDEFINED;

		if (pSource)
			*pSource = VSS_ST_UNDEFINED;

		VssZeroOut(pidInstance);
        VssZeroOut(pidWriter);
        VssZeroOut(pbstrWriterName);

		// check arguments
		if (pidInstance == NULL ||
			pidWriter == NULL ||
			pbstrWriterName == NULL ||
			pUsage == NULL ||
			pSource == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_INVALIDARG,
				L"NULL output parameter."
				);


		CVssSafeAutomaticLock lock(m_csDOM);

		// reposition to top of document
        m_doc.ResetToDocument();

		// look for child IDENTIFICATION element
		if (!m_doc.FindElement(x_wszElementIdentification, TRUE))
			MissingElement(ft, x_wszElementIdentification);

        VSS_ID idInstance;
		VSS_ID idWriter;
		CComBSTR bstrWriterName;
		VSS_USAGE_TYPE usage;
		VSS_SOURCE_TYPE source;


        // obtain instanceId attribute value
        get_VSS_IDValue(ft, x_wszAttrInstanceId, &idInstance);

		// obtain writerId attribute value
        get_VSS_IDValue(ft, x_wszAttrWriterId, &idWriter);

		// obtain friendlyName attribute value
		get_stringValue(x_wszAttrFriendlyName, &bstrWriterName);

        CComBSTR bstrVal;

		// extract usage Attribute value
        if (!m_doc.FindAttribute(x_wszAttrUsage, &bstrVal))
			MissingAttribute(ft, x_wszAttrUsage);

        // convert string value to VSS_USAGE_TYPE
		usage = ConvertToUsageType(ft, bstrVal);
		bstrVal.Empty();

		// extract source attribute value
		if (!m_doc.FindAttribute(x_wszAttrDataSource, &bstrVal))
			MissingAttribute(ft, x_wszAttrDataSource);

        // convert string to VSS_SOURCE_TYPE
		source = ConvertToSourceType(ft, bstrVal);

        // assign output parameters
        *pUsage = usage;
        *pSource = source;
        *pidInstance = idInstance;
        *pidWriter = idWriter;
        *pbstrWriterName = bstrWriterName.Detach();
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}




// get count of components, files to include and files to exclude.
// implements IVssExamineWriterMetadata::GetFileCounts
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pcIncludeFiles, pcExcludeFiles, or pcComponents is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::GetFileCounts
	(
	OUT UINT *pcIncludeFiles,		// count of INCLUDE_FILES elements
	OUT UINT *pcExcludeFiles,		// count of EXCLUDE_FILES elements
	OUT UINT *pcComponents			// count of DATABASE and FILE_GROUP elements
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::GetFileCounts"
		);

	try
		{
		VssZeroOut(pcExcludeFiles);
		VssZeroOut(pcComponents);

        // check output parametrs
		if (pcIncludeFiles == NULL ||
			pcExcludeFiles == NULL ||
			pcComponents == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

        // initalize output parameters
		*pcIncludeFiles = 0;

		CVssSafeAutomaticLock lock(m_csDOM);
        // reposition to top of document
		m_doc.ResetToDocument();
        // position on first BACKUP_LOCATIONS child element
		if (m_doc.FindElement(x_wszElementBackupLocations, TRUE) &&
			m_doc.Next())
			{
			UINT cIncludeFiles = 0;
			UINT cExcludeFiles = 0;
			UINT cComponents = 0;
			do
				{
				// get current node
				CComPtr<IXMLDOMNode> pNode = m_doc.GetCurrentNode();

				DOMNodeType dnt;

				// get node type
				ft.hr = pNode->get_nodeType(&dnt);
				ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_nodeType");

				// if node type is not element, then skip it
				if (dnt != NODE_ELEMENT)
					continue;

				// get node name
				CComBSTR bstrName;
				ft.hr = pNode->get_nodeName(&bstrName);
				ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_nodeName");

				// update counts based on element type
				if (wcscmp(bstrName, x_wszElementIncludeFiles) == 0)
					cIncludeFiles += 1;
				else if (wcscmp(bstrName, x_wszElementExcludeFiles) == 0)
					cExcludeFiles += 1;
				else if (wcscmp(bstrName, x_wszElementDatabase) == 0 ||
						 wcscmp(bstrName, x_wszElementFilegroup) == 0)
					cComponents += 1;
				} while(m_doc.Next(FALSE, FALSE));

			*pcIncludeFiles = cIncludeFiles;
			*pcExcludeFiles = cExcludeFiles;
			*pcComponents = cComponents;
			}
		}
	VSS_STANDARD_CATCH(ft)
	return ft.hr;
	}

// obtain a specific kind of file INCLUDE_FILES or EXCLUDE_FILES
HRESULT CVssExamineWriterMetadata::GetFileType
	(
	CVssFunctionTracer &ft,
	IN UINT iFile,							// which element to extract
	IN LPCWSTR wszFileType,					// which elements to filter
	OUT IVssWMFiledesc **ppFiledesc			// file descriptor
	)
	{
	CVssWMFiledesc *pFiledesc = NULL;
	try
		{
        // check output parameter
		if (ppFiledesc == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

        // null output parameter
        *ppFiledesc = NULL;
		CVssSafeAutomaticLock lock(m_csDOM);

        // reposition to top of document
		m_doc.ResetToDocument();

        // find BACKUP_LOCATIONS element
		if (!m_doc.FindElement(x_wszElementBackupLocations, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"BACKUP_LOCATIONS element was not found."
				);

        // find element type within BACKUP_LOCATIONS
		if (!m_doc.FindElement(wszFileType, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"%s element was not found",
				wszFileType
				);

        // skip to selected element
		for(UINT i = 0; i < iFile; i++)
			{
			if (!m_doc.FindElement(wszFileType, FALSE))
				ft.Throw
					(
					VSSDBG_XML,
					VSS_E_OBJECT_NOT_FOUND,
					L"%s element was not found"
					);
			}

        // construct Filedesc for selected element
		pFiledesc = new CVssWMFiledesc(m_doc.GetCurrentNode());

        // check for allocation failure
		if (pFiledesc == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Can't create CVssWMFiledesc due to allocation failure."
				);

        // 2nd phase of construction
        pFiledesc->Initialize(ft);

		// transfer ownership of pointer
		*ppFiledesc = (IVssWMFiledesc *) pFiledesc;

		// set reference count to 1
		((IVssWMFiledesc *) pFiledesc)->AddRef();

		pFiledesc = NULL;
		}
	VSS_STANDARD_CATCH(ft)

	delete pFiledesc;

	return ft.hr;
	}

// return an INCLUDE_FILES element
// implements IVssExamineWriterMetadata::GetIncludeFile
// caller is responsible for calling IVssWMFiledesc::Release on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL.
//		VSS_E_OBJECT_NOT_FOUND if the specified exclude file doesn't exist
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::GetIncludeFile
	(
	IN UINT iFile,						// which element to select
	OUT IVssWMFiledesc **ppFiledesc		// output constructed Filedesc
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::GetIncludeFile"
		);

    // call helper routine
	return GetFileType(ft, iFile, x_wszElementIncludeFiles, ppFiledesc);
	}


// return an EXCLUDE_FILES element
// implements IVssExamineWriterMetadata::GetExcludeFile
// caller is responsible for calling IVssWMFiledesc::Release on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL.
//		VSS_E_OBJECT_NOT_FOUND if the specified exclude file doesn't exist
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::GetExcludeFile
	(
	IN UINT iFile,
	OUT IVssWMFiledesc **ppFiledesc
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::GetExcludeFile"
		);

	return GetFileType(ft, iFile, x_wszElementExcludeFiles, ppFiledesc);
	}

// obtain a component (DATABASE or FILE_GROUP)
// implements IVssExamineWriterMetadata::GetComponent
// caller is responsible for calling IVssWMComponent::Release on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppComponent is NULL
//		VSS_E_OBJECT_NOT_FOUND if the specified component is not found
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is corrupt
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::GetComponent
	(
	IN UINT iComponent,						// which component to select
	OUT IVssWMComponent **ppComponent		// returned component
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::GetComponent"
		);


	CVssWMComponent *pComponent = NULL;

    try
		{
        // check output parameter
		if (ppComponent == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

        // set output parameter to NULL
        *ppComponent = NULL;


		CVssSafeAutomaticLock lock(m_csDOM);

        // reset position to top of document
		m_doc.ResetToDocument();

        // position on BACKUP_LOCATIONS element
		if (!m_doc.FindElement(x_wszElementBackupLocations, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"BACKUP_LOCATIONS element was not found"
				);

        // position on first child element of BACKUP_LOCATIONS
        if (!m_doc.Next(TRUE, FALSE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"Component was not found"
				);

        // current node
		CComPtr<IXMLDOMNode> pNode = NULL;
		for(UINT i = 0; i <= iComponent; )
			{
			DOMNodeType dnt;

            // obtain current node
            pNode = m_doc.GetCurrentNode();

            // obtain node type
            ft.hr = pNode->get_nodeType(&dnt);
			ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_nodeType");

            // skip node if not an ELEMENT
			if (dnt == NODE_ELEMENT)
				{
                // get element name
				CComBSTR bstrName;
				ft.hr = pNode->get_nodeName(&bstrName);
				ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_nodeName");

                // check that element is a copmonent (either DATABASE
				// or FILE_GROUP)
				if (wcscmp(bstrName, x_wszElementDatabase) == 0 ||
					wcscmp(bstrName, x_wszElementFilegroup) == 0)
					{
                    // increment count of components found and determine
                    // it this is the selected component
					i++;
					if (i > iComponent)
						break;
					}
				}

            // position on next element
			if(!m_doc.Next(FALSE, FALSE))
				ft.Throw
					(
					VSSDBG_XML,
					VSS_E_OBJECT_NOT_FOUND,
					L"Component %d was not found",
                    iComponent
					);
            }


		pComponent = new CVssWMComponent((IXMLDOMNode *) pNode);

        // check for allocation failure
		if (pComponent == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Cannot allocate CVssWMComponent due to allocation failure."
				);

        // 2nd phase of initialization
        pComponent->Initialize(ft);

		// move pointer to output parameter
        *ppComponent = (IVssWMComponent *) pComponent;

		// set reference count to 1.
        ((IVssWMComponent *) pComponent)->AddRef();
		pComponent = NULL;
		}
	VSS_STANDARD_CATCH(ft)

	delete pComponent;

	return ft.hr;
	}


// get RESTORE_METHOD element info.  Return S_FALSE if not found
// implements IVssExamineWriterMetadata::GetRestoreMethod
// caller is responsible for calling SysFreeString on pbstrService
// and pbstrUserProcedure
//
// Returns:
//		S_OK if the operation is successful
//		S_FALSE if there is no restore method
//		E_INVALIDARG if any of the output parameters are NULL.
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::GetRestoreMethod
	(
	OUT VSS_RESTOREMETHOD_ENUM *pMethod,		// method enumeration
	OUT BSTR *pbstrService,						// service name (valid for VSS_RME_STOP_RESTORE_RESTART
	OUT BSTR *pbstrUserProcedure,				// URL/URI to a user procedure to be performed manually
	OUT VSS_WRITERRESTORE_ENUM *pWriterRestore,	// whether writer particpates in the restore
	OUT bool *pbRebootRequired,					// is a reboot after restore required
    OUT UINT *pcMappings						// # of ALTERNATE_LOCATION_MAPPING elements
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::GetRestoreMethod"
		);

	try
		{

        // initialize output parameters
		if (pWriterRestore)
			*pWriterRestore = VSS_WRE_UNDEFINED;

		if (pbRebootRequired)
			*pbRebootRequired = false;

		VssZeroOut(pbstrUserProcedure);
		VssZeroOut(pbstrService);
        VssZeroOut(pcMappings);

        // check output parameters
		if (pMethod == NULL ||
			pbstrService == NULL ||
			pbstrUserProcedure == NULL ||
			pWriterRestore == NULL ||
			pbRebootRequired == NULL ||
            pcMappings == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		*pMethod = VSS_RME_UNDEFINED;


		VSS_RESTOREMETHOD_ENUM method;
		VSS_WRITERRESTORE_ENUM writerRestore;
		CComBSTR bstrUserProcedure;
		CComBSTR bstrService;
		unsigned cMappings = 0;
		bool bRebootRequired;

		CVssSafeAutomaticLock lock(m_csDOM);

        // reposition at top of the document
		m_doc.ResetToDocument();

        // find RESTORE_METHOD element, return S_FALSE if not found
		if (!m_doc.FindElement(x_wszElementRestoreMethod, TRUE))
			ft.hr = S_FALSE;
		else
			{
			// get "method" attribute
			CComBSTR bstrVal = NULL;
			if (!m_doc.FindAttribute(x_wszAttrMethod, &bstrVal))
				MissingAttribute(ft, x_wszAttrMethod);

			// convert string to VSS_RESTOREMETHOD_ENUM
			method = ConvertToRestoreMethod(ft, bstrVal);
			bstrVal.Empty();

			// extract service attribute value
			get_stringValue(x_wszAttrService, &bstrService);

			// extract userProcedure attribute value
			get_stringValue(x_wszAttrUserProcedure, &bstrUserProcedure);

			// extract writerRestore attribute value as a string
			get_stringValue(x_wszAttrWriterRestore, &bstrVal);

			// convert string to VSS_WRITERRESTORE_ENUM
			writerRestore = ConvertToWriterRestore(ft, bstrVal);

			// extract rebootRequired attribute
			get_boolValue(ft, x_wszAttrRebootRequired, &bRebootRequired);

			// get first ALTERNATE_LOCATION_MAPPING elemnent
			if (m_doc.FindElement(x_wszElementAlternateMapping, TRUE))
				{
				// count number of elements
				do
					{
					// increment count of mappings
					cMappings += 1;
					} while(m_doc.FindElement(x_wszElementAlternateMapping, FALSE));
                }

			// assign output parameters
			*pMethod = method;
			*pWriterRestore = writerRestore;
			*pbstrUserProcedure = bstrUserProcedure.Detach();
			*pbstrService = bstrService.Detach();
			*pcMappings = cMappings;
			*pbRebootRequired = bRebootRequired;
			}
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// get a specific alternative location mapping
// implements IVssExamineWriterMetadata::GetAlternateLocationMapping
// caller is responsible for calling IVssWMFiledesc::Release on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL
//		VSS_E_OBJECT_NOT_FOUND if the specified alternate location mapping
//			is not found.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::GetAlternateLocationMapping
	(
	IN UINT iMapping,					// which mapping to extract
	OUT IVssWMFiledesc **ppFiledesc		// file descriptor for mapping
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::GetAlternateLocationMapping"
		);

	CVssWMFiledesc *pFiledesc = NULL;

    try
		{
        // check output parameter
		if (ppFiledesc == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

        // set output parameter to NULL
		*ppFiledesc = NULL;

		CVssSafeAutomaticLock lock(m_csDOM);

        // reposition to top of document
		m_doc.ResetToDocument();

        // find RESTORE_METHOD element
		if (!m_doc.FindElement(x_wszElementRestoreMethod, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"Cannot find RESTORE_METHOD element"
				);

        // find first ALTERNATIVE_LOCATION_MAPPING element
        if (!m_doc.FindElement(x_wszElementAlternateMapping, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"Cannot find ALTERNATE_LOCATION_MAPPING element"
				);

        // search for selected element
		for(UINT i = 0; i < iMapping; i++)
			{
			if (!m_doc.FindElement(x_wszElementAlternateMapping, FALSE))
				ft.Throw
					(
					VSSDBG_XML,
					VSS_E_OBJECT_NOT_FOUND,
					L"Cannot find ALTERNATE_LOCATION_MAPPING element"
					);
            }

		// obtain current node
		CComPtr<IXMLDOMNode> pNode = m_doc.GetCurrentNode();

        // return mapping as a CVssWMFiledesc
		pFiledesc = new CVssWMFiledesc((IXMLDOMNode *) pNode);

        // check for allocation failure
		if (pFiledesc == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Cannot create CVssAlternateLocationMapping due to allocation failure."
				);

		// call 2nd phase of construction
		pFiledesc->Initialize(ft);

		// transfer pointer to output parameter
		*ppFiledesc = (IVssWMFiledesc *) pFiledesc;

		// set reference count to 1
        ((IVssWMFiledesc *) pFiledesc)->AddRef();
		pFiledesc = NULL;
		}
	VSS_STANDARD_CATCH(ft)

	delete pFiledesc;

	return ft.hr;
	}

// obtain the XML document itself
// implements IVssExamineWriterMetadata::GetDocument
// caller is responsible for calling IXMLDOMDocument::Release on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALDARG if ppDoc is NULL.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::GetDocument(IXMLDOMDocument **ppDoc)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssExamineWriterMetadata::GetDocument");

	try
		{
		// validate output parameter
		if (ppDoc == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// set output parameter
		*ppDoc = m_doc.GetInterface();

		BS_ASSERT(*ppDoc);

		// increment reference count on output parameter
		m_doc.GetInterface()->AddRef();
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// save writer metadata as XML string
// implements IVssExamineWriterMetadata::SaveAsXML
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbstrXML is NULL.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::SaveAsXML(BSTR *pbstrXML)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::SaveAsXML"
		);

    try
		{
        // validate output parametr
		if (pbstrXML == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

        // set output parameter to NULL
		*pbstrXML = NULL;

		CVssSafeAutomaticLock lock(m_csDOM);

		// construct XML string
		*pbstrXML = m_doc.SaveAsXML();
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// load document from XLM string
// implements IVssExamineWriterMetadata::LoadFromXML
//
// Returns:
//		S_OK if the operation is successful
//		S_FALSE if the document failed to load.
//		E_INVALIDARG if bstrXML is NULL.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::LoadFromXML(BSTR bstrXML)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::LoadFromXML"
		);

    try
		{
		if (bstrXML == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Required input parameter is NULL.");

		CVssSafeAutomaticLock lock(m_csDOM);
		bool f = LoadDocument(bstrXML);

		ft.hr = f ? S_OK : S_FALSE;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// IUnknown::QueryInterface
STDMETHODIMP CVssExamineWriterMetadata::QueryInterface(REFIID, void **)
	{
	return E_NOTIMPL;
	}

// IUnknown::AddRef
STDMETHODIMP_(ULONG) CVssExamineWriterMetadata::AddRef()
	{
	LONG cRef = InterlockedIncrement(&m_cRef);

	return (ULONG) cRef;
	}

// IUnknown::Release
STDMETHODIMP_(ULONG) CVssExamineWriterMetadata::Release()
	{
	LONG cRef = InterlockedDecrement(&m_cRef);
	BS_ASSERT(cRef >= 0);

	if (cRef == 0)
		{
		// reference count is 0, delete the object
		delete this;
		return 0;
		}
	else
		return (ULONG) cRef;
	}



// return basic information about the component
// implements IVssWMComponent::GetComponentInfo
// caller must call IVssWMComponent::FreeComponentInfo on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppInfo is NULL
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWMComponent::GetComponentInfo(PVSSCOMPONENTINFO *ppInfo)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWMComponent::GetComponentInfo"
		);

	// constructed component info
    VSS_COMPONENTINFO *pInfo = NULL;

    try
		{
        // validate output parameter
		if (ppInfo == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

        // set output parameter to NULL
        *ppInfo = NULL;

        // allocate structure
		pInfo = (VSS_COMPONENTINFO *) CoTaskMemAlloc(sizeof(VSS_COMPONENTINFO));

        // check for allocation failure
		if (pInfo == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Failed to create VSS_COMPONENTINFO"
				);

        // initialize structure
        memset(pInfo, 0, sizeof(*pInfo));

		CVssSafeAutomaticLock lock(m_csDOM);

        // obtain current node
		CComPtr<IXMLDOMNode> pNode = m_doc.GetCurrentNode();

        // get node name
		CComBSTR bstrName = NULL;
		ft.hr = pNode->get_nodeName(&bstrName);
		ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_nodeName");

        // convert string to VSS_COMPONENT_TYPE
        pInfo->type = ConvertToComponentType(ft, bstrName, false);

        // obtain logical path
		get_stringValue(x_wszAttrLogicalPath, &pInfo->bstrLogicalPath);

        // obtain component name
        get_stringValue(x_wszAttrComponentName, &pInfo->bstrComponentName);

        // obtain component description
		get_stringValue(x_wszAttrCaption, &pInfo->bstrCaption);

		CComBSTR bstrIcon;
		if (get_stringValue(x_wszAttrIcon, &bstrIcon))
			{
			Base64Coder coder;
			coder.Decode(bstrIcon);
			UINT cbIcon;
			BYTE *pbIcon = coder.DecodedMessage();
			cbIcon = *(UINT *) pbIcon;
			pInfo->pbIcon = (BYTE *) CoTaskMemAlloc(cbIcon);
			if (pInfo->pbIcon == NULL)
				ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Failed to allocate pbIcon.");

			pInfo->cbIcon = cbIcon;
			memcpy(pInfo->pbIcon, pbIcon + sizeof(UINT), cbIcon);
			}

        // get boolean restoreMetadata attribute value
		get_boolValue(ft, x_wszAttrRestoreMetadata, &pInfo->bRestoreMetadata);

		// get boolean notifyOnBackupComplete attribute value
		get_boolValue(ft, x_wszAttrNotifyOnBackupComplete, &pInfo->bNotifyOnBackupComplete);

		// get boolean selectable attribute value
		get_boolValue(ft, x_wszAttrSelectable, &pInfo->bSelectable);

        // count subElements DATABASE_FILES, DATABASE_LOGFILES, and FILE_LIST

        // descend to first child element

		CXMLDocument doc(m_doc.GetCurrentNode(), m_doc.GetInterface());
		if (doc.Next(TRUE, FALSE))
			{
			do
				{
                // get current node
				CComPtr<IXMLDOMNode> pNode = doc.GetCurrentNode();
				DOMNodeType dnt;

                // determine node type
				ft.hr = pNode->get_nodeType(&dnt);
				ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_nodeType");

                // skip node if not an element
				if (dnt == NODE_ELEMENT)
					{
					CComBSTR bstrName = NULL;

					ft.hr = pNode->get_nodeName(&bstrName);
					ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_nodeName");

                    // update counters based on element type
					if(wcscmp(bstrName, x_wszElementDatabaseFiles) == 0)
						pInfo->cDatabases += 1;
					else if (wcscmp(bstrName, x_wszElementDatabaseLogfiles) == 0)
						pInfo->cLogFiles += 1;
					else if (wcscmp(bstrName, x_wszElementFilelist) == 0)
						pInfo->cFileCount += 1;
					}
				} while (doc.Next(FALSE, FALSE));
            }

        // set output parameter
		*ppInfo = pInfo;
		}
	VSS_STANDARD_CATCH(ft);

    // free structure if there is any failure
	if (FAILED(ft.hr) && pInfo != NULL)
		FreeComponentInfo(pInfo);

	return ft.hr;
	}

// free up component info structure
// implements IVssWMComponent::FreeComponentInfo
// frees information returned by IVssWMComponent::GetComponentInfo
//
// Returns:
//		S_OK if the operation is successful

STDMETHODIMP CVssWMComponent::FreeComponentInfo(PVSSCOMPONENTINFO pInfoC)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssWMComponent::FreeComponentInfo");

	VSS_COMPONENTINFO *pInfo = (VSS_COMPONENTINFO *) pInfoC;

	if (pInfo != NULL)
		{
		try
			{
			if (pInfo->bstrLogicalPath)
				{
				SysFreeString(pInfo->bstrLogicalPath);
				pInfo->bstrLogicalPath = NULL;
				}

			if (pInfo->bstrComponentName)
				{
				SysFreeString(pInfo->bstrComponentName);
				pInfo->bstrComponentName = NULL;
				}

			if (pInfo->bstrCaption)
				{
				SysFreeString(pInfo->bstrCaption);
				pInfo->bstrCaption = NULL;
				}

			if (pInfo->pbIcon)
				{
				CoTaskMemFree(pInfo->pbIcon);
				pInfo->pbIcon = NULL;
				}

			CoTaskMemFree(pInfo);
			}
		VSS_STANDARD_CATCH(ft)
		}

	return ft.hr;
	}

// obtain a FILE_LIST element
// implements IVssWMComponent::GetFile
// caller must call IVssWMFiledesc::Release on the output parameter.
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL.
//		VSS_E_OBJECT_NOT_FOUND if specified log file is not found
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWMComponent::GetFile
	(
	IN UINT iFile,						// selected file in file group
	OUT IVssWMFiledesc **ppFiledesc		// output file descriptor
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWMComponent::GetFile"
		);

	return GetComponentFile(ft, x_wszElementFilelist, iFile, ppFiledesc);
	}

// obtain a DATABASE_FILES element
// implements IVssWMComponent::GetDatabaseFile
// caller must call IVssWMFiledesc::Release on the output parameter.
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL.
//		VSS_E_OBJECT_NOT_FOUND if specified log file is not found
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWMComponent::GetDatabaseFile
	(
	IN UINT iDBFile,					// selected DATABASE_FILE element in DATABASE
	OUT IVssWMFiledesc **ppFiledesc		// output file descriptor
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWMComponent::GetDatabaseFile"
		);

	return GetComponentFile(ft, x_wszElementDatabaseFiles, iDBFile, ppFiledesc);
	}

// obtain a DATABASE_LOGFILES element
// implements IVssWMComponent::GetDatabaseLogFile
// caller must call IVssWMFiledesc::Release on the output parameter.
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL.
//		VSS_E_OBJECT_NOT_FOUND if specified log file is not found
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWMComponent::GetDatabaseLogFile
	(
	IN UINT iDbLogFile,					// selected DATABASE_LOG_FILE element in DATABASE
	OUT IVssWMFiledesc **ppFiledesc		// output file descriptor
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWMComponent::GetDatabaseLogFile"
		);

	return GetComponentFile(ft, x_wszElementDatabaseLogfiles, iDbLogFile, ppFiledesc);
	}

// obtain a DATABASE_FILES, DATABASE_LOGFILES or FILE_LIST element
// internal function used by GetDatabaseFile, GetDatabaseLogFile, and GetFile
HRESULT CVssWMComponent::GetComponentFile
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszElementName,			// element to retrieve DATABASE_FILE, DATABASE_LOG_FILE, or FILE_LIST
	IN UINT iFile,						// which element to retrieve
	OUT IVssWMFiledesc **ppFiledesc		// output file descriptor
	)
	{

	CVssWMFiledesc *pFiledesc = NULL;

	try
		{
        // validate output parameter
		if (ppFiledesc == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

        // initialize output parameter
		*ppFiledesc = NULL;

		CVssSafeAutomaticLock lock(m_csDOM);

        // reposition to top of component
		m_doc.ResetToDocument();

        // find first child element
		if (!m_doc.FindElement(wszElementName, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"Cannot find %s element",
				wszElementName
				);

        // skip to selected element
        for(UINT i = 0; i < iFile; i++)
			{
			if (!m_doc.FindElement(wszElementName, FALSE))
				ft.Throw
					(
					VSSDBG_XML,
					VSS_E_OBJECT_NOT_FOUND,
					L"Cannot find element %s.",
					wszElementName
					);
            }

        // get selected element
		CComPtr<IXMLDOMNode> pNode = m_doc.GetCurrentNode();

	
        // create CVssWMFiledesc from selected element
		pFiledesc = new CVssWMFiledesc((IXMLDOMNode *) pNode);

        // check for allocation failure
		if (pFiledesc == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Cannot create CVssWMFiledesc due to allocation failure."
				);

		// 2nd phase of construction
		pFiledesc->Initialize(ft);

		// transfer pointer
		*ppFiledesc = (IVssWMFiledesc *) pFiledesc;

		// set reference count to 1
        ((IVssWMFiledesc *) pFiledesc)->AddRef();
		pFiledesc = NULL;
		}
	VSS_STANDARD_CATCH(ft)

	delete pFiledesc;

	return ft.hr;
	}

// IUnknown::QueryInterface
STDMETHODIMP CVssWMComponent::QueryInterface(REFIID, void **)
	{
	return E_NOTIMPL;
	}

// IUnknown::AddRef
STDMETHODIMP_(ULONG) CVssWMComponent::AddRef()
	{
	LONG cRef = InterlockedIncrement(&m_cRef);

	return (ULONG) cRef;
	}

// IUnknown::Release
STDMETHODIMP_(ULONG) CVssWMComponent::Release()
	{
	LONG cRef = InterlockedDecrement(&m_cRef);
	BS_ASSERT(cRef >= 0);
	if (cRef == 0)
		{
		// reference count is 0, delete the object
		delete this;
		return 0;
		}
	else
		return cRef;
	}


// obtain path attribute
// implements IVssWMFiledesc::GetPath
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbstrPath is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWMFiledesc::GetPath(OUT BSTR *pbstrPath)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWMFiledesc::GetPath"
		);

    CVssSafeAutomaticLock lock(m_csDOM);
    return GetStringAttributeValue(ft, x_wszAttrPath, false, pbstrPath);
	}

// obtain filespec attribute
// implements IVssWMFiledesc::GetFilespec
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbstrFilespec is NULL
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWMFiledesc::GetFilespec(OUT BSTR *pbstrFilespec)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWMFiledesc::GetFilespec"
		);

    CVssSafeAutomaticLock lock(m_csDOM);
    return GetStringAttributeValue(ft, x_wszAttrFilespec, true, pbstrFilespec);
	}

// obtain recursive attribute
// implements IVssWMFiledesc::GetRecursive
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbRecursive is NULL
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWMFiledesc::GetRecursive(OUT bool *pbRecursive)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWMFiledesc::GetRecursive"
		);

    CVssSafeAutomaticLock lock(m_csDOM);
    return GetBooleanAttributeValue(ft, x_wszAttrRecursive, false, pbRecursive);
	}

// obtain alternatePath attribute
// implements IVssWMFiledesc::GetAlternateLocation
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbstrAlternateLocation is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWMFiledesc::GetAlternateLocation(OUT BSTR *pbstrAlternateLocation)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWMFiledesc::GetAlternateLocation"
		);


    CVssSafeAutomaticLock lock(m_csDOM);
	return GetStringAttributeValue(ft, x_wszAttrAlternatePath, false, pbstrAlternateLocation);
	}

// IUnknown::QueryInterface
STDMETHODIMP CVssWMFiledesc::QueryInterface(REFIID, void **)
	{
	return E_NOTIMPL;
	}

// IUnknown::AddRef
STDMETHODIMP_(ULONG) CVssWMFiledesc::AddRef()
	{
	LONG cRef = InterlockedIncrement(&m_cRef);

	return (ULONG) cRef;
	}

// IUnknown::Release
STDMETHODIMP_(ULONG) CVssWMFiledesc::Release()
	{
	LONG cRef = InterlockedDecrement(&m_cRef);
	BS_ASSERT(cRef >= 0);

	if (cRef == 0)
		{
		// reference count is 0, delete the object
		delete this;
		return 0;
		}
	else
		return (ULONG) cRef;
	}


// initialize the document by creating a toplevel WRITER_METADATA and
// child IDENTIFICATION element
// implemetns IVssCreateWriterMetadata::Initialize
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if usage or source are invalid or if wszFriendlyName is NULL.
//		E_OUTOFMEMORY if an allocation failure occurs

HRESULT CVssCreateWriterMetadata::Initialize
	(
	IN VSS_ID idInstance,				// GUID of instance
	IN VSS_ID idWriter,					// GUID of writer class
	IN LPCWSTR wszFriendlyName,			// friendly name of writer
	IN VSS_USAGE_TYPE usage,			// usage attribute
	IN VSS_SOURCE_TYPE source			// source attribute
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::Initialize"
		);

    try
		{
		LPCWSTR wszUsage;
		LPCWSTR wszSource;

        // validate input argument
		if (wszFriendlyName == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL string input parameter");

        wszUsage = WszFromUsageType(ft, usage);
        wszSource = WszFromSourceType(ft, source);
		CXMLDocument doc;

		InitializeHelper(ft);

		CVssSafeAutomaticLock lock(m_csDOM);

		m_doc.Initialize();
		CXMLNode nodeDoc(m_doc.GetInterface(), m_doc.GetInterface());

        // create toplevel WRITER_METADATA node
		CXMLNode nodeTop = m_doc.CreateNode
							(
							x_wszElementWriterMetadata,
							NODE_ELEMENT
							);

		// setup schema attribute
		nodeTop.SetAttribute(x_wszAttrXmlns, x_wszValueXmlns);

        // setup version attribute
		nodeTop.SetAttribute(x_wszAttrVersion, x_wszVersionNo);

        // create IDENTIFICATION node
		CXMLNode nodeId = m_doc.CreateNode
							(
							x_wszElementIdentification,
							NODE_ELEMENT
							);

        // set writerId attribute
		nodeId.SetAttribute(x_wszAttrWriterId, idWriter);

        // set instanceId attribue
		nodeId.SetAttribute(x_wszAttrInstanceId, idInstance);

        // set friendlyName attribute
		nodeId.SetAttribute(x_wszAttrFriendlyName, wszFriendlyName);

        // set usage attribute
		nodeId.SetAttribute(x_wszAttrUsage, wszUsage);

        // set dataSource attribute
		nodeId.SetAttribute(x_wszAttrDataSource, wszSource);

		// insert identification node in toplevel node
		nodeTop.InsertNode(nodeId);

		// insert toplevel node in document and set it as
		// the toplevel node for navigation purposes
		CXMLNode nodeToplevel = nodeDoc.InsertNode(nodeTop);
        m_doc.SetToplevelNode(nodeToplevel);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// add an INCLUDE_FILES element
// implements IVssCreateWriterMetadata::AddIncludeFiles
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wszPath or wszFilespec is NULL.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::AddIncludeFiles
	(
	IN LPCWSTR wszPath,						// path to root directory
	IN LPCWSTR wszFilespec,					// file specification
	IN bool bRecursive,						// is entire subtree or just directory included
	IN LPCWSTR wszAlternateLocation			// alternate location
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::AddIncludeFiles"
		);

    try
		{
        // validate input parameters
		if (wszPath == NULL || wszFilespec == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

		CVssSafeAutomaticLock lock(m_csDOM);

        // create/obtain BACKUP_LOCATIONS element
		CXMLNode nodeBackupLocations = GetBackupLocationsNode();

        // create child INCLUDE_FILES element
		CXMLNode nodeInclude = m_doc.CreateNode
								(
								x_wszElementIncludeFiles,
								NODE_ELEMENT
								);

        // set path attribute
		nodeInclude.SetAttribute(x_wszAttrPath, wszPath);

		// set filespec attribute
		nodeInclude.SetAttribute(x_wszAttrFilespec, wszFilespec);

		// set recursive attribute
		nodeInclude.SetAttribute
			(
			x_wszAttrRecursive,
			WszFromBoolean(bRecursive)
			);

        // set alternatePath attribute if specified
		if (wszAlternateLocation)
			nodeInclude.SetAttribute(x_wszAttrAlternatePath, wszAlternateLocation);

		// insert INCLUDE_FILES node in BACKUP_LOCATIONS node
		nodeBackupLocations.InsertNode(nodeInclude);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// add an EXCLUDE_FILES element
// implements IVssCreateWriterMetadata::AddExcludeFiles
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wszPath or wszFilespec is NULL.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::AddExcludeFiles
	(
	IN LPCWSTR wszPath,
	IN LPCWSTR wszFilespec,
	IN bool bRecursive
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::AddExcludeFiles"
		);

    try
		{
        // validate input parameters
		if (wszPath == NULL || wszFilespec == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");


		CVssSafeAutomaticLock lock(m_csDOM);

        // create/obtain the BACKUP_LOCATIONS eleement
		CXMLNode nodeBackupLocations = GetBackupLocationsNode();

        // add an EXCLUDE_FILES element
		CXMLNode nodeExclude = m_doc.CreateNode
								(
								x_wszElementExcludeFiles,
								NODE_ELEMENT
								);

		// set path attribute
		nodeExclude.SetAttribute(x_wszAttrPath, wszPath);

		// set filespec attribute
		nodeExclude.SetAttribute(x_wszAttrFilespec, wszFilespec);

		// set recursive attribute
		nodeExclude.SetAttribute
			(
			x_wszAttrRecursive,
			WszFromBoolean(bRecursive)
			);

		// insert EXCLUDE_FILES node in BACKUP_LOCATIONS node
		nodeBackupLocations.InsertNode(nodeExclude);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// internal routine to find or create the BACKUP_LOCATIONS element
// caller should have helper DOM locked
CXMLNode CVssCreateWriterMetadata::GetBackupLocationsNode()
	{
    // reposition to top of document
	m_doc.ResetToDocument();

	CXMLNode nodeTop(m_doc.GetCurrentNode(), NULL);

    // find BACKUP_LOCATIONS element.  If it exists return it
	if (m_doc.FindElement(x_wszElementBackupLocations, TRUE))
		return CXMLNode(m_doc.GetCurrentNode(), m_doc.GetInterface());

    // create BACKUP_LOCATIONS element under WRITER_METADATA element
	CXMLNode node = m_doc.CreateNode
						(
						x_wszElementBackupLocations,
						NODE_ELEMENT
						);

	return nodeTop.InsertNode(node);
	}

// create a component
// implements IVssCreateWriterMetadata::AddComponent
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wszComponentName is NULL or the specified component type is invalid.
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is cortup.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::AddComponent
	(
	IN VSS_COMPONENT_TYPE ct,			// either VSS_CT_DATABASE or VSS_CT_FILEGROUP
	IN LPCWSTR wszLogicalPath,			// logical path to component
	IN LPCWSTR wszComponentName,		// component name
	IN LPCWSTR wszCaption,				// description of component
	IN const BYTE * pbIcon,				// icon
	IN UINT cbIcon,						// size of icon
	IN bool bRestoreMetadata,			// is restore metadata supplied
	IN bool bNotifyOnBackupComplete,	// does writer expect to be notified on BackupComplete
	IN bool bSelectable					// is component selectable
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::AddComponent"
		);

    try
		{
        // validate required input parameter
		if (wszComponentName == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

        // determine element name from the component type
		LPCWSTR wszElement;
        wszElement = WszFromComponentType(ft, ct, false);

		CVssSafeAutomaticLock lock(m_csDOM);

        // obtain BACKUP_LOCATIONS node, creating it if necessary.
		CXMLNode nodeBackupLocations = GetBackupLocationsNode();
        CXMLDocument doc(nodeBackupLocations);

		// find element type (either DATABASE or FILE_GROUP)
        if (doc.FindElement(wszElement, TRUE))
            {
            do
                {
                CComBSTR bstrLogicalPath;
				CComBSTR bstrComponentName;

				// extract logicalPath attribute
                bool bLogicalPath = doc.FindAttribute(x_wszAttrLogicalPath, &bstrLogicalPath);

				// extract componentName attribute
                if (!doc.FindAttribute(x_wszAttrComponentName, &bstrComponentName))
					MissingAttribute(ft, x_wszAttrComponentName);

                // if duplicate comonent is found then throw an error
                if (wcscmp(wszComponentName, bstrComponentName) == 0 &&
                    ((bLogicalPath &&
                      wszLogicalPath &&
                      wcscmp(wszLogicalPath, bstrLogicalPath) == 0) ||
                     (!bstrLogicalPath &&
                      (wszLogicalPath == NULL || wcslen(wszLogicalPath) == 0))))
                    ft.Throw
                        (
                        VSSDBG_XML,
						VSS_E_OBJECT_ALREADY_EXISTS,
                        L"Component %s already exists",
                        wszComponentName
                        );
                } while(doc.FindElement(wszElement, FALSE));
            }


        // create component node
		CXMLNode node = m_doc.CreateNode
								(
								wszElement,
								NODE_ELEMENT
								);


        // set logicalPath attribute if exists
        if (wszLogicalPath)
			node.SetAttribute(x_wszAttrLogicalPath, wszLogicalPath);

        // set componetName attribute
		node.SetAttribute(x_wszAttrComponentName, wszComponentName);

        // set caption element if it exists
		if (wszCaption)
			node.SetAttribute(x_wszAttrCaption, wszCaption);

        // set icon attribute if it exists
		if (pbIcon != NULL && cbIcon > 0)
			{
			Base64Coder coder;
			coder.Encode(pbIcon, cbIcon);
			node.SetAttribute(x_wszAttrIcon, coder.EncodedMessage());
			}

        // set restoreMetadata flags
		node.SetAttribute
			(
			x_wszAttrRestoreMetadata,
			WszFromBoolean(bRestoreMetadata)
			);


        // set notifyOnBackupComplete flag
		node.SetAttribute
			(
			x_wszAttrNotifyOnBackupComplete,
			WszFromBoolean(bNotifyOnBackupComplete)
			);

        // set selectable attribute
		node.SetAttribute
			(
			x_wszAttrSelectable,
			WszFromBoolean(bSelectable)
			);

		// insert component node under BACKUP_LOCATIONS node
		nodeBackupLocations.InsertNode(node);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// create DATABASE_FILES element
// implements IVssCreateWriterMetadata::AddDatabaseFile
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wszDatabaseName, wszPath, or wszFilespec is NULL.
//		VSS_E_OBJECT_NOT_FOUND if the specified component doesn't exist
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is cortup.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::AddDatabaseFiles
	(
	IN LPCWSTR wszLogicalPath,			// logical path name of component
	IN LPCWSTR wszDatabaseName,			// add database name
	IN LPCWSTR wszPath,					// add path name
	IN LPCWSTR wszFilespec				// add file specification
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::AddDatabaseFiles"
		);

    // call internal routine to do the work
	return CreateComponentFiles
			(
			ft,
			x_wszElementDatabase,
			wszLogicalPath,
			wszDatabaseName,
			x_wszElementDatabaseFiles,
			wszPath,
			wszFilespec,
			false,
			NULL
			);
	}


// create a DATABASE_FILES, DATABASE_LOGFILES or FILE_LIST element under
// a component
// internal routine used by AddDatabaseFiles, AddFiles, and AddDatabaseLogFiles
HRESULT CVssCreateWriterMetadata::CreateComponentFiles
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszElement,			// element name (DATABASE or FILE_GROUP)
	IN LPCWSTR wszLogicalPath,		// logical path of component
	IN LPCWSTR wszComponentName,	// component name	
	IN LPCWSTR wszElementFile,		// element name (DATABASE_FILES, DATABASE_LOGFILES, FILELIST)
	IN LPCWSTR wszPath,				// path to root directory containing files
	IN LPCWSTR wszFilespec,			// file specification
	IN bool bRecursive,				// include subtree or just root directory
	IN LPCWSTR wszAlternateLocation	// alternate location for files
	)
	{
    try
        {
		// validate input parameters
        if (wszElement == NULL ||
            wszComponentName == NULL ||
            wszPath == NULL ||
            wszElementFile == NULL ||
            wszFilespec == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");


		// validate element consistency
        if ((wcscmp(wszElement, x_wszElementDatabase) == 0 &&
             wcscmp(wszElementFile, x_wszElementDatabaseFiles) != 0 &&
             wcscmp(wszElementFile, x_wszElementDatabaseLogfiles) != 0) ||
            (wcscmp(wszElement, x_wszElementFilegroup) == 0 &&
             wcscmp(wszElementFile, x_wszElementFilelist) != 0))
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Invalid element type");

		CVssSafeAutomaticLock lock(m_csDOM);

        // reposition to top of document
        m_doc.ResetToDocument();

        // find BACKUP_LOCATIONS element
        if (!m_doc.FindElement(x_wszElementBackupLocations, TRUE))
			ft.Throw
			    (
                VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
                L"BackupLocations element is missing"
                );

        // find first component of the right type
        if (!m_doc.FindElement(wszElement, TRUE))
            ft.Throw
			    (
                VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
                L"Component %s::%s was not created",
                wszElement,
                wszComponentName
                );

        // look for matching component
        bool bFound = false;
        do
            {
            CComBSTR bstrLogicalPath;
            CComBSTR bstrComponentName;

			// extract logical path
            bool fLogicalPath = m_doc.FindAttribute(x_wszAttrLogicalPath, &bstrLogicalPath);

			// extract component name
            if (!m_doc.FindAttribute(x_wszAttrComponentName, &bstrComponentName))
				MissingAttribute(ft, x_wszAttrComponentName);

            // compare logical path if it exists
            if (wszLogicalPath != NULL && fLogicalPath)
                {
				// compare logical path
                if (wcscmp(wszLogicalPath, bstrLogicalPath) != 0)
                    continue;
                }
            else if (wszLogicalPath == NULL &&
                     fLogicalPath &&
                     wcslen(bstrLogicalPath) > 0)
                // logical path in document but component we are searching
				// for has no logical path, skip this one
			    continue;
            else if (wszLogicalPath != NULL && wcslen(wszLogicalPath) > 0)
				// logical path we are searching for is specified but
				// there is no logical path in the document
                continue;

            // if component name matches then we found target component,
			// otherwise move to next component
            if (wcscmp(bstrComponentName, wszComponentName) == 0)
                {
                bFound = true;
                break;
                }
            } while(m_doc.FindElement(wszElement, FALSE));

        // return error if component is not found
        if (!bFound)
            ft.Throw
			    (
                VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
                L"Component %s::%s was not created",
                wszElement,
                wszComponentName
                );


        // use component node as parent node
        CXMLNode nodeComponent(m_doc.GetCurrentNode(), m_doc.GetInterface());

        // create child node of the component
        CXMLNode node = m_doc.CreateNode
						(
						wszElementFile,
						NODE_ELEMENT
						);

        // set path attribute
        node.SetAttribute(x_wszAttrPath, wszPath);

		// set filespec attribute
        node.SetAttribute(x_wszAttrFilespec, wszFilespec);
		
		// set recursive attribute if it is Yes
		if (bRecursive)
			node.SetAttribute
				(
				x_wszAttrRecursive,
				WszFromBoolean(bRecursive)
				);

        if (wszAlternateLocation)
			node.SetAttribute(x_wszAttrAlternatePath, wszAlternateLocation);

		// insert file element under component node
		nodeComponent.InsertNode(node);
        }	
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}


// add a log file specification to a database component
// implements IVssCreateWriterMetadata::AddDatabaseLogFiles
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wszDatabaseName is NULL, wszPath is NULL, or wszFilespec is NULL.
//		VSS_E_OBJECT_NOT_FOUND if the specified component doesn't exist
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is cortup.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::AddDatabaseLogFiles
	(
	IN LPCWSTR wszLogicalPath,			// logical path of database
	IN LPCWSTR wszDatabaseName,			// database name
	IN LPCWSTR wszPath,					// path to directory containing log files
	IN LPCWSTR wszFilespec				// file specification of log files
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::AddDatabaseLogFiles"
		);

    // call internal routine to do the work
    return CreateComponentFiles
			(
			ft,
			x_wszElementDatabase,
			wszLogicalPath,
			wszDatabaseName,
			x_wszElementDatabaseLogfiles,
			wszPath,
			wszFilespec,
			false,
			NULL
			);
	}


// add files to a file group
// implements IVssCreateWriterMetadata::AddFilesToFileGroup
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wszGroupName is NULL, wszPath is NULL, wszFilespec is NULL.
//		VSS_E_OBJECT_NOT_FOUND if the specified component doesn't exist
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is cortup.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::AddFilesToFileGroup
	(
	IN LPCWSTR wszLogicalPath,		// logical path of file group
	IN LPCWSTR wszGroupName,		// group name	
	IN LPCWSTR wszPath,				// path to root directory containing the files
	IN LPCWSTR wszFilespec,			// file specification of the files included in the file group
	IN bool bRecursive,				// are files in the subtree included or just in the directory
	IN LPCWSTR wszAlternateLocation	// alternate location for files in the file group
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::AddFilesToFileGroup"
		);

    // call internal routine to do the work
	return CreateComponentFiles
			(
			ft,
			x_wszElementFilegroup,
			wszLogicalPath,
			wszGroupName,
			x_wszElementFilelist,
			wszPath,
			wszFilespec,
			bRecursive,
			wszAlternateLocation
			);
	}

// create restore method
// implements IVssCreateWriterMetadata::SetRestoreMethod
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if method is invalid, writerRestore is invalid,
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::SetRestoreMethod
	(
	IN VSS_RESTOREMETHOD_ENUM method,		// method
	IN LPCWSTR wszService,					// service name, if method is VSS_RME_STOP_RESTORE_RESTART
	IN LPCWSTR wszUserProcedure,			// uri/url of manual instructions for user to follow to do the restore
	IN VSS_WRITERRESTORE_ENUM writerRestore, // is writer involved in the restore process
	IN bool bRebootRequired
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::SetRestoreMethod"
		);

    try
		{
		// convert VSS_RESTORMETHOD_ENUM to string
		// validate it as well
		LPCWSTR wszMethod = WszFromRestoreMethod(ft, method);

		// convert VSS_WRITERRESTORE_ENUM to string
		// validate it as well
		LPCWSTR wszWriterRestore = WszFromWriterRestore(ft, writerRestore);

		CVssSafeAutomaticLock lock(m_csDOM);

        // reposition to top of document
        m_doc.ResetToDocument();

		// set parent node as WRITER_METADATA node
		CXMLNode nodeTop(m_doc.GetCurrentNode(), m_doc.GetInterface());

		// if RESTORE_METHOD element exists, then return an error
		if (m_doc.FindElement(x_wszElementRestoreMethod, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_ALREADY_EXISTS,
				L"RESTORE_METHOD element already exists."
				);

        // create RESTORE_METHOD node as child of WRITER_METADATA node
		CXMLNode node = m_doc.CreateNode
							(
							x_wszElementRestoreMethod,
							NODE_ELEMENT
							);

        // set method attribute
        node.SetAttribute(x_wszAttrMethod, wszMethod);

		// set service attribute if supplied
		if (wszService)
			node.SetAttribute(x_wszAttrService, wszService);

		// set userProcedure attribute if supplied
		if (wszUserProcedure)
			node.SetAttribute(x_wszAttrUserProcedure, wszUserProcedure);

		// set writerRestore attribute
		node.SetAttribute(x_wszAttrWriterRestore, wszWriterRestore);

		// set rebootRequired attribute
		node.SetAttribute(x_wszAttrRebootRequired, WszFromBoolean(bRebootRequired));

		// insert RESTORE_METHOD node under toplevel node
		nodeTop.InsertNode(node);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// add alternate location mapping
// implements IVssCreateWriterMetadata::AddAlternateLocationMapping
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wszSourcePath, wszSourceFiledesc, or wszDestination is NULL.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::AddAlternateLocationMapping
	(
	IN LPCWSTR wszSourcePath,			// path to source root directory
	IN LPCWSTR wszSourceFilespec,		// file specification
	IN bool bRecursive,					// are files in the subtree relocated or just files in the directory	
	IN LPCWSTR wszDestination			// new location of root directory
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::AddAlternateLocationMapping"
		);
    try
        {
        // validate input parameters
		if (wszSourcePath == NULL ||
			wszSourceFilespec == NULL ||
			wszDestination == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

		CVssSafeAutomaticLock lock(m_csDOM);

        // reposition to top of document
		m_doc.ResetToDocument();

        // find RESTORE_METHOD element
		if (!m_doc.FindElement(x_wszElementRestoreMethod, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"RESTORE_METHOD element is not defined."
				);

        // set parent node as RESTORE_METHOD element
        CXMLNode nodeRM(m_doc.GetCurrentNode(), m_doc.GetInterface());

        // create ALTERNATE_LOCATION_MAPPING element to
		// RESTORE_METHOD element
		CXMLNode node = m_doc.CreateNode
							(
							x_wszElementAlternateMapping,
							NODE_ELEMENT
							);

		// set path attribute					
        node.SetAttribute(x_wszAttrPath, wszSourcePath);

		// add filespec attributte
		node.SetAttribute(x_wszAttrFilespec, wszSourceFilespec);

		// set alternatePath attribute
		node.SetAttribute(x_wszAttrAlternatePath, wszDestination);

		// set recursive attribute
		node.SetAttribute(x_wszAttrRecursive, WszFromBoolean(bRecursive));

		// insert ALTERNATE_LOCATION_MAPPING node under RESTORE_METHOD node
		nodeRM.InsertNode(node);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// obtain the XML document itself
// implements IVssCreateWriterMetadata::GetDocument
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppDoc is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::GetDocument(IXMLDOMDocument **ppDoc)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssCreateWriterMetadata::GetDocument");

	try
		{
		// validate output parameter
		if (ppDoc == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// get IXMLDOMDocument interface
		*ppDoc = m_doc.GetInterface();

		// increment reference count on interface
		m_doc.GetInterface()->AddRef();
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// save WRITER_METADATA document as XML string
// implements IVssCreateWriterMetadata::SaveAsXML
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbstrXML is NULL.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::SaveAsXML(BSTR *pbstrXML)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::SaveAsXML"
		);

    try
		{
        // validate output parameter
		if (pbstrXML == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

        // initialize output paramter
		*pbstrXML = NULL;

		CVssSafeAutomaticLock lock(m_csDOM);

		// construct string from document
		*pbstrXML = m_doc.SaveAsXML();
		}
	VSS_STANDARD_CATCH(ft);

	return ft.hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\comadmin\comadmin.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module COMAdmin.cxx | Simple wrapper around COM Admin classes
    @end

Author:

    Adi Oltean  [aoltean]  08/15/1999

TBD:

    Add comments.

Revision History:

    Name        Date        Comments
    aoltean     08/15/1999  Created.
    aoltean     09/09/1999  dss -> vss
	aoltean		09/21/1999	Fixing VSSDBG_GEN.

--*/


/////////////////////////////////////////////////////////////////////////////
// Defines

// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)

// C4127: conditional expression is constant
#pragma warning( disable: 4127 )


#define STRICT

/////////////////////////////////////////////////////////////////////////////
// Includes

#include <wtypes.h>
#include <stddef.h>
#include <oleauto.h>

#include "vs_assert.hxx"

#include <atlconv.h>
#include <atlbase.h>
#include <comadmin.h>
#include <vs_sec.hxx>

#include "vssmsg.h"

#include "vs_inc.hxx"
#include "vs_idl.hxx"


#include "comadmin.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CADCADMC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Globals


// Collection attributes - TBD: Verify if Keys are OK!!
struct _VsCOMCollectionAttr g_VsCOMCollectionsArray[] =
{
    { L"",                       L"",            L"",          },   // VSS_COM_UNKNOWN = 0,
    { L"ApplicationCluster",     L"Name",        L"Name",      },   // VSS_COM_APPLICATION_CLUSTER,
    { L"Applications",           L"ID",          L"Name",      },   // VSS_COM_APPLICATIONS,
    { L"Components",             L"CLSID",       L"ProgID",    },   // VSS_COM_COMPONENTS,
    { L"ComputerList",           L"Name",        L"Name",      },   // VSS_COM_COMPUTERLIST,
    { L"DCOMProtocols",          L"Name",        L"Name",      },   // VSS_COM_DCOM_PROTOCOLS,
    { L"ErrorInfo",              L"MajorRef",    L"MajorRef",  },   // VSS_COM_ERRORINFO,
    { L"IMDBDataSources",        L"DataSource",  L"DataSource",},   // VSS_COM_IMDB_DATA_SOURCES,
    { L"IMDBDataSourceTables",   L"TableName",   L"TableName", },   // VSS_COM_IMDB_DATA_SOURCE_TABLES,
    { L"InprocServers",          L"CLSID",       L"ProgID",    },   // VSS_COM_INPROC_SERVERS,
    { L"InterfacesForComponent", L"IID"          L"Name"       },   // VSS_COM_INTERFACES_FOR_COMPONENT,
    { L"LocalComputer",          L"Name",        L"Name",      },   // VSS_COM_LOCAL_COMPUTER,
    { L"MethodsForInterface",    L"Index",       L"Name",      },   // VSS_COM_METHODS_FOR_INTERFACE,
    { L"PropertyInfo",           L"Name",        L"Name",      },   // VSS_COM_PROPERTY_INFO,
    { L"PublisherProperties",    L"Name",        L"Name",      },   // VSS_COM_PUBLISHER_PROPERTIES,
    { L"RelatedCollectionInfo",  L"Name",        L"Name",      },   // VSS_COM_RELATED_COLLECTION_INFO,
    { L"Roles",                  L"Name",        L"Name",      },   // VSS_COM_ROLES,
    { L"RolesForComponent",      L"Name",        L"Name",      },   // VSS_COM_ROLES_FOR_COMPONENT,
    { L"RolesForInterface",      L"Name",        L"Name",      },   // VSS_COM_ROLES_FOR_INTERFACE,
    { L"RolesForMethod",         L"Name",        L"Name",      },   // VSS_COM_ROLES_FOR_METHOD,
    { L"Root",                   L"",            L"",          },   // VSS_COM_ROOT,
    { L"SubscriberProperties",   L"Name",        L"Name",      },   // VSS_COM_SUBSCRIBER_PROPERTIES,
    { L"Subscriptions",          L"ID",          L"Name",      },   // VSS_COM_SUBSCRIPTIONS,
    { L"TransientSubscriptions", L"ID",          L"Name",      },   // VSS_COM_TRANSIENT_SUBSCRIPTIONS,
    { L"UsersInRole",            L"User",        L"User",      }    // VSS_COM_USERS_IN_ROLE,
};


/////////////////////////////////////////////////////////////////////////////
// Implementation of CVssCOMAdminCatalog


HRESULT CVssCOMAdminCatalog::Attach(
    IN  const WCHAR* pwszAppName
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssCOMAdminCatalog::Attach" );

    try
    {
        // Testing argument
        if (pwszAppName == NULL || pwszAppName[0] == L'\0') {
            BS_ASSERT(false);
            ft.Throw(VSSDBG_GEN, E_INVALIDARG, L"NULL or empty application name");
        }

        // Begin initializing
        m_bInitialized = false;
        m_pICatalog = NULL;

        // Creating the COMAdminCatalog instance
        ft.hr = m_pICatalog.CoCreateInstance(__uuidof(COMAdminCatalog));
        if (ft.HrFailed()) {
			ft.LogError( VSS_ERROR_CREATING_COMPLUS_ADMIN_CATALOG, VSSDBG_GEN << ft.hr );
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Error creating the COMAdminCatalog instance hr = 0x%08lx", ft.hr);
        }

        // Getting the application name
        m_bstrAppName = pwszAppName;
        if (!m_bstrAppName)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        // End initializing
        m_bInitialized = true;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}




HRESULT CVssCOMAdminCatalog::InstallComponent(
    IN  const WCHAR* pwszDllName,
    IN  const WCHAR* pwszTlbName,
    IN  const WCHAR* pwszProxyStubName
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssCOMAdminCatalog::InstallComponent" );

    try
    {
        // Test if initialized
        if (!m_bInitialized)
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Catalog not initialized");

        // Testing arguments
        if (pwszDllName == NULL || pwszDllName[0] == L'\0')
            ft.Throw(VSSDBG_GEN, E_INVALIDARG, L"NULL or empty paths");

        CComBSTR bstrAppName = (LPWSTR)m_bstrAppName;
        if ((LPWSTR)bstrAppName == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        CComBSTR bstrDllName = pwszDllName;
        if ((LPWSTR)bstrDllName == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        CComBSTR bstrTlbName = pwszTlbName? pwszTlbName: L"";
        if ((LPWSTR)bstrTlbName == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        CComBSTR bstrProxyStubName = pwszProxyStubName? pwszProxyStubName: L"";
        if ((LPWSTR)bstrProxyStubName == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");


        // Install event class for this application
        ft.hr = m_pICatalog->InstallComponent(
            bstrAppName,
            bstrDllName,
            bstrTlbName,
            bstrProxyStubName
            );
        if (ft.HrFailed()) {
            ft.TraceComError();
            ft.LogError( VSS_ERROR_INSTALL_COMPONENT, VSSDBG_GEN << bstrDllName << bstrAppName << ft.hr );
            ft.Throw(VSSDBG_GEN, ft.hr, L"Installing the component failed");
		}
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


HRESULT CVssCOMAdminCatalog::CreateServiceForApplication(
    IN  const WCHAR* pwszServiceName
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssCOMAdminCatalog::CreateServiceForApplication" );

    try
    {
        // Test if initialized
        if (!m_bInitialized)
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Catalog not initialized");

        CComBSTR bstrAppName = (LPWSTR)m_bstrAppName;
        if ((LPWSTR)bstrAppName == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        CComBSTR bstrSvcName = pwszServiceName;
        if ((LPWSTR)bstrSvcName == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        CComBSTR bstrStartType = L"SERVICE_DEMAND_START";
        if ((LPWSTR)bstrStartType == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        CComBSTR bstrErrorControl = L"SERVICE_ERROR_IGNORE";
        if ((LPWSTR)bstrErrorControl == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        CComBSTR bstrRunAs = L"LocalSystem";
        if ((LPWSTR)bstrRunAs == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        CComBSTR bstrPassword = L"";
        if ((LPWSTR)bstrRunAs == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

#ifdef _DEBUG
        VARIANT_BOOL vboolDesktopOK = VARIANT_TRUE;
#else
        VARIANT_BOOL vboolDesktopOK = VARIANT_FALSE;
#endif

        ft.Trace(VSSDBG_GEN,
            L"Calling CreateServiceForApplicationStrings(%s, %s, %s, %s, %s, %s, %s, %s)",
            bstrAppName,
            bstrSvcName,
            bstrStartType,
            bstrErrorControl,
            NULL,
            bstrRunAs,
            bstrPassword,
            vboolDesktopOK == VARIANT_TRUE? L"TRUE": L"FALSE"
            );

        // Install event class for this application
        ft.hr = m_pICatalog->CreateServiceForApplication(
            m_bstrAppName,
            bstrSvcName,
            bstrStartType,
            bstrErrorControl,
            NULL,
            bstrRunAs,
            bstrPassword,
            vboolDesktopOK
            );
        if (ft.HrFailed()) {
            ft.TraceComError();
            ft.LogError( VSS_ERROR_CREATE_SERVICE_FOR_APPLICATION, VSSDBG_GEN << bstrSvcName << m_bstrAppName << ft.hr );
            ft.Throw(VSSDBG_GEN, ft.hr, L"Installing the component failed");
		}
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}





/////////////////////////////////////////////////////////////////////////////
// Implementation of CVssCOMCatalogCollection


HRESULT CVssCOMCatalogCollection::Attach(
    IN  CVssCOMAdminCatalog& catalog
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssCOMCatalogCollection::Attach_ToCatalog" );

    try
    {
        // Begin intializing
        m_bInitialized = false;
        m_pICollection = NULL;

        // Check if Collection type is valid
        if ((m_eType <= 0) || (m_eType >= VSS_COM_COLLECTIONS_COUNT))
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Invalid collection type");

        // Converting collection name into BSTR
        CComBSTR bstrCollectionName = g_VsCOMCollectionsArray[m_eType].wszName;
        if (!bstrCollectionName)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        // Get the catalog interface
        CComPtr<ICOMAdminCatalog2> pICatalog = catalog.GetInterface();
        if (pICatalog == NULL) {
            BS_ASSERT(false);
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Catalog object not initialized.");
        }

        // Get the collection object
        CComPtr<IDispatch> pIDisp;
        ft.hr = pICatalog->GetCollection(bstrCollectionName, &pIDisp);
        if (ft.HrFailed()) {
			ft.LogError( VSS_ERROR_GETTING_COLLECTION, VSSDBG_GEN << bstrCollectionName << ft.hr );
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in getting the collection. hr = 0x%08lx", ft.hr);
        }
        BS_ASSERT(pIDisp);

        // Convert to ICatalogCollection
        CComPtr<ICatalogCollection> pICollection;
        ft.hr = pIDisp->SafeQI(ICatalogCollection, &pICollection);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in querying ICatalogCollection. hr = 0x%08lx", ft.hr);

        // Populate the collection
        ft.hr = pICollection->Populate();
        if (ft.HrFailed()) {
			ft.LogError( VSS_ERROR_POPULATING_COLLECTION, VSSDBG_GEN << bstrCollectionName << ft.hr );
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in populating the collection object. hr = 0x%08lx", ft.hr);
        }

        // End intializing
        m_pICollection = pICollection;
        m_bInitialized = true;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


HRESULT CVssCOMCatalogCollection::Attach(
    IN  CVssCOMCatalogObject& parentObject
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssCOMCatalogCollection::Attach_ToParentCollection" );

    try
    {
        // Begin intializing
        m_bInitialized = false;
        m_pICollection = NULL;

        // Check if Collection type is valid
        if ((m_eType <= 0) || (m_eType >= VSS_COM_COLLECTIONS_COUNT))
            ft.Throw(VSSDBG_GEN, E_INVALIDARG, L"Invalid collection type");

        // Converting collection name into BSTR
        CComBSTR bstrCollectionName = g_VsCOMCollectionsArray[m_eType].wszName;
        if (!bstrCollectionName)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

       // Get the parent object interface
        CComPtr<ICatalogObject> pIParentObject = parentObject.GetInterface();
        if (pIParentObject == NULL) {
            BS_ASSERT(false);
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Parent object not initialized yet.");
        }

        // Get the Key that uniquely identifies the parent object in the grand parent collection
        CComVariant variant;
        // Beware to not leave variant resources before get_Key call!
        ft.hr = pIParentObject->get_Key(&variant);
        if (ft.HrFailed()) {
			ft.LogError( VSS_ERROR_GET_COLLECTION_KEY, VSSDBG_GEN << ft.hr );
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in getting object key. hr = 0x%08lx", ft.hr);
        }

        // Get the grand parent collection interface
        CComPtr<ICatalogCollection> pIGrandParentCollection = parentObject.GetParentInterface();
        if (pIGrandParentCollection == NULL) {
            BS_ASSERT(false);
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Parent object not initialized.");
        }

        // Get the collection object
        CComPtr<IDispatch> pIDisp;
        ft.hr = pIGrandParentCollection->GetCollection(bstrCollectionName, variant, &pIDisp);
        if (ft.HrFailed()) {
			ft.LogError( VSS_ERROR_GET_COLLECTION_FROM_PARENT, VSSDBG_GEN << bstrCollectionName << ft.hr );
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in getting collection. hr = 0x%08lx", ft.hr);
        }
        BS_ASSERT(pIDisp);

        // Convert to ICatalogCollection
        ICatalogCollection* pICollection;
        ft.hr = pIDisp->SafeQI(ICatalogCollection, &pICollection);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in querying ICatalogCollection. hr = 0x%08lx", ft.hr);
        BS_ASSERT(pICollection);
        m_pICollection.Attach(pICollection);

        // Populate the collection
        ft.hr = m_pICollection->Populate();
        if (ft.HrFailed()) {
			ft.LogError( VSS_ERROR_POPULATING_COLLECTION, VSSDBG_GEN << bstrCollectionName << ft.hr );
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in populating the collection object. hr = 0x%08lx", ft.hr);
        }

        // End intializing
        m_bInitialized = true;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


HRESULT CVssCOMCatalogCollection::SaveChanges()
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssCOMCatalogCollection::SaveChanges" );

    try
    {
        // Test if initialized
        if (!m_bInitialized)
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Catalog not initialized");

        // Save changes
        LONG lRet = 0;
        ft.hr = m_pICollection->SaveChanges(&lRet);
        if (ft.HrFailed()) {
			ft.LogError( VSS_ERROR_SAVING_CHANGES, VSSDBG_GEN << ft.hr );
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in saving the changes. hr = 0x%08lx", ft.hr);
        }
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



/////////////////////////////////////////////////////////////////////////////
// Implementation of CVssCOMCatalogCollection


HRESULT CVssCOMCatalogObject::InsertInto(
    IN  CVssCOMCatalogCollection& collection
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssCOMCatalogObject::InsertInto" );

    try
    {
        // Begin initialization
        m_bInitialized = false;
        m_pIObject = NULL;
        m_pIParentCollection = NULL;
        m_lIndex = -1;

        // Get the collection object
        CComPtr<ICatalogCollection> pIParentCollection = collection.GetInterface();
        if (pIParentCollection == NULL)
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Collection object not initialized");

        // Get the instance of the new object
        CComPtr<IDispatch>      pIDisp;
        ft.hr = pIParentCollection->Add(&pIDisp);
        if (ft.HrFailed()) {
			ft.LogError( VSS_ERROR_INSERT_INTO, VSSDBG_GEN << ft.hr );
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in adding the catalog object. hr = 0x%08lx", ft.hr);
        }
        BS_ASSERT(pIDisp);

        // Convert to ICatalogObject
        BS_ASSERT(m_pIObject == NULL);
        ft.hr = pIDisp->SafeQI(ICatalogObject, &m_pIObject);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in querying ICatalogObject. hr = 0x%08lx", ft.hr);

        // End initialization
        m_pIParentCollection = pIParentCollection;
        m_bInitialized = true;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}

//
//  Disclaimer: this method assumes that the collection is already populated
//
//  S_FALSE means object not found
//
HRESULT CVssCOMCatalogObject::AttachByName(
    IN  CVssCOMCatalogCollection& collection,
    IN  const WCHAR wszName[],
    IN  const WCHAR wszPropertyName[] /* = NULL */
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssCOMCatalogObject::AttachByName" );

    try
    {
        // Begin initialization
        m_bInitialized = false;
        m_pIObject = NULL;
        m_pIParentCollection = NULL;
        m_lIndex = -1;

        // Check if Object type is valid
        if ((m_eType <= 0) && (m_eType >= VSS_COM_COLLECTIONS_COUNT))
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Invalid object type");
        if (m_eType != collection.GetType())
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Object type doesn't match with collection type");

        // Get the collection object
        CComPtr<ICatalogCollection> pIParentCollection = collection.GetInterface();
        if (pIParentCollection == NULL)
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Collection object not initialized.");

        // Get the name of the property used as a key
        CComBSTR bstrPropertyName;
        if (wszPropertyName == NULL)
            bstrPropertyName = g_VsCOMCollectionsArray[m_eType].wszDefaultKey;
        else
            bstrPropertyName = wszPropertyName;

        // Get the number of objects in the collection
        LONG lCount = -1;
        ft.hr = pIParentCollection->get_Count(&lCount);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in querying the number of elements. hr = 0x%08lx", ft.hr);
        if (lCount == 0)
            ft.Trace(VSSDBG_GEN, L"Empty collection");

        CComVariant varObjectName = wszName;

        CComVariant variant;
        CComPtr<IDispatch> pIDisp;
        CComPtr<ICatalogObject> pIObject;
        for(LONG lIndex = 0; lIndex < lCount; lIndex++)
        {
            // Release previous references
            pIDisp = pIObject = NULL;

            // Get next item
            ft.hr = pIParentCollection->get_Item(lIndex, &pIDisp);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_GEN, E_UNEXPECTED,
                    L"Failure in getting object with index %ld. hr = 0x%08lx", lIndex, ft.hr);

            // Convert it to ICatalogObject
            ft.hr = pIDisp->SafeQI(ICatalogObject, &pIObject);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in querying ICatalogObject. hr = 0x%08lx", ft.hr);

            variant.Clear(); // do not forget to release resources before get_XXX !
            ft.hr = pIObject->get_Value(bstrPropertyName, &variant);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_GEN, E_UNEXPECTED,
                    L"Failure in getting value for the object key with index %ld. hr = 0x%08lx", lIndex, ft.hr);

            if (varObjectName == variant)
            {
                m_bInitialized = TRUE;
                m_lIndex = lIndex;
                m_pIParentCollection = pIParentCollection;
                m_pIObject = pIObject;
                break;
            }
        }
        if (!m_bInitialized)
            ft.hr = S_FALSE;    // Object not found!
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\backupext\vsxml\vs_xml.cxx ===
/////////////////////////////////////////////////////////////////////////////
// CXMLNode  implementation


#include "stdafx.hxx"
#include "vs_seh.hxx"
#include "vs_trace.hxx"
#include "vs_debug.hxx"
#include "vs_types.hxx"
#include "vs_str.hxx"
#include "vs_vol.hxx"
#include "vs_hash.hxx"
#include "vs_list.hxx"
#include "msxml2.h" //  #182584 - was msxml.h
#include "vs_xml.hxx"
#include "rpcdce.h"
#include "vssmsg.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "BUEXMLC"
//
////////////////////////////////////////////////////////////////////////

// insert a node under the specified node
// The returned interface must be explicitely released.
IXMLDOMNode* CXMLNode::InsertChild
	(
	IN	IXMLDOMNode* pChildNode,	// node to insert
	IN  const CComVariant& vAfter	// node this comes after
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::InsertChild");

	// validate we have a parent node to insert under
	if (m_pNode == NULL || pChildNode == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL node");

	CComPtr<IXMLDOMNode> pInsertedNode;
	// insert node
	ft.hr = m_pNode->insertBefore(pChildNode, vAfter, &pInsertedNode);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::insertBefore");

    // return inserted node
	return pInsertedNode.Detach();
	}


// append a node as a child node of the node
// The returned interface must be explicitely released.
void CXMLNode::AppendChild
	(
	IN	CXMLNode& childNode,
	OUT	IXMLDOMNode** ppNewChildNode
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::AppendChild");

	// validate input arguments
	if ((m_pNode == NULL) || (childNode.m_pNode == NULL) )
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL node");

	if (ppNewChildNode == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

	// append child node
	ft.hr = m_pNode->appendChild( childNode.m_pNode, ppNewChildNode );
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::appendChild");
	}

// set a guid valued attribute
void CXMLNode::SetAttribute
	(
	IN  LPCWSTR wszAttributeName,
	IN  GUID ValueId
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::SetAttribute");

	if (m_pNode == NULL || wszAttributeName == NULL)
		ft.Throw( VSSDBG_XML, E_INVALIDARG, L"NULL input argument");

	LPWSTR wszUuid;
	// convert GUID to string
	RPC_STATUS status = UuidToString(&ValueId, &wszUuid);
	if (status != RPC_S_OK || wszUuid == NULL)
		ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	// convert string to BSTR
	CComBSTR bstrValueId = wszUuid;

	// free up RPC string created by UuidToString
	RpcStringFree(&wszUuid);
	if (!bstrValueId)
        ft.Throw( VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	CComBSTR bstrAttributeName = wszAttributeName;
	if (!bstrAttributeName)
        ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	CComVariant varValue = bstrValueId;
	
	CComPtr<IXMLDOMElement> pElement;
    ft.hr = m_pNode->SafeQI(IXMLDOMElement, &pElement);
	if (ft.HrFailed())
		{
		ft.LogError(VSS_ERROR_QI_IXMLDOMNODE_TO_IXMLDOMELEMENT, VSSDBG_XML << ft.hr);
		ft.Throw
			(
			VSSDBG_XML,
			E_UNEXPECTED,
			L"IXMLDOMNode::SafeQI",
			L"Error querying IXMLDOMElement to the node. 0x%08lx",
			ft.hr
			);
        }

	// Set the attribute
	ft.hr = pElement->setAttribute(bstrAttributeName, varValue);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::setAttribute");
	}


// set a string valued attribute
void CXMLNode::SetAttribute
	(
	IN  LPCWSTR wszAttributeName,
	IN  LPCWSTR wszValue
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::SetAttribute");
	if (m_pNode == NULL || wszAttributeName == NULL || wszValue == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL input argument");

	CComBSTR bstrAttributeName = wszAttributeName;
	if (!bstrAttributeName)
        ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	CComBSTR bstrValue = wszValue;
	if (!bstrValue)
        ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	CComVariant varValue = bstrValue;
	
	CComPtr<IXMLDOMElement> pElement;
	ft.hr = m_pNode->SafeQI(IXMLDOMElement, &pElement);
	if (ft.HrFailed())
		{
		ft.LogError(VSS_ERROR_QI_IXMLDOMNODE_TO_IXMLDOMELEMENT, VSSDBG_XML << ft.hr);
        ft.Throw
			(
			VSSDBG_XML,
			E_UNEXPECTED,
			L"IXMLDOMNode::SafeQI",
			L"Error querying IXMLDOMNode to IXMLDOMElement. 0x%08lx",
			ft.hr
			);
        }

	// Set the attribute
	ft.hr = pElement->setAttribute(bstrAttributeName, varValue);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::setAttribute");
	}


// set an integer valued attribute
void CXMLNode::SetAttribute
	(
	IN  LPCWSTR wszAttributeName,
	IN  INT nValue
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::SetAttribute");

	if (m_pNode == NULL || wszAttributeName == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL node");

	// set attribute name as BSTR
	CComBSTR bstrAttributeName = wszAttributeName;
	if (!bstrAttributeName)
        ft.Throw( VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	CComVariant varValue = nValue;
	
	CComPtr<IXMLDOMElement> pElement;
	ft.hr = m_pNode->SafeQI(IXMLDOMElement, &pElement);
	if (ft.HrFailed())
		{
		ft.LogError(VSS_ERROR_QI_IXMLDOMNODE_TO_IXMLDOMELEMENT, VSSDBG_XML << ft.hr);
		ft.Throw
			(
			VSSDBG_XML,
			E_UNEXPECTED,
			L"IXMLDOMNode::SafeQI",
			L"Error querying from IXMLDOMNode to IXMLDOMElement. hr = 0x%08lx",
			ft.hr
			);
        }

	// Set the attribute
	ft.hr = pElement->setAttribute(bstrAttributeName, varValue);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::setAttribute");
	}


// set a DWORDLONG valued attribute
void CXMLNode::SetAttribute
	(
	IN  LPCWSTR wszAttributeName,
	IN  LONGLONG llValue
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::SetAttribute");

	const nTimestampBufferSize = 0x10;

	if (m_pNode == NULL || wszAttributeName == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL input argument");

	CComBSTR bstrAttributeName = wszAttributeName;
	if (!bstrAttributeName)
        ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	CComBSTR bstrValue(nTimestampBufferSize + 1);
	if (!bstrValue)
        ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	// Print the LONGLONG value
	::_snwprintf(bstrValue, nTimestampBufferSize, L"%016I64x", llValue);

	CComVariant varValue = bstrValue;
	
	CComPtr<IXMLDOMElement> pElement;
	ft.hr = m_pNode->SafeQI(IXMLDOMElement, &pElement);
	if (ft.HrFailed())
		{
		ft.LogError(VSS_ERROR_QI_IXMLDOMNODE_TO_IXMLDOMELEMENT, VSSDBG_XML << ft.hr);
        ft.Throw
			(
			VSSDBG_XML,
			E_UNEXPECTED,
			L"IXMLDOMNode::SafeQI",
			L"Error querying IXMLDOMElement from the IXMLDOMNode. hr = 0x%08lx",
			ft.hr
			);
        }

	// Set the attribute
	ft.hr = pElement->setAttribute(bstrAttributeName, varValue);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::setAttribute");
    }


// add text to a node
void CXMLNode::AddText
	(
	IN  LPCWSTR wszText
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::AddText");

	if (m_pNode == NULL || m_pDoc == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL input argument.");

	CXMLDocument doc(m_pDoc);
	CComPtr<IXMLDOMNode> pTextNode;
	CXMLNode textNode = doc.CreateNode(NULL, NODE_TEXT);
	textNode.SetValue(wszText);
	InsertNode(textNode);
    }


void CXMLNode::SetValue
	(
	IN  LPCWSTR wszValue
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::SetValue");

	if (m_pNode == NULL || wszValue == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL input argument.");

	CComBSTR bstrValue = wszValue;
	if (!bstrValue)
        ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	CComVariant varValue = bstrValue;
	
	// Set the attribute
	ft.hr = m_pNode->put_nodeValue(varValue);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::put_nodeValue");
    }


/////////////////////////////////////////////////////////////////////////////
// CXMLDocument  implementation


void CXMLDocument::Initialize
	(
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::Initialize");

	m_pDoc = NULL;

	ft.hr = m_pDoc.CoCreateInstance(CLSID_DOMDocument30);  //  #182584 - Was CLSID_DOMDocument26
	ft.CheckForError(VSSDBG_XML, L"CoCreateInstance");

	m_pNode = static_cast<IXMLDOMNode*>(m_pDoc);
	m_pNodeCur = m_pNode;
	m_level = 0;
	}


// create a node
CXMLNode CXMLDocument::CreateNode
	(
	IN  LPCWSTR wszName,
	IN  DOMNodeType nType
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::CreateNode");

	// Check if the document is properly initialized
	if (m_pDoc == NULL)
        ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL document");

    CComPtr<IXMLDOMNode> pNode;
    CComVariant vType = (INT)nType;
	CComBSTR bstrName = wszName;		// Duplicating the string.

	// Check if no errors when preparing the arguments
	if (!bstrName && wszName)
        ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	// Create the node
    ft.hr = m_pDoc->createNode(vType, bstrName, NULL, &pNode);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::createNode");

	BS_ASSERT(pNode != NULL);

	return CXMLNode(pNode, m_pDoc);
    }

// insert a node below the current one
CXMLNode CXMLNode::InsertNode
	(
	CXMLNode &node
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::InsertNode");

	CComPtr<IXMLDOMNode> pInsertedNode;
	pInsertedNode.Attach(InsertChild(node.GetNodeInterface()));

	return CXMLNode(pInsertedNode, m_pDoc);
	}



// position on next node
bool CXMLDocument::Next
	(
	IN bool fDescend,					// descend to child if one exists
	IN bool fAscendAllowed				// can ascend to parent?
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::Next");

	CComPtr<IXMLDOMNode> pNodeNext = NULL;
	m_pAttributeMap = NULL;

	while(TRUE)
		{
		// at end?
		if (m_pNodeCur == NULL)
			return FALSE;

		if (fDescend)
			{
			// get first child
			ft.hr = m_pNodeCur->get_firstChild(&pNodeNext);
			ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_firstChild");

			if (ft.hr == S_OK)
				{
				// child was found
				BS_ASSERT(pNodeNext != NULL);
				m_pNodeCur.Attach(pNodeNext.Detach());

				// decended a level
				m_level++;
				return TRUE;
				}
            }

		// move to sibling node
		ft.hr = m_pNodeCur->get_nextSibling(&pNodeNext);
		ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_nextSibling");

		if (ft.hr == S_OK)
			{
			// sibling was found
			BS_ASSERT(pNodeNext != NULL);
			m_pNodeCur.Attach(pNodeNext.Detach());
			return TRUE;
			}

		// check if ascend is allowed and that we are not at the toplevel of
		// the document
		if (!fAscendAllowed || m_level == 0)
			return FALSE;

		// get parent node
		ft.hr = m_pNodeCur->get_parentNode(&pNodeNext);
		ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_parentNode");

	    m_pNodeCur.Attach(pNodeNext.Detach());
		// don't descend to back where we came from
		fDescend = FALSE;

		// move up one level
		m_level--;
		}
	}

// find a specific child attribute of the current node
bool CXMLDocument::FindAttribute
	(
	IN LPCWSTR wszAttrName,			// attriburte name
	OUT BSTR *pbstrAttrValue		// string value of attribute
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::FindAttribute");

	if (m_pNodeCur == NULL || wszAttrName == NULL || pbstrAttrValue == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL argument.");

	// create attribute map if one doesn't exist
	if (m_pAttributeMap == NULL)
		{
		ft.hr = m_pNodeCur->get_attributes(&m_pAttributeMap);
		ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_attributes");
        }

	if (m_pAttributeMap == NULL)
		return FALSE;

	CComPtr<IXMLDOMNode> pNode = NULL;

	// get attribute
	ft.hr = m_pAttributeMap->getNamedItem((LPWSTR) wszAttrName, &pNode);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNamedNodeMap::getNamedItem");

	if (ft.hr == S_FALSE)
		return false;

	ft.hr = pNode->get_text(pbstrAttrValue);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_text");

	return TRUE;
	}

// move to next attribute
IXMLDOMNode *CXMLDocument::NextAttribute()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::NextAttribute");

	if (m_pNodeCur == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL Node.");

	if (m_pAttributeMap == NULL)
		{
		ft.hr = m_pNodeCur->get_attributes(&m_pAttributeMap);
		ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_attributes");
        }

	if (m_pAttributeMap == NULL)
		return FALSE;

	IXMLDOMNode *pNode = NULL;
	// position at next attribute
	ft.hr = m_pAttributeMap->nextNode(&pNode);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNamedNode::nextNode");

	if (ft.hr == S_FALSE)
		return NULL;

	return pNode;
	}


// reset to top node in document
void CXMLDocument::ResetToDocument()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::ResetToDocument");

	m_pNodeCur = m_pNode;
	m_pAttributeMap = NULL;
	m_level = 0;
	}

// reset to parent node in the document
void CXMLDocument::ResetToParent() throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::ResetToParent");

	if (m_pNodeCur == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL node");

	// check to see that we are not at the top level of the document
	if (m_pNodeCur == m_pNode || m_level == 0)
		return;

	CComPtr<IXMLDOMNode> pNodeParent;
	// get parent node
	ft.hr = m_pNodeCur->get_parentNode(&pNodeParent);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_parentNode");

    BS_ASSERT(pNodeParent);
    m_pNodeCur.Attach(pNodeParent.Detach());
	m_pAttributeMap = NULL;

	// move up one level
	m_level--;
	}

// does current node match the specific atttribute type.
bool CXMLDocument::IsNodeMatch
	(
	LPCWSTR wszElementType
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::IsNodeMatch");
	DOMNodeType dnt;

	if (m_pNodeCur == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL node");

	ft.hr = m_pNodeCur->get_nodeType(&dnt);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_NodeType");

	 // check that node type is an element
     if (dnt == NODE_ELEMENT)
		{
		CComBSTR bstrName;

		// get node name
		ft.hr = m_pNodeCur->get_nodeName(&bstrName);
		ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_NodeName");

        // check for match
		if (wcscmp(bstrName, wszElementType) == 0)
			return TRUE;
		}

	return false;
	}

// find a specific child or sibling node
bool CXMLDocument::FindElement
	(
	IN LPCWSTR wszElementType,		// element type to loo for
	IN bool bGotoChild = TRUE		// whether to look for a child node
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::FindElement");

	bool bDescend = bGotoChild;

	// save current level so that we don't ascend above this
	unsigned levelStart = m_level;

	// look for node
	while(Next(bDescend, TRUE))
		{
		bDescend = FALSE;
		if (IsNodeMatch(wszElementType))
			return true;
		}

	// if we descended to the child level, reset to parent level
	if (bGotoChild && m_level > levelStart)
		ResetToParent();

	return FALSE;
	}

// save document as an XML string
BSTR CXMLNode::SaveAsXML
	(
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::saveAsXML");
	BSTR bstrOut;

	if (m_pNode == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL document.");

	ft.hr = m_pNode->get_xml(&bstrOut);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_xml");

    return bstrOut;
	}

// load document from an XML string
bool CXMLDocument::LoadFromXML
	(
	IN BSTR bstrXML
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::LoadFromXML");

	m_pDoc = NULL;
	Initialize();
	BS_ASSERT(m_pDoc != NULL);
	VARIANT_BOOL bSuccessful;
	ft.hr = m_pDoc->loadXML(bstrXML, &bSuccessful);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::loadXML");
		
	return bSuccessful ? TRUE : FALSE;
	}

// load document from a file
bool CXMLDocument::LoadFromFile
	(
	IN LPCWSTR wszFile
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::LoadFromFile");

	// reinitialize the document
	m_pDoc = NULL;
	Initialize();
	BS_ASSERT(m_pDoc != NULL);

	// setup arguments for the Load call
	VARIANT_BOOL bSuccessful;
	VARIANT varFile;
	VariantInit(&varFile);
	varFile.bstrVal = SysAllocString(wszFile);
	varFile.vt = VT_BSTR;

	ft.hr = m_pDoc->load(varFile, &bSuccessful);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::load");

    // return whether load was successful or not
	return bSuccessful ? TRUE : FALSE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\coord\inc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by svc.rc
//

#ifndef __VSS_RESOURCE_H__
#define __VSS_RESOURCE_H__

#if _MSC_VER > 1000
#pragma once
#endif

#define IDS_SERVICENAME                 100


#define IDR_VSSVC                       201
#define IDR_COORD                       202

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        306
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           306
#endif
#endif

#endif // __VSS_RESOURCE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\coord\src\async.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module async.cxx | Implementation of CVssAsync object
    @end

Author:

    Adi Oltean  [aoltean]  10/05/1999

Revision History:

    Name        Date        Comments
    aoltean     10/05/1999  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "worker.hxx"
#include "provmgr.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"
#include "snap_set.hxx"
#include "async.hxx"
#include "vs_sec.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORASYNC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  CVssAsync


CVssAsync::CVssAsync():
	m_pSnapshotSet(NULL),
	m_hrState(S_OK)
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::CVssAsync" );
}


CVssAsync::~CVssAsync()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::~CVssAsync" );
}


IVssAsync* CVssAsync::CreateInstanceAndStartJob(
	IN	CVssSnapshotSetObject*	pSnapshotSetObject
	)

/*++

Routine Description:

    Static method that creates a new instance of the Async interface and
    starts a background thread that runs the CVssAsync::OnRun.

Arguments:

    CVssSnapshotSetObject*	pSnapshotSetObject, - the snapshot set object given as parameter.

Throw values:

    E_OUTOFMEMORY
        - On CComObject<CVssAsync>::CreateInstance failure
        - On PrepareJob failure
        - On StartJob failure

    E_UNEXPECTED
        - On QI failures. We do not log (but we assert) since this is an obvious programming error.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::CreateInstanceAndStartJob" );
	CComPtr<IVssAsync> pAsync;

    // Allocate the COM object.
    CComObject<CVssAsync>* pObject;
    ft.hr = CComObject<CVssAsync>::CreateInstance(&pObject);
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
				  L"Error creating the CVssAsync instance. hr = 0x%08lx", ft.hr);
    BS_ASSERT(pObject);

	// Setting async object internal data
	BS_ASSERT(pSnapshotSetObject);
	
	// AddRef is called - since the CVssAsync keeps a smart pointer.
    pObject->m_pSnapshotSet = pSnapshotSetObject;

    // Querying the IVssSnapshot interface. Now the ref count becomes 1.
    CComPtr<IUnknown> pUnknown = pObject->GetUnknown();
    BS_ASSERT(pUnknown);
    ft.hr = pUnknown->SafeQI(IVssAsync, &pAsync); // The ref count is 2.
    if ( ft.HrFailed() ) {
        BS_ASSERT(false);
        ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
				  L"Error querying the IVssAsync interface. hr = 0x%08lx", ft.hr);
    }
    BS_ASSERT(pAsync);

	// Prepare job (thread created in resume state)
	ft.hr = pObject->PrepareJob();
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Error preparing the job. hr = 0x%08lx", ft.hr);

	// Start job (now the background thread will start running).
	ft.hr = pObject->StartJob();
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Error starting the job. hr = 0x%08lx", ft.hr);

    // The reference count becomes 3 since we keep a reference for the background thread.

    // Right now the background thread is running. This thread will perform a Release when finishes.
    // This will keep the async object alive until the thread finishes.
    // But, we cannot put an AddRef in the OnInit/OnRun on the background thread,
    // (since in this thread we might
    // call all subsequent releases without giving a chance to the other thread to do an AddRef)
    // Also we cannot put an AddRef at creation since we didn't know at that time if the background
    // thread will run.
    // Therefore we must do the AddRef right here.
    // Beware, this AddRef is paired with an Release in the CVssAsync::OnFinish method:
    // Note: we are sure that we cannot reach reference count zero since the thread is surely running,
    //
    IUnknown* pUnknownTmp = pObject->GetUnknown();
    pUnknownTmp->AddRef();

	// Now the background thread related members (m_hrState, m_nPercentDone) begin to update.
    // The ref count goes back to 2

	return pAsync.Detach();	  // The ref count remains 2.
}


/////////////////////////////////////////////////////////////////////////////
//  CVssWorkerThread overrides


bool CVssAsync::OnInit()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::OnInit" );

	if (m_pSnapshotSet != NULL)
	{
		// Setting snapshot set internal data
		BS_ASSERT(m_hrState == S_OK);
		m_hrState = VSS_S_ASYNC_PENDING;

		// Setting snapshot set internal data
		BS_ASSERT(!m_pSnapshotSet->m_bCancel);
		m_pSnapshotSet->m_bCancel = false;
    }

	return (m_pSnapshotSet != NULL);
}


void CVssAsync::OnRun()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::OnRun" );

	try
	{
		// Check if the snapshot object is created.
		if (m_pSnapshotSet == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE,
				L"Snapshot set object not yet created.");
		}

		// We assume that the async object is not yet released.
		// (the wait in destructor should ensure that).
		
		// Call StartSnapshotSet on the given object.
		ft.hr = m_pSnapshotSet->DoSnapshotSet();
		if (ft.hr != S_OK)
		{
			ft.Trace( VSSDBG_COORD,
					  L"Internal DoSnapshotSet failed. 0x%08lx", ft.hr);
			
			// Put the error code into the
			BS_ASSERT(m_hrState == VSS_S_ASYNC_PENDING);
			m_hrState = ft.hr;
		}

		// Now m_hrState may be VSS_S_ASYNC_CANCELLED
	}
	VSS_STANDARD_CATCH(ft)
}


void CVssAsync::OnFinish()	
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::OnFinish" );

    try
    {
		if (m_pSnapshotSet)
		{
			if ( m_hrState == VSS_S_ASYNC_PENDING)
				m_hrState = VSS_S_ASYNC_FINISHED;
			// Else keep the m_hrState error code...
			// It may be VSS_S_ASYNC_CANCELLED, if CVssSnapshotSetObject::TestIfCancelNeeded was called.
		}
		else
			BS_ASSERT(false);

        // Release the background thread reference to this object.
		// Note: We kept an reference around for the time when the backgropund thread is running.
        // In this way we avoid the destruction of the async interface while the
        // background thread is running.
        // The paired addref was done after a sucessful StartJob

        // Mark the thread object as "finished"
        MarkAsFinished();

        // We release the interface only if StartJob was returned with success
        IUnknown* pMyself = GetUnknown();
        pMyself->Release();
    }
    VSS_STANDARD_CATCH(ft)
}


void CVssAsync::OnTerminate()	
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::OnTerminate" );
}


/////////////////////////////////////////////////////////////////////////////
//  IVssAsync implementation


STDMETHODIMP CVssAsync::Cancel()

/*++

Routine Description:

    Cancels the current running process, if any.

Arguments:

    None.

Throw values:

    E_ACCESSDENIED
        - The user is not an administrator or a backup operator
    E_UNEXPECTED
        - m_pSnapshotSet is NULL. Code bug, no logging.

    [lock failures]
        E_OUTOFMEMORY

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::Cancel" );

	try
	{
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account or does not have backup privilege enabled");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Safety check
		if (m_pSnapshotSet == NULL) {
		    BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"m_pSnapshotSet == NULL");
		}

		// If thread is already finished, return correct code.
		if ((m_hrState == VSS_S_ASYNC_FINISHED) || (m_hrState == VSS_S_ASYNC_CANCELLED))
			ft.hr = m_hrState;
		else	// Otherwise, inform the thread that it must cancel. The function returns immediately.
			m_pSnapshotSet->m_bCancel = true;
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


STDMETHODIMP CVssAsync::Wait()

/*++

Routine Description:

    Waits until the process gets finished.

Arguments:

    None.

Throw values:

    E_ACCESSDENIED
        - The user is not an administrator or a backup operator
    E_UNEXPECTED
        - m_pSnapshotSet is NULL. Code bug, no logging.
        - Thread handle is invalid. Code bug, no logging.
        - WaitForSingleObject failed. Code bug, no logging.

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::Wait" );

	try
	{
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account or does not have backup privilege enabled");

		// Safety check
		if (m_pSnapshotSet == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"m_pSnapshotSet == NULL");
		}

		// No async lock here!

		HANDLE hThread = GetThreadHandle();
		if (hThread == NULL)
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"invalid hThread");

		if (::WaitForSingleObject(hThread, INFINITE) == WAIT_FAILED) {
			ft.LogGenericWarning( VSSDBG_GEN,
			    L"WaitForSingleObject(%p,INFINITE) == WAIT_FAILED, GetLastError() == 0x%08lx",
			    hThread, GetLastError() );
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Wait failed. [0x%08lx]", ::GetLastError());
		}
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


STDMETHODIMP CVssAsync::QueryStatus(
				OUT     HRESULT* pHrResult,
				OUT     INT* pnReserved
				)

/*++

Routine Description:

    Query the status for the current running process, if any.

Arguments:

	OUT     HRESULT* pHrResult  - Will be filled with a value reflected by the current status
	OUT     INT* pnReserved     - Reserved today. It will be filled always with zero, if non-NULL

Throw values:

    E_ACCESSDENIED
        - The user is not an administrator or a backup operator
    E_UNEXPECTED
        - m_pSnapshotSet is NULL. Code bug, no logging.
    E_INVALIDARG
        - NULL pHrResult

    [lock failures]
        E_OUTOFMEMORY

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::QueryStatus" );

	try
	{
		// Zero the [out] parameters
		::VssZeroOut(pHrResult);
		::VssZeroOut(pnReserved);

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account or does not have backup privilege enabled");

		// Argument check
		BS_ASSERT(pHrResult);
		if (pHrResult == NULL)
			ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"pHrResult == NULL");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Safety check
		if (m_pSnapshotSet == NULL)
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"m_pSnapshotSet == NULL");

		(*pHrResult) = m_hrState;
		ft.Trace( VSSDBG_COORD, L"Returning *pHrResult: 0x%08x", *pHrResult );
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\coord\src\admin.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Admin.cxx | Implementation of IVssAdmin
    @end

Author:

    Adi Oltean  [aoltean]  07/09/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     07/09/1999  Created
    aoltean     08/26/1999  Adding RegisterProvider
    aoltean     08/26/1999  Adding UnregisterProvider
    aoltean     08/27/1999  Adding IsAdministrator,
                            Adding unique provider name test.
    aoltean     08/30/1999  Calling OnUnregister on un-registering
                            Improving IsProviderNameAlreadyUsed.
    aoltean     09/03/1999  Moving QueryProviders in Query.cxx
                            Moving private methods in Private.cxx
                            More parameter checking
                            Moving constants in coord.hxx
    aoltean     09/09/1999  Adding the notification interface.
                            Making the code clearer.
                            dss -> vss
	aoltean		09/20/1999	Adding shared "copy" class
	aoltean		09/21/1999  Adding a new header for the "ptr" class.


--*/

/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"
#include "reg_util.hxx"

#include "provmgr.hxx"
#include "admin.hxx"
#include "vs_sec.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORADMNC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  IVssAdmin interface


CVssAdmin::CVssAdmin()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAdmin::CVssAdmin" );
}


CVssAdmin::~CVssAdmin()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAdmin::~CVssAdmin" );
}


/////////////////////////////////////////////////////////////////////////////
//  IVssAdmin interface


STDMETHODIMP CVssAdmin::RegisterProvider(
    IN      VSS_ID      ProviderId,
    IN      CLSID       ClassId,
    IN      VSS_PWSZ    pwszProviderName,
	IN		VSS_PROVIDER_TYPE eProviderType,
    IN      VSS_PWSZ    pwszProviderVersion,
    IN      VSS_ID      ProviderVersionId
    )

/*++

Routine Description:

    Register the provider. Add the provider into the internal array if the array is already filled exist.

Arguments:

    VSS_ID      ProviderId,
    CLSID       ClassId,
    VSS_PWSZ    pwszProviderName,
    VSS_PROVIDER_TYPE eProviderType,
    VSS_PWSZ    pwszProviderVersion,
    VSS_ID      ProviderVersionId

Return values:

    E_OUTOFMEMORY
    E_ACCESSDENIED 
        - The user is not administrator
    E_INVALIDARG 
        - Invalid arguments
    VSS_E_PROVIDER_ALREADY_REGISTERED
        - Provider already registered
    E_UNEXPECTED 
        - Registry errors. An error log entry is added describing the error.

    [CVssProviderManager::AddProviderIntoArray() failures]
        E_OUTOFMEMORY

        [lockObj failures] or
        [InitializeAsProvider() failures]
            E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAdmin::RegisterProvider" );
    WCHAR   wszProviderKeyName[_MAX_KEYNAME_LEN];
    WCHAR   wszValueBuffer[_MAX_VALUE_LEN];
    HKEY    hRegKeyVSS = NULL;
    HKEY    hRegKeyProviders = NULL;
    HKEY    hRegKeyNewProvider = NULL;
    HKEY    hRegKeyCLSID = NULL;
    LONG    lRes;
    bool    bProviderKeyCreated = false;

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
                  L"ProviderId = " WSTR_GUID_FMT L",\n"
                  L"ClassId = "  WSTR_GUID_FMT L",\n"
                  L"pwszProviderName = %s\n"
				  L"eProviderType = %d\n"
                  L"pwszProviderVersion = %s\n"
                  L"ProviderVersionId = "  WSTR_GUID_FMT L",\n",
                  GUID_PRINTF_ARG( ProviderId ),
                  GUID_PRINTF_ARG( ClassId ),
                  pwszProviderName,
				  eProviderType,
                  pwszProviderVersion,
                  GUID_PRINTF_ARG( ProviderVersionId )
                  );

        // Argument validation
        if (ProviderId == GUID_NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL Provider ID");
        if (pwszProviderName == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL name");
        if (pwszProviderName[0] == L'\0')
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"Empty name");
        if (::wcslen(pwszProviderName) > _MAX_VALUE_LEN - 1 )
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"pwszProviderName length greater than %d", _MAX_VALUE_LEN - 1);
		switch( eProviderType ) {
		case VSS_PROV_SOFTWARE:
//		case VSS_PROV_HARDWARE: // Disabled in Whistler client
			break;
		default:
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"invalid provider type %d", eProviderType);
		}
        if (pwszProviderVersion == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL version");
        if (::wcslen(pwszProviderVersion) > _MAX_VALUE_LEN - 1 )
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"pwszProviderVersion length greater than %d", _MAX_VALUE_LEN - 1);

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

        // Creating the "HKLM\System\CurrentControlSet\Services\VSS" key, if it does not exist yet.
        DWORD dwDisposition;
        lRes = ::RegCreateKeyExW(
            HKEY_LOCAL_MACHINE,         //  IN HKEY hKey,
            wszVSSKey,                  //  IN LPCWSTR lpSubKey,
            0,                          //  IN DWORD Reserved,
            REG_NONE,                   //  IN LPWSTR lpClass,
            REG_OPTION_NON_VOLATILE,    //  IN DWORD dwOptions,
            KEY_ALL_ACCESS,             //  IN REGSAM samDesired,
            NULL,                       //  IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            &hRegKeyVSS,                //  OUT PHKEY phkResult,
            &dwDisposition              //  OUT LPDWORD lpdwDisposition
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), L"RegCreateKeyExW(HKLM,%s,...)", 
                wszVSSKey);

        // Creating the "Providers" subkey, if it does not exist yet.
        lRes = ::RegCreateKeyExW(
            hRegKeyVSS,                 //  IN HKEY hKey,
            wszVSSKeyProviders,         //  IN LPCWSTR lpSubKey,
            0,                          //  IN DWORD Reserved,
            REG_NONE,                   //  IN LPWSTR lpClass,
            REG_OPTION_NON_VOLATILE,    //  IN DWORD dwOptions,
            KEY_ALL_ACCESS,             //  IN REGSAM samDesired,
            NULL,                       //  IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            &hRegKeyProviders,          //  OUT PHKEY phkResult,
            &dwDisposition              //  OUT LPDWORD lpdwDisposition
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegCreateKeyExW(HKLM\\%s,%s,...)", 
                wszVSSKey, wszVSSKeyProviders);

        // Create the subkey for that Provider Id.
        ::wsprintf(wszProviderKeyName, WSTR_GUID_FMT, GUID_PRINTF_ARG( ProviderId ));
        lRes = ::RegCreateKeyExW(
            hRegKeyProviders,           //  IN HKEY hKey,
            wszProviderKeyName,         //  IN LPCWSTR lpSubKey,
            0,                          //  IN DWORD Reserved,
            REG_NONE,                   //  IN LPWSTR lpClass,
            REG_OPTION_NON_VOLATILE,    //  IN DWORD dwOptions,
            KEY_ALL_ACCESS,             //  IN REGSAM samDesired,
            NULL,                       //  IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            &hRegKeyNewProvider,        //  OUT PHKEY phkResult,
            &dwDisposition              //  OUT LPDWORD lpdwDisposition
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegCreateKeyExW(HKLM\\%s\\%s,%s,...)", 
                wszVSSKey, wszVSSKeyProviders, wszProviderKeyName);

        switch ( dwDisposition )
        {
        case REG_CREATED_NEW_KEY: // OK. The new provider has a new key. Break on.
            // The cleanup code must delete also the provider key also.
            bProviderKeyCreated = true;
            break;
        case REG_OPENED_EXISTING_KEY:
            ft.Throw( VSSDBG_COORD, VSS_E_PROVIDER_ALREADY_REGISTERED,
                      L"Provider with Id %s already registered ", wszProviderKeyName);
        default:
            BS_ASSERT( false );
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegCreateKeyExW(HKLM\\%s\\%s,%s,...,[%d])", 
                wszVSSKey, wszVSSKeyProviders, wszProviderKeyName, dwDisposition);
        }

        // Set provider name
        DWORD dwLength = ::lstrlenW( pwszProviderName );
        BS_ASSERT( dwLength != 0 );
        lRes = ::RegSetValueExW(
            hRegKeyNewProvider,                 // IN HKEY hKey,
            wszVSSProviderValueName,            // IN LPCWSTR lpValueName,
            0,                                  // IN DWORD Reserved,
            REG_SZ,                             // IN DWORD dwType,
            (CONST BYTE*)pwszProviderName,      // IN CONST BYTE* lpData,
            (dwLength + 1) * sizeof(WCHAR)      // IN DWORD cbData
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegSetValueExW(HKLM\\%s\\%s\\%s,%s,0,REG_SZ,%s.%d)", 
                wszVSSKey, wszVSSKeyProviders, wszProviderKeyName, wszVSSProviderValueName, pwszProviderName, 
                (dwLength + 1) * sizeof(WCHAR));

        // Set provider type
        DWORD dwType = eProviderType;
        lRes = ::RegSetValueExW(
            hRegKeyNewProvider,                 // IN HKEY hKey,
            wszVSSProviderValueType,            // IN LPCWSTR lpValueName,
            0,                                  // IN DWORD Reserved,
            REG_DWORD,                          // IN DWORD dwType,
            (CONST BYTE*)(&dwType),				// IN CONST BYTE* lpData,
            sizeof(DWORD)						// IN DWORD cbData
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegSetValueExW(HKLM\\%s\\%s\\%s,%s,0,REG_DWORD,%d,%d)", 
                wszVSSKey, wszVSSKeyProviders, wszProviderKeyName, wszVSSProviderValueType, dwType, sizeof(DWORD));

        // Set provider version
        dwLength = ::lstrlenW( pwszProviderVersion );
        BS_ASSERT( dwLength != 0 );
        lRes = ::RegSetValueExW(
            hRegKeyNewProvider,                 // IN HKEY hKey,
            wszVSSProviderValueVersion,         // IN LPCWSTR lpValueName,
            0,                                  // IN DWORD Reserved,
            REG_SZ,                             // IN DWORD dwType,
            (CONST BYTE*)pwszProviderVersion,   // IN CONST BYTE* lpData,
            (dwLength + 1) * sizeof(WCHAR)      // IN DWORD cbData
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegSetValueExW(HKLM\\%s\\%s\\%s,%s,0,REG_SZ,%s.%d)", 
                wszVSSKey, wszVSSKeyProviders, wszProviderKeyName, wszVSSProviderValueVersion, pwszProviderVersion, 
                (dwLength + 1) * sizeof(WCHAR));

        // Set provider version Id.
        ::wsprintf(wszValueBuffer, WSTR_GUID_FMT, GUID_PRINTF_ARG( ProviderVersionId ));
        dwLength = ::lstrlenW( wszValueBuffer );
        BS_ASSERT( dwLength != 0 );
        lRes = ::RegSetValueExW(
            hRegKeyNewProvider,                 // IN HKEY hKey,
            wszVSSProviderValueVersionId,       // IN LPCWSTR lpValueName,
            0,                                  // IN DWORD Reserved,
            REG_SZ,                             // IN DWORD dwType,
            (CONST BYTE*)wszValueBuffer,        // IN CONST BYTE* lpData,
            (dwLength + 1) * sizeof(WCHAR)      // IN DWORD cbData
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegSetValueExW(HKLM\\%s\\%s\\%s,%s,0,REG_SZ,%s.%d)", 
                wszVSSKey, wszVSSKeyProviders, wszProviderKeyName, wszVSSProviderValueVersionId, wszValueBuffer, 
                (dwLength + 1) * sizeof(WCHAR));

        // Create the subkey for the class Id.
        lRes = ::RegCreateKeyExW(
            hRegKeyNewProvider,                 //  IN HKEY hKey,
            wszVSSKeyProviderCLSID,             //  IN LPCWSTR lpSubKey,
            0,                                  //  IN DWORD Reserved,
            REG_NONE,                           //  IN LPWSTR lpClass,
            REG_OPTION_NON_VOLATILE,            //  IN DWORD dwOptions,
            KEY_ALL_ACCESS,                     //  IN REGSAM samDesired,
            NULL,                               //  IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            &hRegKeyCLSID,                      //  OUT PHKEY phkResult,
            &dwDisposition                      //  OUT LPDWORD lpdwDisposition
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegCreateKeyExW(HKLM\\%s\\%s\\%s,%s,...)", 
                wszVSSKey, wszVSSKeyProviders, wszProviderKeyName, wszVSSKeyProviderCLSID);
        BS_ASSERT(dwDisposition == REG_CREATED_NEW_KEY );

        // Set the CLSID for the newly created key
        ::wsprintf(wszValueBuffer, WSTR_GUID_FMT, GUID_PRINTF_ARG( ClassId ));
        dwLength = ::lstrlenW( wszValueBuffer );
        BS_ASSERT( dwLength != 0 );
        lRes = ::RegSetValueExW(
            hRegKeyCLSID,                       // IN HKEY hKey,
            wszVSSCLSIDValueName,               // IN LPCWSTR lpValueName,
            0,                                  // IN DWORD Reserved,
            REG_SZ,                             // IN DWORD dwType,
            (CONST BYTE*)wszValueBuffer,        // IN CONST BYTE* lpData,
            (dwLength + 1) * sizeof(WCHAR)      // IN DWORD cbData
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegSetValueExW(HKLM\\%s\\%s\\%s\\%s,%s,0,REG_SZ,%s.%d)", 
                wszVSSKey, wszVSSKeyProviders, wszProviderKeyName, wszVSSKeyProviderCLSID, wszVSSCLSIDValueName, 
                wszValueBuffer, (dwLength + 1) * sizeof(WCHAR));

		// Update m_pProvidersArray by inserting the new provider into the array.
		CVssProviderManager::AddProviderIntoArray(
			ProviderId,
			pwszProviderName,
            eProviderType,
			pwszProviderVersion,
			ProviderVersionId,
			ClassId);
    }
    VSS_STANDARD_CATCH(ft)

    // Cleanup resources
    try
    {
        lRes = hRegKeyCLSID? ::RegCloseKey(hRegKeyCLSID): ERROR_SUCCESS;
        if (lRes != ERROR_SUCCESS)
            ft.Trace(VSSDBG_COORD, L"Error closing the hRegKeyCLSID key. [0x%08lx]", GetLastError());

        lRes = hRegKeyNewProvider? ::RegCloseKey(hRegKeyNewProvider): ERROR_SUCCESS;
        if (lRes != ERROR_SUCCESS)
            ft.Trace(VSSDBG_COORD, L"Error closing the hRegKeyNewProvider key. [0x%08lx]", GetLastError());

        lRes = hRegKeyProviders? ::RegCloseKey(hRegKeyProviders): ERROR_SUCCESS;
        if (lRes != ERROR_SUCCESS)
            ft.Trace(VSSDBG_COORD, L"Error closing the hRegKeyProviders key. [0x%08lx]", GetLastError());

        lRes = hRegKeyVSS? ::RegCloseKey(hRegKeyVSS): ERROR_SUCCESS;
        if (lRes != ERROR_SUCCESS)
            ft.Trace(VSSDBG_COORD, L"Error closing the hRegKeyVSS key. [0x%08lx]", GetLastError());

        // Delete all registry keys that correspond to this provider
        if (bProviderKeyCreated && ft.HrFailed()) {
            CVssFunctionTracer ft2(VSSDBG_COORD,  L"CVssAdmin::RegisterProvider_rec_del" );
            WCHAR   wszProviderKeyName[_MAX_KEYNAME_LEN];
            ::wsprintf( wszProviderKeyName, L"%s\\%s\\" WSTR_GUID_FMT,
                    wszVSSKey, wszVSSKeyProviders, GUID_PRINTF_ARG( ProviderId ));
            RecursiveDeleteKey( ft2, HKEY_LOCAL_MACHINE, wszProviderKeyName );
        }
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



STDMETHODIMP CVssAdmin::UnregisterProvider(
    IN      VSS_ID      ProviderId
    )

/*++

Routine Description:

    Unregister the provider. Remove the provider from the internal array if the array is already filled exist.

Arguments:

    VSS_ID      ProviderId

Return values:


    E_ACCESSDENIED 
        - The user is not administrator
    VSS_E_PROVIDER_IN_USE
        - A snapshot set is in progress.
    VSS_E_PROVIDER_NOT_REGISTERED
        - The provider with the given ID is not registered.

    [lock failures]
        E_OUTOFMEMORY

    [CVssProviderManager::RemoveProviderFromArray() failures]
        [lockObj failures]
            E_OUTOFMEMORY

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAdmin::UnregisterProvider" );
    WCHAR   wszKeyBuffer[_MAX_KEYNAME_LEN];

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account");

        if (ProviderId == VSS_SWPRV_ProviderId)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG,
                      L"Attempting to unregister the unique MS Software Snasphot provider");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: "
                  L"ProviderId = " WSTR_GUID_FMT,
                  GUID_PRINTF_ARG( ProviderId ));

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// If a snapshot set is in progress then abort un-registering
		if (CVssProviderManager::AreThereStatefulObjects())
            ft.Throw( VSSDBG_COORD, VSS_E_PROVIDER_IN_USE,
                      L"A snapshot set is in progress");

		// Notify the provider that is being unregistered. Abort unregistering in case of failure.
		// Unload the provider from memory. (forced since unregister was called)
		// Remove provider from m_pProvidersArray.
		if( !CVssProviderManager::RemoveProviderFromArray( ProviderId ))
            ft.Throw( VSSDBG_COORD, VSS_E_PROVIDER_NOT_REGISTERED,
                      L"The provider is not registered");

        // Delete all registry keys that correspond to this provider
        ::wsprintf( wszKeyBuffer, L"%s\\%s\\" WSTR_GUID_FMT,
                wszVSSKey, wszVSSKeyProviders, GUID_PRINTF_ARG( ProviderId ));
        RecursiveDeleteKey( ft, HKEY_LOCAL_MACHINE, wszKeyBuffer );
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssAdmin::AbortAllSnapshotsInProgress()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAdmin::AbortAllSnapshotsInProgress" );

	try
	{
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		CVssProviderManager::DeactivateAll();
    }
    VSS_STANDARD_CATCH(ft)

	return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\coord\src\async_shim.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module async_shim.cxx | Implementation of CVssShimAsync object
    @end

Author:

    Adi Oltean  [aoltean]  07/20/2000

Revision History:

    Name        Date        Comments
    aoltean     07/20/2000  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "worker.hxx"
#include "ichannel.hxx"
#include "shim.hxx"
#include "async_shim.hxx"
#include "vs_sec.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORASYSC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  CVssShimAsync


CVssShimAsync::CVssShimAsync():
    m_guidSnapshotSetId(GUID_NULL),
	m_ulOptionFlags(0),	
	m_ulVolumeCount(0),	
	m_ppwszVolumeNamesArray(NULL),
	m_hrState(S_OK)
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::CVssShimAsync" );
}


CVssShimAsync::~CVssShimAsync()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::~CVssShimAsync" );

	for (ULONG ulIndex = 0; ulIndex < m_ulVolumeCount; ulIndex++ )
	    ::VssFreeString(m_ppwszVolumeNamesArray[ulIndex]);
	delete[] m_ppwszVolumeNamesArray;
}


IVssAsync* CVssShimAsync::CreateInstanceAndStartJob(
	IN	    CVssShimObject*	pShimObject,
    IN      VSS_ID          guidSnapshotSetId,
	IN      ULONG           ulOptionFlags,	
	IN      ULONG           ulVolumeCount,	
	IN      VSS_PWSZ*       ppwszVolumeNamesArray
	)

/*++

Routine Description:

    Static method that creates a new instance of the CVssShimAsync interface and
    starts a background thread that runs the CVssShimAsync::OnRun.

Arguments:

    CVssShimObject*	pShimObject,
    VSS_ID          guidSnapshotSetId,
    ULONG           ulOptionFlags,	
    ULONG           ulVolumeCount,	
    VSS_PWSZ*       ppwszVolumeNamesArray

Throw values:

    E_OUTOFMEMORY
        - On CComObject<CVssAsync>::CreateInstance failure
        - On copy the data members for the async object.
        - On PrepareJob failure
        - On StartJob failure

    E_UNEXPECTED
        - On QI failures. We do not log (but we assert) since this is an obvious programming error.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::CreateInstanceAndStartJob" );
	CComPtr<IVssAsync> pAsync;

    // Allocate the COM object.
    CComObject<CVssShimAsync>* pObject;
    ft.hr = CComObject<CVssShimAsync>::CreateInstance(&pObject);
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
				  L"Error creating the CVssShimAsync instance. hr = 0x%08lx", ft.hr);
    BS_ASSERT(pObject);

    // Querying the IVssSnapshot interface. Now the ref count becomes 1.
    CComPtr<IUnknown> pUnknown = pObject->GetUnknown();
    BS_ASSERT(pUnknown);

	// Setting async object internal data
	BS_ASSERT(pShimObject);

	// Initialize allocated parameters
	pObject->m_guidSnapshotSetId = guidSnapshotSetId;
	pObject->m_ulOptionFlags = ulOptionFlags;
	pObject->m_ulVolumeCount = ulVolumeCount;
	pObject->m_ppwszVolumeNamesArray = new VSS_PWSZ[ulVolumeCount];
	if (pObject->m_ppwszVolumeNamesArray == NULL)
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
				  L"Error creating the CVssShimAsync instance. hr = 0x%08lx", ft.hr);

        ::ZeroMemory( reinterpret_cast<PVOID>( pObject->m_ppwszVolumeNamesArray ), sizeof( VSS_PWSZ ) * ulVolumeCount );

	// Copy each volume name
	for( ULONG ulIndex = 0; ulIndex < ulVolumeCount; ulIndex++) {
	    VssSafeDuplicateStr( ft,
	        pObject->m_ppwszVolumeNamesArray[ulIndex],
	        ppwszVolumeNamesArray[ulIndex]);
	}

	// AddRef is called - since the CVssShimAsync keeps a smart pointer.
    pObject->m_pShim = pShimObject;

    ft.hr = pUnknown->SafeQI(IVssAsync, &pAsync); // The ref count is 2.
    if ( ft.HrFailed() ) {
        BS_ASSERT(false);
        ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
				  L"Error querying the IVssAsync interface. hr = 0x%08lx", ft.hr);
    }
    BS_ASSERT(pAsync);

	// Prepare job (thread created in resume state)
	ft.hr = pObject->PrepareJob();
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Error preparing the job. hr = 0x%08lx", ft.hr);

	// Start job (now the background thread will start running).
	ft.hr = pObject->StartJob();
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Error starting the job. hr = 0x%08lx", ft.hr);

    // The reference count becomes 3 since we keep a reference for the background thread.

    // Right now the background thread is running. This thread will perform a Release when finishes.
    // This will keep the async object alive until the thread finishes.
    // But, we cannot put an AddRef in the OnInit/OnRun on the background thread,
    // (since in this thread we might
    // call all subsequent releases without giving a chance to the other thread to do an AddRef)
    // Also we cannot put an AddRef at creation since we didn't know at that time if the background
    // thread will run.
    // Therefore we must do the AddRef right here.
    // Beware, this AddRef is paired with an Release in the CVssShimAsync::OnFinish method:
    // Note: we are sure that we cannot reach reference count zero since the thread is surely running,
    //
    IUnknown* pUnknownTmp = pObject->GetUnknown();
    pUnknownTmp->AddRef();

	// Now the background thread related members (m_hrState, m_nPercentDone) begin to update.
    // The ref count goes back to 2

	return pAsync.Detach();	  // The ref count remains 2.
}


/////////////////////////////////////////////////////////////////////////////
//  CVssWorkerThread overrides


bool CVssShimAsync::OnInit()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::OnInit" );

	if (m_pShim != NULL)
	{
		// Setting snapshot set internal data
		BS_ASSERT(m_hrState == S_OK);
		m_hrState = VSS_S_ASYNC_PENDING;

		// Setting snapshot set internal data
		BS_ASSERT(!m_pShim->m_bCancel);
		m_pShim->m_bCancel = false;
    }

	return (m_pShim != NULL);
}


void CVssShimAsync::OnRun()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::OnRun" );

	try
	{
		// Check if the snapshot object is created.
		if (m_pShim == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE,
				L"Snapshot set object not yet created.");
		}

		// We assume that the async object is not yet released.
		// (the wait in destructor should ensure that).
		
		// Call SimulateSnapshotFreeze on the given object.
		ft.hr = m_pShim->SimulateSnapshotFreeze(
		            m_guidSnapshotSetId,
		            m_ulOptionFlags,
		            m_ulVolumeCount,
		            m_ppwszVolumeNamesArray);
		if (ft.hr != S_OK)
		{
			ft.Trace( VSSDBG_COORD,
					  L"Internal SimulateSnapshotFreeze failed. 0x%08lx", ft.hr);
			
			// Put the error code into the
			BS_ASSERT(m_hrState == VSS_S_ASYNC_PENDING);
			m_hrState = ft.hr;
		}

		// Now m_hrState may be VSS_S_ASYNC_CANCELLED
	}
	VSS_STANDARD_CATCH(ft)
}


void CVssShimAsync::OnFinish()	
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::OnFinish" );

    try
    {
		if (m_pShim)
		{
			if ( m_hrState == VSS_S_ASYNC_PENDING)
				m_hrState = VSS_S_ASYNC_FINISHED;
			// Else keep the m_hrState error code...
			// It may be VSS_S_ASYNC_CANCELLED, if CVssShimObject::TestIfCancelNeeded was called.
		}
		else
			BS_ASSERT(false);

        // Release the background thread reference to this object.
		// Note: We kept an reference around for the time when the backgropund thread is running.
        // In this way we avoid the destruction of the async interface while the
        // background thread is running.
        // The paired addref was done after a sucessful StartJob

        // Mark the thread object as "finished"
        MarkAsFinished();

        // We release the interface only if StartJob was returned with success
        IUnknown* pMyself = GetUnknown();
        pMyself->Release();
    }
    VSS_STANDARD_CATCH(ft)
}


void CVssShimAsync::OnTerminate()	
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::OnTerminate" );
}


/////////////////////////////////////////////////////////////////////////////
//  IVssAsync implementation


STDMETHODIMP CVssShimAsync::Cancel()

/*++

Routine Description:

    Cancels the current running process, if any.

Arguments:

    None.

Throw values:

    E_ACCESSDENIED
        - The user is not an administrator or a backup operator
    E_UNEXPECTED
        - m_pShim is NULL. Code bug, no logging.

    [lock failures]
        E_OUTOFMEMORY

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::Cancel" );

	try
	{
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account or does not have backup privilege enabled");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Safety check
		if (m_pShim == NULL) {
		    BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"m_pShim == NULL");
		}

		// If thread is already finished, return correct code.
		if ((m_hrState == VSS_S_ASYNC_FINISHED) || (m_hrState == VSS_S_ASYNC_CANCELLED))
			ft.hr = m_hrState;
		else	// Otherwise, inform the thread that it must cancel. The function returns immediately.
			m_pShim->m_bCancel = true;
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


STDMETHODIMP CVssShimAsync::Wait()

/*++

Routine Description:

    Waits until the process gets finished.

Arguments:

    None.

Throw values:

    E_ACCESSDENIED
        - The user is not an administrator or a backup operator
    E_UNEXPECTED
        - m_pShim is NULL. Code bug, no logging.
        - Thread handle is invalid. Code bug, no logging.
        - WaitForSingleObject failed. Code bug, no logging.

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::Wait" );

	try
	{
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account or does not have backup privilege enabled");

		// Safety check
		if (m_pShim == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"m_pShim == NULL");
		}

		// No async lock here!

		HANDLE hThread = GetThreadHandle();
		if (hThread == NULL)
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"invalid hThread");

		if (::WaitForSingleObject(hThread, INFINITE) == WAIT_FAILED) {
			ft.LogGenericWarning( VSSDBG_GEN,
			    L"WaitForSingleObject(%p,INFINITE) == WAIT_FAILED, GetLastError() == 0x%08lx",
			    hThread, GetLastError() );
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Wait failed. [0x%08lx]", ::GetLastError());
		}
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


STDMETHODIMP CVssShimAsync::QueryStatus(
				OUT     HRESULT* pHrResult,
				OUT     INT* pnReserved
				)

/*++

Routine Description:

    Query the status for the current running process, if any.

Arguments:

	OUT     HRESULT* pHrResult  - Will be filled with a value reflected by the current status
	OUT     INT* pnReserved     - Reserved today. It will be filled always with zero, if non-NULL

Throw values:

    E_ACCESSDENIED
        - The user is not an administrator or a backup operator
    E_UNEXPECTED
        - m_pShim is NULL. Code bug, no logging.
    E_INVALIDARG
        - NULL pHrResult

    [lock failures]
        E_OUTOFMEMORY

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::QueryStatus" );

	try
	{
		// Zero the [out] parameters
		::VssZeroOut(pHrResult);
		::VssZeroOut(pnReserved);

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account or does not have backup privilege enabled");

		// Argument check
		BS_ASSERT(pHrResult);
		if (pHrResult == NULL)
			ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"pHrResult == NULL");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Safety check
		if (m_pShim == NULL)
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"m_pShim == NULL");

		(*pHrResult) = m_hrState;
		ft.Trace( VSSDBG_COORD, L"Returning *pHrResult: 0x%08x", *pHrResult );
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\coord\src\coord.cxx ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Abstract:

    @doc
    @module Coord.cxx | Implementation of CVssCoordinator
    @end

Author:

    Adi Oltean  [aoltean]  07/09/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     07/09/1999  Created
    aoltean     07/23/1999  Adding List, moving Admin functions in the Admin.cxx
    aoltean     08/11/1999  Adding support for Software and test provider
    aoltean     08/18/1999  Adding events. Making itf pointers CComPtr.
                            Renaming XXXSnapshots -> XXXSnapshot
    aoltean     08/18/1999  Renaming back XXXSnapshot -> XXXSnapshots
                            More stabe state management
                            Resource deallocations is fair
                            More comments
                            Using CComPtr
    aoltean     09/09/1999  Moving constants in coord.hxx
                            Add Security checks
                            Add argument validation.
                            Move Query into query.cpp
                            Move AddvolumesToInternalList into private.cxx
                            dss -> vss
	aoltean		09/21/1999  Adding a new header for the "ptr" class.
	aoltean		09/27/1999	Provider-generic code.
	aoltean		10/04/1999	Treatment of writer error codes.
	aoltean		10/12/1999	Adding HoldWrites, ReleaseWrites
	aoltean		10/12/1999	Moving all code in Snap_set.cxx in order to facilitate the async interface.
	aoltean		10/15/1999	Adding async support

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "admin.hxx"
#include "provmgr.hxx"
#include "worker.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"
#include "snap_set.hxx"
#include "shim.hxx"
#include "async_shim.hxx"
#include "coord.hxx"
#include "vs_sec.hxx"


#include "async.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORCOORC"
//
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//  CVssCoordinator


STDMETHODIMP CVssCoordinator::SetContext(
	IN		LONG     lContext
    )
/*++

Routine description:

    Implements IVssCoordinator::SetContext

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::SetContext" );

    BS_ASSERT(false);
    return E_NOTIMPL;
    UNREFERENCED_PARAMETER(lContext);
}


STDMETHODIMP CVssCoordinator::StartSnapshotSet(
    OUT		VSS_ID*     pSnapshotSetId
    )
/*++

Routine description:

    Implements IVssCoordinator::StartSnapshotSet

Error codes:

    E_ACCESSDENIED
        - The user is not a backup operator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
        - CVssSnapshotSetObject::CreateInstance failures

    [CVssSnapshotSetObject::StartSnapshotSet() failures]
        E_OUTOFMEMORY
        VSS_E_BAD_STATE
            - wrong calling sequence.
        E_UNEXPECTED
            - if CoCreateGuid fails

        [Deactivate() failures] or
        [Activate() failures]
            [lockObj failures]
                E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::StartSnapshotSet" );

    try
    {
        // Initialize [out] arguments
        VssZeroOut( pSnapshotSetId );

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: pSnapshotSetId = %p", pSnapshotSetId );

        // Argument validation
		BS_ASSERT(pSnapshotSetId);
        if (pSnapshotSetId == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL pSnapshotSetId");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Create the snapshot object, if needed.
		// This call may throw
		// Remark: we cannot re-create this interface since the automatic garbage collection
		// requires that the snapshot set object should be alive.
		if (m_pSnapshotSet == NULL)
            m_pSnapshotSet = CVssSnapshotSetObject::CreateInstance();
					
		// Call StartSnapshotSet on the given object.
        ft.hr = m_pSnapshotSet->StartSnapshotSet(pSnapshotSetId);
		if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, ft.hr,
					  L"Internal StartSnapshotSet failed. 0x%08lx", ft.hr);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssCoordinator::AddToSnapshotSet(
    IN      VSS_PWSZ    pwszVolumeName,
    IN      VSS_ID      ProviderId,
    OUT     VSS_ID *    pSnapshotId
    )
/*++

Routine description:

    E_ACCESSDENIED
        - The user is not a backup operator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
    VSS_E_BAD_STATE
        - Wrong calling sequence
    VSS_E_VOLUME_NOT_SUPPORTED
        - The volume is not supported by any registered providers

    [CVssCoordinator::IsVolumeSupported() failures]
        E_ACCESSDENIED
            The user is not a backup operator.
        E_INVALIDARG
            NULL pointers passed as parameters or a volume name in an invalid format.
        VSS_E_PROVIDER_NOT_REGISTERED
            The Provider ID does not correspond to a registered provider.
        VSS_E_OBJECT_NOT_FOUND
            If the volume name does not correspond to an existing mount point

        [CVssProviderManager::GetProviderInterface() failures]
            E_OUTOFMEMORY

            [lockObj failures]
                E_OUTOFMEMORY    

            [LoadInternalProvidersArray() failures]
                E_OUTOFMEMORY
                E_UNEXPECTED
                    - error while reading from registry. An error log entry is added describing the error.

            [CVssSoftwareProviderWrapper::CreateInstance() failures]
                E_OUTOFMEMORY

                [CoCreateInstance() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - The provider interface couldn't be created. An error log entry is added describing the error.
                
                [OnLoad() failures]
                [QueryInterface failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.
                    VSS_E_PROVIDER_VETO
                        - Expected provider error. The provider already did the logging.

        [CVssProviderManager::GetProviderItfArray() failures]
            E_OUTOFMEMORY

            [lockObj failures]
                E_OUTOFMEMORY
            
            [LoadInternalProvidersArray() failures]
                E_OUTOFMEMORY
                E_UNEXPECTED
                    - error while reading from registry. An error log entry is added describing the error.

            [CVssSoftwareProviderWrapper::CreateInstance() failures]
                E_OUTOFMEMORY

                [CoCreateInstance() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - The provider interface couldn't be created. An error log entry is added describing the error.
                
                [OnLoad() failures]
                [QueryInterface failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.
                    VSS_E_PROVIDER_VETO
                        - Expected provider error. The provider already did the logging.

        [IVssSnapshotProvider::IsVolumeSupported() failures]
            E_ACCESSDENIED
                The user is not an administrator.
            E_INVALIDARG
                NULL pointers passed as parameters or a volume name in an invalid format.
            E_OUTOFMEMORY
                Out of memory or other system resources           
            E_UNEXPECTED
                Unexpected programming error. Logging not done and not needed.
            VSS_E_PROVIDER_VETO
                An error occured while opening the IOCTL channel. The error is logged.
            VSS_E_OBJECT_NOT_FOUND
                The device does not exist or it is not ready.
        

    [CVssSnapshotSetObject::AddToSnapshotSet() failures]
        E_OUTOFMEMORY
        VSS_E_BAD_STATE
            - wrong calling sequence.
        E_INVALIDARG
            - Invalid arguments (for example the volume name is invalid).
        VSS_E_VOLUME_NOT_SUPPORTED
            - The volume is not supported by any registered providers

        [GetSupportedProviderId() failures]
            E_OUTOFMEMORY
            E_INVALIDARG
                - if the volume is not in the correct format.
            VSS_E_VOLUME_NOT_SUPPORTED
                - If the given volume is not supported by any provider

            [QueryProvidersIntoArray() failures]
                E_OUTOFMEMORY

                [lockObj failures]
                    E_OUTOFMEMORY

                [LoadInternalProvidersArray() failures]
                    E_OUTOFMEMORY
                    E_UNEXPECTED
                        - error while reading from registry. An error log entry is added describing the error.

                [CVssSoftwareProviderWrapper::CreateInstance failures]
                    E_OUTOFMEMORY

                    [CoCreateInstance() failures]
                        VSS_E_UNEXPECTED_PROVIDER_ERROR
                            - The provider interface couldn't be created. An error log entry is added describing the error.

                    [OnLoad() failures]
                    [QueryInterface failures]
                        VSS_E_UNEXPECTED_PROVIDER_ERROR
                            - Unexpected provider error. The error code is logged into the event log.
                        VSS_E_PROVIDER_VETO
                            - Expected provider error. The provider already did the logging.

                [InitializeAsProvider() failures]
                    E_OUTOFMEMORY

                [IVssSnapshotProvider::IsVolumeSupported() failures]
                    E_INVALIDARG
                        NULL pointers passed as parameters or a volume name in an invalid format.
                    E_OUTOFMEMORY
                        Out of memory or other system resources           
                    VSS_E_PROVIDER_VETO
                        An error occured while opening the IOCTL channel. The error is logged.
                    VSS_E_OBJECT_NOT_FOUND
                        The device does not exist or it is not ready.

        [GetProviderInterfaceForSnapshotCreation() failures]

            VSS_E_PROVIDER_NOT_REGISTERED

            [lockObj failures]
                E_OUTOFMEMORY

            [LoadInternalProvidersArray() failures]
                E_OUTOFMEMORY
                E_UNEXPECTED
                    - error while reading from registry. An error log entry is added describing the error.

            [CVssSoftwareProviderWrapper::CreateInstance() failures]
                E_OUTOFMEMORY

                [CoCreateInstance() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - The provider interface couldn't be created. An error log entry is added describing the error.

                [OnLoad() failures]
                [QueryInterface failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.
                    VSS_E_PROVIDER_VETO
                        - Expected provider error. The provider already did the logging.

        [CVssQueuedVolumesList::AddVolume() failures]
            E_UNEXPECTED
                - The thread state is incorrect. No logging is done - programming error.
            VSS_E_OBJECT_ALREADY_EXISTS
                - The volume was already added to the snapshot set.
            VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED
                - The maximum number of volumes was reached.
            E_OUTOFMEMORY

            [Initialize() failures]
                E_OUTOFMEMORY

        [BeginPrepareSnapshot() failures]
            E_INVALIDARG
            VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER
            VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.
            VSS_E_PROVIDER_VETO
                - Expected provider error. The provider already did the logging.
            VSS_E_OBJECT_NOT_FOUND
                - Volume not found or device not connected.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::AddToSnapshotSet" );

    try
    {
        // Initialize out parameters
        ::VssZeroOut(pSnapshotId);
        
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
			 L"  VolumeName = %s\n"
             L"  ProviderId = " WSTR_GUID_FMT L"\n"
             L"  pSnapshotId = %p\n",
             pwszVolumeName,
             GUID_PRINTF_ARG( ProviderId ),
             pSnapshotId);

        // Argument validation
        if (pwszVolumeName == NULL || wcslen(pwszVolumeName) == 0)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL pwszVolumeName");
        if (pSnapshotId == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL pSnapshotId");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Check if the snapshot object is created.
		if (m_pSnapshotSet == NULL)
            ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE,
                L"Snapshot set object not yet created.");

        // Check to see if the volume is supported 
        BOOL bIsVolumeSupported = FALSE;
		ft.hr = IsVolumeSupported( ProviderId, pwszVolumeName, &bIsVolumeSupported);
		if (ft.HrFailed())
		    ft.Throw(VSSDBG_COORD, ft.hr, 
		        L"IsVolumeSupported() failed with error code 0x%08lx", ft.hr);
		if (!bIsVolumeSupported)
		    ft.Throw(VSSDBG_COORD, 
		        (ProviderId == GUID_NULL)? 
		            VSS_E_VOLUME_NOT_SUPPORTED: VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER, 
		        L"Volume not supported");
			
		// Call StartSnapshotSet on the given object.
        ft.hr = m_pSnapshotSet->AddToSnapshotSet( pwszVolumeName,
			ProviderId,
			pSnapshotId);
		if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, ft.hr,
					  L"Internal AddToSnapshotSet failed. 0x%08lx", ft.hr);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssCoordinator::DoSnapshotSet(
    IN     IDispatch*  pCallback,
    OUT     IVssAsync** ppAsync
    )
/*++

Routine description:

    Implements IVssCoordinator::DoSnapshotSet
    Calls synchronously the CVssSnapshotSetObject::DoSnapshotSet in a separate thread

Error codes:

    E_ACCESSDENIED
        - The user is not a backup operator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
    VSS_E_BAD_STATE
        - Wrong calling sequence

    [CVssAsync::CreateInstanceAndStartJob] failures]
        E_OUTOFMEMORY
            - On CComObject<CVssAsync>::CreateInstance failure
            - On PrepareJob failure
            - On StartJob failure

        E_UNEXPECTED
            - On QI failures. We do not log (but we assert) since this is an obvious programming error.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::DoSnapshotSet" );

    try
    {
        // Nullify all out parameters
        ::VssZeroOutPtr(ppAsync);

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Check if the snapshot object is created.
		if (m_pSnapshotSet == NULL)
            ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE,
                L"Snapshot set object not yet created.");

        if (pCallback != NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"Non-NULL callback interface.");
		if (ppAsync == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL async interface.");
		
		// Create the new async interface corresponding to the new job.
		// Remark: AddRef will be called on the snapshot set object.
		CComPtr<IVssAsync> ptrAsync;
		ptrAsync.Attach(CVssAsync::CreateInstanceAndStartJob( m_pSnapshotSet));

		// The reference count of the pAsync interface must be 2
		// (one for the returned interface and one for the background thread).
		(*ppAsync) = ptrAsync.Detach();	// Drop that interface in the OUT parameter
		
        // The ref count remnains 2
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssCoordinator::GetSnapshotProperties(
    IN      VSS_ID          SnapshotId,
	OUT 	VSS_SNAPSHOT_PROP	*pProp
    )
/*++

Routine description:

    Implements IVssCoordinator::GetSnapshotProperties

Error codes:

    E_ACCESSDENIED
        - The user is not a backup operator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
    VSS_E_BAD_STATE
        - Wrong calling sequence

    [CVssProviderManager::GetProviderItfArray() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.

            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

    [IVssSnapshotProvider::GetSnapshotProperties() failures]
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.
        VSS_E_OBJECT_NOT_FOUND
            - The snapshot with this ID does not exists.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::GetSnapshotProperties" );

    try
    {
        // Initialize [out] arguments
        ::VssZeroOut( pProp );

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
             L"  SnapshotId = " WSTR_GUID_FMT L"\n"
             L"  pProp = %p\n",
             GUID_PRINTF_ARG( SnapshotId ),
             pProp);

        // Argument validation
		BS_ASSERT(pProp);
        if (pProp == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL pProp");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Get the array of interfaces
		CSnapshotProviderItfArray ItfArray;
		CVssProviderManager::GetProviderItfArray( ItfArray );

		// For each provider get all objects tht corresponds to the filter
		for (int nIndex = 0; nIndex < ItfArray.GetSize(); nIndex++ )
		{
			CComPtr<IVssSnapshotProvider> pProviderItf = ItfArray[nIndex].GetInterface();
			BS_ASSERT(pProviderItf);

			// Get the snapshot interface
			ft.hr = pProviderItf->GetSnapshotProperties(
				SnapshotId,
				pProp);

			// If a snapshot was not found then continue with the next provider.
			if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
				continue;
				
			// If an error happened then abort the entire search.
			if (ft.HrFailed())
				ft.TranslateProviderError( VSSDBG_COORD, ItfArray[nIndex].GetProviderId(),
				    L"GetSnapshot("WSTR_GUID_FMT L",%p)",
				    GUID_PRINTF_ARG(SnapshotId), pProp);

			// The snapshot was found
			break;
		}
    }
    VSS_STANDARD_CATCH(ft)

	// The ft.hr may be an VSS_E_OBJECT_NOT_FOUND or not.
    return ft.hr;
}


STDMETHODIMP CVssCoordinator::ExposeSnapshot(
    IN      VSS_ID SnapshotId,
    IN      VSS_PWSZ wszPathFromRoot,
    IN      LONG lAttributes,
    IN      VSS_PWSZ wszExpose,
    OUT     VSS_PWSZ *pwszExposed
    )
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::ExposeSnapshot" );

    return E_NOTIMPL;
    UNREFERENCED_PARAMETER(SnapshotId);
    UNREFERENCED_PARAMETER(wszPathFromRoot);
    UNREFERENCED_PARAMETER(lAttributes);
    UNREFERENCED_PARAMETER(wszExpose);
    UNREFERENCED_PARAMETER(pwszExposed);
}
    

STDMETHODIMP CVssCoordinator::RemountReadWrite(
	IN      VSS_ID SnapshotId,
	OUT     IVssAsync** ppAsync
    )
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::RemountReadWrite" );

    return E_NOTIMPL;
    UNREFERENCED_PARAMETER(SnapshotId);
    UNREFERENCED_PARAMETER(ppAsync);
}


STDMETHODIMP CVssCoordinator::ImportSnapshots(
	IN      BSTR bstrXMLSnapshotSet,
	OUT     IVssAsync** ppAsync
    )
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::ImportSnapshots" );

    return E_NOTIMPL;
    UNREFERENCED_PARAMETER(bstrXMLSnapshotSet);
    UNREFERENCED_PARAMETER(ppAsync);
}


STDMETHODIMP CVssCoordinator::BreakSnapshotSet(
	[in]	VSS_ID		    SnapshotSetId
    )
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::BreakSnapshotSet" );

    return E_NOTIMPL;
    UNREFERENCED_PARAMETER(SnapshotSetId);
}


STDMETHODIMP CVssCoordinator::IsVolumeSupported(
    IN      VSS_ID          ProviderId,                
    IN      VSS_PWSZ        pwszVolumeName, 
    OUT     BOOL *          pbIsSupported
    )

/*++

Description:

    This call is used to check if a volume can be snapshotted or not by the 
    corresponding provider.
 
Parameters
    ProviderID
        [in] It can be: 
            - GUID_NULL: in this case the function checks if the volume is supported 
            by at least one provider
            - A provider ID: In this case the function checks if the volume is supported 
            by the indicated provider
    pwszVolumeName
        [in] The volume name to be checked, It must represent a volume mount point, like
        in the \\?\Volume{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\ format or c:\
        (with trailing backslash)
    pbIsSupported
        [out] Non-NULL pointer that receives TRUE if the volume can be 
        snapshotted using this provider or FALSE otherwise.
 
Return codes
    S_OK
        The function completed with success
    E_ACCESSDENIED
        The user is not a backup operator.
    E_INVALIDARG
        NULL pointers passed as parameters or a volume name in an invalid format.
    VSS_E_PROVIDER_NOT_REGISTERED
        The Provider ID does not correspond to a registered provider.
    VSS_E_OBJECT_NOT_FOUND
        If the volume name does not correspond to an existing mount point or volume.
    VSS_E_UNEXPECTED_PROVIDER_ERROR
        Unexpected provider error on calling IsVolumeSupported

    [CVssProviderManager::GetProviderInterface() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY    

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

    [CVssProviderManager::GetProviderItfArray() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY
        
        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

    [IVssSnapshotProvider::IsVolumeSupported() failures]
        E_INVALIDARG
            NULL pointers passed as parameters or a volume name in an invalid format.
        E_OUTOFMEMORY
            Out of memory or other system resources           
        VSS_E_PROVIDER_VETO
            An error occured while opening the IOCTL channel. The error is logged.
        VSS_E_OBJECT_NOT_FOUND
            The device does not exist or it is not ready.

    [VerifyVolumeIsSupportedByVSS]
        VSS_E_OBJECT_NOT_FOUND
            - The volume was not found
     
Remarks
    The function will return TRUE in the pbSupportedByThisProvider 
    parameter if it is possible to create a snapshot on the given volume. 
    The function must return TRUE on that volume even if the current 
    configuration does not allow the creation of a snapshot on that volume. 
    For example, if the maximum number of snapshots were reached on the 
    given volume (and therefore no more snapshots can be created on that volume), 
    the method must still indicate that the volume can be snapshotted.
 
--*/


{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::IsVolumeSupported" );
	WCHAR wszVolumeNameInternal[nLengthOfVolMgmtVolumeName + 1];

    try
    {
        // Initialize [out] arguments
        VssZeroOut( pbIsSupported );

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
             L"  ProviderId = " WSTR_GUID_FMT L"\n"
             L"  pwszVolumeName = %p\n"
             L"  pbSupportedByThisProvider = %p\n",
             GUID_PRINTF_ARG( ProviderId ),
             pwszVolumeName,
             pbIsSupported);

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

        // Argument validation
        if ( (pwszVolumeName == NULL) || (wcslen(pwszVolumeName) == 0))
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"pwszVolumeName is NULL");
        if (pbIsSupported == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"Invalid bool ptr");
    
    	// Getting the volume name
    	if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeName,
    			wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal)))
    		ft.Throw( VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, 
    				  L"GetVolumeNameForVolumeMountPoint(%s,...) "
    				  L"failed with error code 0x%08lx", pwszVolumeName, GetLastError());
    	BS_ASSERT(::wcslen(wszVolumeNameInternal) != 0);
    	BS_ASSERT(::IsVolMgmtVolumeName( wszVolumeNameInternal ));

        // Verify if the volume is supported by VSS itself.
        // If not this will throw an VSS_E_VOLUME_NOT_SUPPORTED exception
        VerifyVolumeIsSupportedByVSS( wszVolumeNameInternal );

        // Choose the way of checking if the volume is supported
        if (ProviderId != GUID_NULL) {
            // Try to find the provider interface
    		CComPtr<IVssSnapshotProvider> pProviderItf;
            if (!(CVssProviderManager::GetProviderInterface(ProviderId,&pProviderItf)))
				ft.Throw( VSSDBG_COORD, VSS_E_PROVIDER_NOT_REGISTERED, 
				    L"Provider not found");

            // Call the Provider's IsVolumeSupported
            BS_ASSERT(pProviderItf);
            ft.hr = pProviderItf->IsVolumeSupported( 
                        wszVolumeNameInternal, pbIsSupported);
            if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
                ft.Throw(VSSDBG_COORD, 
                    VSS_E_OBJECT_NOT_FOUND, L"Volume % not found", wszVolumeNameInternal);
            if (ft.HrFailed())
    			ft.TranslateProviderError( VSSDBG_COORD, ProviderId, 
    			    L"IVssSnapshotProvider::IsVolumeSupported() failed with 0x%08lx", ft.hr );
        } else {
    		CComPtr<IVssSnapshotProvider> pProviderItf;
    		CSnapshotProviderItfArray ItfArray;

			// Get the array of interfaces
			CVssProviderManager::GetProviderItfArray( ItfArray );

			// Ask each provider if the volume is supported.
			// If we find at least one provider that supports the 
			// volume then stop iteration.
			for (int nIndex = 0; nIndex < ItfArray.GetSize(); nIndex++ )
			{
				pProviderItf = ItfArray[nIndex].GetInterface();
				BS_ASSERT(pProviderItf);

                BOOL bVolumeSupportedByThisProvider = FALSE;               
                ft.hr = pProviderItf->IsVolumeSupported( 
                            wszVolumeNameInternal, &bVolumeSupportedByThisProvider);
                if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
                    ft.Throw(VSSDBG_COORD, 
                        VSS_E_OBJECT_NOT_FOUND, L"Volume % not found", wszVolumeNameInternal);
				if (ft.HrFailed())
					ft.TranslateProviderError( VSSDBG_COORD, ItfArray[nIndex].GetProviderId(),
                        L"Cannot ask provider " WSTR_GUID_FMT
                        L" if volume is supported. [0x%08lx]", 
                        GUID_PRINTF_ARG(GUID_NULL), ft.hr);

                // Check to see if the volume is supported by this provider.
				if (bVolumeSupportedByThisProvider) {
					BS_ASSERT(pbIsSupported);
					(*pbIsSupported) = TRUE;
					break;
				}
			}
        }
    }
    VSS_STANDARD_CATCH(ft)

    // If an exception was thrown from VerifyVolumeIsSupportedByVSS
    if (ft.hr == VSS_E_VOLUME_NOT_SUPPORTED)
        ft.hr = S_OK;
    
    return ft.hr;
}


STDMETHODIMP CVssCoordinator::IsVolumeSnapshotted(
    IN      VSS_ID          ProviderId,                
    IN      VSS_PWSZ        pwszVolumeName, 
    OUT     BOOL *          pbSnapshotsPresent,
   	OUT 	LONG *		    plSnapshotCompatibility
    )

/*++

Description:

    This call is used to check if a volume can be snapshotted or not by the 
    corresponding provider.
 
Parameters
    ProviderID
        [in] It can be: 
            - GUID_NULL: in this case the function checks if the volume is supported 
            by at least one provider
            - A provider ID
    pwszVolumeName
        [in] The volume name to be checked, It mus represent a mount point, like
        in the \\?\Volume{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\ format or c:\
        (with trailing backslash)
    pbSnapshotPresent
        [out] Non-NULL pointer that receives TRUE if the volume has at least 
        one snapshot or FALSE otherwise.
 
Return codes
    S_OK
        The function completed with success
    E_ACCESSDENIED
        The user is not a backup operator.
    E_INVALIDARG
        NULL pointers passed as parameters or a volume name in an invalid format.
    VSS_E_PROVIDER_NOT_REGISTERED
        The Provider ID does not correspond to a registered provider.
    VSS_E_OBJECT_NOT_FOUND
        If the volume name does not correspond to an existing mount point or volume.
    VSS_E_UNEXPECTED_PROVIDER_ERROR
        Unexpected provider error on calling IsVolumeSnapshotted

    [CVssProviderManager::GetProviderInterface() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY    

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

    [CVssProviderManager::GetProviderItfArray() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY
        
        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

    [IVssSnapshotProvider::IsVolumeSnapshotted() failures]
        E_INVALIDARG
            NULL pointers passed as parameters or a volume name in an invalid format.
        E_OUTOFMEMORY
            Out of memory or other system resources           
        VSS_E_PROVIDER_VETO
            An error occured while opening the IOCTL channel. The error is logged.
        VSS_E_OBJECT_NOT_FOUND
            The device does not exist or it is not ready.

    [VerifyVolumeIsSupportedByVSS]
        VSS_E_OBJECT_NOT_FOUND
            - The volume was not found
     
Remarks
    The function will return S_OK even if the current volume is a non-supported one. 
    In this case FALSE must be returned in the pbSnapshotPresent parameter.
 
--*/


{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::IsVolumeSnapshotted" );
	WCHAR wszVolumeNameInternal[nLengthOfVolMgmtVolumeName + 1];

    try
    {
        // Initialize [out] arguments
        VssZeroOut( pbSnapshotsPresent );
        VssZeroOut( plSnapshotCompatibility );
        
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
             L"  ProviderId = " WSTR_GUID_FMT L"\n"
             L"  pwszVolumeName = %p\n"
             L"  pbSupportedByThisProvider = %p\n"
             L"  plSnapshotCompatibility = %p\n",
             GUID_PRINTF_ARG( ProviderId ),
             pwszVolumeName,
             pbSnapshotsPresent,
             plSnapshotCompatibility
             );

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

        // Argument validation
        if ( (pwszVolumeName == NULL) || (wcslen(pwszVolumeName) == 0))
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"pwszVolumeName is NULL");
        if (pbSnapshotsPresent == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"Invalid bool ptr");
        if (plSnapshotCompatibility == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"Invalid ptr");
    
    	// Getting the volume name
    	if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeName,
    			wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal)))
    		ft.Throw( VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, 
    				  L"GetVolumeNameForVolumeMountPoint(%s,...) "
    				  L"failed with error code 0x%08lx", pwszVolumeName, GetLastError());
    	BS_ASSERT(::wcslen(wszVolumeNameInternal) != 0);
    	BS_ASSERT(::IsVolMgmtVolumeName( wszVolumeNameInternal ));

        // Verify if the volume is supported by VSS itself.
        // If not this will throw an VSS_E_VOLUME_NOT_SUPPORTED exception
        VerifyVolumeIsSupportedByVSS( wszVolumeNameInternal );

        // Choose the way of checking if the volume is supported
        if (ProviderId != GUID_NULL) {
            // Try to find the provider interface
    		CComPtr<IVssSnapshotProvider> pProviderItf;
            if (!(CVssProviderManager::GetProviderInterface(ProviderId,&pProviderItf)))
				ft.Throw( VSSDBG_COORD, VSS_E_PROVIDER_NOT_REGISTERED, 
				    L"Provider not found");

            // Call the Provider's IsVolumeSnapshotted
            BS_ASSERT(pProviderItf);
            ft.hr = pProviderItf->IsVolumeSnapshotted( 
                        wszVolumeNameInternal, 
                        pbSnapshotsPresent, 
                        plSnapshotCompatibility);
            if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
                ft.Throw(VSSDBG_COORD, 
                    VSS_E_OBJECT_NOT_FOUND, L"Volume % not found", wszVolumeNameInternal);
            if (ft.HrFailed())
    			ft.TranslateProviderError( VSSDBG_COORD, ProviderId, 
    			    L"IVssSnapshotProvider::IsVolumeSnapshotted() failed with 0x%08lx", ft.hr );
        } else {
    		CComPtr<IVssSnapshotProvider> pProviderItf;
    		CSnapshotProviderItfArray ItfArray;

			// Get the array of interfaces
			CVssProviderManager::GetProviderItfArray( ItfArray );

			// Ask each provider if the volume is supported.
			// If we find at least one provider that supports the 
			// volume then stop iteration.
			for (int nIndex = 0; nIndex < ItfArray.GetSize(); nIndex++ )
			{
				pProviderItf = ItfArray[nIndex].GetInterface();
				BS_ASSERT(pProviderItf);

                BOOL bVolumeSnapshottedByThisProvider = FALSE;               
                LONG lSnapshotCompatibility = 0;               
                ft.hr = pProviderItf->IsVolumeSnapshotted( 
                            wszVolumeNameInternal, 
                            &bVolumeSnapshottedByThisProvider, 
                            &lSnapshotCompatibility);
                if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
                    ft.Throw(VSSDBG_COORD, 
                        VSS_E_OBJECT_NOT_FOUND, L"Volume % not found", wszVolumeNameInternal);
				if (ft.HrFailed())
					ft.TranslateProviderError( VSSDBG_COORD, ItfArray[nIndex].GetProviderId(),
                        L"Cannot ask provider " WSTR_GUID_FMT
                        L" if volume is snapshotted. [0x%08lx]", 
                        GUID_PRINTF_ARG(GUID_NULL), ft.hr);

                // Check to see if the volume has snapshots on this provider.
				if (bVolumeSnapshottedByThisProvider) {
					BS_ASSERT(pbSnapshotsPresent);
					(*pbSnapshotsPresent) = TRUE;
					(*plSnapshotCompatibility) |= lSnapshotCompatibility;
				}
			}
        }
    }
    VSS_STANDARD_CATCH(ft)

    // If an exception was thrown from VerifyVolumeIsSupportedByVSS
    if (ft.hr == VSS_E_VOLUME_NOT_SUPPORTED)
        ft.hr = S_OK;
    
    return ft.hr;
}



STDMETHODIMP CVssCoordinator::SetWriterInstances( 
	IN  	LONG		    lWriterInstanceIdCount, 				
    IN      VSS_ID          *rgWriterInstanceId
    )
/*++

Routine description:

    Implements IVssCoordinator::SetContext

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::SetWriterInstances" );

    BS_ASSERT(false);
    return E_NOTIMPL;
    UNREFERENCED_PARAMETER(lWriterInstanceIdCount);
    UNREFERENCED_PARAMETER(rgWriterInstanceId);
}



STDMETHODIMP CVssCoordinator::SimulateSnapshotFreeze(
    IN      VSS_ID          guidSnapshotSetId,
	IN      ULONG           ulOptionFlags,	
	IN      ULONG           ulVolumeCount,	
	IN      VSS_PWSZ*       ppwszVolumeNamesArray,
	OUT     IVssAsync**     ppAsync 					
	)
/*++

Routine description:

    Implements IVssShim::SimulateSnapshotFreeze

Error codes:

    E_ACCESSDENIED
        - The user is not a backup operator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
    VSS_E_BAD_STATE
        - Wrong calling sequence

    [CVssAsyncShim::CreateInstanceAndStartJob() failures]
        E_OUTOFMEMORY
            - On CComObject<CVssAsync>::CreateInstance failure
            - On copy the data members for the async object.
            - On PrepareJob failure
            - On StartJob failure

        E_UNEXPECTED
            - On QI failures. We do not log (but we assert) since this is an obvious programming error.

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::SimulateSnapshotFreeze" );

    try
    {
        // Nullify all out parameters
        ::VssZeroOutPtr(ppAsync);

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

		if (ppAsync == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL async interface.");
		
		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Create the shim object, if needed.
		// This call may throw
		if (m_pShim == NULL)
            m_pShim = CVssShimObject::CreateInstance();
		else {
		    // TBD: Ckeck and throw VSS_E_BAD_STATE
		    // if another "simulate background thread is already running" !!!!!
		}
					
		// Create the new async interface corresponding to the new job.
		// Remark: AddRef will be called on the shim object.
		CComPtr<IVssAsync> ptrAsync;
		ptrAsync.Attach(CVssShimAsync::CreateInstanceAndStartJob(
		                    m_pShim,
		                    guidSnapshotSetId,
		                    ulOptionFlags,
		                    ulVolumeCount,
		                    ppwszVolumeNamesArray));
		if (ptrAsync == NULL)
			ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Async interface creation failed");

		// The reference count of the pAsync interface must be 2
		// (one for the returned interface and one for the background thread).
		(*ppAsync) = ptrAsync.Detach();	// Drop that interface in the OUT parameter
		
        // The ref count remnains 2
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssCoordinator::SimulateSnapshotThaw(
    IN      VSS_ID            guidSnapshotSetId
    )
/*++

Routine description:

    Implements IVssShim::SimulateSnapshotThaw

Error codes:

    E_ACCESSDENIED
        - The user is not a backup operator
    VSS_E_BAD_STATE
        - Wrong calling sequence

    !!! TBD !!!

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::SimulateSnapshotThaw" );

    try
    {
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

        //
        // most likely the shim object is not around since SimulateSnapshotFreeze in
        // VssApi releases the IVssShim interface before it returns.
        //
		if (m_pShim == NULL)
            m_pShim = CVssShimObject::CreateInstance();

        // Call the thaw method.
		ft.hr = m_pShim->SimulateSnapshotThaw(guidSnapshotSetId);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssCoordinator::WaitForSubscribingCompletion()
/*++

Routine description:

    Implements IVssShim::SimulateSnapshotThaw

Error codes:

    E_ACCESSDENIED
        - The user is not a backup operator

    [_Module.WaitForSubscribingCompletion() failures]
        E_UNEXPECTED
            - WaitForSingleObject failures

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::WaitForSubscribingCompletion" );

    try
    {
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

    	_Module.WaitForSubscribingCompletion();
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



CVssCoordinator::~CVssCoordinator()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::~CVssCoordinator" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\coord\src\globals.cpp ===
//
// globals.cpp : define all the stinking global vars :(
//



#pragma warning (disable: 4268)
#include <stdafx.hxx>

#define DBINITCONSTANTS
#include <oledb.h>
#include <oledberr.h>
#include <sqloledb.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\coord\src\delete.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Delete.cxx | Implementation of CVssCoordinator::DeleteSnapshots
    @end

Author:

    Adi Oltean  [aoltean]  10/10/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     10/10/1999  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"
#include "vssmsg.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "admin.hxx"
#include "provmgr.hxx"
#include "worker.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"
#include "snap_set.hxx"
#include "vs_sec.hxx"
#include "shim.hxx"
#include "coord.hxx"


////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORDELEC"
//
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//  CVssCoordinator


STDMETHODIMP CVssCoordinator::DeleteSnapshots(
    IN      VSS_ID          SourceObjectId,
    IN      VSS_OBJECT_TYPE eSourceObjectType,
	IN		BOOL			bForceDelete,			
	OUT		LONG*			plDeletedSnapshots,		
	OUT		VSS_ID*			pNondeletedSnapshotID
    )
/*++

Routine description:

    Implements the IVSsCoordinator::Delete

Error codes:

    E_ACCESSDENIED 
        - The user is not a backup operator
    E_INVALIDARG
        - Invalid arguments
    VSS_E_OBJECT_NOT_FOUND
        - Object identified by SourceObjectId not found.

    [GetProviderItfArray() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY
        
        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

    [GetProviderInterface() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY    

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

    [DeleteSnapshots failures]
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::DeleteSnapshots" );

    try
    {
		::VssZeroOut(plDeletedSnapshots);
		::VssZeroOut(pNondeletedSnapshotID);
		
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
				L"  SourceObjectId = " WSTR_GUID_FMT L"\n"
				L"  eSourceObjectType = %d\n"
				L"  bForceDelete = %d"
				L"  plDeletedSnapshots = %p"
				L"  pNondeletedSnapshotID = %p",
				GUID_PRINTF_ARG( SourceObjectId ),
				eSourceObjectType,
				bForceDelete,			
				plDeletedSnapshots,		
				pNondeletedSnapshotID
             	);

        // Argument validation
		BS_ASSERT(plDeletedSnapshots);
        if (plDeletedSnapshots == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL plDeletedSnapshots");
		BS_ASSERT(pNondeletedSnapshotID);
        if (pNondeletedSnapshotID == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL pNondeletedSnapshotID");

		// Delegating the call to the providers
		LONG lLocalDeletedSnapshots = 0;
		CSnapshotProviderItfArray ItfArray;
		CComPtr<IVssSnapshotProvider> pProviderItf;
		switch(eSourceObjectType)
		{
		case VSS_OBJECT_SNAPSHOT_SET:
		case VSS_OBJECT_SNAPSHOT:
			{
				// Get the array of interfaces
				CVssProviderManager::GetProviderItfArray( ItfArray );

				// For each provider get all objects tht corresponds to the filter
				bool bObjectFound = false;
				for (int nIndex = 0; nIndex < ItfArray.GetSize(); nIndex++ )
				{
					pProviderItf = ItfArray[nIndex].GetInterface();
					BS_ASSERT(pProviderItf);

					// Query the provider
					ft.hr = pProviderItf->DeleteSnapshots(
						SourceObjectId,
						eSourceObjectType,
						bForceDelete,
						&lLocalDeletedSnapshots,
						pNondeletedSnapshotID
						);

					// Increment the number of deleted snapshots, even in error case.
					// In error case the DeleteSnapshots may fail in the middle of deletion.
					// Some snapshots may get a chance to be deleted.
					(*plDeletedSnapshots) += lLocalDeletedSnapshots;

					// Treat the "object not found" case.
					// The DeleteSnapshots may fail if the object is not found on a certain provider.
					// If the object is not found on ALL providers then this function must return
					// an VSS_E_OBJECT_NOT_FOUND error.
					if (ft.HrSucceeded())
						bObjectFound = true;
					else if (ft.hr == VSS_E_OBJECT_NOT_FOUND) {
					    ft.hr = S_OK;
						continue;
					} else
    					ft.TranslateProviderError( VSSDBG_COORD, ItfArray[nIndex].GetProviderId(), 
    					    L"DeleteSnapshots("WSTR_GUID_FMT L", %d, %d, [%ld],["WSTR_GUID_FMT L"]) failed",
    					    GUID_PRINTF_ARG(SourceObjectId), (INT)eSourceObjectType, (INT)(bForceDelete? 1: 0), 
    					    lLocalDeletedSnapshots, GUID_PRINTF_ARG(*pNondeletedSnapshotID));
				}
				
				// If no object found in all providers...
				if (!bObjectFound)
					ft.Throw( VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, L"Object not found in any provider");
			}
			break;

		default:
			ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"Invalid type %d", eSourceObjectType);
		}
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrSucceeded())
    	(*pNondeletedSnapshotID) = GUID_NULL;

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\coord\src\lovelace.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Lovelace.cxx

Abstract:

    Definition of CVssQueuedVolume	


    Adi Oltean  [aoltean]  10/20/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     10/20/1999  Created

--*/

#include "stdafx.hxx"
#include "resource.h"
#include "vssmsg.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "worker.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"

#include "ntddsnap.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORLOVLC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CVssQueuedVolume - constructors, destructors and initialization methods


CVssQueuedVolume::CVssQueuedVolume():
	m_hBeginReleaseWritesEvent(NULL),
	m_hFinishHoldWritesEvent(NULL),
	m_InstanceID(GUID_NULL),
	m_ulNumberOfVolumesToFlush(0),
	m_usSecondsToHoldFileSystemsTimeout(nFileSystemsLovelaceTimeout),
	m_usSecondsToHoldIrpsTimeout(nHoldingIRPsLovelaceTimeout),
	m_pwszVolumeName(NULL),
	m_pwszVolumeDisplayName(NULL),
	m_bFlushSucceeded(false),
	m_bReleaseSucceeded(false),
	m_hrFlush(S_OK),
	m_hrRelease(S_OK),
	m_hrOnRun(S_OK)
{
}

	
CVssQueuedVolume::~CVssQueuedVolume()
{
	// Wait for the worker thread to finish, if running.
	// WARNING: FinalReleaseWorkerThreadObject uses virtual methods!
	// Virtual methods in classes derived from CVssQueuedVolume are now inaccessible!
	FinalReleaseWorkerThreadObject();

	// Release the attached strings.
	::VssFreeString(m_pwszVolumeName);
	::VssFreeString(m_pwszVolumeDisplayName);
}


HRESULT CVssQueuedVolume::Initialize(
	IN	LPWSTR pwszVolumeName,
	IN	LPWSTR pwszVolumeDisplayName
	)
/*++

Routine description:

    Initialize a Queued volume object.

Return codes:

    E_OUTOFMEMORY

--*/
{
	CVssFunctionTracer ft(VSSDBG_COORD, L"CVssQueuedVolume::Initialize");

	try
	{
		// Copy with the trailing "\\". 
		::VssSafeDuplicateStr(ft, m_pwszVolumeName, pwszVolumeName);

		// Copy the volume displayed name 
		::VssSafeDuplicateStr(ft, m_pwszVolumeDisplayName, pwszVolumeDisplayName);
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVssQueuedVolume - thread-related methods



void CVssQueuedVolume::SetParameters(
	IN	HANDLE hBeginReleaseWritesEvent,
	IN	HANDLE hFinishHoldWritesEvent,
	IN	VSS_ID	InstanceID,
	IN	ULONG	ulNumberOfVolumesToFlush
	)
{
	m_hBeginReleaseWritesEvent = hBeginReleaseWritesEvent;
	m_hFinishHoldWritesEvent = hFinishHoldWritesEvent;
	m_InstanceID = InstanceID;
	m_ulNumberOfVolumesToFlush = ulNumberOfVolumesToFlush;
}


bool CVssQueuedVolume::OnInit()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnInit" );

	return (m_hBeginReleaseWritesEvent != NULL)
		&& (m_hFinishHoldWritesEvent != NULL)
		&& (m_InstanceID != GUID_NULL)
		&& (m_ulNumberOfVolumesToFlush != 0)
		&& (m_usSecondsToHoldFileSystemsTimeout != 0)
		&& (m_usSecondsToHoldIrpsTimeout != 0);
}


void CVssQueuedVolume::OnRun()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnRun" );

	try
	{
		// Open the IOCTL channel
		// Eliminate the trailing backslash
		// Throw on error 
		BS_ASSERT(::wcslen(m_pwszVolumeName) == nLengthOfVolMgmtVolumeName);
		m_objIChannel.Open(ft, m_pwszVolumeName, true, true);

		// Hold writes
		OnHoldWrites();

		// Signal the thread set that the writes are now hold...
		if (!::SetEvent(m_hFinishHoldWritesEvent))
		    ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
		        L"SetEvent(%p)", m_hFinishHoldWritesEvent );
		m_hFinishHoldWritesEvent = NULL;

		// Wait for the "Release Writes" event
		if (::WaitForSingleObject( m_hBeginReleaseWritesEvent, nHoldingIRPsVssTimeout * 1000 ) == WAIT_FAILED)
		    ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
		        L"WaitForSingleObject(%p,%d) == WAIT_FAILED", 
		        m_hFinishHoldWritesEvent, nHoldingIRPsVssTimeout * 1000 );

		// Release writes.
		OnReleaseWrites();
	}
	VSS_STANDARD_CATCH(ft);

	m_hrOnRun = ft.hr;
}


void CVssQueuedVolume::OnFinish()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnFinish" );

	m_hBeginReleaseWritesEvent = NULL;	// released by the ThreadSet
	m_hFinishHoldWritesEvent = NULL;	// released by the ThreadSet
	m_InstanceID = GUID_NULL;
	m_ulNumberOfVolumesToFlush = 0;
	m_usSecondsToHoldFileSystemsTimeout = 0;
	m_usSecondsToHoldIrpsTimeout = 0;

	// Mark thread state as finished
	MarkAsFinished();
};


void CVssQueuedVolume::OnTerminate()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnTerminate" );
}


void CVssQueuedVolume::OnHoldWrites()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnHoldWrites" );

	try
	{
		BS_ASSERT(m_bFlushSucceeded == false);
		m_bFlushSucceeded = false;
		
		// pack the IOCTL [in] arguments
		m_objIChannel.Pack(ft, m_InstanceID);
		m_objIChannel.Pack(ft, m_ulNumberOfVolumesToFlush);
		m_objIChannel.Pack(ft, m_usSecondsToHoldFileSystemsTimeout);
		m_objIChannel.Pack(ft, m_usSecondsToHoldIrpsTimeout);

		// send the IOCTL
		m_objIChannel.Call(ft, IOCTL_VOLSNAP_FLUSH_AND_HOLD_WRITES);

        BS_ASSERT(ft.hr == S_OK);
		m_bFlushSucceeded = true;
	}
	VSS_STANDARD_CATCH(ft)

	m_hrFlush = ft.hr;
};



void CVssQueuedVolume::OnReleaseWrites()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnReleaseWrites" );

	try
	{
		BS_ASSERT(m_bReleaseSucceeded == false);
		m_bReleaseSucceeded = false;

		// If the Flush IOCTL was succeeded 
        if (IsFlushSucceeded()) {
    		// then send the Release IOCTL.
    		m_objIChannel.Call(ft, IOCTL_VOLSNAP_RELEASE_WRITES);

            BS_ASSERT(ft.hr == S_OK);
    		m_bReleaseSucceeded = true;
        }
	}
	VSS_STANDARD_CATCH(ft)

	m_hrRelease = ft.hr;
};






/////////////////////////////////////////////////////////////////////////////
// CVssQueuedVolumesList


CVssQueuedVolumesList::CVssQueuedVolumesList():
	m_eState(VSS_TS_INITIALIZING),
	m_hBeginReleaseWritesEvent(NULL)
{}
	

CVssQueuedVolumesList::~CVssQueuedVolumesList()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::~CVssQueuedVolumesList" );

	try
	{
		// Remove all volumes from the map
		Reset();

		// Release the internal synchronization objects
		if (m_hBeginReleaseWritesEvent)
			::CloseHandle(m_hBeginReleaseWritesEvent);
	}
	VSS_STANDARD_CATCH(ft)
};


HRESULT CVssQueuedVolumesList::AddVolume(
	WCHAR* pwszVolumeName,
	WCHAR* pwszVolumeDisplayName
	)
/*++

Routine description:

    Adds a volume to the volume list.

Error codes returned:

    E_UNEXPECTED
        - The thread state is incorrect. No logging is done - programming error.
    VSS_E_OBJECT_ALREADY_EXISTS
        - The volume was already added to the snapshot set.
    VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED
        - The maximum number of volumes was reached.
    E_OUTOFMEMORY

    [Initialize() failures]
        E_OUTOFMEMORY
        
--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::AddVolume" );

	try
	{
		// Assert parameters
		BS_ASSERT(pwszVolumeName && pwszVolumeName[0]);
		BS_ASSERT(pwszVolumeDisplayName && pwszVolumeDisplayName[0]);

		// Make sure the volume list object is initialized
		if (m_eState != VSS_TS_INITIALIZING) {
		    BS_ASSERT(false);
            ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Bad state %d.", m_eState);
		}

		// Find if the volume was already added
		if (m_VolumesMap.Lookup(pwszVolumeName))
			ft.Throw( VSSDBG_COORD, VSS_E_OBJECT_ALREADY_EXISTS, L"Volume already added");

		// Check if the maximum number of objects was reached
		if (m_VolumesMap.GetSize() >= MAXIMUM_WAIT_OBJECTS)
            ft.Throw( VSSDBG_COORD, VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED,
                      L"The maximum number (%d) of Lovelace threads was reached.",
                      m_VolumesMap.GetSize());

		// Create the queued volume object
		CVssQueuedVolume* pQueuedVol = new CVssQueuedVolume();
		if (pQueuedVol == NULL)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

		// Initialize the pQueuedVol object. This method may throw
		ft.hr = pQueuedVol->Initialize(pwszVolumeName, pwszVolumeDisplayName);
		if (ft.HrFailed()) {
			delete pQueuedVol;
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
            		  L"Cannot initialize volume object 0x%08lx", ft.hr);
		}

		// Add the volume object to the map
		// Beware that the volume name is already allocated.
		BS_ASSERT(pQueuedVol->GetVolumeName() != NULL);
		if (!m_VolumesMap.Add(pQueuedVol->GetVolumeName(), pQueuedVol))	{
			delete pQueuedVol;
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");
		}
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
};


HRESULT CVssQueuedVolumesList::RemoveVolume(
	WCHAR* pwszVolumeName
	)
/*++

Routine description:

    Removes a volume to the volume list.

Error codes returned:

    E_UNEXPECTED
        - The thread state is incorrect. No logging is done - programming error.
    VSS_E_OBJECT_NOT_FOUND
        - The volume was not added to the snapshot set.

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::RemoveVolume" );

	try
	{
		// Assert parameters
		BS_ASSERT(pwszVolumeName && pwszVolumeName[0]);

		// Make sure the volume list object is initialized
		if (m_eState != VSS_TS_INITIALIZING)
            ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Bad state %d.", m_eState);

		// Find if the volume was already added
		CVssQueuedVolume* pQueuedVol = m_VolumesMap.Lookup(pwszVolumeName);
		if (pQueuedVol == NULL)
			ft.Throw( VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, L"Volume does not exist");

		// Remove the corresponding entry
		BOOL bRemoved = m_VolumesMap.Remove(pwszVolumeName);
		if (!bRemoved) {
			BS_ASSERT(bRemoved);
			ft.Trace( VSSDBG_COORD, L"Error removing the volume entry");
		}

		// Delete the volume object.
		delete pQueuedVol;
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
};


void CVssQueuedVolumesList::Reset()
/*++

Routine description:

    Waits for all background threads. Reset the snapshot set.

Thrown errors:

    None.

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::Reset" );

    // If the flush faield this must be treated already in the "flush" error case
    if (  (m_eState == VSS_TS_HOLDING)
        ||(m_eState == VSS_TS_FAILED_IN_FLUSH) )
    {
        BS_ASSERT(m_VolumesMap.GetSize() > 0);

	    // Wait for all threads to finish. 
	    // This will signal the m_hBeginReleaseWritesEvent event.
	    // WARNING: Ignore return codes from this call. Trace already done.
	    WaitForFinish();
    }

	// Remove all queued volumes
	for(int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++) {
		CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
		BS_ASSERT(pVol);
		delete pVol;
	}

	// Remove all map entries
	m_VolumesMap.RemoveAll();

    ft.Trace(VSSDBG_COORD, L"Current state %d. Reset to initializing", m_eState);
    m_eState = VSS_TS_INITIALIZING;
}
	

HRESULT CVssQueuedVolumesList::FlushAndHoldAllWrites(
	IN	VSS_ID	SnapshotSetID
	)
/*++

Routine description:

    Creates the background threads.
    Flush and Hold all writes on the background threads.
    Wait until all IOCTLS are performed.

Return codes:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - Invalid thread state. Dev error - no entry is put in the event log.
        - Empty volume array. Dev error - no entry is put in the event log.
        - Error creating or waiting a Win32 event. An entry is added into the Event Log if needed.
    VSS_ERROR_FLUSH_WRITES_TIMEOUT
        - An error occured while flushing the writes from a background thread. An event log entry is added.

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::FlushAndHoldAllWrites" );

	HANDLE* pHandleArray = NULL;
	INT nFilledHandles = 0;

	try
	{
		// Check to see if the state is correct
        if (m_eState != VSS_TS_INITIALIZING) {
            BS_ASSERT(false);
            ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Bad state %d.", m_eState);
        }

		// Check we have added some volumes first
		if (m_VolumesMap.GetSize() <= 0) {
			BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Improper array size.");
		}

		// Create the Begin Release Writes event, as a manual reset non-signaled event
		if (m_hBeginReleaseWritesEvent == NULL) {
    		m_hBeginReleaseWritesEvent = ::CreateEvent( NULL, TRUE, FALSE, NULL );
    		if (m_hBeginReleaseWritesEvent == NULL)
    			ft.TranslateGenericError( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()), 
    			    L"CreateEvent( NULL, TRUE, FALSE, NULL )");
		} else
		    ::ResetEvent( m_hBeginReleaseWritesEvent );

		// Create the array of handles local to each thread
		pHandleArray = new HANDLE[m_VolumesMap.GetSize()];
		if (pHandleArray == NULL)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

		// Prepares all jobs
		for (int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++ )
		{
			// Create the Finish Hold Writes event, as a manual reset non-signaled event
			pHandleArray[nIndex] = ::CreateEvent( NULL, TRUE, FALSE, NULL );
			if (pHandleArray[nIndex] == NULL)
			ft.TranslateGenericError( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()), 
			    L"CreateEvent( NULL, TRUE, FALSE, NULL )");

			// Increase the number of filled handles
			nFilledHandles++;
			BS_ASSERT(nFilledHandles == nIndex + 1);

			// Obtain the queued volume object in discussion
			CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
			BS_ASSERT(pVol);

			// Transfer parameters to the current job
			pVol->SetParameters(
				m_hBeginReleaseWritesEvent,
				pHandleArray[nIndex],
				SnapshotSetID,
				m_VolumesMap.GetSize()
				);

			// Prepare the job
			ft.hr = pVol->PrepareJob();
			if (ft.HrFailed())
				ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Error preparing the job %d [0x%08lx]. ", nIndex, ft.hr);
		}

		// Flush and hold writes. All threads will wait for the event to be signaled.
		// This thread will wait until all IOCTLS were sent.

		// Start (i.e. Resume) all threads
		for (int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++ ) {
			// Obtain the queued volume object in discussion
			CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
			BS_ASSERT(pVol);

			// This can happen only because some thread objects were in invalid state...
			ft.hr = pVol->StartJob();
			if (ft.HrFailed())
				ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Error starting the job %d [0x%08lx]. ", nIndex, ft.hr);
		}

		// Wait for all threads to send the FlushAndHold IOCTLS.
		if (::WaitForMultipleObjects( m_VolumesMap.GetSize(),
				pHandleArray, TRUE, nFlushVssTimeout * 1000) == WAIT_FAILED)
			ft.TranslateGenericError( VSSDBG_COORD, 
			    HRESULT_FROM_WIN32(GetLastError()), L"WaitForMultipleObjects(%d,%p,1,%d) == WAIT_FAILED", 
			    m_VolumesMap.GetSize(),pHandleArray, nFlushVssTimeout * 1000);

		// Check for IOCTL errors
		for (int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++ )
		{
			// Obtain the queued volume object in discussion
			CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
			BS_ASSERT(pVol);

            // Check if Flush succeeded.
			if (!pVol->IsFlushSucceeded()) {
                BS_ASSERT(pVol->GetReleaseError() == S_OK);
                
                if ((pVol->GetFlushError() == E_OUTOFMEMORY) ||
                    (pVol->GetOnRunError() == E_OUTOFMEMORY))
                    ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error. [0x%08lx,0x%08lx,0x%08lx]",
                        pVol->GetFlushError(), pVol->GetReleaseError(), pVol->GetOnRunError());
			    
			    ft.LogError(VSS_ERROR_FLUSH_WRITES_TIMEOUT, 
			        VSSDBG_COORD << pVol->GetVolumeDisplayName() << (INT)nIndex 
			            << pVol->GetFlushError() << pVol->GetReleaseError() << pVol->GetOnRunError() );
				ft.Throw( VSSDBG_COORD, VSS_E_FLUSH_WRITES_TIMEOUT,
						  L"Lovelace failed to hold writes at volume %d - '%s'",
						  nIndex, pVol->GetVolumeDisplayName() );
			}
		}

		m_eState = VSS_TS_HOLDING;
	}
	VSS_STANDARD_CATCH(ft)

	// Close all events (from 0..nFilledHandles-1)
	for (int nIndexTmp = 0; nIndexTmp < nFilledHandles; nIndexTmp++ )
		::CloseHandle(pHandleArray[nIndexTmp]);

	// Deallocate the handle array
	delete[] pHandleArray;

	// Check for errors
    if (ft.HrFailed())
		m_eState = VSS_TS_FAILED_IN_FLUSH;

    return ft.hr;
};


HRESULT CVssQueuedVolumesList::ReleaseAllWrites()
/*++

Routine description:

    Signals all the background threads to release the writes.
    Wait until all IOCTLS are performed.

Return codes:

    [WaitForFinish() failures]
        E_UNEXPECTED
            - The list of volumes is empty. Dev error - nothing is logged on.
            - SetEvent failed. An entry is put in the error log.
            - WaitForMultipleObjects failed. An entry is put in the error log.
        E_OUTOFMEMORY
            - Cannot create the array of handles.
            - One of the background threads failed with E_OUTOFMEMORY
        VSS_E_HOLD_WRITES_TIMEOUT
            - Lovelace couldn't keep more the writes. An event log entry is added.

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::ReleaseAllWrites" );

    try
    {
        // If the flush faield this must be treated already in the "flush" error case
	    if (  (m_eState == VSS_TS_HOLDING)
	        ||(m_eState == VSS_TS_FAILED_IN_FLUSH) )
        {
            BS_ASSERT(m_VolumesMap.GetSize() > 0);
    	    // Wait for all threads to finish.
    	    // This will signal the m_hBeginReleaseWritesEvent event.
    	    ft.hr = WaitForFinish();
    	    if (ft.HrFailed())
    		    ft.Throw( VSSDBG_COORD, ft.hr, L"Error waiting threads for finishing");
	    }
    }
    VSS_STANDARD_CATCH(ft)

	// Check for errors
    if (ft.HrFailed())
		m_eState = VSS_TS_FAILED_IN_RELEASE;

    return ft.hr;
};


HRESULT CVssQueuedVolumesList::WaitForFinish()
/*++

Routine description:

    Wait until all Lovelace threads are finished.

Thrown errors:

    E_UNEXPECTED
        - The list of volumes is empty. Dev error - nothing is logged on.
        - SetEvent failed. An entry is put in the error log.
        - WaitForMultipleObjects failed. An entry is put in the error log.
    E_OUTOFMEMORY
        - Cannot create the array of handles.
        - One of the background threads failed with E_OUTOFMEMORY
    VSS_E_HOLD_WRITES_TIMEOUT
        - Lovelace couldn't keep more the writes. An event log entry is added.

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::WaitForFinish" );

	// Table of handles used for synchronization
	HANDLE* pHandleArray = NULL;

	try
	{
		// Release all blocked threads by signaling the m_hBeginReleaseWritesEvent event.
		if(m_hBeginReleaseWritesEvent != NULL) {
			if (!::SetEvent(m_hBeginReleaseWritesEvent))
				ft.TranslateGenericError( VSSDBG_COORD, 
				    HRESULT_FROM_WIN32(GetLastError()), 
				    L"SetEvent(%p)", m_hBeginReleaseWritesEvent);
		}

		// Get the size of the array.
		if (m_VolumesMap.GetSize() <= 0) {
		    BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Zero array size.");
		}

		// Create the array of handles local to each thread
		pHandleArray = new HANDLE[m_VolumesMap.GetSize()];
		if (pHandleArray == NULL)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

		// Search to find any running threads
		int nThreadHandlesCount = 0;
		for (int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++ )
		{
			// Obtain the queued volume object in discussion
			CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
			BS_ASSERT(pVol);
			
			// Get the thread handle, if it is still running
			// Note: the "prepared" threads will not be in "running" state at this point
			// The only procedure that can fire them up (i.e. StartJob) cannot
			// be called anymore at this point.
			if (pVol->IsStarted()) {
			    HANDLE hThread = pVol->GetThreadHandle();
    			BS_ASSERT(hThread != NULL);
    			pHandleArray[nThreadHandlesCount++] = hThread; // will be closed on job array destruction.
			}
		}

        // If we have threads that we can wait on...
        if (nThreadHandlesCount != 0) {
    		// Wait for all threads to send the Release IOCTLS.
    		if (::WaitForMultipleObjects( nThreadHandlesCount,
    				pHandleArray, TRUE, nReleaseVssTimeout * 1000) == WAIT_FAILED)
				ft.TranslateGenericError( VSSDBG_COORD, 
				    HRESULT_FROM_WIN32(GetLastError()),
				    L"WaitForMultipleObjects(%d,%p,1,%d) == WAIT_FAILED", 
				    nThreadHandlesCount,pHandleArray, nReleaseVssTimeout * 1000);
        }

		// Check for IOCTL errors
		for (int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++ )
		{
			// Obtain the queued volume object in discussion
			CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
			BS_ASSERT(pVol);

            // Check if Release writers succeeded. 
            if (pVol->IsFlushSucceeded()) {
                BS_ASSERT(pVol->GetFlushError() == S_OK);

                // Check if Release writes succeeded
    			if (!pVol->IsReleaseSucceeded()) {
                    if ((pVol->GetFlushError() == E_OUTOFMEMORY) ||
                        (pVol->GetReleaseError() == E_OUTOFMEMORY) ||
                        (pVol->GetOnRunError() == E_OUTOFMEMORY))
                        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error. [0x%08lx,0x%08lx,0x%08lx]",
                            pVol->GetFlushError(), pVol->GetReleaseError(), pVol->GetOnRunError());
    			    
    			    ft.LogError(VSS_ERROR_HOLD_WRITES_TIMEOUT, 
    			        VSSDBG_COORD << pVol->GetVolumeDisplayName() << (INT)nIndex 
    			            << pVol->GetFlushError() << pVol->GetReleaseError() << pVol->GetOnRunError() );
    				ft.Throw( VSSDBG_COORD, VSS_E_HOLD_WRITES_TIMEOUT,
    						  L"Lovelace failed to hold writes at volume %d - '%s'",
    						  nIndex, pVol->GetVolumeDisplayName() );
    			}
            }
		}

		m_eState = VSS_TS_RELEASED;
	}
	VSS_STANDARD_CATCH(ft)

	// Deallocate the handle array
	delete[] pHandleArray;

	return ft.hr;
};


CComBSTR CVssQueuedVolumesList::GetVolumesList() throw(HRESULT)
/*++

Routine description:

    Gets the list of volumes as a BSTR.

Throws:

    E_OUTOFMEMORY

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::GetVolumesList" );
	CComBSTR bstrVolumeNamesList;

    BS_ASSERT(m_VolumesMap.GetSize() > 0);

	// Concatenate the list of volume display names
	for (int nIndexTmp = 0; nIndexTmp < m_VolumesMap.GetSize(); nIndexTmp++ ) {
		// Obtain the queued volume object in discussion
		CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndexTmp);
		BS_ASSERT(pVol);

		// Check to see if this is the first item
		if (nIndexTmp == 0) {
			// Put the first volume name
			bstrVolumeNamesList = pVol->GetVolumeName();
			if (bstrVolumeNamesList.Length() == 0)
				ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
		} else {
			// Append the semicolon
			bstrVolumeNamesList += wszVolumeNamesSeparator;
			if (bstrVolumeNamesList.Length() == 0)
				ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
			// Append the next volume name
			bstrVolumeNamesList += pVol->GetVolumeName();
			if (bstrVolumeNamesList.Length() == 0)
				ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
		}
	}

	// Return the built list
	return bstrVolumeNamesList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\coord\src\provmgr.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module ProvMgr.cxx | Implementation of the CVssProviderManager methods
    @end

Author:

    Adi Oltean  [aoltean]  09/27/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     09/27/1999  Created
    aoltean     09/09/1999  Adding AddVolumeTointernalList from coord.cxx
    aoltean     09/09/1999  dss -> vss
    aoltean     09/15/1999  Returning only volume names to the writers.
	aoltean		09/21/1999	Rewriting GetProviderProperties in accordance with the new enumerator.
	aoltean		09/22/1999	Add TransferEnumeratorContentsToArray

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"
#include "vssmsg.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "reg_util.hxx"
#include "provmgr.hxx"
#include "softwrp.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORPRVMC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CVssProviderManager static members

VSS_OBJECT_PROP_Array* CVssProviderManager::m_pProvidersArray = NULL;

CVssProviderManager* CVssProviderManager::m_pStatefulObjList = NULL;

CVssCriticalSection CVssProviderManager::m_GlobalCS;


/////////////////////////////////////////////////////////////////////////////
//  Query methods



void CVssProviderManager::TransferEnumeratorContentsToArray(
    IN  VSS_ID ProviderId,
    IN  IVssEnumObject* pEnum,
    IN  VSS_OBJECT_PROP_Array* pArray
    )

/*++

Routine Description:

    Append to the array the objects returned by this enumerator

Arguments:

    IN  IVssEnumObject* pEnum,          - The enumerator interface used for query
    IN  VSS_OBJECT_PROP_Array* pArray   - The array that will contain the results
    IN  VSS_ID  ProviderID              - The provider ID (for logging in case of errors)

Throw values: 

    E_OUTOFMEMORY

    [InitializeAsEmpty failed] 
        E_OUTOFMEMORY
    
    [IVssEnumObject::Next() failed]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - unexpected provider error when calling Next. An error log entry is added describing the error.
        VSS_E_PROVIDER_VETO
            - provider error when calling Next

Warning:

    The array remains filled partially on error! It is the responsibility of caller to take care.

--*/
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::TransferEnumeratorContentsToArray");

	BS_ASSERT(pEnum);
	BS_ASSERT(pArray);

	ULONG ulFetched;
	VSS_OBJECT_PROP_Ptr ptrObjectProp;
	while (true)
	{
		// Allocate the new structure object, but with zero contents.
		// The internal pointer must not be NULL.
		// WARNING: This might throw E_OUTOFMEMORY
		ptrObjectProp.InitializeAsEmpty(ft);

		// Get the Next object in the newly allocated structure object.
		// This will fill up hte object's type and fields in the union
		// The pointer fields will refer some CoTaskMemAlloc buffers
		// that must be deallocated by us, after the structure is useless.
		VSS_OBJECT_PROP* pProp = ptrObjectProp.GetStruct();
		BS_ASSERT(pProp);
		ft.hr = pEnum->Next(1, pProp, &ulFetched);
		if (ft.hr == S_FALSE) // end of enumeration
		{
			BS_ASSERT(ulFetched == 0);
			break; // This will destroy the last allocated structure in the VSS_OBJECT_PROP_Ptr destructor
		}
		if (ft.HrFailed())
			ft.TranslateProviderError( VSSDBG_COORD, ProviderId, L"IVssEnumObject::Next" );

		// Add the element to the array.
		// If fails then VSS_OBJECT_PROP_Ptr::m_pStruct will be correctly deallocated
		// by the VSS_OBJECT_PROP_Ptr destructor
		if (!pArray->Add(ptrObjectProp))
			ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot add element to the array");

		// Reset the current pointer to NULL
		ptrObjectProp.Reset(); // The internal pointer was detached into pArray.
	}
}


void CVssProviderManager::QuerySupportedProvidersIntoArray(
    IN      bool bQueryAllProviders,
    IN      VSS_PWSZ pwszVolumeName,
	IN		VSS_OBJECT_PROP_Array* pArray
    )

/*++

Routine Description:

    Fill the array with all providers

Arguments:

    BOOL bQueryAllProviders         // If false then query only the providers who supports the volume name below.
	VSS_PWSZ    pwszVolumeName      // The volume name that must be checked.
	VSS_OBJECT_PROP_Array* pArray	// where to put the result.

Throws:

    E_OUTOFMEMORY

    VSS_E_UNEXPECTED_PROVIDER_ERROR
        Unexpected provider error on calling IsVolumeSupported
        
    [lockObj failures]
        E_OUTOFMEMORY

    [LoadInternalProvidersArray() failures]
        E_OUTOFMEMORY
        E_UNEXPECTED
            - error while reading from registry. An error log entry is added describing the error.

    [CVssSoftwareProviderWrapper::CreateInstance failures]
        E_OUTOFMEMORY

        [CoCreateInstance() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - The provider interface couldn't be created. An error log entry is added describing the error.
        
        [OnLoad() failures]
        [QueryInterface failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.
            VSS_E_PROVIDER_VETO
                - Expected provider error. The provider already did the logging.

    [InitializeAsProvider() failures]
        E_OUTOFMEMORY

    [IVssSnapshotProvider::IsVolumeSupported() failures]
        E_INVALIDARG
            NULL pointers passed as parameters or a volume name in an invalid format.
        E_OUTOFMEMORY
            Out of memory or other system resources           
        VSS_E_PROVIDER_VETO
            An error occured while opening the IOCTL channel. The error is logged.
        VSS_E_OBJECT_NOT_FOUND
            If the volume name does not correspond to an existing mount point

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::QuerySupportedProvidersIntoArray");
    VSS_OBJECT_PROP_Ptr ptrProviderProperties;

    BS_ASSERT(bQueryAllProviders || pwszVolumeName );
    BS_ASSERT(!bQueryAllProviders || !pwszVolumeName );
	BS_ASSERT(pArray);

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw E_OUTOFMEMORY
    CVssAutomaticLock2 lockObj(m_GlobalCS); 

	// Load m_pProvidersArray, if needed.
	LoadInternalProvidersArray();
	BS_ASSERT(m_pProvidersArray);

    // Add elements to the collection
    for (int nIndex = 0; nIndex < m_pProvidersArray->GetSize(); nIndex++)
    {
		// Get the structure object from the array
		VSS_OBJECT_PROP_Ptr& ptrProperties = (*m_pProvidersArray)[nIndex];

		// Get the provider structure
        BS_ASSERT(ptrProperties.GetStruct());
		BS_ASSERT(ptrProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);
		VSS_PROVIDER_PROP& ProviderProp = ptrProperties.GetStruct()->Obj.Prov;
		
        // Check if we aplying a filter
        if (!bQueryAllProviders) {
    		// Create the IVssSnapshotProvider interface, if needed
            // The ref count will remain 1
    		if (ptrProperties.m_pProviderItf == NULL) {
    		    // Warning: This call may throw 
                ptrProperties.m_pProviderItf.Attach(
                    CVssSoftwareProviderWrapper::CreateInstance( 
                        ProviderProp.m_ProviderId, ProviderProp.m_ClassId, true ));
    			BS_ASSERT(ptrProperties.m_pProviderItf);
    		}

    		// Check if the volume is supported by this provider
    		BOOL bIsSupported = FALSE;
    		ft.hr = ptrProperties.m_pProviderItf->IsVolumeSupported( pwszVolumeName, &bIsSupported );
            if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
                ft.Throw(VSSDBG_COORD, 
                    VSS_E_OBJECT_NOT_FOUND, L"Volume % not found", pwszVolumeName);
    		if (ft.HrFailed())
    			ft.TranslateProviderError( VSSDBG_COORD, ProviderProp.m_ProviderId, 
    			    L"IVssSnapshotProvider::IsVolumeSupported() failed with 0x%08lx", ft.hr );

            // If the provider does not support this volume then continue the enumeration.
            if (!bIsSupported)
                continue;
        }

		// Build the structure
		// This might throw E_OUTOFMEMORY
		ptrProviderProperties.InitializeAsProvider( ft,
			ProviderProp.m_ProviderId,
			ProviderProp.m_pwszProviderName,
  			ProviderProp.m_eProviderType,
			ProviderProp.m_pwszProviderVersion,
			ProviderProp.m_ProviderVersionId,
			ProviderProp.m_ClassId);

		// Insert provider into the array.
		// If fails then ptrProviderProperties::m_pStruct will be correctly deallocated.
		if (!pArray->Add(ptrProviderProperties))
			ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot add element to the array");

		// Reset the current pointer to NULL since the internal pointer was detached into pArray.
		ptrProviderProperties.Reset();
    }
}


BOOL CVssProviderManager::GetProviderInterface(
	IN		VSS_ID ProviderId,
	OUT		IVssSnapshotProvider** ppProviderInterface
    )

/*++

Routine Description:

    Get the interface corresponding to this provider Id.

Arguments:

	VSS_ID ProviderId,				// Provider Id
	IVssSnapshotProvider** ppProviderInterface // the provider interface

Return value:
	TRUE, if provider was found
	FALSE otherwise.

Throws:
    E_OUTOFMEMORY

    [lockObj failures]
        E_OUTOFMEMORY    

    [LoadInternalProvidersArray() failures]
        E_OUTOFMEMORY
        E_UNEXPECTED
            - error while reading from registry. An error log entry is added describing the error.

    [CVssSoftwareProviderWrapper::CreateInstance() failures]
        E_OUTOFMEMORY

        [CoCreateInstance() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - The provider interface couldn't be created. An error log entry is added describing the error.
        
        [OnLoad() failures]
        [QueryInterface failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.
            VSS_E_PROVIDER_VETO
                - Expected provider error. The provider already did the logging.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::GetProviderInterface");

	BS_ASSERT(ppProviderInterface);

	// Reset the interface pointer
	(*ppProviderInterface) = NULL;

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw E_OUTOFMEMORY exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS); 

	// Load m_pProvidersArray, if needed.
	LoadInternalProvidersArray();
	BS_ASSERT(m_pProvidersArray);

    // Find that provider
    for (int nIndex = 0; nIndex < m_pProvidersArray->GetSize(); nIndex++)
    {
		// Get the structure object from the array
		VSS_OBJECT_PROP_Ptr& ptrProperties = (*m_pProvidersArray)[nIndex];

		// Get the provider structure
		BS_ASSERT(ptrProperties.GetStruct());
		BS_ASSERT(ptrProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);
		VSS_PROVIDER_PROP& ProviderProp = ptrProperties.GetStruct()->Obj.Prov;
		
		// Check if provider was found.
		if (ProviderProp.m_ProviderId != ProviderId)
			continue;

		// Create the IVssSnapshotProvider interface, if needed
		// This may throw if an error occurs at COM object creation!
		if (ptrProperties.m_pProviderItf == NULL)
		{
            ptrProperties.m_pProviderItf.Attach(
                CVssSoftwareProviderWrapper::CreateInstance( 
                    ProviderProp.m_ProviderId, ProviderProp.m_ClassId, true ));
			BS_ASSERT(ptrProperties.m_pProviderItf);
		}

		// Put an interface reference into ppProviderInterface
		ft.hr = ptrProperties.m_pProviderItf.CopyTo(ppProviderInterface);
		BS_ASSERT(ft.HrSucceeded());

		// Exit from the loop
		break;
    }

	return (ppProviderInterface && *ppProviderInterface);
}


void CVssProviderManager::GetProviderItfArray(
	IN		CSnapshotProviderItfArray& ItfArray
	)

/*++

Routine Description:

    Get the array of all provider interfaces

Arguments:

	CSnapshotProviderItfArray& ItfArray

Throws:

    E_OUTOFMEMORY

    [lockObj failures]
        E_OUTOFMEMORY
    
    [LoadInternalProvidersArray() failures]
        E_OUTOFMEMORY
        E_UNEXPECTED
            - error while reading from registry. An error log entry is added describing the error.

    [CVssSoftwareProviderWrapper::CreateInstance() failures]
        E_OUTOFMEMORY

        [CoCreateInstance() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - The provider interface couldn't be created. An error log entry is added describing the error.
        
        [OnLoad() failures]
        [QueryInterface failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.
            VSS_E_PROVIDER_VETO
                - Expected provider error. The provider already did the logging.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::GetProviderItfArray");

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS); 

	// Load m_pProvidersArray, if needed.
	LoadInternalProvidersArray();
	BS_ASSERT(m_pProvidersArray);

	try
	{
		// find that provider
		for (int nIndex = 0; nIndex < m_pProvidersArray->GetSize(); nIndex++)
		{
			// Get the structure object from the array
			VSS_OBJECT_PROP_Ptr& ptrProperties = (*m_pProvidersArray)[nIndex];

			// Get the provider structure
			BS_ASSERT(ptrProperties.GetStruct());
			BS_ASSERT(ptrProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);
			VSS_PROVIDER_PROP& ProviderProp = ptrProperties.GetStruct()->Obj.Prov;

			// Create the IVssSnapshotProvider interface, if needed
			if (ptrProperties.m_pProviderItf == NULL) {
                ptrProperties.m_pProviderItf.Attach(
                    CVssSoftwareProviderWrapper::CreateInstance( 
                        ProviderProp.m_ProviderId, ProviderProp.m_ClassId, true ));
				BS_ASSERT(ptrProperties.m_pProviderItf);
			}

			// Interface reference count is increased (and decreased at block exit).
			CProviderItfNode node(ProviderProp.m_ProviderId, ptrProperties.m_pProviderItf);

			// Add the interface to the array. 
			// Interface reference count is increased again.
			if (!ItfArray.Add(node))
				ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
						  L"Cannot add element to the array");
		}
	}
    VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed())
	{
		ItfArray.RemoveAll();
		ft.Throw( VSSDBG_COORD, ft.hr,
				  L"Cannot add element to the array");
	}
}


/////////////////////////////////////////////////////////////////////////////
//  Provider array management


void CVssProviderManager::LoadInternalProvidersArray()

/*++

Routine Description:

    Fill the array with all providers, if not initialized

Arguments:


Warnings:

	Each time when you access m_pProvidersArray you should call first this method.

Throws:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - error while reading from registry. An error log entry is added describing the error.

    [GetProviderProperties() failures]
        E_OUTOFMEMORY
        E_UNEXPECTED
            - error while reading from registry. An error log entry is added describing the error.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::LoadInternalProvidersArray");

    VSS_OBJECT_PROP_Ptr ptrProviderProperties;
    WCHAR       wszKeyName[_MAX_KEYNAME_LEN];
    HKEY        hKeyProviders = NULL;
    FILETIME    time;
    LONG        lRes;

    try
    {
        // The lock should be active now.
        BS_ASSERT(m_GlobalCS.IsLocked());
    
		// If needed, reconstruct the array from registry.
		if (m_pProvidersArray == NULL)
		{
			// Create the collection object. Initial reference count is 0.
			m_pProvidersArray = new VSS_OBJECT_PROP_Array;
			if (m_pProvidersArray == NULL)
				ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

			// Open the "Providers" key.
			::wsprintf( wszKeyName, L"%s\\%s", wszVSSKey, wszVSSKeyProviders);
			lRes = ::RegOpenKeyExW(
				HKEY_LOCAL_MACHINE, //  IN HKEY hKey,
				wszKeyName,         //  IN LPCWSTR lpSubKey,
				0,                  //  IN DWORD ulOptions,
				KEY_ALL_ACCESS,     //  IN REGSAM samDesired,
				&hKeyProviders      //  OUT PHKEY phkResult
				);
			if (lRes != ERROR_SUCCESS)
			    ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
			        L"RegOpenKeyExW(HKLM,%s\\%s,0,KEY_ALL_ACCESS,&ptr)", wszVSSKey, wszVSSKeyProviders );
			BS_ASSERT(hKeyProviders);

			// Add elements to the collection
			bool bLastProviderInEnumeration = false;
			for (DWORD dwIndex = 0; !bLastProviderInEnumeration; dwIndex++)
			{
				// Fill wszKeyName with the name of the subkey
				DWORD dwSize = _MAX_KEYNAME_LEN;
				lRes = ::RegEnumKeyExW(
					hKeyProviders,      // IN HKEY hKey,
					dwIndex,            // IN DWORD dwIndex,
					wszKeyName,         // OUT LPWSTR lpName,
					&dwSize,            // IN OUT LPDWORD lpcbName,
					NULL,               // IN LPDWORD lpReserved,
					NULL,               // IN OUT LPWSTR lpClass,
					NULL,               // IN OUT LPDWORD lpcbClass,
					&time);             // OUT PFILETIME lpftLastWriteTime
				switch(lRes)
				{
				case ERROR_SUCCESS:
					BS_ASSERT(dwSize != 0);

					// Get the provider properties structure
					ft.hr = CVssProviderManager::GetProviderProperties(
								hKeyProviders,
								wszKeyName,
								ptrProviderProperties
								);
					if (ft.HrFailed())
					{
						// Do not throw in case that the registry contain keys with bad format.
						ft.Warning( VSSDBG_COORD,
								  L"Error on getting Provider properties for %s. [0x%08lx]",
								  wszKeyName, ft.hr );
						BS_ASSERT(ptrProviderProperties.GetStruct() == NULL);
						break;  // Continue the iteration
					}
					BS_ASSERT(ptrProviderProperties.GetStruct());
					BS_ASSERT(ptrProviderProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);

					// Insert it into the array.
					// If fails then ptrProviderProperties::m_pStruct will be correctly deallocated.
					if (!m_pProvidersArray->Add(ptrProviderProperties))
						ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
								  L"Cannot add element to the array");

					// Reset the current pointer to NULL since
					// the internal pointer was detached into pArray.
					ptrProviderProperties.Reset();

					break; // Go to Next key, if not find yet.

				case ERROR_NO_MORE_ITEMS:
					bLastProviderInEnumeration = true;
					break; // End of iteration

				default:
				    // RegEnumKeyExW failure
    			    ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
    			        L"RegEnumKeyExW(HKLM\\%s\\%s,%s,%d,...)", 
    			        wszVSSKey, wszVSSKeyProviders, wszKeyName, dwIndex );
				}
			}
		}
		BS_ASSERT(m_pProvidersArray);
    }
    VSS_STANDARD_CATCH(ft)

    // Cleanup resources
    lRes = hKeyProviders? ::RegCloseKey(hKeyProviders): ERROR_SUCCESS;
    if (lRes != ERROR_SUCCESS)
        ft.Trace( VSSDBG_COORD, L"Error closing the hKeyProviders key. [0x%08lx]", GetLastError());

    // If an error occured then throw it outside
	if (ft.HrFailed()) {
	    // Unload the array of providers
	    UnloadInternalProvidersArray();
	    // Throw the corresponding error
		ft.Throw( VSSDBG_COORD, ft.hr, L"Cannot load the internal providers array [0x%08lx]", ft.hr);
	}
}


void CVssProviderManager::UnloadInternalProvidersArray()

/*++

Routine Description:

    Destroy the static array, if exist.
	Call OnUnload for all providers.
	Deallocate all cached provider interface references.

Arguments:

    None.

Caller:

	You should call this method at program termination.

Throws:

    None.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::UnloadInternalProvidersArray");

    try
    {
        // Lock the global critical section for the duration of this block
        // WARNING: This call may throw exceptions!
        CVssAutomaticLock2 lockObj(m_GlobalCS); 

    	if (m_pProvidersArray != NULL)
    	{
    		for (int nIndex = 0; nIndex < m_pProvidersArray->GetSize(); nIndex++)
    		{
    			// Get the structure object from the array
    			VSS_OBJECT_PROP_Ptr& ptrProperties = (*m_pProvidersArray)[nIndex];

    			// Notify the provider that is being unloaded.
    			if (ptrProperties.m_pProviderItf != NULL)
    			{
    				CComPtr<IVssProviderNotifications> pNotificationsItf;
    				ft.hr = ptrProperties.m_pProviderItf->SafeQI(
    							IVssProviderNotifications, &pNotificationsItf );

    				// If the provider supports notifications, send them to it.
    				if (ft.HrSucceeded())
    				{
                        // We force provider unloading since the service goes down.
    					BS_ASSERT(pNotificationsItf);
    					ft.hr = pNotificationsItf->OnUnload(TRUE);
    					if (ft.HrFailed())
    						ft.Warning( VSSDBG_COORD,
    								  L"Cannot unload load the internal provider");
    				}
    			}
    		}

    		// Delete silently the array and all its elements.
    		// This will release the provider interfaces too.
    		delete m_pProvidersArray;
    		m_pProvidersArray = NULL;

    		// Unload all unused COM server DLLs in this service
    		::CoFreeUnusedLibraries();
    	}
    }
    VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed())
		ft.Warning( VSSDBG_COORD, L"Exception catched 0x%08lx", ft.hr);
}


void CVssProviderManager::AddProviderIntoArray(				
	IN		VSS_ID ProviderId,
	IN      VSS_PWSZ pwszProviderName,
    IN      VSS_PROVIDER_TYPE eProviderType,
	IN      VSS_PWSZ pwszProviderVersion,
	IN      VSS_ID ProviderVersionId,
	IN      CLSID ClassId
	)

/*++

Routine Description:

    Add that provider to the array. This has nothing to do with the registry.
	The caller is supposed to add the provider to the registry also.

	Called only by the RegisterProvider method.

Arguments:

	VSS_ID ProviderId,				// Id of the provider
	VSS_PWSZ pwszProviderName,
    VSS_PROVIDER_TYPE eProviderType,
	VSS_PWSZ pwszProviderVersion,
	VSS_ID ProviderVersionId,
	CLSID ClassId

Throws:

    E_OUTOFMEMORY

    [lockObj failures] or
    [InitializeAsProvider() failures]
        E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::AddProviderIntoArray");

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS); 

	if (m_pProvidersArray)
	{
		VSS_OBJECT_PROP_Ptr ptrProviderProperties;
		ptrProviderProperties.InitializeAsProvider( ft,
			ProviderId,
			pwszProviderName,
            eProviderType,
			pwszProviderVersion,
			ProviderVersionId,
			ClassId	);

		// Insert it into the array.
		// If fails then ptrProviderProperties::m_pStruct will be correctly deallocated.
		if (!m_pProvidersArray->Add(ptrProviderProperties))
			ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
					  L"Cannot add element to the array");

		// Reset the current pointer to NULL since
		// the internal pointer was detached into pArray.
		ptrProviderProperties.Reset();
	}
}


bool CVssProviderManager::RemoveProviderFromArray(
	IN		VSS_ID ProviderId
    )

/*++

Routine Description:

	Eliminates the corresponding array element.
    WARNING: Also load, unload and unregister the provider with the given Id.

	Called only by the UnregisterProvider method

Arguments:

	VSS_ID ProviderId			// The provider Id

Return value:

    true - if the provider was sucessfully removed
    false - if there is no provider registered under that ID.

Throws:

    [lockObj failures]
        E_OUTOFMEMORY

    [LoadInternalProvidersArray() failures]
        E_OUTOFMEMORY
        E_UNEXPECTED
            - error while reading from registry. An error log entry is added describing the error.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::RemoveProviderFromArray");

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS); 

	// Load m_pProvidersArray, if needed.
	LoadInternalProvidersArray();
	BS_ASSERT(m_pProvidersArray);

	// Find that provider
	bool bFind = false;
	for (int nIndex = 0; nIndex < m_pProvidersArray->GetSize(); nIndex++)
	{
		// Get the structure object from the array
		VSS_OBJECT_PROP_Ptr& ptrProperties = (*m_pProvidersArray)[nIndex];

		// Get the provider structure
		BS_ASSERT(ptrProperties.GetStruct());
		BS_ASSERT(ptrProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);
		VSS_PROVIDER_PROP& ProviderProp = ptrProperties.GetStruct()->Obj.Prov;
		
		// Check if provider was found.
		if (ProviderProp.m_ProviderId != ProviderId)
			continue;

		// We will try OnUnload only on providers that were loaded
		// Call notifications, if possible
		if (ptrProperties.m_pProviderItf)
		{
			CComPtr<IVssProviderNotifications> pNotificationsItf;
			ft.hr = ptrProperties.m_pProviderItf->SafeQI( IVssProviderNotifications, &pNotificationsItf );

			// If the provider supports notifications, send them to it.
			if (ft.HrSucceeded())
			{
				BS_ASSERT(pNotificationsItf);
				ft.hr = pNotificationsItf->OnUnload(FALSE);
				if (ft.HrFailed())
					ft.Warning( VSSDBG_COORD, L"Cannot unload the internal provider");
			}
		}

		// Delete the element from the array.
		m_pProvidersArray->RemoveAt(nIndex);

		// Unload all unused COM server DLLs in this service
		::CoFreeUnusedLibraries();

		// Exit from the loop
		bFind = true;
		break;
	}

	return bFind;
}


/////////////////////////////////////////////////////////////////////////////
// CVssProviderManager private methods



HRESULT CVssProviderManager::GetProviderProperties(
    IN  HKEY hKeyProviders,
    IN  LPCWSTR wszProviderKeyName,
    OUT VSS_OBJECT_PROP_Ptr& ptrProviderProperties
    )

/*++

Routine Description:

    Get provider properties from registry.

Arguments:

    IN  HKEY hKeyProviders,							// The providers Key
    IN  LPCWSTR wszProviderKeyName,					// The provider Key name (actually a guid)
    OUT VSS_OBJECT_PROP_Ptr& ptrProviderProperties  // will return an allocated structure containing provider properties

Return values:

    E_OUTOFMEMORY
    E_UNEXPECTED 
        - on registry failures. An error log entry is added describing the error.

    [QueryStringValue failures] or 
    [QueryDWORDValue] failures
        E_OUTOFMEMORY
        E_UNEXPECTED 
            - on registry failures. An error log entry is added describing the error.

Throws:

    None.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::GetProviderProperties");

    HKEY hKeyProvider = NULL;
    HKEY hKeyCLSID = NULL;
    LONG lRes;

    BS_ASSERT( hKeyProviders );
    BS_ASSERT( wszProviderKeyName != NULL && wszProviderKeyName[0] != L'\0' );
    BS_ASSERT( ptrProviderProperties.GetStruct() == NULL );

    try
    {
        // Convert wszProviderKeyName into ProviderId.
		VSS_ID ProviderId;
        ft.hr = ::CLSIDFromString( W2OLE(const_cast<LPWSTR>(wszProviderKeyName)), &ProviderId);
        if (ft.HrFailed())
            ft.TranslateGenericError(VSSDBG_COORD, ft.hr, L"CLSIDFromString(%s)", wszProviderKeyName);

        // Open the provider key
        lRes = ::RegOpenKeyExW(
            hKeyProviders,      //  IN HKEY hKey,
            wszProviderKeyName, //  IN LPCWSTR lpSubKey,
            0,                  //  IN DWORD ulOptions,
            KEY_READ,           //  IN REGSAM samDesired,
            &hKeyProvider       //  OUT PHKEY phkResult
            );
        if (lRes != ERROR_SUCCESS)
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes),
                L"RegOpenKeyExW(hKeyProviders,%s,KEY_READ,...)", wszProviderKeyName);
        BS_ASSERT(hKeyProvider);

		// Get the provider name
		WCHAR wszProviderName[_MAX_VALUE_LEN];
		QueryStringValue( ft,
			hKeyProvider,
			wszProviderKeyName,
			wszVSSProviderValueName,
			_MAX_VALUE_LEN,
			wszProviderName
			);
		BS_ASSERT(wszProviderName[0] != L'\0');

		// Get the provider type
		DWORD dwProviderType = 0;
		QueryDWORDValue( ft,
			hKeyProvider,
			wszProviderKeyName,
			wszVSSProviderValueType,
			&dwProviderType
			);

        VSS_PROVIDER_TYPE eProviderType = VSS_PROV_UNKNOWN;
        switch(dwProviderType) {
        case VSS_PROV_SYSTEM:
        case VSS_PROV_SOFTWARE:
        case VSS_PROV_HARDWARE:
            eProviderType = (VSS_PROVIDER_TYPE) dwProviderType;
            break;
        default:
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes),
                L"QueryDWORDValue(hProvider,%s,%s,%d)", 
                wszProviderKeyName,
    			wszVSSProviderValueType,
    			dwProviderType);
        }

        // Get the provider version string
		WCHAR wszProviderVersion[_MAX_VALUE_LEN];
		QueryStringValue( ft,
			hKeyProvider,
			wszProviderKeyName,
			wszVSSProviderValueVersion,
			_MAX_VALUE_LEN,
			wszProviderVersion
			);

        // Get the provider version Id
		WCHAR wszProviderVersionId[_MAX_VALUE_LEN];
        QueryStringValue( ft,
            hKeyProvider,
            wszProviderKeyName,
            wszVSSProviderValueVersionId,
            _MAX_VALUE_LEN,
            wszProviderVersionId
            );
        BS_ASSERT(wszProviderVersionId[0] != L'\0');

        // Convert wszValueBuffer into ProviderVersionId .
		VSS_ID ProviderVersionId;
        ft.hr = ::CLSIDFromString(W2OLE(wszProviderVersionId), &ProviderVersionId);
        if (ft.HrFailed())
            ft.TranslateGenericError(VSSDBG_COORD, ft.hr,
                L"CLSIDFromString(%s)", wszProviderVersionId);

        // Open the CLSID key of that provider
        lRes = ::RegOpenKeyExW(
            hKeyProvider,           //  IN HKEY hKey,
            wszVSSKeyProviderCLSID, //  IN LPCWSTR lpSubKey,
            0,                      //  IN DWORD ulOptions,
            KEY_ALL_ACCESS,         //  IN REGSAM samDesired,
            &hKeyCLSID              //  OUT PHKEY phkResult
            );
        if (lRes != ERROR_SUCCESS)
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes),
                L"CLSIDFromString(%s)", wszProviderVersionId);
        BS_ASSERT(hKeyCLSID);

        // Get the content of the default value
		WCHAR wszClsid[_MAX_VALUE_LEN];
        QueryStringValue( ft,
            hKeyCLSID,
            wszVSSKeyProviderCLSID,
            wszVSSCLSIDValueName,
            _MAX_VALUE_LEN,
            wszClsid
            );
        BS_ASSERT(wszClsid[0] != L'\0');

        // Get the clsid. Remark: if W2OLE fails a SE is thrown
		CLSID ClassId;
        ft.hr = ::CLSIDFromString(W2OLE(wszClsid), &ClassId);
        if (ft.HrFailed())
            ft.TranslateGenericError(VSSDBG_COORD, ft.hr,
                L"CLSIDFromString(%s)", wszClsid);

		// Initialize the Properties pointer. If an error occurs an exception is thrown.
		ptrProviderProperties.InitializeAsProvider(ft,
			ProviderId,
			wszProviderName,
            eProviderType,
			wszProviderVersion,
			ProviderVersionId,
			ClassId);
    }
    VSS_STANDARD_CATCH(ft)

    // Cleanup resources
    lRes = hKeyProvider? ::RegCloseKey(hKeyProvider): ERROR_SUCCESS;
    if (lRes != ERROR_SUCCESS)
        ft.Trace(VSSDBG_COORD, L"Error closing the hKeyProvider key. [0x%08lx]", GetLastError());

    lRes = hKeyCLSID? ::RegCloseKey(hKeyCLSID): ERROR_SUCCESS;
    if (lRes != ERROR_SUCCESS)
        ft.Trace(VSSDBG_COORD, L"Error closing the hKeyCLSID key. [0x%08lx]", GetLastError());

    // If something went wrong, the out must be NULL.
    if (ft.HrFailed()) {
		BS_ASSERT( ptrProviderProperties.GetStruct() == NULL );
	}

    return ft.hr;
}


void CVssProviderManager::Activate() throw(HRESULT)

/*++

Routine Description:

    Mark the current object as stateful.

	The concrete case the current object is a coordinator interface. This interface have no state
	in the moment when StartSnapshotSet is called. After that the state will contain the
	snapshot set Id, the list of involved snapshots (providers), etc.

	When DoSnapshotSet is called then the state is lost and the object must be taken out from the
	global list of stategful objects.

	This whole thing is done to allow AbortAllSnapshotsInProgress to take action on all objects.

Throws:

    [lockObj failures]
        E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::Activate");

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS); 

	if (!m_bHasState)
	{
		m_pNext = m_pPrev = NULL; // for safety

		if (m_pStatefulObjList != NULL)
		{
			BS_ASSERT(m_pStatefulObjList->m_pPrev == NULL);
			m_pStatefulObjList->m_pPrev = this;
		}
		m_pNext = m_pStatefulObjList;
		m_pStatefulObjList = this;
		m_bHasState = true;
	}
}


void CVssProviderManager::Deactivate() throw(HRESULT)

/*++

Routine Description:

    Mark the current object as stateless.

	The concrete case the current object is a coordinator interface. This interface have no state
	in the moment when StartSnapshotSet is called. After that the state will contain the
	snapshot set Id, the list of involved snapshots (providers), etc.

	When DoSnapshotSet is called then the state is lost and the object must be taken out from the
	global list of stategful objects.

Throws:

    [lockObj failures]
        E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::Deactivate");

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS); 

	if (m_bHasState)
	{
		if (m_pPrev != NULL) // we are in the middle
			m_pPrev->m_pNext = m_pNext;
		else // we are the first
		{
			BS_ASSERT(m_pStatefulObjList == this);
			m_pStatefulObjList = m_pNext;
		}

		if (m_pNext != NULL)
			m_pNext->m_pPrev = m_pPrev;

		m_pNext = m_pPrev = NULL;
		m_bHasState = false;

		// Warning: this call may throw errors!
		OnDeactivate();
	}
}


void CVssProviderManager::DeactivateAll()

/*++

Routine Description:

    Deactivate all activated objects.

Throws:

    [lockObj failures]
        E_OUTOFMEMORY

    [OnDeactivate failures]
        TBD

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::DeactivateAll");

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS); 

	while (m_pStatefulObjList)
	{
		CVssProviderManager* pFirstObj = m_pStatefulObjList;

		BS_ASSERT(pFirstObj->m_bHasState);
		pFirstObj->m_bHasState = false;

		BS_ASSERT(pFirstObj->m_pPrev == NULL);
		m_pStatefulObjList = pFirstObj->m_pNext;

		if (pFirstObj->m_pNext != NULL)
		{
			BS_ASSERT(pFirstObj->m_pNext->m_pPrev == pFirstObj);
			pFirstObj->m_pNext->m_pPrev = NULL;

			pFirstObj->m_pNext = NULL;
		}

		pFirstObj->OnDeactivate();
	}
}


bool CVssProviderManager::AreThereStatefulObjects()
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::AreThereStatefulObjects");

    return (m_pStatefulObjList != NULL);
};



void CVssProviderManager::GetProviderInterfaceForSnapshotCreation(
	IN		VSS_ID ProviderId,
	OUT		IVssSnapshotProvider** ppProviderInterface
	)
/*++

Method:

    CVssProviderManager::GetProviderInterfaceForSnapshotCreation

Description:

    To be called only in AddToSnapshotSet

    This method caches a list of provider interfaces per coordinator instance, named the local cache.
    The list is an associative array ProviderID - interface designed to be used only during the
    snapshot creation protocol.

    This method does not rely on the global Provider interface cached into
    the global Providers array. (i.e. on the "global cache").
    This is because we need to handle "auto-delete" snapshots
    and we link the lifetime of all auto-delete snapshots with the lifetime of the
    originating provider interface. Therefore there might be several provider interfaces with different
    lifetimes.

    Each coordinator object will keep on its own lifetime a list of provider interfaces
    that corresponds to each "used" provider ID. If the coordinator object goes away then
    all used provider interfaces will be released, therefore giving a chance to the provider to
    delete the "auto-delete" snapshots.

Algorithm:

    If a cached interface exists in the current coordinator object then it will be returned. Otherwise
    a new instance will be created, inserted into the local cache and returned.

Info:

    The ref count for the returned interface is at least 2 (one reference in the local cache and another
    which is returned.

Throws:

    VSS_E_PROVIDER_NOT_REGISTERED

    [lockObj failures]
        E_OUTOFMEMORY

    [LoadInternalProvidersArray() failures]
        E_OUTOFMEMORY
        E_UNEXPECTED
            - error while reading from registry. An error log entry is added describing the error.

    [CVssSoftwareProviderWrapper::CreateInstance() failures]
        E_OUTOFMEMORY

        [CoCreateInstance() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - The provider interface couldn't be created. An error log entry is added describing the error.
        
        [OnLoad() failures]
        [QueryInterface failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.
            VSS_E_PROVIDER_VETO
                - Expected provider error. The provider already did the logging.
                
--*/
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::GetProviderInterfaceForSnapshotCreation");

	BS_ASSERT(ppProviderInterface);
    
	// Reset the interface pointer
	(*ppProviderInterface) = NULL;

    // Lookup for the interface cached under that provider.
    CComPtr<IVssSnapshotProvider> pItf = m_mapProviderItfLocalCache.Lookup(ProviderId);
    if (pItf == NULL) {

        // No interface found

        // Lock the global critical section for the duration of this block
        // WARNING: This call may throw exceptions!
        CVssAutomaticLock2 lockObj(m_GlobalCS); 

	    // Load m_pProvidersArray, if needed.
	    LoadInternalProvidersArray();
	    BS_ASSERT(m_pProvidersArray);

        // Find that provider
        bool bFound = false;
        for (int nIndex = 0; nIndex < m_pProvidersArray->GetSize(); nIndex++)
        {
		    // Get the structure object from the array
		    VSS_OBJECT_PROP_Ptr& ptrProperties = (*m_pProvidersArray)[nIndex];

		    // Get the provider structure
		    BS_ASSERT(ptrProperties.GetStruct());
		    BS_ASSERT(ptrProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);
		    VSS_PROVIDER_PROP& ProviderProp = ptrProperties.GetStruct()->Obj.Prov;

		    // Check if provider was found.
		    if (ProviderProp.m_ProviderId != ProviderId)
			    continue;

            // Create the global cached interface (to correctly handle OnUnload)
            // The ref count will remain 1 on the global interface
			if (ptrProperties.m_pProviderItf == NULL)
			{
                ptrProperties.m_pProviderItf.Attach(
                    CVssSoftwareProviderWrapper::CreateInstance( 
                        ProviderProp.m_ProviderId, ProviderProp.m_ClassId, true ));
				BS_ASSERT(ptrProperties.m_pProviderItf);
			}

            // Create the local cached interface
            // Now pItf will keep an interface pointer with ref count == 1,
            // since pItf is a smart pointer.
            pItf.Attach(CVssSoftwareProviderWrapper::CreateInstance( 
                ProviderProp.m_ProviderId, ProviderProp.m_ClassId, false ));
			BS_ASSERT(pItf);

            // Put a copy into the local cache. The ref count becomes 2
            if (!m_mapProviderItfLocalCache.Add(ProviderId, pItf))
                ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

		    // Put an interface reference into ppProviderInterface. The ref count goes to 3
		    ft.hr = pItf.CopyTo(ppProviderInterface);
            BS_ASSERT(ft.HrSucceeded());

		    // Exit from the loop
		    bFound = true;
		    break;
        }

        if (!bFound)
            ft.Throw( VSSDBG_COORD, VSS_E_PROVIDER_NOT_REGISTERED, 
                L"Provider with ID = " WSTR_GUID_FMT L" not registered", GUID_PRINTF_ARG(ProviderId) );
        
    } else {

        // Interface found in the map.
        // The ref count is 2 (one from the map, one from the smart pointer)

		// Put an interface reference into ppProviderInterface. The ref count goes to 3
		ft.hr = pItf.CopyTo(ppProviderInterface);
        BS_ASSERT(ft.HrSucceeded());
    }

    // Unless there was no interface found the smart pointer ref goes from 3 to 2
    // Remaining interfaces: one in returned itf, another in the map
    BS_ASSERT(*ppProviderInterface);
}


CVssProviderManager::~CVssProviderManager()
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::~CVssProviderManager");

	BS_ASSERT((m_pNext == NULL) && (m_pPrev == NULL) && !m_bHasState );

    // The local cache interfaces must be automatically released
    // Here the auto-delete snapshots are deleted.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\coord\src\shim.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Shim.cxx | Implementation of CVssShimObject
    @end

Author:

    Adi Oltean  [aoltean]  07/20/2000

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     07/20/2000  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "worker.hxx"

#include "shim.hxx"

#include "vswriter.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSHIMC"
//
////////////////////////////////////////////////////////////////////////

// Global semaphore used to serialize creation of snapshot sets, CVssShimObject also uses
// this semaphore to serialize both StartSnapshotSet and SimulateSnapshotFreeze.  Defined
// in snap_set.cxx.
extern LONG g_hSemSnapshotSets;

/////////////////////////////////////////////////////////////////////////////
//  CVssShimObject


HRESULT CVssShimObject::SimulateSnapshotFreeze(
    IN      VSS_ID          guidSnapshotSetId,
	IN      ULONG           ulOptionFlags,	
	IN      ULONG           ulVolumeCount,	
	IN      VSS_PWSZ*       ppwszVolumeNamesArray
	)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimObject::SimulateSnapshotFreeze" );

    try
    {
		BS_ASSERT(!m_bHasAcquiredSem);

        // Trace the input parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: SnapshotSetID = " WSTR_GUID_FMT L" "
            L" OptionFlags = %lu, VolumeCount = %d", 
            GUID_PRINTF_ARG(guidSnapshotSetId), ulOptionFlags, ulVolumeCount );
        for ( ULONG ulIndex = 0; ulIndex < ulVolumeCount ; ulIndex++ )
            ft.Trace( VSSDBG_COORD, L"   Volume[%02d]= %s", 
                ulIndex, ppwszVolumeNamesArray[ulIndex] );

        // Prevent simultaneous creation of multiple snapshot sets and SimulateSnapshotFreeze
        // on the same machine.
		if (InterlockedCompareExchange(&g_hSemSnapshotSets, 1, 0) != 0)
			ft.Throw
				(
				VSSDBG_COORD,
				VSS_E_SNAPSHOT_SET_IN_PROGRESS,
				L"Snapshot set creation is already in progress."
				);
        m_bHasAcquiredSem = true;

        //
        // Finally call into the VssApi.DLL's SimulateSnaphotFreezeInternal!
        //
        PFunc_SimulateSnapshotFreezeInternal pFuncFreeze;
        _Module.GetSimulateFunctions( &pFuncFreeze, NULL );
        if ( pFuncFreeze != NULL )
        {
            m_guidSimulateSnapshotSetId = guidSnapshotSetId;        
            ft.hr = pFuncFreeze( guidSnapshotSetId, ulOptionFlags,	ulVolumeCount,	ppwszVolumeNamesArray, &m_bCancel );
            if ( ft.HrFailed() )
            {
                ft.Trace( VSSDBG_COORD, L"ERROR: SimulateSnapshotFreezeInternal returned hr: 0x%08lx", ft.hr );
            }
        }
        else
        {
            ft.Trace( VSSDBG_COORD, L"ERROR: pFuncFreeze is NULL, no registered simulate snapshot function!!" );
        }
        
        if ( ft.HrSucceeded() )
        {
            TestIfCancelNeeded(ft);        
        }
    }
    VSS_STANDARD_CATCH(ft);

	// Cleanup on error...
	if (ft.hr != S_OK) // HrFailed not used since VSS_S_ASYNC_CANCELLED may be thrown...
	{
		ft.Trace( VSSDBG_COORD, L"Abort detected 0x%08lx", ft.hr );
        // These functions should not throw

        // If it was a cancel then abort the snapshot set in progress.
        if (ft.hr == VSS_S_ASYNC_CANCELLED) {
            // TBD: User cancelled.            
        }

        // Thaw any shim writers that got frozen before the error occurred or the
        // async operation was cancelled.  Note that SimulateSnapshotThaw will
        // release the semaphore.
        if ( m_bHasAcquiredSem )
            SimulateSnapshotThaw( guidSnapshotSetId );
	}

    // We may return here VSS_S_ASYNC_CANCELLED
    return ft.hr;
}


HRESULT CVssShimObject::SimulateSnapshotThaw(
    IN      VSS_ID          guidSnapshotSetId
    )
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimObject::SimulateSnapshotThaw" );

    //
    // Finally call into the VssApi.DLL's SimulateSnaphotThawInternal!
    //
    PFunc_SimulateSnapshotThawInternal pFuncThaw;
    _Module.GetSimulateFunctions( NULL, &pFuncThaw );
    if ( pFuncThaw != NULL )
    {
        pFuncThaw( guidSnapshotSetId );
    }
    else
    {
        ft.Trace( VSSDBG_COORD, L"ERROR: pFuncThaw is NULL, no registered simulate snapshot function!!" );
    }

    //
    //  Thaw can be called out of order since the requestor might be making sure that
    //  all writers thaw properly.
    //
    if ( m_bHasAcquiredSem )
    {
    	if ( InterlockedCompareExchange(&g_hSemSnapshotSets, 0, 1) == 1 )
            m_bHasAcquiredSem = false;
    }

    m_guidSimulateSnapshotSetId = GUID_NULL;
    
    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
// Life-management related methods


void CVssShimObject::TestIfCancelNeeded(
	IN	CVssFunctionTracer& ft
    ) throw(HRESULT)
{
	if (m_bCancel)
        ft.Throw( VSSDBG_COORD, VSS_S_ASYNC_CANCELLED, L"Cancel detected.");
}


STDMETHODIMP CVssShimObject::QueryInterface(
	IN	REFIID iid,
	OUT	void** pp
	)
{
    if (pp == NULL)
        return E_INVALIDARG;
    if (iid != IID_IUnknown)
        return E_NOINTERFACE;

    AddRef();
    IUnknown** pUnk = reinterpret_cast<IUnknown**>(pp);
    (*pUnk) = static_cast<IUnknown*>(this);
	return S_OK;
}


ULONG CVssShimObject::AddRef()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimObject::AddRef");
	
    return ::InterlockedIncrement(&m_lRef);
}


ULONG CVssShimObject::Release()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimObject::Release");
	
    LONG l = ::InterlockedDecrement(&m_lRef);
    if (l == 0)
        delete this; // We suppose that we always allocate this object on the heap!
    return l;
}


CVssShimObject* CVssShimObject::CreateInstance() throw(HRESULT)
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimObject::CreateInstance");
	
	CVssShimObject* pObj = new CVssShimObject;
	if (pObj == NULL)
		ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

	if (FAILED(pObj->FinalConstructInternal()))
		ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Error initializing the object");

	return pObj;
}


HRESULT CVssShimObject::FinalConstructInternal()
{
	return S_OK;
}


CVssShimObject::CVssShimObject():
	m_bCancel(false),
	m_lRef(0),
	m_guidSimulateSnapshotSetId( GUID_NULL ),
	m_bHasAcquiredSem( false )
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimObject::CVssShimObject");
}


CVssShimObject::~CVssShimObject()
{
	CVssFunctionTracer ft(VSSDBG_COORD, L"CVssShimObject::~CVssShimObject");

	//
	// If we acquired the semaphore then make
	// sure to call SimulateSnapshotThaw.  This happens if the requestor doesn't
	// call it before exiting.
	//
	if ( m_bHasAcquiredSem )
	{
        ft.Trace( VSSDBG_COORD, L"Calling SimulateSnapshotThaw since requestor did not do so" );
        SimulateSnapshotThaw( m_guidSimulateSnapshotSetId );

        //  Make sure we always clear the semaphore.  SimulateSnapshotThaw should always 
        if ( m_bHasAcquiredSem )
        {
        	InterlockedCompareExchange(&g_hSemSnapshotSets, 0, 1);
        	m_bHasAcquiredSem = false;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\coord\src\reg_util.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module reg_util.cxx | Implementation of the Registry-related functions
    @end

Author:

    Adi Oltean  [aoltean]  09/27/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     09/27/1999  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"
#include "vssmsg.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "provmgr.hxx"
#include "reg_util.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORREGUC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CVssCoordinator private methods


void RecursiveDeleteKey(
    IN  CVssFunctionTracer& ft,
    IN  HKEY hParentKey,
    IN  LPCWSTR wszName
    )

/*++

Routine Description:

    Deletes recursively a registry key.

Arguments:

    IN  CVssFunctionTracer& ft,     // function tracer of the caller
    IN  HKEY hParentKey,            // handle to an ancestor key (like HKEY_LOCAL_MACHINE)
    IN  LPCWSTR wszName             // The key path from ancestor

Remarks:

    Calls RecursiveDeleteSubkeys() who also calls this function

--*/

{
    HKEY hKey;
    WCHAR wszFunctionName[] = L"RecursiveDeleteKey";

	BS_ASSERT(ft.hr == S_OK);
    BS_ASSERT(hParentKey);
    BS_ASSERT(wszName && wszName[0] != L'\0');

    // Open the key
    LONG lRes = ::RegOpenKeyExW(
        hParentKey,     //  IN HKEY hKey,
        wszName,        //  IN LPCWSTR lpSubKey,
        0,              //  IN DWORD ulOptions,
        KEY_ALL_ACCESS, //  IN REGSAM samDesired,
        &hKey           //  OUT PHKEY phkResult
        );
    if (lRes != ERROR_SUCCESS)
    {
        if (ft.hr == S_OK)  // Remember only first error
            ft.hr = lRes;
		ft.LogGenericWarning(VSSDBG_COORD, L"RegOpenKeyExW(0x%08lx,%s,...) == 0x%08lx", hParentKey, wszName, lRes);
        ft.Trace( VSSDBG_COORD, L"%s: Error on opening (enumerated) key with name %s. lRes == 0x%08lx",
                  wszFunctionName, wszName, lRes );
        return;
    }
    BS_ASSERT(hKey);

    // Recursive delete the subkeys
    RecursiveDeleteSubkeys( ft, hKey );

    // Close the key
    lRes = ::RegCloseKey( hKey );
    if (lRes != ERROR_SUCCESS)
    {
        if (ft.hr == S_OK)  // Remember only first error
            ft.hr = lRes;
        ft.Trace( VSSDBG_COORD, L"%s: Error on closing key with name %s. lRes == 0x%08lx",
                  wszFunctionName, wszName, lRes );
    }

    // Delete the key
    lRes = ::RegDeleteKeyW( hParentKey, wszName );
    switch( lRes )
    {
    case ERROR_SUCCESS:
        break;
    case ERROR_FILE_NOT_FOUND:
    default:
        if (ft.hr == S_OK)  // Remember only first error
            ft.hr = lRes;
		ft.LogGenericWarning(VSSDBG_COORD, L"RegDeleteKeyW(0x%08lx,%s) == 0x%08lx", hParentKey, wszName, lRes);
        ft.Trace( VSSDBG_COORD, L"%s: Error on deleting key with name %s. lRes == 0x%08lx",
                  wszFunctionName, wszName, lRes );
    }
}


void RecursiveDeleteSubkeys(
    IN  CVssFunctionTracer& ft,
    IN  HKEY hKey
    )

/*++

Routine Description:

    Deletes recursively all subkeys under a registry key.

Arguments:

    IN  CVssFunctionTracer& ft,     // function tracer of the caller
    IN  HKEY hKey,                  // handle to the current key

Remarks:

    Calls RecursiveDeleteKey() for all subkeys, who also calls this function

--*/

{
    WCHAR wszFunctionName[] = L"RecursiveDeleteSubkeys";
    WCHAR   wszSubKeyName[_MAX_KEYNAME_LEN];
    FILETIME time;

	BS_ASSERT(ft.hr == S_OK);
    BS_ASSERT(hKey);

    // Enumerate all subkeys
    while (true)
    {
        // Fill wszSubKeyName with the name of the subkey
        DWORD dwSize = sizeof(wszSubKeyName)/sizeof(wszSubKeyName[0]);
        LONG lRes = ::RegEnumKeyExW(
            hKey,           // IN HKEY hKey,
            0,              // IN DWORD dwIndex,
            wszSubKeyName,  // OUT LPWSTR lpName,
            &dwSize,        // IN OUT LPDWORD lpcbName,
            NULL,           // IN LPDWORD lpReserved,
            NULL,           // IN OUT LPWSTR lpClass,
            NULL,           // IN OUT LPDWORD lpcbClass,
            &time);         // OUT PFILETIME lpftLastWriteTime
        switch(lRes)
        {
        case ERROR_SUCCESS:
            BS_ASSERT(dwSize != 0);
            RecursiveDeleteKey( ft, hKey, wszSubKeyName );
            break; // Go to Next key
        default:
            if (ft.hr == S_OK)  // Remember only first error
                ft.hr = lRes;
    		ft.LogGenericWarning(VSSDBG_COORD, L"RegEnumKeyExW(0x%08lx,%s,...) == 0x%08lx", hKey, wszSubKeyName, lRes);
            ft.Trace( VSSDBG_COORD, L"%s: Error on iteration. 0x%08lx", wszFunctionName, lRes );
        case ERROR_NO_MORE_ITEMS:
            return;   // End of iteration
        }
    }
}


void QueryStringValue(
    IN  CVssFunctionTracer& ft,
    IN  HKEY    hKey,
    IN  LPCWSTR wszKeyName,
    IN  LPCWSTR wszValueName,
    IN  DWORD   dwValueSize,
    OUT LPCWSTR wszValue
    )

/*++

Routine Description:

    Get the content of a (named) value of a registry key.
    Intended to be called from CVssCoordinator methods.
    Throw some HRESULTS on error

Arguments:

    IN  CVssFunctionTracer& ft,
    IN  HKEY hKey,              // handle to the registry key
    IN  LPCWSTR wszKeyName,     // the name of the key (used only in tracing)
    IN  LPCWSTR wszValueName,   // the name of the value. Empty string for default key value.
    IN  DWORD   dwValueSize,    // the size of the value buffer, in WCHARs
    OUT LPCWSTR wszValue        // The content of that value.
                                // The buffer must be already allocated and must have at
                                // least dwValueSize WCHARs

Remarks:

    The code throws an error if value name length is greater than dwValueSize-1

Throws:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - on registry errors. An error log entry is added describing the error.

--*/

{
    WCHAR       wszFunctionName[] = L"QueryStringValue";

	ft.hr = S_OK;

    BS_ASSERT( hKey );
    BS_ASSERT( wszKeyName != NULL && wszKeyName[0] != L'\0' );
    BS_ASSERT( wszValueName != NULL ); // wszValueName can be L""
    BS_ASSERT( dwValueSize != 0 );
    BS_ASSERT( wszValue );

    ::ZeroMemory( (void*)wszValue, dwValueSize * sizeof(WCHAR) );

    // Get the string content of the named key value
    DWORD   dwType;
    DWORD   dwDataSize = dwValueSize * sizeof(WCHAR);
    LPBYTE  pbData = (LPBYTE)wszValue;
    LONG lRes = ::RegQueryValueExW (
        hKey,           //  IN HKEY hKey,
        wszValueName,   //  IN LPCWSTR lpValueName,
        NULL,           //  IN LPDWORD lpReserved,
        &dwType,        //  OUT LPDWORD lpType,
        pbData,         //  IN OUT LPBYTE lpData,
        &dwDataSize     //  IN OUT LPDWORD lpcbData
        );
    if ( lRes != ERROR_SUCCESS )
        ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
            L"RegQueryValueExW(%s,%s,...)", wszKeyName, wszValueName );

    // Unexpected key type
    if ( dwType != REG_SZ ) { 
        ft.LogError(VSS_ERROR_WRONG_REGISTRY_TYPE_VALUE, 
            VSSDBG_COORD << (INT)dwType << (INT)REG_SZ << wszValueName << wszKeyName );
        ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
                  L"%s: The value %s in the key with name %s has not a REG_SZ type. dwType == 0x%08lx",
                  wszFunctionName, wszValueName, wszKeyName, dwType );
    }
}


void QueryDWORDValue(
    IN  CVssFunctionTracer& ft,
    IN  HKEY    hKey,
    IN  LPCWSTR wszKeyName,
    IN  LPCWSTR wszValueName,
    OUT PDWORD pdwValue
    )

/*++

Routine Description:

    Get the content of a (named) value of a registry key.
    Intended to be called from CVssCoordinator methods.
    Throw some HRESULTS on error

Arguments:

    IN  CVssFunctionTracer& ft,
    IN  HKEY hKey,              // handle to the registry key
    IN  LPCWSTR wszKeyName,     // the name of the key (used only in tracing)
    IN  LPCWSTR wszValueName,   // the name of the value. Empty string for default key value.
    OUT PDWORD pdwValue         // The content of that DWORD value.

Remarks:

    The code throws an error if value name length is greater than dwValueSize-1

Throws:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - on registry errors. An error log entry is added describing the error.

--*/

{
    WCHAR       wszFunctionName[] = L"QueryDWORDValue";

	ft.hr = S_OK;

    BS_ASSERT( hKey );
    BS_ASSERT( wszKeyName != NULL && wszKeyName[0] != L'\0' );
    BS_ASSERT( wszValueName != NULL ); // wszValueName can be L""
    BS_ASSERT( pdwValue );

    (*pdwValue)=0;

    // Get the string content of the named key value
    DWORD   dwType = REG_NONE;  // Prefix bug 192471, still doesn't handle throw inside called functions well.
    DWORD   dwDataSize = sizeof(DWORD);
    LPBYTE  pbData = (LPBYTE)pdwValue;
    LONG lRes = ::RegQueryValueExW (
        hKey,           //  IN HKEY hKey,
        wszValueName,   //  IN LPCWSTR lpValueName,
        NULL,           //  IN LPDWORD lpReserved,
        &dwType,        //  OUT LPDWORD lpType,
        pbData,         //  IN OUT LPBYTE lpData,
        &dwDataSize     //  IN OUT LPDWORD lpcbData
        );
    if ( lRes != ERROR_SUCCESS )
        ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
            L"RegQueryValueExW(%s,%s,...)", wszKeyName, wszValueName );

    // Unexpected key type
    if ( dwType != REG_DWORD ) { 
        ft.LogError(VSS_ERROR_WRONG_REGISTRY_TYPE_VALUE, 
            VSSDBG_COORD << (INT)dwType << (INT)REG_DWORD << wszValueName << wszKeyName );
        ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
                  L"%s: The value %s in the key with name %s has not a REG_DWORD type. dwType == 0x%08lx",
                  wszFunctionName, wszValueName, wszKeyName, dwType );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\coord\src\query.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Query.cxx | Implementation of Query methods in coordinator interfaces
    @end

Author:

    Adi Oltean  [aoltean]  09/03/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     09/03/1999  Created
    aoltean     09/09/1999  Adding Query from coord.cxx
                            dss -> vss
	aoltean		09/20/1999	Simplify memory management
	aoltean		09/21/1999	Converting to the new enumerator
	aoltean		09/22/1999  Making the first branch of Query working
	aoltean		09/27/1999	Provider-generic code

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "provmgr.hxx"
#include "admin.hxx"
#include "worker.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"
#include "snap_set.hxx"
#include "vs_sec.hxx"
#include "shim.hxx"
#include "coord.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORQRYC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  QueryXXXX methods


STDMETHODIMP CVssCoordinator::Query(
    IN      VSS_ID          QueriedObjectId,
    IN      VSS_OBJECT_TYPE eQueriedObjectType,
    IN      VSS_OBJECT_TYPE eReturnedObjectsType,
    OUT     IVssEnumObject**ppEnum
    )

/*++

Routine Description:

    Implements the IVssCoordinator::Query method

Arguments:

    IN      VSS_ID          QueriedObjectId,
    IN      VSS_OBJECT_TYPE eQueriedObjectType,
    IN      VSS_OBJECT_TYPE eReturnedObjectsType,
    OUT     IVssEnumObject**ppEnum

Return values:

    E_ACCESSDENIED
        - The user is not a backup operator or an administrator
    E_OUTOFMEMORY
    E_INVALIDARG 
        - Invalid arguments
    VSS_E_OBJECT_NOT_FOUND
        - Queried object not found.
    E_UNEXPECTED
        - CVssEnumFromArray::Init failures
        - QueryInterface(IID_IVssEnumObject,...) failures

    [GetProviderItf() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY
        
        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

    [CVssProviderManager::TransferEnumeratorContentsToArray() failures]
        E_OUTOFMEMORY

        [InitializeAsEmpty failed] 
            E_OUTOFMEMORY
        
        [IVssEnumObject::Next() failed]
            E_OUTOFMEMORY
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - unexpected provider error when calling Next. An error log entry is added describing the error.
            VSS_E_PROVIDER_VETO
                - provider error when calling Next

    [IVssSnapshotProvider::Query failures]
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.

    [QueryProvidersIntoArray() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

        [InitializeAsProvider() failures]
            E_OUTOFMEMORY

        [IVssEnumObject::Query() failures]
            E_OUTOFMEMORY
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - unexpected provider error when calling Next.
            VSS_E_PROVIDER_VETO
                - expected provider error
    
    [CVssProviderManager::GetProviderInterface() failures]     
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY    

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::Query" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: "
             L"QueriedObjectId = " WSTR_GUID_FMT
             L", eQueriedObjectType = %d"
             L", eReturnedObjectsType = %d"
             L", ppEnum = %p",
             GUID_PRINTF_ARG( QueriedObjectId ),
             eQueriedObjectType,
             eReturnedObjectsType,
             ppEnum);

        // Argument validation
        if (QueriedObjectId != GUID_NULL)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid QueriedObjectId");
        if (eQueriedObjectType != VSS_OBJECT_NONE)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid eQueriedObjectType");
        if ((eReturnedObjectsType != VSS_OBJECT_SNAPSHOT)
            && (eReturnedObjectsType != VSS_OBJECT_PROVIDER))
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid eReturnedObjectsType");
		BS_ASSERT(ppEnum);
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL ppEnum");

        // Create the collection object. Initial reference count is 0.
        VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

        // Fill now the collection
        switch( eReturnedObjectsType )
        {
        case VSS_OBJECT_SNAPSHOT:
            {
        		// Get the array of interfaces
        		CSnapshotProviderItfArray ItfArray;
        		CVssProviderManager::GetProviderItfArray( ItfArray );

                // Initialize an observer.
                // This will keep track of all Snapshot set IDs that are created 
                // while the queries are in process
                CVssSnasphotSetIdObserver rec;

                // Start recording. This may throw.
                // (stop recording occurs anyway at object destruction if a throw happens after this call)
                rec.StartRecording();

        		// For each provider get all objects tht corresponds to the filter
        		for (int nIndex = 0; nIndex < ItfArray.GetSize(); nIndex++ )
        		{
            		CComPtr<IVssSnapshotProvider> pProviderItf = ItfArray[nIndex].GetInterface();
        			BS_ASSERT(pProviderItf);
   
        			// Query the provider
            		CComPtr<IVssEnumObject> pEnumTmp;
        			ft.hr = pProviderItf->Query(
        				GUID_NULL,
        				VSS_OBJECT_NONE,
        				VSS_OBJECT_SNAPSHOT,
        				&pEnumTmp
        				);
        			if (ft.HrFailed())
        				ft.TranslateProviderError( VSSDBG_COORD, ItfArray[nIndex].GetProviderId(),
                            L"Error calling Query(). [0x%08lx]", ft.hr);
        			
        			// Add enumerator contents to array
        			CVssProviderManager::TransferEnumeratorContentsToArray( 
        			    ItfArray[nIndex].GetProviderId(), pEnumTmp, pArray );
        		}

                // Stop recording. 
                rec.StopRecording();

                // Remove from the array all snapshots that were created during Query.
                for(int nIndex = 0; nIndex < pArray->GetSize();) {
        			VSS_OBJECT_PROP_Ptr& ptr = (*pArray)[nIndex]; 
        			VSS_OBJECT_PROP* pStruct = ptr.GetStruct();
        			BS_ASSERT(pStruct);
        			BS_ASSERT(pStruct->Type == VSS_OBJECT_SNAPSHOT);
                	VSS_SNAPSHOT_PROP* pSnap = &(pStruct->Obj.Snap);

                    // If the snapshot belongs to a partially created snapshot set, remove it.
                	if (rec.IsRecorded(pSnap->m_SnapshotSetId)) {
                	    pArray->RemoveAt(nIndex);
                        // Do not increment - the same index will refer to the next element, if any.
                	} else {
                	    // This element is OK. Proceed with the next one.
                	    nIndex++;
                    }
                }
            }
    		break;
    		
        case VSS_OBJECT_PROVIDER:
            // Insert property structures into array.
    		CVssProviderManager::QuerySupportedProvidersIntoArray( 
    		    true, NULL, pArray );
    		break;

        default:
            BS_ASSERT(false);
            ft.Throw( VSSDBG_COORD, E_INVALIDARG,
                      L"Cannot create enumerator instance. [0x%08lx]", ft.hr);
        }

        // Create the enumerator object. Beware that its reference count will be zero.
        CComObject<CVssEnumFromArray>* pEnumObject = NULL;
        ft.hr = CComObject<CVssEnumFromArray>::CreateInstance(&pEnumObject);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
                      L"Cannot create enumerator instance. [0x%08lx]", ft.hr);
        BS_ASSERT(pEnumObject);

        // Get the pointer to the IVssEnumObject interface.
		// Now pEnumObject's reference count becomes 1 (because of the smart pointer).
		// So if a throw occurs the enumerator object will be safely destroyed by the smart ptr.
        CComPtr<IUnknown> pUnknown = pEnumObject->GetUnknown();
        BS_ASSERT(pUnknown);

        // Initialize the enumerator object.
		// The array's reference count becomes now 2, because IEnumOnSTLImpl::m_spUnk is also a smart ptr.
        BS_ASSERT(pArray);
		ft.hr = pEnumObject->Init(pArrayItf, *pArray);
        if (ft.HrFailed()) {
            BS_ASSERT(false);
            ft.TranslateGenericError(VSSDBG_COORD, ft.hr, L"Init(%p, %p)", pArrayItf, *pArray);
        }

        // Initialize the enumerator object.
		// The enumerator reference count becomes now 2.
        ft.hr = pUnknown->SafeQI(IVssEnumObject, ppEnum);
        if ( ft.HrFailed() ) {
            BS_ASSERT(false);
            ft.TranslateGenericError(VSSDBG_COORD, ft.hr, L"QueryInterface(IID_IVssEnumObject,%p)", ppEnum);
        }
        BS_ASSERT(*ppEnum);

		BS_ASSERT( !ft.HrFailed() );
		ft.hr = (pArray->GetSize() != 0)? S_OK: S_FALSE;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssAdmin::QueryProviders(
    OUT   IVssEnumObject**ppEnum
    )

/*++

Routine Description:

    Implements the IVssAdmin::QueryProviders method

Arguments:

    OUT     IVssEnumObject**ppEnum

Return values:

    E_OUTOFMEMORY
    E_INVALIDARG 
        - Invalid arguments
    E_ACCESSDENIED
        - The user is not a backup operator or an administrator
    E_UNEXPECTED
        - CVssEnumFromArray::Init failures
        - QueryInterface(IID_IVssEnumObject,...) failures

    [QueryProvidersIntoArray() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

        [InitializeAsProvider() failures]
            E_OUTOFMEMORY

        [IVssEnumObject::Query() failures]
            E_OUTOFMEMORY
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - unexpected provider error when calling Next.
            VSS_E_PROVIDER_VETO
                - expected provider error
    
--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAdmin::QueryProviders" );
    VSS_OBJECT_PROP_Ptr ptrProviderProperties;

    try
    {
        // Initialize [out] arguments
        VssZeroOut( ppEnum );

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: "
             L"ppEnum = %p",
             ppEnum
             );

        // Argument validation
		BS_ASSERT(ppEnum);
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL ppEnum");

        // Create the collection object. Initial reference count is 0.
        VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

        // Insert property structures into array.
		CVssProviderManager::QuerySupportedProvidersIntoArray( 
		    true, NULL, pArray );

        // Create the enumerator object. Beware that its reference count will be zero.
        CComObject<CVssEnumFromArray>* pEnumObject = NULL;
        ft.hr = CComObject<CVssEnumFromArray>::CreateInstance(&pEnumObject);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
                      L"Cannot create enumerator instance. [0x%08lx]", ft.hr);
        BS_ASSERT(pEnumObject);

        // Get the pointer to the IVssEnumObject interface.
		// Now pEnumObject's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pUnknown = pEnumObject->GetUnknown();
        BS_ASSERT(pUnknown);

        // Initialize the enumerator object. The array's itf pointer refcount becomes now 2.
        ft.hr = pEnumObject->Init(pArrayItf, *pArray);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
                      L"Cannot initialize enumerator instance. [0x%08lx]", ft.hr);

        ft.hr = pUnknown->SafeQI(IVssEnumObject, ppEnum);
        if ( ft.HrFailed() )
            ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
                      L"Error querying the IVssEnumObject interface. hr = 0x%08lx", ft.hr);
        BS_ASSERT(*ppEnum);

		BS_ASSERT( !ft.HrFailed() );
		ft.hr = (pArray->GetSize() != 0)? S_OK: S_FALSE;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
//  CVssSnasphotSetIdObserver


//  Global variables
//

// Global list of observers
CVssDLList<CVssSnasphotSetIdObserver*>	 CVssSnasphotSetIdObserver::m_list;

// Global lock fot the observer operations
CVssSafeCriticalSection  CVssSnasphotSetIdObserver::m_cs;


// Implementation
//

// Constructs an observer object
CVssSnasphotSetIdObserver::CVssSnasphotSetIdObserver():
    m_bRecordingInProgress(false), 
    m_Cookie(VSS_NULL_COOKIE)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::CVssSnasphotSetIdObserver" );
}


// Destructs the observer object
// This does NOT throw!
CVssSnasphotSetIdObserver::~CVssSnasphotSetIdObserver()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::~CVssSnasphotSetIdObserver" );

    // Check if the critical section is initialized
    if (!m_cs.IsInitialized())
        return;
    
    // Global lock. This does NOT throw!
    CVssSafeAutomaticLock lock(m_cs);

    // Check for validity
    if (!IsValid())
        return;

    // Remove ourselves to the global list of observers
    // This also does not throw.
    CVssSnasphotSetIdObserver* pThis = NULL;
    m_list.ExtractByCookie(m_Cookie, pThis);
    BS_ASSERT(this == pThis);
}


// Check if the observer is valid
bool CVssSnasphotSetIdObserver::IsValid()
{
    return (m_Cookie != VSS_NULL_COOKIE);
}


// Puts the observer in the listeners list in order to detect partial results in Query
// This may safely throw!
void CVssSnasphotSetIdObserver::StartRecording() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::StartRecording" );

    // Initialize critical section if needed.
    m_cs.Init();
    if (!m_cs.IsInitialized())
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Unable to initialize the global critical section");

    // Global lock - does not throw
    CVssSafeAutomaticLock lock(m_cs);
    
    // Starts the recording
    BS_ASSERT(m_bRecordingInProgress == false);
    m_bRecordingInProgress = true;

    // Try to add the current snapshot set ID, if any
    // This may throw.
    CVssGlobalSnapshotSetId::InitializeObserver(this);

    // Add ourselves to the global list of observers. 
    // This can throw E_OUTOFMEMORY
    if (m_Cookie != VSS_NULL_COOKIE) {
        BS_ASSERT(false);
        return;
    }
    m_Cookie = m_list.Add(ft, this);
}


// Stop recording SSIDs
void CVssSnasphotSetIdObserver::StopRecording()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::StopRecording" );

    // Programming error: you must successfully call StartRecording first!
    if (!IsValid()) {
        BS_ASSERT(false);
        ft.Throw(VSSDBG_COORD, E_UNEXPECTED, L"StartRecording was not called successfully");
    }
    
    // Acquire the critical section. Doesn't throw.
    BS_ASSERT(m_cs.IsInitialized());
    CVssSafeAutomaticLock lock(m_cs);

    // Stops the recording
    BS_ASSERT(m_bRecordingInProgress == true);
    m_bRecordingInProgress = false;
}


// Check if a SSID was in progress
bool CVssSnasphotSetIdObserver::IsRecorded(
    IN  VSS_ID SnapshotSetID 
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::IsRecorded" );

    // Programming error: you must successfully call StartRecording first!
    if (!IsValid()) {
        BS_ASSERT(false);
        ft.Throw(VSSDBG_COORD, E_UNEXPECTED, L"StartRecording was not called successfully");
    }
    
    // Acquire the critical section
    BS_ASSERT(m_cs.IsInitialized());
    CVssSafeAutomaticLock lock(m_cs);

    // Check to see if the snapshot set is recorded
    return (m_mapSnapshotSets.FindKey(SnapshotSetID) != -1);
}


// Records this Snapshot Set ID in ALL observers
void CVssSnasphotSetIdObserver::BroadcastSSID(
    IN VSS_ID SnapshotSetId
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::BroadcastSSID" );

    // Validate arguments
    BS_ASSERT(SnapshotSetId != GUID_NULL);

    // Do not attempt to broadcast SSIDs if there are no observers
    if (!m_cs.IsInitialized())
        return;
    
    // Acquire the critical section
    CVssSafeAutomaticLock lock(m_cs);

    // Record the SSID for all listeners
    //

    // Get an iterator for the global list of observers
	CVssDLListIterator<CVssSnasphotSetIdObserver*> iterator(m_list);

    // Send the SSID to all observers. If we fail in the middle, 
    // then we are still in a consistent state. In order to simplify 
    // the code we will not add any supplementary checks,
    // since the caller (StartSnapshotSet) will fail anyway, 
    // so we will have an additional harmless filtering for an invalid SSID. 

    // This might throw!
    CVssSnasphotSetIdObserver* pObj = NULL;
	while (iterator.GetNext(pObj))
		pObj->RecordSSID(SnapshotSetId);
}


// Records this Snapshot Set ID in this observer instance
// Remark: The lock is already acquired
void CVssSnasphotSetIdObserver::RecordSSID(
    IN VSS_ID SnapshotSetId
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::RecordSSID" );

    // Check to see if recording is in progress.
    if (!m_bRecordingInProgress)
        return;

    // Add the SSID to the internal map
    if (!m_mapSnapshotSets.Add(SnapshotSetId, 0))
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\coord\src\setup.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    setup.cxx

Abstract:

    Implements the Volume Snapshot Service.

Author:

    Adi Oltean  [aoltean]   06/30/1999

Revision History:

    Name        Date        Comments

    aoltean     06/30/1999  Created.
    aoltean     07/23/1999  Making registration code more error-prone.
                            Changing the service name.
    aoltean     08/11/1999  Initializing m_bBreakFlagInternal
    aoltean     09/09/1999  dss -> vss
	aoltean		09/21/1999  Adding a new header for the "ptr" class.
	aoltean		09/27/1999	Adding some headers
	aoltean		10/05/1999	Moved from svc.cxx
	aoltean		03/10/2000	Simplifying Setup

--*/



////////////////////////////////////////////////////////////////////////
//  Includes

#include "StdAfx.hxx"
#include <comadmin.h>
#include "resource.h"

// General utilities
#include "vs_inc.hxx"

#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "comadmin.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSETUC"
//
////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////
//  COM Server registration
//

HRESULT CVsServiceModule::RegisterServer(
    BOOL bRegTypeLib
    )

/*++

Routine Description:

    Register the new COM server.

Arguments:

    bRegTypeLib,

Remarks:

    Called by CVsServiceModule::_WinMain()

Return Value:

    S_OK
    E_UNEXPECTED  if an error has occured. See trace file for details

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::RegisterServer" );

    try
    {
        //
        // Initialize the COM library
        //

        ft.hr = CoInitialize(NULL);
        if ( ft.HrFailed() )
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"CoInitialize failed 0x%08lx", ft.hr );

        // Add registry entries for CLSID and APPID by running proper scripts
        ft.hr = UpdateRegistryFromResource(IDR_VSSVC, TRUE);
        if ( ft.HrFailed() )
			ft.Trace( VSSDBG_COORD, L"UpdateRegistryFromResource failed 0x%08lx", ft.hr );

        // Register the type library and add object map registry entries
        ft.hr = CComModule::RegisterServer(bRegTypeLib);
        if ( ft.HrFailed() )
			ft.Trace( VSSDBG_COORD, L"UpdateRegistryFromResource failed 0x%08lx", ft.hr );

        //
        // Uninitialize the COM library
        //
        CoUninitialize();
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\coord\src\softwrp.cxx ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Abstract:

    @doc
    @module softwrp.cxx | Implementation of CVssSoftwareProviderWrapper
    @end

Author:

    Adi Oltean  [aoltean]  03/11/2001

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     03/11/2001  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "softwrp.hxx"
#include "vssmsg.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSOFTC"
//
////////////////////////////////////////////////////////////////////////


IVssSnapshotProvider* CVssSoftwareProviderWrapper::CreateInstance(
    IN VSS_ID ProviderId,
	IN CLSID ClassId,
    IN bool bCallOnLoad
    ) throw(HRESULT)
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSoftwareProviderWrapper::CreateInstance");

    // Ref count becomes 1
    CComPtr<CVssSoftwareProviderWrapper> pWrapper = new CVssSoftwareProviderWrapper();
    if (pWrapper == NULL)
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

	// Create the IVssSoftwareSnapshotProvider interface
	ft.hr = pWrapper->m_pSoftwareItf.CoCreateInstance(ClassId, NULL, CLSCTX_LOCAL_SERVER);
	if ( ft.HrFailed() ) {
	    ft.LogError(VSS_ERROR_CREATING_PROVIDER_CLASS, VSSDBG_COORD << ClassId << ft.hr );
		ft.Throw( VSSDBG_COORD, VSS_E_UNEXPECTED_PROVIDER_ERROR, L"CoCreateInstance failed with hr = 0x%08lx", ft.hr);
	}
	BS_ASSERT(pWrapper->m_pSoftwareItf);

	// Query the creation itf.
    ft.hr = pWrapper->m_pSoftwareItf->SafeQI( IVssProviderCreateSnapshotSet, &(pWrapper->m_pCreationItf) );
    if (ft.HrFailed()) {
        ft.TranslateProviderError(VSSDBG_COORD, ProviderId, L"QI for IVssProviderCreateSnapshotSet");
    }
	BS_ASSERT(pWrapper->m_pCreationItf);

	// Query the notification itf.
	// Execute the OnLoad, if needed
    ft.hr = pWrapper->m_pSoftwareItf->SafeQI( IVssProviderNotifications, &(pWrapper->m_pNotificationItf) );
    if (ft.HrSucceeded()) {
	    BS_ASSERT(pWrapper->m_pNotificationItf);
        if (bCallOnLoad) {
		    ft.hr = pWrapper->m_pNotificationItf->OnLoad(NULL);
		    if (ft.HrFailed()) 
                ft.TranslateProviderError(VSSDBG_COORD, ProviderId, L"IVssProviderNotifications::OnLoad");
        }
    } else if (ft.hr != E_NOINTERFACE) {
        BS_ASSERT(false);
        ft.TranslateProviderError(VSSDBG_COORD, ProviderId, L"QI for IVssProviderNotifications");
    }

    // return the created interface
    // Ref count is still 1
    return pWrapper.Detach();
}


/////////////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP CVssSoftwareProviderWrapper::QueryInterface(REFIID iid, void** pp)
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSoftwareProviderWrapper::QueryInterface");
    
    if (pp == NULL)
        return E_INVALIDARG;
    if (iid != IID_IUnknown)
        return E_NOINTERFACE;

    AddRef();
    IUnknown** pUnk = reinterpret_cast<IUnknown**>(pp);
    (*pUnk) = static_cast<IUnknown*>(this);
	return S_OK;
};

STDMETHODIMP_(ULONG) CVssSoftwareProviderWrapper::AddRef()
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSoftwareProviderWrapper::AddRef");
    ft.Trace(VSSDBG_COORD, L"Provider Wrapper AddRef(%p) %lu --> %lu", this, m_lRef, m_lRef+1);
    
    return ::InterlockedIncrement(&m_lRef);
};

STDMETHODIMP_(ULONG) CVssSoftwareProviderWrapper::Release()
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSoftwareProviderWrapper::Release");
    ft.Trace(VSSDBG_COORD, L"Provider Wrapper Release(%p) %lu --> %lu", this, m_lRef, m_lRef-1);
    
    LONG l = ::InterlockedDecrement(&m_lRef);
    if (l == 0)
        delete this; // We suppose that we always allocate this object on the heap!
    return l;
};


/////////////////////////////////////////////////////////////////////////////
//  IVssSoftwareSnapshotProvider


STDMETHODIMP CVssSoftwareProviderWrapper::SetContext(
	IN		LONG     lContext
	)
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->SetContext(lContext);
}


STDMETHODIMP CVssSoftwareProviderWrapper::GetSnapshotProperties(
	IN      VSS_ID			SnapshotId,
	OUT 	VSS_SNAPSHOT_PROP	*pProp
	)
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->GetSnapshotProperties(
                SnapshotId,
                pProp
                );
}


STDMETHODIMP CVssSoftwareProviderWrapper::Query(                                      
    IN      VSS_ID          QueriedObjectId,        
    IN      VSS_OBJECT_TYPE eQueriedObjectType,     
    IN      VSS_OBJECT_TYPE eReturnedObjectsType,   
    OUT     IVssEnumObject**ppEnum                 
	)
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->Query(
                QueriedObjectId,        
                eQueriedObjectType,     
                eReturnedObjectsType,   
                ppEnum
                );
}


STDMETHODIMP CVssSoftwareProviderWrapper::DeleteSnapshots(                            
    IN      VSS_ID          SourceObjectId,         
	IN      VSS_OBJECT_TYPE eSourceObjectType,
	IN		BOOL			bForceDelete,			
	OUT		LONG*			plDeletedSnapshots,		
	OUT		VSS_ID*			pNondeletedSnapshotID
	)
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->DeleteSnapshots(
                SourceObjectId,         
                eSourceObjectType,
                bForceDelete,			
                plDeletedSnapshots,		
                pNondeletedSnapshotID
                );
}


STDMETHODIMP CVssSoftwareProviderWrapper::BeginPrepareSnapshot(                                
    IN      VSS_ID          SnapshotSetId,              
    IN      VSS_ID          SnapshotId,
    IN      VSS_PWSZ		pwszVolumeName
	)
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->BeginPrepareSnapshot(
                SnapshotSetId, 
                SnapshotId,
                pwszVolumeName 
                );
}


STDMETHODIMP CVssSoftwareProviderWrapper::IsVolumeSupported( 
    IN      VSS_PWSZ        pwszVolumeName, 
    OUT     BOOL *          pbSupportedByThisProvider
	)
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->IsVolumeSupported(
                pwszVolumeName, 
                pbSupportedByThisProvider
                );
}


STDMETHODIMP CVssSoftwareProviderWrapper::IsVolumeSnapshotted( 
    IN      VSS_PWSZ        pwszVolumeName, 
    OUT     BOOL *          pbSnapshotsPresent,
	OUT 	LONG *		    plSnapshotCompatibility
	)
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->IsVolumeSnapshotted(
                pwszVolumeName, 
                pbSnapshotsPresent,
                plSnapshotCompatibility
                );
}


STDMETHODIMP CVssSoftwareProviderWrapper::MakeSnapshotReadWrite(                            
    IN      VSS_ID          SourceObjectId
	)
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->MakeSnapshotReadWrite(SourceObjectId);
}


STDMETHODIMP CVssSoftwareProviderWrapper::SetSnapshotProperty(
	IN   VSS_ID  			SnapshotId,
	IN   VSS_SNAPSHOT_PROPERTY_ID	eSnapshotPropertyId,
	IN   VARIANT 			vProperty
	)
/*++

Routine description:

    Implements IVssSoftwareSnapshotProvider::SetSnapshotProperty


--*/
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->SetSnapshotProperty(SnapshotId, eSnapshotPropertyId, vProperty);
}


/////////////////////////////////////////////////////////////////////////////
// IVssProviderCreateSnapshotSet


STDMETHODIMP CVssSoftwareProviderWrapper::EndPrepareSnapshots(                            
    IN      VSS_ID          SnapshotSetId
	)
{
    BS_ASSERT(m_pCreationItf);
    return m_pCreationItf->EndPrepareSnapshots(SnapshotSetId);
}


STDMETHODIMP CVssSoftwareProviderWrapper::PreCommitSnapshots(                            
    IN      VSS_ID          SnapshotSetId
    )
{
    BS_ASSERT(m_pCreationItf);
    return m_pCreationItf->PreCommitSnapshots(SnapshotSetId);
}


STDMETHODIMP CVssSoftwareProviderWrapper::CommitSnapshots(                            
    IN      VSS_ID          SnapshotSetId
    )
{
    BS_ASSERT(m_pCreationItf);
    return m_pCreationItf->CommitSnapshots(SnapshotSetId);
}


STDMETHODIMP CVssSoftwareProviderWrapper::PostCommitSnapshots(                            
    IN      VSS_ID          SnapshotSetId,
	IN      LONG            lSnapshotsCount
    )
{
    BS_ASSERT(m_pCreationItf);
    return m_pCreationItf->PostCommitSnapshots(SnapshotSetId, lSnapshotsCount);
}


STDMETHODIMP CVssSoftwareProviderWrapper::AbortSnapshots(                             
    IN      VSS_ID          SnapshotSetId
    )
{
    BS_ASSERT(m_pCreationItf);
    return m_pCreationItf->AbortSnapshots(SnapshotSetId);
}


////////////////////////////////////////////////////////////////////////
// IVssProviderNotifications

STDMETHODIMP CVssSoftwareProviderWrapper::OnUnload(								
	IN  	BOOL	bForceUnload				
    )
{
    return m_pNotificationItf? m_pNotificationItf->OnUnload(bForceUnload): S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\coord\src\stdafx.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    StdAfx.cxx

Abstract:

    Source file that includes just the standard includes.  stdafx.pch will be
    the pre-compiled header and stdafx.obj will contain the pre-compiled type
    information.

Author:

    Adi Oltean   [aoltean]      07/02/1999

Revision History:

--*/

#include "StdAfx.hxx"

// Needed here to match COM server definitions with the <atlimpl.cpp> stuff
#include "vs_inc.hxx"

#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#pragma warning( disable: 4189 )  /* local variable is initialized but not referenced */
#include <atlimpl.cpp>
#pragma warning( default: 4189 )  /* local variable is initialized but not referenced */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\coord\src\snap_set.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Coord.cxx | Implementation of CVssSnapshotSetObject
    @end

Author:

    Adi Oltean  [aoltean]  07/09/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     07/09/1999  Created
    aoltean     07/23/1999  Adding List, moving Admin functions in the Admin.cxx
    aoltean     08/11/1999  Adding support for Software and test provider
    aoltean     08/18/1999  Adding events. Making itf pointers CComPtr.
                            Renaming XXXSnapshots -> XXXSnapshot
    aoltean     08/18/1999  Renaming back XXXSnapshot -> XXXSnapshots
                            More stabe state management
                            Resource deallocations is fair
                            More comments
                            Using CComPtr
    aoltean     09/09/1999  Moving constants in coord.hxx
                            Add Security checks
                            Add argument validation.
                            Move Query into query.cpp
                            Move AddvolumesToInternalList into private.cxx
                            dss -> vss
	aoltean		09/21/1999  Adding a new header for the "ptr" class.
	aoltean		09/27/1999	Provider-generic code.
	aoltean		10/04/1999	Treatment of writer error codes.
	aoltean		10/12/1999	Adding HoldWrites, ReleaseWrites
	aoltean		10/13/1999	Moving from coord.cxx into snap_set.cxx
	brianb		04/20/2000  Added SQL wrapper stuff
	brianb      04/21/2000  Disable SQL writer until new ODBC driver is available

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"
#include "vssmsg.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "worker.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"

#include "provmgr.hxx"
#include "snap_set.hxx"

#include "vswriter.h"
#include "sqlsnap.h"
#include "sqlwriter.h"
#include "vs_filter.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSNPSC"
//
////////////////////////////////////////////////////////////////////////

// global semaphore used to serialize creation of snapshot sets
LONG g_hSemSnapshotSets = 0;



/////////////////////////////////////////////////////////////////////////////
//  CVssSnapshotSetObject


HRESULT CVssSnapshotSetObject::StartSnapshotSet(
    OUT		VSS_ID*     pSnapshotSetId
    )
/*++

Routine description:
	
	Starts a new calling sequence for snapshot creation.
	Called by CVssCoordinator::StartSnapshotSet.

Arguments:

    OUT		VSS_ID*     pSnapshotSetId

Return values:

    E_OUTOFMEMORY
    VSS_E_SNAPSHOT_SET_IN_PROGRESS
        - StartSnapshotSet is called while another snapshot set in in the
		  process of being created
    E_UNEXPECTED
        - if CoCreateGuid fails

    [Deactivate() failures] or
    [Activate() failures]
        [lockObj failures]
            E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::StartSnapshotSet" );

    try
    {
		BS_ASSERT(pSnapshotSetId);
		BS_ASSERT(!m_bHasAcquiredSem);

        // Prevent simultaneous creation of multiple snapshot sets on the same machine.
		if (InterlockedCompareExchange(&g_hSemSnapshotSets, 1, 0) != 0)
			ft.Throw
				(
				VSSDBG_COORD,
				VSS_E_SNAPSHOT_SET_IN_PROGRESS,
				L"Snapshot set creation is already in progress."
				);

        m_bHasAcquiredSem = true;

        // Verifying state...
        if (m_eCoordState != VSSC_Initialized) {
			// Mark the ending of the snapshot set creation!
			// Warning: may throw E_OUTOFMEMORY
			Deactivate();
        }

		// We should be in the correct state.
        BS_ASSERT(m_eCoordState == VSSC_Initialized);
        BS_ASSERT(m_lSnapshotsCount == 0);

        // Allocate a new Snapshot Set ID
		CVssGlobalSnapshotSetId::NewID();

		// Mark the beginning of the snapshot set creation
		// WARNING: This call may throw an E_OUTOFMEMORY exception!
		Activate();

        // Initialize the state of the snapshot set object.
		// Do not initialize any state that is related to the background state.
        ft.Trace( VSSDBG_COORD, L"Initialize the state of the snapshot set object" );
        (*pSnapshotSetId) = CVssGlobalSnapshotSetId::GetID();
        m_eCoordState = VSSC_SnapshotSetStarted;
    }
    VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed() && m_bHasAcquiredSem)
		{
        // Reset the allocated Snapshot Set ID
		CVssGlobalSnapshotSetId::ResetID();

		InterlockedCompareExchange(&g_hSemSnapshotSets, 0, 1);
		m_bHasAcquiredSem = false;
		}

    return ft.hr;
}


HRESULT CVssSnapshotSetObject::AddToSnapshotSet(
    IN      VSS_PWSZ    pwszVolumeName,              
    IN      VSS_ID      ProviderId,                
	OUT 	VSS_ID		*pSnapshotId
    )
/*++

Routine description:
	
	Adds a volume to the snapshot set

Arguments:

    pwszVolumeName, - volume name (to be parsed by GetVolumeNameForVolumeMountPointW)
    ProviderId      - ID of the provider or GUID_NULL for automatic choosing of the provider
    ppSnapshot      - If non-NULL then will hold a pointer for the returned IVssSnapshot

Return values:

    E_OUTOFMEMORY
    VSS_E_BAD_STATE
        - wrong calling sequence.
    E_INVALIDARG
        - Invalid arguments (for example the volume name is invalid).
    VSS_E_VOLUME_NOT_SUPPORTED
        - The volume is not supported by any registered providers

    [GetSupportedProviderId() failures]
        E_OUTOFMEMORY
        E_INVALIDARG
            - if the volume is not in the correct format.
        VSS_E_VOLUME_NOT_SUPPORTED
            - If the given volume is not supported by any provider

        [QueryProvidersIntoArray() failures]
            E_OUTOFMEMORY

            [lockObj failures]
                E_OUTOFMEMORY

            [LoadInternalProvidersArray() failures]
                E_OUTOFMEMORY
                E_UNEXPECTED
                    - error while reading from registry. An error log entry is added describing the error.

            [CVssSoftwareProviderWrapper::CreateInstance failures]
                E_OUTOFMEMORY

                [CoCreateInstance() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - The provider interface couldn't be created. An error log entry is added describing the error.

                [OnLoad() failures]
                [QueryInterface failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.
                    VSS_E_PROVIDER_VETO
                        - Expected provider error. The provider already did the logging.

            [InitializeAsProvider() failures]
                E_OUTOFMEMORY

            [IVssSnapshotProvider::IsVolumeSupported() failures]
                E_INVALIDARG
                    NULL pointers passed as parameters or a volume name in an invalid format.
                E_OUTOFMEMORY
                    Out of memory or other system resources
                VSS_E_PROVIDER_VETO
                    An error occured while opening the IOCTL channel. The error is logged.
                VSS_E_OBJECT_NOT_FOUND
                    If the volume name does not correspond to an existing mount point

    [GetProviderInterfaceForSnapshotCreation() failures]

        VSS_E_PROVIDER_NOT_REGISTERED

        [lockObj failures]
            E_OUTOFMEMORY

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.

            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

    [CVssQueuedVolumesList::AddVolume() failures]
        E_UNEXPECTED
            - The thread state is incorrect. No logging is done - programming error.
        VSS_E_OBJECT_ALREADY_EXISTS
            - The volume was already added to the snapshot set.
        VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED
            - The maximum number of volumes was reached.
        E_OUTOFMEMORY

        [Initialize() failures]
            E_OUTOFMEMORY

    [BeginPrepareSnapshot() failures]
        E_INVALIDARG
        VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER
        VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.
        VSS_E_OBJECT_NOT_FOUND
            The device does not exist or it is not ready.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::AddToSnapshotSet" );
	WCHAR wszVolumeNameInternal[nLengthOfVolMgmtVolumeName + 1];
	VSS_ID InternalProviderId = ProviderId;

    bool bVolumeInserted = false;
    bool bProviderItfInserted = false;

    try
    {
		BS_ASSERT(::wcslen(pwszVolumeName) > 0);
		BS_ASSERT(pSnapshotId);

        // Verifying state
        if (m_eCoordState != VSSC_SnapshotSetStarted)
            ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE,
					  L"Snapshot Set in incorrect state %d", m_eCoordState);

		// Getting the volume name
		if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeName,
				wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal)))
			ft.Throw( VSSDBG_COORD, VSS_E_VOLUME_NOT_SUPPORTED, // Changed from E_INVALIDARG, bug 197074
					  L"GetVolumeNameForVolumeMountPoint(%s,...) "
					  L"failed with error code 0x%08lx", pwszVolumeName, GetLastError());
		BS_ASSERT(::wcslen(wszVolumeNameInternal) != 0);
		BS_ASSERT(::IsVolMgmtVolumeName( wszVolumeNameInternal ));

        // If the caller did not specified a provider
        if (InternalProviderId == GUID_NULL) {
            // Choose a provider that works.
            // This call may throw!
            GetSupportedProviderId( wszVolumeNameInternal, &InternalProviderId );
            ft.Trace( VSSDBG_COORD, L"Provider found: " WSTR_GUID_FMT, GUID_PRINTF_ARG(InternalProviderId) );

            BS_ASSERT(InternalProviderId != GUID_NULL);
        }

		// Get the provider interface
		CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.Lookup( InternalProviderId );
        if (!pProviderItf) {
            // The ref count will be 2 since the method keeps another
            // copy in its internal local cache.
		    GetProviderInterfaceForSnapshotCreation( InternalProviderId, &pProviderItf );
		    BS_ASSERT(pProviderItf);

		    // Add the interface to the array. In this moment the reference count will become 3.
            // We cannot use the local cache for keeping these interfaces because we need to
            // differentiate between provider interfaces involved in the current snapshot set
            // and provider interfaces involved in auto-delete snapshots.
		    if ( !m_mapProviderItfInSnapSet.Add( InternalProviderId, pProviderItf ) )
                ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

		    // Mark the provider interface as inserted
            bProviderItfInserted = true;
        }

		// Add volume to the thread set.
		// TBD: In the future snapshots will be allowed without involving Lovelace.
		ft.hr = m_VolumesList.AddVolume(wszVolumeNameInternal, pwszVolumeName);
		if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, ft.hr,
					  L"Error adding volume %s to the thread set. 0x%08lx",
					  wszVolumeNameInternal, ft.hr);

		// Mark the volume as inserted
		bVolumeInserted = true;

        // Create the snapshot Id
        VSS_ID SnapshotId;
		ft.hr = ::CoCreateGuid(&SnapshotId);
		if (ft.HrFailed())
			ft.TranslateGenericError( VSSDBG_COORD, ft.hr, L"CoCreateGuid()");

        // Prepare the snapshot
        ft.hr = pProviderItf->BeginPrepareSnapshot(
                    CVssGlobalSnapshotSetId::GetID(),
                    SnapshotId,
                    wszVolumeNameInternal
                    );
        // Check if the volume is a non-supported one.
        if ( ft.hr == E_INVALIDARG ) {
            ft.Throw( VSSDBG_COORD, E_INVALIDARG,
                L"Invalid arguments to BeginPrepareSnapshot for provider " WSTR_GUID_FMT,
                GUID_PRINTF_ARG(ProviderId) );
        }
        if ( ft.hr == VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER ) {
            BS_ASSERT( ProviderId != GUID_NULL );
            ft.Throw( VSSDBG_COORD, VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER,
                L"Volume %s not supported by provider " WSTR_GUID_FMT,
                wszVolumeNameInternal, GUID_PRINTF_ARG(ProviderId) );
        }
        if ( ft.hr == VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED ) {
            ft.Throw( VSSDBG_COORD, VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED,
                L"Volume %s has too many snapshots" WSTR_GUID_FMT,
                wszVolumeNameInternal, GUID_PRINTF_ARG(ProviderId) );
        }
        if ( ft.HrFailed() )
            ft.TranslateProviderError(VSSDBG_COORD, InternalProviderId,
                L"BeginPrepareSnapshot("WSTR_GUID_FMT L","WSTR_GUID_FMT L",%s)",
                GUID_PRINTF_ARG(CVssGlobalSnapshotSetId::GetID()),
                GUID_PRINTF_ARG(SnapshotId), 
                wszVolumeNameInternal);

        // Increment the number of snapshots on this set
        m_lSnapshotsCount++;

        // Set the Snapshot ID
        (*pSnapshotId) = SnapshotId;

        // The pProviderItf reference count will be again 2
        // (the itfs in local cache and in the snapshot set cache) since the smart pointer is gone
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed()) {
		// We do not need to abort the snapshot on error since BeginPrepareSnapshot is the last call.

    	// Remove the volume from the list, if added
    	if (bVolumeInserted) {
    		HRESULT hr2 = m_VolumesList.RemoveVolume( wszVolumeNameInternal );
    		if (FAILED(hr2)) {
    		    BS_ASSERT(false);
    			ft.Trace( VSSDBG_COORD, L"Warning: Error deleting the volume 0x%08lx", hr2);
    		}
    	}

    	// Remove the new interface, if added
    	if (bProviderItfInserted) {
    		if (!m_mapProviderItfInSnapSet.Remove( InternalProviderId ))
    			ft.Trace( VSSDBG_COORD, L"Warning: Error deleting the added interface");
    	}
    }

    return ft.hr;
}


HRESULT CVssSnapshotSetObject::DoSnapshotSet()
/*++

Routine description:

    Performs DoSnapshotSet in a synchronous manner.

Error codes:

    E_OUTOFMEMORY
        - lock statement.
    VSS_E_BAD_STATE
        - Wrong calling sequence.

    [EndPrepareAllSnapshots() failures] or
    [PreCommitAllSnapshots() failures] or
    [CommitAllSnapshots() failures] or
    [PostCommitAllSnapshots() failures]
    
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Invalid number of prepared snapshots

        [EndPrepareSnapshots() failures] or
        [PreCommitSnapshots() failures] or
        [CommitSnapshots() failures] or
        [PostCommitSnapshots() failures]
            E_OUTOFMEMORY
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.
            VSS_E_PROVIDER_VETO
                - Expected provider error. The provider already did the logging.
            VSS_E_OBJECT_NOT_FOUND
                - If the volume name does not correspond to an existing mount point then abort 
                snapshot creation process amd throw VSS_E_OBJECT_NOT_FOUND (Bug 227375)

    [PrepareAndFreezeWriters() failures] or
    [ThawWriters() failures]
        E_OUTOFMEMORY

        [CoCreateInstance(CLSID_VssEvent) failures] or
        [PrepareForSnapshot() failures] or
        [Freeze() failures]
            E_OUTOFMEMORY
            VSS_E_UNEXPECTED_WRITER_ERROR
                - Unexpected writer error. The error code is logged into the event log.

    [LovelaceFlushAndHold() failures]
        [FlushAndHoldAllWrites() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - Invalid thread state. Dev error - no entry is put in the event log.
                - Empty volume array. Dev error - no entry is put in the event log.
                - Error creating or waiting a Win32 event. An entry is added into the Event Log if needed.
            VSS_ERROR_FLUSH_WRITES_TIMEOUT
                - An error occured while flushing the writes from a background thread. An event log entry is added.

    [LovelaceRelease() failures]
        [ReleaseAllWrites() failures]
            [WaitForFinish() failures]
                E_UNEXPECTED
                    - The list of volumes is empty. Dev error - nothing is logged on.
                    - SetEvent failed. An entry is put in the error log.
                    - WaitForMultipleObjects failed. An entry is put in the error log.
                E_OUTOFMEMORY
                    - Cannot create the array of handles.
                    - One of the background threads failed with E_OUTOFMEMORY
                VSS_E_HOLD_WRITES_TIMEOUT
                    - Lovelace couldn't keep more the writes. An event log entry is added.

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::DoSnapshotSet" );

    try
    {
		//
		// Enter in the critical section.
		//

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

        // Verifying state
        if (m_eCoordState != VSSC_SnapshotSetStarted)
            ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE, L"Snapshot Set in incorrect state %d", m_eCoordState);
        m_eCoordState = VSSC_SnapshotCreation;

        if (m_lSnapshotsCount == 0)
            ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE, L"Snapshot Set is empty");

		//
		// Create the snapshot set
		//

		// End the prepare phase for all snapshots. Cancel detection inside
		EndPrepareAllSnapshots();

		// Send PrepareForSnapshot and Freeze to writers.
		// This function may throw HRESULTs
		// Cancel detection inside.
		PrepareAndFreezeWriters();

		// Pre-commit all snapshots. Cancel detection inside
		PreCommitAllSnapshots();

		// Flush and Hold writes on involved volumes
		LovelaceFlushAndHold();

		// Commit all snapshots. Cancel detection inside
		CommitAllSnapshots();

		// Release writes on involved volumes
		LovelaceRelease();

		// On each involved provider, call PostCommitSnapshots for all committed snapshots.
		PostCommitAllSnapshots();

		// Send the Thaw event to all writers.
		ThawWriters();

		//
		// Snapshot set created.
		//

        // Remove any snapshotset related  state
		Deactivate();

		// Hide errors in eventuality of writer vetos
		ft.hr = S_OK;
    }
    VSS_STANDARD_CATCH(ft)

	CVssFunctionTracer ft2( VSSDBG_COORD, L"CVssSnapshotSetObject::DoSnapshotSet_failure_block" );

    try
    {
    	// Cleanup on error...
    	if (ft.hr != S_OK) // HrFailed not used since VSS_S_ASYNC_CANCELLED may be thrown...
    	{
    		ft.Trace( VSSDBG_COORD, L"Abort detected while commiting the snapshot set 0x%08lx", ft.hr );
            // These functions should not throw

    		// Deal correctly with committed snapshots
    		AbortAllSnapshots();

        	// Release writes on involved volumes using Lovelace.
        	// Tracing the return value already done.
        	m_VolumesList.ReleaseAllWrites();

    		// Send Abort to all writers,regardless of what events they were already received.
    		AbortWriters();

            // If it was a cancel then abort the snapshot set in progress.
            // WARNING: This call may throw
            if (ft.hr == VSS_S_ASYNC_CANCELLED)
                Deactivate();
    	}
    }
    VSS_STANDARD_CATCH(ft2);

    if (ft2.HrFailed())
	    ft2.Trace( VSSDBG_COORD, L"Exception catched 0x%08lx", ft2.hr);

	BS_ASSERT(m_bHasAcquiredSem);
	InterlockedCompareExchange(&g_hSemSnapshotSets, 0, 1);
	m_bHasAcquiredSem = false;

    return ft.hr;
}


void CVssSnapshotSetObject::PrepareAndFreezeWriters() throw (HRESULT)
/*++

Routine description:

    Send the PrepareForSnapshot and Freeze events to all writers.

Error codes:

    E_OUTOFMEMORY
    VSS_S_ASYNC_CANCELLED
        - if IVssAsync::Cancel was called

    [CoCreateInstance(CLSID_VssEvent) failures] or
    [PrepareForSnapshot() failures] or
    [Freeze() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_WRITER_ERROR
            - Unexpected writer error. The error code is logged into the event log.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::PrepareAndFreezeWriters" );
		
    // Allocate the string for snapshot set ID
     CComBSTR bstrSnapshotSetID = CVssGlobalSnapshotSetId::GetID();
    if (!bstrSnapshotSetID)
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

    // Create the instance of the event class
    if (m_pWriters == NULL)
    {
        CVssFunctionTracer ft( VSSDBG_COORD, L"PrepareAndFreezeWriters_create_writers_instance" );
        ft.hr = m_pWriters.CoCreateInstance(CLSID_VssEvent);
        ft.TranslateWriterReturnCode( VSSDBG_COORD, L"CoCreateInstance(CLSID_VssEvent)");
        BS_ASSERT(m_pWriters);
		SetupPublisherFilter(m_pWriters);
    }

	// Test if an Cancel occured
	TestIfCancelNeeded(ft);

	// Get the list of volumes to be snapshotted
	CComBSTR bstrVolumeNamesList = m_VolumesList.GetVolumesList();
	if (bstrVolumeNamesList.Length() == 0)
		ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Null volume list");

	// We will ignore the case when if some subscribers returned and
	// error code while treating the event. This is because
	// transient subscriptions are not garbage collected in the event system.
	// In other words, if a subscriber process died without having a change to remove its
	// transient subscriptions the sending event will return one of these
	// EVENT_XXXX_SUBSCRIBERS_FAILED - which is wrong. Therefore this mechanism is not so
	// reliable therefore we will not use it.

    // Send "PrepareForSnapshot" event to all subscribers
    ft.hr = m_pWriters->PrepareForSnapshot(
				bstrSnapshotSetID,
				bstrVolumeNamesList
				);
    ft.TranslateWriterReturnCode( VSSDBG_COORD, L"PrepareForSnapshot(%s,%s)", bstrSnapshotSetID, bstrVolumeNamesList);

	// Test if an Cancel occured
	TestIfCancelNeeded(ft);

    // Freeze the front-end apps
    FreezePhase(bstrSnapshotSetID, VSS_APP_FRONT_END);

    // Freeze the back-end apps
    FreezePhase(bstrSnapshotSetID, VSS_APP_BACK_END);

    // Freeze the system writers
    FreezePhase(bstrSnapshotSetID, VSS_APP_SYSTEM);
}


void CVssSnapshotSetObject::FreezePhase(
        IN  CComBSTR& bstrSnapshotSetID,
        IN  VSS_APPLICATION_LEVEL eAppLevel
        ) throw (HRESULT)
/*++

Routine description:

    Send the Freeze events to all writers.

Error codes:

    E_OUTOFMEMORY
    VSS_S_ASYNC_CANCELLED
        - if IVssAsync::Cancel was called

    [Freeze() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_WRITER_ERROR
            - Unexpected writer error. The error code is logged into the event log.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::FreezePhase" );
		
    // Send "Freeze" event to all level 0 subscribers
    BS_ASSERT(m_pWriters != NULL);
    ft.hr = m_pWriters->Freeze(bstrSnapshotSetID, eAppLevel);
    ft.TranslateWriterReturnCode( VSSDBG_COORD, L"Freeze(%s,%d)", bstrSnapshotSetID, (INT)eAppLevel);

	// Test if an Cancel occured
	TestIfCancelNeeded(ft);
}


void CVssSnapshotSetObject::ThawWriters() throw (HRESULT)
/*++

Routine description:

    Send the Thaw events to all writers.

Error codes:

    E_OUTOFMEMORY

    [Thaw() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_WRITER_ERROR
            - Unexpected writer error. The error code is logged into the event log.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::ThawWriters" );
		
    // Allocate the string for snapshot set ID
    CComBSTR bstrSnapshotSetID = CVssGlobalSnapshotSetId::GetID();

    if (!bstrSnapshotSetID) {
		// We cannot send anymore the Thaw event since we have a memory allocation error
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
	} else {

		// Send "Thaw" event to all subscribers
        BS_ASSERT(m_pWriters != NULL);
		ft.hr = m_pWriters->Thaw(bstrSnapshotSetID);
        ft.TranslateWriterReturnCode( VSSDBG_COORD, L"Thaw(%s)", bstrSnapshotSetID);
	}
}


void CVssSnapshotSetObject::AbortWriters()
/*++

Routine description:

    Send the Abort events to all writers.

Error codes:

    [Abort() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_WRITER_ERROR
            - Unexpected writer error. The error code is logged into the event log.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::AbortWriters" );
		
	if (m_pWriters != NULL) {

		// Allocate the string for snapshot set ID
		CComBSTR bstrSnapshotSetID = CVssGlobalSnapshotSetId::GetID();

		if (!bstrSnapshotSetID) {
			// We cannot send anymore the Abort event since we have a memory allocation error
			ft.Trace( VSSDBG_COORD, L"Memory allocation error");
		} else {

			// Send "Abort" event to all subscribers
			ft.hr = m_pWriters->Abort(bstrSnapshotSetID);
            ft.TranslateWriterReturnCode( VSSDBG_COORD, L"Abort(%s)", bstrSnapshotSetID);
		}
	}
}


void CVssSnapshotSetObject::LovelaceFlushAndHold()
/*++

Routine description:

    Invokes the Lovelace's Flush& Hold on all volumes in the snapshot set.

Throws:

    [FlushAndHoldAllWrites() failures]
        E_OUTOFMEMORY
        E_UNEXPECTED
            - Invalid thread state. Dev error - no entry is put in the event log.
            - Empty volume array. Dev error - no entry is put in the event log.
            - Error creating or waiting a Win32 event. An entry is added into the Event Log if needed.
        VSS_ERROR_FLUSH_WRITES_TIMEOUT
            - An error occured while flushing the writes from a background thread. An event log entry is added.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::LovelaceFlushAndHold" );

	// Flush And Hold writes on involved volumes using Lovelace.
	ft.hr = m_VolumesList.FlushAndHoldAllWrites(CVssGlobalSnapshotSetId::GetID());
	if (ft.HrFailed())
		ft.Throw(VSSDBG_COORD, ft.hr, L"Flush and Hold failure");
}


void CVssSnapshotSetObject::LovelaceRelease()
/*++

Routine description:

    Invokes the Lovelace's Release on all volumes in the snapshot set,

Throws:

    [ReleaseAllWrites() failures]
        [WaitForFinish() failures]
            E_UNEXPECTED
                - The list of volumes is empty. Dev error - nothing is logged on.
                - SetEvent failed. An entry is put in the error log.
                - WaitForMultipleObjects failed. An entry is put in the error log.
            E_OUTOFMEMORY
                - Cannot create the array of handles.
                - One of the background threads failed with E_OUTOFMEMORY
            VSS_E_HOLD_WRITES_TIMEOUT
                - Lovelace couldn't keep more the writes. An event log entry is added.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::LovelaceRelease" );

	// Release writes on involved volumes using Lovelace.
	ft.hr = m_VolumesList.ReleaseAllWrites();
	if (ft.HrFailed())
		ft.Throw(VSSDBG_COORD, ft.hr, L"Release failure");
}


void CVssSnapshotSetObject::EndPrepareAllSnapshots() throw(HRESULT)
/*++

Routine description:

    Call EndPrepareSnapshots for each provider involved in the snapshot set.

Error codes:

    VSS_E_UNEXPECTED_PROVIDER_ERROR
        - Invalid number of prepared snapshots

    [EndPrepareSnapshots() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.
        VSS_E_OBJECT_NOT_FOUND
            If the volume name does not correspond to an existing mount point then abort 
            snapshot creation process amd throw VSS_E_OBJECT_NOT_FOUND (Bug 227375)

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::EndPrepareAllSnapshots" );
		
	// On each involved provider, call PreCommitSnapshots for all prepared snapshots.
	for(int nIndex = 0; nIndex < m_mapProviderItfInSnapSet.GetSize(); nIndex++ )
	{
		// End the background prepare phase
		CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.GetValueAt(nIndex);
        ft.hr = pProviderItf->EndPrepareSnapshots(
                    CVssGlobalSnapshotSetId::GetID());
        if ( ft.hr == VSS_E_OBJECT_NOT_FOUND )
    		ft.Throw(VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, 
    		    L"'Object not found' detected in provider call. Provider ID = " WSTR_GUID_FMT, 
    		    GUID_PRINTF_ARG(m_mapProviderItfInSnapSet.GetKeyAt(nIndex)));
		else if ( ft.HrFailed() )
			ft.TranslateProviderError( VSSDBG_COORD, m_mapProviderItfInSnapSet.GetKeyAt(nIndex),
			    L"EndPrepareSnapshots("WSTR_GUID_FMT L")",
			    GUID_PRINTF_ARG(CVssGlobalSnapshotSetId::GetID()));

		// Test if an Cancel occured
		TestIfCancelNeeded(ft);
    }
}


void CVssSnapshotSetObject::PreCommitAllSnapshots() throw(HRESULT)
/*++

Routine description:

    Call PreCommitSnapshots for each provider involved in the snapshot set.

Error codes:

    VSS_E_UNEXPECTED_PROVIDER_ERROR
        - Invalid number of prepared snapshots

    [PreCommitSnapshots() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.
        VSS_E_OBJECT_NOT_FOUND
            If the volume name does not correspond to an existing mount point then abort 
            snapshot creation process amd throw VSS_E_OBJECT_NOT_FOUND (Bug 227375)

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::PreCommitAllSnapshots" );
		
	// On each involved provider, call PreCommitSnapshots for all prepared snapshots.
	for(int nIndex = 0; nIndex < m_mapProviderItfInSnapSet.GetSize(); nIndex++ )
	{
		// Pre-commit
		CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.GetValueAt(nIndex);
        ft.hr = pProviderItf->PreCommitSnapshots(
                    CVssGlobalSnapshotSetId::GetID());
        if ( ft.hr == VSS_E_OBJECT_NOT_FOUND )
    		ft.Throw(VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, 
    		    L"'Object not found' detected in provider call. Provider ID = " WSTR_GUID_FMT, 
    		    GUID_PRINTF_ARG(m_mapProviderItfInSnapSet.GetKeyAt(nIndex)));
		else if ( ft.HrFailed() )
			ft.TranslateProviderError( VSSDBG_COORD, m_mapProviderItfInSnapSet.GetKeyAt(nIndex),
			    L"PreCommitSnapshots("WSTR_GUID_FMT L")",
			    GUID_PRINTF_ARG(CVssGlobalSnapshotSetId::GetID()));
		
		// Test if an Cancel occured
		TestIfCancelNeeded(ft);
    }
}


void CVssSnapshotSetObject::CommitAllSnapshots() throw(HRESULT)
/*++

Routine description:

    Call CommitSnapshots for each provider involved in the snapshot set.

Error codes:

    VSS_E_UNEXPECTED_PROVIDER_ERROR
        - Invalid number of prepared snapshots

    [CommitSnapshots() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.
        VSS_E_OBJECT_NOT_FOUND
            If the volume name does not correspond to an existing mount point then abort 
            snapshot creation process amd throw VSS_E_OBJECT_NOT_FOUND (Bug 227375)

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::CommitAllSnapshots" );

	// On each involved provider, call CommitSnapshots for all prepared snapshots.
	for(int nIndex = 0; nIndex < m_mapProviderItfInSnapSet.GetSize(); nIndex++ )
	{
		// Commit
		CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.GetValueAt(nIndex);
        ft.hr = pProviderItf->CommitSnapshots(
                    CVssGlobalSnapshotSetId::GetID());
        if ( ft.hr == VSS_E_OBJECT_NOT_FOUND )
    		ft.Throw(VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, 
    		    L"'Object not found' detected in provider call. Provider ID = " WSTR_GUID_FMT, 
    		    GUID_PRINTF_ARG(m_mapProviderItfInSnapSet.GetKeyAt(nIndex)));
		else if ( ft.HrFailed() )
			ft.TranslateProviderError( VSSDBG_COORD, m_mapProviderItfInSnapSet.GetKeyAt(nIndex),
			    L"CommitSnapshots("WSTR_GUID_FMT L")",
			    GUID_PRINTF_ARG(CVssGlobalSnapshotSetId::GetID()));

		// Test if an Cancel occured
		TestIfCancelNeeded(ft);
    }
}


void CVssSnapshotSetObject::PostCommitAllSnapshots() throw (HRESULT)
/*++

Routine description:

    Call PostCommitSnapshots for each provider involved in the snapshot set.

Error codes:

    VSS_E_UNEXPECTED_PROVIDER_ERROR
        - Invalid number of prepared snapshots

    [PostCommitSnapshots() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.
        VSS_E_OBJECT_NOT_FOUND
            If the volume name does not correspond to an existing mount point then abort 
            snapshot creation process amd throw VSS_E_OBJECT_NOT_FOUND (Bug 227375)

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::PostCommitAllSnapshots" );
		
	// On each involved provider, call PostCommitSnapshots for all committed snapshots.
	for(int nIndex = 0; nIndex < m_mapProviderItfInSnapSet.GetSize(); nIndex++ )
	{
		CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.GetValueAt(nIndex);
        ft.hr = pProviderItf->PostCommitSnapshots( CVssGlobalSnapshotSetId::GetID(), m_lSnapshotsCount );
        if ( ft.hr == VSS_E_OBJECT_NOT_FOUND )
    		ft.Throw(VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, 
    		    L"'Object not found' detected in provider call. Provider ID = " WSTR_GUID_FMT, 
    		    GUID_PRINTF_ARG(m_mapProviderItfInSnapSet.GetKeyAt(nIndex)));
		else if ( ft.HrFailed() )
			ft.TranslateProviderError( VSSDBG_COORD, m_mapProviderItfInSnapSet.GetKeyAt(nIndex),
			    L"PostCommitSnapshots("WSTR_GUID_FMT L", %ld)",
			    GUID_PRINTF_ARG(CVssGlobalSnapshotSetId::GetID()), m_lSnapshotsCount);

		// Test if an Cancel occured
		TestIfCancelNeeded(ft);
    }
}


void CVssSnapshotSetObject::AbortAllSnapshots()
/*++

Routine description:

    Call AbortSnapshots for each provider involved in the snapshot set.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::AbortAllSnapshots" );

    try
    {
	    for(int nIndex = 0; nIndex < m_mapProviderItfInSnapSet.GetSize(); nIndex++ )
	    {
		    CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.GetValueAt(nIndex);

		    ft.hr = pProviderItf->AbortSnapshots(CVssGlobalSnapshotSetId::GetID());
		    if (ft.HrFailed())
			    ft.Trace( VSSDBG_COORD, L"AbortSnapshots failed at one writer. hr = 0x%08lx", ft.hr);
	    }
    }
    VSS_STANDARD_CATCH(ft)
}


void CVssSnapshotSetObject::TestIfCancelNeeded(
	IN	CVssFunctionTracer& ft
    ) throw(HRESULT)
{
	if (m_bCancel)
        ft.Throw( VSSDBG_COORD, VSS_S_ASYNC_CANCELLED, L"Cancel detected.");
}


void CVssSnapshotSetObject::OnDeactivate() throw(HRESULT)

/*++

Routine Description:

	Called by CVssProviderManager::Deactivate in order to remove the state of the object.

Warning:

    - The local cache interfaces are not released since are needed in the auto-delete case
    - The Reset function may throw...

Thrown errors:

    E_OUTOFMEMORY.

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::OnDeactivate" );

	// Remove state from the coordinator interface
    // This will release the interfaces also but not completely
    // since a copy is stored in the local cache.
	m_mapProviderItfInSnapSet.RemoveAll();

    // Remove all volumes from the snapshot set.
    m_VolumesList.Reset();

    m_lSnapshotsCount = 0;

   	CVssGlobalSnapshotSetId::ResetID();
	
    m_eCoordState = VSSC_Initialized;
}


void CVssSnapshotSetObject::GetSupportedProviderId(
	IN	LPWSTR wszVolumeName,
    OUT VSS_ID* pProviderId
	) throw(HRESULT)

/*++

Routine Description:

	Called by CVssSnapshotSetObject::AddToSnapshotSet in order to establish the provider
    that will be used for snapshotting this volume

Algorithm:

    for $ProvType in the following order (Hardware, Software, System)
        for $Provider in all providers of type $ProvType
            if ($Provider supports Volume) then
                return the ID of $Provider
    return VSS_E_VOLUME_NOT_SUPPORTED

Remarks:

    We impose no rule for choosing between providers of the same type. The mechanishm of
    choosing is intentionally arbitrarily.

Arguments:
    wszVolumeName - expected to be in the \\\\\?\\Volume{00000000-0000-0000-0000-000000000000}\\ format.

Return values:

    None.

Throws:

    E_OUTOFMEMORY
    E_INVALIDARG
        - if the volume is not in the correct format.
    VSS_E_VOLUME_NOT_SUPPORTED
        - If the given volume is not supported by any provider

    [QueryProvidersIntoArray() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.

            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

        [InitializeAsProvider() failures]
            E_OUTOFMEMORY

        [IVssSnapshotProvider::IsVolumeSupported() failures]
            E_INVALIDARG
                NULL pointers passed as parameters or a volume name in an invalid format.
            E_OUTOFMEMORY
                Out of memory or other system resources
            VSS_E_PROVIDER_VETO
                An error occured while opening the IOCTL channel. The error is logged.
            VSS_E_OBJECT_NOT_FOUND
                If the volume name does not correspond to an existing mount point

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::GetSupportedProviderId" );

    VSS_ID VolumeId;

    // Assert parameters
    BS_ASSERT(pProviderId);
    BS_ASSERT(*pProviderId == GUID_NULL);
    BS_ASSERT(wszVolumeName);

    // Get the volume GUID
    if (!::GetVolumeGuid(wszVolumeName, VolumeId)) {
        // We assert since the check was already done
        BS_ASSERT(false);
        ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"Cannot convert volume name %s to a GUID", wszVolumeName);
    }

    //
    // Get all providers that supports this volume into an array
    //

    // Create the collection object. Initial reference count is 0.
    VSS_OBJECT_PROP_Array* pFilteredProvidersArray = new VSS_OBJECT_PROP_Array;
    if (pFilteredProvidersArray == NULL)
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

    // Get the pointer to the IUnknown interface.
	// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
	// Now pFilteredProvidersArray's reference count becomes 1 (because of the smart pointer).
    CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pFilteredProvidersArray);
    BS_ASSERT(pArrayItf);

    // Insert property structures into the array.
    // Only providers that supports tha volume will be chosen.
	CVssProviderManager::QuerySupportedProvidersIntoArray(
	    false, wszVolumeName, pFilteredProvidersArray );

    //
    //  Search a provider that supports that volume (i.e. from the above list),
    //  in the correct priority order.
    //

    // For each provider type, in the correct priority order
    bool bFound = false;
    for(int nPriority = 0; !bFound && arrProviderTypesOrder[nPriority] ; nPriority++) {

        // Get the current provider type
        VSS_PROVIDER_TYPE nCurrentType = arrProviderTypesOrder[nPriority];

        // For all providers of that type search one that supports the volume
        for(int nIndex = 0; !bFound && (nIndex < pFilteredProvidersArray->GetSize()); nIndex++) {

	        // Get the structure object from the array
	        VSS_OBJECT_PROP_Ptr& ptrProperties = (*pFilteredProvidersArray)[nIndex];

	        // Get the provider structure
            BS_ASSERT(ptrProperties.GetStruct());
	        BS_ASSERT(ptrProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);
	        VSS_PROVIDER_PROP& ProviderProp = ptrProperties.GetStruct()->Obj.Prov;

            // Skip providers with the wrong type
            if (ProviderProp.m_eProviderType != nCurrentType)
                continue;

            // We found a good provider
            (*pProviderId) = ProviderProp.m_ProviderId;
            bFound = true;
        }
    }

    if (!bFound) {
        BS_ASSERT(false); // The "Volume not supported should be detected already by the IsVolumeSupported() call in coord.cxx
        ft.Throw(VSSDBG_COORD, VSS_E_VOLUME_NOT_SUPPORTED, L"Volume %s not supported by any provider", wszVolumeName);
    }
}


/////////////////////////////////////////////////////////////////////////////
// Life-management related methods


STDMETHODIMP CVssSnapshotSetObject::QueryInterface(
	IN	REFIID iid,
	OUT	void** pp
	)
{
    if (pp == NULL)
        return E_INVALIDARG;
    if (iid != IID_IUnknown)
        return E_NOINTERFACE;

    AddRef();
    IUnknown** pUnk = reinterpret_cast<IUnknown**>(pp);
    (*pUnk) = static_cast<IUnknown*>(this);
	return S_OK;
}


ULONG CVssSnapshotSetObject::AddRef()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::AddRef");
	
    return ::InterlockedIncrement(&m_lRef);
}


ULONG CVssSnapshotSetObject::Release()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::Release");
	
    LONG l = ::InterlockedDecrement(&m_lRef);
    if (l == 0)
        delete this; // We suppose that we always allocate this object on the heap!
    return l;
}


CVssSnapshotSetObject* CVssSnapshotSetObject::CreateInstance() throw(HRESULT)
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::CreateInstance");
	
	CVssSnapshotSetObject* pObj = new CVssSnapshotSetObject;
	if (pObj == NULL)
		ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

	if (FAILED(pObj->FinalConstructInternal()))
		ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Error initializing the object");

	return pObj;
}


HRESULT CVssSnapshotSetObject::FinalConstructInternal()
{
	return S_OK;
}


CVssSnapshotSetObject::CVssSnapshotSetObject():
	m_bCancel(false),
	m_lSnapshotsCount(0),
    m_eCoordState(VSSC_Initialized),
	m_bHasAcquiredSem(false),
	m_lRef(0)
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::CVssSnapshotSetObject");
}


CVssSnapshotSetObject::~CVssSnapshotSetObject()
{
	CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSnapshotSetObject::~CVssSnapshotSetObject");

	try
	{
    	// Release aborts all prepared snapshots
    	Deactivate();

	}
	VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed())
	    ft.Trace( VSSDBG_COORD, L"Exception catched 0x%08lx", ft.hr);

	if (m_bHasAcquiredSem)
		InterlockedCompareExchange(&g_hSemSnapshotSets, 0, 1);

}


/////////////////////////////////////////////////////////////////////////////
//  CVssGlobalSnapshotSetId


//  Static data members
//

// Global snapshot set Id
VSS_ID CVssGlobalSnapshotSetId::m_SnapshotSetID = GUID_NULL;

// Global lock
CVssCriticalSection  CVssGlobalSnapshotSetId::m_cs;


//  Implementation
//

// Get the current Snasphot set ID
VSS_ID CVssGlobalSnapshotSetId::GetID() throw(HRESULT)
{
    // (Simplify tracing: do not declare a function tracer)
    
    // Acquire the critical section. This may throw.
    CVssAutomaticLock2 lock(m_cs);

    return m_SnapshotSetID;
}


// Allocate a new Snapshot Set ID
VSS_ID CVssGlobalSnapshotSetId::NewID() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssGlobalSnapshotSetId::NewID" );

    try
    {
        // Acquire the critical section. This may throw.
        CVssAutomaticLock2 lock(m_cs);

        // Create the new Snapshot Set ID
        BS_ASSERT(m_SnapshotSetID == GUID_NULL);
        ft.hr = ::CoCreateGuid( &m_SnapshotSetID );
        if ( ft.HrFailed() )
            ft.TranslateGenericError(VSSDBG_COORD, ft.hr, L"CoCreateGuid" );

        // Broadcast the new snapshot set ID. This may throw.
    	CVssSnasphotSetIdObserver::BroadcastSSID(m_SnapshotSetID);
    }
    VSS_STANDARD_CATCH(ft)

    // Re-throw error, if needed
    if (ft.HrFailed()) {
        m_SnapshotSetID = GUID_NULL;
        ft.Throw( VSSDBG_COORD, ft.hr, L"Re-throw error 0x%08lx", ft.hr);
    }

    // Return the created SSID
    return m_SnapshotSetID;
}


// Clear the current snapshot Set ID
void CVssGlobalSnapshotSetId::ResetID() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssGlobalSnapshotSetId::ResetID" );
    
    // Acquire the critical section. This may throw.
    CVssAutomaticLock2 lock(m_cs);

    // Set the new Snapshot Set ID
    m_SnapshotSetID = GUID_NULL;
}


// Record the current SSID in the given observer
void CVssGlobalSnapshotSetId::InitializeObserver(
    IN CVssSnasphotSetIdObserver* pObserver
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssGlobalSnapshotSetId::InitializeObserver" );
    
    // Acquire the critical section. This may throw.
    CVssAutomaticLock2 lock(m_cs);

    // Record the current Snapshot Set ID. This may throw.
    if (m_SnapshotSetID != GUID_NULL) 
        pObserver->RecordSSID(m_SnapshotSetID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\event\src\impl.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module EventMonImpl.cpp : Implementation of CVssEventClassImpl

    @end

Author:

    Adi Oltean  [aoltean]  08/14/1999

Revision History:

    Name        Date        Comments
    aoltean     08/14/1999  Created

--*/


#include "stdafx.h"
#include "vsevent.h"
#include "Impl.h"

/////////////////////////////////////////////////////////////////////////////
// CVssEventClassImpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\event\src\eventcls.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module EventCls.cpp : Implementation of DLL Exports.

    @end

Author:

    Adi Oltean  [aoltean]  08/14/1999

Revision History:

    Name        Date        Comments
    aoltean     08/14/1999  Created
    aoltean     09/09/1999  Adding copyright

--*/


#include "stdafx.h"
#include "vssmsg.h"
#include "resource.h"
#include <initguid.h>

#include "vs_inc.hxx"

#include "vsevent.h"
#include "Impl.h"

#include <comadmin.h>
#include "comadmin.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "EVTEVTCC"
//
////////////////////////////////////////////////////////////////////////

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_VssEvent, CVssEventClassImpl)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// Constants



const WCHAR g_wszPublisherAppName[]     = L"Volume Shadow Copy Service";   // Publisher Application Name
const WCHAR g_wszEventClassDllName[]    = L"\\EVENTCLS.DLL";
const WCHAR g_wszEventClassProgID[]     = L"VssEvent.VssEvent.1";
const WCHAR g_wszPublisherID[]          = L"VSS Publisher";             // Publisher ID


///////////////////////////////////////////////////////////////////////////////////////
//  COM Server registration
//

HRESULT GetECDllPathName(
	IN	INT nBufferLength, // Does not include terminating zero character
    OUT   WCHAR* wszFileName
    )
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"GetECDllPathName" );

    try
    {
		WCHAR wszPath[MAX_PATH];
        if (!::GetCurrentDirectory(MAX_PATH, wszPath)) {
            ft.LogError(VSS_ERROR_GETTING_CURRENT_DIR, VSSDBG_COORD << HRESULT_FROM_WIN32(GetLastError()) );
            ft.Throw(VSSDBG_COORD, E_UNEXPECTED,
				L"Error on getting the current path. hr = 0x%08lx",
                HRESULT_FROM_WIN32(GetLastError()));
        }

        if ( ::wcslen(wszPath) +
			 ::wcslen(g_wszEventClassDllName) >= (size_t) nBufferLength )
            ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Out of memory.");

        ::_snwprintf(wszFileName, nBufferLength,
				L"%s%s", wszPath, g_wszEventClassDllName);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}

HRESULT RegisterEventClass()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"RegisterEventClass" );

    try
		{
		// create event system
		CComPtr<IEventSystem> pSystem;

		ft.hr = CoCreateInstance
				(
				CLSID_CEventSystem,
				NULL,
				CLSCTX_SERVER,
				IID_IEventSystem,
				(void **) &pSystem
				);

		ft.CheckForError(VSSDBG_WRITER, L"CoCreateInstance");
		CComBSTR bstrClassId = CLSID_VssEvent;

		CComBSTR bstrQuery = "EventClassID == ";
		if (!bstrQuery)
			ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Cannot allocate BSTR.");

		bstrQuery.Append(bstrClassId);
		if (!bstrQuery)
			ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Cannot allocate BSTR.");

		int location;

		// remove event class if it already exists
		ft.hr = pSystem->Remove
				(
				PROGID_EventClassCollection,
				bstrQuery,
				&location
				);

		ft.CheckForError(VSSDBG_WRITER, L"IEventSystem::Remove");

		CComPtr<IEventClass> pEvent;

		CComBSTR bstrEventClassName = L"VssEvent";
		WCHAR buf[MAX_PATH*2 + 1];
		GetECDllPathName(MAX_PATH * 2, buf);

		CComBSTR bstrTypelib = buf;

		// create event class
		// note we will have to do something else to enable parallel firing
		ft.hr = CoCreateInstance
				(
				CLSID_CEventClass,
				NULL,
				CLSCTX_SERVER,
				IID_IEventClass,
				(void **) &pEvent
				);

		ft.CheckForError(VSSDBG_WRITER, L"CoCreatInstance");
		ft.hr = pEvent->put_EventClassID(bstrClassId);
		ft.CheckForError(VSSDBG_WRITER, L"IEventClass::put_EventClassID");
		ft.hr = pEvent->put_EventClassName(bstrEventClassName);
		ft.CheckForError(VSSDBG_WRITER, L"IEventClass::put_EventClassName");
		ft.hr = pEvent->put_TypeLib(bstrTypelib);
		ft.CheckForError(VSSDBG_WRITER, L"IEventClass::put_TypeLib");
		ft.hr = pSystem->Store(PROGID_EventClass, pEvent);
		ft.CheckForError(VSSDBG_WRITER, L"IEventSystem::Store");
		}
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}



///////////////////////////////////////////////////////////////////////////////
//   DLL Entry point
//

//
// The real DLL Entry Point is _DLLMainCrtStartup (initializes global objects and after that calls DllMain
// this is defined in the runtime libaray
//

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        //  Set the correct tracing context. This is an inproc DLL
        g_cDbgTrace.SetContextNum(VSS_CONTEXT_DELAYED_DLL);

        // Set the proper way for displaying asserts
        ::VssSetDebugReport(VSS_DBG_TO_DEBUG_CONSOLE);

        //  initialize COM module
        _Module.Init(ObjectMap, hInstance);

        //  optimization
        DisableThreadLibraryCalls(hInstance);

        // TODO discussion about the logger file in this DLL!
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
//   DLL Exports
//


// Used to determine whether the DLL can be unloaded by OLE
STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


// Returns a class factory to create an object of the requested type
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}


// DllRegisterServer - Adds entries to the system registry
STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}


// DllInstall - install the event class into the COM+ catalog.
STDAPI DllInstall(	
	IN	BOOL bInstall,
	IN	LPCWSTR /* pszCmdLine */
)
{
	HRESULT hr = S_OK;

	// Registers the COM+ application
	// This will implicitely call DllRegisterServer
	if (bInstall)
		hr = RegisterEventClass();

	return hr;
}


// DllUnregisterServer - Removes entries from the system registry
STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\coord\src\vssqlwrt.cpp ===
/*++
Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module VsSqlWr.cpp | Implementation of Sql Writer wrapper class used by the coordinator
    @end

Author:

    Brian Berkowitz  [brianb]  04/18/2000

TBD:
	
	Add comments.

Revision History:

	
    Name        Date        Comments
    brianb     04/18/2000   Created
	brianb	   04/20/2000   integrated with coordinator
	brianb	   05/10/2000   make sure registration thread does CoUninitialize

--*/
#include <stdafx.hxx>
#include "vs_inc.hxx"
#include "vs_idl.hxx"


#include <vswriter.h>
#include <sqlsnap.h>
#include <sqlwriter.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSQLWC"
//
////////////////////////////////////////////////////////////////////////


__declspec(dllexport)
CVssSqlWriterWrapper::CVssSqlWriterWrapper() :
	m_pSqlWriter(NULL)
	{
	}

DWORD CVssSqlWriterWrapper::InitializeThreadFunc(VOID *pv)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssSqlWriterWrapper::InitializeThreadFunc");

	CVssSqlWriterWrapper *pWrapper = (CVssSqlWriterWrapper *) pv;

	BOOL fCoinitializeSucceeded = false;

	try
		{
		// intialize MTA thread
		ft.hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
		if (ft.HrFailed())
			ft.Throw
				(
				VSSDBG_GEN,
				E_UNEXPECTED,
				L"CoInitializeEx failed 0x%08lx", ft.hr
				);

        fCoinitializeSucceeded = true;

		ft.hr = pWrapper->m_pSqlWriter->Initialize();
		}
	VSS_STANDARD_CATCH(ft)

	if (fCoinitializeSucceeded)
		CoUninitialize();

	pWrapper->m_hrInitialize = ft.hr;
	return 0;
	}



__declspec(dllexport)
HRESULT CVssSqlWriterWrapper::CreateSqlWriter()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssSqlWriterWrapper::CreateSqlWriter");

	if (m_pSqlWriter)
		return S_OK;

	try
		{
		m_pSqlWriter = new CSqlWriter;
		if (m_pSqlWriter == NULL)
			ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Allocation of CSqlWriter object failed.");

		DWORD tid;

		HANDLE hThread = CreateThread
							(
							NULL,
							256* 1024,
							CVssSqlWriterWrapper::InitializeThreadFunc,
							this,
							0,
							&tid
							);

		if (hThread == NULL)
			ft.Throw
				(
				VSSDBG_GEN,
				E_UNEXPECTED,
				L"CreateThread failed with error %d",
				GetLastError()
				);

		// wait for thread to complete
        WaitForSingleObject(hThread, INFINITE);
		CloseHandle(hThread);
		ft.hr = m_hrInitialize;
		}
	VSS_STANDARD_CATCH(ft)
	if (ft.HrFailed() && m_pSqlWriter)
		{
		delete m_pSqlWriter;
		m_pSqlWriter = NULL;
		}

	return ft.hr;
	}

__declspec(dllexport)
void CVssSqlWriterWrapper::DestroySqlWriter()
	{
	if (m_pSqlWriter)
		{
		m_pSqlWriter->Uninitialize();
		delete m_pSqlWriter;
		m_pSqlWriter = NULL;
		}
	}


__declspec(dllexport)
CVssSqlWriterWrapper::~CVssSqlWriterWrapper()
	{
	DestroySqlWriter();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\coord\src\svc.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    svc.cxx

Abstract:

    Implements the Volume Snapshot Service.

Author:

    Adi Oltean  [aoltean]   06/30/1999

Revision History:

    Name        Date        Comments

    aoltean     06/30/1999  Created.
    aoltean     07/23/1999  Making registration code more error-prone.
                            Changing the service name.
    aoltean     08/11/1999  Initializing m_bBreakFlagInternal
    aoltean     09/09/1999  dss -> vss
	aoltean		09/21/1999  Adding a new header for the "ptr" class.
	aoltean		09/27/1999	Adding some headers
	aoltean		03/10/2000	Simplifying Setup
	brianb		04/19/2000  Add Sql Writer
	brianb		05/03/2000	Start sql writer before registering COM stuff
	brianb		05/05/2000	fix sql writer startup

--*/


////////////////////////////////////////////////////////////////////////
//  Includes

#include "StdAfx.hxx"
#include <comadmin.h>
#include "resource.h"
#include "vssmsg.h"

// General utilities
#include "vs_inc.hxx"

#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "provmgr.hxx"
#include "admin.hxx"
#include "worker.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"
#include "snap_set.hxx"
#include "shim.hxx"
#include "coord.hxx"

#include "comadmin.hxx"

#include "vswriter.h"
#include "vsbackup.h"
#include "sqlsnap.h"
#include "sqlwriter.h"
#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSVCC"
//
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
//  Constants

// 15 minutes of idle activity until shutdown. 
// The time is expressed number of 100 nanosecond intervals.
const LONGLONG  llVSSVCIdleTimeout = (LONGLONG)(-15) * 60 * 1000 * 1000 * 10;

// Immediate shutdown. 
const LONGLONG  llVSSVCShutdownTimeout = (LONGLONG)(-1);


////////////////////////////////////////////////////////////////////////
//  ATL Stuff


CVsServiceModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_VSSCoordinator, CVssCoordinator)
END_OBJECT_MAP()

// sql server (MSDE) Writer wrapper.  Included in coordinator because
// it needs admin privileges
CVssSqlWriterWrapper g_SqlWrapper;

//
//  Store away the thread id of the thread executing the ServiceMain() method.
//  Used to syncronize the ending of the main thread.
//
static DWORD g_dwServiceMainThreadId = 0;

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//  CVsServiceModule implementation


CVsServiceModule::CVsServiceModule()

/*++

Routine Description:

    Default constructor. Initialize ALL members with predefined values.

--*/

{
	::VssZeroOut(&m_status);
	m_hInstance = NULL;
	m_hServiceStatus = NULL;
	m_dwThreadID = 0;
	m_hShutdownTimer = NULL;
	m_bShutdownInProgress = false;
	m_hSubscriptionsInitializeEvent = NULL;
	m_bCOMStarted = false;
    m_pvFuncSimulateSnapshotFreezeInternal = NULL;
    m_pvFuncSimulateSnapshotThawInternal = NULL;
    
	// Initialize the members of the SERVICE_STATUS that don't change
	m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwControlsAccepted =
		SERVICE_ACCEPT_STOP |
		SERVICE_ACCEPT_SHUTDOWN;
}


///////////////////////////////////////////////////////////////////////////////////////
// Service control routines (i.e. ServiceMain-related methods)
//


void CVsServiceModule::StartDispatcher()

/*++

Routine Description:

    Called in the main execution path.
	Will register the _ServiceMain function.

Called by:

	CVsServiceModule::_WinMain

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::StartDispatcher");

    try
    {
		SERVICE_TABLE_ENTRYW st[] =
		{
			{ const_cast<LPWSTR>(wszServiceName), _ServiceMain },
			{ NULL, NULL }
		};

		// Register the dispatcher main function into the Service Control Manager
		// This call blocks until ServiceMain tells SCM the service status is stopped
		if ( !::StartServiceCtrlDispatcherW(st) ) {
		    ft.LogError(VSS_ERROR_STARTING_SERVICE_CTRL_DISPATCHER, VSSDBG_COORD << HRESULT_FROM_WIN32(GetLastError()) );
			ft.Throw( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
					  L"StartServiceCtrlDispatcherW failed. 0x%08lx", GetLastError() );
	    }

        //  If the ServiceMain thread is still running, wait for it to finish.
        if ( g_dwServiceMainThreadId != 0 )
        {
            HANDLE hServiceMainThread;

            hServiceMainThread = ::OpenThread( SYNCHRONIZE, FALSE, g_dwServiceMainThreadId );
            if ( hServiceMainThread != NULL )
            {
                ft.Trace( VSSDBG_COORD, L"CVsServiceModule::StartDispatcher: Waiting for ServiceMain thread to finish..." );
                //  Wait up to 10 seconds
                if ( ::WaitForSingleObject( hServiceMainThread, 10000 ) == WAIT_TIMEOUT )
                {
                    ft.Trace( VSSDBG_COORD, L"CVsServiceModule::StartDispatcher: Wait timed out, ending anyway" );
                }
                ::CloseHandle( hServiceMainThread );
            }
        }
    }
    VSS_STANDARD_CATCH(ft)

	m_status.dwWin32ExitCode = ft.hr;
}


void WINAPI CVsServiceModule::_ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
    _Module.ServiceMain(dwArgc, lpszArgv);
}


void CVsServiceModule::ServiceMain(
    IN	DWORD	/* dwArgc */,
    IN	LPTSTR* /* lpszArgv */
    )

/*++

Routine Description:

	The main service control dispatcher.

Called by:

    Called by the NT Service framework following
	the StartServiceCtrlDispatcherW which was called in CVsServiceModule::StartDispatcher

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::ServiceMain");

    try
    {
        // Store away this thread id for use by the main thread.
        g_dwServiceMainThreadId = ::GetCurrentThreadId();
        
		// Needed for SERVICE_CONTROL_INTERROGATE that may come between the next two calls
		m_status.dwCurrentState = SERVICE_START_PENDING;

        // Register the control request handler
        m_hServiceStatus = ::RegisterServiceCtrlHandlerW(wszServiceName, _Handler);
        if ( m_hServiceStatus == NULL ) {
		    ft.LogError(VSS_ERROR_STARTING_SERVICE_REG_CTRL_HANDLER, VSSDBG_COORD << HRESULT_FROM_WIN32(GetLastError()) );
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"RegisterServiceCtrlHandler failed. 0x%08lx", GetLastError() );
        }

		// Now we will really inform the SCM that the service is pending its start.
        SetServiceStatus(SERVICE_START_PENDING);

		// Internal initialization
		OnInitializing();

		// The service is started now.
		SetServiceStatus(SERVICE_RUNNING);

		// Wait for shutdown attempt
		OnRunning();

		// Shutdown was started either by receiving the SERVICE_CONTROL_STOP
		// or SERVICE_CONTROL_SHUTDOWN events either because the COM objects number is zero.
		SetServiceStatus(SERVICE_STOP_PENDING);

		// Perform the un-initialization tasks
		OnStopping();

		// The service is stopped now.
        SetServiceStatus(SERVICE_STOPPED);
    }
    VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed()) {

		// Present the error codes to the caller.
		m_status.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
		m_status.dwServiceSpecificExitCode = ft.hr;

		// Perform the un-initialization tasks
		OnStopping();

		// The service is stopped now.
        SetServiceStatus(SERVICE_STOPPED, false);
	}
}


void WINAPI CVsServiceModule::_Handler(DWORD dwOpcode)
{
    _Module.Handler(dwOpcode);
}


void CVsServiceModule::Handler(
    DWORD dwOpcode
    )

/*++

Routine Description:

    Used by Service Control Manager to inform this service about the service-related events

Called by:

	Service Control Manager.

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::Handler");

    try
    {
		// re-initialize "volatile" members
		m_status.dwCheckPoint = 0;
		m_status.dwWaitHint = 0;
		m_status.dwWin32ExitCode = 0;
        m_status.dwServiceSpecificExitCode = 0;

		switch (dwOpcode)
		{
		case SERVICE_CONTROL_INTERROGATE:
			// Present the previous state.
			SetServiceStatus(m_status.dwCurrentState);
			break;

		case SERVICE_CONTROL_STOP:
		case SERVICE_CONTROL_SHUTDOWN:
			SetServiceStatus(SERVICE_STOP_PENDING);
			OnSignalShutdown();
			// The SERVICE_STOPPED status must be communicated
			// in Service's main function.
			break;

		default:
			BS_ASSERT(false);
			ft.Trace( VSSDBG_COORD, L"Bad service request 0x%08lx", dwOpcode );
		}
	}
    VSS_STANDARD_CATCH(ft)
}


void CVsServiceModule::SetServiceStatus(
		IN	DWORD dwState,
		IN	bool bThrowOnError /* = true */
		)

/*++

Routine Description:

    Informs the Service Control Manager about the new status.

Called by:

	CVsServiceModule methods

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::SetServiceStatus");

	try
	{
		ft.Trace( VSSDBG_COORD, L"Attempt to change the service status to %lu", dwState);

		BS_ASSERT(m_hServiceStatus != NULL);

		// Inform SCM about the new status
		m_status.dwCurrentState = dwState;
		if ( !::SetServiceStatus(m_hServiceStatus, &m_status) ) {
		    ft.LogError(VSS_ERROR_SET_SERVICE_STATUS, VSSDBG_COORD << (INT)dwState << HRESULT_FROM_WIN32(GetLastError()) );
			ft.Throw( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
						L"Error on calling SetServiceStatus. 0x%08lx", GetLastError() );
		}
	}
	VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed())
		ft.ThrowIf( bThrowOnError, VSSDBG_COORD, ft.hr,
					L"Error on calling SetServiceStatus. 0x%08lx", ft.hr );
}


void CVsServiceModule::WaitForSubscribingCompletion() throw(HRESULT)

/*++

Routine Description:

    Wait until all subscriptions are performed

Called by:

	CVsServiceModule::ServiceMain

Throws:

    E_UNEXPECTED
        - WaitForSingleObject failures

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::WaitForSubscribingCompletion" );

	// Wait for shutdown
	DWORD dwRet = WaitForSingleObject(
		m_hSubscriptionsInitializeEvent,    // IN HANDLE hHandle,
		INFINITE                            // IN DWORD dwMilliseconds
		);
	if( dwRet != WAIT_OBJECT_0 )
	    ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()), 
	        L"WaitForSingleObject(%p,INFINITE) != WAIT_OBJECT_0", m_hSubscriptionsInitializeEvent);
}


/*++

Routine Description:

    Gets the simulate snapshot function pointers.

Called by:

	CVsServiceModule::ServiceMain

Throws:

    E_UNEXPECTED
        - WaitForSingleObject failures

--*/
void CVsServiceModule::GetSimulateFunctions( 
        OUT PFunc_SimulateSnapshotFreezeInternal *ppvSimulateFreeze, 
        OUT PFunc_SimulateSnapshotThawInternal *ppvSimulateThaw )
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::GetSimulateFunctions" );
    //
    //  Must wait for the shim to finish subscribing before accessing the
    //  internal freeze and thaw functions; otherwise the two m_pvFuncXXXX
    //  vars will be NULL.
    //
	WaitForSubscribingCompletion();        
    if ( ppvSimulateFreeze != NULL )
        *ppvSimulateFreeze = m_pvFuncSimulateSnapshotFreezeInternal;
    if ( ppvSimulateThaw != NULL )
        *ppvSimulateThaw = m_pvFuncSimulateSnapshotThawInternal;
};



///////////////////////////////////////////////////////////////////////////////////////
// Service initialization, running and finalization routines
//


void CVsServiceModule::OnInitializing()

/*++

Routine Description:

    Initialize the service.

	If the m_status.dwWin32ExitCode is S_OK then initialization succeeded.
	Otherwise ServiceMain must silently shutdown the service.

Called by:

	CVsServiceModule::ServiceMain

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::OnInitializing" );

    m_dwThreadID = GetCurrentThreadId();

    // Initialize the COM library
    ft.hr = CoInitializeEx(
            NULL,
            COINIT_MULTITHREADED
            );
    if (ft.HrFailed()) {
	    ft.LogError(VSS_ERROR_STARTING_SERVICE_CO_INIT_FAILURE, VSSDBG_COORD << ft.hr );
        ft.Throw( VSSDBG_COORD, ft.hr, L" Error: CoInitialize(NULL) returned 0x%08lx", ft.hr );
    }

    BS_ASSERT( ft.hr == S_OK );

    m_bCOMStarted = true;

    // Initialize COM security
    ft.hr = CoInitializeSecurity(
           NULL,                                //  IN PSECURITY_DESCRIPTOR         pSecDesc,
           -1,                                  //  IN LONG                         cAuthSvc,
           NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
           NULL,                                //  IN void                        *pReserved1,
           RPC_C_AUTHN_LEVEL_CONNECT,           //  IN DWORD                        dwAuthnLevel,
           RPC_C_IMP_LEVEL_IMPERSONATE,         //  IN DWORD                        dwImpLevel,
           NULL,                                //  IN void                        *pAuthList,
           EOAC_NONE,                           //  IN DWORD                        dwCapabilities,
           NULL                                 //  IN void                        *pReserved3
           );
    if (ft.HrFailed()) {
	    ft.LogError(VSS_ERROR_STARTING_SERVICE_CO_INITSEC_FAILURE, VSSDBG_COORD << ft.hr );
        ft.Throw( VSSDBG_COORD, ft.hr,
                  L" Error: CoInitializeSecurity() returned 0x%08lx", ft.hr );
    }

	// Create the event needed to synchronize
	BS_ASSERT(m_hShutdownTimer == NULL);
	m_hShutdownTimer = CreateWaitableTimer(
		NULL,       //  IN LPSECURITY_ATTRIBUTES lpEventAttributes,
		TRUE,       //  IN BOOL bManualReset,
		NULL        //  IN LPCTSTR lpName
		);
	if ( m_hShutdownTimer == NULL ) {
	    if (GetLastError() != ERROR_OUTOFMEMORY)
    	    ft.LogError(VSS_ERROR_STARTING_SERVICE_UNEXPECTED_INIT_FAILURE, VSSDBG_COORD << HRESULT_FROM_WIN32(GetLastError()));
		ft.Throw( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
				  L"Error creating the shutdown timer 0x%08lx", GetLastError() );
    }

	// Create the event needed to synchronize
	BS_ASSERT(m_hSubscriptionsInitializeEvent == NULL);
	m_hSubscriptionsInitializeEvent = CreateEvent(
		NULL,       //  IN LPSECURITY_ATTRIBUTES lpEventAttributes,
		TRUE,       //  IN BOOL bManualReset,
		FALSE,      //  IN BOOL bInitialState,
		NULL        //  IN LPCTSTR lpName
		);
	if ( m_hSubscriptionsInitializeEvent == NULL ) {
	    if (GetLastError() != ERROR_OUTOFMEMORY)
    	    ft.LogError(VSS_ERROR_STARTING_SERVICE_UNEXPECTED_INIT_FAILURE, VSSDBG_COORD << HRESULT_FROM_WIN32(GetLastError()));
		ft.Throw( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
				  L"Error creating the subscriptions sync event 0x%08lx", GetLastError() );
    }

    //  Register the COM class objects
    ft.hr = RegisterClassObjects( CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER, REGCLS_MULTIPLEUSE );
    if (ft.HrFailed()) {
	    if (GetLastError() != ERROR_OUTOFMEMORY)
    	    ft.LogError(VSS_ERROR_STARTING_SERVICE_CLASS_REG, VSSDBG_COORD << ft.hr);
        ft.Throw( VSSDBG_COORD, ft.hr, L" Error: RegisterClassObjects() returned 0x%08lx", ft.hr );
    }
	
	// The service is started now to prevent the service startup from
	// timing out.  The COM registration is done after we fully complete
	// initialization
	SetServiceStatus(SERVICE_RUNNING);

	// startup sql writer if not already started.
	g_SqlWrapper.CreateSqlWriter();

	// register the shim snapshot writers
	RegisterSnapshotSubscriptions( &m_pvFuncSimulateSnapshotFreezeInternal, &m_pvFuncSimulateSnapshotThawInternal );

    // Mark that all the subscriptiuons are initialized
	if (!::SetEvent( m_hSubscriptionsInitializeEvent )) {
	    ft.LogError(VSS_ERROR_STARTING_SERVICE_UNEXPECTED_INIT_FAILURE, VSSDBG_COORD << HRESULT_FROM_WIN32(GetLastError()));
		ft.Throw( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
				L"Error on setting the sub sync event 0x%08lx", GetLastError());
	}
}



void CVsServiceModule::OnRunning()

/*++

Routine Description:

    Keeps the service alive until the job is done.

Called by:

	CVsServiceModule::ServiceMain

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::OnRunning" );

	// Wait for shutdown
	DWORD dwRet = WaitForSingleObject(
		m_hShutdownTimer,                   // IN HANDLE hHandle,
		INFINITE                            // IN DWORD dwMilliseconds
		);
	if( dwRet != WAIT_OBJECT_0 )
	    ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()), 
	        L"WaitForSingleObject(%p,INFINITE) != WAIT_OBJECT_0", m_hShutdownTimer);

    // Trace the fact that the service will be shutdown
	ft.Trace( VSSDBG_COORD, L"VSSVC: %s event received",
	    m_bShutdownInProgress? L"Shutdown": L"Idle timeout");
}


void CVsServiceModule::OnStopping()

/*++

Routine Description:

    Performs the uninitialization tasks.

Called by:

	CVsServiceModule::ServiceMain

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::OnStopping" );

    try
    {
        g_SqlWrapper.DestroySqlWriter();

        //  Unregister the COM classes
        ft.hr = RevokeClassObjects();
        if (ft.HrFailed())
            ft.Trace( VSSDBG_COORD, L" Error: RevokeClassObjects returned hr = 0x%08lx", ft.hr );

		// Remove the providers array
		CVssProviderManager::UnloadInternalProvidersArray();

		// Remove state from all stateful objects
		CVssProviderManager::DeactivateAll();

		UnregisterSnapshotSubscriptions();
        m_pvFuncSimulateSnapshotFreezeInternal = NULL;
        m_pvFuncSimulateSnapshotThawInternal = NULL;

        // Uninitialize the COM library
        if ( m_bCOMStarted )
            CoUninitialize();

        // Close the handles
		if ( !::CloseHandle( m_hShutdownTimer ) )
			ft.Trace( VSSDBG_COORD, L"Error closing the shutdown event 0x%08lx", GetLastError() );

		if ( !::CloseHandle( m_hSubscriptionsInitializeEvent ) )
			ft.Trace( VSSDBG_COORD, L"Error closing the sub sync event 0x%08lx", GetLastError() );
    }
    VSS_STANDARD_CATCH(ft)
}


void CVsServiceModule::OnSignalShutdown()

/*++

Routine Description:

    Called when the current service shoul