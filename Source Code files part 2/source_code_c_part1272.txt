;
	    }

	    //
	    // PREFIX: PREFIX complains that there is the possibility
	    // of pTHS->CurrSchemaPtr being NULL at this point.  However,
	    // the only time that CurrSchemaPtr could be NULL is at the
	    // system start up.  By the time that the RPC interfaces
	    // of the DS are enabled and this function could be called,
	    // CurrSchemaPtr will no longer be NULL.
	    //
	    Assert(NULL != pTHS->CurrSchemaPtr);

	    Assert(1 == dwInVersion);
	    LogAndTraceEvent(TRUE,
			     DS_EVENT_CAT_RPC_SERVER,
			     DS_EVENT_SEV_EXTENSIVE,
			     DIRLOG_IDL_DRS_GET_MEMBERSHIPS_ENTRY,
			     EVENT_TRACE_TYPE_START,
			     DsGuidDrsGetMemberships,
			     szInsertUL(pmsgIn->V1.cDsNames),
			     szInsertUL(pmsgIn->V1.OperationType),
			     pmsgIn->V1.pLimitingDomain
			     ? szInsertDN(pmsgIn->V1.pLimitingDomain)
			     : szInsertSz(""),
		szInsertUL(pmsgIn->V1.dwFlags),
		NULL, NULL, NULL, NULL);

	    if (!IsDraAccessGranted(pTHS,
				    gAnchor.pDomainDN,
				    &RIGHT_DS_REPL_GET_CHANGES, &ret)) {
		DRA_EXCEPT_NOLOG(ret, 0);
	    }

	    pTHS->fDSA = TRUE;
	    DBOpen2(TRUE, &pTHS->pDB);

	    __try
		{
		// Initialize the optional Attributes return Value, in case
		// they are not requested

		pmsgOut->V1.pAttributes = NULL;

		// Initialize the Sid History field for now, not to return
		// any Sid History
		pmsgOut->V1.cSidHistory = 0;
		pmsgOut->V1.ppSidHistory = NULL;

		if ((pmsgIn->V1.OperationType==RevMembGetUniversalGroups) &&
		    (!SampAmIGC()))
		    {

		    // univ group evaluation can be performed only on a GC
		    ret= ERROR_DS_GC_REQUIRED;
		    // set errCode to 0, will trigger failover
		    pmsgOut->V1.errCode = 0;
		    __leave;
		}

		INC( pcMemberEvalAsGC );

		// Obtain the reverse membership
		NtStatus = SampGetMemberships(
		    pmsgIn->V1.ppDsNames,
		    pmsgIn->V1.cDsNames,
		    pmsgIn->V1.pLimitingDomain,
		    pmsgIn->V1.OperationType,
		    &(pmsgOut->V1.cDsNames),
		    &(pmsgOut->V1.ppDsNames),
		    ((pmsgIn->V1.dwFlags) & DRS_REVMEMB_FLAG_GET_ATTRIBUTES)?
		    &(pmsgOut->V1.pAttributes):NULL,
		    &(pmsgOut->V1.cSidHistory),
		    &(pmsgOut->V1.ppSidHistory)
		);

		ret = NtStatusToDraError(NtStatus);
		pmsgOut->V1.errCode = NtStatus;


	    }
	    __finally
		{

		// End the transaction.  Faster to commit a read only
		// transaction than abort it - so set commit to TRUE.

		DBClose(pTHS->pDB, TRUE);
	    }

	}
	__except ( GetDraException( GetExceptionInformation(), &ret ) )
	{
	    ;
	}

	if (NULL != pTHS) {
	    LogAndTraceEvent(TRUE,
			     DS_EVENT_CAT_RPC_SERVER,
			     DS_EVENT_SEV_EXTENSIVE,
			     DIRLOG_IDL_DRS_GET_MEMBERSHIPS_EXIT,
			     EVENT_TRACE_TYPE_END,
			     DsGuidDrsGetMemberships,
			     szInsertUL(ret),
			     NULL, NULL, NULL, NULL,
			     NULL, NULL, NULL);
	}
    }
    __finally {
	drsDereferenceContext( rpc_handle, IDL_DRSGETMEMBERSHIPS );
    }
    return ret;
}
ULONG
IDL_DRSGetMemberships2(
   RPC_BINDING_HANDLE  rpc_handle,
   DWORD               dwInVersion,
   DRS_MSG_GETMEMBERSHIPS2_REQ *pmsgIn,
   DWORD               *pdwOutVersion,
   DRS_MSG_GETMEMBERSHIPS2_REPLY *pmsgOut
   )
/*++

    Routine Description:

        This Routine Evaluates the Transitive Reverse Membership on any given
        domain controller, including a G.C

    Parameters:

        rpc_handle    The Rpc Handle which the client used for binding
        dwInVersion   The Clients version of the Request packet
        psmgIn        The Request Packet
        pdwOutVersion The server's version of the Reply packet
        pmsgOut       The Reply Packet

    Return Values

        Return Values are NTSTATUS values casted as a ULONG

--*/
{
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    ULONG                   ret = 0;
    THSTATE                 *pTHS = NULL;
    ULONG i;

    drsReferenceContext( rpc_handle, IDL_DRSGETMEMBERSHIPS2 );
    __try {
	__try
	    {
	    // We currently support just one output message version.
	    *pdwOutVersion = 1;

	    // Discard request if we're not installed
	    if ( DsaIsInstalling() ) {
		DRA_EXCEPT_NOLOG (DRAERR_Busy, 0);
	    }

	    if (    ( NULL == pmsgIn )
		    || ( 1 != dwInVersion )
		    ) {
		DRA_EXCEPT_NOLOG( DRAERR_InvalidParameter, 0 );
	    }

	    // Initialize thread state and open data base.

	    if(!(pTHS = InitTHSTATE(CALLERTYPE_SAM))) {
		DRA_EXCEPT_NOLOG( DRAERR_OutOfMem, 0 );
	    }

	    //
	    // PREFIX: PREFIX complains that there is the possibility
	    // of pTHS->CurrSchemaPtr being NULL at this point.  However,
	    // the only time that CurrSchemaPtr could be NULL is at the
	    // system start up.  By the time that the RPC interfaces
	    // of the DS are enabled and this function could be called,
	    // CurrSchemaPtr will no longer be NULL.
	    //
	    Assert(NULL != pTHS->CurrSchemaPtr);

	    Assert(1 == dwInVersion);

	    LogAndTraceEvent(TRUE,
			     DS_EVENT_CAT_RPC_SERVER,
			     DS_EVENT_SEV_EXTENSIVE,
			     DIRLOG_IDL_DRS_GET_MEMBERSHIPS2_ENTRY,
			     EVENT_TRACE_TYPE_START,
			     DsGuidDrsGetMemberships2,
			     szInsertUL(pmsgIn->V1.Count),
			     NULL,NULL,NULL,NULL, NULL, NULL, NULL);

	    if (!IsDraAccessGranted(pTHS,
				    gAnchor.pDomainDN,
				    &RIGHT_DS_REPL_GET_CHANGES, &ret)) {
		DRA_EXCEPT_NOLOG(ret, 0);
	    }

	    pTHS->fDSA = TRUE;

	    //
	    // Allocate space for the return buffer
	    //
	    pmsgOut->V1.Count = pmsgIn->V1.Count;
	    pmsgOut->V1.Replies = THAllocEx(pTHS, pmsgIn->V1.Count * sizeof(DRS_MSG_REVMEMB_REPLY_V1));

	    // Initialize the optional Attributes return Value, in case
	    // they are not requested
	    for ( i = 0; i < pmsgIn->V1.Count; i++ ) {

		DBOpen2(TRUE, &pTHS->pDB);
		__try
		    {
		    pmsgOut->V1.Replies[i].pAttributes = NULL;

		    // Initialize the Sid History field for now, not to return
		    // any Sid History
		    pmsgOut->V1.Replies[i].cSidHistory = 0;
		    pmsgOut->V1.Replies[i].ppSidHistory = NULL;

		    INC( pcMemberEvalAsGC );

		    // Obtain the reverse membership
		    NtStatus = SampGetMemberships(
			pmsgIn->V1.Requests[i].ppDsNames,
			pmsgIn->V1.Requests[i].cDsNames,
			pmsgIn->V1.Requests[i].pLimitingDomain,
			pmsgIn->V1.Requests[i].OperationType,
			&(pmsgOut->V1.Replies[i].cDsNames),
			&(pmsgOut->V1.Replies[i].ppDsNames),
			((pmsgIn->V1.Requests[i].dwFlags) & DRS_REVMEMB_FLAG_GET_ATTRIBUTES)?
			&(pmsgOut->V1.Replies[i].pAttributes):NULL,
			&(pmsgOut->V1.Replies[i].cSidHistory),
			&(pmsgOut->V1.Replies[i].ppSidHistory)
		    );

		    ret = NtStatusToDraError(NtStatus);
		    pmsgOut->V1.Replies[i].errCode = NtStatus;
		}
		__finally
		    {

		    // End the transaction.  Faster to commit a read only
		    // transaction than abort it - so set commit to TRUE.

		    DBClose(pTHS->pDB, TRUE);
		}
	    }
	}
	__except ( GetDraException( GetExceptionInformation(), &ret ) )
	{
	    ;
	}

	if (NULL != pTHS) {
	    LogAndTraceEvent(TRUE,
			     DS_EVENT_CAT_RPC_SERVER,
			     DS_EVENT_SEV_EXTENSIVE,
			     DIRLOG_IDL_DRS_GET_MEMBERSHIPS2_EXIT,
			     EVENT_TRACE_TYPE_END,
			     DsGuidDrsGetMemberships2,
			     szInsertUL(ret),
			     NULL, NULL, NULL, NULL,
			     NULL, NULL, NULL);
	}
    }
    __finally {
	drsDereferenceContext( rpc_handle, IDL_DRSGETMEMBERSHIPS2 );
    }
    return ret; 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\spnop.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       spnop.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module contains the core internal helper routines which implement
    the SPN apis.

    This is called from the ntdsapi stub functions in dsamain\dra\ntdsapi.c

    Callers are expected to have a valid thread state

Author:

    Will Lees (wlees) 26-Jan-97

Revision History:

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <ntdsa.h>                      // Core data types
#include <scache.h>                     // Schema cache code
#include <dbglobal.h>                   // DBLayer header.
#include <mdglobal.h>                   // THSTATE definition
#include <mdlocal.h>                    // DSNAME manipulation routines
#include <dsatools.h>                   // Memory, etc.
#include <objids.h>                     // ATT_* definitions
#include <mdcodes.h>                    // Only needed for dsevent.h
#include <filtypes.h>                   // filter types
#include <dsevent.h>                    // Only needed for LogUnhandledError
#include <dsexcept.h>                   // exception handlers
#include <debug.h>                      // Assert()
#include <drs.h>                        // defines the drs wire interface
#include <drserr.h>                     // DRAERR_*
#include <drsuapi.h>                    // I_DRSCrackNames
#include <cracknam.h>                   // name cracking prototypes
#include <dominfo.h>                    // domain information prototypes
#include <anchor.h>                     // DSA_ANCHOR and gAnchor
#include <dsgetdc.h>                    // DsGetDcName
#include <lmcons.h>                     // MAPI constants req'd for lmapibuf.h
#include <lmapibuf.h>                   // NetApiBufferFree()

#define DEBSUB "DRASPN:"               // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_SPNOP

// Static

// Forward

DWORD
modifySpn(
    IN DSNAME *pDn,
    IN USHORT Choice,
    IN DWORD cSpn,
    LPCWSTR *pSpn
    );

DWORD
mapApiErrorToWin32(
    THSTATE *pTHS,
    DWORD ApiError
    );

// End Forward




DWORD
SpnOperation(
    IN DWORD Operation,
    IN DWORD Flags,
    IN LPCWSTR Account,
    IN DWORD cSpn,
    IN LPCWSTR *pSpn
    )

/*++

Routine Description:

This routine executes the core part of a SPN operation.  It is called from
dsamain\dra\ntdsapi.c.

There should already be a thread state.

We should also be impersonating the client.

If initial validations fail, we return without doing anything.  Otherwise, we use
DirModifyEntry and it does what it wants.  I suspect if any complete successfully, it will
return success.

IMPROVEMENT: return a status for each SPN to distinguish individual success/failures

Arguments:

    Operation - 
    Flags - 
    Account - 
    cSpn - 
    pSpn - 

Return Value:

    Win32 error
    We convert from other internal forms if necessary

--*/

{
    DWORD status, length, i;
    THSTATE *     pTHS = pTHStls;
    USHORT choice;
    DSNAME *pDn = NULL;
    DWORD l1, l2;
    LPWSTR *pList;
    DWORD ret;

    DPRINT5( 2, "SpnOperation, Op=%d, Flags=0x%x, Account=%ws, cSpn=%d, Spn[0]=%ws\n",
             Operation, Flags, Account, cSpn,
             pSpn ? pSpn[0] : L"NULL" );

    // Validation routine called by the core during the update

    // Construct a DSNAME for the AccountDn
    l1 = wcslen( Account );
    l2 = DSNameSizeFromLen( l1 );

    pDn = (DSNAME *) THAllocEx(pTHS, l2 ); // thread allocd
    ZeroMemory( pDn, l2 );
    pDn->NameLen = l1;
    pDn->structLen = l2;
    wcscpy( pDn->StringName, Account );

    // Select the appropriate type of modify operation
    switch (Operation) {
    case DS_SPN_ADD_SPN_OP:
        // Must be non-zero number of SPNs to add
        if ( (cSpn == 0) || (pSpn == NULL) ) {
            return ERROR_INVALID_PARAMETER;
        }
        // What if attribute doesn't exist?
        choice = AT_CHOICE_ADD_VALUES;
        break;
    case DS_SPN_REPLACE_SPN_OP:
        // Replacing with an empty list means remove the whole thing
        if ( (cSpn != 0) && (pSpn != NULL) ) {
            choice = AT_CHOICE_REPLACE_ATT;
        } else {
            choice = AT_CHOICE_REMOVE_ATT;
        }
        break;
    case DS_SPN_DELETE_SPN_OP:
        // Must be non-zero number of SPNs to delete
        if ( (cSpn == 0) || (pSpn == NULL) ) {
            return ERROR_INVALID_PARAMETER;
        }
        choice = AT_CHOICE_REMOVE_VALUES;
        break;
    default:
        return ERROR_INVALID_FUNCTION;
    }

    ret = modifySpn( pDn, choice, cSpn, pSpn );

    if(pDn != NULL) THFreeEx(pTHS, pDn);

    return ret;
} /* SpnOperation */


DWORD
modifySpn(
    IN DSNAME *pDn,
    IN USHORT Choice,
    IN DWORD cSpn,
    IN LPCWSTR *pSpn
    )

/*++

Routine Description:

Helper routine to form the DirModifyEntry call.  We issue one modification entry of
one attribute, with a varying number of values.

Arguments:

    pDn - DSNAME of object.  The object must have the ATT_SERVICE_PRINCIPAL_NAME attribute,
          currently a computer or user object.
    Choice - AT_CHOICE_xxx function for DirModifyEntry
    cSpn - Count of spns
    pSpn - Unicode string of spn values

Return Value:

    DWORD - 

--*/

{
    THSTATE *pTHS=pTHStls;
    DWORD apiError, status, i;
    MODIFYARG ModArg;
    MODIFYRES *pModRes = NULL;
    COMMARG *pCommArg = NULL;
    ATTR Attr;
    ATTRVALBLOCK AttrValBlock;
    ATTRVAL *pAttrVal = NULL;

    // Allocate array of values
    if (cSpn) {
        pAttrVal = (ATTRVAL *) THAllocEx(pTHS, cSpn * sizeof( ATTRVAL ) );
        // This will raise exception on error
    }

    // Construct arguments to DirModifyEntry call

    RtlZeroMemory(&ModArg, sizeof(ModArg));

    ModArg.pObject = pDn;
    ModArg.FirstMod.pNextMod = NULL;
    ModArg.FirstMod.choice = Choice;

    // Attribute value array contains list of values
    for( i = 0; i < cSpn; i++ ) {
        pAttrVal[i].valLen = wcslen( pSpn[i] ) * sizeof( WCHAR ); // no terminator!
        pAttrVal[i].pVal = (PUCHAR) pSpn[i];
    }

    AttrValBlock.valCount = cSpn;
    AttrValBlock.pAVal = pAttrVal;

    Attr.attrTyp = ATT_SERVICE_PRINCIPAL_NAME;
    Attr.AttrVal = AttrValBlock;

    ModArg.FirstMod.AttrInf = Attr;
    ModArg.count = 1;

    pCommArg = &(ModArg.CommArg);
    InitCommarg(pCommArg);

    // No errors if attribute not there to begin with on REPLACE w/cSpn == 0
    // No errors if attribure already exists on ADD
    pCommArg->Svccntl.fPermissiveModify = TRUE;

    apiError = DirModifyEntry(&ModArg, &pModRes);

    status = mapApiErrorToWin32( pTHS, apiError );

    THFree( pModRes );

    DPRINT2( 3, "DirModifyEntry, apiError = %d, status = %x\n", apiError, status );

    if ( (cSpn) && (pAttrVal) ) {
        THFree( pAttrVal );
    }

    return status;
} /* modifySpn */


DWORD
mapApiErrorToWin32(
    THSTATE *pTHS,
    DWORD ApiError
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status;

    if (ApiError == 0) {
        return ERROR_SUCCESS;
    }

    switch (ApiError) {
    case attributeError:
    {
        ATRERR *pAtrErr = (ATRERR *) pTHS->pErrInfo;

        if (pAtrErr) {
            status = pAtrErr->FirstProblem.intprob.extendedErr;
        } else {
            status = ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
        }
        break;
    }
    case nameError:
    {
        NAMERR *pNamErr = (NAMERR *) pTHS->pErrInfo;

        if (pNamErr) {
            status = pNamErr->extendedErr;
        } else {
            status = DS_ERR_BAD_NAME_SYNTAX;
        }
        break;
    }
    case referralError:
    {
        REFERR *pRefErr = (REFERR *) pTHS->pErrInfo;

        if (pRefErr) {
            status = pRefErr->extendedErr;
        } else {
            status = DS_ERR_REFERRAL;
        }
        break;
    }
    case securityError:
        if (pTHS->pErrInfo) {
            status = pTHS->pErrInfo->SecErr.extendedErr;
        } else {
            status = ERROR_ACCESS_DENIED;
        }
        break;
    case serviceError:
        if (pTHS->pErrInfo) {
            status = pTHS->pErrInfo->SvcErr.extendedErr;
            // Special case variants of object not found
            if (status == ERROR_DS_MISSING_SUPREF) {
                status = ERROR_DS_OBJ_NOT_FOUND;
            }
        } else {
            status = DS_ERR_UNKNOWN_ERROR;
        }
        break;
    case updError:
        if (pTHS->pErrInfo) {
            status = pTHS->pErrInfo->UpdErr.extendedErr;
        } else {
            status = DS_ERR_UNKNOWN_ERROR;
        }
        break;
    case systemError:
        if (pTHS->pErrInfo) {
            status = pTHS->pErrInfo->SysErr.extendedErr;
        } else {
            status = DS_ERR_UNKNOWN_ERROR;
        }
        break;
    default:
        Assert( FALSE && "unknown error class code" );
        status = DS_ERR_UNKNOWN_ERROR;
        break;
    }

    return status;
}
/* end of spnop.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\remove.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       remove.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module implements the drs interface routines for decommissioning
    servers and domains

Author:

    Colin Brace     (ColinBr)   02-Feb-98

Revision History:

    Colin Brace     (ColinBr)   02-Feb-98
        Created by adding DsRemoveDsServer, DsRemoveDsDomain

--*/

#include <NTDSpch.h>
#pragma hdrstop

// Core headers.
#include <ntdsa.h>                      // Core data types 
#include <scache.h>                     // Schema cache code
#include <dbglobal.h>                   // DBLayer header.
#include <mdglobal.h>                   // THSTATE definition
#include <mdlocal.h>                    // SPN
#include <debug.h>                      // Assert()
#include <dsatools.h>                   // Memory, etc.
#include <cracknam.h>                   // name cracking prototypes
#include <drs.h>                        // prototypes and CONTEXT_HANDLE_TYPE_*
#include <drautil.h>                    // DRS_CLIENT_CONTEXT
#include <anchor.h>

#include <ntdsa.h>                      // Dir* Api
#include <filtypes.h>                   // For filter construction
#include <attids.h>                     // for filter construction
#include <dsconfig.h>                   // GetConfigParam

// Logging headers.
#include <mdcodes.h>                    // Only needed for dsevent.h
#include <dsevent.h>                    // Only needed for LogUnhandledError

// Assorted DSA headers.
#include <dsexcept.h>
#include <servinfo.h>

#include <ntdsapi.h>

#include "debug.h"                      // standard debugging header 
#define DEBSUB "DRASERV:"               // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_NTDSAPI


//
// Local forwards
//
DWORD
IsLastDcInDomain(
    IN  DSNAME *Server,
    IN  DSNAME *Domain,
    OUT BOOL   *fLastDcInDomain
    );

DWORD
DoesServerExistLocally(
    IN  DSNAME *Server
    );

DWORD
FindCrossRefObject(
    IN  DSNAME *Domain,
    OUT DSNAME **CrossRef
    );


DWORD 
GiveDeleteTreePermission(
    IN  DSNAME     *Object
    );
    
DWORD 
RemoveRidSetObject(
    IN DSNAME* ComputerObject
    );

DWORD 
RemoveDSSPNs(
    IN DSNAME* ComputerObject
    );

DWORD 
GetComputerObject(
    IN DSNAME*   ServerObject,
    OUT DSNAME** ComputerObject
    );

DWORD
AddAceToSd(
    IN  PSECURITY_DESCRIPTOR pSd,
    IN  PSID                 pClientSid,
    IN  ULONG                AccessMask,
    OUT PSECURITY_DESCRIPTOR *ppNewSd
    );

DWORD
AddAceToAcl(
    IN  PACL  pOldAcl,
    IN  PSID  pClientSid,
    IN  ULONG AccessMask,
    OUT PACL *ppNewAcl
    );

DWORD
GetClientSid( 
    OUT PSID *pClientSid
    );

//
// Function definitions
//

ULONG
RemoveDsServerWorker(
    IN  LPWSTR  ServerDN,        
    IN  LPWSTR  DomainDN OPTIONAL,
    OUT BOOL   *fLastDcInDomain OPTIONAL,
    IN  BOOL    fCommit
    )
/*++

Routine Description:

    This routine is the server side portion of DsRemoveDsServer.

Arguments:

    ServerDN: null terminated string of the server to remove as a ds

    DomainDN: null terminated string of a domain

    fLastDcInDomain: set to TRUE on success if ServerDN is the last server
                     in DomainDN

    fCommit: if TRUE, ServerDN is deleted

Return Values:

    A value from the win32 error space.

--*/
{
    NTSTATUS  NtStatus;
    THSTATE   *pTHS;
    ULONG     DirError, WinError;
    LPWSTR    NtdsServerDN = NULL;
    LPWSTR    NtdsaPrefix = L"CN=Ntds Settings,";
    DSNAME    *Server=NULL, *Domain=NULL, *ServerObject=NULL;
    ULONG     Length, Size;
    SEARCHRES *SearchRes;
    DSNAME    *AccountObject = NULL;
    BOOL      fStatus;
    ULONG     RetryCount = 0;

    //
    // Parameter analysis
    //
    Assert( ServerDN );

    
    // Initialize thread state
    if ( !(pTHS=InitTHSTATE(CALLERTYPE_NTDSAPI)) )
    {
        WinError = ERROR_DS_INTERNAL_FAILURE;
        goto Cleanup;
    }
    
    //
    // Setup the dsname for the server's ntdsa object
    //
    Size = ( wcslen( NtdsaPrefix )
           + wcslen( ServerDN )
           + 1 ) * sizeof( WCHAR );  // good ol' NULL

    NtdsServerDN = (LPWSTR) THAlloc(Size);
    if (!NtdsServerDN) {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    wcscpy( NtdsServerDN, NtdsaPrefix );
    wcscat( NtdsServerDN, ServerDN );

    Length = wcslen( NtdsServerDN );
    Size =  DSNameSizeFromLen( Length );
    Server = (DSNAME*) THAlloc(Size);
    if (!Server) {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    Server->structLen = Size;
    Server->NameLen = Length;
    wcscpy( Server->StringName, NtdsServerDN );

    ServerObject = (DSNAME*) THAlloc(Size);
    if (!ServerObject) {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    ServerObject->structLen = Size;

    fStatus = TrimDSNameBy( Server, 1, ServerObject );


    //
    // We don't have to make sure the server in question is not the 
    // current server, because DirRemoveEntry does that automatically.
    //

    //
    // Get the dsname of the associated Account (computer) object
    //
    WinError = GetComputerObject( ServerObject, &AccountObject );
    if ( ERROR_SUCCESS != WinError )
    {
        //
        // Computer object not here? oh, well, this is not fatal
        //
        WinError = ERROR_SUCCESS;
    }

    //
    // Determine if this is the last dc in a domain
    //
    if ( DomainDN )
    {
        Length = wcslen( DomainDN );
        Size =  DSNameSizeFromLen( Length );
        Domain = (DSNAME*) THAlloc(Size );
        if (!Domain) {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        Domain->structLen = Size;
        Domain->NameLen = Length;
        wcscpy( Domain->StringName, DomainDN );

        //
        // Search for servers containing the domain dn and
        // set fLastDcInDomain
        //
        WinError = GetDcsInNcTransacted(pTHStls,
                                        Domain,
                                        EN_INFOTYPES_TYPES_VALS,
                                        &SearchRes);

        if ( ERROR_SUCCESS != WinError )
        {
            THFreeEx(pTHS,Domain);
            goto Cleanup;
        }

        if (  SearchRes->count == 1 
           && NameMatched( Server, SearchRes->FirstEntInf.Entinf.pName ) )
        {
            if ( fLastDcInDomain )
            {
                *fLastDcInDomain = TRUE;
            }
        }
        THFreeEx(pTHS,Domain);

    }

    //
    // Remove the entries, if necessary
    //
    if ( fCommit )
    {
        BOOLEAN   fRemoveDomain = FALSE;
        REMOVEARG RemoveArg;
        REMOVERES *RemoveRes;

        //
        // Give ourselves delete tree permission since by default the enterprise
        // admins don't have delete tree access in the configuration container.
        // Note - if the caller doesn't have access to write to the DACL this
        // call will, properly, fail with ERROR_ACCESS_DENIED.
        //

        WinError = GiveDeleteTreePermission( Server );
        if ( ERROR_SUCCESS != WinError )
        {
            goto Cleanup;
        }

        //
        // Delete the server object
        //
        RtlZeroMemory( &RemoveArg, sizeof( RemoveArg ) );

        RemoveArg.pObject = Server;
        RemoveArg.fPreserveRDN = FALSE;
        RemoveArg.fGarbCollectASAP = FALSE;
        RemoveArg.fTreeDelete = TRUE;  // remove connection objects
        RemoveArg.pMetaDataVecRemote = NULL;
        InitCommarg( &RemoveArg.CommArg );

        // We want configuration changes to travel fast
        RemoveArg.CommArg.Svccntl.fUrgentReplication = TRUE;

        do
        {
            if ( RetryCount > 0 )
            {
                // arbitrary amount of time
                Sleep( 100 );
            }
    
            DirError = DirRemoveEntry( &RemoveArg, &RemoveRes );
            
            WinError = DirErrorToWinError( DirError, &RemoveRes->CommRes );
    
            THClearErrors();

            RetryCount += 1;

        } while ( (ERROR_DS_BUSY == WinError) && (RetryCount < 5)  );

        if ( ERROR_SUCCESS != WinError )
        {
            goto Cleanup;
        }

        //
        // If the ntdsa object was deleted try to delete the rid set object
        // If we are in the same domain
        //
        if ( AccountObject )
        {
            WinError = RemoveRidSetObject( AccountObject );
            if ( ERROR_SUCCESS != WinError )
            {
                //
                // This is not fatal.  Why not?  Because should this server
                // be made a replica again, then this rid pool will be re-used.
                // No other dc will have this rid pool since the rid master has 
                // not reclaimed these rids.
                //
                WinError = ERROR_SUCCESS;
            }

            //
            // Remove the REPL spn
            //
            WinError = RemoveDSSPNs( AccountObject );
            if ( ERROR_SUCCESS != WinError )
            {
                //
                // This is not fatal because it simply means an extra
                // SPN is left on the machine account.
                //
                WinError = ERROR_SUCCESS;
            }


        }

    }
    else
    {
        //
        // Search to make sure the object is here to be deleted
        //
        if ( !fLastDcInDomain )
        {
            WinError = DoesServerExistLocally( Server );
        }

    }

    //
    // That's it - fall through to cleanup
    //

Cleanup:
    if (NtdsServerDN) THFreeEx(pTHS,NtdsServerDN);
    if (Server) THFreeEx(pTHS,Server);
    if (ServerObject) THFreeEx(pTHS,ServerObject);
    
    if (  ERROR_FILE_NOT_FOUND   == WinError
       || ERROR_NOT_FOUND        == WinError
       || ERROR_DS_OBJ_NOT_FOUND == WinError
       || ERROR_OBJECT_NOT_FOUND == WinError
       || ERROR_PATH_NOT_FOUND   == WinError  )
    {
        WinError = DS_ERR_CANT_FIND_DSA_OBJ;
    }

    return( WinError );

}

DWORD
RemoveDsDomainWorker(
    IN LPWSTR  DomainDN
    )
/*++

Routine Description:

    This routine actually does the work of removing the crossref object
    for the specified domain.

Arguments:

    DomainDN  :  null terminated domain DN

Return Values:

    A value from the winerror space.

--*/
{

    THSTATE    *pTHS;
    NTSTATUS   NtStatus;
    DWORD      DirError, WinError;

    DSNAME    *Domain=NULL, *CrossRef, *HostedDomain=NULL;
    ULONG      Size, Length;
    SEARCHRES *SearchRes;

    //
    // Parameter analysis
    //
    Assert( DomainDN );

    // Initialize thread state

    if ( !(pTHS=InitTHSTATE(CALLERTYPE_NTDSAPI)) )
    {
        WinError = ERROR_DS_INTERNAL_FAILURE;
        goto Cleanup;
    }


    //
    // Make a dsname for the domain
    //
    Length = wcslen( DomainDN );
    Size   = DSNameSizeFromLen( Length );
    Domain = (DSNAME*) THAlloc(Size);
    if (!Domain) {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    Domain->structLen = Size;
    Domain->NameLen = Length;
    wcscpy( Domain->StringName, DomainDN );

    //
    // Is this domain currently hosted on this DC
    //
    Size = 0;
    NtStatus = GetConfigurationName( DSCONFIGNAME_DOMAIN,
                                     &Size,
                                     HostedDomain );
    if ( NtStatus == STATUS_BUFFER_TOO_SMALL )
    {
        HostedDomain = (DSNAME*) THAlloc(Size);

        if (!HostedDomain) {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        NtStatus = GetConfigurationName( DSCONFIGNAME_DOMAIN,
                                         &Size,
                                         HostedDomain );

    }

    if ( !NT_SUCCESS( NtStatus ) )
    {
        WinError = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    }

    if ( NameMatched( HostedDomain, Domain ) )
    {
        WinError = DS_ERR_ILLEGAL_MOD_OPERATION;
        goto Cleanup;
    }


    //
    // Do any servers exist in this domain?
    // DaveStr - 5/26/99 - This is redundant as CrossRef deletion now checks
    // to see if the NC is mastered by anyone before and rejects if true.
    //
    WinError = GetDcsInNcTransacted(pTHStls,
                                    Domain,
                                    EN_INFOTYPES_TYPES_VALS,
                                    &SearchRes);

    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }

    if ( SearchRes->count == 0 )
    {
        REMOVEARG RemoveArg;
        REMOVERES *RemoveRes;
        ULONG     RetryCount = 0;

        //
        // Get the name of the cross ref object
        //
        WinError = FindCrossRefObject( Domain,
                                       &CrossRef );

        if ( ERROR_SUCCESS != WinError )
        {
            goto Cleanup;
        }

        //
        // Delete that object
        //
        RtlZeroMemory( &RemoveArg, sizeof( RemoveArg ) );

        RemoveArg.pObject = CrossRef;
        RemoveArg.fPreserveRDN = FALSE;
        RemoveArg.fGarbCollectASAP = FALSE;
        RemoveArg.fTreeDelete = FALSE;    
        RemoveArg.pMetaDataVecRemote = NULL;
        InitCommarg( &RemoveArg.CommArg );

        // We want configuration changes to travel fast
        RemoveArg.CommArg.Svccntl.fUrgentReplication = TRUE;

        do
        {
            if ( RetryCount > 0 )
            {
                // arbitrary amount of time
                Sleep( 100 );
            }
    
            DirError = DirRemoveEntry( &RemoveArg, &RemoveRes );
            
            WinError = DirErrorToWinError( DirError, &RemoveRes->CommRes );

            THClearErrors();

            RetryCount += 1;


        } while ( (ERROR_DS_BUSY == WinError) && (RetryCount < 5)  );

        // We should understand these cases
        Assert( WinError != ERROR_DS_BUSY );

        if (  ERROR_FILE_NOT_FOUND   == WinError
           || ERROR_NOT_FOUND        == WinError
           || ERROR_DS_OBJ_NOT_FOUND == WinError
           || ERROR_OBJECT_NOT_FOUND == WinError
           || ERROR_PATH_NOT_FOUND   == WinError  )
        {
            WinError = DS_ERR_NO_CROSSREF_FOR_NC;
        }

    }
    else
    {
        //
        // There still exist servers with that claim to hold this nc
        // we can't delete it
        //
        WinError = ERROR_DS_NC_STILL_HAS_DSAS;

    }

    //
    // That's it fall through to Cleanup
    //

Cleanup:
    if (Domain) THFreeEx(pTHS,Domain);
    if (HostedDomain) THFreeEx(pTHS,HostedDomain); 

    return ( WinError );
}

DWORD
FindCrossRefObject(
    IN  DSNAME *Domain,
    OUT DSNAME **CrossRef
    )
/*++

Routine Description:

   This routine finds the crossref object for a given domain

Arguments:

    Domain : a valid dsname

    CrossRef: a dsname allocated from the thread heap

Return Values:

    An appropriate winerror.

--*/
{
    THSTATE *pTHS = pTHStls;

    DWORD    WinError, DirError;
    NTSTATUS NtStatus;

    SEARCHARG  SearchArg;
    SEARCHRES  *SearchRes;

    DWORD      dwCrossRefClass = CLASS_CROSS_REF;

    DSNAME     *PartitionsContainer;
    DWORD      Size;
    FILTER     ObjClassFilter, NcNameFilter, AndFilter;


    Assert( Domain );
    Assert( CrossRef );

    //
    // Default the out parameter
    //
    WinError = DS_ERR_NO_CROSSREF_FOR_NC; 
    *CrossRef = NULL;

    //
    //  Get the base dsname to search from
    //
    Size = 0;
    PartitionsContainer = NULL;
    NtStatus = GetConfigurationName( DSCONFIGNAME_PARTITIONS,
                                     &Size,
                                     PartitionsContainer );
    if ( NtStatus == STATUS_BUFFER_TOO_SMALL )
    {
        PartitionsContainer = (DSNAME*) THAlloc(Size);
        if (!PartitionsContainer) {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        NtStatus = GetConfigurationName( DSCONFIGNAME_PARTITIONS,
                                         &Size,
                                         PartitionsContainer );

    }

    if ( !NT_SUCCESS( NtStatus ) )
    {
        WinError = DS_ERR_NO_CROSSREF_FOR_NC;
        goto Cleanup;
    }

    //
    // Setup the filter
    //
    RtlZeroMemory( &AndFilter, sizeof( AndFilter ) );
    RtlZeroMemory( &ObjClassFilter, sizeof( NcNameFilter ) );
    RtlZeroMemory( &NcNameFilter, sizeof( NcNameFilter ) );

    NcNameFilter.choice = FILTER_CHOICE_ITEM;
    NcNameFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    NcNameFilter.FilterTypes.Item.FilTypes.ava.type = ATT_NC_NAME;
    NcNameFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = Domain->structLen;
    NcNameFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*) Domain;

    ObjClassFilter.choice = FILTER_CHOICE_ITEM;
    ObjClassFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    ObjClassFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CLASS;
    ObjClassFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof( dwCrossRefClass );
    ObjClassFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*) &dwCrossRefClass;

    AndFilter.choice                    = FILTER_CHOICE_AND;
    AndFilter.FilterTypes.And.count     = 2;

    AndFilter.FilterTypes.And.pFirstFilter = &ObjClassFilter;
    ObjClassFilter.pNextFilter = &NcNameFilter;

    RtlZeroMemory( &SearchArg, sizeof(SearchArg) );
    SearchArg.pObject = PartitionsContainer;
    SearchArg.choice  = SE_CHOICE_WHOLE_SUBTREE;
    SearchArg.bOneNC  = TRUE;
    SearchArg.pFilter = &AndFilter;
    SearchArg.searchAliases = FALSE;
    SearchArg.pSelection = NULL;  // don't need any attributes
    SearchArg.pSelectionRange = NULL;
    InitCommarg( &SearchArg.CommArg );

    DirError = DirSearch( &SearchArg, &SearchRes );

    if ( 0 == DirError )
    {
        ASSERT( SearchRes );
        if ( SearchRes->count == 1 )
        {
            *CrossRef = SearchRes->FirstEntInf.Entinf.pName;
            WinError = ERROR_SUCCESS;
        }
    }

    //
    // That's it - fall through to cleanup

Cleanup:
    if (PartitionsContainer) THFreeEx(pTHS,PartitionsContainer);
    return WinError;

}

DWORD
DoesServerExistLocally(
    IN  DSNAME *Server
    )
/*++

Routine Description:

   This routine determines if the local dc has a copy of Server.

Arguments:

    Server: a valid dsname

Return Values:

    ERROR_SUCCESS if the object exists; DS_ERR_CANT_FIND_DSA_OBJ otherwise

--*/
{

    DWORD    WinError, DirError;
    NTSTATUS NtStatus;

    SEARCHARG  SearchArg;
    SEARCHRES  *SearchRes;

    DWORD      dwNtdsDsaClass = CLASS_NTDS_DSA;

    DWORD      Size;
    FILTER     ObjClassFilter;

    Assert( Server );

    //
    // Default the return parameter
    //
    WinError = DS_ERR_CANT_FIND_DSA_OBJ; 

    //
    // Setup the filter
    //
    RtlZeroMemory( &ObjClassFilter, sizeof( ObjClassFilter ) );

    ObjClassFilter.choice = FILTER_CHOICE_ITEM;
    ObjClassFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    ObjClassFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CLASS;
    ObjClassFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof( dwNtdsDsaClass );
    ObjClassFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*) &dwNtdsDsaClass;
    ObjClassFilter.pNextFilter = NULL;

    RtlZeroMemory( &SearchArg, sizeof(SearchArg) );
    SearchArg.pObject = Server;
    SearchArg.choice  = SE_CHOICE_BASE_ONLY;
    SearchArg.bOneNC  = TRUE;
    SearchArg.pFilter = &ObjClassFilter;
    SearchArg.searchAliases = FALSE;
    SearchArg.pSelection = NULL;  // don't need any attributes
    SearchArg.pSelectionRange = NULL;
    InitCommarg( &SearchArg.CommArg );

    DirError = DirSearch( &SearchArg, &SearchRes );

    if ( 0 == DirError )
    {
        Assert( SearchRes );
        if ( SearchRes->count == 1 )
        {
            WinError = ERROR_SUCCESS;
        }
    }

    return WinError;

}


DWORD 
GiveDeleteTreePermission(
    IN  DSNAME     *Object
    )
/*++

Routine Description:

    This object gives the built in admin's sid delete tree access to Object

Arguments:

    Object: a valid dsname

Return Values:
    
    ERROR_SUCCESS; ERROR_ACCESS_DENIED

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    ULONG DirError = 0;

    READARG    ReadArg;
    READRES   *ReadResult;

    MODIFYARG  ModifyArg;
    MODIFYRES *ModifyRes;

    ENTINFSEL    EISelection; // Entry Information Selection
    ATTRBLOCK    AttrBlock;
    ATTRVALBLOCK AttrValBlock;
    ATTR         Attr;
    ATTRVAL     *pAttrVal = NULL;
    ATTRVAL      AttrVal;
    ULONG        ValCount = 0;
    ULONG        ValLength = 0;

    PSECURITY_DESCRIPTOR pSd = NULL, pNewSd = NULL;
    PSID        pClientSid = NULL;
    ULONG       SecurityFlags = DACL_SECURITY_INFORMATION;
    PACL        Dacl; 

    ULONG     Length;
    BOOL      fStatus;


    //
    // Parameter check
    //
    Assert( Object );

    RtlZeroMemory(&AttrBlock, sizeof(ATTRBLOCK));
    RtlZeroMemory(&Attr, sizeof(ATTR));
    RtlZeroMemory(&ReadArg, sizeof(READARG));
    RtlZeroMemory(&ModifyArg, sizeof(MODIFYARG));
    RtlZeroMemory(&EISelection, sizeof(ENTINFSEL));
    RtlZeroMemory(&AttrValBlock, sizeof(ATTRVALBLOCK));

    //
    // Read the security descriptor
    //
    Attr.attrTyp = ATT_NT_SECURITY_DESCRIPTOR;
    AttrBlock.attrCount = 1;
    AttrBlock.pAttr = &Attr;
    EISelection.AttrTypBlock = AttrBlock;
    EISelection.attSel = EN_ATTSET_LIST;
    EISelection.infoTypes = EN_INFOTYPES_TYPES_VALS;
    ReadArg.pSel = &EISelection;
    ReadArg.pObject = Object;
    InitCommarg( &ReadArg.CommArg );

    // Don't try to read the SACL
    ReadArg.CommArg.Svccntl.SecurityDescriptorFlags = SecurityFlags;

    DirError = DirRead( &ReadArg, &ReadResult );

    WinError = DirErrorToWinError(DirError, &ReadResult->CommRes);

    THClearErrors();

    if ( ERROR_SUCCESS != WinError )
    {
        if ( ERROR_DS_NO_REQUESTED_ATTS_FOUND == WinError )
        {
            // couldn't find the sd? probably wrong credentials
            WinError = ERROR_ACCESS_DENIED;
        }
        goto Cleanup;
    }

    //
    // Extract the value
    //

    ASSERT(NULL != ReadResult);
    AttrBlock = ReadResult->entry.AttrBlock;
    pAttrVal = AttrBlock.pAttr[0].AttrVal.pAVal;
    ValCount = AttrBlock.pAttr[0].AttrVal.valCount;
    Assert(1 == ValCount);

    pSd = (PDSNAME)(pAttrVal[0].pVal);
    Length = pAttrVal[0].valLen;

    if ( NULL == pSd )
    {
        // No SD? This is bad
        WinError = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }

    //
    // Get the caller's sid
    //
    WinError = GetClientSid( &pClientSid );
    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }

    WinError = AddAceToSd( pSd,
                           pClientSid,
                           ACTRL_DS_DELETE_TREE,
                           &pNewSd );

    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }

    //
    // Write the security descriptor
    //
    memset( &ModifyArg, 0, sizeof( ModifyArg ) );
    ModifyArg.pObject = Object;

    ModifyArg.FirstMod.pNextMod = NULL;
    ModifyArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;

    AttrVal.valLen = Length;
    AttrVal.pVal = (PUCHAR)pNewSd;
    AttrValBlock.valCount = 1;
    AttrValBlock.pAVal = &AttrVal;
    Attr.attrTyp = ATT_NT_SECURITY_DESCRIPTOR;
    Attr.AttrVal = AttrValBlock;

    ModifyArg.FirstMod.AttrInf = Attr;
    ModifyArg.count = 1;

    InitCommarg( &ModifyArg.CommArg );

    //
    // We only want to change the dacl
    //
    ModifyArg.CommArg.Svccntl.SecurityDescriptorFlags = SecurityFlags;


    DirError = DirModifyEntry( &ModifyArg, &ModifyRes );

    WinError = DirErrorToWinError( DirError, &ModifyRes->CommRes );

    THClearErrors();

    //
    // We are done
    //

Cleanup:

    if ( pClientSid )
    {
        LocalFree( pClientSid );
    }

    if ( pNewSd )
    {
        LocalFree( pNewSd );
    }

    return WinError;

}


DWORD 
RemoveRidSetObject(
    IN DSNAME* ComputerObject
    )
/*++

Routine Description:

    This routine finds and delete the rid set object for ComputerObject.

Arguments:

    ComputerObject: the computer object whose ir dobject should be deleted.

Return Values:

    ERROR_SUCCESS if the object exists; 

--*/
{
    DWORD  WinError = ERROR_SUCCESS;
    ULONG  DirError = 0;

    READARG   ReadArg;
    READRES  *ReadResult;

    REMOVEARG RemoveArg;
    REMOVERES *RemoveRes;

    ENTINFSEL EISelection; // Entry Information Selection
    ATTRBLOCK ReadAttrBlock;
    ATTR      Attr;
    ATTRVAL   *pVal;

    DSNAME    *RidObject = NULL;

    //
    // Parameter check
    //
    Assert( ComputerObject );

    //
    // Read the rid set reference property
    //
    RtlZeroMemory(&Attr, sizeof(ATTR));
    RtlZeroMemory(&ReadArg, sizeof(READARG));
    RtlZeroMemory(&EISelection, sizeof(ENTINFSEL));
    RtlZeroMemory(&ReadAttrBlock, sizeof(ATTRBLOCK));

    Attr.attrTyp = ATT_RID_SET_REFERENCES;

    ReadAttrBlock.attrCount = 1;
    ReadAttrBlock.pAttr = &Attr;

    EISelection.AttrTypBlock = ReadAttrBlock;
    EISelection.attSel = EN_ATTSET_LIST;
    EISelection.infoTypes = EN_INFOTYPES_TYPES_VALS;

    ReadArg.pSel = &EISelection;
    ReadArg.pObject = ComputerObject;

    InitCommarg( &ReadArg.CommArg );

    DirError = DirRead( &ReadArg, &ReadResult );

    WinError = DirErrorToWinError( DirError, &ReadResult->CommRes );

    THClearErrors();

    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }

    {
        // Once the RID Set Reference object has been found and read, extract
        // the RID Set DN of interest (currently only one domain is handled)
        // and return that DN for subsequent usage.

        ATTRBLOCK AttrBlock;
        PDSNAME   pVal;
        ATTRVAL *AttrVal = NULL;
        ULONG ValCount = 0;
        ULONG ValLength = 0;
        ULONG Index = 0;

        ASSERT(NULL != ReadResult);

        AttrBlock = ReadResult->entry.AttrBlock;
        AttrVal = AttrBlock.pAttr[0].AttrVal.pAVal;
        ValCount = AttrBlock.pAttr[0].AttrVal.valCount;

        for (Index = 0; Index < ValCount; Index++)
        {
            pVal = (PDSNAME)(AttrVal[Index].pVal);
            ValLength = AttrVal[Index].valLen;
            ASSERT(1 == ValCount);
        }
        ASSERT(NULL != pVal);
        RidObject = pVal;

    }

    //
    // Delete the rid set object
    //
    RtlZeroMemory( &RemoveArg, sizeof( RemoveArg ) );

    RemoveArg.pObject = RidObject;
    RemoveArg.fPreserveRDN = FALSE;
    RemoveArg.fGarbCollectASAP = FALSE;
    RemoveArg.fTreeDelete = FALSE;    
    RemoveArg.pMetaDataVecRemote = NULL;
    InitCommarg( &RemoveArg.CommArg );

    DirError = DirRemoveEntry( &RemoveArg, &RemoveRes );

    WinError = DirErrorToWinError( DirError, &RemoveRes->CommRes );

    THClearErrors();

    //
    // That's it
    // 

Cleanup:

    return WinError;
}

DWORD 
GetComputerObject(
    IN DSNAME*   ServerObject,
    OUT DSNAME** ComputerObject
    )
/*++

Routine Description:

    This routine obtains the computer object from given the server object.

Arguments:

    ServerObject: an ntdsa object
    
    ComputerObject: the corresponding SAM account object                                                                          

Return Values:

    ERROR_SUCCESS if the object exists; 
    
    ERROR_NO_TRUST_SAM_ACCOUNT otherwise
    
    

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    ULONG DirError = 0;

    READARG   ReadArg;
    READRES  *ReadResult;
    ENTINFSEL EISelection; // Entry Information Selection
    ATTRBLOCK ReadAttrBlock;
    COMMARG  *CommArg;
    ATTR      Attr;
    ATTRVAL   *pVal;
    PDSNAME   ServerDsName = NULL;

    Assert( ServerObject );
    Assert( ComputerObject );

    //
    // Read the rid set reference property
    //
    RtlZeroMemory(&Attr, sizeof(ATTR));
    RtlZeroMemory(&ReadArg, sizeof(READARG));
    RtlZeroMemory(&EISelection, sizeof(ENTINFSEL));
    RtlZeroMemory(&ReadAttrBlock, sizeof(ATTRBLOCK));

    Attr.attrTyp = ATT_SERVER_REFERENCE;

    ReadAttrBlock.attrCount = 1;
    ReadAttrBlock.pAttr = &Attr;

    EISelection.AttrTypBlock = ReadAttrBlock;
    EISelection.attSel = EN_ATTSET_LIST;
    EISelection.infoTypes = EN_INFOTYPES_TYPES_VALS;

    ReadArg.pSel = &EISelection;
    ReadArg.pObject = ServerObject;

    CommArg = &(ReadArg.CommArg);
    InitCommarg(CommArg);

    DirError = DirRead(&ReadArg, &ReadResult);

    WinError = DirErrorToWinError(DirError, &ReadResult->CommRes);

    THClearErrors();

    if ( ERROR_SUCCESS == WinError )
    {
        //
        // Extract the value
        //
        ATTRBLOCK AttrBlock;
        PDSNAME   pVal;
        ATTRVAL *AttrVal = NULL;
        ULONG ValCount = 0;
        ULONG ValLength = 0;
        ULONG Index = 0;

        CROSS_REF * pCR;
        COMMARG CommArg;

        ASSERT(NULL != ReadResult);

        AttrBlock = ReadResult->entry.AttrBlock;
        AttrVal = AttrBlock.pAttr[0].AttrVal.pAVal;
        ValCount = AttrBlock.pAttr[0].AttrVal.valCount;

        for (Index = 0; Index < ValCount; Index++)
        {
            pVal = (PDSNAME)(AttrVal[Index].pVal);
            ValLength = AttrVal[Index].valLen;
            ASSERT(1 == ValCount);
        }
        ASSERT(NULL != pVal);

        // Make sure we are authoritative for this object
        InitCommarg(&CommArg);
        CommArg.Svccntl.dontUseCopy = FALSE;

        pCR = FindBestCrossRef(pVal, &CommArg);
        if (   pCR 
            && pCR->pNC
            && NameMatched( pCR->pNC, gAnchor.pDomainDN ) ) {

            // This is good
            *ComputerObject = pVal;
            
        } else {
            WinError = ERROR_NO_TRUST_SAM_ACCOUNT;
        }

    }
    else
    {
        //
        // We couldn't find it 
        //
        WinError = ERROR_NO_TRUST_SAM_ACCOUNT;

    }

    return WinError;
}



DWORD
AddAceToSd(
    IN  PSECURITY_DESCRIPTOR pOldSd,
    IN  PSID  pClientSid,
    IN  ULONG AccessMask,
    OUT PSECURITY_DESCRIPTOR *ppNewSd
    )
/*++

Routine Description:

    This routine creates a new sd with a new ace with pClientSid and AccessMask

Arguments:

    pOldAcl
    
    pClientSid
    
    AccessMask
    
    pNewAcl

Return Values:

    ERROR_SUCCESS if the ace was put in the sd
    
--*/
{

    DWORD  WinError = ERROR_SUCCESS;
    BOOL   fStatus;

    PSECURITY_DESCRIPTOR pNewSelfRelativeSd = NULL;
    DWORD                NewSelfRelativeSdSize = 0;
    PACL                 pNewDacl  = NULL;

    SECURITY_DESCRIPTOR  AbsoluteSd;
    PACL                 pDacl  = NULL;
    PACL                 pSacl  = NULL;
    PSID                 pGroup = NULL;
    PSID                 pOwner = NULL;

    DWORD AbsoluteSdSize = sizeof( SECURITY_DESCRIPTOR );
    DWORD DaclSize = 0;
    DWORD SaclSize = 0;
    DWORD GroupSize = 0;
    DWORD OwnerSize = 0;


    // Parameter check
    Assert( pOldSd );
    Assert( pClientSid );
    Assert( ppNewSd );

    // Init the out parameter
    *ppNewSd = NULL;

    RtlZeroMemory( &AbsoluteSd, AbsoluteSdSize );

    //
    // Make sd absolute
    //
    fStatus = MakeAbsoluteSD( pOldSd,
                              &AbsoluteSd,
                              &AbsoluteSdSize,
                              pDacl,
                              &DaclSize,
                              pSacl,
                              &SaclSize,
                              pOwner,
                              &OwnerSize,
                              pGroup,
                              &GroupSize );

    if ( !fStatus && (ERROR_INSUFFICIENT_BUFFER == (WinError = GetLastError())))
    {
        WinError = ERROR_SUCCESS;

        if ( 0 == DaclSize )
        {
            // No Dacl? We can't write to the dacl, then
            WinError = ERROR_ACCESS_DENIED;
            goto Cleanup;
        }

        if (    (DaclSize > 0) && !(pDacl = LocalAlloc(0,DaclSize))
             || (SaclSize > 0) && !(pSacl = LocalAlloc(0,SaclSize))
             || (OwnerSize > 0) && !(pOwner = LocalAlloc(0,OwnerSize))
             || (GroupSize > 0) && !(pGroup = LocalAlloc(0,GroupSize)) )
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }


        if ( pDacl )
        {
            fStatus = MakeAbsoluteSD( pOldSd,
                                      &AbsoluteSd,
                                      &AbsoluteSdSize,
                                      pDacl,
                                      &DaclSize,
                                      pSacl,
                                      &SaclSize,
                                      pOwner,
                                      &OwnerSize,
                                      pGroup,
                                      &GroupSize );
    
            if ( !fStatus )
            {
                WinError = GetLastError();
            }
        }
        else
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
        }

    }

    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }

    //
    // Create a new dacl with the new ace
    //
    WinError = AddAceToAcl( pDacl,
                           pClientSid,
                           AccessMask,
                           &pNewDacl );

    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }

    //
    // Set the dacl
    //
    fStatus = SetSecurityDescriptorDacl ( &AbsoluteSd,
                                         TRUE,     // dacl is present
                                         pNewDacl,
                                         FALSE );  //  facl is not defaulted

    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    //
    // Make the new sd self relative
    //
    fStatus =  MakeSelfRelativeSD( &AbsoluteSd,
                                   pNewSelfRelativeSd,
                                   &NewSelfRelativeSdSize );

    if ( !fStatus && (ERROR_INSUFFICIENT_BUFFER == (WinError = GetLastError())))
    {
        WinError = ERROR_SUCCESS;

        pNewSelfRelativeSd = LocalAlloc( 0, NewSelfRelativeSdSize );

        if ( pNewSelfRelativeSd )
        {
            fStatus =  MakeSelfRelativeSD( &AbsoluteSd,
                                           pNewSelfRelativeSd,
                                           &NewSelfRelativeSdSize );
    
            if ( !fStatus )
            {
                WinError = GetLastError();
            }
        }
        else
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // That's it fall through to cleanup
    //

Cleanup:
    if (pDacl) 
    {
        LocalFree(pDacl);
    }
    if (pSacl) 
    {
        LocalFree(pSacl);
    }
    if (pOwner) 
    {
        LocalFree(pOwner);
    }
    if (pGroup) 
    {
        LocalFree(pGroup);
    }
    if ( pNewDacl )
    {
        LocalFree( pNewDacl );
    }

    if ( ERROR_SUCCESS == WinError )
    {
        Assert( pNewSelfRelativeSd );
        *ppNewSd = pNewSelfRelativeSd;
    }
    else
    {
        if ( pNewSelfRelativeSd )
        {
            LocalFree( pNewSelfRelativeSd );
        }
    }

    return WinError;

}

DWORD
AddAceToAcl(
    IN  PACL pOldAcl,
    IN  PSID  pClientSid,
    IN  ULONG AccessMask,
    OUT PACL *ppNewAcl
    )
/*++

Routine Description:

    This routine creates a new sd with a new ace with pClientSid and AccessMask

Arguments:

    pOldAcl
    
    pClientSid
    
    AccessMask
    
    pNewAcl

Return Values:

    ERROR_SUCCESS if the ace was put in the sd
    
--*/
{
    DWORD WinError = ERROR_SUCCESS;
    BOOL  fStatus;

    ACL_SIZE_INFORMATION     AclSizeInfo;
    ACL_REVISION_INFORMATION AclRevInfo;
    ACCESS_ALLOWED_ACE       Dummy;

    PVOID  FirstAce = 0;
    PACL   pNewAcl = 0;

    ULONG NewAclSize, NewAceCount, AceSize;

    // Parameter check
    Assert( pOldAcl );
    Assert( pClientSid );
    Assert( ppNewAcl );

    // Init the out parameter
    *ppNewAcl = NULL;

    memset( &AclSizeInfo, 0, sizeof( AclSizeInfo ) );
    memset( &AclRevInfo, 0, sizeof( AclRevInfo ) );

    //
    // Get the old sd's values
    //
    fStatus = GetAclInformation( pOldAcl,
                                 &AclSizeInfo,
                                 sizeof( AclSizeInfo ),
                                 AclSizeInformation );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    fStatus = GetAclInformation( pOldAcl,
                                 &AclRevInfo,
                                 sizeof( AclRevInfo ),
                                 AclRevisionInformation );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    //
    // Calculate the new sd's values
    //
    AceSize = sizeof( ACCESS_ALLOWED_ACE ) - sizeof( Dummy.SidStart )
              + GetLengthSid( pClientSid );

    NewAclSize  = AceSize + AclSizeInfo.AclBytesInUse;
    NewAceCount = AclSizeInfo.AceCount + 1;

    //
    // Init the new acl
    //
    pNewAcl = LocalAlloc( 0, NewAclSize );
    if ( NULL == pNewAcl )
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    fStatus = InitializeAcl( pNewAcl,
                             NewAclSize,
                             AclRevInfo.AclRevision );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    //
    // Copy the old into the new
    //
    fStatus = GetAce( pOldAcl,
                      0,
                      &FirstAce );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    fStatus = AddAce( pNewAcl,
                      AclRevInfo.AclRevision,
                      0,
                      FirstAce,
                      AclSizeInfo.AclBytesInUse - sizeof( ACL ) );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    //
    // Finally, add the new ace
    //
    fStatus = AddAccessAllowedAce( pNewAcl,
                                   ACL_REVISION,
                                   AccessMask,
                                   pClientSid );

    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    // Assign the out parameter
    *ppNewAcl = pNewAcl;

    //
    // That's it fall through to cleanup
    //

Cleanup:

    if ( ERROR_SUCCESS != WinError )
    {
        if ( pNewAcl )
        {
            LocalFree( pNewAcl );
        }
    }

    return WinError;
}


DWORD
GetClientSid( 
    OUT PSID *pClientSid
    )
/*++

Routine Description:
    
    This routine returns the sid of the caller

Arguments:

    pClientSid

Return Values:

    ERROR_SUCCESS if we are are able to impersonate and grab the sid
    
--*/
{
    DWORD        WinError = ERROR_SUCCESS;
    BOOL         fImpersonate = FALSE;
    BOOL         fStatus;

    HANDLE       ThreadToken = 0;
    PTOKEN_USER  UserToken = NULL;
    DWORD        Size;


    WinError = ImpersonateAnyClient();
    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }
    fImpersonate = TRUE;

    fStatus = OpenThreadToken( GetCurrentThread(),
                               MAXIMUM_ALLOWED,
                               TRUE,
                               &ThreadToken );

    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    Size = 0;
    fStatus = GetTokenInformation( ThreadToken,
                                   TokenUser,
                                   UserToken,
                                   Size,
                                   &Size );

    WinError = GetLastError();

    if ( ERROR_INSUFFICIENT_BUFFER == WinError )
    {
        WinError = ERROR_SUCCESS;

        UserToken = LocalAlloc( 0, Size );
        if ( UserToken )
        {
            fStatus = GetTokenInformation( ThreadToken,
                                           TokenUser,
                                           UserToken,
                                           Size,
                                           &Size );
            if ( !fStatus )
            {
                WinError = GetLastError();
            }
        }
        else
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
        }


    }

    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }

    //
    // sanity check
    //
    if ( NULL == UserToken->User.Sid )
    {
        WinError = ERROR_NO_IMPERSONATION_TOKEN;
        goto Cleanup;
    }

    //
    // Set the out parameter
    //
    Size = GetLengthSid( UserToken->User.Sid );
    *pClientSid = LocalAlloc( 0, Size );
    if ( NULL == *pClientSid )
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    CopySid( Size, *pClientSid, UserToken->User.Sid );

Cleanup:

    if ( UserToken )
    {
        LocalFree( UserToken );
    }

    if ( ThreadToken )
    {
        CloseHandle( ThreadToken );
    }

    if ( fImpersonate )
    {
        UnImpersonateAnyClient();
    }

    return WinError;
}


DWORD 
RemoveDSSPNs(
    IN DSNAME* ComputerObject
    )
/*++

Routine Description:
    
    This routine removes the SPN's that the DS registered on itself

Arguments:

    ComputerObject -- DN of the machine account

Return Values:

    ERROR_SUCCESS if we are are able to impersonate and grab the sid
    
--*/
{

    DWORD err = 0;
    THSTATE * pTHS = pTHStls;
    BOOL  fChanged = FALSE, fCommit = FALSE; 

    Assert( ComputerObject );

    // Remove all the SPN's we registered
    __try {

        DBOpen2(TRUE, &pTHS->pDB);

        __try {

            ATTCACHE *pAC_SPN;
            ATTRVALBLOCK AttrValBlock;

            pAC_SPN=SCGetAttById(pTHS, ATT_SERVICE_PRINCIPAL_NAME);
    
            // Step 1 is to position find the compupter object.
            err = DBFindDSName( pTHS->pDB, ComputerObject );
    
            if (  pAC_SPN
               && (err == 0) ) {
    
                memset( &AttrValBlock, 0, sizeof(AttrValBlock) );
    
                // Now, remove all of our SPN's
                WriteSPNsHelp(pTHS,
                              pAC_SPN,
                              &AttrValBlock,
                              &ServicesToRemove,
                              &fChanged
                              );
                if(fChanged) {
                    // OK, put this change into the DB.
                    DBRepl(pTHS->pDB, FALSE, 0, NULL, 0);
                }
                else {
                    // Nothing actually changed, don't write this to the DB
                    DBCancelRec(pTHS->pDB);
                }
                fCommit = TRUE;

            }

        } finally {

            DBClose (pTHS->pDB, fCommit );

        }

    } except (HandleMostExceptions(GetExceptionCode())) {

        //
        // This error is not so important since it is ignored anyway
        //

        err = DIRERR_OBJ_NOT_FOUND;

    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\drsserv\drs_wclient.c ===
#include <NTDSpch.h>
#pragma  hdrstop
#include <drs_w.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\drsserv\drs_server.c ===
#include <NTDSpch.h>
#pragma  hdrstop
#include <drs_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\drsserv\idlnotif.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       idlnotif.c
//
//--------------------------------------------------------------------------


/*

Description:
    Contains the RPC notification routines.

*/

#include <NTDSpch.h>
#pragma hdrstop

#include "drs.h"
#include <fileno.h>
#define  FILENO FILENO_DSNOTIF

void dsa_notify( void );

void IDL_DRSBind_notify (void)
{
        dsa_notify();
}

void IDL_DRSUnbind_notify (void)
{
        dsa_notify();
}

void IDL_DRSReplicaSync_notify (void)
{
        dsa_notify();
}

void IDL_DRSGetNCChanges_notify (void)
{
        dsa_notify();
}

void IDL_DRSUpdateRefs_notify (void)
{
        dsa_notify();
}

void IDL_DRSReplicaAdd_notify (void)
{
    dsa_notify();
}

void IDL_DRSReplicaDel_notify (void)
{
    dsa_notify();
}

void IDL_DRSReplicaModify_notify (void)
{
    dsa_notify();
}

void IDL_DRSVerifyNames_notify (void)
{
        dsa_notify();
}

void IDL_DRSGetMemberships_notify(void)
{
    dsa_notify();
}

void IDL_DRSInterDomainMove_notify (void)
{
    dsa_notify();
}

void IDL_DRSGetNT4ChangeLog_notify (void)
{
    dsa_notify();
}

void IDL_DRSCrackNames_notify (void)
{
    dsa_notify();
}

void IDL_DRSWriteSPN_notify (void)
{
    dsa_notify();
}

void IDL_DRSRemoveDsServer_notify (void)
{
    dsa_notify();
}
void IDL_DRSRemoveDsDomain_notify (void)
{
    dsa_notify();
}

void IDL_DRSDomainControllerInfo_notify (void)
{
    dsa_notify();
}

void IDL_DRSAddEntry_notify (void)
{
    dsa_notify();
}

void IDL_DRSExecuteKCC_notify (void)
{
    dsa_notify();
}

void IDL_DRSAddSidHistory_notify (void)
{
    dsa_notify();
}

void IDL_DRSGetMemberships2_notify (void)
{
    dsa_notify();
}

void IDL_DSAPrepareScript_notify (void)
{
    dsa_notify();
}

void IDL_DSAExecuteScript_notify (void)
{
    dsa_notify();
}

void IDL_DRSReplicaVerifyObjects_notify (void)
{
    dsa_notify();
}

void IDL_DRSGetObjectExistence_notify (void)
{
    dsa_notify();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\bhcache.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       bhcache.h
//
//--------------------------------------------------------------------------

#ifndef __BHCACHE_H__
#define __BHCACHE_H__

// DaveStr - 3/21/97
// Changed the cache to handle multiple concurrent users,
// the option to not cache a handle, and to provide credentials.
// See comments on FGetRpcHandle for the general algorithm.

typedef struct _BHCacheElement  {
    DRS_HANDLE hDrs;
    union {
        BYTE rgbRemoteExt[CURR_MAX_DRS_EXT_STRUCT_SIZE];
        DRS_EXTENSIONS extRemote;
    };
    LPWSTR  pszServer;
    DWORD   cchServer; // includes null terminator
    LPWSTR  pszServerPrincName;
    DWORD   cRefs;
    BOOL    fDontUse;
    BOOL    fLocked;
    DWORD   cTickLastUsed;
    
    union {
        BYTE rgbLocalExt[CURR_MAX_DRS_EXT_STRUCT_SIZE];
        DRS_EXTENSIONS extLocal;
    };
} BHCacheElement;

#define BHCacheSize 256

// Following validation check insures that the hash is good and that
// all fields are set/cleared in unison.

#define VALIDATE_BH_ENTRY(i)                                        \
    Assert(   (i < BHCacheSize)                                     \
           && (   (    rgBHCache[i].pszServer                       \
                    && rgBHCache[i].cchServer                       \
                    && rgBHCache[i].hDrs                            \
                    && rgBHCache[i].cRefs)                          \
               || !memcmp(&rgBHCache[i],                            \
                          &NullBHCacheElement,                      \
                          sizeof(NullBHCacheElement))))

extern BHCacheElement rgBHCache[BHCacheSize];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\exe\dsatest.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dsatest.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file implements a suite of tests to exercise the DSA with the
    intent of flushing out core, dblayer and Jet concurrency and loading
    problems.  It is derived from the original OFS (Object File System)
    propq DRT on \\savik\win40\src\drt\propq.

    NOTE how we want to be as external an in-process client as
    we can be so as not to leverage internals.

Author:

    DaveStr     06-May-97

Environment:

    User Mode - Win32

Revision History:

--*/

#include <ntdspch.h>
#pragma hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <attids.h>                     // ATT_*
#include <mappings.h>                   // SampSetDsa()
#include <sddl.h>                       // ConvertStringSecurityDescriptor...()

typedef enum _Operation {
    OP_ADD              = 0,
    OP_DELETE           = 1,
    OP_SEARCH           = 2,
    OP_DELAY            = 3
} Operation;

typedef enum _QueryOption {
    QOPT_DONTCARE       = 0,        // don't care how many objects are found
    QOPT_ASCENDING      = 1,        // successive queries should find more objs
    QOPT_DESCENDING     = 2,        // successive queries should find less objs
    QOPT_EXACTMATCH     = 3         // Assert(cFound == cExpected)
} QueryOption;

// Globals

CHAR *rpszOperation[] = { "OP_ADD",
                          "OP_DELETE",
                          "OP_SEARCH",
                          "OP_DELAY" };

CHAR *rpszQueryOption[] = { "DON'T CARE",
                            "ASCENDING",
                            "DESCENDING",
                            "EXACT MATCH" };

BOOL                gfVerbose = FALSE;
DWORD               gcObjects = 100000;
DWORD               gcThreads = 50;
DWORD               gcDelaySec = 0;

CHAR                TestRootBuffer[1000];
DSNAME              *gTestRoot = (DSNAME *) TestRootBuffer;

#define             ATT_OBJECT_NUM ATT_FLAGS
SYNTAX_INTEGER      DefaultObjectNum = 0;
ATTRVAL             DefaultObjectNumVal = {sizeof(SYNTAX_INTEGER),
                                           (UCHAR *) &DefaultObjectNum};
SYNTAX_OBJECT_ID    DefaultObjectClass = CLASS_CONTAINER;
ATTRVAL             DefaultObjectClassVal = {sizeof(SYNTAX_OBJECT_ID),
                                             (UCHAR *) &DefaultObjectClass};
CHAR                DefaultSDBuffer[1000];
ATTRVAL             DefaultSDVal = {0, (UCHAR *) DefaultSDBuffer};
ATTR                DefaultAttrs[3] = {{ATT_OBJECT_NUM,
                                       {1, &DefaultObjectNumVal}},
                                       {ATT_OBJECT_CLASS,
                                       {1, &DefaultObjectClassVal}},
                                       {ATT_NT_SECURITY_DESCRIPTOR,
                                       {1, &DefaultSDVal}}};
ATTRBLOCK           DefaultAttrBlock = { 3, DefaultAttrs };
COMMARG             DefaultCommArg;

void _Abort(
    DWORD   err,
    CHAR    *psz,
    int     line)
{
    fprintf(stderr,
            "Abort - line(%d) err(%08lx) %s %s\n",
            line,
            err,
            (psz ? "" : "==>"),
            (psz ? "" : psz));

    DebugBreak();
}

#define Abort(err, psz) _Abort(err, psz, __LINE__)

DSNAME * DSNameFromNum(
    DWORD objectNum)
{
    DSNAME  *pDSName;
    WCHAR   buf[1000];
    DWORD   cChar;
    DWORD   cBytes;

    swprintf(buf, L"CN=DsaTest_%08d,", objectNum);
    wcscat(buf, gTestRoot->StringName);
    cChar = wcslen(buf);
    cBytes = DSNameSizeFromLen(cChar);
    pDSName = (DSNAME *) THAlloc(cBytes);
    pDSName->structLen = cBytes;
    pDSName->NameLen = cChar;
    wcscpy(pDSName->StringName, buf);

    return(pDSName);
}

VOID DoObject(
    Operation   op,
    DWORD       objectNum)
{
    DWORD   err;
    DWORD   i;

    // Create thread state.

    if ( THCreate( CALLERTYPE_INTERNAL ) )
        Abort(1, "THCreate");

    // Avoid security issues.

    SampSetDsa(TRUE);

    switch ( op )
    {
    case OP_ADD:
    {
        ADDARG              addArg;
        ADDRES              *pAddRes = NULL;
        SYNTAX_INTEGER      ThisObjectNum = objectNum;
        ATTRVAL             ThisObjectNumVal = {sizeof(SYNTAX_INTEGER),
                                                (UCHAR *) &ThisObjectNum};
        SYNTAX_OBJECT_ID    ThisObjectClass = CLASS_CONTAINER;
        ATTRVAL             ThisObjectClassVal = {sizeof(SYNTAX_OBJECT_ID),
                                                  (UCHAR *) &ThisObjectClass};
        ATTRVAL             ThisSDVal = {0, (UCHAR *) NULL};
        ATTR                ThisAttrs[3] = {{ATT_OBJECT_NUM,
                                            {1, &ThisObjectNumVal}},
                                            {ATT_OBJECT_CLASS,
                                            {1, &ThisObjectClassVal}},
                                            {ATT_NT_SECURITY_DESCRIPTOR,
                                            {1, &ThisSDVal}}};
        ATTRBLOCK           ThisAttrBlock = { 3, ThisAttrs };
        

        // Construct add arguments.

        memset(&addArg, 0, sizeof(ADDARG));
        addArg.pObject = DSNameFromNum(objectNum);
        addArg.AttrBlock = ThisAttrBlock;
        addArg.CommArg = DefaultCommArg;

        // Core mangles/replaces some properties on us, eg: security desc.,
        // so we allocate new values where appropriate.

        ThisSDVal.valLen = DefaultSDVal.valLen;
        ThisSDVal.pVal = (UCHAR *) THAlloc(ThisSDVal.valLen);
        memcpy(ThisSDVal.pVal, DefaultSDVal.pVal, ThisSDVal.valLen);

        // Do the add.

        err = DirAddEntry(&addArg, &pAddRes);

        if ( err )
            Abort(err, "DirAddEntry");

        break;
    }

    case OP_DELETE:
    {
        REMOVEARG   removeArg;
        REMOVERES   *pRemoveRes = NULL;

        // Construct remove arguments.

        memset(&removeArg, 0, sizeof(REMOVEARG));
        removeArg.pObject = DSNameFromNum(objectNum);
        removeArg.fPreserveRDN = FALSE;
        removeArg.fGarbCollectASAP = FALSE;
        removeArg.CommArg = DefaultCommArg;

        // Do the remove.

        err = DirRemoveEntry(&removeArg, &pRemoveRes);

        if ( err )
            Abort(err, "DirRemoveEntry");

        break;
    }

    case OP_DELAY:
    {
        READARG     readArg;
        READRES     *pReadRes;

        // Construct read arguments.

        memset(&readArg, 0, sizeof(READARG));
        readArg.pObject = gTestRoot;
        readArg.pSel = NULL;
        readArg.CommArg = DefaultCommArg;

        // Do a read to open the transaction.

        DirTransactControl(TRANSACT_BEGIN_DONT_END);
        err = DirRead(&readArg, &pReadRes);

        if ( err )
            Abort(err, "DirReadEntry - begin delay");

        // Delay - interpret objectNum as second count.

        Sleep(objectNum * 1000);

        // Do a read to close the transaction.

        DirTransactControl(TRANSACT_DONT_BEGIN_END);
        err = DirRead(&readArg, &pReadRes);

        if ( err )
            Abort(err, "DirReadEntry - end delay");

        break;
    }

    default:

        Abort(1, "Unknown test operation");
    }

    // Clean up thread state.

    if ( THDestroy() )
        Abort(1, "THDestroy");
}

VOID DoObjectsSingleThreaded(
    Operation   op,
    DWORD       objectNumLow,
    DWORD       objectNumHigh)
{
    DWORD   i;
    DWORD   start = GetTickCount();

    if ( gfVerbose )
        fprintf(stderr,
                "DoObjectsSingleThreaded(%s, [%d..%d]) ...\n",
                rpszOperation[op],
                objectNumLow,
                objectNumHigh);

    for ( i = objectNumLow; i <= objectNumHigh; i++ )
        DoObject(op, i);

    if ( gfVerbose )
        fprintf(stderr,
                "Sequential %s of [%d..%d] ==> %d/sec\n",
                rpszOperation[op],
                objectNumLow,
                objectNumHigh,
                ((objectNumHigh - objectNumLow) * 1000) /
                                        (GetTickCount() - start));
}

typedef struct _DoArgs {
    Operation   op;
    DWORD       objectNumLow;
    DWORD       objectNumHigh;
} DoArgs;

ULONG __stdcall _DoObjects(
    VOID *arg)
{
    DoArgs *p = (DoArgs *) arg;

    DoObjectsSingleThreaded(p->op,
                            p->objectNumLow,
                            p->objectNumHigh);
    return(0);
}

VOID DoObjectsMultiThreaded(
    Operation   op,
    DWORD       backgroundTransactionDuration)
{
    DWORD   i, err, numLow;
    DWORD   start = GetTickCount();
    DWORD   cObjectsPerThread = gcObjects / gcThreads;
    HANDLE  *rh = (HANDLE *) alloca(gcThreads * sizeof(HANDLE));
    DWORD   *rid = (DWORD *) alloca(gcThreads * sizeof(DWORD));
    DoArgs  *rargs = (DoArgs *) alloca(gcThreads * sizeof(DoArgs));

    if ( gfVerbose )
        fprintf(stderr,
                "DoObjectsMultiThreaded(%s) ...\n",
                rpszOperation[op]);

    // Spawn a DoObjects() for each cObjectsPerThread.

    numLow = 0;

    for ( i = 0; i < gcThreads; i++ )
    {
        rargs[i].op = op;
        rargs[i].objectNumLow = numLow;
        rargs[i].objectNumHigh = numLow + cObjectsPerThread - 1;

        rh[i] = CreateThread(NULL,                      // security attrs
                             0,                         // default stack size
                             _DoObjects,                // start routine
                             (VOID *) &rargs[i],        // start argument
                             0,                         // creation flags
                             &rid[i]);                  // thread id

        if ( NULL == rh[i] )
            Abort(GetLastError(), "CreateThread");

        numLow += cObjectsPerThread;
    }

    if ( !backgroundTransactionDuration )
    {
        // Wait for all the threads to complete.

        err = WaitForMultipleObjects(gcThreads,
                                     rh,
                                     TRUE,              // wait for all
                                     INFINITE);

        if ( WAIT_FAILED == err )
            Abort(GetLastError(), "WaitForMultipleObjects");
    }
    else
    {
        // Loop performing background delay and wait for all
        // threads to complete.

#pragma warning(disable:4296)
        while ( TRUE )
        {
            DoObject(OP_DELAY, backgroundTransactionDuration);

            err = WaitForMultipleObjects(gcThreads,
                                         rh,
                                         TRUE,              // wait for all
                                         0);

            if ( WAIT_TIMEOUT == err )
            {
                continue;
            }
            // The following test generates an error 4296, because it turns
            // out that WAIT_OBJECT_0 is 0, and unsigned err can never be neg.
            else if (    (WAIT_OBJECT_0 <= err)
                      && ((WAIT_OBJECT_0 + gcThreads - 1) >= err) )
            {
                break;
            }
            else
            {
                Abort(GetLastError(), "WaitForMultipleObjects");
            }
        }
#pragma warning(default:4296)
    }

    for ( i = 0; i < gcThreads; i++ )
        CloseHandle(rh[i]);

    if ( gfVerbose )
        fprintf(stderr,
                "Concurrent %s of [%d..%d] ==> %d/sec\n",
                rpszOperation[op],
                0,
                gcObjects - 1,
                (gcObjects * 1000) / (GetTickCount() - start));
}

VOID CheckQueryResult(
    QueryOption opt,
    int         iteration,
    int         cExpected,
    int         cFound,
    int         *pcPrevFound)
{
    char buf[256];

    switch ( opt )
    {
    case QOPT_DONTCARE:

        break;

    case QOPT_ASCENDING:

        if ( 0 != iteration )
        {
            if ( cFound < *pcPrevFound )
            {
                sprintf(
                    buf,
                    "Query(%s), Restriction(%d), cFound(%d), cPrevFound(%d)",
                    rpszQueryOption[opt],
                    iteration,
                    cFound,
                    *pcPrevFound);

                Abort(1, buf);
            }
        }

        break;

    case QOPT_DESCENDING:

        if ( 0 != iteration )
        {
            if ( *pcPrevFound < cFound )
            {
                sprintf(
                    buf,
                    "Query(%s), Restriction(%d), cFound(%d), cPrevFound(%d)",
                    rpszQueryOption[opt],
                    iteration,
                    cFound,
                    *pcPrevFound);

                Abort(1, buf);
            }
        }

        break;

    case QOPT_EXACTMATCH:

        if ( cExpected != cFound )
        {
            sprintf(
                buf,
                "Query(%s), Restriction(%d), cFound(%d), cExpected(%d)",
                rpszQueryOption[opt],
                iteration,
                cFound,
                cExpected);

            Abort(1, buf);
        }

        break;

    default:

        Abort(1, "Invalid case value");
        break;

    }

    *pcPrevFound = cFound;
}

/*
    // Check or modify the results depending on what the query options
    // are.  Due to a lack of knowledge about how parallel queries run,
    // we can't assert much about the return count if ASCENDING or DESCENDING
    // was specified.  In those cases, we do a worst case analysis and
    // return the min or max respectively.  I.e. in the ASCENDING case,
    // return cFound value from the query which found the least objects.
    // Thus a caller who makes successive QueryObjectsMultiThreaded calls
    // can call CheckQueryResult(ASCENDING) on each returned *pcFound value
    // and expect the check to succeed as long as in each pass, one of
    // the parallel queries found equal or more objects than on the previous
    // pass.  Ditto, but inversed, for DESCENDING.

    switch ( opt )
    {
        case QOPT_DONTCARE:
        case QOPT_ASCENDING:

            *pcFound = rargs[0].cFound;

            for ( i = 1; i < cRest; i++ )
                if ( rargs[i].cFound < *pcFound )
                    *pcFound = rargs[i].cFound;

            break;

        case QOPT_DESCENDING:

            *pcFound = rargs[0].cFound;

            for ( i = 1; i < cRest; i++ )
                if ( rargs[i].cFound > *pcFound )
                    *pcFound = rargs[i].cFound;

            break;

        case QOPT_EXACTMATCH:

            for ( i = 0; i < cRest; i++ )
            {
                if ( cExpected != rargs[i].cFound )
                {
                    sprintf(buf,
                            "Restriction(%d) - expected(%d) != found(%d)",
                            i, cExpected, rargs[i].cFound);

                    int j = 0;
                    int k = 0;

                    if ( 0 != awid )
                    {
                        while ( j < cExpected && k < rargs[i].cFound )
                        {
                            if ( awid[j] < rargs[i].awid[k] )
                            {
                                if ( fVerbose )
                                    printf( "Restriction(%d) - missing wid %u\n", i, awid[j] );

                                while ( awid[j] < rargs[i].awid[k] && j < cExpected )
                                    j++;
                            }

                            else if ( awid[j] > rargs[i].awid[k] )
                            {
                                if ( fVerbose )
                                    printf( "Restriction(%d) - extra wid %u\n", i, rargs[i].awid[k] );

                                while ( awid[j] > rargs[i].awid[k] && k < rargs[i].cFound )
                                    k++;
                            }

                            else
                            {
                                j++;
                                k++;
                            }
                        }

                    }

                    Abort(E_FAIL, buf);
                }
            }

            *pcFound = rargs[0].cFound;
            break;

        default:

            Abort(E_FAIL, "Invalid case value");
            break;
    }

    for ( i = 0; i < cRest; i++ )
        delete [] rargs[i].awid;

    if ( fVerbose )
    {
        printf("Concurrent queries(%d) of %d objects ==> %d seconds\n",
               cRest,
               *pcFound,
               (GetTickCount() - start) / 1000);
        fflush(stdout);
    }
*/

NTSTATUS
DsWaitUntilDelayedStartupIsDone(void);

ULONG __stdcall _DsaTest(
    VOID *pUnused)
{
    NTSTATUS            status;
    DWORD               cb;
    SECURITY_DESCRIPTOR *pSD;
    DWORD               arg;
    int                 scan;
    CHAR                ch;

    fprintf(stderr,
            "DsaTest waiting for delayed startup to complete ...\n");

    // DsWaitUntilDelayedStartupIsDone() only works once
    // hevDelyedStartupDone is initialized somewhere in the
    // DsaExeStartRoutine() path.  We can't spin/wait till this
    // event is initialized so we just wait 5 seconds assuming
    // that all of ntdsa's events get initialized early on.

    Sleep(5000);

    status = DsWaitUntilDelayedStartupIsDone();

    if ( !NT_SUCCESS(status) )
        Abort(status, "DsWaitUntilDelayedStartupIsDone");

    fprintf(stderr,
            "DsaTest starting ...\n");

    // Initialize miscellaneous globals.

    if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(
            L"O:AOG:DAD:(A;;RPWPCCDCLCSWRCWDWOGA;;;S-1-0-0)",
            SDDL_REVISION_1,
            &pSD,
            &cb)) {
        status = GetLastError();
        Abort(status, "ConvertStringSecurityDescriptorToSecurityDescriptorW");
    }

    if ( cb > sizeof(DefaultSDBuffer) )
        Abort(1, "DefaultSDBuffer overflow");

    DefaultSDVal.valLen = cb;
    memcpy(DefaultSDBuffer, pSD, cb);
    LocalFree(pSD);

    cb = sizeof(TestRootBuffer);

    status = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                                  &cb,
                                  gTestRoot);

    if ( !NT_SUCCESS(status) )
        Abort(status, "GetConfigurationName");

    InitCommarg(&DefaultCommArg);

    // See if caller likes the setup.

    fprintf(stdout, "*********************************\n");
    fprintf(stdout, "*                               *\n");
    fprintf(stdout, "* In-process DSA/JET Excerciser *\n");
    fprintf(stdout, "*                               *\n");
    fprintf(stdout, "*********************************\n\n");


    while ( TRUE )
    {
        fprintf(stdout, "All input is numeric decimal\n");

        // gfVerbose

        fprintf(stdout, "Verbose[%d] ", gfVerbose);
        fflush(stdout);
        scan = fscanf(stdin, "%d", &arg);

        if ( (0 != scan) && (EOF != scan) )
            gfVerbose = arg;

        // gcObjects

        fprintf(stdout, "Objects[%d] ", gcObjects);
        fflush(stdout);
        scan = fscanf(stdin, "%d", &arg);

        if ( (0 != scan) && (EOF != scan) )
            gcObjects = arg;

        // gcThreads

        fprintf(stdout, "Threads[%d] ", gcThreads);
        fflush(stdout);
        scan = fscanf(stdin, "%d", &arg);

        if ( (0 != scan) && (EOF != scan) )
            gcThreads = arg;

        // gcDelaySec

        fprintf(stdout,
                "Background transaction duration (secs) [%d] ",
                gcDelaySec);
        fflush(stdout);
        scan = fscanf(stdin, "%d", &arg);

        if ( (0 != scan) && (EOF != scan) )
        gcDelaySec = arg;

        fprintf(stdout,
                "Testing with: verbose(%d) objects(%d) threads(%d) delay(%d)\n",
                gfVerbose,
                gcObjects,
                gcThreads,
                gcDelaySec);

        fprintf(stdout, "Are these parameters OK [y/n] ? ");
        fflush(stdout);
        ch = (CHAR)getchar();

        while ( ('y' != ch) && ('Y' != ch) && ('n' != ch) && ('N' != ch) )
            ch = (CHAR)getchar();

        if ( ('y' == ch) || ('Y' == ch) )
            break;
    }

    // Run the test.

    DoObjectsMultiThreaded(OP_ADD, gcDelaySec);
    DoObjectsMultiThreaded(OP_DELETE, gcDelaySec);

    fprintf(stderr,
            "DsaTest passed!\n");

    return(0);
}

void DsaTest(void)
{
    HANDLE  h;
    DWORD   id;

    // Start async thread so we don't block DSA startup.

    h = CreateThread(NULL,                  // security attrs
                     0,                     // default stack size
                     _DsaTest,              // start routine
                     NULL,                  // start argument
                     0,                     // creation flags
                     &id);                  // thread id

    if ( h )
    {
        CloseHandle(h);
        return;
    }

    Abort(GetLastError(), "CreateThread");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\anchor.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       anchor.h
//
//--------------------------------------------------------------------------

/*-------------------------------------------------------------------------*/
/* These structures hold a cache of Knowledge used by the DSA */

/*The Cross reference points to an NC in another DSA (pCR).  The actual
  reference is stored as a child of this DSA with an arbitrary name Obj.
  Obj is variable length and extends contiguously below this structure.
  Elements in this linked-list are ordered by descending name size.
*/

typedef struct CROSS_REF_LIST{
   struct CROSS_REF_LIST *pPrevCR;           /* Prev Cross-Reference      */
   struct CROSS_REF_LIST *pNextCR;           /* Next Cross-Reference      */
   CROSS_REF CR;                             /* This Cross-Reference      */
}CROSS_REF_LIST;

/*Avoid the read of the NC head by caching the ATT_SUB_REFS attribute
  from the NC heads. Used in dsamain\src\mdsearch.c
*/
typedef struct _SUBREF_LIST SUBREF_LIST, *PSUBREF_LIST;
struct _SUBREF_LIST{
   PSUBREF_LIST pNextSubref;    /* Next entry on list         */
   PDSNAME      pDSName;        /* DSName struct              */
   DWORD        cAncestors;     /* entries in pAncestors      */
   DWORD        *pAncestors;    /* DNTs of DSName's ancestors */
};

typedef struct _COUNTED_LIST {
    ULONG          cNCs;        /* Number of NC DNTs in the pList */
    DWORD *        pList;       /* array of DNTs */
} COUNTED_LIST;

/* This structure contains Knowledge information used by this DSA */

typedef struct{
   CRITICAL_SECTION    CSUpdate;       /*To serialize updates to gAnchor*/
   // Try not to use the catalog pointers directly! 
   // They must be accessed using helper functions: see NCLEnumerator* in mddit.c
   // This ensures that global lists are visible through the filter of
   // transactional changes (i.e. added and deleted entries are visible)
   NAMING_CONTEXT_LIST *pMasterNC;     /*Master  NC list                 */
   NAMING_CONTEXT_LIST *pReplicaNC;    /*Replica NC list                 */
   CROSS_REF_LIST      *pCRL;          /*Cross Reference List           */
   DSNAME              *pDMD;          /*The name of DMD Object aka Schema NC DN */
   ULONG               ulDNTDMD;       /*DNT of the DMD Object          */
   DSNAME              *pLDAPDMD;      /*The name of LDAP DMD Object    */
   ULONG               ulDntLdapDmd;   /*The DNT of LDAP DMD Object     */
   SYNTAX_DISTNAME_STRING
                       *pDSA;          /*The name/address of this DSA   */
   DSNAME              *pDSADN;        /*The name of this DSA           */
   DSNAME              *pSiteDN;       /*The site name for this DSA     */
   DSNAME              *pDomainDN;     /*The name of this Domain for    */
                                       /* this DSA                      */
   ULONG               ulDNTDomain;    /* DNT of the Domain For this DSA*/
   DSNAME              *pRootDomainDN; /* Root Domain DN                */
   DSNAME              *pConfigDN;     /* Configuration container DN    */
   DSNAME              *pExchangeDN;   /* Exchange Config container DN  */
   ULONG               ulDNTConfig;    /*DNT of the Config container    */
   DSNAME              *pPartitionsDN; /* Partitions container DN       */
   DSNAME              *pDsSvcConfigDN;/* enterprise-wide DS config DN  */
   MTX_ADDR *pmtxDSA;                  /*MS tx addr for this DSA. RPC   */
                                       /* name format                   */
   unsigned            uDomainsInForest;/* count of domains in forest   */
   BOOL  fAmGC;                        /* is this DSA a global catalog? */
   BOOL  fAmVirtualGC;                 /* only one domain in enterprise */
   BOOL  fDisableInboundRepl;          /* is inbound repl disabled?     */
   BOOL  fDisableOutboundRepl;         /* is outbound repl disabled?    */
   ULONG *pAncestors;                  /*DNTs of local DSA's ancestors +*/
                                       /* local DSA                     */
   ULONG AncestorsNum;                 /* Number of DNTs in above array */
   ULONG *pUnDeletableDNTs;            /* Array of DNTs whose deletion  */
                                       /* the DSA should refuse         */
   unsigned UnDeletableNum;            /* Number of DNTs in above array */

/* Array of DNT ancestors of undeletable objects. The DSA will also refuse
   the deletion of these ancestors. Kept separate so we can rebuild the list
   of ancestors when objects in the undeletable list are reparented */

   ULONG *pUnDelAncDNTs;               /* Undeletable ancestors DNTs    */
   unsigned UnDelAncNum;               /* Number of DNTs in above array */
   ULONG ulDefaultLanguage;            /*Default locale for random      */
                                       /* localized index (see jetnsp.c)*/
   ULONG ulNumLangs;                   /* The number of locales this ds */
                                       /* supports.                     */
   ULONG *pulLangs;                    /* buffer of DWORDS holding lang */
                                       /* ids supported by this DSA. 1st*/
                                       /* dword is size of buffer in    */
                                       /* dwords.  Note that the buffer */
                                       /* is allocated and filled       */
                                       /* dynamically, so ulNumLangs is */
                                       /* always <= pulLangs[0]         */
   GLOBALDNREADCACHE *MainGlobal_DNReadCache;   // The DNReadCache.
   WCHAR * pwszRootDomainDnsName;      /*DNS name of the root of the    */
                                       /*  enterprise DNS tree          */
   PWCHAR  pwszHostDnsName;            /*DNS Name of the machine        */
   PDSNAME pInfraStructureDN;          /* DN of the domain              */
                                       /*         infrastructure object */
   DRS_EXTENSIONS_INT *                /*DRS extensions info for the    */
       pLocalDRSExtensions;            /* local DSA                     */
   
   PSECURITY_DESCRIPTOR pDomainSD;     /* The Security Descriptor on our*/
                                       /* domain head.                  */

/*Avoid the read of the NC head by caching the ATT_SUB_REFS attribute
  from the NC heads. Used in dsamain\src\mdsearch.c.
*/
   BOOL         fDomainSubrefList; /* pDomainSubrefList is valid    */
   ULONG        cDomainSubrefList; /* #entries on pDomainSubrefList */
   PSUBREF_LIST pDomainSubrefList; /* cached ATT_SUB_REFS           */
   BOOL         fAmRootDomainDC;   /* true if this DSA is in root domain */

   ULONG        SiteOptions;       /* value of the options on the ntds */
                                   /* site settings object */
/*
   Keep the domain policy regarding max password age and LockoutDuration
   in order to speed up the computation of the attribute msDsUserAccount-
   ControlComputed
*/
   LARGE_INTEGER MaxPasswordAge;   /* Maximum password age in the domain */
   LARGE_INTEGER LockoutDuration;  /* Lockout duration in the domain     */

   LONG    ForestBehaviorVersion;  /*the behavior version of the forest*/
   LONG    DomainBehaviorVersion;  /*the behavior version of the domain*/

   UUID *  pCurrInvocationID;      /* the invocation ID to be used by new */
                                   /* threads; don't ref directly, use    */
                                   /* pTHS->InvocationID                  */
   BOOL     fSchemaUpgradeInProgress;       /* schupgr is running */
   COUNTED_LIST * pNoGCSearchList;  /* This is the list of NCs that     */
                                    /* should not be searched on a GC   */
                                    /* based search.  This data structure*/
                                    /* consists of two parts, an array  */
                                    /* of elements and an count. This   */
                                    /* is done so the updates to both   */
                                    /* count and array, can be done     */
                                    /* simultaneously.  This pointer    */
                                    /* however maybe NULL if there is   */
                                    /* no NC that should not be searched*/
                                    /* , which is actually the expected */
                                    /* case */
   /* NULL-terminated array of allowed DNS suffixes */
   /* see mdupdate:DNSHostNameValueCheck */
   PWCHAR   *allowedDNSSuffixes;
   PWCHAR   additionalRootDomainName;  // the previous root domain name (before the rename of the domain)
}DSA_ANCHOR;


extern DSA_ANCHOR gAnchor;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\checkacl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       checkacl.h
//
//--------------------------------------------------------------------------

typedef enum AclError
{
    AclErrorNone = 0,
    AclErrorGetSecurityDescriptorDacl,
    AclErrorGetAce,
    AclErrorParentAceNotFoundInChild,
    AclErrorAlgorithmError,
    AclErrorInheritedAceOnChildNotOnParent
} AclError;

typedef ULONG (*AclPrintFunc)(char *, ...);

typedef void (*LookupGuidFunc)(GUID *pg, CHAR **ppName, CHAR **ppLabel, BOOL *pfIsClass);

typedef CHAR * (*LookupSidFunc)(PSID pSID);

DWORD
CheckAclInheritance(
    PSECURITY_DESCRIPTOR pParentSD,             // IN
    PSECURITY_DESCRIPTOR pChildSD,              // IN
    GUID                *pChildClassGuid,       // IN
    AclPrintFunc        pfn,                    // IN
    BOOL                fContinueOnError,       // IN
    BOOL                fVerbose,               // IN
    DWORD               *pdwLastError);         // OUT

void
DumpAcl(
    PACL    pAcl,           // IN
    AclPrintFunc pfn,       // IN
    LookupGuidFunc pfnguid, // IN
    LookupSidFunc  pfnsid   // IN
    );

void
DumpAclHeader(
    PACL    pAcl,           // IN
    AclPrintFunc pfn);      // IN

void
DumpSD(
    SECURITY_DESCRIPTOR *pSD,        // IN
    AclPrintFunc        pfn,         // IN 
    LookupGuidFunc      pfnguid,     // IN
    LookupSidFunc       pfnsid);     // IN

void DumpSDHeader (SECURITY_DESCRIPTOR *pSD,        // IN
                   AclPrintFunc        pfn);        // IN


void DumpGUID (GUID *Guid,           // IN
               AclPrintFunc pfn);    // IN

void DumpSID (PSID pSID,             // IN
              AclPrintFunc pfn);     // IN

void
DumpAce(
    ACE_HEADER     *pAce,   // IN
    AclPrintFunc   pfn,     // IN
    LookupGuidFunc pfnguid, // IN
    LookupSidFunc  pfnsid); // IN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\dirty.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dirty.h
//
//--------------------------------------------------------------------------

/* Temporary header for quick map of DN string - DN struct */

extern USHORT APIENTRY
    DNStrStruct(UCHAR *pInStr,int inStrSize
                      ,SYNTAX_DISTNAME *pN, USHORT *pLen);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\draconstr.h ===
#ifndef _DRACONSTR_H_
#define _DRACONSTR_H_

DWORD
draGetLdapReplInfo(IN THSTATE * pTHS,
                   IN ATTRTYP attrId, 
                   IN DSNAME * pObjDSName,
                   IN DWORD dwBaseIndex,     
                   IN PDWORD pdwNumRequested, OPTIONAL
                   IN BOOL fXML,
                   OUT ATTR * pAttr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\exe\main.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       main.c
//
//--------------------------------------------------------------------------

/*++

    main.c

    This contains the main routine which starts up the directory service
    when the DS is run as either a sepeate service or as a command line appli-
    cation

    Revision History

    5/14/96 Murlis Created
    6/10/96 Moved from dsamain\src

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <ntdsa.h>

void
Usage(char *name)
{
    fprintf(stderr, "Usage: %s <-d> <-e> <-i> <-noconsole> <-nosec>\nThis exe starts ntdsa.dll.\n", name);
    fprintf(stderr, "-d has some effect in the internals of the DS\n");
    fprintf(stderr, "-e makes this executable print out the status of the initialization\n");
    fprintf(stderr, "-t puts this exe in an endless init'ing and uninit'ing the ds based on user input\n");
    fprintf(stderr, "-x runs DsaTest\n");
    fprintf(stderr, "-noconsole stops double printing when run in ntsd.exe\n");
    fprintf(stderr, "-nosec disables most security checks\n");
    fprintf(stderr, "\n$%s$%d$\n", name, !0);
}

// Declare the prototype for DsaExeStartRoutine
int __cdecl DsaExeStartRoutine(int argc, char *argv[]);

// Declare DsaTest
void DsaTest(void);

NTSTATUS DsInitialize(ULONG,PDS_INSTALL_PARAM,PDS_INSTALL_RESULT);
NTSTATUS DsUninitialize(BOOL);

/*++

    Main function for running the DS as a 
    seperate executable

--*/
int __cdecl main(int argc, char *argv[])
{
    DWORD WinError = ERROR_BAD_ENVIRONMENT;
    NTSTATUS NtStatus;
    BOOL PrintStatus = FALSE;
    int err;
    int arg = 1;

    // Parse command-line arguments.
    while(arg < argc)
    {

        if (0 == _stricmp(argv[arg], "-e"))
        {
            PrintStatus = TRUE;
        } else if (0 == _stricmp(argv[arg], "-noconsole"))
        {
            ;
        } else if (0 == _stricmp(argv[arg], "-nosec"))
        {
            ;
        }
        else if (0 == _stricmp(argv[arg], "-d"))
        {
            ;
        }
        else if (0 == _stricmp(argv[arg], "-t"))
        {

            BOOLEAN fExit=FALSE;

            while (!fExit) {

                char ch;

                printf("Press return to do first time initialization\n");
                printf("Make sure the correct files are in place\n");
                printf("Or press q to quit:\n");

                ch = (CHAR)getchar();
                while ( ch != '\n' && ch != 'q') 
                    ch = (CHAR)getchar();
                
                if (ch == 'q') {
                    fExit = TRUE;
                    continue;
                }

            
                NtStatus = DsInitialize(FALSE,NULL,NULL);
                if (!NT_SUCCESS(NtStatus)) {
                    fprintf(stderr, "DsInitialize returned 0x%x\n", NtStatus);
                    exit(-1);
                }
    
                printf("Press any key to uninitialize:\n");
    
                ch = (CHAR)getchar();
                if (ch != '\n') printf("\n");
    
                NtStatus = DsUninitialize(FALSE);
                if (!NT_SUCCESS(NtStatus)) {
                    fprintf(stderr, "DsUninitialize returned 0x%x\n", NtStatus);
                    exit(-1);
                }

            }

            exit(0);
            
        }
        else if (0 == _stricmp(argv[arg], "-x"))
        {
            // Test runs asynchronously.
            DsaTest();
        }
        else {
            Usage(argv[0]);
            exit(0);
        }

        arg++;
    }

        err = DsaExeStartRoutine(argc, argv);

    if ( !err ) {
        WinError = ERROR_SUCCESS;
    }
    
    //
    //  This fprintf is for processes who might have
    //  created this executable and want to see the return
    //  value.
    //
    if ( PrintStatus ) {
        fprintf(stderr, "\n$%s$%d$\n", argv[0], WinError);
    }
 
    return err;

} /* main */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\draerror.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       draerror.h
//
//--------------------------------------------------------------------------

ULONG RepErrorFromPTHS(THSTATE *pTHS);

void DraErrOutOfMem(void);

#define RAISE_DRAERR_INCONSISTENT( Arg ) \
DraErrInconsistent( Arg, ((FILENO << 16) | __LINE__) )

void DraErrInconsistent( DWORD Arg, DWORD Id );

void DraErrBusy(void);

void DraErrMissingAtt(DSNAME *pDN, ATTRTYP type);

void DraErrCannotFindNC(DSNAME *pNC);

void DraErrInappropriateInstanceType(DSNAME *pDN, ATTRTYP type);

void DraErrMissingObject(THSTATE *pTHS, ENTINF *pEnt);

void
DraLogGetChangesFailure(
    IN DSNAME *pNC,
    IN LPWSTR pszDsaAddr,
    IN DWORD ret,
    IN DWORD ulExtendedOp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\dominfo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       domainfo.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Headers for the domain information routines used in cracking names.

Author:

    Dave Straube (davestr) 8/26/96

Revision History:

--*/

#ifndef __DOMINFO_H__
#define __DOMINFO_H__

DWORD
InitializeDomainInformation(void);

DWORD
ExtractDnsReferral(
    IN  WCHAR   **ppDnsDomain);

VOID
NormalizeDnsName(
    IN  WCHAR   *pDnsName);

DWORD
DnsDomainFromFqdnObject(
    IN  WCHAR   *pFqdnObject,
    OUT ULONG   *pDNT,
    OUT WCHAR   **ppDnsDomain);

DWORD
DnsDomainFromDSName(
    IN  DSNAME  *pDSName,
    OUT WCHAR   **ppDnsDomain);

// Secure versions of routines which read the database and perform
// all security checks against the SDs of the objects read.

DWORD
FqdnDomainFromDnsDomainSecure(
    IN  WCHAR   *pDnsDomain,
    OUT DSNAME  **ppFqdnDomain);

DWORD
DownlevelDomainFromDnsDomainSecure(
    IN  THSTATE *pTHS,
    IN  WCHAR   *pDnsDomain,
    OUT WCHAR   **ppDownlevelDomain);

DWORD
DnsDomainFromDownlevelDomainSecure(
    IN  WCHAR   *pDownlevelDomain,
    OUT WCHAR   **ppDnsDomain);

DWORD
ReadCrossRefPropertySecure(
    IN  DSNAME  *pNC,
    IN  ATTRTYP attr,
    IN  DWORD   dwRequiredFlags,
    OUT WCHAR   **ppAttrVal);

// Non-secure versions of routines which read the cross ref list and
// do not perform any SD validation.

DWORD
FqdnNcFromDnsNcNonSecure(
    IN  WCHAR   *pDnsDomain,
    IN  ULONG   crFlags,
    OUT DSNAME  **ppFqdnDomain);

DWORD
DownlevelDomainFromDnsDomainNonSecure(
    IN  THSTATE *pTHS,
    IN  WCHAR   *pDnsDomain,
    OUT WCHAR   **ppDownlevelDomain);

DWORD
DnsDomainFromDownlevelDomainNonSecure(
    IN  WCHAR   *pDownlevelDomain,
    OUT WCHAR   **ppDnsDomain);

DWORD
ReadCrossRefPropertyNonSecure(
    IN  DSNAME  *pNC,
    IN  ATTRTYP attr,
    IN  DWORD   dwRequiredFlags,
    OUT WCHAR   **ppAttrVal);

/*
Defines to the non-secure versions of various routines.  Here's the reasoning.

-----Original Message-----
From:       Dave Straube 
Sent:       Wednesday, December 16, 1998 8:53 AM
To:         Praerit Garg; Peter Brundrett
Subject:    security correctness question

The name cracking implementation evaluates security everywhere - even in 
places you might not think.  For example, if you crack ntdev\davestr or 
ntdev.microsoft.com/foo/bar/itg/davestr, then we (securely) query the 
Partitions container to find a cross-ref for a domain whose domain name 
is either ntdev or ntdev.microsoft.com.

It turns out we have all the domains and their alternate names cached in 
memory.  So I could eliminate one search by matching against the cache - 
which is clearly much faster than N reads in Jet.  The problem is that 
this bypasses security in that you may not have rights to see the cross-ref 
for the domain, but I would end up cracking the name anyway.  Here's the 
options as I see them:

1) Do nothing.  Pro is that we have 100% access control on all aspects of 
name cracking.  Con is that we do lots of extra searches and performance 
suffers.  (We actually see this in the perf group's traces which is what 
brought about this line of thinking in the first place.)

2) Use the cache as is.  Pro is that we optimize performance big time.  
Con is that there is no access control with respect to cracking the domain 
component of downlevel or canonical names.  In the case of downlevel names, 
one could argue that there wasn't any security on the visibility/existence 
of a domain name anyway, so why have it now.  And if that's OK for downlevel 
domain names, why not for DNS domain names too?  So the real issue here is 
whether we feel that domain names are something which need to be guarded or 
whether they are just public knowledge.  Note that if you decide they are 
public knowledge then that does not imply we should ACL the Partitions 
container weakly.  ACLs on the Partitions container implement administrative 
control which is distinct from what's public knowledge or not.

3) Improve the cache to hold not only the netbios and DNS domain name values, 
but also have it hold those values' SDs, and check the SD when we have a match.
Pro is that this should get us back to 100% access control as in the original 
case.  Con 1 is that this runs marginally slower due to the access check - but 
at least the disk accesses are elminiated.  Con 2 is that this is more work to 
code and at present I can only detect originating SD writes.  I'd have to 
invent a totally new mechanism to flush the cache when the SDs on the cross 
refs change due to SD propagation.  This is non-trivial and I would most likely
not recommend it even for RTM.

*** Reply from PraeritG ***

I think assuming domain names to be public knowledge is reasonable given that 
they are published in DNS database anyway -- which are considered public 
information stores...  aren't we recommending that enterprises name their 
domains based on alloted DNS names anyway?

So I like option 2 -- least work, better performance.  I don't think it 
compromises security because the stores are still acl'd.
*/

// Uncomment following line to return to secure domain name implementation.
// #define SECURE_DOMAIN_NAMES

#ifdef SECURE_DOMAIN_NAMES

#define FqdnDomainFromDnsDomain(pDnsDomain, ppFqdnDomain) \
    FqdnDomainFromDnsDomainSecure(pDnsDomain, ppFqdnDomain)

#define DownlevelDomainFromDnsDomain(pTHS, pDnsDomain, ppDownlevelDomain) \
    DownlevelDomainFromDnsDomainSecure(pTHS, pDnsDomain, ppDownlevelDomain)

#define DnsDomainFromDownlevelDomain(pDownlevelDomain, ppDnsDomain) \
    DnsDomainFromDownlevelDomainSecure(pDownlevelDomain, ppDnsDomain)

#define ReadCrossRefProperty(pNC, attr, dwRequiredFlags, ppAttrVal) \
    ReadCrossRefPropertySecure(pNC, attr, dwRequiredFlags, ppAttrVal)

#else

#define FqdnNcFromDnsNc(pDnsDomain, crFlags, ppFqdnDomain) \
    FqdnNcFromDnsNcNonSecure(pDnsDomain, crFlags, ppFqdnDomain)

#define DownlevelDomainFromDnsDomain(pTHS, pDnsDomain, ppDownlevelDomain) \
    DownlevelDomainFromDnsDomainNonSecure(pTHS, pDnsDomain, ppDownlevelDomain)

#define DnsDomainFromDownlevelDomain(pDownlevelDomain, ppDnsDomain) \
    DnsDomainFromDownlevelDomainNonSecure(pDownlevelDomain, ppDnsDomain)

#define ReadCrossRefProperty(pNC, attr, dwRequiredFlags, ppAttrVal) \
    ReadCrossRefPropertyNonSecure(pNC, attr, dwRequiredFlags, ppAttrVal)

#endif

#endif // __DOMINFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\direrr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       direrr.h
//
//--------------------------------------------------------------------------

/***********************************************
 *
 * This file is a relic.
 *
 * !!! DO NOT ADD ANY NEW LINES TO THIS FILE !!!
 *
 * DIRERRs are now #defined to be errors out of winerror.h.  If you
 * need a new error, define it in %_NTROOT%\windows\nlsmsg\winerror.w in the
 * windows project and rebuild winerror.h. (build from %_NTROOT%\windows)
 * (a faster way is to "nmake -f makefil0" from windows)
 *
 * Over time, we should find users of DIRERRs and change them to use the DS_ERRs
 * defined in winerror.h.  When a DIRERR is no longer used, it should be removed
 * from this file.  Eventually, this file should become empty.
 *
 * Part of this process is to look in winerror.w to see if the explanatory text
 * for the error matches what you are really trying to report.  If it does,
 * change the use of DIRERR_foo to DS_ERR_foo.  If the text doesn't match,
 * create a new DS_ERR_bar, or find one already in the file that is appropriate.
 * When you remove the last use of DIRERR_foo, remove the definition from this
 * file. 
 *
 * Explicitly, this file could be removed, but for now it is used to keep track
 * of which errors we've looked at to make sure we are setting an appropriate
 * error.
 *
 * Once again, do not add lines to this file, and avoid using DIRERRs at all.
 * Use DS_ERRs
 *
 * April 17, 1998
 *   DS_ERR_* were renamed to ERROR_DS_* in winerror.h
 *
 */
#define DIRERR_ADD_REPLICA_INHIBITED      ERROR_DS_ADD_REPLICA_INHIBITED      
#define DIRERR_ALIASED_OBJ_MISSING        ERROR_DS_ALIASED_OBJ_MISSING        
#define DIRERR_ALIAS_POINTS_TO_ALIAS      ERROR_DS_ALIAS_POINTS_TO_ALIAS      
#define DIRERR_ATTRIBUTE_OWNED_BY_SAM     ERROR_DS_ATTRIBUTE_OWNED_BY_SAM     
#define DIRERR_ATT_ALREADY_EXISTS         ERROR_DS_ATT_ALREADY_EXISTS         
#define DIRERR_ATT_IS_NOT_ON_OBJ          ERROR_DS_ATT_IS_NOT_ON_OBJ          
#define DIRERR_ATT_NOT_DEF_IN_SCHEMA      ERROR_DS_ATT_NOT_DEF_IN_SCHEMA      
#define DIRERR_ATT_SCHEMA_REQ_ID          ERROR_DS_ATT_SCHEMA_REQ_ID          
#define DIRERR_ATT_SCHEMA_REQ_SYNTAX      ERROR_DS_ATT_SCHEMA_REQ_SYNTAX      
#define DIRERR_ATT_VAL_ALREADY_EXISTS     ERROR_DS_ATT_VAL_ALREADY_EXISTS     
#define DIRERR_AUX_CLS_TEST_FAIL          ERROR_DS_AUX_CLS_TEST_FAIL          
#define DIRERR_BAD_ATT_SCHEMA_SYNTAX      ERROR_DS_BAD_ATT_SCHEMA_SYNTAX      
#define DIRERR_BAD_ATT_SYNTAX             ERROR_DS_INVALID_ATTRIBUTE_SYNTAX
#define DIRERR_BAD_HIERARCHY_FILE         ERROR_DS_BAD_HIERARCHY_FILE         
#define DIRERR_BAD_INSTANCE_TYPE          ERROR_DS_BAD_INSTANCE_TYPE          
#define DIRERR_BAD_NAME_SYNTAX            ERROR_DS_BAD_NAME_SYNTAX            
#define DIRERR_BAD_RDN_ATT_ID_SYNTAX      ERROR_DS_BAD_RDN_ATT_ID_SYNTAX      
#define DIRERR_BUILD_HIERARCHY_TABLE_FAILED ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED 
#define DIRERR_CANT_ADD_ATT_VALUES        ERROR_DS_CANT_ADD_ATT_VALUES        
#define DIRERR_CANT_ADD_SYSTEM_ONLY       ERROR_DS_CANT_ADD_SYSTEM_ONLY       
#define DIRERR_CANT_CACHE_ATT             ERROR_DS_CANT_CACHE_ATT             
#define DIRERR_CANT_CACHE_CLASS           ERROR_DS_CANT_CACHE_CLASS           
#define DIRERR_CANT_DELETE                ERROR_DS_CANT_DELETE                
#define DIRERR_CANT_DELETE_DSA_OBJ        ERROR_DS_CANT_DELETE_DSA_OBJ        
#define DIRERR_CANT_DEL_MASTER_CROSSREF   ERROR_DS_CANT_DEL_MASTER_CROSSREF   
#define DIRERR_CANT_DEREF_ALIAS           ERROR_DS_CANT_DEREF_ALIAS           
#define DIRERR_CANT_FIND_DSA_OBJ          ERROR_DS_CANT_FIND_DSA_OBJ          
#define DIRERR_CANT_FIND_EXPECTED_NC      ERROR_DS_CANT_FIND_EXPECTED_NC      
#define DIRERR_CANT_FIND_NC_IN_CACHE      ERROR_DS_CANT_FIND_NC_IN_CACHE      
#define DIRERR_CANT_MIX_MASTER_AND_REPS   ERROR_DS_CANT_MIX_MASTER_AND_REPS   
#define DIRERR_CANT_MOD_SYSTEM_ONLY       ERROR_DS_CANT_MOD_SYSTEM_ONLY       
#define DIRERR_CANT_REMOVE_ATT_CACHE      ERROR_DS_CANT_REMOVE_ATT_CACHE      
#define DIRERR_CANT_REMOVE_CLASS_CACHE    ERROR_DS_CANT_REMOVE_CLASS_CACHE    
#define DIRERR_CANT_REM_MISSING_ATT       ERROR_DS_CANT_REM_MISSING_ATT       
#define DIRERR_CANT_REM_MISSING_ATT_VAL   ERROR_DS_CANT_REM_MISSING_ATT_VAL   
#define DIRERR_CANT_REPLACE_HIDDEN_REC    ERROR_DS_CANT_REPLACE_HIDDEN_REC    
#define DIRERR_CANT_RETRIEVE_CHILD        ERROR_DS_CANT_RETRIEVE_CHILD        
#define DIRERR_CANT_RETRIEVE_DN           ERROR_DS_CANT_RETRIEVE_DN           
#define DIRERR_CANT_RETRIEVE_INSTANCE     ERROR_DS_CANT_RETRIEVE_INSTANCE     
#define DIRERR_CHILDREN_EXIST             ERROR_DS_CHILDREN_EXIST             
#define DIRERR_CLASS_MUST_BE_CONCRETE     ERROR_DS_CLASS_MUST_BE_CONCRETE     
#define DIRERR_CLASS_NOT_DSA              ERROR_DS_CLASS_NOT_DSA              
#define DIRERR_CODE_INCONSISTENCY         ERROR_DS_CODE_INCONSISTENCY         
#define DIRERR_CONFIG_PARAM_MISSING       ERROR_DS_CONFIG_PARAM_MISSING       
#define DIRERR_COULDNT_CONTACT_FSMO       ERROR_DS_COULDNT_CONTACT_FSMO       
#define DIRERR_COUNTING_AB_INDICES_FAILED ERROR_DS_COUNTING_AB_INDICES_FAILED 
#define DIRERR_CROSS_NC_DN_RENAME         ERROR_DS_CROSS_NC_DN_RENAME         
#define DIRERR_CROSS_REF_EXISTS           ERROR_DS_CROSS_REF_EXISTS
#define DIRERR_DATABASE_ERROR             ERROR_DS_DATABASE_ERROR             
#define DIRERR_DRA_SCHEMA_MISMATCH        ERROR_DS_DRA_SCHEMA_MISMATCH        
#define DIRERR_DSA_MUST_BE_INT_MASTER     ERROR_DS_DSA_MUST_BE_INT_MASTER     
#define DIRERR_DUP_LDAP_DISPLAY_NAME      ERROR_DS_DUP_LDAP_DISPLAY_NAME      
#define DIRERR_DUP_MAPI_ID                ERROR_DS_DUP_MAPI_ID                
#define DIRERR_DUP_OID                    ERROR_DS_DUP_OID                    
#define DIRERR_DUP_RDN                    ERROR_DS_DUP_RDN                    
#define DIRERR_DUP_SCHEMA_ID_GUID         ERROR_DS_DUP_SCHEMA_ID_GUID         
#define DIRERR_EXISTS_IN_AUX_CLS          ERROR_DS_EXISTS_IN_AUX_CLS          
#define DIRERR_EXISTS_IN_MAY_HAVE         ERROR_DS_EXISTS_IN_MAY_HAVE         
#define DIRERR_EXISTS_IN_MUST_HAVE        ERROR_DS_EXISTS_IN_MUST_HAVE        
#define DIRERR_EXISTS_IN_POSS_SUP         ERROR_DS_EXISTS_IN_POSS_SUP         
#define DIRERR_EXISTS_IN_SUB_CLS          ERROR_DS_EXISTS_IN_SUB_CLS          
#define DIRERR_GCVERIFY_ERROR             ERROR_DS_GCVERIFY_ERROR             
#define DIRERR_GENERIC_ERROR              ERROR_DS_GENERIC_ERROR              
#define DIRERR_GOVERNSID_MISSING          ERROR_DS_GOVERNSID_MISSING          
#define DIRERR_HIERARCHY_TABLE_MALLOC_FAILED ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED 
#define DIRERR_ILLEGAL_MOD_OPERATION      ERROR_DS_ILLEGAL_MOD_OPERATION      
#define DIRERR_ILLEGAL_SUPERIOR           ERROR_DS_ILLEGAL_SUPERIOR           
#define DIRERR_INSUFF_ACCESS_RIGHTS       ERROR_DS_INSUFF_ACCESS_RIGHTS       
#define DIRERR_INTERNAL_FAILURE           ERROR_DS_INTERNAL_FAILURE           
#define DIRERR_INVALID_DMD                ERROR_DS_INVALID_DMD                
#define DIRERR_INVALID_ROLE_OWNER         ERROR_DS_INVALID_ROLE_OWNER         
#define DIRERR_MASTERDSA_REQUIRED         ERROR_DS_MASTERDSA_REQUIRED         
#define DIRERR_MAX_OBJ_SIZE_EXCEEDED      ERROR_DS_MAX_OBJ_SIZE_EXCEEDED      
#define DIRERR_MISSING_EXPECTED_ATT       ERROR_DS_MISSING_EXPECTED_ATT       
#define DIRERR_MISSING_REQUIRED_ATT       ERROR_DS_MISSING_REQUIRED_ATT       
#define DIRERR_MISSING_SUPREF             ERROR_DS_MISSING_SUPREF             
#define DIRERR_NAME_REFERENCE_INVALID     ERROR_DS_NAME_REFERENCE_INVALID     
#define DIRERR_NAME_TOO_LONG              ERROR_DS_NAME_TOO_LONG              
#define DIRERR_NAME_TOO_MANY_PARTS        ERROR_DS_NAME_TOO_MANY_PARTS        
#define DIRERR_NAME_TYPE_UNKNOWN          ERROR_DS_NAME_TYPE_UNKNOWN          
#define DIRERR_NAME_UNPARSEABLE           ERROR_DS_NAME_UNPARSEABLE           
#define DIRERR_NAME_VALUE_TOO_LONG        ERROR_DS_NAME_VALUE_TOO_LONG        
#define DIRERR_NCNAME_MISSING_CR_REF      ERROR_DS_NCNAME_MISSING_CR_REF      
#define DIRERR_NCNAME_MUST_BE_NC          ERROR_DS_NCNAME_MUST_BE_NC          
#define DIRERR_NONEXISTENT_MAY_HAVE       ERROR_DS_NONEXISTENT_MAY_HAVE       
#define DIRERR_NONEXISTENT_MUST_HAVE      ERROR_DS_NONEXISTENT_MUST_HAVE      
#define DIRERR_NONEXISTENT_POSS_SUP       ERROR_DS_NONEXISTENT_POSS_SUP       
#define DIRERR_NOTIFY_FILTER_TOO_COMPLEX  ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX  
#define DIRERR_NOT_AN_OBJECT              ERROR_DS_NOT_AN_OBJECT              
#define DIRERR_NOT_ON_BACKLINK            ERROR_DS_NOT_ON_BACKLINK            
#define DIRERR_NO_CHAINED_EVAL            ERROR_DS_NO_CHAINED_EVAL            
#define DIRERR_NO_CHAINING 	          ERROR_DS_NO_CHAINING 	          
#define DIRERR_NO_CROSSREF_FOR_NC         ERROR_DS_NO_CROSSREF_FOR_NC         
#define DIRERR_NO_DELETED_NAME            ERROR_DS_NO_DELETED_NAME            
#define DIRERR_NO_PARENT_OBJECT           ERROR_DS_NO_PARENT_OBJECT           
#define DIRERR_NO_RDN_DEFINED_IN_SCHEMA   ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA   
#define DIRERR_NO_REQUESTED_ATTS_FOUND    ERROR_DS_NO_REQUESTED_ATTS_FOUND    
#define DIRERR_OBJECT_CLASS_REQUIRED      ERROR_DS_OBJECT_CLASS_REQUIRED      
#define DIRERR_OBJ_CLASS_NOT_DEFINED      ERROR_DS_OBJ_CLASS_NOT_DEFINED      
#define DIRERR_OBJ_CLASS_NOT_SUBCLASS     ERROR_DS_OBJ_CLASS_NOT_SUBCLASS     
#define DIRERR_OBJ_GUID_EXISTS            ERROR_DS_OBJ_GUID_EXISTS            
#define DIRERR_OBJ_NOT_FOUND              ERROR_DS_OBJ_NOT_FOUND              
#define DIRERR_OBJ_STRING_NAME_EXISTS     ERROR_DS_OBJ_STRING_NAME_EXISTS     
#define DIRERR_OBJ_TOO_LARGE              ERROR_DS_OBJ_TOO_LARGE              
#define DIRERR_OUT_OF_SCOPE               ERROR_DS_OUT_OF_SCOPE               
#define DIRERR_PARENT_IS_AN_ALIAS         ERROR_DS_PARENT_IS_AN_ALIAS         
#define DIRERR_RANGE_CONSTRAINT           ERROR_DS_RANGE_CONSTRAINT           
#define DIRERR_RDN_DOESNT_MATCH_SCHEMA    ERROR_DS_RDN_DOESNT_MATCH_SCHEMA    
#define DIRERR_RECALCSCHEMA_FAILED        ERROR_DS_RECALCSCHEMA_FAILED        
#define DIRERR_REFERRAL                   ERROR_DS_REFERRAL                   
#define DIRERR_REPLICATOR_ONLY            ERROR_DS_REPLICATOR_ONLY            
#define DIRERR_ROOT_CANT_BE_SUBREF        ERROR_DS_ROOT_CANT_BE_SUBREF        
#define DIRERR_ROOT_MUST_BE_NC            ERROR_DS_ROOT_MUST_BE_NC            
#define DIRERR_ROOT_REQUIRES_CLASS_TOP    ERROR_DS_ROOT_REQUIRES_CLASS_TOP    
#define DIRERR_SCHEMA_ALLOC_FAILED        ERROR_DS_SCHEMA_ALLOC_FAILED        
#define DIRERR_SCHEMA_NOT_LOADED          ERROR_DS_SCHEMA_NOT_LOADED          
#define DIRERR_SECURITY_CHECKING_ERROR    ERROR_DS_SECURITY_CHECKING_ERROR    
#define DIRERR_SECURITY_ILLEGAL_MODIFY    ERROR_DS_SECURITY_ILLEGAL_MODIFY    
#define DIRERR_SEC_DESC_INVALID           ERROR_DS_SEC_DESC_INVALID
#define DIRERR_SEC_DESC_TOO_SHORT         ERROR_DS_SEC_DESC_TOO_SHORT         
#define DIRERR_SEMANTIC_ATT_TEST          ERROR_DS_SEMANTIC_ATT_TEST          
#define DIRERR_SHUTTING_DOWN              ERROR_DS_SHUTTING_DOWN
#define DIRERR_SINGLE_VALUE_CONSTRAINT    ERROR_DS_SINGLE_VALUE_CONSTRAINT    
#define DIRERR_SUBREF_MUST_HAVE_PARENT    ERROR_DS_SUBREF_MUST_HAVE_PARENT    
#define DIRERR_SUBTREE_NOTIFY_NOT_NC_HEAD ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD 
#define DIRERR_SUB_CLS_TEST_FAIL          ERROR_DS_SUB_CLS_TEST_FAIL          
#define DIRERR_SYNTAX_MISMATCH            ERROR_DS_SYNTAX_MISMATCH
#define DIRERR_TREE_DELETE_NOT_FINISHED   ERROR_DS_TREE_DELETE_NOT_FINISHED   
#define DIRERR_UNKNOWN_ERROR              ERROR_DS_UNKNOWN_ERROR              
#define DIRERR_UNKNOWN_OPERATION          ERROR_DS_UNKNOWN_OPERATION          
#define DIRERR_USER_BUFFER_TO_SMALL       ERROR_DS_USER_BUFFER_TO_SMALL       
#define DIRERR_EPOCH_MISMATCH             ERROR_DS_EPOCH_MISMATCH
#define DIRERR_SRC_NAME_MISMATCH          ERROR_DS_SRC_NAME_MISMATCH
#define DIRERR_SRC_AND_DST_NC_IDENTICAL   ERROR_DS_SRC_AND_DST_NC_IDENTICAL
#define DIRERR_DST_NC_MISMATCH            ERROR_DS_DST_NC_MISMATCH
#define DIRERR_NOT_AUTHORITIVE_FOR_DST_NC ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC
#define DIRERR_SRC_GUID_MISMATCH          ERROR_DS_SRC_GUID_MISMATCH
#define DIRERR_CANT_MOVE_DELETED_OBJECT   ERROR_DS_CANT_MOVE_DELETED_OBJECT
#define DIRERR_PDC_OPERATION_IN_PROGRESS  ERROR_DS_PDC_OPERATION_IN_PROGRESS
#define DIRERR_CROSS_DOMAIN_CLEANUP_REQD  ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD

// These translations take care of old DS_ERR_ references

#define DS_ERR_NO_PARENT_OBJECT           ERROR_DS_NO_PARENT_OBJECT
#define DS_ERR_INTERNAL_FAILURE           ERROR_DS_INTERNAL_FAILURE
#define DS_ERR_DRA_INTERNAL_ERROR         ERROR_DS_DRA_INTERNAL_ERROR
#define DS_ERR_BAD_NAME_SYNTAX            ERROR_DS_BAD_NAME_SYNTAX
#define DS_ERR_REFERRAL                   ERROR_DS_REFERRAL
#define DS_ERR_UNKNOWN_ERROR              ERROR_DS_UNKNOWN_ERROR
#define DS_ERR_UNKNOWN_OPERATION          ERROR_DS_UNKNOWN_OPERATION
#define DS_ERR_CANT_DELETE_DSA_OBJ        ERROR_DS_CANT_DELETE_DSA_OBJ
#define DS_ERR_CANT_FIND_DSA_OBJ          ERROR_DS_CANT_FIND_DSA_OBJ
#define DS_ERR_ILLEGAL_MOD_OPERATION      ERROR_DS_ILLEGAL_MOD_OPERATION
#define DS_ERR_NO_CROSSREF_FOR_NC         ERROR_DS_NO_CROSSREF_FOR_NC
#define DS_ERR_CANT_DELETE                ERROR_DS_CANT_DELETE
#define DS_ERR_DRA_CONNECTION_FAILED      ERROR_DS_DRA_CONNECTION_FAILED
#define DS_ERR_DRA_EXTN_CONNECTION_FAILED ERROR_DS_DRA_EXTN_CONNECTION_FAILED
#define DS_ERR_ATT_NOT_DEF_IN_SCHEMA      ERROR_DS_ATT_NOT_DEF_IN_SCHEMA
#define DS_ERR_ATT_NOT_DEF_FOR_CLASS      ERROR_DS_ATT_NOT_DEF_FOR_CLASS
#define DS_ERR_ADMIN_LIMIT_EXCEEDED       ERROR_DS_ADMIN_LIMIT_EXCEEDED
#define DS_ERR_OBJ_NOT_FOUND              ERROR_DS_OBJ_NOT_FOUND
#define DS_ERR_DUP_LINK_ID                ERROR_DS_DUP_LINK_ID
#define DS_ERR_REFUSING_FSMO_ROLES        ERROR_DS_REFUSING_FSMO_ROLES
#define DS_ERR_INVALID_ROLE_OWNER         ERROR_DS_INVALID_ROLE_OWNER
#define DS_ERR_MISSING_FSMO_SETTINGS      ERROR_DS_MISSING_FSMO_SETTINGS
#define DS_ERR_NOT_AN_OBJECT              ERROR_DS_NOT_AN_OBJECT

/* Don't add anything here.  See note at top. */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\cracknam.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       cracknam.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module defines various name cracking APIs.

Author:

    Dave Straube (davestr) 8/17/96

Revision History:

    Dave Straube (davestr) 10/20/97
        Removed friendly names and added UPN format.

--*/

#ifndef __CRACKNAM_H__
#define __CRACKNAM_H__

#include <ntdsapip.h>           // #defines for CrackNamesEx

typedef struct 
{
    DWORD   dwFlags;
    ULONG   CodePage;
    ULONG   LocaleId;
    DWORD   formatOffered;
    DWORD   status;
    DSNAME  *pDSName;
    WCHAR   *pDnsDomain;
    WCHAR   *pFormattedName;

} CrackedName;

extern
BOOL
CrackNameStatusSuccess(
    DWORD       status);

extern 
WCHAR *
Tokenize(
    WCHAR       *pString,
    WCHAR       *separators,
    BOOL        *pfSeparatorFound,
    WCHAR       **ppNext);

extern
BOOL
Is_DS_FQDN_1779_NAME(
    WCHAR       *pName,
    CrackedName *pCrackedName);

extern
BOOL
Is_DS_NT4_ACCOUNT_NAME(
    WCHAR       *pName,
    CrackedName *pCrackedName);

extern
BOOL
Is_DS_DISPLAY_NAME(
    WCHAR       *pName,
    CrackedName *pCrackedName);

extern
BOOL
Is_DS_NT4_ACCOUNT_NAME_SANS_DOMAIN(
    WCHAR       *pName,
    CrackedName *pCrackedName);

extern
BOOL
Is_DS_DS_ALT_SECURITY_IDENTITIES_NAME(
    WCHAR       *pName,
    CrackedName *pCrackedName);

extern
BOOL
Is_DS_UNIQUE_ID_NAME(
    WCHAR       *pName,
    CrackedName *pCrackedName);

extern
BOOL 
Is_DS_CANONICAL_NAME(
    WCHAR       *pName,
    CrackedName *pCrackedName);

extern
BOOL
Is_DS_UNIVERSAL_PRINCIPAL_NAME(
    WCHAR       *pName,
    CrackedName *pCrackedName);

extern
BOOL
Is_DS_CANONICAL_NAME_EX(
    WCHAR       *pName,
    CrackedName *pCrackedName);

extern
VOID
DSNAME_To_DS_FQDN_1779_NAME(
    CrackedName *pCrackedName);

extern
VOID
DSNAME_To_DS_NT4_ACCOUNT_NAME(
    CrackedName *pCrackedName);

extern
VOID
DSNAME_To_DS_DISPLAY_NAME(
    CrackedName *pCrackedName);

extern
VOID
DSNAME_To_DS_UNIQUE_ID_NAME(
    CrackedName *pCrackedName);

extern
VOID
DSNAME_To_CANONICAL(
    THSTATE     *pTHS,
    CrackedName *pCrackedName, 
    WCHAR       **ppLastSlash);

//extern
//VOID
//DSNAME_To_DS_CANONICAL_NAME(
//    CrackedName *pCrackedName);

#define DSNAME_To_DS_CANONICAL_NAME(p) DSNAME_To_CANONICAL(pTHS, p, NULL)

extern
VOID
DSNAME_To_DS_UNIVERSAL_PRINCIPAL_NAME(
    CrackedName *pCrackedName);

extern
VOID
DSNAME_To_DS_CANONICAL_NAME_EX(
    THSTATE     *pTHS,
    CrackedName *pCrackedName);

extern
VOID
CrackNames(
    DWORD       dwFlags,
    ULONG       codePage,
    ULONG       localeId,
    DWORD       formatOffered,
    DWORD       formatDesired,
    DWORD       cNames,
    WCHAR       **rpNames,
    DWORD       *pcNamesOut,
    CrackedName **prCrackedNames);

extern
VOID
ProcessFPOsExTransaction(
    DWORD       formatDesired,
    DWORD       cNames,
    CrackedName *rNames);

extern DWORD LdapMaxQueryDuration;

#define SetCrackSearchLimits(pCommArg)                          \
    (pCommArg)->StartTick = GetTickCount();                     \
    (pCommArg)->DeltaTick = 1000 * LdapMaxQueryDuration;        \
    (pCommArg)->Svccntl.localScope = TRUE;


#endif // __CRACKNAM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\dramail.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       dramail.h
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Declarations for asynchronous replication.

DETAILS:

CREATED:

REVISION HISTORY:

--*/

// Message types (enumeration).
#define MRM_REQUPDATE            1
#define MRM_UPDATEREPLICA        2

// Message attributes (bit flags).
#define MRM_MSG_SIGNED              (0x20000000)
#define MRM_MSG_SEALED              (0x40000000)
#define MRM_MSG_COMPRESSED          (0x80000000)

// This is the bogus buffer that we pass to MEsEncodeFixedBufferHandleCreate,
// The buffer is bogus in that we only pass this pointer when we create the
// handle, but we reset the buffer pointer in the handle before use.
#define BOGUS_BUFFER_SIZE 16
extern char grgbBogusBuffer[BOGUS_BUFFER_SIZE];

// These are the mail message version numbers. If we get a request in that
// has a protocol version number different than ours, the request is
// incompatible and must be discarded.

// Change the ProtocolVersionCaller field when the MAIL_REP_MSG changes or
// when the semantics of replication change in an incompatible way between
// destination and source.
// Change the dwMsgVersion field when the structure version changes.

#define CURRENT_PROTOCOL_VERSION 11

/* Turn off the warning about the zero-sized array. */
#pragma warning (disable: 4200)

// MAIL_REP_MSG structures contain a message blob (an RPC-marchalled buffer),
// which currently is optionally compressed, always signed, and sometimes
// sealed.
typedef struct _MAIL_REP_MSG {
    ULONG CompressionVersionCaller; // COMP_ZIP or COMP_NONE
    ULONG ProtocolVersionCaller;    // Must be CURRENT_PROTOCOL_VERSION or
                                    //   message is thrown out

    ULONG cbDataOffset;             // Offset (from beginning of MAIL_REP_MSG)
                                    //   of data field.  Present to allow
                                    //   additional fields to be added later
                                    //   (at the current data offset) without
                                    //   breaking backward compatibility.
                                    //   0 if data field not present.
    ULONG cbDataSize;               // Size of message data
    ULONG cbUncompressedDataSize;   // Size of message data before compression
    ULONG cbUnsignedDataSize;       // Size of message data before encryption

    DWORD dwMsgType;                // MRM_UPDATEREPLICA or MRM_REQUPDATE,
                                    //   possibly ORed with MRM_MSG_COMPRESSED,
                                    //   MRM_MSG_SIGNED, and/or MRM_MSG_SEALED
    DWORD dwMsgVersion;             // Version of above message structure

    ///////////////////////////////////////////////////////////////////////////
    //
    // Fields between here and message data added after Win2k.
    //

    DWORD dwExtFlags;               // Extension flags.  Consumed by Whistler
                                    //   Beta 1 and Beta 2 DCs.  Superseded by
                                    //   the full DRS_EXTENSIONS structure on
                                    //   >= Whistler Beta 3 DCs.
                                    //   0 if extensions not present.
    DWORD cbExtOffset;              // Offset (from beginning of MAIL_REP_MSG)
                                    //   of DRS_EXTENSIONS structure field.
                                    //   Set only by >= Whistler Beta 3 DCs.  If
                                    //   zero, use dwExtFlags (a subset of the
                                    //   DRS_EXTENSIONS structure) instead.

    char  rgbDontRefDirectly[];     // DON'T REFERENCE THIS FIELD DIRECTLY --
                                    // USE THE MACROS BELOW!
                                    //
                                    // Variable length data, including:
                                    //
                                    // DRS_EXTENSIONS (optional, at offset
                                    //   cbExtOffset from beginning of message)
                                    //
                                    // Message Data (which may be compressed
                                    //   and/or encrypted, depending on high
                                    //   bits of dwMsgType, at offset
                                    //   cbDataOffset from beginning of message)
                                    //
                                    //   WARNING! This field must be 8 byte
                                    //   aligned in order for
                                    //   MesDecodeBufferCreate to work!
                                    //
                                    //   MESSAGE DATA MUST BE THE LAST
                                    //   VARIABLE-LENGTH FIELD!
} MAIL_REP_MSG;

#if DBG
#define ASSERTION_FAILURE(x, y, z)  DoAssert((x), (y), (z))
#else
#define ASSERTION_FAILURE(x, y, z)  0
#endif

// Get the size of the message header (i.e., the fixed fields preceding the
// variable-length portion of the message).  Not valid for messages that
// don't contain message data.
#define MAIL_REP_MSG_HEADER_SIZE(x) \
    ((x)->cbDataOffset \
     ? ((x)->cbDataOffset > offsetof(MAIL_REP_MSG, cbExtOffset) + sizeof((x)->cbExtOffset) \
        ? (x)->cbExtOffset \
        : (x)->cbDataOffset) \
     : (ASSERTION_FAILURE("cbDataOffset != 0", __FILE__, __LINE__), (DWORD) -1))

// Known header sizes.
#define MAIL_REP_MSG_CURRENT_HEADER_SIZE offsetof(MAIL_REP_MSG, rgbDontRefDirectly)
#define MAIL_REP_MSG_W2K_HEADER_SIZE     offsetof(MAIL_REP_MSG, dwExtFlags)

// Get the byte offset of the DRS_EXTENSIONS structure in the message, or 0 if
// none.
#define MAIL_REP_MSG_DRS_EXT_OFFSET(x) \
    ((x)->cbDataOffset \
     ? ((x)->cbDataOffset > offsetof(MAIL_REP_MSG, cbExtOffset) + sizeof(DWORD) \
        ? (x)->cbExtOffset \
        : 0) \
     : (ASSERTION_FAILURE("cbDataOffset != 0", __FILE__, __LINE__), (DWORD) 0))

// Get a pointer to the DRS_EXTENSIONS structure in the message, or NULL if
// none.
#define MAIL_REP_MSG_DRS_EXT(x) \
    (MAIL_REP_MSG_DRS_EXT_OFFSET(x) \
        ? (DRS_EXTENSIONS *) ((BYTE *) (x) + MAIL_REP_MSG_DRS_EXT_OFFSET(x)) \
        : NULL)

// Get a pointer to the message data in the message, or NULL if none.
#define MAIL_REP_MSG_DATA(x) \
    ((x)->cbDataOffset \
        ? ((BYTE *) (x) + (x)->cbDataOffset) \
        : NULL)

// Get the total size of the message (header and all variable-length data).
// Not valid for messages that don't contain message data.
#define MAIL_REP_MSG_SIZE(x) \
    ((x)->cbDataOffset \
     ? ((x)->cbDataOffset + (x)->cbDataSize) \
     : (ASSERTION_FAILURE("cbDataOffset != 0", __FILE__, __LINE__), (DWORD) -1))

// Is the message a native header only (no variable-length fields)?
#define MAIL_REP_MSG_IS_NATIVE_HEADER_ONLY(x) \
    ((0 == (x)->cbDataOffset) && (0 == (x)->cbExtOffset))

// Is the message a native message?  Must contain at least one variable-length
// field.
#define MAIL_REP_MSG_IS_NATIVE(x) \
    ((x)->cbExtOffset \
     ? ((MAIL_REP_MSG_CURRENT_HEADER_SIZE == (x)->cbExtOffset) \
        && (ROUND_UP_COUNT(MAIL_REP_MSG_CURRENT_HEADER_SIZE \
                           + DrsExtSize(MAIL_REP_MSG_DRS_EXT(x)), \
                           MAIL_REP_MSG_DATA_ALIGN) \
            == (x)->cbDataOffset)) \
     : (MAIL_REP_MSG_CURRENT_HEADER_SIZE == (x)->cbDataOffset))

// Variable length fields should be at 8-byte offsets from the beginning of the
// message.
#define MAIL_REP_MSG_EXT_ALIGN  sizeof(LONGLONG)
#define MAIL_REP_MSG_DATA_ALIGN sizeof(LONGLONG)

/* Turn back on the warning about the zero-sized array. */
#pragma warning (default: 4200)

typedef HANDLE DRA_CERT_HANDLE;

ULONG
DRAEnsureMailRunning();

void
draSendMailRequest(
    IN  THSTATE *               pTHS,
    IN  DSNAME *                pNC,
    IN  DWORD                   ulOptions,
    IN  REPLICA_LINK *          pRepLink,
    IN  UPTODATE_VECTOR *       pUpToDateVec,
    IN  PARTIAL_ATTR_VECTOR *   pPartialAttrSet,
    IN  PARTIAL_ATTR_VECTOR *   pPartialAttrSetEx
    );

ULONG __stdcall
MailReceiveThread(
    IN  void *  pvIgnored
    );

void
draSignMessage(
    IN  THSTATE      *  pTHS,
    IN  MAIL_REP_MSG *  pUnsignedMailRepMsg,
    OUT MAIL_REP_MSG ** ppSignedMailRepMsg
    );

void
draVerifyMessageSignature(
    IN  THSTATE      *      pTHS,
    IN  MAIL_REP_MSG *      pSignedMailRepMsg,
    IN  CHAR         *      pbData,
    OUT MAIL_REP_MSG **     ppUnsignedMailRepMsg,
    OUT DRA_CERT_HANDLE *   phSignerCert         OPTIONAL
    );

void
draEncryptAndSignMessage(
    IN  THSTATE      *  pTHS,
    IN  MAIL_REP_MSG *  pUnsealedMailRepMsg,
    IN  DRA_CERT_HANDLE hRecipientCert,
    OUT MAIL_REP_MSG ** ppSealedMailRepMsg
    );

void
draDecryptAndVerifyMessageSignature(
    IN  THSTATE      *      pTHS,
    IN  MAIL_REP_MSG *      pSealedMailRepMsg,
    IN  CHAR         *      pbData,
    OUT MAIL_REP_MSG **     ppUnsealedMailRepMsg,
    OUT DRA_CERT_HANDLE *   phSignerCert         OPTIONAL
    );

MTX_ADDR *
draGetTransportAddress(
    IN OUT  DBPOS *   pDB,
    IN      DSNAME *  pDSADN,
    IN      ATTRTYP   attAddress
    );

void
draFreeCertHandle(
    IN  DRA_CERT_HANDLE     hCert
    );

ULONG
draCompressBlobDispatch(
    OUT BYTE               *pCompBuff,
    IN  ULONG               CompSize,
    IN  DRS_EXTENSIONS     *pExt,          OPTIONAL
    IN  BYTE               *pUncompBuff,
    IN  ULONG               UncompSize,
    OUT DRS_COMP_ALG_TYPE  *CompressionAlg
    );

ULONG
draUncompressBlobDispatch(
    IN  THSTATE *   pTHS,
    IN  DRS_COMP_ALG_TYPE CompressionAlg,
    OUT BYTE *      pUncompBuff,
    IN  ULONG       cbUncomp,
    IN  BYTE *      pCompBuff,
    IN  ULONG       cbCompBuff
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\drarpc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       drarpc.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Contains all structures and prototypes for ds rpc, rpctests, and test hooks.

Author:

    Greg Johnson (gregjohn)   

Revision History:

    Created     <03/03/01>  gregjohn

--*/

#ifndef _DRARPC_H_
#define _DRARPC_H_

#if DBG
#define RPC_TEST(x,y) RpcTest((x), (y)) 
#else 
#define RPC_TEST(x,y)  
#endif 

typedef enum _RPCCALL {
    MIN_RPCCALL = 0,
    IDL_DRSBIND,
    IDL_DRSADDENTRY,
    IDL_DRSADDSIDHISTORY,
    IDL_DRSCRACKNAMES,
    IDL_DRSDOMAINCONTROLLERINFO,
    IDL_DRSEXECUTEKCC,
    IDL_DRSGETMEMBERSHIPS,
    IDL_DRSGETMEMBERSHIPS2,
    IDL_DRSGETNCCHANGES,
    IDL_DRSGETNT4CHANGELOG,
    IDL_DRSGETREPLINFO,
    IDL_DRSINHERITSECURITYIDENTITY,
    IDL_DRSINTERDOMAINMOVE,
    IDL_DRSREMOVEDSDOMAIN,
    IDL_DRSREMOVEDSSERVER,
    IDL_DRSREPLICAADD,
    IDL_DRSREPLICADEL,
    IDL_DRSREPLICAMODIFY,
    IDL_DRSREPLICASYNC,
    IDL_DRSUPDATEREFS,
    IDL_DRSVERIFYNAMES,
    IDL_DRSWRITESPN,
    IDL_DRSUNBIND,
    IDL_DRSREPLICAVERIFYOBJECTS,
    IDL_DRSGETOBJECTEXISTENCE,
    // add new calls here
    // IDL_DRSExecuteScript ??	

    MAX_RPCCALL
} RPCCALL;

VOID drsReferenceContext(
    IN DRS_HANDLE hDrs,
    IN RPCCALL    rpcCall
    );

VOID
drsDereferenceContext(
    IN DRS_HANDLE hDrs,
    IN RPCCALL rpcCall
    );

#if DBG
typedef struct _BARRIER {
    BOOL fBarrierInit;
    HANDLE heBarrierInUse;
    BOOL fBarrierInUse;
    HANDLE heBarrier;
    CRITICAL_SECTION csBarrier; 
    ULONG  ulTimeout;
    ULONG  ulThreads;
    ULONG  ulCount;
} BARRIER;

typedef struct _RPCTIME_INFO {
    BOOL  fEnabled;
    ULONG ulRunTimeSecs;
} RPCTIME_INFO;

typedef struct _RPCSYNC_INFO {
    BOOL  fEnabled;
    ULONG ulNumThreads;
} RPCSYNC_INFO;

void
BarrierInit(
    IN BARRIER * pbarUse,
    IN ULONG    ulThreads,
    IN ULONG    ulTimeout
    );

void
BarrierSync(
    IN BARRIER * pbarUse
    );

void
RpcTimeSet(
    IN ULONG IPAddr, 
    IN RPCCALL rpcCall, 
    IN ULONG ulRunTimeSecs
    );

void
RpcTimeReset(
    void
    );

void
RpcSyncSet(
    IN ULONG IPAddr, 
    IN RPCCALL rpcCall
    ); 

void
RpcSyncReset(
    void
    );

void RpcTest(
    ULONG IPAddr, 
    RPCCALL rpcCall
    ); 

RPCCALL 
GetRpcCallA(
    LPSTR pszDsa
    );

ULONG
GetIPAddrA(
    LPSTR pszDSA
    );

#endif /* DBG */

#endif /* _DRARPC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\drauptod.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       drauptod.h
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Manages the per-NC up-to-date vectors, which record the highest originating
    writes we've seen from a set of DSAs.  This vector, in turn, is used in
    GetNCChanges() calls to filter out redundant property changes before they
    hit the wire.

DETAILS:

CREATED:

    08/27/96   Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#ifndef DRAUPTOD_H_INCLUDED
#define DRAUPTOD_H_INCLUDED

#define UTODVEC_fUpdateLocalCursor  ( 1 )

VOID
UpToDateVec_Read(
    IN  DBPOS *             pDB,
    IN  SYNTAX_INTEGER      InstanceType,
    IN  DWORD               dwFlags,
    IN  USN                 usnLocalDsa,
    OUT UPTODATE_VECTOR **  pputodvec
    );

VOID
UpToDateVec_Improve(
    IN      DBPOS *             pDB,
    IN      UUID *              puuidDsaRemote,
    IN      USN_VECTOR *        pusnvec,
    IN OUT  UPTODATE_VECTOR *   putodvecRemote
    );

VOID
UpToDateVec_Replace(
    IN      DBPOS *             pDB,
    IN      UUID *              pRemoteDsa,
    IN      USN_VECTOR *        pUsnVec,
    IN OUT  UPTODATE_VECTOR *   pUTD
    );

BOOL
UpToDateVec_IsChangeNeeded(
    IN  UPTODATE_VECTOR *   pUpToDateVec,
    IN  UUID *              puuidDsaOrig,
    IN  USN                 usnOrig
    );

BOOL
UpToDateVec_GetCursorUSN(
    IN  UPTODATE_VECTOR *   putodvec,
    IN  UUID *              puuidDsaOrig,
    OUT USN *               pusnCursorUSN
    );

UPTODATE_VECTOR *
UpToDateVec_Convert(
    IN  THSTATE *           pTHS,
    IN  DWORD               dwOutVersion,
    IN  UPTODATE_VECTOR *   pIn             OPTIONAL
    );

void
UpToDateVec_AddTimestamp(
    IN      UUID *                      puuidInvocId,
    IN      DSTIME                      timeToAdd,
    IN OUT  UPTODATE_VECTOR *           pUTD
    );

VOID
UpToDateVec_Merge(
    IN THSTATE *           pTHS,
    IN UPTODATE_VECTOR *   pUTD1,
    IN UPTODATE_VECTOR *   pUTD2,
    OUT UPTODATE_VECTOR ** ppUTDMerge
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\drametap.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       drametap.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module defines PRIVATE per-property meta-data parsing,
    and updating functions. Some drameta.c functions cannot be
    exported outside dra, thus (for instance due to REQ_MSG_UPDATE
    declaration incompatibilities) we would define them here for
    exclusive dra usage
    Implementation is still defined in drameta.c

Author:

     eyals

Revision History:

    when            who             what
    3/28/00         eyals           created


--*/

#ifndef _DRAMETAP_H_
#define _DRAMETAP_H_

//
// Note: REQ_UPDATE_MSG is unavailable for ntdsa/src sources,
// thus the prototype cannot be declared in drameta.h
//
void
ReplFilterPropsToShip(
    THSTATE                     *pTHS,
    DSNAME                      *pDSName,
    ATTRTYP                     rdnType,
    BOOL                        fIsSubRef,
    USN                         usnPropWaterMark,
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec,
    PROPERTY_META_DATA_VECTOR   *pMetaData,
    ATTRBLOCK                   *pAttrBlock,
    BOOL                        fFilterGroupMember,
    DRS_MSG_GETCHGREQ_NATIVE *  pMsgIn
    );

BOOL
ReplFilterGCAttr(
    ATTRTYP                     attid,               // [in]
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec,    // [in]
    DRS_MSG_GETCHGREQ_NATIVE *  pMsgIn,              // [in]
    BOOL                        fFilterGroupMember,  // [in]
    BOOL*                       pfIgnoreWatermarks   // [out]
    );




#endif // _DRAMETAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\drautil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       drautil.h
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

DETAILS:

CREATED:

REVISION HISTORY:

--*/

struct _MAIL_REP_MSG;
struct _DRS_MSG_GETCHGREQ_V8;
struct _DRS_MSG_GETCHGREPLY_V6;
union _DRS_MSG_GETCHGREQ;
union _DRS_MSG_GETCHGREPLY;

// Critical section for NC sync data.

extern CRITICAL_SECTION csNCSyncData;

extern BOOL gfInitSyncsFinished;

// The following data is private to drautil.c, but is exposed for the
// benefit of the debugging extensions.

// Structure for sources for initial sync.
// Variable length structure, always null terminated

typedef struct _NCSYNCSOURCE {
    struct _NCSYNCSOURCE *pNextSource;
    BOOL fCompletedSrc;
    ULONG ulResult;
    ULONG cchDSA; // Count, in chars, of name, not incl term
    WCHAR szDSA[1]; // always terminated
} NCSYNCSOURCE;

// Structure for initial sync accounting.

typedef struct _NCSYNCDATA {
    ULONG ulUntriedSrcs;        // Unattempted sync sources
    ULONG ulTriedSrcs;          // Attempted sources
    ULONG ulLastTriedSrcs;      // Previous number attempted sources
    ULONG ulReplicaFlags;       // Writable?
    BOOL fSyncedFromOneSrc;           // Set when full synced from one source
    BOOL fNCComplete;           // NC is synced or we've tried all sources.
    struct _NCSYNCDATA *pNCSDNext;
    NCSYNCSOURCE *pFirstSource;
    DSNAME NC;
} NCSYNCDATA;

extern NCSYNCDATA *gpNCSDFirst; // Head of NC sync data list

extern ULONG gulNCUnsynced; // Count of NCs that have not been synced since startup
extern ULONG gulNCUnsyncedWrite; // Count of unsynced writable
extern ULONG gulNCUnsyncedReadOnly; // Count of unsynced readonly

// The way we know if we got through the promotion process once
extern BOOL gfWasPreviouslyPromotedGC;

// To track GC promotion progress
extern CRITICAL_SECTION csGCState;

extern ULONG gulRestoreCount; // Count of restores done on this DC so far

extern BOOL gfJustRestored;

// This is the reference to the global setting which indicates whether
// this feature is enabled. Code that checks this flag should be synchonized
// for the thread's lifetime. We check the global once when a thread
// state is created. Feature code should check the cached view of this
// flag in the thread state and not use this one.
extern BOOL gfLinkedValueReplication;

// Pause after we determine we have no unsynced NCs before we recheck.

#define ADMIN_UPDATE_CHECK_PAUSE_SECS   180

// These are the states of the GC Partition Occupancy Variable
// values
#define GC_OCCUPANCY_MIN                            0
#define GC_OCCUPANCY_NO_REQUIREMENT                 0
#define GC_OCCUPANCY_ATLEAST_ONE_ADDED              1
#define GC_OCCUPANCY_ATLEAST_ONE_SYNCED             2
#define GC_OCCUPANCY_ALL_IN_SITE_ADDED              3
#define GC_OCCUPANCY_ALL_IN_SITE_SYNCED             4
#define GC_OCCUPANCY_ALL_IN_FOREST_ADDED            5
#define GC_OCCUPANCY_ALL_IN_FOREST_SYNCED           6
#define GC_OCCUPANCY_MAX                            6
#define GC_OCCUPANCY_DEFAULT                        GC_OCCUPANCY_MAX

// First delay after GC promotion (if enabled)
// This should be enough for the KCC to run, and for all the GCs
// in the Enterprise to replicate in
#define GC_PROMOTION_INITIAL_CHECK_PERIOD_MINS (5)
#define GC_PROMOTION_INITIAL_CHECK_PERIOD_SECS \
(GC_PROMOTION_INITIAL_CHECK_PERIOD_MINS*60)

// Period of checking that initial syncing is making progress
#if DBG
#define SYNC_CHECK_PERIOD_SECS  (10*60)         // 5 minutes
#else
#define SYNC_CHECK_PERIOD_SECS  (30*60)         // 30 minutes
#endif

// Client context structure.  Is allocated and initialized on bind, a pointer
// to which is passed in on subsequent calls, and is freed on unbind.
typedef struct _DRS_CLIENT_CONTEXT
{
    LIST_ENTRY          ListEntry;
    LONG                lReferenceCount;  // number of users of this struct		
    UUID                uuidDsa;          // objectGuid of client's ntdsDSA obj
    SESSION_KEY         sessionKey;       // keys for RPC session encryption
    union {
        BYTE            rgbExtRemote[ CURR_MAX_DRS_EXT_STRUCT_SIZE ];
        DRS_EXTENSIONS  extRemote;
    };
    DSTIME              timeLastUsed;     // time client last used this ctx
    ULONG               IPAddr;           // IP address of client machine
    
    union {
        BYTE            rgbExtLocal[ CURR_MAX_DRS_EXT_STRUCT_SIZE ];
        DRS_EXTENSIONS  extLocal;
    };
} DRS_CLIENT_CONTEXT;

extern LIST_ENTRY gDrsuapiClientCtxList;
extern CRITICAL_SECTION gcsDrsuapiClientCtxList;
extern BOOL gfDrsuapiClientCtxListInitialized;
extern DWORD gcNumDrsuapiClientCtxEntries;

// Structure for keeping track of the replicas we're periodically synching
typedef struct{
    void * pvQEntry;
    DSNAME * pDNRepNC;
} PERREP_ENTRY ;


// DRA memory allocation macros

// DRACHK is currently unused, used to be a checker for meory overwrite.
// Calls to DRACHK still exist, so can be replaced if required later.

#define DRAMALLOCEX(size)  draalnmallocex(size)
#define DRAFREE(pv)  draalnfree (pv)
#define DRACHK(pv)

// Aligned allocations
#define DRAALNMALLOCEX(size)  draalnmallocex(size)
#define DRAALNFREE(pv)  draalnfree (pv)
#define DRAALNREALLOCEX(pv, size) draalnreallocex(pv, size)

// Function prototypes

DWORD GetExceptData (EXCEPTION_POINTERS* pExceptPtrs, USHORT *pret);

void * dramallocex (size_t size);
void * draalnmallocex (size_t size);
void draalnfree (void * pv);
void * draalnreallocex (void * pv, size_t size);

BOOL MtxSame(UNALIGNED MTX_ADDR *pmtx1, UNALIGNED MTX_ADDR *pmtx2);

DWORD InitDRA(
    THSTATE *pTHS
    );

USHORT InitFreeDRAThread (THSTATE *pTHS, USHORT transType);

void CloseFreeDRAThread (THSTATE *pTHS, BOOL fCommit);

REPLICA_LINK *
FixupRepsFrom(
    REPLICA_LINK *prl,
    PDWORD       pcbPrl
    );


ULONG
FindDSAinRepAtt(
    DBPOS *                 pDB,
    ATTRTYP                 attid,
    DWORD                   dwFindFlags,
    UUID *                  puuidDsaObj,
    UNALIGNED MTX_ADDR *    pmtxDRA,
    BOOL *                  pfAttExists,
    REPLICA_LINK **         pprl,
    DWORD *                 pcbRL
    );
#define DRS_FIND_DSA_BY_ADDRESS ( 0 )
#define DRS_FIND_DSA_BY_UUID    ( 1 )   /* Bit field */
#define DRS_FIND_AND_REMOVE     ( 2 )   /* Bit field */

void InitDraThreadEx(THSTATE **ppTHS, DWORD dsid);
#define InitDraThread(ppTHS) InitDraThreadEx((ppTHS), DSID(FILENO,__LINE__))

void BeginDraTransactionEx(USHORT transType, BOOL fBypassUpdatesEnabledCheck);
#define BeginDraTransaction(t) BeginDraTransactionEx((t), FALSE)

USHORT EndDraTransaction(BOOL fCommit);

DWORD  DraReturn(THSTATE *pTHS, DWORD status);

DWORD
FindNC(
    IN  DBPOS *             pDB,
    IN  DSNAME *            pNC,
    IN  ULONG               ulOptions,
    OUT SYNTAX_INTEGER *    pInstanceType   OPTIONAL
    );
#define FIND_MASTER_NC  1       /* Bit field */
#define FIND_REPLICA_NC 2       /* Bit field */

VOID GetObjDN(DBPOS *pDB, DSNAME *pDN);

void
GetExpectedRepAtt(
    IN  DBPOS * pDB,
    IN  ATTRTYP type,
    OUT VOID *  pOutBuf,
    IN  ULONG   size
    );

ULONG InitDRATasks(
    THSTATE *pTHS
    );

void HandleRestore();

void
draRetireInvocationID(
    IN OUT  THSTATE *   pTHS
    );

BOOL IsFSMOSelfOwnershipValid( DSNAME *pNC );

void FindNCParentDorA (DBPOS *pDB, DSNAME * pDN, ULONG * pNCDNT);

UCHAR * MakeMtxPrintable (THSTATE *pTHS, UNALIGNED MTX_ADDR *pmtx_addr);

BOOL fNCFullSync (DSNAME *pNC);

void AddInitSyncList (DSNAME *pNC, ULONG ulReplicaFlags, LPWSTR source);

void InitSyncAttemptComplete(DSNAME *pNC, ULONG ulOptions, ULONG ulResult, LPWSTR source );

void
CheckInitSyncsFinished(
    void
    );

void
CheckGCPromotionProgress(
    IN  void *  pvParam,
    OUT void ** ppvNext,
    OUT DWORD * pcSecsUntilNextIteration
    );

BOOL
DraIsPartitionSynchronized(
    DSNAME *pNC
    );

BOOL
IsDraAccessGranted(
    IN  THSTATE *       pTHS,
    IN  DSNAME *        pNC,
    IN  const GUID *    pControlAccessRequired,
    OUT DWORD *         pdwError
    );

// Get the number of elements in an array.
#define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))

#if DBG
void
UpToDateVec_Validate(
    IN  UPTODATE_VECTOR *   putodvec
    );

void
UsnVec_Validate(
    IN  USN_VECTOR *        pusnvec
    );
#else
#define UpToDateVec_Validate(x) /* nada */
#define UsnVec_Validate(x) /* nada */
#endif

void
DupAttr(
    IN  THSTATE * pTHS,
    IN  ATTR *    pInAttr,
    OUT ATTR *    pOutAttr
    );

VOID
CopyExtensions(
    DRS_EXTENSIONS *pextSrc,
    DRS_EXTENSIONS *pextDst
    );

// Convert an MTX_ADDR (such as that embedded in a REPLICA_LINK structure) into
// a Unicode server name.  Returned string is allocated off the thread heap.
#define TransportAddrFromMtxAddrEx(pmtx) \
    UnicodeStringFromString8(CP_UTF8, (pmtx)->mtx_name, -1)

MTX_ADDR *
MtxAddrFromTransportAddrEx(
    IN  THSTATE * pTHS,
    IN  LPWSTR    psz
    );

DSNAME *
DSNameFromStringW(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszDN
    );

DWORD
AddSchInfoToPrefixTable(
    IN THSTATE *pTHS,
    IN OUT SCHEMA_PREFIX_TABLE *pPrefixTable
    );


VOID
StripSchInfoFromPrefixTable(
    IN SCHEMA_PREFIX_TABLE *pPrefixTable,
    OUT PBYTE pSchemaInfo
    );

BOOL
CompareSchemaInfo(
    IN THSTATE *pTHS,
    IN PBYTE pSchemaInfo,
    OUT BOOL *pNewSchemaIsBetter OPTIONAL
    );

DWORD
WriteSchInfoToSchema(
    IN PBYTE pSchemaInfo,
    OUT BOOL *pfSchInfoChanged
    );

REPL_DSA_SIGNATURE_VECTOR *
DraReadRetiredDsaSignatureVector(
    IN  THSTATE *   pTHS,
    IN  DBPOS *     pDB
    );

VOID
draGetLostAndFoundGuid(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    OUT GUID *      pguidLostAndFound
    );


//
// Dns Fully qualified (dns)domain name validation macros
// Notes:
//   - All other possible return codes (from DnsValidate_Name) are valid.
//   - Files using these macros must include <dnsapi.h> & ensure the
//     corresponding lib dnsapi.lib is linked.
//   - DnsNameHostnameFull ensures that a) name cannot be numeric, b) allows
//     single labeled non-dotted host name (thus the extra dot check)
//   - NULL names are skipped.
//


#define VALIDATE_RAISE_FQ_DOT_DNS_NAME_W( pwszName )             \
{                                                                \
    if ( pwszName &&                                             \
         ( ERROR_INVALID_NAME ==                                 \
          DnsValidateName_W( pwszName, DnsNameHostnameFull ) ||  \
          NULL == wcschr( pwszName, L'.' ) )) {                  \
        DRA_EXCEPT(DNS_ERROR_INVALID_NAME, 0);                  \
    }                                                            \
}


#define VALIDATE_RAISE_FQ_DOT_DNS_NAME_UTF8( pszName )           \
{                                                                \
    if ( pszName &&                                              \
         ( ERROR_INVALID_NAME ==                                 \
            DnsValidateName_UTF8( pszName, DnsNameHostnameFull ) || \
            NULL == strchr( pszName, '.') )) {                   \
        DRA_EXCEPT(DNS_ERROR_INVALID_NAME, 0);                  \
    }                                                            \
}

BOOL
draIsCompletionOfDemoteFsmoTransfer(
    IN  struct _DRS_MSG_GETCHGREQ_V8 *  pMsgIn  OPTIONAL
    );

DWORD
DraUpgrade(
    THSTATE     *pTHS,
    LONG        lOldDsaVer,
    LONG        lNewDsaVer
    );

void
DraSetRemoteDsaExtensionsOnThreadState(
    IN  THSTATE *           pTHS,
    IN  DRS_EXTENSIONS *    pextRemote
    );

LPWSTR
GetNtdsDsaDisplayName(
    IN  THSTATE * pTHS,
    IN  GUID *    pguidNtdsDsaObj
    );

LPWSTR
GetTransportDisplayName(
    IN  THSTATE * pTHS,
    IN  GUID *    pguidTransportObj
    );

DWORD
DraGetNcSize(
    IN  THSTATE *                     pTHS,
    IN  BOOL                          fCriticalOnly,
    IN  ULONG                         dntNC
);


///////////////////////////////////////////////////////////////////////////////
//
//  from dramsg.c
//

#define DRA_XLATE_COMPRESS      (1)
#define DRA_XLATE_FSMO_REPLY    (2)

void
draXlateNativeRequestToOutboundRequest(
    IN  THSTATE *                       pTHS,
    IN  struct _DRS_MSG_GETCHGREQ_V8 *  pNativeReq,
    IN  MTX_ADDR *                      pmtxLocalDSA        OPTIONAL,
    IN  UUID *                          puuidTransportDN    OPTIONAL,
    IN  DWORD                           dwMsgVersionToSend,
    OUT union _DRS_MSG_GETCHGREQ *      pOutboundReq
    );

void
draXlateInboundRequestToNativeRequest(
    IN  THSTATE *                       pTHS,
    IN  DWORD                           dwInboundReqVersion,
    IN  union _DRS_MSG_GETCHGREQ *      pInboundReq,
    IN  DRS_EXTENSIONS *                pExt,
    OUT struct _DRS_MSG_GETCHGREQ_V8 *  pNativeReq,
    OUT DWORD *                         pdwReplyVersion,
    OUT MTX_ADDR **                     ppmtxReturnAddress,
    OUT UUID *                          puuidTransportObj
    );

DWORD
draXlateNativeReplyToOutboundReply(
    IN      THSTATE *                         pTHS,
    IN      struct _DRS_MSG_GETCHGREPLY_V6 *  pNativeReply,
    IN      DWORD                             dwXlateFlags,
    IN      DRS_EXTENSIONS *                  pExt,
    IN OUT  DWORD *                           pdwMsgOutVersion,
    OUT     union _DRS_MSG_GETCHGREPLY *      pOutboundReply
    );

void
draXlateInboundReplyToNativeReply(
    IN  THSTATE *                           pTHS,
    IN  DWORD                               dwOutVersion,
    IN  union _DRS_MSG_GETCHGREPLY *        pInboundReply,
    IN  DWORD                               dwXlateFlags,
    OUT struct _DRS_MSG_GETCHGREPLY_V6 *    pNativeReply
    );

DWORD
draEncodeRequest(
    IN  THSTATE *                   pTHS,
    IN  DWORD                       dwMsgVersion,
    IN  union _DRS_MSG_GETCHGREQ *  pReq,
    IN  DWORD                       cbHeaderSize,
    OUT BYTE **                     ppbEncodedMsg,
    OUT DWORD *                     pcbEncodedMsg
    );

ULONG
draDecodeRequest(
    IN  THSTATE *                   pTHS,
    IN  DWORD                       dwMsgVersion,
    IN  BYTE *                      pbEncodedMsg,
    IN  DWORD                       cbEncodedMsg,
    OUT union _DRS_MSG_GETCHGREQ *  pReq
    );

ULONG
draEncodeReply(
    IN  THSTATE *                     pTHS,
    IN  DWORD                         dwMsgVersion,
    IN  union _DRS_MSG_GETCHGREPLY *  pmsgUpdReplica,
    IN  DWORD                         cbHeaderSize,
    OUT BYTE **                       ppbEncodedMsg,
    OUT DWORD *                       pcbEncodedMsg
    );

ULONG
draDecodeReply(
    IN  THSTATE *                     pTHS,
    IN  DWORD                         dwMsgVersion,
    IN  BYTE *                        pbEncodedMsg,
    IN  DWORD                         cbEncodedMsg,
    OUT union _DRS_MSG_GETCHGREPLY *  pmsgUpdReplica
    );

DSNAME *
draGetServerDsNameFromGuid(
    IN THSTATE *pTHS,
    IN eIndexId idx,
    IN UUID *puuid
    );

ULONG
draGetCursors(
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDB,
    IN  DSNAME *            pNC,
    IN  DS_REPL_INFO_TYPE   InfoType,
    IN  DWORD               dwBaseIndex,
    IN  PDWORD              pdwNumRequested,
    OUT void **             ppCursors
    );

void
draFreeCursors(
    IN THSTATE *            pTHS,
    IN DS_REPL_INFO_TYPE    InfoType,
    IN void *               pCursors
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\drasch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       drasch.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module defines the structures and
    functions to manipulate partial attribute set

Author:

    R.S. Raghavan (rsraghav)	

Revision History:

    Created     <mm/dd/yy>  rsraghav

--*/

#ifndef _DRASCH_H_
#define _DRASCH_H_

#include <drs.h>

// Structure that represents a GC partial replica deletion list stored in the NC Head
typedef struct _GCDeletionList
{
    USN     usnUnused;               	    // unused, but potentially contains a non-zero value
					    // if upgraded from Win2K - formerly usnHighestToBeProcessed
    USN     usnLastProcessed;               // represents the last processed changed USN in the background deletion
    PARTIAL_ATTR_VECTOR PartialAttrVecDel;  // partial attr vecs that are to be deleted

} GCDeletionList;

#define GCDeletionListSizeFromLen(cAttrs) (offsetof(GCDeletionList, PartialAttrVecDel) + PartialAttrVecV1SizeFromLen(cAttrs))
#define GCDeletionListSize(pDList) (offsetof(GCDeletionList, PartialAttrVecDel) + PartialAttrVecV1Size(&pDList->PartialAttrVecDel))

// Structure that represents the currently processed partial replica deletion list
typedef struct _GCDeletionListProcessed
{
    DSNAME          *pNC;                   // pointer to the dsname of the NC
    GCDeletionList  *pGCDList;              // pointer to the corresponding deletion list
    ULONG           purgeCount;             // count of objects that are already purged in this NC
    BOOL            fReload;                // flag that tells if DeletionList for this NC has to be reloaded
    BOOL            fNCHeadPurged;          // tells if the NCHead is already purged

} GCDeletionListProcessed;

// Interval for checking if partial replicas need to be purged (5 mins)
#define PARTIAL_REPLICA_PURGE_CHECK_INTERVAL_SECS (300)

//
// PAS states
//
#define PAS_RESET                0          // Resets to no-PAS entries in repsFrom, & identifies No-PAS state.
#define PAS_ACTIVE               1          // PAS cycle's on the task queue. PAS cycle is pending (or running) &
                                            // repsFrom entry is marked w/ it.
                                            // Also: Activate PAS cycle

#define PAS_IS_VALID(flag)      ( (flag) == PAS_ACTIVE )

BOOL
GC_IsMemberOfPartialSet(
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec,   // [in]
    ATTRTYP                     attid,              // [in]
    OUT DWORD                   *pdwAttidPosition); // [out, optional]

BOOL
GC_AddAttributeToPartialSet(
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec,   // [in, out]
    ATTRTYP                     attid);             // [in]

BOOL
GC_IsSamePartialSet(
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec1,        // [in]
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec2);       // [in]

BOOL
GC_GetDiffOfPartialSets(
    PARTIAL_ATTR_VECTOR         *pPartialAttrVecOld,        // [in]
    PARTIAL_ATTR_VECTOR         *pPartialAttrVecNew,        // [in]
    PARTIAL_ATTR_VECTOR         **ppPartialAttrVecAdded,    // [out]
    PARTIAL_ATTR_VECTOR         **ppPartialAttrVecDeleted); // [out]

BOOL
GC_IsSubsetOfPartialSet(
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec,           // [in]
    PARTIAL_ATTR_VECTOR         *pPartialAttrVecSuper);     // [in]

BOOL
GC_ReadPartialAttributeSet(
    DSNAME                      *pNC,               // [in]
    PARTIAL_ATTR_VECTOR         **ppPartialAttrVec);// [out]

void
GC_GetPartialAttrSets(
    THSTATE                     *pTHS,              // [in]
    DSNAME                      *pNC,               // [in]
    REPLICA_LINK                *pRepLink,          // [in]
    PARTIAL_ATTR_VECTOR         **ppPas,            // [out]
    PARTIAL_ATTR_VECTOR         **ppPasEx           // [out, optional]
    );


VOID
GC_WritePartialAttributeSet(
    DSNAME                      *pNC,               // [in]
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec);  // [in]

VOID
GC_TriggerSyncFromScratchOnAllLinks(
    DSNAME                      *pNC);              // [in]

BOOL
GC_ReadGCDeletionList(
    DSNAME                      *pNC,               // [in]
    GCDeletionList              **ppGCDList);       // [out]

VOID
GC_WriteGCDeletionList(
    DSNAME                      *pNC,               // [in]
    GCDeletionList              *pGCDList);         // [in]

BOOL
GC_GetGCDListToProcess(
    DSNAME **ppNC,                  // [out]
    GCDeletionList **ppGCDList);    // [out]

BOOL
GC_ReinitializeGCDListProcessed(
    BOOL fCompletedPrevious,        // [in]
    BOOL *pfMorePurging);           // [out]

BOOL
GC_UpdateLastUsnProcessedAndPurgeCount(
    USN     usnLastProcessed,       // [in]
    ULONG   cPurged);               // [in]

PARTIAL_ATTR_VECTOR     *
GC_RemoveOverlappedAttrs(
    PARTIAL_ATTR_VECTOR     *pAttrVec1,              // [in, out]
    PARTIAL_ATTR_VECTOR     *pAttrVec2,              // [in]
    BOOL                    *pfRemovedOverlaps);     // [out]

GCDeletionList *
GC_AddMoreAttrs(
    GCDeletionList           *pGCDList,             // [in]
    PARTIAL_ATTR_VECTOR     *pAttrVec);             // [in]

PARTIAL_ATTR_VECTOR*
GC_ExtendPartialAttributeSet(
    THSTATE                     *pTHS,              // [in]
    PARTIAL_ATTR_VECTOR         *poldPAS,           // [in, out]
    PARTIAL_ATTR_VECTOR         *paddedPAS);        // [in]

PARTIAL_ATTR_VECTOR*
GC_CombinePartialAttributeSet(
    THSTATE                     *pTHS,              // [in]
    PARTIAL_ATTR_VECTOR         *pPAS1,             // [in]
    PARTIAL_ATTR_VECTOR         *pPAS2 );           // [in]


VOID
GC_ProcessPartialAttributeSetChanges(
    THSTATE     *pTHS,                              // [in]
    DSNAME      *pNC,                               // [in]
    UUID*        pActiveSource);                    // [optional, in]

//
// Partial Attribute Set (PAS) functions
//
void
GC_LaunchSyncPAS (
    THSTATE      *pTHS,               // [in]
    DSNAME*      pNC,                 // [in]
    UUID*                   pActiveSource,       // [optional, in]
    PARTIAL_ATTR_VECTOR     *pAddedPAS);

ULONG
GC_FindValidPASSource(
    THSTATE*     pTHS,                // [in]
    DSNAME*      pNC,                 // [in]
    UUID*        pUuidDsa             // [optional, out]
    );

BOOL
GC_ValidatePASLink(
    REPLICA_LINK *pPASLink          // [in]
    );

VOID
GC_TriggerFullSync (
    THSTATE*                pTHS,                // [in]
    DSNAME*                 pNC,                 // [in]
    PARTIAL_ATTR_VECTOR     *pAddedPAS);         // [in]

ULONG
GC_GetPreferredSource(
    THSTATE*    pTHS,                // [in]
    DSNAME*     pNC,                 // [in]
    UUID        **ppPrefUuid         // [ptr in, out]
    );

#define DSA_PREF_RW                 0x1         // Preferred RW source
#define DSA_PREF_INTRA              0x2         // Preferred intra-site source
#define DSA_PREF_IP                 0x4         // Preferred over ip xport
#define DSA_PREF_VER                0x8         // Preferred DSA version (post w2k)
VOID
GC_GetDsaPreferenceCriteria(
    THSTATE*    pTHS,                // [in]
    DSNAME*     pNC,                 // [in]
    REPLICA_LINK *pRepsFrom,         // [in]
    PDWORD      pdwFlag);            // [out]

ULONG
GC_RegisterPAS(
    THSTATE     *pTHS,              // [in]
    DSNAME      *pNC,               // [in]
    UUID        *pUuidDsa,          // [optional, in]
    PARTIAL_ATTR_VECTOR   *pPAS,    // [optional, in]
    DWORD       dwOp,               // [in]
    BOOL        fResetUsn           // [in]
    );

ULONG
GC_CompletePASReplication(
    THSTATE               *pTHS,                    // [in]
    DSNAME                *pNC,                     // [in]
    UUID                  *pUuidDsa,                // [in]
    PARTIAL_ATTR_VECTOR* pPartialAttrSet,           // [in]
    PARTIAL_ATTR_VECTOR* pPartialAttrSetEx          // [in]
    );

BOOL
GC_StaleLink(
    REPLICA_LINK *prl                   // [in]
    );

// end of PAS functions


#endif // _DRASCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\drameta.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       drameta.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module defines all per-property meta-data parsing,
    and updating functions.

Author:

    R.S. Raghavan (rsraghav)	

Revision History:

    Created     <mm/dd/yy>  rsraghav

--*/

#ifndef _DRAMETA_H_
#define _DRAMETA_H_

#include <prefix.h>

// Value assigned to the usnProperty field of a PROPERTY_META_DATA structure to
// signify that the property has been touched/removed on a gc.  The "real" meta data is
// filled-in/removed for all such properties just before the object is committed.
#define USN_PROPERTY_TOUCHED    ( -1 )
#define USN_PROPERTY_GCREMOVED    ( -2 )

//
// Following bit flags define any special processing
// requested for the property meta data. More than
// one can be bitwise-OR'ed to specify more than
// one special processing of meta data.
//
#define META_STANDARD_PROCESSING    (0)
#define META_AUTHORITATIVE_MODIFY   (0x00000001)

// Object update states

#define UPDATE_NOT_UPDATED 0
#define UPDATE_INSTANCE_TYPE 1
#define UPDATE_OBJECT_UPDATE 2
#define UPDATE_OBJECT_CREATION 3

// Value update status
#define UPDATE_VALUE_UPDATE 2
#define UPDATE_VALUE_CREATION 3

BOOL
ReplValueIsChangeNeeded(
    IN USN usnPropWaterMark,
    IN UPTODATE_VECTOR *pUpTodateVecDest,
    VALUE_META_DATA *pValueMetaData
    );

PROPERTY_META_DATA *
ReplLookupMetaData(
    IN      ATTRTYP                         attrtyp,
    IN      PROPERTY_META_DATA_VECTOR *     pMetaDataVec,
    OUT     DWORD *                         piProp                  OPTIONAL
    );

PROPERTY_META_DATA *
ReplInsertMetaData(
    IN      THSTATE                       * pTHS,
    IN      ATTRTYP                         attrtyp,
    IN OUT  PROPERTY_META_DATA_VECTOR **    ppMetaDataVec,
    IN OUT  DWORD *                         pcbMetaDataVecAlloced,
    OUT     BOOL *                          pfIsNewElement          OPTIONAL
    );

void
ReplOverrideMetaData(
    IN      ATTRTYP                         attrtyp,
    IN OUT  PROPERTY_META_DATA_VECTOR *     pMetaDataVec
    );

void
ReplUnderrideMetaData(
    IN      THSTATE *                       pTHS,
    IN      ATTRTYP                         attrtyp,
    IN OUT  PROPERTY_META_DATA_VECTOR **    ppMetaDataVec,
    IN OUT  DWORD *                         pcbMetaDataVecAlloced   OPTIONAL
    );

void
ReplPrepareDataToShip(
    IN      THSTATE                       * pTHS,
    IN      ENTINFSEL *                     pSel,
    IN      PROPERTY_META_DATA_VECTOR *     pMetaDataVec,
    IN OUT  REPLENTINFLIST *                pList
    );

DWORD
ReplReconcileRemoteMetaDataVec(
    IN      THSTATE *                       pTHS,
    IN      PROPERTY_META_DATA_VECTOR *     pMetaDataVecLocal,      OPTIONAL
    IN      BOOL                            fIsAncestorOfLocalDsa,
    IN      BOOL                            fLocalObjDeleted,
    IN      BOOL                            fDeleteLocalObj,
    IN      BOOL                            fBadDelete,
    IN      USHORT                          RemoteObjDeletion,
    IN      ENTINF *                        pent,
    IN      PROPERTY_META_DATA_VECTOR *     pMetaDataVecRemote,
    IN OUT  GUID **                         ppParentGuid,
    OUT     ATTRBLOCK *                     pAttrBlockOut,
    OUT     PROPERTY_META_DATA_VECTOR **    ppMetaDataVecOut
    );

void
ReplMorphRDN(
    IN      THSTATE *   pTHS,
    IN OUT  ATTR *      pAttrRDN,
    IN      GUID *      pGuid
    );

int
ReplCompareMetaData(
    IN      PROPERTY_META_DATA *    pMetaData1,
    IN      PROPERTY_META_DATA *    pMetaData2  OPTIONAL
    );

int
__inline
ReplCompareVersions(
    IN DWORD Version1,
    IN DWORD Version2
    );

int
ReplCompareValueMetaData(
    VALUE_META_DATA *pValueMetaData1,
    VALUE_META_DATA *pValueMetaData2,
    BOOL *pfConflict OPTIONAL
    );

BOOL
ReplPruneOverrideAttrForSize(
    THSTATE *                   pTHS,
    DSNAME *                    pName,
    DSTIME *                    pTimeNow,
    USN *                       pusnLocal,
    ATTRBLOCK *                 pAttrBlock,
    PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote
    );

VOID
ReplOverrideLinks(
    IN THSTATE *pTHS
    );

void
ReplCheckMetadataWasApplied(
    IN      THSTATE *                   pTHS,
    IN OUT  PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote
    );

#endif // _DRAMETA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\drancrep.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       drancrep.h
//
//--------------------------------------------------------------------------

extern CRITICAL_SECTION csSyncLock;


// This is purely for debugging purposes, and (if set) is the address of the
// last other server we attempted a ReplicaSync call to.

extern UNALIGNED MTX_ADDR * pLastReplicaMTX;


// LostAndFound RDNs
#define LOST_AND_FOUND_CONFIG L"LostAndFoundConfig"
#define LOST_AND_FOUND_DOMAIN L"LostAndFound"
#define LOST_AND_FOUND_CONFIG_LEN ((sizeof(LOST_AND_FOUND_CONFIG) / sizeof(WCHAR)) - 1)
#define LOST_AND_FOUND_DOMAIN_LEN ((sizeof(LOST_AND_FOUND_DOMAIN) / sizeof(WCHAR)) - 1)


// The following constants are returns fromm the AttrValFromPentif function.
// They are single constants, not bitfields
// The return values are chosen so that the function returns TRUE if
// no values are returned.

#define ATTR_PRESENT_VALUE_RETURNED 0
#define ATTR_PRESENT_NO_VALUES 1
#define ATTR_NOT_PRESENT 2

USHORT AttrValFromPentinf(ENTINF *pent,ATTRTYP atype,VOID *pVal, ATTR **ppAttr);

#define OBJECT_DELETION_NOT_CHANGED 0
#define OBJECT_BEING_DELETED 1
#define OBJECT_DELETION_REVERSED 2

USHORT
AttrDeletionStatusFromPentinf (
        ENTINF *pent
    );

ULONG
ReplicateNC(
    IN      THSTATE *               pTHS,
    IN      DSNAME *                pNC,
    IN      MTX_ADDR *              pmtx_addr,
    IN      LPWSTR                  pszSourceDsaDnsDomainName,
    IN      USN_VECTOR *            pusnvecLast,
    IN      ULONG                   RepFlags,
    IN      REPLTIMES *             prtSchedule,
    IN OUT  UUID *                  puuidDsaObjSrc,
    IN      UUID *                  puuidInvocIdSrc,
    IN      ULONG *                 pulSyncFailure,
    IN      BOOL                    fNewReplica,
    IN      UPTODATE_VECTOR *       pUpToDateVec,
    IN      PARTIAL_ATTR_VECTOR *   pPartialAttrSet,
    IN      PARTIAL_ATTR_VECTOR *   pPartialAttrSetEx
    );

ULONG
DeleteRepTree(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC
    );

USHORT GetNextDelObj( THSTATE *pTHS, BOOL fFirstCall, USHORT *plevel, BOOL fNCLimit,
        DSNAME *pDN);

ULONG
DeleteLocalObj(
    THSTATE *                   pTHS,
    DSNAME *                    pDN,
    BOOL                        fPreserveRDN,
    BOOL                        fGarbCollectASAP,
    PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote
    );

ULONG
UpdateNC(
    THSTATE *                     pTHS,
    DSNAME *                      pNC,
    DRS_MSG_GETCHGREPLY_NATIVE *  pmsgReply,
    LPWSTR                        pszSourceServer,
    ULONG *                       pulSyncFailure,
    ULONG                         RepFlags,
    DWORD *                       pdwNCModified,
    DWORD *                       pdwObjectCreationCount,
    DWORD *                       pdwValueCreationCount,
    BYTE  *                       pSchemaInfo,
    BOOL                          fIsPreemptable
    );

// Following constants are used to return the modification
// status through UpdateNC()
// These are constants - not bit fields. Caller
// of UpdateNC() is expected to use the returned value as a
// whole - not analyze it bitwise.
#define MODIFIED_NOTHING            (0)
#define MODIFIED_NCHEAD_ONLY        (1)
#define MODIFIED_NCTREE_INTERIOR    (2)

DWORD
UpdateRepsFromRef(
    THSTATE *               pTHS,
    ULONG                   ulModifyFields,
    DSNAME *                pNC,
    DWORD                   dwFindFlags,
    BOOL                    fMustAlreadyExist,
    UUID *                  puuidDsaObj,
    UUID *                  puuidInvocId,
    USN_VECTOR *            pusnvecTo,
    UUID *                  puuidTransportObj,
    UNALIGNED MTX_ADDR *    pmtx_addr,
    ULONG                   RepFlags,
    REPLTIMES *             prtSchedule,
    ULONG                   ulResultThisAttempt,
    PPAS_DATA               pPasData
    );
#define URFR_NEED_NOT_ALREADY_EXIST ( FALSE )
#define URFR_MUST_ALREADY_EXIST     ( TRUE )

int IsNCUpdateable (THSTATE *pTHS, ENTINF *pent, USN usnLastSync,
                                                        BOOL writeable);

// Return codes from IsNCUpdateable
#define UPDATE_OK       1
#define UPDATE_INCOMPAT 2
#define UPDATE_LOST_WRTS  3
#define UPDATE_LOST_NWTS  4


// Convert the DSNAME of an NTDS-DSA object into a network address.
LPWSTR
DSaddrFromName(
    IN  THSTATE   * pTHS,
    IN  DSNAME *    pdnServer
    );

// Change the instance type of the given object to the specified value.
ULONG
ChangeInstanceType(
    IN  THSTATE *       pTHS,
    IN  DSNAME *        pName,
    IN  SYNTAX_INTEGER  it,
    IN  DWORD           dsid
    );

DWORD  ReplicateCrossRefBack(
    DSNAME *        pdnCR, 
    WCHAR *         wszNamingFsmoDns
    );

ULONG
RenameLocalObj(
    THSTATE                     *pTHS,
    ULONG                       dntNC,
    ATTR                        *pAttrRdn,
    GUID                        *pObjectGuid,
    GUID                        *pParentGuid,
    PROPERTY_META_DATA_VECTOR   *pMetaDataVecRemote,
    BOOL                        fMoveToLostAndFound,
    BOOL                        fDeleteLocalObj
    );

// From dramderr.c
void 
draEncodeError(
    THSTATE *                  pTHS,     
    DWORD                      ulRepErr,
    DWORD *                    pdwErrVer,
    DRS_ERROR_DATA **          ppErrData
    );

void
draDecodeDraErrorDataAndSetThError(
    DWORD                 dwVer,
    DRS_ERROR_DATA *      pErrData,
    DWORD                 dwOptionalError,
    THSTATE *             pTHS
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\dsaapi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       dsaapi.h
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    In-process replication API.

DETAILS:

CREATED:

REVISION HISTORY:

--*/

#ifndef _dsaapi_h_
#define _dsaapi_h_

ULONG
DirReplicaAdd(
    IN  DSNAME *    pNC,
    IN  DSNAME *    pSourceDsaDN,               OPTIONAL
    IN  DSNAME *    pTransportDN,               OPTIONAL
    IN  LPWSTR      pszSourceDsaAddress,
    IN  LPWSTR      pszSourceDsaDnsDomainName,  OPTIONAL
    IN  REPLTIMES * preptimesSync,              OPTIONAL
    IN  ULONG       ulOptions
    );

ULONG
DirReplicaModify(
    DSNAME *    pNC,
    UUID *      puuidSourceDRA,
    UUID *      puuidTransportObj,
    LPWSTR      pszSourceDRA,
    REPLTIMES * prtSchedule,
    ULONG       ulReplicaFlags,
    ULONG       ulModifyFields,
    ULONG       ulOptions
    );
#define DRS_UPDATE_ALL        ( 0 )         // 0x00
#define DRS_UPDATE_FLAGS      ( 1 << 0 )    // 0x01
#define DRS_UPDATE_ADDRESS    ( 1 << 1 )    // 0x02
#define DRS_UPDATE_SCHEDULE   ( 1 << 2 )    // 0x04
#define DRS_UPDATE_RESULT     ( 1 << 3 )    // 0x08
#define DRS_UPDATE_TRANSPORT  ( 1 << 4 )    // 0x10
#define DRS_UPDATE_PAS        ( 1 << 5 )    // 0x20
#define DRS_UPDATE_USN        ( 1 << 6 )    // 0x40
// The difference between UPDATE_FLAGS and UPDATE_SYSTEM_FLAGS is
// that UPDATE_FLAGS is not allowed to change the state of system
// reserved flags.
#define DRS_UPDATE_SYSTEM_FLAGS (1 << 7 )   // 0x80

#define DRS_UPDATE_MASK       (   DRS_UPDATE_FLAGS    \
                                | DRS_UPDATE_ADDRESS  \
                                | DRS_UPDATE_SCHEDULE \
                                | DRS_UPDATE_RESULT   \
                                | DRS_UPDATE_TRANSPORT\
                                | DRS_UPDATE_PAS      \
                                | DRS_UPDATE_USN      \
                                | DRS_UPDATE_SYSTEM_FLAGS \
                              )

ULONG
DirReplicaDelete(
        DSNAME *pNC,
        LPWSTR pszSourceDRA,
        ULONG ulOptions
);

ULONG
DirReplicaSynchronize(
        DSNAME *pNC,
        LPWSTR pszSourceDRA,
        UUID * puuidSourceDRA,
        ULONG ulOptions
);

ULONG
DirReplicaReferenceUpdate(
        DSNAME *pNC,
        LPWSTR pszReferencedDRA,
        UUID * puuidReferencedDRA,
        ULONG ulOptions
);

typedef struct _DRS_DEMOTE_TARGET_SEARCH_INFO {
    DWORD cNumAttemptsSoFar;
    GUID  guidLastDSA;
} DRS_DEMOTE_TARGET_SEARCH_INFO;
                        
ULONG
DirReplicaGetDemoteTarget(
    IN      DSNAME *                        pNC,
    IN OUT  DRS_DEMOTE_TARGET_SEARCH_INFO * pDTSInfo,
    OUT     LPWSTR *                        ppszDemoteTargetDNSName,
    OUT     DSNAME **                       ppDemoteTargetDSADN
    );

ULONG
DirReplicaDemote(
    IN  DSNAME *    pNC,
    IN  LPWSTR      pszOtherDSADNSName,
    IN  DSNAME *    pOtherDSADN,
    IN  ULONG       ulOptions
    );

DWORD
DirReplicaSetCredentials(
    IN HANDLE ClientToken,
    IN WCHAR *User,
    IN WCHAR *Domain,
    IN WCHAR *Password,
    IN ULONG  PasswordLength   // number of characters NOT including terminating
                               // NULL
    );

#endif /* _dsaapi_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\dstaskq.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dstaskq.h
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

DETAILS:

CREATED:

REVISION HISTORY:

    01/10/97    Jeff Parham (jeffparh)
                Extracted task queue functions to taskq.h (with some
                modifications) such that the task queue code can be moved to a
                more abstract, general-purpose library.

--*/

#include <taskq.h>

extern void TQ_BuildHierarchyTable(     void *, void **, DWORD * );
extern void TQ_DelayedFreeMemory(       void *, void **, DWORD * );
extern void TQ_SynchronizeReplica(      void *, void **, DWORD * );
extern void TQ_GarbageCollection(       void *, void **, DWORD * );
extern void TQ_CheckSyncProgress(       void *, void **, DWORD * );
extern void TQ_CheckAsyncQueue(         void *, void **, DWORD * );
extern void TQ_CheckReplLatency(        void *, void **, DWORD * );
extern void TQ_DelayedMailStart(        void *, void **, DWORD * );
extern void TQ_DelayedFreeSchema(       void *, void **, DWORD * );
extern void TQ_ReloadDNReadCache(       void *, void **, DWORD * );
extern void TQ_NT4ReplicationCheckpoint(void *, void **, DWORD * );
extern void TQ_PurgePartialReplica(     void *, void **, DWORD * );
extern void TQ_GroupTypeCacheMgr(       void *, void **, DWORD * );
extern void TQ_FPOCleanup(              void *, void **, DWORD * );
extern void TQ_RebuildAnchor(           void *, void **, DWORD * );
extern void TQ_WriteServerInfo(         void *, void **, DWORD * );
extern void TQ_StalePhantomCleanup(     void *, void **, DWORD * );
extern void TQ_DRSExpireContextHandles( void *, void **, DWORD * );
extern void TQ_DelayedSDPropEnqueue(    void *, void **, DWORD * );
extern void TQ_ProtectAdminGroups(      void *, void **, DWORD * );
extern void TQ_CheckFullSyncProgress(   void *, void **, DWORD * );
extern void TQ_CheckGCPromotionProgress(void *, void **, DWORD * );
extern void TQ_CountAncestorsIndexSize (void *, void **, DWORD * );
extern void TQ_RefreshUserMemberships  (void *, void **, DWORD * );
extern void TQ_LinkCleanup(             void *, void **, DWORD * );
extern void TQ_DeleteExpiredEntryTTLMain(void *,void **, DWORD * );
extern void TQ_RebuildCatalog(          void *, void **, DWORD * );
extern void TQ_FailbackOffsiteGC(       void *, void **, DWORD * );
extern void TQ_BehaviorVersionUpdate(   void *, void **, DWORD * );
extern void TQ_RebuildRefCache(         void *, void **, DWORD * );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\dsastubs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dsastubs.h
//
//--------------------------------------------------------------------------

/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

#ifndef _dsastubs_h_
#define _dsastubs_h_



ULONG DUA_DirBind
(
    DIRHANDLE FAR         * pDirHandle,  /* returns a handle */
    ASSOCIATE_INFO FAR    * pBindDSA,    /* used to find the DSA to bind */
    BINDARG FAR           * pBindArg,    /* binding credentials */
    VOID FAR             ** ppOutBuf,    /* return Result or Error out buf */
    USHORT FAR            * pOutBufSize  /* The size of the output buffer */
);


ULONG DUA_DirUnBind
(
    DIRHANDLE   dirhandle       /* directory handle for this session */
);


ULONG DUA_DirCompare
(
    DIRHANDLE           dirHandle,   /* handle */
    COMPAREARG FAR    * pCompareArg, /* Compare argument */
    VOID FAR         ** ppOutBuf,    /* return Result or Error out buf */
    USHORT FAR        * pOutBufSize  /* Size of the out buffer returned */
);


ULONG DUA_DirSearch
(
    DIRHANDLE       dirHandle,    /* handle*/
    SEARCHARG FAR * pSearchArg,   /* search argument */
    VOID FAR     ** ppOutBuf,     /* return Result or Error output Buffer */
    USHORT FAR    * pOutBufSize   /* Size of the output buffer returned */
);


ULONG DUA_DirList
(
    DIRHANDLE       dirHandle,    /* handle*/
    LISTARG FAR   * pListArg,     /* list argument */
    VOID FAR     ** ppOutBuf,     /* return Result or Error output Buffer */
    USHORT FAR    * pOutBufSize   /* size of the output buffer returned */
);


ULONG DUA_DirRead
(
    DIRHANDLE       dirHandle,   /* handle */
    READARG FAR   * pReadArg,    /* Read argument */
    VOID FAR     ** ppOutBuf,    /* return Result or Error output Buffer */
    USHORT FAR    * pOutBufSize  /* Size of the output buffer returned */
);


ULONG DUA_DirAddEntry
(
    DIRHANDLE       dirHandle,      /* handle */
    ADDARG FAR    * pAddArg,        /* add argument */
    VOID FAR     ** ppOutBuf,       /* Error output Buf (only on error) */
    USHORT FAR    * pOutBufSize     /* Size of the output buffer returned */
);


ULONG DUA_DirRemoveEntry
(
    DIRHANDLE       dirHandle,      /* handle */
    REMOVEARG FAR * pRemoveArg,     /* remove argument */
    VOID FAR     ** ppOutBuf,       /* Error output Buf (only on error) */
    USHORT FAR    * pOutBufSize     /* Size of the output buffer returned */
);


#endif /* _dsastubs_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\gcverify.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       gcverify.h
//
//--------------------------------------------------------------------------

#ifndef __GCVERIFY_H__
#define __GCVERIFY_H__

extern
ENTINF *
GCVerifyCacheLookup(
    DSNAME *pDSName);

ULONG
PreTransVerifyNcName(
    THSTATE *                 pTHS,
    ADDCROSSREFINFO *         pCRInfo
    );

extern
ULONG
GCVerifyDirAddEntry(
    ADDARG *pAddArg);

extern
ULONG
GCVerifyDirModifyEntry(
    MODIFYARG   *pModifyArg);

VOID
VerifyDSNAMEs_V1(
    struct _THSTATE         *pTHS,
    DRS_MSG_VERIFYREQ_V1    *pmsgIn,
    DRS_MSG_VERIFYREPLY_V1  *pmsgOut);

VOID
VerifySIDs_V1(
    struct _THSTATE         *pTHS,
    DRS_MSG_VERIFYREQ_V1    *pmsgIn,
    DRS_MSG_VERIFYREPLY_V1  *pmsgOut);

VOID
VerifySamAccountNames_V1(
    struct _THSTATE         *pTHS,
    DRS_MSG_VERIFYREQ_V1    *pmsgIn,
    DRS_MSG_VERIFYREPLY_V1  *pmsgOut);

typedef struct _FIND_DC_INFO
{
    DWORD   cBytes;
    DWORD   seqNum;
    DWORD   cchDomainNameOffset;
    WCHAR   addr[1];
    //  Note: pFindDCInfo->addr = server name
    //        pFindDCInfo->addr + cchDomainNameOffset = domain name
} FIND_DC_INFO;

// Returns DNS domain name of GC given a FIND_DC_INFO *.
#define FIND_DC_INFO_DOMAIN_NAME(pFindDCInfo) \
    (&(pFindDCInfo)->addr[(pFindDCInfo)->cchDomainNameOffset])

//
// Flags for Find GC/Find DC
//
#define FIND_DC_USE_CACHED_FAILURES      (0x1)
#define FIND_DC_USE_FORCE_ON_CACHE_FAIL  (0x2)
#define FIND_DC_GC_ONLY                 (0x4)

extern
DWORD
FindDC(
    DWORD       dwFlags,
    WCHAR *     wszNcDns,
    FIND_DC_INFO **ppInfo);

#define FindGC(flags, output)   FindDC((flags) | FIND_DC_GC_ONLY, NULL, output)

extern
VOID
InvalidateGC(
    FIND_DC_INFO *pInfo,
    DWORD       winError);


DWORD
GCGetVerifiedNames (
        IN  THSTATE *pTHS,
        IN  DWORD    count,
        IN  PDSNAME *pObjNames,
        OUT PDSNAME *pVerifiedNames
        );

VOID
GCVerifyCacheAdd(
    IN struct _SCHEMA_PREFIX_MAP_TABLE * hPrefixMap,
    IN ENTINF * pEntInf);


#endif // __GCVERIFY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\hiertab.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       hiertab.h
//
//--------------------------------------------------------------------------


#define HT_MAX_NAME	(257 * sizeof(wchar_t))
#define HT_MAX_RDN	64

typedef struct _HierarchyTableElement {
    wchar_t               *displayName;                        
    DWORD                 dwEph;
    DWORD                 depth;
    PUCHAR		  pucStringDN;
} HierarchyTableElement, * PHierarchyTableElement;

typedef struct _HierarchyTableType {
    DWORD                  Version;
    DWORD                  GALCount;
    DWORD                 *pGALs;
    DWORD                  TemplateRootsCount;
    DWORD                 *pTemplateRoots;
    DWORD	           Size;
    PHierarchyTableElement Table;
} HierarchyTableType, * PHierarchyTableType;


extern ULONG gulHierRecalcPause;

extern PHierarchyTableType    HierarchyTable;

extern HANDLE hevHierRecalc_OKToInserInTaskQueue;


extern void
BuildHierarchyTableMain (
        void *,
        void **,
        DWORD *
        );

extern DWORD
GetIndexSize (
        THSTATE *pTHS,
        DWORD ABCont
        );

extern DWORD
InitHierarchy (
        void
        );

extern void
HTGetHierarchyTablePointer (
        PHierarchyTableType    *ptHierTab,
        DWORD                  **ppIndexArray,
        DWORD                  SortLocale
        );

extern void
HTGetGALAndTemplateDNT (
        NT4SID *pSid,
        DWORD   cbSid,
        DWORD  *pGALDNT,
        DWORD  *pTemplateDNT
        ); 

#define HIERARCHY_DO_ONCE        0
#define HIERARCHY_PERIODIC_TASK  1
#define HIERARCHY_DELAYED_START  2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\drsdra.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       drsdra.h
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Internal replication API.  Should be called only by other replication APIs
    -- other callers should use the DirReplica* family of functions.

DETAILS:

CREATED:

REVISION HISTORY:

--*/

typedef struct _DRA_REPL_SESSION_STATISTICS {
    DWORD ObjectsReceived;
    DWORD ObjectsCreated;
    DWORD ValuesReceived;
    DWORD ValuesCreated;
    DWORD SourceNCSizeObjects;
    DWORD SourceNCSizeValues;
    DWORD ulTotalObjectsReceived;
    DWORD ulTotalObjectsCreated;
    DWORD ulTotalValuesReceived;
    DWORD ulTotalValuesCreated;
} DRA_REPL_SESSION_STATISTICS, *PDRA_REPL_SESSION_STATISTICS;

ULONG
DRA_ReplicaSync(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  UUID *      pinvocationid,
    IN  LPWSTR      pszDSA,
    IN  ULONG       ulOptions
    );

ULONG
DRA_ReplicaAdd(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  DSNAME *    pSourceDsaDN,               OPTIONAL
    IN  DSNAME *    pTransportDN,               OPTIONAL
    IN  MTX_ADDR *  pmtx_addr,
    IN  LPWSTR      pszSourceDsaDnsDomainName,  OPTIONAL
    IN  REPLTIMES * preptimesSync,              OPTIONAL
    IN  ULONG       ulOptions
    );

ULONG
DRA_ReplicaDel(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  MTX_ADDR *  pSDSAMtx_addr,
    IN  ULONG       ulOptions
    );

ULONG DRA_UpdateRefs(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  MTX_ADDR *  pDSAMtx_addr,
    IN  UUID *      puuidDSA,
    IN  ULONG       ulOptions
    );

ULONG
DRA_GetNCChanges(
    IN  THSTATE *                     pTHS,
    IN  FILTER *                      pFilter,
    IN  DWORD                         dwDirSyncControlFlags,
    IN  DRS_MSG_GETCHGREQ_NATIVE *    pmsgIn,
    OUT DRS_MSG_GETCHGREPLY_NATIVE *  pmsgOut
    );

ULONG
DRA_ReplicaModify(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  UUID *      puuidSourceDRA,
    IN  UUID *      puuidTransportObj,
    IN  MTX_ADDR *  pmtxSourceDRA,
    IN  REPLTIMES * prtSchedule,
    IN  ULONG       ulReplicaFlags,
    IN  ULONG       ulModifyFields,
    IN  ULONG       ulOptions
    );

void
draConstructGetChgReq(
    IN  THSTATE *                   pTHS,
    IN  DSNAME *                    pNC,
    IN  REPLICA_LINK *              pRepsFrom,
    IN  UPTODATE_VECTOR *           pUtdVec             OPTIONAL,
    IN  PARTIAL_ATTR_VECTOR *       pPartialAttrSet     OPTIONAL,
    IN  PARTIAL_ATTR_VECTOR *       pPartialAttrSetEx   OPTIONAL,
    IN  ULONG                       ulOptions,
    OUT DRS_MSG_GETCHGREQ_NATIVE *  pMsgReq
    );

void
draReportSyncProgress(
    THSTATE *pTHS,
    DSNAME *pNC,
    LPWSTR pszSourceServer,
    DRA_REPL_SESSION_STATISTICS *pReplStats
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\dswait.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dswait.h
//
//--------------------------------------------------------------------------

/*
 * dswait.h 
 * This file includes all the definitions required for XDS client context*
 * maintained on the servers and support for dswaits
 *
 */

typedef struct {
    CRITICAL_SECTION		cs;
    HANDLE			hev;
    ULONG			cEntered;
    ULONG			cWriters;
} RWLock;

typedef struct _DSWaitDNTList {
    ULONG			dnt;
    struct _DSWaitDNTList	*pNext;
} DSWaitDNTList;

typedef struct {
    CRITICAL_SECTION		cs;
    HANDLE			hev;
    ULONG			cDNT;
    ULONG			*rgDNT;
    ULONG			cPDNT;
    ULONG			*rgPDNT;
    ULONG			ulFlags;
    ULONG			cMods;
    DSWaitDNTList		*pMods;
} DSWaitItem;

//
// Flag definitions for DSWaitItem.ulFlags
//
#define	DSWAIT_CHANGES_SIGNALED			0x00000001
#define DSWAIT_ABORTED				0x00000002
#define DSWAIT_ITEM_REMOVED_FROM_LISTS		0x00000004

typedef struct _DSWaitList {
    DSWaitItem			*pItem;
    struct _DSWaitList		*pNext;
    struct _DSWaitList		*pPrev;
} DSWaitList;


typedef struct {
    CRITICAL_SECTION		cs;
    DSWaitList			*pwl;
} XDSClientContext;


typedef struct {
    BOOL fInUse;
    XDSClientContext *pContext;
} ContextListEntry;

extern DSWaitList			*gpDSWaits;
extern RWLock				*pRWLockDSWaits;
extern CRITICAL_SECTION			csServerContexts;
extern ULONG				cServerContexts;
extern ContextListEntry 		*rgServerContexts;
extern ULONG				ulMaxWaits;
extern ULONG				ulCurrentWaits;

// functions
RWLock		*CreateRWLock(void);
void 		DestroyRWLock(RWLock **ppLock); 
void 		LockRWLock(RWLock *pLock, BOOL fWriteLock);
void 		UnlockRWLock(RWLock *pLock, BOOL fWriteLock);
XDSClientContext *CreateXDSClientContext();
ULONG 		CreateXDSClientContextHandle();
XDSClientContext *PXDSClientContextFromHandle(ULONG ulHandle);
void 		ReleaseXDSClientContext(XDSClientContext **ppContext,
			BOOL fDestroyContext);
DSWaitItem 	*CreateDSWaitItem(XDSClientContext *pContext, 
			    DSWaitDNTList *pDNTList, DSWaitDNTList *pPDNTList);
void 		DestroyXDSClientContextHandle( ULONG ulHandle);
void		AbandonAllWaitsOnAllContexts(void);
void 		NotifyWaiters(DBPOS *pDB);
void		DestroyModsList(DSWaitDNTList **ppMods);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\dsatools.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsatools.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Directory utility definitions

Author:

    DS team

Environment:

Notes:

Revision History:

--*/

#ifndef _DSATOOLS_
#define _DSATOOLS_

#include "direrr.h"        /* header for error codes */


// Global NULL UUID

extern UUID gNullUuid;

// Global NULL NT4SID

extern NT4SID gNullNT4SID;

// Global usn vector indicating the NC should be synced from scratch.

extern USN_VECTOR gusnvecFromScratch;

// Global usn vector indicating the NC should be synced from max USNs
// (i.e., don't send any objects).

extern USN_VECTOR gusnvecFromMax;

/*-------------------------------------------------------------------------*/

/* Start the transaction by setting a database sync point and initializing
   some resource flags.  Every transaction must start with a call to this
   function after a transaction handle has been obtained (pTHS).  There are
   three types of transactions,  read transactions, write transactions which
   require exclusive access (the usual case), and write transactions that
   allow readers.
*/

extern int APIENTRY SyncTransSet(USHORT tranType);

extern VOID APIENTRY SyncTransEnd(THSTATE * pTHS, BOOL fCommit);

/* Ends the transaction by commiting and cleaning up all resources
   and returns. This function may be called multiple times with no ill
   effect.
*/

extern int APIENTRY  CleanReturn(THSTATE *pTHS, DWORD dwError, BOOL fAbnormalTerm);

/* N.B. This define must be manually kept in sync with the function
 *      IsSpecial() in dsamain\src\parsedn.c.
 */
#define DN_SPECIAL_CHARS L",=\r\n+<>#;\"\\"

/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/

/* A transaction always begins by setting either a read or write sync point.
   This will set the appropriate locks and initialize thread global vars.

*/

#define SYNC_READ_ONLY         0
#define SYNC_WRITE             1

// Transaction entry/exit prototypes for Dir* APIs.

extern void
SYNC_TRANS_READ(void);

extern void
SYNC_TRANS_WRITE(void);

extern void
_CLEAN_BEFORE_RETURN(
    DWORD   err,
    BOOL    fAbnormalTermination);

#define CLEAN_BEFORE_RETURN(err) _CLEAN_BEFORE_RETURN(err, AbnormalTermination())

/*
SRALLOC macro

New version is simplified some.

The macro should be simplified more:
It may not be necessary to treat SRALLOCDontRestSize cases
specially here.  Also, CleanReturn's return value is always the
same value as passed in, unless SRALLOC_SIZE_ERROR.   This
trick in CleanReturn() should be thought out -- is it necessary, the
right place, and what interaction with this macro is there?

Actually, the whole thing should be gutted.

*/


#define SRALLOC( pTHS, size, ppLoc )                                    \
        if (!(*(ppLoc) = THAlloc((DWORD) size)))                        \
        {                                                               \
            return SetSvcError(SV_PROBLEM_ADMIN_LIMIT_EXCEEDED,         \
                        DIRERR_USER_BUFFER_TO_SMALL );                  \
        }                                                               \

/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/* Initialize the primary thread data structure. This must be the first
   call in every transaction API handler.
*/

THSTATE* _InitTHSTATE_(DWORD CallerType, DWORD dsid);
#define InitTHSTATE(CallerType) \
    _InitTHSTATE_(CallerType, ((FILENO << 16) | __LINE__))

THSTATE * create_thread_state( void );

DWORD DBInitThread( THSTATE* pTHS );
DWORD DBCloseThread( THSTATE* pTHS );

/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/* This macro can be used to compare two DN's for equality */

#define IS_DN_EQUAL(pDN1, pDN2)                          \
  (   ((pDN1)->AVACount        == (pDN2)->AVACount)      \
   && (NameMatched(pDN1, pDN2) == (pDN1)->AVACount)      \
  )

/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/* These functions are used to dynamically allocate memory on a transaction
   basis.  In other words, to allocate memory that belongs to a single
   thread and a single invocation of an API.  The model is that
   THAlloc is called to allocate some transaction memory.  It allocates
   memory and stores the address in the pMem array.  pMem is dynamically
   allocated and will grow to hold all transaction memory addresses.

   THAllocEx takes it's size as a DWORD, and throws an exception if
   something goes wrong.

   THFree is used to release all transaction allocations.

   The non-excepting versions are now exported, and hence live in ntdsa.h

*/

void * APIENTRY THAllocException(THSTATE *pTHS,
                                 DWORD size,
                                 BOOL fUseHeapOrg,
                                 DWORD ulId);

#define THAllocEx(pTHS, size) \
    THAllocException(pTHS, (size), FALSE, ((FILENO << 16) | __LINE__))

#define THAllocOrgEx(pTHS, size) \
    THAllocException(pTHS, size, TRUE, ((FILENO << 16) | __LINE__))

#ifndef USE_THALLOC_TRACE
    void * APIENTRY THAllocOrg(THSTATE* pTHS, 
                               DWORD size);
#else
    void * APIENTRY THAllocOrgDbg(THSTATE *pTHS, DWORD size, DWORD dsid);
    #define THAllocOrg(pThs, size) \
        THAllocOrgDbg((pTHS), (size), ((FILENO << 16) | __LINE__))
#endif

void * APIENTRY THReAllocException(THSTATE *pTHS,
                                   void * memory,
                                   DWORD size,
                                   BOOL fUseHeapOrg,
                                   DWORD ulId);

#define THReAllocEx(pTHS, memory, size) THReAllocException(pTHS, memory, size, FALSE, \
                          ((FILENO << 16) | __LINE__))

#define THReAllocOrgEx(pTHS, memory, size) \
    THReAllocException(pTHS, memory, size, TRUE, ((FILENO << 16) | __LINE__))


VOID THFreeEx(THSTATE *pTHS, VOID *buff);

VOID THFreeOrg(THSTATE *pTHS, VOID *buff);


//  versions of THAlloc et al that take a pTHS but do NOT throw an exception
void* THAllocNoEx_(THSTATE* pTHS, DWORD size, DWORD ulId);
#define THAllocNoEx(pTHS, size) THAllocNoEx_(pTHS, size, ((FILENO << 16) | __LINE__))
void* THReAllocNoEx_(THSTATE* pTHS, void* memory, DWORD size, DWORD ulId);
#define THReAllocNoEx(pTHS, memory, size) THReAllocNoEx_(pTHS, memory, size, ((FILENO << 16) | __LINE__))
void THFreeNoEx(THSTATE* pTHS, void* buff);


VOID free_thread_state( VOID );

//number of slots in each CPU heap cache
#define HEAP_CACHE_SIZE_PER_CPU   8

//data structure for thread memory allocation
typedef struct _HMEM
{
    HANDLE    hHeap;
    THSTATE * pTHS;
    PUCHAR    pZone;
} HMEM;

//data structure for heap cache of each CPU
typedef struct _HEAPCACHE
{
    HMEM slots[HEAP_CACHE_SIZE_PER_CPU];
    DWORD  index;
    CRITICAL_SECTION csLock;
#if DBG
    DWORD cGrabHeap;
#endif
} HEAPCACHE;

//size of each cache block
#define CACHE_BLOCK_SIZE 64

//the allocation size of each HEAPCACHE
#define HEAPCACHE_ALLOCATION_SIZE ((sizeof(HEAPCACHE)+CACHE_BLOCK_SIZE-1)/CACHE_BLOCK_SIZE*CACHE_BLOCK_SIZE)

/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/* This function determines if the current object is an alias by looking
   for the alias class in the object's class hierarchy
*/

extern BOOL APIENTRY IsAlias(DBPOS *pDB);


#if DBG
#define CACHE_UUID 1
#endif

#ifdef CACHE_UUID
void CacheUuid (UUID *pUuid, char * pDSAName);
#endif

UCHAR * UuidToStr(UUID* pUuid, UCHAR *pOutUuid);
VOID SidToStr(PUCHAR pSid, DWORD SidLen, PUCHAR pOutSid);

// The string returned by the above function with uuid caching is an ascii
// version of the uuid, the string server name, a space and a zero.
// Without caching, the string is ommitted

#define MAX_SERVER_NAME_LEN MAX_PATH
#ifdef CACHE_UUID
#define SZUUID_LEN ((2*sizeof(UUID)) + MAX_SERVER_NAME_LEN +2)
#else
#define SZUUID_LEN ((2*sizeof(UUID))+1)
#endif

/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/* This function produces a printable string name for an object.  The string
   is assumed to be large enough to hold the output!  It returns a pointer
   to the output string parameter.
*/

extern UCHAR * GetExtDN(THSTATE *pTHS, DBPOS *pDB);

extern DSNAME * GetExtDSName(DBPOS *pDB);

extern UCHAR * MakeDNPrintable(DSNAME *pDN);

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function retrieves only living objects from the database.  It performs
   a  DBFind  and checks that the found  object has  not been logically
   deleted.
*/

#define FIND_ALIVE_FOUND 0
#define FIND_ALIVE_NOTFOUND 1
#define FIND_ALIVE_SYSERR   2
#define FIND_ALIVE_BADNAME  3
#define FIND_ALIVE_OBJ_DELETED  4

extern int APIENTRY  FindAliveDSName(DBPOS FAR *pDB, DSNAME *pDN);

extern VOID TH_mark(THSTATE *pTHS);

extern VOID TH_free_to_mark(THSTATE *pTHS);

#define CP_TELETEX  20261
#define CP_NON_UNICODE_FOR_JET 1252
#ifndef CP_WINUNICODE
#define CP_WINUNICODE 1200
#endif

/* This function takes a string in the clients code page and converts it
   to a unicode string.
*/
extern wchar_t  *UnicodeStringFromString8(UINT CodePage, char *szA, LONG cbA);

/* This function takes a unicode string allocates memory and converts it to
   the client's code page
*/
extern char *
String8FromUnicodeString (
        BOOL bThrowExcept,
        UINT CodePage,
        wchar_t *szU,
        LONG cbU,
        LPLONG pCb,
        LPBOOL pfUsedDefChar);

//
// helper function which takes a DSNAME and returns its hashkey
//
extern DWORD DSNAMEToHashKey(THSTATE *pTHS, const DSNAME *pDN);

//
// helper function which takes a DSNAME and returns its LCMapped version
// this can be used in string comparisons using strcmp
//
extern CHAR* DSNAMEToMappedStr(THSTATE *pTHS, const DSNAME *pDN);

//
// helper function which takes a WCHAR and returns its hashkey
//
extern DWORD DSStrToHashKey(THSTATE *pTHS, const WCHAR *pStr, int cchLen);

//
// helper function that takes a WCHAR string and returns the LCMapped version
// cchMaxStr is the maximum expected size of the passed in string
//
extern CHAR * DSStrToMappedStr (THSTATE *pTHS, const WCHAR *pStr, int cchMaxStr);


//------------------------------------------------------------------------------
// the following is taken from hashfn.h (LKRHash) by prepending DS in al functions

// Produce a scrambled, randomish number in the range 0 to RANDOM_PRIME-1.
// Applying this to the results of the other hash functions is likely to
// produce a much better distribution, especially for the identity hash
// functions such as Hash(char c), where records will tend to cluster at
// the low end of the hashtable otherwise.  LKRhash applies this internally
// to all hash signatures for exactly this reason.

__inline DWORD
DSHashScramble(DWORD dwHash)
{
    // Here are 10 primes slightly greater than 10^9
    //  1000000007, 1000000009, 1000000021, 1000000033, 1000000087,
    //  1000000093, 1000000097, 1000000103, 1000000123, 1000000181.

    // default value for "scrambling constant"
    const DWORD RANDOM_CONSTANT = 314159269UL;
    // large prime number, also used for scrambling
    const DWORD RANDOM_PRIME =   1000000007UL;

    return (RANDOM_CONSTANT * dwHash) % RANDOM_PRIME ;
}

// Faster scrambling function

__inline DWORD
DSHashRandomizeBits(DWORD dw)
{
        return (((dw * 1103515245 + 12345) >> 16)
            | ((dw * 69069 + 1) & 0xffff0000));
}


// Small prime number used as a multiplier in the supplied hash functions
#define DS_HASH_MULTIPLIER 101

#undef DS_HASH_SHIFT_MULTIPLY

#ifdef DS_HASH_SHIFT_MULTIPLY
# define DS_HASH_MULTIPLY(dw)   (((dw) << 7) - (dw))
#else
# define DS_HASH_MULTIPLY(dw)   ((dw) * DS_HASH_MULTIPLIER)
#endif

// Fast, simple hash function that tends to give a good distribution.

__inline DWORD
DSHashString(
    const char* psz,
    DWORD       dwHash)
{
    // force compiler to use unsigned arithmetic
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz;  ++upsz)
        dwHash = DS_HASH_MULTIPLY(dwHash)  +  *upsz;

    return DSHashScramble (dwHash);
}


// Unicode version of above

__inline DWORD
DSHashStringW(
    const wchar_t* pwsz,
    DWORD          dwHash)
{
    for (  ;  *pwsz;  ++pwsz)
        dwHash = DS_HASH_MULTIPLY(dwHash)  +  *pwsz;

    return DSHashScramble (dwHash);
}

//------------------------------------------------------------------------------

/* This function takes a buffer of DWORDS, the first DWORD being a count
   of the rest of the DWORDS, and the rest of the DWORDS are pointers to
   free.  It frees them, then frees the buffer.
*/
extern void
DelayedFreeMemoryEx (
        DWORD_PTR *buffer,
        DWORD timeDelay
        );


extern void
DelayedFreeMemory(
        void * buffer,
        void ** ppvNext,
        DWORD * pcSecsUntilNext
        );

#define DELAYED_FREE( pv )                                          \
    if ( DsaIsInstalling() )                                        \
    {                                                               \
        free( pv );                                                 \
    }                                                               \
    else                                                            \
    {                                                               \
        DWORD_PTR * pdw;                                            \
                                                                    \
        pdw = malloc( 2 * sizeof( DWORD_PTR ) );                    \
                                                                    \
        if ( NULL == pdw )                                          \
        {                                                           \
            LogUnhandledError( 0 );                                 \
        }                                                           \
        else                                                        \
        {                                                           \
            pdw[ 0 ] = 1;                                           \
            pdw[ 1 ] = (DWORD_PTR) (pv);                            \
            InsertInTaskQueue( TQ_DelayedFreeMemory, pdw, 3600 );   \
        }                                                           \
    }

extern DWORD dwTSindex;
#define MACROTHSTATE 1
#ifdef  MACROTHSTATE
#define pTHStls ((THSTATE*)TlsGetValue(dwTSindex))
#else
/* This is the thread specific, globally accessible, thread state variable. */
extern __declspec(thread) THSTATE *pTHStls;
#endif

BOOL fNullUuid (const UUID *pUuid);
BOOL fNullNT4SID (NT4SID *pSid);

// Returns TRUE if the attribute is one that we don't allow people to set and
// that we simply skip if it is specified in an add entry call.
BOOL SysAddReservedAtt(ATTCACHE *pAC);


// returns TRUE if pDN is a descedent of pPrefix.  Only uses the string portion
// of the DSNAMEs
extern unsigned
NamePrefix(const DSNAME *pPrefix,
           const DSNAME *pDN);

// Converts a string into a distname, allocating memory.  Returns 0 on success
DWORD StringDNtoDSName(char *szDN, DSNAME **pDistname);


// Convert from a UTC or Generalised Time string to a SYNTAX_TIME
BOOL
fTimeFromTimeStr (
        SYNTAX_TIME *psyntax_time,
        OM_syntax syntax,
        char *pb,
        ULONG len,
        BOOL *pLocalTimeSpecified
        );

// Get a unique dword, used to identify a client connection by a head.
// Currently only used by LDAP head and the SDProp enqueuer to keep track of
// which sessions started which SD prop events.
DWORD
dsGetClientID(
        void
        );


#define ACTIVE_CONTAINER_SCHEMA      1
#define ACTIVE_CONTAINER_SITES       2
#define ACTIVE_CONTAINER_SUBNETS     3
#define ACTIVE_CONTAINER_PARTITIONS  4
#define ACTIVE_CONTAINER_OUR_SITE    5

#define ACTIVE_CONTAINER_LIST_ID_MAX 5


DWORD
RegisterActiveContainerByDNT(
        ULONG DNT,
        DWORD ID
        );

DWORD
RegisterActiveContainer(
        DSNAME *pDN,
        DWORD   ID
        );
void
CheckActiveContainer(
        DWORD PDNT,
        DWORD *pID
        );

// Values from call type
#define ACTIVE_CONTAINER_FROM_ADD    0
#define ACTIVE_CONTAINER_FROM_MOD    1
#define ACTIVE_CONTAINER_FROM_MODDN  2
#define ACTIVE_CONTAINER_FROM_DEL    3

DWORD
PreProcessActiveContainer (
        THSTATE    *pTHS,
        DWORD      dwCallType,
        DSNAME     *pDN,
        CLASSCACHE *pCC,
        DWORD      ID
        );

DWORD
PostProcessActiveContainer (
        THSTATE    *pTHS,
        DWORD      dwCallType,
        DSNAME     *pDN,
        CLASSCACHE *pCC,
        DWORD      ID
        );

ULONG CheckRoleOwnership(THSTATE *pTHS,
                         DSNAME  *pRoleObject,
                         DSNAME  *pOperationTarget);

typedef struct _DirWaitItem {
    DWORD      hServer;
    DWORD      hClient;
    PF_PFI     pfPrepareForImpersonate;
    PF_TD      pfTransmitData;
    PF_SI      pfStopImpersonating;
    ULONG      DNT;
    BOOL       bOneNC;
    ENTINFSEL *pSel;
    struct _DirWaitItem * pNextItem;
    SVCCNTL    Svccntl;
} DirWaitItem;

typedef struct _DirWaitHead {
    DWORD                DNT;
    struct _DirWaitHead *pNext;
    DirWaitItem         *pList;
} DirWaitHead;
extern DirWaitHead *gpDntMon[256];
extern DirWaitHead *gpPdntMon[256];

typedef struct _DirNotifyItem {
    DWORD                  DNT;
    DirWaitItem           *pWaitItem;
    struct _DirNotifyItem *pNext;
} DirNotifyItem;

// Globals for keeping track of ds_waits.
extern RTL_RESOURCE resDirNotify;
extern CRITICAL_SECTION csDirNotifyQueue;
extern HANDLE hevDirNotifyQueue;

ULONG DirNotifyThread(void * parm);
BOOL
DirPrepareForImpersonate (
        DWORD hClient,
        DWORD hServer,
        void ** ppImpersonateData
        );
VOID
DirStopImpersonating (
        DWORD hClient,
        DWORD hServer,
        void * pImpersonateData
        );
void
NotifyWaitersPostProcessTransactionalData(
        THSTATE *pTHS,
        BOOL fCommit,
        BOOL fCommitted
        );

// Find a Naming Context corresponding to the Sid
BOOLEAN
FindNcForSid(
    IN PSID pSid,
    OUT PDSNAME * NcName
    );


VOID
SetInstallStatusMessage (
    IN  DWORD  MessageId,
    IN  WCHAR *Insert1, OPTIONAL
    IN  WCHAR *Insert2, OPTIONAL
    IN  WCHAR *Insert3, OPTIONAL
    IN  WCHAR *Insert4, OPTIONAL
    IN  WCHAR *Insert5  OPTIONAL
    );

VOID
SetInstallErrorMessage (
    IN  DWORD  WinError,
    IN  DWORD  MessageId,
    IN  WCHAR *Insert1, OPTIONAL
    IN  WCHAR *Insert2, OPTIONAL
    IN  WCHAR *Insert3, OPTIONAL
    IN  WCHAR *Insert4  OPTIONAL
    );

//
// This global variable is used to keep track of what operations
// are done during InstallBaseNTDS, so that they may be undone if the operation
// fails.
//
extern ULONG gInstallOperationsDone;

#define SET_INSTALL_ERROR_MESSAGE0( err, msgid ) \
    SetInstallErrorMessage( (err), (msgid), NULL, NULL, NULL, NULL )

#define SET_INSTALL_ERROR_MESSAGE1( err, msgid, a ) \
    SetInstallErrorMessage( (err), (msgid), (a), NULL, NULL, NULL )

#define SET_INSTALL_ERROR_MESSAGE2( err, msgid, a, b ) \
    SetInstallErrorMessage( (err), (msgid), (a), (b), NULL, NULL )

#define SET_INSTALL_ERROR_MESSAGE3( err, msgid, a, b, c ) \
    SetInstallErrorMessage( (err), (msgid), (a), (b), (c), NULL )

#define SET_INSTALL_ERROR_MESSAGE4( err, msgid, a , b, c, d ) \
    SetInstallErrorMessage( (err), (msgid), (a), (b), (c), (d) )

extern ULONG Win32ErrorFromPTHS(THSTATE *pTHS);

extern void __fastcall INC_READS_BY_CALLERTYPE(CALLERTYPE type);
extern void __fastcall INC_WRITES_BY_CALLERTYPE(CALLERTYPE type);
extern void __fastcall INC_SEARCHES_BY_CALLERTYPE(CALLERTYPE type);

void CleanUpThreadStateLeakage(void);

// Define hash table for use by Get-Changes to determine whether a given object
// has already been added to the output buffer (as keyed by its DNT).

typedef struct _DNT_HASH_ENTRY
{
    ULONG dnt;
    struct _DNT_HASH_ENTRY * pNext;
    DWORD dwData;
} DNT_HASH_ENTRY;

DNT_HASH_ENTRY *
dntHashTableAllocate(
    THSTATE *pTHS
    );

BOOL
dntHashTablePresent(
    DNT_HASH_ENTRY *pDntHashTable,
    DWORD dnt,
    LPDWORD dwData OPTIONAL
    );

VOID
dntHashTableInsert(
    THSTATE *pTHS,
    DNT_HASH_ENTRY *pDntHashTable,
    DWORD dnt,
    DWORD dwData
    );

VOID
DsUuidCreate(
    GUID *pGUID
    );

VOID
DsUuidToStringW(
    IN  GUID   *pGuid,
    OUT PWCHAR *ppszGuid
    );

DWORD
GetBehaviorVersion(
    IN OUT  DBPOS       *pDB,
    IN      DSNAME      *dsObj,
    OUT     PDWORD      pdwBehavior);


PDSNAME
GetConfigDsName(
    IN  PWCHAR  wszParam
    );



#endif /* _DSATOOLS_ */

/* end dsatools.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\ntdscriptexec.h ===
//+-----------------------------------------------------------------------------
//
// NTDSriptExec.h
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
//------------------------------------------------------------------------------
#ifndef __NTDSCRIPTEXEC_H
#define __NTDSCRIPTEXEC_H


#ifdef __cplusplus
extern "C" {
#endif
    DWORD GeneralScriptExecute (THSTATE *pTHS, WCHAR * Script );

#ifdef DBG
    ULONG ExecuteScriptLDAP (OPARG *pOpArg, OPRES *pOpRes);
#endif

#ifdef __cplusplus
}
#endif

#endif // __NTDSCRIPTEXEC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\magicdnt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       magicdnt.h
//
//--------------------------------------------------------------------------

/*
 * This file contains some magic dnts for some interesting objects.
 * These DNTs were found by inspection, and are used during tloadobj,
 * and during server install.  Tloadobj verifies all of these numbers.
 */

#define MAGICDNT_ROOT             1
#define MAGICDNT_ORG              4
#define MAGICDNT_ORGUNIT          5
#define MAGICDNT_DMD              6
#define MAGICDNT_CONFIGCONTAINER 80
#define MAGICDNT_SERVERSCONTAINER (MAGICDNT_CONFIGCONTAINER + 1)
#define MAGICDNT_SERVER           (MAGICDNT_SERVERSCONTAINER + 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\nlwrap.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       nlwrap.h
//
//--------------------------------------------------------------------------

/* 
    This file contains wrappers for various netlogon routines and either
    stubs them out or passes them on to netlogon depending on whether
    we're running as an executable or inside the lsass process.
*/

#include <crypt.h>                      // for samisrv.h
#include <samrpc.h>                     // for samisrv.h
#include <lsarpc.h>                     // for samisrv.h
#include <samisrv.h>                    // for nlrepl.h
#undef _AVOID_REPL_API
#include "nlrepl.h"                     // I_NetLogon* API and flag definitions

extern
NTSTATUS
dsI_NetNotifyNtdsDsaDeletion (
    IN LPWSTR DnsDomainName,
    IN GUID *DomainGuid,
    IN GUID *DsaGuid,
    IN LPWSTR DnsHostName
    );

extern
NTSTATUS
dsI_NetLogonReadChangeLog(
    IN PVOID InContext,
    IN ULONG InContextSize,
    IN ULONG ChangeBufferSize,
    OUT PVOID *ChangeBuffer,
    OUT PULONG BytesRead,
    OUT PVOID *OutContext,
    OUT PULONG OutContextSize
    );

extern
NTSTATUS
dsI_NetLogonNewChangeLog(
    OUT HANDLE *ChangeLogHandle
    );

NTSTATUS
extern
dsI_NetLogonAppendChangeLog(
    IN HANDLE ChangeLogHandle,
    IN PVOID ChangeBuffer,
    IN ULONG ChangeBufferSize
    );

extern
NTSTATUS
dsI_NetLogonCloseChangeLog(
    IN HANDLE ChangeLogHandle,
    IN BOOLEAN Commit
    );

extern
NTSTATUS
dsI_NetLogonLdapLookupEx(
    IN PVOID Filter,
    IN PVOID SockAddr,
    OUT PVOID *Response,
    OUT PULONG ResponseSize
    );

extern
NTSTATUS
dsI_NetLogonSetServiceBits(
    IN DWORD ServiceBitsOfInterest,
    IN DWORD ServiceBits
    );

extern
VOID
dsI_NetLogonFree(
    IN PVOID Buffer
    );

extern
NTSTATUS
dsI_NetNotifyDsChange(
    IN NL_DS_CHANGE_TYPE DsChangeType
    );

extern
NET_API_STATUS
dsDsrGetDcNameEx2(
    IN LPWSTR ComputerName OPTIONAL,
    IN LPWSTR AccountName OPTIONAL,
    IN ULONG AllowableAccountControlBits,
    IN LPWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\ntdsctr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ntdsctr.h
//
//--------------------------------------------------------------------------

//
//  NTDSCTR.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the
//  "First Counter" and "First Help" values of the device they belong to,
//  in order to determine the  absolute location of the counter and
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//
//  We use a version number to keep track of which set of counters we are
//  using, and whether the performance counters in the registry need to be
//  reloaded.  If you add or delete any counters, please change the version
//  number at the end of this file.
//
#define DSAOBJ                  0
#define DRA_IN_PROPS            2
#define BROWSE                  4
#define REPL                    6
#define THREAD                  8
#define ABCLIENT                10
#define PENDSYNC                12
#define REMREPUPD               14
#define SDPROPS                 16
#define SDEVENTS                18
#define LDAPCLIENTS             20
#define LDAPACTIVE              22
#define LDAPWRITE               24
#define LDAPSEARCH              26
#define DRAOBJSHIPPED           28
#define DRAPROPSHIPPED          30
#define DRA_IN_VALUES           32
#define DRASYNCREQUESTMADE      34
#define DRASYNCREQUESTSUCCESSFUL 36
#define DRASYNCREQUESTFAILEDSCHEMAMISMATCH 38
#define DRASYNCOBJRECEIVED      40
#define DRASYNCPROPUPDATED      42
#define DRASYNCPROPSAME         44
#define MONLIST                 46
#define NOTIFYQ                 48
#define LDAPUDPCLIENTS          50
#define SUBSEARCHOPS            52
#define NAMECACHEHIT            54
#define NAMECACHETRY            56
#define HIGHESTUSNISSUEDLO      58
#define HIGHESTUSNISSUEDHI      60
#define HIGHESTUSNCOMMITTEDLO   62
#define HIGHESTUSNCOMMITTEDHI   64
#define SAMWRITES               66
#define TOTALWRITES1            68
#define DRAWRITES               70
#define TOTALWRITES2            72
#define LDAPWRITES              74
#define TOTALWRITES3            76
#define LSAWRITES               78
#define TOTALWRITES4            80
#define KCCWRITES               82
#define TOTALWRITES6            84
#define NSPIWRITES              86
#define TOTALWRITES7            88
#define OTHERWRITES             90
#define TOTALWRITES8            92
#define TOTALWRITES             94
#define SAMSEARCHES             96
#define TOTALSEARCHES1          98 
#define DRASEARCHES             100
#define TOTALSEARCHES2          102
#define LDAPSEARCHES            104
#define TOTALSEARCHES3          106
#define LSASEARCHES             108
#define TOTALSEARCHES4          110
#define KCCSEARCHES             112
#define TOTALSEARCHES6          114
#define NSPISEARCHES            116
#define TOTALSEARCHES7          118
#define OTHERSEARCHES           120
#define TOTALSEARCHES8          122
#define TOTALSEARCHES           124
#define SAMREADS                126
#define TOTALREADS1             128
#define DRAREADS                130
#define TOTALREADS2             132
#define DRA_IN_DN_VALUES        134
#define DRA_IN_OBJS_FILTERED    136
#define LSAREADS                138
#define TOTALREADS4             140
#define KCCREADS                142
#define TOTALREADS6             144
#define NSPIREADS               146
#define TOTALREADS7             148
#define OTHERREADS              150
#define TOTALREADS8             152
#define TOTALREADS              154
#define LDAPBINDSUCCESSFUL      156
#define LDAPBINDTIME            158
#define CREATEMACHINESUCCESSFUL 160
#define CREATEMACHINETRIES      162
#define CREATEUSERSUCCESSFUL    164
#define CREATEUSERTRIES         166
#define PASSWORDCHANGES         168
#define MEMBERSHIPCHANGES       170
#define QUERYDISPLAYS           172
#define ENUMERATIONS            174
#define MEMBEREVALTRANSITIVE    176
#define MEMBEREVALNONTRANSITIVE 178
#define MEMBEREVALRESOURCE      180
#define MEMBEREVALUNIVERSAL     182
#define MEMBEREVALACCOUNT       184
#define MEMBEREVALASGC          186
#define ASREQUESTS              188
#define TGSREQUESTS             190
#define KERBEROSAUTHENTICATIONS 192
#define MSVAUTHENTICATIONS      194
#define DRASYNCFULLREM          196
#define DRA_IN_BYTES_TOTAL_RATE      198
#define DRA_IN_BYTES_NOT_COMP_RATE   200
#define DRA_IN_BYTES_COMP_PRE_RATE   202
#define DRA_IN_BYTES_COMP_POST_RATE  204
#define DRA_OUT_BYTES_TOTAL_RATE     206
#define DRA_OUT_BYTES_NOT_COMP_RATE  208
#define DRA_OUT_BYTES_COMP_PRE_RATE  210
#define DRA_OUT_BYTES_COMP_POST_RATE 212
#define DS_CLIENT_BIND          214
#define DS_SERVER_BIND          216
#define DS_CLIENT_NAME_XLATE    218
#define DS_SERVER_NAME_XLATE    220
#define SDPROP_RUNTIME_QUEUE    222
#define SDPROP_WAIT_TIME        224
#define DRA_OUT_OBJS_FILTERED   226
#define DRA_OUT_VALUES          228
#define DRA_OUT_DN_VALUES       230
#define NSPI_ANR                232
#define NSPI_PROPERTY_READS     234
#define NSPI_OBJECT_SEARCH      236
#define NSPI_OBJECT_MATCHES     238
#define NSPI_PROXY_LOOKUP       240
#define ATQ_THREADS_TOTAL       242
#define ATQ_THREADS_LDAP        244
#define ATQ_THREADS_OTHER       246
#define DRA_IN_BYTES_TOTAL      248
#define DRA_IN_BYTES_NOT_COMP   250
#define DRA_IN_BYTES_COMP_PRE   252
#define DRA_IN_BYTES_COMP_POST  254
#define DRA_OUT_BYTES_TOTAL     256
#define DRA_OUT_BYTES_NOT_COMP  258
#define DRA_OUT_BYTES_COMP_PRE  260
#define DRA_OUT_BYTES_COMP_POST 262
#define LDAP_NEW_CONNS_PER_SEC  264
#define LDAP_CLS_CONNS_PER_SEC  266
#define LDAP_SSL_CONNS_PER_SEC  268
#define LDAP_THREADS_IN_NETLOG  270
#define LDAP_THREADS_IN_AUTH    272
#define LDAP_THREADS_IN_DRA     274
#define DRA_REPL_QUEUE_OPS      276
#define DRA_TDS_IN_GETCHNGS     278
#define DRA_TDS_IN_GETCHNGS_W_SEM    280
#define DRA_REM_REPL_UPD_LNK    282
#define DRA_REM_REPL_UPD_TOT    284
#define NTDSAPIWRITES           286
#define NTDSAPISEARCHES         288
#define NTDSAPIREADS            290

#define DSA_PERF_COUNTER_BLOCK  TEXT("Global\\Microsoft.Windows.NTDS.Perf")

//If the last counter changes, DSA_LAST_COUNTER_INDEX need to be changed
#define DSA_LAST_COUNTER_INDEX NTDSAPIREADS

extern volatile unsigned long * pcBrowse;
extern volatile unsigned long * pcSDProps;
extern volatile unsigned long * pcSDEvents;
extern volatile unsigned long * pcLDAPClients;
extern volatile unsigned long * pcLDAPActive;
extern volatile unsigned long * pcLDAPWritePerSec;
extern volatile unsigned long * pcLDAPSearchPerSec;
extern volatile unsigned long * pcThread;
extern volatile unsigned long * pcABClient;
extern volatile unsigned long * pcMonListSize;
extern volatile unsigned long * pcNotifyQSize;
extern volatile unsigned long * pcLDAPUDPClientOpsPerSecond;
extern volatile unsigned long * pcSearchSubOperations;
extern volatile unsigned long * pcNameCacheHit;
extern volatile unsigned long * pcNameCacheTry;
extern volatile unsigned long * pcHighestUsnIssuedLo;
extern volatile unsigned long * pcHighestUsnIssuedHi;
extern volatile unsigned long * pcHighestUsnCommittedLo;
extern volatile unsigned long * pcHighestUsnCommittedHi;
extern volatile unsigned long * pcSAMWrites;
extern volatile unsigned long * pcDRAWrites;
extern volatile unsigned long * pcLDAPWrites;
extern volatile unsigned long * pcLSAWrites;
extern volatile unsigned long * pcKCCWrites;
extern volatile unsigned long * pcNSPIWrites;
extern volatile unsigned long * pcOtherWrites;
extern volatile unsigned long * pcNTDSAPIWrites;
extern volatile unsigned long * pcTotalWrites;
extern volatile unsigned long * pcSAMSearches;
extern volatile unsigned long * pcDRASearches;
extern volatile unsigned long * pcLDAPSearches;
extern volatile unsigned long * pcLSASearches;
extern volatile unsigned long * pcKCCSearches;
extern volatile unsigned long * pcNSPISearches;
extern volatile unsigned long * pcOtherSearches;
extern volatile unsigned long * pcNTDSAPISearches;
extern volatile unsigned long * pcTotalSearches;
extern volatile unsigned long * pcSAMReads;
extern volatile unsigned long * pcDRAReads;
extern volatile unsigned long * pcLSAReads;
extern volatile unsigned long * pcKCCReads;
extern volatile unsigned long * pcNSPIReads;
extern volatile unsigned long * pcOtherReads;
extern volatile unsigned long * pcNTDSAPIReads;
extern volatile unsigned long * pcTotalReads;
extern volatile unsigned long * pcLDAPBinds;
extern volatile unsigned long * pcLDAPBindTime;
extern volatile unsigned long * pcCreateMachineSuccessful;
extern volatile unsigned long * pcCreateMachineTries;
extern volatile unsigned long * pcCreateUserSuccessful;
extern volatile unsigned long * pcCreateUserTries;
extern volatile unsigned long * pcPasswordChanges;
extern volatile unsigned long * pcMembershipChanges;
extern volatile unsigned long * pcQueryDisplays;
extern volatile unsigned long * pcEnumerations;
extern volatile unsigned long * pcMemberEvalTransitive;
extern volatile unsigned long * pcMemberEvalNonTransitive;
extern volatile unsigned long * pcMemberEvalResource;
extern volatile unsigned long * pcMemberEvalUniversal;
extern volatile unsigned long * pcMemberEvalAccount;
extern volatile unsigned long * pcMemberEvalAsGC;
extern volatile unsigned long * pcAsRequests;
extern volatile unsigned long * pcTgsRequests;
extern volatile unsigned long * pcKerberosAuthentications;
extern volatile unsigned long * pcMsvAuthentications;
extern volatile unsigned long * pcDsClientBind;
extern volatile unsigned long * pcDsServerBind;
extern volatile unsigned long * pcDsClientNameTranslate;
extern volatile unsigned long * pcDsServerNameTranslate;
extern volatile unsigned long * pcSDPropRuntimeQueue;
extern volatile unsigned long * pcSDPropWaitTime;
extern volatile unsigned long * pcNspiANR;
extern volatile unsigned long * pcNspiPropertyReads;
extern volatile unsigned long * pcNspiObjectSearch;
extern volatile unsigned long * pcNspiObjectMatches;
extern volatile unsigned long * pcNspiProxyLookup;
extern volatile unsigned long * pcAtqThreadsTotal;
extern volatile unsigned long * pcAtqThreadsLDAP;
extern volatile unsigned long * pcAtqThreadsOther;
extern volatile unsigned long * pcLdapNewConnsPerSec;
extern volatile unsigned long * pcLdapClosedConnsPerSec;
extern volatile unsigned long * pcLdapSSLConnsPerSec;
extern volatile unsigned long * pcLdapThreadsInNetlogon;
extern volatile unsigned long * pcLdapThreadsInAuth;
extern volatile unsigned long * pcLdapThreadsInDra;

// Replication-specific counters.
extern volatile unsigned long * pcRepl;
extern volatile unsigned long * pcPendSync;
extern volatile unsigned long * pcRemRepUpd;
extern volatile unsigned long * pcDRAObjShipped;
extern volatile unsigned long * pcDRAPropShipped;
extern volatile unsigned long * pcDRASyncRequestMade;
extern volatile unsigned long * pcDRASyncRequestSuccessful;
extern volatile unsigned long * pcDRASyncRequestFailedSchemaMismatch;
extern volatile unsigned long * pcDRASyncObjReceived;
extern volatile unsigned long * pcDRASyncPropUpdated;
extern volatile unsigned long * pcDRASyncPropSame;
extern volatile unsigned long * pcDRASyncFullRemaining;
extern volatile unsigned long * pcDRAInBytesTotal;
extern volatile unsigned long * pcDRAInBytesTotalRate;
extern volatile unsigned long * pcDRAInBytesNotComp;
extern volatile unsigned long * pcDRAInBytesNotCompRate;
extern volatile unsigned long * pcDRAInBytesCompPre;
extern volatile unsigned long * pcDRAInBytesCompPreRate;
extern volatile unsigned long * pcDRAInBytesCompPost;
extern volatile unsigned long * pcDRAInBytesCompPostRate;
extern volatile unsigned long * pcDRAOutBytesTotal;
extern volatile unsigned long * pcDRAOutBytesTotalRate;
extern volatile unsigned long * pcDRAOutBytesNotComp;
extern volatile unsigned long * pcDRAOutBytesNotCompRate;
extern volatile unsigned long * pcDRAOutBytesCompPre;
extern volatile unsigned long * pcDRAOutBytesCompPreRate;
extern volatile unsigned long * pcDRAOutBytesCompPost;
extern volatile unsigned long * pcDRAOutBytesCompPostRate;
extern volatile unsigned long * pcDRAInProps;
extern volatile unsigned long * pcDRAInValues;
extern volatile unsigned long * pcDRAInDNValues;
extern volatile unsigned long * pcDRAInObjsFiltered;
extern volatile unsigned long * pcDRAOutObjsFiltered;
extern volatile unsigned long * pcDRAOutValues;
extern volatile unsigned long * pcDRAOutDNValues;
extern volatile unsigned long * pcDRAReplQueueOps;
extern volatile unsigned long * pcDRATdsInGetChngs;
extern volatile unsigned long * pcDRATdsInGetChngsWSem;
extern volatile unsigned long * pcDRARemReplUpdLnk;
extern volatile unsigned long * pcDRARemReplUpdTot;


#define INC(x) InterlockedIncrement((LPLONG)x)
#define DEC(x) InterlockedDecrement((LPLONG)x)
#define ISET(x, y) InterlockedExchange((LPLONG)x, y)
#define IADJUST(x, y) InterlockedExchangeAdd((LPLONG)x,y)
#define HIDWORD(usn) ((DWORD) (((usn) >> 32) & 0xffffffff))
#define LODWORD(usn) ((DWORD) ((usn) & 0xffffffff))

// Some of our counters are in fact only updated in one thread, or we
// may not care too much about accuracy.  For those, we have a cheaper
// increment macro.  Note that these are NOT SAFE for counters that must
// reliably return to zero (e.g., ThreadsInUse).
#define PERFINC(x) ((*(x))++)
#define PERFDEC(x) ((*(x))--)


// Version history
// 0 or none, pre April 1998, original set
// 1, April 1998, wlees, added pcDRASyncFullRemaining
// 2, Murlis May 1998 Changed Logon Perf Counters
// 3, Fix help text for logon counters
// 4, Nov 1998, jeffparh, Add DRA in/out byte counters
// 5, 11/21/98, DaveStr, Add DsBind & DsCrackNames counters
// 6, Jan 1999, jeffparh, Add/revise various DRA counters
// 7, Feb 1999, mariosz, Add various Nspi counters
// 8, May 1999, rrandall, Add Atq counters
// 9, June 1999, rrandall, fix counter names and descriptions.
// 10, July 1999, jeffparh, Add DRA cumulative byte ctrs (in addition to rates)
// 11, Feb, 2000, xinhe, Delete XDS counters
// 12, Oct, 2000, rrandall, add debug counters for tracking lping problems.
// 13, Nov, 2000, gregjohn, add DRA queue length and IDL_DRSGetNCChanges thread counters
// 14, Nov, 2000, gregjohn, add NTDSAPI Dir search/read/write counter
// 15, Jan, 2001, rrandall, remove "LDAP Successful Binds" counter

#define NTDS_PERFORMANCE_COUNTER_VERSION 15

         
//The size of the shared memory block for communication between 
//ntdsa.dll and ntdsperf.dll
#define DSA_PERF_SHARED_PAGE_SIZE 4096

//We want to spread the counters evenly throughout the shared memory block,
//The following constant defines the distance in DWORD between two contiguous counters
#define COUNTER_ADDRESS_INCREMENT_IN_DWORD (DSA_PERF_SHARED_PAGE_SIZE/(DSA_LAST_COUNTER_INDEX/2+1)/sizeof(DWORD))

//The following macro returns the offset in DWORD of counter X
#define COUNTER_OFFSET(X) ( (X) / 2 * COUNTER_ADDRESS_INCREMENT_IN_DWORD )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\lht.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    lht.h

Abstract:

    This module defines the data structures and function prototypes for an
    unsynchronized linear hash table (LHT).

Author:

    Andrew E. Goodsell (andygo) 01-Apr-2001

Revision History:

--*/

#ifndef _LHT_
#define _LHT_


typedef enum _LHT_ERR {
    LHT_errSuccess,             //  success
    LHT_errOutOfMemory,         //  not enough memory
    LHT_errInvalidParameter,    //  bad argument to function
    LHT_errEntryNotFound,       //  entry was not found
    LHT_errNoCurrentEntry,      //  currently not positioned on an entry
    LHT_errKeyDuplicate,        //  cannot insert because key already exists
    LHT_errKeyChange,           //  cannot replace because key has changed
    } LHT_ERR;

typedef
SIZE_T
(*LHT_PFNHASHKEY) (
    IN      PVOID   pvKey
    );

typedef
SIZE_T
(*LHT_PFNHASHENTRY) (
    IN      PVOID   pvEntry
    );

typedef
BOOLEAN
(*LHT_PFNENTRYMATCHESKEY) (
    IN      PVOID   pvEntry,
    IN      PVOID   pvKey
    );

typedef
VOID
(*LHT_PFNCOPYENTRY) (
    OUT     PVOID   pvEntryDest,
    IN      PVOID   pvEntrySrc
    );

typedef
PVOID
(*LHT_PFNMALLOC) (
    IN      SIZE_T  cbAlloc
    );

typedef
VOID
(*LHT_PFNFREE) (
    IN      PVOID   pvAlloc
    );

typedef struct _LHT LHT, *PLHT;
typedef struct _LHT_CLUSTER LHT_CLUSTER, *PLHT_CLUSTER;

typedef struct _LHT_POS {
    PLHT            plht;                   //  linear hash table
    BOOLEAN         fScan;                  //  we are scanning the table
    PLHT_CLUSTER    pClusterHead;           //  the first cluster in the current bucket
    SIZE_T          iBucket;                //  the current bucket index
    PLHT_CLUSTER    pCluster;               //  the current cluster in the current bucket
    PVOID           pvEntryPrev;            //  the previous entry
    PVOID           pvEntry;                //  the current entry
    PVOID           pvEntryNext;            //  the next entry
} LHT_POS, *PLHT_POS;

typedef struct _LHT_STAT {
    SIZE_T          cEntry;                 //  number of entries in table
    SIZE_T          cBucket;                //  number of buckets in use
    SIZE_T          cBucketPreferred;       //  preferred number of buckets
    SIZE_T          cOverflowClusterAlloc;  //  total overflow clusters allocated
    SIZE_T          cOverflowClusterFree;   //  total overflow clusters freed
    SIZE_T          cBucketSplit;           //  total buckets split
    SIZE_T          cBucketMerge;           //  total buckets merged
    SIZE_T          cDirectorySplit;        //  total directory splits
    SIZE_T          cDirectoryMerge;        //  total directory merges
    SIZE_T          cStateTransition;       //  total maintenance state transitions
    SIZE_T          cPolicySelection;       //  total maintenance policy selections
    SIZE_T          cMemoryAllocation;      //  total memory allocations
    SIZE_T          cMemoryFree;            //  total memory frees
    SIZE_T          cbMemoryAllocated;      //  total bytes of memory allocated
    SIZE_T          cbMemoryFreed;          //  total bytes of memory freed
} LHT_STAT, *PLHT_STAT;


EXTERN_C
LHT_ERR LhtCreate(
    IN      SIZE_T                      cbEntry,
    IN      LHT_PFNHASHKEY              pfnHashKey,
    IN      LHT_PFNHASHENTRY            pfnHashEntry,
    IN      LHT_PFNENTRYMATCHESKEY      pfnEntryMatchesKey,
    IN      LHT_PFNCOPYENTRY            pfnCopyEntry        OPTIONAL,
    IN      SIZE_T                      cLoadFactor         OPTIONAL,
    IN      SIZE_T                      cEntryMin           OPTIONAL,
    IN      LHT_PFNMALLOC               pfnMalloc           OPTIONAL,
    IN      LHT_PFNFREE                 pfnFree             OPTIONAL,
    IN      SIZE_T                      cbCacheLine         OPTIONAL,
    OUT     PLHT*                       pplht
    );
EXTERN_C
VOID LhtDestroy(
    IN      PLHT        plht    OPTIONAL
    );

EXTERN_C
VOID LhtMoveBeforeFirst(
    IN      PLHT        plht,
    OUT     PLHT_POS    ppos
    );
EXTERN_C
LHT_ERR LhtMoveNext(
    IN OUT  PLHT_POS    ppos
    );
EXTERN_C
LHT_ERR LhtMovePrev(
    IN OUT  PLHT_POS    ppos
    );
EXTERN_C
VOID LhtMoveAfterLast(
    IN      PLHT        plht,
    OUT     PLHT_POS    ppos
    );

EXTERN_C
LHT_ERR LhtFindEntry(
    IN      PLHT        plht,
    IN      PVOID       pvKey,
    OUT     PLHT_POS    ppos
    );

EXTERN_C
LHT_ERR LhtRetrieveEntry(
    IN OUT  PLHT_POS    ppos,
    OUT     PVOID       pvEntry
    );
EXTERN_C
LHT_ERR LhtReplaceEntry(
    IN OUT  PLHT_POS    ppos,
    IN      PVOID       pvEntry
    );
EXTERN_C
LHT_ERR LhtInsertEntry(
    IN OUT  PLHT_POS    ppos,
    IN      PVOID       pvEntry
    );
EXTERN_C
LHT_ERR LhtDeleteEntry(
    IN OUT  PLHT_POS    ppos
    );

EXTERN_C
VOID LhtQueryStatistics(
    IN      PLHT        plht,
    OUT     PLHT_STAT   pstat
    );


#endif  //  _LHT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\mdlocal.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       mdlocal.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

 * Include file for Core DS functions and data structures that are
 * internal to the DSA itself.

Author:

    DS Team

Environment:

Notes:

Revision History:

--*/

#ifndef _MDLOCAL_
#define _MDLOCAL_

#define SERVINFO_RUN_ONCE 1
#define SERVINFO_PERIODIC 0

#define GTC_FLAGS_HAS_SID_HISTORY 1

typedef struct _GROUPTYPECACHERECORD {
    DWORD DNT;
    DWORD NCDNT;
    DWORD GroupType;
    ATTRTYP Class;
    GUID   Guid;
    NT4SID Sid;
    DWORD  SidLen;
    DWORD  flags;
#if DBG == 1
    DWORD Hits;
#endif
} GROUPTYPECACHERECORD;

typedef struct _GROUPTYPECACHEGUIDRECORD {
    GUID guid;
    DWORD DNT;
} GROUPTYPECACHEGUIDRECORD;



VOID
GroupTypeCachePostProcessTransactionalData (
        THSTATE * pTHS,
        BOOL fCommit,
        BOOL fCommitted
        );

VOID
GroupTypeCacheAddCacheRequest (
        ULONG ulDNT
        );

BOOL
GetGroupTypeCacheElement (
        GUID  *pGuid,
        ULONG *pulDNT,
        GROUPTYPECACHERECORD *pGroupTypeCacheRecord);

VOID
InvalidateGroupTypeCacheElement(
        ULONG ulDNT
        );

extern BOOL gulDoNicknameResolution;
extern BOOL gbDoListObject;
extern BOOL gbLoadMapi;
extern ULONG gulTombstoneLifetimeSecs;
extern BOOL gbFsmoGiveaway;
extern HANDLE hMailReceiveThread;
extern BOOL gfTaskSchedulerInitialized;
extern BOOL gfDisableBackgroundTasks;
extern BOOL gfIsSynchronized;
extern BOOL gResetAfterInstall;
extern BOOL gbLDAPusefPermissiveModify;

int NoDelCriticalObjects(DSNAME *pObj, ULONG DNT);
int LocalRead(THSTATE *pTHS, READARG *pReadArg, READRES *pReadRes);
int LocalRemove(THSTATE *pTHS, REMOVEARG *pRemoveArg);
int LocalAdd(THSTATE *pTHS, ADDARG *pAddArg, BOOL fAddingDeleted);
int LocalModify(THSTATE *pTHS, MODIFYARG *pModifyArg);
int LocalRenameDSA(THSTATE *pTHS, DSNAME *pNewDSA);

BOOL
GetWellKnownDNT (
        DBPOS   *pDB,
        GUID *pGuid,
        DWORD *pDNT
        );

int
LocalModifyDN(THSTATE *pTHS,
              MODIFYDNARG *pModifyDNArg,
              MODIFYDNRES *pModifyDNRes);

int
LocalSearch (
        THSTATE *pTHS,
        SEARCHARG *pSearchArg,
        SEARCHRES *pSearchRes,
        DWORD flags);

/* Check that an RDN doesn't violate any extra naming requirements.  */
extern DWORD
fVerifyRDN(WCHAR *pRDN, ULONG ulRDN);

// Find the DNT of the NC that pDN is in.  Return it in pncdnt
// Note: sets error in pTHStls.
#define FINDNCDNT_ALLOW_DELETED_PARENT    ( TRUE )
#define FINDNCDNT_DISALLOW_DELETED_PARENT ( FALSE )

#define FINDNCDNT_ALLOW_PHANTOM_PARENT    ( TRUE  )
#define FINDNCDNT_DISALLOW_PHANTOM_PARENT ( FALSE )

ULONG FindNcdntSlowly(
    IN  DSNAME * pdnObject,
    IN  BOOL     fAllowDeletedParent,
    IN  BOOL     fAllowPhantomParent,
    OUT ULONG *  pncdnt
    );

// By definition this one doesn't allow phantom parents
ULONG FindNcdntFromParent(
    IN  RESOBJ * pParent,
    IN  BOOL     fAllowDeletedParent,
    OUT ULONG *  pncdnt
    );


// This structure defines a retired DSA Signature
// Obsolete format used prior to Win2k RTM RC1.
typedef struct _REPL_DSA_SIGNATURE_OLD
{
    UUID uuidDsaSignature;      // uuid representing the DSA signature that has
                                //   been retired
    SYNTAX_TIME timeRetired;    // time when the signature was retired
} REPL_DSA_SIGNATURE_OLD;

// This structure defines retired DSA Signature vector that is stored on an
// ntdsDSA object.
// Obsolete format used in Win2k beta 3.
typedef struct _REPL_DSA_SIGNATURE_VECTOR_OLD
{
    DWORD cNumSignatures;
    REPL_DSA_SIGNATURE_OLD rgSignature[1];
} REPL_DSA_SIGNATURE_VECTOR_OLD;

// useful macros
#define ReplDsaSignatureVecOldSizeFromLen(cNumSignatures)       \
    (offsetof(REPL_DSA_SIGNATURE_VECTOR_OLD, rgSignature[0])    \
     + (cNumSignatures) * sizeof(REPL_DSA_SIGNATURE_OLD))

#define ReplDsaSignatureVecOldSize(pSignatureVec) \
    ReplDsaSignatureVecOldSizeFromLen((pSignatureVec)->cNumSignatures)

typedef struct _REPL_DSA_SIGNATURE_V1 {
    UUID        uuidDsaSignature;   // uuid representing the DSA signature that
                                    //   has been retired
    SYNTAX_TIME timeRetired;        // time when the signature was retired
    USN         usnRetired;         // local usn at which sig was retired
} REPL_DSA_SIGNATURE_V1;

typedef struct _REPL_DSA_SIGNATURE_VECTOR_V1 {
    DWORD                   cNumSignatures;
    REPL_DSA_SIGNATURE_V1   rgSignature[1];
} REPL_DSA_SIGNATURE_VECTOR_V1;

typedef struct _REPL_DSA_SIGNATURE_VECTOR {
    DWORD   dwVersion;
    union {
        REPL_DSA_SIGNATURE_VECTOR_V1    V1;
    };
} REPL_DSA_SIGNATURE_VECTOR;

#define ReplDsaSignatureVecV1SizeFromLen(cNumSignatures)       \
    (offsetof(REPL_DSA_SIGNATURE_VECTOR, V1)                   \
     + offsetof(REPL_DSA_SIGNATURE_VECTOR_V1, rgSignature[0])  \
     + (cNumSignatures) * sizeof(REPL_DSA_SIGNATURE_V1))

#define ReplDsaSignatureVecV1Size(pSignatureVec) \
    ReplDsaSignatureVecV1SizeFromLen((pSignatureVec)->V1.cNumSignatures)


// Do appropriate security and schema checks before allowing new object.
// Used in LocalAdd and in LocalModifyDN
int
CheckParentSecurity (
        RESOBJ *pParent,
        CLASSCACHE *pObjSch,
        BOOL fAddingDeleted,
        PSECURITY_DESCRIPTOR *pNTSD,
        ULONG *cbNTSD);

PDSNAME
mdGetExchangeDNForAnchor (
        THSTATE  *pTHS,
        DBPOS    *pDB
        );

/* This function invokes our garbage collection utility
   which removes all logically deleted objects that have aged
   beyond a certain point.
*/

USHORT
Garb_Collect(
DSTIME    AgeOutDate );

VOID
GarbageCollection(
    ULONG *pNextPeriod );

VOID
Garb_Collect_EntryTTL(
    IN DSTIME       AgeOutDate,
    IN OUT ULONG    *pulSuccessCount,
    IN OUT ULONG    *pulFailureCount,
    IN OUT ULONG    *pulNextSecs );

DWORD
DeleteExpiredEntryTTL(
    OUT ULONG   *pulNextSecs );

extern ULONG gulGCPeriodSecs;
extern LONG DynamicObjectDefaultTTL;
extern LONG DynamicObjectMinTTL;

void
SearchPerformanceLogging (void);

int
ReSetNamingAtts (
        THSTATE *pTHS,
        RESOBJ *pResObj,
        DSNAME *pNewParent,
        ATTR *pNewRDN,
        BOOL fCheckRDNConstraints,
        BOOL fAllowPhantomParent,
        CLASSCACHE *pClassSch
        );

/* This function sets an update error for output */

#define SetUpdError(p, e)  DoSetUpdError(p, e, 0,  DSID(FILENO,__LINE__))
#define SetUpdErrorEx(p, e, d) DoSetUpdError(p, e, d,  DSID(FILENO,__LINE__))

int APIENTRY
DoSetUpdError (
        USHORT problem,
        DWORD extendedErr,
        DWORD extendedData,
        DWORD dsid);


/* This function sets a name error for output. */

#define SetNamError(p, pDN, e) \
        DoSetNamError(p, pDN, e, 0, DSID(FILENO,__LINE__))
#define SetNamErrorEx(p, pDN, e, d) \
        DoSetNamError(p, pDN, e, d, DSID(FILENO,__LINE__))

int APIENTRY
DoSetNamError (
        USHORT problem,
        DSNAME *pDN,
        DWORD extendedErr,
        DWORD extendedData,
        DWORD dsid
        );

/* This function sets a security error for output */

#define SetSecError(p, e) DoSetSecError(p, e, 0, DSID(FILENO,__LINE__))
#define SetSecErrorEx(p, e, d) DoSetSecError(p, e, d, DSID(FILENO,__LINE__))

int APIENTRY
DoSetSecError (
        USHORT problem,
        DWORD extendedErr,
        DWORD extendedData,
        DWORD dsid);

/* This function sets a service error for output */
#define SetSvcError(p, e) DoSetSvcError(p, e, 0, DSID(FILENO,__LINE__))
#define SetSvcErrorEx(p, e, d) DoSetSvcError(p, e, d, DSID(FILENO,__LINE__))

int APIENTRY
DoSetSvcError(
        USHORT problem,
        DWORD extendedErr,
        DWORD extendedData,
        DWORD dsid);


/* This function sets a system error for output */

#define SetSysError(p, e) DoSetSysError(p, e, 0, DSID(FILENO,__LINE__))
#define SetSysErrorEx(p, e, d) DoSetSysError(p, e, d, DSID(FILENO,__LINE__))

int APIENTRY
DoSetSysError (
        USHORT problem,
        DWORD extendedErr,
        DWORD extendedData,
        DWORD dsid);

/* This function sets the att error.  Each call will add a new problem
   to the list.  The object name is only set the first time.  pVal can be
   set to NULL if not needed.
*/

#define SetAttError(pDN, aTyp, p, pAttVal, e) \
          DoSetAttError(pDN, aTyp, p, pAttVal, e, 0, DSID(FILENO,__LINE__))
#define SetAttErrorEx(pDN, aTyp, p, pAttVal, e, d) \
          DoSetAttError(pDN, aTyp, p, pAttVal, e, d, DSID(FILENO,__LINE__))

int APIENTRY
DoSetAttError (
        DSNAME *pDN,
        ATTRTYP aTyp,
        USHORT problem,
        ATTRVAL *pAttVal,
        DWORD extendedErr,
        DWORD extendedData,
        DWORD dsid);


/* In many cases processing will continue even with an attibute error.  This
   macro ensures that we were able to generate an attribute error since it
   is possible that we will generate a size error instead if we don't have
   enough space.  We return if an attribute error was not generated.
   Otherwise we continue.
*/

#define SAFE_ATT_ERROR(pDN,aTyp,problem,pVal,extendedErr)         \
   if (SetAttErrorEx((pDN),(aTyp),(problem),(pVal),(extendedErr), 0) \
                                             != attributeError){     \
      DPRINT1(2,"An attribute error was not safely generated"        \
                "...returning<%u>\n", (pTHStls)->errCode);              \
      return (pTHStls)->errCode;                                        \
   }                                                                 \
   else

#define SAFE_ATT_ERROR_EX(pDN,aTyp,problem,pVal,extendedErr,extendedData)  \
   if (SetAttErrorEx((pDN),(aTyp),(problem),(pVal),(extendedErr), \
                                                        (extendedData)) \
                                             != attributeError){     \
      DPRINT1(2,"An attribute error was not safely generated"        \
                "...returning<%u>\n", (pTHStls)->errCode);              \
      return (pTHStls)->errCode;                                        \
   }                                                                 \
   else

/* This function sets a referral error.  Each call will add a new access pnt
   to the list.  The contref info and base object name is only set the
   first time.
*/
#define SetRefError(pDN, aliasRDN, pOpState,                              \
                    RDNsInternal, refType, pDSA, e)                       \
                DoSetRefError(pDN, aliasRDN, pOpState, RDNsInternal,      \
                              refType, pDSA, e, 0, DSID(FILENO,__LINE__))

#define SetRefErrorEx(pDN, aliasRDN, pOpState,                            \
                      RDNsInternal, refType, pDSA, e, d)                  \
                DoSetRefError(pDN, aliasRDN, pOpState, RDNsInternal,      \
                              refType, pDSA, e, d, DSID(FILENO,__LINE__))

int APIENTRY
DoSetRefError(DSNAME *pDN,
              USHORT aliasRDN,
              NAMERESOP *pOpState,
              USHORT RDNsInternal,
              USHORT refType,
              DSA_ADDRESS *pDSA,
              DWORD extendedErr,
              DWORD extendedData,
              DWORD dsid);

// This routine takes exception information and stuffs it into a THSTATE
void
HandleDirExceptions(DWORD dwException,
                    ULONG ulErrorCode,
                    ULONG dsid);

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Initializes DSA by getting the DSAname and address from lanman and
   loading the knowledge information (REFS and NCs)
   associated with the DSA into memory.
*/

int APIENTRY InitDSAInfo(void);

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Loads the global gpRootDomainSid with the root domain's Sid, which
   is used for  SD conversions during schema cache load and during install.
*/

extern PSID gpRootDomainSid;
void LoadRootDomainSid();

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Initializes DSA by getting the DSAname and address from lanman and
   loading the knowledge information (REFS and NCs)
   associated with the DSA into memory.
*/

int APIENTRY LoadSchemaInfo(THSTATE *pTHS);


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Rebuild the cache that holds cross and superior knowledge references.

   Basically,  the cross references and seperior reference for this DSA
   reside as sibling objects of the DSA object itself.  The DSA object is
   a child of the DSA Application Process object.  The steps are as follows:

 - We free all existing cross references and the superior reference.

 - We retrieve the DSA AP object and set a filter for the
   cross-reference  object class.  We retrieve each object and move
   it to the cache.

 - We reposition on the DSA AP, set a filter for the superior reference
   (only 1), retrieve it an relocate it to the cache.
*/

int APIENTRY  BuildRefCache(void);


void APIENTRY GetInvocationId(void);

void
APIENTRY
InitInvocationId(
    IN  THSTATE *   pTHS,
    IN  BOOL        fRestored,
    OUT USN *       pusnAtBackup    OPTIONAL
    );

// update flags in gAnchor from user-defined Options DWORD on the
// local NTDS-DSA object
DWORD UpdateGCAnchorFromDsaOptions( BOOL fInStartup );
DWORD UpdateNonGCAnchorFromDsaOptions( BOOL fInStartup );
DWORD UpdateGCAnchorFromDsaOptionsDelayed( BOOL fInStartup );

// Update gAnchor.pwszRootDomainDnsName with the value from DnsName
int UpdateRootDomainDnsName( IN WCHAR *pDnsName );

// Update gAnchor.pmtxDSA using the current gAnchor.pwszRootDomainDnsName and
// gAnchor.pDSADN->Guid.
int UpdateMtxAddress( void );

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
ULONG
GetNextObjByUsn(
    IN OUT  DBPOS *   pDB,
    IN      ULONG     ncdnt,
    IN      USN       usnSeekStart,
    OUT     USN *     pusnFound         OPTIONAL
    );

ULONG
GetNextObjOrValByUsn(
    IN OUT  DBPOS *   pDB,
    IN      ULONG     ncdnt,
    IN      USN       usnSeekStart,
    IN      BOOL      fCritical,
    IN      BOOL      fValuesOnly,
    IN      ULONG *   pulTickToTimeOut  OPTIONAL,
    IN OUT  VOID **   ppvCachingContext,
    OUT     USN *     pusnFound         OPTIONAL,
    OUT     BOOL *    pfValueChangeFound OPTIONAL
    );

#define NAME_RES_QUERY_ONLY            0x1
#define NAME_RES_CHILDREN_NEEDED       0x2
#define NAME_RES_PHANTOMS_ALLOWED      0x4
#define NAME_RES_VACANCY_ALLOWED       0x8
#define NAME_RES_IMPROVE_STRING_NAME  0x10
#define NAME_RES_GC_SEMANTICS         0x20

int DoNameRes(THSTATE *pTHS,
              DWORD dwFlags,
              DSNAME *pObj,
              COMMARG *pComArg,
              COMMRES *pComRes,
              RESOBJ **ppResObj);

RESOBJ * CreateResObj(DBPOS *pDB,
                      DSNAME * pDN);

DWORD ResolveReplNotifyDelay(
    BOOL             fFirstNotify,
    DWORD *          pdwDBVal
    );

void APIENTRY NotifyReplicas(
                             ULONG ulNcdnt,
                             BOOL fUrgent
                             );

BOOL
fHasDescendantNC(THSTATE *pTHS,
                 ATTRBLOCK *pObj,
                 COMMARG *pComArg);

//
// Macro to check if the given attribute should be sent out through
// the GC port. If it is not a member of the partial set,
// it is still sent out if it is constructed or if it is a backlink.
//


#define IS_GC_ATTRIBUTE(_pAC) ((_pAC)->bMemberOfPartialSet ||  (_pAC)->bIsConstructed || (FIsBacklink((_pAC)->ulLinkID)) )


//
// GetEntInf flags
//

#define GETENTINF_FLAG_CAN_REORDER      0x00000001  // ok to reorder selection
#define GETENTINF_FLAG_DONT_OPTIMIZE    0x00000002  // not to optimize
#define GETENTINF_NO_SECURITY           0x00000004  // Don't apply a security
                                                    // check
#define GETENTINF_GC_ATTRS_ONLY         0x00000008  // Don't return non GC attrs
#define GETENTINF_IGNORE_DUPS           0x00000010  // Don't do any sorting to
                                                    // remove duplicate attrs

//
// wrapper around the attcache pointer to include an index for use in
// attribute reordering
//

typedef struct _INDEXED_AC {

    DWORD       Index;
    ATTCACHE*   AttCache;
} INDEXED_AC, *PINDEXED_AC;


//
// Used for passing preformatted ATTCACHE arrays between GetEntInf and
// it's callers.
//

typedef struct _CACHED_AC_ {

    DWORD       nAtts; // number of entries in AC
    PDWORD      pOrderIndex;  // pointer to the index array
    DWORD       classId;  // class id of this blob
    ATTCACHE**  AC;    // pointer to the ATTCACHE array

} CACHED_AC, *PCACHED_AC;



typedef struct _CLASSSTATEINFO
{
    DWORD    cOldObjClasses_alloced;
    DWORD    cOldObjClasses;
    ATTRTYP *pOldObjClasses;

    DWORD    cNewObjClasses_alloced;
    DWORD    cNewObjClasses;
    ATTRTYP *pNewObjClasses;

    DWORD    cNewAuxClasses_alloced;
    DWORD    cNewAuxClasses;
    ATTRTYP *pNewAuxClasses;
    CLASSCACHE **pNewAuxClassesCC;

    ATTCACHE *pObjClassAC;
    BOOL     fObjectClassChanged;

    BOOL     fOperationAdd;
} CLASSSTATEINFO;

int ReadClassInfoAttribute (DBPOS *pDB,
                           ATTCACHE *pAC,
                           ATTRTYP **ppClassID,
                           DWORD    *pcClasses_alloced,
                           DWORD    *pcClasses,
                           CLASSCACHE ***ppClassCC);

int SetClassInheritance(THSTATE *pTHS,
                        CLASSCACHE **ppClassSch,
                        CLASSSTATEINFO  *pClassInfo,
                        BOOL   bSetSystemFlags,
                        DSNAME *pObject);

int
VerifyAndAdjustAuxClasses (
        THSTATE *pTHS,
        DSNAME *pObject,
        CLASSCACHE *pClassSch,
        CLASSSTATEINFO  *pClassInfo);

int
BreakObjectClassesToAuxClasses (
        THSTATE *pTHS,
        CLASSCACHE **ppClassSch,
        CLASSSTATEINFO  *pClassInfo);

int
BreakObjectClassesToAuxClassesFast (
        THSTATE *pTHS,
        CLASSCACHE *pClassSch,
        CLASSSTATEINFO  *pClassInfo);

int
CloseAuxClassList (
    THSTATE *pTHS,
    CLASSCACHE *pClassSch,
    CLASSSTATEINFO  *pClassInfo);

CLASSCACHE *
FindMoreSpecificClass(
        CLASSCACHE *pCC1,
        CLASSCACHE *pCC2
        );


// macros todo the allocation/reallocation of CLASSSTATEINFO data structures
//
#define ClassInfoAllocOrResizeElement(p,startSize,allocedSize,newSize) \
        if (!(p)) {                                                             \
            (allocedSize) = (startSize);                                        \
            (p) = THAllocEx (pTHS, sizeof (ATTRTYP) * (allocedSize) );          \
        }                                                                       \
        else if ( (allocedSize) < (newSize) ) {                                 \
            (allocedSize) = (newSize) + (startSize);                            \
            (p) = THReAllocEx (pTHS, (p), sizeof (ATTRTYP) * (allocedSize) );   \
        }


#define ClassInfoAllocOrResizeElement2(p,pCC,startSize,allocedSize,newSize) \
        if (!(p)) {                                                             \
            (allocedSize) = (startSize);                                        \
            (p) = THAllocEx (pTHS, sizeof (ATTRTYP) * (allocedSize) );          \
            (pCC) = THAllocEx (pTHS, sizeof (CLASSCACHE *) * (allocedSize) );   \
        }                                                                       \
        else if ( (allocedSize) < (newSize) ) {                                 \
            (allocedSize) = (newSize) + (startSize);                            \
            (p) = THReAllocEx (pTHS, (p), sizeof (ATTRTYP) * (allocedSize) );   \
            (pCC) = THReAllocEx (pTHS, (pCC), sizeof (CLASSCACHE *) * (allocedSize) ); \
        }


#define MIN_NUM_OBJECT_CLASSES  16


/* Retrieve object information based on the input selection list*/
int APIENTRY
GetEntInf (
        IN DBPOS *pDB,
        IN ENTINFSEL *pSel,
        IN RANGEINFSEL *pSelRange,
        IN ENTINF *pEnt,
        IN RANGEINF *pRange,
        IN ULONG SecurityDescriptorFlags,
        IN PSECURITY_DESCRIPTOR pSec,
        IN DWORD Flags,
        IN OUT PCACHED_AC CachedAC,
        IN OPTIONAL RESOBJ *pResObj);

VOID
SvccntlFlagsToGetEntInfFlags(
    IN  SVCCNTL* Svccntl,
    OUT PDWORD Flags
    );

#define SEARCH_UNSECURE_SELECT 1
#define SEARCH_AB_FILTER       2
void
SearchBody (
        THSTATE *pTHS,
        SEARCHARG *pSearchArg,
        SEARCHRES *pSearchRes,
        DWORD flags);

void DBFreeSearhRes (
    THSTATE *pTHS, 
    SEARCHRES *pSearchRes, 
    BOOL fFreeOriginal);

int SetInstanceType(THSTATE *pTHS,
                    DSNAME *pDN,
                    CREATENCINFO * pCreateNC);

int AddCatalogInfo(THSTATE *pTHS,
                   DSNAME *pDN);

int DelCatalogInfo(THSTATE *pTHS,
                   DSNAME *pDN,
                   SYNTAX_INTEGER iType);

int GetObjSchemaMod(MODIFYARG* pModifyArg, CLASSCACHE **ppClassSch);

// Find ATTR for ATT_OBJ_CLASS in the given ATTRBLOCK and return a pointer to
// the corresponding class schema structure.  Sets thread-state error on
// failure.  Also, find the GUID and SID if they are there.
int
FindValuesInEntry (
        THSTATE    *pTHS,
        ADDARG     *pAddArg,
        CLASSCACHE **ppCC,
        GUID       *pGuid,
        BOOL       *pFoundGuid,
        NT4SID     *pSid,
        DWORD      *pSidLen,
        CLASSSTATEINFO  **ppClassInfo
        );

int
CheckRenameSecurity (
        THSTATE *pTHS,
        PSECURITY_DESCRIPTOR pSecurity,
        PDSNAME pDN,
        CLASSCACHE *pCC,
        RESOBJ * pResObj,
        ATTRTYP rdnType,
        BOOL    fMove,
        RESOBJ * pResParent);

#define SECURITY_PRIVATE_OBJECT 0x1

int
CheckModifySecurity (
        THSTATE *pTHS,
        MODIFYARG *pModifyArg,
        BOOL *pfCheckDNSValues,
        BOOL *pfCheckAdditionalDNSValues,
        BOOL *pfCheckSPNValues);

int
CheckAddSecurity (
        THSTATE *pTHS,
        CLASSCACHE *pCC,
        ADDARG *pModifyArg,
        PSECURITY_DESCRIPTOR pNTSD,
        ULONG cbNTSD,
        GUID *pGuid);

void
CheckReadSecurity (
        THSTATE *pTHS,
        ULONG SecurityDescriptorFlags,
        PSECURITY_DESCRIPTOR pSecurity,
        PDSNAME pDN,
        ULONG * cInAtts,
        CLASSCACHE *pCC,
        ATTCACHE **rgpAC );

int
ModifyAuxclassSecurityDescriptor (
        THSTATE *pTHS,
        DSNAME *pDN,
        COMMARG *pCommArg,
        CLASSCACHE *pClassSch,
        CLASSSTATEINFO *pClassInfo,
        RESOBJ * pResParent);

BOOL
CheckConstraintEntryTTL (
        IN  THSTATE     *pTHS,
        IN  DSNAME      *pObject,
        IN  ATTCACHE    *pACTtl,
        IN  ATTR        *pAttr,
        OUT ATTCACHE    **ppACTtd,
        OUT LONG        *pSecs
        );

unsigned
CheckConstraint (
        ATTCACHE *pAttSchema,
        ATTRVAL *pAttVal
        );

BOOL
GetFilterSecurity (
        THSTATE *pTHS,
        FILTER *pFilter,
        ULONG   SortType,
        ATTRTYP SortAtt,
        BOOL fABFilter,
        POBJECT_TYPE_LIST *ppFilterSecurity,
        BOOL **ppbSortSkip,
        DWORD **ppResults,
        DWORD *pSecSize);

int GetObjSchema(DBPOS *pDB, CLASSCACHE **ppClassSch);
int GetObjRdnType(DBPOS *pDB, CLASSCACHE *pCC, ATTRTYP *pRdnType);
int CallerIsTrusted(THSTATE *pTHS);

int
ValidateObjClass(THSTATE *pTHS,
                 CLASSCACHE *pClassSch,
                 DSNAME *pDN,
                 ULONG cModAtts,
                 ATTRTYP *pModAtts,
                 CLASSSTATEINFO  **pClassInfo);

CLASSSTATEINFO  *ClassStateInfoCreate (THSTATE *pTHS);
void ClassStateInfoFree (THSTATE *pTHS, CLASSSTATEINFO  *pClassInfo);

struct _VERIFY_ATTS_INFO {
    DSNAME *    pObj;
    ULONG       NCDNT;   // May be INVALIDDNT if adding root of NC.
    CROSS_REF * pObjCR_DontAccessDirectly;  // use VerifyAttsGetObjCR
    DBPOS *     pDBTmp_DontAccessDirectly;  // use HVERIFYATTS_GET_PDBTMP
    ADDCROSSREFINFO * pCRInfo; // This is used when adding a cross-ref.


    // the following are used to keep track of attribute changes between calls 
    // to ModSetAttsHelper*Process functions
    DWORD         fGroupTypeChange;
    ULONG         ulGroupTypeOld;
    DWORD         fLockoutTimeUpdated;
    LARGE_INTEGER LockoutTimeNew;
    DWORD         fUpdateScriptChanged;
    LONG          NewForestVersion;
};

typedef struct _VERIFY_ATTS_INFO * HVERIFY_ATTS;

HVERIFY_ATTS
VerifyAttsBegin(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pObj,
    IN  ULONG       dntOfNCRoot,
    IN  ADDCROSSREFINFO *  pCRInfo
    );

void
VerifyAttsEnd(
    IN      THSTATE *       pTHS,
    IN OUT  HVERIFY_ATTS *  phVerifyAtts
    );

int
ReplaceAtt(
        THSTATE *pTHS,
        HVERIFY_ATTS hVerifyAtts,
        ATTCACHE *pAttSchema,
        ATTRVALBLOCK *pAttrVal,
        BOOL fCheckAttValConstraint);

int AddAtt(THSTATE *pTHS,
           HVERIFY_ATTS hVerifyAtts,
           ATTCACHE *pAttSchema,
           ATTRVALBLOCK *pAttrVal);

int AddAttType(THSTATE *pTHS,
               DSNAME *pObject,
               ATTCACHE *pAttSchema);

#define AAV_fCHECKCONSTRAINTS    1
#define AAV_fENFORCESINGLEVALUE  2
#define AAV_fPERMISSIVE          4
int
AddAttVals (
        THSTATE *pTHS,
        HVERIFY_ATTS hVerifyAtts,
        ATTCACHE *pAttSchema,
        ATTRVALBLOCK *pAttrVal,
        DWORD dwFlags);

int RemAttVals(THSTATE *pTHS,
               HVERIFY_ATTS hVerifyAtts,
               ATTCACHE *pAC,
               ATTRVALBLOCK *pAttrVal,
               BOOL fPermissive);

int InsertObj(THSTATE *pTHS,
              DSNAME *pDN,
              PROPERTY_META_DATA_VECTOR *pMetaDataVecRemote,
              BOOL bModExisting,
              DWORD dwMetaDataFlags);

DWORD
ObjCachingPreProcessTransactionalData (
        BOOL fCommit
        );
VOID
ObjCachingPostProcessTransactionalData (
        THSTATE *pTHS,
        BOOL fCommit,
        BOOL fCommitted
        );

int AddObjCaching(THSTATE *pTHS,
                  CLASSCACHE *pClassSch,
                  DSNAME *pDN,
                  BOOL fAddingDeleted,
                  BOOL fIgnoreExisting
                  );

int DelObjCaching(THSTATE *pTHS,
                  CLASSCACHE *pClassSch,
                  RESOBJ *pRes,
                  BOOL fCleanup);

int ModObjCaching(THSTATE *pTHS,
                  CLASSCACHE *pClassSch,
                  ULONG cModAtts,
                  ATTRTYP *pModAtts,
                  RESOBJ *pRes);
ULONG
AddCRToMem(THSTATE *pTHS,
           NAMING_CONTEXT *pCR,
           DSNAME *pObj,
           DWORD flags,
           WCHAR* NetbiosName,
           ULONG  NetbiosNameLen,
           WCHAR* DnsName,
           ULONG  DnsNameLen
           );
VOID
AddCRLToMem (
        struct CROSS_REF_LIST *pCRL
        );

DWORD
MakeStorableCRL(THSTATE *pTHS,
                DBPOS *pDB,
                DSNAME *pObj,
                struct CROSS_REF_LIST **ppCRL,
                BOOL   fIgnoreExisting);

BOOL
DelCRFromMem(THSTATE *pTHS,
             NAMING_CONTEXT *pCR);

ULONG
ValidateCRDeletion(THSTATE *pTHS,
                   DSNAME  *pDN);

VOID
ModCrossRefCaching(
    THSTATE *pTHS,
    CROSS_REF *pCR
    );

int AddClassToSchema(void);

int DelClassFromSchema(void);

int ModClassInSchema(void);

int AddAttToSchema(void);

int DelAttFromSchema(void);

int ModAttInSchema(void);

int ModLocalDsaObj(void);

int APIENTRY RebuildLocalScopeInternally(void);

int GetExistingAtt(DBPOS *pDB, ATTRTYP type,
                          void *pOutBuf, ULONG cbOutBuf);


#define  PHANTOM_CHECK_FOR_FSMO    1
#define  PHANTOM_IS_PHANTOM_MASTER 2

void
PhantomCleanupLocal (
        DWORD * pcSecsUntilNextIteration,
        BOOL  * pIsPhantomMaster
        );

BOOL
IsObjVisibleBySecurity (THSTATE *pTHS, BOOL  fUseCache);


BOOL
IsAccessGrantedParent (
        ACCESS_MASK ulAccessMask,
        CLASSCACHE *pCC,
        BOOL fSetError
        );

BOOL
IsAccessGrantedAddGuid (
        DSNAME  *pDN,
        COMMARG *pCommArg
        );

DWORD
FindFirstObjVisibleBySecurity(
    THSTATE       *pTHS,
    ULONG          ulDNT,
    DSNAME       **ppParent
    );

DWORD
CheckObjDisclosure(
    THSTATE       *pTHS,
    RESOBJ        *pResObj,
    BOOL          fCheckForSecErr
    );

extern const GUID RIGHT_DS_CHANGE_INFRASTRUCTURE_MASTER;
extern const GUID RIGHT_DS_CHANGE_SCHEMA_MASTER;
extern const GUID RIGHT_DS_CHANGE_RID_MASTER;
extern const GUID RIGHT_DS_CHANGE_DOMAIN_MASTER;
extern const GUID RIGHT_DS_DO_GARBAGE_COLLECTION;
extern const GUID RIGHT_DS_RECALCULATE_HIERARCHY;
extern const GUID RIGHT_DS_RECALCULATE_SECURITY_INHERITANCE;
extern const GUID RIGHT_DS_CHECK_STALE_PHANTOMS;
extern const GUID RIGHT_DS_UPDATE_SCHEMA_CACHE;
extern const GUID RIGHT_DS_ALLOCATE_RIDS;
extern const GUID RIGHT_DS_OPEN_ADDRESS_BOOK;
extern const GUID RIGHT_DS_CHANGE_PDC;
extern const GUID RIGHT_DS_ADD_GUID;
extern const GUID RIGHT_DS_REPL_GET_CHANGES;
extern const GUID RIGHT_DS_REPL_SYNC;
extern const GUID RIGHT_DS_REPL_MANAGE_TOPOLOGY;
extern const GUID RIGHT_DS_REPL_MANAGE_REPLICAS;
extern const GUID RIGHT_DS_REFRESH_GROUP_CACHE;

BOOL
IsControlAccessGranted (
        PSECURITY_DESCRIPTOR pNTSD,
        PDSNAME pDN,
        CLASSCACHE *pCC,
        GUID pControlGuid,
        BOOL fSetError
        );

BOOL
IsAccessGrantedAttribute (
        THSTATE *pTHS,
        PSECURITY_DESCRIPTOR pNTSD,
        PDSNAME pDN,
        ULONG  cInAtts,
        CLASSCACHE *pCC,
        ATTCACHE **rgpAC,
        ACCESS_MASK ulAccessMask,
        BOOL fSetError
        );

BOOL
IsAccessGranted (
        PSECURITY_DESCRIPTOR pNTSD,
        PDSNAME pDN,
        CLASSCACHE *pCC,
        ACCESS_MASK ulAccessMask,
        BOOL fSetError
        );

BOOL
IsAccessGrantedSimple (
        ACCESS_MASK ulAccessMask,
        BOOL fSetError
        );

ATTRTYP KeyToAttrType(THSTATE *pTHS,
                      WCHAR * pKey,
                      unsigned cc);

typedef struct _OID {
    int cVal;
    unsigned *Val;
} OID;

unsigned EncodeOID(OID *pOID, unsigned char * pEncoded, unsigned ccEncoded);
BOOL DecodeOID(unsigned char *pEncoded, int len, OID *pOID);

OidStringToStruct(
                  THSTATE *pTHS,
                  WCHAR * pString,
                  unsigned len,
                  OID * pOID);

unsigned
OidStructToString(
                  OID *pOID,
                  WCHAR *pOut,
                  ULONG ccOut);
unsigned
AttrTypeToIntIdString (
        ATTRTYP attrtyp,
        WCHAR   *pOut,
        ULONG   ccOut
        );
int
AttrTypToString (
        THSTATE *pTHS,
        ATTRTYP attrTyp,
        WCHAR *pOutBuf,
        ULONG cLen
        );


int
StringToAttrTyp (
        THSTATE *pTHS,
        WCHAR   *pInString,
        ULONG   len,
        ATTRTYP *pAttrTyp
        );

extern int APIENTRY
AddNCToDSA(THSTATE *pTHS,
           ATTRTYP listType,
           DSNAME *pDN,
           SYNTAX_INTEGER iType);

extern DWORD
AddInstantiatedNC(
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDBCat,
    IN  DSNAME *            pDN,
    IN  SYNTAX_INTEGER      iType,
    IN  BOOL                fStartup
    );

extern DWORD
RemoveInstantiatedNC(
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDB,
    IN  DSNAME *            pDN
    );

extern DWORD
RemoveAllInstantiatedNCs(
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDB
    );


extern int APIENTRY
DelNCFromDSA(THSTATE *pTHS,
             ATTRTYP listType,
             DSNAME *pDN);

extern int APIENTRY
AddSubToNC(THSTATE *pTHS,
           DSNAME *pDN,
           DWORD dsid);

extern int APIENTRY
DelSubFromNC(THSTATE *pTHS,
             DSNAME *pDN,
             DWORD dsid);

#define PARENTMASTER  0x0001     /*The parent object must be a master*/
#define PARENTFULLREP 0x0002     /*The parent object must be a replica*/

extern int APIENTRY
      ParentExists(ULONG requiredParent, DSNAME *pDN);

extern int APIENTRY NoChildrenExist(RESOBJ *pRes);

extern void
RebuildCatalog(void * pv,
              void ** ppvNext,
              DWORD * pcSecsUntilNextIteration );

extern  DSNAME *FindNCParentDSName(DSNAME *pDN, BOOL masterOnly,
                                   BOOL parentOnly);

extern int
MoveSUBInfoToParentNC(THSTATE *pTHS,
                      DSNAME *pDN);

extern int
MoveParentSUBInfoToNC(THSTATE *pTHS,
                      DSNAME *pDN);


/* from mdname.c */

CROSS_REF *
FindBestCrossRef(const DSNAME *pObj,
                 const COMMARG *pComArg);

CROSS_REF *
FindExactCrossRef(const DSNAME *pObj,
                  const COMMARG *pComArg);

CROSS_REF *
FindExactCrossRefForAltNcName(
                  ATTRTYP attrTyp,
                  ULONG crFlags,
                  const WCHAR * pwszVal);

BOOL
IsCrossRefProtectedFromDeletion(
    IN DSNAME * pDN
    );

int
GenSubRef(NAMING_CONTEXT * pSubNC,
          DSNAME *pObj,
          COMMARG *pComArg);

DWORD
AdjustDNSPort(
        WCHAR *pString,
        DWORD cbString,
        BOOL  fFirst
        );

int
GenCrossRef(CROSS_REF *pCR,
            DSNAME *pObj);

int
GenSupRef(THSTATE *pTHS,
          DSNAME *pObj,
          ATTRBLOCK *pObjB,
          const COMMARG *pComArg,
          DSA_ADDRESS *pDA);

CROSS_REF *
FindCrossRef(const ATTRBLOCK *pObj,
             const COMMARG *pComArg);

void
SpliceDN(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pOriginalDN,
    IN  DSNAME *    pNewParentDN,   OPTIONAL
    IN  WCHAR *     pwchNewRDN,     OPTIONAL
    IN  DWORD       cchNewRDN,      OPTIONAL
    IN  ATTRTYP     NewRDNType,     OPTIONAL
    OUT DSNAME **   ppNewDN
    );

unsigned
BlockNamePrefix(THSTATE *pTHS,
                const ATTRBLOCK *pPrefix,
                const ATTRBLOCK *pDN);

unsigned
GetTopNameComponent(const WCHAR *pName,
                    unsigned ccName,
                    const WCHAR **ppKey,
                    unsigned *pccKey,
                    const WCHAR **ppVal,
                    unsigned *pccVal);

int DelAutoSubRef(DSNAME *pCR);

int
AddPlaceholderNC(
    IN OUT  DBPOS *         pDBTmp,
    IN OUT  DSNAME *        pNCName,
    IN      SYNTAX_INTEGER  it
    );

// Given a DSName, fill in the GUID and SID from the object you get by looking
// up the DSNAME.
DWORD
FillGuidAndSid (
        IN OUT DSNAME *pDN
        );

#define IsDNSepChar(x) (((x) == L',') || ((x) == L';'))

// Returns TRUE if this is the root
BOOL IsRoot(const DSNAME *pName);

// Convert from a DSNAME to a name in ATTRBLOCK format
unsigned DSNameToBlockName(THSTATE *pTHS,
                           const DSNAME *pDSName,
                           ATTRBLOCK ** ppBlockName,
                           BOOL fLowerCase
                           );
#define DN2BN_PRESERVE_CASE ( FALSE )
#define DN2BN_LOWER_CASE    ( TRUE )

// Free a block name returned by DSNameToBlockName
void FreeBlockName (ATTRBLOCK * pBlockName);

// convert a BLOCKNAME to DSName
DWORD BlockNameToDSName (THSTATE *pTHS, ATTRBLOCK * pBlockName, DSNAME **ppName);

//
// Converts a X500 Name to Ldap Convention
//
VOID
ConvertX500ToLdapDisplayName
(
    WCHAR* x500Name,
    DWORD  Len,
    WCHAR* LdapName,
    DWORD* RetLen
);

// Mangle an RDN to avoid name conflicts.  NOTE: pszRDN must be pre-allocated
// to hold at least MAX_RDN_SIZE WCHARs.
VOID
MangleRDN(
    IN      MANGLE_FOR  eMangleFor,
    IN      GUID *      pGuid,
    IN OUT  WCHAR *     pszRDN,
    IN OUT  DWORD *     pcchRDN
    );

BOOL
IsMangledDSNAME(
    DSNAME *pDSName
    );

// Check if this rename operation has to exempted from Rename restriction
BOOL
IsExemptedFromRenameRestriction(THSTATE *pTHS, MODIFYDNARG *pModifyDNArg);

// Copy ATTRBLOCK format name into single chunk of permanent memory
ATTRBLOCK * MakeBlockNamePermanent(ATTRBLOCK * pName);

VOID
CheckNCRootNameOwnership(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC
    );


// C++ code in the core DS introduces potential problems with new/delete.
// This is because new'd items are not guaranteed to be cleaned up
// correctly during exception handling. In the typical case, allocations
// occur from the thread heap, but not always.  There being no way to tell
// new/delete which behaviour is desired, we redefine new/delete to generate
// a compiler error.  Astute developers should notice this before checkin
// and take appropriate action.  Implementing an asserting or exception
// raising new/delete is not an option as other C++ DS components which
// link with core.lib might get this version depending on the link order.

#define new     NEW_NOT_SUPPORTED_IN_CORE
#define delete  DELETE_NOT_SUPPORTED_IN_CORE

// This Unicode character is not allowed in a DS name.
#define BAD_NAME_CHAR 0x000A

// A globally available valid DSNAME of the root...
extern DSNAME * gpRootDN;
// ...and the same thing as a BLOCKNAME
extern ATTRBLOCK * gpRootDNB;

//
// The functions below set/check the state of the Dsa based on the value of
// the gInitPhase global variable.

extern BOOLEAN DsaIsInstalling();
extern BOOLEAN DsaIsRunning();
extern VOID DsaSetIsInstalling();
extern VOID DsaSetIsRunning();

// the following functions deal with SingleUserMode manipulations
extern BOOL __fastcall DsaIsSingleUserMode (void);
extern void DsaSetMultiUserMode();
extern BOOL DsaSetSingleUserMode();

// the function below keep track of if we are installing from media

extern BOOLEAN DsaIsInstallingFromMedia();
extern VOID DsaSetIsInstallingFromMedia();

//
// This function is used to set when the machine fully installed because it
// has done its first full sync
VOID DsaSetIsSynchronized( BOOL f );

//
// This function tests whether the ds is not fully installed
BOOL DsIsBeingBackSynced();

// Given a requested right, a security descriptor, and a SID, check to see what
// attributes in the provided list have the requested right granted
typedef enum {
    csacaAllAccessGranted = 1,
    csacaAllAccessDenied,
    csacaPartialGrant
} CSACA_RESULT;

CSACA_RESULT
CheckSecurityAttCacheArray (
        THSTATE *pTHS,
        DWORD RightRequested,
        PSECURITY_DESCRIPTOR pSecurity,
        PDSNAME pDN,
        ULONG  cInAtts,
        CLASSCACHE *pCC,
        ATTCACHE **rgpAC,
        DWORD flags
        );

// Given a requested right, a security descriptor, and a SID, check to see what
// classes in the provided list have the requested right granted
DWORD
CheckSecurityClassCacheArray (
        THSTATE *pTHS,
        DWORD RightRequested,
        PSECURITY_DESCRIPTOR pSecurity,
        PDSNAME pDN,
        ULONG  cInClass,
        CLASSCACHE **rgpCC
        );

// Helper function to extract the DSNAME out of various DN-valued
// attributes.

extern
PDSNAME
DSNameFromAttrVal(ATTCACHE *pAC, ATTRVAL *pAttrVal);

void APIENTRY
AddNCToMem(DWORD dwCatalog, DSNAME *pDN);

void APIENTRY
DelNCFromMem(DWORD dwCatalog, DSNAME *pDN);

DWORD MakeNCEntry(IN DSNAME *pDN, OUT NAMING_CONTEXT_LIST **ppNCL);

VOID FreeNCEntry(NAMING_CONTEXT_LIST *pNCL);

NAMING_CONTEXT_LIST *
FindNCLFromNCDNT(DWORD NCDNT,
                 BOOL fMasterOnly);

NAMING_CONTEXT * FindNamingContext(ATTRBLOCK *pObj,
                                   COMMARG *pComArg);

//
// Converts a text representation of a security descriptor into a real one
//
DWORD
ConvertTextSecurityDescriptor (
    IN  PWSTR                   pwszTextSD,
    OUT PSECURITY_DESCRIPTOR   *ppSD,
    OUT PULONG                  pcSDSize
    );


// Bit flags for CheckPermissionsAnyClient.
#define CHECK_PERMISSIONS_WITHOUT_AUDITING 1
#define CHECK_PERMISSIONS_FLAG_MASK        1


//
// Permission checking. Returns 0 if permission checking was successful.
// On success *pAccessStatus is set to true if access is granted and false
// otherwise. On failure a detailed error code is available. This function
// assumes that it is being called within the security context of the
// client, i.e. that some flavor of client impersonation has been called.
//
// Returns:
// 0 if successful. On failure the result of GetLastError() immediately
// following the unsuccessful win32 api call.
//

DWORD
CheckPermissionsAnyClient(
    PSECURITY_DESCRIPTOR pSelfRelativeSD, // Security descriptor to test
    PDSNAME pDN,                          // DN of the object. We only
                                          // care about the GUID and
                                          // the SID
    ACCESS_MASK ulDesiredAccess,          // Desired access mask
    POBJECT_TYPE_LIST pObjTypeList,       // Desired guids to check
    DWORD cObjTypeList,                   // Number of entries in list
    ACCESS_MASK *pGrantedAccess,          // What access was granted
    DWORD *pAccessStatus,                 // 0 = all granted; !0=denied
    DWORD flags,
    OPTIONAL AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzCtx  // grab context from THSTATE by default
    );


// ========================================================
// Authz framework routines
// ========================================================

// Initializes global Authz RM
DWORD
InitializeAuthzResourceManager();

// releases global Authz RM
DWORD
ReleaseAuthzResourceManager();

extern AUTHZ_RESOURCE_MANAGER_HANDLE ghAuthzRM; // global AuthZ resource manager handle

// create a new client context
PAUTHZ_CLIENT_CONTEXT NewAuthzClientContext();

//
// Privilege checking. Returns 0 if privilege checking was successful.
// pResult says whether privilege was held. On failure a detailed error code is
// available. This function does not assume that it is being called within the
// security context of the client, i.e. that some flavor of client impersonation
// has been called. It does assume that some impersonation may be done.
//
DWORD
CheckPrivilegeAnyClient(
    IN DWORD privilege,
    OUT BOOL *pResult
    );


// Verify RPC caller is an authenticated user.

DWORD
VerifyRpcClientIsAuthenticatedUser(
    VOID            *Context,
    GUID            *InterfaceUuid);

// Bit flags for MergeSecurityDescriptorAnyClient.  Default behaviour is to do a
// normal merge (not creating a brand new SD) where we have the ability to
// impersonate a client.

#define MERGE_CREATE   1                // We're creating a new Security
                                        // Descriptor from a parent SD and an SD
                                        // specified for the object.  Default is
                                        // to assume we are trying to write a
                                        // new SD on an object that already has
                                        // an SD
#define MERGE_AS_DSA   2                // We are doing this in the context of
                                        // the DSA itself, meaning we can't
                                        // impersonate a client.
#define MERGE_DEFAULT_SD 4              // The SD provided is the default SD from
                                        // the schema.
#define MERGE_OWNER    8                // The SD prvoided lacks the OWNER and/or
                                        // group fields, Add these fields to the
                                        // SD, in most cases this will involve
                                        // impersonating the client.

DWORD
ValidateSPNsAndDNSHostName (
        THSTATE    *pTHS,
        DSNAME     *pDN,
        CLASSCACHE *pCC,
        BOOL        fCheckDNSHostNameValue,
        BOOL        fCheckAdditionalDNSHostNameValue,
        BOOL        fCheckSPNValues,
        BOOL        fNewObject
        );

DWORD
WrappedMakeSpnW(
        THSTATE *pTHS,
        WCHAR   *ServiceClass,
        WCHAR   *ServiceName,
        WCHAR   *InstanceName,
        USHORT  InstancePort,
        WCHAR   *Referrer,
        DWORD   *pcbSpnLength, // Note this is somewhat different that DsMakeSPN
        WCHAR  **ppszSpn
        );

DWORD
MergeSecurityDescriptorAnyClient(
        IN  PSECURITY_DESCRIPTOR pParentSD,
        IN  ULONG                cbParentSD,
        IN  PSECURITY_DESCRIPTOR pCreatorSD,
        IN  ULONG                cbCreatorSD,
        IN  SECURITY_INFORMATION SI,
        IN  DWORD                flags,
        IN  GUID                 **ppGuid,
        IN  ULONG                GuidCount,
        OUT PSECURITY_DESCRIPTOR *ppMergedSD,
        OUT ULONG                *cbMergedSD
        );

BOOL
IAmWhoISayIAm (
        IN PSID pSid,
        IN DWORD cbSid
    );

DWORD
GetPlaceholderNCSD(
    IN  THSTATE *               pTHS,
    OUT PSECURITY_DESCRIPTOR *  ppSD,
    OUT DWORD *                 pcbSD
    );

ULONG ErrorOnShutdown(void);

//
// drive/volume mapping stuff
//

typedef struct DS_DRIVE_MAPPING_ {

    BOOL    fUsed:1;        // used by the DS
    BOOL    fChanged:1;     // letter and mapping changed
    BOOL    fListed:1;      // in reg key

    INT     NewDrive;    // drive index.  -1 if invalid.

} DS_DRIVE_MAPPING, *PDS_DRIVE_MAPPING;

#define DS_MAX_DRIVES   26      // A to Z

VOID
DBInitializeDriveMapping(
    IN PDS_DRIVE_MAPPING DriveMapping
    );

VOID
ValidateDsPath(
    IN LPSTR  Parameter,
    IN LPSTR  szPath,
    IN DWORD  Flags,
    IN PBOOL  fSwitched, OPTIONAL
    IN PBOOL  fDriveChanged OPTIONAL
    );

//
// Flags used for validatedspath
//

#define VALDSPATH_DIRECTORY         0x1
#define VALDSPATH_USE_ALTERNATE     0x2
#define VALDSPATH_ROOT_ONLY         0x4


// Global configuration variables
extern ULONG gulAOQAggressionLimit;
extern ULONG gulDraThreadOpPriThreshold;
extern int   gnDraThreadPriHigh;
extern int   gnDraThreadPriLow;
extern int   giDCFirstDsaNotifyOverride;
extern int   giDCSubsequentDsaNotifyOverride;
extern ULONG gcMaxIntraSiteObjects;
extern ULONG gcMaxIntraSiteBytes;
extern ULONG gcMaxInterSiteObjects;
extern ULONG gcMaxInterSiteBytes;
extern ULONG gcMaxAsyncInterSiteObjects;
extern ULONG gcMaxAsyncInterSiteBytes;
extern ULONG gulDrsCtxHandleLifetimeIntrasite;
extern ULONG gulDrsCtxHandleLifetimeIntersite;
extern ULONG gulDrsCtxHandleExpiryCheckInterval;
extern ULONG gulDrsRpcBindTimeoutInMins;
extern ULONG gulDrsRpcReplicationTimeoutInMins;
extern ULONG gulDrsRpcGcLookupTimeoutInMins;
extern ULONG gulDrsRpcMoveObjectTimeoutInMins;
extern ULONG gulDrsRpcNT4ChangeLogTimeoutInMins;
extern ULONG gulDrsRpcObjectExistenceTimeoutInMins;
extern ULONG gulDrsRpcGetReplInfoTimeoutInMins;
extern ULONG gcMaxTicksToGetSDPLock;
extern ULONG gcMaxTicksMailSendMsg;
extern ULONG gcMaxMinsSlowReplWarning;
extern ULONG gcSearchInefficientThreshold;
extern ULONG gcSearchExpensiveThreshold;
extern ULONG gulInteserctExpenseRatio;
extern ULONG gulMaxRecordsWithoutIntersection;
extern ULONG gulEstimatedAncestorsIndexSize;
extern ULONG gulReplQueueCheckTime;
extern ULONG gulReplLatencyCheckInterval;
extern ULONG gulLdapIntegrityPolicy;
extern ULONG gulDraCompressionLevel;


//
// Defines whether DSID will be returned.  Since DSID can reveal
// directory information, very high security sites may want to 
// prevent them from being returned.
//
#define DSID_REVEAL_ALL        0
#define DSID_HIDE_ON_NAME_ERR  1
#define DSID_HIDE_ALL          2
extern ULONG gulHideDSID;


// The maximum time (in msec) that a transaction should be allowed to be open
// during normal operation (e.g., unless we're stress testing huge group
// replication, etc.).
#define MAX_TRANSACTION_TIME   30 * 60 * 1000L    // 30 minutes

ULONG
DoSecurityChecksForLocalAdd(
    ADDARG         *pAddArg,
    CLASSCACHE     *pCC,
    GUID           *NewObjectGuid,
    BOOL           fAddingDeleted
    );

ULONG
CheckRemoveSecurity(
        BOOL fTree,
        CLASSCACHE * pCC,
        RESOBJ     *pResObj );

ULONG
CheckIfEntryTTLIsAllowed(
        THSTATE *pTHS,
        ADDARG  *pAddArg );

// Globals holding the Kerberos principal name, read during RPC startup, used
// constantly by the LDAP head.
extern ULONG gulLDAPServiceName;
extern PUCHAR gszLDAPServiceName;

// Forward decls, defs, and vars for inter-domain move.

ULONG
PhantomizeObject(
    DSNAME  *pObject,
    DSNAME  *pNewParent,
    BOOL    fChildrenAllowed
    );

// Fsmo transfer helper function
ULONG
GenericBecomeMaster(DSNAME *pFSMO,
                    ATTRTYP ObjClass,
                    GUID    RightRequired,
                    OPRES  *pOpRes);

// A helper function for qsort & bsearch on ATTRTYP arrays
int __cdecl
CompareAttrtyp(
        const void * pv1,
        const void * pv2
        );

VOID
MergeSortedACLists(
    IN  THSTATE    *pTHS,
    IN  ATTCACHE  **rgpAC1,
    IN  DWORD       cAtts1,
    IN  ATTCACHE  **rgpAC2,
    IN  DWORD       cAtts2,
    IN OUT ATTCACHE **rgpACOut,
    OUT DWORD      *pcAttsOut
    );

BOOL
IsACListSorted(
    IN ATTCACHE  **rgpAC,
    IN DWORD       cAtts
    );

// Used to notify NetLogon whether or not we're healthy.  The flag says what
// our current state is, the function is how you change the setting, and
// the cs is how the function serializes access.
extern BOOL gfDsaWritable;
extern CRITICAL_SECTION csDsaWritable;
void
SetDsaWritability(BOOL fNewState,
                  DWORD err);


#if DBG
// Used for asserts only
BOOL CheckCurrency(DSNAME *pDN);
#endif

ULONG
OidToAttrType (
        THSTATE *pTHS,
        BOOL fAddToTable,
        OID_t *OID,
        ATTRTYP *attrtyp);

ULONG
OidToAttrCache (
        OID_t *OID,
        ATTCACHE **pAC);

ULONG
AttrTypeToOid (
        ATTRTYP attrtyp,
        OID_t *OID);

ULONG
OidStrToAttrType (
        THSTATE *pTHS,
        BOOL fAddToTable,
        char* StrOid,
        ATTRTYP *attrtyp);

// from sortlocales.c
BOOL
InitLocaleSupport (THSTATE *pTHS);

BOOL
AttrTypToLCID (THSTATE *pTHS,
               ATTRTYP attrType,
               DWORD *pLcid);

// These two items were added to support RemoteAddOneObjectSimply() in
//   boot\install.cxx and  src\mdndnc.c
struct _ADDENTRY_REPLY_INFO;

struct _SecBufferDesc;
typedef struct _SecBufferDesc SecBufferDesc;

ULONG
GetRemoteAddCredentials(
    THSTATE         *pTHS,
    WCHAR           *pDstDSA,
    SecBufferDesc   *pSecBufferDesc
    );

VOID
FreeRemoteAddCredentials(
    SecBufferDesc   *pSecBufferDesc
    );

DWORD
RemoteAddOneObjectSimply(
    IN   LPWSTR pServerName,
    IN   SecBufferDesc * pClientCreds,
    IN   ENTINFLIST* pEntInfList,
    OUT  struct _ADDENTRY_REPLY_INFO **infoList
    );

// These 2 functions help safely pull these components out of the 
// thread error state.
DWORD
GetTHErrorExtData(
    THSTATE * pTHS
    );

DWORD
GetTHErrorDSID(
    THSTATE * pTHS
    );



// Globals from drsuapi.c.
extern RTL_CRITICAL_SECTION gcsDrsAsyncRpcListLock;
extern LIST_ENTRY gDrsAsyncRpcList;

void
DsaEnableLinkedValueReplication(
    THSTATE *pTHS,
    BOOL fFirstTime
    );

// macros to get the composite SearchFlags from the CommArg
#define SEARCH_FLAGS(x) (((x).fForwardSeek?DB_SEARCH_FORWARD:0) | \
                         ((x).Svccntl.makeDeletionsAvail?DB_SEARCH_DELETIONS_VISIBLE:0))

#define REVERSE_SEARCH_FLAGS(x) (((x).fForwardSeek?0:DB_SEARCH_FORWARD) | \
                                 ((x).Svccntl.makeDeletionsAvail?DB_SEARCH_DELETIONS_VISIBLE:0))

//  Non-Domain Naming Contexts (NDNCs)
// This a section relating to mdndnc.c
// THese are all functions and helper functions related to NCs and creation and maintance.

// These functions are for NDNC Head stuff in mdndnc.c
DWORD  AddNCPreProcess(THSTATE * pTHS, ADDARG * pAddArg, ADDRES * pAddRes);
DWORD  AddNDNCHeadCheck(THSTATE * pTHS, CROSS_REF * pCR, ADDARG * pAddArg);
DWORD  GetCrossRefForNC(THSTATE * pTHS, DSNAME * pNCDN);
ULONG  ModifyCRForNDNC(THSTATE * pTHS, DSNAME * pDN, CREATENCINFO * pCreateNC);
BOOL   AddNCWellKnownObjectsAtt(THSTATE * pTHS, ADDARG * pAddArg);
ULONG  AddSpecialNCContainers(THSTATE * pTHS, DSNAME * pDN);
BOOL   fIsNDNC(DSNAME * pNC);
BOOL   fIsNDNCCR(IN CROSS_REF * pCR);
DWORD  GetFsmoDnsAddress(THSTATE * pTHS, DSNAME * pdnFsmoContainer, WCHAR ** pwszFsmoDnsAddr, BOOL * pfRemoteFsmo);
DWORD  GetDcsInNcTransacted(THSTATE * pTHS, DSNAME * Domain, UCHAR cInfoType, SEARCHRES ** ppSearchRes);
CROSS_REF * FindCrossRefByDns(LPWSTR wszDnsDomain);
CROSS_REF * GetDefaultSDRefDomCR(DSNAME * pdnNC);
PSID   GetSDRefDomSid(CROSS_REF * pCR);
DWORD  ValidateDomainDnsName(THSTATE * pTHS, DSNAME * pdnName);


#define fISADDNDNC(x)      ((x) && ((x)->iKind & CREATE_NONDOMAIN_NC))

DWORD
ForceChangeToCrossRef(
    IN DSNAME *  pdnCrossRefObj,
    IN WCHAR *   wszNcDn,
    IN GUID *    pDomainGuid,
    IN ULONG     cbSid,      OPTIONAL
    IN PSID      pSid        OPTIONAL
    );

// from dsatools.c

// This global variable indicates whether we should make a callback
// to give a stringized replication update.  This is used for dcpromo.
extern DSA_CALLBACK_STATUS_TYPE gpfnInstallCallBack;

// Allow other tasks to run by pausing garbage collection after
// processing this many objects. Garbage collection "pauses" by simply
// rescheduling itself to run in 0 seconds.
#define MAX_DUMPSTER_SIZE 5000

// NCL enumeration data structures

// a catalog is identified by an ID (see enum below). This is because a catalog
// essentially consists of two parts: the global list sitting in gAnchor, and the
// local updates that sit in nested_transactional_data. So, whenever we need to
// enumerate (or do whatever) with a catalog, we will pass a single ID instead
// of two pointers.
typedef enum {
    CATALOG_MASTER_NC = 1,
    CATALOG_REPLICA_NC = 2
} CATALOG_ID_ENUM;

// filters for the enumerator
typedef enum {
    NCL_ENUMERATOR_FILTER_NONE = 0,                   // no filter, include all entries
    NCL_ENUMERATOR_FILTER_NCDNT = 1,                  // search for a matching NCDNT
    NCL_ENUMERATOR_FILTER_NC = 2,                     // matching NC, using NameMatched
    NCL_ENUMERATOR_FILTER_BLOCK_NAME_PREFIX1 = 3,     // BlockNamePrefix(pTHS, pNCL->pNCBlock, matchValue) > 0
    NCL_ENUMERATOR_FILTER_BLOCK_NAME_PREFIX2 = 4      // BlockNamePrefix(pTHS, matchValue, pNCL->pNCBlock) > 0
} NCL_ENUMERATOR_FILTER;

typedef struct _NCL_ENUMERATOR {
    CATALOG_ID_ENUM             catalogID;                  // which catalog is being enumerated
    NAMING_CONTEXT_LIST         *pCurEntry;                 // current entry
    NAMING_CONTEXT_LIST         *pBase;                     // base entry (used in CatalogReset)
    NESTED_TRANSACTIONAL_DATA   *pCurTransactionalData;     // currently looking at this transactional level
    BOOL                        bNewEnumerator;             // is it a freshly initialized/reset enumerator?
    NCL_ENUMERATOR_FILTER       filter;                     // filter type
    PVOID                       matchValue;                 // filter match value
    DWORD                       matchResult;                // result of matching function (useful for BLOCK_NAME_PREFIX filters)
    THSTATE                     *pTHS;                      // pTHS cached for BlockNamePrefix calls
} NCL_ENUMERATOR;

// catalog enumerator functions
VOID __fastcall NCLEnumeratorInit(NCL_ENUMERATOR *pEnum, CATALOG_ID_ENUM catalogID);
VOID __fastcall NCLEnumeratorSetFilter(NCL_ENUMERATOR *pEnum, NCL_ENUMERATOR_FILTER filter, PVOID value);
VOID __fastcall NCLEnumeratorReset(NCL_ENUMERATOR *pEnum);
NAMING_CONTEXT_LIST* __fastcall NCLEnumeratorGetNext(NCL_ENUMERATOR *pEnum);

// catalog modification functions (no modifications to global data, only
// local transactional data is modified).
DWORD CatalogAddEntry(NAMING_CONTEXT_LIST *pNCL, CATALOG_ID_ENUM catalogID);
DWORD CatalogRemoveEntry(NAMING_CONTEXT_LIST *pNCL, CATALOG_ID_ENUM catalogID);

// catalog updates functions
// initialize CATALOG_UPDATES structure
VOID CatalogUpdatesInit(CATALOG_UPDATES *pCatUpdates);
// release any memory used by CATALOG_UPDATES structure
VOID CatalogUpdatesFree(CATALOG_UPDATES *pCatUpdates);
// merge CATALOG_UPDATES lists from inner into outer nested transactional data
VOID CatalogUpdatesMerge(CATALOG_UPDATES *pCUouter, CATALOG_UPDATES *pCUinner);
// apply updates in CATALOG_UPDATES list to the global catalog, return TRUE if there were changes
BOOL CatalogUpdatesApply(CATALOG_UPDATES *pCatUpdates, NAMING_CONTEXT_LIST **pGlobalList);

ULONG
PrePhantomizeChildCleanup(
    THSTATE     *pTHS,
    BOOL        fChildrenAllowed
    );

void DbgPrintErrorInfo();

BOOL
fDNTInProtectedList(
    ULONG DNT,
    BOOL *pfNtdsaAncestorWasProtected
    );

ULONG
MakeProtectedAncList(
    ULONG *pUnDeletableDNTs,
    unsigned UnDeletableNum,
    DWORD **ppList,
    DWORD *pCount
    );

// exported from mddit.c for bsearch() and bsort() of NDNC's DNTs in the gAnchor.
int _cdecl CompareDNT(const void *pv1, const void *pv2);

// the string id of the xml script for behavior version upgrade
#define IDS_BEHAVIOR_VERSION_UPGRADE_SCRIPT_0   1

#endif /* _MDLOCAL_ */

/* end mdlocal.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\pek.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       pek.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file contains services for encrypting and decrypting password attributes
    at the DBLayer level

Author:

    Murlis 

Environment:

    User Mode - Win32

Revision History:
    19 Jan 1998 Created
    

--*/

#ifndef __PEK_H__
#define __PEK_H__

#include <nt.h>
#include <wxlpc.h>

// version number to be used in pek list
#define DS_PEK_CURRENT_VERSION      2
// the following version is used by pre-RC2 win2k DC's
#define DS_PEK_PRE_RC2_W2K_VERSION  1

#define DS_PEK_BOOT_KEY_RETRY_COUNT 3
#define DS_PEK_KEY_SIZE             16


//
// Flags for PEK intiatialze
//

#define DS_PEK_GENERATE_NEW_KEYSET 0x1
#define DS_PEK_READ_KEYSET         0x2


//
// Flags for PEK set Boot Options
//

#define DS_PEK_SET_OPERATION       0x4

// Algorithm ID definition
// 0x10 chosen so does not conflict with the
// algorithm ID that SAM's secret data structures
// use.
#define DS_PEK_DBLAYER_ENCRYPTION   0x10
#define DS_PEK_DBLAYER_ENCRYPTION_WITH_SALT 0x11
#define DS_PEK_DBLAYER_ENCRYPTION_FOR_REPLICATOR 0x12

#include <pshpack1.h>

//
// The following structure is the encrypted data
// associated with the algorithm ID of DS_PEK_DBLAYER_ENCRYPTION
//
typedef struct _ENCRYPTED_DATA
{
   USHORT AlgorithmId;
   USHORT Flags;
   ULONG  KeyId;
   UCHAR  EncryptedData[ANYSIZE_ARRAY];
} ENCRYPTED_DATA;


//
// The following structure is the encrypted data
// associated with the algorithm ID of DS_PEK_DBLAYER_ENCRYPTION_WITH_SALT
//
typedef struct _ENCRYPTED_DATA_WITH_SALT
{
   USHORT AlgorithmId;
   USHORT Flags;
   ULONG  KeyId;
   UCHAR  Salt[16]; // 128 bits of Salt
   UCHAR  EncryptedData[ANYSIZE_ARRAY];
} ENCRYPTED_DATA_WITH_SALT;

//
// The following structure is the encrypted data that is returned
// to replicator for replicating out the encrypted information
// We do not need an algorithm ID here as if we introduce a new kind
// of encryption we will need an extension bit to indicate that we support
// it and that bit conveys us the same information
//
typedef struct _ENCRYPTED_DATA_FOR_REPLICATOR
{
   UCHAR  Salt[16]; // 128 bits of Salt
   ULONG  CheckSum;
   UCHAR  EncryptedData[ANYSIZE_ARRAY];
} ENCRYPTED_DATA_FOR_REPLICATOR;
   
typedef struct _ENCRYPTED_PEK_LIST_PRE_WIN2K_RC2
{
    ULONG           Version;
    WX_AUTH_TYPE    BootOption;
    UCHAR           EncryptedData[ANYSIZE_ARRAY];
} ENCRYPTED_PEK_LIST_PRE_WIN2K_RC2;

typedef struct _ENCRYPTED_PEK_LIST
{
    ULONG           Version;
    WX_AUTH_TYPE    BootOption;
    UCHAR           Salt[DS_PEK_KEY_SIZE];
    UCHAR           EncryptedData[ANYSIZE_ARRAY];
} ENCRYPTED_PEK_LIST;



typedef struct _PEK_V1
{
    ULONG KeyId;
    UCHAR Key[DS_PEK_KEY_SIZE];
} PEK_V1;

typedef struct _PEK
{
    union 
    {
        PEK_V1 V1;
    };
} PEK;

typedef struct _CLEAR_PEK_LIST
{
    ULONG           Version;
    WX_AUTH_TYPE    BootOption;
    UCHAR           Salt[DS_PEK_KEY_SIZE];
    GUID            Authenticator;
    FILETIME        LastKeyGenerationTime;
    ULONG           CurrentKey;
    ULONG           CountOfKeys;
    PEK             PekArray[ANYSIZE_ARRAY];
} CLEAR_PEK_LIST;

#include <poppack.h>

//
// Macros for computing lengths
//

// Compute the length of a clear pek list, given the encrypted pek list
#define ClearPekListSize(n) (sizeof(CLEAR_PEK_LIST)+(n-1)*sizeof(PEK))



NTSTATUS
PEKInitialize(
    IN DSNAME * Object OPTIONAL, 
    IN ULONG Flags,
    IN PVOID Syskey OPTIONAL,
    IN ULONG cbSyskey OPTIONAL
    );

ULONG
PEKCheckSum(
    IN PBYTE Data,
    IN ULONG Length
    );


VOID
PEKEncrypt(
    IN THSTATE * pTHS,
    IN PVOID ClearData,
    IN ULONG ClearLength,
    OUT PVOID  EncryptedData OPTIONAL,
    OUT PULONG EncryptedLength
    );

VOID
PEKDecrypt(
    IN THSTATE * pTHS,
    IN PVOID  InputData,
    IN ULONG  EncryptedLength,
    OUT PVOID  ClearData, OPTIONAL
    OUT PULONG ClearLength
    );


NTSTATUS
PEKAddKey(
    IN PVOID NewKey,
    IN ULONG cbNewKey
    );

FILETIME
PEKGetLastKeyGenerationTime();



WX_AUTH_TYPE
PEKGetBootOptions(VOID);

NTSTATUS
PEKChangeBootOption(
    WX_AUTH_TYPE    BootOption,
    ULONG           Flags,
    PVOID           NewKey,
    ULONG           cbNewKey
    );

NTSTATUS
PEKSaveChanges(DSNAME *ObjectToSave);


VOID
PEKClearSessionKeys(
    THSTATE * pTHS
    );


NTSTATUS
PEKGetSessionKey(
    THSTATE * pTHS,
    VOID * RpcContext
    );

NTSTATUS
PEKGetSessionKey2(
    SESSION_KEY *SessionKeyOut,
    VOID * RpcContext
    );

VOID
PEKSecurityCallback(VOID *Context);

VOID
PEKSaveSessionKeyForMyThread(
    IN OUT  THSTATE *       pTHS,
    OUT     SESSION_KEY *   pSessionKey
    );

VOID
PEKRestoreSessionKeySavedByMyThread(
    IN OUT  THSTATE *       pTHS,
    IN      SESSION_KEY *   pSessionKey
    );

VOID
PEKRestoreSessionKeySavedByDiffThread(
    IN OUT  THSTATE *       pTHS,
    IN      SESSION_KEY *   pSessionKey
    );

VOID
PEKDestroySessionKeySavedByDiffThread(
    IN OUT  SESSION_KEY *   pSessionKey
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\mappings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       mappings.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file contains the Mappings from SAM Objects to DS Objects

Author:

    Murlis 16-May-1996

Environment:

    User Mode - Win32

Revision History:

    ChrisMay    14-Jun-96
        Added missing attributes (and corresponding ones in mappings.c), miscellaneous
        clean up and documentation.

    Murlis      16-Jun-96
        Added additional documentation, ordered attributes.

    ChrisMay    26-Jun-96
        Added work around so that SAMP_USER_FULL_NAME doesn't to the admin
        display name. Remapped SAMP_USER_GROUPS from zero to ATT_EXTENSION_ATTRIBUTE_2.

    ColinBr     18-Jul-96
        Added 3 new mappings for membership relation SAM attributes. If
        a SAM object doesn't use these attributes(SAMP_USER_GROUPS,
        SAMP_ALIAS_MEMBERS, and SAMP_GROUP_MEMBERS), then they are mapped
        to a benign field (ATT_USER_GROUPS).

--*/

#ifndef __MAPPINGS_H__
#define __MAPPINGS_H__

// Isolate the required includes here so most of SAM sources needn't be aware
// of DS include dependencies.

#include <samrpc.h>
#include <ntdsa.h>
#include <drs.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>

//+
//+  Define SAMP_OBJECT_TYPE structure
//+
typedef enum _SAMP_OBJECT_TYPE  {

    SampServerObjectType = 0,   // local-account object types
    SampDomainObjectType,
    SampGroupObjectType,
    SampAliasObjectType,
    SampUserObjectType,
    SampUnknownObjectType       // This is used as a max index value
                                // and so must follow the valid object types.
} SAMP_OBJECT_TYPE, *PSAMP_OBJECT_TYPE;

//++
//++ Define Unknowns for error handling
//++

#define DS_CLASS_UNKNOWN                        -1
#define DS_ATTRIBUTE_UNKNOWN                    -1
#define SAM_ATTRIBUTE_UNKNOWN                   -1



#define DS_SAM_ATTRIBUTE_BASE                   (131072+460)



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Each object type has a defined set of variable length attributes.   //
// These are arranged within the object as an array of offsets and     //
// lengths (SAMP_VARIABLE_LENGTH_ATTRIBUTE data types).                //
// This section defines the offset of each variable length attribute   //
// for each object type.                                               //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
// Variable length attributes common to all objects
//

#define SAMP_OBJECT_SECURITY_DESCRIPTOR (0L)


//
// Variable length attributes of a SERVER object
//

#define SAMP_SERVER_SECURITY_DESCRIPTOR (SAMP_OBJECT_SECURITY_DESCRIPTOR)

#define SAMP_SERVER_VARIABLE_ATTRIBUTES (1L)


//
// Variable length attributes of a DOMAIN object
//

#define SAMP_DOMAIN_SECURITY_DESCRIPTOR (SAMP_OBJECT_SECURITY_DESCRIPTOR)
#define SAMP_DOMAIN_SID                 (1L)
#define SAMP_DOMAIN_OEM_INFORMATION     (2L)
#define SAMP_DOMAIN_REPLICA             (3L)

#define SAMP_DOMAIN_VARIABLE_ATTRIBUTES (4L)



//
// Variable length attributes of a USER object
//

#define SAMP_USER_SECURITY_DESCRIPTOR   (SAMP_OBJECT_SECURITY_DESCRIPTOR)
#define SAMP_USER_ACCOUNT_NAME          (1L)
#define SAMP_USER_FULL_NAME             (2L)
#define SAMP_USER_ADMIN_COMMENT         (3L)
#define SAMP_USER_USER_COMMENT          (4L)
#define SAMP_USER_PARAMETERS            (5L)
#define SAMP_USER_HOME_DIRECTORY        (6L)
#define SAMP_USER_HOME_DIRECTORY_DRIVE  (7L)
#define SAMP_USER_SCRIPT_PATH           (8L)
#define SAMP_USER_PROFILE_PATH          (9L)
#define SAMP_USER_WORKSTATIONS          (10L)
#define SAMP_USER_LOGON_HOURS           (11L)
#define SAMP_USER_GROUPS                (12L)
#define SAMP_USER_DBCS_PWD              (13L)
#define SAMP_USER_UNICODE_PWD           (14L)
#define SAMP_USER_NT_PWD_HISTORY        (15L)
#define SAMP_USER_LM_PWD_HISTORY        (16L)

#define SAMP_USER_VARIABLE_ATTRIBUTES   (17L)


//
// Variable length attributes of a GROUP object
//

#define SAMP_GROUP_SECURITY_DESCRIPTOR  (SAMP_OBJECT_SECURITY_DESCRIPTOR)
#define SAMP_GROUP_NAME                 (1L)
#define SAMP_GROUP_ADMIN_COMMENT        (2L)
#define SAMP_GROUP_MEMBERS              (3L)

#define SAMP_GROUP_VARIABLE_ATTRIBUTES  (4L)


//
// Variable length attributes of an ALIAS object
//

#define SAMP_ALIAS_SECURITY_DESCRIPTOR  (SAMP_OBJECT_SECURITY_DESCRIPTOR)
#define SAMP_ALIAS_NAME                 (1L)
#define SAMP_ALIAS_ADMIN_COMMENT        (2L)
#define SAMP_ALIAS_MEMBERS              (3L)

#define SAMP_ALIAS_VARIABLE_ATTRIBUTES  (4L)



//++
//++ Define SAM fixed-attribute IDs on a per-object type.
//++

#define SAM_FIXED_ATTRIBUTES_BASE                       100

//++ Server Object

#define SAMP_FIXED_SERVER_REVISION_LEVEL                SAM_FIXED_ATTRIBUTES_BASE +1

//++ Domain Object


#define SAMP_FIXED_DOMAIN_CREATION_TIME                 SAM_FIXED_ATTRIBUTES_BASE + 0
#define SAMP_FIXED_DOMAIN_MODIFIED_COUNT                SAM_FIXED_ATTRIBUTES_BASE + 1
#define SAMP_FIXED_DOMAIN_MAX_PASSWORD_AGE              SAM_FIXED_ATTRIBUTES_BASE + 2
#define SAMP_FIXED_DOMAIN_MIN_PASSWORD_AGE              SAM_FIXED_ATTRIBUTES_BASE + 3
#define SAMP_FIXED_DOMAIN_FORCE_LOGOFF                  SAM_FIXED_ATTRIBUTES_BASE + 4
#define SAMP_FIXED_DOMAIN_LOCKOUT_DURATION              SAM_FIXED_ATTRIBUTES_BASE + 5
#define SAMP_FIXED_DOMAIN_LOCKOUT_OBSERVATION_WINDOW    SAM_FIXED_ATTRIBUTES_BASE + 6
#define SAMP_FIXED_DOMAIN_MODCOUNT_LAST_PROMOTION       SAM_FIXED_ATTRIBUTES_BASE + 7
#define SAMP_FIXED_DOMAIN_NEXT_RID                      SAM_FIXED_ATTRIBUTES_BASE + 8
#define SAMP_FIXED_DOMAIN_PWD_PROPERTIES                SAM_FIXED_ATTRIBUTES_BASE + 9
#define SAMP_FIXED_DOMAIN_MIN_PASSWORD_LENGTH           SAM_FIXED_ATTRIBUTES_BASE + 10
#define SAMP_FIXED_DOMAIN_PASSWORD_HISTORY_LENGTH       SAM_FIXED_ATTRIBUTES_BASE + 11
#define SAMP_FIXED_DOMAIN_LOCKOUT_THRESHOLD             SAM_FIXED_ATTRIBUTES_BASE + 12
#define SAMP_FIXED_DOMAIN_SERVER_STATE                  SAM_FIXED_ATTRIBUTES_BASE + 13
#define SAMP_FIXED_DOMAIN_UAS_COMPAT_REQUIRED           SAM_FIXED_ATTRIBUTES_BASE + 14
#define SAMP_DOMAIN_ACCOUNT_TYPE                        SAM_FIXED_ATTRIBUTES_BASE + 15
// The Following Domain Fixed Properties Correspond to fields added in NT 4.0 SP3 to the
// SAM fixed length data structures. These are used for encrypting credential information
// in NT4 SP3 SAM. Since NT5 Encryption relies upon a different scheme, No corresponding
// DS attributes are defined in mappings.c, but the following constants are reserved,
// should a use arise
#define SAMP_FIXED_DOMAIN_KEY_AUTH_TYPE                 SAM_FIXED_ATTRIBUTES_BASE + 16
#define SAMP_FIXED_DOMAIN_KEY_FLAGS                     SAM_FIXED_ATTRIBUTES_BASE + 17
#define SAMP_FIXED_DOMAIN_KEY_INFORMATION               SAM_FIXED_ATTRIBUTES_BASE + 18
// The following is a pseudo-attribute strictly so we have something to
// stick in DomainAttributeMappingTable in mappings.c.
#define SAMP_DOMAIN_MIXED_MODE                          SAM_FIXED_ATTRIBUTES_BASE + 19
#define SAMP_DOMAIN_MACHINE_ACCOUNT_QUOTA               SAM_FIXED_ATTRIBUTES_BASE + 20
#define SAMP_DOMAIN_BEHAVIOR_VERSION                    SAM_FIXED_ATTRIBUTES_BASE + 21 
#define SAMP_DOMAIN_LASTLOGON_TIMESTAMP_SYNC_INTERVAL   SAM_FIXED_ATTRIBUTES_BASE + 22 

//++ Group Object

#define SAMP_FIXED_GROUP_RID                            SAM_FIXED_ATTRIBUTES_BASE + 0
#define SAMP_FIXED_GROUP_OBJECTCLASS                    SAM_FIXED_ATTRIBUTES_BASE + 1
#define SAMP_GROUP_ACCOUNT_TYPE                         SAM_FIXED_ATTRIBUTES_BASE + 2
#define SAMP_GROUP_SID_HISTORY                          SAM_FIXED_ATTRIBUTES_BASE + 3
#define SAMP_FIXED_GROUP_TYPE                           SAM_FIXED_ATTRIBUTES_BASE + 4
#define SAMP_FIXED_GROUP_IS_CRITICAL                    SAM_FIXED_ATTRIBUTES_BASE + 5
#define SAMP_FIXED_GROUP_MEMBER_OF                      SAM_FIXED_ATTRIBUTES_BASE + 6
#define SAMP_FIXED_GROUP_SID                            SAM_FIXED_ATTRIBUTES_BASE + 7


//++ Alias Object

#define SAMP_FIXED_ALIAS_RID                            SAM_FIXED_ATTRIBUTES_BASE + 0
#define SAMP_FIXED_ALIAS_OBJECTCLASS                    SAM_FIXED_ATTRIBUTES_BASE + 1
#define SAMP_ALIAS_ACCOUNT_TYPE                         SAM_FIXED_ATTRIBUTES_BASE + 2
#define SAMP_ALIAS_SID_HISTORY                          SAM_FIXED_ATTRIBUTES_BASE + 3
#define SAMP_FIXED_ALIAS_TYPE                           SAM_FIXED_ATTRIBUTES_BASE + 4
#define SAMP_FIXED_ALIAS_SID                            SAM_FIXED_ATTRIBUTES_BASE + 5



//++ User Object

#define SAMP_FIXED_USER_LAST_LOGON                      SAM_FIXED_ATTRIBUTES_BASE + 0
#define SAMP_FIXED_USER_LAST_LOGOFF                     SAM_FIXED_ATTRIBUTES_BASE + 1
#define SAMP_FIXED_USER_PWD_LAST_SET                    SAM_FIXED_ATTRIBUTES_BASE + 2
#define SAMP_FIXED_USER_ACCOUNT_EXPIRES                 SAM_FIXED_ATTRIBUTES_BASE + 3
#define SAMP_FIXED_USER_LAST_BAD_PASSWORD_TIME          SAM_FIXED_ATTRIBUTES_BASE + 4
#define SAMP_FIXED_USER_USERID                          SAM_FIXED_ATTRIBUTES_BASE + 5
#define SAMP_FIXED_USER_PRIMARY_GROUP_ID                SAM_FIXED_ATTRIBUTES_BASE + 6
#define SAMP_FIXED_USER_ACCOUNT_CONTROL                 SAM_FIXED_ATTRIBUTES_BASE + 7
#define SAMP_FIXED_USER_COUNTRY_CODE                    SAM_FIXED_ATTRIBUTES_BASE + 8
#define SAMP_FIXED_USER_CODEPAGE                        SAM_FIXED_ATTRIBUTES_BASE + 9
#define SAMP_FIXED_USER_BAD_PWD_COUNT                   SAM_FIXED_ATTRIBUTES_BASE + 10
#define SAMP_FIXED_USER_LOGON_COUNT                     SAM_FIXED_ATTRIBUTES_BASE + 11
#define SAMP_FIXED_USER_OBJECTCLASS                     SAM_FIXED_ATTRIBUTES_BASE + 12
#define SAMP_USER_ACCOUNT_TYPE                          SAM_FIXED_ATTRIBUTES_BASE + 13
#define SAMP_FIXED_USER_LOCAL_POLICY_FLAGS              SAM_FIXED_ATTRIBUTES_BASE + 14
#define SAMP_FIXED_USER_SUPPLEMENTAL_CREDENTIALS        SAM_FIXED_ATTRIBUTES_BASE + 15
#define SAMP_USER_SID_HISTORY                           SAM_FIXED_ATTRIBUTES_BASE + 16
#define SAMP_FIXED_USER_LOCKOUT_TIME                    SAM_FIXED_ATTRIBUTES_BASE + 17
#define SAMP_FIXED_USER_IS_CRITICAL                     SAM_FIXED_ATTRIBUTES_BASE + 18
#define SAMP_FIXED_USER_UPN                             SAM_FIXED_ATTRIBUTES_BASE + 19
#define SAMP_USER_CREATOR_SID                           SAM_FIXED_ATTRIBUTES_BASE + 20
#define SAMP_FIXED_USER_SID                             SAM_FIXED_ATTRIBUTES_BASE + 21
#define SAMP_FIXED_USER_SITE_AFFINITY                   SAM_FIXED_ATTRIBUTES_BASE + 22
#define SAMP_FIXED_USER_LAST_LOGON_TIMESTAMP            SAM_FIXED_ATTRIBUTES_BASE + 23
#define SAMP_FIXED_USER_CACHED_MEMBERSHIP               SAM_FIXED_ATTRIBUTES_BASE + 24
#define SAMP_FIXED_USER_CACHED_MEMBERSHIP_TIME_STAMP    SAM_FIXED_ATTRIBUTES_BASE + 25
#define SAMP_FIXED_USER_ACCOUNT_CONTROL_COMPUTED        SAM_FIXED_ATTRIBUTES_BASE + 26
#define SAMP_USER_PASSWORD                              SAM_FIXED_ATTRIBUTES_BASE + 27
#define SAMP_USER_A2D2LIST                              SAM_FIXED_ATTRIBUTES_BASE + 28

//++ Unknown Object

#define SAMP_UNKNOWN_OBJECTCLASS                        SAM_FIXED_ATTRIBUTES_BASE + 0
#define SAMP_UNKNOWN_OBJECTRID                          SAM_FIXED_ATTRIBUTES_BASE + 1
#define SAMP_UNKNOWN_OBJECTNAME                         SAM_FIXED_ATTRIBUTES_BASE + 2
#define SAMP_UNKNOWN_OBJECTSID                          SAM_FIXED_ATTRIBUTES_BASE + 3
#define SAMP_UNKNOWN_COMMON_NAME                        SAM_FIXED_ATTRIBUTES_BASE + 4
#define SAMP_UNKNOWN_ACCOUNT_TYPE                       SAM_FIXED_ATTRIBUTES_BASE + 5
#define SAMP_UNKNOWN_GROUP_TYPE                         SAM_FIXED_ATTRIBUTES_BASE + 6


//
// Define the maximum number of attributes that SAM cares about any object. This
// constant is used in SAM to declare attribute blocks in the stack
//

#define MAX_SAM_ATTRS   64


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//  Mapping table structures for SAM to DS object Mappings                   //
//                                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

// Various fields declared as pointer to avoid "initializer is
// not a constant" errors in mappings.c.

typedef enum
{
    Integer,
    LargeInteger,
    OctetString,
    UnicodeString,
    Dsname
} ATTRIBUTE_SYNTAX;

// Define 'flavors' of mapped attributes.  Any attribute for which SAM
// needs to perform semantic validation, auditing or netlogon notification
// is declared as SamWriteRequired.  Any attribute which only SAM itself
// can write (eg: RID) is declared as SamReadOnly.  Attributes which SAM
// maps, but can be written without notifying SAM are declared as
// NonSamWriteAllowed (though we know of none like this at present - 8/1/96).

typedef enum
{
    SamWriteRequired,       // SAM checks semantics, audits or notifies
    NonSamWriteAllowed,     // SAM maps but doesn't care
    SamReadOnly             // SAM owns and no one can write
} SAMP_WRITE_RULES;


// SAM doesn't have a counterpart to all core (DS - LDAP) modification
// choice, define the choices SAM can understand and execute. 

typedef enum
{
    SamAllowAll,                // Don't check this attr operation
    SamAllowDeleteOnly,         // Value or attribute can only be removed
    SamAllowReplaceAndRemove,   // Attribute can be replaced and removed
    SamAllowReplaceOnly         // Replace attribute only
} SAMP_ALLOWED_MOD_TYPE;

typedef struct {
    BOOL                    fSamWriteRequired;
    BOOL                    fIgnore;
    USHORT                  choice;             // ATT_CHOICE_*
    ATTR                    attr;
    ULONG                   iAttr;              // index into class' attr map
    ATTCACHE                *pAC;
} SAMP_CALL_MAPPING;


typedef struct
{
    ULONG                           SamAttributeType;
    ULONG                           DsAttributeId;
    ATTRIBUTE_SYNTAX                AttributeSyntax;
    SAMP_WRITE_RULES                writeRule;
    SAMP_ALLOWED_MOD_TYPE           SampAllowedModType; 
    ACCESS_MASK                     domainModifyRightsRequired;
    ACCESS_MASK                     objectModifyRightsRequired;
}   SAMP_ATTRIBUTE_MAPPING;

#define SAM_CREATE_ONLY         TRUE    // SAMP_CLASS_MAPPING.fSamCreateOnly
#define NON_SAM_CREATE_ALLOWED  FALSE   // SAMP_CLASS_MAPPING.fSamCreateOnly

typedef struct
{
    ULONG                       DsClassId;
    SAMP_OBJECT_TYPE            SamObjectType;
    BOOL                        fSamCreateOnly;
    ULONG                       *pcSamAttributeMap;
    SAMP_ATTRIBUTE_MAPPING      *rSamAttributeMap;
    ACCESS_MASK                 domainAddRightsRequired;
    ACCESS_MASK                 domainRemoveRightsRequired;
    ACCESS_MASK                 objectAddRightsRequired;
    ACCESS_MASK                 objectRemoveRightsRequired;
}   SAMP_CLASS_MAPPING;

typedef enum
{
    LoopbackAdd,
    LoopbackModify,
    LoopbackRemove
} SAMP_LOOPBACK_TYPE;

typedef struct
{
    SAMP_LOOPBACK_TYPE  type;               // original Dir* operation type
    DSNAME              *pObject;           // object being operated on
    ULONG               cCallMap;           // elements in rCallMap
    SAMP_CALL_MAPPING   *rCallMap;          // original arguments
    BOOL                fPermissiveModify;  // fPermissiveModify in original call
    ULONG               MostSpecificClass;  // Most specific object class of the loop
                                            // back object
} SAMP_LOOPBACK_ARG;

/////////////////////////////////////////////////////////////////////////
//                                                                     //
//  Group Type Definitions                                             //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


typedef enum _NT4_GROUP_TYPE
{
    NT4LocalGroup=1,
    NT4GlobalGroup
} NT4_GROUP_TYPE;

typedef enum _NT5_GROUP_TYPE
{
    NT5ResourceGroup=1,
    NT5AccountGroup,
    NT5UniversalGroup
} NT5_GROUP_TYPE;




///////////////////////////////////////////////////////////////////////
//                                                                   //
//                                                                   //
//  SAM_ACCOUNT_TYPE Definitions. The SAM account type property      //
//  is used to keep information about every account type object,     //
//                                                                   //
//   There is a value defined for every type of account which        //
//   May wish to list using the enumeration or Display Information   //
//   API. In addition since Machines, Normal User Accounts and Trust //
//   accounts can also be enumerated as user objects the values for  //
//   these must be a contiguous range.                               //
//                                                                   //
///////////////////////////////////////////////////////////////////////

#define SAM_DOMAIN_OBJECT               0x0
#define SAM_GROUP_OBJECT                0x10000000
#define SAM_NON_SECURITY_GROUP_OBJECT   0x10000001
#define SAM_ALIAS_OBJECT                0x20000000
#define SAM_NON_SECURITY_ALIAS_OBJECT   0x20000001
#define SAM_USER_OBJECT                 0x30000000
#define SAM_NORMAL_USER_ACCOUNT         0x30000000
#define SAM_MACHINE_ACCOUNT             0x30000001
#define SAM_TRUST_ACCOUNT               0x30000002
#define SAM_ACCOUNT_TYPE_MAX            0x7fffffff




//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  Export the Mapping Functions and Data Structures                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

extern BOOL                 gfDoSamChecks;
extern SAMP_CLASS_MAPPING   ClassMappingTable[];
extern ULONG                cClassMappingTable;

extern
ULONG
SampGetSamAttrIdByName(
    SAMP_OBJECT_TYPE ObjectType,
    UNICODE_STRING AttributeIdentifier);
    
extern
ULONG
SampGetDsAttrIdByName(
    UNICODE_STRING AttributeIdentifier);
    
extern
ULONG
SampDsAttrFromSamAttr(
    SAMP_OBJECT_TYPE    ObjectType,
    ULONG               SamAttr);

extern
ULONG
SampSamAttrFromDsAttr(
    SAMP_OBJECT_TYPE    ObjectType,
    ULONG DsAttr);

extern
ULONG
SampDsClassFromSamObjectType(
    ULONG SamObjectType);

extern
ULONG
SampSamObjectTypeFromDsClass(
    ULONG DsClass);

typedef enum
{
    TransactionRead,
    TransactionWrite,
    TransactionAbort,
    TransactionCommit,
    TransactionCommitAndKeepThreadState,
    TransactionAbortAndKeepThreadState
} SAMP_DS_TRANSACTION_CONTROL;

extern
NTSTATUS
SampMaybeBeginDsTransaction(
    SAMP_DS_TRANSACTION_CONTROL ReadOrWrite);

extern
NTSTATUS
SampMaybeEndDsTransaction(
    SAMP_DS_TRANSACTION_CONTROL CommitOrAbort);

extern
BOOL
SampExistsDsTransaction();

extern
BOOL
SampExistsDsLoopback(
    DSNAME  **ppLoopbackName);

extern
BOOL
SampSamClassReferenced(
    CLASSCACHE  *pClassCache,
    ULONG       *piClass);

extern
BOOLEAN
SampIsSecureLdapConnection(
    VOID
    );


extern
BOOL
SampSamAttributeModified(
    ULONG       iClass,
    MODIFYARG   *pModifyArg
    );

extern
BOOL
SampSamReplicatedAttributeModified(
    ULONG       iClass,
    MODIFYARG   *pModifyArg
    );

extern
ULONG
SampAddLoopbackRequired(
    ULONG       iClass,
    ADDARG      *pAddArg,
    BOOL        *pfLoopbackRequired);

extern
ULONG
SampModifyLoopbackRequired(
    ULONG       iClass,
    MODIFYARG   *pModifyArg,
    BOOL        *pfLoopbackRequired);

extern
VOID
SampBuildAddCallMap(
    ADDARG              *pArg,
    ULONG               iClass,
    ULONG               *pcCallMap,
    SAMP_CALL_MAPPING   **prCallMap,
    ACCESS_MASK         *pDomainModifyRightsRequired,
    ACCESS_MASK         *pObjectModifyRightsRequired);

extern
VOID
SampBuildModifyCallMap(
    MODIFYARG           *pArg,
    ULONG               iClass,
    ULONG               *pcCallMap,
    SAMP_CALL_MAPPING   **prCallMap,
    ACCESS_MASK         *pDomainModifyRightsRequired,
    ACCESS_MASK         *pObjectModifyRightsRequired);

extern
ULONG
SampAddLoopbackCheck(
    ADDARG      *pAddArg,
    BOOL        *pfContinue);

extern
ULONG
SampModifyLoopbackCheck(
    MODIFYARG   *pModifyArg,
    BOOL        *pfContinue);

extern
ULONG
SampRemoveLoopbackCheck(
    REMOVEARG   *pRemoveArg,
    BOOL        *pfContinue);

extern
NTSTATUS
SampGetMemberships(
    IN  PDSNAME     *rgObjNames,
    IN  ULONG       cObjNames,
    IN  OPTIONAL    DSNAME  *pLimitingDomain,
    IN  REVERSE_MEMBERSHIP_OPERATION_TYPE   OperationType,
    OUT ULONG       *pcDsNames,
    OUT PDSNAME     **prpDsNames,
    OUT PULONG      *Attributes OPTIONAL,
    OUT PULONG      pcSidHistory OPTIONAL,
    OUT PSID        **rgSidHistory OPTIONAL
    );

NTSTATUS
SampGetGroupsForToken(
    IN  DSNAME * pObjName,
    IN  ULONG    Flags,
    OUT ULONG   *pcSids,
    OUT PSID    **prpSids
   );

extern
VOID
SampSplitNT4SID(
    IN NT4SID       *pAccountSid,
    IN OUT NT4SID   *pDomainSid,
    OUT ULONG       *pRid);

extern
DIRERR * APIENTRY
SampGetErrorInfo(
    VOID
    );

extern
VOID
SampMapSamLoopbackError(
    NTSTATUS status);

extern
ULONG
SampDeriveMostBasicDsClass(
    ULONG   DerivedClass);

extern
BOOL
SampIsWriteLockHeldByDs();

extern
NTSTATUS
SampSetIndexRanges(
    ULONG   IndexTypeToUse,
    ULONG   LowLimitLength1,
    PVOID   LowLimit1,
    ULONG   LowLimitLength2,
    PVOID   LowLimit2,
    ULONG   HighLimitLength1,
    PVOID   HighLimit1,
    ULONG   HighLimitLength2,
    PVOID   HighLimit2,
    BOOL    RootOfSearchIsNcHead
    );

extern
NTSTATUS
SampGetDisplayEnumerationIndex (
      IN    DSNAME      *DomainName,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    PRPC_UNICODE_STRING Prefix,
      OUT   PULONG      Index,
      OUT   PRESTART    *RestartToReturn
      );


extern
NTSTATUS
SampGetQDIRestart(
    IN PDSNAME  DomainName,
    IN DOMAIN_DISPLAY_INFORMATION DisplayInformation, 
    IN ULONG    LastObjectDNT,
    OUT PRESTART *ppRestart
    );




extern
ULONG
SampAddToDownLevelNotificationList(
    DSNAME      * Object,
    ULONG       iClass,
    ULONG       LsaClass,
    SECURITY_DB_DELTA_TYPE  DeltaType,
    BOOL      MixedModeChange,
    BOOL      RoleTransfer,
    DOMAIN_SERVER_ROLE NewRole
    );

extern
VOID
SampProcessReplicatedInChanges(
    SAMP_NOTIFICATION_INFORMATION * NotificationList
    );

extern
VOID
SampGetLoopbackObjectClassId(
    PULONG  ClassId
    );

extern
NTSTATUS
SampGetAccountCounts(
        DSNAME * DomainObjectName,
        BOOLEAN  GetApproximateCount, 
        int    * UserCount,
        int    * GroupCount,
        int    * AliasCount
        );

extern
BOOLEAN
SampSamUniqueAttributeAdded(
        ADDARG * pAddarg
        );

extern
BOOLEAN
SampSamUniqueAttributeModified(
        MODIFYARG * pModifyarg
        );


extern
ULONG
SampVerifySids(
    ULONG           cSid,
    PSID            *rpSid,
    DSNAME         ***prpDSName
    );

extern
NTSTATUS
SampGCLookupSids(
    IN  ULONG         cSid,
    IN  PSID         *rpSid,
    OUT PDS_NAME_RESULTW *Results
    );

extern
NTSTATUS
SampGCLookupNames(
    IN  ULONG           cNames,
    IN  UNICODE_STRING *rNames,
    OUT ENTINF         **rEntInf
    );

extern
VOID
SampGetEnterpriseSidList(
   IN   PULONG pcSids,
   IN OPTIONAL PSID * rgSids
   );

extern
VOID
SampSignalStart(
        VOID
        );

extern
BOOL
SampAmIGC();

extern
VOID
SampSetSam(IN BOOLEAN fSAM);

NTSTATUS
InitializeLsaNotificationCallback(
    VOID
    );

NTSTATUS
UnInitializeLsaNotificationCallback(
    VOID
    );

BOOL
SampIsClassIdLsaClassId(
    THSTATE *pTHS,
    IN ULONG Class,
    IN ULONG cModAtt,
    IN ATTRTYP *pModAtt,
    OUT PULONG LsaClass
    );

BOOL
SampIsClassIdAllowedByLsa(
    THSTATE *pTHS,
    IN ULONG Class
    );

NTSTATUS
SampGetServerRoleFromFSMO(
   DOMAIN_SERVER_ROLE *ServerRole
   );

BOOL
SampIsRoleTransfer(
    MODIFYARG * pModifyArg,
    DOMAIN_SERVER_ROLE *NewRole
    );

NTSTATUS
SampComputeGroupType(
    ULONG  ObjectClass,
    ULONG  GroupType,
    NT4_GROUP_TYPE *pNT4GroupType,
    NT5_GROUP_TYPE *pNT5GroupType,
    BOOLEAN        *pSecurityEnabled
   );

BOOL
SampIsMixedModeChange(
    MODIFYARG * pModifyArg
    );


NTSTATUS
SampCommitBufferedWrites(
    IN SAMPR_HANDLE SamHandle
    );

VOID
SampInvalidateDomainCache();

//
// Functions to support external entities of data changes
// in the SAM database.  For example, notifying packages and the PDC
// when passwords change.
//
BOOLEAN
SampAddLoopbackTask(
    IN PVOID NotifyInfo
    );

VOID
SampProcessLoopbackTasks(
    VOID
    );


BOOL
LoopbackTaskPreProcessTransactionalData(
        BOOL fCommit
        );
void
LoopbackTaskPostProcessTransactionalData(
        THSTATE *pTHS,
        BOOL fCommit,
        BOOL fCommitted
        );


BOOLEAN
SampDoesDomainExist(
    IN PDSNAME pDN
    );

VOID
SampNotifyLsaOfXrefChange(
    IN DSNAME * pObject
    );

NTSTATUS
MatchDomainDnByDnsName(
   IN LPWSTR         DnsName,
   OUT PDSNAME       DomainDsName OPTIONAL,
   IN OUT PULONG     DomainDsNameLen
   );

extern
NTSTATUS
SampNetlogonPing(
    IN  ULONG           DomainHandle,
    IN  PUNICODE_STRING AccountName,
    OUT PBOOLEAN        AccountExists,
    OUT PULONG          UserAccountControl
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\scache.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       scache.h
//
//--------------------------------------------------------------------------

#ifndef __SCACHE_H__
#define __SCACHE_H__

// Define the Jet types used in this header file and in dbglobal.h.  Then, mark
// jet.h as included so that no one else will accidently include jet.h
#ifndef _JET_INCLUDED
typedef ULONG_PTR JET_TABLEID;
typedef unsigned long JET_DBID;
typedef ULONG_PTR JET_SESID;
typedef unsigned long JET_COLUMNID;
typedef unsigned long JET_GRBIT;
#define _JET_INCLUDE
#endif

// Starting (and minimum) table sizes for the schema cache tables.
// Tables will be grown dynamically beyond this if needed
// Note: START_PREFIXCOUNT must be at least as large as MSPrefixCount
// (defined in prefix.h) plus the maximum number of new prefixes that
// a thread can create

#define START_ATTCOUNT 2048
#define START_CLSCOUNT 512
#define START_PREFIXCOUNT 256

typedef unsigned short OM_syntax;
#define OM_S_NO_MORE_SYNTAXES           ( (OM_syntax) 0 )
#define OM_S_BIT_STRING                 ( (OM_syntax) 3 )
#define OM_S_BOOLEAN                    ( (OM_syntax) 1 )
#define OM_S_ENCODING_STRING            ( (OM_syntax) 8 )
#define OM_S_ENUMERATION                ( (OM_syntax) 10 )
#define OM_S_GENERAL_STRING             ( (OM_syntax) 27 )
#define OM_S_GENERALISED_TIME_STRING    ( (OM_syntax) 24 )
#define OM_S_GRAPHIC_STRING             ( (OM_syntax) 25 )
#define OM_S_IA5_STRING                 ( (OM_syntax) 22 )
#define OM_S_INTEGER                    ( (OM_syntax) 2 )
#define OM_S_NULL                       ( (OM_syntax) 5 )
#define OM_S_NUMERIC_STRING             ( (OM_syntax) 18 )
#define OM_S_OBJECT                     ( (OM_syntax) 127 )
#define OM_S_OBJECT_DESCRIPTOR_STRING   ( (OM_syntax) 7 )
#define OM_S_OBJECT_IDENTIFIER_STRING   ( (OM_syntax) 6 )
#define OM_S_OCTET_STRING               ( (OM_syntax) 4 )
#define OM_S_PRINTABLE_STRING           ( (OM_syntax) 19 )
#define OM_S_TELETEX_STRING             ( (OM_syntax) 20 )
#define OM_S_UTC_TIME_STRING            ( (OM_syntax) 23 )
#define OM_S_VIDEOTEX_STRING            ( (OM_syntax) 21 )
#define OM_S_VISIBLE_STRING             ( (OM_syntax) 26 )
#define OM_S_UNICODE_STRING  	        ( (OM_syntax) 64 )
#define OM_S_I8                         ( (OM_syntax) 65 )
#define OM_S_OBJECT_SECURITY_DESCRIPTOR ( (OM_syntax) 66 )

BOOL OIDcmp(OID_t const *string1, OID_t const *string2);

typedef struct _attcache
{
    ATTRTYP id;			    // Internal Id from msDS-IntId
    ATTRTYP Extid;			// Tokenized OID from attributeId
    UCHAR *name;		    /* Attribute name (null terminated) UTF8*/
    ULONG nameLen;          /* strlen(name) (doesn't include NULL)  */
    unsigned syntax;        /* Syntax				*/
    BOOL isSingleValued;	/* Single Valued or Multi-valued?	*/
    BOOL rangeLowerPresent;	/* Lower range present                  */
    ULONG rangeLower;		/* Optional - Lower range               */
    BOOL rangeUpperPresent;	/* Upper range present			*/
    ULONG rangeUpper;		/* Optional - Upper range               */
    JET_COLUMNID jColid;	/* Column id in JET database		*/
    ULONG ulMapiID;		    /* MAPI PropID (not PropTag)		*/
    ULONG ulLinkID;		    /* unique link/backlink id		*/
    GUID propGuid;              /* Guid of this att for security        */
    GUID propSetGuid;           /* Guid of the property set of this     */
    OID_t OMObjClass;           /* class of OM object referenced	*/
    int OMsyntax;		        /* OM syntax				*/
    DWORD fSearchFlags;	        /* Defined below                        */
    char*    pszPdntIndex;      /* Index name if fSearchFlags fPDNTATTINDEX set */
    struct tagJET_INDEXID *pidxPdntIndex; /* PDNT index hint              */
    char*    pszIndex;          /* Index name if fSearchFlags fATTINDEX set  */
    struct tagJET_INDEXID *pidxIndex; /* index hint                       */
    char*    pszTupleIndex;     /* Index name if fSearchFlags fTUPLEINDEX set */
    struct tagJET_INDEXID *pidxTupleIndex; /* index hint */
    unsigned bSystemOnly:1;     /* system only attribute?		*/
    unsigned bExtendedChars:1;	/* Skip character set checking?         */
    unsigned bMemberOfPartialSet:1; /* Is member of the partial attribute set? */
    unsigned bDefunct:1;	    /* Attribute is already deleted? */
    unsigned bIsConstructed:1;	/* Attribute is a constructed att? */
    unsigned bIsNotReplicated:1;/* Attribute is never replicated?       */
    unsigned bIsBaseSchObj:1;   /* shipped in NT5 base schema */
    unsigned bIsOperational:1;  /* not returned on read unless requested */

    // The new schema reuse, defunct, and delete feature doesn't
    // allow reusing attributes used as the rdnattid of any class,
    // alive or defunct, or with FLAG_ATTR_IS_RDN set in systemFlags.
    // Attributes that fall into one of these catagories are termed
    // rdn attributes.
    //
    // A user sets FLAG_ATTR_IS_RDN to select which of several
    // defunct attrs can be used as the rdnattid of a new class.
    // The system will identify attributes once used as rdnattids
    // in purged classes by setting FLAG_ATTR_IS_RDN.
    //
    // The restrictions are in place because the NameMatched(), DNLock(),
    // and phantom upgrade code (list not exhaustive) depends on the
    // invariant relationship between ATT_RDN, ATT_FIXED_RDN_TYPE,
    // the rdnattid column, LDN-syntaxed DNs, and the RDNAttId in
    // the class definition. Breaking that dependency is beyond
    // the scope of the schema delete project.
    //
    // Defuncted rdn attributes are silently resurrected and so "own"
    // their OID, LDN, and MapiID. The tokenized OID, RdnExtId, is
    // read from the DIT, the now-active rdn attribute looked up 
    // in the active table, and the RdnIntId assigned from pAC->id.
    //
    // The RDN of a new object must match its object's RdnIntId.
    // Replicated objects and existing objects might not match
    // the rdnattid of their class because the class may be
    // superced by a class with a different rdnattid. The code
    // handles these cases by using the value in the
    // ATT_FIXED_RDN_TYPE column and *NOT* the rdnattid in the
    // class definition.
    //
    // bIsRdn is set if any class, live or defunct, claims this
    // attribute as an rdnattid or if FLAG_ATTR_IS_RDN is set
    // in systemFlags.
    //
    // bFlagIsRdn is set if the systemFlags FLAG_ATTR_IS_RDN is set.
    unsigned bIsRdn:1;
    unsigned bFlagIsRdn:1;

    // Once the new schema-reuse behavior is enabled, active attributes
    // may collide with each other because the schema objects replicate
    // from oldest change to youngest change. Meaning a new attribute
    // may replicate before the attribute it supercedes if the superceded
    // attribute is modified after being superceded (eg, it was renamed).
    //
    // The schema cache detects and treats the colliding attributes as
    // if they were defunct. If later replication does not clear up the
    // collision, the user can choose a winner and officially defunct
    // the loser.
    //
    // Colliding attributes are left in the schema cache until all
    // attributes and classes are loaded so that multiple collisions
    // can be detected. For performance, the collision types are
    // recorded in these bit fields to avoid duplicate effort by
    // ValidSchemaUpdate().
    unsigned bDupLDN:1;
    unsigned bDupOID:1;
    unsigned bDupPropGuid:1; // aka schemaIdGuid
    unsigned bDupMapiID:1;

    // Out-of-order replication or divergent schemas can create
    // inconsistent schemas. Normally, the affected attributes
    // are marked defunct (See above). But if the attributes
    // are used as rdnattids, then one of the attributes must
    // win the OID, LDN, and mapiID for the code to work. All
    // other things being equal, the largest objectGuid wins.
    GUID objectGuid;        // tie breaker for colliding rdns
    ATTRTYP aliasID;        /* the ATTRTYP this ATTCACHE is an alias for */
} ATTCACHE;


typedef struct _AttTypeCounts
{
    ULONG cLinkAtts;                // No. of forward links in may+must
    ULONG cBackLinkAtts;            // No. of backlinks in may+must
    ULONG cConstructedAtts;         // No. of constructed atts in may+must
    ULONG cColumnAtts;              // No. of regular (with columns) atts in may+must
} ATTTYPECOUNTS;


typedef struct _classcache
{
    ULONG DNT;                  /* The DNT of the schema entry */
    UCHAR *name;		/* Class name (ldapDisplayName) (null terminated)	UTF8	*/
    ULONG nameLen;              /* strlen(name) (doesn't include NULL)  */
    ULONG ClassId;		/* Class ID				*/
    PSECURITY_DESCRIPTOR pSD;   /* Default SD for this class            */
    DWORD SDLen;                /* Length of default SD.                */
    WCHAR * pStrSD;             /*  maybe NULL if not loaded yet */
    ULONG  cbStrSD;            /* Byte size of pStrSD */
    BOOL RDNAttIdPresent;	/* RDN Att Id present?                  */
    ULONG ClassCategory;	/* X.500 object type for this class     */
    DSNAME *pDefaultObjCategory; /* Default search category to put on instances */
    // The new schema reuse, defunct, and delete feature doesn't
    // allow reusing attributes used as the rdnattid of any class,
    // alive or defunct, or with FLAG_ATTR_IS_RDN set in systemFlags.
    // Attributes that fall into one of these catagories are termed
    // rdn attributes.
    //
    // The restrictions are in place because the NameMatched(), DNLock(),
    // and phantom upgrade code (list not exhaustive) depends on the
    // invariant relationship between ATT_RDN, ATT_FIXED_RDN_TYPE,
    // the rdnattid column, LDN-syntaxed DNs, and the RDNAttId in
    // the class definition.
    //
    // Defuncted rdn attributes are silently resurrected and so "own"
    // their OID, LDN, and MapiID. The tokenized OID, RdnExtId, is
    // read from the DIT, the now-active rdn attribute looked up 
    // in the active table, and the RdnIntId assigned from pAC->id.
    //
    // The RDN of a new object must match its object's RdnIntId.
    // Replicated objects and existing objects might not match
    // the rdnattid of their class because the class may be
    // superced by a class with a different rdnattid. The code
    // handles these cases by using the value in the
    // ATT_FIXED_RDN_TYPE column and *NOT* the rdnattid in the
    // class definition.
    //
    // Naming attribute for the class.
    ULONG RdnIntId;		    /* Internal Id (msDS-IntId) */
    ULONG RdnExtId;		    /* Tokenized OID (attributeId) */
    ULONG SubClassCount;	/* count of superclasses		*/
    ULONG *pSubClassOf;		/* ptr to array of superclasses		*/
    ULONG MySubClass;       /* the direct superclass of the class */
    ULONG AuxClassCount;        /* count of auxiliary classes           */
    ULONG *pAuxClass;           /* ptr to array of auxiliary classes    */
    unsigned PossSupCount;	/* Possible superior count		*/
    ULONG *pPossSup;		/* ptr to array of poss superiors in DIT */
    GUID propGuid;              /* Guid of this class for security      */

    unsigned MustCount;		/* Count of Must Atts                   */
    unsigned MayCount;		/* Count of May Atts                    */

    ATTRTYP *pMustAtts;		/* Pointer to array of Must Atts	*/
    ATTRTYP *pMayAtts;		/* Pointer to array of May Atts		*/
    ATTCACHE **ppAllAtts;       // Pointer to array of attcache pointers for
                                  // attributes in may and must list.
    ATTTYPECOUNTS *pAttTypeCounts; // Count of different type of atts in may
                                   // and must. Filled in only if 
                                   // ppAllAtts is filled in
    unsigned MyMustCount;	/* Count of Must Atts(exclude inherited)*/
    unsigned MyMayCount;	/* Count of May Atts (exclude inherited)*/
    unsigned MyPossSupCount;/* Count of PossSup (exclude inherited)*/

    ATTRTYP *pMyMustAtts;	/* Pointer to array of MustAtts*/
    ATTRTYP *pMyMayAtts;	/* Pointer to array of MayAtts*/
    ULONG   *pMyPossSup;    /* Pointer to array of PossSup*/

    unsigned bSystemOnly:1;     /* system only attribute?		*/
    unsigned bClosed : 1;	/* transitive closure done		*/
    unsigned bClosureInProgress:1; /* transitive closure underway	*/
    unsigned bUsesMultInherit:1; /* Uses multiple inheritance or not    */
    unsigned bHideFromAB:1; /* default ATT_HIDE_FROM_ADDRESS_BOOK value for /*
                            /* newly created instances of this class */
    unsigned bDefunct:1;  /* Class is already deleted? */
    unsigned bIsBaseSchObj:1; /* shipped in NT5 base schema */
    // Once the new schema-reuse behavior is enabled, active classes
    // may collide with each other because the schema objects replicate
    // from oldest change to youngest change. Meaning a new class
    // may replicate before the class it supercedes if the superceded
    // class is modified after being superceded (eg, it was renamed).
    //
    // The schema cache detects and treats the colliding classes as
    // if they were defunct. If later replication does not clear up the
    // collision, the user can choose a winner and officially defunct
    // the loser.
    //
    // Colliding classes are left in the schema cache until all
    // attributes and classes are loaded so that multiple collisions
    // can be detected. And for performance, the collision types are
    // recorded in these bit fields to avoid duplicate effort by
    // ValidSchemaUpdate().
    unsigned bDupLDN:1;
    unsigned bDupOID:1;
    unsigned bDupPropGuid:1;
    // Defunct classes continue to own their OID so that delete, rename,
    // and replication continue to work. If there are multiple defunct
    // classes then a "winner" is chosen. The winner has the greatest
    // objectGuid.
    GUID objectGuid;
} CLASSCACHE;

typedef struct _hashcache {
    unsigned hKey;
    void *   pVal;
} HASHCACHE;

typedef struct _hashcachestring {
    PUCHAR   value;
    ULONG    length;
    void *   pVal;
} HASHCACHESTRING;

#define FREE_ENTRY (void *) -1 // Invalid ptr that's non zero.
//
// Hash Function is lot faster if this is a power of two...though we take
// some hit on the spread.
//

// Various constants regarding the schemaInfo property on the schema container
// (SchemaInfo format is: 1 byte, \xFF, to indicate it is for last change
// count  (so that we can add other values if we need later), 4 bytes for the
// count (Version, which is stored in network data format to avoid 
// little-endian/big-endian mismatch problem) itself and lastly, 16 bytes 
// for the invocation id of the DSA doing the last originating write.
// The invalid schema-info value comes from the fact that we start with
// version 1, so noone can have version 0

#define SCHEMA_INFO_PREFIX "\xFF"
#define SCHEMA_INFO_PREFIX_LEN 1
#define SCHEMA_INFO_LENGTH 21
#define INVALID_SCHEMA_INFO "\xFF\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"


typedef struct _schemaptr
{
    ULONG            caANRids;       // Number of ULONGs allocated in pANRids
    ULONG            cANRids;        // Number of ULONGS used in pANRids
    ULONG*           pANRids;        // ATTR IDs of the attributes to do ANR on
    ULONG            ATTCOUNT;       // Size of the Table
    ULONG            CLSCOUNT;       // Size of the Table
    ULONG            PREFIXCOUNT;    // Size of the Prefix Table
    ULONG            nAttInDB;       // includes new att's not yet in schema cache
    ULONG            nClsInDB;       // includes new cls's not yet in schema cache
    DSTIME           sysTime;        // The Time at which the Schema Cache was built
    SCHEMA_PREFIX_TABLE PrefixTable;
    ULONG               cPartialAttrVec;    // size of partial set (PAS) table
    PARTIAL_ATTR_VECTOR *pPartialAttrVec;   // Pointer to the current partial set

    // An active attribute is one that still "owns" the indicated value
    // by the expediant method of having an entry in the hash.
    HASHCACHE*       ahcId;             // all attrs by msDS_IntId
    HASHCACHE*       ahcExtId;          // Active attrs by attibuteId
    HASHCACHE*       ahcCol;            // jet column ids of all attrs
    HASHCACHE*       ahcMapi;           // MapiIds of active attrs
    HASHCACHE*       ahcLink;           // LinkIDs of all attrs
    HASHCACHESTRING* ahcName;           // LDN of active attrs
    HASHCACHE*       ahcClass;          // active classes
    HASHCACHESTRING* ahcClassName;      // LDN of active classes
    HASHCACHE*       ahcClassAll;       // all classes, including defunct ones
    // hash table of pointers to attcache, hashed by schema-id-guid
    // used for faster comparison during schema update validations.
    // Not allocated during normal cache loads
    ATTCACHE**       ahcAttSchemaGuid;
    CLASSCACHE**     ahcClsSchemaGuid;
    ULONG            RefCount;  // No. of threads accessing this cache
    // Copy of the schemaInfo attribute on schema container
    BYTE             SchemaInfo[SCHEMA_INFO_LENGTH];  
    DWORD            lastChangeCached;  // last change cached since the last reboot
    ATTRVALBLOCK     *pDitContentRules;
                   
    // schema objects w/o constant attid because their prefixes
    // were not in the original hardcoded prefix table. Their
    // attids vary per DC so a constant like those in attids.h
    // cannot be used.
    ATTRTYP          EntryTTLId;        // attid for ATT_ENTRY_TTL
    ULONG            DynamicObjectId;   // clsid for CLASS_DYNAMIC_OBJECT
    ULONG            InetOrgPersonId;   // clsid for CLASS_INETORGPERSON

    // Snapshot of forest's behavior version taken at the beginning of
    // a schema cache load. The snapshot is used instead of gAnchor
    // because the version may change mid-load.
    LONG    ForestBehaviorVersion;
} SCHEMAPTR;

// Check if the forest behavior version allows the new schema
// defunct, reuse, and delete feature. Check both the version
// used to load the schema cache and the version in the anchor
//
// The schema cache is first loaded at boot using the new
// behavior because the forest version isn't known until later.
// If the forest version doesn't match the schema version, the
// schema is reloaded so users get the correct "view" of the
// schema. But we don't want AD incorrectly enabling advanced
// features in the window between when the schema is first loaded
// and then later reloaded with a lower version. So, disallow new
// features until both the schema and the anchor agree the forest
// version has advanced far enough.
#define ALLOW_SCHEMA_REUSE_FEATURE(_pSch) \
     ((((SCHEMAPTR *)(_pSch))->ForestBehaviorVersion >= DS_BEHAVIOR_SCHEMA_REUSE) \
      && (gAnchor.ForestBehaviorVersion >= DS_BEHAVIOR_SCHEMA_REUSE))

// Check if the forest behavior version allows the new schema
// defunct, reuse, and delete behavior during a cache load.
// The cache is loaded with the more flexible, new behavior
// during boot, install, and mkdit because the forest's
// behavior version is unknown and loading the cache with
// a prior version may cause unnecessary and worrisome events.
// Temporarily presenting the more flexible, new behavior
// is easier on the user and causes no harm.
#define ALLOW_SCHEMA_REUSE_VIEW(_pSch) \
     (((SCHEMAPTR *)(_pSch))->ForestBehaviorVersion >= DS_BEHAVIOR_SCHEMA_REUSE)


typedef struct {
     SCHEMAPTR *pSchema;           // pointer to schema cache to free
     DWORD cTimesRescheduled;      // No. of times the freeing of the
                                   // cache has been rescheduled
     BOOL fImmediate;              // TRUE => free cache immediately
} SCHEMARELEASE;

typedef struct {
    DWORD cAlloced;
    DWORD cUsed;
    ATTCACHE **ppACs;
} SCHEMAEXT;

typedef struct _Syntax_Pair {
    unsigned attSyntax;
    OM_syntax  omSyntax;                // XDS remnant
} Syntax_Pair;

typedef struct {
    unsigned cCachedStringSDLen;      // Last converted string default SD len in characters
    WCHAR    *pCachedStringSD;        // Last converted string default SD
    PSECURITY_DESCRIPTOR pCachedSD;   // Last converted SD
    ULONG    cCachedSDSize;           // Last converted SD size in bytes
} CACHED_SD_INFO;


typedef struct _AttConflictData {
    ULONG Version;
    ULONG AttID;
    ULONG AttSyntax;
    GUID  Guid;
} ATT_CONFLICT_DATA;

typedef struct _ClsConflictData {
    ULONG Version;
    ULONG ClsID;
    GUID  Guid;
} CLS_CONFLICT_DATA;

  
   
extern DWORD gNoOfSchChangeSinceBoot;
extern CRITICAL_SECTION csNoOfSchChangeUpdate;


// Om_Object_Class values needed for defaulting (if not specified by user)
// during adds of new attribute with object syntax
// Also used for validating on adds

#define _om_obj_cls_access_point "\x2b\x0c\x02\x87\x73\x1c\x00\x85\x3e"
#define _om_obj_cls_access_point_len 9

#define _om_obj_cls_or_name "\x56\x06\x01\x02\x05\x0b\x1d"
#define _om_obj_cls_or_name_len  7

#define _om_obj_cls_ds_dn "\x2b\x0c\x02\x87\x73\x1c\x00\x85\x4a"
#define _om_obj_cls_ds_dn_len 9

#define _om_obj_cls_presentation_addr "\x2b\x0c\x02\x87\x73\x1c\x00\x85\x5c"
#define _om_obj_cls_presentation_addr_len 9

#define _om_obj_cls_replica_link "\x2a\x86\x48\x86\xf7\x14\x01\x01\x01\x06"
#define _om_obj_cls_replica_link_len 10

#define _om_obj_cls_dn_binary "\x2a\x86\x48\x86\xf7\x14\x01\x01\x01\x0b"
#define _om_obj_cls_dn_binary_len 10

#define _om_obj_cls_dn_string "\x2a\x86\x48\x86\xf7\x14\x01\x01\x01\x0c"
#define _om_obj_cls_dn_string_len 10

// Ultimately SCAtt{Ext|Int}IdTo{Int|Ext}Id should be declared as
// __inline rather than __fastcall
ATTRTYP __fastcall SCAttExtIdToIntId(struct _THSTATE *pTHS,
                                     ATTRTYP ExtId);
ATTRTYP __fastcall SCAttIntIdToExtId(struct _THSTATE *pTHS,
                                     ATTRTYP IntId);
ATTCACHE * __fastcall SCGetAttById(struct _THSTATE *pTHS,
                                   ATTRTYP attrid);
ATTCACHE * __fastcall SCGetAttByExtId(struct _THSTATE *pTHS,
                                   ATTRTYP attrid);
ATTCACHE * __fastcall SCGetAttByCol(struct _THSTATE *pTHS,
                                    JET_COLUMNID jcol);
ATTCACHE * __fastcall SCGetAttByMapiId(struct _THSTATE *pTHS,
                                       ULONG ulPropID);
ATTCACHE * __fastcall SCGetAttByName(struct _THSTATE *pTHS,
                                     ULONG ulSize,
                                     PUCHAR pVal);
ATTCACHE * __fastcall SCGetAttByLinkId(struct _THSTATE *pTHS,
                                       ULONG ulLinkID);
CLASSCACHE * __fastcall SCGetClassById(struct _THSTATE *pTHS,
                                       ATTRTYP classid);
CLASSCACHE * __fastcall SCGetClassByName(struct _THSTATE *pTHS,
                                         ULONG ulSize,
                                         PUCHAR pVal);
DSTIME SCGetSchemaTimeStamp(void);
int SCCacheSchemaInit(VOID);
int SCCacheSchema2(void);
int SCCacheSchema3(void);
int SCAddClassSchema(struct _THSTATE *pTHS, CLASSCACHE *pCC);
int SCModClassSchema (struct _THSTATE *pTHS, ATTRTYP ClassId);
int SCDelClassSchema(ATTRTYP ClassId);
int SCAddAttSchema(struct _THSTATE *pTHS, ATTCACHE *pAC, BOOL fNoJetCol, BOOL fFixingRdn);
int SCModAttSchema (struct _THSTATE *pTHS, ATTRTYP attrid);
int SCDelAttSchema(struct _THSTATE *pTHS,
                   ATTRTYP attrid);
int SCBuildACEntry (ATTCACHE *pACOld, ATTCACHE **ppACNew);
int SCBuildCCEntry (CLASSCACHE *pCCold, CLASSCACHE **ppCCNew);
void SCUnloadSchema(BOOL fUpdate);
int SCEnumMapiProps(unsigned * pcProps, ATTCACHE ***ppACBuf);
int SCEnumNamedAtts(unsigned * pcAtts, ATTCACHE ***ppACBuf);
int SCEnumNamedClasses(unsigned * pcClasses, CLASSCACHE ***ppACBuf);
int SCLegalChildrenOfClass(ULONG parentClass,
                           ULONG *pcLegalChildren, CLASSCACHE ***ppLegalChildren);
int SCEnumNamedAuxClasses(unsigned * pcClasses,CLASSCACHE ***ppCCBuf);
ATTRTYP SCAutoIntId(struct _THSTATE *pTHS);

ATTCACHE * SCGetAttSpecialFlavor (struct _THSTATE * pTHS, ATTCACHE * pAC, BOOL fXML);



// These are the values for search flags, and are to be treated as bit fields
#define fATTINDEX       1
#define fPDNTATTINDEX   2
// NOTE, to get ANR behaviour, set fANR AND set fATTINDEX.
#define fANR            4
#define fPRESERVEONDELETE 8
// Bit to mark if attribute should be copied on object copy.
// Not used by DS, marking used by UI user copy tool, reserved here
// so that we don't use it later
#define fCOPY           16
// Bit used to indicate that this attribute should have a tuple
// index built for it.
#define fTUPLEINDEX    32

#define INDEX_BITS_MASK (fATTINDEX | fPDNTATTINDEX | fANR | fTUPLEINDEX)

// NOTE! These values are an enumeration, not bit fields!
#define SC_CHILDREN_USE_GOVERNS_ID   1
#define SC_CHILDREN_USE_SECURITY     2

int SCLegalChildrenOfName(DSNAME *pDSName, DWORD flags,
                          ULONG *pcLegalChildren, CLASSCACHE ***ppLegalChildren);

int SCLegalAttrsOfName(DSNAME *pDSName, BOOL SecurityFilter,
                       ULONG *pcLegalAttrs, ATTCACHE ***ppLegalAttrs);

void SCAddANRid(DWORD aid);
DWORD SCGetANRids(LPDWORD *IDs);
BOOL SCCanUpdateSchema(struct _THSTATE *pTHS);

VOID  SCRefreshSchemaPtr(struct _THSTATE *pTHS);
BOOL  SCReplReloadCache(struct _THSTATE *pTHS, DWORD TimeoutInMs);
VOID  SCExtendSchemaFsmoLease();
BOOL  SCExpiredSchemaFsmoLease();
BOOL  SCSignalSchemaUpdateLazy();
BOOL  SCSignalSchemaUpdateImmediate();
ULONG SCSchemaUpdateThread(PVOID pv);
int   WriteSchemaObject();
int   RecalcSchema(struct _THSTATE *pTHS);
int   ValidSchemaUpdate();
void  DelayedFreeSchema(void * buffer, void ** ppvNext, DWORD * pcSecsUntilNext);
int   SCUpdateSchemaBlocking();
int   SCRealloc(VOID **ppMem, DWORD nBytes);
int   SCReallocWrn(VOID **ppMem, DWORD nBytes);
int   SCCalloc(VOID **ppMem, DWORD nItems, DWORD nBytes);
int   SCCallocWrn(VOID **ppMem, DWORD nItems, DWORD nBytes);
int   SCResizeAttHash(struct _THSTATE *pTHS, ULONG nNewEntries);
int   SCResizeClsHash(struct _THSTATE *pTHS, ULONG nNewEntries);
void  SCFree(VOID **ppMem);
void  SCFreeSchemaPtr(SCHEMAPTR **ppSch);
void  SCFreeAttcache(ATTCACHE **ppac);
void  SCFreeClasscache(CLASSCACHE **ppcc);
void  SCFreePrefixTable(PrefixTableEntry **ppPrefixTable, ULONG PREFIXCOUNT);
DWORD SCGetDefaultSD(struct _THSTATE * pTHS, CLASSCACHE * pCC, PSID pDomainSid, 
                     PSECURITY_DESCRIPTOR * ppSD, ULONG * pcbSD);

ATTCACHE **
SCGetTypeOrderedList(
    struct _THSTATE *pTHS,
    IN CLASSCACHE *pCC
    );

VOID IncrementSchChangeCount(struct _THSTATE *pTHS);

extern CRITICAL_SECTION csDitContentRulesUpdate;

//Takes the place of the global definition of the above vars
#define DECLARESCHEMAPTR \
ULONG            ATTCOUNT     = ((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->ATTCOUNT;\
ULONG            CLSCOUNT     = ((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->CLSCOUNT;\
HASHCACHE*       ahcId        = ((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->ahcId;\
HASHCACHE*       ahcExtId     = ((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->ahcExtId;\
HASHCACHE*       ahcCol       = ((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->ahcCol;\
HASHCACHE*       ahcMapi      = ((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->ahcMapi;\
HASHCACHE*       ahcLink      = ((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->ahcLink;\
HASHCACHESTRING* ahcName      = ((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->ahcName;\
HASHCACHE*       ahcClass     = ((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->ahcClass;\
HASHCACHESTRING* ahcClassName = ((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->ahcClassName;\
HASHCACHE*       ahcClassAll  = ((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->ahcClassAll;\
ATTCACHE**       ahcAttSchemaGuid = ((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->ahcAttSchemaGuid;\
CLASSCACHE**     ahcClsSchemaGuid = ((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->ahcClsSchemaGuid;

// number of charecters in an index
#define MAX_INDEX_NAME 128

#define IS_DN_VALUED_ATTR(pAC)                          \
    ((SYNTAX_DISTNAME_TYPE == (pAC)->syntax)            \
     || (SYNTAX_DISTNAME_BINARY_TYPE == (pAC)->syntax)  \
     || (SYNTAX_DISTNAME_STRING_TYPE == (pAC)->syntax))

// Crude stats for debug and perf analysis
#if DBG
typedef struct _SCHEMASTATS {
    DWORD   Reload;     // cache reloaded by thread
    DWORD   SigNow;     // kick reload thread for immediate reload
    DWORD   SigLazy;    // kick reload thread for lazy reload
    DWORD   StaleRepl;  // Cache is stale so Repl thread retries the resync
    DWORD   SchemaRepl; // inbound schema replication (UpdateNC)
} SCHEMASTATS;
extern SCHEMASTATS SchemaStats;
#define SCHEMASTATS_DECLARE SCHEMASTATS SchemaStats
#define SCHEMASTATS_INC(_F_)    (SchemaStats._F_++)
#else
#define SCHEMASTATS_DECLARE
#define SCHEMASTATS_INC(_F_)
#endif

#define OID_LENGTH(oid_string)  (sizeof(OMP_O_##oid_string)-1)

/* Macro to make class constants available within a compilation unit
 */
#define OID_IMPORT(class_name)                                    \
                extern char   OMP_D_##class_name[] ;              \
                extern OID_t class_name;


/* Macro to allocate memory for class constants within a compilation unit
 */
#define OID_EXPORT(class_name)                                        \
        char OMP_D_##class_name[] = OMP_O_##class_name ;              \
        OID_t class_name = { OID_LENGTH(class_name), OMP_D_##class_name } ;

#endif __SCACHE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\samwrite.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       samwrite.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Prototypes for all the routines which map ATTR data to SAM information
    structs and writes them via Samr calls.

Author:

    DaveStr     01-Aug-96
    

Environment:

    User Mode - Win32

Revision History:


--*/

#ifndef __SAMWRITE_H__
#define __SAMWRITE_H__

#define WRITE_PROC(name)                    \
extern                                      \
ULONG                                       \
SampWrite##name(                            \
    SAMPR_HANDLE        hObj,               \
    ULONG               iAttr,              \
    DSNAME              *pObject,           \
    ULONG               cCallMap,           \
    SAMP_CALL_MAPPING   *rCallMap); 

WRITE_PROC(NotAllowed)

//WRITE_PROC(ServerSecurityDescriptor)

//WRITE_PROC(DomainSecurityDescriptor)
WRITE_PROC(DomainOemInformation)
WRITE_PROC(DomainMaxPasswordAge)
WRITE_PROC(DomainMinPasswordAge)
WRITE_PROC(DomainForceLogoff)
WRITE_PROC(DomainLockoutDuration)
WRITE_PROC(DomainLockoutObservationWindow)
WRITE_PROC(DomainPasswordProperties)
WRITE_PROC(DomainMinPasswordLength)
WRITE_PROC(DomainPasswordHistoryLength)
WRITE_PROC(DomainLockoutThreshold)
WRITE_PROC(DomainUasCompatRequired)
WRITE_PROC(DomainNtMixedDomain)

//WRITE_PROC(GroupSecurityDescriptor)
WRITE_PROC(GroupName)
WRITE_PROC(GroupAdminComment)
WRITE_PROC(GroupMembers)
WRITE_PROC(GroupTypeAttribute)

//WRITE_PROC(AliasSecurityDescriptor)
WRITE_PROC(AliasName)
WRITE_PROC(AliasAdminComment)
WRITE_PROC(AliasMembers)

//WRITE_PROC(UserSecurityDescriptor)
WRITE_PROC(UserAllInformation)
WRITE_PROC(UserForcePasswordChange)
WRITE_PROC(UserLockoutTimeAttribute)

WRITE_PROC(SidHistory);


#endif // __SAMWRITE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\servinfo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       servinfo.h
//
//--------------------------------------------------------------------------


typedef struct _ServiceClassArray {
    DWORD count;
    PWCHAR *Vals;
} ServiceClassArray;

extern ServiceClassArray ServicesToRemove;

void
WriteSPNsHelp(
        THSTATE *pTHS,
        ATTCACHE *pAC_SPN,
        ATTRVALBLOCK *pAttrValBlock,
        ServiceClassArray *pClasses,
        BOOL *pfChanged
        );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\samlogon.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       samlogon.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Shared routines for the token group exapnsion and caching                         

Author:

    ColinBr     11-Mar-00
    

Environment:

    User Mode - Win32

Revision History:


--*/

#ifndef __SAMLOGON_H__
#define __SAMLOGON_H__

BOOL
isGroupCachingEnabled(
    VOID
    );

//
// AUG stands for Account and Universal Group, though the structure
// will typically hold either one, not both
//
#define AUG_PARTIAL_MEMBERSHIP_ONLY 0x00000001
typedef struct _AUG_MEMBERSHIPS
{
    ULONG   Flags;
    
    ULONG    MembershipCount;
    DSNAME** Memberships;
    ULONG*   Attributes;
    
    ULONG   SidHistoryCount;
    PSID*   SidHistory;

} AUG_MEMBERSHIPS;

VOID
freeAUGMemberships(
    IN  THSTATE *pTHS,
    IN AUG_MEMBERSHIPS*p
    );

NTSTATUS
GetMembershipsFromCache(
    IN  DSNAME* pDSName,
    OUT AUG_MEMBERSHIPS** Account,
    OUT AUG_MEMBERSHIPS** Universal
    );

NTSTATUS
CacheMemberships(
    IN  DSNAME* pDSName,
    IN  AUG_MEMBERSHIPS* Account,
    IN  AUG_MEMBERSHIPS* Universal
    );

NTSTATUS
GetAccountAndUniversalMemberships(
    IN  THSTATE *pTHS,
    IN  ULONG   Flags,
    IN  LPWSTR  PreferredGc OPTIONAL,
    IN  LPWSTR  PreferredGcDomain OPTIONAL,
    IN  ULONG   Count,
    IN  DSNAME **Users,
    IN  BOOL    fRefreshTask,
    OUT AUG_MEMBERSHIPS **ppAccountMemberships OPTIONAL,
    OUT AUG_MEMBERSHIPS **ppUniversalMemberships OPTIONAL
    );


#endif // __SAMLOGON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\sdprop.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       sdprop.h
//
//--------------------------------------------------------------------------

// Critical sections, events to build a writer/reader lock
extern CRITICAL_SECTION csSDP_AddGate;
extern HANDLE hevSDP_OKToRead, hevSDP_OKToWrite;

// event signalled by SDPropagator thread when it dies.
extern HANDLE hevSDPropagatorDead;

// event the SDPropagator waits on. Should be set when something is in the
// SDProp queue
extern HANDLE hevSDPropagationEvent;

// event the SDPropagator waits on before running.  Intended to be signalled by
// SAM, which can conflict with the SDPropagator
extern HANDLE hevSDPropagatorStart;

extern PSECURITY_DESCRIPTOR pNoSDFoundSD;
extern DWORD                cbNoSDFoundSD;

NTSTATUS
__stdcall
SecurityDescriptorPropagationMain (
        PVOID StartupParam
        );



DWORD
SDPEnqueueTreeFixUp(
        THSTATE *pTHS,
        DWORD   dwFlags
        );

// These routines manage a reader/writer gate which all calls to add objects
// should enter as readers BEFORE opening a transaction.  Currently, DirAdd
// calls the reader gates before entering a transaction and after closing the
// transaction.   The Security Descriptor Propagator enters as a writer before
// it's transaction.
// The implementation of this gate is that the writer is blocked until there are
// no active readers, while readers only block if there is an ACTIVE (not
// blocked) writer.  This could lead to starving the writer, but the writer is a
// background process which will eventually get resources when no one is adding
// an object.
//
// The routines that return BOOLs may ONLY fail if we are shutting down!
BOOL
SDP_EnterAddAsReader(
        VOID );

VOID
SDP_LeaveAddAsReader(
        VOID );

BOOL
SDP_EnterAddAsWriter(
        VOID );

VOID
SDP_LeaveAddAsWriter(
        VOID );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\prefix.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       prefix.h
//
//--------------------------------------------------------------------------

#ifndef _PREFIX_H_
#define _PREFIX_H_


// Indices upto 100 are reserved for MS

#define MS_RESERVED_PREFIX_RANGE 100

// Prefix indices for internal prefixes used

#define _dsP_attrTypePrefIndex       0
#define _dsP_objClassPrefIndex       1
#define _msP_attrTypePrefIndex       2
#define _msP_objClassPrefIndex       3
#define _dmsP_attrTypePrefIndex      4
#define _dmsP_objClassPrefIndex      5
#define _sdnsP_attrTypePrefIndex     6
#define _sdnsP_objClassPrefIndex     7
#define _dsP_attrSyntaxPrefIndex     8
#define _msP_attrSyntaxPrefIndex     9
#define _msP_ntdsObjClassPrefIndex   10

// [ArobindG: 7/15/98]: The following 8 prefixe spaces with indices
// from 11 to 18 were assigned long back for temporary use. Unfortunately
// we didn't take them out earlier. Now that we are in the upgrade mode,
// it is unadvisable to take them out, since older binaries will still
// have them, and the prefixes will replicate in to a DC with new binaries 
// (if we remove these) anyway, adding them to the prefix map with
// different indices, which is confusing. Moreover, we cannot reuse these
// indices now for the same reason. So we will just keep them around,
// calling them dead for code clarity. We can use these prefix spaces
// later on if we wish to.

#define _Dead_AttPrefIndex_1     11  
#define _Dead_ClassPrefIndex_1   12
#define _Dead_AttPrefIndex_2     13
#define _Dead_ClassPrefIndex_2   14
#define _Dead_AttPrefIndex_3     15
#define _Dead_ClassPrefIndex_3   16
#define _Dead_ClassPrefIndex_4   17
#define _Dead_AttPrefIndex_4     18

#define _Ldap_0AttPrefIndex     19
#define _Ldap_1AttPrefIndex     20
#define _Ldap_2AttPrefIndex     21
#define _Ldap_3AttPrefIndex     22

// This one is not temporary.  Keep this one around.
#define _msP_ntdsExtnObjClassPrefIndex 23

// Prefixes for constructed att OIDs
#define _Constr_1AttPrefIndex     24
#define _Constr_2AttPrefIndex     25
#define _Constr_3AttPrefIndex     26
#define _DynObjPrefixIndex        27
#define _InetOrgPersonPrefixIndex 28
#define _labeledURIPrefixIndex    29
#define _unstructuredPrefixIndex  30

#ifndef dsP_attributeType
  #define _dsP_attrTypePrefix "\x55\x4"
  #define _dsP_attrTypePrefLen 2
  #define dsP_attributeType(X) (_dsP_attrTypePrefix #X) /* joint-iso-ccitt 5 4 */
#endif

#ifndef dsP_objectClass
  #define _dsP_objClassPrefix "\x55\x6"
  #define _dsP_objClassPrefLen 2
  #define dsP_objectClass(X)   (_dsP_objClassPrefix #X) /* joint-iso-ccitt 5 6 */
#endif

#ifndef msP_attributeType
  #define _msP_attrTypePrefix "\x2A\x86\x48\x86\xF7\x14\x01\x02"
  #define _msP_attrTypePrefLen 8
  #define msP_attributeType(X) (_msP_attrTypePrefix #X) /* ms-ds 2 */
#endif

#ifndef msP_objectClass
  #define _msP_objClassPrefix "\x2A\x86\x48\x86\xF7\x14\x01\x03"
  #define _msP_objClassPrefLen 8
  #define msP_objectClass(X)   (_msP_objClassPrefix #X) /* ms-ds 3 */
#endif

#ifndef dmsP_attrType
  #define _dmsP_attrTypePrefLen 8
  #define _dmsP_attrTypePrefix "\x60\x86\x48\x01\x65\x02\x02\x01"
  #define dmsP_attrType(X)   (_dmsP_attrTypePrefix #X)
#endif

#ifndef dmsP_objClass
  #define _dmsP_objClassPrefLen 8
  #define _dmsP_objClassPrefix "\x60\x86\x48\x01\x65\x02\x02\x03"
  #define dmsP_objClass(X)   (_dmsP_objClassPrefix #X)
#endif


#ifndef sdnsP_attrType
  #define _sdnsP_attrTypePrefLen 8
  #define _sdnsP_attrTypePrefix "\x60\x86\x48\x01\x65\x02\x01\x05"
  #define sdnsP_attrType(X)   (_sdnsP_attrTypePrefix #X)
#endif

#ifndef sdnsP_objClass
  #define _sdnsP_objClassPrefLen 8
  #define _sdnsP_objClassPrefix "\x60\x86\x48\x01\x65\x02\x01\x04"
  #define sdnsP_objClass(X)   (_sdnsP_objClassPrefix #X)
#endif

#ifndef dsP_attrSyntax
  #define _dsP_attrSyntaxPrefix "\x55\x5"
  #define _dsP_attrSyntaxPrefLen 2
  #define dsP_attrSyntax(X)   (_dsP_attrSyntaxPrefix #X) /* joint-iso-ccitt 5 5 */
#endif

#ifndef msP_attrSyntax
  #define _msP_attrSyntaxPrefix "\x2A\x86\x48\x86\xF7\x14\x01\x04"
  #define _msP_attrSyntaxPrefLen 8
  #define msP_attrSyntax(X) (_msP_attrSyntaxPrefix #X) /* ms-ds 4 */
#endif

#ifndef msP_ntdsObjClass
  #define _msP_ntdsObjClassPrefix "\x2A\x86\x48\x86\xF7\x14\x01\x05"
  #define _msP_ntdsObjClassPrefLen 8
  #define msP_ntdsObjClass(X) (_msP_ntdsObjClassPrefix #X) /* ms-nt-ds 5 */
#endif

#define _msP_ntdsExtnObjClassPrefix "\x2A\x86\x48\x86\xF7\x14\x01\x05\xB6\x58"
#define _msP_ntdsExtnObjClassPrefLen 10
#define msP_ntdsExntObjClass(X) (_msP_ntsExtnObjClassPrefix #X) /* ms-nt-ds 5 */
  

// 1.2.840.113556.1.4.260 - customer attributes
#define _Dead_AttPrefix_1 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x04"
#define _Dead_AttLen_1 10

// 1.2.840.113556.1.4.262  YiHsins Attribute Space
#define _Dead_AttPrefix_2 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x06"
#define _Dead_AttLen_2 10

// 1.2.840.113556.1.4.263  DaveStr's Attribute Space
#define _Dead_AttPrefix_3 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x07"
#define _Dead_AttLen_3 10

// 1.2.840.113556.1.5.56 Customer Class Space
#define _Dead_ClassPrefix_1 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x38"
#define _Dead_ClassLen_1 9

// 1.2.840.113556.1.5.57 YiHsins Class Space
#define _Dead_ClassPrefix_2 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x39"
#define _Dead_ClassLen_2 9

// 1.2.840.113556.1.5.58 DaveStr Class Space
#define _Dead_ClassPrefix_3 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x3A"
#define _Dead_ClassLen_3 9


// 1.2.840.113556.1.4.305 Srinigs Att Space
#define _Dead_AttPrefix_4 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x31"
#define _Dead_AttLen_4 10

// 1.2.840.113556.1.5.73 Srinig Class Space
#define _Dead_ClassPrefix_4 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x49"
#define _Dead_ClassLen_4 9

#define _Ldap_0AttPrefix "\x09\x92\x26\x89\x93\xF2\x2C\x64"
#define _Ldap_0AttLen 8

#define _Ldap_1AttPrefix "\x60\x86\x48\x01\x86\xF8\x42\x03"
#define _Ldap_1AttLen 8

#define _Ldap_2AttPrefix "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01"
#define _Ldap_2AttLen 9

#define _Ldap_3AttPrefix "\x60\x86\x48\x01\x86\xF8\x42\x03\x01"
#define _Ldap_3AttLen 9

#define _Constr_1AttPrefix "\x55\x15"
#define _Constr_1AttLen 2

#define _Constr_2AttPrefix "\x55\x12"
#define _Constr_2AttLen 2

#define _Constr_3AttPrefix "\x55\x14"
#define _Constr_3AttLen 2

// // 1.3.6.1.4.1.1466.101.119 x2B060104018B3A6577 LDAP RFC for Dynamic Objects
#define _DynObjPrefix   "\x2B\x06\x01\x04\x01\x8B\x3A\x65\x77"
#define _DynObjLen      9

// // 2.16.840.1.113730.3.2  x6086480186F8420302 InetOrgPerson prefix
#define _InetOrgPersonPrefix "\x60\x86\x48\x01\x86\xF8\x42\x03\x02"
#define _InetOrgPersonLen  9

// //  1.3.6.1.4.1.250.1  x2B06010401817A01 labeledURI prefix
#define _labeledURIPrefix "\x2B\x06\x01\x04\x01\x81\x7A\x01"
#define _labeledURILen 8

// // 1.2.840.113549.1.9  x2A864886F70D0109 unstructuredAddress and unstructuredName prefix                         
#define _unstructuredPrefix "\x2A\x86\x48\x86\xF7\x0D\x01\x09"
#define _unstructuredLen 8


#define MSPrefixCount 31

// All hardcoded prefixes we added till the IDS at end of April are the only ones
// we can trust to be the same on any DC for a given prefix. From that IDS,
// we started supporting upgrades, and any new hardcoded prefix we added
// after that may have different indices on different DCs (that is, not
// necessarily the same as the hardcoded index here for that prefix), since
// some may have got a new OID with that prefix as part of a schema object
// add during schema upgrade, and since its (older) binaries still does not
// contain the prefix in the hardcoded table, it went ahead and added this
// as a new prefix with a random index. When it gets the new binaries with
// the hardcoded prefix, we will void out the hardcoded prefix so that there
// will be only one entry for the prefix.
//
// This also means that an OID with a prefix beyond this may have different
// attids in different DCs just like dynamically added schema objects, even
// though the OID is in schema.ini. So you cannot use this attids as hardcoded
// constants in code. Mkhdr comments out such attids in attids.h so that you
// cannot accidentally end up using them.
//
// 26 was the last index usable in hardcoded attids, so even if you add
// a new prefix, DO NOT CHANGE the following constant. Just change the
// MSPrefixCount as usual.

#define MAX_USABLE_HARDCODED_INDEX  26


#define DECLAREPREFIXPTR \
PrefixTableEntry *PrefixTable = ((SCHEMAPTR *)pTHStls->CurrSchemaPtr)->PrefixTable.pPrefixEntry; \
ULONG  PREFIXCOUNT =  ((SCHEMAPTR *)pTHStls->CurrSchemaPtr)->PREFIXCOUNT; 

int   InitPrefixTable(PrefixTableEntry *PrefixTable, ULONG PREFIXCOUNT);
int   InitPrefixTable2(PrefixTableEntry *PrefixTable, ULONG PREFIXCOUNT);
void  SCFreePrefixTable(PrefixTableEntry **ppPrefixTable, ULONG PREFIXCOUNT);
void  PrintPrefixTable(PrefixTableEntry *PrefixTable, ULONG PREFIXCOUNT);
int   AppendPrefix(OID_t *NewPrefix,
                   DWORD ndx,
                   UCHAR *pBuf,
                   BOOL fFirst);
int   WritePrefixToSchema(struct _THSTATE *pTHS);
int   AddPrefixToTable(PrefixTableEntry *NewPrefix, 
                       PrefixTableEntry **ppTable, 
                       ULONG *pPREFIXCOUNT);


typedef struct _SCHEMA_PREFIX_MAP_ENTRY {
    USHORT  ndxFrom;
    USHORT  ndxTo;
} SCHEMA_PREFIX_MAP_ENTRY;

#define SCHEMA_PREFIX_MAP_fFromLocal (1)
#define SCHEMA_PREFIX_MAP_fToLocal   (2)

/* Turn off the warning about the zero-sized array. */
#pragma warning (disable: 4200)

typedef struct _SCHEMA_PREFIX_MAP_TABLE {
    struct _THSTATE        *pTHS;
    DWORD                   dwFlags;
    DWORD                   cNumMappings;
    SCHEMA_PREFIX_MAP_ENTRY rgMapping[];
} SCHEMA_PREFIX_MAP_TABLE;

/* Turn back on the warning about the zero-sized array. */
#pragma warning (default: 4200)

#define SchemaPrefixMapSizeFromLen(x)               \
    (offsetof(SCHEMA_PREFIX_MAP_TABLE, rgMapping)   \
    + (x) * sizeof(SCHEMA_PREFIX_MAP_ENTRY))

typedef SCHEMA_PREFIX_MAP_TABLE * SCHEMA_PREFIX_MAP_HANDLE;

SCHEMA_PREFIX_MAP_HANDLE
PrefixMapOpenHandle(
    IN  SCHEMA_PREFIX_TABLE *   pTableFrom,
    IN  SCHEMA_PREFIX_TABLE *   pTableTo
    );

BOOL
PrefixTableAddPrefixes(
    IN  SCHEMA_PREFIX_TABLE *   pTable
    );

BOOL
PrefixMapTypes(
    IN      SCHEMA_PREFIX_MAP_HANDLE  hPrefixMap,
    IN      DWORD                     cNumTypes,
    IN OUT  ATTRTYP *                 pTypes
    );

BOOL
PrefixMapAttr(
    IN      SCHEMA_PREFIX_MAP_HANDLE  hPrefixMap,
    IN OUT  ATTR *                    pAttr
    );

BOOL
PrefixMapAttrBlock(
    IN      SCHEMA_PREFIX_MAP_HANDLE  hPrefixMap,
    IN OUT  ATTRBLOCK *               pAttrBlock
    );

__inline void PrefixMapCloseHandle(IN SCHEMA_PREFIX_MAP_HANDLE *phPrefixMap) {
    THFree(*phPrefixMap);
    *phPrefixMap = NULL;
}

#endif // _PREFIX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\xdommove.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       xDomMove.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module defines various items relevant to cross domain move.

Author:

    Dave Straube (davestr) 8/7/98

Revision History:

--*/

#ifndef __XDOMMOVE_H__
#define __XDOMMOVE_H__

/*
Cross domain move is the only consumer of ATT_PROXIED_OBJECT_NAME.
This attribute is SYNTAX_DISTNAME_BINARY_TYPE.  The DISTNAME component
references different things depending on which object it is on and the
state of the object with respect to a cross domain move.  The legal
content of the BINARY component is defined here.  

We only need two values in the blob area - a type field and an epoch
number.  Rather than define structs and bear the overhead of MIDL type
pickling, and considering that NT is little endian and thus all we really
care about is alignment, we do hand marshalling of the blob component.
*/

// Following is on objects which have been moved.
#define PROXY_TYPE_MOVED_OBJECT     0

// Following is on proxy objects which are the carrier to other replicas
// of the moved from domain indicating that phantomization needs to occur.
#define PROXY_TYPE_PROXY            1

// Following defines upper limit on known types.
#define PROXY_TYPE_UNKNOWN          2

// Following defined here so they can be included by dsexts.
#define PROXY_TYPE_OFFSET   0
#define PROXY_EPOCH_OFFSET  1

// Proxy blob is 3 DWORDs: { SYNTAX_ADDRESS.structLen, proxyType, proxyEpoch }
#define PROXY_BLOB_SIZE     (3 * sizeof(DWORD))

// Internal proxy representation is INTERNAL_SYNTAX_DISTNAME_STRING.tab 
// followed by the proxy blob.
#define PROXY_SIZE_INTERNAL (sizeof(DWORD) + PROXY_BLOB_SIZE)

#define PROXY_DWORD_ADDR(pProxy, i) \
     (& ((DWORD *) &(DATAPTR(pProxy)->byteVal[0]))[i])
#define PROXY_SANITY_CHECK(pProxy) \
    Assert(PROXY_BLOB_SIZE == (DATAPTR(pProxy))->structLen); \
    Assert(htonl(* PROXY_DWORD_ADDR(pProxy, PROXY_TYPE_OFFSET)) < PROXY_TYPE_UNKNOWN);
#define INTERNAL_PROXY_SANITY_CHECK(cBytes, pProxy) \
    Assert(PROXY_SIZE_INTERNAL == cBytes); \
    Assert(PROXY_BLOB_SIZE == (pProxy)->data.structLen); \
    Assert(htonl(((DWORD *) (pProxy)->data.byteVal)[PROXY_TYPE_OFFSET]) < PROXY_TYPE_UNKNOWN);

extern
DWORD
GetProxyType(
    SYNTAX_DISTNAME_BINARY          *pProxy);

extern
DWORD
GetProxyTypeInternal(
    DWORD                           cBytes,
    INTERNAL_SYNTAX_DISTNAME_STRING *pProxy);

extern
DWORD
GetProxyEpoch(
    SYNTAX_DISTNAME_BINARY          *pProxy);

extern
DWORD
GetProxyEpochInternal(
    DWORD                           cBytes,
    INTERNAL_SYNTAX_DISTNAME_STRING *pProxy);

// Following throws exceptions and returns THAllocEx'd memory.

extern
VOID
MakeProxy(
    THSTATE                         *pTHS,
    DSNAME                          *pName,
    DWORD                           type,
    DWORD                           epoch,
    ULONG                           *pcBytes,
    SYNTAX_DISTNAME_BINARY          **ppProxy);

extern
VOID
MakeProxyKeyInternal(
    DWORD                           DNT,
    DWORD                           type,
    DWORD                           *pcBytes,
    VOID                            *buff);

#endif // __XDOMMOVE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\usn.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       usn.h
//
//--------------------------------------------------------------------------

/*
    history: 05/08/96 RajNath    Converted USN to LARGE_INTEGER
*/
#ifndef _usn_
#define _usn_

/* used to be USN, but that got defined in winnt.h, so it's now DSA_USN */
// typedef ULONG DSA_USN; USING THE typedef USN from NTDEF.H

static const USN USN_INVALID = 0;           
static const USN USN_START =   1;           
static const USN USN_MAX   =   MAXLONGLONG;

/* Frequency to update Hidden Record, should be power of 2 */
static const USN USN_DELTA_INIT =  64;

extern USN gusnEC;
extern USN gusnInit;

// Invalid object version. Object version is set to this when object
// is to be treated as deleted and garbage collected

static const ULONG OBJ_VERSION_INVALID = 0;

// Start object version. Lowest valid object version

static const ULONG OBJ_VERSION_START =  1;

// Define for maximum sensitivity, value that will get all objects,
// used by intra domain replication.

static const LONG MAX_SENSTVTY = 100;

#endif /* ifndef _usn_ */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\ldap\connect.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    connect.cxx

Abstract:

    This module implements the LDAP server for the NT5 Directory Service.

    This file interfaces between Atq and the LDAP Agent. Connect.cxx calls
    into the authentication, sspi and ASN.1 routines as appropriate. SImilarly
    authentication, sspi and ASN.1 call into connect.cxx to access Atq.

Author:

    Colin Watson     [ColinW]    16-Jul-1996

Revision History:

--*/

#include <NTDSpchx.h>
#pragma  hdrstop

#include <ipexport.h>
#include <ntddtcp.h>
#include "ldapsvr.hxx"

#define  FILENO FILENO_LDAP_CONN

#define MINUTES_UNTIL_NEXT_MAX_CONNECT_LOG      5

time_t lastLoggedMaxConnections=0;
LDAPString MaxConnExceededError = 
 DEFINE_LDAP_STRING("The maximum number of connections has been exceeded.");

//
// Used for winsock pnp stuff.
//

SOCKET LdapWinsockPnpSocket = INVALID_SOCKET;
HANDLE LdapWinsockPnpEvent = NULL;
HANDLE LdapPnpEventChangeHandle = NULL;

LDAP_ENDPOINT LdapEndpoint[MaxLdapType] = {0};

//
// Special endpoint list for UDP. This is to fix a problem where on multihomed
// machines on the same subnet, the request will go in through 1 address and
// go out another. This causes problems for the ldap client since it cannot
// match the request/response.
//

DWORD   LdapNumUdpBinds = 0;

//
// Internal routines
//

VOID ProcessConnTimeout( IN PLDAP_CONN LdapConn );
VOID ReserveLdapPorts(VOID);

VOID
LdapStopUdpPort(
    IN PVOID Endpoints
    );

BOOL
LdapDoUdpPnpBind(
    VOID
    );

VOID
NTAPI
PnpChangeCallback(
    IN PVOID   Context,
    IN BOOLEAN WaitCondition
    );


BOOL
ProcessNewClient(
    IN SOCKET      sNew,
    IN PVOID       EndpointContext,
    IN SOCKADDR *  psockAddrRemote,
    IN PATQ_CONTEXT patqContext,
    IN PVOID       pvBuff,
    IN DWORD       cbWritten
    )
/*++

Routine Description:

    Processes connection requests from clients.

Arguments:

    sNew - socket handle used for connect.
    EndpointContext - Actually, the connection type
    psockAddrRemote - remote IP address of client.
    patqContext - atq context used
    pvBuff - Initial read
    cbWritten - size of initial read.

Return Value:

    TRUE, if connection handled
    FALSE, otherwise.  The caller will need to do the cleanup in this case.

--*/
{
    PLDAP_CONN   pLdapConn = NULL;

    DWORD err     = NO_ERROR;
    BOOL fMaxExceeded = FALSE;
    PLDAP_ENDPOINT  ldapEndpoint = (PLDAP_ENDPOINT)EndpointContext;
    BOOL fUDP = (BOOL)(ldapEndpoint->ConnectionType == LdapUdpType);
    LARGE_INTEGER StartTickLarge;

    QueryPerformanceCounter(&StartTickLarge);

    if (!LdapStarted) {
       return FALSE; //   Shutting down
    }

    //
    // See if this client is allowed
    //

    if ( LdapDenyList != NULL ) {

        ACQUIRE_LOCK(&LdapLimitsLock);

        PIP_SEC_LIST denyList = LdapDenyList;
        if ( denyList == NULL ) {
            RELEASE_LOCK(&LdapLimitsLock);
            goto no_list;
        }

        ReferenceDenyList(denyList);
        RELEASE_LOCK(&LdapLimitsLock);

        if ( denyList->IsPresent((PSOCKADDR_IN)psockAddrRemote) ) {

            //
            // this is blacklisted
            //

            DereferenceDenyList(denyList);
            return FALSE;
        }

        DereferenceDenyList(denyList);
    }

no_list:

    //
    // Create a new connection object
    //

    pLdapConn = LDAP_CONN::Alloc(fUDP, &fMaxExceeded);

    if ( pLdapConn != NULL) {

        //
        // Start off processing this client connection.
        //
        //  Once we make a reset call, the LDAP_CONN object is created
        //  with the socket and atq context.
        //  From now on LDAP_CONN will take care of freeing
        //  ATQ context & socket
        //

        if ( pLdapConn->Init(ldapEndpoint,
                             psockAddrRemote,
                             patqContext,
                             cbWritten)) {

            if ( cbWritten != 0 ) {

                Assert(fUDP);

                pLdapConn->ReferenceConnection( );
                pLdapConn->IoCompletion(
                                patqContext,
                                (PUCHAR)pvBuff,
                                cbWritten,
                                NO_ERROR,
                                NULL,
                                &StartTickLarge
                                );
                pLdapConn->DereferenceConnection( );
            }

        } else {

            //
            // reset operation failed. release memory and exit.
            //

            pLdapConn->Disconnect( );
        }

        return TRUE;    // We've handled this
    } else {

        if(fMaxExceeded) {

            SendDisconnectNotify(patqContext, unavailable, &MaxConnExceededError);

            if((lastLoggedMaxConnections +
                ( MINUTES_UNTIL_NEXT_MAX_CONNECT_LOG * 60)) <  time(NULL)) {
                LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_ATQ_MAX_CONNECTIONS_EXCEEDED,
                         szInsertUL(LdapMaxConnections),
                         szInsertUL(MINUTES_UNTIL_NEXT_MAX_CONNECT_LOG),
                         NULL);
                lastLoggedMaxConnections = time(NULL);
            }
        }
    }
    return FALSE;

} // ProcessNewClient()



VOID
LdapCompletionRoutine( IN PVOID pvContext,
                       IN DWORD cbWritten,
                       IN DWORD hrCompletionStatus,
                       IN OVERLAPPED *lpo
                       )
/*++

Routine Description:

    This routine will be called back from ATQ when a network I/O completes.

    LdapCompletionRoutine takes the context which points to the LDAP_CONN
    object for this client and calls the completion routine on that object
    to process the transaction.

Arguments:

    pvContext   - Network interface object (LDAP_CONN object)

    cbWritten   - Number of bytes written to the net.

    hrCompletionStatus - Final completion status of operation.

    lpo         - lpOverlapped associated with request

Return Value:

    None.

--*/
{
    PLDAP_CONN pLdapConn = (PLDAP_CONN) pvContext;
    LONG ref;
    LARGE_INTEGER StartTickLarge;
    FILETIME ftNow;
    
    QueryPerformanceCounter(&StartTickLarge);

    if (hrCompletionStatus == ERROR_SEM_TIMEOUT) {

        IF_DEBUG(TIMEOUT) {
            DPRINT1(0,"Got timeout indication for connection %x\n", pLdapConn);
        }

        ProcessConnTimeout( pLdapConn );
        return;
    }

    //
    // Set current Time
    //

    GetSystemTimeAsFileTime(&ftNow);
    FileTimeToLocalFileTime(&ftNow, (PFILETIME)&pLdapConn->m_timeNow);

    //
    // if this is our first request, set the correct timeout
    //

    if ( !pLdapConn->m_fInitRecv ) {
        pLdapConn->m_fInitRecv = TRUE;

        AtqContextSetInfo(
                     (PATQ_CONTEXT)pLdapConn->m_atqContext,
                      ATQ_INFO_TIMEOUT,
                      LdapMaxConnIdleTime + 1
                      );
    } else {

        DWORD timeout;

        //
        // Reset timeout
        //
    
        timeout = GetNextAtqTimeout(
                                &pLdapConn->m_hardExpiry,
                                &pLdapConn->m_timeNow,
                                LdapMaxConnIdleTime
                                );

        AtqContextSetInfo2(
                  pLdapConn->m_atqContext,
                  ATQ_INFO_NEXT_TIMEOUT,
                  (DWORD_PTR)timeout
                  );

    }

    INC(pcLDAPActive);
    INC(pcThread);

    Assert( lpo != NULL );

    pLdapConn->ReferenceConnection( );
    InterlockedIncrement((PLONG)&pLdapConn->m_nRequests);
    pLdapConn->m_nTotalRequests++;

    pLdapConn->IoCompletion(
                        pLdapConn->m_atqContext,
                        NULL,
                        cbWritten,
                        hrCompletionStatus,
                        lpo,
                        &StartTickLarge
                        );

    InterlockedDecrement((PLONG)&pLdapConn->m_nRequests);
    pLdapConn->DereferenceConnection( );

    DEC(pcLDAPActive);
    DEC(pcThread);

} // LdapCompletionRoutine


VOID
NewConnectionEx(
   IN VOID *       patqContext,
   IN DWORD        cbWritten,
   IN DWORD        dwError,
   IN OVERLAPPED * lpo )
/*++
    Description:

        Callback function for new connections when using AcceptEx.
        This function verifies if this is a valid connection
         ( maybe using IP level authentication)
         and creates a new connection object

        The connection object is added to list of active connections.
        If the max number of connections permitted is exceeded,
          the client connection object is destroyed and
          connection is rejected.

    Arguments:

       patqContext:   pointer to ATQ context for the IO operation.

       cbWritten:     count of bytes available from first read operation.

       dwError:       error if any from initial operation.

       lpo:           indicates if this function was called as a result
                      of IO completion or due to some error.
    Returns:

        None.

--*/
{
    BOOL  fProcessed;
    PVOID pvEndpointContext;

    SOCKADDR * psockAddrLocal  = NULL;
    SOCKADDR * psockAddrRemote = NULL;
    SOCKET     sNew   = INVALID_SOCKET;
    PVOID      pvBuff = NULL;

    INC(pcLDAPActive);
    INC(pcThread);

    
    AtqContextSetInfo(
                 (PATQ_CONTEXT)patqContext,
                  ATQ_INFO_ABORTIVE_CLOSE,
                  TRUE
                  );
    
    if ( (dwError != NO_ERROR) || !lpo) {

        IF_DEBUG(WARNING) {
            DPRINT2(0,"NewConnectionEx failed, dwError =  0x%x, Internal = 0x%x\n",
                    dwError,
                    lpo->Internal);
        }

        // For now free up the resources.

        //AtqContextSetInfo((PATQ_CONTEXT)patqContext, ATQ_INFO_COMPLETION_CONTEXT,NULL);
        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_ATQ_CLOSE_SOCKET_ERROR,
                 szInsertUL(dwError),
                 szInsertHex(DSID(FILENO,__LINE__)),
                 szInsertUL(-1));
        AtqCloseSocket((PATQ_CONTEXT)patqContext, TRUE);
        AtqFreeContext((PATQ_CONTEXT)patqContext, TRUE );
        DEC(pcLDAPActive);
        DEC(pcThread);
        return;
    }

    //
    // Set initial timeout
    //

    AtqContextSetInfo(
                 (PATQ_CONTEXT)patqContext,
                  ATQ_INFO_TIMEOUT,
                  LdapInitRecvTimeout + 1
                  );

    AtqGetAcceptExAddrs( (PATQ_CONTEXT ) patqContext,
                         &sNew,
                         &pvBuff,
                         &pvEndpointContext,
                         &psockAddrLocal,
                         &psockAddrRemote);


    //
    // Either we're a GC or they aren't asking for a GC.  In either case, we
    // will support the call.
    //

    fProcessed = ProcessNewClient( sNew,
                                  pvEndpointContext,
                                  psockAddrRemote,
                                  (PATQ_CONTEXT ) patqContext,
                                  pvBuff,
                                  cbWritten);

    if ( !fProcessed ) {

        //
        // We failed to process this connection. Free up resources properly
        //

#if 0
        AtqContextSetInfo((PATQ_CONTEXT )patqContext,
                          ATQ_INFO_COMPLETION_CONTEXT,NULL);
#endif
        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_ATQ_CLOSE_SOCKET_ERROR,
                 szInsertUL(fProcessed),
                 szInsertHex(DSID(FILENO,__LINE__)),
                 szInsertUL(-1));
        AtqCloseSocket( (PATQ_CONTEXT )patqContext, TRUE );
        AtqFreeContext( (PATQ_CONTEXT )patqContext, TRUE );
    } else {

        //
        // On non-datagram sockets, turn on keepalives so we
        // notice dead clients.  Yes, this means on every
        // completion we reset keepalives to be on, but if
        // keepalives are already on, this is a very cheap
        // operation, done entirely in memory.
        //

        BOOL fDoKeepalive = TRUE;

        if ( setsockopt( (SOCKET) ((PATQ_CONTEXT)patqContext)->hAsyncIO,
                        SOL_SOCKET,
                        SO_KEEPALIVE,
                        (const CHAR *) &fDoKeepalive,
                        sizeof( fDoKeepalive)) != 0) {

            IF_DEBUG(WARNING) {
                DPRINT2(0,"setsockopt(%d,KA,TRUE) failed. Error = %d\n",
                        ((PATQ_CONTEXT)patqContext)->hAsyncIO,
                        WSAGetLastError());
            }
        }
    }

    DEC(pcLDAPActive);
    DEC(pcThread);

    return;
} // NewConnectionEx()


BOOL
InitializeLimits(
             VOID
             );

#if DBG
VOID
CheckForPOD(
        DWORD nBytes,
        PCHAR pBuffer
        )
{
    if ( nBytes >= 4 ) {

        if ( (pBuffer[0] == 'P') &&
             (pBuffer[1] == 'O') &&
             (pBuffer[2] == 'D') &&
             (pBuffer[3] == 'D')) {

            if ( nBytes == 8 ) {
                DWORD flag;

                flag = pBuffer[4] |
                    (pBuffer[5] << 8) |
                    (pBuffer[6] << 16) |
                    (pBuffer[7] << 24);

                KdPrint(("Got POD. Setting debug flag to %x [old is %x]\n",flag, LdapFlags));
                LdapFlags = flag;
            } else {
                KdPrint(("Got POD Break.\n"));
                DebugBreak( );
            }
        }
    }
} // CheckForPOD
#endif



VOID
UDPIoCompletion(
        IN VOID *       patqContext,
        IN DWORD        cbWritten,
        IN DWORD        dwError,
        IN OVERLAPPED * lpo
        )
/*++
    Description:

    Callback function for new connections when using AcceptEx over a UDP
    connection. This function verifies if this is a valid connection ( maybe
    using IP level authentication) and creates a new connection object

    The connection object is added to list of active connections. If the max
    number of connections permitted is exceeded, the client connection object is
    destroyed and connection is rejected.

    Arguments:

    patqContext:   pointer to ATQ context for the IO operation.

    cbWritten:     count of bytes available from first read operation.

    dwError:       error if any from initial operation.

    lpo:           indicates if this function was called as a result
                   of IO completion or due to some error.
    Returns:

    None.

--*/
{
    BOOL  fProcessed;
    PVOID pvEndpointContext;

    SOCKADDR * psockAddrLocal  = NULL;
    SOCKADDR * psockAddrRemote = NULL;
    SOCKET     sNew   = INVALID_SOCKET;
    PVOID      pvBuff = NULL;
    DWORD_PTR  ContextInfo;
    int        psockAddrRemoteSize;

    INC(pcLDAPActive);
    INC(pcThread);

    IF_DEBUG(UDP) {
        DPRINT1(0, "Got a UDP IO completion: context %d\n",patqContext);
    }

    if(patqContext == NULL) {
        DEC(pcLDAPActive);
        DEC(pcThread);
        return;
    };

    ContextInfo = AtqContextGetInfo(
            (PATQ_CONTEXT)patqContext,
            ATQ_INFO_COMPLETION_CONTEXT
            );

    if (ContextInfo != NULL) {

        if (NULL != lpo) {

            PLDAP_REQUEST request = (PLDAP_REQUEST)ContextInfo;
            PLDAP_CONN conn = request->m_LdapConnection;

            //
            // increment connection reference so it does not disappear
            // during request cleanups
            //

            conn->ReferenceConnection( );
            conn->Disconnect( );
            request->m_LdapConnection->DereferenceAndKillRequest( request );
            request->DereferenceRequest( );
            conn->DereferenceConnection( );
        }

        //
        // This is a write completion, shut this down
        //

        DPRINT(1,"Write completion\n");
        DEC(pcLDAPActive);
        DEC(pcThread);
        return;
    }

    //
    // If a client connects and then disconnects gracefully ,we will get a
    // completion with zero bytes and success status.
    //

    if ((cbWritten == 0) && (dwError == NO_ERROR)) {
        dwError = WSAECONNABORTED;
    }

    if ((dwError != NO_ERROR) || (lpo == NULL)) {

        IF_DEBUG(UDP) {
            DPRINT2(0,
                (PUCHAR)"UdpCompletion failed %x, %d\n", dwError, lpo);
        }

        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_ATQ_CLOSE_SOCKET_ERROR,
                 szInsertUL(dwError),
                 szInsertHex(DSID(FILENO,__LINE__)),
                 szInsertUL(-1));

        AtqCloseSocket( (PATQ_CONTEXT) patqContext, TRUE );
        AtqFreeContext( (PATQ_CONTEXT) patqContext, FALSE );

        DEC(pcLDAPActive);
        DEC(pcThread);
        return;
    }

    AtqGetDatagramAddrs(
            (PATQ_CONTEXT ) patqContext,
            &sNew,
            &pvBuff,
            &pvEndpointContext,
            &psockAddrRemote,
            &psockAddrRemoteSize);

#if DBG
    CheckForPOD(cbWritten, (PCHAR)pvBuff);
#endif

    fProcessed = ProcessNewClient( sNew,
                                  pvEndpointContext,
                                  psockAddrRemote,
                                  (PATQ_CONTEXT ) patqContext,
                                  pvBuff,
                                  cbWritten);


    if ( !fProcessed ) {

        IF_DEBUG(UDP) {
            DPRINT(0,
               "UDP Failed in the process call, closing socket and context\n");
        }

        //
        // We failed to process this connection. Free up resources properly
        //

#if 0
        AtqContextSetInfo((PATQ_CONTEXT )patqContext,
                          ATQ_INFO_COMPLETION_CONTEXT,NULL);
#endif
        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_ATQ_CLOSE_SOCKET_ERROR,
                 szInsertUL(fProcessed),
                 szInsertHex(DSID(FILENO,__LINE__)),
                 szInsertUL(-1));
        AtqCloseSocket( (PATQ_CONTEXT )patqContext, TRUE );
        AtqFreeContext( (PATQ_CONTEXT )patqContext, TRUE );
    }

    DEC(pcLDAPActive);
    DEC(pcThread);

    return;

} // UDPIoCompletion



VOID
ShutdownConnections( VOID )

/*++

Routine Description:

    This routine deregisters the LDAP client with Atq, and blocks until all
    clients are gone.

Arguments:

    None.

Return Value:

    None.

--*/
{
    int SleepCount = 30;

    IF_DEBUG(INIT) {
        DPRINT(0, "ShutdownConnections entered.\n");
    }

    CloseConnections( );

    while (CurrentConnections > 0 ) {
        if (SleepCount-- == 0) {
            //  Failed to close down in a timely fashion!
            LogUnhandledError(STATUS_UNSUCCESSFUL);
            Sleep(5*1000);  //  Let error get logged - just in-case
            break;
        }
        Sleep(1000);
        IF_DEBUG(WARNING) {
            DPRINT1(0,"Waiting for %d connections to close\n",
                    CurrentConnections);
        }
    }

    //
    // Cleanup PNP handles
    //

    IF_DEBUG(UDP) {
        DPRINT(0,"Cleaning up UDP Pnp Handles\n");
    }

    if ( LdapPnpEventChangeHandle != NULL ) {
        RtlDeregisterWait(LdapPnpEventChangeHandle);
        LdapPnpEventChangeHandle = NULL;
    }

    if ( LdapWinsockPnpEvent != NULL ) {
        CloseHandle(LdapWinsockPnpEvent);
        LdapWinsockPnpEvent = NULL;
    }

    if ( LdapWinsockPnpSocket != INVALID_SOCKET ) {
        closesocket(LdapWinsockPnpSocket);
        LdapWinsockPnpSocket = INVALID_SOCKET;
    }

    //
    // Shutdown all the ATQ endpoints
    //

    for (int index=0; index < MaxLdapType; index++) {

        PVOID endpoint;

        ACQUIRE_LOCK(&csConnectionsListLock);
        endpoint = LdapEndpoint[index].AtqEndpoint;
        LdapEndpoint[index].AtqEndpoint = NULL;
        RELEASE_LOCK(&csConnectionsListLock);

        if (endpoint != NULL ) {

            //
            // If this is UDP, then it points to an array of ENDPOINTS
            //

            if ( index == LdapUdpType ) {

                LdapStopUdpPort(endpoint);
                LdapFree(endpoint);

            } else {

                (VOID) AtqStopEndpoint(endpoint);
                if (!AtqCloseEndpoint(endpoint)) {
                    IF_DEBUG(WARNING) {
                        DPRINT1(0,"AtqStopAndCloseEndpoint error for %x\n", endpoint);
                    }
                }
            }
        }
    }

    IF_DEBUG(INIT) {
        DPRINT(0, "ShutdownConnections complete\n");
    }

    return;
} // ShutdownConnections


PVOID
LdapGetAtqEndpoint(
    PATQ_ENDPOINT_CONFIGURATION Config,
    PVOID Context
    )
/*++

Routine Description:

    Call the ATQ package to get the endpoint.

Arguments:

    Config - Configuration block to pass to ATQ
    Context - Context to pass to ATQ

Return Value:

    TRUE, port started.
    FALSE, otherwise

--*/
{

    PVOID endpoint;

    endpoint = AtqCreateEndpoint( Config, Context );
    if ( endpoint == NULL ) {
        DPRINT1(0,"AtqCreateEndpoint failed with %d\n",
                   GetLastError());
        return NULL;
    }

    AtqEndpointSetInfo2(endpoint, EndpointInfoConsumerType, AtqConsumerLDAP);

    if ( !AtqStartEndpoint(endpoint) ) {

        (VOID)AtqStopEndpoint(endpoint);
        (VOID)AtqCloseEndpoint(endpoint);

        DPRINT1(0,"AtqStartEndpoint failed with %d\n",
                   GetLastError());
        return NULL;
    }

    return endpoint;
} // LdapGetAtqEndpoint



BOOL
LdapStartTcpPort(
    IN DWORD  Index,
    IN USHORT Port
    )
/*++

Routine Description:

    Start the TCP Ports

Arguments:

    Index - which ldaptype index to use
    Port - port to bind to

Return Value:

    TRUE, port started.
    FALSE, otherwise

--*/
{
    ATQ_ENDPOINT_CONFIGURATION config;

    Assert(LdapEndpoint[Index].ConnectionType == Index);

    if ( LdapEndpoint[Index].AtqEndpoint != NULL ) {

        DPRINT1(0,"LDAP Attempting to start %d endpointtwice!!!\n", Index);
        return TRUE;
    }

    //
    //  ATQ offers a feature whereby it avoids context switches by informing
    //  us when the first packet arrives. Unfortunately it keeps the buffer
    //  until the connection is destroyed.
    //

    IF_DEBUG(INIT) {
        DPRINT1(0,"Starting TCP Port %d\n", Port);
    }

    config.nAcceptExOutstanding = 12;
    config.AcceptExTimeout = (unsigned long)-1;  // Forever

    config.fDatagram = FALSE;
    config.fLockDownPort = TRUE;
    config.pfnConnect = NULL;
    config.cbAcceptExRecvBuffer = 0;
    config.pfnConnectEx = NewConnectionEx;
    config.pfnIoCompletion = LdapCompletionRoutine;

    config.ListenPort = Port;
    config.IpAddress = INADDR_ANY;

    LdapEndpoint[Index].AtqEndpoint = LdapGetAtqEndpoint(
                                                     &config,
                                                     (PVOID)&LdapEndpoint[Index]
                                                     );
    if ( LdapEndpoint[Index].AtqEndpoint == NULL ) {
        DPRINT2(0,"GetAtqEndpoint[%d] failed with %d\n", Index, GetLastError());
        return FALSE;
    }

    return TRUE;
} // LdapStartTcpPort


BOOL
LdapStartSslPorts(
    VOID
    )
/*++

Routine Description:

    Start the SSL ports

Arguments:

    None.

Return Value:

    TRUE, SSL started.
    FALSE, otherwise

--*/
{

    //
    // Try to start SSL. We start the SSL ports regardless of whether
    // we got a cert or not.
    //

    //(VOID)InitializeSSL( );

    //
    // Start main port
    //

    (VOID)LdapStartTcpPort(LdapSslType,LDAP_SSL_PORT);

    //
    // Start GC Port
    //

    if ( gAnchor.fAmGC ) {
        (VOID)LdapStartTcpPort(GcSslType,LDAP_GC_SSL_PORT);
    }

    return TRUE;

} // LdapStartSslPorts


BOOL
LdapStartUdpPort(
    IN PSOCKET_ADDRESS SockAddress,
    IN DWORD nAddresses
    )
/*++

Routine Description:

    Start all the Udp bindings.

Arguments:

    SockAddress - array of SOCKET_ADDRESS containing the IP addresses of
        valid addresses for the local machine
    nAddresses - number of elements of the SockAddress array

Return Value:

    TRUE, UDP started.
    FALSE, otherwise

--*/
{

    ATQ_ENDPOINT_CONFIGURATION config;
    PVOID endpoint;
    PLDAP_ENDPOINT udpEndpoint;
    DWORD i,j;
    BOOL           fRet = TRUE;

    //
    // if the endpoint is not NULL, then we have an existing binding.
    // stop the existing binding before we start new ones.
    //

    ACQUIRE_LOCK(&LdapUdpEndpointLock);
    
    endpoint = LdapEndpoint[LdapUdpType].AtqEndpoint;
    LdapEndpoint[LdapUdpType].AtqEndpoint = NULL;

    if ( endpoint != NULL ) {

        LdapStopUdpPort(endpoint);
        LdapFree(endpoint);
        LdapNumUdpBinds = 0;

        IF_DEBUG(UDP) {
            DPRINT1(0,"LdapStartUdpPort: Freeing old endpoint list %x\n", endpoint);
        }
    }

    Assert(LdapNumUdpBinds == 0);

    //
    // if we have nothing to bind, return
    //

    if ( nAddresses == 0 ) {
        IF_DEBUG(UDP) {
            DPRINT(0,"StartUDP: Empty list.  No listens started\n");
        }
        goto exit;
    }

    //
    // Allocate a buffer for the bindings
    //

    udpEndpoint = (PLDAP_ENDPOINT)LdapAlloc(nAddresses * sizeof(LDAP_ENDPOINT));
    if ( udpEndpoint == NULL ) {
        DPRINT1(0,"Unable to allocate %d udp endpoints\n", nAddresses);
        fRet = FALSE;
        goto exit;
    }

    IF_DEBUG(UDP) {
        DPRINT2(0,"LdapStartUdpPort: Allocated udp list %x for %d endpoints\n",
                 udpEndpoint, nAddresses);
    }

    //
    // Fill in the ATQ configuration structure
    //

    config.nAcceptExOutstanding = 3;
    config.AcceptExTimeout = (unsigned long)-1;  // Forever

    config.fDatagram = TRUE;
    config.fLockDownPort = TRUE;
    config.pfnConnect = NULL;
    config.pfnConnectEx = UDPIoCompletion;
    config.pfnIoCompletion = UDPIoCompletion;

    config.cbAcceptExRecvBuffer = LdapMaxDatagramRecv;
    config.ListenPort = LDAP_PORT;
    config.cbDatagramWSBufSize = (16*1024);
    config.fReverseQueuing = TRUE;
    
    //
    // Do a bind for each addresses
    //

    for (i=0, j=0; i < nAddresses; i++) {

        PSOCKADDR_IN addr;
        Assert(SockAddress[i].iSockaddrLength == sizeof(SOCKADDR_IN));
        addr = (PSOCKADDR_IN)SockAddress[i].lpSockaddr;

        config.IpAddress = addr->sin_addr.s_addr;

        udpEndpoint[j].ConnectionType = LdapUdpType;
        udpEndpoint[j].AtqEndpoint =
            LdapGetAtqEndpoint( &config, (PVOID)&udpEndpoint[j] );

        if ( udpEndpoint[i].AtqEndpoint == NULL ) {
            DPRINT3(0,"GetAtqEndpoint[%d] on address %s failed with %d\n",
                       i, inet_ntoa(addr->sin_addr), GetLastError());
            continue;
        }

        j++;
        IF_DEBUG(UDP) {
            DPRINT2(0,"LdapStartUdp: Got endpoint %x for %s\n",
                udpEndpoint[i].AtqEndpoint, inet_ntoa(addr->sin_addr));
        }
    }

    if ( j > 0 ) {
        LdapNumUdpBinds = j;
        LdapEndpoint[LdapUdpType].AtqEndpoint = (PVOID)udpEndpoint;
    } else {
        DPRINT(0,"No UDP endpoints started\n");
        LdapFree(udpEndpoint);
        fRet = FALSE;
        goto exit;
    }

    IF_DEBUG(INIT) {
        DPRINT1(0,"LdapStartUdpPort started with %d bindings.\n",LdapNumUdpBinds);
    }

exit:
    RELEASE_LOCK(&LdapUdpEndpointLock);

    return fRet;
} // LdapStartUdpPort


VOID
LdapStopUdpPort(
    IN PVOID Endpoints
    )
/*++

Routine Description:

    Stops all the Udp bindings.

Arguments:

    Endpoints - an array to a list of UDP endpoints.

Return Value:

    None.

--*/
{
    PLDAP_ENDPOINT udpEndpoint = (PLDAP_ENDPOINT)Endpoints;

    IF_DEBUG(UDP) {
        DPRINT1(0,"LdapStopUdpPort called. nBinds %d\n", LdapNumUdpBinds);
    }

    for (DWORD j=0; j < LdapNumUdpBinds ;j++ ) {

        PVOID endpoint = udpEndpoint[j].AtqEndpoint;
        Assert(udpEndpoint[j].ConnectionType == LdapUdpType);

        if ( endpoint != NULL ) {

            IF_DEBUG(UDP) {
                DPRINT1(0,"Closing UDP endpoint %p\n",endpoint);
            }

            (VOID) AtqStopEndpoint(endpoint);
            if (!AtqCloseEndpoint(endpoint)) {
                IF_DEBUG(WARNING) {
                    DPRINT1(0,"LdapStopUdpPort: AtqCloseEndpoint error for %x\n",
                           endpoint );
                }
            }
        }
    }

    return;
} // LdapStopUdpPort


extern "C"
BOOL
LdapStartGCPort(
        VOID
        )
/*++

Routine Description:

    Starts the GC port

Arguments:

    None.

Return Value:

    TRUE, if succesful. FALSE otherwise.

--*/
{
    IF_DEBUG(INIT) {
        DPRINT1(0,"Starting GC Port[%d]\n",gAnchor.fAmGC);
    }

    if ( !LdapStarted ) {
        IF_DEBUG(INIT) {
            DPRINT(0,"Ldap not started.\n");
        }
        return FALSE;
    }

    if ( !gAnchor.fAmGC ) {

        IF_DEBUG(INIT) {
            DPRINT(0,"Not a GC\n");
        }
        return TRUE;
    }

    if ( LdapStartTcpPort(
                        GcTcpType,
                        LDAP_GC_PORT
                        ) ) {

        LdapStartTcpPort(GcSslType,LDAP_GC_SSL_PORT);
        return TRUE;
    }

    return FALSE;

} // LdapStartGCPort


extern "C"
VOID
LdapStopGCPort(
        VOID
        )
/*++

Routine Description:

    Stops the GC port from listening.

Arguments:

    None.

Return Value:

    None

--*/
{

    PVOID atqGcEndpoint;
    PVOID atqGcSslEndpoint;

    IF_DEBUG(INIT) {
        DPRINT(0,"Stopping the GC Port\n");
    }

    ACQUIRE_LOCK( &csConnectionsListLock );

    atqGcEndpoint = LdapEndpoint[GcTcpType].AtqEndpoint;
    atqGcSslEndpoint = LdapEndpoint[GcSslType].AtqEndpoint;
    LdapEndpoint[GcTcpType].AtqEndpoint = NULL;
    LdapEndpoint[GcSslType].AtqEndpoint = NULL;

    RELEASE_LOCK(&csConnectionsListLock);

    if ( atqGcEndpoint != NULL ) {
        AtqStopEndpoint(atqGcEndpoint);
        AtqCloseEndpoint(atqGcEndpoint);
    }

    if ( atqGcSslEndpoint != NULL ) {
        AtqStopEndpoint(atqGcSslEndpoint);
        AtqCloseEndpoint(atqGcSslEndpoint);
    }
    return;

} // LdapStopGCPort




NTSTATUS
InitializeConnections( VOID )
/*++

Routine Description:

    This routine registers the LDAP client with Atq.

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/
{
    DWORD i;
    DWORD NetStatus;

    IF_DEBUG(INIT) {
        DPRINT(0, "InitializeConnections entered.\n");
    }

    //
    // Find out from ATQ the largest datagram that can be sent.
    //

    LdapMaxDatagramSend = (DWORD) AtqGetInfo(AtqMaxDGramSend);
    IF_DEBUG(INIT) {
        DPRINT1(0, "LdapMaxDatagramSend set to %d.\n", LdapMaxDatagramSend);
    }

    //
    // Reserve Ldap GC ports so they are not dished out on wildcard binds
    //

    ReserveLdapPorts( );

    for ( i=0; i < MaxLdapType; i++ ) {
        LdapEndpoint[i].AtqEndpoint = NULL;
        LdapEndpoint[i].ConnectionType = i;
    }

    //
    // Open a socket to get winsock PNP notifications on.
    //

    LdapWinsockPnpSocket = WSASocket( AF_INET,
                           SOCK_DGRAM,
                           0, // PF_INET,
                           NULL,
                           0,
                           0 );

    if ( LdapWinsockPnpSocket == INVALID_SOCKET ) {

        NetStatus = WSAGetLastError();
        DPRINT1(0,"WASSocket failed with %ld\n", NetStatus );
        goto do_udp_bind;
    }

    //
    // Open an event to wait on.
    //

    LdapWinsockPnpEvent = CreateEvent(
                                  NULL,     // No security ettibutes
                                  FALSE,    // Auto reset
                                  FALSE,    // Initially not signaled
                                  NULL);    // No Name

    if ( LdapWinsockPnpEvent == NULL ) {
        NetStatus = GetLastError();
        DPRINT1(0,"Cannot create Winsock PNP event %ld\n", NetStatus );
        goto do_udp_bind;
    }

    //
    // Associate the event with new addresses becoming available on the socket.
    //

    NetStatus = WSAEventSelect( LdapWinsockPnpSocket, LdapWinsockPnpEvent, FD_ADDRESS_LIST_CHANGE );

    if ( NetStatus != 0 ) {
        NetStatus = WSAGetLastError();
        DPRINT1(0,"Can't WSAEventSelect %ld\n", NetStatus );
        goto do_udp_bind;
    }

do_udp_bind:

    if ( NetStatus != 0 ) {
        if ( LdapWinsockPnpEvent != NULL ) {
            CloseHandle(LdapWinsockPnpEvent);
            LdapWinsockPnpEvent = NULL;
        }

        if ( LdapWinsockPnpSocket != INVALID_SOCKET ) {
            closesocket(LdapWinsockPnpSocket);
            LdapWinsockPnpSocket = INVALID_SOCKET;
        }
    }


    //
    // We need to bind to each address with UDP.  We also need to handle PNP issues.
    //

    if ( !LdapDoUdpPnpBind( )) {
        goto shutdown;
    }

    //
    // Bind to the tcp ports
    //

    if ( !LdapStartTcpPort(LdapTcpType,LDAP_PORT) ) {
        goto shutdown;
    }

    if ( gAnchor.fAmGC ) {

        if ( !LdapStartTcpPort(
                        GcTcpType,
                        LDAP_GC_PORT
                        ) ) {
            goto shutdown;
        }
    }

    LdapStartSslPorts( );

    IF_DEBUG(INIT) {
        DPRINT(0, "InitializeConnections succeeded.\n");
    }
    return TRUE;
shutdown:

    if ( LdapWinsockPnpSocket != INVALID_SOCKET ) {
        closesocket(LdapWinsockPnpSocket);
        LdapWinsockPnpSocket = INVALID_SOCKET;
    }

    if ( LdapWinsockPnpEvent != NULL ) {
        CloseHandle(LdapWinsockPnpEvent);
        LdapWinsockPnpEvent = NULL;
    }

    IF_DEBUG(INIT) {
        DPRINT(0, "InitializeConnections failed.\n");
    }
    ShutdownConnections( );
    return FALSE;

} // InitializeConnections


VOID
ProcessConnTimeout(
    IN PLDAP_CONN LdapConn
    )
{
    DWORD   nextTimeout = 120;
    FILETIME ftNow;
    TimeStamp tsLocal;

    //
    //  ATQ has decided to timeout one of our requests on a connection,
    //  but we don't want nor pay any attention to their timeouts.
    //

    if ( !LdapConn->m_fInitRecv ) {
        goto disconnect;
    }

    IF_DEBUG(TIMEOUT) {
        DPRINT6(0,"Timeout on conn %x [nfy %d req %d curr %d max %d auth %x]\n",
                LdapConn, LdapConn->m_countNotifies,
                LdapConn->m_nRequests, CurrentConnections,
                LdapMaxConnections, LdapConn->m_pSecurityContext);
    }

    //
    // Zap the paged result storage if any
    //

    (VOID)FreeAllPagedBlobs(LdapConn);

#if 0
    // !!! Disable this algorithm since its very confusing and does
    // not seem to serve much purpose.
    //
    //
    // if conn < 1/4 maxConn, ignore.  Call again after 2 minutes
    //

    fourXcurrent = CurrentConnections << 2;

    if ( fourXcurrent < LdapMaxConnections ) {
        IF_DEBUG(TIMEOUT) {
            DPRINT(0,"Less than 1/4 max, no timeout\n");
        }
        goto exit;
    }

    //
    // disconnect if unauthenticated
    //

    if ( LdapConn->m_pSecurityContext == NULL ) {
        IF_DEBUG(TIMEOUT) {
            DPRINT(0,"Disconnecting unauthenticated connection.\n");
        }
        goto disconnect;
    }

    //
    // if conn is less than 3/4 max, disconnect the unauthenticated
    //

    if ( fourXcurrent < (3 * LdapMaxConnections) ) {

        IF_DEBUG(TIMEOUT) {
            DPRINT(0,"Less than 3/4, no timeout.\n");
        }
        goto exit;
    }
#endif

disconnect:

    //
    // We should disconnect if there are no outstanding requests
    //

    if ( (LdapConn->m_countNotifies == 0) &&
         (LdapConn->m_nRequests == 0) ) {

        IF_DEBUG(WARNING) {
            DPRINT2(0,"Disconnecting %p [auth %x] on timeout\n", 
                    LdapConn, LdapConn->m_pSecurityContext);
        }

        goto timeout;
    }

    IF_DEBUG(TIMEOUT) {
        DPRINT2(0,"Unable to timeout, outstanding requests %d notifications %d\n",
               LdapConn->m_nRequests, LdapConn->m_countNotifies);
    }

    //
    // Disconnect if we are near the hard expiry.
    //

    GetSystemTimeAsFileTime(&ftNow);
    FileTimeToLocalFileTime(&ftNow, (PFILETIME)&tsLocal);

    if ( IsContextExpired(&LdapConn->m_hardExpiry, &tsLocal) ) {

        IF_DEBUG(WARNING) {
            DPRINT2(0,"Disconnecting %p on context timeout. Notify count %d.\n", 
                    LdapConn, LdapConn->m_countNotifies);
        }

        goto timeout;
    }

    //
    // Compute the next timeout which is the min of LdapMaxConnIdleTime and the
    // hard timeout (in secs) remaining.
    //

    nextTimeout = GetNextAtqTimeout(
                        &LdapConn->m_hardExpiry,
                        &tsLocal,
                        LdapMaxConnIdleTime
                        );

    //
    // Reset timeout
    //

    AtqContextSetInfo2(
              LdapConn->m_atqContext,
              ATQ_INFO_NEXT_TIMEOUT,
              (DWORD_PTR)nextTimeout
              );

    return;

timeout:

    {
        PCHAR ipAddress;

        // !!! Don't send blocking disconnect notify as ATQ holds a lock here
        // if client has died and does not receive data, this might block forever.
        //
        //SendDisconnectNotify(LdapConn->m_socket, timeLimitExceeded );

        //
        // Send Notice of disconnect, then timeout
        //

        LdapConn->Disconnect( );

        //
        // Log event
        //

        ipAddress = inet_ntoa(
                      ((PSOCKADDR_IN)&LdapConn->m_RemoteSocket)->sin_addr );

        IF_DEBUG(TIMEOUT) {
            DPRINT1(0,"Disconnecting client %s because of timeout\n",
                    ipAddress);
        }

        if (ipAddress != NULL ) {
            LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_LDAP_CONNECTION_TIMEOUT,
                 szInsertSz(ipAddress),
                 NULL,
                 NULL);
        }
        return;
    }

} // ProcessConnTimeout


VOID
ReserveLdapPorts(
    VOID
    )
/*++

Routine Description:

    This routine does an IOCTL call to tcp to reserve the LDAP ports.
        3268
        3269

    After the call, tcp will not allocate these ports to clients that asks
    tcp to pick a port for it.

Arguments:

    None.

Return Value:

    None.  If failure, ignore.

--*/
{
    TCP_RESERVE_PORT_RANGE portRange;
    IO_STATUS_BLOCK iosb;
    UNICODE_STRING string;
    NTSTATUS status;
    HANDLE TcpipDriverHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    BOOL ok;
    DWORD bytesReturned;

    //
    // We only need to reserve 3268 and 3269 (and not 636 and 389) since
    // these 2 ports the ones that are part of the reserved pool.
    //

    portRange.UpperRange = 3269;
    portRange.LowerRange = 3268;

    RtlInitUnicodeString(&string, DD_TCP_DEVICE_NAME);

    InitializeObjectAttributes(&objectAttributes,
                               &string,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );
    status = NtCreateFile(&TcpipDriverHandle,
                          SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                          &objectAttributes,
                          &iosb,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_OPEN_IF,
                          0,
                          NULL,
                          0
                          );
    if (!NT_SUCCESS(status)) {
        DPRINT1(0,"LdapReservePorts: Cannot open tcp driver.Error %x\n", status);
        return;
    }

    ok = DeviceIoControl(TcpipDriverHandle,
                         IOCTL_TCP_RESERVE_PORT_RANGE,
                         &portRange,
                         sizeof(portRange),
                         NULL,
                         0,
                         &bytesReturned,
                         NULL
                         );
    if (!ok) {
        DPRINT1(0,"LdapReservePorts: IoControl failed with %x\n", GetLastError());
    }

    NtClose(TcpipDriverHandle);
    return;

} // ReserveLdapPorts



BOOL
LdapDoUdpPnpBind(
    VOID
    )
/*++

Routine Description:

    Handle a WSA PNP event that IP addresses have changed

Arguments:

    None

Return Value:

    TRUE if the address list has changed

--*/
{
    DWORD NetStatus;
    BOOL RetVal = FALSE;
    DWORD BytesReturned;
    LPSOCKET_ADDRESS_LIST socketAddressList = NULL;
    ULONG SocketAddressSize = 0;
    int i;
    int j;
    int MaxAddressCount;
    SOCKET_ADDRESS  defaultAddress;

    //
    // If datagram is disabled, return.
    //

    if ( LdapMaxDatagramRecv == 0 ) {
        IF_DEBUG(WARNING) {
            DPRINT(0,"Datagram processing disabled\n");
        }
        return TRUE;
    }

    //
    // Ask for notification of address changes.
    //

    if ( LdapWinsockPnpSocket == INVALID_SOCKET ) {
        IF_DEBUG(UDP) {
            DPRINT(0,"LdapPnpSocket invalid. Using default.\n");
        }
        goto useDefault;
    }

    //
    // register change notification with winsock
    //

    NetStatus = WSAIoctl( LdapWinsockPnpSocket,
                          SIO_ADDRESS_LIST_CHANGE,
                          NULL, // No input buffer
                          0,    // No input buffer
                          NULL, // No output buffer
                          0,    // No output buffer
                          &BytesReturned,
                          NULL, // No overlapped,
                          NULL );   // Not async

    if ( NetStatus != 0 ) {
        NetStatus = WSAGetLastError();
        if ( NetStatus != WSAEWOULDBLOCK) {
            DPRINT1(0,"LdapUdpPnpBind: Cannot WSAIoctl SIO_ADDRESS_LIST_CHANGE %ld\n",
                      NetStatus);
            goto useDefault;
        }
    }

    //
    // Get the list of IP addresses for this machine.
    //

    BytesReturned = 150; // Initial guess
    for (;;) {

        //
        // Allocate a buffer that should be big enough.
        //

        if ( socketAddressList != NULL ) {
            LocalFree( socketAddressList );
        }

        socketAddressList = (LPSOCKET_ADDRESS_LIST)LocalAlloc( 0, BytesReturned );

        if ( socketAddressList == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            DPRINT1(0,"LdapUdpPnpBind: Cannot allocate buffer for WSAIoctl SIO_ADDRESS_LIST_QUERY %ld\n",
                      NetStatus);
            goto useDefault;
        }

        //
        // Get the list of IP addresses
        //

        NetStatus = WSAIoctl( LdapWinsockPnpSocket,
                              SIO_ADDRESS_LIST_QUERY,
                              NULL, // No input buffer
                              0,    // No input buffer
                              (PVOID) socketAddressList,
                              BytesReturned,
                              &BytesReturned,
                              NULL, // No overlapped,
                              NULL );   // Not async

        if ( NetStatus != 0 ) {
            NetStatus = WSAGetLastError();
            //
            // If the buffer isn't big enough, try again.
            //
            if ( NetStatus == WSAEFAULT ) {
                continue;
            }

            DPRINT2(0,"LdapUdpPnpBind: Cannot WSAIoctl SIO_ADDRESS_LIST_QUERY %ld %ld\n",
                      NetStatus, BytesReturned);
            goto useDefault;
        }

        break;
    }

    //
    // Weed out any zero IP addresses and other invalid addresses
    //

    for ( i=0,j=0; i<socketAddressList->iAddressCount; i++ ) {
        PSOCKET_ADDRESS SocketAddress;

        //
        // Copy this address to the front of the list.
        //
        socketAddressList->Address[j] = socketAddressList->Address[i];

        //
        // If the address isn't valid,
        //  skip it.
        //
        SocketAddress = &socketAddressList->Address[j];

        if ( SocketAddress->iSockaddrLength == 0 ||
             SocketAddress->lpSockaddr == NULL ||
             SocketAddress->lpSockaddr->sa_family != AF_INET ||
             ((PSOCKADDR_IN)(SocketAddress->lpSockaddr))->sin_addr.s_addr == 0 ) {

            IF_DEBUG(UDP) {
                DPRINT1(0,"Skipping address with index %d\n", i);
            }

        } else {

            //
            // Otherwise keep it.
            //

            IF_DEBUG(UDP) {
                DPRINT1(0,"Adding address %s\n",
                         inet_ntoa(((PSOCKADDR_IN)(SocketAddress->lpSockaddr))->sin_addr));
            }

            SocketAddressSize += sizeof(SOCKET_ADDRESS) + SocketAddress->iSockaddrLength;
            j++;
        }
    }
    socketAddressList->iAddressCount = j;

    if ( j == 0 ) {
        IF_DEBUG(UDP) {
            DPRINT(0,"No valid IP address.\n");
        }
        socketAddressList->iAddressCount = 0;
    }

    //
    // Start the actual bind
    //

    RetVal = LdapStartUdpPort(socketAddressList->Address,
                              socketAddressList->iAddressCount);

    if ( socketAddressList != NULL ) {
        LocalFree( socketAddressList );
    }

    //
    // if we have not yet registered a wait thread, do it now
    //

    if ( LdapPnpEventChangeHandle == NULL ) {

        NetStatus = RtlRegisterWait(&LdapPnpEventChangeHandle,
                                    LdapWinsockPnpEvent,
                                    PnpChangeCallback,
                                    NULL,
                                    INFINITE,
                                    WT_EXECUTEONLYONCE);

        IF_DEBUG(UDP) {
            DPRINT1(0,"RtlRegisterWait returned with status %x\n",NetStatus);
        }

        if ( NetStatus != STATUS_SUCCESS ) {
            DPRINT1(0,"RtlRegisterWait failed with %x\n",NetStatus);
        }
    }

    return RetVal;

useDefault:

    SOCKADDR_IN addr;

    ZeroMemory(&addr, sizeof(addr));
    defaultAddress.iSockaddrLength = sizeof(SOCKADDR_IN);
    defaultAddress.lpSockaddr = (PSOCKADDR)&addr;
    addr.sin_addr.s_addr = INADDR_ANY;

    RetVal = LdapStartUdpPort(&defaultAddress, 1);
    if ( socketAddressList != NULL ) {
        LocalFree( socketAddressList );
    }

    return RetVal;
} //LdapDoUdpPnpBind


VOID
NTAPI
PnpChangeCallback(
    IN PVOID   Context,
    IN BOOLEAN WaitCondition
    )
{

    IF_DEBUG(UDP) {
        DPRINT2(0,"PnpChangeCallback called with Context %p Wait %x\n",
                 Context, WaitCondition);
    }

    if ( LdapPnpEventChangeHandle != NULL ) {
        RtlDeregisterWait(LdapPnpEventChangeHandle);
        LdapPnpEventChangeHandle = NULL;
    }

    if ( !LdapStarted ) {
        return;
    }

    LdapDoUdpPnpBind( );
    return;

} // PnpChangeCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\ldap\decode.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    decode.cxx

Abstract:

    This module contains the ber decoding routines for LDAP.

Author:

    Johnson Apacible    (JohnsonA)      23-Mar-1998

--*/

#include "NTDSpchx.h"
#pragma  hdrstop

#include "ldapsvr.hxx"
#include <winldap.h>
#include "ber.hxx"

#define FILENO FILENO_LDAP_DECODE


inline
PBYTE
GrabBvBuffer(
    IN PBERVAL Blob,
    IN DWORD LenRequired
    )
/*++

Routine Description:

    Try to allocate a buffer from Bv. 

Arguments:

    Bv - a berval struct containing the buffer available for partitioning.
        We double dword align this.
    LenRequired - Length to allocate.
    
Return Value:

    returns the pointer to the allocated buffer.  NULL if failure.

--*/
{
    DWORD i = GET_ALIGNED_LENGTH(LenRequired);
    PBYTE p;

    if ( i > Blob->bv_len ) {

        DWORD alloc = (i > SIZEINCREMENT) ? i : SIZEINCREMENT;
        ASSERT((alloc & 0x7) == 0);

        IF_DEBUG(DECODE) {
            DPRINT2(0,"Allocating BvBuffer with size %d [need %d]\n",alloc,i);
        }

        p = (PBYTE)THAlloc(alloc);
        if ( p == NULL ) {
            IF_DEBUG(ERROR) {
                DPRINT1(0,"GrabBv: THAlloc failed to allocate %d bytes\n",alloc);
            }
        } else {
            Blob->bv_val = (PCHAR)(p + i);
            Blob->bv_len = alloc - i;
        }
        return p;
    }

    p = (PBYTE)Blob->bv_val;
    Blob->bv_val += i;
    Blob->bv_len -= i;

    return p;
} // GrabBvBuffer


DWORD
DecodeLdapRequest(
    IN  PBERVAL    Request,
    OUT LDAPMsg*   Message,
    IN  PBERVAL    Blob,
    OUT DWORD      *pdwActualSize,
    OUT DWORD      *pErrorMessage,
    OUT DWORD      *pdwDsid
    )
/*++

Routine Description:

    Main decode dispatch routine for LDAP requests.

Arguments:

    Request - berval structure pointing to ber encoded buffer to decode.
    Message - pointer to a LDAPMsg structure to contain the decoded info.
    Blob - a berval struct containing the buffer available for partitioning.
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_INSUFFICIENT_BUFFER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    CBerDecode ldapBer;

    unsigned long savedLength = 0;
    char *savedValue = NULL;
    
    IF_DEBUG(DECODE) {
        savedLength = Request->bv_len;
        savedValue  = Request->bv_val;
    }
    
    //
    // Initialize and check length
    //

    ZeroMemory(Message, sizeof(LDAPMsg));
    
    error = ldapBer.InitMsgSequence(Request, Blob, pdwActualSize);
    if ( error != ERROR_SUCCESS ) {
        *pErrorMessage = LdapDecodeError;
        *pdwDsid = DSID(FILENO, __LINE__);
        return error;
    }

    error = ldapBer.DecodeLdapMsg(Message, pErrorMessage, pdwDsid);
    if ( error != ERROR_SUCCESS ) {
        IF_DEBUG(DECODE) {
            DPRINT(0,"DecodeLdapMsg FAILED on this LDAP request:\n");
            for (unsigned i = 0, col = 0;
                 i < savedLength;
                 i++, col = (col + 1) % 16) {
                DPRINT1(0, "%02X ", (unsigned char) savedValue[i]);
                if (col == 15) {
                    DPRINT(0, "\n");
                }
            }
            DPRINT(0,"\n");
        }
        return error;
    }

    return ERROR_SUCCESS;

} // DecodeLdapRequest



DWORD
CBerDecode::DecodeLdapMsg(
    OUT LDAPMsg* Output,
    OUT DWORD    *pErrorMessage,
    OUT DWORD    *pdwDsid
    )
/*++

Routine Description:

    Main decode dispatch routine for LDAP requests.

Arguments:

    Output - pointer to a LDAPMsg structure to contain the decoded info.
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_INSUFFICIENT_BUFFER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{
    DWORD msgId;
    DWORD tag=0, tlen;
    DWORD err;
    DWORD dwNotUsed;
    PVOID pEA;

    
    *pErrorMessage = LdapDecodeError;
    //
    // Store the original information before we modify it in the Get*
    // functions.
    //

    DWORD bufferLength = m_cbData;
    PBYTE bufferStart  = m_pbData;
    
    //
    // get the messageID
    //
    
    err = GetInteger((PLONG)&msgId);
    if ( err != ERROR_SUCCESS ) {
        *pdwDsid = DSID(FILENO, __LINE__);
        return err;
    }

    Output->messageID = msgId;

    //
    // ok, get the protocolOp
    //

    if ( (GetTag(&tag) != ERROR_SUCCESS) ||
         (GetLength(&tlen) != ERROR_SUCCESS) ) {
        *pdwDsid = DSID(FILENO, __LINE__);
        return ERROR_INVALID_PARAMETER;
    }

    IF_DEBUG(DECODE) {
        DPRINT3(0,"Decoding: msgId=%x, protocol=%x, len=%x\n",
                 msgId, tag, tlen);
    }

    if ( tag == LDAP_SEARCH_CMD ) {
    
        __try {

            //
            // decode the search request
            //
            
            Output->protocolOp.choice = searchRequest_chosen;
            err = DecodeSearchRequest(
                      &Output->protocolOp.u.searchRequest,
                      m_pBlob);
            
            //
            // [0] Controls OPTIONAL
            //
            
            GetControlsEx(&Output->controls, &Output->bit_mask, m_pBlob);

        } __except(GetExceptionData(GetExceptionInformation(),
                                    &dwNotUsed, 
                                    &pEA,
                                    pErrorMessage,
                                    pdwDsid)) {
            IF_DEBUG(DECODE) {
                DPRINT(0,"DecodeRequest exception\n");
            }
            err = ERROR_INVALID_PARAMETER;
        }
    
    } else {
    
        //
        // create a BerElement* for calls to ber_* functions
        //

        BERVAL tempBerVal;
        
        tempBerVal.bv_len = bufferLength;
        tempBerVal.bv_val = (char*) bufferStart;

        m_pBerElt = ber_init(&tempBerVal);
        if ( m_pBerElt == NULL ) {
            *pdwDsid = DSID(FILENO, __LINE__);
            return ERROR_INVALID_PARAMETER;
        }

        DWORD newMsgId;
        unsigned long result;

        result = ber_scanf(m_pBerElt, "{i", &newMsgId);
        if ( result != 0 ) {
            *pdwDsid = DSID(FILENO, __LINE__);
            return ERROR_INVALID_PARAMETER;
        }

        ASSERT(newMsgId == msgId);

        //
        // decode the protocol operation
        //
        
        __try {

            switch (tag) {
                
            case LDAP_BIND_CMD:
            {
                Output->protocolOp.choice = bindRequest_chosen;
                err = DecodeBindRequest(&Output->protocolOp.u.bindRequest);
                if ( err != ERROR_SUCCESS ) {
                    *pdwDsid = DSID(FILENO, __LINE__);
                }
                break;
            }
            
            case LDAP_UNBIND_CMD:
            {
                Output->protocolOp.choice = unbindRequest_chosen;
                err = DecodeUnbindRequest(&Output->protocolOp.u.unbindRequest);
                if ( err != ERROR_SUCCESS ) {
                    *pdwDsid = DSID(FILENO, __LINE__);
                }
                break;
            }
            
            case LDAP_MODIFY_CMD:
            {
                Output->protocolOp.choice = modifyRequest_chosen;
                err = DecodeModifyRequest(&Output->protocolOp.u.modifyRequest);
                if ( err != ERROR_SUCCESS ) {
                    *pdwDsid = DSID(FILENO, __LINE__);
                }
                break;
            }
            
            case LDAP_ADD_CMD:
            {
                Output->protocolOp.choice = addRequest_chosen;
                err = DecodeAddRequest(&Output->protocolOp.u.addRequest);
                if ( err != ERROR_SUCCESS ) {
                    *pdwDsid = DSID(FILENO, __LINE__);
                }
                break;
            }

            case LDAP_DELETE_CMD:
            {
                Output->protocolOp.choice = delRequest_chosen;
                err = DecodeDelRequest(&Output->protocolOp.u.delRequest);
                if ( err != ERROR_SUCCESS ) {
                    *pdwDsid = DSID(FILENO, __LINE__);
                }
                break;
            }
            
            case LDAP_MODRDN_CMD:
            {
                Output->protocolOp.choice = modDNRequest_chosen;
                err = DecodeModifyDnRequest(&Output->protocolOp.u.modDNRequest);
                if ( err != ERROR_SUCCESS ) {
                    *pdwDsid = DSID(FILENO, __LINE__);
                }
                break;
            }
            
            case LDAP_ABANDON_CMD:
            {
                Output->protocolOp.choice = abandonRequest_chosen;
                err = DecodeAbandonRequest(&Output->protocolOp.u.abandonRequest);
                if ( err != ERROR_SUCCESS ) {
                    *pdwDsid = DSID(FILENO, __LINE__);
                }
                break;
            }
            

            case LDAP_COMPARE_CMD:
            {
                Output->protocolOp.choice = compareRequest_chosen;
                err = DecodeCompareRequest(&Output->protocolOp.u.compareRequest);
                if ( err != ERROR_SUCCESS ) {
                    *pdwDsid = DSID(FILENO, __LINE__);
                }
                break;
            }
            
            case LDAP_EXTENDED_CMD:
            {
                Output->protocolOp.choice = extendedReq_chosen;
                err = DecodeExtendedRequest(&Output->protocolOp.u.extendedReq);
                if ( err != ERROR_SUCCESS ) {
                    *pdwDsid = DSID(FILENO, __LINE__);
                }
                break;
            }

            default:
                return ERROR_INVALID_PARAMETER;
            }

            if ( err == ERROR_SUCCESS ) {
                
                unsigned long id;
                PeekId(&id);
                if ( id == MakeBerId(BER_CLASS_CONTEXT_SPECIFIC,
                                     BER_FORM_CONSTRUCTED,
                                     0) ) {
                    DecodeControls(&Output->controls, FALSE);
                    Output->bit_mask |= controls_present;
                }

            }
            
        } __except(GetExceptionData(GetExceptionInformation(),
                                    &dwNotUsed, 
                                    &pEA,
                                    pErrorMessage,
                                    pdwDsid)) {
            IF_DEBUG(DECODE) {
                DPRINT(0,"DecodeRequest exception\n");
            }
            return ERROR_INVALID_PARAMETER;
        }

        if ( err == ERROR_SUCCESS ) {
        
            result = ber_scanf(m_pBerElt, "}");
            if ( result != 0 ) {
                *pdwDsid = DSID(FILENO, __LINE__);
                return ERROR_INVALID_PARAMETER;
            }

        }
        
        ber_free(m_pBerElt, 1);
        
    }
    
    return err;

} // DecodeLdapMsg



DWORD
CBerDecode::DecodeSearchRequest(
    OUT SearchRequest* Output,
    IN PBERVAL Blob
    )
/*++

Routine Description:

    Main decode routine for LDAP search requests.

Arguments:

    Output - pointer to a SearchRequest structure to contain the decoded info.
    Blob - a berval struct containing the buffer available for partitioning.
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_INSUFFICIENT_BUFFER

--*/

{
    BERVAL baseDN;
    LONG tmpInt;

    //
    // Get the base DN, the scope, derefAlias, size, time limit, types only
    //

    GetOctetStringEx(&baseDN);
    ConvertBVToDN(&baseDN, &Output->baseObject);

    GetIntegerEx(&tmpInt,BER_ENUMERATED);
    Output->scope = (_enum2)tmpInt;

    GetIntegerEx(&tmpInt,BER_ENUMERATED);
    Output->derefAliases = (_enum3)tmpInt;

    GetIntegerEx(&tmpInt);
    Output->sizeLimit = (DWORD)tmpInt;

    GetIntegerEx(&tmpInt);
    Output->timeLimit = (DWORD)tmpInt;

    GetBooleanEx(&tmpInt);
    Output->typesOnly = (ossBoolean)(tmpInt != 0);

    IF_DEBUG(DECODE) {
        DPRINT5(0,"Search params: scope %x deref %x size %d time %d types %x\n",
                 Output->scope, Output->derefAliases, Output->sizeLimit,
                 Output->timeLimit, Output->typesOnly);
    }

    //
    // Filter
    //

    GetFilterEx(&Output->filter,Blob);

    //
    // Attribute Description List
    //

    GetAttributeDescriptionListEx(&Output->attributes, Blob);
    
    return ERROR_SUCCESS;

} // DecodeSearchRequest



DWORD
CBerDecode::DecodeBindRequest(
    OUT BindRequest *Output
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP BindRequest, and copy the information
    into the Output structure.

Arguments:

    Output - pointer to an BindRequest structure to receive the decoded
             information.
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = DecodeBeginSequence(FALSE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    unsigned int integerVersion;
    error = DecodeInteger(&integerVersion, TRUE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    Output->version = (unsigned short) integerVersion;

    error = DecodeLdapDn(&Output->name, TRUE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    error = DecodeAuthenticationChoice(&Output->authentication, TRUE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    error = DecodeEndSequence();
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    return ERROR_SUCCESS;

} // DecodeBindRequest



DWORD
CBerDecode::DecodeUnbindRequest(
    OUT UnbindRequest *Output
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP UnbindRequest, and copy the information
    into the Output structure.

Arguments:

    Output - pointer to an UnbindRequest structure to receive the decoded
             information.
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = DecodeNull(FALSE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;

} // DecodeUnbindRequest



DWORD
CBerDecode::DecodeModifyRequest(
    OUT ModifyRequest *Output
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP ModifyRequest, and copy the information
    into the Output structure.

Arguments:

    Output - pointer to an ModifyRequest structure to receive the decoded
             information.
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = DecodeBeginSequence(FALSE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    error = DecodeLdapDn(&Output->object, TRUE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    error = DecodeModificationList(&Output->modification, TRUE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    error = DecodeEndSequence();
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;

} // DecodeModifyRequest



DWORD
CBerDecode::DecodeAddRequest(
    OUT AddRequest *Output
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP AddRequest, and copy the information
    into the Output structure.

Arguments:

    Output - pointer to an AddRequest structure to receive the decoded
             information.
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = DecodeBeginSequence(FALSE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    error = DecodeLdapDn(&Output->entry, TRUE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    error = DecodeAttributeList(&Output->attributes, TRUE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    error = DecodeEndSequence();
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;

} // DecodeAddRequest



DWORD
CBerDecode::DecodeDelRequest(
    OUT DelRequest *Output
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP DelRequest, and copy the information
    into the Output structure.

Arguments:

    Output - pointer to an DelRequest structure to receive the decoded
             information.
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = DecodeLdapDn(Output, FALSE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;

} // DecodeDelRequest



DWORD
CBerDecode::DecodeModifyDnRequest(
    OUT ModifyDNRequest *Output
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP ModifyDNRequest, and copy the information
    into the Output structure.

Arguments:

    Output - pointer to an ModifyDNRequest structure to receive the decoded
             information.
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = DecodeBeginSequence(FALSE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    Output->bit_mask = 0;

    error = DecodeLdapDn(&Output->entry, TRUE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    error = DecodeRelativeLdapDn(&Output->newrdn, TRUE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    error = DecodeBoolean(&Output->deleteoldrdn, TRUE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    //
    // optional newSuperior value
    //

    unsigned long id;
    PeekId(&id);

    if ( id == MakeBerId(BER_CLASS_CONTEXT_SPECIFIC,
                         BER_FORM_PRIMITIVE,
                         0) ) {

        error = DecodeLdapDn(&Output->newSuperior, FALSE);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }
    
        Output->bit_mask |= newSuperior_present;
    }

    error = DecodeEndSequence();
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;

} // DecodeModifyDNRequest



DWORD
CBerDecode::DecodeAbandonRequest(
    OUT AbandonRequest *Output
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP AbandonRequest, and copy the information
    into the Output structure.

Arguments:

    Output - pointer to an AbandonRequest structure to receive the decoded
             information.
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = DecodeMessageId(Output, FALSE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    return ERROR_SUCCESS;

} // DecodeAbandonRequest



DWORD
CBerDecode::DecodeCompareRequest(
    OUT CompareRequest *Output
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP CompareRequest, and copy the information
    into the Output structure.

Arguments:

    Output - pointer to an CompareRequest structure to receive the decoded
             information.
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = DecodeBeginSequence(FALSE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    error = DecodeLdapDn(&Output->entry, TRUE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    error = DecodeAttributeValueAssertion(&Output->ava, TRUE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    error = DecodeEndSequence();
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    return ERROR_SUCCESS;

} // DecodeCompareRequest



DWORD
CBerDecode::DecodeExtendedRequest(
    OUT ExtendedRequest *Output
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP UnbindRequest, and copy the information
    into the Output structure.

Arguments:

    Output - pointer to an UnbindRequest structure to receive the decoded
             information.
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;
    DWORD tag;

    error = DecodeBeginSequence(FALSE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    error =  VerifyId(MakeBerId(BER_CLASS_CONTEXT_SPECIFIC,
                                BER_FORM_PRIMITIVE,
                                0));
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    error = DecodeLdapOid(&Output->requestName, FALSE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    //
    // optional value
    //

    PeekId(&tag);

    if ( tag == MakeBerId(BER_CLASS_CONTEXT_SPECIFIC,
                              BER_FORM_PRIMITIVE,
                              1) ) {
        
        error = DecodeOctetString(&Output->requestValue.length,
                              &Output->requestValue.value,
                              FALSE);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }
    } else {

        Output->requestValue.length = 0;
        Output->requestValue.value = NULL;
    }

    error = DecodeEndSequence();
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;

} // DecodeExtendedRequest



DWORD
CBerDecode::DecodeMessageId(
    OUT MessageID *Output,
    IN BOOL DoVerifyId
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP MessageID, and copy the information
    into the Output structure.

Arguments:

    Output - pointer to an MessageID structure to receive the decoded
             information.
    DoVerifyId - if TRUE, it will check to make sure that the identifier of
                 the input is correct.  FALSE means that the caller already
                 verified this (this would be used for implicitly tagged
                 types).
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = DecodeInteger(Output, DoVerifyId);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    return ERROR_SUCCESS;
    
} // DecodeMessageId



DWORD
CBerDecode::DecodeLdapString(
    OUT LDAPString *Output,
    IN BOOL DoVerifyId
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAPString, and copy the information
    into the Output structure.

Arguments:

    Output - pointer to an LDAPString structure to receive the decoded
             information.
    DoVerifyId - if TRUE, it will check to make sure that the identifier of
                 the input is correct.  FALSE means that the caller already
                 verified this (this would be used for implicitly tagged
                 types).
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = DecodeOctetString(&Output->length,
                              &Output->value,
                              DoVerifyId);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    return ERROR_SUCCESS;
    
} // DecodeLdapString



DWORD
CBerDecode::DecodeLdapOid(
    OUT LDAPOID *Output,
    IN BOOL DoVerifyId
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAPOID, and copy the information
    into the Output structure.

Arguments:

    Output - pointer to an LDAPOID structure to receive the decoded
             information.
    DoVerifyId - if TRUE, it will check to make sure that the identifier of
                 the input is correct.  FALSE means that the caller already
                 verified this (this would be used for implicitly tagged
                 types).
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = DecodeOctetString(&Output->length,
                              &Output->value,
                              DoVerifyId);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    return ERROR_SUCCESS;
    
} // DecodeLdapOid



DWORD
CBerDecode::DecodeLdapDn(
    OUT LDAPDN *Output,
    IN BOOL DoVerifyId
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAPDN, and copy the information
    into the Output structure.

Arguments:

    Output - pointer to an LDAPDN structure to receive the decoded
             information.
    DoVerifyId - if TRUE, it will check to make sure that the identifier of
                 the input is correct.  FALSE means that the caller already
                 verified this (this would be used for implicitly tagged
                 types).
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = DecodeLdapString(Output, DoVerifyId);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    return ERROR_SUCCESS;
    
} // DecodeLdapDn



DWORD
CBerDecode::DecodeRelativeLdapDn(
    OUT RelativeLDAPDN *Output,
    IN BOOL DoVerifyId
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding a RelativeLDAPDN, and copy the information
    into the Output structure.

Arguments:

    Output - pointer to an RelativeLDAPDN structure to receive the decoded
             information.
    DoVerifyId - if TRUE, it will check to make sure that the identifier of
                 the input is correct.  FALSE means that the caller already
                 verified this (this would be used for implicitly tagged
                 types).
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = DecodeLdapString(Output, DoVerifyId);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    return ERROR_SUCCESS;
    
} // DecodeRelativeLdapDn



DWORD
CBerDecode::DecodeAttributeDescription(
    OUT AttributeDescription *Output,
    IN BOOL DoVerifyId
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an AttributeDescription, and copy the information
    into the Output structure.

Arguments:

    Output - pointer to an AttributeDescription structure to receive the
             decoded information.
    DoVerifyId - if TRUE, it will check to make sure that the identifier of
                 the input is correct.  FALSE means that the caller already
                 verified this (this would be used for implicitly tagged
                 types).
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = DecodeLdapString(Output, DoVerifyId);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    return ERROR_SUCCESS;
    
} // DecodeAttributeDescription



DWORD
CBerDecode::DecodeAttributeValue(
    OUT AttributeValue *Output,
    IN BOOL DoVerifyId
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP AttributeValue, and copy the information
    into the Output structure.

Arguments:

    Output - pointer to an AttributeValue structure to receive the decoded
             information.
    DoVerifyId - if TRUE, it will check to make sure that the identifier of
                 the input is correct.  FALSE means that the caller already
                 verified this (this would be used for implicitly tagged
                 types).
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = DecodeOctetString(&Output->length,
                              &Output->value,
                              DoVerifyId);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    return ERROR_SUCCESS;
    
} // DecodeAttributeValue



DWORD
CBerDecode::DecodeAttributeValueAssertion(
    OUT AttributeValueAssertion *Output,
    IN BOOL DoVerifyId
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP AttributeValueAssertion, and copy the
    information into the Output structure.

Arguments:

    Output - pointer to an AttributeValueAssertion structure to receive the
             decoded information.
    DoVerifyId - if TRUE, it will check to make sure that the identifier of
                 the input is correct.  FALSE means that the caller already
                 verified this (this would be used for implicitly tagged
                 types).
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = DecodeBeginSequence(DoVerifyId);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    error = DecodeAttributeDescription(&Output->attributeDesc, TRUE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    error = DecodeAssertionValue(&Output->assertionValue, TRUE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    error = DecodeEndSequence();
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    return ERROR_SUCCESS;
    
} // DecodeAttributeValueAssertion



DWORD
CBerDecode::DecodeAssertionValue(
    OUT AssertionValue *Output,
    IN BOOL DoVerifyId
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP AssertionValue, and copy the information
    into the Output structure.

Arguments:

    Output - pointer to an AssertionValue structure to receive the decoded
             information.
    DoVerifyId - if TRUE, it will check to make sure that the identifier of
                 the input is correct.  FALSE means that the caller already
                 verified this (this would be used for implicitly tagged
                 types).
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = DecodeOctetString(&Output->length,
                              &Output->value,
                              DoVerifyId);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    return ERROR_SUCCESS;
    
} // DecodeAssertionValue



DWORD
CBerDecode::DecodeAttributeVals(
    OUT AttributeVals *Output,
    IN BOOL DoVerifyId
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP AttributeVals, and copy the information
    into the Output structure.

Arguments:

    Output - pointer to an AttributeVals structure to receive the decoded
             information.
    DoVerifyId - if TRUE, it will check to make sure that the identifier of
                 the input is correct.  FALSE means that the caller already
                 verified this (this would be used for implicitly tagged
                 types).
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    if ( DoVerifyId ) {
        error = VerifyId(BER_SET);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }
    }

    unsigned long len;
    char *pOpaque;
    
    for ( BOOL elementsRemaining = MoveToFirstElement(&len, &pOpaque);
          elementsRemaining;
          elementsRemaining = MoveToNextElement(&len, pOpaque) ) {
        
        *Output = (AttributeVals)GrabBvBuffer(m_pBlob, sizeof(AttributeVals_));
        if ( *Output == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        error = DecodeAttributeValue(&((*Output)->value), TRUE);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }

        Output = &((*Output)->next);
        
    }

    *Output = NULL;

    return ERROR_SUCCESS;
    
} // DecodeAttributeVals



DWORD
CBerDecode::DecodeControls(
    OUT Controls *Output,
    IN BOOL DoVerifyId
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP Controls, and copy the information
    into the Output structure.

Arguments:

    Output - pointer to an Controls structure to receive the decoded
             information.
    DoVerifyId - if TRUE, it will check to make sure that the identifier of
                 the input is correct.  FALSE means that the caller already
                 verified this (this would be used for implicitly tagged
                 types).
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    if ( DoVerifyId ) {
        error = VerifyId(BER_SEQUENCE);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }
    }
    
    unsigned long len;
    char *pOpaque;
    
    for ( BOOL elementsRemaining = MoveToFirstElement(&len, &pOpaque);
          elementsRemaining;
          elementsRemaining = MoveToNextElement(&len, pOpaque) ) {
        
        *Output = (Controls)GrabBvBuffer(m_pBlob, sizeof(Controls_));
        if ( *Output == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        error = DecodeControl(&((*Output)->value), TRUE);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }

        Output = &((*Output)->next);
        
    }

    *Output = NULL;

    return ERROR_SUCCESS;
    
} // DecodeControls



DWORD
CBerDecode::DecodeControl(
    OUT Control *Output,
    IN BOOL DoVerifyId
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP Control, and copy the information
    into the Output structure.

Arguments:

    Output - pointer to an Control structure to receive the decoded
             information.
    DoVerifyId - if TRUE, it will check to make sure that the identifier of
                 the input is correct.  FALSE means that the caller already
                 verified this (this would be used for implicitly tagged
                 types).
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;
    DWORD id;

    error = DecodeBeginSequence(DoVerifyId);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    error = DecodeLdapOid(&Output->controlType, TRUE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    //
    // see if anything else was sent
    //

    PeekId(&id);
    
    //
    // default FALSE
    //

    Output->bit_mask = 0;
    Output->criticality = FALSE;

    if ( id == BER_BOOLEAN ) {

        error = DecodeBoolean(&Output->criticality, FALSE);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }

        Output->bit_mask |= criticality_present;

        //
        // see if client sent a control value
        //

        PeekId(&id);
    }

    //
    // optional control value
    //

    if ( id == BER_OCTETSTRING ) {
        error = DecodeOctetString(&Output->controlValue.length,
                              &Output->controlValue.value,
                              TRUE);

        if ( error != ERROR_SUCCESS ) {
            return error;
        }
    } else {

        Output->controlValue.length = 0;
        Output->controlValue.value = NULL;
    }

    error = DecodeEndSequence();
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    return ERROR_SUCCESS;
    
} // DecodeControl



DWORD
CBerDecode::DecodeAuthenticationChoice(
    OUT AuthenticationChoice *Output,
    IN BOOL DoVerifyId
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP AuthenticationChoice, and copy the
    information into the Output structure.

Arguments:

    Output - pointer to an AuthenticationChoice structure to receive the
             decoded information.
    DoVerifyId - if TRUE, it will check to make sure that the identifier of
                 the input is correct.  FALSE means that the caller already
                 verified this (this would be used for implicitly tagged
                 types).
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;
    unsigned long id;
    
    PeekId(&id);

    switch ( id ) {

    case MakeBerId(BER_CLASS_CONTEXT_SPECIFIC,
                   BER_FORM_PRIMITIVE,
                   0):
    {
        Output->choice = simple_chosen;
        error = DecodeOctetString(&Output->u.simple.length,
                                  &Output->u.simple.value,
                                  FALSE);
        break;
    }
        
    case MakeBerId(BER_CLASS_CONTEXT_SPECIFIC,
                   BER_FORM_CONSTRUCTED,
                   3):
    {
        Output->choice = sasl_chosen;
        error = DecodeSaslCredentials(&Output->u.sasl, FALSE);
        break;
    }

    case MakeBerId(BER_CLASS_CONTEXT_SPECIFIC,
                   BER_FORM_PRIMITIVE,
                   9):
    {
        Output->choice = sicilyNegotiate_chosen;
        error = DecodeOctetString(&Output->u.sicilyNegotiate.length,
                                  &Output->u.sicilyNegotiate.value,
                                  FALSE);
        break;
    }
        
    case MakeBerId(BER_CLASS_CONTEXT_SPECIFIC,
                   BER_FORM_PRIMITIVE,
                   10):
    {
        Output->choice = sicilyInitial_chosen;
        error = DecodeOctetString(&Output->u.sicilyInitial.length,
                                  &Output->u.sicilyInitial.value,
                                  FALSE);
        break;
    }
        
    case MakeBerId(BER_CLASS_CONTEXT_SPECIFIC,
                   BER_FORM_PRIMITIVE,
                   11):
    {
        Output->choice = sicilySubsequent_chosen;
        error = DecodeOctetString(&Output->u.sicilySubsequent.length,
                                  &Output->u.sicilySubsequent.value, FALSE);
        break;
    }
        
    default:
    {
        return ERROR_INVALID_PARAMETER;
    }

    }

    /* check the return value of the function that was called */
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;
    
} // DecodeAuthenticationChoice



DWORD
CBerDecode::DecodeSaslCredentials(
    OUT SaslCredentials *Output,
    IN BOOL DoVerifyId
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP SaslCredentials, and copy the
    information into the Output structure.

Arguments:

    Output - pointer to an SaslCredentials structure to receive the
             decoded information.
    DoVerifyId - if TRUE, it will check to make sure that the identifier of
                 the input is correct.  FALSE means that the caller already
                 verified this (this would be used for implicitly tagged
                 types).
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;
    DWORD tag;

    error = DecodeBeginSequence(DoVerifyId);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    error = DecodeLdapString(&Output->mechanism, TRUE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    //
    // see if credentials were sent
    //

    PeekId(&tag);

    if ( tag == BER_OCTETSTRING ) {
        error = DecodeOctetString(&Output->credentials.length,
                                  &Output->credentials.value,
                                  TRUE);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }
    } else {
        Output->credentials.length = 0;
        Output->credentials.value = NULL;
    }

    error = DecodeEndSequence();
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;
    
} // DecodeSaslCredentials



DWORD
CBerDecode::DecodeAttributeListElement(
    OUT AttributeListElement *Output,
    IN BOOL DoVerifyId
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP AttributeListElement, and copy the
    information into the Output structure.

Arguments:

    Output - pointer to an AttributeListElement structure to receive the
             decoded information.
    DoVerifyId - if TRUE, it will check to make sure that the identifier of
                 the input is correct.  FALSE means that the caller already
                 verified this (this would be used for implicitly tagged
                 types).
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = DecodeBeginSequence(DoVerifyId);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    error = DecodeAttributeDescription(&Output->type, TRUE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    error = DecodeAttributeVals(&Output->vals, TRUE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    error = DecodeEndSequence();
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    return ERROR_SUCCESS;
    
} // DecodeAttributeListElement



DWORD
CBerDecode::DecodeModificationList(
    OUT ModificationList *Output,
    IN BOOL DoVerifyId
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP ModificationList, and copy the
    information into the Output structure.

Arguments:

    Output - pointer to an ModificationList structure to receive the
             decoded information.
    DoVerifyId - if TRUE, it will check to make sure that the identifier of
                 the input is correct.  FALSE means that the caller already
                 verified this (this would be used for implicitly tagged
                 types).
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    if ( DoVerifyId ) {
        error = VerifyId(BER_SEQUENCE);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }
    }

    unsigned long len;
    char *pOpaque;
    
    for ( BOOL elementsRemaining = MoveToFirstElement(&len, &pOpaque);
          elementsRemaining;
          elementsRemaining = MoveToNextElement(&len, pOpaque) ) {
        
        *Output = (ModificationList) GrabBvBuffer(m_pBlob,
                                                  sizeof(ModificationList_));
        if ( *Output == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        error = DecodeBeginSequence(TRUE);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }

        unsigned int operation;
        error = DecodeInteger(&operation, FALSE);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }
        (*Output)->value.operation = (_enum1_2) operation;

        error = DecodeAttributeTypeAndValues(&((*Output)->value.modification),
                                             TRUE);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }

        error = DecodeEndSequence();
        if ( error != ERROR_SUCCESS ) {
            return error;
        }
        
        Output = &((*Output)->next);
        
    }

    *Output = NULL;
    
    return ERROR_SUCCESS;
    
} // DecodeModificationList



DWORD
CBerDecode::DecodeAttributeTypeAndValues(
    OUT AttributeTypeAndValues *Output,
    IN BOOL DoVerifyId
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP AttributeTypeAndValues, and copy the
    information into the Output structure.

Arguments:

    Output - pointer to an AttributeTypeAndValues structure to receive the
             decoded information.
    DoVerifyId - if TRUE, it will check to make sure that the identifier of
                 the input is correct.  FALSE means that the caller already
                 verified this (this would be used for implicitly tagged
                 types).
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = DecodeBeginSequence(DoVerifyId);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    error = DecodeAttributeDescription(&Output->type, TRUE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    typedef AttributeTypeAndValues::_setof1 SetOf1;
    
    SetOf1 **current = &Output->vals;

    unsigned long len;
    char *pOpaque;
    
    for ( BOOL elementsRemaining = MoveToFirstElement(&len, &pOpaque);
          elementsRemaining;
          elementsRemaining = MoveToNextElement(&len, pOpaque) ) {

        *current = (SetOf1*)
                       GrabBvBuffer(m_pBlob, sizeof(SetOf1));
        if ( *current == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        error = DecodeAttributeValue(&((*current)->value), TRUE);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }

        current = &(*current)->next;

    }

    *current = NULL;

    error = DecodeEndSequence();
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;
    
} // DecodeAttributeTypeAndValues



DWORD
CBerDecode::DecodeAttributeList(
    OUT AttributeList *Output,
    IN BOOL DoVerifyId
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP AttributeList, and copy the
    information into the Output structure.

Arguments:

    Output - pointer to an AttributeList structure to receive the
             decoded information.
    DoVerifyId - if TRUE, it will check to make sure that the identifier of
                 the input is correct.  FALSE means that the caller already
                 verified this (this would be used for implicitly tagged
                 types).
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    if ( DoVerifyId ) {
        error = VerifyId(BER_SEQUENCE);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }
    }

    unsigned long len;
    char *pOpaque;
    
    for ( BOOL elementsRemaining = MoveToFirstElement(&len, &pOpaque);
          elementsRemaining;
          elementsRemaining = MoveToNextElement(&len, pOpaque) ) {
        
        *Output = (AttributeList) GrabBvBuffer(m_pBlob,
                                               sizeof(AttributeList_));
        if ( *Output == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        error = DecodeAttributeListElement(&((*Output)->value), TRUE);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }

        Output = &((*Output)->next);
        
    }

    *Output = NULL;
    
    return ERROR_SUCCESS;
    
} // DecodeAttributeList



DWORD
CBerDecode::InitMsgSequence(
    IN PBERVAL Req,
    IN PBERVAL Blob,
    OUT DWORD *pdwActualSize
    )
/*++

Routine Description:

    Sets up the CBerDecode class.

Arguments:
    
    Req - a berval struct pointing to the data to be decoded.
    Blob - Used for allocation
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD tag=0, tlen;
    PBYTE newData;
    DWORD err;

    m_iCurrPos = 0;
    m_pbData = (PBYTE)Req->bv_val;
    m_cbData = Req->bv_len;
    m_RecursionDepth = 0;

    err = GetTag( &tag );
    if ( err != ERROR_SUCCESS ) {
        IF_DEBUG(DECODE) {
            DPRINT1(0,"InitMsg: error %d in GetTag\n",err);
        }
        return err;
    }

    if ( tag != BER_SEQUENCE ) {
        IF_DEBUG(DECODE) {
            DPRINT1(0,"Invalid sequence tag %x\n",tag);
        }
        return ERROR_INVALID_PARAMETER;
    }
    
    err = GetLength(&tlen);
    if ( err != ERROR_SUCCESS ) {
        IF_DEBUG(DECODE) {
            DPRINT1(0,"InitMsg: error %d in GetLength\n",err);
        }
        return err;
    }
     
    *pdwActualSize = m_cbData = tlen + m_iCurrPos;

    if ( m_cbData > Req->bv_len ) {
        IF_DEBUG(DECODE) {
            DPRINT2(0,"Incomplete buffer: need %d have %d\n",
                     m_cbData, Req->bv_len);
        }
        return ERROR_INSUFFICIENT_BUFFER;
    }

    Req->bv_len -= m_cbData;
    Req->bv_val += m_cbData;
    
    //
    // Copy the input buffer since this gets overwritten during ShrinkReceive
    //

    newData = (PBYTE)GrabBvBuffer(Blob,m_cbData);
    if ( newData == NULL ) {
        IF_DEBUG(ERROR) {
            DPRINT1(0,"Cannot allocate request buffer[size %d]\n",
                     m_cbData);
        }
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CopyMemory(newData, m_pbData, m_cbData);
    m_pbData = newData;

    //
    // Keep this blob for further allocation.
    //
    m_pBlob = Blob;
    
    return ERROR_SUCCESS;

} // InitMsgSequence



VOID
CBerDecode::GetFilterEx(
    IN OUT Filter* pFilter,
    IN PBERVAL Blob
    )
/*++

Routine Description:

    Main decode routine for LDAP Filters

Arguments:

    pFilter - pointer to a Filter structure to contain the decoded info.
    Blob - a berval struct containing the buffer available for partitioning.
    
Return Value:

    None. Generates an exception on error.

--*/

{
    BERVAL attr;
    DWORD tag=0;

    m_RecursionDepth++;
    if (m_RecursionDepth > BER_MAX_RECURSION) {
        DPRINT(0, "GetFilter: exceeded recursion count\n");
        goto error_exit;
    }

    if ( PeekTag(&tag) != ERROR_SUCCESS ) {
        IF_DEBUG(DECODE) {
            DPRINT(0,"GetFilter: PeekTag failed\n");
        }
        goto error_exit;
    }

    IF_DEBUG(DECODE) {
        DPRINT1(0,"GetFilter: Filter tag %x\n",tag);
    }

    ZeroMemory(pFilter, sizeof(Filter));

    switch (tag) {
    case LDAP_FILTER_AND:
        pFilter->choice = and_chosen;
        GetSetOfFilterEx((PCHAR*)&pFilter->u.and,Blob,LDAP_FILTER_AND);
        break;

    case LDAP_FILTER_OR:
        pFilter->choice = or_chosen;
        GetSetOfFilterEx((PCHAR*)&pFilter->u.or,Blob,LDAP_FILTER_OR);
        break;

    case LDAP_FILTER_NOT: {
        Filter *notFilter;
        DWORD tlen;

        pFilter->choice = not_chosen;
        notFilter = (Filter*)GrabBvBuffer(Blob,sizeof(Filter));
        if ( notFilter == NULL ) {
            IF_DEBUG(ERROR) {
                DPRINT(0,"Cannot allocate setFilter for NOT\n");
            }
            goto error_exit;
        }
        pFilter->u.not = notFilter;

        //
        // skip NOT tag and length
        //

        if ( (GetTag( &tag ) != ERROR_SUCCESS) ||
             (GetLength(&tlen) != ERROR_SUCCESS) ){
            goto error_exit;
        }

        GetFilterEx(notFilter,Blob);
        break;
    }

    case LDAP_FILTER_EQUALITY:
        pFilter->choice = equalityMatch_chosen;
        GetAttributeValueAssertionEx(&pFilter->u.equalityMatch, LDAP_FILTER_EQUALITY);
        break;

    case LDAP_FILTER_SUBSTRINGS:
        pFilter->choice = substrings_chosen;
        GetSubstringFilterEx(&pFilter->u.substrings,Blob,LDAP_FILTER_SUBSTRINGS);
        break;

    case LDAP_FILTER_GE:
        pFilter->choice = greaterOrEqual_chosen;
        GetAttributeValueAssertionEx(&pFilter->u.greaterOrEqual, LDAP_FILTER_GE);
        break;

    case LDAP_FILTER_LE:
        pFilter->choice = lessOrEqual_chosen;
        GetAttributeValueAssertionEx(&pFilter->u.lessOrEqual, LDAP_FILTER_LE);
        break;

    case LDAP_FILTER_PRESENT:
        pFilter->choice = present_chosen;
        GetOctetStringEx(&attr,LDAP_FILTER_PRESENT);
        ConvertBVToDN(&attr, &pFilter->u.present);
        break;

    case LDAP_FILTER_APPROX:
        pFilter->choice = approxMatch_chosen;
        GetAttributeValueAssertionEx(&pFilter->u.approxMatch, LDAP_FILTER_APPROX);
        break;

    case LDAP_FILTER_EXTENSIBLE:
        pFilter->choice = extensibleMatch_chosen;
        GetMatchingRuleAssertionEx(&pFilter->u.extensibleMatch,LDAP_FILTER_EXTENSIBLE);
        break;

    default:
        IF_DEBUG(DECODE) {
            DPRINT1(0,"GetFilter: Invalid filter tag: %d\n", tag);
        }
        goto error_exit;
        break;
    }

    m_RecursionDepth--;
    return;

error_exit:

    RaiseDsaExcept(DSA_BAD_ARG_EXCEPTION,
                   LdapFilterDecodeErr,
                   0,
                   DSID(FILENO, __LINE__),
                   DS_EVENT_SEV_MINIMAL);
    return;

} // GetFilter


DWORD
CBerDecode::GetTLV(
    OUT PDWORD Tag,
    OUT PDWORD TagLen,
    OUT PBYTE* Value
    )
/*++

Routine Description:

    Extracts the entire element consisting of tag, length, and value.
    
Arguments:

    Tag - pointer to a DWORD to receive the extracted tag.
    TagLen - pointer to a DWORD to receive the extracted length.
    Value - pointer to a PBYTE to receive the address of the value

Return Value:

    ERROR_INVALID_PARAMETER
    ERROR_INSUFFICIENT_BUFFER
    ERROR_SUCCESS

--*/

{
    DWORD  tmpPos;

    if ( (GetTag( Tag ) != ERROR_SUCCESS) ||
         (GetLength(TagLen) != ERROR_SUCCESS) ){
        return ERROR_INVALID_PARAMETER;
    }

    //
    // see if we are big enough
    //

    *Value = &m_pbData[m_iCurrPos];
    tmpPos = m_iCurrPos;
    m_iCurrPos += *TagLen;

    if ( m_iCurrPos > m_cbData || m_iCurrPos < tmpPos) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    if ( *TagLen == 0 ) {
        *Value = NULL;
    }

    return ERROR_SUCCESS;

} // GetTLV



VOID
CBerDecode::GetOctetStringEx( 
    IN OUT PBERVAL BerStr,
    IN DWORD TagRequired
    )
/*++

Routine Description:

    Extracts the string from the ber encoded buffer.
    
Arguments:

    BerStr - points to the BERVAL that will contain the value of the string encoding
    TagRequired - Tag this element is expected to have

Return Value:

    None. Exception on error.

--*/

{
    DWORD tag, tlen;
    PBYTE value;
    DWORD err;

    err = GetTLV(&tag, &tlen, &value);

    if ( (err != ERROR_SUCCESS) || (tag != TagRequired) ) {
        RaiseDsaExcept(DSA_BAD_ARG_EXCEPTION,
               LdapDecodeError,
               0,
               DSID(FILENO, __LINE__),
               DS_EVENT_SEV_MINIMAL);
    }

    BerStr->bv_len = tlen;
    BerStr->bv_val = (PCHAR)value;
    return;

} // CBerDecode::GetOctetString( )


VOID
CBerDecode::GetIntegerEx( 
    OUT PLONG IntValue,
    IN DWORD TagRequired
    )
/*++

Routine Description:

    A wrapper for GetInteger. This one generates an exception.
    
Arguments:

    IntValue - points to the LONG that will contain the value of the integer encoding
    TagRequired - Tag this element is expected to have

Return Value:

    None. Exception on error.

--*/

{
    if ( GetInteger(IntValue, TagRequired) != ERROR_SUCCESS ) {
        RaiseDsaExcept(DSA_BAD_ARG_EXCEPTION,
               LdapDecodeError,
               0,
               DSID(FILENO, __LINE__),
               DS_EVENT_SEV_MINIMAL);
    }

    return;

} // CBerDecode::GetIntegerEx( )

VOID
CBerDecode::GetBooleanEx( 
    OUT PLONG BoolValue,
    IN DWORD TagRequired
    )
/*++

Routine Description:

    Returns the boolean value of the BER encoding
    
Arguments:

    BoolValue - points to the LONG that will contain the value of the boolean encoding
    TagRequired - Tag this element is expected to have
    
Return Value:

    None. Exception on error.

--*/

{
    DWORD tag, tlen;
    PBYTE value;
    LONG intValue;
    DWORD err;

    err = GetTLV(&tag, &tlen, &value);
    if ( (err != ERROR_SUCCESS) || (tag != TagRequired) || (0 == tlen) ) {
        IF_DEBUG(DECODE) {
            DPRINT2(0,"GetBooleanEx: Invalid Tag[%x]. expected[%x]\n",
                     tag, TagRequired);
        }
        RaiseDsaExcept(DSA_BAD_ARG_EXCEPTION,
               LdapDecodeError,
               0,
               DSID(FILENO, __LINE__),
               DS_EVENT_SEV_MINIMAL);
    }

    GetInt((PBYTE)value, tlen, &intValue);
    *BoolValue = intValue;
    return;

} // CBerDecode::GetIntegerEx( )


DWORD
CBerDecode::GetInteger( 
    OUT PLONG IntValue,
    IN DWORD TagRequired
    )
/*++

Routine Description:

    Returns the integer value of the BER encoding
    
Arguments:

    IntValue - points to the LONG that will contain the value of the integer encoding
    TagRequired - Tag this element is expected to have
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER

--*/

{
    DWORD tag, tlen;
    PBYTE value;
    DWORD err;

    err = GetTLV(&tag, &tlen, &value);
    if ( (err != ERROR_SUCCESS) || (tag != TagRequired) || (0 == tlen) ) {
        return(ERROR_INVALID_PARAMETER);
    }

    GetInt((PBYTE)value, tlen, IntValue);
    return ERROR_SUCCESS;

} // CBerDecode::GetInteger



VOID
CBerDecode::GetInt(
    IN PBYTE pbData, 
    IN ULONG cbValue, 
    IN PLONG plValue
    )
/*++

Routine Description:

    Converts a ber encoded int into a LONG.
    *** Code stolen from ldap\client\ldapber.cxx ***
    
Arguments:

    pbData - points to the ber encoded int
    cbValue - length of pbData
    plValue - will contain the decoded length
    
Return Value:

    None.

--*/
{
    ULONG   ulVal=0, ulTmp=0;
    ULONG   cbDiff;
    BOOL    fSign = FALSE;

    // We assume the tag & length have already been taken off and we're
    // at the value part.

    if (cbValue > sizeof(LONG)) {

        *plValue = 0x7FFFFFFF;
        return;
    }

    cbDiff = sizeof(LONG) - cbValue;

    // See if we need to sign extend;

    if ((cbDiff > 0) && (*pbData & 0x80)) {

        fSign = TRUE;
    }

    while (cbValue > 0)
    {
        ulVal <<= 8;
        ulVal |= (ULONG)*pbData++;
        cbValue--;
    }

    // Sign extend if necessary.
    if (fSign) {

        *plValue = 0x80000000;
        *plValue >>= cbDiff * 8;
        *plValue |= ulVal;

    } else {

        *plValue = (LONG) ulVal;
    }

} // CBerDecode::GetInt



VOID
CBerDecode::GetCbLength(
    PDWORD pcbLength
    )
/*++

Routine Description:
        Gets the # of bytes required for the length field in the current
        position in the BER buffer.

        *** Code stolen from ldap\client\ldapber.cxx ***
    
Arguments:

    pcbLength - Points to the DWORD that will contain the Length of the length.
    
Return Value:

    None.

--*/

{
    // Short or long version of the length ?
    if (m_pbData[m_iCurrPos] & 0x80)
    {
        *pcbLength = 1;
        *pcbLength += m_pbData[m_iCurrPos] & 0x7f;
    }
    else
    {
        // Short version of the length.
        *pcbLength = 1;
    }
}



DWORD
CBerDecode::GetLength(
    IN PDWORD pcb
    )
/*++

Routine Description:
    Gets the length from the current position in the BER buffer.  Only
    definite lengths are supported.

    *** Code stolen from ldap\client\ldapber.cxx ***
    
Arguments:

    pcb - Points to the DWORD that will contain the Length of the element
    
Return Value:

    NOERROR
    E_INVALIDARG
    LDAP_NO_SUCH_ATTRIBUTE

--*/

{
    ULONG   cbLength;
    ULONG   i, cb;

    if (m_cbData <= m_iCurrPos) {
        IF_DEBUG(DECODE) {
            DPRINT2(0,"GetLength ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos);
        }
        return ERROR_INSUFFICIENT_BUFFER;
    }

    GetCbLength(&cbLength);
    // Short or long version of the length ?
    if (cbLength == 1)
    {
        cb = m_pbData[m_iCurrPos++] & 0x7f;
    }
    else if (cbLength <= 5)
    {
        // Account for the overhead byte.cbLength field.
        cbLength--;
        m_iCurrPos++;

        if ( (m_iCurrPos + cbLength) > m_cbData  ) {
            IF_DEBUG(DECODE) {
                DPRINT2(0,"Buffer Too Short. Expected %d Got %d.\n",
                            m_iCurrPos + cbLength, m_cbData);
            }
            return ERROR_INSUFFICIENT_BUFFER;
        }

        cb = m_pbData[m_iCurrPos++];
        for (i=1; i < cbLength; i++)
        {
            cb <<= 8;
            cb |= m_pbData[m_iCurrPos++] & 0xffffffff;
        }
    }
    else
    {
        // We don't support lengths 2^32.
        ASSERT(cbLength <= 5);
        return E_INVALIDARG;
    }

    *pcb = cb;

    return NOERROR;
} // CBerDecode::GetLength



VOID
CBerDecode::GetAttributeDescriptionListEx(
    IN OUT AttributeDescriptionList *AttList,
    IN PBERVAL Blob
    )
/*++

Routine Description:

    Main decode routine for Attribute Description List

Arguments:

    AttList - pointer to contain the allocated AttributeDescription List structure s
        to contain the decoded info.
    Blob - a berval struct containing the buffer available for partitioning.
    
Return Value:

    None. Generates an exception on error.

--*/
{
    DWORD tag, tlen;
    AttributeDescriptionList alist;
    DWORD endPos;
    PCHAR* previousPtr = (PCHAR*)AttList;

    //
    // This is a sequence of octet strings
    //

    *AttList = NULL;
    if ( (GetTag( &tag ) != ERROR_SUCCESS) ||
         (GetLength(&tlen) != ERROR_SUCCESS) ){
        goto error_exit;
    }

    if ( tag != BER_SEQUENCE ) {
        IF_DEBUG(DECODE) {
            DPRINT1(0,"GetAttrDesc: Wrong tag for sequence %x\n",tag);
        }
        goto error_exit;
    }

    if ( tlen == 0 ) {
        return;
    }

    endPos = GetCurrentPos( ) + tlen;

    //
    // Count the number of attributes
    //

    do {

        PBYTE value;
        DWORD err;

        err = GetTLV(&tag, &tlen, &value);
        if ( (err != ERROR_SUCCESS) || (tag != BER_OCTETSTRING) ) {
            goto error_exit;
        }

        alist = (AttributeDescriptionList)
                    GrabBvBuffer(Blob,sizeof(AttributeDescriptionList_));
         
        if ( alist == NULL ) {
            IF_DEBUG(DECODE) {
                DPRINT(0,"Cannot allocate description buffer\n");
            }
            goto error_exit;
        }
        
        alist->value.length = tlen;
        alist->value.value = value;

        *previousPtr = (PCHAR)alist;
        previousPtr = (PCHAR*)&alist->next;

    } while ( endPos > GetCurrentPos() );

    *previousPtr = NULL;

    return;

error_exit:

   RaiseDsaExcept(DSA_BAD_ARG_EXCEPTION,
                 LdapBadAttrDescList,
                 0,
                 DSID(FILENO, __LINE__),
                 DS_EVENT_SEV_MINIMAL);
    return;

} // CBerDecode::GetAttributeDescriptionListEx



VOID
CBerDecode::GetAttributeValueAssertionEx(
    IN OUT AttributeValueAssertion* ValAssert,
    IN DWORD RequiredTag
    )
/*++

Routine Description:

    Main decode routine for LDAP AttributeValueAssertion

Arguments:

    ValAssert - pointer to a AttributeValueAssertion  structure 
        to contain the decoded info.
    RequiredTag - the Tag required for the decoding.
    
Return Value:

    None. Generates an exception on error.

--*/

{
    DWORD tag, tlen;
    DWORD err;
    PBYTE value;

    //
    // This is a sequence of octet strings
    //

    if ( (GetTag( &tag ) != ERROR_SUCCESS) ||
         (GetLength(&tlen) != ERROR_SUCCESS) ){
        goto error_exit;
    }

    if ( tag != RequiredTag ) {
        IF_DEBUG(DECODE) {
            DPRINT2(0,"GetAttrDesc: Wrong tag for sequence [%x] should be [%x]\n",
                     tag, RequiredTag);
        }
        goto error_exit;
    }

    if ( tlen == 0 ) {
        IF_DEBUG(ERROR) {
            DPRINT(0,"Got empty assertion value.\n");
        }
        goto error_exit;
    }

    //
    // get the attribute name
    //

    err = GetTLV(&tag, &tlen, &value);
    if ( (err != ERROR_SUCCESS) || (tag != BER_OCTETSTRING) ) {
        goto error_exit;
    }

    ValAssert->attributeDesc.length = tlen;
    ValAssert->attributeDesc.value = value;

    //
    // Get the attribute value
    //

    err = GetTLV(&tag, &tlen, &value);
    if ( (err != ERROR_SUCCESS) || (tag != BER_OCTETSTRING) ) {
        goto error_exit;
    }

    ValAssert->assertionValue.length = tlen;
    ValAssert->assertionValue.value = value;

    return;

error_exit:

   RaiseDsaExcept(DSA_BAD_ARG_EXCEPTION,
                 LdapFilterDecodeErr,
                 0,
                 DSID(FILENO, __LINE__),
                 DS_EVENT_SEV_MINIMAL);
    return;

} // CBerDecode::GetAttributeValueAssertionEx



VOID
CBerDecode::GetSetOfFilterEx(
    OUT PCHAR* pSetOfFilter,
    IN PBERVAL Blob,
    IN DWORD RequiredTag
    )
/*++

Routine Description:

    Main decode routine for LDAP SET of Filter

Arguments:

    pSetOfFilter - pointer to contain the allocated set of filter structure 
        to contain the decoded info.
    Blob - a berval struct containing the buffer available for partitioning.
    RequiredTag - the Tag required for the decoding.
    
Return Value:

    None. Generates an exception on error.

--*/

{
    DWORD tag=0, tlen;
    _setof3 setofFilter;
    DWORD endPos;
    PCHAR* previousPtr = pSetOfFilter;

    //
    // This is a sequence of octet strings
    //

    ASSERT(sizeof(_setof3_) == sizeof(_setof4_));

    if ( (GetTag( &tag ) != ERROR_SUCCESS) ||
         (GetLength(&tlen) != ERROR_SUCCESS) ){
        goto error_exit;
    }

    if ( tag != RequiredTag ) {

        goto error_exit;
    }

    //
    // set the ending position. We stop when we hit this
    //

    endPos = GetCurrentPos() + tlen;

    while ( endPos > GetCurrentPos() ) {

        setofFilter = (_setof3)GrabBvBuffer(Blob,sizeof(_setof3_));
        if ( setofFilter == NULL ) {
            IF_DEBUG(ERROR) {
                DPRINT(0,"Cannot allocate setofFilter\n");
            }
            goto error_exit;
        }

        GetFilterEx(&setofFilter->value,Blob);
        *previousPtr = (PCHAR)setofFilter;
        previousPtr = (PCHAR*)&setofFilter->next;
    }

    *previousPtr = NULL;
    return;

error_exit:

    *pSetOfFilter = NULL;
    RaiseDsaExcept(DSA_BAD_ARG_EXCEPTION,
                   LdapFilterDecodeErr,
                   0,
                   DSID(FILENO, __LINE__),
                   DS_EVENT_SEV_MINIMAL);

    return;

} // CBerDecode::GetSetOfFilterEx



VOID
CBerDecode::GetSubstringFilterEx(
    IN SubstringFilter *pSubstring,
    IN PBERVAL Blob,
    IN DWORD RequiredTag
    )
/*++

Routine Description:

    Main decode routine for LDAP Substring Filter

Arguments:

    pSubstring - pointer to a SubstringFilter structure 
        to contain the decoded info.
    Blob - a berval struct containing the buffer available for partitioning.
    RequiredTag - the Tag required for the decoding.
    
Return Value:

    None. Generates an exception on error.

--*/

{
    DWORD tag, tlen;
    DWORD endPos;
    BERVAL berString;
    PCHAR* previousPtr;

    //
    // This is a sequence of octet strings
    //

    IF_DEBUG(DECODE) {
        DPRINT(0,"Decoding Substring Filter\n");
    }

    pSubstring->substrings = NULL;
    if ( (GetTag( &tag ) != ERROR_SUCCESS) ||
         (GetLength(&tlen) != ERROR_SUCCESS) ){
        goto error_exit;
    }

    if ( tag != RequiredTag ) {
        IF_DEBUG(DECODE) {
            DPRINT2(0,"SubstFilter: Wrong tag for sequence [%x] should be [%x]\n",
                     tag, RequiredTag);
        }
        goto error_exit;
    }

    endPos = GetCurrentPos() + tlen;

    //
    // Get type
    //

    GetOctetStringEx(&berString);
    ConvertBVToDN(&berString, &pSubstring->type);

    if ( GetCurrentPos() > endPos ) {
        IF_DEBUG(ERROR) {
            DPRINT2(0,"GetSubstringFilter: Type field exceeded limit[%d][%d]\n",
                     GetCurrentPos(), endPos);
        }
        goto error_exit;
    }

    //
    // now get the substrings (SEQUENCE of CHOICES)
    //

    if ( (GetTag( &tag ) != ERROR_SUCCESS) ||
         (GetLength(&tlen) != ERROR_SUCCESS) ){
        goto error_exit;
    }

    if ( tag != BER_SEQUENCE ) {
        DPRINT1(0,"SubstringFilter: Wrong tag for sequence[%x]\n",tag);
        goto error_exit;
    }

    if ( (GetCurrentPos() + tlen) != endPos ) {
        IF_DEBUG(ERROR) {
            DPRINT2(0,"SubstringFilter: Length mismatch[%d != %d]\n",
                     endPos, GetCurrentPos()+tlen);
        }
        goto error_exit;
    }

    previousPtr = (PCHAR*)&pSubstring->substrings;
    while ( endPos > GetCurrentPos() ) {

        DWORD err;
        PBYTE value;
        SubstringFilterList sList;

        //
        // Allocate the substring list structure
        //

        sList = (SubstringFilterList)GrabBvBuffer(Blob,sizeof(SubstringFilterList_));
        if ( sList == NULL ) {
            IF_DEBUG(ERROR) {
                DPRINT(0,"Cannot allocate substring filter list\n");
            }
            goto error_exit;
        }

        ZeroMemory(sList, sizeof(SubstringFilterList_));

        err = GetTLV(&tag, &tlen, &value);
        if ( err != ERROR_SUCCESS ) {
            goto error_exit;
        }

        switch (tag) {
        case LDAP_SUBSTRING_INITIAL:
            sList->value.choice = initial_chosen;
            sList->value.u.initial.length = tlen;
            sList->value.u.initial.value = value;
            break;

        case LDAP_SUBSTRING_ANY:
            sList->value.choice = any_chosen;
            sList->value.u.any.length = tlen;
            sList->value.u.any.value = value;
            break;

        case LDAP_SUBSTRING_FINAL:
            sList->value.choice = final_chosen;
            sList->value.u.final.length = tlen;
            sList->value.u.final.value = value;
            break;

        default:
            IF_DEBUG(ERROR) {
                DPRINT1(0,"SubstringFilter: Invalid substring tag %x\n",tag);
            }
            goto error_exit;
        }

        *previousPtr = (PCHAR)sList;
        previousPtr = (PCHAR*)&sList->next;
    }

    *previousPtr = NULL;
    return;

error_exit:

    RaiseDsaExcept(DSA_BAD_ARG_EXCEPTION,
                   LdapFilterDecodeErr,
                   0,
                   DSID(FILENO, __LINE__),
                   DS_EVENT_SEV_MINIMAL);

    return;

} // CBerDecode::GetSubstringFilterEx



VOID
CBerDecode::GetMatchingRuleAssertionEx(
    IN MatchingRuleAssertion* pMatchingRule,
    IN DWORD RequiredTag
    )
/*++

Routine Description:

    Main decode routine for LDAP Matching Rule Assertions

Arguments:

    pMatchingRule - pointer to a MatchingRuleAssertion structure 
        to contain the decoded info.
    RequiredTag - the Tag required for the decoding.
    
Return Value:

    None. Generates an exception on error.

--*/

{
    DWORD err;
    DWORD tag, tlen;
    DWORD endPos;
    LONG tmpInt;
    PBYTE value;

    //
    // This is a sequence of octet strings
    //

    IF_DEBUG(DECODE) {
        DPRINT(0,"Decoding Matching Rule Assertion\n");
    }

    ZeroMemory(pMatchingRule, sizeof(MatchingRuleAssertion));

    if ( (GetTag( &tag ) != ERROR_SUCCESS) ||
         (GetLength(&tlen) != ERROR_SUCCESS) ){
        IF_DEBUG(DECODE) {
            DPRINT(0,"MatchRuleAssert: Cannot get tag or length\n");
        }
        goto error_exit;
    }

    if ( tag != RequiredTag ) {
        IF_DEBUG(DECODE) {
            DPRINT2(0,"MatchRuleAssert: Wrong tag for sequence [%x] should be [%x]\n",
                     tag, RequiredTag);
        }
        goto error_exit;
    }

    endPos = GetCurrentPos() + tlen;

    if ( PeekTag(&tag) != ERROR_SUCCESS ) {
        IF_DEBUG(DECODE) {
            DPRINT(0,"Peek tag error for MatchingRuleAssertion\n");
        }
        goto error_exit;
    }

    //
    // MatchingRule present?
    //

    if ( tag == (BER_CLASS_CONTEXT_SPECIFIC | 0x1) ) {

        err = GetTLV(&tag, &tlen, &value);
        if ( err != ERROR_SUCCESS ) {
            goto error_exit;
        }

        pMatchingRule->bit_mask |= matchingRule_present;
        pMatchingRule->matchingRule.length = tlen;
        pMatchingRule->matchingRule.value = value;

        if ( PeekTag(&tag) != ERROR_SUCCESS ) {
            IF_DEBUG(DECODE) {
                DPRINT(0,"[2]Peek tag error for MatchingRuleAssertion\n");
            }
            goto error_exit;
        }
    }

    //
    // type present?
    //

    if ( tag == (BER_CLASS_CONTEXT_SPECIFIC | 0x2) ) {

        err = GetTLV(&tag, &tlen, &value);
        if ( err != ERROR_SUCCESS ) {
            goto error_exit;
        }

        pMatchingRule->bit_mask |= type_present;
        pMatchingRule->type.length = tlen;
        pMatchingRule->type.value = value;

        if ( PeekTag(&tag) != ERROR_SUCCESS ) {
            IF_DEBUG(DECODE) {
                DPRINT(0,"[3]Peek tag error for MatchingRuleAssertion\n");
            }
            goto error_exit;
        }
    }

    //
    // matchValue. Must be present
    //

    if ( tag != (BER_CLASS_CONTEXT_SPECIFIC | 0x3) ) {
        IF_DEBUG(ERROR) {
            DPRINT1(0,"Invalid matchValue tag in MatchRuleAssertion[tag %x]\n",tag);
        }
        goto error_exit;
    }

    err = GetTLV(&tag, &tlen, &value);
    if ( err != ERROR_SUCCESS ) {
        goto error_exit;
    }

    pMatchingRule->matchValue.length = tlen;
    pMatchingRule->matchValue.value = value;

    //
    // if no more tag, dnAttributes will be zero.
    //

    if ( PeekTag(&tag) != ERROR_SUCCESS ) {
        goto exit;
    }

    //
    // dnAttributes, default is FALSE
    //

    if ( tag != (BER_CLASS_CONTEXT_SPECIFIC | 0x4) ) {
        IF_DEBUG(ERROR) {
            DPRINT1(0,"Invalid tag for dnAttributes [%x]\n",tag);
        }
        goto error_exit;
    }

    pMatchingRule->bit_mask |= dnAttributes_present;
    GetBooleanEx(&tmpInt, tag);
    if ( tmpInt != 0 ) {
        pMatchingRule->dnAttributes = 1;
    }

exit:

    ASSERT(GetCurrentPos() == endPos);
    return;

error_exit:

    RaiseDsaExcept(DSA_BAD_ARG_EXCEPTION,
                   LdapFilterDecodeErr,
                   0,
                   DSID(FILENO, __LINE__),
                   DS_EVENT_SEV_MINIMAL);

    return;

} // CBerDecode::GetMatchingRuleAssertionEx


VOID
CBerDecode::GetControlsEx(
    OUT Controls* LdapControls,
    OUT unsigned char *BitMask,
    IN PBERVAL Blob
    )
/*++

Routine Description:

    Main decode routine for LDAP Controls

Arguments:

    LdapControls - pointer to receive a Controls structure that contains the
                   decoded info.
    BitMask - pointer to a bit-mask that will have the controls_present flat
              flipped if controls are present.
    Blob - a berval struct containing the buffer available for partitioning.
    
Return Value:

    None. Generates an exception on error.

--*/

{
    DWORD tag=0, tlen;
    DWORD endPos;
    PCHAR* previousPtr = (PCHAR*)LdapControls;

    if ( PeekTag(&tag) != ERROR_SUCCESS ) {
        return;
    }

    //
    // Hmm. Wrong tag. Flag this down
    //

    if ( tag != 0xA0 ) {
        IF_DEBUG(DECODE) {
            DPRINT1(0,"GetControls: Wrong tag for Controls [%x]\n",tag);
        }
        goto error_exit;
    }

    //
    // OK, This is a sequence of controls
    //

    *BitMask |= controls_present;

    if ( (GetTag( &tag ) != ERROR_SUCCESS) ||
         (GetLength(&tlen) != ERROR_SUCCESS) ){
        IF_DEBUG(DECODE) {
            DPRINT(0,"Cannot get tag or length of controls sequence\n");
        }
        goto error_exit;
    }

    IF_DEBUG(DECODE) {
        DPRINT(0,"Decoding controls\n");
    }

    endPos = GetCurrentPos() + tlen;

    while ( endPos > GetCurrentPos() ) {

        Controls controls;
        BERVAL berString;

        //
        // Allocate the substring list structure
        //

        controls = (Controls)GrabBvBuffer(Blob,sizeof(Controls_));
        if ( controls == NULL ) {
            IF_DEBUG(ERROR) {
                DPRINT(0,"Cannot allocate Controls.\n");
            }
            goto error_exit;
        }

        //
        // Get Sequence
        //

        if ( (GetTag( &tag ) != ERROR_SUCCESS) ||
             (GetLength(&tlen) != ERROR_SUCCESS) ){
            IF_DEBUG(DECODE) {
                DPRINT(0,"Cannot get tag or length of control sequence\n");
            }
            goto error_exit;
        }

        if ( tag != BER_SEQUENCE ) {
            IF_DEBUG(DECODE) {
                DPRINT1(0,"GetControls: Wrong tag for Control Sequence [%x]\n",tag);
            }
        }

        //
        // Get control type (OID)
        //

        GetOctetStringEx(&berString);
        controls->value.controlType.length = berString.bv_len;
        controls->value.controlType.value = (PBYTE)berString.bv_val;

        controls->value.criticality = 0;
        if ( PeekTag(&tag) != ERROR_SUCCESS ) {
            tag = BER_INVALID_TAG;
        }

        //
        // criticality?
        //

        if ( tag == BER_BOOLEAN ) {
            LONG tmpInt;
            GetBooleanEx(&tmpInt);
            controls->value.bit_mask |= criticality_present;
            if ( tmpInt != 0 ) {
                controls->value.criticality = 1;
            }

            //
            // We might have a control Value
            //

            if ( PeekTag(&tag) != ERROR_SUCCESS ) {
                tag = BER_INVALID_TAG;
            }
        }

        //
        // controlValue?
        //

        if ( tag == BER_OCTETSTRING ) {
            GetOctetStringEx(&berString);
            controls->value.controlValue.length = berString.bv_len;
            controls->value.controlValue.value = (PBYTE)berString.bv_val;

        } else {
            ASSERT(tag == 0);
        }

        *previousPtr = (PCHAR)controls;
        previousPtr = (PCHAR*)&controls->next;
    }

    *previousPtr = NULL;

    ASSERT(GetCurrentPos() == endPos);
    return;

error_exit:

    *LdapControls = NULL;
    RaiseDsaExcept(DSA_BAD_ARG_EXCEPTION,
                   LdapControlsDecodeErr,
                   0,
                   DSID(FILENO, __LINE__),
                   DS_EVENT_SEV_MINIMAL);

    return;

} // CBerDecode::GetControlsEx



DWORD
CBerDecode::DecodeOctetString(
    OUT unsigned int *LengthOutput,
    OUT unsigned char **ValueOutput,
    IN BOOL DoVerifyId
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP octet string, and write the encoded
    information into the output parameters passed in.

Arguments:

    LengthOutput - points to the integer to receive the length of the octet
                   string.
    ValueOutput - points to the char* to receive a pointer to the bytes of
                  the octet string.
    DoVerifyId - if TRUE, it will check to make sure that the identifier of
                 the input is correct.  FALSE means that the caller already
                 verified this (this would be used for implicitly tagged
                 types).
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    if ( DoVerifyId ) {
        error = VerifyId(BER_OCTETSTRING);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }
    }
    
    unsigned long result;
    PBERVAL tempBerVal;
    
    result = ber_scanf(m_pBerElt, "O", &tempBerVal);
    if ( result != 0 ) {
        return ERROR_INVALID_PARAMETER;
    } else if ( tempBerVal == NULL ) {
        *LengthOutput = 0;
        *ValueOutput = (PUCHAR)m_pBlob->bv_val;
        return ERROR_SUCCESS;
    }
    
    *LengthOutput = tempBerVal->bv_len;
    
    *ValueOutput = GrabBvBuffer(m_pBlob, tempBerVal->bv_len);
    if ( *ValueOutput == NULL ) {
        ber_bvfree(tempBerVal);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    CopyMemory(*ValueOutput, tempBerVal->bv_val, tempBerVal->bv_len);

    ber_bvfree(tempBerVal);
    
    return ERROR_SUCCESS;

} // DecodeOctetString



DWORD
CBerDecode::DecodeBoolean(
    OUT ossBoolean *Output,
    IN BOOL DoVerifyId
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP boolean, and write the encoded information
    into the boolean pointed to by Output.

Arguments:

    Output - points to the boolean to receive the encoded information.
    DoVerifyId - if TRUE, it will check to make sure that the identifier of
                 the input is correct.  FALSE means that the caller already
                 verified this (this would be used for implicitly tagged
                 types).
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER

--*/
{

    DWORD error;

    if ( DoVerifyId ) {
        error = VerifyId(BER_BOOLEAN);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }
    }
    
    unsigned long result;
    int boolean;
    
    result = ber_scanf(m_pBerElt, "b", &boolean);
    if ( result != 0 ) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( boolean == 0 ) {
        *Output = FALSE;
    } else {
        *Output = TRUE;
    }
    
    return ERROR_SUCCESS;

} // DecodeBoolean



DWORD
CBerDecode::DecodeInteger(
    OUT unsigned int *Output,
    IN BOOL DoVerifyId
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP integer, and write the encoded information
    into the int pointed to by Output.

Arguments:

    Output - points to the integer to receive the encoded information.
    DoVerifyId - if TRUE, it will check to make sure that the identifier of
                 the input is correct.  FALSE means that the caller already
                 verified this (this would be used for implicitly tagged
                 types).
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER

--*/
{

    DWORD error;

    if ( DoVerifyId ) {
        error = VerifyId(BER_INTEGER);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }
    }
    
    unsigned long result;
    
    result = ber_scanf(m_pBerElt, "i", Output);
    if ( result != 0 ) {
        return ERROR_INVALID_PARAMETER;
    }
    
    return ERROR_SUCCESS;

} // DecodeInteger



DWORD
CBerDecode::DecodeNull(
    IN BOOL DoVerifyId
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding an LDAP Nulltype.

Arguments:

    DoVerifyId - if TRUE, it will check to make sure that the identifier of
                 the input is correct.  FALSE means that the caller already
                 verified this (this would be used for implicitly tagged
                 types).
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER

--*/
{

    DWORD error;

    if ( DoVerifyId ) {
        error = VerifyId(BER_NULL);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }
    }
    
    unsigned long result;
    
    result = ber_scanf(m_pBerElt, "n");
    if ( result != 0 ) {
        return ERROR_INVALID_PARAMETER;
    }
    
    return ERROR_SUCCESS;

} // DecodeNull



DWORD
CBerDecode::DecodeBeginSequence(
    IN BOOL DoVerifyId
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding the beginning of an LDAP sequence.

Arguments:

    DoVerifyId - if TRUE, it will check to make sure that the identifier of
                 the input is correct.  FALSE means that the caller already
                 verified this (this would be used for implicitly tagged
                 types).
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER

--*/
{

    DWORD error;

    if ( DoVerifyId ) {
        error = VerifyId(BER_SEQUENCE);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }
    }
    
    unsigned long result;
    
    result = ber_scanf(m_pBerElt, "{");
    if ( result != 0 ) {
        return ERROR_INVALID_PARAMETER;
    }

    return ERROR_SUCCESS;

} // DecodeBeginSequence



DWORD
CBerDecode::DecodeEndSequence(
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding the end of an LDAP sequence.

Arguments:

    None
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER

--*/
{

    unsigned long result;
    
    result = ber_scanf(m_pBerElt, "}");
    if ( result != 0 ) {
        return ERROR_INVALID_PARAMETER;
    }
    
    return ERROR_SUCCESS;

} // DecodeEndSequence



DWORD
CBerDecode::DecodeBeginSet(
    IN BOOL DoVerifyId
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding the beginning of an LDAP set.

Arguments:

    DoVerifyId - if TRUE, it will check to make sure that the identifier of
                 the input is correct.  FALSE means that the caller already
                 verified this (this would be used for implicitly tagged
                 types).
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER

--*/
{

    DWORD error;

    if ( DoVerifyId ) {
        error = VerifyId(BER_SET);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }
    }
    
    unsigned long result;
    
    result = ber_scanf(m_pBerElt, "[");
    if ( result != 0 ) {
        return ERROR_INVALID_PARAMETER;
    }
    
    return ERROR_SUCCESS;

} // DecodeBeginSet



DWORD
CBerDecode::DecodeEndSet(
    )
/*++

Routine Description:

    Interpret the information at the current position in the input buffer
    (m_pbData) as encoding the end of an LDAP set.

Arguments:

    None
    
Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER

--*/
{

    unsigned long result;
    
    result = ber_scanf(m_pBerElt, "]");
    if ( result != 0 ) {
        return ERROR_INVALID_PARAMETER;
    }
    
    return ERROR_SUCCESS;

} // DecodeEndSet



DWORD
CBerDecode::VerifyId(
    IN unsigned long RequiredId
    )
/*++

Routine Description:

    This function peeks at the identifier of the next part of the input, and
    if it is not the given RequiredId, throws an exception.

Arguments:

    RequiredId - the identifier that is expected to occur in the input

Return Value:

    ERROR_SUCCESS

--*/
{

    unsigned long id;
    
    PeekId(&id);

    if ( id != RequiredId ) {
        IF_DEBUG(DECODE) {
            DPRINT2(0,"error: invalid tag: %02x found, %02x expected\n",
                    id, RequiredId);
        }
        RaiseDsaExcept(DSA_BAD_ARG_EXCEPTION,
                       LdapDecodeError,
                       0,
                       DSID(FILENO, __LINE__),
                       DS_EVENT_SEV_MINIMAL);
    }

    return ERROR_SUCCESS;

} // VerifyId



VOID
CBerDecode::PeekId(
    OUT unsigned long *Id
    )
/*++

Routine Description:

    This function peeks at the identifier of the next part of the input, and
    stores that tag in the output parameter Id.

Arguments:

    Id - receives the identifier that is found on the next input TLV

Return Value:

    None. 

--*/
{

    unsigned long length;
    *Id = ber_peek_tag(m_pBerElt, &length);

    return;
    
} // PeekId



BOOL
CBerDecode::MoveToFirstElement(
    IN unsigned long *PLength,
    IN char **PPOpaque
    )
/*++

Routine Description:

    This function starts decoding a SEQUENCE OF or SET OF by moving the
    current position to the beginning of the first element.  The value it
    returns indicates whether or not the construction contains elements.

Arguments:

    PLength - first parameter to ber_first_element
    PPOpaque - second parameter to ber_first_element

Return Value:

    TRUE - there are elements in this sequence or set.
    FALSE - this sequence or set is empty.

--*/
{

    unsigned long result;

    result = ber_first_element(m_pBerElt, PLength, PPOpaque);

    return (result != LBER_DEFAULT);

} // MoveToFirstElement



BOOL
CBerDecode::MoveToNextElement(
    IN unsigned long *PLength,
    IN char *POpaque
    )
/*++

Routine Description:

    This function continues decoding a SEQUENCE OF or SET OF by moving the
    current position to the beginning of the next element.  The value it
    returns indicates whether or not the construction contains elements.

Arguments:

    PLength - first parameter to ber_next_element
    POpaque - second parameter to ber_next_element

Return Value:

    TRUE - there are more elements in this sequence or set.
    FALSE - this are no more elements in this sequence or set.

--*/
{

    unsigned long result;

    result = ber_next_element(m_pBerElt, PLength, POpaque);

    return (result != LBER_DEFAULT);

} // MoveToNextElement
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\include\xrefpro.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       xrefpro.h
//
//--------------------------------------------------------------------------

/*
 * XRefPro.h -
 * Procedure defs for bind referrals and access point caching.
 */

BOOL
XSetDirHandle(DIRHANDLE dirHandle,
		PDISTNAME pCredents);

VOID
XRemoveDirHandle(DIRHANDLE dirHandle);

VOID
XFlushDirHandles(DIRHANDLE dirHandle);

USHORT
XGetDirHandle( DIRHANDLE dirHandle,         // our 'parent' key handle
               DIRHANDLE * phdirRefHandle,  // new referral handle
               ACCPNT *pAccPnt ) ;          // NULL if no referral, else the referral point

ACCPNT *
XGetAccessPoint(DIRHANDLE dirHandle);

VOID XInitReferralCache( VOID ) ;

USHORT XGetMasterDSAHandle( DIRHANDLE dirHandle,         // our 'parent' key handle
                            DIRHANDLE * phdirRefHandle,  // new referral handle
                            PDISTNAME pDN,
                            ACCPNT ** ppAccpnt );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\ldap\encode.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    encode.cxx

Abstract:

    Definition of functions that turn LDAPMsg structures into BER encodings.

Author:

    Kevin Zatloukal (t-KevinZ) 7-July-1998

--*/

#include "NTDSpchx.h"
#pragma  hdrstop

#include "ldapsvr.hxx"
#include <winldap.h>
#include "ber.hxx"

#define MAX_BER_TAGLEN  6
#define  FILENO FILENO_LDAP_ENCODE


DWORD
EncodeLdapMsg(
    IN LDAPMsg* Msg,
    OUT PLDAP_REQUEST Output
    )
/*++

Routine Description:

    Encodes the given LDAPMsg structure into a BER encoding which is stored
    in the LDAP_REQUEST structure given.

Arguments:

    Msg - the LDAPMsg structure to encode
    Output - the LDAP_REQUEST structure to hold the BER encoding

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    CBerEncode encoder;
    DWORD error;
            
    if ( Msg == NULL ) {
        IF_DEBUG(ENCODE) {
            DPRINT(0,"EncodeLdapMsg passed NULL Msg parameter.\n");
        }
        return ERROR_INVALID_PARAMETER;
    }
    
    error = encoder.InitEncoding();
    if ( error != ERROR_SUCCESS ) {
        IF_DEBUG(ENCODE) {
            DPRINT(0,"Failed to initialize encoder.\n");
        }
        return error;
    }

    error = encoder.EncodeLdapMsg(Msg);
    if ( error != ERROR_SUCCESS ) {
        IF_DEBUG(ENCODE) {
            DPRINT(0,"Failed to encode message.\n");
        }
        return error;
    }

    error = encoder.GetOutput(Output);
    if ( error != ERROR_SUCCESS ) {
        IF_DEBUG(ENCODE) {
            DPRINT(0,"Failed to produce output encoding.\n");
        }
        return error;
    }

    return ERROR_SUCCESS;

} // EncodeLdapMsg



CBerEncode::~CBerEncode(
    )
/*++

Routine Description:

    Cleans up the private members of this class instance.

Arguments:

    None

Return Value:

    None

--*/
{

    if ( m_pBerElt != NULL ) {
        ber_free(m_pBerElt, 1);
    }

} // ~CBerEncode



DWORD
CBerEncode::InitEncoding(
    )
/*++

Routine Description:

    Initializes the data members.  This function is here so that this class
    will have the same structure as the CBerDecode class.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS
    ERROR_NOT_ENOUGH_MEMORY

--*/
{
            
    m_pBerElt = ber_alloc_t(LBER_USE_DER);
            
    if ( m_pBerElt == NULL ) {
        IF_DEBUG(ENCODE) {
            DPRINT(0,"Failed to allocate BerElement* member variable.\n");
        }
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    return ERROR_SUCCESS;
            
} // InitEncoding



DWORD
CBerEncode::GetOutput(
    OUT PLDAP_REQUEST Output
    )
/*++

Routine Description:

    This function copies the encoding held in the private members into the
    LDAP_REQUEST structure given.

Arguments:

    Output - the structure in which to copy the BER encoding.

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    PBERVAL pTempBerval;
            
    int nResult = ber_flatten(m_pBerElt, &pTempBerval);

    if ( nResult != 0 ) {
        IF_DEBUG(ENCODE) {
            DPRINT(0,"Failed to flatten BerElement representation.\n");
        }
        return ERROR_INVALID_PARAMETER;
    }

    LONG growSize = pTempBerval->bv_len - (ULONG)Output->GetSendBufferSize();

    if ( growSize > 0 ) {

        BOOL bResult = Output->GrowSend(growSize);

        if ( bResult == FALSE ) {
            IF_DEBUG(ENCODE) {
                DPRINT(0,"Failed to grow output buffer.\n");
            }
            ber_bvfree(pTempBerval);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

    }

    PUCHAR pSendBuffer = Output->GetSendBuffer();
    if (NULL == pSendBuffer) {
        ber_bvfree(pTempBerval);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    CopyMemory(pSendBuffer, pTempBerval->bv_val, pTempBerval->bv_len);
    Output->SetBufferPtr(pSendBuffer + pTempBerval->bv_len);
    
    ber_bvfree(pTempBerval);

    return ERROR_SUCCESS;
            
} // GetOutput



DWORD
CBerEncode::EncodeLdapMsg(
    IN LDAPMsg* Input
    )
/*++

Routine Description:

    Create and store the BER encoding for the given LDAPMsg

Arguments:

    Input - the LDAPMsg to encode

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    IF_DEBUG(ENCODE) {
        DPRINT3(0,"Encoding: msgId=%x, protocol=%x, %s\n",
                 Input->messageID,
                 Input->protocolOp.choice,
                 (Input->bit_mask & controls_present) ?
                   "controls present" : "no controls present");
    }
    
    error = EncodeBeginSequence();
    if ( error != ERROR_SUCCESS ) {
        IF_DEBUG(ENCODE) {
            DPRINT(0,"EncodeLdapMsg: failed encoding: begin sequence\n");
        }
        return error;
    }

    error = EncodeMessageId(&Input->messageID);
    if ( error != ERROR_SUCCESS ) {
        IF_DEBUG(ENCODE) {
            DPRINT(0,"EncodeLdapMsg: failed encoding: messageId\n");
        }
        return error;
    }

    switch ( Input->protocolOp.choice ) {
        
    case bindResponse_chosen:
        error = EncodeBindResponse(&Input->protocolOp.u.bindResponse);
        break;
        
    case modifyResponse_chosen:
        error = EncodeModifyResponse(&Input->protocolOp.u.modifyResponse);
        break;
        
    case addResponse_chosen:
        error = EncodeAddResponse(&Input->protocolOp.u.addResponse);
        break;
        
    case delResponse_chosen:
        error = EncodeDelResponse(&Input->protocolOp.u.delResponse);
        break;
        
    case modDNResponse_chosen:
        error = EncodeModifyDNResponse(&Input->protocolOp.u.modDNResponse);
        break;
        
    case compareResponse_chosen:
        error = EncodeCompareResponse(&Input->protocolOp.u.compareResponse);
        break;
        
    case extendedResp_chosen:
        error = EncodeExtendedResponse(&Input->protocolOp.u.extendedResp);
        break;

    default:
        IF_DEBUG(ENCODE) {
            DPRINT(0,"EncodeLdapMsg: invalid protocol type\n");
        }
        return ERROR_INVALID_PARAMETER;
        
    }

    if ( error != ERROR_SUCCESS ) {
        IF_DEBUG(ENCODE) {
            DPRINT(0,"EncodeLdapMsg: failed encoding: protocolOp\n");
        }
        return error;
    }

    if ( Input->bit_mask & controls_present ) {
        
        error = EncodeControls(
                    Input->controls,
                    MakeBerId(BER_CLASS_CONTEXT_SPECIFIC,
                              BER_FORM_CONSTRUCTED,
                              0)
                    );
        if ( error != ERROR_SUCCESS ) {
            IF_DEBUG(ENCODE) {
                DPRINT(0,"EncodeLdapMsg: failed encoding: controls\n");
            }
            return error;
        }

    }

    error = EncodeEndSequence();
    if ( error != ERROR_SUCCESS ) {
        IF_DEBUG(ENCODE) {
            DPRINT(0,"EncodeLdapMsg: failed encoding: end sequence\n");
        }
        return error;
    }

    return ERROR_SUCCESS;

} // EncodeLdapMsg



DWORD
CBerEncode::EncodeBindResponse(
    IN BindResponse* Input
    )
/*++

Routine Description:

    Create and store the BER encoding for the given BindResponse.

Arguments:

    Input - the BindResponse to encode

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = EncodeBeginSequence(LDAP_RES_BIND);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    /* Start:  COMPONENTS OF LDAPResult */
    
    error = EncodeInteger((unsigned int*)&Input->resultCode, BER_ENUMERATED);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }    

    error = EncodeLdapDn(&Input->matchedDN);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    error = EncodeLdapString(&Input->errorMessage);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    if ( Input->bit_mask & BindResponse_referral_present ) {

        error = EncodeReferral(Input->BindResponse_referral);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }        
        
    }

    /* End: COMPONENTS OF LDAPResult */
        
    //
    // !!! 1/12/98 This is definitely not LDAPv3 compliant. This was the
    // correct format around 7/97 but was changed after that. Somehow this
    // was missed.  Not only is the server wrong, but the NT ldap client is
    // also wrong. We are doing a coordinated checkin to fix this problem.
    //

    if ( Input->bit_mask & BindResponse_ldapv3 ) {

        Assert( Input->bit_mask & serverCreds_present );

        //
        // This is the v3 standard
        //

        IF_DEBUG(ENCODE) {
            DPRINT(0,"Encoding bind response using standard method\n");
        }

        error = EncodeOctetString(
                    &Input->serverCreds.u.sasl.credentials.length,
                    &Input->serverCreds.u.sasl.credentials.value,
                    MakeBerId(BER_CLASS_CONTEXT_SPECIFIC,
                              BER_FORM_PRIMITIVE,
                              7)
                    );

        if ( error != ERROR_SUCCESS ) {
            return error;
        }

    } else if ( Input->bit_mask & serverCreds_present ) {

        //
        // This is the bogus response we had been sending back
        //
        
        IF_DEBUG(ENCODE) {
            DPRINT(0,"Encoding bind response using old nonstandard method\n");
        }

        error = EncodeAuthenticationChoice(
                    &Input->serverCreds,
                    MakeBerId(BER_CLASS_CONTEXT_SPECIFIC,
                              BER_FORM_PRIMITIVE,
                              7)
                    );
        if ( error != ERROR_SUCCESS ) {
            return error;
        }
    }
    
    error = EncodeEndSequence();
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;

} // EncodeBindResponse



DWORD
CBerEncode::EncodeModifyResponse(
    IN ModifyResponse* Input
    )
/*++

Routine Description:

    Create and store the BER encoding for the given ModifyResponse.

Arguments:

    Input - the ModifyResponse to encode

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = EncodeLdapResult(Input, LDAP_RES_MODIFY);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;

} // EncodeModifyResponse



DWORD
CBerEncode::EncodeAddResponse(
    IN AddResponse* Input
    )
/*++

Routine Description:

    Create and store the BER encoding for the given AddResponse.

Arguments:

    Input - the AddResponse to encode

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = EncodeLdapResult(Input, LDAP_RES_ADD);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;

} // EncodeAddResponse



DWORD
CBerEncode::EncodeDelResponse(
    IN DelResponse* Input
    )
/*++

Routine Description:

    Create and store the BER encoding for the given DelResponse.

Arguments:

    Input - the DelResponse to encode

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = EncodeLdapResult(Input, LDAP_RES_DELETE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;

} // EncodeDelResponse



DWORD
CBerEncode::EncodeModifyDNResponse(
    IN ModifyDNResponse* Input
    )
/*++

Routine Description:

    Create and store the BER encoding for the given ModifyDNResponse.

Arguments:

    Input - the ModifyDNResponse to encode

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = EncodeLdapResult(Input, LDAP_RES_MODRDN);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;

} // EncodeModifyDNResponse



DWORD
CBerEncode::EncodeCompareResponse(
    IN CompareResponse* Input
    )
/*++

Routine Description:

    Create and store the BER encoding for the given CompareResponse.

Arguments:

    Input - the CompareResponse to encode

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = EncodeLdapResult(Input, LDAP_RES_COMPARE);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;

} // EncodeCompareResponse



DWORD
CBerEncode::EncodeExtendedResponse(
    IN ExtendedResponse* Input
    )
/*++

Routine Description:

    Create and store the BER encoding for the given ExtendedResponse.

Arguments:

    Input - the ExtendedResponse to encode

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = EncodeBeginSequence(LDAP_RES_EXTENDED);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    /* Start:  COMPONENTS OF LDAPResult */
    
    error = EncodeInteger((unsigned int*)&Input->resultCode, BER_ENUMERATED);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }    

    error = EncodeLdapDn(&Input->matchedDN);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    error = EncodeLdapString(&Input->errorMessage);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    if ( Input->bit_mask & ExtendedResponse_referral_present ) {

        error = EncodeReferral(Input->ExtendedResponse_referral);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }        
        
    }
    
    /* End: COMPONENTS OF LDAPResult */
        
    if ( Input->bit_mask & responseName_present ) {

        error = EncodeLdapOid(
                    &Input->responseName,
                    MakeBerId(BER_CLASS_CONTEXT_SPECIFIC,
                              BER_FORM_PRIMITIVE,
                              10)
                    );
        if ( error != ERROR_SUCCESS ) {
            return error;
        }

    }
    
    if ( Input->bit_mask & response_present ) {

        error = EncodeOctetString(
                    &Input->response.length,
                    &Input->response.value,
                    MakeBerId(BER_CLASS_CONTEXT_SPECIFIC,
                              BER_FORM_PRIMITIVE,
                              11)
                    );
        if ( error != ERROR_SUCCESS ) {
            return error;
        }

    }
    
    error = EncodeEndSequence();
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;

} // EncodeExtendedResponse



DWORD
CBerEncode::EncodeMessageId(
    IN MessageID *Input,
    IN DWORD NewId /* = BER_INVALID_TAG */
    )
/*++

Routine Description:

    Create and store the BER encoding for the given MessageID structure.
    The parameter NewId can be added to give it a new tag.

Arguments:

    Input - the MessageID structure to encode
    NewId - the tag value to use (defaults to BER_INVALID_TAG to indicate
             that no value was given)

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = EncodeInteger(Input, NewId);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;

} // EncodeMessageId



DWORD
CBerEncode::EncodeControls(
    IN Controls_ *Input,
    IN DWORD NewId /* = BER_INVALID_TAG */
    )
/*++

Routine Description:

    Create and store the BER encoding for the given Controls structure.  The
    parameter NewId can be added to give it a new tag.

Arguments:

    Input - the Controls structure to encode
    NewId - the tag value to use (defaults to BER_INVALID_TAG to indicate
             that no value was given)

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = EncodeBeginSequence(NewId);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    while ( Input != NULL ) {

        error = EncodeControl(&Input->value);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }

        Input = Input->next;

    }

    error = EncodeEndSequence();
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;

} // EncodeControls



DWORD
CBerEncode::EncodeControl(
    IN Control *Input,
    IN DWORD NewId /* = BER_INVALID_TAG */
    )
/*++

Routine Description:

    Create and store the BER encoding for the given Control structure.  The
    parameter NewId can be added to give it a new tag.

Arguments:

    Input - the Control structure to encode
    NewId - the tag value to use (defaults to BER_INVALID_TAG to indicate
             that no value was given)

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = EncodeBeginSequence(NewId);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    error = EncodeLdapOid(&Input->controlType);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    if ( Input->bit_mask & criticality_present ) {
        
        error = EncodeBoolean(&Input->criticality);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }
        
    }

    error = EncodeOctetString(&Input->controlValue.length,
                              &Input->controlValue.value);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    error = EncodeEndSequence();
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;

} // EncodeControl



DWORD
CBerEncode::EncodeAuthenticationChoice(
    IN AuthenticationChoice *Input,
    IN DWORD NewId /* = BER_INVALID_TAG */
    )
/*++

Routine Description:

    Create and store the BER encoding for the given AuthenticationChoice
    structure.  The parameter NewId can be added to give it a new tag.

Arguments:

    Input - the AuthenticationChoice structure to encode
    NewId - the tag value to use (defaults to BER_INVALID_TAG to show when
             no value has been given)

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    if ( NewId != BER_INVALID_TAG ) {

        error = EncodeBeginSequence(NewId);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }

    }
    
    switch ( Input->choice ) {

    case simple_chosen:
        error = EncodeOctetString(
                    &Input->u.simple.length,
                    &Input->u.simple.value,
                    MakeBerId(BER_CLASS_CONTEXT_SPECIFIC,
                              BER_FORM_PRIMITIVE,
                              0)
                    );
        break;

    case sasl_chosen:
        error = EncodeSaslCredentials(
                    &Input->u.sasl,
                    MakeBerId(BER_CLASS_CONTEXT_SPECIFIC,
                              BER_FORM_CONSTRUCTED,
                              3)
                    );
        break;

    case sicilyNegotiate_chosen:
        error = EncodeOctetString(
                    &Input->u.sicilyNegotiate.length,
                    &Input->u.sicilyNegotiate.value,
                    MakeBerId(BER_CLASS_CONTEXT_SPECIFIC,
                              BER_FORM_PRIMITIVE,
                              9)
                    );
        break;

    case sicilyInitial_chosen:
        error = EncodeOctetString(
                    &Input->u.sicilyInitial.length,
                    &Input->u.sicilyInitial.value,
                    MakeBerId(BER_CLASS_CONTEXT_SPECIFIC,
                              BER_FORM_PRIMITIVE,
                              10)
                    );
        break;

    case sicilySubsequent_chosen:
        error = EncodeOctetString(
                    &Input->u.sicilySubsequent.length,
                    &Input->u.sicilySubsequent.value,
                    MakeBerId(BER_CLASS_CONTEXT_SPECIFIC,
                              BER_FORM_PRIMITIVE,
                              11)
                    );
        break;

    default:
        return ERROR_INVALID_PARAMETER;
        
    }

    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    if ( NewId != BER_INVALID_TAG ) {

        error = EncodeEndSequence();
        if ( error != ERROR_SUCCESS ) {
            return error;
        }

    }
    
    return ERROR_SUCCESS;

} // EncodeAuthenticationChoice



DWORD
CBerEncode::EncodeSaslCredentials(
    IN SaslCredentials *Input,
    IN DWORD NewId /* = BER_INVALID_TAG */
    )
/*++

Routine Description:

    Create and store the BER encoding for the given SaslCredentials structure.
    The parameter NewId can be added to give it a new tag.

Arguments:

    Input - the SaslCredentials structure to encode
    NewId - the tag value to use (defaults to BER_INVALID_TAG to indicate
             that no value was given)

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = EncodeBeginSequence(NewId);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    error = EncodeLdapString(&Input->mechanism);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    error = EncodeOctetString(&Input->credentials.length,
                              &Input->credentials.value);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    error = EncodeEndSequence();
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;

} // EncodeSaslCredentials



DWORD
CBerEncode::EncodeLdapResult(
    IN LDAPResult *Input,
    IN DWORD NewId /* = BER_INVALID_TAG */
    )
/*++

Routine Description:

    Create and store the BER encoding for the given LDAPResult structure.
    The parameter NewId can be added to give it a new tag.

Arguments:

    Input - the LDAPResult structure to encode
    NewId - the tag value to use (defaults to BER_INVALID_TAG to indicate
             that no value was given)

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = EncodeBeginSequence(NewId);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    error = EncodeInteger((unsigned int*)&Input->resultCode, BER_ENUMERATED);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    error = EncodeLdapDn(&Input->matchedDN);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    error = EncodeLdapString(&Input->errorMessage);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    if ( Input->bit_mask & LDAPResult_referral_present ) {
    
        error = EncodeReferral(
                    Input->LDAPResult_referral,
                    MakeBerId(BER_CLASS_CONTEXT_SPECIFIC,
                              BER_FORM_CONSTRUCTED,
                              3)
                    );
        if ( error != ERROR_SUCCESS ) {
            return error;
        }

    }

    error = EncodeEndSequence();
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;

} // EncodeLdapResult



DWORD
CBerEncode::EncodeReferral(
    IN Referral_ *Input,
    IN DWORD NewId /* = BER_INVALID_TAG */
    )
/*++

Routine Description:

    Create and store the BER encoding for the given Referral structure.
    The parameter NewId can be added to give it a new tag.

Arguments:

    Input - the Referral structure to encode
    NewId - the tag value to use (defaults to BER_INVALID_TAG to indicate
             that no value was given)

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = EncodeBeginSequence(NewId);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    while ( Input != NULL ) {

        error = EncodeLdapUrl(&Input->value);
        if ( error != ERROR_SUCCESS ) {
            return error;
        }

        Input = Input->next;
        
    }

    error = EncodeEndSequence();
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;

} // EncodeReferral



DWORD
CBerEncode::EncodeLdapString(
    IN LDAPString *Input,
    IN DWORD NewId /* = BER_INVALID_TAG */
    )
/*++

Routine Description:

    Create and store the BER encoding for the given LDAPString structure.
    The parameter NewId can be added to give it a new tag.

Arguments:

    Input - the LDAPString structure to encode
    NewId - the tag value to use (defaults to BER_INVALID_TAG to indicate
             that no value was given)

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = EncodeOctetString(&Input->length, &Input->value, NewId);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;

} // EncodeLdapString



DWORD
CBerEncode::EncodeLdapOid(
    IN LDAPOID *Input,
    IN DWORD NewId /* = BER_INVALID_TAG */
    )
/*++

Routine Description:

    Create and store the BER encoding for the given LDAPOID structure.
    The parameter NewId can be added to give it a new tag.

Arguments:

    Input - the LDAPOID structure to encode
    NewId - the tag value to use (defaults to BER_INVALID_TAG to indicate
             that no value was given)

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = EncodeOctetString(&Input->length, &Input->value, NewId);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;

} // EncodeLdapOid



DWORD
CBerEncode::EncodeLdapDn(
    IN LDAPDN *Input,
    IN DWORD NewId /* = BER_INVALID_TAG */
    )
/*++

Routine Description:

    Create and store the BER encoding for the given LDAPDN structure.
    The parameter NewId can be added to give it a new tag.

Arguments:

    Input - the LDAPDN structure to encode
    NewId - the tag value to use (defaults to BER_INVALID_TAG to indicate
             that no value was given)

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = EncodeLdapString(Input, NewId);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;

} // EncodeLdapDn



DWORD
CBerEncode::EncodeLdapUrl(
    IN LDAPURL *Input,
    IN DWORD NewId /* = BER_INVALID_TAG */
    )
/*++

Routine Description:

    Create and store the BER encoding for the given LDAPURL structure.
    The parameter NewId can be added to give it a new tag.

Arguments:

    Input - the LDAPURL structure to encode
    NewId - the tag value to use (defaults to BER_INVALID_TAG to indicate
             that no value was given)

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD error;

    error = EncodeLdapString(Input, NewId);
    if ( error != ERROR_SUCCESS ) {
        return error;
    }
    
    return ERROR_SUCCESS;

} // EncodeLdapUrl



DWORD
CBerEncode::EncodeBeginSequence(
    IN DWORD NewId /* = BER_INVALID_TAG */
    )
/*++

Routine Description:

    Create and store the BER encoding for the beginning of a BER SEQUENCE.
    The parameter NewId can be added to give it a new tag.

Arguments:

    NewId - the tag value to use (defaults to BER_INVALID_TAG to indicate
             that no value was given)

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    int result;
    
    if ( NewId != BER_INVALID_TAG ) {

        // Since the base encoding will be constructed make sure that the new
        // tag reflects that.
        NewId = MakeBerId(GetBerClass(NewId),
                          BER_FORM_CONSTRUCTED,
                          GetBerTag(NewId));
        
        result = ber_printf(m_pBerElt, "t", NewId);
        if ( result == -1 ) {
            IF_DEBUG(ERROR) {
                DPRINT(0,"EncodeBeginSequence: ber_printf returned -1\n");
            }
            return ERROR_INVALID_PARAMETER;
        }
        
    }

    result = ber_printf(m_pBerElt, "{");
    if ( result == -1 ) {
        IF_DEBUG(ERROR) {
            DPRINT(0,"EncodeBeginSequence: ber_printf returned -1\n");
        }
        return ERROR_INVALID_PARAMETER;
    }

    return ERROR_SUCCESS;

} // EncodeBeginSequence



DWORD
CBerEncode::EncodeEndSequence(
    )
/*++

Routine Description:

    Create and store the BER encoding for the end of a BER SEQUENCE.
    The parameter NewId can be added to give it a new tag.

Arguments:

    None

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    int result;
    
    result = ber_printf(m_pBerElt, "}");
    if ( result == -1 ) {
        IF_DEBUG(ERROR) {
            DPRINT(0,"EncodeEndSequence: ber_printf returned -1\n");
        }
        return ERROR_INVALID_PARAMETER;
    }
    
    return ERROR_SUCCESS;

} // EncodeEndSequence



DWORD
CBerEncode::EncodeInteger(
    IN unsigned int *Input,
    IN DWORD NewId /* = BER_INVALID_TAG */
    )
/*++

Routine Description:

    Create and store the BER encoding for the given integer.
    The parameter NewId can be added to give it a new tag.

Arguments:

    Input - the integer to encode
    NewId - the tag value to use (defaults to BER_INVALID_TAG to indicate
             that no value was given)

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    int result;
    
    if ( NewId != BER_INVALID_TAG ) {

        NewId = MakeBerId(GetBerClass(NewId),
                          BER_FORM_PRIMITIVE,
                          GetBerTag(NewId));
        
        result = ber_printf(m_pBerElt, "t", NewId);
        if ( result == -1 ) {
            IF_DEBUG(ERROR) {
                DPRINT(0,"EncodeInteger: ber_printf returned -1\n");
            }
            return ERROR_INVALID_PARAMETER;
        }
        
    }

    result = ber_printf(m_pBerElt, "i", *Input);
    if ( result == -1 ) {
        IF_DEBUG(ERROR) {
            DPRINT(0,"EncodeInteger: ber_printf returned -1\n");
        }
        return ERROR_INVALID_PARAMETER;
    }
    
    return ERROR_SUCCESS;

} // EncodeInteger



DWORD
CBerEncode::EncodeBoolean(
    IN ossBoolean *Input,
    IN DWORD NewId /* = BER_INVALID_TAG */
    )
/*++

Routine Description:

    Create and store the BER encoding for the given boolean.
    The parameter NewId can be added to give it a new tag.

Arguments:

    Input - the boolean to encode
    NewId - the tag value to use (defaults to BER_INVALID_TAG to indicate
             that no value was given)

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    int result;
    
    if ( NewId != BER_INVALID_TAG ) {

        NewId = MakeBerId(GetBerClass(NewId),
                          BER_FORM_PRIMITIVE,
                          GetBerTag(NewId));
        
        result = ber_printf(m_pBerElt, "t", NewId);
        if ( result == -1 ) {
            IF_DEBUG(ERROR) {
                DPRINT(0,"EncodeBoolean: ber_printf returned -1\n");
            }
            return ERROR_INVALID_PARAMETER;
        }
        
    }

    if ( *Input == TRUE ) {
        result = ber_printf(m_pBerElt, "b", 0xFF);
    } else {
        result = ber_printf(m_pBerElt, "b", 0);
    }
    
    if ( result == -1 ) {
        IF_DEBUG(ERROR) {
            DPRINT(0,"EncodeBoolean: ber_printf returned -1\n");
        }
        return ERROR_INVALID_PARAMETER;
    }
    
    return ERROR_SUCCESS;

} // EncodeBoolean



DWORD
CBerEncode::EncodeOctetString(
    IN unsigned int *InputLength,
    IN unsigned char **InputValue,
    IN DWORD NewId /* = BER_INVALID_TAG */
    )
/*++

Routine Description:

    Create and store the BER encoding for the given octet string.
    The parameter NewId can be added to give it a new tag.

Arguments:

    InputLength - length of the octet string to encode
    InputValue - points to the bytes in the octet string to encode
    NewId - the tag value to use (defaults to BER_INVALID_TAG to indicate
             that no value was given)

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
{

    int result;
    
    if ( NewId != BER_INVALID_TAG ) {

        NewId = MakeBerId(GetBerClass(NewId),
                          BER_FORM_PRIMITIVE,
                          GetBerTag(NewId));
        
        result = ber_printf(m_pBerElt, "t", NewId);
        if ( result == -1 ) {
            IF_DEBUG(ERROR) {
                DPRINT(0,"EncodeOctetString: ber_printf returned -1\n");
            }
            return ERROR_INVALID_PARAMETER;
        }
        
    }

    result = ber_printf(m_pBerElt, "o", *InputValue, *InputLength);
    if ( result == -1 ) {
        IF_DEBUG(ERROR) {
            DPRINT(0,"EncodeOctetString: ber_printf returned -1\n");
        }
        return ERROR_INVALID_PARAMETER;
    }
    
    return ERROR_SUCCESS;

} // EncodeOctetString
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\ldap\command.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    command.cxx

Abstract:

    This module implements the LDAP server for the NT5 Directory Service.

    This file contains the code to process each LDAP operation. It has been
    seperated from userdata.cxx because this is where most of the NTDS specific
    parts of the LDAP_CONN class code is contained.


Author:

    Colin Watson     [ColinW]    09-Dec-1996

Revision History:

--*/

#include <NTDSpchx.h>
#pragma  hdrstop

#include "ldapsvr.hxx"

#define  FILENO FILENO_LDAP_COMMAND

#define LDAP_AUTH_REQUIRE  2

extern "C" {
#include "drsdra.h"
#include "mdlocal.h"
#include "drautil.h"
#include "dstrace.h"
#include "objids.h"

ULONG gulLdapIntegrityPolicy = 0;  // If this is set to 2 then the server will only accept
                                   // binds that have integrity checking turned
                                   // on.  i.e. digest or kerberos signing.
                                   // The variable is set by the LdapServerIntegrity
                                   // registry value in the NTDS\Parameters key

ULONG gulLdapPrivacyPolicy = 0;    // If this is set to 2 then the server will only accept
                                   // binds that have privacy (encryption) turned
                                   // on.  i.e. digest or kerberos sealing.
                                   // The variable is currently not set anywhere but
                                   // is here as a place holder.
    
#undef new
#undef delete
}

ATTRTYP gTTLAttrType = INVALID_ATT;

LDAPDN BindTypeDpa  = DEFINE_LDAP_STRING("DPA");
LDAPDN BindTypeNtlm = DEFINE_LDAP_STRING("NTLM");
LDAPDN BindTypeBoth = DEFINE_LDAP_STRING("NTLM;DPA");
LDAPDN BindTypeNone = DEFINE_LDAP_STRING("");

extern LDAPString NullMessage;

#define LDAP_AUTH_HAS_SIGNSEAL   0x1
#define LDAP_AUTH_HAS_NAME       0x2

//
// Called to check whether integrity checking is required on a connection.
//
__forceinline
_enum1
LDAP_CONN::DoCheckAuthRequirements ( LDAPString *pErrorMessage, DWORD dsid ) {
    if ( IsSSLOrTLS() ) {
        return success;
    }

    if ((LDAP_AUTH_REQUIRE == gulLdapIntegrityPolicy) && !m_fSign) {
        return DoSetLdapError( strongAuthRequired,
                               ERROR_DS_STRONG_AUTH_REQUIRED,
                               LdapIntegrityRequired,
                               0,
                               dsid,
                               pErrorMessage);
    }
    if ((LDAP_AUTH_REQUIRE == gulLdapPrivacyPolicy) && !m_fSeal) {
        return DoSetLdapError( strongAuthRequired,
                               ERROR_DS_STRONG_AUTH_REQUIRED,
                               LdapPrivacyRequired,
                               0,
                               dsid,
                               pErrorMessage);
    }
    return success;
}



void
LDAP_StopImpersonating (
        DWORD hClient,
        DWORD hServer,
        void * pImpersonateData
        )
{
    LDAP_CONN *pLdapConn=NULL;

    pTHStls->phSecurityContext = NULL;
    if(pImpersonateData) {
        LPLDAP_SECURITY_CONTEXT pTemp =
            (LPLDAP_SECURITY_CONTEXT)pImpersonateData;

        pTemp->DereferenceSecurity();
    }

    // find the related LDAP_CONN and stop the impersonation
    pLdapConn = FindUserData(hClient);

    if ( pLdapConn != NULL ) {
        pLdapConn->StopImpersonate();
        ReleaseUserData(pLdapConn);
    }

    return;

} // LDAP_StopImpersonating


BOOL
LDAP_PrepareToImpersonate (
        DWORD hClient,
        DWORD hServer,
        void ** ppImpersonateData
        )
{
    LDAP_CONN *pLdapConn=NULL;
    NOTIFYRES *pNotifyRes;

    //
    // For now, we're not copying the impersonation data.
    //

    *ppImpersonateData = NULL;

    pLdapConn = FindUserData(hClient);

    if ( pLdapConn != NULL ) {

        //
        // OK, LDAP is alive and the hClient maps to a known userdata object
        //

        pLdapConn->SetImpersonate(ppImpersonateData);
        ReleaseUserData(pLdapConn);

    } else {

        //
        // Didn't find a userdata for this one.  Send back an unregister.
        //

        DirNotifyUnRegister( hServer, &pNotifyRes);
        return FALSE;
    }

    return TRUE;
} // LDAP_PrepareToImpersonate


void
LDAP_ReceiveNotificationData (
        DWORD hClient,
        DWORD hServer,
        ENTINF *pEntinf
        )
{
    LDAP_CONN *pLdapConn=NULL;
    NOTIFYRES *pNotifyRes;

    pLdapConn = FindUserData(hClient);

    if ( pLdapConn != NULL ) {

        //
        // OK, LDAP is alive and the hClient maps to a known userdata object
        // Now, tell that object about the entinf
        //

        pLdapConn->ProcessNotification(hServer,pEntinf);
        ReleaseUserData(pLdapConn);

    } else {

        //
        // Didn't find a userdata for this one.  Send back an unregister.
        //

        DirNotifyUnRegister( hServer, &pNotifyRes);
    }

    return;

} // LDAP_ReceiveNotificationData

BOOL
IsNegotiateBlob(
    IN PSecBufferDesc     pInSecurityMessage
    )
/*++

Routine Description:

    This routine determines whether the blob passed is a negotiate blob
    or a native kerberos blob.  Note that a negotiate blob can enclose a
    kerberos blob (non native).

Arguments:

    pInSecurityMessage - Blob passed in by the client

Return Value:

    None.

--*/
{
    SECURITY_STATUS scRet;
    PSecPkgInfo pPkgInfo;

    //
    // Get the name of the blob.
    // !!!! Do not free the returned buffer !!!
    //

    scRet = SaslIdentifyPackage(pInSecurityMessage,
                                &pPkgInfo);

    if ( scRet == SEC_E_OK ) {

        IF_DEBUG(BIND) {
            DPRINT1(0,"Client sent us a %s blob.\n", pPkgInfo->Name);
        }

        //
        // Check if this is a kerberos blob
        //

        if ( _stricmp(pPkgInfo->Name, "Kerberos" ) == 0 ) {
            return FALSE;
        }

        Assert(_stricmp(pPkgInfo->Name, "Negotiate") == 0);

    } else {
        IF_DEBUG(ERROR) {
            DPRINT1(0,"SaslIdentifyPackage returned %x\n", scRet);
        }
    }

    //
    // either the call failed or the package is negotiate.
    // Return TRUE for either case.
    //

    return TRUE;

} // IsNegotiateBlob

_enum1
LDAP_CONN::SetSecurityContextAtts(
    IN  LPLDAP_SECURITY_CONTEXT pSecurityContext,
    IN  DWORD                   fContextAttributes,
    IN  DWORD                   flags,
    OUT LDAPString              *pErrorMessage
    )
/*++

Routine Description:

    This routine takes a security context and sets a number of the security
    related attributes on the connection.
    
Arguments:

    pSecurityContext - The context from which to set up the connection
    fContextAttributes - value returned from AcceptContext
    flags            - Some flags to specify options supported by the security
                       context.  Valid values are:
                       
                       LDAP_AUTH_HAS_SIGNSEAL - The context supports signing/sealing
                       LDAP_AUTH_HAS_NAME     - The context supports query for
                                                 the username.
    pErrorMessage    - Used to pass back an error message if there is an error.
    
Return Value:

    An _enum1 ldap error code.

--*/
{
    _enum1 code;

    //
    // Get the name of logged on user. Set the flag to indicate
    // that the username buffer was allocated by the
    // security package and should be freed accordingly.
    //
    if ( m_userName != NULL ) {
        if ( m_fUserNameSecAlloc) {
            FreeContextBuffer(m_userName);
        } else {
            LocalFree(m_userName);
        }
        m_userName = NULL;
    }

    if (LDAP_AUTH_HAS_NAME) {
        pSecurityContext->GetUserName(&m_userName);
        m_fUserNameSecAlloc = TRUE;
    }
    
    if (LDAP_AUTH_HAS_SIGNSEAL) {
        pSecurityContext->SetContextAttributes(fContextAttributes);

        if (IsSSLOrTLS() &&
            (pSecurityContext->NeedsSealing() ||
             pSecurityContext->NeedsSigning())) {
            code = SetLdapError(inappropriateAuthentication,
                                ERROR_DS_INAPPROPRIATE_AUTH,
                                LdapNoSigningSealingOverTLS,
                                0,
                                pErrorMessage);
            ZapSecurityContext();
            return code;

        }
        if ( pSecurityContext->NeedsSigning() ) {
            IF_DEBUG(SSL) {
                DPRINT1(0,"Signing is active on connection %p\n",this);
            }
            m_fSign =TRUE;
        }

        if ( pSecurityContext->NeedsSealing() ) {

            IF_DEBUG(SSL) {
                DPRINT1(0,"Sealing is active on connection %p\n",this);
            }
            m_fSeal = TRUE;
            m_cipherStrength = pSecurityContext->GetSealingCipherStrength();
            IF_DEBUG(SSL) {
                DPRINT1(0, "Setting sealing cipher strength to %d.\n", m_cipherStrength);
            }
        }
    }

    //
    // If encryption of some type is required find out if
    // we got it now.
    //
    code = CheckAuthRequirements(pErrorMessage);
    if (code) {
        return code;
    }

    return success;
}


VOID
LDAP_CONN::SetImpersonate(
        void **ppData
        )
{
    THSTATE *pTHS = pTHStls;
    //
    //  Set so that the DS can impersonate this client
    //

    if(m_pSecurityContext) {
        pTHS->phSecurityContext = m_pSecurityContext->GetSecurityContext();
        *ppData = (void *)m_pSecurityContext;
    }
    else {
        pTHS->phSecurityContext = NULL;
    }

    // put our client context on the Thread state
    EnterCriticalSection(&m_csClientContext);
    __try {
        AssignAuthzClientContext(&pTHS->pAuthzCC, m_clientContext);
    }
    __finally {
        LeaveCriticalSection(&m_csClientContext);
    }
    
    return;
}

VOID
LDAP_CONN::StopImpersonate(
        void
        )
{
    THSTATE *pTHS = pTHStls;

    // we were not in a bind. Remove client context from the thread state
    AssignAuthzClientContext(&pTHS->pAuthzCC, NULL);
}

VOID
LDAP_CONN::ProcessNotification(
        IN ULONG hServer,
        IN ENTINF *pEntInf
        )
{
    SearchResultFull_  fullResult;
    SearchResultEntry Entry;
    CONTROLS_ARG      Controls;
    PLDAP_REQUEST     request = NULL;
    DWORD             rc;
    MessageID         messageID;
    THSTATE           *pTHS=pTHStls;
    LDAPString        errMsg, matchedDN;

    //
    // Find the messageID that goes with this hServer
    //

    if(!fGetMessageIDForNotifyHandle(hServer, &messageID)) {
        // We don't seem to have this handle.  Go home.
        return;
    }

    IF_DEBUG(NOTIFICATION) {
        DPRINT1(0,"ProcessNotification called for id %x\n", messageID);
    }

    memset(&Controls, 0, sizeof(CONTROLS_ARG));
    InitCommarg(&Controls.CommArg);

    // OK, first translate the EntInf into a search result looking thing.
    if(LDAP_EntinfToSearchResultEntry (
            pTHS,
            m_CodePage,
            pEntInf,
            NULL,
            NULL,
            &Controls,
            &Entry)) {
        // Hmm.  Failed.  Oh well, no return path to give this to anyone.
        return;
    }

    // Now, get a request object
    request = LDAP_REQUEST::Alloc(m_atqContext,this);
    if (request == NULL) {
        IF_DEBUG(NOMEM) {
            DPRINT(0,"Unable to allocate request to send notification\n");
        }

        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_ATQ_CLOSE_SOCKET_ERROR,
                 szInsertUL(ERROR_NOT_ENOUGH_MEMORY),
                 szInsertHex(DSID(FILENO,__LINE__)),
                 szInsertUL(m_dwClientID));
        return;
    }

    //
    // init parameters
    //

    request->m_MessageId = messageID;

    errMsg.length = 0;
    errMsg.value = NULL;

    matchedDN.length = 0;
    matchedDN.value = NULL;

    fullResult.next = NULL;
    fullResult.value.choice = entry_chosen;
    fullResult.value.u.entry = Entry;

    // Ok, send it.
    if (rc = EncodeSearchResult(request,
                                this,
                                &fullResult,
                                success,
                                NULL,       // referrals
                                NULL,       // controls
                                &errMsg,
                                &matchedDN,
                                1,
                                TRUE) ) {

        IF_DEBUG(WARNING) {
            DPRINT1(0,"Error %d encoding notification result\n",rc);
        }

        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_ATQ_CLOSE_SOCKET_ERROR,
                 szInsertUL(rc),
                 szInsertHex(DSID(FILENO,__LINE__)),
                 szInsertUL(m_dwClientID));

        DereferenceAndKillRequest(request);
        return;
    }

    //
    // Add a reference to handle the write completion we're gonna get.
    //

    if (request->Send(m_fUDP,&m_hSslSecurityContext)) {
        Assert(MSGIDS_BUFFER_SIZE > m_MsgIdsPos);

        // Record the completion of this msgId.
        EnterCriticalSection(&m_csLock);

        m_MsgIds[m_MsgIdsPos++] = messageID;

        if (MSGIDS_BUFFER_SIZE <= m_MsgIdsPos) {
            m_MsgIdsPos = 0;
        }

        LeaveCriticalSection(&m_csLock);

        return;
    }

    //
    // Well, we don't need this reference, we're not going to get a completion
    //

    rc= GetLastError();
    IF_DEBUG(NOTIFICATION) {
        DPRINT1(0, "AtqWriteFile failed %d\n", rc);
    }

    // Yes, an error occurred, we're abandoning the socket.
    LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
             DS_EVENT_SEV_BASIC,
             DIRLOG_ATQ_CLOSE_SOCKET_ERROR,
             szInsertUL(rc),
             szInsertHex(DSID(FILENO,__LINE__)),
             szInsertUL(m_dwClientID));

    Disconnect( );
    DereferenceAndKillRequest(request);

    return;
} // ProcessNotification


_enum1
LDAP_CONN::BindRequest(
        IN THSTATE *pTHS,
        IN PLDAP_REQUEST request,
        IN LDAPMsg* pMessage,
        OUT AuthenticationChoice *pServerCreds,
        OUT LDAPString *pErrorMessage,
        OUT LDAPDN *pMatchedDN
    )
/*++

Routine Description:

    This routine processes a simple bind request.

Arguments:

    request     - Object used to track this transaction.

    pMessage    - Decoded message from client.

Return Value:

    None.

--*/
{

    SECURITY_STATUS scRet = STATUS_UNSUCCESSFUL;
    SEC_WINNT_AUTH_IDENTITY_A Credentials;
    SecBufferDesc     InSecurityMessage;
    SecBuffer         InSecurityBuffer;
    SecBufferDesc     OutSecurityMessage;
    SecBuffer         OutSecurityBuffer;

    DWORD             dwException;
    ULONG             ulErrorCode;
    ULONG             dsid;
    PVOID             dwEA;
    _enum1            code;
    DWORD             fContextAttributes = 0;
    DWORD             dwSecContextFlags = 0;
    TimeStamp         tsTimeStamp, tsHardExpiry;
    BOOL              fDidOne = FALSE;
    BOOL              fBindComplete = TRUE;
    BOOL              fDigestSASL = FALSE;
    BOOL              fNegoSASL = FALSE;
    BOOL              fFastBind = FALSE;
    BOOL              fNTLM     = FALSE;
    PWCHAR            pwchName;

    USHORT            Version;
    ULONG             CodePage;
    BOOL              fSimple = FALSE;
    BOOL              fUsingSSLCreds = FALSE;

    LPLDAP_SECURITY_CONTEXT pTmpSecurityContext;

// save typing.
#define BINDREQUEST  pMessage->protocolOp.u.bindRequest

    IF_DEBUG(BIND) {
        DPRINT1(0,"BindRequest @ %08lX.\n", request);
    }

    StartBindTimer();
    
    OutSecurityBuffer.pvBuffer = NULL;

    if ( NULL == m_pPartialSecContext ) {

        //
        // Log bind attempt
        //

        LogAndTraceEvent(FALSE,
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_BEGIN_LDAP_BIND,
                         EVENT_TRACE_TYPE_START,
                         DsGuidLdapBind,
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
    }

    __try {

        pMatchedDN->length = 0;
        pMatchedDN->value = NULL;
        pServerCreds->choice = 0;

        if (m_fFastBindMode) {
            fFastBind = TRUE;
        }

        Version = BINDREQUEST.version;
        switch(Version) {
        case 2:
            CodePage = CP_ACP;
            break;

        case 3:
            CodePage = CP_UTF8;
            break;

        default:
            // Huh?
            code = SetLdapError(protocolError,
                                ERROR_INVALID_PARAMETER,
                                LdapBadVersion,
                                Version,
                                pErrorMessage);

            Version = 3;
            CodePage = CP_UTF8;
            goto ExitTry;
        }

        IF_DEBUG(BIND) {
            DPRINT1( 0, "LDAP V%d client. ", Version);
        }

        memset(&Credentials, 0, sizeof(Credentials));

        if (fFastBind && simple_chosen != BINDREQUEST.authentication.choice) {
            code = SetLdapError(unwillingToPerform,
                                ERROR_DS_INAPPROPRIATE_AUTH,
                                LdapBadFastBind,
                                0,
                                pErrorMessage);

            goto ExitTry;
        }

        switch (BINDREQUEST.authentication.choice) {
        case simple_chosen:

            IF_DEBUG(BIND) {
                DPRINT(0,"simple bind chosen.\n");
            }

            //
            // We already know that a simple bind will not result in any 
            // encryption.  Check if that's ok and bail if not.
            //
            code = CheckAuthRequirements(pErrorMessage);
            if (code) {
                goto ExitTry;
            }

            Credentials.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

            if (BINDREQUEST.name.length != 0) {

                // Turn the LDAPDN passed in to us into a
                code = LDAP_MakeSimpleBindParams(
                        CodePage,
                        &BINDREQUEST.name,
                        (LDAPString *)&BINDREQUEST.authentication.u.simple,
                        &Credentials);

                if( code )  {
                    IF_DEBUG(BIND) {
                        DPRINT1(0,"MakeSimpleBindParams failed with %d\n", code);
                    }

                    code = SetLdapError(code,
                                        GetLastError(),
                                        LdapBadName,
                                        0,
                                        pErrorMessage);
                    goto ExitTry;
                }
            }

            code = success;

            if (fhCredential &&        // We have this provider loaded
                (Credentials.UserLength != 0) || // they gave us a name
                (Credentials.PasswordLength != 0 )) {

                InSecurityMessage.ulVersion = SECBUFFER_VERSION;
                InSecurityMessage.cBuffers = 1;
                InSecurityMessage.pBuffers = &InSecurityBuffer;

                InSecurityBuffer.cbBuffer = sizeof(SEC_WINNT_AUTH_IDENTITY_A);
                InSecurityBuffer.BufferType = SECBUFFER_TOKEN;

                InSecurityBuffer.pvBuffer = &Credentials;

                pTmpSecurityContext = new LDAP_SECURITY_CONTEXT(FALSE, fFastBind ? TRUE : FALSE);

                if ( pTmpSecurityContext == NULL ) {
                    IF_DEBUG(NOMEM) {
                        DPRINT(0,"Unable to allocate security context\n");
                    }
                    scRet = SEC_E_INSUFFICIENT_MEMORY;
                } else {
                    
                    TimeStamp tsExpiry;

                    scRet = pTmpSecurityContext->AcceptContext(
                        &hCredential,
                        &InSecurityMessage,
                        fFastBind ? ASC_REQ_ALLOW_NON_USER_LOGONS : 0,
                        0,
                        NULL,
                        NULL,
                        &tsExpiry,
                        NULL);

                    //
                    // The expiry returned here seems to be bogus so make one up.
                    //
                    tsHardExpiry.QuadPart = MAXLONGLONG;
                    tsTimeStamp = tsHardExpiry;
                }

                if(FAILED(scRet)) {

                    if ( pTmpSecurityContext != NULL ) {
                        delete pTmpSecurityContext;
                        pTmpSecurityContext = NULL;
                    }


                    code = SetLdapError(invalidCredentials,
                                        scRet,
                                        LdapAscErr,
                                        GetLastError(),
                                        pErrorMessage);
                    IF_DEBUG(BIND) {
                        if (fFastBind) {
                            DPRINT1(0, "Fast Bind Failed with 0x%x.\n", scRet);
                        }
                    }
                } else {

                    if (!fFastBind) {
                        ZapPartialSecContext();
                        m_pPartialSecContext = pTmpSecurityContext;
                        fSimple = TRUE;
                        
                        pwchName = (PWCHAR)LocalAlloc(LPTR,
                                               (Credentials.UserLength+1) * sizeof(WCHAR));

                        if ( pwchName != NULL ) {
                            wcscpy(pwchName, (PWCHAR)Credentials.User);
                        }

                    } else {
                        IF_DEBUG(BIND) {
                            DPRINT(0, "Fast Bind Succeeded\n");
                        }
                        // Don't need this anymore since we're doing fast binds.
                        delete pTmpSecurityContext;
                        pTmpSecurityContext = NULL;
                    }
                }
            }
            else {

                //
                //  Either we don't have this provider loaded or they gave us
                //  no username or password supplied so use the null sessiona
                //  account.
                //

                IF_DEBUG(BIND) {
                    DPRINT(0,"Using NULL session account\n");
                }
            }
            break;

        case sasl_chosen:

            IF_DEBUG(BIND) {
                DPRINT(0,"sasl chosen\n");
            }

            if(fhGssCredential &&
               ( ((BINDREQUEST.authentication.u.sasl.mechanism.length == 6 ) &&
                  (memcmp(BINDREQUEST.authentication.u.sasl.mechanism.value,
                       "GSSAPI", 6) == 0) )
                 ||

                 ((BINDREQUEST.authentication.u.sasl.mechanism.length == 10 ) &&
                  ((memcmp(BINDREQUEST.authentication.u.sasl.mechanism.value,
                        "GSS-SPNEGO", 10) == 0) ) ) )
                ) {

                fNegoSASL = TRUE;
            } else if (fhDigestCredential &&
                ( ((BINDREQUEST.authentication.u.sasl.mechanism.length == 10 ) &&
                   (memcmp(BINDREQUEST.authentication.u.sasl.mechanism.value,
                        "DIGEST-MD5", 10) == 0) ) )
                ) {
                IF_DEBUG(BIND) {
                    DPRINT(0, "Received a Digest bind request.\n");
                }
                fDigestSASL = TRUE;
            }

            if (fNegoSASL || fDigestSASL) {
            

                InSecurityMessage.ulVersion = SECBUFFER_VERSION;
                InSecurityMessage.cBuffers = 1;
                InSecurityMessage.pBuffers = &InSecurityBuffer;

                InSecurityBuffer.cbBuffer =
                   BINDREQUEST.authentication.u.sasl.credentials.length;
                InSecurityBuffer.BufferType = SECBUFFER_TOKEN;
                InSecurityBuffer.pvBuffer =
                   BINDREQUEST.authentication.u.sasl.credentials.value;

                OutSecurityMessage.ulVersion = SECBUFFER_VERSION;
                OutSecurityMessage.cBuffers = 1;
                OutSecurityMessage.pBuffers = &OutSecurityBuffer;

                //  SSPI will allocate buffer of correct size
                OutSecurityBuffer.cbBuffer = 0;
                OutSecurityBuffer.BufferType = SECBUFFER_TOKEN;
                OutSecurityBuffer.pvBuffer = NULL;

                //
                // There is a bug in pre B3RC3 servers/clients where we send
                // back a wrongly formatted Bind response. We need to keep
                // sending the bogus response to old clients and send the
                // correct LDAPv3 response to new ones.
                //
                // We return the LDAP v3 response if
                //  1) If the client negotiates with GSS-SPNEGO
                //  2) If the client negotiates with GSSAPI but uses native
                //      kerberos and not the earlier negotiate blobs
                //
                // Also we use add an extra round trip for the GSSAPI exchange
                // to be compliant with the spec. We will use the new API
                // SASLAcceptSecurityContext if the client negotiates with
                // GSSAPI AND uses a native kerberos blob (instead of the old
                // negotiate blob).
                //

                if (m_pPartialSecContext == NULL ) {

                    BOOL fSasl = FALSE;
                    BOOL fGssApi = FALSE;
                    BOOL fUseV3Response = FALSE;

                    if ( BINDREQUEST.authentication.u.sasl.mechanism.length != 10 ) {

                        fGssApi = TRUE;

                        //
                        // See if we need to send the new response type. If we do,
                        // we also negotiate SASL
                        //

                        if ( !IsNegotiateBlob(&InSecurityMessage) ) {

                            fSasl = TRUE;
                            fUseV3Response = TRUE;

                            IF_DEBUG(BIND) {
                                DPRINT(0,"Client using GSSAPI with Kerberos Blob.\n");
                            }
                        } else {
                            IF_DEBUG(BIND) {
                                DPRINT(0,"Client using GSSAPI with Negotiate Blob.\n");
                            }
                        }

                    } else {
                        IF_DEBUG(BIND) {
                            DPRINT(0,"Client using SPNEGO\n");
                        }
                        fUseV3Response = TRUE;
                    }

                    //
                    // request SASL if this is a new client and not SPNEGO
                    //

                    m_pPartialSecContext = new LDAP_SECURITY_CONTEXT(fSasl);

                    if ( m_pPartialSecContext != NULL ) {
                        if ( fGssApi ) {
                            m_pPartialSecContext->SetGssApi( );
                        }
                        if ( fUseV3Response ) {
                            IF_DEBUG(BIND) {
                                DPRINT(0,"Client expecting v3 bind response\n");
                            }
                            m_pPartialSecContext->SetUseLdapV3Response( );
                        }
                    } else {
                        IF_DEBUG(NOMEM) {
                            DPRINT(0,"Cannot allocate a security context for SASL\n");
                        }
                        scRet = SEC_E_INSUFFICIENT_MEMORY;
                    }
                }

                if ( m_pPartialSecContext != NULL ) {

                    DWORD ContextReqs;

                    ContextReqs = ASC_REQ_CONFIDENTIALITY |
                                  ASC_REQ_INTEGRITY       |
                                  ASC_REQ_ALLOCATE_MEMORY;

                    if (fNegoSASL) {
                        ContextReqs |= ASC_REQ_MUTUAL_AUTH;
                    }

                    scRet = m_pPartialSecContext->AcceptContext(
                        fDigestSASL ? &hDigestCredential : &hGssCredential,
                        &InSecurityMessage,
                        ContextReqs,
                        0,
                        &OutSecurityMessage,
                        &fContextAttributes,
                        &tsTimeStamp,
                        &tsHardExpiry );

                    IF_DEBUG(BIND) {
                        DPRINT1(0, "Accept Context returned 0x%x\n", scRet);
                    }
                }

                switch(scRet) {
                case SEC_I_CONTINUE_NEEDED:
                case STATUS_SUCCESS:

                    //
                    //  Need to send data back as next step in multi-leg
                    //  authentication.
                    //

                    pServerCreds->choice = sasl_chosen;
                    pServerCreds->u.sasl.mechanism.length =  sizeof("GSSAPI")-1;
                    pServerCreds->u.sasl.mechanism.value =
                        (unsigned char *)&"GSSAPI";
                    pServerCreds->u.sasl.credentials.length =
                        OutSecurityBuffer.cbBuffer;
                    pServerCreds->u.sasl.credentials.value =
                        (unsigned char *)THAllocEx(pTHS,
                                OutSecurityBuffer.cbBuffer);
                    memcpy(pServerCreds->u.sasl.credentials.value,
                           (unsigned char *)OutSecurityBuffer.pvBuffer,
                           OutSecurityBuffer.cbBuffer);

                    if ( m_pPartialSecContext->UseLdapV3Response() ) {

                        pServerCreds->choice = sasl_v3response_chosen;

                    }
                    
                    if ( scRet == STATUS_SUCCESS ) {

                        dwSecContextFlags = LDAP_AUTH_HAS_SIGNSEAL |
                                               LDAP_AUTH_HAS_NAME;

                        
                        code = success;
                    } else {
                        code = saslBindInProgress;
                        fBindComplete = FALSE;
                    }

                    break;

                case SEC_E_INSUFFICIENT_MEMORY:

                    code = SetLdapError(unavailable,
                                        scRet,
                                        LdapAscErr,
                                        GetLastError(),
                                        pErrorMessage);

                    break;

                default:
                    code = SetLdapError(invalidCredentials,
                                        scRet,
                                        LdapAscErr,
                                        GetLastError(),
                                        pErrorMessage);

                    break;
                }
            } else if ( ((BINDREQUEST.authentication.u.sasl.mechanism.length == 8 ) &&
                  (memcmp(BINDREQUEST.authentication.u.sasl.mechanism.value,
                       "EXTERNAL", 8) == 0) &&
                         (BINDREQUEST.authentication.u.sasl.credentials.length == 0) &&
                         IsTLS() )) {

                // Since we got here, the client is requesting an implicit external bind, meaning
                // they didn't supply any credentials and they expect all of the credentials to 
                // be supplied by the tls negotiation.  We don't support explicit external binds
                // since that involves just supplying a username in the bind credentials.

                // In addition there is no need to check auth requirements here
                // since if this bind succeeds we must be doing some kind of 
                // encryption for TLS.

                IF_DEBUG(SSL) {
                    DPRINT(0, "Doing TLS External bind.\n");
                }

                if (GetSslClientCertToken()) {

                    m_pPartialSecContext->GetHardExpiry( &tsTimeStamp );

                    tsHardExpiry = tsTimeStamp;
                    fUsingSSLCreds = TRUE;

                    code = success;

                } else {
                    IF_DEBUG(SSL) {
                        DPRINT(0, "External bind attempted without any TLS client creds.\n");
                    }

                    code = SetLdapError(invalidCredentials,
                                        SEC_E_LOGON_DENIED,
                                        LdapNoTLSCreds,
                                        0,
                                        pErrorMessage);
                }
            } else {
                IF_DEBUG(BIND) {
                    if ( fhGssCredential ) {
                        DPRINT(0,"Invalid mechanism requested by client\n");
                    } else {
                        DPRINT(0,"Gss package not loaded.\n");
                    }
                }
                code = SetLdapError(inappropriateAuthentication,
                                    ERROR_DS_INAPPROPRIATE_AUTH,
                                    LdapBadAuth,
                                    0,
                                    pErrorMessage);
            }
            break;

        case sicilyNegotiate_chosen:

            // Return list of authentication type supported.  Note that
            // the client is unbound and remains unbound during this call

            // We don't actually need anything out of the bindrequest.

            code = success;
            if(fhNtlmCredential) {
                if(fhDpaCredential) {
                    *pMatchedDN = BindTypeBoth;
                }
                else {
                    *pMatchedDN = BindTypeNtlm;
                }
            }
            else if(fhDpaCredential) {
                *pMatchedDN = BindTypeDpa;
            }
            else {
                *pMatchedDN = BindTypeNone;
                code = SetLdapError(inappropriateAuthentication,
                                    ERROR_DS_INAPPROPRIATE_AUTH,
                                    LdapBadAuth,
                                    0,
                                    pErrorMessage);
            }

            IF_DEBUG(BIND) {
                DPRINT1(0,"sicily negotiate chosen. Bind type %s\n",
                       pMatchedDN->value);
            }

            break;

        case sicilyInitial_chosen:

            IF_DEBUG(BIND) {
                DPRINT(0,"sicily initial chosen\n");
            }

            // If we're partially bound, unbind, since this choice
            // means to start from scratch.
            ZapPartialSecContext();
            
            // Fall through
        case sicilySubsequent_chosen:

            IF_DEBUG(BIND) {
                DPRINT(0,"sicily subsequent chosen\n");
            }

            // Build up structures used
            InSecurityMessage.ulVersion = SECBUFFER_VERSION;
            InSecurityMessage.cBuffers = 1;
            InSecurityMessage.pBuffers = &InSecurityBuffer;

            InSecurityBuffer.cbBuffer =
                BINDREQUEST.authentication.u.sicilyInitial.length;
            InSecurityBuffer.BufferType = SECBUFFER_TOKEN;
            InSecurityBuffer.pvBuffer =
                BINDREQUEST.authentication.u.sicilyInitial.value;

            OutSecurityMessage.ulVersion = SECBUFFER_VERSION;
            OutSecurityMessage.cBuffers = 1;
            OutSecurityMessage.pBuffers = &OutSecurityBuffer;

            //  SSPI will allocate buffer of correct size
            OutSecurityBuffer.cbBuffer = 0;
            OutSecurityBuffer.BufferType = SECBUFFER_TOKEN;
            OutSecurityBuffer.pvBuffer = NULL;

            if(!(memcmp(BINDREQUEST.authentication.u.sicilyInitial.value,
                        "NTLMSSP", 7)) &&
               (fhNtlmCredential)) {
                // See they wanted NTLM, we support it.
                fDidOne = TRUE;
                fNTLM   = TRUE;
                if(!m_pPartialSecContext) {
                    m_pPartialSecContext = new LDAP_SECURITY_CONTEXT(FALSE);
                }

                if ( m_pPartialSecContext == NULL ) {
                    scRet = SEC_E_INSUFFICIENT_MEMORY;
                } else {

                    scRet = m_pPartialSecContext->AcceptContext(
                        &hNtlmCredential,
                        &InSecurityMessage,
                        ASC_REQ_ALLOCATE_MEMORY,
                        0,
                        &OutSecurityMessage,
                        &fContextAttributes,
                        &tsTimeStamp,
                        &tsHardExpiry );
                }
            }
            else if(!(memcmp(BINDREQUEST.authentication.u.sicilyInitial.value,
                             "DPASSP", 6)) &&
                    (fhDpaCredential)) {
                // They want DPA, we have it.
                fDidOne = TRUE;
                if(!m_pPartialSecContext) {
                    m_pPartialSecContext = new LDAP_SECURITY_CONTEXT(FALSE);
                }

                if ( m_pPartialSecContext == NULL ) {
                    scRet = SEC_E_INSUFFICIENT_MEMORY;
                } else {
                    scRet = m_pPartialSecContext->AcceptContext(
                        &hDpaCredential,
                        &InSecurityMessage,
                        ASC_REQ_ALLOCATE_MEMORY,
                        0,
                        &OutSecurityMessage,
                        &fContextAttributes,
                        &tsTimeStamp,
                        &tsHardExpiry );
                }
            }

            if(fDidOne) {
                switch(scRet) {
                case STATUS_SUCCESS:
                    // OK!

                    if (fNTLM) {
                        dwSecContextFlags =  LDAP_AUTH_HAS_SIGNSEAL |
                                               LDAP_AUTH_HAS_NAME;
                    }

                    code = success;

                    break;
                case SEC_I_CONTINUE_NEEDED:
                    //
                    //  Need to send data back as next step in multi-leg
                    //  authentication.
                    //

                    pMatchedDN->length = OutSecurityBuffer.cbBuffer;
                    pMatchedDN->value =
                        (unsigned char *)THAllocEx(pTHS,
                                                   OutSecurityBuffer.cbBuffer);
                    memcpy(pMatchedDN->value,
                           (unsigned char *)OutSecurityBuffer.pvBuffer,
                           OutSecurityBuffer.cbBuffer);

                    fBindComplete = FALSE;
                    code = success;
                    break;
                default:

                    code = SetLdapError(invalidCredentials,
                                        scRet,
                                        LdapAscErr,
                                        GetLastError(),
                                        pErrorMessage);
                    break;
                }
            }
            else {
                // Can't do whatever it is they want.
                code = SetLdapError(inappropriateAuthentication,
                                    ERROR_DS_INAPPROPRIATE_AUTH,
                                    LdapBadAuth,
                                    0,
                                    pErrorMessage);

            }
            break;
        default:

            IF_DEBUG(WARNING) {
                DPRINT1(0,"Unknown authentication choice %d\n",
                    BINDREQUEST.authentication.choice);
            }

            code = SetLdapError(authMethodNotSupported,
                                ERROR_DS_AUTH_METHOD_NOT_SUPPORTED,
                                LdapBadAuth,
                                0,
                                pErrorMessage);

            break;
        }
    ExitTry:;
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        code = LDAP_HandleDsaExceptions(dwException, ulErrorCode, pErrorMessage);

    }

    StopBindTimer();

    if ( fBindComplete && !fFastBind) {

        MoveSecurityContext(request);
        
        if (code) {
            ZapSecurityContext();
        } else {
            
            // Zap the context but don't zap the partial context it can
            // be moved to be the primary context.
            ZapSecurityContext(FALSE);
            m_pSecurityContext = m_pPartialSecContext;
            m_pPartialSecContext = NULL;

            ExposeBindPerformance();

            if (m_pSecurityContext) {
                code = SetSecurityContextAtts(m_pSecurityContext,
                                              fContextAttributes,
                                              dwSecContextFlags,
                                              pErrorMessage);

                if (code) {
                    ZapSecurityContext();
                }

                if (!code) {
                    //
                    // set the timeouts
                    //

                    SetContextTimeouts(&tsTimeStamp, &tsHardExpiry);

                    if (fNegoSASL) {
                        if ( m_pSecurityContext->IsGssApi() ) {
                            m_fGssApi = TRUE;
                        } else if ( fDigestSASL ) {
                            m_fDigest = TRUE;
                        } else {                            
                            m_fSpNego = TRUE;
                        }
                    }

                    if (fUsingSSLCreds) {
                        SetUsingSSLCreds();
                    }

                    if (fSimple) {
                        m_userName = pwchName;
                    }

                    m_Version      = Version;
                    m_CodePage     = CodePage;
                    m_fSimple      = fSimple;                

                    // Find out if this is an admin.  For use
                    // if we run out of connections and need
                    // to bump some.
                    SetIsAdmin(pTHS);

                }
            }

            //
            // If encryption of some type is required find out if
            // we got it now.
            //
            code = CheckAuthRequirements(pErrorMessage);
        }


        LogAndTraceEvent(FALSE,
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_END_LDAP_BIND,
                         EVENT_TRACE_TYPE_END,
                         DsGuidLdapBind,
                         szInsertUL(scRet),
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL);

    } else if ( code ) {
        ResetBindTimer();
    }

    if (OutSecurityBuffer.pvBuffer) {
        FreeContextBuffer(OutSecurityBuffer.pvBuffer);
    }

    if (fFastBind) {
        //
        // This was a fast bind.  There shouldn't be any security context.
        //
        Assert(NULL == m_pSecurityContext);
        ZapSecurityContext();
        
        //
        // If encryption of some type is required find out if
        // we got it now.
        //
        code = CheckAuthRequirements(pErrorMessage);
    }
    
    //
    // Reset network buffer options in case our encryption state has changed.
    //
    SetNetBufOpts(m_pSecurityContext);

    IF_DEBUG(BIND) {
        DPRINT1(0 , "Bind Request complete, sending response to client. code = %d\n", code);
    }

    return (_enum1)code;

}   // BindRequest


_enum1
LDAP_CONN::SearchRequest(
        IN  THSTATE *pTHS,
        OUT BOOL    *pNoReturn,
        IN PLDAP_REQUEST request,
        IN  LDAPMsg* pMessage,
        OUT Referral *ppReferral,
        OUT Controls *ppControls_return,
        OUT LDAPString *pErrorMessage,
        OUT LDAPDN *pMatchedDN
    )
/*++

Routine Description:

    This routine processes a search request.

Arguments:

    request     - Object used to track this transaction.

    pMessage    - Decoded message from client.

Return Value:

    None.

--*/
{
    ATTFLAG                     *pFlags;
    SEARCHARG                   SearchArg;
    SearchResultFull_           *result_return=NULL;
    SEARCHRES                   *pSearchRes = NULL;
    CONTROLS_ARG                ControlArg;
    DWORD                       dwException;
    ULONG                       ulErrorCode;
    ULONG                       dsid;
    DWORD                       objectCount = 0;
    PVOID                       dwEA;
    DWORD                       starttime;
    error_status_t              dscode;
    _enum1                      code = success;
    BOOL                        bSendNoResponse=FALSE;
    RANGEINFSEL                 SelectionRange;
    DRS_MSG_GETCHGREPLY_NATIVE  msgOut;
    RootDseFlags                rootDseFlag;

    struct SearchRequest* searchRequest =
                &pMessage->protocolOp.u.searchRequest;


    IF_DEBUG(SEARCH) {
        DPRINT1( 0, "SearchRequest @ %08lX.\n", request);
    }

    PERFINC(pcLDAPSearchPerSec);
    *ppControls_return = NULL;

    ZeroMemory(&ControlArg, sizeof(CONTROLS_ARG));
    InitCommarg(&ControlArg.CommArg);

    //
    // Translate the LDAPMsg to a SearchArg and make the core call
    //

    __try {

        *pNoReturn = FALSE;
        *ppReferral = NULL;

        ZeroMemory(&SearchArg, sizeof(SEARCHARG));

        // Initialize output parameters
        starttime = GetTickCount();

        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                 DS_EVENT_SEV_INTERNAL,
                 DIRLOG_API_TRACE,
                 szInsertSz("ldap_search"),
                 NULL,
                 NULL);


        // Normal search, build the parameters.

        // Get the distinguished name of the base of the search
        code = LDAP_LDAPDNToDSName(
                m_CodePage,
                &searchRequest->baseObject,
                &SearchArg.pObject );

        if( code )  {
            code = SetLdapError(code,
                                DIRERR_BAD_NAME_SYNTAX,
                                LdapBadName,
                                0,
                                pErrorMessage);
            _leave;
        }

        //
        // If this is a <SID=> search, make sure it did not come in
        // through the GC port. We are adding this restriction because the
        // DS currently does not support SID based searches on other domains.
        // But the client expects the GC to be able to give that result back.
        // Hence. This change.
        //

        if ( (SearchArg.pObject->SidLen != 0) && m_fGC ) {

            IF_DEBUG(ERR_NORMAL) {
                DPRINT(0,"SID based searches not allowed through the GC port\n");
            }

            code = SetLdapError(unwillingToPerform,
                                ERROR_DS_UNWILLING_TO_PERFORM,
                                LdapGcDenied,
                                0,
                                pErrorMessage);
            _leave;
        }

        // First, fill in the ControlArg based on the message.  We do this
        // inside the critical section since we might adjust the cookie.
        EnterCriticalSection(&m_csLock);
        __try {
            code = LDAP_SearchMessageToControlArg(
                    this,
                    pMessage,
                    request,
                    &ControlArg);
        }
        __finally {
            LeaveCriticalSection(&m_csLock);
        }

        if( code ) {
            if (!pTHS->errCode) {
                pTHS->errCode = ERROR_INVALID_PARAMETER;
            }

            code = SetLdapError(code,
                                    pTHS->errCode,
                                    LdapBadControl,
                                    0,
                                    pErrorMessage);
            _leave;
        }

        SearchArg.choice = ControlArg.Choice;
        SearchArg.CommArg = ControlArg.CommArg;

        // get the filter
        code = LDAP_FilterToDirFilter(
                pTHS,
                m_CodePage,
                &ControlArg.CommArg.Svccntl,
                &searchRequest->filter,
                &SearchArg.pFilter );
        if( code  ) {
            code = SetLdapError(code,
                                ERROR_INVALID_PARAMETER,
                                LdapBadFilter,
                                0,
                                pErrorMessage);
            _leave;
        }

        // if this is a root DSE search, just fill up
        // the constructed atts in the ControlArg,

        if((searchRequest->baseObject.length == 0) &&
                (searchRequest->scope == baseObject)   ) {

            //
            // They want operational atts.
            // ldap return error string also handled by the routine
            //

            code = LDAP_GetDSEAtts(
                    this,
                    &ControlArg,
                    searchRequest,
                    &result_return,
                    pErrorMessage,
                    &rootDseFlag);

            request->SetDseFlag(rootDseFlag);

        } else {

            //
            // only search operation allowed on UDP is a root DSE search
            //

            if ( m_fUDP ) {
                IF_DEBUG(WARNING) {
                    DPRINT(0,"Non rootDSE searches not allowed on UDP.\n");
                }
                code = SetLdapError(unwillingToPerform,
                                    ERROR_DS_NOT_SUPPORTED,
                                    LdapUdpDenied,
                                    0,
                                    pErrorMessage);
                _leave;
            }

            // get the entry info selection
            code = LDAP_SearchRequestToEntInfSel (
                    pTHS,
                    m_CodePage,
                    searchRequest,
                    &ControlArg,
                    &pFlags,
                    &SelectionRange,
                    &SearchArg.pSelection );

            if( code  ) {
                code = SetLdapError(code,
                                    ERROR_INVALID_PARAMETER,
                                    LdapBadConv,
                                    0,
                                    pErrorMessage);
                _leave;
            }

            SearchArg.pSelectionRange = &SelectionRange;
            SearchArg.CommArg.Svccntl.fMissingAttributesOnGC =
                ControlArg.CommArg.Svccntl.fMissingAttributesOnGC;

            //
            // Finish building the search argument.
            //

            //
            // If this went through the GC port OR if a phantom root control
            // was specified set the search on one NC flag to false
            //

            if ( m_fGC || ControlArg.phantomRoot ) {
                SearchArg.bOneNC = 0;
            } else {
                SearchArg.bOneNC = 1;
            }

            if(ControlArg.Notification) {
                NOTIFYARG NotifyArg;
                NOTIFYRES *pNotifyRes=NULL;

                // Set the pointer to the function to prepare to impersonate.
                NotifyArg.pfPrepareForImpersonate = LDAP_PrepareToImpersonate;

                // Set the pointer for the callback to receive data.
                NotifyArg.pfTransmitData = LDAP_ReceiveNotificationData;

                NotifyArg.pfStopImpersonating = LDAP_StopImpersonating;

                // Tell him my ID.
                NotifyArg.hClient = m_dwClientID;

                // See if we are allowing notifications on this connection, and
                // reserve a notification if we are.
                code = PreRegisterNotify(request->m_MessageId);
                if(code) {
                    code = SetLdapError(code,
                                        GetLastError(),
                                        LdapBadNotification,
                                        0,
                                        pErrorMessage);
                    _leave;
                }

                // This is a notification search.  Register it as such.
                dscode =  DirNotifyRegister( &SearchArg, &NotifyArg, &pNotifyRes);
                // see if everything went Ok
                if( dscode ) {

                    //
                    // Nope, so we need to Unregister the PreRegistration we did
                    // Since DirNotifyRegister failed, we pass FALSE to indicate
                    // that we should not do a core unregister
                    //

                    UnregisterNotify(request->m_MessageId,FALSE);

                    code = LDAP_DirErrorToLDAPError(pTHS,
                                                    m_Version,
                                                    m_CodePage,
                                                    dscode,
                                                    &ControlArg,
                                                    ppReferral,
                                                    pErrorMessage,
                                                    pMatchedDN);
                }
                else {
                    // We successfully registered with the core.  Now, complete the
                    // registration bookkeeping in the userdata object.  We're not
                    // supposed to send a response if that succeeds.
                    if(RegisterNotify(pNotifyRes->hServer,
                                      request->m_MessageId)) {
                        bSendNoResponse=TRUE;
                    }
                    else {
                        // Failed to complete the notification.  Unregister with the
                        // core and clean up the local pre-registration.
                        DirNotifyUnRegister(pNotifyRes->hServer, &pNotifyRes);
                        UnregisterNotify(request->m_MessageId,TRUE);
                        code = SetLdapError(other,
                                            ERROR_DS_INTERNAL_FAILURE,
                                            LdapBadNotification,
                                            0,
                                            pErrorMessage);
                    }
                }

            } else {

                if(request->m_fAbandoned) {
                    __leave;
                }

                if ( !ControlArg.replRequest ) {

                    //
                    // Normal search
                    //
                    dscode = (USHORT)DirSearch( &SearchArg, &pSearchRes);

                } else {

                    //Replication
                    DRS_MSG_GETCHGREQ_NATIVE msgIn;
                    PARTIAL_ATTR_VECTOR *pPartialAttrVec = NULL;

                    //Get the cookie from the replication control
                    code = LDAP_UnpackReplControl(
                                          SearchArg.pObject,
                                          &SearchArg,
                                          &ControlArg,
                                          &msgIn,
                                          &pPartialAttrVec);
                    if( code )  {
                        code = SetLdapError(code,
                                            ERROR_DS_DECODING_ERROR,
                                            LdapBadControl,
                                            0,
                                            pErrorMessage);
                        __leave;
                    }

                    Assert(!pTHS->fDRA);

                    // Unless the client has specified object-level security...
                    if (!(ControlArg.replFlags & DRS_DIRSYNC_OBJECT_SECURITY)) {
                        // Check the client has the appropriate control access right.
                        if (!IsDraAccessGranted(pTHS,
                                                msgIn.pNC,
                                                &RIGHT_DS_REPL_GET_CHANGES,
                                                &dscode)) {

                            code = SetLdapError(insufficientAccessRights,
                                                dscode,
                                                LdapBadControl,
                                                0,
                                                pErrorMessage);

                            __leave;
                        }
                        // Skip future access checks
                        pTHS->fDRA = TRUE;
                    }

                    // Note that we use the DRS_PUBLIC_ONLY flag to indicate that
                    // no secrets should be returned

                    INC(pcLdapThreadsInDra);
                    __try {
                        msgIn.pPartialAttrSet = (PARTIAL_ATTR_VECTOR_V1_EXT*)pPartialAttrVec;
                        dscode = DRA_GetNCChanges( pTHS,
                                                   SearchArg.pFilter,
                                                   ControlArg.replFlags,
                                                   &msgIn,
                                                   &msgOut );
                    }
                    __except (GetDraException(GetExceptionInformation(),
                                              &dscode)) {
                        // Exception generated; dscode holds the ERROR_DS_DRA_*
                        // error code.
                    }
                    DEC(pcLdapThreadsInDra);
                    pTHS->fDRA = FALSE;
                }

                if(request->m_fAbandoned) {
                    __leave;
                }

                // see if everything went Ok
                if( dscode ) {

                    if ( !ControlArg.replRequest ) {
                        code = LDAP_DirErrorToLDAPError(pTHS,
                                                    m_Version,
                                                    m_CodePage,
                                                    dscode,
                                                    &ControlArg,
                                                    ppReferral,
                                                    pErrorMessage,
                                                    pMatchedDN);

                    } else {
                        code = SetLdapError(unwillingToPerform,
                                    dscode,
                                    LdapBadControl,
                                    0,
                                    pErrorMessage);
                    }

                } else {

                    if( ! ControlArg.replRequest ) {
                        // Core search succeeded, convert the results into
                        // ldap structures
                        code = LDAP_SearchResToSearchResultFull (
                                pTHS,
                                this,
                                pSearchRes,
                                pFlags,
                                &ControlArg,
                                &result_return
                                );

                    } else {
                        code = LDAP_ReplicaMsgToSearchResultFull (
                            pTHS,
                            m_CodePage,
                            &msgOut,
                            &ControlArg,
                            &result_return,
                            ppControls_return
                            );
                    }
                }
            } // not notification
        }  // if not root-DSE

        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                 DS_EVENT_SEV_EXTENSIVE,
                 DIRLOG_API_TRACE_COMPLETE,
                 szInsertSz("ldap_search"),
                 szInsertUL((GetTickCount() - starttime)),
                 NULL);
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        code = LDAP_HandleDsaExceptions(dwException, ulErrorCode, pErrorMessage);
    }

    //
    // free up the paged blob that was used
    //

    if ( ControlArg.Blob != NULL ) {
        FreePagedBlob(ControlArg.Blob);
    }

    if(bSendNoResponse || request->m_fAbandoned) {
        // what we return makes no difference.  However, we must set the
        // *pNoReturn to TRUE
        *pNoReturn = TRUE;
        return code;

    }

    if ( pSearchRes != NULL ) {
        objectCount = pSearchRes->count;
        if(pSearchRes->pPartialOutcomeQualifier) {
            objectCount += pSearchRes->pPartialOutcomeQualifier->count;
        }
    }

    // now, create the controls to return, unless we already have an error.
    switch(code) {
    case sizeLimitExceeded:
    case timeLimitExceeded:
    case referral:
    case unavailableCriticalExtension:
    case success:
        if(!*ppControls_return) {
            // only create the controls if someone else hasn't already done so.
            code = LDAP_CreateOutputControls (
                    pTHS,
                    this,
                    code,
                    &request->m_StartTick,
                    pSearchRes,
                    &ControlArg,
                    ppControls_return
                    );
        }
        break;
    }


    if ( EncodeSearchResult(request,
                            this,
                            result_return,
                            code,
                            *ppReferral,
                            *ppControls_return,
                            pErrorMessage,
                            pMatchedDN,
                            objectCount,
                            FALSE ) != ERROR_SUCCESS ) {

        //
        // Something fatal happened
        //

        code = SetLdapError(resultsTooLarge,
                            ERROR_DS_ENCODING_ERROR,
                            LdapEncodeError,
                            0,
                            pErrorMessage);
    }
    
    return code;
}   // SearchRequest


_enum1
LDAP_CONN::DelRequest(
        IN THSTATE *pTHS,
        IN PLDAP_REQUEST request,
        IN LDAPMsg* pMessage,
        OUT Referral *ppReferral,
        OUT Controls *ppControls_return,
        OUT LDAPString *pErrorMessage,
        OUT LDAPDN *pMatchedDN
    )
/*++

Routine Description:

    This routine processes a simple delete request.

Arguments:

    request     - Object used to track this transaction.

    pMessage    - Decoded message from client.

Return Value:

    None.

--*/
{
    REMOVEARG       RemoveArg;
    REMOVERES *     pRemoveRes;
    DWORD           dwException;
    ULONG           ulErrorCode;
    ULONG           dsid;
    CONTROLS_ARG    ControlArg;
    PVOID           dwEA;
    error_status_t  dscode;
    _enum1          code = success;

    DPRINT1( VERBOSE, "DeleteRequest @ %08lX.\n", request);

    PERFINC(pcLDAPWritePerSec);

    memset( &RemoveArg, 0, sizeof( RemoveArg ) );
    ZeroMemory( &ControlArg, sizeof(ControlArg) );

    // Translate the LDAPMsg to a SearchArg and make the core call
    __try {

        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                 DS_EVENT_SEV_INTERNAL,
                 DIRLOG_API_TRACE,
                 szInsertSz("ldap_delete"),
                 NULL,
                 NULL);

        //
        // Reject if on GC port
        //

        if ( m_fGC ) {

            code = SetLdapError(unwillingToPerform,
                                ERROR_DS_UNWILLING_TO_PERFORM,
                                LdapGcDenied,
                                0,
                                pErrorMessage);

            IF_DEBUG(WARNING) {
                DPRINT(0,"Rejected attempt to delete using the GC port.\n");
            }
            goto ExitTry;
        }

        // get the distinguished name

        code = LDAP_LDAPDNToDSName(
                m_CodePage,
                &pMessage->protocolOp.u.delRequest,
                &RemoveArg.pObject );
        if( code )  {
            code = SetLdapError(code,
                                ERROR_INVALID_PARAMETER,
                                LdapBadName,
                                0,
                                pErrorMessage);
            goto ExitTry;
        }

        code = LDAP_ControlsToControlArg (
                pMessage->controls,
                request,
                m_CodePage,
                &ControlArg);

        if(code) {
            code = SetLdapError(code,
                                ERROR_INVALID_PARAMETER,
                                LdapBadControl,
                                0,
                                pErrorMessage);
            goto ExitTry;
        }
        RemoveArg.CommArg = ControlArg.CommArg;
        RemoveArg.fTreeDelete = ControlArg.treeDelete;

        // make the call
        dscode = (USHORT)DirRemoveEntry( &RemoveArg, &pRemoveRes);

        // see if there was an error
        if( dscode != 0 ) {
            code = LDAP_DirErrorToLDAPError(pTHS,
                                            m_Version,
                                            m_CodePage,
                                            dscode,
                                            &ControlArg,
                                            ppReferral,
                                            pErrorMessage,
                                            pMatchedDN);
            goto ExitTry;
        }

    ExitTry:;
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        code = LDAP_HandleDsaExceptions(dwException, ulErrorCode, pErrorMessage);
    }

    // Note: we ignore the results of this output creation.  It wouldn't do to
    // succeed on the DB call, then fail on the creation of output controls and
    // report a failure to the client, since the modification was made in the
    // DIT.
    LDAP_CreateOutputControls (
            pTHS,
            this,
            code,
            &request->m_StartTick,
            NULL,
            &ControlArg,
            ppControls_return
            );

    return code;
}   // DelRequest

_enum1
LDAP_CONN::ModifyDNRequest(
        IN THSTATE *pTHS,
        IN PLDAP_REQUEST request,
        IN LDAPMsg* pMessage,
        OUT Referral *ppReferral,
        OUT Controls *ppControls_return,
        OUT LDAPString *pErrorMessage,
        OUT LDAPDN *pMatchedDN
        )
/*++

Routine Description:

This routine processes a simple modify DN request.

Arguments:

    request     - Object used to track this transaction.

    pMessage    - Decoded message from client.

Return Value:

    None.

--*/
{
    MODIFYDNARG     ModifyDNArg;
    MODIFYDNRES *   pModifyDNRes;
    ATTR            RDNAttr;
    DWORD           dwException;
    ULONG           ulErrorCode;
    ULONG           dsid;
    CONTROLS_ARG    ControlArg;
    PVOID           dwEA;
    error_status_t  dscode;
    _enum1          code = success;

    memset(&ModifyDNArg,0,sizeof(MODIFYDNARG));
    ZeroMemory( &ControlArg, sizeof(ControlArg) );

    PERFINC(pcLDAPWritePerSec);

    DPRINT1( VERBOSE, "ModifyDNRequest @ %08lX.\n", request);

    // Translate the LDAPMsg to a ModifyDNArg and make the core call
    __try {

        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                 DS_EVENT_SEV_INTERNAL,
                 DIRLOG_API_TRACE,
                 szInsertSz("ldap_modDN"),
                 NULL,
                 NULL);

        //
        // Reject if on GC port
        //

        if ( m_fGC ) {
            code = SetLdapError(unwillingToPerform,
                                ERROR_DS_UNWILLING_TO_PERFORM,
                                LdapGcDenied,
                                0,
                                pErrorMessage);
            IF_DEBUG(WARNING) {
                DPRINT(0,"Rejected attempt to modifyDN using the GC port.\n");
            }
            goto ExitTry;
        }

        ModifyDNArg.pNewRDN = &RDNAttr;

        // get the distinguished name of the object to rename
        code = LDAP_LDAPDNToDSName(
                m_CodePage,
                &pMessage->protocolOp.u.modDNRequest.entry,
                &ModifyDNArg.pObject );
        if( code )  {
            code = SetLdapError(code,
                                ERROR_INVALID_PARAMETER,
                                LdapBadName,
                                0,
                                pErrorMessage);
            goto ExitTry;
        }

        // Get the new RDN
        code = LDAP_LDAPRDNToAttr(
                pTHS,
                m_CodePage,
                &pMessage->protocolOp.u.modDNRequest.newrdn,
                ModifyDNArg.pNewRDN);
        if( code )  {
            code = SetLdapError(code,
                                ERROR_INVALID_PARAMETER,
                                LdapBadConv,
                                GetLastError(),
                                pErrorMessage);
            goto ExitTry;
        }

        code = LDAP_ControlsToControlArg (
                pMessage->controls,
                request,
                m_CodePage,
                &ControlArg);

        if(code) {
            code = SetLdapError(code,
                                ERROR_INVALID_PARAMETER,
                                LdapBadControl,
                                0,
                                pErrorMessage);
            goto ExitTry;
        }
        ModifyDNArg.CommArg = ControlArg.CommArg;
        ModifyDNArg.pDSAName = ControlArg.pModDnDSAName;

        // Check for requests to leave the oldrdn in place
        if(!pMessage->protocolOp.u.modDNRequest.deleteoldrdn) {
            // we don't handle that.
            code = unwillingToPerform;
            code = SetLdapError(unwillingToPerform,
                                ERROR_INVALID_PARAMETER,
                                LdapCannotLeaveOldRdn,
                                0,
                                pErrorMessage);
            goto ExitTry;
        }

        // See if a new superior was given.
        if(pMessage->protocolOp.u.modDNRequest.bit_mask & newSuperior_present) {
            code = LDAP_LDAPDNToDSName(
                    m_CodePage,
                    &pMessage->protocolOp.u.modDNRequest.newSuperior,
                    &ModifyDNArg.pNewParent );
            if( code )  {
                code = SetLdapError(code,
                                    ERROR_INVALID_PARAMETER,
                                    LdapBadName,
                                    0,
                                    pErrorMessage);
                goto ExitTry;
            }
        }

        // do the call
        dscode = (USHORT)DirModifyDN( &ModifyDNArg, &pModifyDNRes);

        // see if there was an error
        if( dscode != 0 ) {
            code = LDAP_DirErrorToLDAPError(pTHS,
                                            m_Version,
                                            m_CodePage,
                                            dscode,
                                            &ControlArg,
                                            ppReferral,
                                            pErrorMessage,
                                            pMatchedDN);
            goto ExitTry;
        }

    ExitTry:;
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        code = LDAP_HandleDsaExceptions(dwException, ulErrorCode, pErrorMessage);
    }


    // Note: we ignore the results of this output creation.  It wouldn't do to
    // succeed on the DB call, then fail on the creation of output controls and
    // report a failure to the client, since the modification was made in the
    // DIT.
    LDAP_CreateOutputControls (
            pTHS,
            this,
            code,
            &request->m_StartTick,
            NULL,
            &ControlArg,
            ppControls_return
            );

    return code;
}   // DelRequest

_enum1
LDAP_CONN::ModifyRequest(
        IN THSTATE *pTHS,
        IN PLDAP_REQUEST request,
        IN LDAPMsg* pMessage,
        OUT Referral *ppReferral,
        OUT Controls *ppControls_return,
        OUT LDAPString *pErrorMessage,
        OUT LDAPDN *pMatchedDN
        )
/*++

Routine Description:

This routine processes a simple modify request.

Arguments:

    request     - Object used to track this transaction.

    pMessage    - Decoded message from client.

Return Value:

    None.

--*/
{
    _enum1          code;
    MODIFYARG       ModArg;
    MODIFYRES *     pModRes;
    ULONG           dsid;
    PVOID           dwEA;
    DWORD           dwException;
    ULONG           ulErrorCode;
    error_status_t  dscode;
    ATTRMODLIST     *pAttrModList;
    CONTROLS_ARG    ControlArg;
    OPARG           *pOpArg=NULL;
    OPRES           *pOpRes=NULL;

    memset(&ModArg, 0, sizeof(MODIFYARG));
    ZeroMemory( &ControlArg, sizeof(ControlArg) );

    PERFINC(pcLDAPWritePerSec);

    DPRINT1( VERBOSE, "ModifyRequest @ %08lX.\n", request);
    // Translate the LDAPMsg to a ModifyDNArg and make the core call
    __try {

        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                 DS_EVENT_SEV_INTERNAL,
                 DIRLOG_API_TRACE,
                 szInsertSz("ldap_modify"),
                 NULL,
                 NULL);

        //
        // Reject if on GC port
        //

        if ( m_fGC ) {
            code = SetLdapError(unwillingToPerform,
                                ERROR_DS_UNWILLING_TO_PERFORM,
                                LdapGcDenied,
                                0,
                                pErrorMessage);
            IF_DEBUG(WARNING) {
                DPRINT(0,"Rejected attempt to modify using the GC port.\n");
            }
            goto ExitTry;
        }

        if(pMessage->protocolOp.u.modifyRequest.object.length == 0) {
            code = LDAP_ModificationListToOpArg(
                    m_CodePage,
                    pMessage->protocolOp.u.modifyRequest.modification,
                    &pOpArg);
            if( code )  {
                code = SetLdapError(code,
                                    ERROR_INVALID_PARAMETER,
                                    LdapBadConv,
                                    GetLastError(),
                                    pErrorMessage);
                goto ExitTry;
            }

            dscode = (USHORT)DirOperationControl(pOpArg,
                                                 &pOpRes);
        }
        else {
            // This is a normal modification operation.

            // get the distinguished name of the object to rename
            code = LDAP_LDAPDNToDSName(
                    m_CodePage,
                    &pMessage->protocolOp.u.modifyRequest.object,
                    &ModArg.pObject );
            if( code )  {
                code = SetLdapError(code,
                                    ERROR_INVALID_PARAMETER,
                                    LdapBadName,
                                    0,
                                    pErrorMessage);
                goto ExitTry;
            }

            code = LDAP_ControlsToControlArg (
                    pMessage->controls,
                    request,
                    m_CodePage,
                    &ControlArg);

            if(code) {
                code = SetLdapError(code,
                                    ERROR_INVALID_PARAMETER,
                                    LdapBadControl,
                                    0,
                                    pErrorMessage);
                goto ExitTry;
            }

            // Get the new attributes
            code = LDAP_ModificationListToAttrModList(
                    pTHS,
                    m_CodePage,
                    &ControlArg.CommArg.Svccntl,
                    pMessage->protocolOp.u.modifyRequest.modification,
                    &pAttrModList,
                    &ModArg.count);
            if( code )  {
                code = SetLdapError(code,
                                    ERROR_INVALID_PARAMETER,
                                    LdapBadConv,
                                    GetLastError(),
                                    pErrorMessage);
                goto ExitTry;
            }

            ModArg.CommArg = ControlArg.CommArg;
            ModArg.FirstMod = *pAttrModList;

            // do the call
            dscode = (USHORT)DirModifyEntry( &ModArg, &pModRes);
        }

        // see if there was an error
        if( dscode != 0 ) {
            code = LDAP_DirErrorToLDAPError(pTHS,
                                            m_Version,
                                            m_CodePage,
                                            dscode,
                                            &ControlArg,
                                            ppReferral,
                                            pErrorMessage,
                                            pMatchedDN);
            goto ExitTry;
        }

    ExitTry:;
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        code = LDAP_HandleDsaExceptions(dwException, ulErrorCode, pErrorMessage);
    }

    // Note: we ignore the results of this output creation.  It wouldn't do to
    // succeed on the DB call, then fail on the creation of output controls and
    // report a failure to the client, since the modification was made in the
    // DIT.
    LDAP_CreateOutputControls (
            pTHS,
            this,
            code,
            &request->m_StartTick,
            NULL,
            &ControlArg,
            ppControls_return
            );

    return code;
}   // ModifyRequest

_enum1
LDAP_CONN::AddRequest(
        IN THSTATE *pTHS,
        IN PLDAP_REQUEST request,
        IN LDAPMsg* pMessage,
        OUT Referral *ppReferral,
        OUT Controls *ppControls_return,
        OUT LDAPString *pErrorMessage,
        OUT LDAPDN *pMatchedDN
    )
/*++

Routine Description:

This routine processes a simple add request.

Arguments:

    request     - Object used to track this transaction.

    pMessage    - Decoded message from client.

Return Value:

    None.

--*/
{

    _enum1          code = success;
    ADDARG          AddArg;
    ADDRES *        pAddRes;
    ULONG           dsid;
    PVOID           dwEA;
    DWORD           dwException;
    ULONG           ulErrorCode;
    CONTROLS_ARG    ControlArg;
    error_status_t  dscode;

    PERFINC(pcLDAPWritePerSec);
    memset(&AddArg, 0, sizeof(ADDARG));
    ZeroMemory( &ControlArg, sizeof(ControlArg) );

    DPRINT1( VERBOSE, "AddRequest @ %08lX.\n", request);
    // Translate the LDAPMsg to a ModifyDNArg and make the core call
    __try {

        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                 DS_EVENT_SEV_INTERNAL,
                 DIRLOG_API_TRACE,
                 szInsertSz("ldap_add"),
                 NULL,
                 NULL);
        //
        // Reject if on GC port
        //

        if ( m_fGC ) {
            code = SetLdapError(unwillingToPerform,
                                ERROR_DS_UNWILLING_TO_PERFORM,
                                LdapGcDenied,
                                0,
                                pErrorMessage);
            IF_DEBUG(WARNING) {
                DPRINT(0,"Rejected attempt to add using the GC port.\n");
            }
            goto ExitTry;
        }

        // get the distinguished name of the object to rename
        code = LDAP_LDAPDNToDSName(
                m_CodePage,
                &pMessage->protocolOp.u.addRequest.entry,
                &AddArg.pObject );
        if( code )  {
            code = SetLdapError(code,
                                ERROR_INVALID_PARAMETER,
                                LdapBadName,
                                0,
                                pErrorMessage);
            goto ExitTry;
        }

        code = LDAP_ControlsToControlArg (
                pMessage->controls,
                request,
                m_CodePage,
                &ControlArg);

        if(code) {
            code = SetLdapError(code,
                                ERROR_INVALID_PARAMETER,
                                LdapBadControl,
                                0,
                                pErrorMessage);
            goto ExitTry;
        }

        AddArg.CommArg = ControlArg.CommArg;

        // Get the new attributes
        code = LDAP_AttributeListToAttrBlock(
                pTHS,
                m_CodePage,
                &ControlArg.CommArg.Svccntl,
                pMessage->protocolOp.u.addRequest.attributes,
                &AddArg.AttrBlock);
        if( code )  {
            code = SetLdapError(code,
                                ERROR_INVALID_PARAMETER,
                                LdapBadConv,
                                GetLastError(),
                                pErrorMessage);
            goto ExitTry;
        }


        // do the call

        dscode = (USHORT)DirAddEntry( &AddArg, &pAddRes);

        // see if there was an error
        if( dscode != 0 ) {
            code = LDAP_DirErrorToLDAPError(pTHS,
                                            m_Version,
                                            m_CodePage,
                                            dscode,
                                            &ControlArg,
                                            ppReferral,
                                            pErrorMessage,
                                            pMatchedDN);
            goto ExitTry;
        }

    ExitTry:;
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        code = LDAP_HandleDsaExceptions(dwException, ulErrorCode, pErrorMessage);
    }

    // Note: we ignore the results of this output creation.  It wouldn't do to
    // succeed on the DB call, then fail on the creation of output controls and
    // report a failure to the client, since the modification was made in the
    // DIT.
    LDAP_CreateOutputControls (
            pTHS,
            this,
            code,
            &request->m_StartTick,
            NULL,
            &ControlArg,
            ppControls_return
            );


    return code;
}   // AddRequest

_enum1
LDAP_CONN::CompareRequest(
        IN THSTATE *pTHS,
        IN PLDAP_REQUEST request,
        IN LDAPMsg* pMessage,
        OUT Referral *ppReferral,
        OUT Controls *ppControls_return,
        OUT LDAPString *pErrorMessage,
        OUT LDAPDN *pMatchedDN
    )
/*++

Routine Description:

This routine processes a simple compare request.

Arguments:

    request     - Object used to track this transaction.

    pMessage    - Decoded message from client.

Return Value:

    None.

--*/
{

    _enum1          code = success;
    COMPAREARG      CompareArg;
    COMPARERES      *pCompareRes;
    ULONG           dsid;
    PVOID           dwEA;
    DWORD           dwException;
    ULONG           ulErrorCode;
    error_status_t  dscode;
    CONTROLS_ARG    ControlArg;

    memset(&CompareArg, 0, sizeof(COMPAREARG));
    ZeroMemory( &ControlArg, sizeof(ControlArg) );

    PERFINC(pcLDAPSearchPerSec);

    DPRINT1( VERBOSE, "CompareRequest @ %08lX.\n", request);
    // Translate the LDAPMsg to a ModifyDNArg and make the core call
    __try {

        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                 DS_EVENT_SEV_INTERNAL,
                 DIRLOG_API_TRACE,
                 szInsertSz("ldap_compare"),
                 NULL,
                 NULL);

        code = LDAP_ControlsToControlArg (
                pMessage->controls,
                request,
                m_CodePage,
                &ControlArg);

        if(code) {
            code = SetLdapError(code,
                                ERROR_INVALID_PARAMETER,
                                LdapBadControl,
                                0,
                                pErrorMessage);
            goto ExitTry;
        }
        CompareArg.CommArg = ControlArg.CommArg;


        // get the distinguished name of the object to rename
        code = LDAP_LDAPDNToDSName(
                m_CodePage,
                &pMessage->protocolOp.u.compareRequest.entry,
                &CompareArg.pObject );
        if( code )  {
            code = SetLdapError(code,
                                ERROR_INVALID_PARAMETER,
                                LdapBadName,
                                0,
                                pErrorMessage);
            goto ExitTry;
        }

        // Get the assertion
        code = LDAP_AssertionValueToDirAVA(
                pTHS,
                m_CodePage,
                &CompareArg.CommArg.Svccntl,
                &pMessage->protocolOp.u.compareRequest.ava,
                &CompareArg.Assertion);
        if( code )  {
            code = SetLdapError(code,
                                ERROR_INVALID_PARAMETER,
                                LdapBadConv,
                                GetLastError(),
                                pErrorMessage);
            goto ExitTry;
        }

        // do the call
        dscode = (USHORT)DirCompare(&CompareArg, &pCompareRes);

        // see if there was an error
        if( dscode != 0 ) {
            code = LDAP_DirErrorToLDAPError(pTHS,
                                            m_Version,
                                            m_CodePage,
                                            dscode,
                                            &ControlArg,
                                            ppReferral,
                                            pErrorMessage,
                                            pMatchedDN);
            goto ExitTry;
        }

        // Ok, turn the CompareRes into something LDAP likes.
        code = (pCompareRes->matched ? compareTrue : compareFalse);

    ExitTry:;
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        code = LDAP_HandleDsaExceptions(dwException, ulErrorCode, pErrorMessage);
    }

    // Note: we ignore the results of this output creation.  It wouldn't do to
    // succeed on the DB call, then fail on the creation of output controls and
    // report a failure to the client, since the modification was made in the
    // DIT.
    LDAP_CreateOutputControls (
            pTHS,
            this,
            code,
            &request->m_StartTick,
            NULL,
            &ControlArg,
            ppControls_return
            );

    return code;
}   // CompareRequest

_enum1
LDAP_CONN::AbandonRequest(
        IN THSTATE *pTHS,
        IN PLDAP_REQUEST request,
        IN LDAPMsg* pMessage
    )
/*++

Routine Description:

This routine processes a simple abandon request.

Arguments:

    request     - Object used to track this transaction.

    pMessage    - Decoded message from client.

Return Value:

    None.

--*/
{

    IF_DEBUG(MISC) {
        DPRINT1(0,"Abandon request received. msgID is %d\n",
                pMessage->protocolOp.u.abandonRequest);

    }
    MarkRequestAsAbandonded(pMessage->protocolOp.u.abandonRequest);

    //
    // And, unregister any notifies on this message
    //

    UnregisterNotify(pMessage->protocolOp.u.abandonRequest,TRUE);

    return success;
}   // AbandonRequest


_enum1
LDAP_CONN::ExtendedRequest(
                IN  THSTATE       *pTHS,
                IN  PLDAP_REQUEST request,
                IN  LDAPMsg       *pMessage,
                OUT Referral      *pReferral,
                OUT LDAPString    *pErrorMessage,
                OUT LDAPDN        *pMatchedDN,
                OUT LDAPOID       *pResponseName,
                OUT LDAPString    *pResponse
               )
/*++

Routine Description:

This routine processes a simple extended request.

Arguments:

    pTHS        - thread state structure.

    request     - Object used to track this transaction.

    pMessage    - Decoded message from client.
    
    pReferral   - Where to put any referrals generated by the request.
    
    pMatchedDN  - Where to put the matchedDN field of the extended response that will
                  be sent back to the client.
                  
    pResponseName - Where to put the Extended Request responseName field.
    
    pResponse   - Where to put the Extended Request response field.

Return Value:

    Error code to be returned to the client.

--*/
{
    DWORD  i;
    DWORD  dwExtRequestID = EXT_REQUEST_UNKNOWN;
    _enum1 code = success;
    struct ExtendedRequest* extendedRequest =
                &pMessage->protocolOp.u.extendedReq;

    IF_DEBUG(MISC) {
        DPRINT1( 0, "ExtendedRequest @ %08lX.\n", request);
    }

    for (i = 0; i < NUM_EXTENDED_REQUESTS; i++) {
        if (AreOidsEqual(&extendedRequest->requestName, &KnownExtendedRequests[i])) {
            dwExtRequestID = i;
            break;
        }
    }

    if (EXT_REQUEST_UNKNOWN == dwExtRequestID) {
        code = SetLdapError(protocolError,
                            ERROR_DS_DECODING_ERROR,
                            LdapUnknownExtendedRequestOID,
                            0,
                            pErrorMessage);
        return code;
    }
    
    switch(dwExtRequestID) {
    case EXT_REQUEST_START_TLS:
        code = StartTLSRequest(pTHS,
                               request,
                               pMessage,
                               pErrorMessage,
                               pResponseName);
        break;
    case EXT_REQUEST_TTL_REFRESH:
        code = TTLRefreshRequest(pTHS,
                                 request,
                                 pMessage,
                                 pReferral,
                                 pErrorMessage,
                                 pResponseName,
                                 pResponse);
        break;
    case EXT_REQUEST_FAST_BIND:
        code = FastBindModeRequest(pTHS,
                                   request,
                                   pMessage,
                                   pErrorMessage,
                                   pResponseName);
    }

    return code;
}   // Extended request



_enum1
LDAP_CONN::StartTLSRequest(
                IN  THSTATE       *pTHS,
                IN  PLDAP_REQUEST request,
                IN  LDAPMsg       *pMessage,
                OUT LDAPString    *pErrorMessage,
                OUT LDAPOID       *pResponseName
               )
/*++

Routine Description:

This routine processes a StartTLS request.

Arguments:

    pTHS        - Threadstate

    request     - Object used to track this transaction.

    pMessage    - Decoded message from client.
    
    pErrorMessage - place to put an error message if an error occurs.
    
    pResponseName - Put the ExtendedResponse responseName field here.

Return Value:

    Error code to be returned to the client.

--*/
{
    // Set the responseName to be the same as the requestName.
    pResponseName->length = pMessage->protocolOp.u.extendedReq.requestName.length;
    pResponseName->value = pMessage->protocolOp.u.extendedReq.requestName.value;

    if (IsTLS()) {
        IF_DEBUG(SSL) {
            DPRINT1(0, "TLS already active on connection, %p\n", this);
        }
        return SetLdapError(operationsError,
                            0,
                            LdapTLSAlreadyActive,
                            0,
                            pErrorMessage);
    }

    if (IsSignSeal()) {
        IF_DEBUG(SSL) {
            DPRINT1(0, "StartTLS attempted on signing/sealing connection, %p\n", this);
        }
        return SetLdapError(operationsError,
                            0,
                            LdapNoSigningSealingOverTLS,
                            0,
                            pErrorMessage);
    }

    //
    // There can't be any outstanding requests, and the connection cannot be in
    // the middle of a mutli-stage bind.
    //
    if (m_Notifications || m_nRequests != 1 || (m_pSecurityContext && m_pSecurityContext->IsPartiallyBound())) {
        IF_DEBUG(SSL) {
            DPRINT1(0, "Can't StartTLS with outstanding requests or multi-stage binds, %p\n", this);
        }
        return SetLdapError(operationsError,
                            0,
                            LdapNoPendingRequestsAtStartTLS,
                            0,
                            pErrorMessage);
    }

    if (!InitializeSSL()) {
        IF_DEBUG(SSL) {
            DPRINT(0, "SChannel failed to initialize.  Can't start TLS.\n");
        }
        return SetLdapError(unavailable,
                            0,
                            LdapSSLInitError,
                            0,
                            pErrorMessage);
                            
    }

    // Get into TLS mode. 
    m_fTLS = TRUE;
    PERFINC(pcLdapSSLConnsPerSec);

    SetNetBufOpts(NULL);

    return success;
}


_enum1
LDAP_CONN::TTLRefreshRequest(
                IN  THSTATE       *pTHS,
                IN  PLDAP_REQUEST request,
                IN  LDAPMsg       *pMessage,
                OUT Referral      *pReferral,
                OUT LDAPString    *pErrorMessage,
                OUT LDAPOID       *pResponseName,
                OUT LDAPString    *pResponse
               )
/*++

Routine Description:

This routine processes a TTL Refresh extended request.

Arguments:
    pTHS        - Threadstate

    request     - Object used to track this transaction.

    pMessage    - Decoded message from client.
    
    pErrorMessage - place to put an error message if an error occurs.
    
    pResponseName - Put the ExtendedResponse responseName field here.

    pResponse    - Put the ExtendedResponse response field here.
    
Return Value:

    Error code to be returned to the client.

--*/
{
    LDAPDN        entryName;
    DWORD         requestTtl;
    BERVAL        requestValue;
    LDAPString    responseValue;
    LDAPString    tmpLdapString;
    PDSNAME       pCoreEntryName;
    DWORD         responseTtl = 0;
    _enum1        code = success;
    CONTROLS_ARG  ControlArg;
    READARG       readArg;
    READRES       *pReadRes;
    ENTINFSEL     entInfSel;
    MODIFYARG     modifyArg;
    MODIFYRES     *pModifyRes;
    ATTR          attr;
    ATTRVAL       attrVal;
    ULONG         dscode;
    ULONG         dsid;
    PVOID         dwEA;
    DWORD         dwException;
    ULONG         ulErrorCode;

    // Set the responseName to be the same as the requestName.
    pResponseName->length = pMessage->protocolOp.u.extendedReq.requestName.length;
    pResponseName->value = pMessage->protocolOp.u.extendedReq.requestName.value;
    
    requestValue.bv_len = pMessage->protocolOp.u.extendedReq.requestValue.length;
    requestValue.bv_val = (PCHAR)pMessage->protocolOp.u.extendedReq.requestValue.value;

    code = DecodeTTLRequest(&requestValue, &entryName, &requestTtl, pErrorMessage);
    if (success != code) {
        return code;
    }

    // Convert the DN valued entryName to a core DS DSNAME.
    code = LDAP_LDAPDNToDSName(m_CodePage, &entryName, &pCoreEntryName);
    if (success != code) {
        return SetLdapError(code,
                            ERROR_INVALID_PARAMETER,
                            LdapBadConv,
                            GetLastError(),
                            pErrorMessage);
    }

    //
    // Process this request.
    //

    __try {

        //
        // First stop is the modify.
        //
        
        // set up the MODIFYARG
        memset(&modifyArg, 0, sizeof(modifyArg));
        InitCommarg(&modifyArg.CommArg);
        modifyArg.pObject = pCoreEntryName;
        modifyArg.count   = 1;

        // set up the ATTRMODLIST
        attrVal.valLen = sizeof(DWORD);
        attrVal.pVal = (PUCHAR)&requestTtl;

        modifyArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
        modifyArg.FirstMod.AttrInf.attrTyp = gTTLAttrType;
        modifyArg.FirstMod.AttrInf.AttrVal.valCount = 1;
        modifyArg.FirstMod.AttrInf.AttrVal.pAVal = &attrVal;

        // Do the modify
        dscode = DirModifyEntry(&modifyArg, &pModifyRes);

        // see if there was an error
        if ( dscode != 0 ) {
            memset(&ControlArg, 0, sizeof(ControlArg));
            code = LDAP_DirErrorToLDAPError(pTHS,
                                            m_Version,
                                            m_CodePage,
                                            dscode,
                                            &ControlArg,
                                            pReferral,
                                            pErrorMessage,
                                            &tmpLdapString);
            goto ExitTry;
        }


        //
        // Now get the actual value that will be returned to the client.
        //

        // set up the ENTINFSEL for the DirRead
        attr.attrTyp = gTTLAttrType;
        attr.AttrVal.valCount = 0;
        attr.AttrVal.pAVal    = NULL;

        memset(&entInfSel, 0, sizeof(ENTINFSEL));
        entInfSel.attSel    = EN_ATTSET_LIST;
        entInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

        entInfSel.AttrTypBlock.attrCount = 1;
        entInfSel.AttrTypBlock.pAttr     = &attr;

        // set up the READARG
        memset(&readArg, 0, sizeof(readArg));
        InitCommarg(&readArg.CommArg);
        readArg.pObject   = pCoreEntryName;
        readArg.pSel      = &entInfSel;

        //
        // Read the value that the server actually used so that
        // it can be returned to the client
        //
        dscode = DirRead(&readArg, &pReadRes);

        // see if there was an error
        if ( dscode != 0 ){
            memset(&ControlArg, 0, sizeof(ControlArg));
            code = LDAP_DirErrorToLDAPError(pTHS,
                                            m_Version,
                                            m_CodePage,
                                            dscode,
                                            &ControlArg,
                                            pReferral,
                                            pErrorMessage,
                                            &tmpLdapString);
            goto ExitTry;
        }


        if (!pReadRes->entry.AttrBlock.attrCount){
            THFree(pReadRes);
            return SetLdapError(other,
                                0,
                                LdapBadConv,
                                0,
                                pErrorMessage);
        }

        Assert(pReadRes->entry.AttrBlock.attrCount == 1);

        Assert(pReadRes->entry.AttrBlock.pAttr->AttrVal.pAVal->valLen == sizeof(DWORD));

        responseTtl = *((DWORD *)pReadRes->entry.AttrBlock.pAttr->AttrVal.pAVal->pVal);

    ExitTry:;
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        code = LDAP_HandleDsaExceptions(dwException, ulErrorCode, pErrorMessage);
    }

    if (success != code) {
        //
        // Must have hit an exception,
        // pErrorMessage should already contain the extended error.
        //
        return code;
    }

    //
    // Make response value.
    //
    code = EncodeTTLResponse(responseTtl, &responseValue, pErrorMessage);
    if (code != success) {
        return code;
    }

    pResponse->length = responseValue.length;
    pResponse->value = responseValue.value;

    return success;

}


_enum1
LDAP_CONN::FastBindModeRequest(
                IN  THSTATE       *pTHS,
                IN  PLDAP_REQUEST request,
                IN  LDAPMsg       *pMessage,
                OUT LDAPString    *pErrorMessage,
                OUT LDAPOID       *pResponseName
               )
/*++

Routine Description:

This routine processes a FastBindMode request.

Arguments:

    pTHS        - Threadstate

    request     - Object used to track this transaction.

    pMessage    - Decoded message from client.
    
    pErrorMessage - place to put an error message if an error occurs.
    
    pResponseName - Put the ExtendedResponse responseName field here.

Return Value:

    Error code to be returned to the client.

--*/
{
    // Set the responseName to be the same as the requestName.
    pResponseName->length = pMessage->protocolOp.u.extendedReq.requestName.length;
    pResponseName->value = pMessage->protocolOp.u.extendedReq.requestName.value;

    IF_DEBUG(BIND) {
        DPRINT(0, "*********Entering Fast Bind mode!\n");
    }

    if (IsSignSeal()) {
        return SetLdapError(unwillingToPerform,
                            0,
                            LdapNoSignSealFastBind,
                            0,
                            pErrorMessage);
    }

    m_fFastBindMode = TRUE;
    return success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\ldap\globals.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    globals.cxx

Abstract:

    This module implements the LDAP server for the NT5 Directory Service.

    This file defines functions and types required for the LDAP server
    configuration class LDAP_SERVER_CONFIG.

Author:

    Johnson Apacible (JohnsonA) 12-Nov-1997

--*/

#include <NTDSpchx.h>
#pragma  hdrstop

#include "ldapsvr.hxx"
#include <attids.h>

#ifdef new
#error "new is redefined. undef below may cause problems"
#endif
#ifdef delete
#error "delete is redefined. undef below may cause problems"
#endif

extern "C" {
#include <mdlocal.h>
}
// In an attempt to disallow new and delete from core.lib, mdlocal.h
// redefines them to cause compilation to fail.  Undo this here
// since this file doesn't get compiled into core.lib anyway.  We just
// require a couple of global variable declarations from mdlocal.h
#ifdef delete
#undef delete
#endif
#ifdef new
#undef new
#endif

#define  FILENO FILENO_LDAP_GLOBALS

//
// LDAP Stats
//

BOOL     fLdapInitialized = FALSE;
BOOL     fBypassLimitsChecks = FALSE;

LONG     CurrentConnections = 0;
LONG     MaxCurrentConnections = 0;
LONG     UncountedConnections = 0;
LONG     ActiveLdapConnObjects = 0;
USHORT   LdapBuildNo = 0;

//
// allocation cache stats
//

CRITICAL_SECTION csConnectionsListLock;
LIST_ENTRY       ActiveConnectionsList;

CRITICAL_SECTION LdapConnCacheLock;
LIST_ENTRY       LdapConnCacheList;

CRITICAL_SECTION LdapRequestCacheLock;
LIST_ENTRY       LdapRequestCacheList;

CRITICAL_SECTION LdapUdpEndpointLock;

DWORD            LdapConnMaxAlloc = 0;
DWORD            LdapConnAlloc = 0;
DWORD            LdapRequestAlloc = 0;
DWORD            LdapRequestMaxAlloc = 0;
DWORD            LdapConnCached = 0;
DWORD            LdapRequestsCached = 0;
DWORD            LdapBlockCacheLimit = 64;
DWORD            LdapBufferAllocs = 0;

//
// Limits
//

CRITICAL_SECTION LdapLimitsLock;

//
// SSL lock.
//

CRITICAL_SECTION LdapSslLock;

// Define as "C" so *.c in dsamain\src can reference and link.
extern "C" {
// exported limits
DWORD           LdapAtqMaxPoolThreads = 4;
DWORD           LdapMaxDatagramRecv = DEFAULT_LDAP_MAX_DGRAM_RECV;
DWORD           LdapMaxReceiveBuffer = DEFAULT_LDAP_MAX_RECEIVE_BUF;
DWORD           LdapInitRecvTimeout = DEFAULT_LDAP_INIT_RECV_TIMEOUT;
DWORD           LdapMaxConnections = DEFAULT_LDAP_CONNECTIONS_LIMIT;
DWORD           LdapMaxConnIdleTime = DEFAULT_LDAP_MAX_CONN_IDLE;
DWORD           LdapMaxPageSize = DEFAULT_LDAP_SIZE_LIMIT;
DWORD           LdapMaxQueryDuration = DEFAULT_LDAP_TIME_LIMIT;
DWORD           LdapMaxTempTable = DEFAULT_LDAP_MAX_TEMP_TABLE;
DWORD           LdapMaxResultSet = DEFAULT_LDAP_MAX_RESULT_SET;
DWORD           LdapMaxNotifications =
                        DEFAULT_LDAP_NOTIFICATIONS_PER_CONNECTION_LIMIT;

// exported configurable settings
LONG            DynamicObjectDefaultTTL = DEFAULT_DYNAMIC_OBJECT_DEFAULT_TTL;
LONG            DynamicObjectMinTTL = DEFAULT_DYNAMIC_OBJECT_MIN_TTL;

// not exported limits
DWORD           LdapMaxDatagramSend = 64 * 1024;
DWORD           LdapMaxReplSize = DEFAULT_LDAP_MAX_REPL_SIZE;
}

LIMITS_NOTIFY_BLOCK   LimitsNotifyBlock[6] = {0};

//
// Ldap comments
//

PCHAR LdapComments[] = {
    
    "Error decoding ldap message",
    "Server cannot encode the response",
    "A jet error was encountered",
    "A DSA exception was encountered",
    "Unsupported ldap version",
    "Error processing name",
    "AcceptSecurityContext error",
    "Invalid Authentication method",
    "Error processing control",
    "Error processing filter",
    "Error retrieving RootDSE attributes",
    "Error in attribute conversion operation",
    "Operation not allowed through UDP",
    "Operation not allowed through GC port",
    "Error processing notification request",
    "Too many searches",
    "Old RDN must be deleted",
    "Only one outstanding bind per connection allowed",
    "Cannot rebind once sign/seal activated",
    "Cannot rebind while notifications active",
    "Unknown extended request OID",
    "TLS already in effect",
    "Error initializing SSL/TLS",
    "Cannot start kerberos signing/sealing when using TLS/SSL",
    "The server did not receive any credentials via TLS",
    "Error processing extended request requestValue",
    "The server is busy",
    "The server has timed out the connection",
    "The server did not have enough resources to process the request",
    "The server encountered a network error",
    "Error decrypting ldap message",
    "Unable to start TLS due to an outstanding request or multi-stage bind",
    "The server was unable to decode a search request filter",
    "The server was unable to decode a search request attribute description list, the filter may have been invalid",
    "The server was unable to decode the controls on a previous request",
    "Only simple binds may be performed on a connection that is in fast bind mode.",
    "Cannot switch to fast bind mode when signing or sealing is active on the connection",
    "The server requires binds to turn on integrity checking if SSL\\TLS are not already active on the connection",
    "The server requires binds to turn on privacy protection if SSL\\TLS are not already active on the connection"
};


//
// Debug flag
//

DWORD           LdapFlags = DEBUG_ERROR;

// GUID used for checksumming
//
GUID gCheckSum_serverGUID;

//
// Attribute caches
//

AttributeVals   LdapAttrCache = NULL;

LDAP_ATTRVAL_CACHE   KnownControlCache = {0};
LDAP_ATTRVAL_CACHE   KnownLimitsCache = {0};
LDAP_ATTRVAL_CACHE   KnownConfSetsCache = {0};
LDAP_ATTRVAL_CACHE   LdapVersionCache = {0};
LDAP_ATTRVAL_CACHE   LdapSaslSupported = {0};
LDAP_ATTRVAL_CACHE   LdapCapabilitiesCache = {0};
LDAP_ATTRVAL_CACHE   KnownExtendedRequestsCache = {0};


//
// protos
//

VOID DestroyLimits(VOID);
BOOL InitializeTTLGlobals(VOID);
VOID DestroyTTLGlobals(VOID);


//
// Misc
//

PIP_SEC_LIST    LdapDenyList = NULL;


BOOL
InitializeGlobals(
    VOID
    )
/*++

Routine Description:

    Initializes all global variables.

Arguments:

    None.

Return Value:

    TRUE if success, FALSE otherwise.

--*/
{
    {
        //
        // Read debug flag
        //

        DWORD err;
        HKEY hKey = NULL;

        err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           DSA_CONFIG_SECTION,
                           0,
                           KEY_ALL_ACCESS,
                           &hKey
                           );

        if ( err == NO_ERROR ) {

            DWORD flag;
            DWORD nflag = sizeof(flag);
            DWORD type;

            err = RegQueryValueEx(hKey,
                                  TEXT("LdapFlags"),
                                  NULL,
                                  &type,
                                  (LPBYTE)&flag,
                                  &nflag
                                  );
            if ( err == NO_ERROR ) {
                LdapFlags = flag;
            }
            RegCloseKey(hKey);
        }
    }

    //
    // Initialize Cache
    //

    if ( !InitializeCache( ) ) {
        return FALSE;
    }

    //
    // Get build number
    //

    {
        OSVERSIONINFO osInfo;
        osInfo.dwOSVersionInfoSize = sizeof(osInfo);
        (VOID)GetVersionEx(&osInfo);
        LdapBuildNo = (USHORT)osInfo.dwBuildNumber;
        IF_DEBUG(WARNING) {
            DPRINT1(0,"NT build number %d\n", osInfo.dwBuildNumber);
        }
    }

    //
    // Initialize limits
    //

    for (DWORD i=0;i<CLIENTID_MAX ;i++ ) {
        LimitsNotifyBlock[i].ClientId = i;
        Assert(LimitsNotifyBlock[i].NotifyHandle == 0);
        switch (i) {
        case CLIENTID_DEFAULT:
        case CLIENTID_SERVER_POLICY:
        case CLIENTID_SITE_POLICY:
            LimitsNotifyBlock[i].CheckAttribute = ATT_LDAP_ADMIN_LIMITS;
            break;
        case CLIENTID_SITE_LINK:
        case CLIENTID_SERVER_LINK:
            LimitsNotifyBlock[i].CheckAttribute = ATT_QUERY_POLICY_OBJECT;
            break;
        case CLIENTID_CONFSETS:
            LimitsNotifyBlock[i].CheckAttribute = ATT_MS_DS_OTHER_SETTINGS;
            break;
        }

    }

    if (!InitializeCriticalSectionAndSpinCount(
                            &LdapLimitsLock,
                            LDAP_SPIN_COUNT
                            ) ) {
        DPRINT1(0,"Unable to initialize crit sect. Err %d\n",GetLastError());
        return FALSE;
    }

    //
    // init the SSL lock.
    //

    InitializeCriticalSection(&LdapSslLock);

    //
    // Init the udp endpoint lock
    //

    InitializeCriticalSection(&LdapUdpEndpointLock);

    //
    // init paged blob
    //

    InitializeListHead( &PagedBlobListHead );
    if (!InitializeCriticalSectionAndSpinCount(
                            &PagedBlobLock,
                            LDAP_SPIN_COUNT
                            ) ) {
        DPRINT1(0,"Unable to initialize crit sect. Err %d\n",GetLastError());
        return FALSE;
    }

    InitializeListHead( &ActiveConnectionsList);
    if (!InitializeCriticalSectionAndSpinCount(
                            &csConnectionsListLock,
                            LDAP_SPIN_COUNT
                            ) ) {
        DPRINT1(0,"Unable to initialize crit sect. Err %d\n",GetLastError());
        return FALSE;
    }

    //
    // Initialize allocation caches
    //

    if (!InitializeCriticalSectionAndSpinCount(
                                &LdapConnCacheLock,
                                LDAP_SPIN_COUNT) ) {

        DPRINT1(0,"Unable to initialize crit sect. Err %d\n",GetLastError());
        DeleteCriticalSection(&csConnectionsListLock);
        return FALSE;
    }

    InitializeListHead(&LdapConnCacheList);

    if (!InitializeCriticalSectionAndSpinCount(
                                &LdapRequestCacheLock,
                                LDAP_SPIN_COUNT)) {

        DPRINT1(0,"Unable to initialize crit sect. Err %d\n",GetLastError());
        DeleteCriticalSection(&csConnectionsListLock);
        DeleteCriticalSection(&LdapConnCacheLock);
        return FALSE;
    }

    InitializeListHead(&LdapRequestCacheList);

    (VOID)InitializeLimitsAndDenyList(NULL);
    (VOID)InitializeTTLGlobals();

    DsUuidCreate (&gCheckSum_serverGUID);

    fLdapInitialized = TRUE;

    return TRUE;
} // InitializeGlobals


VOID
DestroyGlobals(
    VOID
    )
/*++

Routine Description:

    Cleanup all global variables.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD i;

    //
    // Delete the critical section object
    //

    if ( !fLdapInitialized ) {
        return;
    }

    //
    // Wait for all connections to be freed
    //

    for (i=0; i < 20; i++) {

        InterlockedIncrement(&ActiveLdapConnObjects);
        if ( InterlockedDecrement(&ActiveLdapConnObjects) == 0 ) {
            break;
        }

        Sleep(500);
        DPRINT1(0,"Waiting for %d Connections to drain\n",
            ActiveLdapConnObjects);
    }

    if ( i == 20 ) {
        DPRINT(0,"Aborting Global cleanup\n");
        return;
    }

    //
    // Free cached connection blocks
    //
    Assert( IsListEmpty( &ActiveConnectionsList));

    ACQUIRE_LOCK(&LdapRequestCacheLock);

    while ( !IsListEmpty(&LdapRequestCacheList) ) {

        PLIST_ENTRY listEntry;
        PLDAP_REQUEST pRequest;

        listEntry = RemoveHeadList(&LdapRequestCacheList);
        pRequest = CONTAINING_RECORD(listEntry,LDAP_REQUEST,m_listEntry);
        delete pRequest;
    }

    RELEASE_LOCK(&LdapRequestCacheLock);


    ACQUIRE_LOCK(&LdapConnCacheLock);

    while ( !IsListEmpty(&LdapConnCacheList) ) {

        PLIST_ENTRY listEntry;
        PLDAP_CONN pConn;

        listEntry = RemoveHeadList(&LdapConnCacheList);
        pConn = CONTAINING_RECORD(listEntry,LDAP_CONN,m_listEntry);
        delete pConn;
    }

    RELEASE_LOCK(&LdapConnCacheLock);

    if ( LdapAttrCache != NULL ) {
        LdapFree(LdapAttrCache);
        LdapAttrCache = NULL;
    }

    DestroyLimits( );

    if (LdapBufferAllocs != 0) {
        IF_DEBUG(WARNING) {
            DPRINT1(0,"LdapBufferAllocs %x\n", LdapBufferAllocs);
        }
    }

    DeleteCriticalSection( &LdapRequestCacheLock );
    DeleteCriticalSection( &LdapConnCacheLock );
    DeleteCriticalSection( &csConnectionsListLock);
    DeleteCriticalSection( &LdapLimitsLock);
    DeleteCriticalSection( &PagedBlobLock );
    DeleteCriticalSection( &LdapSslLock );

} // Destroy Globals


VOID
CloseConnections( VOID )
/*++

Routine Description:

    This routine walks the list of LDAP_CONN structures calling ATQ to
    terminate the session.

Arguments:

    None.

Return Value:

    None.

--*/
{

    PLIST_ENTRY pentry;

    ACQUIRE_LOCK(&csConnectionsListLock);

    //
    //  Scan the blocked requests list looking for pending requests
    //   that needs to be unblocked and unblock these requests.
    //

    for (pentry  = ActiveConnectionsList.Flink;
         pentry != &ActiveConnectionsList;
         pentry  = pentry->Flink )
    {
        LDAP_CONN * pLdapConn = CONTAINING_RECORD(pentry,
                                                 LDAP_CONN,
                                                 m_listEntry );

        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_ATQ_CLOSE_SOCKET_SHUTDOWN,
                 NULL,
                 NULL,
                 NULL);

        AtqCloseSocket(pLdapConn->m_atqContext, TRUE);
    }


    RELEASE_LOCK(&csConnectionsListLock);

} // CloseConnections()



PLDAP_CONN
FindUserData (
        DWORD hClient
        )
/*++

Routine Description:

    Find the specified connection context

Arguments:

    hClient - client ID of connection to find.

Return Value:

    The pointer to the connection

--*/
{
    PLIST_ENTRY pentry;

    ACQUIRE_LOCK(&csConnectionsListLock);

    for (pentry  = ActiveConnectionsList.Flink;
         pentry != &ActiveConnectionsList;
         pentry  = pentry->Flink                   ) {

        PLDAP_CONN pLdapConn = CONTAINING_RECORD(pentry,
                                                 LDAP_CONN,
                                                 m_listEntry );

        if(pLdapConn->m_dwClientID == hClient) {

            //
            // Add a reference to it
            //

            pLdapConn->ReferenceConnection( );
            RELEASE_LOCK(&csConnectionsListLock);
            return pLdapConn;
        }
    }

    RELEASE_LOCK(&csConnectionsListLock);
    return NULL;

} // FindUserData


VOID
ReleaseUserData (
        PLDAP_CONN pLdapConn
        )
/*++

Routine Description:

    Release the connection found via FindUserData

Arguments:

    pLdapConn - connection to release.

Return Value:

    None

--*/
{
    pLdapConn->DereferenceConnection( );
    return;
} // ReleaseUserData


BOOL
InitializeTTLGlobals(
    VOID
    )
/*++

Routine Description:

    This routine attempts to initialize the ATTRTYP for the entryTtl attribute.
    This ATT_ID can be different on every DC so LDAP needs to find out what
    it is on this DC at runtime.

Arguments:

    None

Return Value:

    TRUE if initialization successful, FALSE otherwise

--*/
{
    BOOL            allocatedTHState = FALSE;
    BOOL            fRet = FALSE;
    BOOL            fDSA = TRUE;
    THSTATE*        pTHS = pTHStls;
    _enum1          code;
    AttributeType ldapAttrType = { 
        (sizeof(LDAP_TTL_ATT_OID) - 1),
        (PUCHAR)LDAP_TTL_ATT_OID
        };


    if ( pTHS == NULL ) {

        if ( (pTHS = InitTHSTATE(CALLERTYPE_LDAP)) == NULL) {
            DPRINT(0,"Unable to initialize thread state\n");
            return FALSE;
        }
        allocatedTHState = TRUE;
    }

    //
    // Convert the att oid to a DS att type
    //

    code = LDAP_AttrTypeToDirAttrTyp (pTHS,
                                      CP_UTF8,
                                      NULL,              // No Svccntl
                                      &ldapAttrType,
                                      &gTTLAttrType,     // Get the ATTRTYP
                                      NULL               // No AttCache
                                     );
    if (success != code) {
        goto exit;
    }


    fRet = TRUE;

exit:
    if ( allocatedTHState ) {
        free_thread_state();
    }
    return fRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\ldap\ldap.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ldap.cxx
//
//--------------------------------------------------------------------------

/******************************************************************/
/* Abstract syntax: ldap */
/* Created: Tue Jan 27 10:27:59 1998 */
/* ASN.1 compiler version: 4.2 Beta B */
/* Target operating system: Windows NT 3.5 or later/Windows 95 */
/* Target machine type: Intel x86 */
/* C compiler options required: -Zp8 (Microsoft) or equivalent */
/* ASN.1 compiler options specified:
 * -noshortennames -nouniquepdu -c++ -noconstraints -ber -gendirectives
 * ldapnew.gen
 */

#include   <stddef.h>
#include   <string.h>
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
#include   "etype.h"
#include   "ldap.h"

static struct ObjectID_ _v0[] = {
    {&_v0[1], 2},
    {NULL, 5}
};
ID ds = _v0;

static struct ObjectID_ _v1[] = {
    {&_v1[1], 2},
    {&_v1[2], 5},
    {NULL, 4}
};
ID attributeType = _v1;

static struct ObjectID_ _v2[] = {
    {&_v2[1], 2},
    {&_v2[2], 5},
    {NULL, 13}
};
ID matchingRule = _v2;

static struct ObjectID_ _v3[] = {
    {&_v3[1], 2},
    {&_v3[2], 5},
    {NULL, 4}
};
ID id_at = _v3;

static struct ObjectID_ _v4[] = {
    {&_v4[1], 2},
    {&_v4[2], 5},
    {NULL, 13}
};
ID id_mr = _v4;

static struct ObjectID_ _v6[] = {
    {&_v6[1], 2},
    {&_v6[2], 5},
    {&_v6[3], 13},
    {NULL, 0}
};
static struct MATCHING_RULE _v5 = {
    AssertionType_present,
    0,
    _v6
};
static struct ObjectID_ _v7[] = {
    {&_v7[1], 2},
    {&_v7[2], 5},
    {&_v7[3], 4},
    {NULL, 0}
};
ATTRIBUTE objectClass = {
    Type_present,
    NULL,
    0,
    &_v5,
    NULL,
    NULL,
    0,
    0,
    0,
    userApplications,
    _v7
};

static struct ObjectID_ _v9[] = {
    {&_v9[1], 2},
    {&_v9[2], 5},
    {&_v9[3], 13},
    {NULL, 1}
};
static struct MATCHING_RULE _v8 = {
    AssertionType_present,
    9,
    _v9
};
static struct ObjectID_ _v10[] = {
    {&_v10[1], 2},
    {&_v10[2], 5},
    {&_v10[3], 4},
    {NULL, 1}
};
ATTRIBUTE aliasedEntryName = {
    Type_present | single_valued_present,
    NULL,
    9,
    &_v8,
    NULL,
    NULL,
    TRUE,
    0,
    0,
    userApplications,
    _v10
};

static struct ObjectID_ _v11[] = {
    {&_v11[1], 2},
    {&_v11[2], 5},
    {&_v11[3], 13},
    {NULL, 0}
};
MATCHING_RULE objectIdentifierMatch = {
    AssertionType_present,
    0,
    _v11
};

static struct ObjectID_ _v12[] = {
    {&_v12[1], 2},
    {&_v12[2], 5},
    {&_v12[3], 13},
    {NULL, 1}
};
MATCHING_RULE distinguishedNameMatch = {
    AssertionType_present,
    9,
    _v12
};

static struct ObjectID_ _v13[] = {
    {&_v13[1], 2},
    {&_v13[2], 5},
    {&_v13[3], 4},
    {NULL, 0}
};
ObjectID id_at_objectClass = _v13;

static struct ObjectID_ _v14[] = {
    {&_v14[1], 2},
    {&_v14[2], 5},
    {&_v14[3], 4},
    {NULL, 1}
};
ObjectID id_at_aliasedEntryName = _v14;

static struct ObjectID_ _v15[] = {
    {&_v15[1], 2},
    {&_v15[2], 5},
    {&_v15[3], 13},
    {NULL, 0}
};
ObjectID id_mr_objectIdentifierMatch = _v15;

static struct ObjectID_ _v16[] = {
    {&_v16[1], 2},
    {&_v16[2], 5},
    {&_v16[3], 13},
    {NULL, 1}
};
ObjectID id_mr_distinguishedNameMatch = _v16;

int maxInt = 2147483647;

static int _v17 = 0;

static ossBoolean _v18 = FALSE;

static ossBoolean _v19 = FALSE;

static ossBoolean _v20 = FALSE;

static AttributeUsage _v21 = userApplications;

static ossBoolean _v22 = FALSE;

static ossBoolean _v23 = FALSE;

static ossBoolean _v24 = FALSE;

void DLL_ENTRY_FDEF _ossinit_ldap(struct ossGlobal *world) {
    ossLinkBer(world);
}

static MessageID _v25[2] = {0, 2147483647};
static unsigned short _v26[2] = {1, 127};
static unsigned int _v27[2] = {0, 2147483647};
static unsigned int _v28[2] = {0, 2147483647};
static AbandonRequest _v29[2] = {0, 2147483647};
static unsigned int _v30[2] = {1, 2147483647};
static unsigned int _v31[2] = {1, 2147483647};
static unsigned int _v32[2] = {0, 2147483647};
static unsigned int _v33[2] = {0, 2147483647};

static Version _v34[2] = {
   0, 1
};
static Version _v35[2] = {
   0, 1
};
static int _v36[4] = {
   0, 1, 2, 3
};
static int _v37[39] = {
   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 16, 17, 18, 19, 20, 21, 32,
   33, 34, 36, 48, 49, 50, 51, 52, 53, 54, 64, 65, 66, 67, 68, 69, 70, 71, 80
};
static int _v38[3] = {
   0, 1, 2
};
static int _v39[4] = {
   0, 1, 2, 3
};
static int _v40[3] = {
   0, 1, 2
};
static int _v41[11] = {
   0, 1, 2, 8, 11, 16, 18, 50, 51, 53, 80
};
static unsigned short _pduarray[] = {
    0, 9, 124, 129, 142, 146, 148, 154, 168, 171,
    175, 178
};

static struct etype _etypearray[] = {
    {-1, 0, 0, "ObjectID", 4, 4, 2, 4, 40, 0, 27, 0},
    {-1, 0, 0, "ObjectID", 4, 4, 2, 4, 40, 0, 27, 0},
    {-1, 2, 0, NULL, 2, 0, 0, 0, 8, 0, 50, 0},
    {-1, 3, 0, "TYPE-IDENTIFIER", 0, 2, 0, 0, 8, 0, 49, 0},
    {-1, 0, 0, "ID", 4, 4, 2, 4, 8, 0, 27, 0},
    {-1, 4, 0, "UniqueIdentifier", 8, 0, 4, 4, 8, 0, 3, 0},
    {-1, 0, 0, "ObjectID", 4, 4, 2, 4, 40, 0, 27, 0},
    {-1, 6, 0, NULL, 16, 0, 0, 0, 8, 0, 51, 0},
    {-1, 7, 9, "AlgorithmIdentifier", 24, 2, 1, 0, 8, 0, 12, 0},
    {-1, 15, 0, "DistinguishedName", 4, 4, 4, 4, 8, 42, 18, 0},
    {-1, 17, 9, "AlgorithmIdentifier", 24, 2, 1, 0, 8, 0, 12, 0},
    {-1, 20, 0, "DistinguishedName", 4, 4, 4, 4, 8, 42, 18, 0},
    {-1, 23, 0, NULL, 18, 0, 0, 0, 8, 0, 29, 0},
    {-1, 26, 0, NULL, 8, 0, 4, 4, 8, 0, 3, 0},
    {-1, 29, 31, NULL, 56, 4, 0, 0, 8, 2, 12, 0},
    {-1, 47, 0, NULL, 8, 0, 4, 4, 8, 0, 3, 0},
    {-1, 49, 51, "Token", 88, 3, 0, 0, 8, 6, 12, 0},
    {-1, 63, 0, "Version", 4, 0, 4, 0, 8, 1, 0, 0},
    {-1, 65, 0, "CertificateSerialNumber", 4, 0, 4, 0, 8, 0, 0, 0},
    {-1, 67, 68, "Name", 8, 1, 2, 4, 8, 9, 13, 0},
    {-1, 71, 0, NULL, 18, 0, 0, 0, 8, 0, 29, 0},
    {-1, 73, 75, "Validity", 36, 2, 0, 0, 8, 10, 12, 0},
    {-1, 83, 0, NULL, 8, 0, 4, 4, 8, 0, 3, 0},
    {-1, 85, 87, "SubjectPublicKeyInfo", 32, 2, 0, 0, 8, 12, 12, 0},
    {-1, 95, 0, "Version", 4, 0, 4, 0, 8, 5, 0, 0},
    {-1, 98, 0, "UniqueIdentifier", 8, 0, 4, 4, 8, 0, 3, 0},
    {-1, 100, 0, "UniqueIdentifier", 8, 0, 4, 4, 8, 0, 3, 0},
    {-1, 102, 104, NULL, 136, 9, 1, 0, 8, 14, 12, 0},
    {-1, 144, 0, NULL, 8, 0, 4, 4, 8, 0, 3, 0},
    {-1, 146, 148, "Certificate", 168, 3, 0, 0, 8, 23, 12, 0},
    {-1, 3, 0, "ALGORITHM", 0, 2, 0, 0, 8, 0, 49, 0},
    {-1, 160, 0, "SupportedAlgorithms", 4, 0, 0, 0, 12, 0, 52, 0},
    {-1, 161, 148, "Certificate", 168, 3, 0, 0, 8, 23, 12, 0},
    {-1, 164, 148, "Certificate", 168, 3, 0, 0, 8, 23, 12, 0},
    {-1, 167, 169, "CertificatePair", 340, 2, 1, 0, 8, 26, 12, 0},
    {-1, 179, 0, "_seqof1", 4, 340, 4, 4, 40, 34, 18, 0},
    {-1, 181, 183, "CertificationPath", 176, 2, 1, 0, 8, 28, 12, 0},
    {-1, 0, 0, "ObjectID", 4, 4, 2, 4, 40, 0, 27, 0},
    {-1, 191, 0, NULL, 16, 0, 0, 0, 8, 0, 51, 0},
    {-1, 192, 194, "AttributeTypeAndValue", 20, 2, 0, 0, 8, 30, 12, 0},
    {-1, 200, 0, "SupportedAttributes", 4, 0, 0, 0, 12, 0, 52, 0},
    {-1, 15, 0, "RDNSequence", 4, 4, 4, 4, 8, 42, 18, 0},
    {-1, 201, 0, "RelativeDistinguishedName", 4, 20, 4, 4, 8, 39, 15, 0},
    {3, 203, 0, "AttributeUsage", 4, 0, 4, 0, 24, 9, 58, 0},
    {-1, 205, 0, "ATTRIBUTE", 0, 10, 1, 0, 9, 0, 49, 0},
    {-1, 206, 0, NULL, 2, 0, 0, 0, 8, 0, 50, 0},
    {-1, 207, 0, "MATCHING-RULE", 0, 2, 1, 0, 9, 0, 49, 0},
    {-1, 207, 0, "MATCHING-RULE", 0, 2, 1, 0, 9, 0, 49, 0},
    {-1, 207, 0, "MATCHING-RULE", 0, 2, 1, 0, 9, 0, 49, 0},
    {-1, 208, 0, NULL, 1, 0, 0, 0, 8, 0, 8, 0},
    {-1, 205, 0, "ATTRIBUTE", 0, 10, 1, 0, 8, 0, 49, 0},
    {-1, 207, 0, "MATCHING-RULE", 0, 2, 1, 0, 8, 0, 49, 0},
    {-1, 210, 0, "MessageID", 4, 0, 4, 0, 136, 0, 55, 0},
    {-1, 212, 0, "LDAPString", 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 212, 0, "LDAPDN", 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 214, 0, NULL, 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 216, 218, "SaslCredentials", 16, 2, 0, 0, 8, 32, 12, 0},
    {-1, 226, 0, "_octet2", 8, 0, 4, 4, 40, 0, 20, 0},
    {-1, 228, 218, "SaslCredentials", 16, 2, 0, 0, 8, 32, 12, 0},
    {-1, 230, 0, "_octet1", 8, 0, 4, 4, 40, 0, 20, 0},
    {-1, 232, 0, "_octet2_2", 8, 0, 4, 4, 40, 0, 20, 0},
    {-1, 234, 0, "_octet3", 8, 0, 4, 4, 40, 0, 20, 0},
    {-1, 236, 237, "AuthenticationChoice", 20, 5, 2, 4, 8, 34, 13, 0},
    {-1, 248, 0, NULL, 2, 0, 2, 0, 136, 0, 55, 1},
    {-1, 250, 252, "BindRequest", 32, 3, 0, 0, 8, 39, 12, 0},
    {80, 272, 0, "_enum1", 4, 0, 4, 0, 56, 15, 58, 0},
    {-1, 274, 0, "Referral", 4, 8, 4, 4, 8, 130, 18, 0},
    {-1, 276, 237, "AuthenticationChoice", 20, 5, 2, 4, 8, 34, 13, 0},
    {-1, 278, 280, "BindResponse", 48, 5, 1, 0, 8, 42, 12, 0},
    {-1, 302, 0, "UnbindRequest", 1, 0, 0, 0, 8, 0, 5, 0},
    {-1, 212, 0, "AttributeDescription", 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 304, 0, "AssertionValue", 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 306, 308, "AttributeValueAssertion", 16, 2, 0, 0, 8, 47, 12, 0},
    {-1, 316, 0, "SubstringFilterList", 4, 12, 4, 4, 8, 138, 18, 0},
    {-1, 318, 320, "SubstringFilter", 12, 2, 0, 0, 8, 49, 12, 0},
    {-1, 212, 0, "AttributeType", 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 212, 0, "MatchingRuleId", 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 328, 0, "MatchingRuleId", 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 330, 0, "AttributeDescription", 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 332, 0, "AssertionValue", 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 334, 0, NULL, 1, 0, 0, 0, 8, 0, 8, 0},
    {-1, 336, 338, "MatchingRuleAssertion", 32, 4, 1, 0, 8, 51, 12, 0},
    {-1, 360, 362, "Filter", 36, 10, 2, 4, 9, 55, 13, 0},
    {-1, 383, 308, "AttributeValueAssertion", 16, 2, 0, 0, 8, 47, 12, 0},
    {-1, 385, 320, "SubstringFilter", 12, 2, 0, 0, 8, 49, 12, 0},
    {-1, 387, 308, "AttributeValueAssertion", 16, 2, 0, 0, 8, 47, 12, 0},
    {-1, 389, 308, "AttributeValueAssertion", 16, 2, 0, 0, 8, 47, 12, 0},
    {-1, 391, 0, "AttributeType", 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 393, 308, "AttributeValueAssertion", 16, 2, 0, 0, 8, 47, 12, 0},
    {-1, 395, 338, "MatchingRuleAssertion", 32, 4, 1, 0, 8, 51, 12, 0},
    {-1, 397, 362, "Filter", 36, 10, 2, 4, 8, 55, 13, 0},
    {-1, 398, 0, "_setof3", 4, 36, 4, 4, 40, 90, 15, 0},
    {-1, 400, 0, "_setof4", 4, 36, 4, 4, 40, 90, 15, 0},
    {2, 402, 0, "_enum2", 4, 0, 4, 0, 56, 56, 58, 0},
    {3, 404, 0, "_enum3", 4, 0, 4, 0, 56, 61, 58, 0},
    {-1, 406, 0, NULL, 4, 0, 4, 0, 136, 0, 55, 2},
    {-1, 408, 0, NULL, 4, 0, 4, 0, 136, 0, 55, 3},
    {-1, 410, 412, "SearchRequest", 68, 8, 0, 0, 8, 65, 12, 0},
    {-1, 462, 464, "SearchResultEntry", 12, 2, 0, 0, 8, 73, 12, 0},
    {-1, 472, 474, "LDAPResult", 28, 4, 1, 0, 8, 75, 12, 0},
    {-1, 490, 474, "SearchResultDone", 28, 4, 1, 0, 8, 75, 12, 0},
    {-1, 492, 0, "ModificationList", 4, 16, 4, 4, 8, 158, 18, 0},
    {-1, 494, 496, "ModifyRequest", 12, 2, 0, 0, 8, 79, 12, 0},
    {-1, 504, 474, "ModifyResponse", 28, 4, 1, 0, 8, 75, 12, 0},
    {-1, 506, 508, "AddRequest", 12, 2, 0, 0, 8, 81, 12, 0},
    {-1, 516, 474, "AddResponse", 28, 4, 1, 0, 8, 75, 12, 0},
    {-1, 518, 0, "DelRequest", 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 520, 474, "DelResponse", 28, 4, 1, 0, 8, 75, 12, 0},
    {-1, 212, 0, "RelativeLDAPDN", 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 522, 0, "LDAPDN", 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 524, 526, "ModifyDNRequest", 32, 4, 1, 0, 8, 83, 12, 0},
    {-1, 542, 474, "ModifyDNResponse", 28, 4, 1, 0, 8, 75, 12, 0},
    {-1, 544, 546, "CompareRequest", 24, 2, 0, 0, 8, 87, 12, 0},
    {-1, 554, 474, "CompareResponse", 28, 4, 1, 0, 8, 75, 12, 0},
    {-1, 556, 0, "AbandonRequest", 4, 0, 4, 0, 136, 0, 55, 4},
    {-1, 558, 0, "LDAPOID", 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 560, 0, "LDAPOID", 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 562, 0, NULL, 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 564, 566, "ExtendedRequest", 16, 2, 0, 0, 8, 89, 12, 0},
    {-1, 574, 0, "LDAPOID", 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 576, 0, NULL, 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 578, 580, "ExtendedResponse", 44, 6, 1, 0, 8, 91, 12, 0},
    {-1, 610, 611, "_choice1", 72, 20, 2, 4, 40, 97, 13, 0},
    {-1, 652, 0, "Controls", 4, 24, 4, 4, 8, 133, 18, 0},
    {-1, 654, 656, "LDAPMsg", 84, 3, 1, 0, 8, 117, 12, 0},
    {-1, 706, 0, "AttributeDescriptionList", 4, 8, 4, 4, 8, 70, 18, 0},
    {-1, 708, 0, "AttributeValue", 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 710, 0, "AttributeVals", 4, 8, 4, 4, 8, 126, 15, 0},
    {-1, 710, 0, "AttributeVals", 4, 8, 4, 4, 8, 126, 15, 0},
    {-1, 712, 714, "Attribute", 12, 2, 0, 0, 8, 120, 12, 0},
    {-1, 212, 0, "LDAPURL", 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 722, 0, "Referral", 4, 8, 4, 4, 8, 130, 18, 0},
    {-1, 724, 0, NULL, 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 726, 728, "Control", 24, 3, 1, 0, 8, 122, 12, 0},
    {-1, 742, 0, "Controls", 4, 24, 4, 4, 8, 133, 18, 0},
    {-1, 744, 0, "LDAPString", 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 746, 0, "LDAPString", 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 748, 0, "LDAPString", 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 750, 751, "_choice1", 12, 3, 2, 4, 40, 125, 13, 0},
    {-1, 316, 0, "SubstringFilterList", 4, 12, 4, 4, 8, 138, 18, 0},
    {-1, 758, 0, NULL, 4, 0, 4, 0, 136, 0, 55, 5},
    {-1, 760, 0, NULL, 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 762, 764, "PagedResultsSearchControlValue", 12, 2, 0, 0, 8, 128, 12, 0},
    {-1, 772, 0, NULL, 4, 0, 4, 0, 136, 0, 55, 6},
    {-1, 774, 0, NULL, 4, 0, 4, 0, 136, 0, 55, 7},
    {-1, 776, 0, NULL, 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 778, 780, "ReplicationSearchControlValue", 16, 3, 0, 0, 8, 130, 12, 0},
    {-1, 792, 0, NULL, 4, 0, 4, 0, 136, 0, 55, 8},
    {-1, 794, 796, "SecurityDescriptorSearchControlValue", 4, 1, 0, 0, 8, 133, 12, 0},
    {-1, 800, 802, "AttributeListElement", 12, 2, 0, 0, 8, 134, 12, 0},
    {-1, 800, 802, "AttributeListElement", 12, 2, 0, 0, 8, 134, 12, 0},
    {-1, 810, 0, "PartialAttributeList", 4, 12, 4, 4, 8, 150, 18, 0},
    {-1, 812, 0, "SearchResultReference", 4, 8, 4, 4, 8, 130, 18, 0},
    {-1, 814, 815, "_choice3", 32, 3, 2, 4, 40, 136, 13, 0},
    {-1, 822, 0, "SearchResultFull", 4, 32, 4, 4, 8, 153, 18, 0},
    {-1, 824, 0, "_setof1", 4, 8, 4, 4, 40, 126, 15, 0},
    {-1, 826, 828, "AttributeTypeAndValues", 12, 2, 0, 0, 8, 139, 12, 0},
    {2, 836, 0, "_enum1_2", 4, 0, 4, 0, 56, 67, 58, 0},
    {-1, 838, 840, NULL, 16, 2, 0, 0, 8, 141, 12, 0},
    {-1, 492, 0, "ModificationList", 4, 16, 4, 4, 8, 158, 18, 0},
    {-1, 800, 802, "AttributeListElement", 12, 2, 0, 0, 8, 134, 12, 0},
    {-1, 848, 0, "AttributeList", 4, 12, 4, 4, 8, 160, 18, 0},
    {-1, 850, 0, NULL, 18, 0, 0, 0, 8, 0, 29, 0},
    {-1, 852, 0, NULL, 18, 0, 0, 0, 8, 0, 29, 0},
    {-1, 854, 0, NULL, 8, 0, 4, 4, 8, 0, 3, 0},
    {-1, 856, 0, NULL, 8, 0, 4, 4, 8, 0, 3, 0},
    {-1, 858, 0, "LDAPOID", 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 860, 0, NULL, 8, 0, 4, 4, 8, 0, 3, 0},
    {-1, 862, 864, "ProtectedPassword", 72, 6, 1, 0, 8, 143, 12, 0},
    {-1, 908, 183, "CertificationPath", 176, 2, 1, 0, 8, 28, 12, 0},
    {-1, 910, 51, "Token", 88, 3, 0, 0, 8, 6, 12, 0},
    {-1, 912, 914, "StrongCredentials", 268, 2, 1, 0, 8, 149, 12, 0},
    {-1, 924, 0, "MatchingRuleId", 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 926, 0, NULL, 1, 0, 0, 0, 8, 0, 8, 0},
    {-1, 928, 930, NULL, 24, 3, 1, 0, 8, 151, 12, 0},
    {-1, 944, 0, "SortKeyList", 4, 24, 4, 4, 8, 174, 18, 0},
    {80, 946, 0, "_enum1_4", 4, 0, 4, 0, 56, 72, 58, 0},
    {-1, 948, 0, "AttributeType", 8, 0, 4, 4, 8, 0, 20, 0},
    {-1, 950, 952, "SortResult", 16, 2, 1, 0, 8, 154, 12, 0}
};

static struct ConstraintEntry _econstraintarray[] = {
    {5, 14, _v25},
    {5, 14, _v26},
    {5, 14, _v27},
    {5, 14, _v28},
    {5, 14, _v29},
    {5, 14, _v30},
    {5, 14, _v31},
    {5, 14, _v32},
    {5, 14, _v33}
};

static struct efield _efieldarray[] = {
    {4, 6, -1, 85, 2},
    {8, 7, 0, 86, 3},
    {0, 10, -1, 87, 2},
    {24, 11, -1, 88, 2},
    {28, 12, -1, 89, 2},
    {48, 13, -1, 90, 2},
    {0, 14, -1, 91, 2},
    {56, 8, -1, 92, 2},
    {80, 15, -1, 93, 2},
    {4, 41, -1, 94, 2},
    {0, 20, -1, 95, 2},
    {18, 20, -1, 96, 2},
    {0, 8, -1, 97, 2},
    {24, 22, -1, 98, 2},
    {4, 24, 0, 99, 7},
    {8, 18, -1, 101, 2},
    {12, 8, -1, 102, 2},
    {36, 19, -1, 103, 2},
    {44, 21, -1, 104, 2},
    {80, 19, -1, 105, 2},
    {88, 23, -1, 106, 2},
    {120, 25, 1, 107, 3},
    {128, 26, 2, 108, 3},
    {0, 27, -1, 109, 2},
    {136, 8, -1, 110, 2},
    {160, 28, -1, 111, 2},
    {4, 32, 0, 112, 3},
    {172, 33, 1, 113, 3},
    {4, 29, -1, 114, 2},
    {172, 35, 0, 115, 3},
    {0, 37, -1, 116, 2},
    {4, 38, -1, 117, 2},
    {0, 53, -1, 118, 2},
    {8, 55, -1, 119, 2},
    {4, 57, -1, 120, 2},
    {4, 58, -1, 121, 2},
    {4, 59, -1, 122, 2},
    {4, 60, -1, 123, 2},
    {4, 61, -1, 124, 2},
    {0, 63, -1, 125, 2},
    {4, 54, -1, 126, 2},
    {12, 62, -1, 127, 2},
    {4, 65, -1, 128, 2},
    {8, 54, -1, 129, 2},
    {16, 53, -1, 130, 2},
    {24, 66, 0, 131, 3},
    {28, 67, 1, 132, 3},
    {0, 70, -1, 133, 2},
    {8, 71, -1, 134, 2},
    {0, 70, -1, 135, 2},
    {8, 73, -1, 136, 2},
    {4, 77, 0, 137, 3},
    {12, 78, 1, 138, 3},
    {20, 79, -1, 139, 2},
    {28, 80, 2, 140, 7},
    {4, 91, -1, 142, 2},
    {4, 92, -1, 143, 2},
    {4, 82, -1, 144, 2},
    {4, 83, -1, 145, 2},
    {4, 84, -1, 146, 2},
    {4, 85, -1, 147, 2},
    {4, 86, -1, 148, 2},
    {4, 87, -1, 149, 2},
    {4, 88, -1, 150, 2},
    {4, 89, -1, 151, 2},
    {0, 54, -1, 152, 2},
    {8, 93, -1, 153, 2},
    {12, 94, -1, 154, 2},
    {16, 95, -1, 155, 2},
    {20, 96, -1, 156, 2},
    {24, 49, -1, 157, 2},
    {28, 90, -1, 158, 2},
    {64, 125, -1, 159, 2},
    {0, 54, -1, 160, 2},
    {8, 151, -1, 161, 2},
    {4, 65, -1, 162, 2},
    {8, 54, -1, 163, 2},
    {16, 53, -1, 164, 2},
    {24, 66, 0, 165, 3},
    {0, 54, -1, 166, 2},
    {8, 101, -1, 167, 2},
    {0, 54, -1, 168, 2},
    {8, 161, -1, 169, 2},
    {4, 54, -1, 170, 2},
    {12, 108, -1, 171, 2},
    {20, 49, -1, 172, 2},
    {24, 109, 0, 173, 3},
    {0, 54, -1, 174, 2},
    {8, 72, -1, 175, 2},
    {0, 116, -1, 176, 2},
    {8, 117, -1, 177, 2},
    {4, 65, -1, 178, 2},
    {8, 54, -1, 179, 2},
    {16, 53, -1, 180, 2},
    {24, 66, 0, 181, 3},
    {28, 119, 1, 182, 3},
    {36, 120, 2, 183, 3},
    {4, 64, -1, 184, 2},
    {4, 68, -1, 185, 2},
    {4, 69, -1, 186, 2},
    {4, 97, -1, 187, 2},
    {4, 98, -1, 188, 2},
    {4, 100, -1, 189, 2},
    {4, 152, -1, 190, 2},
    {4, 102, -1, 191, 2},
    {4, 103, -1, 192, 2},
    {4, 104, -1, 193, 2},
    {4, 105, -1, 194, 2},
    {4, 106, -1, 195, 2},
    {4, 107, -1, 196, 2},
    {4, 110, -1, 197, 2},
    {4, 111, -1, 198, 2},
    {4, 112, -1, 199, 2},
    {4, 113, -1, 200, 2},
    {4, 114, -1, 201, 2},
    {4, 118, -1, 202, 2},
    {4, 121, -1, 203, 2},
    {4, 52, -1, 204, 2},
    {8, 122, -1, 205, 2},
    {80, 123, 0, 206, 3},
    {0, 70, -1, 207, 2},
    {8, 128, -1, 208, 2},
    {4, 115, -1, 209, 2},
    {12, 49, 0, 210, 7},
    {16, 132, -1, 212, 2},
    {4, 135, -1, 213, 2},
    {4, 136, -1, 214, 2},
    {4, 137, -1, 215, 2},
    {0, 140, -1, 216, 2},
    {4, 141, -1, 217, 2},
    {0, 143, -1, 218, 2},
    {4, 144, -1, 219, 2},
    {8, 145, -1, 220, 2},
    {0, 147, -1, 221, 2},
    {0, 70, -1, 222, 2},
    {8, 127, -1, 223, 2},
    {4, 98, -1, 224, 2},
    {4, 152, -1, 225, 2},
    {4, 100, -1, 226, 2},
    {0, 70, -1, 227, 2},
    {8, 155, -1, 228, 2},
    {0, 157, -1, 229, 2},
    {4, 156, -1, 230, 2},
    {2, 162, 0, 231, 3},
    {20, 163, 1, 232, 3},
    {40, 164, 2, 233, 3},
    {48, 165, 3, 234, 3},
    {56, 166, -1, 235, 2},
    {64, 167, -1, 236, 2},
    {4, 169, 0, 237, 3},
    {180, 170, -1, 238, 2},
    {4, 75, -1, 239, 2},
    {12, 172, 0, 240, 3},
    {20, 173, 1, 241, 7},
    {4, 176, -1, 243, 2},
    {8, 177, 0, 244, 3}
};

static void *_enamearray[] = {
    (void *)0,
    (void *)0x2, _v34,
    "v1", "v2",
    (void *)0x2, _v35,
    "v1", "v2",
    (void *)0x4, _v36,
    "userApplications", "directoryOperation", "distributedOperation", "dSAOperation",
    (void *)0x27, _v37,
    "success", "operationsError", "protocolError", "timeLimitExceeded", "sizeLimitExceeded",
    "compareFalse", "compareTrue", "authMethodNotSupported", "strongAuthRequired", "referralv2",
    "referral", "adminLimitExceeded", "unavailableCriticalExtension", "noSuchAttribute", "undefinedAttributeType",
    "inappropriateMatching", "constraintViolation", "attributeOrValueExists", "invalidAttributeSyntax", "noSuchObject",
    "aliasProblem", "invalidDNSyntax", "aliasDereferencingProblem", "inappropriateAuthentication", "invalidCredentials",
    "insufficientAccessRights", "busy", "unavailable", "unwillingToPerform", "loopDetect",
    "namingViolation", "objectClassViolation", "notAllowedOnNonLeaf", "notAllowedOnRDN", "entryAlreadyExists",
    "objectClassModsProhibited", "resultsTooLarge", "affectsMultipleDSAs", "other",
    (void *)0x3, _v38,
    "baseObject", "singleLevel", "wholeSubtree",
    (void *)0x4, _v39,
    "neverDerefAliases", "derefInSearching", "derefFindingBaseObj", "derefAlways",
    (void *)0x3, _v40,
    "add", "delete", "replace",
    (void *)0xb, _v41,
    "sortSuccess", "sortOperationsError", "sortTimeLimitExceeded", "sortStrongAuthRequired", "sortAdminLimitExceeded",
    "sortNoSuchAttribute", "sortInappropriateMatching", "sortInsufficientAccessRights", "sortBusy", "sortUnwillingToPerform",
    "sortOther",
    "algorithm",
    "parameters",
    "algorithm",
    "name",
    "time",
    "random",
    "toBeSigned",
    "algorithmIdentifier",
    "encrypted",
    "rdnSequence",
    "notBefore",
    "notAfter",
    "algorithm",
    "subjectPublicKey",
    "version", &_v17,
    "serialNumber",
    "signature",
    "issuer",
    "validity",
    "subject",
    "subjectPublicKeyInfo",
    "issuerUniqueIdentifier",
    "subjectUniqueIdentifier",
    "toBeSigned",
    "algorithmIdentifier",
    "encrypted",
    "forward",
    "reverse",
    "userCertificate",
    "theCACertificates",
    "type",
    "value",
    "mechanism",
    "credentials",
    "simple",
    "sasl",
    "sicilyNegotiate",
    "sicilyInitial",
    "sicilySubsequent",
    "version",
    "name",
    "authentication",
    "resultCode",
    "matchedDN",
    "errorMessage",
    "referral",
    "serverCreds",
    "attributeDesc",
    "assertionValue",
    "type",
    "substrings",
    "matchingRule",
    "type",
    "matchValue",
    "dnAttributes", &_v22,
    "and",
    "or",
    "not",
    "equalityMatch",
    "substrings",
    "greaterOrEqual",
    "lessOrEqual",
    "present",
    "approxMatch",
    "extensibleMatch",
    "baseObject",
    "scope",
    "derefAliases",
    "sizeLimit",
    "timeLimit",
    "typesOnly",
    "filter",
    "attributes",
    "objectName",
    "attributes",
    "resultCode",
    "matchedDN",
    "errorMessage",
    "referral",
    "object",
    "modification",
    "entry",
    "attributes",
    "entry",
    "newrdn",
    "deleteoldrdn",
    "newSuperior",
    "entry",
    "ava",
    "requestName",
    "requestValue",
    "resultCode",
    "matchedDN",
    "errorMessage",
    "referral",
    "responseName",
    "response",
    "bindRequest",
    "bindResponse",
    "unbindRequest",
    "searchRequest",
    "searchResEntry",
    "searchResDone",
    "searchResRef",
    "modifyRequest",
    "modifyResponse",
    "addRequest",
    "addResponse",
    "delRequest",
    "delResponse",
    "modDNRequest",
    "modDNResponse",
    "compareRequest",
    "compareResponse",
    "abandonRequest",
    "extendedReq",
    "extendedResp",
    "messageID",
    "protocolOp",
    "controls",
    "type",
    "vals",
    "controlType",
    "criticality", &_v23,
    "controlValue",
    "initial",
    "any",
    "final",
    "size",
    "cookie",
    "flag",
    "size",
    "cookie",
    "flags",
    "type",
    "vals",
    "entry",
    "reference",
    "resultCode",
    "type",
    "vals",
    "operation",
    "modification",
    "time1",
    "time2",
    "random1",
    "random2",
    "algorithmIdentifier",
    "encipheredPassword",
    "certification-path",
    "bind-token",
    "attributeType",
    "orderingRule",
    "reverseOrder", &_v24,
    "sortResult",
    "attributeType"
};

static Etag _tagarray[] = {
    1, 0x0006, 0, 0, 1, 0x0003, 0, 1, 0x0010, 11,
    14, 1, 0x0006, 1, 0, 1, 0x0010, 2, 0x8000, 0x0010,
    2, 0x8001, 0x0010, 2, 0x8002, 0x0017, 2, 0x8003, 0x0003, 1,
    0x0010, 35, 38, 41, 44, 1, 0x8000, 1, 1, 0x8001,
    2, 1, 0x8002, 3, 1, 0x8003, 4, 1, 0x0003, 1,
    0x0010, 54, 57, 60, 1, 0x0010, 1, 1, 0x0010, 2,
    1, 0x0003, 3, 1, 0x0002, 1, 0x0002, 0, 1, 0x0010,
    1, 1, 0x0017, 1, 0x0010, 77, 80, 1, 0x0017, 1,
    1, 0x0017, 2, 1, 0x0003, 1, 0x0010, 89, 92, 1,
    0x0010, 1, 1, 0x0003, 2, 2, 0x8000, 0x0002, 1, 0x8001,
    1, 0x8002, 1, 0x0010, 113, 118, 121, 124, 127, 130,
    133, 136, 141, 2, 0x0002, 2, 0x8000, 1, 1, 0x0002,
    2, 1, 0x0010, 3, 1, 0x0010, 4, 1, 0x0010, 5,
    1, 0x0010, 6, 1, 0x0010, 7, 2, 0x8001, 8, 0x8002,
    9, 1, 0x8002, 9, 1, 0x0003, 1, 0x0010, 151, 154,
    157, 1, 0x0010, 1, 1, 0x0010, 2, 1, 0x0003, 3,
    0, 2, 0x8000, 0x0010, 2, 0x8001, 0x0010, 1, 0x0010, 171,
    176, 2, 0x8000, 1, 0x8001, 2, 1, 0x8001, 2, 1,
    0x0010, 1, 0x0010, 185, 188, 1, 0x0010, 1, 1, 0x0010,
    2, 0, 1, 0x0010, 196, 199, 1, 0x0006, 1, 0,
    0, 1, 0x0011, 1, 0x000a, 0, 0, 0, 1, 0x0001,
    1, 0x0002, 1, 0x0004, 1, 0x0004, 1, 0x0010, 220, 223,
    1, 0x0004, 1, 1, 0x0004, 2, 1, 0x8000, 1, 0x8003,
    1, 0x8009, 1, 0x800a, 1, 0x800b, 0, 5, 0x8000, 1,
    0x8003, 2, 0x8009, 3, 0x800a, 4, 0x800b, 5, 1, 0x0002,
    1, 0x4000, 255, 258, 261, 1, 0x0002, 1, 1, 0x0004,
    2, 5, 0x8000, 3, 0x8003, 3, 0x8009, 3, 0x800a, 3,
    0x800b, 3, 1, 0x000a, 1, 0x8003, 1, 0x8007, 1, 0x4001,
    285, 288, 291, 294, 299, 1, 0x000a, 1, 1, 0x0004,
    2, 1, 0x0004, 3, 2, 0x8003, 4, 0x8007, 5, 1,
    0x8007, 5, 1, 0x4002, 1, 0x0004, 1, 0x0010, 310, 313,
    1, 0x0004, 1, 1, 0x0004, 2, 1, 0x0010, 1, 0x0010,
    322, 325, 1, 0x0004, 1, 1, 0x0010, 2, 1, 0x8001,
    1, 0x8002, 1, 0x8003, 1, 0x8004, 1, 0x0010, 342, 349,
    354, 357, 3, 0x8001, 1, 0x8002, 2, 0x8003, 3, 2,
    0x8002, 2, 0x8003, 3, 1, 0x8003, 3, 1, 0x8004, 4,
    1, 0x8002, 10, 0x8000, 1, 0x8001, 2, 0x8002, 3, 0x8003,
    4, 0x8004, 5, 0x8005, 6, 0x8006, 7, 0x8007, 8, 0x8008,
    9, 0x8009, 10, 1, 0x8003, 1, 0x8004, 1, 0x8005, 1,
    0x8006, 1, 0x8007, 1, 0x8008, 1, 0x8009, 0, 1, 0x8000,
    1, 0x8001, 1, 0x000a, 1, 0x000a, 1, 0x0002, 1, 0x0002,
    1, 0x4003, 420, 423, 426, 429, 432, 435, 438, 459,
    1, 0x0004, 1, 1, 0x000a, 2, 1, 0x000a, 3, 1,
    0x0002, 4, 1, 0x0002, 5, 1, 0x0001, 6, 10, 0x8000,
    7, 0x8001, 7, 0x8002, 7, 0x8003, 7, 0x8004, 7, 0x8005,
    7, 0x8006, 7, 0x8007, 7, 0x8008, 7, 0x8009, 7, 1,
    0x0010, 8, 1, 0x4004, 466, 469, 1, 0x0004, 1, 1,
    0x0010, 2, 1, 0x0010, 478, 481, 484, 487, 1, 0x000a,
    1, 1, 0x0004, 2, 1, 0x0004, 3, 1, 0x8003, 4,
    1, 0x4005, 1, 0x0010, 1, 0x4006, 498, 501, 1, 0x0004,
    1, 1, 0x0010, 2, 1, 0x4007, 1, 0x4008, 510, 513,
    1, 0x0004, 1, 1, 0x0010, 2, 1, 0x4009, 1, 0x400a,
    1, 0x400b, 1, 0x8000, 1, 0x400c, 530, 533, 536, 539,
    1, 0x0004, 1, 1, 0x0004, 2, 1, 0x0001, 3, 1,
    0x8000, 4, 1, 0x400d, 1, 0x400e, 548, 551, 1, 0x0004,
    1, 1, 0x0010, 2, 1, 0x400f, 1, 0x4010, 1, 0x0004,
    1, 0x8000, 1, 0x8001, 1, 0x4017, 568, 571, 1, 0x8000,
    1, 1, 0x8001, 2, 1, 0x800a, 1, 0x800b, 1, 0x4018,
    586, 589, 592, 595, 602, 607, 1, 0x000a, 1, 1,
    0x0004, 2, 1, 0x0004, 3, 3, 0x8003, 4, 0x800a, 5,
    0x800b, 6, 2, 0x800a, 5, 0x800b, 6, 1, 0x800b, 6,
    0, 20, 0x4000, 1, 0x4001, 2, 0x4002, 3, 0x4003, 4,
    0x4004, 5, 0x4005, 6, 0x4006, 8, 0x4007, 9, 0x4008, 10,
    0x4009, 11, 0x400a, 12, 0x400b, 13, 0x400c, 14, 0x400d, 15,
    0x400e, 16, 0x400f, 17, 0x4010, 18, 0x4013, 7, 0x4017, 19,
    0x4018, 20, 1, 0x8000, 1, 0x0010, 659, 662, 703, 1,
    0x0002, 1, 20, 0x4000, 2, 0x4001, 2, 0x4002, 2, 0x4003,
    2, 0x4004, 2, 0x4005, 2, 0x4006, 2, 0x4007, 2, 0x4008,
    2, 0x4009, 2, 0x400a, 2, 0x400b, 2, 0x400c, 2, 0x400d,
    2, 0x400e, 2, 0x400f, 2, 0x4010, 2, 0x4013, 2, 0x4017,
    2, 0x4018, 2, 1, 0x8000, 3, 1, 0x0010, 1, 0x0004,
    1, 0x0011, 1, 0x0010, 716, 719, 1, 0x0004, 1, 1,
    0x0011, 2, 1, 0x0010, 1, 0x0004, 1, 0x0010, 731, 734,
    739, 1, 0x0004, 1, 2, 0x0001, 2, 0x0004, 3, 1,
    0x0004, 3, 1, 0x0010, 1, 0x8000, 1, 0x8001, 1, 0x8002,
    0, 3, 0x8000, 1, 0x8001, 2, 0x8002, 3, 1, 0x0002,
    1, 0x0004, 1, 0x0010, 766, 769, 1, 0x0002, 1, 1,
    0x0004, 2, 1, 0x0002, 1, 0x0002, 1, 0x0004, 1, 0x0010,
    783, 786, 789, 1, 0x0002, 1, 1, 0x0002, 2, 1,
    0x0004, 3, 1, 0x0002, 1, 0x0010, 797, 1, 0x0002, 1,
    1, 0x0010, 804, 807, 1, 0x0004, 1, 1, 0x0011, 2,
    1, 0x0010, 1, 0x4013, 0, 3, 0x4004, 1, 0x4005, 3,
    0x4013, 2, 1, 0x0010, 1, 0x0011, 1, 0x0010, 830, 833,
    1, 0x0004, 1, 1, 0x0011, 2, 1, 0x000a, 1, 0x0010,
    842, 845, 1, 0x000a, 1, 1, 0x0010, 2, 1, 0x0010,
    1, 0x8000, 1, 0x8001, 1, 0x8002, 1, 0x8003, 1, 0x8004,
    1, 0x8005, 1, 0x0010, 870, 881, 890, 897, 902, 905,
    5, 0x8000, 1, 0x8001, 2, 0x8002, 3, 0x8003, 4, 0x8004,
    5, 4, 0x8001, 2, 0x8002, 3, 0x8003, 4, 0x8004, 5,
    3, 0x8002, 3, 0x8003, 4, 0x8004, 5, 2, 0x8003, 4,
    0x8004, 5, 1, 0x8004, 5, 1, 0x8005, 6, 1, 0x8000,
    1, 0x8001, 1, 0x0010, 916, 921, 2, 0x8000, 1, 0x8001,
    2, 1, 0x8001, 2, 1, 0x8000, 1, 0x8001, 1, 0x0010,
    933, 936, 941, 1, 0x0004, 1, 2, 0x8000, 2, 0x8001,
    3, 1, 0x8001, 3, 1, 0x0010, 1, 0x000a, 1, 0x8000,
    1, 0x0010, 954, 957, 1, 0x000a, 1, 1, 0x8000, 2
};

static struct eheader _head = {_ossinit_ldap, -1, 15, 805, 12, 179,
    _pduarray, _etypearray, _efieldarray, _enamearray, _tagarray,
    _econstraintarray, NULL, NULL, 0};

#ifdef _OSSGETHEADER
void *DLL_ENTRY_FDEF ossGetHeader()
{
    return &_head;
}
#endif /* _OSSGETHEADER */

void *ldap = &_head;
#ifdef __cplusplus
}	/* extern "C" */
#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\ldap\ldapber.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    ldapber.cxx

Abstract:

    ber conversions

Author:

    Johnson Apacible (JohnsonA) 30-Jan-1998

--*/

#include <NTDSpchx.h>
#pragma  hdrstop

#include "ldapsvr.hxx"

#define  FILENO FILENO_LDAP_LDAPBER

extern LDAPOID KnownControls[];

#define MAX_BER_TAGLEN  6

VOID
_fastcall
AddInt(
   PUCHAR pbData, 
   ULONG cbValue, 
   LONG lValue)
{
    ULONG i;

    for (i=cbValue; i > 0; i--) {
        *pbData++ = (BYTE)(lValue >> ((i - 1) * 8)) & 0xff;
    }
} // AddInt


VOID
_fastcall
FillTagLen(
    IN PUCHAR *Buf,
    IN UCHAR  Tag,
    IN DWORD  Length,
    IN BOOL   UseMaxLen
    )
/*++

Routine Description:

    Fills the tag and length portion of the encoding

Arguments:

    pBuf - address of a pointer to the buffer to fill
    Tag - if given, the tag used for the encoding. Else, defaults to 0x4
    Length - length to fill in
    UseMaxLen - should we use the full byte length encoding?

Return Value:

    None.

--*/
{
    PUCHAR p = *Buf;
    PUCHAR l;
    DWORD i;

    *p++ = Tag;
    if ( !UseMaxLen && (Length < 0x7f) ) {
        *p++ = (UCHAR)Length;
    } else {

        *p++ = 0x84;
        *p++ = (UCHAR)((Length & 0xFF000000) >> 24);
        *p++ = (UCHAR)((Length & 0x00FF0000) >> 16);
        *p++ = (UCHAR)((Length & 0x0000FF00) >> 8);
        *p++ = (UCHAR)(Length & 0x000000FF);
    }

    *Buf = p;
    return;
} // FillTagLen


VOID
_fastcall
BerFillOctet(
    IN PUCHAR   *pBuf,
    IN PUCHAR   OctetString,
    IN DWORD    StringLen,
    IN PUCHAR   Tag = NULL
    )
/*++

Routine Description:

    Fills the ber encoded octet string

Arguments:

    pBuf - address of a pointer to the buffer to fill
    OctetString - octet string to copy
    StringLen - length of the octet string
    Tag - if given, the tag used for the encoding. Else, defaults to 0x4

Return Value:

    None.

--*/
{
    PUCHAR p = *pBuf;

    FillTagLen(&p, (Tag == NULL) ? 0x04 : *Tag, StringLen, FALSE);

    if ( StringLen != 0 ) {
        CopyMemory(p,
                   OctetString,
                   StringLen
                   );
        p += StringLen;
    }

    *pBuf = p;
    return;
} // BerFillOctet


DWORD
DerFillDwordEx(
    IN PUCHAR   *pBuf,
    IN DWORD    i,
    IN UCHAR    Tag
    )
/*++

Routine Description:

    Fills the ber encoded Dword

Arguments:

    pBuf - address of a pointer to the buffer to fill
    Value - value of DWORD to fill.
    Tag   - The tag to apply to the DER encoded DWORD.

Return Value:

    The total size of the encoded value.

--*/
{
    PUCHAR  p = *pBuf;
    ULONG   cbInt;
    DWORD   dwMask = 0xff000000;
    DWORD   dwHiBitMask = 0x80000000;

    if (i == 0){
        cbInt = 1;
    } else {

        cbInt = sizeof(LONG);
        while (dwMask && !(i & dwMask)) {
            dwHiBitMask >>= 8;
            dwMask >>= 8;
            cbInt--;
        }

        if (!(i & 0x80000000)) {

            //
            //  the value to insert was a positive number, make sure we allow
            //  for it by sending an extra bytes since it's not negative.
            //

            if (i & dwHiBitMask) {
                cbInt++;
            }

        }
    }

    //
    // Set tag, skip length
    //

    *p++ = Tag;
    *p++ = (UCHAR)cbInt;

    AddInt(p, cbInt, i);
    p += cbInt;

    *pBuf = p;
    return cbInt + 2;  // 2 is for the Tag and the length.
} // DerFillDword


VOID
DerFillDword(
    IN PUCHAR   *pBuf,
    IN DWORD    i
    )
/*++

Routine Description:

    Fills the ber encoded Dword

Arguments:

    pBuf - address of a pointer to the buffer to fill
    Value - value of DWORD to fill.

Return Value:

    None.

--*/
{
    DerFillDwordEx(pBuf, i, 0x02);

    return;
} // DerFillDword


DWORD
DecodeSDControl(
    IN PBERVAL  Bv,
    IN PDWORD   Flags
    )
/*++

Routine Description:

    BER Decode the SD Control

Arguments:

    Bv - berval containing info to decode.
    Flags - pointer to DWORD for returning flag.

Return Value:

    0 if success, else error code.

--*/
{
    BerElement *ber;
    ULONG res;

    ber = ber_init(Bv);
    if ( ber == NULL ) {
        IF_DEBUG(ENCODE) {
            DPRINT1(0,"DecodeSDControl: ber_init failed with %d\n", 
                    GetLastError());
        }
        return ERROR_GEN_FAILURE;
    }

    res = ber_scanf(ber,"{i}", Flags);
    ber_free(ber,1);

    if ( res == LBER_ERROR ) {
        IF_DEBUG(ENCODE) {
            DPRINT1(0,"DecodeSDControl: ber_scanf failed with %d\n", 
                 GetLastError());
        }
        return ERROR_INVALID_PARAMETER;
    }

    IF_DEBUG(SEARCH){
        DPRINT1(0,"Got SD flag %x\n", *Flags);
    }

    return ERROR_SUCCESS;

} // DecodeSDControl


DWORD
DecodeReplicationControl(
    IN PBERVAL  Bv,
    IN PDWORD   Flags,
    IN PDWORD   Size,
    IN PBERVAL  Cookie
    )
/*++

Routine Description:

    BER Decode the Replication control.

Arguments:

    Bv - berval containing info to decode.
    pFlags - pointer to     

Return Value:

    0 if success, else error code.

--*/
{
    BerElement *ber;
    ULONG res;
    PBERVAL cookieVal = NULL;
    DWORD cookieLen = 0;

    Cookie->bv_val = NULL;
    Cookie->bv_len = 0;

    ber = ber_init(Bv);
    if ( ber == NULL ) {
        IF_DEBUG(ENCODE) {
            DPRINT1(0,"DecodeReplControl: ber_init failed with %d\n", 
                    GetLastError());
        }
        return ERROR_GEN_FAILURE;
    }

    res = ber_scanf(ber,"{iiO}", Flags, Size, &cookieVal);
    ber_free(ber,1);

    if ( res == LBER_ERROR ) {
        IF_DEBUG(ENCODE) {
            DPRINT1(0,"DecodeReplControl: ber_scanf failed with %d\n", 
                 GetLastError());
        }
        return ERROR_INVALID_PARAMETER;
    }

    if ( cookieVal != NULL ) {
        cookieLen = cookieVal->bv_len;
    }

    if(cookieLen != 0) {
        if(cookieLen < (sizeof(USN) + sizeof(USN_VECTOR))) {
            ber_bvfree(cookieVal);
            return ERROR_INVALID_PARAMETER;
        }

        //Allocate buffer for cookie. The pointer is 8-byte aligned               
        Cookie->bv_val = (PCHAR) THAlloc(cookieLen);

        if(Cookie->bv_val == NULL ) {

            IF_DEBUG(ERROR) {
                DPRINT2(0,"DecodeReplControl: alloc[%d] failed with %d\n",
                    cookieLen, GetLastError());
            }
            ber_bvfree(cookieVal);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        Cookie->bv_len = cookieLen;
        CopyMemory(
                Cookie->bv_val,
                cookieVal->bv_val,
                cookieLen
                );
    }

    if ( cookieVal != NULL ) {
        ber_bvfree(cookieVal);
    }
    return ERROR_SUCCESS;
} // DecodeReplicationControl


DWORD
DecodeGCVerifyControl(
    IN PBERVAL  Bv,
    IN PDWORD   Flags,
    IN PWCHAR  *ServerName
    )
/*++

Routine Description:

    BER Decode the server verify hint control.

Arguments:

    Bv - berval containing info to decode.
    pFlags - pointer to DWORD to receive value of flag
    ServerName - pointer to buffer to receive the server name

Return Value:

    0 if success, else error code.

--*/
{
    BerElement *ber;
    ULONG res;
    PBERVAL serverVal = NULL;
    DWORD serverLen = 0;
    DWORD ret = ERROR_SUCCESS;
    PWCHAR tmpBuf;

    *ServerName = NULL;

    ber = ber_init(Bv);
    if ( ber == NULL ) {
        IF_DEBUG(WARNING) {
            DPRINT1(0,"DecodeGCVerify: ber_init failed with %d\n", 
                    GetLastError());
        }
        return ERROR_GEN_FAILURE;
    }

    res = ber_scanf(ber,"{iO}", Flags, &serverVal);

    if ( res == LBER_ERROR ) {
        IF_DEBUG(WARNING) {
            DPRINT1(0,"DecodeGCVerifyControl: ber_scanf failed with %d\n", 
                 GetLastError());
        }
        ret = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    if ( serverVal != NULL ) {
        serverLen = serverVal->bv_len;
    }

    //
    // Length should not be zero or odd
    //

    if ( (serverLen == 0) || ((serverLen & 0x1) != 0) ) {
        IF_DEBUG(WARNING) {
            DPRINT1(0,"DecodeGCVerifyControl: invalid server name length %d.\n",
                   serverLen);
        }
        ret = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    //
    // Copy the unicode string
    //

    tmpBuf = (PWCHAR)THAlloc(serverLen + sizeof(WCHAR));
    if ( tmpBuf == NULL ) {
        IF_DEBUG(NOMEM) {
            DPRINT(0,"DecodeGCVerifyControl: Cannot allocate memory\n");
        }
        ret = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    CopyMemory(tmpBuf, serverVal->bv_val, serverLen);
    tmpBuf[serverLen/sizeof(WCHAR)] = L'\0';
    *ServerName = tmpBuf;

exit:
    if ( serverVal != NULL ) {
        ber_bvfree(serverVal);
    }

    if ( ber != NULL ) {
        ber_free(ber,1);
    }
    return ret;
} // DecodeGCVerifyControl


DWORD
DecodeSearchOptionControl(
    IN PBERVAL  Bv,
    IN PDWORD   Flags
    )
/*++

Routine Description:

    BER Decode the Search Option control.

Arguments:

    Bv - berval containing info to decode.
    pFlags - pointer to dword to receive the value of the flag

Return Value:

    0 if success, else error code.

--*/
{
    BerElement *ber;
    ULONG res;
    DWORD ret = ERROR_SUCCESS;

    ber = ber_init(Bv);
    if ( ber == NULL ) {
        IF_DEBUG(WARNING) {
            DPRINT1(0,"DecodeSearchOption: ber_init failed with %d\n", 
                    GetLastError());
        }
        return ERROR_GEN_FAILURE;
    }

    res = ber_scanf(ber,"{i}", Flags);

    if ( res == LBER_ERROR ) {
        IF_DEBUG(WARNING) {
            DPRINT1(0,"DecodeSearchOptionControl: ber_scanf failed with %d\n", 
                 GetLastError());
        }
        ret = ERROR_INVALID_PARAMETER;
        goto exit;
    }

exit:

    if ( ber != NULL ) {
        ber_free(ber,1);
    }
    return ret;
} // DecodeSearchOption


DWORD
DecodeStatControl(
    IN PBERVAL  Bv,
    IN PDWORD   Flags
    )
/*++

Routine Description:

    BER Decode the Stat control.

Arguments:

    Bv - berval containing info to decode.
    pFlags - pointer to dword to receive the value of the flag

Return Value:

    0 if success, else error code.

--*/
{
    BerElement *ber;

    if (Bv->bv_len == sizeof (DWORD) && Bv->bv_val && Flags) {

        *Flags = *(DWORD *)Bv->bv_val;

        return ERROR_SUCCESS;
    }
    
    return ERROR_INVALID_PARAMETER;

} // DecodeStatControl


DWORD
DecodePagedControl(
    IN PBERVAL  Bv,
    IN PDWORD   Size,
    IN PBERVAL  Cookie
    )
/*++

Routine Description:

    Decode a paged control

Arguments:

    CodePage - code page to use              
    Bv - points to the sort control blob sent by the client
    fReverseSort - on return, whether the sort is reverse ordering
    SortAttr - attribute to sort on

Return Value:

    ERROR_SUCCESS   - encoding went well.
    ERROR_GEN_FAILURE - error with the ber package
    ERROR_NOT_ENOUGH_MEMORY - cannot allocate send buffers.
    
--*/
{

    BerElement *ber;
    ULONG res;
    PBERVAL cookieVal = NULL;
    DWORD   cookieLen = 0;

    Cookie->bv_val = NULL;
    Cookie->bv_len = 0;
    
    ber = ber_init(Bv);
    if ( ber == NULL ) {
        IF_DEBUG(ENCODE) {
            DPRINT1(0,"DecodePagedControl: ber_init failed with %d\n", 
                    GetLastError());
        }
        return ERROR_GEN_FAILURE;
    }

    res = ber_scanf(ber,"{iO}", Size, &cookieVal);
    ber_free(ber,1);

    IF_DEBUG(PAGED) {
        DPRINT3(0,"PagedControl: decode result is %x Size %d Cookie %x\n",
                 res, *Size, cookieVal);
    }

    if ( res == LBER_ERROR ) {
        IF_DEBUG(ENCODE) {
            DPRINT1(0,"DecodePagedControl: ber_scanf failed with %d\n", 
                 GetLastError());
        }
        return ERROR_INVALID_PARAMETER;
    }

    if ( cookieVal != NULL ) {
        cookieLen = cookieVal->bv_len;
    } 

    if(cookieLen > 0 ) {

        PRESTART pRestart = (PRESTART)cookieVal->bv_val;

        IF_DEBUG(PAGED) {
            DPRINT1(0,"Cookie Length is %d\n",cookieLen);
        }

        if( (cookieLen != sizeof(DWORD)) &&
             ((cookieLen < sizeof(RESTART))      ||
              (cookieLen != pRestart->structLen))) {

            //
            // Our cookies are DWORDs, which are handles
            //

            ber_bvfree(cookieVal);
            IF_DEBUG(ERROR) {
                DPRINT1(0,"DecodePagedControl: Invalid cookie len[%d]\n",
                        cookieLen);
            }
            return ERROR_INVALID_PARAMETER;
        }
        
        Cookie->bv_val = (PCHAR) THAlloc(cookieLen);
        if(Cookie->bv_val == NULL) {
            IF_DEBUG(ERROR) {
                DPRINT2(0,"DecodePagedControl: alloc[%d] failed with %d\n",
                    cookieLen, GetLastError());
            }
            ber_bvfree(cookieVal);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        Cookie->bv_len = cookieLen;
        CopyMemory(
                Cookie->bv_val,
                cookieVal->bv_val,
                cookieLen
                );
    } 

    if ( cookieVal != NULL ) {
        ber_bvfree(cookieVal);
    }
    return ERROR_SUCCESS;

} // DecodePageControl


DWORD
DecodeSortControl(
    IN DWORD    CodePage,
    IN PBERVAL  Bv,
    IN PBOOL    fReverseSort,
    OUT AttributeType *pAttType,
    OUT MatchingRuleId  *pMatchingRule
    )
/*++

Routine Description:

    Decode a sort control

Arguments:

    CodePage - code page to use              
    Bv - points to the sort control blob sent by the client
    fReverseSort - on return, whether the sort is reverse ordering
    SortAttr - attribute to sort on

Return Value:

    ERROR_SUCCESS   - encoding went well.
    ERROR_GEN_FAILURE - error with the ber package
    ERROR_NOT_ENOUGH_MEMORY - cannot allocate send buffers.
    
--*/
{
    THSTATE *pTHS=pTHStls;
    BerElement *ber;
    DWORD count = 0;
    INT reverse = 0;
    PCHAR opaque;
    DWORD len;
    DWORD tag;
    PBERVAL berVal;

    *fReverseSort = FALSE;
    ber = ber_init(Bv);
    if ( ber == NULL ) {
        IF_DEBUG(ENCODE) {
            DPRINT1(0,"DecodeSortControl: ber_init failed with %d\n", 
                    GetLastError());
        }
        return ERROR_GEN_FAILURE;
    }

    //
    // Process the sort key list (SEQ OF SEQ)
    //

    for ( tag = ber_first_element(ber, &len, &opaque);
          tag != LBER_DEFAULT;
          tag = ber_next_element(ber, &len, opaque))  {

        PBERVAL         attrType = NULL;
        DWORD           ttag, tlen;

        //
        // We only support single keys, fail this
        //

        if ( count++ > 0 ) {
            IF_DEBUG(ERROR) {
                DPRINT(0,"UNSUPPORTED: Client specified more than one key.\n");
            }
            goto error_exit;
        }

        //
        // Get the attribute type
        //

        if ( ber_scanf(ber,"{O", &attrType) == LBER_ERROR ) {
            IF_DEBUG(ENCODE) {
                DPRINT1(0,"DecodeSortControl: ber_scanf failed with %d\n", 
                     GetLastError());
            }         
            goto error_exit;
        }

        if ( attrType != NULL ) {
                        
            pAttType->length = attrType->bv_len;
            pAttType->value = (PUCHAR)THAlloc(attrType->bv_len);
            if (NULL == pAttType->value) {
                ber_bvfree(attrType);
                ber_free(ber,1);
                return ERROR_NOT_ENOUGH_MEMORY;
            }
                        memcpy(pAttType->value, (PUCHAR)attrType->bv_val, attrType->bv_len);
        } else {
            pAttType->length = 0;
        }

        if ( pAttType->length == 0 ) {
            IF_DEBUG(ENCODE) {
                DPRINT(0,"DecodeSortControl: NULL attr list\n");
            }         
            goto error_exit;
        }
        
        ber_bvfree(attrType);

        //
        // ordering rule is OPTIONAL.
        //

        ttag = ber_peek_tag(ber,&tlen);

        if ( ttag == 0x80 ) {

            if ( ber_scanf(ber,"O", &berVal) == LBER_ERROR ) {
                IF_DEBUG(ENCODE) {
                    DPRINT1(0,"DecodeSortControl: ber_scanf failed with %d\n",
                         GetLastError());
                }           
                goto error_exit;
            }

            pMatchingRule->value = (PUCHAR) THAlloc(berVal->bv_len);
            if(NULL == pMatchingRule->value) {
                IF_DEBUG(ERROR) {
                    DPRINT(0,"DecodeSortControl: Cannot allocate MatchingRule value.\n");
                }
                ber_bvfree(berVal);
                ber_free(ber, 1);
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            memcpy(pMatchingRule->value, berVal->bv_val, berVal->bv_len);
            pMatchingRule->length = berVal->bv_len;
            ber_bvfree(berVal);
            berVal = NULL;

            ttag = ber_peek_tag(ber,&tlen);
        } 
        else {
            pMatchingRule->value = NULL;
        }
        
        if ( ttag == 0x81 ) {

            //
            // reverse order is BOOLEAN DEFAULT FALSE
            //

            if ( ber_scanf(ber,"b", &reverse) == LBER_ERROR ) {
                IF_DEBUG(ENCODE) {
                    DPRINT1(0,"DecodeSortControl: ber_scanf failed with %d\n",
                         GetLastError());
                }           
                goto error_exit;
            }

            IF_DEBUG(SEARCH) {
                DPRINT1(0,"Reverse Sort %x\n",reverse);
            }
        }
        *fReverseSort = (BOOL)(reverse != 0);
        // strictly speaking, we should be checking the result value of this ber_scanf
        // originally, we did not. Should we start doing it now?
        // WHAT IF we break some clients??? So, let's leave this as is...
        ber_scanf(ber,"}");
    }

    //
    // no keys found
    //

    if ( count == 0 ) {
        goto error_exit;
    }

    ber_free(ber,1);
    return ERROR_SUCCESS;

error_exit:
    ber_free(ber,1);
    return ERROR_INVALID_PARAMETER;
} // DecodeSortControl


DWORD
DecodeVLVControl(
    IN PBERVAL  Bv,
    OUT VLV_REQUEST  *pVLVRequest,
    OUT PBERVAL     pCookie,
    OUT AssertionValue *pVal
    )
/*++

Routine Description:

    Decode a Virtual LIst View (VLV) control

Arguments:

    Bv - points to the sort control blob sent by the client
    VLVResult - Where to put decoded VLV arguments.

Return Value:

    ERROR_SUCCESS   - encoding went well.
    ERROR_GEN_FAILURE - error with the ber package
    ERROR_NOT_ENOUGH_MEMORY - cannot allocate send buffers.
    
--*/
{
    THSTATE *pTHS=pTHStls;
    BerElement *ber;
    DWORD len;
    DWORD tag;
    PBERVAL berVal;
    PBERVAL pCookieVal = NULL;
    

    pCookie->bv_val = NULL;
    pCookie->bv_len = 0;

    ber = ber_init(Bv);    
    if ( ber == NULL ) {
        IF_DEBUG(ENCODE) {
            DPRINT1(0,"DecodeVLVControl: ber_init failed with %d\n", 
                    GetLastError());
        }
        return ERROR_GEN_FAILURE;
    }

    //
    // Get beforeCount and afterCount
    //

    if ( ber_scanf(ber,"{ii", &pVLVRequest->beforeCount, &pVLVRequest->afterCount) == LBER_ERROR ) {
        IF_DEBUG(ENCODE) {
            DPRINT1(0,"DecodeVLVControl2: ber_scanf failed with %d\n",
                 GetLastError());
        }           
        goto error_exit;
    }

    tag = ber_peek_tag(ber,&len);

    if (0xa0 == tag) {
        //
        // Get offset and contentCount
        //

        if (ber_scanf(ber, "{ii}", &pVLVRequest->targetPosition, &pVLVRequest->contentCount) == LBER_ERROR) {
            IF_DEBUG(ENCODE) {
                DPRINT1(0,"DecodeVLVControl3: ber_scanf failed with %d\n",
                     GetLastError());
            }           
            goto error_exit;
        }
    } else if (0x81 == tag) {
        //
        // Get the assertionValue
        //

        if (ber_scanf(ber, "O", &berVal) == LBER_ERROR) {
            IF_DEBUG(ENCODE) {
                DPRINT1(0,"DecodeVLVControl4: ber_scanf failed with %d\n",
                     GetLastError());
            }           
            goto error_exit;
        }

        pVal->value = (PUCHAR) THAlloc(berVal->bv_len);
        if(NULL == pVal->value) {
            IF_DEBUG(ERROR) {
                DPRINT(0,"DecodeVLVControl: Cannot allocate VLV value.\n");
            }
            ber_bvfree(berVal);
            ber_free(ber, 1);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        memcpy(pVal->value, berVal->bv_val, berVal->bv_len);
        pVal->length = berVal->bv_len;
        pVLVRequest->fseekToValue = TRUE;
        ber_bvfree(berVal);
        berVal = NULL;
    } else {
        IF_DEBUG(ENCODE) {
            DPRINT1(0,"DecodeVLVControl5: bad choice %x\n",
                 tag);
        }           
        goto error_exit;
    }

    //
    // Is there a contextID?
    //
    tag = ber_peek_tag(ber, &len);
    if (0x04 == tag) {

        if (ber_scanf(ber, "O", &pCookieVal) == LBER_ERROR) {
            IF_DEBUG(ENCODE) {
                DPRINT1(0,"DecodeVLVControl5: ber_scanf failed with %d\n",
                     GetLastError());
            }           
            goto error_exit;
        }
        if (pCookieVal->bv_len > 0) {
        
            PRESTART pRestart = (PRESTART)pCookieVal->bv_val;

            IF_DEBUG(PAGED) {
                DPRINT1(0,"VLV Cookie Length is %d\n",pCookieVal->bv_len);
            }

            if( (pCookieVal->bv_len != sizeof(DWORD)) &&
                 ((pCookieVal->bv_len < sizeof(RESTART))      ||
                  (pCookieVal->bv_len != pRestart->structLen))) {

                //
                // Our cookies are either DWORDs, which are handles, or RESTART
                // structs
                //

                ber_bvfree(pCookieVal);
                IF_DEBUG(ERROR) {
                    DPRINT1(0,"DecodeVLVControl: Invalid cookie len[%d]\n",
                            pCookieVal->bv_len);
                }
                goto error_exit;
            }
        }

        pCookie->bv_val = (PCHAR) THAlloc(pCookieVal->bv_len);
        if(NULL == pCookie->bv_val) {
            IF_DEBUG(ERROR) {
                DPRINT(0,"DecodeVLVControl: Cannot allocate VLV value.\n");
            }
            ber_bvfree(pCookieVal);
            ber_free(ber, 1);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        pCookie->bv_len = pCookieVal->bv_len;
        CopyMemory(pCookie->bv_val, pCookieVal->bv_val, pCookieVal->bv_len);

    } else if (LBER_DEFAULT != tag) {

        IF_DEBUG(ERROR) {
            DPRINT(0,"DecodeVLVControl: Found something other than the optional contextID\n");
        }
        goto error_exit;
    }

    // strictly speaking, we should be checking the result value of this ber_scanf
    // originally, we did not. Should we start doing it now?
    // WHAT IF we break some clients??? So, let's leave this as is...
    ber_scanf(ber,"}");
    ber_free(ber, 1);
    return ERROR_SUCCESS;

error_exit:
    ber_free(ber, 1);
    return ERROR_INVALID_PARAMETER;
} // DecodeVLVControl



DWORD
DecodeASQControl(
    IN PBERVAL  Bv,
    AttributeType *pAttType
    )
/*++

Routine Description:

    Decode a ASQ control

Arguments:

    Bv - points to the sort control blob sent by the client
    pAttrTyp - the attribute type we will do ASQ on

Return Value:

    ERROR_SUCCESS   - encoding went well.
    ERROR_GEN_FAILURE - error with the ber package
    ERROR_NOT_ENOUGH_MEMORY - cannot allocate send buffers.
    
--*/
{
    THSTATE *pTHS=pTHStls;
    BerElement *ber;
    DWORD len;
    DWORD tag;
    PBERVAL berVal;
    PBERVAL         attrType = NULL;


    ber = ber_init(Bv);    
    if ( ber == NULL ) {
        IF_DEBUG(ENCODE) {
            DPRINT1(0,"DecodeASQControl: ber_init failed with %d\n", 
                    GetLastError());
        }
        return ERROR_GEN_FAILURE;
    }

    //
    // Get the attribute type
    //

    if ( ber_scanf(ber,"{O}", &attrType) == LBER_ERROR ) {
        IF_DEBUG(ENCODE) {
            DPRINT1(0,"DecodeASQControl: ber_scanf failed with %d\n", 
                 GetLastError());
        }         
        goto asq_error_exit;
    }

    if ( attrType != NULL ) {

        pAttType->length = attrType->bv_len;
        pAttType->value = (PUCHAR)THAlloc(attrType->bv_len);
        if (NULL == pAttType->value) {
            ber_bvfree(attrType);
            ber_free(ber,1);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        memcpy(pAttType->value, (PUCHAR)attrType->bv_val, attrType->bv_len);
    } else {
        pAttType->length = 0;
    }

    if ( pAttType->length == 0 ) {
        IF_DEBUG(ENCODE) {
            DPRINT(0,"DecodeASQControl: NULL attr list\n");
        }         
        goto asq_error_exit;
    }

    ber_bvfree(attrType);

    ber_free(ber, 1);
    return ERROR_SUCCESS;

asq_error_exit:
    ber_free(ber, 1);
    return ERROR_INVALID_PARAMETER;
}
                             

DWORD
EncodePagedControl(
    IN Controls* PagedControl,
    IN PUCHAR   Cookie,
    IN DWORD    CookieLen
    )
/*++

Routine Description:

    Encodes a paged control

Arguments:

    PagedControl - control to encode
    Cookie - pointer to the cookie
    CookieLen - length of the cookie

Return Value:

    ERROR_SUCCESS   - encoding went well.
    ERROR_NOT_ENOUGH_MEMORY - cannot allocate send buffers.
    
--*/
{
    PUCHAR pSeqLen;
    PUCHAR  pTmp;
    Controls control;
    PUCHAR  pCook = (PUCHAR)&Cookie;
    DWORD   blobSize = CookieLen + MAX_BER_TAGLEN + 3 + MAX_BER_TAGLEN;

    IF_DEBUG(PAGED) {
        DPRINT1(0,"PagedEncode: Encoding cookie of size %d\n", CookieLen);
    }

    control = (Controls)THAlloc(sizeof(struct Controls_) + blobSize);

    if(control == NULL) {
        IF_DEBUG(ERROR) {
            DPRINT(0,"Ldap: Cannot allocate paged control\n");
        }
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    control->value.controlType = KnownControls[CONTROL_PAGED_RESULTS];
    control->value.controlValue.value = (PUCHAR)(control + 1);

    pTmp = control->value.controlValue.value;

    pSeqLen = pTmp;
    pTmp += MAX_BER_TAGLEN;

    *pTmp++ = 0x2;      // Size = 0
    *pTmp++ = 0x1;
    *pTmp++ = 0x0;

    BerFillOctet(&pTmp, Cookie, CookieLen);

    control->value.controlValue.length = 
        (DWORD)(pTmp - control->value.controlValue.value);
    FillTagLen(&pSeqLen, 0x30, (DWORD)(pTmp - pSeqLen - MAX_BER_TAGLEN), TRUE);
    *PagedControl = control;

    return ERROR_SUCCESS;

} // EncodePageControl


DWORD
EncodeReplControl(
    IN Controls* ReplControl,
    IN ReplicationSearchControlValue  *ReplCtrl  
    )
/*++

Routine Description:

    BER Decode the Replication control.

Arguments:

    Bv - berval containing info to decode.
    pFlags - pointer to     

Return Value:

    0 if success, else error code.

--*/
{
    BerElement* ber;
    Controls control;
    BERVAL  *bval = NULL;
    INT rc;

    ber = ber_alloc_t(LBER_USE_DER);
    if ( ber == NULL ) {
        IF_DEBUG(ENCODE) {
            DPRINT1(0,"EncodeRepl: ber_alloc_t failed with %d\n",GetLastError());
        }
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    rc = ber_printf(ber,"{iio}",
                    ReplCtrl->flag,
                    ReplCtrl->size,
                    ReplCtrl->cookie.value,
                    ReplCtrl->cookie.length);

    if ( rc == -1 ) {
        IF_DEBUG(ENCODE) {
            DPRINT1(0,"EncodeRepl: ber_printf failed with %d\n",GetLastError());
        }
        ber_free(ber,1);
        return ERROR_INVALID_PARAMETER;
    }

    rc = ber_flatten(ber, &bval);
    ber_free(ber,1);

    if ( rc == -1 ) {
        IF_DEBUG(ENCODE) {
            DPRINT1(0,"EncodeRepl: ber_flatten failed with %d\n",GetLastError());
        }
        return ERROR_INVALID_PARAMETER;
    }

    control = (Controls)THAlloc(sizeof(struct Controls_) + bval->bv_len);

    if (control == NULL) {
        IF_DEBUG(ERROR) {
            DPRINT(0,"Could not allocate memory for controls\n");
        }
        ber_bvfree(bval);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    control->value.controlType = KnownControls[CONTROL_REPLICATION];
    control->value.controlValue.value = (PUCHAR)(control + 1);
    control->value.controlValue.length = bval->bv_len;

    CopyMemory(
        control->value.controlValue.value,
        bval->bv_val,
        bval->bv_len
        );

    ber_bvfree(bval);

    *ReplControl = control;
    return ERROR_SUCCESS;
} // EncodeReplicationControl



DWORD
EncodeSortControl(
    IN Controls* SortControl,
    IN _enum1_4  SortResult
    )
/*++

Routine Description:

    Encodes a sort control

Arguments:

    SortControl - sort control to encode
    SortResult  - result of the sort

Return Value:

    ERROR_SUCCESS   - encoding went well.
    ERROR_NOT_ENOUGH_MEMORY - cannot allocate send buffers.
    
--*/
{
    PUCHAR  pTmp;
    Controls control;

    control = (Controls)THAlloc(sizeof(struct Controls_) + 5);

    if(control == NULL) {
        IF_DEBUG(ERROR) {
            DPRINT(0,"EncodeSort: Unable to allocate control memory\n");
        }
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    control->value.controlType = KnownControls[CONTROL_SORT_RESULT];
    control->value.controlValue.length = 5;
    control->value.controlValue.value = (PUCHAR)(control + 1);

    pTmp = control->value.controlValue.value;

    pTmp[0] = 0x30;     // SEQUENCE
    pTmp[1] = 0x3;

    pTmp[2] = 0x0A;      // sortResult
    pTmp[3] = 0x01;
    pTmp[4] = (UCHAR)SortResult;

    *SortControl = control;

    return ERROR_SUCCESS;

} // EncodeSortControl


DWORD
EncodeSearchResult(
    IN PLDAP_REQUEST Request,
    IN PLDAP_CONN LdapConn,
    IN SearchResultFull_* ReturnResult,
    IN _enum1 Code,
    IN Referral pReferral,
    IN Controls  pControl,
    IN LDAPString *pErrorMessage,
    IN LDAPDN *pMatchedDN,
    IN DWORD   ObjectCount,
    IN BOOL    DontSendResultDone
    )
/*++

Routine Description:

    Encodes a search request in it's entirety.

Arguments:

    

Return Value:

    ERROR_SUCCESS   - encoding went well.
    ERROR_NOT_ENOUGH_MEMORY - cannot allocate send buffers.
    ERROR_UNEXP_NET_ERROR - Datagram has grown too big.
    
--*/
{
#define ID_BUF_LEN  8
    PUCHAR   p;
    UCHAR   idBuf[ID_BUF_LEN];
    DWORD   idStringLen;
    DWORD   lenNeeded;
    INT     len = 0;

    PUCHAR  pMsgLen;
    PUCHAR  pOpLen;
    PUCHAR  pBuff;
    DWORD   totalEncodedLength = 0;
    BOOL    fFirstTime = TRUE;

    //
    // Fill in the id string
    //

    IF_DEBUG(SEND) {
        DPRINT3(0,"EncodeSearch: Encoding req %x code %d objs %d\n",
                 Request, Code, ObjectCount);
    }

    Assert(sizeof(Request->m_MessageId) == sizeof(DWORD));

    p = idBuf;
    DerFillDword(&p, Request->m_MessageId);
    idStringLen = (DWORD)(p - idBuf);

    switch (Code) {
    case success:
    case timeLimitExceeded:
    case sizeLimitExceeded:
    case adminLimitExceeded:
        break;
    default:
        goto exit;
    }

    ObjectCount >>= 3;
    if ( ObjectCount == 0 ) {
        ObjectCount = 1;
    } else if ( ObjectCount > 20 ) {
        ObjectCount = 20;
    }

    while(ReturnResult != NULL) {

        DWORD dnLen;
        PUCHAR pSeqOfSeqLen;
        SearchResultEntry *entry;

        lenNeeded = idStringLen + MAX_BER_TAGLEN * 2; // id + msg + op

        switch(ReturnResult->value.choice) {
        case entry_chosen:

            PartialAttributeList pal;
            AttributeVals vals;

            lenNeeded += MAX_BER_TAGLEN;                // sequence

            entry = &ReturnResult->value.u.entry;    
            dnLen = entry->objectName.length;
            lenNeeded += dnLen + MAX_BER_TAGLEN;

            lenNeeded += MAX_BER_TAGLEN;                // sequence
            pal = entry->attributes;
            while ( pal != NULL  ) {

                lenNeeded += MAX_BER_TAGLEN;            // of sequence
                lenNeeded += pal->value.type.length + MAX_BER_TAGLEN;

                lenNeeded += MAX_BER_TAGLEN;    // set
                vals = pal->value.vals;
                while ( vals != NULL ) {

                    lenNeeded += vals->value.length + MAX_BER_TAGLEN;
                    vals = vals->next;
                }
                pal = pal->next;
            }

            //
            // see if the buffer is big enough
            //

            IF_DEBUG(SEND) {
                DPRINT1(0,"Entry Size %d\n",lenNeeded);
            }

            totalEncodedLength += lenNeeded;

            if ( lenNeeded > Request->GetSendBufferSize( ) ) {

                if ( !Request->GrowSend(fFirstTime ? 
                                        lenNeeded * 2 : 
                                        lenNeeded * ObjectCount) ) {
                    Code = other;
                    goto exit;
                }

                fFirstTime = FALSE;
            }

            //
            // Start the encoding
            //

            Assert(Request->GetSendBufferSize() >= lenNeeded);

            pBuff = Request->GetSendBuffer();

            pMsgLen = pBuff;
            pBuff += MAX_BER_TAGLEN;

            CopyMemory(pBuff, idBuf, idStringLen);
            pBuff += idStringLen;

            pOpLen = pBuff;
            pBuff += MAX_BER_TAGLEN;

            BerFillOctet(&pBuff, entry->objectName.value, dnLen);

            //
            // Start encoding sequece of sequence 
            //

            pSeqOfSeqLen = pBuff;
            pBuff += MAX_BER_TAGLEN;

            pal = entry->attributes;
            
            while ( pal != NULL  ) {

                PUCHAR pSeqLen = pBuff;
                PUCHAR pSetLen;

                pBuff += MAX_BER_TAGLEN;
    
                BerFillOctet(&pBuff, 
                             pal->value.type.value, 
                             pal->value.type.length);

                pSetLen = pBuff;
                pBuff += MAX_BER_TAGLEN;

                vals = pal->value.vals;
                while ( vals != NULL ) {
                    BerFillOctet(&pBuff, vals->value.value, vals->value.length);
                    vals = vals->next;
                }

                FillTagLen(&pSetLen, 
                           0x31, 
                           (DWORD)(pBuff - pSetLen - MAX_BER_TAGLEN),
                           TRUE);

                FillTagLen(&pSeqLen, 
                           0x30, 
                           (DWORD)(pBuff - pSeqLen - MAX_BER_TAGLEN),
                           TRUE);

                pal = pal->next;
            }

            FillTagLen(&pSeqOfSeqLen, 
                       0x30, 
                       (DWORD)(pBuff - pSeqOfSeqLen - MAX_BER_TAGLEN),
                       TRUE);

            FillTagLen(&pOpLen,
                       0x64, 
                       (DWORD)(pBuff - pOpLen - MAX_BER_TAGLEN),
                       TRUE);


            FillTagLen(&pMsgLen,
                       0x30, 
                       (DWORD)(pBuff - pMsgLen - MAX_BER_TAGLEN),
                       TRUE);

            Request->SetBufferPtr(pBuff);
            break;

        case reference_chosen:

            SearchResultReference ref;

            IF_DEBUG(SEND) {
                DPRINT(0,"Got reference entry!\n");
            }

            if ( LdapConn->m_Version == 2 ) {
                Assert(pReferral == NULL);
                pReferral = (Referral)ReturnResult->value.u.reference;
                if ( pReferral == NULL ) {
                    IF_DEBUG(ERROR){
                        DPRINT(0,"LdapEncodeSearch: NULL Referral\n");
                    }
                    ReturnResult = ReturnResult->next;
                    continue;
                }
                Code = referralv2;
                goto exit;
            }

            //
            // ok, let's start scrogging the data
            //

            lenNeeded = MAX_BER_TAGLEN +    // Msg
                        idStringLen    +    // id
                        MAX_BER_TAGLEN +    // proto
                        MAX_BER_TAGLEN;    // sequence        

            ref = ReturnResult->value.u.reference;
            if ( ref == NULL ) {
                IF_DEBUG(ERROR){
                    DPRINT(0,"LdapEncodeSearch: NULL Reference\n");
                }
                ReturnResult = ReturnResult->next;
                continue;
            }
            while ( ref != NULL ) {
                lenNeeded += ref->value.length + MAX_BER_TAGLEN;
                ref = ref->next;
            }

            totalEncodedLength += lenNeeded;
            if ( lenNeeded > Request->GetSendBufferSize() ) {
                IF_DEBUG(SEND) {
                    DPRINT1(0, "Growing send buffer by 0x%x bytes.\n", lenNeeded);
                }
                if ( !Request->GrowSend(lenNeeded) ) {
                    Code = other;
                    goto exit;
                }
            }

            //
            // party time
            //

            pBuff = Request->GetSendBuffer();
            pMsgLen = pBuff;
            pBuff += MAX_BER_TAGLEN;
        
            CopyMemory(pBuff, idBuf, idStringLen);
            pBuff += idStringLen;
        
            pOpLen = pBuff;
            pBuff += MAX_BER_TAGLEN;

            ref = ReturnResult->value.u.reference;
            while ( ref != NULL ) {

                if ( ref->value.length > 0 ) {
                    BerFillOctet(&pBuff, ref->value.value, ref->value.length);
                }
                ref = ref->next;
            }

            //
            // ok, set the protocol and message lengths
            //

            FillTagLen(&pOpLen,
                       0x73, 
                       (DWORD)(pBuff - pOpLen - MAX_BER_TAGLEN),
                       TRUE);
        
            FillTagLen(&pMsgLen,
                       0x30, 
                       (DWORD)(pBuff - pMsgLen - MAX_BER_TAGLEN),
                       TRUE);
        
            Request->SetBufferPtr(pBuff);
            break;
                
        default:
        case resultCode_chosen:
            Assert(FALSE);          // Shouldn't be one of these here.
            break;
        }

        ReturnResult = ReturnResult->next;

        if ( LdapConn->m_fUDP && (totalEncodedLength > LdapMaxDatagramSend) ) {
            IF_DEBUG(ERROR) {
                DPRINT2(0,"LdapEncodeSearch: Datagram[%d] too big to send[max %d]\n",
                     totalEncodedLength, LdapMaxDatagramSend);
            }
            return ERROR_UNEXP_NET_ERR;
        }
    }

    if ( DontSendResultDone ) {
        IF_DEBUG(ENCODE) {
            DPRINT(0,"Skipping Result done.\n");
        }
        return ERROR_SUCCESS;
    }

exit:

    //
    // OK, code the result done part
    //

    lenNeeded = MAX_BER_TAGLEN + // Msg Sequence
                idStringLen    + // id length
                MAX_BER_TAGLEN + // proto length
                3 +              // return code
                MAX_BER_TAGLEN + // matched DN
                MAX_BER_TAGLEN;  // error msg
             
    lenNeeded += pMatchedDN->length;
    if ( pReferral != NULL ) {

        lenNeeded += pReferral->value.length + MAX_BER_TAGLEN;

        if ( LdapConn->m_Version == 3 ) {

            Referral ref;
            ref = pReferral->next;
            while ( ref != NULL ) {
                lenNeeded += ref->value.length + MAX_BER_TAGLEN;
                ref = ref->next;
            }

            lenNeeded += pErrorMessage->length;
        }
    } else {
        lenNeeded += pErrorMessage->length;
    }

    //
    // See if we need to piggy back a control
    //

    if ( pControl != NULL ) {

        Controls controls = pControl;

        lenNeeded += MAX_BER_TAGLEN;

        while ( controls != NULL ) {

            Control* control = &controls->value;

            lenNeeded += MAX_BER_TAGLEN;

            lenNeeded += control->controlType.length + MAX_BER_TAGLEN;
            lenNeeded += control->controlValue.length + MAX_BER_TAGLEN;

            controls = controls->next;
        }
    }

    if ( lenNeeded > Request->GetSendBufferSize() ) {
        IF_DEBUG(SEND) {
            DPRINT1(0, "Growing send buffer by 0x%x bytes.\n", lenNeeded);
        }
        if ( !Request->GrowSend(lenNeeded) ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // OK, Fill her up
    //

    pBuff = Request->GetSendBuffer();
    pMsgLen = pBuff;
    pBuff += MAX_BER_TAGLEN;

    CopyMemory(pBuff, idBuf, idStringLen);
    pBuff += idStringLen;

    pOpLen = pBuff;
    pBuff += MAX_BER_TAGLEN;

    *pBuff++ = 0x0a;
    *pBuff++ = 0x1;
    *pBuff++ = (UCHAR)Code;

    BerFillOctet(&pBuff, pMatchedDN->value, pMatchedDN->length);

    //
    // We do referrals differently if it's v2
    //

    if ( pReferral != NULL ) {

        if ( LdapConn->m_Version == 2 ) {
            IF_DEBUG(SEND) {
                DPRINT(0,"Processing v2 referral\n");
            }
            Assert(Code == referralv2);
            BerFillOctet(&pBuff, pReferral->value.value, pReferral->value.length);
        } else {

            Referral ref = pReferral;
            PUCHAR pSeqLen;

            Assert(Code == referral);

            BerFillOctet(&pBuff, pErrorMessage->value, pErrorMessage->length);

            //
            // referrals are sequences of LDAPURLs
            //

            pSeqLen = pBuff;
            pBuff += MAX_BER_TAGLEN;

            while ( ref != NULL ) {
                if ( ref->value.length > 0 ) {
                    BerFillOctet(&pBuff, ref->value.value, ref->value.length);
                }
                ref = ref->next;
            }

            FillTagLen(&pSeqLen,
                       0xA3, 
                       (DWORD)(pBuff - pSeqLen - MAX_BER_TAGLEN),
                       TRUE);

        }
    } else {
        BerFillOctet(&pBuff, pErrorMessage->value, pErrorMessage->length);
    }

    //
    // ok, set the protocol and message lengths
    //

    FillTagLen(&pOpLen, 0x65, (DWORD)(pBuff - pOpLen - MAX_BER_TAGLEN), TRUE);

    //
    // See if we need to piggy back a control
    //

    if ( pControl != NULL ) {

        Controls controls = pControl;

        PUCHAR pCtrlsLen = pBuff;
        pBuff += MAX_BER_TAGLEN;

        while ( controls != NULL ) {

            Control* control = &controls->value;

            PUCHAR pCtrlLen = pBuff;
            pBuff += MAX_BER_TAGLEN;

            BerFillOctet(&pBuff, 
                         control->controlType.value, 
                         control->controlType.length);

            BerFillOctet(&pBuff, 
                         control->controlValue.value, 
                         control->controlValue.length);

            FillTagLen(&pCtrlLen, 0x30, (DWORD)(pBuff - pCtrlLen - MAX_BER_TAGLEN), TRUE);

            controls = controls->next;
        }

        FillTagLen(&pCtrlsLen, 0xA0, (DWORD)(pBuff - pCtrlsLen - MAX_BER_TAGLEN), TRUE);
    }

    FillTagLen(&pMsgLen, 0x30, (DWORD)(pBuff - pMsgLen - MAX_BER_TAGLEN), TRUE);

    Request->SetBufferPtr(pBuff);

    return ERROR_SUCCESS;

} // EncodeSearchResult


DWORD
EncodeStatControl(
    IN Controls* StatControl,
    IN DWORD     nStats,
    IN LDAP_STAT_ARRAY StatArray[]
    )
/*++

Routine Description:

    Encodes a STATs control

Arguments:
    
    StatControl - the control to encode
    nStats - number of statistics
    StatArray - the array of the statistics (starting at 1)

Return Value:

    ERROR_SUCCESS   - encoding went well.
    ERROR_NOT_ENOUGH_MEMORY - cannot allocate send buffers.
    
--*/
{
    PUCHAR  pSeqLen, pTmp;
    Controls control;
    DWORD i;
    DWORD cbControlValue;
    DWORD cbFilter = 0, cbIndexes = 0;
    THSTATE *pTHS;

    pTHS = pTHStls;

    if (pTHS->searchLogging.pszFilter) {
        cbFilter = strlen(pTHS->searchLogging.pszFilter) + 1;
    }
    if (pTHS->searchLogging.pszIndexes) {
        cbIndexes = strlen(pTHS->searchLogging.pszIndexes) + 1;
    }

    cbControlValue = sizeof(struct Controls_) + MAX_BER_TAGLEN +
                          (nStats + 2) * 2 * MAX_BER_TAGLEN +
                          2 * MAX_BER_TAGLEN + cbFilter + cbIndexes;

    control = (Controls)THAlloc( cbControlValue );
    
    if(control == NULL) {
        IF_DEBUG(ERROR) {
            DPRINT(0,"EncodeSort: Unable to allocate control memory\n");
        }
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    control->value.controlType = KnownControls[CONTROL_STAT_REQUEST];
    control->value.controlValue.value = (PUCHAR)(control + 1);

    pTmp = control->value.controlValue.value;

    pSeqLen = pTmp;
    pTmp += MAX_BER_TAGLEN;

    for ( i=1; i <= nStats; i++ ) {
        if (StatArray[i].Value_str) {
            if (StatArray[i].Stat == STAT_FILTER) {
                DerFillDword(&pTmp, StatArray[i].Stat);
                BerFillOctet(&pTmp, StatArray[i].Value_str, cbFilter, NULL);
            }
            else if (StatArray[i].Stat == STAT_INDEXES) {
                DerFillDword(&pTmp, StatArray[i].Stat);
                BerFillOctet(&pTmp, StatArray[i].Value_str, cbIndexes, NULL);
            }
        }
        else {
            if (StatArray[i].Stat) {
                DerFillDword(&pTmp, StatArray[i].Stat);
                DerFillDword(&pTmp, StatArray[i].Value);
            }
        }
    }

    control->value.controlValue.length = 
        (DWORD)(pTmp - control->value.controlValue.value);
    FillTagLen(&pSeqLen, 0x30, (DWORD)(pTmp - pSeqLen - MAX_BER_TAGLEN), TRUE);
    *StatControl = control;
    return ERROR_SUCCESS;

} // EncodeStatControl


// 
// Extended request related functions go here.
//

_enum1
DecodeTTLRequest(
    IN  PBERVAL      Bv,
    OUT LDAPDN       *entryName,
    OUT DWORD        *requestTtl,
    OUT LDAPString   *pErrorMessage
    )
{
    PBERVAL    dn;
    BerElement *ber;
    ULONG      res;
    ULONG      tag;
    ULONG      len;
    DWORD      tmpTtl;

    ber = ber_init(Bv);
    if ( ber == NULL ) {
        IF_DEBUG(ERROR) {
            DPRINT1(0,"DecodeTTLRequest: ber_init failed with %d\n", 
                GetLastError());
        }
        return SetLdapError(protocolError,
                            ERROR_DS_DECODING_ERROR,
                            LdapExtendedReqestDecodeError,
                            GetLastError(),
                            pErrorMessage);
    }

    res = ber_scanf(ber,"{");
    
    if (res != LBER_ERROR && (0x80 == ber_peek_tag(ber, &len))) {

        res = ber_scanf(ber,"O", &dn);

        if (res != LBER_ERROR && (0x81 == ber_peek_tag(ber, &len))) {

            res = ber_scanf(ber, "i}", &tmpTtl);
        } else {
            // peek_tag may have failed.
            res = LBER_ERROR;
        }
    } else {
        // peek_tag may have failed.
        res = LBER_ERROR;
    }

    if ( res == LBER_ERROR ) {
        IF_DEBUG(ERROR) {
            DPRINT1(0,"DecodeSDControl: ber_scanf failed with %d\n", 
                 GetLastError());
        }
        ber_free(ber,1);
        return SetLdapError(protocolError,
                            ERROR_DS_DECODING_ERROR,
                            LdapExtendedReqestDecodeError,
                            GetLastError(),
                            pErrorMessage);
    }

    entryName->value = (PUCHAR)THAlloc(dn->bv_len);
    if (!entryName->value) {
        IF_DEBUG(ALLOC) {
            DPRINT(0, "DecodeTTLRequest: Failed to allocate memory for DN\n");
        }
        ber_free(ber,1);
        return unavailable;
    }
    
    entryName->length = dn->bv_len;
    CopyMemory(entryName->value, dn->bv_val, entryName->length);
    *requestTtl = tmpTtl;

    ber_free(ber,1);

    return success;
}

_enum1
EncodeTTLResponse(
    IN  DWORD        responseTtl,
    OUT LDAPString   *responseValue,
    OUT LDAPString   *pErrorMessage
    )
{
   DWORD   responseSize;
   PUCHAR  responseBuf;
   PUCHAR  pTmp;

   responseBuf = (PUCHAR)THAlloc(sizeof(DWORD) + 2 + 2); // 2 for the resonseTtl tag and length,
                                                 // and 2 for the sequence tag and length.
   if (!responseBuf) {
       IF_DEBUG(ALLOC) {
           DPRINT(0, "EncodeTTLRequest: Failed to allocate memory for response\n");
       }
       return unavailable;
   }

   pTmp = &responseBuf[2];
   responseBuf[0] = 0x30;                              // Start SEQUENCE
   responseBuf[1] = (UCHAR)DerFillDwordEx(&pTmp, responseTtl, 0x81);

   responseValue->length = responseBuf[1] + 2; // 2 for the SEQUENCE tag and length;
   responseValue->value = responseBuf;

   return success;
}

DWORD
EncodeVLVControl(
    IN Controls* VLVControl,
    IN VLV_REQUEST *pVLVRequest,
    IN PUCHAR      Cookie,
    IN DWORD       cbCookie
    )
/*++

Routine Description:

    BER Encode the Virtual List View control.

Arguments:

    VLVControl - Where to put the encoded VLV values.
    pVLVRequest - The VLV info to encode.

Return Value:

    0 if success, else error code.

--*/
{
    BerElement* ber;
    Controls control;
    BERVAL  *bval = NULL;
    BERVAL  cookieVal;
    INT rc;

    ber = ber_alloc_t(LBER_USE_DER);
    if ( ber == NULL ) {
        IF_DEBUG(ENCODE) {
            DPRINT1(0,"EncodeRepl: ber_alloc_t failed with %d\n",GetLastError());
        }
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    rc = ber_printf(ber,"{iie",
                    pVLVRequest->targetPosition,
                    pVLVRequest->contentCount,
                    pVLVRequest->Err);

    if ( rc == -1 ) {
        IF_DEBUG(ENCODE) {
            DPRINT1(0,"EncodeVLV1: ber_printf failed with %d\n",GetLastError());
        }
        ber_free(ber,1);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Encode the cookie if there is one.
    //
    if (NULL != pVLVRequest->pVLVRestart) {
        cookieVal.bv_len = cbCookie;
        cookieVal.bv_val = (char *) Cookie;

        rc = ber_printf(ber, "o", Cookie, cbCookie);

        if ( rc == -1 ) {
            IF_DEBUG(ENCODE) {
                DPRINT1(0,"EncodeVLV3: ber_printf failed with %d\n",GetLastError());
            }
            ber_free(ber,1);
            return ERROR_INVALID_PARAMETER;
        }
    }

    rc = ber_printf(ber, "}");

    if ( rc == -1 ) {
        IF_DEBUG(ENCODE) {
            DPRINT1(0,"EncodeVLV2: ber_printf failed with %d\n",GetLastError());
        }
        ber_free(ber,1);
        return ERROR_INVALID_PARAMETER;
    }

    rc = ber_flatten(ber, &bval);
    ber_free(ber,1);

    if ( rc == -1 ) {
        IF_DEBUG(ENCODE) {
            DPRINT1(0,"EncodeVLV: ber_flatten failed with %d\n",GetLastError());
        }
        return ERROR_INVALID_PARAMETER;
    }

    control = (Controls)THAlloc(sizeof(struct Controls_) + bval->bv_len);

    if (control == NULL) {
        IF_DEBUG(ERROR) {
            DPRINT(0,"Could not allocate memory for controls\n");
        }
        ber_bvfree(bval);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    control->value.controlType = KnownControls[CONTROL_VLV_RESULT];
    control->value.controlValue.value = (PUCHAR)(control + 1);
    control->value.controlValue.length = bval->bv_len;

    CopyMemory(
        control->value.controlValue.value,
        bval->bv_val,
        bval->bv_len
        );

    ber_bvfree(bval);

    *VLVControl = control;
    return ERROR_SUCCESS;
} // EncodeVLVControl


DWORD
EncodeASQControl(
    IN Controls* ASQControl,
    DWORD        Err
    )
/*++

Routine Description:

    Encodes a ASQ control

Arguments:

    ASQControl - ASQ to encode

Return Value:

    ERROR_SUCCESS   - encoding went well.
    ERROR_NOT_ENOUGH_MEMORY - cannot allocate send buffers.
    
--*/
{
    PUCHAR  pTmp;
    Controls control;

    control = (Controls)THAlloc(sizeof(struct Controls_) + 5);

    if(control == NULL) {
        IF_DEBUG(ERROR) {
            DPRINT(0,"EncodeASQControl: Unable to allocate control memory\n");
        }
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    control->value.controlType = KnownControls[CONTROL_ASQ];
    control->value.controlValue.length = 5;
    control->value.controlValue.value = (PUCHAR)(control + 1);

    pTmp = control->value.controlValue.value;

    pTmp[0] = 0x30;     // SEQUENCE
    pTmp[1] = 0x3;

    pTmp[2] = 0x0A;      // sortResult
    pTmp[3] = 0x01;
    pTmp[4] = (UCHAR)Err;

    *ASQControl = control;

    return ERROR_SUCCESS;

} // EncodeASQControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\ldap\ldapconv.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ldapconv.cxx

Abstract:

    This module implements the LDAP server for the NT5 Directory Service.

    This file contains routines to convert between LDAP message structures and
    core dsa data structures.

Author:

    Tim Williams     [TimWi]    5-Aug-1996

Revision History:

--*/

#include <NTDSpchx.h>
#pragma  hdrstop

#include "ldapsvr.hxx"

extern "C" {

#include <dsjet.h>              // for error codes
#include "mdlocal.h"

#include <debug.h>
#include "filtypes.h"
#include "objids.h"
#include <allocaln.h>
#include "cracknam.h"
#include "ntdsapi.h"
#include "ntldap.h"
#include "dominfo.h"   
#include "pek.h"
#undef RPC_STRING // remove warning because samrpc.h defines RPC_STRING again
#include <nlwrap.h>     // I_NetLogon* wrappers

#include <drautil.h>
#include "ReplStructInfo.hxx"
#include "ReplMarshal.hxx"
#include "draconstr.h"
#include "drauptod.h"
}

#define  FILENO FILENO_LDAP_CONV
#define  MAX_NUM_STRING_LENGTH 12 // Big enough for 0xFFFFFFFF in decimal

//Taken from ldapcore.cxx
#define ATT_OPT_RANGE    2

// The default number of values returned
#define DEFAULT_VALUE_LIMIT 1000

LDAPString V2ReferralPreamble=DEFINE_LDAP_STRING("Referral:\x0Aldap://");
LDAPString V3ReferralPreamble=DEFINE_LDAP_STRING("ldap://");
LDAPString V2POQPreamble=DEFINE_LDAP_STRING("Referral:");

LDAPString LDAP_VERSION_TWO   = DEFINE_LDAP_STRING("2");
LDAPString LDAP_VERSION_THREE = DEFINE_LDAP_STRING("3");

//
// SASL Mechanisms
//
LDAPString LDAP_SASL_GSSAPI   = DEFINE_LDAP_STRING("GSSAPI");
LDAPString LDAP_SASL_SPNEGO   = DEFINE_LDAP_STRING("GSS-SPNEGO");
LDAPString LDAP_SASL_EXTERNAL = DEFINE_LDAP_STRING("EXTERNAL");
LDAPString LDAP_SASL_DIGEST   = DEFINE_LDAP_STRING("DIGEST-MD5");
#define NUM_SASL_MECHS 4

LDAPString ScopeBase = DEFINE_LDAP_STRING("??base");
LDAPString ScopeOne  = DEFINE_LDAP_STRING("??one");
LDAPString ScopeTree = DEFINE_LDAP_STRING("??sub");
LDAPString ScopeNull = DEFINE_LDAP_STRING("??");



_enum1
LDAP_FilterItemToDirFilterItem (
        IN  THSTATE        *pTHS,
        IN  ULONG          CodePage,
        IN  SVCCNTL        *Svccntl OPTIONAL,
        IN  UCHAR          Choice,
        IN  AttributeType  *pLDAP_att,
        IN  UCHAR          *pValOrSubstr,
        IN OUT FILTER         **ppDirFilter,
        OUT ATTCACHE       **ppAC         // OPTIONAL
        );

//
// Limits
// The MaxLimits field is defaulted to 0, meaning there is no maximum value
//

LIMIT_BLOCK KnownLimits[] = {
    { DEFINE_LDAP_STRING("MaxPoolThreads"), &LdapAtqMaxPoolThreads, LIMIT_LOW_MAX_POOL_THREADS },
    { DEFINE_LDAP_STRING("MaxDatagramRecv"), &LdapMaxDatagramRecv, LIMIT_LOW_MAX_DATAGRAM_RECV },
    { DEFINE_LDAP_STRING("MaxReceiveBuffer"), &LdapMaxReceiveBuffer, LIMIT_LOW_MAX_RECEIVE_BUF },
    { DEFINE_LDAP_STRING("InitRecvTimeout"), &LdapInitRecvTimeout, LIMIT_LOW_INIT_RECV_TIMEOUT },
    { DEFINE_LDAP_STRING("MaxConnections"), &LdapMaxConnections, LIMIT_LOW_MAX_CONNECTIONS },
    { DEFINE_LDAP_STRING("MaxConnIdleTime"), &LdapMaxConnIdleTime, LIMIT_LOW_MAX_CONN_IDLE },
    { DEFINE_LDAP_STRING("MaxPageSize"), &LdapMaxPageSize, LIMIT_LOW_MAX_PAGE_SIZE },
    { DEFINE_LDAP_STRING("MaxQueryDuration"), &LdapMaxQueryDuration, LIMIT_LOW_MAX_QUERY_DURATION },
    { DEFINE_LDAP_STRING("MaxTempTableSize"), &LdapMaxTempTable, LIMIT_LOW_MAX_TEMP_TABLE_SIZE },
    { DEFINE_LDAP_STRING("MaxResultSetSize"), &LdapMaxResultSet, LIMIT_LOW_MAX_RESULT_SET_SIZE },
    { DEFINE_LDAP_STRING("MaxNotificationPerConn"), &LdapMaxNotifications, LIMIT_LOW_MAX_NOTIFY_PER_CONN },
    { DEFINE_LDAP_STRING(""), NULL, 0 }
};
#define NUM_KNOWNLIMITS (sizeof(KnownLimits)/sizeof(LIMIT_BLOCK) - 1)

//
// Configurable Settings
// WARN: changes to default values should be reflected in schema.ini
// Dump this data struct from the debugger using the dump LIMITS in dsexts.
//

LIMIT_BLOCK KnownConfSets[] = {
{ DEFINE_LDAP_STRING("DynamicObjectDefaultTTL"), 
                     (PDWORD)&DynamicObjectDefaultTTL, 
                     LIMIT_LOW_DYNAMIC_OBJECT_TTL,
                     LIMIT_HIGH_DYNAMIC_OBJECT_TTL },
{ DEFINE_LDAP_STRING("DynamicObjectMinTTL"), 
                     (PDWORD)&DynamicObjectMinTTL, 
                     LIMIT_LOW_DYNAMIC_OBJECT_TTL,
                     LIMIT_HIGH_DYNAMIC_OBJECT_TTL } ,
{ DEFINE_LDAP_STRING(""), NULL, 0 }
};
#define NUM_KNOWNCONFSETS (sizeof(KnownConfSets)/sizeof(LIMIT_BLOCK) - 1)

//
// Extended Requests
//
// !!!If you change this you must change NUM_EXTENDED_REQUESTS in const.hxx!!!
LDAPOID KnownExtendedRequests [] = {
    DEFINE_LDAP_STRING(LDAP_SERVER_START_TLS_OID),
    DEFINE_LDAP_STRING(LDAP_TTL_REFRESH_OID),
    DEFINE_LDAP_STRING(LDAP_SERVER_FAST_BIND_OID)
};

//
// Controls !!! Must match index in const.hxx
//

LDAPOID KnownControls[] = {
    DEFINE_LDAP_STRING(LDAP_PAGED_RESULT_OID_STRING),   // 319
    DEFINE_LDAP_STRING(LDAP_SERVER_SD_FLAGS_OID),       // 801
    DEFINE_LDAP_STRING(LDAP_SERVER_SORT_OID),           // 473
    DEFINE_LDAP_STRING(LDAP_SERVER_NOTIFICATION_OID),   // 528
    DEFINE_LDAP_STRING(LDAP_SERVER_SHOW_DELETED_OID),   // 417
    DEFINE_LDAP_STRING(LDAP_SERVER_LAZY_COMMIT_OID),    // 619
    DEFINE_LDAP_STRING(LDAP_SERVER_DIRSYNC_OID),        // 841
    DEFINE_LDAP_STRING(LDAP_SERVER_EXTENDED_DN_OID),    // 529
    DEFINE_LDAP_STRING(LDAP_SERVER_TREE_DELETE_OID),    // 805
    DEFINE_LDAP_STRING(LDAP_SERVER_CROSSDOM_MOVE_TARGET_OID),   // 521
    DEFINE_LDAP_STRING(LDAP_SERVER_GET_STATS_OID),      // 970
    DEFINE_LDAP_STRING(LDAP_SERVER_VERIFY_NAME_OID),    // 1338
    DEFINE_LDAP_STRING(LDAP_SERVER_RESP_SORT_OID),      // 474
    DEFINE_LDAP_STRING(LDAP_SERVER_DOMAIN_SCOPE_OID),   // 1339
    DEFINE_LDAP_STRING(LDAP_SERVER_SEARCH_OPTIONS_OID), // 1340
    DEFINE_LDAP_STRING(LDAP_SERVER_PERMISSIVE_MODIFY_OID),//1413
    DEFINE_LDAP_STRING(LDAP_CONTROL_VLVREQUEST),         // 9
    DEFINE_LDAP_STRING(LDAP_CONTROL_VLVRESPONSE),        // 10
    DEFINE_LDAP_STRING(LDAP_SERVER_ASQ_OID),             // 1504
    DEFINE_LDAP_STRING("1.2.840.113556.1.4.802")         // range option
};
#define NUM_KNOWNCONTROLS (sizeof(KnownControls)/sizeof(LDAPOID))

//
// Matching rules
//

LDAPOID KnownMatchingRules[] = {
    DEFINE_LDAP_STRING("1"),                      // unknown
    DEFINE_LDAP_STRING("1.2.840.113556.1.4.803"), // bit and
    DEFINE_LDAP_STRING("1.2.840.113556.1.4.804")  // bit or
};
#define NUM_KNOWNMATCHINGRULES (sizeof(KnownMatchingRules)/sizeof(LDAPOID))

#define MATCH_UNKNOWN 0
#define MATCH_BIT_AND 1
#define MATCH_BIT_OR  2

// OIDs for recycling
// 1.2.840.113556.1.4.416   // NOTENOTE: Cannot be used for a control. Was old SD control.

//
// OIDs that can be used for anything
//

// 1.2.840.113556.1.4.1341
// 1.2.840.113556.1.4.1342

//
// Supported Capabilities
//

LDAPOID SupportedCapabilities[] = {
    DEFINE_LDAP_STRING(LDAP_CAP_ACTIVE_DIRECTORY_OID),
    DEFINE_LDAP_STRING(LDAP_CAP_ACTIVE_DIRECTORY_V51_OID),
    DEFINE_LDAP_STRING("1.2.840.113556.1.4.1791")
};
#define NUM_SUPPORTED_CAPS  (sizeof(SupportedCapabilities)/sizeof(LDAPOID))


// There are attributes we support but that are not stored in the
// schema.

AttributeType RootDSEAtts[] = {
    DEFINE_LDAP_STRING("subschemaSubentry"),
    DEFINE_LDAP_STRING("currentTime"),
    DEFINE_LDAP_STRING("serverName"),
    DEFINE_LDAP_STRING("namingContexts"),
    DEFINE_LDAP_STRING("defaultNamingContext"),
    DEFINE_LDAP_STRING("pendingPropagations"),
    DEFINE_LDAP_STRING("netlogon"),
    DEFINE_LDAP_STRING("supportedControl"),
    DEFINE_LDAP_STRING("highestCommittedUSN"),
    DEFINE_LDAP_STRING("supportedLDAPVersion"),
    DEFINE_LDAP_STRING("supportedLDAPPolicies"),
    DEFINE_LDAP_STRING("schemaNamingContext"),
    DEFINE_LDAP_STRING("configurationNamingContext"),
    DEFINE_LDAP_STRING("rootDomainNamingContext"),
    DEFINE_LDAP_STRING("supportedSASLMechanisms"),
    DEFINE_LDAP_STRING("dnsHostName"),
    DEFINE_LDAP_STRING("ldapServiceName"),
    DEFINE_LDAP_STRING("approxDBLoad"),
    DEFINE_LDAP_STRING("dsServiceName"),
    DEFINE_LDAP_STRING("supportedCapabilities"),

    // the next three are not publicly visible
    DEFINE_LDAP_STRING("dsSchemaAttrCount"),
    DEFINE_LDAP_STRING("dsSchemaClassCount"),
    DEFINE_LDAP_STRING("dsSchemaPrefixCount"),

    DEFINE_LDAP_STRING("isSynchronized"),
    DEFINE_LDAP_STRING("isGlobalCatalogReady"),
    DEFINE_LDAP_STRING("supportedConfigurableSettings"),
    DEFINE_LDAP_STRING("supportedExtension"),

    DEFINE_LDAP_STRING("msDS-ReplPendingOps"),
    DEFINE_LDAP_STRING("msDS-ReplLinkFailures"),
    DEFINE_LDAP_STRING("msDS-ReplConnectionFailures"),
    DEFINE_LDAP_STRING("msDS-ReplAllInboundNeighbors"),
    DEFINE_LDAP_STRING("msDS-ReplAllOutboundNeighbors"),
    DEFINE_LDAP_STRING("msDS-ReplQueueStatistics"),
    DEFINE_LDAP_STRING("domainFunctionality"),
    DEFINE_LDAP_STRING("forestFunctionality"),
    DEFINE_LDAP_STRING("domainControllerFunctionality")
};
#define NUM_ROOT_DSE_ATTS (sizeof(RootDSEAtts)/sizeof(AttributeType))

// Keep the following list in the same order as the RootDSEAtts array
#define LDAP_ATT_SUBSCHEMA_SUBENTRY                   0
#define LDAP_ATT_CURRENT_TIME                         1
#define LDAP_ATT_SERVER_NAME                          2
#define LDAP_ATT_NAMING_CONTEXTS                      3
#define LDAP_ATT_DEFAULT_NAMING_CONTEXT               4
#define LDAP_ATT_PENDING_PROPAGATIONS                 5
#define LDAP_ATT_NETLOGON                             6
#define LDAP_ATT_SUPPORTED_CONTROLS                   7
#define LDAP_ATT_HIGHEST_COMMITTED_USN                8
#define LDAP_ATT_SUPPORTED_VERSION                    9
#define LDAP_ATT_SUPPORTED_POLICIES                  10
#define LDAP_ATT_SCHEMA_NC                           11
#define LDAP_ATT_CONFIG_NC                           12
#define LDAP_ATT_ROOT_DOMAIN_NC                      13
#define LDAP_ATT_SUPPORTED_SASL_MECHANISM            14
#define LDAP_ATT_DNS_HOST_NAME                       15
#define LDAP_ATT_LDAP_SERVICE_NAME                   16
#define LDAP_ATT_APPROX_DB_LOAD                      17
#define LDAP_ATT_DS_SERVICE_NAME                     18
#define LDAP_ATT_SUPPORTED_CAPS                      19
#define LDAP_ATT_SCHEMA_ATTCOUNT                     20
#define LDAP_ATT_SCHEMA_CLSCOUNT                     21
#define LDAP_ATT_SCHEMA_PREFIXCOUNT                  22
#define LDAP_ATT_IS_SYNCHRONIZED                     23
#define LDAP_ATT_IS_GC_READY                         24
#define LDAP_ATT_SUPPORTED_CONFIGURABLE_SETTINGS     25
#define LDAP_ATT_SUPPORTED_EXTENSIONS                26
#define LDAP_ATT_MSDS_REPLPENDINGOPS                 27
#define LDAP_ATT_MSDS_REPLLINKFAILURES               28
#define LDAP_ATT_MSDS_REPLCONNECTIONFAILURES         29
#define LDAP_ATT_MSDS_REPLALLINBOUNDNEIGHBORS        30
#define LDAP_ATT_MSDS_REPLALLOUTBOUNDNEIGHBORS       31
#define LDAP_ATT_MSDS_REPLQUEUESTATISTICS            32
#define LDAP_ATT_DOMAIN_BEHAVIOR_VERSION             33
#define LDAP_ATT_FOREST_BEHAVIOR_VERSION             34
#define LDAP_ATT_DC_BEHAVIOR_VERSION                 35

    
typedef struct _RootDSEModControls {
    LDAPString name;
    OpType     eOp;
} RootDSEModControls;

RootDSEModControls KnownRootDSEMods[] = {
//  The following control is not to be made available to LDAP.  Ever.
//  I'm leaving it here as a comment to make this obvious so it isn't accidently
//  added in again later.  MurliS (Mr. RIDs) has said this control should only
//  be available to internal callers.
//    {DEFINE_LDAP_STRING("allocateRids"), OP_CTRL_RID_ALLOC},
    {DEFINE_LDAP_STRING("becomeDomainMaster"), OP_CTRL_BECOME_DOM_MASTER},
    {DEFINE_LDAP_STRING("becomeRidMaster"), OP_CTRL_BECOME_RID_MASTER},
    {DEFINE_LDAP_STRING("becomeSchemaMaster"), OP_CTRL_BECOME_SCHEMA_MASTER},
    {DEFINE_LDAP_STRING("doGarbageCollection"), OP_CTRL_GARB_COLLECT},
    {DEFINE_LDAP_STRING("recalcHierarchy"), OP_CTRL_RECALC_HIER},
    {DEFINE_LDAP_STRING("schemaUpdateNow"), OP_CTRL_SCHEMA_UPDATE_NOW},
    {DEFINE_LDAP_STRING("becomePdc"), OP_CTRL_BECOME_PDC},
    {DEFINE_LDAP_STRING("fixupInheritance"), OP_CTRL_FIXUP_INHERITANCE},
    {DEFINE_LDAP_STRING("invalidateRidPool"), OP_CTRL_INVALIDATE_RID_POOL},
    {DEFINE_LDAP_STRING("dumpDatabase"), OP_CTRL_DUMP_DATABASE},
    {DEFINE_LDAP_STRING("checkPhantoms"), OP_CTRL_CHECK_PHANTOMS},
    {DEFINE_LDAP_STRING("becomeInfrastructureMaster"), OP_CTRL_BECOME_INFRASTRUCTURE_MASTER},
    {DEFINE_LDAP_STRING("updateCachedMemberships"), OP_CTRL_UPDATE_CACHED_MEMBERSHIPS},
    {DEFINE_LDAP_STRING("becomePdcWithCheckPoint"), OP_CTRL_BECOME_PDC_WITH_CHECKPOINT},
    {DEFINE_LDAP_STRING("doLinkCleanup"), OP_CTRL_LINK_CLEANUP},
    {DEFINE_LDAP_STRING("SchemaUpgradeInProgress"), OP_CTRL_SCHEMA_UPGRADE_IN_PROGRESS},
#if DBG
    // Can't enable abandonFsmoRoles in non-DBG builds unless you first add an
    // access check to GiveawayAllFsmoRoles!
    {DEFINE_LDAP_STRING("abandonFsmoRoles"), OP_CTRL_FSMO_GIVEAWAY},
    {DEFINE_LDAP_STRING("enableLinkedValueReplication"), OP_CTRL_ENABLE_LVR},
    {DEFINE_LDAP_STRING("replTestHook"), OP_CTRL_REPL_TEST_HOOK},
    {DEFINE_LDAP_STRING("DynamicObjectControl"), OP_CTRL_DYNAMIC_OBJECT_CONTROL},
    {DEFINE_LDAP_STRING("executeScript"),OP_CTRL_EXECUTE_SCRIPT},
#ifdef INCLUDE_UNIT_TESTS
    {DEFINE_LDAP_STRING("refCountTest"), OP_CTRL_REFCOUNT_TEST},
    {DEFINE_LDAP_STRING("takeCheckPoint"), OP_CTRL_TAKE_CHECKPOINT},
    {DEFINE_LDAP_STRING("roleTransferStress"),OP_CTRL_ROLE_TRANSFER_STRESS},
    {DEFINE_LDAP_STRING("checkAncestors"),OP_CTRL_ANCESTORS_TEST},
    {DEFINE_LDAP_STRING("BhcacheTest"),OP_CTRL_BHCACHE_TEST},
    {DEFINE_LDAP_STRING("scCacheConsistencyTest"),OP_SC_CACHE_CONSISTENCY_TEST},
    {DEFINE_LDAP_STRING("phantomize"),OP_CTRL_PHANTOMIZE},
    {DEFINE_LDAP_STRING("removeObject"),OP_CTRL_REMOVE_OBJECT},
    {DEFINE_LDAP_STRING("genericControl"), OP_CTRL_GENERIC_CONTROL},
    {DEFINE_LDAP_STRING("protectObject"),OP_CTRL_PROTECT_OBJECT},
#endif
#endif
};

#define numKnownRootDSEMods \
                         (sizeof(KnownRootDSEMods)/sizeof(RootDSEModControls))
     

// default heuristic for permissive modify is FALSE
BOOL gbLDAPusefPermissiveModify = FALSE;

enum CtrlCriticality {
    ctrlNotFound      = 0,
    ctrlCriticalTrue  = 1,
    ctrlCriticalFalse = 2
    };

_enum1
LDAP_ControlsToControlArg(
        IN  Controls         LDAP_Controls,
        IN  PLDAP_REQUEST    Request,
        IN  ULONG            CodePage,
        OUT CONTROLS_ARG     *pControlArg
        )
{
    THSTATE                        *pTHS=pTHStls;
    ULONG                          i, ulControlID=CONTROL_UNKNOWN;
    AttributeType                  AttType;
    AttributeType                  asqAttType;
    AssertionValue                 vlvAttVal;
    MatchingRuleId                 MatchingRule;
    ATTCACHE                       *pAC=NULL;
    DWORD                          searchFlags, statFlags;
    BERVAL                         pageCookieVal;
    BERVAL                         vlvCookieVal;
    _enum1                         code;

    // These flags are set to 0 if not found, 1 if critical, 2 if non-critical
    CtrlCriticality                 fSortControlFound            = ctrlNotFound;
    CtrlCriticality                 fPagedControlFound           = ctrlNotFound;
    CtrlCriticality                 fRenameServerControlFound    = ctrlNotFound;
    CtrlCriticality                 fSDFlagsControlFound         = ctrlNotFound;
    CtrlCriticality                 fShowDeletedControlFound     = ctrlNotFound;
    CtrlCriticality                 fNotificationControlFound    = ctrlNotFound;
    CtrlCriticality                 fLazyCommitControlFound      = ctrlNotFound;
    CtrlCriticality                 fReplicationControlFound     = ctrlNotFound;
    CtrlCriticality                 fGcVerifyControlFound        = ctrlNotFound;
    CtrlCriticality                 fTreeDeleteControlFound      = ctrlNotFound;
    CtrlCriticality                 fStatRequestControlFound     = ctrlNotFound;
    CtrlCriticality                 fExtendedDNControlFound      = ctrlNotFound;
    CtrlCriticality                 fDontGenRefFound             = ctrlNotFound;
    CtrlCriticality                 fPermissiveModifyFound       = ctrlNotFound;
    CtrlCriticality                 fVLVFound                    = ctrlNotFound;
    CtrlCriticality                 fASQFound                    = ctrlNotFound;
    
    // set the permissive modify flag according to heuristics
    if (gbLDAPusefPermissiveModify) {
        pControlArg->CommArg.Svccntl.fPermissiveModify = 1;
    }
    
    pControlArg->Stats[STAT_THREADCOUNT].Stat = STAT_THREADCOUNT;
    pControlArg->Stats[STAT_THREADCOUNT].Value = *pcLDAPActive;

    // Keep track of start time in milliseconds
    pControlArg->Stats[STAT_CALLTIME].Stat = STAT_CALLTIME;
    QueryPerformanceCounter(&pControlArg->StartTick);

    pControlArg->Stats[STAT_ENTRIES_RETURNED].Stat = STAT_ENTRIES_RETURNED;
    pControlArg->Stats[STAT_ENTRIES_VISITED].Stat = STAT_ENTRIES_VISITED;
    pControlArg->Stats[STAT_FILTER].Stat = STAT_FILTER;
    pControlArg->Stats[STAT_INDEXES].Stat = STAT_INDEXES;
    
    //
    // Allow core to sort unless 
    //

    if ( (LdapFlags & DEBUG_NO_REORDER) == 0 ) {
        pControlArg->CommArg.Svccntl.fMaintainSelOrder = FALSE;
    }

    //
    // If this didn't come through the GC Port, don't use copies
    //

    if ( !Request->m_LdapConnection->m_fGC ) {
        pControlArg->CommArg.Svccntl.dontUseCopy = TRUE;
    } else {
        pControlArg->CommArg.Svccntl.fGcAttsOnly = TRUE;
    }

    //
    // First, deal with the Controls
    //

    while (LDAP_Controls) {

        BOOL    fCriticality;
        BERVAL  bv;

        //
        // First, see if we understand the control type
        // That's a check of LDAP_Controls->value.controlType which sets
        // ulControlID.
        //

        ulControlID = CONTROL_UNKNOWN;
        
        for(i=0;i<NUM_KNOWNCONTROLS;i++) {

            if(AreOidsEqual(&LDAP_Controls->value.controlType,
                            &KnownControls[i])) {
                ulControlID = i;
                break;
            }
        }
        
        bv.bv_val = (PCHAR)LDAP_Controls->value.controlValue.value;
        bv.bv_len = LDAP_Controls->value.controlValue.length;

        fCriticality = LDAP_Controls->value.criticality;

        switch(ulControlID) {

        case CONTROL_SORTED_SEARCH:

            BOOL fReverseSort;

            if(fSortControlFound) {
                // Hey, you can't specify two of these.
                return protocolError;
            }

            fSortControlFound = fCriticality ? ctrlCriticalTrue : ctrlCriticalFalse;

            if(DecodeSortControl(
                         CodePage,
                         &bv,
                         &fReverseSort,
                         &AttType,
                         &MatchingRule)) {

                if(fCriticality) {
                    // Ooops, critical unrecognized control
                    return unavailableCriticalExtension;
                } else {
                    fSortControlFound = ctrlNotFound;
                    break;
                }
            }

            IF_DEBUG(SEARCH) {
                DPRINT1(0,"Sorted search control found[rev %x].\n",fReverseSort);
            }

            if ( fReverseSort ) {
                pControlArg->CommArg.fForwardSeek = FALSE;
            }

            // OK, we have a type, go ahead and try to sort by it.

            pControlArg->CommArg.SortType = fCriticality? 
                                                SORT_MANDATORY :
                                                SORT_OPTIONAL;

            break;

        case CONTROL_CROSS_DOM_MOVE_TARGET:
            if(fRenameServerControlFound) {
                // Hey, you can't specify two of these.
                return protocolError;
            }
            fRenameServerControlFound = fCriticality ? ctrlCriticalTrue : ctrlCriticalFalse;

            if(bv.bv_len != 0) {
                ULONG totalLength;
                
                // OK, they sent us a string.  Allo
                totalLength = MultiByteToWideChar(
                        CodePage,
                        0,
                        bv.bv_val,
                        bv.bv_len,
                        NULL,
                        0);
                if (totalLength == 0) {
                    // error occured
                    IF_DEBUG(ERR_NORMAL) {
                        DPRINT1(0,"MultiByteToWideChar failed with %d\n",GetLastError());
                    }
                    return other;
                }

                pControlArg->pModDnDSAName =
                    (WCHAR *)THAlloc((totalLength + 1) * sizeof(WCHAR));
                
                if ( pControlArg->pModDnDSAName == NULL ) {
                    return other;
                }

                totalLength = MultiByteToWideChar(
                        CodePage,
                        0,
                        (const char *)bv.bv_val,
                        bv.bv_len,
                        pControlArg->pModDnDSAName,
                        sizeof(WCHAR) * totalLength);
                
                if (totalLength == 0) {
                    // error occured
                    IF_DEBUG(ERR_NORMAL) {
                        DPRINT1(0,"MultiByteToWideChar failed with %d\n",GetLastError());
                    }
                    return other;
                }
                
                pControlArg->pModDnDSAName[totalLength] = '\0';
            }
            else {
                // Zero length value means to perform checks only.
                // This is indicated to core by 0-length string.
                pControlArg->pModDnDSAName = L"";
            }
            break;

        case CONTROL_PAGED_RESULTS:

            DWORD pageSize;

            if(fPagedControlFound) {
                // Hey, you can't specify two of these.
                return protocolError;
            }
            fPagedControlFound = (fCriticality? ctrlCriticalTrue : ctrlCriticalFalse);
            // Parse the paged results data

            if ( DecodePagedControl(
                            &bv, 
                            &pageSize, 
                            &pageCookieVal) != ERROR_SUCCESS) {

                if(fCriticality) {
                    // Ooops, critical unrecognized control
                    return unavailableCriticalExtension;
                } else {
                    fPagedControlFound = ctrlNotFound;
                    break;
                }
            }
            pControlArg->pageRequest = TRUE;
            pControlArg->pageSize = pageSize;
            break;

        case CONTROL_SECURITY_DESCRIPTOR_BER:

            DWORD sdFlags;

            if(fSDFlagsControlFound) {
                // Hey, you can't specify two of these.
                return protocolError;
            }
            fSDFlagsControlFound = fCriticality ? ctrlCriticalTrue : ctrlCriticalFalse;

            if(DecodeSDControl(&bv, &sdFlags) != ERROR_SUCCESS) {

                if(fCriticality) {
                    // Ooops, critical unrecognized control
                    return unavailableCriticalExtension;
                } else {
                    fSDFlagsControlFound = ctrlNotFound;
                    break;
                }
            }

            sdFlags &= LDAP_VALID_SECURITY_DESCRIPTOR_MASK;

            pControlArg->CommArg.Svccntl.SecurityDescriptorFlags = sdFlags;
            pControlArg->sdRequest = TRUE;

            break;

        case CONTROL_SHOW_DELETED:
            if(fShowDeletedControlFound) {
                // Hey, you can't specify two of these.
                return protocolError;
            }
            fShowDeletedControlFound = fCriticality ? ctrlCriticalTrue : ctrlCriticalFalse;
            
            // should be no data
            if(bv.bv_len != 0) {
                // This isn't supposed to have any data!
                if(fCriticality) {
                    // Ooops, critical unrecognized control
                    return unavailableCriticalExtension;
                }
                else {
                    fShowDeletedControlFound = ctrlNotFound;
                    break;
                }
            }

            pControlArg->CommArg.Svccntl.makeDeletionsAvail = TRUE;
            break;

        case CONTROL_TREE_DELETE:
            if(fTreeDeleteControlFound) {
                // Hey, you can't specify two of these.
                return protocolError;
            }
            fTreeDeleteControlFound =fCriticality ? ctrlCriticalTrue : ctrlCriticalFalse;

            // should be no data
            if(bv.bv_len != 0) {
                // This isn't supposed to have any data!
                if(fCriticality) {
                    // Ooops, critical unrecognized control
                    return unavailableCriticalExtension;
                }
                else {
                    fTreeDeleteControlFound = ctrlNotFound;
                    break;
                }
            }

            pControlArg->treeDelete = TRUE;
            break;

        case CONTROL_STAT_REQUEST:
            
            statFlags = 0;
            
            if(fStatRequestControlFound) {
                // Hey, you can't specify two of these.
                return protocolError;
            }
            fStatRequestControlFound =fCriticality ? ctrlCriticalTrue : ctrlCriticalFalse;

            // Parse the stat request data
            if(bv.bv_len != 0) {
                if(DecodeStatControl(&bv, &statFlags) != ERROR_SUCCESS ) {
                    if(fCriticality) {
                        // Ooops, critical unrecognized control
                        return unavailableCriticalExtension;
                    } else {
                        fStatRequestControlFound = ctrlNotFound;
                        break;
                    }
                }
                //
                // Set the correct flags
                //

                if ( statFlags & SO_ONLY_OPTIMIZE ) {
                    pControlArg->CommArg.Svccntl.DontPerformSearchOp = SO_ONLY_OPTIMIZE;
                } else if ( statFlags & SO_STATS ) {
                    pControlArg->CommArg.Svccntl.DontPerformSearchOp = SO_STATS;
                }
            }
            else {
                pControlArg->CommArg.Svccntl.DontPerformSearchOp = SO_STATS;
            }

            pControlArg->statRequest = TRUE;
            break;
            
        case CONTROL_DN_EXTENDED:

            if(fExtendedDNControlFound) {
                // Hey, you can't specify two of these.
                return protocolError;
            }
            fExtendedDNControlFound =fCriticality ? ctrlCriticalTrue : ctrlCriticalFalse;

            // should be no data.
            if(bv.bv_len != 0) {
                // This isn't supposed to have any data!
                if(fCriticality) {
                    // Ooops, critical unrecognized control
                    return unavailableCriticalExtension;
                }
                else {
                    fExtendedDNControlFound = ctrlNotFound;
                    break;
                }
            }

            pControlArg->extendedDN = TRUE;
            break;
            
        case CONTROL_LAZY_COMMIT:
            if(fLazyCommitControlFound) {
                // Hey, you can't specify two of these.
                return protocolError;
            }
            fLazyCommitControlFound = fCriticality ? ctrlCriticalTrue : ctrlCriticalFalse;

            // Parse the lazy commit data
            if(bv.bv_len != 0) {
                // This isn't supposed to have any data!
                if(fCriticality) {
                    // Ooops, critical unrecognized control
                    return unavailableCriticalExtension;
                }
                else {
                    fLazyCommitControlFound = ctrlNotFound;
                    break;
                }
            }

            pControlArg->CommArg.fLazyCommit = TRUE;
            break;

        case CONTROL_NOTIFICATION:
            if(fNotificationControlFound) {
                // Hey, you can't specify two of these.
                return protocolError;
            }

            if ( Request->m_LdapConnection->m_fUDP ) {

                IF_DEBUG(SEARCH) {
                    DPRINT(0,"Notifications not allowed on UDP\n");
                }
                return protocolError;
            }

            fNotificationControlFound = fCriticality ? ctrlCriticalTrue : ctrlCriticalFalse;
            
            // should be no data
            if(bv.bv_len != 0) {
                // This isn't supposed to have any data!
                if(fCriticality) {
                    // Ooops, critical unrecognized control
                    return unavailableCriticalExtension;
                }
                else {
                    fNotificationControlFound = ctrlNotFound;
                    break;
                }
            }

            pControlArg->Notification = TRUE;
            break;
            
        case CONTROL_REPLICATION:

            DWORD replSize;
            DWORD replFlags;
            BERVAL replBv;

            if(fReplicationControlFound) {
                // Hey, you can't specify two of these.
                return protocolError;
            }
            fReplicationControlFound = fCriticality ? ctrlCriticalTrue : ctrlCriticalFalse;

            if( !fCriticality ) {
                return protocolError;   //Criticality must be true
            }

            if(DecodeReplicationControl(&bv, 
                        &replFlags, 
                        &replSize, 
                        &replBv ) != ERROR_SUCCESS ) {

                return unavailableCriticalExtension;
            }

            // Check if any old clients are using invalid values
            Assert( !(replFlags & ~LDAP_VALID_DIRSYNC_CONTROL_FLAGS) );

            pControlArg->replRequest = TRUE;
            pControlArg->replFlags = replFlags & LDAP_VALID_DIRSYNC_CONTROL_FLAGS;
            pControlArg->replFlags |= DRS_DIRSYNC_PUBLIC_DATA_ONLY;  // no secrets

            pControlArg->replSize = replSize;
            pControlArg->replCookie.length = replBv.bv_len;
            pControlArg->replCookie.value = (PUCHAR)replBv.bv_val;

            IF_DEBUG(SEARCH) {
                DPRINT2(0,"Repl control: flags %x size %d\n",replFlags, replSize);
            }
            break;

        case CONTROL_SERVER_VERIFY_NAME:

            DWORD verifyFlags;
            PWCHAR gcVerifyName;

            if(fGcVerifyControlFound) {
                // Hey, you can't specify two of these.
                return protocolError;
            }
            fGcVerifyControlFound = fCriticality ? ctrlCriticalTrue : ctrlCriticalFalse;

            if( !fCriticality ) {
                return protocolError;   //Criticality must be true
            }

            if(DecodeGCVerifyControl(&bv, 
                        &verifyFlags, 
                        &gcVerifyName ) != ERROR_SUCCESS ) {

                return unavailableCriticalExtension;
            }

            pControlArg->CommArg.Svccntl.pGCVerifyHint = gcVerifyName;

            IF_DEBUG(SEARCH) {
                DPRINT2(0,"GC Verify control: flags %x name %ws\n",
                        verifyFlags, gcVerifyName);
            }
            break;

        case CONTROL_DOMAIN_SCOPE:     

            if(fDontGenRefFound) {
                // Hey, you can't specify two of these.
                return protocolError;
            }

            fDontGenRefFound = fCriticality ? ctrlCriticalTrue : ctrlCriticalFalse;
            
            // No data
            if(bv.bv_len != 0) {
                // This isn't supposed to have any data!
                if(fCriticality) {
                    // Ooops, critical unrecognized control
                    return unavailableCriticalExtension;
                }
                else {
                    fDontGenRefFound = ctrlNotFound;
                    break;
                }
            }

            pControlArg->CommArg.Svccntl.localScope = 1;
            break;

        case CONTROL_SEARCH_OPTIONS:

            searchFlags = 0;

            if(DecodeSearchOptionControl(&bv, &searchFlags) != ERROR_SUCCESS ) {

                if(fCriticality) {
                    // Ooops, critical unrecognized control
                    return unavailableCriticalExtension;
                } else {
                    break;
                }
            }

            //
            // Set the correct flags
            //

            if ( searchFlags & SERVER_SEARCH_FLAG_DOMAIN_SCOPE ) {
                pControlArg->CommArg.Svccntl.localScope = 1;
            } 
            
            if ( searchFlags & SERVER_SEARCH_FLAG_PHANTOM_ROOT ) {
                pControlArg->phantomRoot = 1;
            }

            break;
        
        case CONTROL_PERMISSIVE_MODIFY:
            
            if(fPermissiveModifyFound) {
                // Hey, you can't specify two of these.
                return protocolError;
            }

            fPermissiveModifyFound = fCriticality ? ctrlCriticalTrue : ctrlCriticalFalse;
            
            pControlArg->CommArg.Svccntl.fPermissiveModify = 1;

            break;
        case CONTROL_VLV:
            if (fVLVFound) {
                // Can't specify two of these.
                return protocolError;           
            }
            fVLVFound = fCriticality ? ctrlCriticalTrue : ctrlCriticalFalse;

            if (DecodeVLVControl(&bv, &(pControlArg->CommArg.VLVRequest), &vlvCookieVal, &vlvAttVal)) {

                if (fCriticality) {
                    return unavailableCriticalExtension;
                } else {
                    fVLVFound = ctrlNotFound;
                    break;
                }
            }
            pControlArg->vlvRequest = TRUE;
            break;

        case CONTROL_ASQ:
            if (fASQFound) {
                // Can't specify two of these.
                return protocolError;           
            }

            fASQFound = fCriticality ? ctrlCriticalTrue : ctrlCriticalFalse;

            if (DecodeASQControl(&bv, &asqAttType) ) {

                if (fCriticality) {
                     return unavailableCriticalExtension;
                } else {
                    fASQFound = ctrlNotFound;
                    break;
                }
            }
            pControlArg->asqRequest = TRUE;
            break;

        case CONTROL_SORT_RESULT:
            // This is not valid as an input control, fall through
        case CONTROL_UNKNOWN:
        default:
            if(fCriticality) {
                // Ooops, critical unrecognized control
                return unavailableCriticalExtension;
            }
            break;
        }
        
        LDAP_Controls = LDAP_Controls->next;
    }

    IF_DEBUG(PAGED) {        
        if (fPagedControlFound || fVLVFound) {
            DPRINT2 (0, "VLV: %d  PAGED: %d\n", fVLVFound, fPagedControlFound);
        }
    }

    if (fPagedControlFound && fVLVFound) {

        if ((fPagedControlFound == ctrlCriticalTrue) && (fVLVFound == ctrlCriticalFalse)) {
            // paged is critical, VLV is not, so forget about VLV
            fVLVFound = ctrlNotFound;
            pControlArg->vlvRequest = FALSE;
            IF_DEBUG(PAGED) {        
                DPRINT (0, "Skipping VLV\n");
            }
        }
        else if ((fPagedControlFound == ctrlCriticalFalse) && (fVLVFound == ctrlCriticalTrue)) {
            // VLV is critical, paged is not, so forget about paged
            fPagedControlFound = ctrlNotFound;
            pControlArg->pageRequest = FALSE;
            IF_DEBUG(PAGED) {        
                DPRINT (0, "Skipping Paged\n");
            }
        }
        else if ((fPagedControlFound == ctrlCriticalTrue) && (fVLVFound == ctrlCriticalTrue)) {
            // VLV and paged are critical. this is error
            IF_DEBUG(PAGED) {        
                DPRINT (0, "ERROR. VLV & PAGED critical\n");
            }
            pTHS->errCode = ERROR_DS_INCOMPATIBLE_CONTROLS_USED;
            return unavailableCriticalExtension;
        }
        else {
            // VLV and paged are not critical. forget VLV
            fVLVFound = ctrlNotFound;
            pControlArg->vlvRequest = FALSE;
            IF_DEBUG(PAGED) {        
                DPRINT (0, "Skipping VLV\n");
            }
        }
    }


    if((fSortControlFound || fPagedControlFound) &&
       fNotificationControlFound) {
        // Potential conflict of controls.
        if(fNotificationControlFound == ctrlCriticalFalse) {
            // Notification was requested in a non-critical way.  Some
            // conflicting control was also specified.  Since notification was
            // not critical, don't do it.
            pControlArg->Notification = FALSE;
        }
        else {
            // Notification was critical.  Check the others.
            if((fSortControlFound==ctrlCriticalTrue) || (fPagedControlFound == ctrlCriticalTrue)) {
                // No good.  these conflict.
                return unavailableCriticalExtension;
            }
            else {
                if(fSortControlFound) {
                    // OK, we don't sort.
                    pControlArg->CommArg.SortType = 0;
                    pControlArg->sortResult = sortUnwillingToPerform;
                }
                if(fPagedControlFound) {
                    // OK, we don't page
                    pControlArg->pageRequest = FALSE;
                    pControlArg->pageSize = 0;
                    
                }
            }
        }
    }

    if (fSortControlFound) {
        // Convert the name of the attribute to do the sorting on
        // to the internal attribute type.
        if(LDAP_AttrTypeToDirAttrTyp (pTHS,
                                      CodePage,
                                      NULL,                           // don't need a SVCCNTL.
                                      &AttType,                       // The att to be converted.
                                      &pControlArg->CommArg.SortAttr, // The converted att type.
                                      &pAC)) {                        // Get the attcache for later use.
            pControlArg->sortResult = sortNoSuchAttribute;
            pControlArg->CommArg.SortType = 0;
            if (ctrlCriticalFalse == fSortControlFound) {
                // non-critical
                fSortControlFound = ctrlNotFound;
            } else {
                return unavailableCriticalExtension;
            }
        }

        // convert the matchingRule to the internal LCID
        if (MatchingRule.value) {
            ATTRTYP mRuleTyp;
            DWORD   lcid;
            WCHAR   pString[256];         // Ought to be big enough
            ULONG len;

            // translate the input string to unicode
            if (!(len = MultiByteToWideChar(CodePage,
                                            0,
                                            (LPCSTR) MatchingRule.value, 
                                            MatchingRule.length,
                                            (LPWSTR) (pString),
                                            256))) {
                IF_DEBUG(ERR_NORMAL) {
                    DPRINT1(0,"MultiByteToWideChar failed with %d\n",GetLastError());
                }
                pControlArg->sortResult = sortInappropriateMatching;
                pControlArg->CommArg.SortType = 0;
                if (ctrlCriticalFalse == fSortControlFound) {
                    // non-critical
                    fSortControlFound = ctrlNotFound;
                } else {
                    return unavailableCriticalExtension;
                }
            }
            else if (StringToAttrTyp (pTHS, pString,len, &mRuleTyp) ||
                !AttrTypToLCID (pTHS, mRuleTyp, &lcid) ){

                IF_DEBUG(ERR_NORMAL) {
                    DPRINT1 (0, "Error finding sort OID: %s\n", MatchingRule.value);  
                }

                pControlArg->sortResult = sortInappropriateMatching;
                pControlArg->CommArg.SortType = 0;
                if (ctrlCriticalFalse == fSortControlFound) {
                    // non-critical
                    fSortControlFound = ctrlNotFound;
                } else {
                    return unavailableCriticalExtension;
                }
            }
            else {
                DWORD j;
                BOOL fFound = FALSE;
                DPRINT1 (0, "Asking for LANG 0x%x\n", lcid );

                // check to see whether we support the specified language locale
                if (gAnchor.ulNumLangs) {
                    for(j=1; j<=gAnchor.ulNumLangs; j++) {
                        if (gAnchor.pulLangs[j] == lcid) {
                            pTHS->dwLcid = lcid;
                            fFound = TRUE;
                            break;
                        }
                    }
                }

                if (!fFound) {
                    pControlArg->sortResult = sortInappropriateMatching;
                    pControlArg->CommArg.SortType = 0;
                    if (ctrlCriticalFalse == fSortControlFound) {
                        // non-critical
                        fSortControlFound = ctrlNotFound;
                    } else {
                        return unavailableCriticalExtension;
                    }
                }
            }
        }
    }
    
    if (fPagedControlFound) {
        code = LDAP_UnpackPagedBlob((PUCHAR)pageCookieVal.bv_val,
                                    pageCookieVal.bv_len,
                                    Request->m_LdapConnection,
                                    &(pControlArg->Blob),
                                    &(pControlArg->CommArg.PagedResult.pRestart));
        if (code != success ||
            ( pControlArg->CommArg.PagedResult.pRestart &&
              pControlArg->CommArg.PagedResult.pRestart->restartType != NTDS_RESTART_PAGED)) {
       
            if (ctrlCriticalTrue == fPagedControlFound) {
                return unavailableCriticalExtension;
            } else {
                fPagedControlFound = ctrlNotFound;
                pControlArg->pageRequest = FALSE;
            }
        } else {
            // They are asking for a paged search.  Set up the size limit
            pControlArg->CommArg.PagedResult.fPresent = TRUE;
        
            pControlArg->CommArg.ulSizeLimit =
                min(pControlArg->pageSize, pControlArg->CommArg.ulSizeLimit);
        }
    }
    
    if (fVLVFound) {
        //
        // If they specified a seek value then convert it to
        // dblayer format.
        //
        if (pControlArg->CommArg.VLVRequest.fseekToValue) {            
            if(LDAP_AttrValToDirAttrVal(pTHS,
                                        CodePage,
                                        NULL,                     // don't need a SVCCNTL
                                        pAC,
                                        &vlvAttVal,              // value to convert. 
                                        &(pControlArg->CommArg.VLVRequest.seekValue)))// where to put the converted value.
            {
                //
                // The conversion failed for some reason.
                //
                if (ctrlCriticalFalse == fVLVFound) {
                    // non-critical
                    fVLVFound = ctrlNotFound;
                    pControlArg->vlvRequest = FALSE;
                } else {
                    THFree(vlvAttVal.value);
                    return unavailableCriticalExtension;
                }
            }
            THFree(vlvAttVal.value);
        }
        code = LDAP_UnpackPagedBlob((PUCHAR)vlvCookieVal.bv_val,
                                    vlvCookieVal.bv_len,
                                    Request->m_LdapConnection,
                                    &(pControlArg->Blob),
                                    &(pControlArg->CommArg.VLVRequest.pVLVRestart));

        if (code != success ||
            ( pControlArg->CommArg.VLVRequest.pVLVRestart &&
              pControlArg->CommArg.VLVRequest.pVLVRestart->restartType != NTDS_RESTART_VLV)) {
            
            if (ctrlCriticalTrue == fVLVFound) {
                return unavailableCriticalExtension;
            } else {
                fVLVFound = ctrlNotFound;
                pControlArg->vlvRequest = FALSE;
            }
        } else {
            pControlArg->CommArg.VLVRequest.fPresent = TRUE;
        }
    }

    if (fASQFound) {

        // Convert the name of the attribute to do the sorting on
        // to the internal attribute type.
        if(LDAP_AttrTypeToDirAttrTyp (pTHS,
                                      CodePage,
                                      NULL,                           // don't need a SVCCNTL.
                                      &asqAttType,                    // The att to be converted.
                                      &pControlArg->CommArg.ASQRequest.attrType, // The converted att type.
                                      &pAC)) {                        // Get the attcache for later use.
            if (ctrlCriticalFalse == fASQFound) {
                // non-critical
                pControlArg->asqRequest = FALSE;
                fASQFound = ctrlNotFound;
            } else {
                pControlArg->asqResultCode = (DWORD) invalidAttributeSyntax;
                return unavailableCriticalExtension;
            }
        }
    }

    return success;
} // LDAP_ControlsToControlArg


_enum1
LDAP_SearchMessageToControlArg (
        IN  PLDAP_CONN       LdapConn,
        IN  LDAPMsg          *pMessage,
        IN  PLDAP_REQUEST    Request,
        OUT CONTROLS_ARG     *pControlArg
        )
/*++
Routine Description:
    Translate an LDAP Search Request Message into a new CONTROLS_ARG.

Arguments:
    pMessage - the LDAP Search request message
    localworld - an oss parameter (used in decoding controls)
    pControlArg - CONTROLS_ARG to fill up.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
// A typing hack
#define SEARCHREQUEST pMessage->protocolOp.u.searchRequest
    _enum1 code;
    
    //
    // Init the CONTROLS_ARG to the defaults and deal with the controls
    //

    pControlArg->CommArg.ulSizeLimit = LdapMaxPageSize;
    
    code = LDAP_ControlsToControlArg (pMessage->controls,
                                      Request,
                                      LdapConn->m_CodePage,
                                      pControlArg);
    if(code != success) {
        return code;
    }

    //
    // Deal with scope
    //

    switch (SEARCHREQUEST.scope) {
    case baseObject:
        pControlArg->Choice = SE_CHOICE_BASE_ONLY;
        break;
    case singleLevel:
        pControlArg->Choice = SE_CHOICE_IMMED_CHLDRN;
        break;
    case wholeSubtree:
        pControlArg->Choice = SE_CHOICE_WHOLE_SUBTREE;
        break;
    default:
        return other;
    }

    // Deal with derefAliases
    switch(SEARCHREQUEST.derefAliases) {
    case neverDerefAliases:
        pControlArg->CommArg.Svccntl.DerefAliasFlag = DA_NEVER;
        break;
    case derefInSearching:
        pControlArg->CommArg.Svccntl.DerefAliasFlag = DA_SEARCHING;
        break;
    case derefFindingBaseObj:
        pControlArg->CommArg.Svccntl.DerefAliasFlag = DA_BASE;
        break;
    case derefAlways:
        pControlArg->CommArg.Svccntl.DerefAliasFlag = DA_ALWAYS;
        break; 
    default:
        return other;
    }
    
    // Deal with sizeLimit
    if(SEARCHREQUEST.sizeLimit) {

        //
        // We need to know the size limit sent by the client so we can send
        // the correct response to the page search
        //

        pControlArg->SizeLimit = SEARCHREQUEST.sizeLimit;

        pControlArg->CommArg.ulSizeLimit =
            min((ULONG)SEARCHREQUEST.sizeLimit,
                pControlArg->CommArg.ulSizeLimit);

    } else {
        pControlArg->SizeLimit = (DWORD)-1;
    }

    //
    // Do we have time limits?
    //

    if(SEARCHREQUEST.timeLimit || (LdapMaxQueryDuration != -1)) {

        pControlArg->CommArg.StartTick = GetTickCount();
        if(!pControlArg->CommArg.StartTick) {
            // What rotten luck.  Current Tick was 0, but we need a non-zero
            // value for this (code later uses existance of a non-zero start
            // tick as the flag to do time limit checks).  Set it back one
            // tick, since consecutive calls to GetTickCount are monotonic
            // increasing, but don't always increment every time you call
            // (i.e. another call done soon might get 0 again, and so if we
            // had set tick count to 1, then it would look like we had run into
            // a time limit).
            pControlArg->CommArg.StartTick = 0xFFFFFFFF;
        }

        if(LdapMaxQueryDuration < SEARCHREQUEST.timeLimit ||
           0 == SEARCHREQUEST.timeLimit) {
            // The default limit is more restrictive or we simply don't have a
            // non-default time limit.
            // timeLimit is seconds, ticks are milliseconds
            pControlArg->CommArg.DeltaTick = 1000 * LdapMaxQueryDuration;
        } 
        else {
            pControlArg->CommArg.DeltaTick = 1000 * SEARCHREQUEST.timeLimit;
        }
            
    }
    else {
        pControlArg->CommArg.StartTick = 0;
        pControlArg->CommArg.DeltaTick = 0;
    }
    
    if (pControlArg->asqRequest) {
        // they are asking for an ASQ search.
        pControlArg->CommArg.ASQRequest.fPresent = TRUE;
    }

    // Go home
    return success;
} // LDAP_SearchMessageToControlArg


_enum1
LDAP_UnpackPagedBlob (
        IN  PUCHAR           pCookie,
        IN  DWORD            cbCookie,
        IN  PLDAP_CONN       pLdapConn,
        OUT PLDAP_PAGED_BLOB *ppPagedBlob,
        OUT PRESTART         *ppRestart
        )
/*++
Routine Description:
    Unpack the cookie sent in a paged or VLV request into a RESTART struct.

Arguments:
    pCookie - The cookie value passed in with the request.
    cbCookie - The length in bytes of pCookie.
    pLdapConn - This LDAP connection.
    pPagedBlob - Pointer to the paged blob if it needs to be freed later.
    ppRestart - Where to put the RESTART struct.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    PLDAP_PAGED_BLOB  pLocalPagedBlob;
    DWORD             BlobId;

   *ppPagedBlob = NULL;

    // check to see if the restarted search is stored internally or the client
    // gives us back the data
    if ( cbCookie == sizeof(DWORD) ) {

            //
            // We must be holding their cookie for them.  See if this is so.
            //
            BlobId = *(PDWORD)pCookie;
            pLocalPagedBlob = ReleasePagedBlob(pLdapConn, BlobId, FALSE);
            if ( pLocalPagedBlob == NULL ) {
                IF_DEBUG(WARNING) {
                    DPRINT(0,"Cookie taken from under us!\n");
                }
                return unavailable;
            }

            *ppPagedBlob = pLocalPagedBlob;
            *ppRestart = 
                (RESTART*)pLocalPagedBlob->Blob;
    } else  {
        // check if the cookie that the client gave us is actually the
        // one that we gave him and in addition has not been changed

        GUID *pserverGUID;
        ULONG CRC32;
        ULONG origCheckSum;

        *ppRestart = (RESTART *)pCookie;

        if (*ppRestart) {
            // this is a really bad client. it changed the size of the passed blob.
            // nop. we are not going to AV.
            if (cbCookie < (*ppRestart)->structLen) {
                    return unavailable;
            }

            origCheckSum = (*ppRestart)->CRC32;

            // Put the CRC32 value back to zero since that's the way
            // it was when the structure was checksummed.
            (*ppRestart)->CRC32 = 0;

            CRC32 = PEKCheckSum ((PBYTE)*ppRestart, (*ppRestart)->structLen);

            // oops. this is not sent by us or it has been changed
            if ((CRC32 != origCheckSum) ||
                memcmp (&gCheckSum_serverGUID, 
                        &((*ppRestart)->serverGUID), 
                        sizeof (GUID)) ) {

                    DPRINT (0, "Inadequate Buffer passed in restart\n");
                    return unavailable;
            }
        }
    }
    return success;
}


_enum1
LDAP_SubstringFilterToFilterItem (
        IN  ULONG           CodePage,
        IN  DWORD           type,
        IN  SVCCNTL*        Svccntl OPTIONAL,
        IN  ATTCACHE        *pAC,
        IN  SubstringFilter *pSubstring,
        OUT SUBSTRING       **ppSubstringFilter
        )
/*++
Routine Description:
    Translate an LDAP substring filter to a directory substring filter item.

Arguments:
    pSubstring - the LDAP substring filter structure.
    filter_item - pointer to directory filter item to fill up.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    THSTATE *pTHS=pTHStls;
    _enum1    code=success;
    SUBSTRING *pSS;                     // Newly formed DIR substring filter
    SubstringFilterList  pNextElement;
    unsigned  count = 0;
    ANYSTRINGLIST *pASL=NULL,*pASLTemp=NULL,**ppASLEnd=&pASL;


    pSS = (SUBSTRING *)THAllocEx(pTHS, sizeof(SUBSTRING));

    pSS->type = type;

    // Now, loop through the LDAP substring filter turning the values into
    // elements on the DIR filter.


    pNextElement = pSubstring->substrings;

    while(!code && pNextElement) {
        switch(pNextElement->value.choice) {
        case initial_chosen:
            // An initial substring.
            if(pSS->initialProvided) {
                // They've already given us an initial
                return other;
            }
            pSS->initialProvided = TRUE;
            // Translate the attribute value.
            code = LDAP_AttrValToDirAttrVal (
                    pTHS,
                    CodePage,
                    Svccntl,
                    pAC,
                    (AssertionValue *)&pNextElement->value.u.initial,
                    &pSS->InitialVal);

            break;
        case any_chosen:
            // a medial substring

            // allocate a new node for the list of medials.
            pASLTemp = (ANYSTRINGLIST *)THAllocEx(pTHS, sizeof(ANYSTRINGLIST));
            // Tack it onto the list of medials (order is important)
            pASLTemp->pNextAnyVal = NULL;
            *ppASLEnd = pASLTemp;
            ppASLEnd = &pASLTemp->pNextAnyVal;
            // inc the count
            count++;
            // Translate the attribute value.
            code = LDAP_AttrValToDirAttrVal (
                    pTHS,
                    CodePage,
                    Svccntl,
                    pAC,
                    (AssertionValue *)&pNextElement->value.u.any,
                    &pASLTemp->AnyVal);
            break;
        case final_chosen:
            // a final substring
            if(pSS->finalProvided) {
                // We already have an initial
                return other;
            }
            pSS->finalProvided = TRUE;
            // Translate the attribute value.
            code = LDAP_AttrValToDirAttrVal (
                    pTHS,
                    CodePage,
                    Svccntl,
                    pAC,
                    (AssertionValue *)&pNextElement->value.u.final,
                    &pSS->FinalVal);
            break;
        default:
            return other;
        }
        pNextElement = pNextElement->next;
    }

    if(!code) {
        // all went well, set it up.
        *ppSubstringFilter = pSS;
        if(count) {
            Assert(pASL);
            pSS->AnyVal.count = (USHORT)count;
            pSS->AnyVal.FirstAnyVal = *pASL;
        }
    }

    return code;
}

_enum1
LDAP_FilterToDirFilter (
        IN  THSTATE *pTHS,
        IN  ULONG  CodePage,
        IN  SVCCNTL*      Svccntl OPTIONAL,
        IN  Filter *pLDAPFilter,
        OUT FILTER **ppDirFilter
        )
/*++
Routine Description:
    Translate an LDAP filter to a directory filter.

    NOTE: when possible, the core flavored data structures refer to the same
    memory as the LDAP versions.

Arguments:
    pLDAPFilter - the LDAP filter structure.
    ppDirFilter - pointer to place to put pointer to newly created directory
                  filter.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    ATTCACHE *pAC=NULL;
    ULONG    i, ulMatchID;
    BOOL     bDoValue;
    UCHAR    *pValOrSubstr = NULL;
    UCHAR    DirChoice     = 0;
    UCHAR    choice        = 0;
    AttributeDescription *pLDAP_att    = NULL;
    
    // Translate the LDAP filter to a Dir filter.

    // be optimistic at first
    _enum1 code = success;

    Assert( ppDirFilter);

    // deal with a null filter
    if ( pLDAPFilter == 0 ) {
        *ppDirFilter = 0;
        IF_DEBUG(CONV) {
            DPRINT(0,"Null filter received.\n");
        }
        return protocolError;
    }

    // allocate space for this filter
    *ppDirFilter = (FILTER *)THAlloc(sizeof( FILTER));
    if( !*ppDirFilter ) {
        IF_DEBUG(NOMEM) {
            DPRINT(0,"Cannot allocate filter structure\n");
        }
        return other;
    }

    (*ppDirFilter)->pNextFilter = NULL;

    switch( pLDAPFilter->choice) {
    case and_chosen:
        {
            // Local variables for looping
            _setof3 pNextFilter=pLDAPFilter->u.and;
            FILTER  **ppNextDirFilter =
                &(*ppDirFilter)->FilterTypes.And.pFirstFilter;

            // Set up base info.
            (*ppDirFilter)->choice = FILTER_CHOICE_AND;
            (*ppDirFilter)->FilterTypes.And.count = 0;

            while(pNextFilter) {
                if(code = LDAP_FilterToDirFilter(
                        pTHS,
                        CodePage,
                        Svccntl,
                        &pNextFilter->value,
                        ppNextDirFilter)) {
                    break;
                }

                // Got another one..
                (*ppDirFilter)->FilterTypes.And.count++;

                // advance loop variables for next pass
                ppNextDirFilter = &(*ppNextDirFilter)->pNextFilter;
                pNextFilter = pNextFilter->next;
            }
        }
        break;

    case or_chosen:
        {
            // Local variables for looping
            _setof4 pNextFilter=pLDAPFilter->u.or;
            FILTER  **ppNextDirFilter =
                &(*ppDirFilter)->FilterTypes.Or.pFirstFilter;

            // Set up base info.
            (*ppDirFilter)->choice = FILTER_CHOICE_OR;
            (*ppDirFilter)->FilterTypes.Or.count = 0;

            while(pNextFilter) {
                if(code = LDAP_FilterToDirFilter(
                        pTHS,
                        CodePage,
                        Svccntl,
                        &pNextFilter->value,
                        ppNextDirFilter)) {
                    break;
                }

                // Got another one..
                (*ppDirFilter)->FilterTypes.Or.count++;

                // advance loop variables for next pass
                ppNextDirFilter = &(*ppNextDirFilter)->pNextFilter;
                pNextFilter = pNextFilter->next;
            }
        }
        break;

    case not_chosen:

        (*ppDirFilter)->choice = FILTER_CHOICE_NOT;
        // there is exactly one nested filter.

        code = LDAP_FilterToDirFilter(pTHS, 
                                      CodePage, 
                                      Svccntl,
                                      pLDAPFilter->u.not,
                                      &(*ppDirFilter)->FilterTypes.pNot );
        break;

    case equalityMatch_chosen:
        
        pLDAP_att    = &pLDAPFilter->u.equalityMatch.attributeDesc;
        pValOrSubstr = (PUCHAR)&pLDAPFilter->u.equalityMatch.assertionValue;
        DirChoice    = FI_CHOICE_EQUALITY;
        
        break;

    case substrings_chosen:

        pLDAP_att    = &pLDAPFilter->u.substrings.type;
        pValOrSubstr = (PUCHAR)&pLDAPFilter->u.substrings;
        DirChoice    = FI_CHOICE_SUBSTRING;

        break;

    case greaterOrEqual_chosen:

        pLDAP_att    = &pLDAPFilter->u.lessOrEqual.attributeDesc;
        pValOrSubstr = (PUCHAR)&pLDAPFilter->u.lessOrEqual.assertionValue;
        DirChoice    = FI_CHOICE_GREATER_OR_EQ;
        
        break;

    case lessOrEqual_chosen:

        pLDAP_att    = &pLDAPFilter->u.lessOrEqual.attributeDesc;
        pValOrSubstr = (PUCHAR)&pLDAPFilter->u.lessOrEqual.assertionValue;
        DirChoice    = FI_CHOICE_LESS_OR_EQ;

        break;

    case present_chosen:

        pLDAP_att    = &pLDAPFilter->u.present;
        DirChoice    = FI_CHOICE_PRESENT;

        break;

    case approxMatch_chosen:

        pLDAP_att    = &pLDAPFilter->u.approxMatch.attributeDesc;
        pValOrSubstr = (PUCHAR)&pLDAPFilter->u.approxMatch.assertionValue;
        DirChoice    = FI_CHOICE_EQUALITY;

        break;

    case extensibleMatch_chosen:

        // Assume an item filter.
        (*ppDirFilter)->choice = FILTER_CHOICE_ITEM;
        bDoValue = FALSE;

        // Find out what match rule to use.  We only support matching where the
        // type is supplied.
        if(pLDAPFilter->u.extensibleMatch.bit_mask & type_present) {
            if(pLDAPFilter->u.extensibleMatch.bit_mask & matchingRule_present) {
                // Look up the matching rule.
                ulMatchID = MATCH_UNKNOWN;
                for(i=0;i<NUM_KNOWNMATCHINGRULES;i++) {
                    if(EQUAL_LDAP_STRINGS(
                            (pLDAPFilter->u.extensibleMatch.matchingRule),
                            (KnownMatchingRules[i]))) {
                        ulMatchID = i;
                        break;
                    }
                }
                switch(ulMatchID) {
                case MATCH_BIT_AND:
                    choice = FI_CHOICE_BIT_AND;
                    bDoValue = TRUE;
                    break;
                    
                case MATCH_BIT_OR:
                    choice = FI_CHOICE_BIT_OR;
                    bDoValue = TRUE;
                    break;
                    
                case MATCH_UNKNOWN:
                default:
                    // We don't do the matchingrule they asked for
                    break;
                }
            }
            else {
                // No matching rule, so this is interpreted as an equality
                // filter. Set the filter and filter item types.
                (*ppDirFilter)->FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
                bDoValue = TRUE;
            }
        }

        if(bDoValue) {

            pLDAP_att    = &pLDAPFilter->u.extensibleMatch.type;
            pValOrSubstr = (PUCHAR)&pLDAPFilter->u.extensibleMatch.matchValue;
            DirChoice    = choice;

        } else {
            // Couldn't map this to a filter, so turn this into a UNDEFINED fitler.
            (*ppDirFilter)->FilterTypes.Item.choice = FI_CHOICE_UNDEFINED;
            code = success;
        }
        break;
    default:
        code = other;
    }

    // 
    // Do we need a filter item?
    //
    if (pLDAP_att) {
        code = LDAP_FilterItemToDirFilterItem (
                                pTHS,
                                CodePage,
                                Svccntl,
                                DirChoice,
                                pLDAP_att,
                                pValOrSubstr, 
                                ppDirFilter,
                                NULL
                                );
    }

    if( code  ) {
        *ppDirFilter = 0;
    }

    return code;
}


_enum1
LDAP_FilterItemToDirFilterItem (
        IN  THSTATE        *pTHS,
        IN  ULONG          CodePage,
        IN  SVCCNTL        *Svccntl OPTIONAL,
        IN  UCHAR          Choice,
        IN  AttributeType  *pLDAP_att,
        IN  UCHAR          *pValOrSubstr,
        IN OUT FILTER         **ppDirFilter,
        OUT ATTCACHE       **ppAC         // OPTIONAL
        )
/*++
Routine Description:
    Translate an LDAP AttributeValueAssertion into a directory filter item.
    Also, give back the pointer to the attcache for the attribute type if they
    asked for it.

Arguments:
    Svccntl - if present, requires us to check whether this is a GC port
        request so we can filter out the non-GC partial attributes
    Choice - indicates what kind of filter item this should be.
    pLDAP_att - pointer to the LDAP attribute type.
    pValOrSubstr - pointer to either an AssertionValue or a SubstringFilter 
        depending on the value of Choice.
    ppDirFilter - Where to put the finished filter item.
    ppAC - pointer to place to put pointer to the attcache.  This out param will
        always be filled in if the attrtype can be looked up.  If this the funtion
        returns an error and *ppAC is not NULL then the attribute asked
        for is a GC only attribute.  Ignored if NULL.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    DWORD  chopAt = 0;
    DWORD  i;
    AssertionValue  *pLDAP_val = NULL;
    SubstringFilter *pLDAP_substr = NULL;
    ATTRTYP  type = 0, *pType = NULL;
    ATTCACHE  *pAC = NULL;
    _enum1          code;

    if (Choice == FI_CHOICE_PRESENT) {
        pType = &(*ppDirFilter)->FilterTypes.Item.FilTypes.present;
    } else if (Choice == FI_CHOICE_SUBSTRING) {
        pLDAP_substr = (SubstringFilter *)pValOrSubstr;
        pType = &type;
    } else {
        pLDAP_val = (AssertionValue *)pValOrSubstr;
        pType = &(*ppDirFilter)->FilterTypes.Item.FilTypes.ava.type;
    }


    Assert(NULL != *ppDirFilter);

    // Start by scanning forward through the attribute type looking for a ';'
    for(i=0;(i<pLDAP_att->length) && (pLDAP_att->value[i] != ';');i++);

    if(i < pLDAP_att->length) {
        chopAt = pLDAP_att->length;
        pLDAP_att->length = i;
    }

    // Set the filter and filter item types.
    (*ppDirFilter)->choice = FILTER_CHOICE_ITEM;
    (*ppDirFilter)->FilterTypes.Item.choice = Choice;

    // Translate the attribute type.
    if(code = LDAP_AttrTypeToDirAttrTyp (
            pTHS,
            CodePage,
            Svccntl,
            pLDAP_att,
            pType,
            &pAC)) {
        if (unwillingToPerform != code) {

            // Failed to recognize this attrtype.  Turn this into an 
            // UNDEFINED filter
            code = success;
            if (NULL == pAC && Choice != FI_CHOICE_PRESENT) {                
                (*ppDirFilter)->FilterTypes.Item.choice = FI_CHOICE_UNDEFINED;
            } else {
                // Since an ATTCACHE was returned we are on a GC asking
                // for a non-GC attr.  Revert to win2k behavior.
                (*ppDirFilter)->FilterTypes.Item.choice = FI_CHOICE_FALSE;
            }
        }
        goto exit;
    }
    
    //
    // If there were options see if they are recognized and valid.
    // Currently only the binary option is accepted in a filter.
    //
    if (chopAt) {
        pLDAP_att->length = chopAt;
        chopAt = 0;
        if (code = LDAP_DecodeAttrDescriptionOptions(
                            pTHS,
                            CodePage,
                            Svccntl,
                            pLDAP_att,
                            NULL,
                            pAC,
                            ATT_OPT_BINARY,
                            NULL,
                            NULL,
                            NULL
                            )) {
            // Got an unrecognized option
            if (Choice == FI_CHOICE_PRESENT) {
                // Unrecognized attr on a presence test results in a false filter.
                (*ppDirFilter)->FilterTypes.Item.choice = FI_CHOICE_FALSE;
            } else {
                // Ignore the attribute.
                (*ppDirFilter)->FilterTypes.Item.choice = FI_CHOICE_UNDEFINED;
            }
            goto exit;
        }
    }

    if ((pAC->id == ATT_OBJECT_CATEGORY) && (Choice == FI_CHOICE_EQUALITY)) {
        //
        // We intercept object categories and if this is not a DN, then
        // we try to create one.
        //

        ATTRTYP typ;
        CLASSCACHE* pCC;

        if (LDAP_AttrTypeToDirClassTyp(
                pTHS,
                CodePage,
                (LDAPDN*)pLDAP_val, 
                &typ,
                &pCC) == success) {

            DSNAME *tmpDSName;

            //
            // We need to copy the default object category
            //

            tmpDSName = (DSNAME*)THAlloc(pCC->pDefaultObjCategory->structLen);
            if ( tmpDSName == NULL ) {
                IF_DEBUG(NOMEM) {
                    DPRINT(0,"Cannot allocate DSNAME\n");
                }
                return other;
            }

            CopyMemory(tmpDSName, 
                       pCC->pDefaultObjCategory, 
                       pCC->pDefaultObjCategory->structLen);
            (*ppDirFilter)->FilterTypes.Item.FilTypes.ava.Value.pVal = 
                    (PUCHAR)tmpDSName;
            (*ppDirFilter)->FilterTypes.Item.FilTypes.ava.Value.valLen = 
                    tmpDSName->structLen;

            code = success;
            goto exit;
        }
    }
    
    //
    // We're done if this is a presence test.
    //
    if (Choice != FI_CHOICE_PRESENT) {

        //
        // FROM RFC2251
        //
        // If . . . the assertion value cannot be parsed . . . then the 
        // filter is Undefined . . .
        // Servers MUST NOT return errors if attribute descriptions or matching
        // rule ids are not recognized, or assertion values cannot be parsed.
        //
        if (Choice != FI_CHOICE_SUBSTRING) {
            // Translate the attribute value.
            code = LDAP_AttrValToDirAttrVal (
                pTHS,
                CodePage,
                Svccntl,
                pAC,
                pLDAP_val,
                &(*ppDirFilter)->FilterTypes.Item.FilTypes.ava.Value);
            if (success != code) {
                if (FI_CHOICE_EQUALITY == Choice) {
                    // Right hand side in a filter not existant.  The value supplied
                    // could not possibly equal a value of the attribute therefore
                    // turn this into a FALSE filter.
                    (*ppDirFilter)->FilterTypes.Item.choice = FI_CHOICE_FALSE;
                } else {
                    (*ppDirFilter)->FilterTypes.Item.choice = FI_CHOICE_UNDEFINED;
                }
                code = success;
            }
        } else {
            code = LDAP_SubstringFilterToFilterItem(
                CodePage,
                type,
                Svccntl,
                pAC,
                pLDAP_substr,
                &(*ppDirFilter)->FilterTypes.Item.FilTypes.pSubstring);
            if (success != code) {
                (*ppDirFilter)->FilterTypes.Item.choice = FI_CHOICE_UNDEFINED;
                code = success;
            }
        }
    }

exit:

    if (ppAC) {
        *ppAC = pAC;
    }
    return code;
}


_enum1
LDAP_SearchRequestToEntInfSel (
        IN  THSTATE           *pTHS,
        IN  ULONG             CodePage,
        IN  SearchRequest     *pSearchRequest,
        IN  CONTROLS_ARG      *pControlArg,
        OUT ATTFLAG           **ppFlags,
        OUT RANGEINFSEL       *pSelectionRange,
        OUT ENTINFSEL         **ppEntInfSel
        )
/*++
Routine Description:
    Translate an LDAP SearchRequest into into an entinfsel.  Allocate the
    entinfsel here.

Arguments:
    pSearchRequest - the original search request for this search
    ppEntinfsel - pointer to place to put pointer to new entinfsel
    
Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    ATTFLAG                  *pFlags=NULL;
    RANGEINFOITEM            *pRange=NULL;
    _enum1                   code;
    unsigned                 count=0,i = 0,flagsIndex;
    AttributeDescriptionList pAttributes = pSearchRequest->attributes;
    AttributeDescriptionList pAttributesTemp;
    ENTINFSEL                *pEntInfSel=((ENTINFSEL *)
                                          THAllocEx(pTHS, sizeof(ENTINFSEL)));
    BOOL                     fNeedSD = FALSE;
    BOOL                     fAllAtts = FALSE;

    pSelectionRange->valueLimit = DEFAULT_VALUE_LIMIT;
    pSelectionRange->count = 0;
    pSelectionRange->pRanges = NULL;
    
    // Do they want just the types or the types and the values.
    pEntInfSel->infoTypes = (pSearchRequest->typesOnly?
                         EN_INFOTYPES_TYPES_ONLY: EN_INFOTYPES_TYPES_VALS);

    // Set up the return value.
    *ppEntInfSel = pEntInfSel;

    if(!pAttributes) {
        // Null attribute list.  Assume that means they want everything.
        fAllAtts = TRUE;
        *ppFlags = NULL;

        // Note that "everything" to the core DS does not include the Security
        // Descriptor. As a convenience to callers, if they ask for everything
        // via a null selection list AND they have specified sd flags (which we
        // notice via the control arg), then we go ahead and explicitly tell the
        // core to return the SD to us.
        if ( pControlArg->sdRequest ) {
            pEntInfSel->AttrTypBlock.pAttr =
                (ATTR *)THAllocEx(pTHS, sizeof(ATTR));
            // Mark that we need to explicitly add the SD into the selection
            // list. 
            fNeedSD = TRUE;
        }
        else {
            fNeedSD = FALSE;
        }
        goto exit_success;
    }

    // Non-null attribute list, so this has an explicit list of attributes to
    // deal with (although it might also have a "*", which means all
    // attributes.)

    // Count the number of attributes.
    pAttributesTemp = pAttributes;
    while(pAttributesTemp) {
        count++;
        pAttributesTemp = pAttributesTemp->next;
    }

    if ( pControlArg->sdRequest ) {
        //
        // If the security descriptor control was specified, we might need to
        // add ntSecurityDescriptor to the list.  We will only need to add it if
        // we come across a "*" in the input list (which would imply that they
        // are asking for all attributes + some explicit list) AND we don't come
        // across an explicit request for the SD attribute.
        //
        count++;
        fNeedSD = TRUE;
    }
    else {
        // We will definitely NOT need to add in a request for the SD
        // attribute. 
        fNeedSD = FALSE;
    }
    
    // They just want a selected list.
    pEntInfSel->attSel = EN_ATTSET_LIST;

    pEntInfSel->AttrTypBlock.pAttr =
        (ATTR *)THAllocEx(pTHS, count*sizeof(ATTR));
    pFlags = (ATTFLAG *)THAllocEx(pTHS, (count + 1) * sizeof(ATTFLAG));
    pSelectionRange->pRanges =
        (RANGEINFOITEM *)THAllocEx(pTHS, (count + 1) * sizeof(RANGEINFOITEM));
    
    for(flagsIndex=0;pAttributes;pAttributes=pAttributes->next) {

        // Translate the LDAP attribute list to a entinfsel
        // convert pAttributes->value to an attrtyp

        // Note that even if they specified "*" (i.e. lookup all attributes), we
        // still need to parse to see if they specified an unknown attribute.

        code = LDAP_AttrDescriptionToDirAttrTyp (
                pTHS,
                CodePage,
                &pControlArg->CommArg.Svccntl,
                &(pAttributes->value),
                ATT_OPT_ALL,
                &(pEntInfSel->AttrTypBlock.pAttr[i].attrTyp),
                &pFlags[flagsIndex],
                pSelectionRange,
                NULL);
        if(pFlags[flagsIndex].flag) {
            flagsIndex++;
        }

        // request.
        if(code) {
            if(pAttributes->value.length==1 &&
               pAttributes->value.value[0]=='*') {
                // They are asking for all normal attributes, regardless of
                // anything else.  Unfortunately, we cant skip parsing because
                // they might be looking for attributes that are only returned
                // if expressly asked for (ie dblayer constructed atts, NT
                // Security Descriptor, ReplPropertyMetaData, etc.)
                fAllAtts = TRUE;
                code = success;
            }
            else {
                
#ifdef NEVER
                // for now (maybe forever) we are not going to complain if they
                // specified an attribute we didn't understand.  Skip this code
                
                // Couldn't find the attribute,something lost in the
                // translation
                return code;
#else
                if (unwillingToPerform == code) {
                    return code;
                }
                else { 
                    // Yeah, whatever.  Just blow off the error.
                    code = success;
                }
#endif
                
            }
        }           
        else {
            // Normally found attribute, it's in the list.  However, if this is
            // the ATT_NT_SECURITY_DESCRIPTOR, we know that we won't have to add
            // it to the list, it's already there.
            if(pEntInfSel->AttrTypBlock.pAttr[i].attrTyp ==
               ATT_NT_SECURITY_DESCRIPTOR) {
                fNeedSD = FALSE;
            }
            i++;
        }
    }

    if(flagsIndex) {
        pFlags[flagsIndex].type = (ULONG) -1; // An end marker
        *ppFlags = pFlags;
    }
    else {
        // No flags
        *ppFlags = NULL;
        THFreeEx(pTHS, pFlags);
    }

    if(!pSelectionRange->count) {
        THFreeEx(pTHS, pSelectionRange->pRanges);
        pSelectionRange->pRanges = NULL;
    }
    else {
        pSelectionRange->pRanges = (RANGEINFOITEM *)
            THReAllocEx(pTHS, pSelectionRange->pRanges,
                        pSelectionRange->count * sizeof(RANGEINFOITEM));
    }

exit_success:

    if(!fAllAtts) {
        // Ok, normal entinfsel
        pEntInfSel->AttrTypBlock.attrCount = i;

    } else {
        if(fNeedSD) {
            // We have been asked for all attributes, and through other means
            // have determined that we need to explicitly add the SD att to the
            // list.  Do so here.
            pEntInfSel->AttrTypBlock.pAttr[i].attrTyp =
                ATT_NT_SECURITY_DESCRIPTOR;
            i++;
        }


        // They specified some combination of "*" and valid attributes.  
        // Set the entinfsel appropriately.

        if ( i == 0 ) {

            if ( pEntInfSel->AttrTypBlock.pAttr != NULL ) {
                THFreeEx(pTHS, pEntInfSel->AttrTypBlock.pAttr);
            }
            pEntInfSel->attSel = EN_ATTSET_ALL;
            pEntInfSel->AttrTypBlock.attrCount = 0;
            pEntInfSel->AttrTypBlock.pAttr = NULL;

        } else {

            //
            // someone specified '*' + normal attributes
            //

            pEntInfSel->attSel = EN_ATTSET_ALL_WITH_LIST;
            pEntInfSel->AttrTypBlock.attrCount = i;
        }
    }
    // Go home

    return success;
} // LDAP_SearchRequestToEntInfSel

_enum1
LDAP_EntinfToSearchResultEntry (
        IN  THSTATE           *pTHS,
        IN  ULONG             CodePage,
        IN  ENTINF            *pEntinf,
        IN  RANGEINF          *pRangeInf,
        IN  ATTFLAG           *pFlags,
        IN  CONTROLS_ARG      *pControlArg,
        OUT SearchResultEntry *pEntry
        )
/*++
Routine Description:
    Translate a directory Entinf to an LDAP SearchResultEntry.

Arguments:
    pEntinf - the directory entinf.
    pRangeInf - the directory range information.  May be NULL.
    pControlArg - common arguments for this translation
    pEntry - pointer to the SearchResultEntry to fill up.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    _enum1 code;
    
    code = LDAP_DSNameToLDAPDN(
            CodePage,
            pEntinf->pName,
            pControlArg->extendedDN,
            &pEntry->objectName);
    if(code) {
        return code;
    }

    // Translate the attributes in the Entinf.
    code = LDAP_AttrBlockToPartialAttributeList (
            pTHS,
            CodePage,
            &pEntinf->AttrBlock,
            pRangeInf,
            pFlags,
            pEntinf->pName,
            pControlArg,
            ((pEntinf->ulFlags & ENTINF_FROM_MASTER) != 0),
            &pEntry->attributes);

    return code;
}

_enum1
LDAP_AddValinfAsAttr (
        IN  THSTATE           *pTHS,
        IN  ULONG             CodePage,
        IN  REPLVALINF        *pValinf,
        IN  DWORD             valCount,
        IN  RANGEINF          *pRangeInf,
        IN  ATTFLAG           *pFlags,
        IN  CONTROLS_ARG      *pControlArg,
        OUT SearchResultEntry *pEntry
        )
/*++
Routine Description:
    Translate a directory Valinf to an LDAP SearchResultEntry.

Arguments:
    pTHS - thread state
    CodePage - internationalization
    pValinf - the directory valinf.
    pRangeInf - the directory range information.  May be NULL.
    pControlArg - common arguments for this translation
    ppAttribute - New list allocated

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    _enum1 code;
    ULONG cbReturned, i;
    ATTRBLOCK attrBlock;
    ATTR attr;
    ATTRVAL *pAVal;
    ATTFLAG rgFlags[1];
    RANGEINF rangeInf;
    RANGEINFOITEM rangeInfoItem;
    PartialAttributeList_ *pAttribute;

    Assert( pValinf && valCount );

    // Fake up a range specification to express whether the value is present
    // One flag for each attribute
    rgFlags[0].type = pValinf->attrTyp;
    rgFlags[0].flag = ATT_OPT_RANGE;

    rangeInf.count = 1;
    rangeInf.pRanges = &rangeInfoItem;
    rangeInfoItem.AttId = pValinf->attrTyp;
    if (pValinf->fIsPresent) {
        rangeInfoItem.lower = 1;
        rangeInfoItem.upper = 1;
    } else {
        rangeInfoItem.lower = 0;
        rangeInfoItem.upper = 0;
    }

    pAVal = (ATTRVAL *) THAllocEx( pTHS, valCount * sizeof( ATTRVAL ) );

    // Make up a fake attrblock
    // One attribute, containing n values
    attrBlock.attrCount = 1;
    attrBlock.pAttr = &attr;
    attr.attrTyp = pValinf->attrTyp;
    attr.AttrVal.valCount = valCount;
    attr.AttrVal.pAVal = pAVal;
    for( i = 0; i < valCount; i++ ) {
        memcpy( &(pAVal[i]), &( (pValinf++)->Aval), sizeof( ATTRVAL ) );
    }

    // pValInf now points beyond the last value

    // Translate the attributes in the Entinf.
    code = LDAP_AttrBlockToPartialAttributeList (
            pTHS,
            CodePage,
            &attrBlock,
            &rangeInf,
            rgFlags,
            NULL, // pDSName, not used
            pControlArg,
            1,
            &pAttribute );

    if ((!code) && pAttribute) {
        // Set up pointer to next attribute in chain.
        Assert( pAttribute->next == NULL );
        pAttribute->next = pEntry->attributes;
        pEntry->attributes = pAttribute;
    }

    THFreeEx( pTHS, pAVal );

    return code;
}
    

// This routine enquotes DNs as required for URLs in RFC 1738.  Note that you
// cannot pass a whole URL in here, because we'd quote the characters needed
// to make the URL work.  Instead, pass only the DN (or any other string
// that must be embedded in a URL in a way that does not affect the URL).
// May free and reallocate the buffer in the string, so that string MUST 
// be THAlloced all by itself
_enum1
LDAP_LDAPStringToURL(
        LDAPString *pString)
{
    _enum1 code = success;
    unsigned index, numChars;
    
    
    // As a tiny sop to efficiency, hard code the characters in a switch
    // so that the compiler can optimize based on the fixed values.

    for(numChars=0, index=0;index<pString->length;index++) {
        switch (pString->value[index]) {
          case '`':
          case ' ':
          case '%':
          case '/':
          case '?':
          case '"':
          case '[':
          case ']':
          case '{':
          case '}':
          case '|':
          case '^':
          case '~':
          case '<':
          case '>':
            numChars++;
            break;

          default:
            ;
        }
    }
    
    if(numChars) {
        // OK, there were some funky chars.  Allocate more room.
        PUCHAR pTemp = (PUCHAR)THAlloc(pString->length + numChars*2);
        if(!pTemp) {
            // Out of memory!
            return other;
        }
        index = pString->length - 1;
        pString->length += numChars*2;
        while(numChars) {
            switch (pString->value[index]) {
              case '`':
                pTemp[index + 2*numChars    ] = '0';
                pTemp[index + 2*numChars - 1] = '6';
                pTemp[index + 2*numChars - 2] = '%';
                numChars--;
                break;
              case ' ':
                pTemp[index + 2*numChars    ] = '0';
                pTemp[index + 2*numChars - 1] = '2';
                pTemp[index + 2*numChars - 2] = '%';
                numChars--;
                break;
              case '%':
                pTemp[index + 2*numChars    ] = '5';
                pTemp[index + 2*numChars - 1] = '2';
                pTemp[index + 2*numChars - 2] = '%';
                numChars--;
                break;
              case '/':
                pTemp[index + 2*numChars    ] = 'F';
                pTemp[index + 2*numChars - 1] = '2';
                pTemp[index + 2*numChars - 2] = '%';
                numChars--;
                break;
              case '?':
                pTemp[index + 2*numChars    ] = 'F';
                pTemp[index + 2*numChars - 1] = '3';
                pTemp[index + 2*numChars - 2] = '%';
                numChars--;
                break;
              case '"':
                pTemp[index + 2*numChars    ] = '2';
                pTemp[index + 2*numChars - 1] = '2';
                pTemp[index + 2*numChars - 2] = '%';
                numChars--;
                break;
              case '[':
                pTemp[index + 2*numChars    ] = 'B';
                pTemp[index + 2*numChars - 1] = '5';
                pTemp[index + 2*numChars - 2] = '%';
                numChars--;
                break;
              case ']':
                pTemp[index + 2*numChars    ] = 'D';
                pTemp[index + 2*numChars - 1] = '5';
                pTemp[index + 2*numChars - 2] = '%';
                numChars--;
                break;
              case '{':
                pTemp[index + 2*numChars    ] = 'B';
                pTemp[index + 2*numChars - 1] = '7';
                pTemp[index + 2*numChars - 2] = '%';
                numChars--;
                break;
              case '}':
                pTemp[index + 2*numChars    ] = 'D';
                pTemp[index + 2*numChars - 1] = '7';
                pTemp[index + 2*numChars - 2] = '%';
                numChars--;
                break;
              case '|':
                pTemp[index + 2*numChars    ] = 'C';
                pTemp[index + 2*numChars - 1] = '7';
                pTemp[index + 2*numChars - 2] = '%';
                numChars--;
                break;
              case '^':
                pTemp[index + 2*numChars    ] = 'E';
                pTemp[index + 2*numChars - 1] = '5';
                pTemp[index + 2*numChars - 2] = '%';
                numChars--;
                break;
              case '~':
                pTemp[index + 2*numChars    ] = 'E';
                pTemp[index + 2*numChars - 1] = '7';
                pTemp[index + 2*numChars - 2] = '%';
                numChars--;
                break;
              case '<':
                pTemp[index + 2*numChars    ] = 'C';
                pTemp[index + 2*numChars - 1] = '3';
                pTemp[index + 2*numChars - 2] = '%';
                numChars--;
                break;
              case '>':
                pTemp[index + 2*numChars    ] = 'E';
                pTemp[index + 2*numChars - 1] = '3';
                pTemp[index + 2*numChars - 2] = '%';
                numChars--;
                break;

              default:
                // Not special, just copy it.
                pTemp[index + 2*numChars] = pString->value[index];
                break;
            }
            index--;
        }
        if(index) {
            memcpy(pTemp,pString->value,index+1);
        }
        THFree(pString->value);
        pString->value = pTemp;
    }

    return code;
}

_enum1
LDAP_ValueToStringValue(IN THSTATE        *pTHS,
                        IN ULONG           CodePage,
                        IN ATTRVAL        *pAttrVal,
                        IN ATTCACHE       *pAC,
                        IN PCONTROLS_ARG  pControlArg,
                        IN OUT unsigned   *pcbAlloc,
                        IN OUT LDAPString *StringFilter)
//
// This routine appends a single attribute value to an output string,
// reallocating the output string if necessary.
//
// Arguments:
//    CodePage       - desired output code page
//    pAttrVal       - the value to be converted
//    pAC            - the attribute
//    pcbAlloc       - pointer to the current allocated size of the buffer
//    StringFilter->value  - address of buffer to fill in
//    StringFilter->length - current working offset in buffer
{
    _enum1 code = success;
    AssertionValue AV;

    // Use an existing translation routine
    code = LDAP_DirAttrValToAttrVal(pTHS,
                                    CodePage,
                                    pAC,
                                    pAttrVal,
                                    0,      // No flags
                                    pControlArg,
                                    &AV);
    if (code) {
        return code;
    }

    // make sure our output buffer is big enough
    if (StringFilter->length + AV.length >= *pcbAlloc) {
        *pcbAlloc = max( *pcbAlloc * 2,
                        StringFilter->length + AV.length);
        StringFilter->value = (UCHAR*)THReAllocEx(pTHS, StringFilter->value,
                                                  *pcbAlloc);
    }

    // and copy the value in.
    memcpy(&(StringFilter->value[StringFilter->length]),
           AV.value,
           AV.length);
    StringFilter->length += AV.length;
    Assert(StringFilter->length <= *pcbAlloc);

    THFreeEx(pTHS, AV.value);

    return code;
}

_enum1
LDAP_FilterItemToLDAPStringFilterItem(IN THSTATE       *pTHS,
                                      IN ULONG          CodePage,
                                      IN FILITEM       *pItem,
                                      IN PCONTROLS_ARG pControlArg,
                                      IN OUT unsigned  *pcbAlloc,
                                      IN OUT LDAPString*StringFilter)
//
// This routine appends a single Filter item to an output string,
// reallocating the output string if necessary.
//
// Arguments:
//    CodePage       - desired output code page
//    pItem          - the filter item to be converted
//    pcbAlloc       - pointer to the current allocated size of the buffer
//    StringFilter->value  - address of buffer to fill in
//    StringFilter->length - current working offset in buffer
{
    _enum1 code = success;
    ATTCACHE *pAC;
    SUBSTRING *pSub;
    ANYSTRINGLIST *pAny;

    if (pItem->choice != FI_CHOICE_SUBSTRING) {
        if (!(pAC = SCGetAttById(pTHS, pItem->FilTypes.ava.type))) {
            IF_DEBUG(CONV) {
                DPRINT1(0,"SCGetAttById[%x] failed\n",pItem->FilTypes.ava.type);
            }
            return other;
        }
    }
    else {
        if (!(pAC = SCGetAttById(pTHS, pItem->FilTypes.pSubstring->type))) {
            IF_DEBUG(CONV) {
                DPRINT1(0,"SCGetAttById[%x] failed\n",pItem->FilTypes.pSubstring->type);
            }
            return other;
        }
    }

    if (StringFilter->length + 2  + pAC->nameLen >= *pcbAlloc) {
        *pcbAlloc *= 2;
        StringFilter->value = (UCHAR*)THReAllocEx(pTHS, StringFilter->value,
                                                  *pcbAlloc);
    }

    memcpy(&(StringFilter->value[StringFilter->length]),
           pAC->name,
           pAC->nameLen);
    StringFilter->length += pAC->nameLen;

    switch (pItem->choice) {
      case FI_CHOICE_EQUALITY:
        StringFilter->value[StringFilter->length++] = '=';
        code = LDAP_ValueToStringValue(pTHS,
                                       CodePage,
                                       &pItem->FilTypes.ava.Value,
                                       pAC,
                                       pControlArg,
                                       pcbAlloc,
                                       StringFilter);
        break;

      case FI_CHOICE_GREATER_OR_EQ:
        StringFilter->value[StringFilter->length++] = '>';
        StringFilter->value[StringFilter->length++] = '=';
        code = LDAP_ValueToStringValue(pTHS,
                                       CodePage,
                                       &pItem->FilTypes.ava.Value,
                                       pAC,
                                       pControlArg,
                                       pcbAlloc,
                                       StringFilter);
        break;

      case FI_CHOICE_LESS_OR_EQ:
        StringFilter->value[StringFilter->length++] = '<';
        StringFilter->value[StringFilter->length++] = '=';
        code = LDAP_ValueToStringValue(pTHS,
                                       CodePage,
                                       &pItem->FilTypes.ava.Value,
                                       pAC,
                                       pControlArg,
                                       pcbAlloc,
                                       StringFilter);
        break;

      case FI_CHOICE_PRESENT:
        StringFilter->value[StringFilter->length++] = '=';
        StringFilter->value[StringFilter->length++] = '*';
        break;

      case FI_CHOICE_SUBSTRING:
        StringFilter->value[StringFilter->length++] = '=';
        pSub = pItem->FilTypes.pSubstring;
        if (pSub->initialProvided) {
            code = LDAP_ValueToStringValue(pTHS,
                                           CodePage,
                                           &pSub->InitialVal,
                                           pAC,
                                           pControlArg,
                                           pcbAlloc,
                                           StringFilter);
            if (code != success) {
                return code;
            }
        }
        if (StringFilter->length + 1 >= *pcbAlloc) {
            *pcbAlloc *= 2;
            StringFilter->value = (UCHAR*)THReAllocEx(pTHS, StringFilter->value,
                                                      *pcbAlloc);
        }
        StringFilter->value[StringFilter->length++] = '*';
        pAny = &pSub->AnyVal.FirstAnyVal;
        while (pAny) {
            code = LDAP_ValueToStringValue(pTHS,
                                           CodePage,
                                           &pAny->AnyVal,
                                           pAC,
                                           pControlArg,
                                           pcbAlloc,
                                           StringFilter);
            if (code != success) {
                return code;
            }
            if (StringFilter->length + 1 >= *pcbAlloc) {
                *pcbAlloc *= 2;
                StringFilter->value = (UCHAR*)THReAllocEx(pTHS, StringFilter->value,
                                                          *pcbAlloc);
            }
            StringFilter->value[StringFilter->length++] = '*';
            pAny = pAny->pNextAnyVal;
        }
        if (pSub->finalProvided) {
            code = LDAP_ValueToStringValue(pTHS,
                                           CodePage,
                                           &pSub->FinalVal,
                                           pAC,
                                           pControlArg,
                                           pcbAlloc,
                                           StringFilter);
            if (code != success) {
                return code;
            }
        }
        break;

      case FI_CHOICE_LESS:
      case FI_CHOICE_GREATER:
      case FI_CHOICE_NOT_EQUAL:
      case FI_CHOICE_TRUE:
      case FI_CHOICE_FALSE:
      case FI_CHOICE_UNDEFINED:
      default:
        Assert(!"Bogus value in LDAP filter?");
        // LDAP v3 is missing a bunch of filter operators (probably just
        // another of the misguided minimalizations that removed the
        // read operation).  None of the above operators are supported, you
        // have to construct them as compounds of more complicated filters.
        // For example, (foo>1) would need to be written as 
        // (&(foo>=1)(!(foo=1))).  Since we're just echoing out a filter
        // that came in from the client, perhaps with a small addition,
        // we should never encounter any of these operators that the
        // client could not have given us to begin with, hence the assert.
        code = other;
    }

    Assert(StringFilter->length <= *pcbAlloc);
    return code;
}

_enum1
LDAP_FilterToLDAPStringFilter(IN THSTATE        *pTHS,
                              IN ULONG           CodePage,
                              IN FILTER         *pDSFilter,
                              IN PCONTROLS_ARG  pControlArg,
                              IN OUT unsigned   *pcbAlloc,
                              IN OUT LDAPString *StringFilter)
/*++
  Translates a core filter object into an LDAP string-ized filter.  
  Re-allocates the string portion of the filter as necessary.

  Arguments:
    CodePage             - client code page
    pDSFilter            - Filter to translate
    pcbAlloc             - total allocated buffer amount
    StringFilter->value  - address of buffer to fill in
    StringFilter->length - current working offset in buffer
*/
{
    _enum1 code = success;
    unsigned i;
    FILTER * pFilterTemp;

    Assert(*pcbAlloc >= StringFilter->length);
    
    if (StringFilter->length + 2 >= *pcbAlloc) {
        *pcbAlloc *= 2;
        StringFilter->value = (UCHAR*)THReAllocEx(pTHS, StringFilter->value,
                                                  *pcbAlloc);
    }

    StringFilter->value[StringFilter->length++] = '(';

    switch (pDSFilter->choice) {
      case FILTER_CHOICE_AND:
        StringFilter->value[StringFilter->length++] = '&';
        pFilterTemp = pDSFilter->FilterTypes.And.pFirstFilter;
        for (i=0; 
             (code == success) && (i<pDSFilter->FilterTypes.And.count);
             i++) {
            code = LDAP_FilterToLDAPStringFilter(pTHS,
                                                 CodePage,
                                                 pFilterTemp,
                                                 pControlArg,
                                                 pcbAlloc,
                                                 StringFilter);
            pFilterTemp = pFilterTemp->pNextFilter;
        }
        break;
        
      case FILTER_CHOICE_OR:
        StringFilter->value[StringFilter->length++] = '|';
        pFilterTemp = pDSFilter->FilterTypes.Or.pFirstFilter;
        for (i=0; 
             (code == success) && (i<pDSFilter->FilterTypes.Or.count);
             i++) {
            code = LDAP_FilterToLDAPStringFilter(pTHS,
                                                 CodePage,
                                                 pFilterTemp,
                                                 pControlArg,
                                                 pcbAlloc,
                                                 StringFilter);
            pFilterTemp = pFilterTemp->pNextFilter;
        }
        break;

      case FILTER_CHOICE_NOT:
        StringFilter->value[StringFilter->length++] = '!';
        code = LDAP_FilterToLDAPStringFilter(pTHS,
                                             CodePage,
                                             pDSFilter->FilterTypes.pNot,
                                             pControlArg,
                                             pcbAlloc,
                                             StringFilter);
        break;

      case FILTER_CHOICE_ITEM:
        code = LDAP_FilterItemToLDAPStringFilterItem(pTHS,
                                                     CodePage,
                                                     &pDSFilter->FilterTypes.Item,
                                                     pControlArg,
                                                     pcbAlloc,
                                                     StringFilter);
        break;
    }

    if (success == code) {
        if (StringFilter->length + 1 >= *pcbAlloc) {
            *pcbAlloc *= 2;
            StringFilter->value = (UCHAR*)THReAllocEx(pTHS, StringFilter->value,
                                                      *pcbAlloc);
        }
        
        StringFilter->value[StringFilter->length++] = ')';
    }

    Assert(StringFilter->length <= *pcbAlloc);
    return code;
}
    


_enum1
LDAP_ContRefToReferral (
        IN  THSTATE              *pTHS,
        IN  USHORT                Version,
        IN  ULONG                 CodePage,
        IN  CONTREF               *pContRef,
        IN  PCONTROLS_ARG         pControlArg,
        OUT Referral              *ppReference
        )
/*++
Routine Description:
    Translate a directory address to an LDAP SearchResultReference.
    In the return, the Referral structure is one allocation, the value of the
    referral is another.

    The referral string we generate is as follows:

      preamble hostport "/" DN [ scope [ "?" filter ] ]

    Note that we elide various portions, such as the attributes, that
    we do not support, and that several separators are built into our
    pre-fab scope strings.

Arguments:
    pDsaAddr - the directory address.
    pName - The dsname of the target
    pReference - pointer to the SearchResultReference to fill up.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    LDAPString DN;
    const LDAPString *pScope;
    LDAPString Filter;
    Referral pReference;
    unsigned cbAddress, cbUrl;
    _enum1 code;
    DSA_ADDRESS_LIST* pDAL;
    Referral headRef = NULL;

    pDAL = pContRef->pDAL;

    while ( pDAL != NULL ) {

        if(!(pReference = ((Referral)THAlloc(sizeof(struct Referral_))))) {
            // No space.
            return other;
        }
        pReference->next = headRef;
        headRef = pReference;

        // While we work our way through processing the parts of the referral,
        // keep a running tally of how large the final string will be.
        if(Version == 2) {
            cbUrl = V2ReferralPreamble.length;
        }
        else {
            cbUrl = V3ReferralPreamble.length;
        }

        // First, see how big the hostport portion will be
        cbAddress = WideCharToMultiByte(CodePage,
                                    0,
                                    pDAL->Address.Buffer,
                                    pDAL->Address.Length/sizeof(WCHAR),
                                    NULL,
                                    0,
                                    NULL,
                                    NULL);
        if (cbAddress == 0) {
            // error occured
            IF_DEBUG(ERR_NORMAL) {
                DPRINT1(0,"MultiByteToWideChar failed with %d\n",GetLastError());
            }
            return other;
        }
        
        cbUrl += cbAddress;

        // Next, turn the DN into a LDAP dn.
        code = LDAP_DSNameToLDAPDN(
                CodePage,
                pContRef->pTarget,
                FALSE,
                &DN);
        if(code)
            return code;

        code = LDAP_LDAPStringToURL(&DN);
        if(code)
            return code;

        cbUrl += 1 + DN.length;

        // Next, find the right scope
        if (pContRef->bNewChoice) {
            switch (pContRef->choice) {
              case SE_CHOICE_BASE_ONLY:
                pScope = &ScopeBase;
                break;

              case SE_CHOICE_IMMED_CHLDRN:
                pScope = &ScopeOne;
                break;

              case SE_CHOICE_WHOLE_SUBTREE:
                pScope = &ScopeTree;
                break;
            }
        }
        else {
            pScope = &ScopeNull;
        }

        cbUrl += pScope->length;

        // Next, produce the string-ized filter
        if (pContRef->pNewFilter) {
            unsigned cbAlloc = 100;     // initial guess

            Filter.value = (PUCHAR)THAlloc(cbAlloc);
            if (Filter.value) {
                Filter.length = 0;
            }
            else {
                return other;
            }

            code = LDAP_FilterToLDAPStringFilter(pTHS,
                                                 CodePage,
                                                 pContRef->pNewFilter,
                                                 pControlArg,
                                                 &cbAlloc,
                                                 &Filter);
            if (code) {
                return code;
            }
            Assert(cbAlloc >= Filter.length);

            code = LDAP_LDAPStringToURL(&Filter);
            if (code) {
                return code;
            }

            cbUrl += 1 + Filter.length;
        }

        // Now allocate a buffer large enough to contain everything we've done
        // Add one extra byte for a null
        if(!(pReference->value.value =(PUCHAR)THAlloc(cbUrl+1))) {
            return other;
        }

        // First, the URL preamble.  From now on out cbUrl is not the total length
        // of the string but rather the index of the current character we're 
        // working on.
        cbUrl = 0;
        if(Version == 2) {
            memcpy(pReference->value.value,V2ReferralPreamble.value,
                   V2ReferralPreamble.length);
            cbUrl = V2ReferralPreamble.length;
        }
        else {
            memcpy(pReference->value.value,V3ReferralPreamble.value,
                   V3ReferralPreamble.length);
            cbUrl = V3ReferralPreamble.length;
        }
        
        // Now, the server name
        cbAddress = WideCharToMultiByte(CodePage,
                0,
                pDAL->Address.Buffer,
                pDAL->Address.Length/sizeof(WCHAR),
                (char*)&(pReference->value.value[cbUrl]),
                cbAddress,
                NULL,
                NULL);
        if (cbAddress == 0) {
            // error occured
            IF_DEBUG(ERR_NORMAL) {
                DPRINT1(0,"MultiByteToWideChar failed with %d\n",GetLastError());
            }
            return other;
        }
        
        cbUrl += cbAddress;

        // The slash separating servername and DN
        pReference->value.value[cbUrl] = '/';
        cbUrl++;

        // The DN
        memcpy(&(pReference->value.value[cbUrl]),
               DN.value,
               DN.length);
        cbUrl += DN.length;
        
        // Now the optional components
        if (pContRef->bNewChoice || pContRef->pNewFilter) {
            // if we have a filter we must always return a scope, even if it's null
            memcpy(&(pReference->value.value[cbUrl]),
                   pScope->value,
                   pScope->length);
            cbUrl += pScope->length;

            if (pContRef->pNewFilter) {
                // First the question separating the scope from the filter
                pReference->value.value[cbUrl] = '?';
                cbUrl++;
                // Now the filter itself
                memcpy(&(pReference->value.value[cbUrl]),
                       Filter.value,
                       Filter.length);
                cbUrl += Filter.length;
            }
        }

        pReference->value.length = cbUrl;
        // V2 referrals are null terminated, and it doesn't hurt if v3 referrals
        // are too.
        pReference->value.value[cbUrl] = '\0';

        *ppReference = pReference;

        // We're done with this.
        THFreeEx(pTHS, DN.value);
        pDAL = pDAL->pNextAddress;
    }

    return success;
}


_enum1
LDAP_SearchResToSearchResultFull (
        IN  THSTATE           *pTHS,
        IN  PLDAP_CONN        LdapConn,
        IN  SEARCHRES         *pSearchRes,
        IN  ATTFLAG           *pFlags,
        IN  CONTROLS_ARG      *pControlArg,
        OUT SearchResultFull_ **ppResultReturn
        )
/*++
Routine Description:
    Translate a directory SearchRes inot a linked list of LDAP SearchResultFull
    objects.

Arguments:
    pSearchRes - the directory search result.
    pControlArg - common arg structure for this search
    ppResultReturn - pointer to place to put the linked list of LDAP search
                     results.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    SearchResultFull_ *pResultReturn;
    unsigned i=0;                       // loop index
    ENTINFLIST *pEntList = &pSearchRes->FirstEntInf;
    RANGEINFLIST *pRangeList;
    RANGEINF     *pRangeInf = NULL;
    unsigned objCount;
    CONTREF *pContref = NULL;

    // How many entries in the search result full chain?
    objCount = pSearchRes->count;
    if(pSearchRes->pPartialOutcomeQualifier) {
        pContref = pSearchRes->pPartialOutcomeQualifier->pUnexploredDSAs;
        objCount += pSearchRes->pPartialOutcomeQualifier->count;
    }
    
    if(!objCount) {
        // The search result is empty.
        *ppResultReturn = NULL;
    }
    else {
        // Set up the rangeinf pointer.
        if(!pSearchRes->FirstRangeInf.pNext &&
           !pSearchRes->FirstRangeInf.RangeInf.count) {
            // OK, no range inf list is present (since there is at most one
            // element in the list and the first (constantly allocated), element
            // is empty.
            pRangeList = NULL;
            pRangeInf = NULL;
        }
        else {
            pRangeList = &pSearchRes->FirstRangeInf;
            if(pRangeList->RangeInf.count) {
                pRangeInf = &pRangeList->RangeInf;
            }
            else {
                // Keep this null if there is no range.
                pRangeInf = NULL;
            }
                
        }
            
        
        // The search result is not empty.
        // Allocate all the search results we need.
        pResultReturn =
            (SearchResultFull_ *)THAlloc(objCount * sizeof(SearchResultFull_));
        if(!pResultReturn) {
            // Out of Memory
            return other;
        }
        
        
        // Loop through the Entinfs in the directory search result, turning them
        // into their LDAP equivalent.
        for(i=0;i<pSearchRes->count;i++) {
            _enum1 code;
            
            // Set up the next pointer in this chain.
            pResultReturn[i].next = &(pResultReturn[i+1]);
            
            // Say what we are.
            pResultReturn[i].value.choice = entry_chosen;
            
            // Translate the entinf.
            code = LDAP_EntinfToSearchResultEntry(
                    pTHS,
                    LdapConn->m_CodePage,
                    &pEntList->Entinf,
                    pRangeInf,
                    pFlags,
                    pControlArg,
                    &pResultReturn[i].value.u.entry);
            if(code) {
                return code;
            }
            
            // Reset pointers for another trip through the loop.
            pEntList = pEntList->pNextEntInf;
            if(pRangeList) {
                pRangeList = pRangeList->pNext;
                if(pRangeList && pRangeList->RangeInf.count) {
                    pRangeInf = &pRangeList->RangeInf;
                }
                else {
                    // Keep this null if there is no range.
                    pRangeInf = NULL;
                }
            }
        }
        
        // Now, set up the referrals
        if(pContref) {
            unsigned j;
            _enum1 code;
            unsigned beginI = i;
            unsigned buffSize = V2POQPreamble.length;
            // We have some referrals
            for(j=0;j<pSearchRes->pPartialOutcomeQualifier->count;i++,j++) {
                Referral pRef=NULL;
                // Loop through the CONTREFs in the directory search result,
                // turning them into their LDAP equivalent.
                
                // Set up the next pointer in this chain.
                pResultReturn[i].next = &(pResultReturn[i+1]);
                
                // Say what we are.
                pResultReturn[i].value.choice = reference_chosen;
                
                // Translate the entinf.
                code = LDAP_ContRefToReferral (
                        pTHS,
                        3,                  // Always build V3 POQs
                        LdapConn->m_CodePage,
                        pContref,
                        pControlArg,
                        &pRef);
                if(code) {
                    return code;
                }
                pResultReturn[i].value.u.reference =(SearchResultReference)pRef;
                // Track how big a buff we need if this ends up being a V2
                // referral 
                buffSize += pRef->value.length + 1;
                
                // Advance pointers for another trip through the loop.
                pContref = pContref->pNextContRef;
            }
            if(LdapConn->m_Version == 2) {

                PUCHAR newBuff=NULL;
                unsigned k=0, index;
                SearchResultReference pTemp = NULL;
                
                // OK, for V2 handling, we need to compact all the references
                // down into the first reference
                
                newBuff = (PUCHAR)THAlloc(buffSize+1);
                if(!newBuff) {
                    return other;
                }
                
                // First, add the POQ preamble
                memcpy(newBuff,
                       V2POQPreamble.value,
                       V2POQPreamble.length);
                
                k = V2POQPreamble.length;
                
                // Now, add each item into the string
                
                // First one gets different handling (we don't free the
                // reference object). 
                pTemp = pResultReturn[beginI].value.u.reference;
                
                newBuff[k]=0x0A;
                k++;
                memcpy(&newBuff[k],
                       pTemp->value.value,
                       pTemp->value.length);
                k += pTemp->value.length;
                
                // We're done with this, free it, but don't free the reference
                // object. 
                THFreeEx(pTHS, pTemp->value.value);
                
                for(index = beginI + 1; index < i; index++) {
                    pTemp = pResultReturn[index].value.u.reference;
                    
                    newBuff[k] = 0x0A;
                    k++;
                    memcpy(&newBuff[k],
                           &pTemp->value.value,
                           pTemp->value.length);
                    k += pTemp->value.length;
                    
                    // We're done with these, free them
                    THFreeEx(pTHS, pTemp->value.value);
                    THFreeEx(pTHS, pTemp);
                }
                
                // Null terminate, but don't count it in the size.
                newBuff[buffSize] = '\0';
                i = beginI;
                pResultReturn[i].next = NULL;
                pResultReturn[i].value.u.reference->value.value = newBuff;
                pResultReturn[i].value.u.reference->value.length = k;
                i++;
            }
        }
        
        // Set up our end marker.
        pResultReturn[i-1].next = NULL;
        
        *ppResultReturn = pResultReturn;
    }
    
    if(pSearchRes->pPartialOutcomeQualifier) {
        
        //
        // Check to see if time or size limits were blown
        //

        switch(pSearchRes->pPartialOutcomeQualifier->problem) {
        case PA_PROBLEM_SIZE_LIMIT :

            //
            // if we hit this limit because of a size limit, not a page size
            // limit, then we are not going to continue paging.  Tweak away any
            // request for paging.
            //

            if ( pControlArg->pageRequest &&
                 (pControlArg->pageSize > pControlArg->SizeLimit) ) {
                pControlArg->pageRequest = FALSE;
            }

            return sizeLimitExceeded;
            break;
            
        case PA_PROBLEM_TIME_LIMIT:
            return timeLimitExceeded;
            break;
            
        default:
            // This is only hit for the pPartialOutcomeQualifier.  That's not
            // really an error, now is it?
            return success;
            break;
        }
    }

    
    return success;
}
_enum1
LDAP_CreateOutputControls (
        IN  THSTATE           *pTHS,
        IN  PLDAP_CONN        LdapConn,
        IN  _enum1            code,
        IN  LARGE_INTEGER     *pRequestStartTick,
        IN  SEARCHRES         *pSearchRes,
        IN  CONTROLS_ARG      *pControlArg,
        OUT  Controls         *ppControlsReturn
        )
{
    PUCHAR cookie;
    DWORD cookieLen;
    Controls pControls;

    // OK, create the controls to return
    *ppControlsReturn=NULL;

    //
    // First control we could return is the paged result control, but it is only
    // done if we are given a search result
    //
    if(pSearchRes && pControlArg->pageRequest) {
        
        //
        // Yep, they requested paged results, we have to send back some kind of
        // page result control (even if the cookie is NULL)
        //


        if((code ==  sizeLimitExceeded) ||
           (code == timeLimitExceeded)    ) {
            // return code was size of time limit exceeded.  However, we are
            // paging, so we should return a success value instead.
            code = success;
        }
            
        if(pSearchRes->PagedResult.fPresent &&
           pControlArg->pageSize) {

            if ( !LDAP_PackPagedCookie (
                pSearchRes->PagedResult.pRestart,
                LdapConn,
                pSearchRes->bSorted ? TRUE : FALSE,
                &cookie,
                &cookieLen
                )) {

                return other;
            }

            IF_DEBUG(PAGED) {
                DPRINT1(0,"Sending back cookie [size %d]\n",
                    cookieLen);
            }


        } else {

            cookie = NULL;
            cookieLen = 0;
        }

        if ( EncodePagedControl(&pControls, 
                                cookie, 
                                cookieLen) != ERROR_SUCCESS ) {
            return other;
        }

        if (NULL != cookie) {        
            THFree(cookie);
        }

        pControls->next = *ppControlsReturn;
        *ppControlsReturn = pControls;
    }

    //
    // Second control we could return is the VLV control
    //
    if (pSearchRes && pControlArg->vlvRequest) {
        //
        // Yep, they requested VLV results, we have to send back some kind of
        // VLV result control (even if the cookie is NULL)
        //

        if((code ==  sizeLimitExceeded) ||
           (code == timeLimitExceeded)    ) {
            // return code was size of time limit exceeded.  However, we are
            // doing VLV, so we should return a success value instead.
            code = success;
        }
            
        if(pSearchRes->VLVRequest.fPresent && !pSearchRes->VLVRequest.Err) {

            if ( !LDAP_PackPagedCookie (
                pSearchRes->VLVRequest.pVLVRestart,
                LdapConn,
                pSearchRes->bSorted ? TRUE : FALSE,
                &cookie,
                &cookieLen
                )) {

                return other;
            }

            IF_DEBUG(PAGED) {
                DPRINT1(0,"Sending back cookie [size %d]\n",
                    cookieLen);
            }


        } else {

            cookie = NULL;
            cookieLen = 0;
        }

        if ( EncodeVLVControl(&pControls,
                              &(pSearchRes->VLVRequest),
                              cookie, 
                              cookieLen) != ERROR_SUCCESS ) {
            return other;
        }

        if (NULL != cookie) {        
            THFree(cookie);
        }

        pControls->next = *ppControlsReturn;
        *ppControlsReturn = pControls;
    }

    //
    // Third control we could return is the ASQ control
    //
    if (pControlArg->asqRequest) {
        if ( EncodeASQControl(&pControls,
                                pSearchRes ? pSearchRes->ASQRequest.Err :
                                             pControlArg->asqResultCode) != ERROR_SUCCESS ) {
            return other;
        }

        pControls->next = *ppControlsReturn;
        *ppControlsReturn = pControls;
    }
    
    //
    // if error is referral, then we don't return the next two control responses
    //

    if ( code == referral ) {
        goto exit;
    }

    //
    // Fourth control we could return is the sorted control, but is only done if
    // we were given a search results or there was an error.
    //

    if (pControlArg->sortResult ||
         (
           pControlArg->CommArg.SortType && pSearchRes && 
            (
              pSearchRes->count || pSearchRes->SortResultCode
            )
         )
       ) {
        // A sort order was requested
        _enum1_4      sortRes;

        if (pControlArg->sortResult) {
            
            // Sorting was not done due to an error caught in the LDAP head.
            sortRes = pControlArg->sortResult;
        
        } else if(pSearchRes->bSorted) {

            // The results are sorted
            sortRes = sortSuccess;

        } else if (pSearchRes->SortResultCode) {

            // Sorting was not done due to an error caught in the DS.
            sortRes = (_enum1_4)pSearchRes->SortResultCode;

        } else {

            // Sorting was not done, and we don't know why.  This shouldn't happen.
            //
            // 392627 Need ensure sort errors are returned
            // For now, disable the assert because we are at least
            // returning an "unwilling to perform" error in the control
            // so well-behaved apps will know the results weren't sorted
            // for some reason even if the reason is unclear.
            // Assert(!"Unknown error for sort control");
            sortRes = sortUnwillingToPerform;

        }

        if ( EncodeSortControl( &pControls, sortRes ) != ERROR_SUCCESS ) {
            return other;
        }
        
        pControls->next = *ppControlsReturn;
        *ppControlsReturn = pControls;        
    }

    //
    // Fifth control we could return is the stat request control
    //
    if(pControlArg->statRequest) {
        // Stats were requested
        LARGE_INTEGER tickNow;
        BOOL bHeld = FALSE;

        memset (pControlArg->Stats, 0, sizeof (pControlArg->Stats));

        pControlArg->Stats[STAT_THREADCOUNT].Stat = STAT_THREADCOUNT;
        pControlArg->Stats[STAT_THREADCOUNT].Value = *pcLDAPActive;
        pControlArg->Stats[STAT_CALLTIME].Stat = STAT_CALLTIME;
        pControlArg->Stats[STAT_ENTRIES_RETURNED].Stat = STAT_ENTRIES_RETURNED;
        pControlArg->Stats[STAT_ENTRIES_VISITED].Stat = STAT_ENTRIES_VISITED;
        pControlArg->Stats[STAT_FILTER].Stat = STAT_FILTER;
        pControlArg->Stats[STAT_INDEXES].Stat = STAT_INDEXES;

        // track time in milliseconds
        QueryPerformanceCounter(&tickNow);
        pControlArg->Stats[STAT_CALLTIME].Value =
            (DWORD)((tickNow.QuadPart - pRequestStartTick->QuadPart)/
                    LdapFrequencyConstant.QuadPart);

        if(!CheckPrivilegeAnyClient(SE_DEBUG_PRIVILEGE, &bHeld) &&
           bHeld) {
            pControlArg->Stats[STAT_ENTRIES_RETURNED].Value = pTHS->searchLogging.SearchEntriesReturned;
            pControlArg->Stats[STAT_ENTRIES_VISITED].Value = pTHS->searchLogging.SearchEntriesVisited;
            pControlArg->Stats[STAT_FILTER].Value_str = (PUCHAR)pTHS->searchLogging.pszFilter;
            pControlArg->Stats[STAT_INDEXES].Value_str = (PUCHAR)pTHS->searchLogging.pszIndexes;
        }
        else {
            pControlArg->Stats[STAT_ENTRIES_RETURNED].Value = 0;
            pControlArg->Stats[STAT_ENTRIES_VISITED].Value = 0;
            pControlArg->Stats[STAT_FILTER].Value_str = NULL;
            pControlArg->Stats[STAT_INDEXES].Value_str = NULL;
        }
        
        if ( EncodeStatControl( &pControls, STAT_NUM_STATS,
                               pControlArg->Stats ) != ERROR_SUCCESS ) {
            return other;
        }
        
        pControls->next = *ppControlsReturn;
        *ppControlsReturn = pControls;        
    }
    
exit:
    return code;
} // LDAP_SearchResToSearchResultFull



BOOLEAN
LDAP_PackPagedCookie (
        IN OUT PRESTART pRestart,
        IN PLDAP_CONN   pLdapConn,
        IN BOOL         fForceStorageOnServer,
        OUT PUCHAR     *ppCookie,
        OUT DWORD      *pcbCookie
        )
/*++
Routine Description:
    Prepare the cookie for Paged results and VLV.  Caller must free pCookie when done.

Arguments:

    pRestart - The restart argument to prepare.
    pLdapConn - The connection this cookie should be associated with.
    fForceStorageOnServer - When TRUE, the generated cookie will be guaranteed
                            to remain on the server, and a handle to it will be
                            sent to the client.  If FALSE then the entire cookie
                            may be sent back to the client.
    ppCookie - Where to put the cookie.
    pcbCookie - Pointer to where to return the length in bytes of the cookie.

Return Values:
    TRUE if successful, FALSE otherwise.

--*/
{
    if((!fForceStorageOnServer) && (pRestart->structLen < 0x400)) {

        // cookie is less than 1K.  Just send it back.
        // add a GUID identifying ourselves and a CRC check to
        // this cookie so as to check it later
        // when the client gives us this cookie back

        memcpy( &pRestart->serverGUID, 
                &gCheckSum_serverGUID, 
                sizeof (GUID) );

        // Set this to zero for the checksum and put the real value in after.
        pRestart->CRC32 = 0;
        pRestart->CRC32 = 
                    PEKCheckSum ((PBYTE)pRestart, 
                                 pRestart->structLen);

        *ppCookie = (PUCHAR) THAlloc(pRestart->structLen);
        if (NULL == *ppCookie) {
            return FALSE;
        }
        memcpy( *ppCookie, pRestart, pRestart->structLen ); 
        *pcbCookie = pRestart->structLen;

    } else {

        //
        // We got a continuation from the core and the client cares about
        // it.
        //

        PLDAP_PAGED_BLOB pPagedBlob;


        //
        // The cookie is too large.  We'll store it for them.
        //

        pPagedBlob = AllocatePagedBlob(
                            pRestart->structLen,
                            (PCHAR)pRestart, 
                            pLdapConn
                            );

        if( pPagedBlob == NULL ) {
            return FALSE;
        }

        *ppCookie = (PUCHAR) THAlloc( sizeof(pPagedBlob->BlobId) );
        if (NULL == *ppCookie) {
            return FALSE;
        }
        memcpy( *ppCookie, &(pPagedBlob->BlobId), sizeof(pPagedBlob->BlobId) );
        *pcbCookie = sizeof(pPagedBlob->BlobId);
    }

    return TRUE;
}


_enum1
LDAP_PackReplControl (
        IN  THSTATE *pTHS,
        IN  DRS_MSG_GETCHGREPLY_NATIVE *pReplicaMsg,
        OUT ReplicationSearchControlValue  *pReplCtrl  
        )
/*++
Routine Description:
    Prepare the cookie for ReplicationControlValue

Arguments:

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    UPTODATE_VECTOR *pUtdvecV1;
    DWORD cbVecSize = 0;
    PUCHAR p;

    pReplCtrl->flag = (UINT)(pReplicaMsg->fMoreData);
    pReplCtrl->size = 0;
    pReplCtrl->cookie.length = MIN_REPL_CONTROL_BLOB_LENGTH; // everything except utdvec

    //
    // if we have an up to date vector, verify and compute the size
    //

    pUtdvecV1 = UpToDateVec_Convert(pTHS, 1, pReplicaMsg->pUpToDateVecSrc);
    
    if (NULL != pUtdvecV1) {
        Assert(IS_VALID_UPTODATE_VECTOR(pUtdvecV1));

        if (pUtdvecV1->V1.cNumCursors > 0) {      
            cbVecSize = UpToDateVecV1Size(pUtdvecV1);
            pReplCtrl->cookie.length += cbVecSize;
        }
    }

    p = pReplCtrl->cookie.value = (PUCHAR)THAlloc( pReplCtrl->cookie.length );
    if( ! pReplCtrl->cookie.value ) {
        return other;
    }

    ZeroMemory(p, pReplCtrl->cookie.length);

    //
    // Pack the signature
    //

    *((PDWORD)p) = REPL_SIGNATURE;
    p += sizeof(DWORD);

    //
    // Pack the Version. 
    //

    *((PDWORD)p) = REPL_VERSION;    
    p += sizeof(DWORD);

    //
    // Set the current time
    //

    GetSystemTimeAsFileTime((PFILETIME)p);
    p += sizeof(FILETIME);

    //
    // reserved for now
    //

    p += sizeof(LARGE_INTEGER);

    //
    // Pack the size of the up to date vector
    //

    *((PDWORD)p) = cbVecSize;
    p += sizeof(DWORD);

    //
    // Copy the usnvecTo. 
    //

    CopyMemory( p,
            &pReplicaMsg->usnvecTo, 
            sizeof(USN_VECTOR));

    p += sizeof(USN_VECTOR);

    //
    // Copy the invocation UUID
    //

    CopyMemory( p,
                &pReplicaMsg->uuidInvocIdSrc,
                sizeof(UUID));

    p += sizeof(UUID);

    //
    // Copy the UPTODATE_VECTOR if it exists
    //

    if( cbVecSize > 0 ) {
        CopyMemory( p,
                    pUtdvecV1, 
                    cbVecSize);
        THFreeEx(pTHS, pUtdvecV1);
    }

    return success;
} // LDAP_PackReplControl 


_enum1
LDAP_UnpackReplControl (
        IN  NAMING_CONTEXT            *pNC,
        IN  SEARCHARG                 *pSearchArg,
        IN  CONTROLS_ARG              *pControlArg,
        OUT DRS_MSG_GETCHGREQ_NATIVE  *pMsgIn,
        OUT PARTIAL_ATTR_VECTOR       **ppPartialAttrVec
        )
/*++
Routine Description:
    Prepare DRS_MSG_GETCHGREQ_NATIVE for GetNCChanges()

Arguments:

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    THSTATE *   pTHS = pTHStls;
    DWORD       dwIndex;
    ATTR*       pAttr;
    ATTRTYP*    pAttrTyp;
    PUCHAR      p = NULL;

    ZeroMemory( pMsgIn, sizeof(*pMsgIn) );

    pMsgIn->pNC = pNC;
    pMsgIn->ulFlags = DRS_WRIT_REP;
    if (pControlArg->replFlags & DRS_DIRSYNC_ANCESTORS_FIRST_ORDER) {
        pMsgIn->ulFlags |= DRS_GET_ANC;
    }
    pMsgIn->cMaxObjects = pControlArg->CommArg.ulSizeLimit; 

    if ( pControlArg->replSize == 0 ) {
        pControlArg->replSize = LdapMaxReplSize;
    }

    //
    // see if the blob is ok
    //

    pMsgIn->cMaxBytes = pControlArg->replSize;

    if( pControlArg->replCookie.length != 0 ) {
        if( pControlArg->replCookie.length < MIN_REPL_CONTROL_BLOB_LENGTH ) {
            IF_DEBUG(WARNING) {
                DPRINT2(0,"Repl Cookie length[%d] too short. Minimum %d\n", 
                        pControlArg->replCookie.length,
                        MIN_REPL_CONTROL_BLOB_LENGTH);
            }
            return protocolError;
        }

        p = pControlArg->replCookie.value;
    }

    if ( p != NULL ) {

        PDWORD pdwField;
        UNALIGNED UUID* invUuid;
        DWORD cbVecSize;

        //
        // Check the signature
        //

        pdwField = (PDWORD)p;
        p += sizeof(DWORD);

        if ( *pdwField != REPL_SIGNATURE ) {
            IF_DEBUG(WARNING) {
                DPRINT2(0,"Invalid signature %x. Expected %x\n", 
                        *pdwField, REPL_SIGNATURE);
            }
            return protocolError;
        }

        pdwField = (PDWORD)p;
        p += sizeof(DWORD);
        if ( *pdwField != REPL_VERSION ) {
            IF_DEBUG(WARNING) {
                DPRINT2(0,"Invalid version number %x. Expected %x\n", 
                        *pdwField, REPL_VERSION);
            }
            return protocolError;
        }

        //
        // Skip the time and reserve for now
        //

        p += sizeof(FILETIME) + sizeof(LARGE_INTEGER);

        //
        // get the size of the up to date vector
        //

        pdwField = (PDWORD)p;
        cbVecSize = *pdwField;
        if ( (cbVecSize < sizeof(UPTODATE_VECTOR_V1_EXT)) ||
             (pControlArg->replCookie.length < MIN_REPL_CONTROL_BLOB_LENGTH + cbVecSize) ) {

            //
            // Huh?  This should not happen but stranger things have.
            //

            cbVecSize = 0;
        }

        //
        // p will now point to vectorFrom
        //

        p += sizeof(DWORD);

        //
        // Check the invocation ID, if it is ours, then copy the vector from field.
        //

        invUuid = (UUID*)(p + sizeof(USN_VECTOR));

        if ( DsIsEqualGUID( invUuid, &pTHS->InvocationID ) ) {
            CopyMemory( &pMsgIn->usnvecFrom, 
                        p,
                        sizeof(USN_VECTOR) );
        }

        //
        // p will now point to the up to date vector
        //

        p += sizeof(USN_VECTOR) + sizeof(UUID);

        //
        // Get the uptodate vector, if it exists and is the right version and size.
        // To ensure proper alignment of the up to date vector, allocate new memory here.
        //

        if ( cbVecSize > 0 ) {
            UPTODATE_VECTOR *pVec = (UPTODATE_VECTOR *)THAllocEx( pTHS, cbVecSize );
            memcpy( pVec, p, cbVecSize );

            if (
                   ( pVec->dwVersion != 1 )
                || ( UpToDateVecV1Size(pVec) != cbVecSize )
                || ( cbVecSize != pControlArg->replCookie.length - MIN_REPL_CONTROL_BLOB_LENGTH )
               )
            {
                return protocolError;
            }

            pMsgIn->pUpToDateVecDest
                = UpToDateVec_Convert(pTHS, UPTODATE_VECTOR_NATIVE_VERSION, pVec);

            THFreeEx(pTHS, pVec);
        }
    }

    if ( (pSearchArg->pSelection == NULL) || 
         (pSearchArg->pSelection->AttrTypBlock.attrCount == 0) ) {
        *ppPartialAttrVec = NULL;
        return success;
    }

    *ppPartialAttrVec
        = (PARTIAL_ATTR_VECTOR *)
                THAllocEx(
                    pTHS,
                    PartialAttrVecV1SizeFromLen(
                            pSearchArg->pSelection->AttrTypBlock.attrCount));

    if( ! *ppPartialAttrVec ) {
        return other;
    }

    (*ppPartialAttrVec)->V1.cAttrs = pSearchArg->pSelection->AttrTypBlock.attrCount;

    for( dwIndex=0, pAttr=pSearchArg->pSelection->AttrTypBlock.pAttr, 
            pAttrTyp=(*ppPartialAttrVec)->V1.rgPartialAttr; 
            dwIndex < (*ppPartialAttrVec)->V1.cAttrs; 
            dwIndex++, pAttrTyp++, pAttr++ ) {
        *pAttrTyp = pAttr->attrTyp;
    }

    //
    // GetNCChanges() requires that the attributes be sorted.
    //
    qsort((*ppPartialAttrVec)->V1.rgPartialAttr,
          (*ppPartialAttrVec)->V1.cAttrs,
          sizeof(ATTRTYP),
          CompareAttrtyp);

    return success;
}

_enum1
LDAP_AddGuidAsAttr (
        IN  THSTATE               *pTHS,
        IN  ULONG                 CodePage,
        IN  ATTRTYP               AttrTyp,
        IN  LPGUID                pGuid,
        IN  PCONTROLS_ARG         pControlArg,
        OUT SearchResultEntry     *pEntry
        )
/*++
Routine Description:
    Get GUID from DSNAME and add it to the attribute list

Arguments:

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    ATTCACHE            *pAC;
    ATTRVAL             attrVal;
    AttributeVals         pNextAttribute;
    PartialAttributeList_ *pAttribute;
    _enum1                code;

    // Allocate all the PartialAttributeList_'s we need
    pAttribute = (PartialAttributeList_ *)
                        THAlloc( sizeof(PartialAttributeList_) + 
                                 PAD64(sizeof(AttributeVals_)) );
    if( !pAttribute ) {
        IF_DEBUG(NOMEM) {
            DPRINT(0,"LdapAddGuidAsStr failed to allocate memory\n");
        }
        return other;
    }

    // Turn the attrtyp in the attrblock into an LDAP attribute type.
    code = LDAP_DirAttrTypToAttrType (
                pTHS,
                CodePage,
                AttrTyp,
                0,     // No flags
                &(pAttribute->value.type),
                &pAC);

    if(code) {
        // Something went wrong.
        return code;
    }
        
    //
    // allocate the node in the LDAP value list for this attribute
    //

    pAttribute->value.vals = (AttributeVals)
        ALIGN64_ADDR((PCHAR)pAttribute+sizeof(PartialAttributeList_));

    Assert( IS_ALIGNED64(pAttribute->value.vals) );

    pNextAttribute = pAttribute->value.vals;

    // Now, translate the value.
    attrVal.valLen = sizeof(GUID);
    attrVal.pVal = (PUCHAR)pGuid;

    code = LDAP_DirAttrValToAttrVal (
                    pTHS,
                    CodePage,
                    pAC,
                    &attrVal,
                    0,      // No flags
                    pControlArg,
                    (AssertionValue *)&(pNextAttribute->value));
    if(code) {
        // Something went wrong
        return code;
    }

    // Set up pointer to next attribute in chain.
    pAttribute->next = pEntry->attributes;
    pEntry->attributes = pAttribute;

    return success;
}

_enum1
LDAP_ValinfObjectToSearchResultEntry (
        IN  THSTATE           *pTHS,
        IN  ULONG             CodePage,
        IN  REPLVALINF        *pValinf,
        IN  CONTROLS_ARG      *pControlArg,
        OUT SearchResultEntry *pEntry
        )
/*++
Routine Description:
    Translate a directory Valinf to an LDAP SearchResultEntry.

Arguments:
    pTHS - thread state
    CodePage - internationalization
    pValinf - the directory valinf.
    pRangeInf - the directory range information.  May be NULL.
    pControlArg - common arguments for this translation
    pEntry - pointer to the SearchResultEntry to fill up.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    _enum1 code;

    Assert( pValinf );

    code = LDAP_DSNameToLDAPDN(
        CodePage,
        pValinf->pObject,
        pControlArg->extendedDN,
        &pEntry->objectName);
    if(code) {
        return code;
    }

    //
    // Add UUID (from DSNAME) as an attribute
    //

    code = LDAP_AddGuidAsAttr(pTHS, 
                              CodePage,
                              ATT_OBJECT_GUID,
                              &(pValinf->pObject->Guid),
                              pControlArg,
                              pEntry
        ); 

    return code;
}
    

_enum1
LDAP_ReplicaMsgToSearchResultFull (
        IN  THSTATE                     *pTHS,
        IN  ULONG                       CodePage,
        IN  DRS_MSG_GETCHGREPLY_NATIVE  *pReplicaMsg,
        IN  PCONTROLS_ARG               pControlArg,
        OUT SearchResultFull_           **ppResultReturn,
        OUT Controls                    *ppControlsReturn
        )
/*++
Routine Description:
    Translate a dra DRS_MSG_GETCHGREPLY_NATIVE into a linked list of LDAP
    SearchResultFull objects.

Arguments:
    pReplicaMsg - the result from DRA_GetNCChanges().
    pControlArg - common arg structure for this search
    ppResultReturn - pointer to place to put the linked list of LDAP search
                     results.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    SearchResultFull_ *pResultReturn;
    ULONG i=0, j;                       // loop index
    REPLENTINFLIST *pEntList = pReplicaMsg->pObjects;
    ULONG objCount, valCount, valObjCount;
    ReplicationSearchControlValue repl;
    Controls      pControls;
    _enum1 code;
    REPLVALINF *pValueLast, *pValueCurr, *pValueNext;
    BOOL fEntryCurrency, fAttrCurrency;


    // How many entries in the search result full chain?
    objCount = pReplicaMsg->cNumObjects;
    valCount = pReplicaMsg->cNumValues;

    // How many object entries in the value list
    if (valCount && pReplicaMsg->rgValues) {

        valObjCount = 1;
        for( j = 1, pValueLast = pReplicaMsg->rgValues, pValueCurr = pValueLast + 1;
             j < valCount;
             j++, pValueLast = pValueCurr++ ) {
            if (memcmp( &(pValueLast->pObject->Guid),
                        &(pValueCurr->pObject->Guid),
                        sizeof(GUID) ) != 0) {
                valObjCount++;
            }
        }
    } else {
        valObjCount = 0;
    }

    if ( (!objCount) && (!valObjCount) ) {
        // The search result is empty.
        *ppResultReturn = NULL;
    }
    else {

        //
        // The search result is not empty.
        // Allocate all the search results we need. 
        //

        pResultReturn =
            (SearchResultFull_ *)THAlloc((objCount+valObjCount) * sizeof(SearchResultFull_));
        if(!pResultReturn) {
            // Out of Memory
            return other;
        }
        
        //
        // Loop through the Entinfs in the directory search result, turning them
        // into their LDAP equivalent.
        //

        for(i=0;i<objCount;i++) {
            // Set up the next pointer in this chain.
            pResultReturn[i].next = &(pResultReturn[i+1]);
            
            // Say what we are.
            pResultReturn[i].value.choice = entry_chosen;
            
            // Translate the entinf.
            code = LDAP_EntinfToSearchResultEntry(
                    pTHS,
                    CodePage,
                    &pEntList->Entinf,
                    NULL,
                    NULL,
                    pControlArg,
                    &pResultReturn[i].value.u.entry);
            if(code) {
                return code;
            }
            
            //
            // Add UUID (from DSNAME) as an attribute
            //

            code = LDAP_AddGuidAsAttr(pTHS, 
                                      CodePage,
                                      ATT_OBJECT_GUID,
                                      &pEntList->Entinf.pName->Guid,
                                      pControlArg,
                                      &(pResultReturn[i].value.u.entry)
                                      ); 
            if(code) {
                return code;
            }

            //
            // Add Parent Guid as an attribute
            //

            if ( pEntList->pParentGuid != NULL ) {
                code = LDAP_AddGuidAsAttr(pTHS, 
                                      CodePage, 
                                      ATT_PARENT_GUID,
                                      pEntList->pParentGuid,
                                      pControlArg,
                                      &(pResultReturn[i].value.u.entry) ); 
                if(code) {
                    return code;
                }
            }

            // Reset pointers for another trip through the loop.
            pEntList = pEntList->pNextEntInf;
        }

        //
        // Return the values
        //

        // We are going through the value array and grouping them by similar properties.
        // We trigger actions when we reach the end of a run of values with the same
        // properties.  At the end of a run of values with a given set of attribute
        // properties, we add an attribute. At the end of a run of values with the
        // same object guid, we add the object name and guid attribute.
        // i - tracks the current object entry, one per guid
        // j - tracks the current value being examined
        // fEntryCurrent - means the current value is NOT the last with this guid
        // fAttrCurrent - means the current value is NOT the last for this
        //     set of properties
        // pValueLast - marks the first value in a run we are building up
        // pValueNext - lookahead to the next value, invalid on the last value

        pValueLast = pReplicaMsg->rgValues;

        // Note that on the last pass, pValueNext points beyond the end of the array
        for(j=0, pValueCurr = pReplicaMsg->rgValues, pValueNext = pValueCurr + 1;
            j < valCount;
            j++, pValueCurr = pValueNext++ ) {

            if (j < (valCount - 1)) {
                fEntryCurrency = (memcmp( &(pValueCurr->pObject->Guid),
                                          &(pValueNext->pObject->Guid), sizeof(GUID) ) == 0);
                if (fEntryCurrency) {
                    fAttrCurrency = ( (pValueCurr->attrTyp == pValueNext->attrTyp) &&
                                      (pValueCurr->fIsPresent == pValueNext->fIsPresent) );
                } else {
                    // Last value with this object guid
                    fAttrCurrency = FALSE;
                }
            } else {
                // Last value in list
                fEntryCurrency = fAttrCurrency = FALSE;
            }
            
            if (!fAttrCurrency) {
                // This is the last value for this attribute

                // CODE.ENHANCEMENT: There is no restriction on the number of values added
                // to the attribute. Once the number of values exceeds some limit, should
                // we start a new attribute or object entry?
                code = LDAP_AddValinfAsAttr(
                    pTHS,
                    CodePage,
                    pValueLast,
                    (DWORD) (pValueNext - pValueLast), // ptr subtr yields count
                    NULL, // pRangeInfo
                    NULL,
                    pControlArg,
                    &pResultReturn[i].value.u.entry);
                if(code) {
                    return code;
                }
            
                pValueLast = pValueNext;
            }

            if (!fEntryCurrency) {
                // This is the last value for this object guid
                // Set up the next pointer in this chain.
                pResultReturn[i].next = &(pResultReturn[i+1]);
                    
                // Say what we are.
                pResultReturn[i].value.choice = entry_chosen;
            
                // Translate the entinf.
                code = LDAP_ValinfObjectToSearchResultEntry(
                    pTHS,
                    CodePage,
                    pValueCurr,
                    pControlArg,
                    &pResultReturn[i].value.u.entry);
                if(code) {
                    return code;
                }

                i++;
            }
        }  // end for...

        Assert( objCount + valObjCount == i );
        // Set up our end marker.
        pResultReturn[i-1].next = NULL;
        
        *ppResultReturn = pResultReturn;
    }
    
    // OK, create the controls to return
    *ppControlsReturn = NULL;

    code = LDAP_PackReplControl( pTHS, pReplicaMsg, &repl );
    if(code) {
        return code;
    }

    if ( EncodeReplControl( &pControls, &repl ) != ERROR_SUCCESS ) {
        return other;
    }
        
    pControls->next = NULL;
    *ppControlsReturn = pControls;

    return success;
}


_enum1
LDAP_ModificationListToAttrModList(
        IN  THSTATE            *pTHS,
        IN  ULONG              CodePage,
        IN  SVCCNTL*           Svccntl OPTIONAL,
        IN  ModificationList   pModification,
        OUT ATTRMODLIST        **ppAttrModList,
        OUT USHORT             *pCount
        )
/*++
Routine Description:
    Translate an LDAP modification list to a dir modlist.

Arguments:
    pAttributes - the LDAP modification list.
    ppAttrModList - the dir modlist.
    pCount - the number of entries in the modification list.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    ATTRMODLIST *pAttrMods = NULL;
    ModificationList  pTempMods = pModification;
    USHORT      count=0;
    _enum1      code;

    // First, count the modifications
    while(pTempMods) {
        count++;
        pTempMods = pTempMods->next;
    }

    if(!count) {
        // Hey!, no modifications!  This will do no work in the core, so go
        // ahead and return an error here.
        return unwillingToPerform;
    }
    
    // Now, allocate the ATTRMODS
    pAttrMods = (ATTRMODLIST *)THAllocEx(pTHS, count * sizeof(ATTRMODLIST));
    (*ppAttrModList) = pAttrMods;
    *pCount = count;

    // Loop through the modifications, translating to ATTRMODS
    pTempMods = pModification;

    while(pTempMods) {

        // Set the mod type.
        switch(pTempMods->value.operation) {
        case add:
            pAttrMods->choice = AT_CHOICE_ADD_VALUES;
            break;
        case operation_delete:
            if(!pTempMods->value.modification.vals) {
                // No vals, this means to remove the entire attribute
                pAttrMods->choice = AT_CHOICE_REMOVE_ATT;
            }
            else {
                pAttrMods->choice = AT_CHOICE_REMOVE_VALUES;
            }
            break;
        case replace:
            pAttrMods->choice = AT_CHOICE_REPLACE_ATT;
            break;
        default:
            return other;
            break;
        }

        // Translate the attribute to an attr
        code = LDAP_AttributeToDirAttr(
                pTHS,
                CodePage,
                Svccntl,
                (Attribute *)&pTempMods->value.modification,
                &pAttrMods->AttrInf);
        if(code) {
            return code;
        }


        if(!pAttrMods->AttrInf.AttrVal.valCount &&
           (pAttrMods->choice != AT_CHOICE_REMOVE_ATT &&
            pAttrMods->choice != AT_CHOICE_REPLACE_ATT)) {
            // Hey, you didn't give me any values!
            return constraintViolation;
        }
                
        // Set pointer to next value.
        pAttrMods->pNextMod = &pAttrMods[1];

        // Set loop variables to deal with next value.
        pTempMods = pTempMods->next;
        pAttrMods++;
    }

    // Set the end node of the linked list to point to null.
    (*ppAttrModList)[count - 1].pNextMod = NULL;
    // go home.
    return success;
}


_enum1
LDAP_DirSvcErrorToLDAPError (
    IN DWORD dwError
    )
{
    switch (dwError) {
    case 0:
        return success;
        break;

    case SV_PROBLEM_BUSY:
        return busy;
        break;

    case SV_PROBLEM_UNAVAILABLE:
        return unavailable;
        break;

    case SV_PROBLEM_WILL_NOT_PERFORM:
        return unwillingToPerform;
        break;

    case SV_PROBLEM_CHAINING_REQUIRED:
        return unwillingToPerform; // DS_E_CHAINING_REQUIRED;
        break;

    case SV_PROBLEM_UNABLE_TO_PROCEED:
        return operationsError;
        break;

    case SV_PROBLEM_INVALID_REFERENCE:
        return operationsError; // DS_E_INVALID_REF;
        break;

    case SV_PROBLEM_TIME_EXCEEDED:
        return timeLimitExceeded;
        break;

    case SV_PROBLEM_ADMIN_LIMIT_EXCEEDED:
        return adminLimitExceeded;
        break;

    case SV_PROBLEM_LOOP_DETECTED:
        return loopDetect;
        break;

    case SV_PROBLEM_UNAVAIL_EXTENSION:
        return unavailableCriticalExtension;
        break;

    case SV_PROBLEM_OUT_OF_SCOPE:
        return operationsError; // DS_E_OUT_OF_SCOPE;
        break;

    case SV_PROBLEM_DIR_ERROR:
        return operationsError; // DS_E_DIT_ERROR;
        break;

    default:

        IF_DEBUG(WARNING) {
            DPRINT1(0,"Unable to map svcError %x\n", dwError);
        }
        return other;
    }

    // Hmm, I wonder what went wrong.  Oh, well, it was something.
    return other;
}


_enum1
LDAP_DirErrorToLDAPError (
        IN THSTATE       *pTHS,
        IN USHORT         Version,
        IN ULONG          CodePage,
        IN error_status_t codeval,
        IN PCONTROLS_ARG  pControlArg,
        OUT Referral      *ppReferral,
        OUT LDAPString    *pError,
        OUT LDAPString    *pName
        )
/*++
Routine Description:
    Translate a Dir error and error structure to an LDAP error code.

Arguments:
    codeval - the category of directory error.
    error_struct - the error structure with extended information.

Return Values:
    the LDAP error code corresponding to the Dir error information.

--*/
{
    register DIRERR *direrr =  (pTHS->pErrInfo);
    _enum1 code;
    BOOL ok;

    ok = CreateErrorString(&(pError->value), (PULONG)&(pError->length));

    if ( ok ) {

        IF_DEBUG(ERR_NORMAL) {
            DPRINT1(0,"Returning extended error string %s\n", pError->value);
        }

        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
            DS_EVENT_SEV_MINIMAL,
            DIRLOG_LDAP_EXT_ERROR,
            szInsertSz(pError->value),
            NULL, NULL);
    }
    
    switch (codeval) {
    case attributeError:
        switch(direrr->AtrErr.FirstProblem.intprob.problem) {
        case PR_PROBLEM_NO_ATTRIBUTE_OR_VAL:
            return noSuchAttribute;
            break;
            
        case PR_PROBLEM_INVALID_ATT_SYNTAX:
            return invalidAttributeSyntax;
            break;
            
        case PR_PROBLEM_UNDEFINED_ATT_TYPE:
            return undefinedAttributeType;
            break;
            
        case PR_PROBLEM_WRONG_MATCH_OPER:
            return inappropriateMatching;
            break;
            
        case PR_PROBLEM_CONSTRAINT_ATT_TYPE:
            return constraintViolation;
            break;
            
        case PR_PROBLEM_ATT_OR_VALUE_EXISTS:
            return attributeOrValueExists;
            break;
        default:
            IF_DEBUG(WARNING) {
                DPRINT1(0,"Unable to map AttrError %x\n",
                        direrr->AtrErr.FirstProblem.intprob.problem);
            }
            return other;
        }
        break;
        
    case nameError:
        switch( direrr->NamErr.problem ) {
        case NA_PROBLEM_NO_OBJECT:
            if(direrr->NamErr.pMatched) {
                LDAP_DSNameToLDAPDN(
                        CodePage,
                        direrr->NamErr.pMatched,
                        FALSE,
                        pName);
            }
            return noSuchObject;
            break;
            
        case NA_PROBLEM_NO_OBJ_FOR_ALIAS:
            return aliasProblem;
            break;
            
        case NA_PROBLEM_NAMING_VIOLATION:
            return namingViolation;
            break;
            
        case NA_PROBLEM_BAD_ATT_SYNTAX:
            return invalidDNSyntax; // DS_E_INVALID_ATTRIBUTE_VALUE;
            break;
            
        case NA_PROBLEM_ALIAS_NOT_ALLOWED:
            return aliasDereferencingProblem;
            break;
            
        case NA_PROBLEM_BAD_NAME:
            return invalidDNSyntax; // DS_E_BAD_NAME;
            break;
        default:
            IF_DEBUG(WARNING) {
                DPRINT1(0,"Unable to map NameError %x\n", direrr->NamErr.problem);
            }
            return other;
        }
        break;
        
    case referralError: 
        if(!direrr->RefErr.Refer.count) {
            // Huh?  nothing to refer to
            return other;
        }
        
        //Assert(direrr->RefErr.Refer.count == 1);
        
        // Translate the access point to a referral
        code = LDAP_ContRefToReferral(
                pTHS,
                Version,
                CodePage,
                &direrr->RefErr.Refer,
                pControlArg,
                ppReferral);
        if(code) {
            return code;
        }
        if(Version == 2) {
            return referralv2;
        }
        else {
            return referral;
        }
        break;
        
    case securityError:
        switch(direrr->SecErr.problem) {
        case SE_PROBLEM_INAPPROPRIATE_AUTH:
            return inappropriateAuthentication;
            break;
            
        case SE_PROBLEM_INVALID_CREDENTS:
            return invalidCredentials;
            break;
            
        case SE_PROBLEM_INSUFF_ACCESS_RIGHTS:
            return insufficientAccessRights;
            break;
            
        case SE_PROBLEM_INVALID_SIGNATURE:
            return authMethodNotSupported; // DS_E_INVALID_SIGNATURE;
            break;
            
        case SE_PROBLEM_PROTECTION_REQUIRED:
            return authMethodNotSupported; // DS_E_PROTECTION_REQUIRED;
            break;
            
        case SE_PROBLEM_NO_INFORMATION:
            return authMethodNotSupported; // DS_E_NO_INFORMATION;
            break;
        default:
            IF_DEBUG(WARNING) {
                DPRINT1(0,"Unable to map SecError %x\n", direrr->SecErr.problem);
            }
            return other;
        }
        break;
        
    case serviceError:
        
        // direrr->SvcErr.problem has the system error code
        return LDAP_DirSvcErrorToLDAPError (direrr->SvcErr.problem);
        break;
        

    case updError:
        switch(direrr->UpdErr.problem) {
        case UP_PROBLEM_NAME_VIOLATION:
            return namingViolation;
            break;
            
        case UP_PROBLEM_OBJ_CLASS_VIOLATION:
            return objectClassViolation;
            break;
            
        case UP_PROBLEM_CANT_ON_NON_LEAF:
            return notAllowedOnNonLeaf;
            break;
            
        case UP_PROBLEM_CANT_ON_RDN:
            return notAllowedOnRDN;
            break;
            
        case UP_PROBLEM_ENTRY_EXISTS:
            return entryAlreadyExists;
            break;
            
        case UP_PROBLEM_AFFECTS_MULT_DSAS:
            return affectsMultipleDSAs;
            break;
            
        case UP_PROBLEM_CANT_MOD_OBJ_CLASS:
            return objectClassModsProhibited;
            break;
        default:
            IF_DEBUG(WARNING) {
                DPRINT1(0,"LDAP: Unable to map updError %x\n",direrr->UpdErr.problem);
            }
            return other;
        }
        break;
        
    case systemError:
        // direrr->SysErr.problem has the system error code.

        IF_DEBUG(WARNING) {
            DPRINT1(0,"LDAP: Dir operation returns system error %x\n", direrr->SysErr.problem);
        }
        return other;
        break;
    }
    
    // Hmm, I wonder what went wrong.  Oh, well, it was something.
    return other;
}



_enum1
LDAP_HandleDsaExceptions (
        IN DWORD dwException,
        IN ULONG ulErrorCode,
        OUT LDAPString *pErrorMessage
        )
/*++
Routine Description:
    Return an appropriate LDAP error code when we catch an exception in an
    operation request.

Arguments:
    dwException - the exception that occured.
    ulErrorCode - the specific dir error that occured.
    pErrorMessage - error string returned to the client.
    
Retunr Value:
    returns the appropriate LDAP error code.
--*/
{
    _enum1 code = other;
    DWORD commentId;
    DWORD err;

    IF_DEBUG(WARNING) {
        DPRINT2(0,"Dsa Exception %x [err %d]\n",
                dwException, (JET_ERR)ulErrorCode);
    }

    switch(dwException) {
    case DSA_DB_EXCEPTION:
        switch ((JET_ERR) ulErrorCode) {
        case JET_errWriteConflict:
            commentId = LdapJetError;
            code = busy;
            err = ERROR_SHARING_VIOLATION;
            break;

        case JET_errRecordTooBig:
            commentId = LdapJetError;
            code = adminLimitExceeded;
            err = ERROR_DS_ADMIN_LIMIT_EXCEEDED;
            break;

        case JET_errLogWriteFail:
        case JET_errDiskFull:
        case JET_errLogDiskFull:
            // fall through

        default:
            code = operationsError;
            err = ERROR_DISK_FULL;
            commentId = LdapJetError;
            break;
        }
        break;

    case DSA_EXCEPTION:
        code = operationsError;
        err = ERROR_DS_UNKNOWN_ERROR;
        commentId = LdapDsaException;
        break;

    case DSA_BAD_ARG_EXCEPTION:
        code = protocolError;
        err = ERROR_INVALID_PARAMETER;
        commentId = LdapDsaException;
        break;

    case STATUS_NO_MEMORY:
    case DSA_MEM_EXCEPTION:
        commentId = LdapDsaException;
        code = operationsError;
        err = ERROR_NOT_ENOUGH_MEMORY;
        break;

    default:
        code = other;
        err = ERROR_DS_UNKNOWN_ERROR;
        commentId = LdapDsaException;
        break;
    }

    code = SetLdapError(code,
                        err,
                        commentId,
                        ulErrorCode,
                        pErrorMessage);

    return code;
}


_enum1
LDAP_GetReplDseAtts(IN THSTATE * pTHS, 
                    IN ULONG CodePage,
                    IN OUT BOOL * pbHasReplAccess,
                    IN AttributeType *patTypeName,
                    IN AttributeType *patBaseTypeName,
                    IN DWORD dwAttrId, 
                    IN BOOL bTypesOnly,
                    OUT ULONG * pNumDone,
                    IN OUT PartialAttributeList * ppAttributes);

_enum1
LDAP_GetDSEAtts (
        IN  PLDAP_CONN        LdapConn,
        IN  PCONTROLS_ARG     pControlArg,
        IN  SearchRequest     *pSearchRequest,
        OUT SearchResultFull_ **ppSearchResult,
        OUT LDAPString        *pErrorMessage,
        OUT RootDseFlags      *pRootDseFlag
        )
/*++
Routine Description:
    Create a search response for the operational attributes for a directory
    service.

Arguments:
    LdapConn - pointer to current ldap connection
    pControlArg - pointer to control arg supplied by client
    pSearchArg - the search arg built based on the SearchRequest
    ppSearchResult - the operational atts
    pErrorMessage - pointer to error message string to be returned to client

Return Value:
    returns an LDAP error code.
--*/
{
    THSTATE              *pTHS = pTHStls;
    SearchResultFull_    *pSearchRes;
    PartialAttributeList pAttributes = NULL;
    _enum1               code        = success;
    ATTCACHE             fakeAC;
    ATTRVAL              dirAttrVal;
    DWORD                count = 0;
    NAMING_CONTEXT_LIST  *pNCL;
    AttributeVals        pVals;
    ULONG                NumDone = 0;
    DWORD                codePage = LdapConn->m_CodePage;
    DWORD                i;
    DWORD                data = 0;
    DWORD                err = ERROR_DS_INTERNAL_FAILURE;
    ULONG                requestedAttCount=0;
    AttributeType        *requestedAtts[NUM_ROOT_DSE_ATTS];
    BOOL                 fAllAtts = FALSE;
    BOOL                 typesOnly = pSearchRequest->typesOnly;
    AttributeDescriptionList padlAttributes = pSearchRequest->attributes;
    BOOL bHasReplAccess = FALSE;
    NCL_ENUMERATOR       nclEnum;

    *pRootDseFlag = rdseDseSearch;

    memset(requestedAtts, 0, sizeof(requestedAtts));
    memset(&fakeAC, 0, sizeof(ATTCACHE));

    DPRINT(1, " [4] LDAP_GetDSEAtts\n");

    // First, find out what attributes they want.
    if(!padlAttributes) {
        // Null attribute list.  Assume that means they want everything.
        fAllAtts = TRUE;
    }
    else {
        // Non-null attribute list.
        for(; padlAttributes; padlAttributes=padlAttributes->next) {
            if(padlAttributes->value.length==1 &&
               padlAttributes->value.value[0]=='*') {
                // They are asking for all Root DSE attributes, regardless of
                // anything else.  Nothing else to do
                fAllAtts  = TRUE;
                continue;
            }
            else {
                BOOL fFound = FALSE;
                DWORD dwRealLength;
                
                // The parsing process makes a pass through the attributes and sets an
                // array of booleans according to whether a given attribute appears.
                // A second pass checks for each fixed attribute and executes it if
                // necessary.

                // During this first pass, we truncate the attribute so that no options
                // are visible during the basic match of the attribute name.
                // We store a pointer to the original attribute name in the requestedAtts
                // array so that we can later parse the options if desired.

                // Start looking for the binary option on the attr type.
                for(i=0;(i<padlAttributes->value.length) && (padlAttributes->value.value[i] != ';');i++)
                    ;

                //
                // Save the length of the att type since we will temporarily
                // change it if we find an option.
                //
                dwRealLength = padlAttributes->value.length;
    
                // Truncate name for matching purposes
                padlAttributes->value.length = i;

                // Look this up to see if it's a known a root dse att.
                for(i=0;i<NUM_ROOT_DSE_ATTS;i++) {
                    if(EQUAL_LDAP_STRINGS((padlAttributes->value),
                                          (RootDSEAtts[i]))) {
                        requestedAttCount++;
                        // Mark present and save pointer to name
                        requestedAtts[i]=&(padlAttributes->value);
                        fFound=TRUE;
                        break;
                    }
                }

                // Restore attribute length
                padlAttributes->value.length = dwRealLength;

#ifdef NEVER
                // for now (maybe forever) we are not going to complain if they
                // specified an attribute we didn't understand.  Skip this code
                if(!fFound) {
                    // Couldn't find the attribute,something lost in the
                    // translation
                    return code;
                }
#else
                // Yeah, whatever.  Just blow off the error.
                code = success;
#endif
            }
        }  // for
    }

    if(fAllAtts) {
        requestedAttCount = NUM_ROOT_DSE_ATTS;
    }
    
    // Now we know what attributes to do.  Do them

    pSearchRes = (SearchResultFull_ *)THAllocEx(pTHS,
                    sizeof(SearchResultFull_) +
                    PAD64(requestedAttCount*sizeof(PartialAttributeList_)));
        
    //
    // Set up the null pointer, as we have only one object to return.
    //

    pSearchRes->next = NULL;
    pSearchRes->value.choice = entry_chosen;

    //
    // The name is the null name.
    //

    pSearchRes->value.u.entry.objectName.length = 0;
    pSearchRes->value.u.entry.objectName.value = NULL;

    //
    // Ok, set up the attribute list.
    //

    pAttributes = (PartialAttributeList)
        ALIGN64_ADDR((PCHAR)pSearchRes + sizeof(SearchResultFull_));
    Assert( IS_ALIGNED64(pAttributes) );

    pSearchRes->value.u.entry.attributes = pAttributes;

    // 1) Do the currentTime value.
    if(fAllAtts || requestedAtts[LDAP_ATT_CURRENT_TIME]) {
        
        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_CURRENT_TIME];
        
        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        }
        else {
            //
            // Set up some support data structures and call the conversion.
            // set pVal to NULL, this will signal DirAttrToAttrVal to do a
            // GetSystemTime. 
            //

            fakeAC.OMsyntax = OM_S_GENERALISED_TIME_STRING;
            dirAttrVal.valLen = sizeof(DSTIME);
            dirAttrVal.pVal = NULL;

            pAttributes->value.vals =
                (AttributeVals)THAllocEx(pTHS, sizeof(AttributeVals_));
            pAttributes->value.vals->next = NULL;
            code = LDAP_DirAttrValToAttrVal(
                    pTHS,
                    codePage,
                    &fakeAC,
                    &dirAttrVal,
                    0,      // No flags
                    pControlArg,
                    (AssertionValue *)&pAttributes->value.vals->value);

            if(code) {
                data = LDAP_ATT_CURRENT_TIME;
                goto exit;
            }
        }
        NumDone++;
        pAttributes++;
    }

    // 2) Do the subschemaSubentry value.
    if(fAllAtts || requestedAtts[LDAP_ATT_SUBSCHEMA_SUBENTRY]) {

        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_SUBSCHEMA_SUBENTRY];
        
        if(typesOnly) {
            // Weird combo, but whatever
            pAttributes->value.vals = NULL;
        }
        else {
            // Cruft up some locals for the call
            dirAttrVal.valLen = gAnchor.pLDAPDMD->structLen;
            dirAttrVal.pVal = (PUCHAR)gAnchor.pLDAPDMD;
        
            fakeAC.OMsyntax = OM_S_OBJECT;
            fakeAC.syntax = SYNTAX_DISTNAME_TYPE;
            
            pAttributes->value.vals =
                (AttributeVals)THAllocEx(pTHS, sizeof(AttributeVals_));
            pAttributes->value.vals->next = NULL;
            code = LDAP_DirAttrValToAttrVal (
                    pTHS,
                    codePage,
                    &fakeAC,
                    &dirAttrVal,
                    0,     // No flags
                    pControlArg,
                    (AssertionValue*)&pAttributes->value.vals->value);

            if(code) {
                data = LDAP_ATT_SUBSCHEMA_SUBENTRY;
                goto exit;
            }
        }
        NumDone++;
        pAttributes++;
    }
    
    // 3) Do the serverName value.
    if(fAllAtts || requestedAtts[LDAP_ATT_DS_SERVICE_NAME]) {

        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_DS_SERVICE_NAME];

        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        }
        else {
            // At this point, we should NOT have an open DB
            Assert(!pTHS->pDB);
            DBOpen2(TRUE,&pTHS->pDB);
            __try {
                // Get the truly current name of the DSA
                if (DBFindDSName(pTHS->pDB, gAnchor.pDSADN) ||
                            DBGetAttVal(pTHS->pDB,
                                        1,
                                        ATT_OBJ_DIST_NAME,
                                        0,
                                        0,
                                        &dirAttrVal.valLen,
                                        &dirAttrVal.pVal)) {

                    code = other;
                    __leave;
                }
                        
                // Cruft up some more locals for the call
                fakeAC.OMsyntax = OM_S_OBJECT;
                fakeAC.syntax = SYNTAX_DISTNAME_TYPE;

                pAttributes->value.vals =
                  (AttributeVals)THAllocEx(pTHS, sizeof(AttributeVals_));
                pAttributes->value.vals->next = NULL;
                code = LDAP_DirAttrValToAttrVal (
                                pTHS,
                                codePage,
                                &fakeAC,
                                &dirAttrVal,
                                0,      // no flags
                                pControlArg,
                                (AssertionValue*)&pAttributes->value.vals->value);

            } __finally {
                // Close the DB.
                DBClose(pTHS->pDB, TRUE);
            }

            if(code) {
                data = LDAP_ATT_DS_SERVICE_NAME;
                goto exit;
            }
        }
        
        NumDone++;
        pAttributes++;
    }

    // 4) Do the currentPropagation value.  
    if(requestedAtts[LDAP_ATT_PENDING_PROPAGATIONS]) {
        SDPropInfo *pInfo=NULL;
        
        // First, see if there are any values
        // At this point, we should NOT have an open DB
        Assert(!pTHS->pDB);
        DBOpen2(TRUE,&pTHS->pDB);
        __try {
            err = DBSDPropagationInfo(
                    pTHS->pDB,
                    pTHS->dwClientID,
                    &count,
                    &pInfo);
            if(err) {
                code = other;
                __leave;
            }
            
            if(count) {
                // OK, we have some
                pAttributes->next = &pAttributes[1];
                pAttributes->value.type =
                    RootDSEAtts[LDAP_ATT_PENDING_PROPAGATIONS]; 
                
                if(typesOnly) {
                    // Weird, but valid
                    pAttributes->value.vals = NULL;
                }
                else {
                    ULONG cbRet, len = 0;
                    CHAR *pName = NULL;
                    dirAttrVal.pVal = (PUCHAR)pName;
                    
                    pAttributes->value.vals =
                        (AttributeVals)THAllocEx(pTHS,
                                                 count* sizeof(AttributeVals_));
                    
                    pVals = pAttributes->value.vals;
                    
                    fakeAC.OMsyntax = OM_S_OBJECT;
                    fakeAC.syntax = SYNTAX_DISTNAME_TYPE;
                    
                    for(i=0;i<count;i++) {
                        pVals->next = &(pVals[1]);
                        
                        // Cruft up some locals for the call
                        
                        // First, position on the object
                        err = DBFindDNT(pTHS->pDB,pInfo[i].beginDNT);
                        if(err) {
                            code = other;
                            __leave;
                        }
                        
                        // Now read the name
                        err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                                          DBGETATTVAL_fREALLOC,
                                          len,
                                          &cbRet, (UCHAR **)&pName);
                        len = max(len, cbRet);
                        if(err) {
                            code = other;
                            __leave;
                        }
                        
                        // Finally, convert the DSNAME into an LDAP structure.
                        dirAttrVal.valLen = len;
                        
                        code = LDAP_DirAttrValToAttrVal (
                                pTHS,
                                codePage,
                                &fakeAC,
                                &dirAttrVal,
                                0,  // No flags
                                pControlArg,
                                (AssertionValue*)&pVals->value);
                        if(code) {
                            __leave;
                        }
                        pVals++;
                    }
                    pVals--;
                    pVals->next = NULL;
                    if (pName) {
                        THFreeEx(pTHS, pName);
                    }
                }
            
                NumDone++;
                pAttributes++;
            }
        }
        __finally {
            // Close the DB.
            DBClose(pTHS->pDB, TRUE);
        }

        if(code) {
            data = LDAP_ATT_PENDING_PROPAGATIONS;
            goto exit;
        }
    }
    
    // 5) Do the namingContexts value.
    if(fAllAtts || requestedAtts[LDAP_ATT_NAMING_CONTEXTS]) {

        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_NAMING_CONTEXTS];

        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        }
        else {
            // Count the number of naming contexts;
            count = 0;

            NCLEnumeratorInit(&nclEnum, CATALOG_MASTER_NC);
            while (NCLEnumeratorGetNext(&nclEnum)) {
                count++;
            }
            pAttributes->value.vals =
                (AttributeVals)THAllocEx(pTHS, count * sizeof(AttributeVals_));

            pVals = pAttributes->value.vals;

            fakeAC.OMsyntax = OM_S_OBJECT;
            fakeAC.syntax = SYNTAX_DISTNAME_TYPE;

            NCLEnumeratorReset(&nclEnum);
            while (pNCL = NCLEnumeratorGetNext(&nclEnum)) {
                pVals->next = &(pVals[1]);

                // Cruft up some locals for the call
                dirAttrVal.valLen = pNCL->pNC->structLen;
                dirAttrVal.pVal = (PUCHAR)pNCL->pNC;

                code = LDAP_DirAttrValToAttrVal (
                        pTHS,
                        codePage,
                        &fakeAC,
                        &dirAttrVal,
                        0, // No flags
                        pControlArg,
                        (AssertionValue*)&pVals->value);
                if(code) {
                    data = LDAP_ATT_NAMING_CONTEXTS;
                    goto exit;
                }
                pVals++;
            }
            pVals--;
            pVals->next = NULL;
        }

        NumDone++;
        pAttributes++;
    }

    // 6) Do the defaultNamingContext value.
    if(fAllAtts || requestedAtts[LDAP_ATT_DEFAULT_NAMING_CONTEXT]) {

        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_DEFAULT_NAMING_CONTEXT];
        
        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        }
        else {
            pAttributes->value.vals =
                (AttributeVals)THAllocEx(pTHS, sizeof(AttributeVals_));

            pVals = pAttributes->value.vals;
            pVals->next = NULL;

            fakeAC.OMsyntax = OM_S_OBJECT;
            fakeAC.syntax = SYNTAX_DISTNAME_TYPE;

            // Cruft up some locals for the call
            dirAttrVal.valLen = gAnchor.pDomainDN->structLen;
            dirAttrVal.pVal = (PUCHAR)gAnchor.pDomainDN;

            code = LDAP_DirAttrValToAttrVal (
                    pTHS,
                    codePage,
                    &fakeAC,
                    &dirAttrVal,
                    0,  // No flags
                    pControlArg,
                    (AssertionValue*)&pVals->value);
            if(code) {
                data = LDAP_ATT_DEFAULT_NAMING_CONTEXT;
                goto exit;
            }
        }

        NumDone++;
        pAttributes++;
    }

    
    // 7) Do the schemaNamingContext value.
    if(fAllAtts || requestedAtts[LDAP_ATT_SCHEMA_NC]) {

        pAttributes->next = &pAttributes[1];
        pAttributes->value.type =
            RootDSEAtts[LDAP_ATT_SCHEMA_NC];
        
        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        }
        else {
            pAttributes->value.vals =
                (AttributeVals)THAllocEx(pTHS, sizeof(AttributeVals_));

            pVals = pAttributes->value.vals;
            pVals->next = NULL;

            fakeAC.OMsyntax = OM_S_OBJECT;
            fakeAC.syntax = SYNTAX_DISTNAME_TYPE;

            // Cruft up some locals for the call
            dirAttrVal.valLen = gAnchor.pDMD->structLen;
            dirAttrVal.pVal = (PUCHAR)gAnchor.pDMD;

            code = LDAP_DirAttrValToAttrVal (
                    pTHS,
                    codePage,
                    &fakeAC,
                    &dirAttrVal,
                    0,  // No flags
                    pControlArg,
                    (AssertionValue*)&pVals->value);
            if(code) {
                data = LDAP_ATT_SCHEMA_NC;
                goto exit;
            }
        }

        NumDone++;
        pAttributes++;
    }

    // 8) Do the configNC value.
    if(fAllAtts || requestedAtts[LDAP_ATT_CONFIG_NC]) {

        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_CONFIG_NC];
        
        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        }
        else {
            pAttributes->value.vals =
                (AttributeVals)THAllocEx(pTHS, sizeof(AttributeVals_));

            pVals = pAttributes->value.vals;
            pVals->next = NULL;

            fakeAC.OMsyntax = OM_S_OBJECT;
            fakeAC.syntax = SYNTAX_DISTNAME_TYPE;

            // Cruft up some locals for the call
            dirAttrVal.valLen = gAnchor.pConfigDN->structLen;
            dirAttrVal.pVal = (PUCHAR)gAnchor.pConfigDN;

            code = LDAP_DirAttrValToAttrVal (
                    pTHS,
                    codePage,
                    &fakeAC,
                    &dirAttrVal,
                    0,  // No flags
                    pControlArg,
                    (AssertionValue*)&pVals->value);
            if(code) {
                data = LDAP_ATT_CONFIG_NC;
                goto exit;
            }
        }

        NumDone++;
        pAttributes++;
    }

    // 9) Do the RootDomainNC value.
    if(fAllAtts || requestedAtts[LDAP_ATT_ROOT_DOMAIN_NC]) {

        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_ROOT_DOMAIN_NC];
        
        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        }
        else {
            pAttributes->value.vals =
                (AttributeVals)THAllocEx(pTHS, sizeof(AttributeVals_));

            pVals = pAttributes->value.vals;
            pVals->next = NULL;

            fakeAC.OMsyntax = OM_S_OBJECT;
            fakeAC.syntax = SYNTAX_DISTNAME_TYPE;

            // Cruft up some locals for the call
            dirAttrVal.valLen = gAnchor.pRootDomainDN->structLen;
            dirAttrVal.pVal = (PUCHAR)gAnchor.pRootDomainDN;

            code = LDAP_DirAttrValToAttrVal (
                    pTHS,
                    codePage,
                    &fakeAC,
                    &dirAttrVal,
                    0,      // No flags
                    pControlArg,
                    (AssertionValue*)&pVals->value);
            if(code) {
                data = LDAP_ATT_ROOT_DOMAIN_NC;
                goto exit;
            }
        }

        NumDone++;
        pAttributes++;
    }

    // 10) Do the netlogon value.
    if(   gfRunningInsideLsa
       && LdapConn->m_fUDP
      && requestedAtts[LDAP_ATT_NETLOGON]) {
        
        *pRootDseFlag = rdseLdapPing;

        DWORD fOk = TRUE;
        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_NETLOGON];
        
        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        }
        else {
            PVOID Response=NULL;
            ULONG ResponseLen=0;
            DWORD ret;
            PVOID oldThreadState;

            //
            // Save the old thread state since this might call SAM
            // who in turn might get confused if we already have an
            // existing one.
            //
            
            oldThreadState = THSave( );
            Assert(oldThreadState != NULL);
            
            INC(pcLdapThreadsInNetlogon);
            // OK, call the security package
            __try {
                ret = dsI_NetLogonLdapLookupEx(
                        (PVOID)&(pSearchRequest->filter),
                        (PVOID)&LdapConn->m_RemoteSocket,
                        &Response,
                        &ResponseLen);
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                ret = STATUS_UNSUCCESSFUL;
            }
            
            DEC(pcLdapThreadsInNetlogon);
            if ( oldThreadState != NULL ) {
                THRestore(oldThreadState);
            }
            
            if(!SUCCEEDED(ret)) {
                
                data = LDAP_ATT_NETLOGON;
                err = ret;

                fOk = FALSE;
                IF_DEBUG(WARNING) {
                    if ( ret != STATUS_INVALID_PARAMETER) {
                        DPRINT1(0,"Call to dsI_NetLogonLdapLookupEx failed %x.\n", ret);
                    }
                }
                goto exit;
            }
            else {
                
                // Succeeded.  Copy into THAlloced memory.
                pAttributes->value.vals = 
                    (AttributeVals)THAllocEx(pTHS, 
                                             sizeof(AttributeVals_) + 
                                             PAD64(ResponseLen));

                pAttributes->value.vals->next = NULL;
                pAttributes->value.vals->value.value = (PUCHAR)
                    ALIGN64_ADDR(((PCHAR)pAttributes->value.vals + 
                                sizeof(AttributeVals_)));

                Assert(IS_ALIGNED64(pAttributes->value.vals->value.value));

                CopyMemory(
                       pAttributes->value.vals->value.value,
                       Response,
                       ResponseLen);

                dsI_NetLogonFree(Response);
                pAttributes->value.vals->value.length = ResponseLen;
            
                code = success;
            }
        }

        NumDone++;
        pAttributes++;
    }

    // 11) Do the supported controls value.
    if(fAllAtts || requestedAtts[LDAP_ATT_SUPPORTED_CONTROLS]) {
        
        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_SUPPORTED_CONTROLS];
        
        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        }
        else {
            pAttributes->value.vals = KnownControlCache.Buffer;
        }

        NumDone++;
        pAttributes++;
    }

    // 12) Do the supported version value.
    if(fAllAtts || requestedAtts[LDAP_ATT_SUPPORTED_VERSION]) {
        
        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_SUPPORTED_VERSION];
        
        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        }
        else {
            pAttributes->value.vals = LdapVersionCache.Buffer;
        }

        NumDone++;
        pAttributes++;
    }


    // 13) Do the supported limits
    if(fAllAtts || requestedAtts[LDAP_ATT_SUPPORTED_POLICIES]) {

        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_SUPPORTED_POLICIES];
        
        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        }
        else {
            pAttributes->value.vals = KnownLimitsCache.Buffer;
        }

        NumDone++;
        pAttributes++;
    }

    // 14) Do the highestCommittedUSN value.
    if(fAllAtts || requestedAtts[LDAP_ATT_HIGHEST_COMMITTED_USN]) {

        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_HIGHEST_COMMITTED_USN];
        
        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        }
        else {
            LONGLONG usnValue;

            pAttributes->value.vals =
                (AttributeVals)THAllocEx(pTHS, sizeof(AttributeVals_));

            pVals = pAttributes->value.vals;
            pVals->next = NULL;

            fakeAC.OMsyntax = OM_S_I8;

            // Cruft up some locals for the call
            dirAttrVal.valLen = sizeof(usnValue);
            dirAttrVal.pVal = (PUCHAR)&usnValue;
            usnValue = DBGetHighestCommittedUSN();

            code = LDAP_DirAttrValToAttrVal (
                    pTHS,
                    codePage,
                    &fakeAC,
                    &dirAttrVal,
                    0,  // No flags
                    pControlArg,
                    (AssertionValue*)&pVals->value);
            if(code) {
                data = LDAP_ATT_HIGHEST_COMMITTED_USN;
                return code;
            }
        }

        NumDone++;
        pAttributes++;
    }

    // 15) Do the supported SASL mechanism value.
    if(fAllAtts || requestedAtts[LDAP_ATT_SUPPORTED_SASL_MECHANISM]) {
        
        pAttributes->next = &pAttributes[1];
        pAttributes->value.type= RootDSEAtts[LDAP_ATT_SUPPORTED_SASL_MECHANISM];
        
        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        } else {
            pAttributes->value.vals = LdapSaslSupported.Buffer;
        }

        NumDone++;
        pAttributes++;
    }

    // 16) Do the DNS HOST NAME value.
    if(fAllAtts || requestedAtts[LDAP_ATT_DNS_HOST_NAME]) {
        
        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_DNS_HOST_NAME];
        
        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        } else {

            fakeAC.OMsyntax = OM_S_UNICODE_STRING;

            dirAttrVal.pVal = (PUCHAR)gAnchor.pwszHostDnsName;
            dirAttrVal.valLen = (wcslen(gAnchor.pwszHostDnsName) *
                                         sizeof(WCHAR));

            pAttributes->value.vals =
                        (AttributeVals)THAllocEx(pTHS, sizeof(AttributeVals_));
            pAttributes->value.vals->next = NULL;

            code = LDAP_DirAttrValToAttrVal (
                            pTHS,
                            codePage,
                            &fakeAC,
                            &dirAttrVal,
                            0,      // No flags
                            pControlArg,
                            (AssertionValue*)&pAttributes->value.vals->value);

            if ( code ) {
                data = LDAP_ATT_DNS_HOST_NAME;
                goto exit;
            }
        }

        NumDone++;
        pAttributes++;
    }

    // 17) Do the LDAP Service Name value.
    if((fAllAtts || requestedAtts[LDAP_ATT_LDAP_SERVICE_NAME]) &&
       gszLDAPServiceName) {
        
        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_LDAP_SERVICE_NAME];
        
        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        }
        else {

            //
            // Get the dns name of the domain.  The format of the value returned is
            // <dns name>:<kerberos principal name>
            //

            fakeAC.OMsyntax = OM_S_UNICODE_STRING;
            dirAttrVal.pVal = (PUCHAR)gAnchor.pwszRootDomainDnsName;
            dirAttrVal.valLen = wcslen((PWCHAR)dirAttrVal.pVal) * sizeof(WCHAR);

            pAttributes->value.vals = (AttributeVals)THAllocEx(pTHS, sizeof(AttributeVals_));
            pAttributes->value.vals->next = NULL;

            code = LDAP_DirAttrValToAttrVal (pTHS,
                                            codePage,
                                            &fakeAC,
                                            &dirAttrVal,
                                            0,      // No flags
                                            pControlArg,
                                            (AssertionValue*)&pAttributes->value.vals->value);
            
            if(code) {
                data = LDAP_ATT_LDAP_SERVICE_NAME;
                goto exit;
            }
            
            // OK, now grow the value and tack on the kerberos principal name.
            pAttributes->value.vals[0].value.value = (PUCHAR) THReAllocEx(
                    pTHS, 
                    pAttributes->value.vals[0].value.value,
                    (pAttributes->value.vals[0].value.length + 1 +
                     gulLDAPServiceName) );
            
            pAttributes->value.vals[0].value.value[
                    pAttributes->value.vals[0].value.length++] = ':';
            
            memcpy(
                   &pAttributes->value.vals[0].value.value[
                           pAttributes->value.vals[0].value.length],
                   gszLDAPServiceName,
                   gulLDAPServiceName);
            
            pAttributes->value.vals[0].value.length += gulLDAPServiceName;
            pAttributes->value.vals[0].next = NULL; 
        }

        NumDone++;
        pAttributes++;
    }

    // 18) Do the Approx DB load (i.e. size of DNT index)
    // only supported on DBG builds

#if DBG
    if(requestedAtts[LDAP_ATT_APPROX_DB_LOAD]) {
        
        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_APPROX_DB_LOAD];
        
        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        }
        else {
            DWORD indexSize=0;
            pAttributes->value.vals =
                (AttributeVals)THAllocEx(pTHS, 1 * sizeof(AttributeVals_)); 

            // At this point, we should NOT have an open DB.  Open one then get
            // the size of the DNT index.
            Assert(!pTHS->pDB);
            DBOpen2(TRUE,&pTHS->pDB);
            __try {
                if(DBSetCurrentIndex(pTHS->pDB, Idx_Dnt, NULL, FALSE) ||
                   DBMove(pTHS->pDB,FALSE,DB_MoveFirst)) {
                    code = other;
                }
                else {
                    // DBGetIndexSize can't return an error.
                    DBGetIndexSize(pTHS->pDB,&indexSize);
                    code = success;
                }
            }
            __finally {
                // Close the DB.
                DBClose(pTHS->pDB, TRUE);
            }

            if(code) {
                data = LDAP_ATT_APPROX_DB_LOAD;
                goto exit;
            }

            pAttributes->value.vals =
                (AttributeVals)THAllocEx(pTHS, sizeof(AttributeVals_));

            pVals = pAttributes->value.vals;
            pVals->next = NULL;

            fakeAC.OMsyntax = OM_S_INTEGER;
            
            // Cruft up some locals for the call
            dirAttrVal.valLen = sizeof(indexSize);
            dirAttrVal.pVal = (PUCHAR)&indexSize;

            code = LDAP_DirAttrValToAttrVal (
                    pTHS,
                    codePage,
                    &fakeAC,
                    &dirAttrVal,
                    0,       // No flags
                    pControlArg,
                    (AssertionValue*)&pVals->value);
            if(code) {
                data = LDAP_ATT_APPROX_DB_LOAD;
                goto exit;
            }
        }

        NumDone++;
        pAttributes++;
    }
#endif

    // 19) Do the serverName value.
    if(fAllAtts || requestedAtts[LDAP_ATT_SERVER_NAME]) {        

        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_SERVER_NAME];

        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        }
        else {
            // At this point, we should NOT have an open DB
            Assert(!pTHS->pDB);
            DBOpen2(TRUE,&pTHS->pDB);
            __try {
                // The the DN of the server (i.e. this machine).  We do that by
                // moving to the ds service object, then moving to it's parent,
                // which is the machine.  Then, get the truly current name of
                // the machine.
                if (DBFindDSName(pTHS->pDB, gAnchor.pDSADN) ||
                    DBFindDNT(pTHS->pDB, pTHS->pDB->PDNT)   ||
                    DBGetAttVal(pTHS->pDB,
                                1,
                                ATT_OBJ_DIST_NAME,
                                0,
                                0,
                                &dirAttrVal.valLen,
                                &dirAttrVal.pVal)) {

                    code = other;
                    __leave;
                }

                // Cruft up some more locals for the call
                fakeAC.OMsyntax = OM_S_OBJECT;
                fakeAC.syntax = SYNTAX_DISTNAME_TYPE;

                pAttributes->value.vals =
                  (AttributeVals)THAllocEx(pTHS, sizeof(AttributeVals_));
                pAttributes->value.vals->next = NULL;
                code = LDAP_DirAttrValToAttrVal(
                        pTHS,
                        codePage,
                        &fakeAC,
                        &dirAttrVal,
                        0,    // No flags
                        pControlArg,
                        (AssertionValue*)&pAttributes->value.vals->value);
                
            } __finally {
                // Close the DB.
                DBClose(pTHS->pDB, TRUE);
            }

            if(code) {
                data = LDAP_ATT_SERVER_NAME;
                goto exit;
            }
        }

        NumDone++;
        pAttributes++;
    }

    // 20) Do the supported version value.
    if(fAllAtts || requestedAtts[LDAP_ATT_SUPPORTED_CAPS]) {
        
        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_SUPPORTED_CAPS];
        
        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        } else {
            pAttributes->value.vals = LdapCapabilitiesCache.Buffer;
        }

        NumDone++;
        pAttributes++;
    }

    //21 do the schema attr count
    if(requestedAtts[LDAP_ATT_SCHEMA_ATTCOUNT]) {
        
        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_SCHEMA_ATTCOUNT];
        
        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        }
        else {
            pAttributes->value.vals = (AttributeVals)THAllocEx(pTHS, sizeof(AttributeVals_));
            
            pAttributes->value.vals->next = NULL;

            // allocate a big enough string.
            pAttributes->value.vals->value.value = (PUCHAR)THAllocEx(pTHS, MAX_NUM_STRING_LENGTH);
            sprintf((char *)pAttributes->value.vals->value.value,
                "%d",( SYNTAX_INTEGER )((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->nAttInDB );
            pAttributes->value.vals->value.length = strlen((const char *)pAttributes->value.vals->value.value);
        }

        NumDone++;
        pAttributes++;
    }
    
    //22 do the schema class count
    if(requestedAtts[LDAP_ATT_SCHEMA_CLSCOUNT]) {
        
        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_SCHEMA_CLSCOUNT];
        
        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        }
        else {
            pAttributes->value.vals = (AttributeVals)THAllocEx(pTHS, sizeof(AttributeVals_));
            
            pAttributes->value.vals->next = NULL;

            // allocate a big enough string.
            pAttributes->value.vals->value.value = (PUCHAR)THAllocEx(pTHS, MAX_NUM_STRING_LENGTH);
            sprintf((char *)pAttributes->value.vals->value.value,
                "%d",( SYNTAX_INTEGER )((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->nClsInDB );
            pAttributes->value.vals->value.length = strlen((const char *)pAttributes->value.vals->value.value);
        }

        NumDone++;
        pAttributes++;
    }

    //23 do the schema prefix count
    if(requestedAtts[LDAP_ATT_SCHEMA_PREFIXCOUNT]) {
        
        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_SCHEMA_PREFIXCOUNT];
        
        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        }
        else {
            pAttributes->value.vals = (AttributeVals)THAllocEx(pTHS, sizeof(AttributeVals_));
            
            pAttributes->value.vals->next = NULL;
            
            pAttributes->value.vals->value.value = (PUCHAR)THAllocEx(pTHS, MAX_NUM_STRING_LENGTH);
            sprintf((char *)pAttributes->value.vals->value.value,
                "%d",( SYNTAX_INTEGER )((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->PrefixTable.PrefixCount );
            pAttributes->value.vals->value.length = strlen((const char *)pAttributes->value.vals->value.value);
        }

        NumDone++;
        pAttributes++;
    }

    //24 do the is synchronized attribute
    // This indicates the writable partition checks have been completed and
    // the system is open for business to netlogon
    if(fAllAtts || requestedAtts[LDAP_ATT_IS_SYNCHRONIZED]) {
        
        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_IS_SYNCHRONIZED];
        
        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        }
        else {
            pAttributes->value.vals =
                (AttributeVals)THAllocEx(pTHS, sizeof(AttributeVals_));

            pVals = pAttributes->value.vals;
            pVals->next = NULL;

            fakeAC.OMsyntax = OM_S_BOOLEAN;

            // Cruft up some locals for the call
            dirAttrVal.valLen = sizeof(gfIsSynchronized);
            dirAttrVal.pVal = (PUCHAR)&gfIsSynchronized;

            code = LDAP_DirAttrValToAttrVal (
                    pTHS,
                    codePage,
                    &fakeAC,
                    &dirAttrVal,
                    0,  // No flags
                    pControlArg,
                    (AssertionValue*)&pVals->value);
            if(code) {
                data = LDAP_ATT_IS_SYNCHRONIZED;
                return code;
            }
        }

        NumDone++;
        pAttributes++;
    }

    //25 do the is gc ready attribute
    // I used the word ready here to suggest that a system could be marked as
    // a gc, but not ready yet.  This is actually the case.  A system is requested
    // for gc-ness using the server option.  The actually promotion process can
    // take some time, either immeidately after the option was set, or after system
    // boot.  On a non-GC system, this attribute is always false and never becomes
    // true.  To detect a system in transition, the server object gc option will
    // be true, but is gc ready will be false.
    if(fAllAtts || requestedAtts[LDAP_ATT_IS_GC_READY]) {
        
        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_IS_GC_READY];
        
        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        }
        else {
            pAttributes->value.vals =
                (AttributeVals)THAllocEx(pTHS, sizeof(AttributeVals_));

            pVals = pAttributes->value.vals;
            pVals->next = NULL;

            fakeAC.OMsyntax = OM_S_BOOLEAN;

            // Cruft up some locals for the call
            dirAttrVal.valLen = sizeof(gAnchor.fAmGC);
            dirAttrVal.pVal = (PUCHAR)&(gAnchor.fAmGC);

            code = LDAP_DirAttrValToAttrVal (
                    pTHS,
                    codePage,
                    &fakeAC,
                    &dirAttrVal,
                    0,  // No flags
                    pControlArg,
                    (AssertionValue*)&pVals->value);
            if(code) {
                data = LDAP_ATT_IS_GC_READY;
                return code;
            }
        }

        NumDone++;
        pAttributes++;
    }

    // 26) Do the supported configurable settings
    if(requestedAtts[LDAP_ATT_SUPPORTED_CONFIGURABLE_SETTINGS]) {
    
        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_SUPPORTED_CONFIGURABLE_SETTINGS];
    
        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        }
        else {
            pAttributes->value.vals = KnownConfSetsCache.Buffer;
        }
        
        NumDone++;
        pAttributes++;
    }
    
    // 27) Do the supported extensions value.
    if(requestedAtts[LDAP_ATT_SUPPORTED_EXTENSIONS]) {
        
        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_SUPPORTED_EXTENSIONS];
        
        if(typesOnly) {
            // Weird, but valid
            pAttributes->value.vals = NULL;
        }
        else {
            pAttributes->value.vals = KnownExtendedRequestsCache.Buffer;
        }

        NumDone++;
        pAttributes++;
    }


#ifndef REPL_REVERT
    DWORD dwReplIndex;
    dwReplIndex = LDAP_ATT_MSDS_REPLPENDINGOPS;
    if (requestedAtts[dwReplIndex]) {
        code = LDAP_GetReplDseAtts(pTHS, codePage, &bHasReplAccess,
                                   requestedAtts[dwReplIndex],
                                   &RootDSEAtts[dwReplIndex],
                                   ROOT_DSE_MS_DS_REPL_PENDING_OPS, 
                                   typesOnly, &NumDone, &pAttributes);
        if(code) {
            data = dwReplIndex;
            goto exit;
        }
    }

    dwReplIndex = LDAP_ATT_MSDS_REPLLINKFAILURES;
    if (requestedAtts[dwReplIndex]) {
        code = LDAP_GetReplDseAtts(pTHS, codePage, &bHasReplAccess,
                                   requestedAtts[dwReplIndex],
                                   &RootDSEAtts[dwReplIndex],
                                   ROOT_DSE_MS_DS_REPL_LINK_FAILURES, 
                                   typesOnly, &NumDone, &pAttributes);
        if(code) {
            data = dwReplIndex;
            goto exit;
        }
    }

    dwReplIndex = LDAP_ATT_MSDS_REPLCONNECTIONFAILURES;
    if (requestedAtts[dwReplIndex]) {
        code = LDAP_GetReplDseAtts(pTHS, codePage, &bHasReplAccess,
                                   requestedAtts[dwReplIndex],
                                   &RootDSEAtts[dwReplIndex],
                                   ROOT_DSE_MS_DS_REPL_CONNECTION_FAILURES, 
                                   typesOnly, &NumDone, &pAttributes);
        if(code) {
            data = dwReplIndex;
            goto exit;
        }
    }

    dwReplIndex = LDAP_ATT_MSDS_REPLALLINBOUNDNEIGHBORS;
    if (requestedAtts[dwReplIndex]) {
        code = LDAP_GetReplDseAtts(pTHS, codePage, &bHasReplAccess,
                                   requestedAtts[dwReplIndex],
                                   &RootDSEAtts[dwReplIndex],
                                   ROOT_DSE_MS_DS_REPL_ALL_INBOUND_NEIGHBORS,
                                   typesOnly, &NumDone, &pAttributes);
        if(code) {
            data = dwReplIndex;
            goto exit;
        }
    }        

    dwReplIndex = LDAP_ATT_MSDS_REPLALLOUTBOUNDNEIGHBORS;
    if (requestedAtts[dwReplIndex]) {
        code = LDAP_GetReplDseAtts(pTHS, codePage, &bHasReplAccess,
                                   requestedAtts[dwReplIndex],
                                   &RootDSEAtts[dwReplIndex],
                                   ROOT_DSE_MS_DS_REPL_ALL_OUTBOUND_NEIGHBORS,
                                   typesOnly, &NumDone, &pAttributes);
        if(code) {
            data = dwReplIndex;
            goto exit;
        }
    }        

    dwReplIndex = LDAP_ATT_MSDS_REPLQUEUESTATISTICS;
    if (requestedAtts[dwReplIndex]) {
        code = LDAP_GetReplDseAtts(pTHS, codePage, &bHasReplAccess,
                                   requestedAtts[dwReplIndex],
                                   &RootDSEAtts[dwReplIndex],
                                   ROOT_DSE_MS_DS_REPL_QUEUE_STATISTICS,
                                   typesOnly, &NumDone, &pAttributes);
        if(code) {
            data = dwReplIndex;
            goto exit;
        }
    }        
#endif


    // domain behavior version
    if(fAllAtts || requestedAtts[LDAP_ATT_DOMAIN_BEHAVIOR_VERSION]) {
        
        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_DOMAIN_BEHAVIOR_VERSION];
        
        pAttributes->value.vals = (AttributeVals)THAllocEx(pTHS, sizeof(AttributeVals_));
            
        pAttributes->value.vals->next = NULL;
            
        pAttributes->value.vals->value.value = (PUCHAR)THAllocEx(pTHS, MAX_NUM_STRING_LENGTH);
        sprintf((char *)pAttributes->value.vals->value.value,
                "%d",( SYNTAX_INTEGER )gAnchor.DomainBehaviorVersion );
        pAttributes->value.vals->value.length = strlen((const char *)pAttributes->value.vals->value.value);

        NumDone++;
        pAttributes++;
    }

    // forest behavior version
    if(fAllAtts || requestedAtts[LDAP_ATT_FOREST_BEHAVIOR_VERSION]) {
        
        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_FOREST_BEHAVIOR_VERSION];
        
        pAttributes->value.vals = (AttributeVals)THAllocEx(pTHS, sizeof(AttributeVals_));
            
        pAttributes->value.vals->next = NULL;
            
        pAttributes->value.vals->value.value = (PUCHAR)THAllocEx(pTHS, MAX_NUM_STRING_LENGTH);
        sprintf((char *)pAttributes->value.vals->value.value,
                "%d",( SYNTAX_INTEGER )gAnchor.ForestBehaviorVersion );
        pAttributes->value.vals->value.length = strlen((const char *)pAttributes->value.vals->value.value);

        NumDone++;
        pAttributes++;
    }

    // dc behavior version
    if(fAllAtts || requestedAtts[LDAP_ATT_DC_BEHAVIOR_VERSION]) {
        
        pAttributes->next = &pAttributes[1];
        pAttributes->value.type = RootDSEAtts[LDAP_ATT_DC_BEHAVIOR_VERSION];
        
        pAttributes->value.vals = (AttributeVals)THAllocEx(pTHS, sizeof(AttributeVals_));
            
        pAttributes->value.vals->next = NULL;
            
        pAttributes->value.vals->value.value = (PUCHAR)THAllocEx(pTHS, MAX_NUM_STRING_LENGTH);
        sprintf((char *)pAttributes->value.vals->value.value,
                "%d",( SYNTAX_INTEGER )DS_BEHAVIOR_VERSION_CURRENT );
        pAttributes->value.vals->value.length = strlen((const char *)pAttributes->value.vals->value.value);

        NumDone++;
        pAttributes++;
    }



    if(NumDone) {
        // We did at least some.
        pSearchRes->value.u.entry.attributes[NumDone - 1].next = NULL;
    }
    else {
        // Didn't actually have any attributes for them.
        // THFree(pSearchRes->value.u.entry.attributes);
        pSearchRes->value.u.entry.attributes = NULL;
    }
    *ppSearchResult = pSearchRes;

exit:

    if ( code != success ) {
        Assert(err != ERROR_SUCCESS);
        (VOID) SetLdapError(code,
                            err,
                            LdapBadRootDse,
                            data,
                            pErrorMessage);
    }

    return code;

} //LDAP_GetDSEAtts

_enum1
LDAP_GetReplDseAtts(
    IN THSTATE * pTHS, 
    IN ULONG CodePage,
    IN OUT BOOL * pbHasReplAccess,
    IN AttributeType *patTypeName,
    IN AttributeType *patBaseTypeName,
    IN DWORD dwAttrId, 
    IN BOOL bTypesOnly,
    OUT ULONG * pNumDone,
    IN OUT PartialAttributeList * ppAttributes
    )

/*++

Routine Description:

  LDAP_GetDSEAtts is optimized for speed and hence much of the book keeping is exposed
  to each root attribute. All this book keeping is consolidated here for the replication
  root DSE attributes. 
  
  LDAP_GetDSEAtts stores attributes in a linked list. Each attribute link points to another
  linked list which contains each value of a multivalue. This function handles the creation
  and linking of these two lists. 

  Asserts the user has RIGHT_DS_REPL_MANAGE_TOPOLOGY. (FYI IsDraAccessGranted opens a
  DB context.)


Arguments:

  pTHS - we allocate data to be referanced by a link list

  CodePage - shuttled to LDAP_DirAttrValToAttrVal

  pbHasReplAccess - caches the result of an access check. If this is false then no 
    access check has been made. Set it to true if the user has access. If the user
    doesn't have access return an error code. This will short circuit LDAP_GetDseAtts 
    and bypass constructing any more requested root attributes.

  patTypeName - The name of the type as requested by the user, with options

  patBaseTypeName - The name of the type without options

  attrId - The spoofed ATTRID of the replication attribute. It is "spoofed" because,
    as of the time of this writing, they were not defined in <attids.h>. 
    attrId is passed to Repl_XXX functions to get information about the attribute.

  bTypesOnly - if true the no data is returned for the attribute

  pNumDone - a book keeping variable passed in from LDAP_GetDSEAtts which is 
    incremented once if the user has sufficient access rights to retrieve the repl info.

  ppAttributes - the ppAttributes is a pointer to LDAP_GetDSEAtts pointer to a linked
    list where attributes are chained together. The list is allocated in a contiguous 
    block of memory. Each attribute is responsible for chaining its link to the next.

  
Return values:

    insufficientAccessRights 
    success
    other if a required pointer is NULL
  
--*/
{
    Assert(ARGUMENT_PRESENT(pTHS) &&
           ARGUMENT_PRESENT(ppAttributes) &&
           ARGUMENT_PRESENT(pNumDone));

    ATTR attr;
    DWORD i, err = 0;
    _enum1 retErr = success;
    AttributeVals * ppVals = NULL, pVals = NULL;
    PartialAttributeList pAttributes;
    ATTFLAG attFlag;
    RANGEINFSEL rangeInfSel;
    RANGEINFOITEM rangeInfoItem = { 0 };
    DWORD dwStartIndex, dwNumValues;
    BOOL fRangeDefaulted;
    ATTCACHE fakeAC;

    fakeAC.id = dwAttrId;
    fakeAC.OMsyntax = OM_S_UNICODE_STRING;

    pAttributes = *ppAttributes;

    Assert( pbHasReplAccess);

    // Verify the caller has the access required to retrieve this information.
    if (!(*pbHasReplAccess))
    {
        DSNAME * pAccessCheckDN = gAnchor.pDomainDN;
        if (!IsDraAccessGranted(pTHS, pAccessCheckDN, &RIGHT_DS_REPL_MANAGE_TOPOLOGY, &err)) 
        {
            DPRINT(1, "ACCESS DENIED\n");
            retErr = insufficientAccessRights;
            goto exit;
        }
        else
        {
            *pbHasReplAccess = TRUE;
        }
    }

    // Check for options
    rangeInfSel.valueLimit = DEFAULT_VALUE_LIMIT;
    rangeInfSel.count = 0;
    rangeInfSel.pRanges = &rangeInfoItem;
    
    retErr = LDAP_DecodeAttrDescriptionOptions(
        pTHS,
        CodePage,
        NULL, // svccntl,
        patTypeName,
        &dwAttrId,
        &fakeAC,
        ATT_OPT_ALL,
        &attFlag,
        &rangeInfSel,
        NULL
        );
    if (retErr != success) {
        goto exit;
    }

    DBGetValueLimits( 
        &fakeAC,
        &rangeInfSel,
        &dwStartIndex,
        &dwNumValues,
        &fRangeDefaulted
        );

    // We should always have a value limit
    Assert( dwNumValues != 0xffffffff );

    // If an explicit range was provided, it should have been used
    Assert( (!(attFlag.flag & ATT_OPT_RANGE)) || !fRangeDefaulted );

    // User only wanted types
    if (bTypesOnly)
    {
        // Weird, but valid
        pAttributes->value.vals = NULL;
    }
    else
    {
        // Get the data
        INC(pcLdapThreadsInDra);
        err = draGetLdapReplInfo(pTHS, dwAttrId, NULL, dwStartIndex, &dwNumValues, !(attFlag.flag & ATT_OPT_BINARY), &attr);
        DEC(pcLdapThreadsInDra);
        if (err)
        {
            if (DB_ERR_NO_VALUE == err)
            {
                retErr = success;
                goto exit;
            } 
            else
            {
                DPRINT(1, "draGetLdapReplInfo returned an error unknown to LDAP_GetReplDseAtts\n");
                retErr = other;
                goto exit;
            }
        }

        // Allocate a link for every multi-value and link it to the previous link
        DPRINT1(1, " LDAP_GetReplDseAtts - %d from draGetLdapReplInfo. \n", attr.AttrVal.valCount)
        ppVals = &(pAttributes->value.vals);
        for (i = 0; i < attr.AttrVal.valCount; i ++)
        {
            (*ppVals) = NULL;
            *ppVals = (AttributeVals)THAllocEx(pTHS, sizeof(AttributeVals_));
            if (!*ppVals)
                return other;
            ppVals = &(*ppVals)->next;
        }
        (*ppVals) = NULL;

        // Store the results in the links
        DPRINT(1, " LDAP_GetReplDseAtts - Attr to AttriubeVals \n")
        pVals = pAttributes->value.vals;
        for (i = 0; i < attr.AttrVal.valCount; i ++)
        {
            Assert(pVals);

            // Store the result in a link
            pVals->value.length = attr.AttrVal.pAVal[i].valLen;
            pVals->value.value = attr.AttrVal.pAVal[i].pVal;
            DPRINT1(1, "LDAP link value length %d \n", pVals->value.length);

            // Convert the values 
            if (! (attFlag.flag & ATT_OPT_BINARY)) {
                LDAP_DirAttrValToAttrVal(
                    pTHS, 
                    CodePage, 
                    &fakeAC, 
                    &attr.AttrVal.pAVal[i], 
                    attFlag.flag,
                    NULL, 
                    (AssertionValue*)&pVals->value);
            }
            else {
                pVals->value.length = attr.AttrVal.pAVal[i].valLen;
                pVals->value.value = attr.AttrVal.pAVal[i].pVal;
            }

            pVals = pVals->next;
        }
        Assert(!pVals);

        DPRINT(1, " LDAP_GetReplDseAtts - Conversion compleate \n")
    }
    
    // LDAP_GetDSEAtts attribute link list book keeping
    pAttributes->next = &pAttributes[1];


    // If the caller did not request a range, but not all data was returned,
    // generate a range for him.
    // ISSUE: In this case, the attribute returned will be different from the
    // attribute that was requested. Is this a concern?
    if ( ((attFlag.flag & ATT_OPT_RANGE) == 0) &&
         (dwNumValues != 0xffffffff) ) {
        attFlag.flag |= ATT_OPT_RANGE;
    }

    // Generate the output attribute type name
    if (attFlag.flag) {
        if (attFlag.flag & ATT_OPT_RANGE) {
            // The output range may have been updated as a result of the call
            rangeInfoItem.lower = dwStartIndex;
            rangeInfoItem.upper = dwNumValues;
        }

        // Some options were used
        LDAP_BuildAttrDescWithOptions(
            pTHS,
            patBaseTypeName,
            &attFlag,
            &rangeInfoItem,
            &pAttributes->value.type
            );
    } else {
        // No options
        pAttributes->value.type = *patBaseTypeName;
    }

    (*pNumDone)++;
    (*ppAttributes)++;

exit:
    return retErr;
}


_enum1
LDAP_MakeSimpleBindParams(
        IN  ULONG  CodePage,
        IN  LDAPDN *pStringName,
        IN  LDAPString *pPassword,
        OUT SEC_WINNT_AUTH_IDENTITY_A *pCredentials
        )
/*++
Routine Description:
    Translate an LDAPDN in the connections code page to a string DN in Unicode.

Arguments:
    pStringName - pointer to the ldapdn
    pCredentials - pointer to the security structure to fill in.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    WCHAR *pwcTemp;
    ULONG  Size;
    
    pCredentials->Domain = NULL;
    pCredentials->DomainLength = 0;

    // OK, convert to Unicode. The 1 here is for the NULL I'm going to add.
    pwcTemp = (WCHAR *)THAlloc((pStringName->length + 1) * sizeof(WCHAR));
    if(!pwcTemp) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return other;
    }
    
    pCredentials->User = (PUCHAR)pwcTemp;
    
    if(!pStringName->length) {
        // Actually, no DN was passed in.  Just set up the params to a 0 length
        //string. 
        Size = 0;
    }
    else {

        // Translate to Unicode.  Size gets set to the number of unicode chars
        // returned by MultiByteToWideChar.
        Size = MultiByteToWideChar(CodePage,
                                   0,
                                   (const char *)pStringName->value,
                                   pStringName->length,
                                   pwcTemp,
                                   pStringName->length);
        if(!Size) { 
            Assert(ERROR_INSUFFICIENT_BUFFER == GetLastError());
            SetLastError(ERROR_INVALID_PARAMETER);
            // They gave us a string that was too long.
            return other;
        }
    }
    // Tack a NULL onto the end
    pwcTemp[Size] = 0;
    pCredentials->UserLength = Size;
    
    // Now the password
    pwcTemp = (WCHAR *)THAlloc((pPassword->length + 1) * sizeof(WCHAR));
    if(!pwcTemp) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return other;
    }
    
    pCredentials->Password = (PUCHAR)pwcTemp;
    
    if(!pPassword->length) {
        Size = 0;
    }
    else {
        Size = MultiByteToWideChar(CodePage,
                                   0,
                                   (const char *)pPassword->value,
                                   pPassword->length,
                                   (WCHAR *)pCredentials->Password,
                                   pPassword->length);
        if(!Size) {
            Assert(ERROR_INSUFFICIENT_BUFFER == GetLastError());
            SetLastError(ERROR_INVALID_PARAMETER);
            // They gave us a string that was too long.
            return other;
        }
    }
    pwcTemp[Size]=0;
    pCredentials->PasswordLength = Size;


    return success;
}


extern _enum1
LDAP_ModificationListToOpArg (
        IN  ULONG             CodePage,
        IN  ModificationList  pModification,
        OUT OPARG             **ppOpArg
        )
/*++
Routine Description:
    Translate an LDAP modification list to a dir operational control.

Arguments:
    pAttributes - the LDAP modification list.
    pppOpArrg - the dir OpArg.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    DWORD i;
    
    if(!pModification                         ||
        // Hey!, no modifications!  This won't work.
       pModification->next                    ||
        // Hey!, too many modifications!  This won't work.
       (pModification->value.operation != add  &&
        pModification->value.operation != replace ) ||
       // We only do adds.
       !pModification->value.modification.vals ||
       // We don't support mods w/out values.
       pModification->value.modification.vals->next) {
        // We only support single values
        return unwillingToPerform;
    }

    // See if the attribute is one we understand
    for(i=0;i<numKnownRootDSEMods;i++) {
        if(EQUAL_LDAP_STRINGS(KnownRootDSEMods[i].name,
                              pModification->value.modification.type)) {
            *ppOpArg =
                (OPARG *)THAlloc(sizeof(OPARG));
            if(!(*ppOpArg))
                return other;
            (*ppOpArg)->eOp = KnownRootDSEMods[i].eOp;
            (*ppOpArg)->cbBuf = 
                pModification->value.modification.vals->value.length;
            (*ppOpArg)->pBuf = 
                (char *)pModification->value.modification.vals->value.value;
            return success;
        }
    }

    // We failed.
    return unwillingToPerform;
} // LDAP_ModificationListToOpArg


BOOL
InitializeCache(
            VOID
            )
{

    INT i;
    AttributeVals pVals;

    pVals = (AttributeVals)LdapAlloc( sizeof(AttributeVals_) *
                            (NUM_KNOWNCONTROLS +    // ldap controls
                            NUM_KNOWNLIMITS    +    // ldap limits
                            NUM_SUPPORTED_CAPS +    // capabilities
                            2                  +    // version
                            NUM_SASL_MECHS     +    // SASL supported
                            NUM_KNOWNCONFSETS  +    // configurable settings
                            NUM_EXTENDED_REQUESTS   // Extensions
                            ));

    if ( pVals == NULL ) {
        DPRINT(0,"Unable to allocate memory for attrval cache\n");
        return FALSE;
    }

    LdapAttrCache = pVals;

    //
    // Known controls
    //

    KnownControlCache.Buffer = pVals;

    for(i=0;i<NUM_KNOWNCONTROLS; i++) {

        pVals->next = &(pVals[1]);
        
        pVals->value.length = KnownControls[i].length;
        pVals->value.value = KnownControls[i].value;
        KnownControlCache.Size += pVals->value.length;
        pVals++;
    }
    pVals--;
    pVals->next = NULL;
    pVals++;

    //
    // Known Limits
    //

    Assert(pVals == &LdapAttrCache[NUM_KNOWNCONTROLS]);
    KnownLimitsCache.Buffer = pVals;

    for(i=0;i<NUM_KNOWNLIMITS; i++) {

        pVals->next = &(pVals[1]);
        
        pVals->value.length = KnownLimits[i].Name.length;
        pVals->value.value = KnownLimits[i].Name.value;
        KnownLimitsCache.Size += pVals->value.length;
        pVals++;
    }
    pVals--;
    pVals->next = NULL;
    pVals++;

    //
    // Version
    //

    Assert(pVals == &LdapAttrCache[NUM_KNOWNCONTROLS+NUM_KNOWNLIMITS]);
    LdapVersionCache.Buffer = pVals;

    pVals->value.length = LDAP_VERSION_THREE.length;
    pVals->value.value = LDAP_VERSION_THREE.value;
    LdapVersionCache.Size = pVals->value.length;

    pVals->next = (pVals+1);
    pVals++;

    pVals->value.length = LDAP_VERSION_TWO.length;
    pVals->value.value = LDAP_VERSION_TWO.value;
    LdapVersionCache.Size += pVals->value.length;
    pVals->next = NULL;
    pVals++;

    //
    // Capabilities
    //

    Assert(pVals == &LdapAttrCache[NUM_KNOWNCONTROLS+NUM_KNOWNLIMITS+2]);

    LdapCapabilitiesCache.Buffer = pVals;

    for(i=0;i<NUM_SUPPORTED_CAPS; i++) {

        pVals->next = &(pVals[1]);
        
        pVals->value.length = SupportedCapabilities[i].length;
        pVals->value.value = SupportedCapabilities[i].value;
        LdapCapabilitiesCache.Size += pVals->value.length;
        pVals++;
    }
    pVals--;
    pVals->next = NULL;
    pVals++;
    
    //
    // SASL
    //

    Assert(pVals == &LdapAttrCache[NUM_KNOWNCONTROLS+NUM_KNOWNLIMITS+2+NUM_SUPPORTED_CAPS]);
    LdapSaslSupported.Buffer = pVals;
    pVals->value.length = LDAP_SASL_GSSAPI.length;
    pVals->value.value = LDAP_SASL_GSSAPI.value;
    LdapSaslSupported.Size = pVals->value.length;

    pVals->next = (pVals+1);
    pVals++;

    pVals->value.length = LDAP_SASL_SPNEGO.length;
    pVals->value.value = LDAP_SASL_SPNEGO.value;
    LdapSaslSupported.Size += pVals->value.length;

    pVals->next = (pVals+1);
    pVals++;

    pVals->value.length = LDAP_SASL_EXTERNAL.length;
    pVals->value.value = LDAP_SASL_EXTERNAL.value;
    LdapSaslSupported.Size += pVals->value.length;

    pVals->next = (pVals+1);
    pVals++;

    pVals->value.length = LDAP_SASL_DIGEST.length;
    pVals->value.value = LDAP_SASL_DIGEST.value;
    LdapSaslSupported.Size += pVals->value.length;

    pVals->next = NULL;
    pVals++;
    
    //
    // Known Configurable Settings
    //

    Assert(pVals == &LdapAttrCache[NUM_KNOWNCONTROLS+NUM_KNOWNLIMITS+2+NUM_SUPPORTED_CAPS+NUM_SASL_MECHS]);
    KnownConfSetsCache.Buffer = pVals;

    for(i=0;i<NUM_KNOWNCONFSETS; i++) {

        pVals->next = &(pVals[1]);

        pVals->value.length = KnownConfSets[i].Name.length;
        pVals->value.value = KnownConfSets[i].Name.value;
        KnownConfSetsCache.Size += pVals->value.length;
        pVals++;
    }
    pVals--;
    pVals->next = NULL;
    pVals++;

    //
    // Extensions
    //

    Assert(pVals == &LdapAttrCache[NUM_KNOWNCONTROLS+NUM_KNOWNLIMITS+2+NUM_SUPPORTED_CAPS+NUM_SASL_MECHS+NUM_KNOWNCONFSETS]);
    KnownExtendedRequestsCache.Buffer = pVals;

    for(i=0;i<NUM_EXTENDED_REQUESTS; i++) {

        pVals->next = &(pVals[1]);

        pVals->value.length = KnownExtendedRequests[i].length;
        pVals->value.value = KnownExtendedRequests[i].value;
        KnownExtendedRequestsCache.Size += pVals->value.length;
        pVals++;
    }
    pVals--;
    pVals->next = NULL;
    pVals++;


    return TRUE;

} // InitializeCache
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\ldap\init.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    init.cxx

Abstract:

    This module implements the LDAP server for the NT5 Directory Service.

    This file contains initialisation and shutdown support.

Author:

    Colin Watson     [ColinW]    09-Jul-1996

Revision History:

--*/

#include <NTDSpchx.h>
#pragma  hdrstop

#include "ldapsvr.hxx"
#include <schnlsp.h>
#include <ntsecapi.h>

#define  FILENO FILENO_LDAP_INIT

CredHandle hCredential;
CredHandle hNtlmCredential;
CredHandle hDpaCredential;
CredHandle hGssCredential;
CredHandle hSslCredential;
CredHandle hDigestCredential;

BOOL fhCredential=FALSE;
BOOL fhNtlmCredential=FALSE;
BOOL fhDpaCredential=FALSE;
BOOL fhGssCredential=FALSE;
BOOL fhSslCredential=FALSE;
BOOL fhDigestCredential=FALSE;

BOOL LdapStarted = FALSE;
LARGE_INTEGER LdapFrequencyConstant;

//
// This is a flag used to tell us whether we need to log an event or not.
//

BOOL fLoggedSslCredError = FALSE;


NTSTATUS
InitFailed(
    char *              ProviderName,
    NTSTATUS            Status,
    int                 State
    );

extern "C"
NTSTATUS
DoLdapInitialize(
    )
/*++

Routine Description:

    This routine initialises the LDAP Agent. It assumes that Atq is initialized.

Arguments:

    None

Return Value:

    NTSTATUS

--*/
{

    SECURITY_STATUS scRet;
    TimeStamp expirytime;

    SSL_CREDENTIAL_CERTIFICATE creds;
    UNICODE_STRING *  SecretValue[3];
    INT i;

    //
    // Get the frequency for performance counting
    //

    QueryPerformanceFrequency(&LdapFrequencyConstant);

    LdapFrequencyConstant.QuadPart = (LdapFrequencyConstant.QuadPart/ 1000);

    //
    // Start up ATQ
    //

    DPRINT(0, "Calling AtqInitialize\n");
    if (!AtqInitialize( 0 )) {

        DPRINT1(0,"AtqInitialize failed %d\n", GetLastError());
        return(STATUS_UNSUCCESSFUL);
    }

    //
    // Initialize globals
    //

    (VOID)InitializeGlobals();

    //
    // Set ATQ properties
    //

    {
        DWORD_PTR   old;
        old = AtqSetInfo(AtqMaxPoolThreads,LdapAtqMaxPoolThreads);
        IF_DEBUG(INIT){
            DPRINT2(0,"Setting ATQ MaxPoolThread to %d[%d]\n",
                    LdapAtqMaxPoolThreads,(DWORD)old);
        }
        AtqSetInfo2(AtqUpdatePerfCounterCallback, (DWORD_PTR)UpdateDSPerfStats);
    }

    // Get the plain text credential handle
    scRet = AcquireCredentialsHandleA(  NULL,       // My name (ignored)
                                "PWDSSP",           // Package
                                SECPKG_CRED_INBOUND,// Use
                                NULL,               // Logon Id (ign.)
                                NULL,               // auth data
                                NULL,               // dce-stuff
                                NULL,               // dce-stuff
                                &hCredential,       // Handle
                                NULL );

    if ( FAILED( scRet )) {
        // We don't have a simple-authentication provider
        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_LDAP_SIMPLE_WARNING,
                 NULL, NULL, NULL);
    } else {
        fhCredential = TRUE;
    }

    // Get the NTLM credential handle
    scRet = AcquireCredentialsHandleA(
            NULL,                       // My name (ignored)
            "NTLM",                     // Package
            SECPKG_CRED_INBOUND,        // Use
            NULL,                       // Logon Id (ign.)
            NULL,                       // auth data
            NULL,                       // dce-stuff
            NULL,                       // dce-stuff
            &hNtlmCredential,           // Handle
            &expirytime );

    if ( FAILED( scRet )) {
        // We don't have a NTLM provider
        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_LDAP_NTLM_WARNING,
                 NULL, NULL, NULL);
    }
    else {
        fhNtlmCredential = TRUE;
    }
    // Get the DPA text credential handle
    scRet = AcquireCredentialsHandleA(  NULL,       // My name (ignored)
                                "DPA",             // Package
                                SECPKG_CRED_INBOUND,// Use
                                NULL,               // Logon Id (ign.)
                                NULL,               // auth data
                                NULL,               // dce-stuff
                                NULL,               // dce-stuff
                                &hDpaCredential,       // Handle
                                NULL );

    if ( SUCCEEDED( scRet )) {
        IF_DEBUG(WARNING) {
            DPRINT1(0,"Cannot initialize DPA Authentication.Err %x\n",scRet);
        }
        fhDpaCredential = TRUE;
    }

    // Now the negotiate package
    scRet = AcquireCredentialsHandleA(  NULL,       // My name (ignored)
                                "Negotiate",        // Package
                                SECPKG_CRED_INBOUND,// Use
                                NULL,               // Logon Id (ign.)
                                NULL,               // auth data
                                NULL,               // dce-stuff
                                NULL,               // dce-stuff
                                &hGssCredential,    // Handle
                                &expirytime );

    if ( FAILED( scRet )) {
        // We don't have a Negotiate provider
        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_LDAP_NEGOTIATE_WARNING,
                 NULL, NULL, NULL);
    }
    else {
        fhGssCredential = TRUE;
    }

    // Now the Digest package
    scRet = AcquireCredentialsHandleA(  NULL,            // My name (ignored)
                                "wdigest", // MICROSOFT_DIGEST_NAME_A, // Package
                                SECPKG_CRED_INBOUND,     // Use
                                NULL,                    // Logon Id (ign.)
                                NULL,                    // auth data
                                NULL,                    // dce-stuff
                                NULL,                    // dce-stuff
                                &hDigestCredential,      // Handle
                                &expirytime );

    if ( FAILED( scRet )) {
        // We don't have a Digest provider
        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_LDAP_DIGEST_WARNING,
                 NULL, NULL, NULL);
    }
    else {
        fhDigestCredential = TRUE;
    }

    //
    // Create a server config object and load values from registry.
    //

    LdapStarted = TRUE;
    if (!InitializeConnections() ) {
        LdapStarted = FALSE;
        return InitFailed("InitializeConnections", STATUS_UNSUCCESSFUL, 3);
    }

    return STATUS_SUCCESS;

} // DoLdapInitialize


extern "C"
VOID
DoCredentialShutdown(
        )
{
    ACQUIRE_LOCK(&LdapSslLock);
    if(fhSslCredential) {
        FreeCredentialsHandle(&hSslCredential);
        fhSslCredential = FALSE;
    }
    RELEASE_LOCK(&LdapSslLock);

    if(fhGssCredential) {
        FreeCredentialsHandle(&hGssCredential);
        fhGssCredential = FALSE;
    }
    if(fhCredential) {
        FreeCredentialsHandle(&hCredential);
        fhCredential = FALSE;
    }
    if(fhNtlmCredential) {
        FreeCredentialsHandle(&hNtlmCredential);
        fhNtlmCredential = FALSE;
    }
    if(fhDpaCredential) {
        FreeCredentialsHandle(&hDpaCredential);
        fhDpaCredential = FALSE;
    }
    if(fhDigestCredential) {
        FreeCredentialsHandle(&hDigestCredential);
        fhDigestCredential = FALSE;
    }

    return;
} // DoCredentialShutdown


NTSTATUS
InitFailed(
    char *              ProviderName,
    NTSTATUS            Status,
    int                 State
           )
/*++
    Description:

        Reports that DoLdapInitialize Failed and cleans up

    Arguments:

        ProviderName - Supplies the provider name we failed to load
        Status - The reason we failed
        State - How much cleanup is required

    Returns:
        Status as a convenience to the caller.

--*/
{
    if (ProviderName) {
        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_LDAP_SSP_ERROR,
            szInsertSz(ProviderName),
            szInsertHex(0),
            NULL);
    } else {
         LogUnhandledError(Status);
    }

    DoCredentialShutdown();

    return(Status);
}

extern "C"
VOID
TriggerLdapStop(
    )
/*++

Routine Description:

    This routine stops the LDAP Agent. It assumes that Atq is still running.

Arguments:

    None

Return Value:

    None

--*/
{
    IF_DEBUG(INIT) {
        DPRINT(0,,"TriggerLdapStop entered.\n");
    }

    if (!LdapStarted) {
        return;
    }

    CloseConnections();

    return;
} // TriggerLdapStop

extern "C"
VOID
WaitLdapStop(
    )
/*++

Routine Description:

    This routine stops the LDAP Agent. It assumes that Atq is still running.

Arguments:

    None

Return Value:

    None

--*/
{
    IF_DEBUG(INIT) {
        DPRINT(0,"Shutting down LDAP...\n");
    }

    if (!LdapStarted) {
        return;
    }

    LdapStarted = FALSE;

    ShutdownConnections();

    DoCredentialShutdown();

    //
    // Terminate ATQ
    //

    if (!AtqTerminate()) {
        DPRINT1(0,"AtqTerminate failed with %d\n",GetLastError());
    }

    //
    // Cleanup global variables
    //

    DestroyGlobals();

    return;
} // DoLdapStop



BOOL
InitializeSSL(
    VOID
    )
/*++

Routine Description:

    This routine attempts to initialize SSL

Arguments:

    None

Return Value:

    TRUE if initialization successful, FALSE otherwise

--*/
{

    SECURITY_STATUS secStatus;
    TimeStamp   expiry;
    BOOL fRet = TRUE;
    BOOL fLogEvent = FALSE;
    DWORD mid = 0;

    //
    // Should be single threaded
    //

    ACQUIRE_LOCK(&LdapSslLock);
    if ( fhSslCredential ) {
        RELEASE_LOCK(&LdapSslLock);
        return TRUE;
    }

    IF_DEBUG(SSL) {
        DPRINT(0,"Initializing SSL\n");
    }

    secStatus = AcquireCredentialsHandle(
                                NULL,
                                UNISP_NAME,
                                SECPKG_CRED_INBOUND,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                &hSslCredential,
                                &expiry
                                );

    if ( FAILED(secStatus) ) {
        IF_DEBUG(SSL) {
            DPRINT1(0, "AcquireCredentials failed with %x\n", secStatus);
        }

        fRet = FALSE;
        goto exit;
    }

    IF_DEBUG(SSL) {
        DPRINT(0,"SSL Initialization successful!\n");
    }

exit:

    //
    // See if we need to log something
    //

    if ( fRet ) {

        if ( fLoggedSslCredError ) {
            fLogEvent = TRUE;
            mid = DIRLOG_LDAP_SSL_GOT_CERT;
        }

        fhSslCredential = TRUE;

    } else {

        if ( !fLoggedSslCredError ) {

            fLoggedSslCredError = TRUE;
            fLogEvent = TRUE;
            mid = DIRLOG_LDAP_SSL_NO_CERT;
        }
    }

    RELEASE_LOCK(&LdapSslLock);

    if ( fLogEvent ) {

        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                 DS_EVENT_SEV_ALWAYS,
                 mid,
                 NULL, NULL, NULL);
    }

    return fRet;

} // InitializeSSL

extern "C"
VOID
DisableLdapLimitsChecks(
    VOID
    )
{
    fBypassLimitsChecks = TRUE;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\ldap\ldapcore.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ldapcore.cxx

Abstract:

    This module implements the LDAP server for the NT5 Directory Service.

    This file contains routines to convert between LDAP basic data structures
    and core dsa data structures.

Author:

    Tim Williams     [TimWi]    5-Aug-1996

Revision History:

--*/

#include <NTDSpchx.h> 
#pragma  hdrstop

#include "ldapsvr.hxx"

extern "C" {

#include "mdlocal.h"

#include <dsutil.h>
#include <debug.h>
#include <sddl.h>
#include "filtypes.h"
#include "objids.h"
#include "xom.h"

#define  FILENO FILENO_LDAP_CORE

OID_IMPORT(MH_C_OR_NAME);
OID_IMPORT(DS_C_ACCESS_POINT);

// Global heuristic value.  If this is true then LDAP_AttrTypeToDirAttrType will return 
// unwillingToPerform when a client going through the GC port attempts to search for 
// non-GC attributes.
ULONG gulGCAttErrorsEnabled = FALSE; 
}


#define  MAX_NUM_STRING_LENGTH 12 // Big enough for 0xFFFFFFFF in decimal

#define  MAX_LONG_NUM_STRING_LENGTH 21 // Big enough for 0xFFFFFFFFFFFFFFFF

// These #defines are used in coversion to/from LDAP
#define LDAP_PRES_ADD_PREFIX      "RFC1006+00+"
#define LDAP_PRES_ADD_PREFIX_SIZE (sizeof(LDAP_PRES_ADD_PREFIX)-1)
#define LDAP_DNPART_PREFIX        "#X500:"
#define LDAP_DNPART_PREFIX_LEN    (sizeof(LDAP_DNPART_PREFIX)-1)
#define LDAP_ADDRESS_PREFIX       "X400:"
#define LDAP_ADDRESS_PREFIX_LEN   (sizeof(LDAP_ADDRESS_PREFIX)-1)


// These are used as the canonical representation of TRUE and FALSE stringized
// booleans.
AssertionValue TrueValue = DEFINE_LDAP_STRING("TRUE");
AssertionValue FalseValue = DEFINE_LDAP_STRING("FALSE");

#include "ReplStructInfo.hxx"
#include "ReplMarshal.hxx"

_enum1
LDAP_LDAPORAddressToORAddress(
        IN  ULONG            CodePage,
        OUT ULONG           *pBytesConsumed,
        IN  LDAPString      *StringAddress,
        OUT SYNTAX_ADDRESS **ppAddress
        )
/*
Description:
    Translate an LDAP String ORAddress to a Dir ORAddress.  Allocates room for
    the ORAddress.  The String address may have an embedded non escaped '#' in
    it.  This routine stops at that symbol.

Arguments:
    CodePage - Code page of the client who provided us this string.
    pBytesConsumed - place to tell how many bytes of the input string we
               actually used to convert to an ORAddress
    pStringName - pointer to the string OR address.
    ppAddress - pointer to place to put pointer to new OR Address.

Return Values:
    success if all went well, an ldap error other wise.
*/
{
    // NYI for now, we don't handle address portions of ornames
    // When we start supporting them, we need to have code here
    // to do appropriate conversions.
    return unwillingToPerform;
}

_enum1
LDAP_ORAddressToLDAPORAddress(
        IN  ULONG           CodePage,
        IN  SYNTAX_ADDRESS *pAddress,
        OUT LDAPString     *StringAddress
        )
/*++
Routine Description:
    Translate a DS binary ORAddress into an LDAP string.  Right now, we don't
    have a defined ORAddress binary format, so this isn't supported.

Arguments:
    CodePage - CodePage of the client we're sending data to
    pORName - pointer to the binary blob of the DIR OR name.
    pStringName - pointer to the ldap oraddress we're filling out.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    DWORD dataLength = PAYLOAD_LEN_FROM_STRUCTLEN( pAddress->structLen );

    if(!dataLength) {
        // No data.
        StringAddress->value = NULL;
        StringAddress->length = 0;
        return success;
    }

    // NYI
    // When we start supporting them, we need to have code here
    // to do appropriate conversions.
    StringAddress->value = (PUCHAR)THAlloc(sizeof("NOT SUPPORTED") - 1);
    if(!StringAddress->value) {
        return other;
    }
    memcpy(StringAddress->value,"NOT SUPPORTED",sizeof("NOT SUPPORTED") - 1);
    StringAddress->length = sizeof("NOT SUPPORTED") - 1;

    return success;

}

_enum1
LDAP_LDAPDNToDSName (
        IN  ULONG  CodePage,
        IN  LDAPDN *pStringName,
        OUT DSNAME **ppDSName
        )
/*++
Routine Description:
    Translate an LDAPDN to a DSName.  Allocates room for the DSName.
    Does syntax checking of the LDAPDN, and shoves it into the DSName.

Arguments:
    pStringName - pointer to the ldapdn
    ppDSName - pointer to place to put pointer or new DSName.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    WCHAR *pName;
    ULONG  Size=0;

    pName = (WCHAR *)THAlloc((1 + pStringName->length) * sizeof(WCHAR)) ;
    if (!pName) {
        return other;
    }

    if(pStringName->length) {
        // Copy the name from the LDAP structure
        Size = MultiByteToWideChar(CodePage,
                                   0,
                                   (const char *)pStringName->value,
                                   pStringName->length,
                                   pName,
                                   pStringName->length);
        if(!Size) {
            Assert(ERROR_INSUFFICIENT_BUFFER == GetLastError());
            // They gave us a string that was too long.
            THFree(pName);
            return namingViolation;
        }
    }

    // UserFriendlyNameToDN want a null terminated string.
    pName[Size] = 0;

    if(UserFriendlyNameToDSName (pName, Size, ppDSName)) {
        // Failed.  Return error;
        THFree(pName);
        return invalidDNSyntax;
    }
    // Go home
    THFree(pName);
    return success;
}


_enum1
LDAP_DSNameToLDAPDN(
        IN ULONG        CodePage,
        IN DSNAME       *pDSName,
        IN BOOL         fExtended,
        OUT LDAPString  *StringName
        )
/*++
Routine Description:
    Translate a DSName to an LDAPDN.  Allocates room for the string portion of
    the LDAPDN.  Converte RDN values in quoted format to escaped.

Arguments:
    pDSName - pointer to the DSName.
    fExtended - Include full DSNAME
    pStringName - pointer to the ldapdn

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    DWORD err;
    DWORD len;
    PUCHAR name;

    name = (PUCHAR) String8FromUnicodeString(FALSE,
                                   CodePage,
                                   pDSName->StringName,
                                   pDSName->NameLen,
                                   (LONG *)&len,
                                   NULL);

    if ( NULL == name ) {
        return(other);
    }

    //
    // if caller asks for extended, see if we have a GUID and SID to return
    //

    if ( fExtended ) {

        PUCHAR tmpBuf, buf;
        tmpBuf = (PUCHAR)THAlloc(len + 32 + sizeof(GUID)*2 + sizeof(NT4SID) * 2);

        if ( tmpBuf == NULL ) {
            IF_DEBUG(ERROR) {
                DPRINT(0,"THAlloc failed to allocate mem for DSNAME\n");
            }
            goto exit;
        }

        buf=tmpBuf;
        *buf = '\0';

        if ( !fNullUuid(&pDSName->Guid ) ) {

            CopyMemory(buf,"<GUID=", 6);
            buf += 6;
            UuidToStr(&pDSName->Guid, buf);
            buf += sizeof(GUID)*2;
            CopyMemory(buf,">;",3);
            buf += 2;
        }

        Assert(pDSName->SidLen <= sizeof(NT4SID));

        if ( pDSName->SidLen != 0 ) {

            CopyMemory(buf,"<SID=", 5);
            buf += 5;
            SidToStr((PUCHAR)pDSName->Sid.Data, pDSName->SidLen, buf);
            buf += (pDSName->SidLen * 2);
            CopyMemory(buf, ">;", 3);
            buf += 2;
        }

        if ( buf != tmpBuf ) {
            CopyMemory(buf,name,len);
            THFree(name);
            buf[len] = '\0';

            name = tmpBuf;
            len = strlen((PCHAR)tmpBuf);
        } else {
            THFree(tmpBuf);
        }
    }

exit:
    StringName->length = len;
    StringName->value = name;
    return(success);

} // LDAP_DSNameToLDAPDN


_enum1
LDAP_DirPresentationAddressToPresentationAddress (
        IN  ULONG           CodePage,
        IN  SYNTAX_ADDRESS *pAddress,
        OUT AssertionValue *pVal
        )
/*++
Routine Description:
    Translate a presentation address to an assertion value.  Allocates room for
    the string portion of AssertionValue.  Does no semantic checking of the
    presentation address, just shoves the string implied by the presentation
    addressess into the assertionvalue.

Arguments:
    pAddress - pointer to the presentation address.
    pVal - pointer to the assertion value.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    THSTATE *pTHS=pTHStls;
    DWORD cbTemp=0;
    PUCHAR pTemp = NULL;

    // First, convert the core unicode value into the appropriate code page
    pTemp = (PUCHAR) String8FromUnicodeString(
            FALSE,
            CodePage,
            (PWCHAR)pAddress->uVal,
            (PAYLOAD_LEN_FROM_STRUCTLEN( pAddress->structLen )) / sizeof(WCHAR),
            (PLONG) &cbTemp,
            NULL);

    if(!pTemp) {
        return other;
    }

    pVal->length = cbTemp;
    pVal->value = pTemp;

    return success;
}

_enum1
LDAP_PresentationAddressToDirPresentationAddress (
        IN  THSTATE        *pTHS,
        IN  ULONG           CodePage,
        IN  AssertionValue *pVal,
        OUT SYNTAX_ADDRESS **ppAddress
        )
/*++
Routine Description:
    Translate an assertion value to a presentation address.   Allocates room for
    the presentation address.  Does no semantic checking of the
    presentation address, just creates the structure implied by the assertion
    value.

Arguments:
    pVal - pointer to the assertion value.
    ppAddress - pointer to the presentation address.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    PUCHAR value;
    ULONG  length;
    PUCHAR pTemp;

    value = pVal->value;
    length = pVal->length;

    // First, translate to a UNICODE string
    // NOTE: this is possibly an overallocatioln, since the input string may
    // be in UTF8 and therefore might have more than 1 byte per character.
    pTemp = (PUCHAR) THAlloc(sizeof(SYNTAX_UNICODE) * length);
    if(!pTemp) {
        return other;
    }

    // convert to unicode
    length = MultiByteToWideChar(
            CodePage,
            0,
            (LPCSTR)value,
            length,
            (LPWSTR) pTemp,
            (sizeof(SYNTAX_UNICODE) * length));

    // right now, length is count of chars.  Adjust to count of bytes.
    length *= sizeof(SYNTAX_UNICODE);

    if (!length) {
        IF_DEBUG(ERR_NORMAL) {
            DPRINT1(0,"MultiByteToWideChar failed with %d\n",GetLastError());
        }
        THFree(pTemp);
        return  constraintViolation;
    }

    *ppAddress = (SYNTAX_ADDRESS *)THAllocEx(pTHS, STRUCTLEN_FROM_PAYLOAD_LEN( length ));

    memcpy((*ppAddress)->uVal,
           pTemp,
           length);

    (*ppAddress)->structLen = STRUCTLEN_FROM_PAYLOAD_LEN( length );

    THFree(pTemp);
    return success;
}

_enum1
LDAP_DirAccessPointToAccessPoint (
        IN   THSTATE                 *pTHS,
        IN   ULONG                    CodePage,
        IN   SYNTAX_DISTNAME_STRING  *pDNAddress,
        OUT  AssertionValue          *pVal
        )
/*++
Routine Description:
    Translate an access point to an assertion value.   Allocates room for
    the string portion of the assertion value.  Does no semantic checking of the
    access point address, just creates the string implied by the access point
    structure

Arguments:
    pDNAddress - pointer to the access point.
    pVal - pointer to the assertion value.

    Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    LDAPDN LDAPdn;
    _enum1 code;

    // An access point is a presentation address appended by a DN.
    code = LDAP_DirPresentationAddressToPresentationAddress(
            CodePage,
            DATAPTR(pDNAddress),
            pVal);

    if(code) {
        return code;
    }

    // Now, deal with the DN portion.
    code = LDAP_DSNameToLDAPDN (CodePage,NAMEPTR(pDNAddress), FALSE, &LDAPdn);
    if(code == success) {
        if(pVal->length == 0) {
            // Haven't allocated any space yet.
            pVal->value = (PUCHAR)THAllocEx(pTHS, LDAPdn.length +
                                            LDAP_DNPART_PREFIX_LEN);
        }
        else {
            // Have already allocated some space.
            pVal->value = (PUCHAR)THReAllocEx(pTHS,
                    pVal->value,
                    (pVal->length+ LDAPdn.length +
                     LDAP_DNPART_PREFIX_LEN));
        }

        strcpy((char *)&pVal->value[pVal->length],
               LDAP_DNPART_PREFIX);

        pVal->length += LDAP_DNPART_PREFIX_LEN;

        memcpy(&pVal->value[pVal->length],
               LDAPdn.value,
               LDAPdn.length);
        pVal->length += LDAPdn.length;
    }

    return code;
}

_enum1
LDAP_AccessPointToDirAccessPoint (
        IN   THSTATE                *pTHS,
        IN   ULONG                   CodePage,
        IN   AssertionValue          *pVal,
        OUT  SYNTAX_DISTNAME_STRING **ppDNAddress
        )
/*++
Routine Description:
    Translate an assertion value to an access point.   Allocates room for
    the access point.  Does no semantic checking of the
    access point address, just creates the structure implied by the assertion
    value.


Arguments:
    pVal - pointer to the assertion value.
    ppDNAddress - pointer to the presentation address.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    _enum1         code;
    ULONG          i;
    BOOL           fFound = FALSE;
    DSNAME         *pDN;
    SYNTAX_ADDRESS *pAddress;
    AssertionValue TempVal;

    // An access point is a presentation address and a DN.
    // First, go looking through the string for the magic header telling us
    // where to split the string into presentation address/dn
    if (pVal->length > LDAP_DNPART_PREFIX_LEN) {    
        for(i=0;i<pVal->length - LDAP_DNPART_PREFIX_LEN;i++) {
            if(!memcmp(&(pVal->value[i]),
                      LDAP_DNPART_PREFIX,
                      LDAP_DNPART_PREFIX_LEN)) {
                fFound = TRUE;
                break;
            }
        }
    }
    if(!fFound) {
        return invalidAttributeSyntax;
    }
    TempVal.length = i;
    TempVal.value = pVal->value;

    code = LDAP_PresentationAddressToDirPresentationAddress(
            pTHS,
            CodePage,
            &TempVal,
            &pAddress);

    if(code) {
        return code;
    }

    // Now, the DSNAME
    TempVal.length = pVal->length - i - LDAP_DNPART_PREFIX_LEN;
    TempVal.value = &pVal->value[i + LDAP_DNPART_PREFIX_LEN];

    code = LDAP_LDAPDNToDSName(CodePage,(LDAPString *)&TempVal,&pDN);
    if(code) {
        return code;
    }

    // Now, combine the DSNAME and the ADDRESS.

    (*ppDNAddress) =  (SYNTAX_DISTNAME_STRING*)
        THAllocEx(pTHS, DERIVE_NAME_DATA_SIZE(pDN,pAddress));

    BUILD_NAME_DATA((*ppDNAddress),pDN,pAddress);
    return success;
}



_enum1
LDAP_DirReplicaLinkToReplicaLink (
        IN  REPLICA_LINK   *pReplicaLink,
        IN  ULONG          cbReplicaLink,
        OUT AssertionValue *pVal
        )
/*++
Routine Description:
    Translate a replica link to an assertion value.  Allocates room for
    the string portion of AssertionValue.  Does no semantic checking of the
    replica link, just shoves the string implied by the replica link
    into the assertion value.

Arguments:
    pReplicaLink - pointer to the replica link.
    pVal - pointer to the assertion value.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    // NOTE: no string representation, it's just an octet.
    pVal->length = cbReplicaLink;
    pVal->value = (PUCHAR) pReplicaLink;
    return success;
}

_enum1
LDAP_ReplicaLinkToDirReplicaLink (
        IN  AssertionValue *pVal,
        OUT ULONG          *pcbReplicaLink,
        OUT REPLICA_LINK    **ppReplicaLink
        )
/*++
Routine Description:
    Translate an assertion value to a replica link.   Allocates room for
    the replica link.  Does no semantic checking of the
    replica link, just creates the structure implied by the assertion
    value.

Arguments:
    pVal - pointer to the assertion value.
    ppReplicaLink - pointer to the replica link.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    // NOTE: no string representation, just send it as an octet.
    *pcbReplicaLink = pVal->length;
    *ppReplicaLink = (REPLICA_LINK *)pVal->value;
    return success;
}


_enum1
LDAP_ORNameToDirORName (
        IN  THSTATE       *pTHS,
        IN  ULONG          CodePage,
        IN  AssertionValue *pVal,
        OUT SYNTAX_DISTNAME_BINARY   **ppORName
        )
/*++
Routine Description:
    Translate an assertion value to an ORName.  Allocates room for orname.
    Does no semantic checking of the orname, translates the string
    representation of the orname in the assertion value to an orname structure.

Arguments:
    pVal - pointer to the assertion value.
    pORName - pointer to the ORName.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    // be optimistic at first
    _enum1 code = success;
    unsigned lengthLeft = pVal->length;
    PUCHAR pString = pVal->value;
    SYNTAX_DISTNAME_BINARY *pORName=NULL;
    BOOL                    fDidORAddress = FALSE;

    // Some locals to feed the LDAPORAddressToORAddress routine.
    LDAPString LDAPORAddress;
    SYNTAX_ADDRESS EmptyAddress;
    SYNTAX_ADDRESS *pORAddress=NULL;

    // Some locals to feed the LDAPDNtoDSName routine.
    LDAPDN LDAPdn;
    DSNAME *pDN = NULL;


    if(!lengthLeft) {
        // Hey, you have to give us SOME data.
        return invalidAttributeSyntax;
    }

    // See if there is an ORAddress portion to this.
    if((lengthLeft > LDAP_ADDRESS_PREFIX_LEN) &&
       !memcmp(pString, LDAP_ADDRESS_PREFIX, LDAP_ADDRESS_PREFIX_LEN)) {
        DWORD bytesConsumed;
        // We seem to have an OR Address.  Set up the locals.

        pString += LDAP_ADDRESS_PREFIX_LEN;
        lengthLeft -= LDAP_ADDRESS_PREFIX_LEN;

        LDAPORAddress.value = pString;
        LDAPORAddress.length = lengthLeft;
        code = LDAP_LDAPORAddressToORAddress (CodePage,
                                              &bytesConsumed,
                                              &LDAPORAddress,
                                              &pORAddress);
        if(code) {
            return code;
        }
        fDidORAddress = TRUE;
        pString += bytesConsumed;
        lengthLeft -= bytesConsumed;
    }
    else {
        pORAddress = &EmptyAddress;
        EmptyAddress.structLen= STRUCTLEN_FROM_PAYLOAD_LEN( 0 );
    }

    if(!lengthLeft) {
        // We must have done an ORAddress and had no DN.  return.
        return success;
    }

    // Now, deal with the DN portion.
    if(fDidORAddress) {
        // We did an ORAddress portion, therefore we require the constant
        // separator between the ORAddress and the DN.
        if((lengthLeft < LDAP_DNPART_PREFIX_LEN) ||
           memcmp(pString,LDAP_DNPART_PREFIX,LDAP_DNPART_PREFIX_LEN)) {
            // We don't have the speparator, but we demand one.
            return invalidAttributeSyntax;
        }
        else {
            pString+=LDAP_DNPART_PREFIX_LEN;
            lengthLeft -= LDAP_DNPART_PREFIX_LEN;
        }
    }

    // OK, the remainder of the string is a DN. Set up the locals.
    LDAPdn.value=pString;
    LDAPdn.length = lengthLeft;

    code = LDAP_LDAPDNToDSName (CodePage,&LDAPdn, &pDN);
    if(code) {
        return code;
    }

    // Build the final data structure.
    (*ppORName) =  (SYNTAX_DISTNAME_BINARY*)
        THAllocEx(pTHS, DERIVE_NAME_DATA_SIZE(pDN,pORAddress));

    BUILD_NAME_DATA((*ppORName),pDN,pORAddress);


    return success;
}

_enum1
LDAP_DirORNameToORName (
        IN  THSTATE       *pTHS,
        IN  ULONG          CodePage,
        IN  SYNTAX_DISTNAME_BINARY    *pORName,
        OUT AssertionValue *pVal
        )
/*++
Routine Description:
    Translate an ORName to an assertion value.  Allocates room for the string
    portion of AssertionValue.  Does no semantic checking of the orname, just
    shoves the string implied by the orname into the assertionvalue.

Arguments:
    pORName - pointer to the ORName.
    pVal - pointer to the assertion value.

    Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    // be optimistic at first
    _enum1 code = success;
    LDAPDN LDAPdn;
    LDAPString LDAPORAddress;
    PUCHAR pString;
    DWORD  cbRequired, i;

    // Just in case...
    pVal->length = 0;
    pVal->value = NULL;

    DPRINT(VERBOSE,
           "Directory ORName to LDAP conversion ignores address portion\n");


    // Start by the ORAddress.
    code = LDAP_ORAddressToLDAPORAddress(CodePage, DATAPTR(pORName),
                                         &LDAPORAddress);
    if(code != success) {
        return code;
    }

    // And, get the string DN.
    code = LDAP_DSNameToLDAPDN (CodePage,NAMEPTR(pORName), FALSE, &LDAPdn);
    if(code != success) {
        return code;
    }

    // Compute the length of the output string.
    if(LDAPORAddress.length) {
        // We have an ORAddress, so we need space for it and it's prefix
        cbRequired = LDAPORAddress.length + LDAP_ADDRESS_PREFIX_LEN;
        if(LDAPdn.length) {
            // And a DN, so we need space for IT and its' prefix.
            cbRequired += LDAPdn.length + LDAP_DNPART_PREFIX_LEN;
        }
    }
    else if (LDAPdn.length) {
        // Just a DN.  Short circuit out of here.
        pVal->length = LDAPdn.length;
        pVal->value = LDAPdn.value;
        return success;
    }
    else {
        // No data.
        return other;
    }

    // OK, at this point, we know we have an ORAddress and maybe a DN.  We also
    // know how long the string needs to be.
    pString = (PUCHAR)THAllocEx(pTHS, cbRequired);
    memcpy(pString, LDAP_ADDRESS_PREFIX, LDAP_ADDRESS_PREFIX_LEN);

    i = LDAP_ADDRESS_PREFIX_LEN;

    memcpy(&pString[i],
           LDAPORAddress.value,
           LDAPORAddress.length);

    THFreeEx(pTHS, LDAPORAddress.value);

    if(LDAPdn.length) {
        i+= LDAPORAddress.length;

        memcpy(&pString[i],
               LDAP_DNPART_PREFIX,
               LDAP_DNPART_PREFIX_LEN);
        i += LDAP_DNPART_PREFIX_LEN;

        memcpy(&pString[i],
               LDAPdn.value,
               LDAPdn.length);

        THFreeEx(pTHS, LDAPdn.value);
    }

    pVal->value = pString;
    pVal->length = cbRequired;

    return success;
}

_enum1
LDAP_DirDNBlobToLDAPDNBlob(
        IN   THSTATE                 *pTHS,
        IN   ULONG                    CodePage,
        IN   SYNTAX_DISTNAME_STRING  *pDNBlob,
        IN   BOOL                     fExtended,
        OUT  AssertionValue          *pVal
        )
/*++
Routine Description:
    Translate a Binary Data + DN pair to an assertion value.   Allocates room
    for the string portion of the assertion value.

Arguments:
    pDNBlob - pointer to the dn + string.
    pVal - pointer to the assertion value.

    Return Values:
    success if all went well, an ldap error other wise.
--*/
{
    LDAPDN LDAPdn;
    _enum1 code;
    PUCHAR pString;
    DWORD  cbAllocated = 1024;
    DWORD  stringLength;
    DWORD  i,j;

    // First, encode the string length

    pString = (PUCHAR)THAllocEx(pTHS, cbAllocated);

    pString[0]='B';
    pString[1]=':';

    stringLength = PAYLOAD_LEN_FROM_STRUCTLEN( (DATAPTR(pDNBlob))->structLen );

    sprintf((PCHAR)&pString[2], "%d",stringLength * 2);

    i = strlen((const char *)pString);

    pString[i++] = ':';

    Assert(i < cbAllocated);

    if(i + (2 * stringLength) + 1 >= cbAllocated) {
        // Not enough room
        pString = (PUCHAR)THReAllocEx(pTHS, pString, (i +  (2 * stringLength) + 1));
    }

    for(j=0 ; j<stringLength ;j++, i+= 2) {
        sprintf((PCHAR)&pString[i],"%02X", (DATAPTR(pDNBlob))->byteVal[j]);
    }

    pString[i++] = ':';

    // Now, deal with the DN portion.
    code = LDAP_DSNameToLDAPDN (CodePage,NAMEPTR(pDNBlob), fExtended, &LDAPdn);
    if(code == success) {
        // Have already allocated some space.
        pString = (PUCHAR)THReAllocEx(pTHS, pString, (i +  LDAPdn.length));

        memcpy(&pString[i],
               LDAPdn.value,
               LDAPdn.length);
        pVal->length = i + LDAPdn.length;
        pVal->value = pString;
    }

    return code;
}

_enum1
LDAP_LDAPDNBlobToDirDNBlob(
        IN   THSTATE                 *pTHS,
        IN   ULONG                    CodePage,
        IN   AssertionValue          *pVal,
        OUT  SYNTAX_DISTNAME_STRING **ppDNBlob
        )
/*++
Routine Description:
    Translate a string + DN to a SYNTAX_DISTNAME_STRING. Allocates room for
    the SYNTAX_DISTNAME_STRING.

Arguments:
    pVal - pointer to the assertion value.
    ppDNBlob - pointer to the presentation address.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    _enum1         code;
    ULONG          i, j;
    BOOL           fFound = FALSE;
    DSNAME         *pDN;
    SYNTAX_ADDRESS *pAddress;
    AssertionValue TempVal;


    DWORD          stringLength=0;
    BOOL           fDone = FALSE;

    if(pVal->value[0] != 'b' && pVal->value[0] != 'B') {
        return invalidAttributeSyntax;
    }

    if(pVal->value[1] != ':' ) {
        return invalidAttributeSyntax;
    }

    // First, get the size of the string.
    for(i=2;!fDone && i<pVal->length;i++) {
        // Parse the string one character at a time to detect any
        // non-allowed characters.
        if(pVal->value[i] == ':') {
            fDone = TRUE;
            continue;
        }

        if((pVal->value[i] < '0') || (pVal->value[i] > '9'))
            return invalidAttributeSyntax;

        stringLength = (stringLength * 10) + pVal->value[i] - '0';
    }
    if(!fDone) {
        // Didn't find the ':'
        return invalidAttributeSyntax;
    }

    // Make sure there is a ':' between the string and the dn
    if(pVal->length < (i + stringLength) || pVal->value[i+stringLength] != ':') {
        return invalidAttributeSyntax;
    }

    if(stringLength & 1) {
        return invalidAttributeSyntax;
    }

    // Now, get the string
    pAddress = (SYNTAX_ADDRESS *)
        THAlloc(STRUCTLEN_FROM_PAYLOAD_LEN( stringLength/2 ));

    if(!pAddress) {
        return other;
    }

    pAddress->structLen = STRUCTLEN_FROM_PAYLOAD_LEN( stringLength/2 );


    stringLength /= 2;

    for(j=0;j<stringLength;j++) {
        // get the next two characters as a byte.
        CHAR acTmp[3];

        acTmp[0] = (CHAR)tolower(pVal->value[i++]);
        acTmp[1] = (CHAR)tolower(pVal->value[i++]);
        acTmp[2] = '\0';

        if(isxdigit(acTmp[0]) && isxdigit(acTmp[1])) {
            pAddress->byteVal[j] = (UCHAR)strtol(acTmp, NULL, 16);
        }
        else {
            THFree(pAddress);
            return invalidAttributeSyntax;
        }

    }

    // eat the ':'
    i++;

    // Now, the DSNAME
    TempVal.length = pVal->length - i;
    TempVal.value = &pVal->value[i];

    code = LDAP_LDAPDNToDSName(CodePage,(LDAPString *)&TempVal,&pDN);
    if(code) {
        THFree(pAddress);
        return code;
    }

    // Now, combine the DSNAME and the ADDRESS.

    (*ppDNBlob) =  (SYNTAX_DISTNAME_STRING*)
        THAllocEx(pTHS, DERIVE_NAME_DATA_SIZE(pDN,pAddress));

    BUILD_NAME_DATA((*ppDNBlob),pDN,pAddress);

    THFree(pAddress);
    return success;
}

_enum1
LDAP_DirDNStringToLDAPDNString(
        IN   THSTATE                 *pTHS,
        IN   ULONG                    CodePage,
        IN   SYNTAX_DISTNAME_STRING  *pDNString,
        IN   BOOL                     fExtended,
        OUT  AssertionValue          *pVal
        )
/*++
Routine Description:
    Translate a Unicode String + DN pair to an assertion value.   Allocates room
    for the string portion of the assertion value.

Arguments:
    pDNString - pointer to the dn + string.
    pVal - pointer to the assertion value.

    Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    LDAPDN LDAPdn;
    _enum1 code;
    PUCHAR pString;
    DWORD  cbAllocated = 1024;
    DWORD  stringLength;
    DWORD  i;
    SYNTAX_ADDRESS *pAddress;

    // First, encode the string length

    pString = (PUCHAR)THAllocEx(pTHS, cbAllocated);

    pString[0]='S';
    pString[1]=':';

    pAddress = DATAPTR(pDNString);

    stringLength = WideCharToMultiByte(CodePage,            // code page
        0,                                                  // flags
        pAddress->uVal,                                     // unicode string
        PAYLOAD_LEN_FROM_STRUCTLEN(pAddress->structLen) / 2,// sizeof string in chars
        NULL,                                               // string 8
        0,                                                  // sizeof(string 8) in bytes
        NULL,                                               // default char
        NULL);                                              // used default char

    sprintf((PCHAR)&pString[2], "%d",stringLength);

    i = strlen((const char *)pString);

    pString[i++] = ':';

    Assert(i < cbAllocated);

    if(i + stringLength + 1 <= cbAllocated) {
        // Not enough room
        pString = (PUCHAR)THReAllocEx(pTHS, pString, (i +  stringLength + 1));
    }

    stringLength = WideCharToMultiByte(CodePage,            // code page
        0,                                                  // flags
        pAddress->uVal,                                     // unicode string
        PAYLOAD_LEN_FROM_STRUCTLEN(pAddress->structLen) / 2,// sizeof string in chars
        (PCHAR) &pString[i],                                // string 8
        stringLength + 1,                                   // sizeof(string 8) in bytes
        NULL,                                               // default char
        NULL);                                              // used default char
    
    i += stringLength;

    pString[i++] = ':';

    // Now, deal with the DN portion.
    code = LDAP_DSNameToLDAPDN (CodePage,NAMEPTR(pDNString), fExtended, &LDAPdn);
    if(code == success) {
        // Have already allocated some space.
        pString = (PUCHAR)THReAllocEx(pTHS, pString, (i +  LDAPdn.length));

        memcpy(&pString[i],
               LDAPdn.value,
               LDAPdn.length);
        pVal->length = i + LDAPdn.length;
        pVal->value = pString;
    }

    return code;
}

_enum1
LDAP_LDAPDNStringToDirDNString(
        IN   THSTATE                 *pTHS,
        IN   ULONG                    CodePage,
        IN   AssertionValue          *pVal,
        OUT  SYNTAX_DISTNAME_STRING **ppDNString
        )
/*++
Routine Description:
    Translate a string + DN to a SYNTAX_DISTNAME_STRING. Allocates room for
    the SYNTAX_DISTNAME_STRING.

Arguments:
    pVal - pointer to the assertion value.
    ppDNString - pointer to the presentation address.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    _enum1         code;
    ULONG          i;
    BOOL           fFound = FALSE;
    DSNAME         *pDN;
    SYNTAX_ADDRESS *pAddress;
    AssertionValue TempVal;


    DWORD          stringLength=0;
    DWORD          unicodeStrLen=0;
    BOOL           fDone = FALSE;

    if(pVal->value[0] != 's' && pVal->value[0] != 'S') {
        return invalidAttributeSyntax;
    }

    if(pVal->value[1] != ':') {
        return invalidAttributeSyntax;
    }

    // First, get the size of the string.
    for(i=2;!fDone && i<pVal->length;i++) {
        // Parse the string one character at a time to detect any
        // non-allowed characters.
        if(pVal->value[i] == ':') {
            fDone = TRUE;
            continue;
        }

        if((pVal->value[i] < '0') || (pVal->value[i] > '9'))
            return invalidAttributeSyntax;

        stringLength = (stringLength * 10) + pVal->value[i] - '0';
    }
    if(!fDone) {
        // Didn't find the ':'
        return invalidAttributeSyntax;
    }

    // Make sure there is a ':' between the string and the dn
    if(pVal->length < (i + stringLength) || pVal->value[i+stringLength] != ':') {
        return invalidAttributeSyntax;
    }


    // Now, get the string
    // This may llocate more than we need since UTF8 may exand when converted
    // to Unicode.
    pAddress = (SYNTAX_ADDRESS *)
        THAlloc(STRUCTLEN_FROM_PAYLOAD_LEN( stringLength  * sizeof(SYNTAX_UNICODE) ));

    if(!pAddress) {
        return other;
    }

    // convert to unicode
    unicodeStrLen = MultiByteToWideChar(
        CodePage,
        0,
        (LPCSTR) (&pVal->value[i]),
        stringLength,
        (LPWSTR) pAddress->uVal,
        (sizeof(SYNTAX_UNICODE) * stringLength));


    if (!unicodeStrLen) {

        IF_DEBUG(ERR_NORMAL) {
            DPRINT1(0,"MultiByteToWideChar failed with %d\n",GetLastError());
        }
        code =  constraintViolation;
    }

    // unicodeStrLen is count of chars, convert to number of 
    // bytes before filling in structLen.
    pAddress->structLen = STRUCTLEN_FROM_PAYLOAD_LEN( unicodeStrLen * sizeof(SYNTAX_UNICODE) );

    // Now, the DSNAME
    TempVal.length = pVal->length - i - stringLength - 1;
    TempVal.value = &pVal->value[i + stringLength + 1];

    code = LDAP_LDAPDNToDSName(CodePage,(LDAPString *)&TempVal,&pDN);
    if(code) {
        THFree(pAddress);
        return code;
    }

    // Now, combine the DSNAME and the ADDRESS.

    (*ppDNString) =  (SYNTAX_DISTNAME_STRING*)
        THAllocEx(pTHS, DERIVE_NAME_DATA_SIZE(pDN,pAddress));

    BUILD_NAME_DATA((*ppDNString),pDN,pAddress);
    THFree(pAddress);
    return success;
}
_enum1
LDAP_AttrTypeToDirClassTyp (
        IN  THSTATE       *pTHS,
        IN  ULONG         CodePage,
        IN  AttributeType *LDAP_att,
        OUT ATTRTYP       *pAttrType,
        OUT CLASSCACHE    **ppCC        // OPTIONAL
        )
/*++
Routine Description:
    Translate an LDAP Attribute Type to a directory attrtyp that references a
    class.  Also, give back the pointer to the classcache for the class type if
    they asked for it.

Arguments:
    LDAP_att - pointer to the LDAP attribute type.
    pAttrType - Place to put the directory attrtyp.
    ppAC - pointer to place to put pointer to the classcache.  Ignored if NULL.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    CLASSCACHE *pCC=NULL;
    ATTRTYP     classTyp;

    // First, look up the string in the schema cache
    pCC = SCGetClassByName(pTHS, LDAP_att->length, LDAP_att->value);
    if(NULL == pCC) {
        // Not an object we know by name.  Try to parse the string as an
        // OID string, (e.g.  "OID.1.2.814.500" or "1.2.814.500",
        // StringToAttrType accepts both formats)
        WCHAR pString[512];         // Ought to be big enough
        ULONG len;
        // translate the input string to unicode
        if (!(len = MultiByteToWideChar(
                CodePage,
                0,
                (LPCSTR) (LDAP_att->value),
                LDAP_att->length,
                (LPWSTR) pString,
                512))) {

            IF_DEBUG(ERR_NORMAL) {
                DPRINT1(0,"MultiByteToWideChar failed with %d\n",GetLastError());
            }
            return  constraintViolation;
        }
        else {
            if(StringToAttrTyp(pTHS, pString,len,&classTyp)== -1) {
                // failed to convert.
                return  noSuchAttribute;
            }

            pCC = SCGetClassById(pTHS, classTyp);
            if(NULL == pCC) {
                return noSuchAttribute;
            }
        }
    }

    // Ok, to get here, we have to have a pCC now.

    // Set the value.
    *pAttrType = pCC->ClassId;

    if(ppCC) {
        *ppCC = pCC;
    }

    return success;
}

_enum1
LDAP_DirClassTypToAttrType (
        IN  THSTATE       *pTHS,
        IN  ULONG         CodePage,
        IN  ATTRTYP       AttrTyp,
        IN  ULONG         Flag,
        OUT AttributeType *LDAP_att,
        OUT CLASSCACHE    **ppCC        // OPTIONAL
        )
/*++
Routine Description:
    Translate a directory attrtyp that references a class to an LDAP Attribute
    Type.  Also, give back the pointer to the classcache for the attribute type
    if they asked for it.

    NOTE: the string returned by this routine is shared by the classcache, don't
    mess with it.

    Arguments:
    AttrType - The directory attrtyp.
    LDAP_att - pointer to the LDAP attribute type.
    ppCC - pointer to place to put pointer to the classcache.  Ignored if NULL.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{

    CLASSCACHE *pCC;
    if(!(pCC = SCGetClassById(pTHS, AttrTyp))
        // ldap head returns defunct classes in OID-syntax form
        || (pCC->bDefunct && ALLOW_SCHEMA_REUSE_VIEW(pTHS->CurrSchemaPtr))) {
        return noSuchAttribute;
    }

    if (!(Flag & ATT_OPT_BINARY)) {
       // found an attribute
       LDAP_att->length = pCC->nameLen;
       LDAP_att->value = pCC->name;
    }
    else {
        // Binary Flag. Return BER encoding of OID
        OID_t Oid;
        if (AttrTypeToOid (pCC->ClassId, &Oid)) {
          return noSuchAttribute;
         }
        LDAP_att->length = Oid.length;
        LDAP_att->value = (UCHAR *) Oid.elements;

    }


    if(ppCC) {
        *ppCC = pCC;
    }

    return success;
}


_enum1
LDAP_AttrTypeToDirAttrTyp (
        IN THSTATE       *pTHS,
        IN ULONG         CodePage,
        IN SVCCNTL*      Svccntl OPTIONAL,
        IN AttributeType *LDAP_att,
        OUT ATTRTYP      *pAttrType,
        OUT ATTCACHE     **ppAC         // OPTIONAL
        )
/*++
Routine Description:
    Translate an LDAP Attribute Type to a directory attrtyp.  Also, give back
    the pointer to the attcache for the attribute type if they asked for it.

Arguments:
    Svccntl - if present, requires us to check whether this is a GC port
        request so we can filter out the non-GC partial attributes
    LDAP_att - pointer to the LDAP attribute type.
    pAttrType - Place to put the directory attrtyp.
    ppAC - pointer to place to put pointer to the attcache.  This out param will
        always be filled in if the attrtype can be looked up.  If this the funtion
        returns an error and *ppAC is not NULL then the attribute asked
        for is a GC only attribute.  Ignored if NULL.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    ATTCACHE *pAC=NULL;
    AttributeType TempAtt = *LDAP_att;
    ATTRTYP  attrTyp;

    // Now, look up the string in the schema cache
    //
    // Ignore defunct attributes because the new schema
    // reuse behavior treats defunct attributes as if they
    // were deleted.
    if(!(pAC = SCGetAttByName(pTHS, TempAtt.length, TempAtt.value))
        || (pAC->bDefunct && ALLOW_SCHEMA_REUSE_VIEW(pTHS->CurrSchemaPtr))) {

        // Not an object we know by name.  Try to parse the string as an
        // OID string, (e.g.  "OID.1.2.814.500" or "1.2.814.500",
        // StringToAttrType will accept both formats)
        WCHAR pString[512];         // Ought to be big enough
        ULONG len;

        IF_DEBUG(CONV) {
            DPRINT1(0,"Cannot find attribute %s.Checking if OID.\n",TempAtt.value);
        }

        // translate the input string to unicode
        if (!(len = MultiByteToWideChar(
                CodePage,
                0,
                (LPCSTR) (TempAtt.value),
                TempAtt.length,
                (LPWSTR) pString,
                512))) {

            IF_DEBUG(ERR_NORMAL) {
                DPRINT1(0,"MultiByteToWideChar failed with %d\n",GetLastError());
            }
            return  constraintViolation;
        }
        else {
            if(StringToAttrTyp(pTHS, pString,len,&attrTyp)== -1) {
              // failed to convert.
                 return  noSuchAttribute;
            }

            // Tokenized OIDs are in the ExtId hash table
            if(!(pAC = SCGetAttByExtId(pTHS, attrTyp))) {
                return noSuchAttribute;
            }
        }
    }

    // We are here mans we found an attcache
    Assert(pAC != NULL);

    if(ppAC) {
        *ppAC = pAC;
    }
    
    //
    // If we came in through the GC port and this attribute is not
    // a GC attribute, ignore it
    //
    if ( (Svccntl != NULL) &&
         (Svccntl->fGcAttsOnly) &&
         !IS_GC_ATTRIBUTE(pAC) ) {
        if (gulGCAttErrorsEnabled) {
            return unwillingToPerform;
        } else {
            //
            // Set so lower layers know some attributes were
            // stripped out.
            //
            Svccntl->fMissingAttributesOnGC = TRUE;
            return noSuchAttribute;
        }
    }
    // Set the value.
    *pAttrType = pAC->id;

    return success;
}

_enum1
LDAP_DirAttrTypToAttrType (
        IN  THSTATE       *pTHS,
        IN  ULONG         CodePage,
        IN  ATTRTYP       AttrTyp,
        IN  ULONG         Flag,
        OUT AttributeType *LDAP_att,
        OUT ATTCACHE      **ppAC        // OPTIONAL
        )
/*++
Routine Description:
    Translate a  directory attrtyp to an LDAP Attribute Type.  Also, give back
    the pointer to the attcache for the attribute type if they asked for it.

    NOTE: the string returned by this routine is shared by the attcache, don't
    mess with it.

Arguments:
    AttrType - The directory attrtyp.
    LDAP_att - pointer to the LDAP attribute type.
    ppAC - pointer to place to put pointer to the attcache.  Ignored if NULL.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    ATTCACHE *pAC;

    // This may be an attrtyp or an attrval. In either case, check
    // the tokenized OID hash table first to locate the "active"
    // attribute. If that fails, check the internal id table.
    if(!(pAC = SCGetAttByExtId(pTHS, AttrTyp))
       && !(pAC = SCGetAttById(pTHS, AttrTyp))) {
        return noSuchAttribute;
    }
    // Treat defunct attributes as if they were deleted.
    if (pAC->bDefunct && ALLOW_SCHEMA_REUSE_VIEW(pTHS->CurrSchemaPtr)) {
        return noSuchAttribute;
    }

    if (!(Flag & ATT_OPT_BINARY)) {
       LDAP_att->length = pAC->nameLen;
       LDAP_att->value = pAC->name;
    }
    else {
        // Binary Flag. Return BER encoding of OID
        OID_t Oid;
        // use the tokenized OID (attributeId), not the internal id (msDS-IntId)
        if (AttrTypeToOid (pAC->Extid, &Oid)) {
          return noSuchAttribute;
         }
        LDAP_att->length = Oid.length;
        LDAP_att->value = (UCHAR *) Oid.elements;
    }

    if(ppAC) {
        *ppAC = pAC;
    }

    return success;

}

_enum1
LDAP_AttrValToDirAttrVal (
        IN  THSTATE       *pTHS,
        IN  ULONG          CodePage,
        IN  SVCCNTL*      Svccntl OPTIONAL,
        IN  ATTCACHE       *pAC,
        IN  AssertionValue *pLDAP_val,
        OUT ATTRVAL        *pValue
        )
/*++
Routine Description:
    Translate an LDAP Attribute Value to a directory attribute value.  Assumes
    data representation as described by RFC-1778.

    NOTE: When possible, the values in the directory attribute value structure
    simply point to the same memory referenced by the LDAP attribute value.
    Remember this when freeing/using/dereffing memory.  When LDAP and core do
    not share a data representation, allocate memory.

Arguments:
    pAC - attcache of the attribute that this value is.
    pLDAP_val - the LDAP attribute value.
    pValue - pointer to the directory attribute value structure to fill up.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    _enum1 code=success;
    ATTCACHE *pACVal;

    if(!pAC) {
        return noSuchAttribute;
    }

    // 0 length values and null pointers are not allowed
    if(!pLDAP_val ||
       !pLDAP_val->value ||
       !pLDAP_val->length) {

        IF_DEBUG(ERR_NORMAL) {
            DPRINT(0,"AttrValToDir: Null values not allowed.\n");
        }
        return invalidAttributeSyntax;
    }

    // Based on the att, turn the string we were given into a value.
    switch (pAC->OMsyntax) {
    case OM_S_BOOLEAN:
        {
            int val=0;
            // Only two values are allowed.  Anything else is not-understood.
            // Case matters.
            if((pLDAP_val->length == TrueValue.length) &&
               memcmp(TrueValue.value,pLDAP_val->value,pLDAP_val->length)== 0) {
                val = 1;
            }
            if((pLDAP_val->length == FalseValue.length) &&
               memcmp(FalseValue.value,pLDAP_val->value,pLDAP_val->length)== 0){
                val=2;
            }

            if(!val) {
                code = invalidAttributeSyntax;
            }
            else {
                pValue->valLen = sizeof( BOOL );
                pValue->pVal = ( UCHAR * ) THAllocEx(pTHS, sizeof(BOOL));
                *( BOOL * )pValue->pVal = (val==1);
            }
        }

        break;

    case OM_S_ENUMERATION:
    case OM_S_INTEGER:
        {
            SYNTAX_INTEGER *pInt, sign=1;
            ATTCACHE *pACLink;
            unsigned i;

            pInt = ( SYNTAX_INTEGER  *) THAllocEx(pTHS, sizeof(SYNTAX_INTEGER));
            *pInt = 0;
            i=0;
            if(pLDAP_val->value[i] == '-') {
                sign = -1;
                i++;
            }
            if(i==pLDAP_val->length) {
                // No length or just a '-'
                code = invalidAttributeSyntax;
            } else for(;i<pLDAP_val->length;i++) {
                // Parse the string one character at a time to detect any
                // non-allowed characters.
                if((pLDAP_val->value[i] < '0') || (pLDAP_val->value[i] > '9')) {
                    code = invalidAttributeSyntax;
                    break;
                }

                *pInt = (*pInt * 10) + pLDAP_val->value[i] - '0';
            }
            if (code == success) {
                *pInt *= sign;
            } else if (pAC->id != ATT_LINK_ID) {
                return code;
            } else {
                // AutoLinkId
                // The ldap head cooperates in this venture by translating
                // the ldapDisplayName or OID for a LinkId attribute into
                // the corresponding schema cache entry and determining
                // the correct linkid.

                // Call support routine to translate.
                // Translates ldapDisplayNames and OIDs (OID.1.2.3 and 1.2.3)
                code = LDAP_AttrTypeToDirAttrTyp(pTHS,
                                                 CodePage,
                                                 Svccntl,
                                                 (AttributeType *)pLDAP_val,
                                                 (ATTRTYP *)pInt,
                                                 &pACLink);
                if (code != success) {
                    // Not an ldapDisplayName or OID. Underlying code
                    // eventually returns ERROR_DS_BACKLINK_WITHOUT_LINK.
                    *pInt = RESERVED_AUTO_NO_LINK_ID;
                } else if (pACLink->id == ATT_LINK_ID) {
                    // underlying code will generate a forward linkid
                    *pInt = RESERVED_AUTO_LINK_ID;
                } else if (FIsLink(pACLink->ulLinkID)) {
                    // user is creating a backlink for an existing link
                    *pInt = MakeBacklinkId(MakeLinkBase(pACLink->ulLinkID));
                } else {
                    // ldapDisplayName or OID of a non-link attribute.
                    // Pretend this is a backlink w/o a corresponding
                    // foward link. Underlying code eventually returns
                    // ERROR_DS_BACKLINK_WITHOUT_LINK.
                    *pInt = RESERVED_AUTO_NO_LINK_ID;
                }
                code = success;
            }

            // Ok, got the value, set it up.
            pValue->valLen = sizeof( SYNTAX_INTEGER );
            pValue->pVal = ( UCHAR * ) pInt;
        }
        break;

    case OM_S_OBJECT:
        switch(pAC->syntax) {
        case SYNTAX_DISTNAME_TYPE:

            // DS_C_DS_DN
            code = LDAP_LDAPDNToDSName(
                    CodePage,
                    (LDAPDN *)pLDAP_val,
                    (DSNAME **) &pValue->pVal);

            if( !code ) {
                pValue->valLen=((DSNAME*)pValue->pVal)->structLen;
            }
            break;

        case SYNTAX_DISTNAME_BINARY_TYPE:

            // THis could be an ORName or a simple distname binary
            if(OIDcmp(&pAC->OMObjClass, &MH_C_OR_NAME)) {
                // MH_C_OR_NAME
                code = LDAP_ORNameToDirORName(
                        pTHS,
                        CodePage,
                        pLDAP_val,
                        (SYNTAX_DISTNAME_BINARY **)&pValue->pVal);
            }
            else {
                code = LDAP_LDAPDNBlobToDirDNBlob(
                        pTHS,
                        CodePage,
                        pLDAP_val,
                        (SYNTAX_DISTNAME_BINARY **)&pValue->pVal);
            }
            if( !code ) {
                pValue->valLen=
                    NAME_DATA_SIZE((SYNTAX_DISTNAME_BINARY *)(pValue->pVal));
            }
            break;

        case SYNTAX_ADDRESS_TYPE:
            // DS_C_PRESENTATION_ADDRESS
            code = LDAP_PresentationAddressToDirPresentationAddress(
                    pTHS,
                    CodePage,
                    pLDAP_val,
                    (SYNTAX_ADDRESS **)&pValue->pVal);

            if( !code ) {
                pValue->valLen=((SYNTAX_ADDRESS*)pValue->pVal)->structLen;
            }
            break;

        case SYNTAX_DISTNAME_STRING_TYPE:
            // THis could be an ORName or a simple distname binary
            if(OIDcmp(&pAC->OMObjClass, &DS_C_ACCESS_POINT)) {
                // DS_C_ACCESS_POINT
                code = LDAP_AccessPointToDirAccessPoint(
                        pTHS,
                        CodePage,
                        pLDAP_val,
                        (SYNTAX_DISTNAME_BINARY **)&pValue->pVal);
            }
            else {
                code = LDAP_LDAPDNStringToDirDNString(
                        pTHS,
                        CodePage,
                        pLDAP_val,
                        (SYNTAX_DISTNAME_STRING **)&pValue->pVal);
            }

            if(!code) {
                pValue->valLen = NAME_DATA_SIZE((ACCPNT*)pValue->pVal);
            }
            break;

        case SYNTAX_OCTET_STRING_TYPE:

            // This had better be a replica-link valued object, since that is
            // all we support.

            code = LDAP_ReplicaLinkToDirReplicaLink (
                    pLDAP_val,
                    &pValue->valLen,
                    (REPLICA_LINK **)&pValue->pVal);
            break;

        default:
            code = invalidAttributeSyntax;
            break;
        }

        break;
    case OM_S_OBJECT_IDENTIFIER_STRING:
        // allocate space for the oid
        pValue->valLen = sizeof( ULONG );
        pValue->pVal = ( UCHAR * ) THAllocEx(pTHS, sizeof (ULONG));

        // Call support routine to translate.
        code = LDAP_AttrTypeToDirAttrTyp (
                pTHS,
                CodePage,
                Svccntl,
                (AttributeType *)pLDAP_val,
                (ATTRTYP *)pValue->pVal,
                &pACVal);

        // Need the tokenized OID (attributeId), not the internal id (msDS-IntId)
        if (code == success) {
            *((ATTRTYP *)pValue->pVal) = pACVal->Extid;
        }

        if(code == noSuchAttribute) {
            // Ok, it's not an attribute, see if it is a class.
            code = LDAP_AttrTypeToDirClassTyp (
                    pTHS,
                    CodePage,
                    (AttributeType *)pLDAP_val,
                    (ATTRTYP *)pValue->pVal,
                    NULL);
        }

        if(code == noSuchAttribute) {
            // Not an object we know. Could be a new id.
            // Try to parse the string as an OID string,
            // (e.g.  "OID.1.2.814.500" or "1.2.814.500")
            // The call to StringToAttrType can handle
            // both strings starting with OID. and not

            WCHAR pString[512];         // Ought to be big enough
            ULONG len;
            // translate the input string to unicode
            if (!(len = MultiByteToWideChar(
                    CodePage,
                    0,
                    (LPCSTR) (pLDAP_val->value),
                    pLDAP_val->length,
                    (LPWSTR) pString,
                    512))) {

                IF_DEBUG(ERR_NORMAL) {
                    DPRINT1(0,"MultiByteToWideChar failed with %d\n",GetLastError());
                }
                code =  constraintViolation;
            }
            else {
               if(StringToAttrTyp(pTHS, pString,len,(ATTRTYP *)pValue->pVal)== -1) {
                     // failed to convert.
                    code = noSuchAttribute;
                }
                else {
                    code = success;
                }
            }
        }

        break;

    case OM_S_IA5_STRING:
    case OM_S_NUMERIC_STRING:
    case OM_S_TELETEX_STRING:
    case OM_S_PRINTABLE_STRING:
    
        if(pAC->bExtendedChars) { /* allow any character */
            code = success;
        } else {        
            code = CheckStringSyntax(pAC->OMsyntax, pLDAP_val);
            if (success != code) {
                return code;
            }
        }
        pValue->valLen = pLDAP_val->length;
        pValue->pVal = pLDAP_val->value;

        break;

    case OM_S_OBJECT_SECURITY_DESCRIPTOR:
    
        //
        // Copy the security descriptor to make sure that it
        // is 8 byte aligned.
        //
        pValue->pVal = (UCHAR *)THAllocEx(pTHS, pLDAP_val->length);
        CopyMemory(pValue->pVal, pLDAP_val->value, pLDAP_val->length);
        pValue->valLen = pLDAP_val->length;

        code = success;

        break;

    case OM_S_OCTET_STRING:
    
        if (SYNTAX_SID_TYPE == pAC->syntax) {
            PSID   pSid;
            //
            // This value needs to be copied to ensure that it is
            // 8 byte aligned.  Also, null terminate for the string check below.
            //
            pValue->pVal = (UCHAR *)THAllocEx(pTHS, pLDAP_val->length + 1);
            CopyMemory(pValue->pVal, pLDAP_val->value, pLDAP_val->length);
            pValue->valLen = pLDAP_val->length;
            pValue->pVal[pValue->valLen] = '\0';
            
            //
            // Check to see if this is the userfriendly string representation.
            //
            if (pValue->valLen >= 2 && !_strnicmp((char *)pValue->pVal, "S-", 2)
                && ConvertStringSidToSidA((char *)pValue->pVal, &pSid)) {

                __try {
                    // Now copy the converted SID into THAlloc'ed memory
                    THFreeEx(pTHS, pValue->pVal);
                    pValue->valLen = RtlLengthSid(pSid);
                    pValue->pVal = (PUCHAR)THAllocEx(pTHS, pValue->valLen);
                    CopyMemory(pValue->pVal, pSid, pValue->valLen);
                }
                __finally {
                    LocalFree(pSid);
                }

            }

            code = success;

            break;
        }
        //
        // deliberate fall through if this is not a SID.
        //

    case OM_S_GENERAL_STRING:
    case OM_S_GRAPHIC_STRING:
    case OM_S_OBJECT_DESCRIPTOR_STRING:
    case OM_S_VIDEOTEX_STRING:

        // Strings is strings, just use them.
        pValue->valLen = pLDAP_val->length;
        pValue->pVal = pLDAP_val->value;

        code = success;
        break;

    case OM_S_UNICODE_STRING:

        // NOTE: this is possibly an overallocation, since the input string may
        // be in UTF8 and therefore might have more than 1 byte per character.
        pValue->pVal =
            ( UCHAR * ) THAllocEx(pTHS,  sizeof(SYNTAX_UNICODE) * pLDAP_val->length);

        // convert to unicode
        pValue->valLen = MultiByteToWideChar(
                CodePage,
                0,
                (LPCSTR) (pLDAP_val->value),
                pLDAP_val->length,
                (LPWSTR) pValue->pVal,
                (sizeof(SYNTAX_UNICODE) * pLDAP_val->length));

        // right now, valLen is count of chars.  Adjust to count of bytes.
        pValue->valLen *= sizeof(SYNTAX_UNICODE);

        if (!pValue->valLen) {

            IF_DEBUG(ERR_NORMAL) {
                DPRINT1(0,"MultiByteToWideChar failed with %d\n",GetLastError());
            }
            code =  constraintViolation;
        }
        break;

    case OM_S_GENERALISED_TIME_STRING:
    case OM_S_UTC_TIME_STRING:
        {
           BOOL fLocalTimeSpecified = FALSE;

           pValue->valLen = sizeof(SYNTAX_TIME);
           pValue->pVal = ( UCHAR * ) THAllocEx(pTHS, pValue->valLen);
           if(!fTimeFromTimeStr((SYNTAX_TIME *) pValue->pVal,
                                (OM_syntax)pAC->OMsyntax,
                                (char *)pLDAP_val->value,
                                pLDAP_val->length,
                                &fLocalTimeSpecified)) {
               if (fLocalTimeSpecified) {
                  // this is valid syntax, but we don't support
                  code = unwillingToPerform;
               }
               else {
                  code = invalidAttributeSyntax;
               }
           }
        }
        break;

    case OM_S_I8:
        {
            SYNTAX_I8 *pInt;
            LONG sign=1;
            unsigned i;

            pInt = ( SYNTAX_I8  *) THAllocEx(pTHS, sizeof(SYNTAX_I8));
            pInt->QuadPart = 0;
            i=0;
            if(pLDAP_val->value[i] == '-') {
                sign = -1;
                i++;
            }

            if(i==pLDAP_val->length) {
                // No length or just a '-'
                return invalidAttributeSyntax;
            }

            for(;i<pLDAP_val->length;i++) {
                // Parse the string one character at a time to detect any
                // non-allowed characters.
                if((pLDAP_val->value[i] < '0') || (pLDAP_val->value[i] > '9'))
                    return invalidAttributeSyntax;

                pInt->QuadPart = ((pInt->QuadPart * 10) +
                                  pLDAP_val->value[i] - '0');
            }
            pInt->QuadPart *= sign;

            // Ok, got the value, set it up.
            pValue->valLen = sizeof( SYNTAX_I8 );
            pValue->pVal = (UCHAR *)pInt;
        }
        break;

    case OM_S_NULL:
    case OM_S_ENCODING_STRING:
    default:
        // huh?
        code = invalidAttributeSyntax;
    }

    return code;
}

_enum1
LDAP_DirAttrValToAttrVal (
        IN  THSTATE        *pTHS,
        IN  ULONG          CodePage,
        IN  ATTCACHE       *pAC,
        IN  ATTRVAL        *pValue,
        IN  ULONG          Flag,
        IN  PCONTROLS_ARG  pControlArg,
        OUT AssertionValue *pLDAP_val
        )
/*++
Routine Description:
    Translate a directory attribute value to an LDAP Attribute Value.  Assumes
    data representation as described by RFC-1778.

    NOTE: When possible, the values in the LDAP attribute value structure
    simply point to the same memory referenced by the directory attribute value.
    Remember this when freeing/using/dereffing memory.  When LDAP and core do
    not share a data representation, allocate memory.

Arguments:
    pAC - attcache of the attribute that this value is.
    pValue - pointer to the directory attribute value structure.
    pLDAP_val - pointer to the LDAP attribute value to fill up.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    _enum1 code=success;
    SYSTEMTIME sysTime;
    struct tm tmTime;

    if(!pAC) {
        return noSuchAttribute;
    }

    // Based on the att, turn the string we were given into a value.
        
    switch (pAC->OMsyntax) {
    case OM_S_BOOLEAN:
        if(*(BOOL *)pValue->pVal) {
            *pLDAP_val = TrueValue;
        }
        else {
            *pLDAP_val = FalseValue;
        }
        break;

    case OM_S_ENUMERATION:
    case OM_S_INTEGER:
        // allocate a big enough string.
        pLDAP_val->value = (PUCHAR)THAllocEx(pTHS, MAX_NUM_STRING_LENGTH);
        sprintf((char *)pLDAP_val->value,
                "%d",*( SYNTAX_INTEGER * )pValue->pVal);
        pLDAP_val->length = strlen((const char *)pLDAP_val->value);
        break;

    case OM_S_OBJECT:
        switch(pAC->syntax) {
        case SYNTAX_DISTNAME_TYPE:

            // DS_C_DS_DN
            code = LDAP_DSNameToLDAPDN(
                    CodePage,
                    (DSNAME *) pValue->pVal,
                    pControlArg->extendedDN,
                    (LDAPDN *)pLDAP_val);

            break;

        case SYNTAX_DISTNAME_BINARY_TYPE:

            if(OIDcmp(&pAC->OMObjClass, &MH_C_OR_NAME)) {
                // MH_C_OR_NAME

                code = LDAP_DirORNameToORName (
                        pTHS,
                        CodePage,
                        (SYNTAX_DISTNAME_BINARY *) pValue->pVal,
                        pLDAP_val);
            }
            else {
                code = LDAP_DirDNBlobToLDAPDNBlob (
                        pTHS,
                        CodePage,
                        (SYNTAX_DISTNAME_BINARY *) pValue->pVal,
                        pControlArg->extendedDN,
                        pLDAP_val);
            }
            break;

        case SYNTAX_ADDRESS_TYPE:
            // DS_C_PRESENTATION_ADDRESS
            code = LDAP_DirPresentationAddressToPresentationAddress(
                    CodePage,
                    (SYNTAX_ADDRESS *)pValue->pVal,
                    pLDAP_val);
            break;

        case SYNTAX_DISTNAME_STRING_TYPE:
            if(OIDcmp(&pAC->OMObjClass, &DS_C_ACCESS_POINT)) {
                // DS_C_ACCESS_POINT
                code = LDAP_DirAccessPointToAccessPoint (
                        pTHS,
                        CodePage,
                        (SYNTAX_DISTNAME_STRING *)pValue->pVal,
                        pLDAP_val);
            }
            else {
                code = LDAP_DirDNStringToLDAPDNString (
                        pTHS,
                        CodePage,
                        (SYNTAX_DISTNAME_STRING *)pValue->pVal,
                        pControlArg->extendedDN,
                        pLDAP_val);
            }

            break;

        case SYNTAX_OCTET_STRING_TYPE:
            // This had better be a replica-link valued object, since that is
            // all we support.
            code = LDAP_DirReplicaLinkToReplicaLink (
                    (REPLICA_LINK *)pValue->pVal,
                    pValue->valLen,
                    pLDAP_val);
            break;

        default:
            code = invalidAttributeSyntax;
            break;
        }

        break;
    case OM_S_OBJECT_IDENTIFIER_STRING:
        if(pAC->id == ATT_GOVERNS_ID || pAC->id == ATT_ATTRIBUTE_ID) {
            // Force into the dotted number path
            code = noSuchAttribute;
        }
        else {
            // OK, get the description format if we have it.
            code = LDAP_DirAttrTypToAttrType (
                    pTHS,
                    CodePage,
                    *(ATTRTYP *)pValue->pVal,
                    Flag,
                    (AttributeType *)pLDAP_val,
                    NULL);
            if(code == noSuchAttribute) {
                // Not an attribute, try a class.
                code =  LDAP_DirClassTypToAttrType (
                        pTHS,
                        CodePage,
                        *(ATTRTYP *)pValue->pVal,
                        Flag,
                        (AttributeType *)pLDAP_val,
                        NULL);
            }
        }

        if(code == noSuchAttribute) {

          // See if Binary flag is present. If yes, return BER encoding
          // instead of dotted decimal string
          if (!(Flag & ATT_OPT_BINARY)) {
            // no binary flag, do as usual.

              WCHAR OutBuff[512];         // Ought to be big enough
              int len;
              // no nice, printable version, since this isn't an attribute
              // or class I know. Turn it into a string representation of
              // the OID string.

              len = AttrTypToString(pTHS, *(ATTRTYP *)pValue->pVal,OutBuff, 512);
              if(len < 0)
                  code = noSuchAttribute;
              else {
                  // Use OutBuff[4] to avoid the "OID." that AttrTypeToString
                  // uses
                  pLDAP_val->value = (PUCHAR) String8FromUnicodeString(
                          FALSE,
                          CodePage,
                          &OutBuff[4],
                          len-4,
                          (PLONG) &pLDAP_val->length,
                          NULL);

                  if(!pLDAP_val->value) {
                      code = other;
                  }
                  else {
                      code = success;
                  }
              }
          }
          else {
             // Binary Flag. Send back BER encoding
              OID_t Oid;

              if (AttrTypeToOid (*(ATTRTYP *)pValue->pVal, &Oid)) {
                return noSuchAttribute;
               }
              pLDAP_val->length = Oid.length;
              pLDAP_val->value = (UCHAR *) Oid.elements;
              code = success;

          }
        }
        break;

    case OM_S_OBJECT_SECURITY_DESCRIPTOR:
        // if we are returning an SD to the user that is 8 bytes, 
        // that means that we are returning the internal format
        Assert (pValue->valLen > 8);

    case OM_S_GENERAL_STRING:
    case OM_S_GRAPHIC_STRING:
    case OM_S_IA5_STRING:
    case OM_S_NUMERIC_STRING:
    case OM_S_OBJECT_DESCRIPTOR_STRING:
    case OM_S_OCTET_STRING:
    case OM_S_PRINTABLE_STRING:
    case OM_S_TELETEX_STRING:
    case OM_S_VIDEOTEX_STRING:

        pLDAP_val->length = pValue->valLen;
        pLDAP_val->value = pValue->pVal;
        break;

    case OM_S_UNICODE_STRING:

        pLDAP_val->value = (PUCHAR) String8FromUnicodeString(
            FALSE,
            CodePage,
            (PWCHAR)pValue->pVal,
            pValue->valLen/sizeof(WCHAR),
            (PLONG) &pLDAP_val->length,
            NULL);

        if(!pLDAP_val->value) {
            code = other;
        }
        break;

    case OM_S_GENERALISED_TIME_STRING:
        Assert( pValue->valLen == 8 );
        pLDAP_val->length = 17;
        pLDAP_val->value = (PUCHAR) THAllocEx(pTHS, 18);

        //
        // if the caller did not supply a DSTIME, do a GetSystemTime here
        //

        if ( pValue->pVal != NULL ) {
            DSTimeToUtcSystemTime((*(DSTIME *) pValue->pVal),
                                  &sysTime);
        } else {
            GetSystemTime(&sysTime);
        }

        // Create a tm structure so that we can print
        // it out easily
        tmTime.tm_year = sysTime.wYear - 1900;
        tmTime.tm_mon = sysTime.wMonth - 1;
        tmTime.tm_wday = sysTime.wDayOfWeek;
        tmTime.tm_mday = sysTime.wDay;
        tmTime.tm_hour = sysTime.wHour;
        tmTime.tm_min = sysTime.wMinute;
        tmTime.tm_sec = sysTime.wSecond;
        tmTime.tm_isdst = 0;
        tmTime.tm_yday = 0;

        strftime(( char * ) pLDAP_val->value,
                 (pLDAP_val->length + 1),
                 "%Y%m%d%H%M%S.0Z",
                 &tmTime
                 );
        break;

    case OM_S_UTC_TIME_STRING:

        Assert( pValue->valLen == 8 );
        pLDAP_val->length = 13;
        pLDAP_val->value = (PUCHAR)THAllocEx(pTHS, 14);

        DSTimeToUtcSystemTime((*(DSTIME *) pValue->pVal),
                              &sysTime);

        // Create a tm structure so that we can print
        // it out easily
        tmTime.tm_year = sysTime.wYear - 1900;
        tmTime.tm_mon = sysTime.wMonth - 1;
        tmTime.tm_wday = sysTime.wDayOfWeek;
        tmTime.tm_mday = sysTime.wDay;
        tmTime.tm_hour = sysTime.wHour;
        tmTime.tm_min = sysTime.wMinute;
        tmTime.tm_sec = sysTime.wSecond;
        tmTime.tm_isdst = 0;
        tmTime.tm_yday = 0;

        strftime(( char * ) pLDAP_val->value,
                 (pLDAP_val->length + 1),
                 "%y%m%d%H%M%SZ",
                 &tmTime);
        break;
    case OM_S_I8:
        pLDAP_val->value = (PUCHAR)THAllocEx(pTHS, MAX_LONG_NUM_STRING_LENGTH);
        sprintf((PSZ)pLDAP_val->value,
                "%I64d",
                *((LARGE_INTEGER *) pValue->pVal) );
        pLDAP_val->length = strlen((const char *)pLDAP_val->value);
        break;

        break;

    case OM_S_NULL:
    case OM_S_ENCODING_STRING:
    default:
        // huh?
        code = invalidAttributeSyntax;
    }

    return code;
}

_enum1
LDAP_AttributeToDirAttr(
        IN  THSTATE   *pTHS,
        IN  ULONG     CodePage,
        IN  SVCCNTL*      Svccntl OPTIONAL,
        IN  Attribute *pAttribute,
        OUT ATTR      *pAttr
        )
/*++
Routine Description:
    Translate an LDAP attribute into an ATTR.

Arguments:
    pAttribute - the LDAP attribute list.
    pAttr - the Attr to fill in.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    ATTCACHE       *pAC, *pXMLAC;
    ATTRVAL        *pAVals;
    AttributeVals  pTempVals = pAttribute->vals;
    ULONG          count = 0;
    _enum1         code;
    DWORD          i, dwRealLength;
    BOOL           fFoundBinary = FALSE;
    BOOL           fFoundXML = FALSE;

    // Count the values for this attribute
    while(pTempVals) {
        count++;
        pTempVals = pTempVals->next;
    }

    // Start looking for the binary option on the attr type.
    for(i=0;(i<pAttribute->type.length) && (pAttribute->type.value[i] != ';');i++)
        ;

    //
    // Save the length of the att type since we will temporarily
    // change it if we find a binary option.  Putting this
    // here get's rid of a compiler warning.
    //
    dwRealLength = pAttribute->type.length;
    
    if (i < pAttribute->type.length) {
        //
        // Found a ';' now look for 'binary'.

        i++;
        //
        // Make sure there is room for a binary option.
        if (BINARY_OPTION_LENGTH == (pAttribute->type.length - i)) {

            // NOTE: memicmp is correct, since we're dealing with UTF8 or ASCII
            // here, and BINARY_OPTION is explicitly defined in the ASCII range.
            if(!_memicmp(&pAttribute->type.value[i],
                BINARY_OPTION,BINARY_OPTION_LENGTH)) {

                fFoundBinary = TRUE;
                pAttribute->type.length = i - 1;
            }
        }
        else if (XML_OPTION_LENGTH == (pAttribute->type.length - i)) {

            // NOTE: memicmp is correct, since we're dealing with UTF8 or ASCII
            // here, and BINARY_OPTION is explicitly defined in the ASCII range.
            if(!_memicmp(&pAttribute->type.value[i],
                XML_OPTION,XML_OPTION_LENGTH)) {

                fFoundXML = TRUE;
                pAttribute->type.length = i - 1;
            }
        }
    }

    // Set the attribute type;
    code = LDAP_AttrTypeToDirAttrTyp(
            pTHS,
            CodePage,
            Svccntl,
            &pAttribute->type,
            &pAttr->attrTyp,
            &pAC);
    if(code) {
        return code;
    }

    if (fFoundBinary) {
        pAttribute->type.length = dwRealLength;

        if(pAC->OMsyntax != OM_S_OCTET_STRING) {
            //
            // Binary is only allowed on things we hold as binary anyway.
            //
            return noSuchAttribute;
        }
    }
    else if (fFoundXML) {
        pAttribute->type.length = dwRealLength;

        pXMLAC = SCGetAttSpecialFlavor (pTHS, pAC, TRUE);
        if (pXMLAC) {
            DPRINT2 (0, "Found an XML attribute: 0x%x -> 0x%x\n", pAttr->attrTyp, pXMLAC->id);
            pAC = pXMLAC;
            pAttr->attrTyp = pXMLAC->id;
        }
    }

    // Allocate the ATTRVALS we need
    pAttr->AttrVal.valCount = count;
    if(!count) {
        pAttr->AttrVal.pAVal = NULL;
        return success;
    }
    pAttr->AttrVal.pAVal = (ATTRVAL *)THAllocEx(pTHS, count * sizeof(ATTRVAL));

    // Set up for the loop through the vals
    pAVals = pAttr->AttrVal.pAVal;
    pTempVals = pAttribute->vals;
    while(pTempVals) {
        code = LDAP_AttrValToDirAttrVal(
                pTHS,
                CodePage,
                Svccntl,
                pAC,
                (AssertionValue *)&pTempVals->value,
                pAVals);
        if(code) {
            return code;
        }

        pAVals++;
        pTempVals = pTempVals->next;
    }

    return success;
}

_enum1
LDAP_BuildAttrDescWithOptions(
    IN THSTATE * pTHS, 
    IN AttributeType *patOldTypeName,
    IN ATTFLAG       *pFlag,
    IN RANGEINFOITEM *pRangeInfoItem,
    OUT AttributeType *patNewTypeName
    )

/*++

Routine Description:

    This routine generates options for an output attribute type name.

Arguments:

    pTHS - 
    patOldTypeName - 
    pFlag - 
    pRangeInfoItem - 
    patNewTypeName - 

Return Value:

    _enum1 - 

--*/

{
    PUCHAR pcBuff, pcTemp;
    DWORD dwTotal;

    Assert( pFlag->flag );

    // Allocate worst case length
    dwTotal = patOldTypeName->length +
        1 + BINARY_OPTION_LENGTH +
        1 + RANGE_OPTION_LENGTH + 1 +
        15 + 1 + 15;
    pcTemp = pcBuff = (PUCHAR)THAllocEx(pTHS, dwTotal );

    // Copy base name
    memcpy(pcTemp, patOldTypeName->value, patOldTypeName->length);
    pcTemp += patOldTypeName->length;

    // Add in binary if necessary
    if(pFlag->flag & ATT_OPT_BINARY) {
        *pcTemp++ = ';';
        memcpy(pcTemp, BINARY_OPTION, BINARY_OPTION_LENGTH);
        pcTemp += BINARY_OPTION_LENGTH;
    }
    // Add in xml if necessary
    else if(pFlag->flag & ATT_OPT_XML) {
        *pcTemp++ = ';';
        memcpy(pcTemp, XML_OPTION, XML_OPTION_LENGTH);
        pcTemp += XML_OPTION_LENGTH;
    }

    // Add in range if necessary
    if(pFlag->flag & ATT_OPT_RANGE) {
        CHAR RangeString[31];
        DWORD cbRange;

        *pcTemp++ = ';';
        memcpy(pcTemp, RANGE_OPTION, RANGE_OPTION_LENGTH);
        pcTemp += RANGE_OPTION_LENGTH;
        // Tweak the name of the attribute to return that information.
        if(pRangeInfoItem->upper != 0xFFFFFFFF) {
            sprintf(RangeString,"%d-%d", pRangeInfoItem->lower, pRangeInfoItem->upper);
        }
        else {
            sprintf(RangeString,"%d-*", pRangeInfoItem->lower);
        }
        cbRange = strlen(RangeString);
        memcpy(pcTemp, RangeString, cbRange);
        pcTemp += cbRange;
    }

    // Return final result
    patNewTypeName->value = pcBuff;
    patNewTypeName->length = (DWORD) (pcTemp - pcBuff);

    Assert( patNewTypeName->length <= dwTotal );

    return success;
} /* LDAP_BuildAttrDescWithOptions */

_enum1
LDAP_AttrBlockToPartialAttributeList (
        IN  THSTATE               *pTHS,
        IN  ULONG                 CodePage,
        IN  ATTRBLOCK             *pAttrBlock,
        IN  RANGEINF              *pRangeInf,
        IN  ATTFLAG               *pFlags,
        IN  DSNAME                *pDSName,
        IN  CONTROLS_ARG          *pControlArg,
        IN  BOOL                  bFromEntry,
        OUT PartialAttributeList_ **ppAttributes
        )
/*++
Routine Description:
    Translate a directory ATTRBLOCK to an LDAP PartialAttributeList.  Allocate
    the PartialAttributeList here.

Arguments:
    pAttrBlock - pointer to the directory attrblock
    pControlArg - common arguments for this translation.
    ppAttributes - pointer to place to put pointer to PartialAttributeList.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    ATTCACHE *pAC;
    unsigned ldapIndex, dirIndex, index; // loop indices
    AttributeVals         pNextAttribute;
    PartialAttributeList_ *pAttributes;
    _enum1                code;
    ULONG                 i;
    PUCHAR                pTemp;
    DWORD                 numAttributesAllocated;

    // Allocate all the PartialAttributeList_'s we need
    numAttributesAllocated = pAttrBlock->attrCount;

    pAttributes = (PartialAttributeList_ *)
        THAllocEx(pTHS, numAttributesAllocated * sizeof(PartialAttributeList_));

    // Walk through all the attributes in the attr block.
    for(ldapIndex = 0, dirIndex=0;dirIndex<pAttrBlock->attrCount;dirIndex++) {
        ATTR *pAttr = &(pAttrBlock->pAttr[dirIndex]);
        BOOL  bExplicitRange;
        ULONG binaryFlag;

        // Turn the attrtyp in the attrblock into an LDAP attribute type.
        code = LDAP_DirAttrTypToAttrType (
                pTHS,
                CodePage,
                pAttr->attrTyp,
                0,
                &pAttributes[ldapIndex].value.type,
                &pAC);

        if(code) {
            // Something went wrong.
            return code;
        }

        binaryFlag = 0;
        bExplicitRange=FALSE;
        if(pFlags) {
            // We seem to have some flags
            for(i=0;
                ((pFlags[i].type != (ULONG) -1) && (pAC->id != pFlags[i].type));
                i++);
            if(pFlags[i].type == pAC->id) {
                // We found it.  We only support the ATT_BINARY right now.
                if(pFlags[i].flag & ATT_OPT_BINARY) {
                    binaryFlag = pFlags[i].flag;
                    pTemp = (PUCHAR)THAllocEx(pTHS,
                            pAttributes[ldapIndex].value.type.length + 1 +
                            BINARY_OPTION_LENGTH);

                    memcpy(pTemp,
                           pAttributes[ldapIndex].value.type.value,
                           pAttributes[ldapIndex].value.type.length);
                    pTemp[pAttributes[ldapIndex].value.type.length] = ';';

                    memcpy(&pTemp[pAttributes[ldapIndex].value.type.length + 1],
                           BINARY_OPTION,
                           BINARY_OPTION_LENGTH);

                    pAttributes[ldapIndex].value.type.value = pTemp;
                    pAttributes[ldapIndex].value.type.length +=
                        BINARY_OPTION_LENGTH + 1;
                }
                if(pFlags[i].flag & ATT_OPT_RANGE) {
                    // A range was explicitly asked for.
                    bExplicitRange = TRUE;
                }
            }
        }

        if(pRangeInf) {
            CHAR   RangeString[30];
            ULONG  cbRange;

            // We have some range limits returned from the server.  See if the
            // attribute we're currently processing is one which was limited.
            for(i=0;i<pRangeInf->count;i++) {
                if(pRangeInf->pRanges[i].AttId == pAC->id) {
                    // Yep, this one is limited.
                    if(!bExplicitRange) {
                        // We're range limited, but we didn't ask to be.  Make a
                        // new entry in the partial attribute list.
                        numAttributesAllocated++;
                        pAttributes = (PartialAttributeList_ *)
                            THReAllocEx(pTHS, pAttributes,
                                        (numAttributesAllocated *
                                         sizeof(PartialAttributeList_)));
                        pAttributes[ldapIndex + 1].value.type.length =
                            pAttributes[ldapIndex].value.type.length;
                        pAttributes[ldapIndex + 1].value.type.value =
                            pAttributes[ldapIndex].value.type.value;
                        pAttributes[ldapIndex].value.vals = NULL;
                        ldapIndex++;

                    }
                    // Tweak the name of the attribute to return that
                    // information.
                    if(pRangeInf->pRanges[i].upper != 0xFFFFFFFF) {
                        sprintf(RangeString,"%d-%d",
                                pRangeInf->pRanges[i].lower,
                                pRangeInf->pRanges[i].upper);
                    }
                    else {
                        sprintf(RangeString,"%d-*",
                                pRangeInf->pRanges[i].lower);
                    }
                    cbRange = strlen(RangeString);

                    pTemp =
                        (PUCHAR)THAllocEx(pTHS,
                                pAttributes[ldapIndex].value.type.length +
                                RANGE_OPTION_LENGTH + 1 +
                                cbRange);
                    memcpy(pTemp,
                           pAttributes[ldapIndex].value.type.value,
                           pAttributes[ldapIndex].value.type.length);
                    pTemp[pAttributes[ldapIndex].value.type.length] = ';';

                    memcpy(&pTemp[pAttributes[ldapIndex].value.type.length + 1],
                           RANGE_OPTION,
                           RANGE_OPTION_LENGTH);
                    memcpy(&pTemp[RANGE_OPTION_LENGTH + 1 +
                                  pAttributes[ldapIndex].value.type.length],
                           RangeString,
                           cbRange);
                    pAttributes[ldapIndex].value.type.value = pTemp;
                    pAttributes[ldapIndex].value.type.length +=
                        RANGE_OPTION_LENGTH + 1 + cbRange;

                    break;
                }
            }
        }

        if(!pAttr->AttrVal.valCount) {
            pAttributes[ldapIndex].value.vals = NULL;
            ldapIndex++;
            continue;
        }

        // allocate all the nodes in the LDAP value list for this attribute
        pNextAttribute = (AttributeVals)
            THAllocEx(pTHS, pAttr->AttrVal.valCount * sizeof(AttributeVals_));

        // Set up the first pointer.
        pAttributes[ldapIndex].value.vals = pNextAttribute;

        // Now, translate all the values.  Walk the values in the attrblock.
        for(index=0;index<pAttr->AttrVal.valCount;index++) {
            // Set up pointer to next val in chain.
            pNextAttribute[index].next = &(pNextAttribute[index+1]);

            // Turn the list from the core around as we hand it back to the LDAP
            // client. Solves a bug in ordering of the attribute objectClass,
            // and order of other attributes is unimportant.
            code = LDAP_DirAttrValToAttrVal (
                    pTHS,
                    CodePage,
                    pAC,
                    &pAttr->AttrVal.pAVal[pAttr->AttrVal.valCount - 1 - index],
                    binaryFlag,
                    pControlArg,
                    (AssertionValue *)&(pNextAttribute[index].value));
            if(code) {
                // Something went wrong
                return code;
            }
        }

        // No more values. Yes, this only works because we got at least one
        // value
        Assert(index>0);
        pNextAttribute[index-1].next = NULL;

        // Ok, we're including this in the ldap list, inc the ldap counter.
        ldapIndex++;
    }

    // No more attributes.

    // At this point, ldapIndex is the number of entries we have, and the last
    // entry has an invalid pointer.  Fix it, if we have any entries at all
    if(!ldapIndex) {
        // Somehow, we got no values, probably because they were all too long.
        THFree(pAttributes);
        pAttributes = NULL;
    }
    else {
        // Set up pointer to next attribute in chain.
        for(i=0;i<ldapIndex;i++) {
            pAttributes[i].next = &pAttributes[i+1];
        }
        // Set the last pointer to null.
        pAttributes[ldapIndex-1].next = NULL;
    }

    // Set up the return value.
    *ppAttributes = pAttributes;
    return success;
}

extern _enum1
LDAP_LDAPRDNToAttr (
        IN  THSTATE           *pTHS,
        IN  ULONG             CodePage,
        IN  RelativeLDAPDN    *pLDAPRDN,
        OUT ATTR              *pAttr
        )
/*++
Routine Description:
    Translate an LDAP RDN into an ATTR.

Arguments:
    pLDAPRDN - the LDAP RDN.
    pAttr - the Attr to fill in.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    DSNAME *pDN, *pTrimmed;
    WCHAR  RDNBuff[MAX_RDN_SIZE], *pRDNVal = (WCHAR *)RDNBuff;
    ULONG  rdnLen=0;
    _enum1 code;

    // First, we have to turn the pLDAPRDN into a dsname
    code = LDAP_LDAPDNToDSName(CodePage,pLDAPRDN,&pDN);
    if(code) {
        return code;
    }

    if(IsRoot(pDN)) {
        // Hey! they didn't give us a string to work with.
        return protocolError;
    }

    // Now, get the info out as an RDN
    if(GetRDNInfo(pTHS, pDN,pRDNVal, &rdnLen, &pAttr->attrTyp) || !rdnLen) {
        // Nothing there that we can work with.
        return namingViolation;
    }

    // Make sure the RDN is just that, an RDN, not a full DN
    pTrimmed = (DSNAME *)THAlloc(pDN->structLen);
    if (!pTrimmed) {
        return other;
    }
    if(TrimDSNameBy(pDN,1,pTrimmed) || // At least one name part
       !IsRoot(pTrimmed)) {            // At most one name part
        // Nope, it was a full DN
        THFree(pTrimmed);
        return namingViolation;
    }

    // Set up the Attr.
    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS, sizeof(ATTRVAL));

    // rdnLen is a count of WCHARS, turn it into a count of bytes
    rdnLen *=sizeof(WCHAR);

    // Don't need the DN anymore, might as well recycle.
    pAttr->AttrVal.pAVal->pVal=(PUCHAR)THReAllocEx(pTHS, pDN,rdnLen*sizeof(WCHAR));
    pDN = NULL;

    // Now, copy the rdn to the newly (re)alloced memory
    memcpy(pAttr->AttrVal.pAVal->pVal,pRDNVal,rdnLen*sizeof(WCHAR));


    pAttr->AttrVal.pAVal->valLen = rdnLen;

    THFree(pTrimmed);
    return success;
}

_enum1
LDAP_AssertionValueToDirAVA (
        IN  THSTATE                  *pTHS,
        IN  ULONG                    CodePage,
        IN  SVCCNTL*                 Svccntl OPTIONAL,
        IN  AttributeValueAssertion  *pAva,
        OUT AVA *pDirAva)
/*++
Routine Description:
    Translate an LDAP attribute value assertion into a DIR ava.

Arguments:
    pAva - the ldap attribute value assertion
    pDirAva - the dir ava to fill in

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    ATTCACHE *pAC=NULL;
    _enum1   code;

    // Translate the attribute type.
    code = LDAP_AttrDescriptionToDirAttrTyp (
                 pTHS,
                 CodePage,
                 Svccntl,
                 &pAva->attributeDesc,
                 ATT_OPT_BINARY,
                 &pDirAva->type,
                 NULL,
                 NULL,
                 &pAC
                 );

    if(!code) {
        // Translate the attribute value.
        code = LDAP_AttrValToDirAttrVal (
                pTHS,
                CodePage,
                Svccntl,
                pAC,
                &pAva->assertionValue,
                &pDirAva->Value);
    }

    return code;
}

_enum1
LDAP_AttributeListToAttrBlock(
        IN  THSTATE       *pTHS,
        IN  ULONG         CodePage,
        IN  SVCCNTL*      Svccntl OPTIONAL,
        IN  AttributeList pAttributes,
        OUT ATTRBLOCK     *pAttrBlock
        )
/*++
Routine Description:
    Translate an LDAP attribute list into an ATTRBLOCK.

Arguments:
    pAttributes - the LDAP attribute list.
    pAttrBloc - the AttrBlock to fill in.

Return Values:
    success if all went well, an ldap error other wise.

--*/
{
    AttributeList pTempAL;
    ULONG         count=0;
    ATTR          *pAttrs;
    _enum1        code;

    // First, count the number of attributes.
    pTempAL=pAttributes;
    while(pTempAL) {
        count++;
        pTempAL = pTempAL->next;
    }

    // Allocate the ATTRs we need;
    pAttrBlock->attrCount = count;
    pAttrBlock->pAttr = (ATTR *)THAllocEx(pTHS, count * sizeof(ATTR));

    // Set up for the loop through the attrs
    pAttrs = pAttrBlock->pAttr;
    pTempAL=pAttributes;
    while(pTempAL) {
        code = LDAP_AttributeToDirAttr(
                pTHS,
                CodePage,
                Svccntl,
                (Attribute *)&pTempAL->value,
                pAttrs);
        if(code) {
            return code;
        }

        if(!pAttrs->AttrVal.valCount) {
            // If you are building a list, you must have some values.  If you
            // want a list with no values, build an entinfsel.

            IF_DEBUG(ERR_NORMAL) {
                DPRINT1(0,"AttributeToDirAttr failed with %d\n",code);
            }
            return constraintViolation;
        }

        pAttrs++;
        pTempAL = pTempAL->next;
    }


    return success;
}


extern _enum1
LDAP_DecodeAttrDescriptionOptions (
        IN  THSTATE       *pTHS,
        IN  ULONG          CodePage,
        IN  SVCCNTL*       Svccntl  OPTIONAL,
        IN  AttributeType *LDAP_att OPTIONAL,
        IN OUT  ATTRTYP   *pAttrType,
        IN  ATTCACHE      *pAC,
        IN  DWORD         dwPossibleFlags,
        OUT ATTFLAG       *pFlag  OPTIONAL,
        OUT RANGEINFSEL   *pRange OPTIONAL,
        OUT ATTCACHE      **ppAC  OPTIONAL
        )
{
    // Look for options.  We support Range.
    DWORD  i, dwTemp;
    BOOL   done;
    BOOL   fFoundRange=FALSE;
    BOOL   fFoundBinary=FALSE;
    BOOL   fFoundXML=FALSE;
    _enum1 code;
    ATTCACHE *pBINAC=NULL;
    ATTCACHE *pXMLAC=NULL;

    if (pFlag) {
        pFlag->flag = 0;
        pFlag->type = 0;
    }

    // Start by scanning forward through the attribute type looking for a ';'
    for(i=0;(i<LDAP_att->length) && (LDAP_att->value[i] != ';');i++);

    if(i >= LDAP_att->length) {
        return success;
    }

    // OK, there definitely seem to be some options, or at least, a ';'
    i++;
    while(i<LDAP_att->length) {
        switch(LDAP_att->value[i]) {
        case 'r':
        case 'R':
            if(fFoundRange || !(dwPossibleFlags & ATT_OPT_RANGE)) {
                // two ranges are illegal, or the caller is not expecting 
                // the range option at this point.
                return  noSuchAttribute;
            }

            // OK, look for Range=X[-Y];
            if((LDAP_att->length - i) < RANGE_OPTION_LENGTH) {
                // Not enough room for options
                return  noSuchAttribute;
            }

            // NOTE: memicmp is correct, since we're dealing with UTF8 or ASCII
            // here, and RANGE_OPTION is explicitly defined in the ASCII range.
            if(_memicmp(&LDAP_att->value[i],RANGE_OPTION,RANGE_OPTION_LENGTH)) {
                // Not a range option
                return  noSuchAttribute;
            }

            // OK, looks like a range option.
            i+= RANGE_OPTION_LENGTH;

            if (!pRange) {
                //
                // Don't bother parsing out the rest of the range.  Just
                // skip to the next option.
                //
                for (;i<LDAP_att->length && LDAP_att->value[i] != ';'; i++);
                if (LDAP_att->value[i] == ';') {
                    i++;
                }
                break;
            }
            pRange->pRanges[pRange->count].AttId = *pAttrType;

            // Parse out the actual ranges.
            dwTemp = 0;
            done = FALSE;
            for(;!done && i<LDAP_att->length;i++) {
                // Parse the string one character at a time to detect any
                // non-allowed characters.
                if((LDAP_att->value[i] < '0') || LDAP_att->value[i] > '9')
                    done = TRUE;
                else
                    dwTemp = dwTemp * 10 + LDAP_att->value[i] - '0';
            }
            if(done)
                i--;
            pRange->pRanges[pRange->count].lower = dwTemp;
            if(i == LDAP_att->length) {
                // just found range=X
                pRange->pRanges[pRange->count].upper =
                    pRange->pRanges[pRange->count].lower;
            }
            else if(i < LDAP_att->length) {
                // room for more stuff
                switch(LDAP_att->value[i]) {
                case ';':
                    // No more to the range option
                    pRange->pRanges[pRange->count].upper =
                        pRange->pRanges[pRange->count].lower;
                    break;
                case '-':
                    // OK, look for the rest of the range
                    i++;
                    if(i >= LDAP_att->length) {
                        return  noSuchAttribute;
                    }
                    if(LDAP_att->value[i] == '*') {
                        pRange->pRanges[pRange->count].upper = 0xFFFFFFFF;
                        i++;
                    }
                    else {
                        dwTemp = 0;
                        done = FALSE;
                        for(;!done && i<LDAP_att->length;i++) {
                            // Parse the string one character at a time to
                            // detect  any non-allowed characters.
                            if((LDAP_att->value[i] < '0') ||
                               LDAP_att->value[i] > '9')
                                done = TRUE;
                            else
                                dwTemp = dwTemp * 10 + LDAP_att->value[i] - '0';
                        }
                        if(done)
                            i--;
                        pRange->pRanges[pRange->count].upper = dwTemp;
                    }
                    break;
                default:
                    // Malformed.
                    return  noSuchAttribute;
                    break;
                }
            }

            if (pFlag) {
                if (!fFoundXML) {
                    // don't want to overwrite it
                    pFlag->type = *pAttrType;
                }
                pFlag->flag |= ATT_OPT_RANGE;
            }
            if (pRange) {
                pRange->count++;
            }
            fFoundRange = TRUE;

            break;

        case 'b':
        case 'B':
            
            // OK, look for Binary
            if(fFoundBinary || !(dwPossibleFlags & ATT_OPT_BINARY)) {
                // Can't specify two binary options, or the caller isn't
                // expecting a binary option here.
                return  noSuchAttribute;
            }

            // OK, look for binary;
            if((LDAP_att->length - i) < BINARY_OPTION_LENGTH) {
                // Not enough room for options
                return  noSuchAttribute;
            }

            // NOTE: memicmp is correct, since we're dealing with UTF8 or ASCII
            // here, and BINARY_OPTION is explicitly defined in the ASCII range.
            if(_memicmp(&LDAP_att->value[i],
                        BINARY_OPTION,BINARY_OPTION_LENGTH)) {
                // Not a binary option
                return  noSuchAttribute;
            }

            pBINAC = SCGetAttSpecialFlavor (pTHS, pAC, FALSE);
            if (pBINAC) {
                pAC = pBINAC;
                DPRINT2 (1, "Found a special BINARY attribute: 0x%x -> 0x%x\n", *pAttrType, pBINAC->id);
                *pAttrType = pBINAC->id;
                if(ppAC) {
                    *ppAC = pAC;
                }
            }

            // OK, looks like a binary option.
            i+= BINARY_OPTION_LENGTH;
            if (pFlag) {
                pFlag->type = *pAttrType;
                pFlag->flag |= ATT_OPT_BINARY;
            }
            fFoundBinary = TRUE;

            if((pAC->OMsyntax != OM_S_OCTET_STRING)
                 && (pAC->OMsyntax != OM_S_OBJECT_IDENTIFIER_STRING)
                 && (pAC->OMsyntax != OM_S_UNICODE_STRING)) {
                
                // Binary is only allowed on things we hold as binary
                return noSuchAttribute;
            }
            break;

        case 'x':
        case 'X':
            
            DPRINT (1, "Looking for XML option\n");
            // OK, look for xml
            if(fFoundXML || !(dwPossibleFlags & ATT_OPT_XML)) {
                // Either there were to xml options, which is illegal,
                // or the caller did not expect the xml option here.
                return  noSuchAttribute;
            }

            // OK, look for xml;
            if((LDAP_att->length - i) < XML_OPTION_LENGTH) {
                // Not enough room for options
                return  noSuchAttribute;
            }

            // NOTE: memicmp is correct, since we're dealing with UTF8 or ASCII
            // here, and XML_OPTION is explicitly defined in the ASCII range.
            if(_memicmp(&LDAP_att->value[i],
                        XML_OPTION,XML_OPTION_LENGTH)) {
                // Not a binary option
                return  noSuchAttribute;
            }

            pXMLAC = SCGetAttSpecialFlavor (pTHS, pAC, TRUE);
            if (pXMLAC) {
                pAC = pXMLAC;
                DPRINT2 (1, "Found an XML attribute: 0x%x -> 0x%x\n", *pAttrType, pXMLAC->id);
                *pAttrType = pXMLAC->id;
                if(ppAC) {
                    *ppAC = pAC;
                }
            }

            // OK, looks like an xml option.
            i+= XML_OPTION_LENGTH;
            if (pFlag) {
                pFlag->type = *pAttrType;
                pFlag->flag |= ATT_OPT_XML;
            }
            fFoundXML = TRUE;
            break;

        default:
            return noSuchAttribute;
            // NYI
            break;
        }

        if(i < LDAP_att->length) {
            // We better have been left on a ; if we have anything left.
            if(LDAP_att->value[i] == ';')
                i++;
            else
                return noSuchAttribute;
        }
    }
    // Something went wrong.
    return success;

}

extern _enum1
LDAP_AttrDescriptionToDirAttrTyp (
        IN  THSTATE       *pTHS,
        IN  ULONG          CodePage,
        IN  SVCCNTL*      Svccntl OPTIONAL,
        IN  AttributeType *LDAP_att,
        IN  DWORD         dwPossibleOptions,
        OUT ATTRTYP       *pAttrType,
        OUT ATTFLAG       *pFlag,
        OUT RANGEINFSEL   *pRange,
        OUT ATTCACHE     **ppAC         // OPTIONAL
        )
{
    // Look for options.  We support Range.
    DWORD  chopAt, i;
    _enum1 code;
    ATTCACHE *pAC=NULL;

    if (pFlag) {
        pFlag->flag = 0;
        pFlag->type = 0;
    }

    // Start by scanning forward through the attribute type looking for a ';'
    for(i=0;(i<LDAP_att->length) && (LDAP_att->value[i] != ';');i++);

    if(i >= LDAP_att->length) {
        // No options, just call attrtype
        return LDAP_AttrTypeToDirAttrTyp (
                pTHS,
                CodePage,
                Svccntl,
                LDAP_att,
                pAttrType,
                ppAC);
    }

    chopAt = LDAP_att->length;
    LDAP_att->length = i;

    code = LDAP_AttrTypeToDirAttrTyp (
            pTHS,
            CodePage,
            Svccntl,
            LDAP_att,
            pAttrType,
            &pAC);
    if(ppAC) {
        *ppAC = pAC;
    }

    LDAP_att->length = chopAt;
    if(code != success) {
        return code;
    }

    return LDAP_DecodeAttrDescriptionOptions(
        pTHS,
        CodePage,
        Svccntl,
        LDAP_att,
        pAttrType,
        pAC,
        dwPossibleOptions,
        pFlag,
        pRange,
        ppAC
        );
}

#define         TELETEX_CHAR    ((BYTE) 1)
#define         IA5_CHAR        ((BYTE) 2)
#define         PRINTABLE_CHAR  ((BYTE) 4)
#define         NUMERIC_CHAR    ((BYTE) 8)

BYTE rgbCharacterSet[256] = {
/* 00 */  IA5_CHAR,
/* 01 */  IA5_CHAR,
/* 02 */  IA5_CHAR,
/* 03 */  IA5_CHAR,
/* 04 */  IA5_CHAR,
/* 05 */  IA5_CHAR,
/* 06 */  IA5_CHAR,
/* 07 */  IA5_CHAR,
/* 08 */  IA5_CHAR,
/* 09 */  IA5_CHAR,
/* 0a */  IA5_CHAR,
/* 0b */  IA5_CHAR,
/* 0c */  IA5_CHAR,
/* 0d */  IA5_CHAR,
/* 0e */  IA5_CHAR,
/* 0f */  IA5_CHAR,
/* 00 */  IA5_CHAR,
/* 11 */  IA5_CHAR,
/* 12 */  IA5_CHAR,
/* 13 */  IA5_CHAR,
/* 14 */  IA5_CHAR,
/* 15 */  IA5_CHAR,
/* 16 */  IA5_CHAR,
/* 17 */  IA5_CHAR,
/* 18 */  IA5_CHAR,
/* 19 */  IA5_CHAR,
/* 1a */  IA5_CHAR,
/* 1b */  IA5_CHAR,
/* 1c */  IA5_CHAR,
/* 1d */  IA5_CHAR,
/* 1e */  IA5_CHAR,
/* 1f */  IA5_CHAR,
/* 20 */  IA5_CHAR | TELETEX_CHAR | NUMERIC_CHAR | PRINTABLE_CHAR,
/* 21 */  IA5_CHAR | TELETEX_CHAR,
/* 22 */  IA5_CHAR | TELETEX_CHAR,
/* 23 */  IA5_CHAR | TELETEX_CHAR,
/* 24 */  IA5_CHAR | TELETEX_CHAR,
/* 25 */  IA5_CHAR | TELETEX_CHAR,
/* 26 */  IA5_CHAR | TELETEX_CHAR,
/* 27 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 28 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 29 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 2a */  IA5_CHAR | TELETEX_CHAR,
/* 2b */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 2c */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 2d */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 2e */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 2f */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 30 */  IA5_CHAR | TELETEX_CHAR | NUMERIC_CHAR | PRINTABLE_CHAR,
/* 31 */  IA5_CHAR | TELETEX_CHAR | NUMERIC_CHAR | PRINTABLE_CHAR,
/* 32 */  IA5_CHAR | TELETEX_CHAR | NUMERIC_CHAR | PRINTABLE_CHAR,
/* 33 */  IA5_CHAR | TELETEX_CHAR | NUMERIC_CHAR | PRINTABLE_CHAR,
/* 34 */  IA5_CHAR | TELETEX_CHAR | NUMERIC_CHAR | PRINTABLE_CHAR,
/* 35 */  IA5_CHAR | TELETEX_CHAR | NUMERIC_CHAR | PRINTABLE_CHAR,
/* 36 */  IA5_CHAR | TELETEX_CHAR | NUMERIC_CHAR | PRINTABLE_CHAR,
/* 37 */  IA5_CHAR | TELETEX_CHAR | NUMERIC_CHAR | PRINTABLE_CHAR,
/* 38 */  IA5_CHAR | TELETEX_CHAR | NUMERIC_CHAR | PRINTABLE_CHAR,
/* 39 */  IA5_CHAR | TELETEX_CHAR | NUMERIC_CHAR | PRINTABLE_CHAR,
/* 3a */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 3b */  IA5_CHAR | TELETEX_CHAR,
/* 3c */  IA5_CHAR | TELETEX_CHAR,
/* 3d */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 3e */  IA5_CHAR | TELETEX_CHAR,
/* 3f */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 40 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR, // @ is not actually a printable
                                                    // char, but was added to keep from
                                                    // breaking Instant Messenger.
                                                    // Windows Bugs 205690
/* 41 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 42 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 43 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 44 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 45 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 46 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 47 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 48 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 49 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 4a */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 4b */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 4c */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 4d */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 4e */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 4f */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 50 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 51 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 52 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 53 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 54 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 55 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 56 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 57 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 58 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 59 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 5a */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 5b */  IA5_CHAR | TELETEX_CHAR,
/* 5c */  IA5_CHAR | TELETEX_CHAR,
/* 5d */  IA5_CHAR | TELETEX_CHAR,
/* 5e */  IA5_CHAR | TELETEX_CHAR,
/* 5f */  IA5_CHAR | TELETEX_CHAR,
/* 60 */  IA5_CHAR | TELETEX_CHAR,
/* 61 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 62 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 63 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 64 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 65 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 66 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 67 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 68 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 69 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 6a */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 6b */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 6c */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 6d */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 6e */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 6f */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 70 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 71 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 72 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 73 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 74 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 75 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 76 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 77 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 78 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 79 */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 7a */  IA5_CHAR | TELETEX_CHAR | PRINTABLE_CHAR,
/* 7b */  IA5_CHAR | TELETEX_CHAR,
/* 7c */  IA5_CHAR | TELETEX_CHAR,
/* 7d */  IA5_CHAR | TELETEX_CHAR,
/* 7e */  IA5_CHAR | TELETEX_CHAR,
/* 7f */  IA5_CHAR,
/* 80 */  0,
/* 81 */  0,
/* 82 */  0,
/* 83 */  0,
/* 84 */  0,
/* 85 */  0,
/* 86 */  0,
/* 87 */  0,
/* 88 */  0,
/* 89 */  0,
/* 8a */  0,
/* 8b */  0,
/* 8c */  0,
/* 8d */  0,
/* 8e */  0,
/* 8f */  0,
/* 90 */  0,
/* 91 */  0,
/* 92 */  0,
/* 93 */  0,
/* 94 */  0,
/* 95 */  0,
/* 96 */  0,
/* 97 */  0,
/* 98 */  0,
/* 99 */  0,
/* 9a */  0,
/* 9b */  0,
/* 9c */  0,
/* 9d */  0,
/* 9e */  0,
/* 9f */  0,
/* a0 */  0,
/* a1 */  TELETEX_CHAR,
/* a2 */  TELETEX_CHAR,
/* a3 */  TELETEX_CHAR,
/* a4 */  TELETEX_CHAR,
/* a5 */  TELETEX_CHAR,
/* a6 */  TELETEX_CHAR,
/* a7 */  TELETEX_CHAR,
/* a8 */  TELETEX_CHAR,
/* a9 */  TELETEX_CHAR,
/* aa */  TELETEX_CHAR,
/* ab */  TELETEX_CHAR,
/* ac */  TELETEX_CHAR,
/* ad */  TELETEX_CHAR,
/* ae */  TELETEX_CHAR,
/* af */  TELETEX_CHAR,
/* b0 */  TELETEX_CHAR,
/* b1 */  TELETEX_CHAR,
/* b2 */  TELETEX_CHAR,
/* b3 */  TELETEX_CHAR,
/* b4 */  TELETEX_CHAR,
/* b5 */  TELETEX_CHAR,
/* b6 */  TELETEX_CHAR,
/* b7 */  TELETEX_CHAR,
/* b8 */  TELETEX_CHAR,
/* b9 */  TELETEX_CHAR,
/* ba */  TELETEX_CHAR,
/* bb */  TELETEX_CHAR,
/* bc */  TELETEX_CHAR,
/* bd */  TELETEX_CHAR,
/* be */  TELETEX_CHAR,
/* bf */  TELETEX_CHAR,
/* c0 */  TELETEX_CHAR,
/* c1 */  TELETEX_CHAR,
/* c2 */  TELETEX_CHAR,
/* c3 */  TELETEX_CHAR,
/* c4 */  TELETEX_CHAR,
/* c5 */  TELETEX_CHAR,
/* c6 */  TELETEX_CHAR,
/* c7 */  TELETEX_CHAR,
/* c8 */  TELETEX_CHAR,
/* c9 */  TELETEX_CHAR,
/* ca */  TELETEX_CHAR,
/* cb */  TELETEX_CHAR,
/* cc */  TELETEX_CHAR,
/* cd */  TELETEX_CHAR,
/* ce */  TELETEX_CHAR,
/* cf */  TELETEX_CHAR,
/* d0 */  TELETEX_CHAR,
/* d1 */  TELETEX_CHAR,
/* d2 */  TELETEX_CHAR,
/* d3 */  TELETEX_CHAR,
/* d4 */  TELETEX_CHAR,
/* d5 */  TELETEX_CHAR,
/* d6 */  TELETEX_CHAR,
/* d7 */  TELETEX_CHAR,
/* d8 */  TELETEX_CHAR,
/* d9 */  TELETEX_CHAR,
/* da */  TELETEX_CHAR,
/* db */  TELETEX_CHAR,
/* dc */  TELETEX_CHAR,
/* dd */  TELETEX_CHAR,
/* de */  TELETEX_CHAR,
/* df */  TELETEX_CHAR,
/* e0 */  TELETEX_CHAR,
/* e1 */  TELETEX_CHAR,
/* e2 */  TELETEX_CHAR,
/* e3 */  TELETEX_CHAR,
/* e4 */  TELETEX_CHAR,
/* e5 */  TELETEX_CHAR,
/* e6 */  TELETEX_CHAR,
/* e7 */  TELETEX_CHAR,
/* e8 */  TELETEX_CHAR,
/* e9 */  TELETEX_CHAR,
/* ea */  TELETEX_CHAR,
/* eb */  TELETEX_CHAR,
/* ec */  TELETEX_CHAR,
/* ed */  TELETEX_CHAR,
/* ee */  TELETEX_CHAR,
/* ef */  TELETEX_CHAR,
/* f0 */  TELETEX_CHAR,
/* f1 */  TELETEX_CHAR,
/* f2 */  TELETEX_CHAR,
/* f3 */  TELETEX_CHAR,
/* f4 */  TELETEX_CHAR,
/* f5 */  TELETEX_CHAR,
/* f6 */  TELETEX_CHAR,
/* f7 */  TELETEX_CHAR,
/* f8 */  TELETEX_CHAR,
/* f9 */  TELETEX_CHAR,
/* fa */  TELETEX_CHAR,
/* fb */  TELETEX_CHAR,
/* fc */  TELETEX_CHAR,
/* fd */  TELETEX_CHAR,
/* fe */  TELETEX_CHAR,
/* ff */  0
};

//
// Check string syntax validity
//

_enum1 CheckStringSyntax(int syntax, AssertionValue *pLDAP_val)
{
    BYTE        *pb     = (BYTE *) pLDAP_val->value;
    BYTE        bMask;
    unsigned int i;

    syntax &= OM_S_SYNTAX;

    switch (syntax)
    {
        case OM_S_IA5_STRING:
            bMask = IA5_CHAR;
            break;

        case OM_S_TELETEX_STRING:
            bMask = TELETEX_CHAR;
            break;

        case OM_S_NUMERIC_STRING:
            bMask = NUMERIC_CHAR;
            break;

        case OM_S_PRINTABLE_STRING:
            bMask = PRINTABLE_CHAR;
            break;

        default:
            return success;
    }

    for (i=0; i< pLDAP_val->length; i++, pb++)
        if (!(rgbCharacterSet[*pb] & bMask))
            return invalidAttributeSyntax;

    return success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\ldap\limits.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    limits.cxx

Abstract:

    This module implements the LDAP server for the NT5 Directory Service.

    This file contains code to support the LDAP limits and the
    Directory Service's configurable settings such as the maximum
    time to live (EntryTTL).
    
    CLEANUP: split the LDAP limits and configurable settings code
    into separate, more generic routines.

Author:

    Johnson Apacible    (johnsona)  19-Jan-1998

--*/

#include <NTDSpchx.h>
#pragma  hdrstop

#include <filtypes.h>
#include "ldapsvr.hxx"
#include <attids.h>
#include "limits.hxx"
extern "C" {
#include <mdlocal.h>
#include <taskq.h>
}

#define FILENO FILENO_LDAP_LIMITS
#define LOCALHOST       0x100007f   // 127.0.0.1

VOID
DeferredNotification(
    IN  VOID *  pvParam,
    IN  VOID ** ppvParamNext,
    OUT DWORD * pcSecsUntilNextIteration
    );

BOOL
RegisterLimitsNotification(
    IN DSNAME*  DnName,
    IN DWORD    ClientId
    );

BOOL
DottedDecimalToDword(
    IN PCHAR*   ppszAddress,
    IN DWORD *  pdwAddress,
    IN PCHAR    pszLast
    );

BOOL
IsNotifyValid(
    IN PLIMITS_NOTIFY_BLOCK notifyBlock
    );

BOOL
DsReadLimits(
    IN DSNAME*  DnName,
    IN ATTRTYP  AttType,
    OUT ATTRVALBLOCK**  AttrVals
    );

BOOL
LdapAppendAttrBlocks(
    IN ATTRVALBLOCK*    BaseBlock,
    IN ATTRVALBLOCK*    NewBlock
    );

VOID
LimitsReceiveNotificationData (
        IN DWORD hClient,
        IN DWORD hServer,
        IN ENTINF *pEntinf
        );

//
// Globals
//

LDAPDN DefQueryPolicy =
    DEFINE_LDAP_STRING("CN=Default Query Policy,CN=Query-Policies,");

DWORD   hDefQPNotify = 0;
DWORD   hServerLinkNotify = 0;
DWORD   hSiteLinkNotify = 0;
DWORD   hSiteQPNotify = 0;
DWORD   hServerQPNotify = 0;


VOID
DereferenceDenyList(
    IN PIP_SEC_LIST DenyList
    )
{
    if ( InterlockedDecrement((PLONG)&DenyList->RefCount) == 0 ) {
        IF_DEBUG(LIMITS) {
            DPRINT1(0,"Freeing LDAP deny list %x\n", DenyList);
        }
        LdapFree(DenyList);
    }
} // DereferenceDenyList

VOID
ReferenceDenyList(
    IN PIP_SEC_LIST DenyList
    )
{
    Assert(DenyList->RefCount > 0);
    InterlockedIncrement((PLONG)&DenyList->RefCount);
} // ReferenceDenyList


VOID
ResetDefaultConfSets(
    VOID
    )
{
    IF_DEBUG(LIMITS) {
        DPRINT(0,"Resetting Default configurable settings\n");
    }

    DynamicObjectDefaultTTL = DEFAULT_DYNAMIC_OBJECT_DEFAULT_TTL;
    DynamicObjectMinTTL = DEFAULT_DYNAMIC_OBJECT_MIN_TTL;

    return;

} // ResetDefaultConfSets


VOID
ResetDefaultLimits(
    VOID
    )
{
    IF_DEBUG(LIMITS) {
        DPRINT(0,"Resetting Default limits\n");
    }

    LdapAtqMaxPoolThreads = 4;
    LdapMaxDatagramRecv = DEFAULT_LDAP_MAX_DGRAM_RECV;
    LdapMaxReceiveBuffer = DEFAULT_LDAP_MAX_RECEIVE_BUF;
    LdapInitRecvTimeout = DEFAULT_LDAP_INIT_RECV_TIMEOUT;
    LdapMaxConnections = DEFAULT_LDAP_CONNECTIONS_LIMIT;
    LdapMaxConnIdleTime = DEFAULT_LDAP_MAX_CONN_IDLE;
    LdapMaxPageSize = DEFAULT_LDAP_SIZE_LIMIT;
    LdapMaxQueryDuration = DEFAULT_LDAP_TIME_LIMIT;
    LdapMaxTempTable = DEFAULT_LDAP_MAX_TEMP_TABLE;
    LdapMaxResultSet = DEFAULT_LDAP_MAX_RESULT_SET;
    LdapMaxNotifications = DEFAULT_LDAP_NOTIFICATIONS_PER_CONNECTION_LIMIT;

    return;

} // ResetDefaultLimits


BOOL
ProcessIpDenyList(
    IN  ATTRVALBLOCK*  AttrVals
    )
/*++

Routine Description:

    This routine reads the deny IP list from the DS

Arguments:

    IpSecList - on return, will contain a new system IP_SEC_LIST.
        Up to the user to delete the old one.

Return Value:

    FALSE, memory alloc failed or cannot read DS

--*/
{

    DWORD i, m;
    DWORD nEntries = 0;
    DWORD realCount = 0;
    DWORD nMasks = 0;
    BOOL  fRet = TRUE;

    PLIST_ENTRY  listEntry;
    LIST_ENTRY  entryList;
    PTEMP_IP_ENTRY_NODE pIPList = NULL;
    PIP_MASK_GROUP  maskGroup;
    PIP_SEC_ENTRY   ipEntry;
    PIP_SEC_LIST    ipSecList = NULL;

    ATTVAL* vals;

    IF_DEBUG(LIMITS) {
        DPRINT(0,"Reading LDAP Deny List\n");
    }

    //
    // String is in the form of X.X.X.X M.M.M.M;...
    // where X.X.X.X is the net address, while M.M.. is the mask
    //

    nEntries = AttrVals->valCount;

    if ( nEntries == 0 ) {
        IF_DEBUG(LIMITS) {
            DPRINT(0,"No values for IP Deny List found\n");
        }
        goto exit_replace_old;
    }

    pIPList = (PTEMP_IP_ENTRY_NODE)
        LdapAlloc( nEntries * sizeof(TEMP_IP_ENTRY_NODE) );

    if ( pIPList == NULL ) {
        DPRINT2(0,"Failed alloc for IP List[err %x][size %d]\n",
                    GetLastError(), nEntries);
        fRet = FALSE;
        goto exit;
    }

    //
    // Convert entries and sort.
    //

    InitializeListHead(&entryList);

    for ( i=0; i < nEntries; i++ ) {

        PUCHAR p, pszLast;
        DWORD netAddress;
        DWORD netMask;
        BOOL inserted, oldMask;
        PTEMP_IP_ENTRY_NODE pNode;

        vals = &AttrVals->pAVal[i];
        p = vals->pVal;
        pszLast = p + vals->valLen;

        if ( !DottedDecimalToDword((PCHAR*)&p, &netAddress, (PCHAR)pszLast) ||
             !DottedDecimalToDword((PCHAR*)&p, &netMask, (PCHAR)pszLast) ) {

            DPRINT1(0,"Badly formatted IP,mask pair for entry %d\n",i);
            continue;
        }

        if ( netMask == 0 ) {
            IF_DEBUG(LIMITS) {
                DPRINT1(0,"Zero mask entered.\n",i);
            }
        }

        IF_DEBUG(LIMITS) {
            DPRINT2(0,"Adding [IP %x] [Mask %x]\n",netAddress,netMask);
        }

        pIPList[i].IpAddress = netAddress;
        pIPList[i].Mask = netMask;

        //
        // put it in the right spot
        // oldMask becomes true if we detected an identical mask in the list
        //

        inserted = FALSE;
        oldMask = FALSE;

        for ( listEntry = entryList.Flink;
            listEntry != &entryList;
            listEntry = listEntry->Flink ) {

            pNode = CONTAINING_RECORD(listEntry,
                                      TEMP_IP_ENTRY_NODE,
                                      ListEntry
                                      );

            if ( netMask == pNode->Mask ) {
                oldMask = TRUE;

                //
                // ignore dups, handle as if already inserted.
                //

                if ( netAddress == pNode->IpAddress ) {

                    IF_DEBUG(WARNING) {
                        DPRINT2(0,"Duplicate IP address found [%x %x]\n",
                            netMask, netAddress);
                    }
                    inserted = TRUE;
                    break;
                }
            }

            if ( (netMask > pNode->Mask) ||
                    ((netMask == pNode->Mask) &&
                     (netAddress > pNode->IpAddress)) ) {

                InsertTailList(&pNode->ListEntry,&pIPList[i].ListEntry);
                inserted = TRUE;
                if ( !oldMask ) {
                    nMasks++;
                }
                realCount++;
                break;
            }
        }

        if ( !inserted ) {
            InsertTailList(&entryList, &pIPList[i].ListEntry);
            if ( !oldMask ) {
                nMasks++;
            }
            realCount++;
        }
    }

    if ( realCount == 0 ) {
        IF_DEBUG(WARNING) {
            DPRINT(0,"No properly formatted IP entry found\n");
        }
        goto exit;
    }

    //
    // Build the final structure
    //

    ipSecList = (PIP_SEC_LIST)LdapAlloc(
                                sizeof(IP_SEC_LIST) +
                                (nMasks * sizeof(IP_MASK_GROUP)) +
                                (realCount * sizeof(IP_SEC_ENTRY)));

    if ( ipSecList == NULL ) {
        fRet = FALSE;
        DPRINT1(0,"Cannot allocate IP list structure[err %d]\n",
                    GetLastError());
        goto exit;
    }

    ZeroMemory(
           ipSecList,
           sizeof(IP_SEC_LIST) +
           (nMasks * sizeof(IP_MASK_GROUP)) +
           (realCount * sizeof(IP_SEC_ENTRY)));

    maskGroup = (PIP_MASK_GROUP)(ipSecList + 1);
    ipEntry = (PIP_SEC_ENTRY)(maskGroup + nMasks);

    ipSecList->nMasks = nMasks;
    ipSecList->MaskGroups = maskGroup;
    ipSecList->IpEntries = ipEntry;
    ipSecList->RefCount = 1;
    ipSecList->nEntries = realCount;

    for ( i = 0, m=0, listEntry = entryList.Flink;
          i < realCount;
          i++, listEntry = listEntry->Flink ) {

        PTEMP_IP_ENTRY_NODE pNode;
        pNode = CONTAINING_RECORD(listEntry,
                                  TEMP_IP_ENTRY_NODE,
                                  ListEntry
                                  );

        ipEntry[i].IpAddress = pNode->IpAddress;

        if (maskGroup[m].Mask == pNode->Mask ) {
            maskGroup[m].nEntries++;

        } else {

            if ( maskGroup[m].Mask != 0 ) {
                m++;
            }

            Assert( m < nMasks );
            maskGroup[m].Mask = pNode->Mask;
            maskGroup[m].nEntries = 1;
            maskGroup[m].StartIndex = i;
            maskGroup[m].Start = &ipEntry[i];
        }
    }

exit_replace_old:

    //
    // See if we have old copy of deny list
    //

    ACQUIRE_LOCK(&LdapLimitsLock);

    //
    // if we have a deny list, replace it with the new one
    //

    if ( LdapDenyList != NULL ) {

        Assert(LdapDenyList->RefCount > 0);
        DereferenceDenyList(LdapDenyList);
    }

    LdapDenyList = ipSecList;

    //
    // go through the list of connections and disconnect the ones
    // that are on this list.
    //

enforceDenyList:

    if ( ipSecList != NULL ) {

        PLIST_ENTRY pEntry;
        PLDAP_CONN pConn;

        ReferenceDenyList(ipSecList);
        RELEASE_LOCK(&LdapLimitsLock);

again:
        ACQUIRE_LOCK( &csConnectionsListLock );
        
        pEntry = ActiveConnectionsList.Flink;
        while ( pEntry != &ActiveConnectionsList ) {

            pConn = CONTAINING_RECORD(pEntry,
                                      LDAP_CONN,
                                      m_listEntry);

            //
            // if it's on the list, nuke it
            //

            if ( ipSecList->IsPresent((PSOCKADDR_IN)(&pConn->m_RemoteSocket)) ) {

                pConn->ReferenceConnection( );

                RELEASE_LOCK( &csConnectionsListLock );

                pConn->Disconnect();
                pConn->DereferenceConnection();

                //
                // see if this was changed underneath us
                //

                if ( ipSecList != LdapDenyList) {

                    DereferenceDenyList(ipSecList);

                    ACQUIRE_LOCK(&LdapLimitsLock);
                    ipSecList = LdapDenyList;
                    goto enforceDenyList;

                } else {
                    goto again;
                }
            }

            pEntry = pEntry->Flink;
        }
        
        RELEASE_LOCK( &csConnectionsListLock );

        DereferenceDenyList(ipSecList);

    } else {
        RELEASE_LOCK(&LdapLimitsLock);
    }

exit:

    if ( pIPList != NULL ) {
        LdapFree(pIPList);
    }
    return fRet;
} // ProcessIpDenyList


BOOL
DottedDecimalToDword(
    IN PCHAR*   ppszAddress,
    IN DWORD *  pdwAddress,
    IN PCHAR    pszLast
    )
/*++

Routine Description:

    Converts a dotted decimal IP string to it's network equivalent

    Note: White space is eaten before *pszAddress and pszAddress is set
    to the character following the converted address

    *** Copied from IIS 2.0 project ***
Arguments:

    ppszAddress - Pointer to address to convert.  White space before the
        address is OK.  Will be changed to point to the first character after
        the address
    pdwAddress - DWORD equivalent address in network order

    returns TRUE if successful, FALSE if the address is not correct

--*/
{
    CHAR *          psz;
    USHORT          i;
    ULONG           value;
    int             iSum =0;
    ULONG           k = 0;
    UCHAR           Chr;
    UCHAR           pArray[4];

    psz = *ppszAddress;

    //
    //  Skip white space
    //

    while ( *psz && !isdigit( *psz )) {
        psz++;
    }

    //
    //  Convert the four segments
    //

    pArray[0] = 0;

    while ( (psz != pszLast) && (Chr = *psz) && (Chr != ' ') ) {
        if (Chr == '.') {
            // be sure not to overflow a byte.
            if (iSum <= 0xFF) {
                pArray[k] = (UCHAR)iSum;
            } else {
                return FALSE;
            }

            // check for too many periods in the address
            if (++k > 3) {
                return FALSE;
            }
            pArray[k] = 0;
            iSum = 0;

        } else {
            Chr = Chr - '0';

            // be sure character is a number 0..9
            if ((Chr < 0) || (Chr > 9)) {
                return FALSE;
            }
            iSum = iSum*10 + Chr;
        }

        psz++;
    }

    // save the last sum in the byte and be sure there are 4 pieces to the
    // address
    if ((iSum <= 0xFF) && (k == 3)) {
        pArray[k] = (UCHAR)iSum;
    } else {
        return FALSE;
    }

    // now convert to a ULONG, in network order...
    value = 0;

    // go through the array of bytes and concatenate into a ULONG
    for (i=0; i < 4; i++ )
    {
        value = (value << 8) + pArray[i];
    }
    *pdwAddress = htonl( value );

    *ppszAddress = psz;

    return TRUE;
} // DottedDecimalToDword


BOOL
IP_SEC_LIST::IsPresent(
               IN PSOCKADDR_IN SockAddr
               )
{
    DWORD i;
    PIP_MASK_GROUP maskGroup;

    Assert( !IsEmpty( ) );

    if ( fBypassLimitsChecks ) {
        IF_DEBUG(LIMITS) {
            DPRINT(0,"Bypass check flag turned on\n");
        }
        return FALSE;
    }

    for ( i = 0; i < nMasks; i++ ) {

        DWORD   netAddress;

        //
        // Always allow localhost to go through.
        //

        if ( SockAddr->sin_addr.s_addr == LOCALHOST ) {
            return FALSE;
        }

        netAddress = MaskGroups[i].Mask & SockAddr->sin_addr.s_addr;

        if ( MaskGroups[i].FindIP(netAddress)) {
            IF_DEBUG(WARNING) {
                DPRINT1(0, "Found %s in deny list. Access denied.\n", 
                        inet_ntoa(SockAddr->sin_addr));
            }
            return TRUE;
        }
    }

    return FALSE;

} // IsPresent


BOOL
IP_MASK_GROUP::FindIP(
   IN DWORD NetAddress
   )
{
    DWORD i,j;

    //
    // if less than 5 entries, do linear search. Else, do binary.
    //

    if ( nEntries < 5 ) {

        for ( i=0; i<nEntries; i++) {
            if ( NetAddress == Start[i].IpAddress ) {
                return TRUE;
            }
        }
    } else {

        DWORD   left, right, mid;

        for (left = StartIndex, right = StartIndex + nEntries - 1 ;
             left <= right ; ) {

            mid = (left+right)/2;

            if ( Start[mid].IpAddress > NetAddress ) {

                left = mid + 1;
            } else if ( Start[mid].IpAddress < NetAddress ) {
                right = mid - 1;

            } else {
                return TRUE;
            }
        }
    }

    return FALSE;

} // FindIP


BOOL
DsReadLimits(
    IN  DSNAME*         DnName,
    IN  ATTRTYP         AttType,
    OUT ATTRVALBLOCK**  AttrVals
    )
{
    BOOL        fRet = FALSE;
    _enum1      code;
    DWORD       dscode;
    READARG     readArg;
    READRES     *readRes = NULL;
    ENTINFSEL   entInfSel;
    ATTR        attr;
    ATTVAL      attrVal;
    PUCHAR      val;

    DWORD       len;
    PUCHAR      pStr;
    ATTCACHE    *pAC=NULL;

    IF_DEBUG(LIMITS) {
        DPRINT(0,"DsReadLimits entered.\n");
    }

    ZeroMemory(&readArg, sizeof(READARG));
    ZeroMemory(&entInfSel, sizeof(entInfSel));

    *AttrVals = NULL;
    __try {

        readArg.pObject = DnName;

        InitCommarg(&readArg.CommArg);

        readArg.pSel = &entInfSel;
        entInfSel.attSel = EN_ATTSET_LIST;
        entInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
        entInfSel.AttrTypBlock.attrCount = 1;
        entInfSel.AttrTypBlock.pAttr = &attr;

        attr.attrTyp = AttType;
        attr.AttrVal.valCount = 0;
        attr.AttrVal.pAVal = NULL;

        dscode = DirRead(&readArg, &readRes);

        //
        // Discard the thread's error state to avoid impacting 
        // other calls to the Dir* routines. Otherwise, the other
        // calls will return this error (return (pTHS->errCode))
        // even if they finished w/o error. Clearing the thread's
        // error state does not affect readRes or dscode.
        //
        if ( (dscode != 0) ) {
            THClearErrors();
        }

        if ( (dscode > 1) ) {
            IF_DEBUG(WARNING) {
                DPRINT1(0,"DirRead error %d\n",dscode);
            }
            _leave;
        }

        if ( readRes->entry.AttrBlock.attrCount != 0 ) {

            Assert( readRes->entry.AttrBlock.attrCount == 1 );
            *AttrVals = &readRes->entry.AttrBlock.pAttr->AttrVal;

            if ( (*AttrVals)->valCount != 0  ) {
                fRet = TRUE;
            }
        }

    } __except ( EXCEPTION_EXECUTE_HANDLER ) {
        DPRINT(0,"Exception in DsReadLimits\n");
    }

    return fRet;
} // DsReadLimits

#define LDAPMAX(a,b)    (((a) > (b)) ? (a) : (b))
#define LDAPMIN(a,b)    (((a) < (b)) ? (a) : (b))


BOOL
ProcessLimitsOrConfSets(
             IN ATTRVALBLOCK*   AttrVals,
             IN LIMIT_BLOCK*    Known
             )
/*++

Routine Description:

    Processes the admin limits ATTRVALs

Arguments:

    AttrVals - contains the limit strings

Return Value:

    TRUE, successful. FALSE, otherwise.

--*/
{

    for (DWORD i=0;i<AttrVals->valCount;i++) {

        PLIMIT_BLOCK    pBlock;

        ATTVAL* vals;
        DWORD   value;
        PWCHAR  pName;
        PWCHAR  p;
        LDAPOID attrName;
        WCHAR   number[32];
        DWORD   j;

        UNICODE_STRING unicodeString;
        ANSI_STRING  ansiString;
        CHAR    tmpBuffer[MAX_PATH];

        vals = &AttrVals->pAVal[i];

        ansiString.MaximumLength = sizeof(tmpBuffer);
        ansiString.Buffer = tmpBuffer;

        //
        // Get limit index and value
        //

        for (j=0, p = (PWCHAR)vals->pVal, pName = NULL;
             j < vals->valLen/sizeof(WCHAR);
             j++, p++ ) {

            //
            // Look for '='
            //

            if (*p == L'=') {

                INT valLen;

                *p++ = L'\0';
                j++;

                valLen = vals->valLen/sizeof(WCHAR) - j;

                if ( (valLen > 0) && (valLen < 32) ) {

                    pName = (PWCHAR)vals->pVal;

                    if (_wcsnicmp(p,L"TRUE", 4) == 0 ) {
                        number[0] = L'1';
                        valLen = 1;
                    } else if (_wcsnicmp(p,L"FALSE",5) == 0 ) {
                        number[0] = L'0';
                        valLen = 1;
                    } else {

                        for ( INT k=0; k < valLen; k++ ) {
                            if ( !iswdigit(*p) ) {
                                pName = NULL;
                                break;
                            }
                            number[k] = *p++;
                        }
                    }
                    number[valLen] = L'\0';
                }
                break;
            }
        }

        if ( pName == NULL ) {
            IF_DEBUG(ERROR) {
                DPRINT1(0,"Misformatted limit string[index %d]. Ignored.\n",i);
            }
            continue;
        }

        value = _wtoi(number);

        RtlInitUnicodeString(&unicodeString, pName);

        if ( unicodeString.Length/sizeof(WCHAR) >= ansiString.MaximumLength ) {
            DPRINT1(0,"Attribute name too long [%d]\n", unicodeString.Length/sizeof(WCHAR));
            continue;
        }

        RtlUnicodeStringToAnsiString(&ansiString,&unicodeString,FALSE);

        attrName.value  = (PUCHAR)ansiString.Buffer;
        attrName.length = ansiString.Length;

        pBlock = Known;
        while ( pBlock->Limit != NULL ) {

            if(EQUAL_LDAP_STRINGS((attrName),
                                   pBlock->Name)) {

                IF_DEBUG(LIMITS) {
                    DPRINT3(0,"Limit %s set to %d[%d]\n", 
                            ansiString.Buffer, value, *(pBlock->Limit));
                }

                //
                // Make sure that we don't set this limit below/above a 
                // a dangerous level.
                //

                *(pBlock->Limit) = LDAPMAX(value, pBlock->MinLimit);
                if (pBlock->MaxLimit) {
                    *(pBlock->Limit) = LDAPMIN((*(pBlock->Limit)), pBlock->MaxLimit);
                }

                //
                // Found it.  Get out of the while loop.
                //

                break;
            }

            //
            // Continue looking for the right value.
            //

            pBlock++;
        }

        IF_DEBUG(WARNING) {
            if ( pBlock->Limit == NULL ) {
                DPRINT2(0,"Cannot find match for limit %s[%d]\n", ansiString.Buffer, value);
            }
        }
    }

    return TRUE;

} // ProcessLimitsOrConfSets


BOOL
ProcessAdminLimits(
             IN ATTRVALBLOCK*   AttrVals
             )
/*++

Routine Description:

    Processes the admin limits ATTRVALs

Arguments:

    AttrVals - contains the limit strings

Return Value:

    TRUE, successful. FALSE, otherwise.

--*/
{

    IF_DEBUG(LIMITS) {
        DPRINT(0,"ProcessAdminLimits entered.\n");
    }

    ResetDefaultLimits( );

    ProcessLimitsOrConfSets(AttrVals, KnownLimits);

    //
    // Set default in core
    //
    SetCommArgDefaults(LdapMaxTempTable);

    return TRUE;

} // ProcessAdminLimits


BOOL
ProcessConfSets(
             IN ATTRVALBLOCK*   AttrVals
             )
/*++

Routine Description:

    Processes the configurable settings in ATTRVALs

Arguments:

    AttrVals - contains the configurable settings strings

Return Value:

    TRUE, successful. FALSE, otherwise.

--*/
{

    IF_DEBUG(LIMITS) {
        DPRINT(0,"ProcessConfSets entered.\n");
    }

    ResetDefaultConfSets( );

    ProcessLimitsOrConfSets(AttrVals, KnownConfSets);

    return TRUE;

} // ProcessConfSets


BOOL
RegisterLimitsNotification(
    IN DSNAME*  DnName,
    IN DWORD    ClientId
    )
/*++

Routine Description:

    Register notification for a specific DN

Arguments:

    DnName - object to be notified on
    ClientID - the return context

Return Value:

    TRUE, registration successful. FALSE, otherwise.

--*/
{
    SEARCHARG   searchArg;
    NOTIFYARG   notifyArg;
    NOTIFYRES*  notifyRes = NULL;
    DWORD       dscode;

    ENTINFSEL   entInfSel;
    FILTER      filter;

    IF_DEBUG(LIMITS) {
        DPRINT(0,"RegisterLimitsNotification entered\n");
    }

    if ( LimitsNotifyBlock[ClientId].NotifyHandle != 0 ) {
        IF_DEBUG(LIMITS) {
            DPRINT1(0,"RegisterLimits: %d already registered\n",ClientId);
        }
        return TRUE;
    }

    //
    // Copy the DN Name into the limits blocks
    //

    if ( (LimitsNotifyBlock[ClientId].ObjectDN == NULL) ||
         (LimitsNotifyBlock[ClientId].ObjectDN->structLen < DnName->structLen) ) {

        if ( LimitsNotifyBlock[ClientId].ObjectDN != NULL ) {
            LdapFree( LimitsNotifyBlock[ClientId].ObjectDN );
        }

        LimitsNotifyBlock[ClientId].ObjectDN = 
            (DSNAME*)LdapAlloc(DnName->structLen);
    }

    if ( LimitsNotifyBlock[ClientId].ObjectDN != NULL ) {
        
        CopyMemory(
            LimitsNotifyBlock[ClientId].ObjectDN,
            DnName,
            DnName->structLen);
    }

    //
    // init notify arg
    //

    notifyArg.pfPrepareForImpersonate = DirPrepareForImpersonate;
    notifyArg.pfTransmitData = LimitsReceiveNotificationData;
    notifyArg.pfStopImpersonating = DirStopImpersonating;
    notifyArg.hClient = ClientId;

    //
    // init search arg
    //

    ZeroMemory(&searchArg, sizeof(SEARCHARG));
    ZeroMemory(&entInfSel, sizeof(ENTINFSEL));
    ZeroMemory(&filter, sizeof(FILTER));

    searchArg.pObject = DnName;

    InitCommarg(&searchArg.CommArg);
    searchArg.choice = SE_CHOICE_BASE_ONLY;
    searchArg.bOneNC = TRUE;

    searchArg.pSelection = &entInfSel;
    entInfSel.attSel = EN_ATTSET_LIST;
    entInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    entInfSel.AttrTypBlock.attrCount = 0;
    entInfSel.AttrTypBlock.pAttr = NULL;

    searchArg.pFilter = &filter;
    filter.choice = FILTER_CHOICE_ITEM;
    filter.FilterTypes.Item.choice = FI_CHOICE_TRUE;

    ACQUIRE_LOCK(&LdapLimitsLock);

    if ( LimitsNotifyBlock[ClientId].NotifyHandle == 0 ) {

        IF_DEBUG(LIMITS) {
            DPRINT1(0,"Registering notification for client id %d\n",
                     ClientId);
        }

        dscode = DirNotifyRegister(&searchArg, &notifyArg, &notifyRes);

        if ( dscode != 0 ) {
            DPRINT1(0,"DirNotifyRegister failed with %d\n",dscode);
        } else {
            LimitsNotifyBlock[ClientId].NotifyHandle = notifyRes->hServer;
        }
    }
    RELEASE_LOCK(&LdapLimitsLock);

    return TRUE;

} // RegisterLimitsNotification


VOID
LimitsReceiveNotificationData (
        IN DWORD hClient,
        IN DWORD hServer,
        IN ENTINF *pEntinf
        )
{
    if ( !LdapStarted ) {
        return;
    }

    IF_DEBUG(LIMITS) {
        DPRINT2(0,"LimitsNotificationCallback [hClient %d hServer %d]\n",
                 hClient, hServer);
    }

    if ( hClient >= CLIENTID_MAX ) {
        DPRINT1(0,"LdapLimits: Got bogus hClient %x\n",hClient);
        return;
    }

    Assert(hClient == LimitsNotifyBlock[hClient].ClientId);

    InsertInTaskQueue(DeferredNotification, &LimitsNotifyBlock[hClient], 0);

    return;
} // LimitsReceiveNotificationData


BOOL
LdapConstructDNName(
    IN LDAPDN*          BaseDN,
    IN LDAPDN*          ObjectDN,
    OUT DSNAME **       ppDSName
    )
/*++

Routine Description:

    Appends two names

Arguments:

    BaseDN - DN to append to
    ObjectDN - DN to append
    ppDSName - contains appended name

Return Value:

    TRUE, init successful. FALSE, otherwise.

--*/
{
    DWORD       len;
    LDAPDN      ldapStr;
    _enum1      code;

    //
    // concatenate
    //

    len = BaseDN->length + ObjectDN->length;

    ldapStr.value = (PUCHAR)THAlloc(len);
    if ( ldapStr.value == NULL ) {
        IF_DEBUG(NOMEM) {
            DPRINT1(0,"THAlloc[size %d] failed\n",len);
        }
        return FALSE;
    }

    ldapStr.length = len;

    CopyMemory(ldapStr.value, ObjectDN->value, ObjectDN->length);
    CopyMemory(ldapStr.value+ObjectDN->length,
               BaseDN->value,
               BaseDN->length
               );

    code = LDAP_LDAPDNToDSName(
                    CP_UTF8,
                    &ldapStr,
                    ppDSName
                    );

    THFree(ldapStr.value);
    return (code == success);

} // LdapConstructDNName


BOOL
InitializeLimitsAndDenyList(
    IN PVOID pvParam
    )
/*++

Routine Description:

    Main initialization routine for limits and ip deny list.

Arguments:

    pvParam - the notification Block

Return Value:

    TRUE, init successful. FALSE, otherwise.

--*/
{

    _enum1  code;
    DWORD   i;
    BOOL    allocatedTHState = FALSE;
    BOOL    fRet = FALSE;
    BOOL    fDSA = TRUE;

    LDAPDN          enterpriseConfig;
    ATTRVALBLOCK*   attrVals;
    ATTRVALBLOCK    limitsAttrVals;
    ATTRVALBLOCK    denyListAttrVals;
    ATTRVALBLOCK    ConfSetsAttrVals;
    ATTRVALBLOCK*   tmpAV;

    DSNAME*         serverLinkDN = NULL;
    DSNAME*         siteLinkDN = NULL;
    DSNAME*         defQPDN  = NULL;
    DSNAME*         serverQPDN = NULL;
    DSNAME*         siteQPDN = NULL;
    DSNAME*         tmpDsName;
    THSTATE*        pTHS = pTHStls;

    PLIMITS_NOTIFY_BLOCK notifyBlock = (PLIMITS_NOTIFY_BLOCK)pvParam;

    IF_DEBUG(LIMITS) {
        DPRINT(0,"InitializeLimitsAndDenyList entered.\n");
    }

    if ( pTHS == NULL ) {

        if ( (pTHS = InitTHSTATE(CALLERTYPE_LDAP)) == NULL) {
            DPRINT(0,"Unable to initialize thread state\n");
            return FALSE;
        }
        allocatedTHState = TRUE;
    } else {

        fDSA = pTHS->fDSA;
    }

    pTHS->fDSA = TRUE;

    //
    // See if there were any real changes
    //

    if ( (notifyBlock != NULL) && !IsNotifyValid(notifyBlock) ) {
        goto exit;
    }

    //
    // Get values from default
    //

    __try {

        code = LDAP_DSNameToLDAPDN(CP_UTF8,
                        gAnchor.pDsSvcConfigDN,
                        FALSE,
                        &enterpriseConfig
                        );

        if ( code != 0 ) {
            DPRINT1(0,"Cannot convert to UTF8. code %d\n", code);
            _leave;
        }

        //
        // concatenate
        //

        if ( !LdapConstructDNName(
                        &enterpriseConfig,
                        &DefQueryPolicy,
                        &defQPDN) ) {

            DPRINT(0,"Unable to concatenate DNs\n");
            code = operationsError;
            _leave;
        }

    } __except(EXCEPTION_EXECUTE_HANDLER ) {

        code = operationsError;
        DPRINT(0,"Exception handled.\n");
    }

    if ( code != 0 ) {
        goto exit;
    }

    //
    // Get values for server
    //

    serverLinkDN = gAnchor.pDSADN;

    if ( DsReadLimits(
                    serverLinkDN,
                    ATT_QUERY_POLICY_OBJECT,
                    &attrVals
                    ) ) {
        //
        // Get the actual object
        //

        Assert(attrVals->valCount == 1);
        serverQPDN = (DSNAME*)attrVals->pAVal->pVal;
    } else {
        IF_DEBUG(LIMITS) {
            DPRINT(0,"No server QPO found\n");
        }
    }

    //
    // Get value for site. Remove CN=NTDS Settings,CN=<server>,CN=Servers
    //

    tmpDsName = (DSNAME*)THAlloc(serverLinkDN->structLen);
    if ( (tmpDsName != NULL) &&
         (TrimDSNameBy(serverLinkDN, 3, tmpDsName) == 0) ) {

        siteLinkDN = (DSNAME*)THAlloc(serverLinkDN->structLen);
        if ( siteLinkDN != NULL ) {

            //
            // Add CN=NTDS Site Settings
            //

            AppendRDN(tmpDsName,
                      siteLinkDN,
                      serverLinkDN->structLen,
                      L"NTDS Site Settings",
                      0,
                      ATT_COMMON_NAME
                      );
            
            if ( DsReadLimits(
                    siteLinkDN,
                    ATT_QUERY_POLICY_OBJECT,
                    &attrVals
                    ) ) {

                Assert(attrVals->valCount == 1);
                siteQPDN = (DSNAME*)attrVals->pAVal->pVal;
            } else {
                IF_DEBUG(LIMITS) {
                    DPRINT(0,"No site QPO found\n");
                }
            }
        }
    }

    //
    // if server and site point to the same thing, ignore the server 
    //

    if ( siteQPDN != NULL ) {

        if ( serverQPDN != NULL ) {
            if ( NameMatched(siteQPDN, serverQPDN) ) {
                IF_DEBUG(LIMITS) {
                    DPRINT(0,"Server and site links point to the same QP\n");
                }
                serverQPDN = NULL;
            }
        }

        if ( NameMatched(siteQPDN, defQPDN) ) {

            IF_DEBUG(LIMITS) {
                DPRINT(0,"Site DN is identical to default DN!\n");
            }
            siteQPDN = NULL;
        }
    }

    if ( serverQPDN != NULL ) {
        if ( NameMatched(serverQPDN, defQPDN) ) {
            IF_DEBUG(LIMITS) {
                DPRINT(0,"Server DN is identical to default DN!\n");
            }
            serverQPDN = NULL;
        }
    }

    ZeroMemory(&limitsAttrVals, sizeof(ATTRBLOCK));
    ZeroMemory(&denyListAttrVals, sizeof(ATTRBLOCK));
    ZeroMemory(&ConfSetsAttrVals, sizeof(ATTRBLOCK));

    for (i=0;i<3;i++) {

        DSNAME *    objectName = NULL;

        switch (i) {
        case 0:     // read defaults
            objectName = defQPDN;
            break;
        case 1:
            objectName = siteQPDN;
            break;
        case 2:
            objectName = serverQPDN;
            break;
        }

        if ( objectName != NULL ) {

            if ( DsReadLimits(
                    objectName,
                    ATT_LDAP_ADMIN_LIMITS,
                    &tmpAV) ) {

                LdapAppendAttrBlocks(
                    &limitsAttrVals,
                    tmpAV
                    );
            }

            if ( DsReadLimits(
                    objectName,
                    ATT_LDAP_IPDENY_LIST,
                    &tmpAV) ) {

                LdapAppendAttrBlocks(
                    &denyListAttrVals,
                    tmpAV
                    );
            }
        }
    }

    // Other service-wide limits.
    if (DsReadLimits(gAnchor.pDsSvcConfigDN,
                     ATT_MS_DS_OTHER_SETTINGS,
                     &tmpAV)) {
        LdapAppendAttrBlocks(&ConfSetsAttrVals, tmpAV);
    }

    //
    // Go process the attrval lists
    //

    ProcessAdminLimits(&limitsAttrVals);
    ProcessIpDenyList(&denyListAttrVals);
    ProcessConfSets(&ConfSetsAttrVals);

    //
    // setup the notifications
    //

    RegisterLimitsNotification(defQPDN,CLIENTID_DEFAULT);
    RegisterLimitsNotification(serverLinkDN,CLIENTID_SERVER_LINK);
    RegisterLimitsNotification(gAnchor.pDsSvcConfigDN, CLIENTID_CONFSETS);
    if ( siteLinkDN != NULL ) {
        RegisterLimitsNotification(siteLinkDN,CLIENTID_SITE_LINK);
    }

    if ( siteQPDN != NULL ) {
        RegisterLimitsNotification(siteQPDN,CLIENTID_SITE_POLICY);
    }

    if ( serverQPDN != NULL ) {
        RegisterLimitsNotification(serverQPDN,CLIENTID_SERVER_POLICY);
    }
    fRet = TRUE;

exit:
    if ( allocatedTHState ) {
        free_thread_state();
    } else {
        pTHS->fDSA = fDSA;
    }
    return fRet;

} // InitializeLimitsAndDenyList


BOOL
LdapAppendAttrBlocks(
    IN ATTRVALBLOCK*    BaseBlock,
    IN ATTRVALBLOCK*    NewBlock
    )
/*++

Routine Description:

    Appends an attrval to another one.

Arguments:

    BaseBlock - ATTRVAL block to append to
    NewBLock - ATTRVAL block to append

Return Value:

    TRUE, append successful. FALSE, otherwise.

--*/
{
    if ( NewBlock->valCount > 0 ) {

        if ( BaseBlock->pAVal == NULL ) {

            Assert(BaseBlock->valCount == 0);

            BaseBlock->pAVal = (ATTRVAL*)THAlloc(NewBlock->valCount * sizeof(ATTRVAL));
            if ( BaseBlock->pAVal == NULL ) {
                DPRINT1(0,"THAlloc of limit block failed with %d\n", GetLastError());
                return FALSE;
            }
        } else {
            PVOID   pMem;
            Assert(BaseBlock->valCount > 0);

            pMem = THReAlloc(
                        BaseBlock->pAVal,
                        (BaseBlock->valCount + NewBlock->valCount)
                         * sizeof(ATTRVAL));

            if ( pMem == NULL ) {
                DPRINT1(0,"Realloc of limit block failed with %d\n", GetLastError());
                return FALSE;
            }

            BaseBlock->pAVal = (ATTRVAL*)pMem;
        }

        CopyMemory(
            &BaseBlock->pAVal[BaseBlock->valCount],
            &NewBlock->pAVal[0],
            NewBlock->valCount * sizeof(ATTRVAL)
            );

        BaseBlock->valCount += NewBlock->valCount;

    }
    return TRUE;
} // LdapAppendAttrBlocks

VOID
DestroyLimits(
    VOID
    )
{
    NOTIFYRES*  notifyRes;
    DWORD i;

    //
    // Destroy notifications
    //

    IF_DEBUG(LIMITS) {
        DPRINT(0,"LdapDestroyLimits called.\n");
    }

    if ( !InitTHSTATE(CALLERTYPE_LDAP) ) {
        DPRINT(0,"Unable to initialize thread state\n");
        goto free_buf;
    }

    pTHStls->fDSA = TRUE;

    ACQUIRE_LOCK(&LdapLimitsLock);
    for ( i=0;i < CLIENTID_MAX ;i++) {

        if ( LimitsNotifyBlock[i].NotifyHandle != 0 ) {
            DirNotifyUnRegister(
                LimitsNotifyBlock[i].NotifyHandle,
                &notifyRes);
            LimitsNotifyBlock[i].NotifyHandle = 0;
        }

        if ( LimitsNotifyBlock[i].ObjectDN != NULL ) {
            LdapFree(LimitsNotifyBlock[i].ObjectDN);
            LimitsNotifyBlock[i].ObjectDN = NULL;
        }
    }
    RELEASE_LOCK(&LdapLimitsLock);

    free_thread_state( );

free_buf:

    //
    // Zap Deny IP List
    //

    ACQUIRE_LOCK(&LdapLimitsLock);
    if ( LdapDenyList != NULL ) {
        DereferenceDenyList(LdapDenyList);
        LdapDenyList = NULL;
    }
    RELEASE_LOCK(&LdapLimitsLock);

    return;

} // DestroyLimits


VOID
DeferredNotification(
    IN  VOID *  pvParam,
    IN  VOID ** ppvParamNext,
    OUT DWORD * pcSecsUntilNextIteration
    )
/*++

Routine Description:

    Actual notification handling

Arguments:

    pvParam - actually the notification block

Return Value:

    None

--*/
{
    //
    // OK, we redo the init
    //

    *pcSecsUntilNextIteration = TASKQ_DONT_RESCHEDULE;
    InitializeLimitsAndDenyList(pvParam);
    return;
} // DeferredNotification


BOOL
IsNotifyValid(
    IN PLIMITS_NOTIFY_BLOCK notifyBlock
    )
/*++

Routine Description:

    Checks to see if something really changed.

Arguments:

    notifyBlock - notifyBlock containing the notification info

Return Value:

    TRUE if something changed, FALSE otherwise.

--*/
{

    ATTRVALBLOCK*   tmpAV;
    NOTIFYRES*  notifyRes;

    //
    // We need to read the repl meta data and see if there are any
    // changes here.
    //

    if ( notifyBlock->ObjectDN != NULL ) {

        if ( DsReadLimits(
                notifyBlock->ObjectDN,
                ATT_REPL_PROPERTY_META_DATA,
                &tmpAV
                ) ) {

            USN  newUSN = 0;
            BOOL fCheckDenyList = FALSE;
            PROPERTY_META_DATA_VECTOR *pVector = 
                (PROPERTY_META_DATA_VECTOR*)tmpAV->pAVal->pVal;

            VALIDATE_META_DATA_VECTOR_VERSION(pVector);

            IF_DEBUG(LIMITS) {
                DPRINT2(0,"LimitsNotify: valCount %d NumProps %d\n",
                         tmpAV->valCount, pVector->V1.cNumProps);
            }

            fCheckDenyList = 
                (BOOL)(notifyBlock->CheckAttribute == ATT_LDAP_ADMIN_LIMITS);

            for ( DWORD i=0; i < pVector->V1.cNumProps; i++) {

                PROPERTY_META_DATA *pMetaData = 
                    (PROPERTY_META_DATA*)&pVector->V1.rgMetaData[i];

                if ( (pMetaData->attrType == notifyBlock->CheckAttribute) ||
                     (fCheckDenyList && 
                      (pMetaData->attrType == ATT_LDAP_IPDENY_LIST)) ) {

                    newUSN += pMetaData->usnProperty;
                }
            }

            //
            // Found nothing?
            //

            if ( newUSN == 0 ) {
                IF_DEBUG(LIMITS) {
                    DPRINT(0,"Cannot find check attribute\n");
                }
                return FALSE;
            }

            if ( newUSN != notifyBlock->PreviousUSN ) {

                IF_DEBUG(LIMITS) {
                    DPRINT(0,"USN Updated\n");
                }
                notifyBlock->PreviousUSN = newUSN;
            } else {

                IF_DEBUG(LIMITS) {
                    DPRINT(0,"No USN Change\n");
                }

                return FALSE;
            }
        } else {
            DPRINT(0,"Unable to read property Metadata\n");
        }
    }

    //
    // if this is a link change, then unregister the notification
    //

    if ( notifyBlock->ClientId == CLIENTID_SITE_LINK ) {

        IF_DEBUG(LIMITS) {
            DPRINT1(0,"Unregistering limits notification for %d\n", 
                     CLIENTID_SITE_POLICY);
        }
        ACQUIRE_LOCK(&LdapLimitsLock);
        if ( LimitsNotifyBlock[CLIENTID_SITE_POLICY].NotifyHandle != 0 ) {
            DirNotifyUnRegister(
                LimitsNotifyBlock[CLIENTID_SITE_POLICY].NotifyHandle,
                &notifyRes);
            LimitsNotifyBlock[CLIENTID_SITE_POLICY].NotifyHandle = 0;


        }
        RELEASE_LOCK(&LdapLimitsLock);
    } else if ( notifyBlock->ClientId == CLIENTID_SERVER_LINK ) {

        IF_DEBUG(LIMITS) {
            DPRINT1(0,"Unregistering limits notification for %d\n", 
                     CLIENTID_SERVER_POLICY);
        }
        ACQUIRE_LOCK(&LdapLimitsLock);
        if ( LimitsNotifyBlock[CLIENTID_SERVER_POLICY].NotifyHandle != 0 ) {
            DirNotifyUnRegister(
                LimitsNotifyBlock[CLIENTID_SERVER_POLICY].NotifyHandle,
                &notifyRes);
            LimitsNotifyBlock[CLIENTID_SERVER_POLICY].NotifyHandle = 0;
        }
        RELEASE_LOCK(&LdapLimitsLock);
    }

    return(TRUE);
} // IsNotifyValid
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\ldap\misc.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    misc.cxx

Abstract:

    misc helper functions.

Author:

    Johnson Apacible (JohnsonA) 30-Jan-1998

--*/

#include <NTDSpchx.h>
#pragma  hdrstop

#include "ldapsvr.hxx"
extern "C" {
#include "mdlocal.h"
#undef new
#undef delete
}

#define  FILENO FILENO_LDAP_MISC

LIST_ENTRY  PagedBlobListHead;
LONG    CurrentPageStorageSetSize   = 0;
LONG    PageBlobAllocs  = 0;
LONG    LdapBlobId = 1;

CRITICAL_SECTION    PagedBlobLock;

VOID
ZapPagedBlobs(
    VOID
    );

PLDAP_PAGED_BLOB
AllocatePagedBlob(
    IN DWORD        Size,
    IN PVOID        Blob,
    IN PLDAP_CONN   LdapConn
    )
/*++

Routine Description:

    Allocate storage to store paged blobs.

Arguments:

    Size - length in bytes of blob.
    Blob - Actual blob.
    LdapConn - Connection to store blob on.

Return Value:

    Pointer to blob. NULL if failure.

--*/
{
    DWORD   allocSize;
    LIST_ENTRY          *pTmp;
    PLDAP_PAGED_BLOB    pPaged;
    PLDAP_PAGED_BLOB    pTmpPaged = NULL;

    allocSize = sizeof(LDAP_PAGED_BLOB) + Size -1;
    pPaged = (PLDAP_PAGED_BLOB)LdapAlloc(allocSize);

    IF_DEBUG(SEARCH) {
        DPRINT2(0,"Allocated paged blob %x [size %d]\n", pPaged, Size);
    }

    if ( pPaged != NULL ) {

        pPaged->Signature = LDAP_PAGED_SIGNATURE;
        pPaged->LdapConn = LdapConn;
        pPaged->BlobSize = Size;

        CopyMemory(pPaged->Blob, Blob, Size);
        pPaged->BlobId = InterlockedExchangeAdd(&LdapBlobId, 1);

        //
        // insert into global list
        //

        InterlockedIncrement(&PageBlobAllocs);
        ACQUIRE_LOCK(&PagedBlobLock);
        if (LDAP_COOKIES_PER_CONN <= LdapConn->m_CookieCount) {

            // Remove the oldest paged blob from the LDAP_CONN list.
            pTmp = RemoveHeadList( &LdapConn->m_CookieList );
            pTmpPaged = CONTAINING_RECORD(pTmp, LDAP_PAGED_BLOB, ConnEntry);
            pTmpPaged->LdapConn = NULL;
            LdapConn->m_CookieCount--;

            // Remove it from the global list.
            RemoveEntryList( &pTmpPaged->ListEntry );
        }
        // Insert the new one in the global list.
        InsertTailList(&PagedBlobListHead, &pPaged->ListEntry);
        // ...and in the LDAP_CONN list.
        InsertTailList(&LdapConn->m_CookieList, &pPaged->ConnEntry);
        LdapConn->m_CookieCount++;
        CurrentPageStorageSetSize += Size;
        RELEASE_LOCK(&PagedBlobLock);

        IF_DEBUG(WARNING) {
            if (pTmpPaged) {
                DPRINT(0, "LDAP_CONN paged blob overflow!\n");
            }
        }
        // Go ahead and free any overflowed paged blobs now that
        // we are outside of the lock.
        FreePagedBlob(pTmpPaged);
    }

    Assert( LDAP_COOKIES_PER_CONN >= LdapConn->m_CookieCount );
    //
    // if we've exceeded our limit, try to delete older blobs
    //

    if ( (DWORD)CurrentPageStorageSetSize > LdapMaxResultSet ) {
        ZapPagedBlobs( );
    }

    return pPaged;

} // AllocatePagedBlob


VOID
FreePagedBlob(
    IN PLDAP_PAGED_BLOB Blob
    )
/*++

Routine Description:

    Free paged blobs.

Arguments:

    Blob - Actual blob.

Return Value:

    None.

--*/
{
    if ( Blob != NULL ) {

        IF_DEBUG(SEARCH) {
            DPRINT2(0,"Freed paged blob %x [size %d]\n",Blob,Blob->BlobSize);
        }

        LdapFree(Blob);    
        InterlockedDecrement(&PageBlobAllocs);
        Assert(PageBlobAllocs >= 0);
    }

} // FreePagedBlob


VOID
FreeAllPagedBlobs(
    IN PLDAP_CONN LdapConn
    )
/*++

Routine Description:

    Free all the paged blobs on a particular connection.

Arguments:

    LdapConn - The connection whose blobs are to be freed.

Return Value:

    None.

--*/
{
    LIST_ENTRY       *pTmp;
    PLDAP_PAGED_BLOB pPaged;

    ACQUIRE_LOCK(&PagedBlobLock);

    pTmp = LdapConn->m_CookieList.Blink;
    while (pTmp != &LdapConn->m_CookieList) {
        pPaged = CONTAINING_RECORD(pTmp, LDAP_PAGED_BLOB, ConnEntry);
        pTmp = pPaged->ConnEntry.Blink;
        
        RemoveEntryList( &pPaged->ConnEntry );
        pPaged->LdapConn = NULL;
        LdapConn->m_CookieCount--;
        RemoveEntryList( &pPaged->ListEntry );

        CurrentPageStorageSetSize -= pPaged->BlobSize;
        Assert(CurrentPageStorageSetSize >= 0);

        FreePagedBlob( pPaged );

    }

    Assert( LdapConn->m_CookieCount == 0 );
    
    RELEASE_LOCK(&PagedBlobLock);


} // FreeAllPagedBlobs

PLDAP_PAGED_BLOB
ReleasePagedBlob(
    IN PLDAP_CONN        LdapConn,
    IN DWORD             BlobId,
    IN BOOL              FreeBlob
    )
/*++

Routine Description:

    Remove paged blob from queue and decrement.

Arguments:

    LdapConn - connection blob is associated to.
    BlobId   - The ID used to find the correct blob.
    FreeBlob - Should blob be freed

Return Value:

    Blob that was released

--*/
{
    PLDAP_PAGED_BLOB pPaged = NULL;
    PLDAP_PAGED_BLOB pTmpPaged = NULL;
    LIST_ENTRY       *pTmp;

    ACQUIRE_LOCK(&PagedBlobLock);

    // See if the BlobId passed in exists on this connection.
    for (pTmp = LdapConn->m_CookieList.Blink; pTmp != &LdapConn->m_CookieList; pTmp = pTmp->Blink) {
        pTmpPaged = CONTAINING_RECORD(pTmp, LDAP_PAGED_BLOB, ConnEntry);
        if (pTmpPaged->BlobId == BlobId) {
            pPaged = pTmpPaged;
            break;
        }
    }

    if ( pPaged != NULL ) {

        Assert(LdapConn == pPaged->LdapConn);

        IF_DEBUG(SEARCH) {
            DPRINT2(0,"Released paged blob %x[id %d]\n", pPaged, pPaged->BlobId);
        }

        CurrentPageStorageSetSize -= pPaged->BlobSize;
        Assert(CurrentPageStorageSetSize >= 0);

        RemoveEntryList(&pPaged->ListEntry);
        RemoveEntryList(&pPaged->ConnEntry);
        LdapConn->m_CookieCount--;
        pPaged->LdapConn = NULL;
        RELEASE_LOCK(&PagedBlobLock);

        if ( FreeBlob ) {
            FreePagedBlob(pPaged);
            pPaged = NULL;
        }

    } else {
        RELEASE_LOCK(&PagedBlobLock);
    }
    return pPaged;

} // ReleasePagedBlob


VOID
ZapPagedBlobs(
    VOID
    )
{
    //
    // zap only if more than 3
    //

    IF_DEBUG(WARNING) {
        DPRINT2(0,"Zapping blobs, max paged storage exceeded [cur %d max %d]\n",
                CurrentPageStorageSetSize, LdapMaxResultSet);
    }

    while ( ((DWORD)CurrentPageStorageSetSize > LdapMaxResultSet) && 
         (PageBlobAllocs > 3) ) {

        PLIST_ENTRY listEntry;
        PLDAP_PAGED_BLOB pPaged;

        ACQUIRE_LOCK( &PagedBlobLock );        

        if ( PagedBlobListHead.Flink != &PagedBlobListHead ) {
            listEntry = RemoveHeadList(&PagedBlobListHead);

            pPaged = CONTAINING_RECORD(listEntry,
                                   LDAP_PAGED_BLOB,
                                   ListEntry
                                   );

            RemoveEntryList(&pPaged->ConnEntry);
            pPaged->LdapConn->m_CookieCount--;

            CurrentPageStorageSetSize -= pPaged->BlobSize;
            pPaged->LdapConn = NULL;
            FreePagedBlob(pPaged);

        } else {
            Assert(CurrentPageStorageSetSize == 0);
        }

        RELEASE_LOCK( &PagedBlobLock );        
    }

    return;

} // ZapPagedBlobs


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function sets an ldap error for output */

_enum1
DoSetLdapError (
        IN _enum1 code,
        IN DWORD Win32Err,
        IN DWORD CommentId,
        IN DWORD Data,
        IN DWORD Dsid,
        OUT LDAPString    *pError
        )
{
    CHAR pTempBuff[1024];
    DWORD cbTempBuff = 0;
    PCHAR pString = NULL;

    THSTATE *pTHS=pTHStls;
    BOOL ok;

    pError->value = NULL;
    pError->length = 0;

    _snprintf(pTempBuff, sizeof(pTempBuff),
              "%08X: LdapErr: DSID-%08X, comment: %s, data %x, v%x",
              Win32Err,
              (gulHideDSID == DSID_HIDE_ALL) ? 0 : Dsid,
              LdapComments[CommentId],
              Data,
              LdapBuildNo);

    cbTempBuff = strlen(pTempBuff);
    if ( cbTempBuff == 0 ) {
        goto exit;
    }

    pString = (PCHAR)THAlloc(cbTempBuff+1);
    if ( pString == NULL ) {
        cbTempBuff = 0;
        goto exit;
    }

    cbTempBuff++;
    strcpy(pString,pTempBuff);

    LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
            DS_EVENT_SEV_MINIMAL,
            DIRLOG_LDAP_EXT_ERROR,
            szInsertSz(pString),
            NULL, NULL);
    
    IF_DEBUG(ERR_NORMAL) {
        DPRINT1(0,"Returning extended error string %s\n", pString);
    }

exit:
    pError->value = (PUCHAR)pString;
    pError->length = cbTempBuff;
    return code;

} // DoSetLdapError


BOOL
IsContextExpired(
    IN PTimeStamp tsContextExpires,
    IN PTimeStamp tsLocal
    )
/*++

Routine Description:

    Check if context has expired based on the time given.

Arguments:

    tsContextExpires - expiration time for context
    tsLocal - Current local time. If not present,
        we need to get the time for the caller.

Return Value:

    TRUE, if time has expired
    FALSE, otherwise

--*/
{
    //
    // context has expired?
    //

    if (tsContextExpires->QuadPart <= tsLocal->QuadPart) {
        // yup
        return TRUE;
    }

    return FALSE;

} // IsContextExpired


DWORD
GetNextAtqTimeout(
    IN PTimeStamp tsContextExpires,
    IN PTimeStamp tsLocal,
    IN DWORD DefaultIdleTime
    )
{

    DWORD timeout = 30;     // 30 seconds minimum
    LARGE_INTEGER liDiff;

    //
    // if the context had already expired, give the timeout thread 30 seconds to cleanup.
    //

    if ( tsContextExpires->QuadPart <= tsLocal->QuadPart ) {
        goto exit;
    }

    //
    //  get the difference and convert to seconds
    //

    liDiff.QuadPart = tsContextExpires->QuadPart - tsLocal->QuadPart;
    liDiff.QuadPart /= (LONGLONG)(10*1000*1000);

    //
    // if the high part is not 0, then the default timeout always wins
    //

    if ( liDiff.HighPart != 0 ) {
        timeout = 0xFFFFFFFF;
    } else {
        timeout = liDiff.LowPart;
    }


    if ( timeout > DefaultIdleTime ) {
        timeout = DefaultIdleTime;
    }

exit:

    return timeout;

} // GetNextAtqTimeout
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\ldap\request.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    request.cxx

Abstract:

    This module implements the LDAP server for the NT5 Directory Service.

    This include file defines the REQUEST class which is the object that
    represents an LDAP request/response pair as they are processed through
    the server.

    Note: Request and SSL work as a team to get the job done. Changes in one may
    affect the other.

Author:

    Colin Watson     [ColinW]    31-Jul-1996

Revision History:

--*/

#include <NTDSpchx.h>
#pragma  hdrstop

#include "ldapsvr.hxx"
#include <kerberos.h>

#define  FILENO FILENO_LDAP_REQ

LIST_ENTRY  LdapRequestFreeList;

#define SET_MSG_LENGTH(_header, _len)   {       \
    (_header)[0] = (CHAR)(((_len) & 0xFF000000) >> 24); \
    (_header)[1] = (CHAR)(((_len) & 0xFF0000) >> 16);   \
    (_header)[2] = (CHAR)(((_len) & 0xFF00) >> 8);      \
    (_header)[3] = (CHAR)((_len) & 0xFF);   \
    }


LDAP_REQUEST::LDAP_REQUEST( VOID)
/*++
  This function creates a new request object for the information
    required to process a request from a user connection.

  Returns:
     a newly constructed REQUEST object.

--*/
:   m_fAllocated        (TRUE)
{
    Reset( );

} // LDAP_REQUEST::LDAP_REQUEST()



LDAP_REQUEST::~LDAP_REQUEST(VOID)
{
    IF_DEBUG(REQUEST) {
        DPRINT1(0,"Delete request object @ %08lX.\n", this);
    }
    Cleanup( );

} // LDAP_REQUEST::~LDAP_REQUEST()


VOID
LDAP_REQUEST::Reset(
    VOID
    )
/*++

Routine Description:

    Initializes all simple fields.

Arguments:

    None.

Return Value:

    None

--*/
{
    m_wsaBuf                = NULL;
    m_sendBufAllocList      = NULL;
    m_wsaBufCount           = 0;
    m_wsaBufAlloc           = 0;
    m_nextBufferPtr         = NULL;
    m_cchReceiveBufferUsed  = 0;
    m_fAbandoned            = FALSE;
    m_refCount              = 0;
    m_patqContext           = NULL;
    m_LdapConnection        = NULL;
    m_cchReceiveBuffer      = INITIAL_RECV_SIZE;
    m_signature             = SIGN_LDAP_REQUEST_FREE;
    m_MessageId             = 0;
    m_HeaderSize            = 0;
    m_TrailerSize           = 0;
    m_fSignSeal             = FALSE;
    m_fSSL                  = FALSE;
    m_fTLS                  = FALSE;
    m_fCanScatterGather     = TRUE;
    m_fNeedsHeader          = FALSE;
    m_fNeedsTrailer         = FALSE;
    m_RootDseFlag           = rdseNonDse;

    //
    // SSL\TLS
    //

    m_cchUnSealedData       = 0;
    m_cchSealedData         = 0;
    m_pSslContextBuffer     = NULL;
    m_ReceivedSealedData    = FALSE;

    DPRINT1(VERBOSE, "request object created  @ %08lX.\n", this);

    InitializeListHead( &m_listEntry);
    m_pReceiveBuffer = m_ReceiveBuffer;
    m_fDeleteBuffer = FALSE;

    ZeroMemory( &m_ov, sizeof(m_ov));

    //
    // Should be last
    //

    m_State                 = BlockStateCached;

} // LDAP_REQUEST::Reset


VOID
LDAP_REQUEST::Cleanup(
    VOID
    )
/*++

Routine Description:

    Destroy all allocated buffers.

Arguments:

    None.

Return Value:

    None

--*/
{
    if ( m_LdapConnection != NULL ) {
        m_LdapConnection->DereferenceConnection();
        m_LdapConnection = NULL;
    }

    if (m_pOldSecContext) {
        m_pOldSecContext->DereferenceSecurity();
        m_pOldSecContext = NULL;
    }

    if (m_fDeleteBuffer) {

        Assert( m_pReceiveBuffer != m_ReceiveBuffer);
        DPRINT1(VERBOSE,
                "    deleting receive buffer @ %08lX.\n", m_pReceiveBuffer);
        Assert(m_pReceiveBuffer);
        LdapFree(m_pReceiveBuffer);

        m_pReceiveBuffer = NULL;
        m_fDeleteBuffer = FALSE;
    }
    
    ResetSend();
} // LDAP_REQUEST::Cleanup


VOID
LDAP_REQUEST::Init(
        IN PATQ_CONTEXT AtqContext,
        IN PLDAP_CONN LdapConn
        )
/*++

Routine Description:

    Initializes the request object for use.

Arguments:

    AtqContext - atqcontext to associate with the request
    LdapConn   - Connection object to associate with the request

Return Value:

    None

--*/
{
    m_patqContext = AtqContext; 
    LdapConn->ReferenceConnection( );
    m_LdapConnection = LdapConn;
    m_signature = SIGN_LDAP_REQUEST;
    m_pSealedData = m_pReceiveBuffer;
    m_fSSL = LdapConn->IsSSL();
    m_fTLS = LdapConn->IsTLS();
    m_fSignSeal = LdapConn->IsSignSeal();
    m_pOldSecContext = NULL;
    GetNetBufOpts();

    //
    // Link the request into the list of requests.
    //

    ReferenceRequest( );
    LdapConn->LockConnection( );
    m_State = BlockStateActive;
    InsertHeadList( 
        &LdapConn->m_requestList, 
        &m_listEntry 
        );
    LdapConn->UnlockConnection( );

    return;

} // LDAP_REQUEST::Init




LDAP_REQUEST*
LDAP_REQUEST::Alloc(
        IN PATQ_CONTEXT AtqContext,
        IN PLDAP_CONN LdapConn
        )
/*++

Routine Description:

    Allocates a request object.

Arguments:

    AtqContext - atqcontext to associate with the request
    LdapConn   - Connection object to associate with the request

Return Value:

    Pointer to the allocated request object

--*/
{
    PLDAP_REQUEST pRequest = NULL;
    PLIST_ENTRY   listEntry;

    ACQUIRE_LOCK(&LdapRequestCacheLock);

    if ( LdapConn->m_requestObject.m_State == BlockStateCached ) {
        pRequest = &LdapConn->m_requestObject;
        pRequest->m_State = BlockStateActive;
        RELEASE_LOCK(&LdapRequestCacheLock);
        Assert(!pRequest->m_fAllocated);
        IF_DEBUG(REQUEST) {
            DPRINT1(0,"Allocated built-in request %x\n",pRequest);
        }
        goto init;
    }

    if ( !IsListEmpty(&LdapRequestCacheList) ) {

        listEntry = RemoveHeadList(&LdapRequestCacheList);

        LdapRequestsCached--;
        RELEASE_LOCK(&LdapRequestCacheLock);

        pRequest = CONTAINING_RECORD(listEntry,
                                    LDAP_REQUEST,
                                    m_listEntry
                                    );

        Assert(pRequest->m_State == BlockStateCached);

        IF_DEBUG(REQUEST) {
            DPRINT1(0,"Allocated cached request %x\n",pRequest);
        }
    } else {

        RELEASE_LOCK(&LdapRequestCacheLock);
        pRequest = new LDAP_REQUEST;

        if ( pRequest != NULL ) {

            IF_DEBUG(REQUEST) {
                DPRINT1(0,"Allocated heap request %x\n",pRequest);
            }

            LdapRequestAlloc++;
            if ( LdapRequestAlloc > LdapRequestMaxAlloc ) {
                LdapRequestMaxAlloc = LdapRequestAlloc;
            }
        }
    }

init:

    if ( pRequest != NULL ) {

        //
        // !!! Make sure ref count is zero. There is a bug somewhere with ref
        // counts being off. 
        //

        Assert(pRequest->m_refCount == 0);
        pRequest->m_refCount = 0;
        pRequest->Init(AtqContext,LdapConn);
    }

    return pRequest;

} // LDAP_REQUEST::Alloc



VOID
LDAP_REQUEST::Free(
    LDAP_REQUEST* pRequest
    )
/*++

Routine Description:

    Frees/Cache the request object.

Arguments:

    pRequest - the request object to cache/free

Return Value:

    None.

--*/
{
    pRequest->Cleanup();
    pRequest->Reset();

    IF_DEBUG(REQUEST) {
        DPRINT1(0,"Freed request %x\n",pRequest);
    }

    if ( pRequest->m_fAllocated ) {

        if ( LdapRequestsCached < LdapBlockCacheLimit ) {
            ACQUIRE_LOCK( &LdapRequestCacheLock );
            LdapRequestsCached++;
            InsertHeadList( &LdapRequestCacheList, &pRequest->m_listEntry );
            RELEASE_LOCK( &LdapRequestCacheLock );
        } else {
            LdapRequestAlloc--;
            delete pRequest;
        }
    }

    return;

} // LDAP_REQUEST::Free


BOOL
LDAP_REQUEST::GrowReceive(
    DWORD dwActualSize
    )
/*++

Routine Description:

    This routine will be called when we need more data to construct the current message.

Arguments:

    dwActualSize - the actual size of buffer to use. 
                   if zero we allocate a small buffer.

Return Value:

    TRUE if could grow the buffer.

--*/
{
    PUCHAR pReceiveBufferSave = m_pReceiveBuffer;

    IF_DEBUG(MISC) {
        DPRINT1(0, "Growing receive buffer, request@ %08lX.\n", this);
    }

    Assert((dwActualSize == 0) || (dwActualSize > m_cchReceiveBufferUsed));

    // check to see if we have filled up the buffer. if not, we don't have to grow it
    if (dwActualSize && (dwActualSize <= m_cchReceiveBuffer)) {
        //
        // We already have enough buffer space, just not enough data.
        // 
        return TRUE;
    } else if (!dwActualSize && (m_cchReceiveBufferUsed < m_cchReceiveBuffer)) {
        //
        // We don't know how much buffer is required, be we still have some
        // left.  Use that before getting more to avoid growing the buffer
        // faster than the message is being received.
        //
        return TRUE;
    }

    if (m_pReceiveBuffer == m_ReceiveBuffer) {

        //
        //  This is the first time we have extended the buffer
        //

        // if size not known, figure one
        //
        if (dwActualSize == 0) {
            dwActualSize = m_cchReceiveBuffer + SIZEINCREMENT;
        }
        // if this is the first time, and we know the size,
        // we want to read up to the LdapLimit
        //
        else if (dwActualSize > LdapMaxReceiveBuffer) {
            IF_DEBUG(ERROR) {
                DPRINT(0,"Cannot grow buffer due to admin limit\n");
            }
            return FALSE;
        }

        PUCHAR NewStart = (PUCHAR)LdapAlloc(dwActualSize);

        if (!NewStart) {

            IF_DEBUG(ERROR) {
                DPRINT2(0,"Failed to allocate receive buffer[%x] err %x\n",
                        m_cchReceiveBuffer + SIZEINCREMENT, GetLastError());
            }
            return FALSE; // failed to allocate memory

        } else {

            IF_DEBUG(MISC) {
                DPRINT1(0,"    Case 2 @ %08lX.\n", this);
            }
            //
            //  Save data received so far and update to point at new buffer.
            //
            
            m_fDeleteBuffer = TRUE;
            CopyMemory(NewStart, &m_ReceiveBuffer[0], m_cchReceiveBufferUsed);
            m_pReceiveBuffer = NewStart;
            m_cchReceiveBuffer = dwActualSize;
        }

    } else {

        DWORD neededBufferSize = m_cchReceiveBuffer * 2;
        PUCHAR NewStart = NULL;
        
        IF_DEBUG(MISC) {
            DPRINT1(0,"    Case 3 @ %08lX.\n", this);
        }

        // if we need more than we allow, wait until we fill
        // the buffer we allow. if this is filled, then fail
        if (neededBufferSize > LdapMaxReceiveBuffer) {
            if (m_cchReceiveBuffer >= LdapMaxReceiveBuffer) {
                IF_DEBUG(ERROR) {
                    DPRINT(0,"Cannot grow buffer due to admin limit\n");
                }
                return FALSE;
            }
            else {
                neededBufferSize = LdapMaxReceiveBuffer;
            }
        }

        NewStart = (PUCHAR)LocalReAlloc(
                                   m_pReceiveBuffer,
                                   neededBufferSize,
                                   LMEM_MOVEABLE); 

        if (!NewStart) {
            IF_DEBUG(ERROR) {
                DPRINT1(0,"Realloc failed with %x\n",GetLastError());
            }
            return FALSE; // No room to grow!
        }

        m_pReceiveBuffer = NewStart;
        m_cchReceiveBuffer = neededBufferSize;
    }

    if ( HaveSealedData() ) {
        
        //
        //  Buffer has moved. Change our pointer to go to the correct offset
        //

        m_pSealedData = m_pReceiveBuffer + (m_pSealedData - pReceiveBufferSave);
    }

    return TRUE;
} // GrowReceive


VOID
LDAP_REQUEST::ShrinkReceive(
        IN DWORD Size,
        IN BOOL  fIgnoreSealedData
        )
/*++

Routine Description:

    This routine adjusts the contents of the request buffer to take into account
    a removed message.

Arguments:

    Size - Number of bytes processed from the request buffer.
    fIgnoreSealedData - treat the buffer like ordinary buffers

Return Value:

    None.

--*/
{

    if ( HaveSealedData() && !fIgnoreSealedData ) {

        //
        //  UserData has processed "Size" unsealed bytes.
        //

        m_cchUnSealedData -= Size;
    
        if ( (m_cchUnSealedData != 0) || ((m_cchSealedData != 0) && !IsSSLOrTLS()) ) {
    
            //  1. Not processed all the unsealed data. Just move the unread, unsealed
            //  data to the start of the buffer.
            //  2. Sign/sealing is turned on and we have more encrypted data 
            //  to process. Moved sealed data to start of the buffer.
    
            m_pSealedData -= Size;
        } else if (m_cchSealedData) {

            //  Doing SSL with more encrypted stuff.
            //  There is a gap (where the unsealed data was) followed by
            //  the sealed data. We only have a part of the SSL message otherwise
            //  we would have decrypted it already. Luckily we have nothing to do
            //  in this case except remove the gap. Since there is guaranteed to be a
            //  header at the start of the sealed data we will wait until Decrypt
            //  and then move the data just once. If m_pSealedData - pReceiveBuffer were
            //  large then it would be worth the copy.
            //

            return;

        } else {
            //  No more data to process. Empty out the underlying buffer.
            Size = GetReceiveBufferUsed( );
        }
    }

    Assert(m_cchReceiveBufferUsed >= Size);
    
    m_cchReceiveBufferUsed -= Size;
    
    //  Use MoveMemory because pointers may overlap.
    
    if ( m_cchReceiveBufferUsed > 0 ) {
        MoveMemory(m_pReceiveBuffer, m_pReceiveBuffer + Size, m_cchReceiveBufferUsed);
    }

} // ShrinkReceive

DecryptReturnValues
LDAP_REQUEST::DecryptSSL(
    VOID
    )
/*++

Routine Description:

    Decrypt received SSL\TLS data, if necessary.

Arguments:

    None.

Return Value:

    Indication to caller as to what to do next.

--*/
{
    PLDAP_CONN conn = m_LdapConnection;
    DecryptReturnValues ret = Processed;
    PCtxtHandle phContext;

    SECURITY_STATUS scRet;
    BOOL UnsealedSomeData = FALSE;
    
    SecBufferDesc   MessageIn;
    SecBuffer       InBuffers[MAX_SSL_BUFFERS];
    PUCHAR          pSavedSealedData;

    Assert(IsSSLOrTLS());

    phContext = &conn->m_hSslSecurityContext;
    if (conn->m_SslState != Sslbound) {
        return Authenticate(phContext, &conn->m_SslState);
    }

    IF_DEBUG(SSL) {
        DPRINT2(0,"Decrypt SSL Message %p Length %d\n", m_pSealedData, m_cchSealedData);
    }

    if (!m_cchSealedData) {
        //
        // Nothing left to decrypt.  There should be some already decoded
        // data though.
        // 
        Assert(m_cchUnSealedData);
        return Processed;
    }

    //
    // ok, decryption time
    //
    //  The ReceiveBuffer is used as follows:
    //
    //  1. m_cchUnSealedData bytes of data starting at pReceiveBuffer
    //  2. possibly a gap caused when unsealing the above data
    //  3. m_cchSealedData bytes starting at m_pSealedData.
    //
    //  The size of the gap is:
    //      GetReceiveBufferUsed() - m_cchSealedData - m_cchUnSealedData
    //
    //
    //  Unseal as many SSL messages as possible. When we have no more unsealed data
    //  or we only have a partial SSL message we exit.
    //
    //  Return values depend upon whether we unsealed anything. If we did then return
    //  processed.
    //

    if (!m_ReceivedSealedData) {
        //  Well that was easy.
        IF_DEBUG(SSL) {
            DPRINT(0,"No sealed data to decrypt\n");
        }
        goto exit;
    }

    m_ReceivedSealedData = FALSE;

    while (m_cchSealedData) {
        
        pSavedSealedData = m_pSealedData;
        
        MessageIn.ulVersion = SECBUFFER_VERSION;
        MessageIn.cBuffers = 4;
        MessageIn.pBuffers = InBuffers;

        InBuffers[0].BufferType = SECBUFFER_DATA;
        InBuffers[0].pvBuffer = m_pSealedData;
        InBuffers[0].cbBuffer = m_cchSealedData;
        InBuffers[1].BufferType = SECBUFFER_EMPTY;
        InBuffers[2].BufferType = SECBUFFER_EMPTY;
        InBuffers[3].BufferType = SECBUFFER_EMPTY;

        IF_DEBUG(SSL) {
            DPRINT2(0,"Decrypting buffer %p [length %d]\n",
                   m_pSealedData, m_cchSealedData);
        }

        scRet = DecryptMessage(phContext, &MessageIn, 0, NULL);

        IF_DEBUG(SSL) {
            DPRINT1(0,"UnsealMessage returns with %x\n",scRet);
        }

        //
        //  Remove any gaps in the unsealed data and remember the unencrypted data
        //

        if (scRet == SEC_E_OK) {

            PUCHAR pbNextFree = m_pReceiveBuffer + m_cchUnSealedData;
            m_cchSealedData = 0;

            for ( int i = 0; 
                 (i < MAX_SSL_BUFFERS) 
                  && (InBuffers[i].BufferType != SECBUFFER_EMPTY);
                  i++ ) {


                if ( InBuffers[i].BufferType == SECBUFFER_DATA ) {

                    IF_DEBUG(SSL) {
                        DPRINT2(0,"Data Buffer %p Length %d\n",
                               InBuffers[i].pvBuffer, InBuffers[i].cbBuffer);
                    }

                    //
                    // Slide the data down if necessary.
                    //
                    if ( pbNextFree != InBuffers[i].pvBuffer ) {

                        CopyMemory( pbNextFree,
                                    InBuffers[i].pvBuffer,
                                    InBuffers[i].cbBuffer );
                    }
                    pbNextFree += InBuffers[i].cbBuffer;
                    m_cchUnSealedData += InBuffers[i].cbBuffer;
                    UnsealedSomeData = TRUE;

                } else if ( InBuffers[i].BufferType == SECBUFFER_EXTRA ) {

                    IF_DEBUG(SSL) {
                        DPRINT2(0,"Extra Buffer %p Length %d\n",
                               InBuffers[i].pvBuffer, InBuffers[i].cbBuffer);
                    }

                    m_pSealedData = (PUCHAR)InBuffers[i].pvBuffer;
                    m_cchSealedData = InBuffers[i].cbBuffer;
                }

            }
            IF_DEBUG(SSL) {
                DPRINT1(0, "Setting m_cchUnSealedData to %d\n", m_cchUnSealedData);
                DPRINT1(0, "Setting m_cchReceiveBufferUsed to %d\n", m_cchReceiveBufferUsed);
            }

        } else if ( scRet == SEC_E_INCOMPLETE_MESSAGE ) {
            break;
        } else if ( scRet == SEC_I_CONTEXT_EXPIRED && IsTLS() ) {
            // Client wants to stop encrypting.
            IF_DEBUG(SSL) {
                DPRINT(0, "Received StopTLS from client.\n");
            }

            conn->m_SslState = Sslunbinding;

            conn->LockConnection();
            __try {            
                conn->AbandonAllRequests();
            }
            __finally {
                conn->UnlockConnection();
            }

            conn->ZapSecurityContext();
            conn->m_fTLS = FALSE;
            conn->SetNetBufOpts(NULL);

            ShrinkReceive(GetReceiveBufferUsed( ), FALSE);

            ret = SendTLSClose(phContext);
            return ret;

        } else {
            //  When LDAP logs to eventvwr we should optionally
            //  log the error code here.

            IF_DEBUG(ERROR) {
                DPRINT3(0,"Decrypt %x Start %x Length %d.\n", 
                        this, m_pSealedData, m_cchSealedData);
            }
            ret = DecryptFailed;
            goto exit;
        }
    }

    if ( m_cchUnSealedData != 0 ) {

        if (UnsealedSomeData) {
            ret = Processed;

            if ((!m_cchSealedData) && (pSavedSealedData == m_pSealedData)) {
                //
                // The entire buffer was decrypted so move the sealed data pointer up.
                //
                IF_DEBUG(SSL) {
                    DPRINT(0, "Decrypted some data, moving pSealedData up.\n");
                    DPRINT2(0, "  m_cchSealedData = %d, m_cchUnSealedData = %d\n", m_cchSealedData, m_cchUnSealedData);
                }
                m_cchReceiveBufferUsed = m_cchUnSealedData + m_cchSealedData;
                m_pSealedData = m_pReceiveBuffer + m_cchReceiveBufferUsed;
            }

        } else {
            ret = NeedMoreInput;
        }

    } else {

        if (m_cchSealedData == 0) {

            //
            //  No unsealed data or sealed data. Toss out any lower level
            //  data
            //

            ShrinkReceive(GetReceiveBufferUsed( ), TRUE);
        }
        ret = NeedMoreInput;
    }

exit:

    return ret;
} // Decrypt


BOOL
LDAP_REQUEST::PostReceive(
    VOID
    )
/*++

Routine Description:

    This routine will be called when we need more data from the client.

Arguments:

    None.

Return Value:

    TRUE on success and FALSE if there is a failure.

--*/
{

    BOOL Status;

    WSABUF wsabuf = {
        m_cchReceiveBuffer - m_cchReceiveBufferUsed,
        (PCHAR)m_pReceiveBuffer + m_cchReceiveBufferUsed
        };

    ReferenceRequestOperation( );
 
    Status = AtqReadSocket(
                m_patqContext,
                &wsabuf,
                1,
                NULL
                );

    DereferenceRequest( );

    if (!Status) {
        DereferenceRequest( );
        DPRINT1(QUIET, "AtqReadFile failed %d\n", GetLastError());
    }

    return Status;
} // PostReceive


SECURITY_STATUS
LDAP_REQUEST::ReceivedClientData(
    IN DWORD cbWritten,
    IN PUCHAR pbBuffer
    )
/*++

Routine Description:

    This routine will be called when we have a Receive completion.

Arguments:

    cbWritten supplies the number of bytes put there.
    pbBuffer supplies where ATQ put the data. NULL if we told ATQ
        where to put the data.

Return Value:

    Success.

--*/
{
    //
    // Set this flag here
    //

    m_fSignSeal = m_LdapConnection->IsSignSeal();
    m_fTLS = m_LdapConnection->IsTLS();
    
    GetNetBufOpts();

    if ( HaveSealedData() ) {

        //
        //  Update the information about the raw data
        //
        m_cchSealedData += cbWritten;
        m_ReceivedSealedData = TRUE;
    }

    m_cchReceiveBufferUsed += cbWritten;
    
    if (pbBuffer != NULL) {

        m_pReceiveBuffer = pbBuffer;

        //
        // The only time we get data from ATQ without us telling ATQ where to
        // put the data is in the UDP case.
        //
    }

    return ERROR_SUCCESS;
} // ReceivedClientData


BOOL
LDAP_REQUEST::GrowSend(
    IN DWORD Size
    )
/*++

Routine Description:

    This routine will be called when we need to put more than one request in a message.
    For example search.

Arguments:

    Size of the request to be added.

Return Value:

    TRUE indicates buffer grown. FALSE means malloc failure.

--*/
{
    PUCHAR NewStart = NULL;
    DWORD GrowthSize = 0;

    IF_DEBUG(SEND) {
        DPRINT3(0, "GrowSend: Entered GrowSend with ScatterGather = %s, header = %d, trailer =%d\n",
                CanScatterGather() ? "TRUE" : "FALSE",
                NeedsHeader() ? m_HeaderSize : 0,
                NeedsTrailer() ? m_TrailerSize : 0);
    }

    //
    // If we need to reserve space for a trailer add that in now.
    //
    if (NeedsTrailer() && !CanScatterGather()) {
        Size += m_TrailerSize;
    }

    DWORD requestSize =  (Size > SIZEINCREMENT)? Size : SIZEINCREMENT;

    IF_DEBUG(SEND) {
        DPRINT2(0,"GrowSend: Requested size %d [wsaBuf %x]\n",
                 Size, m_wsaBuf);
    }

    if ( m_wsaBuf == NULL ) {

        //
        // This is the first time through this function.  Need to set up a send
        // buffer from scratch.
        //

        PCHAR pHeader = NULL;

        Assert(m_wsaBuf == NULL);
        Assert(m_wsaBufCount == 0);
        Assert(m_wsaBufAlloc == 0);

        if ( Size < 512 ) {
            GrowthSize = 512;
        } else {
            GrowthSize = requestSize;
        }

        NewStart = (PUCHAR)LdapAlloc(GrowthSize);

        //
        // if sign/sealing is enabled in thie connection, allocate a buffer for
        // the header
        //

        if ( NeedsHeader() && !CanScatterGather() && (NewStart != NULL) ) {

            IF_DEBUG(SSL) {
                DPRINT1(0,"Allocating the header buffer [size %d]\n",
                        sizeof(DWORD) + m_HeaderSize);
            }

            pHeader = (PCHAR)LdapAlloc( sizeof(DWORD) + m_HeaderSize );
            if ( pHeader == NULL ) {
                IF_DEBUG(WARNING) {
                    DPRINT(0,"Unable to allocate header for sign/seal\n");
                }
                LdapFree(NewStart);
                NewStart = NULL;
            }
        }

        //
        // This is our initial buffer. Use the builtin WSAbufs
        //

        if ( NewStart != NULL ) {
            m_wsaBuf = (LPWSABUF)m_builtinWsaBuf;
            m_wsaBufAlloc = NUM_BUILTIN_WSABUF;

            if ( pHeader != NULL ) {

                m_wsaBuf[0].len = sizeof(DWORD) + m_HeaderSize;
                m_wsaBuf[0].buf = pHeader;
                m_wsaBufCount = 1;
            }
        }

        IF_DEBUG(SEND) {
            DPRINT2(0,"GrowSend: Initial buffer %x Length %d\n", 
                     NewStart, GrowthSize);
        }

    } else {

        LPWSABUF buf;
        LPWSABUF tmpWsaBuf;
        Assert(m_wsaBufCount != 0);

        //
        // First see if there are enough WSABUFS on the request, and if not
        // get some more.
        //

        if ( (m_wsaBufCount < m_wsaBufAlloc) || !CanScatterGather() ) {
            //
            // Either we still have unused WSABUFS or
            // if scatter gathering isn't allowed then we have to grow the existing
            // buffer on the WSABUF, so we don't need any more WSABUF's.  
            //
            tmpWsaBuf = m_wsaBuf;

        } else {

            //
            // There aren't enough WSABUFS on this request.  It's time to get some more.
            // If this is the first time we've run out then we need to fall back to getting
            // them from the heap.  Otherwise just try to expand the the current WSABUF array.
            //
            m_wsaBufAlloc = m_wsaBufCount + NUM_BUILTIN_WSABUF;
            if ( m_wsaBuf == m_builtinWsaBuf ) {

                tmpWsaBuf = (LPWSABUF)LdapAlloc(m_wsaBufAlloc*sizeof(WSABUF));
                if ( tmpWsaBuf != NULL ) {
                    CopyMemory(tmpWsaBuf, m_wsaBuf, sizeof(m_builtinWsaBuf));
                }

            } else {

                tmpWsaBuf = (LPWSABUF)LocalReAlloc(
                                    m_wsaBuf,
                                    m_wsaBufAlloc*sizeof(WSABUF),
                                    LMEM_MOVEABLE
                                    );
            }
        }

        //
        // If we managed to get enough WSABUFS it's time to 
        // get some more actual send buffer space.
        //

        if ( tmpWsaBuf != NULL ) {

            m_wsaBuf = tmpWsaBuf;

            // The new or expanded buffer will go in the last WSABUF
            buf = &tmpWsaBuf[m_wsaBufCount-1];

            GrowthSize = buf->len + requestSize;
    
            //
            // Try to expand the buffer first. If this is the first buffer, it should be
            // limited to about 8K
            //

            if ( (m_wsaBufCount != 1) || (GrowthSize <= 2*SIZEINCREMENT) || !CanScatterGather() ) {

                NewStart = (PUCHAR)LocalReAlloc(
                                buf->buf,
                                GrowthSize,
                                IsSSLOrTLS() ? LMEM_MOVEABLE: 0);
            } else {
                NewStart = NULL;
            }

            if ( NewStart == NULL ) {

                // 
                // For some reason the buffer couldn't be expanded.  That's OK as long
                // as we can scatter gather.
                //

                if ( CanScatterGather() ) {
                    //
                    // Scatter gather is allowed so try to allocate a new buffer
                    //

                    IF_DEBUG(SEND) {
                        DPRINT2(0,"GrowSend: Cannot expand %x to %d\n", buf->buf, GrowthSize);
                    }

                    //
                    // Set the correct length for the previous buffer
                    //

                    PackLastSendBuffer( );

                    //
                    // Adjust size 
                    //

                    GrowthSize = requestSize;
                    NewStart = (PUCHAR)LdapAlloc(GrowthSize);

                    IF_DEBUG(SEND) {
                        DPRINT2(0,"GrowSend: Allocated %x length %d instead\n",
                                NewStart, GrowthSize);
                    }

                }
            } else {

                IF_DEBUG(SEND) {
                    DPRINT2(0,"GrowSend: Extended %x to %d\n", 
                             NewStart, GrowthSize);
                }

                //
                // We managed to extend the same buffer. Make sure we adjust
                // the next ptr if the base ptr has changed
                //

                if ( NewStart != (PUCHAR)buf->buf ) {
                    DWORD offset;
                    offset = (DWORD)(GetSendBuffer() - (PUCHAR)buf->buf);
                    SetBufferPtr(NewStart + offset);
                    buf->buf = (PCHAR)NewStart;
                }

                //
                // If trailer space had to be reserved, make it invisible for now.
                //

                buf->len = GrowthSize;
                if (NeedsTrailer() && !CanScatterGather()) {                
                    buf->len -= m_TrailerSize;
                }

                //
                // Since this was a simple expansion we're all done.
                //
                return TRUE;
            }
        } else {
            IF_DEBUG(ERROR) {
                DPRINT(0,"Cannot allocate memory for WSABUF\n");
            }
        }

    }

    if (NewStart == NULL) {
        IF_DEBUG(ERROR) {
            DPRINT2(0,"Failed to grow receive buffer[%x] err %x\n",
                    GrowthSize, GetLastError());
        }

        return FALSE;
    }

    //
    // If we are here, then a new buffer was allocated, either because
    // this was the first call to this function or because the last buffer
    // could not be expanded.  Attach the new buffer to the last WSABUF and
    // hide any trailer space that may have been reserved.
    //
    m_wsaBuf[m_wsaBufCount].len = (NeedsTrailer() && !CanScatterGather()) 
                                     ? (GrowthSize - m_TrailerSize) : GrowthSize;

    m_wsaBuf[m_wsaBufCount].buf = (PCHAR)NewStart;
    m_wsaBufCount++;
    SetBufferPtr((PUCHAR)NewStart);

    return TRUE;

} // GrowSend



VOID
LDAP_REQUEST::ResetSend(
    VOID
    )
/*++

Routine Description:

    This routine will be called when we have sent the encoded message and we
    need to clear the internal buffer.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD i;

    if (m_pSslContextBuffer != NULL) {
        FreeContextBuffer( m_pSslContextBuffer );
        m_pSslContextBuffer = NULL;
    }

    m_nextBufferPtr = NULL;
    if (m_sendBufAllocList) {
        for (i=0; m_sendBufAllocList[i]; i++) {
            LdapFree(m_sendBufAllocList[i]);
        }
        if (m_sendBufAllocList != m_builtinSendBufAllocList) {
            LdapFree(m_sendBufAllocList);
        }
        m_sendBufAllocList = NULL;
    } else if ( m_wsaBufCount != 0 ) {
        Assert(m_wsaBuf != NULL);

        for (i=0; i < m_wsaBufCount; i++ ) {
            IF_DEBUG(SEND) {
                DPRINT2(0,"ResetSend: Freeing wsaBuf%d %x\n",i, m_wsaBuf[i].buf);
            }

            if ( m_wsaBuf[i].buf != NULL ) {
                LdapFree(m_wsaBuf[i].buf);
            }
        }
    }

    m_wsaBufCount = 0;
    m_wsaBufAlloc = 0;

    if ( m_wsaBuf != NULL ) {
        if ((m_wsaBuf != m_builtinWsaBuf) && (m_wsaBuf != m_builtinEncryptBuf)) {
            LdapFree(m_wsaBuf);
        }
        m_wsaBuf = NULL;
    }

    return;

} // ResetSend


BOOL
LDAP_REQUEST::Send(
    BOOL       fDataGram,
    CtxtHandle * phSslSecurityContext
    )
/*++

Routine Description:

    This routine will be called when we have encoded another message and we need
    to send the internal buffer contents to the client.

Arguments:

    fDataGram   - Is this a datagram send?
    phSslSecurityContext - Used by SSL,

Return Value:

    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL     bRetVal = TRUE;
    WSABUF   wsaBuf;
    LPWSABUF pWsaBuf;
    DWORD    bufCount;
    DWORD    fHaveSent = FALSE;
    DWORD    dwSentBytes;

    //
    // See if we need to encrypt/sign message
    //

    if ( HaveSealedData() ) {
        if ( IsSSLOrTLS() ) {
            if ( !EncryptSslSend(phSslSecurityContext) ) {
                return FALSE;
            }
        } else {
            if ( !SignSealMessage( ) ) {
                return FALSE;
            }
        }
    }

    PackLastSendBuffer( );
    bufCount = m_wsaBufCount;
    pWsaBuf = m_wsaBuf;

    //
    // Add 2 references
    //

    ReferenceRequestOperation( );

    if ( fDataGram ) {

        AtqContextSetInfo(
                m_patqContext,
                ATQ_INFO_COMPLETION_CONTEXT,
                (DWORD_PTR)this
                );
        
        bRetVal = AtqWriteDatagramSocket(
                    m_patqContext,
                    pWsaBuf,
                    bufCount,
                    NULL);

    } else {

        INT i = 5;

        do {

            bRetVal =  AtqWriteSocket( m_patqContext,
                                   pWsaBuf,
                                   bufCount,
                                   &m_ov);

            if ( bRetVal || (WSAGetLastError() != WSAENOBUFS) ) {
                IF_DEBUG(ERR_NORMAL) {
                    if ( !bRetVal ) {
                        DPRINT1(0,"AtqWriteSocket failed with %d\n",GetLastError());
                    }
                }
                break;
            }

            SetLastError(ERROR_NO_SYSTEM_RESOURCES);

            //
            // We can't chunk the send if we have only one buffer because we need
            // to do an async operation so this completes the processing properly.
            //

            if ( bufCount > 1 ) {

                //
                // try sending the first chunk synchronously in 4K chunks. If successful, 
                // remove the first chunk from the next retry.  If failed, retry.
                //

                PCHAR  pBuf = pWsaBuf->buf;
                DWORD sendLength;
                DWORD remLength = pWsaBuf->len;
                
                IF_DEBUG(WARNING) {
                    DPRINT2(0,"Sending buffer %p [len %d] in chunks.\n", pBuf, remLength);
                }

                do {
                      
                    sendLength = min(remLength, 4 * 1024);
                    remLength -= sendLength;

                    wsaBuf.len = sendLength;
                    wsaBuf.buf = pBuf;

                    bRetVal = AtqSyncWsaSend(m_patqContext, &wsaBuf, 1, &dwSentBytes);

                    if ( bRetVal ) {

                        //
                        // the send succeeded, mark that we've sent something. update the
                        // buffer.
                        //

                        fHaveSent = TRUE;
                        pBuf += sendLength;

                    } else if ( fHaveSent ) {

                        //
                        // if we failed and we've sent a partial chunk, bail out. we can't
                        // recover.
                        // 

                        IF_DEBUG(ERROR) {
                            DPRINT1(0,"Synchronous send failed with %d\n",WSAGetLastError());
                        }
                        goto exit;
                    }


                } while ( remLength > 0 );

                //
                // if we sent the first buffer successfully, retry with the updated 
                // pointers.  Free the buffer we've just sent.
                //

                if ( fHaveSent ) {

                    LdapFree(pWsaBuf->buf);
                    pWsaBuf->buf = NULL;

                    pWsaBuf++;
                    bufCount--;
                    continue;
                } 
            }

            //
            // We're here because either we have only one buffer to send or
            // our retry failed.
            //

            i--;
            Sleep(100);

            IF_DEBUG(WARNING) {
                DPRINT3(0,"Retrying [%d] AtqWriteSocket on %p [len %d]\n",
                        i, pWsaBuf->buf, pWsaBuf->len);
            }

        } while ( i > 0 );
    }

exit:
    DereferenceRequest( );

    if ( !bRetVal ) {
        DereferenceRequest( );

        //
        // if the operation failed but we've send a partial chunk, then fail with
        // a different error so we don't retry. The connection needs to be shutdown.
        //

        if ( fHaveSent ) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return bRetVal;

} // Send



BOOL
LDAP_REQUEST::SyncSend(
    CtxtHandle *        phSslSecurityContext
    )
/*++

Routine Description:

    Performs a synchronous send on the associated connection.

Arguments:

    phSslSecurityContext - supplies the connections context is SSL/TLS is active.

Return Value:

    TRUE on success and FALSE if there is a failure.
    
--*/
{
    BOOL   bRetVal = TRUE;
    LPWSABUF pWsaBuf;
    DWORD   bufCount;
    DWORD   dwBytesWritten;
    
    //
    // See if we need to encrypt/sign message
    //

    if ( HaveSealedData() ) {
        if ( IsSSLOrTLS() ) {
            if ( !EncryptSslSend(phSslSecurityContext) ) {
                return FALSE;
            }
        } else {
            if ( !SignSealMessage( ) ) {
                return FALSE;
            }
        }
    }

    PackLastSendBuffer( );
    bufCount = m_wsaBufCount;
    pWsaBuf = m_wsaBuf;
    
    return  AtqSyncWsaSend( m_patqContext,
                            pWsaBuf,
                            bufCount,
                            &dwBytesWritten);
}


DecryptReturnValues
LDAP_REQUEST::Authenticate(
    CtxtHandle *        phSslSecurityContext,
    SslSecurityState *  pSslState
    )
/*++

Routine Description:

    Handle authentication exchange.

Arguments:

    phSslSecurityContext - supplies the connections context
    pSslState - supplies address to save the connection state

Return Value:

    NeedMoreInput - The caller is to post a receive using this request
    ResponseSent - The response has already been sent.  Caller may need
            to allocate a new request object to start a receive
    DecryptFailed - Failure       
    
--*/
{
    SECURITY_STATUS scRet;
    TimeStamp       tsExpiry;
    DWORD           ContextAttributes;

    SecBufferDesc   InMessage;
    SecBuffer       InBuffers[MAX_SSL_BUFFERS];

    SecBufferDesc   OutMessage;
    SecBuffer       OutBuffers[MAX_SSL_BUFFERS];

    IF_DEBUG(SSL) {
        DPRINT2(0,"Authenticating SSL connection [State %x][req %x]\n",
                *pSslState, this);
    }

start_accept:

    InMessage.ulVersion = SECBUFFER_VERSION;
    InMessage.cBuffers = 4;
    InMessage.pBuffers = InBuffers;

    ZeroMemory(InBuffers, sizeof( InBuffers ) );
    InBuffers[0].BufferType = SECBUFFER_TOKEN;
    InBuffers[0].cbBuffer = GetReceiveBufferUsed( );
    InBuffers[0].pvBuffer = m_pReceiveBuffer;
    InBuffers[1].BufferType = SECBUFFER_EMPTY;
    InBuffers[2].BufferType = SECBUFFER_EMPTY;
    InBuffers[3].BufferType = SECBUFFER_EMPTY;

    OutMessage.ulVersion = SECBUFFER_VERSION;
    OutMessage.cBuffers = 4;
    OutMessage.pBuffers = OutBuffers;

    ZeroMemory(OutBuffers, sizeof( OutBuffers ) );  
    OutBuffers[0].BufferType = SECBUFFER_EMPTY;
    OutBuffers[1].BufferType = SECBUFFER_EMPTY;
    OutBuffers[2].BufferType = SECBUFFER_EMPTY;
    OutBuffers[3].BufferType = SECBUFFER_EMPTY;

    //
    // Put this under lock since the ssl credentials may be dynamically
    // changed.
    //

    ACQUIRE_LOCK(&LdapSslLock);

    if ( fhSslCredential ) {
        INC(pcLdapThreadsInAuth);
        scRet = AcceptSecurityContext(
                &hSslCredential,
                (*pSslState==Sslpartialbind)?phSslSecurityContext:NULL,
                &InMessage,
                ASC_REQ_SEQUENCE_DETECT |
                    ASC_REQ_REPLAY_DETECT |
                    ASC_REQ_CONFIDENTIALITY |
                    ASC_REQ_MUTUAL_AUTH |
                    ASC_REQ_STREAM |
                    ASC_REQ_ALLOCATE_MEMORY,
                SECURITY_NATIVE_DREP,
                phSslSecurityContext,
                &OutMessage,
                &ContextAttributes,
                &tsExpiry );
        DEC(pcLdapThreadsInAuth);
    } else {

        RELEASE_LOCK(&LdapSslLock);
        return DecryptFailed;
    }

    RELEASE_LOCK(&LdapSslLock);

    IF_DEBUG(SSL) {
        DPRINT1(0,"AcceptSecurityContext returned %x\n", scRet);
    }

    if(SECBUFFER_EXTRA == InBuffers[1].BufferType) {
        IF_DEBUG(SSL) {
            DPRINT2(0,"ASC returned extra buffer[scRet %x][bytes %d]\n",
                    scRet, InBuffers[1].cbBuffer);
        }

        ShrinkReceive(GetReceiveBufferUsed( ) - InBuffers[1].cbBuffer, TRUE);
        m_pSealedData = (PUCHAR)m_pReceiveBuffer;
        m_cchSealedData = InBuffers[1].cbBuffer;
        goto start_accept;
    } else if (scRet != SEC_E_INCOMPLETE_MESSAGE) {
        //  Indicate there's nothing left in the buffer
        m_cchSealedData = 0;
        ShrinkReceive(GetReceiveBufferUsed(), TRUE);
    }

    if ( SUCCEEDED( scRet ) ) {

        WSABUF wsaBuf = {OutBuffers[0].cbBuffer,
                         (PCHAR)OutBuffers[0].pvBuffer };

        //
        //  Record address so we can free later
        //

        m_pSslContextBuffer = OutBuffers[0].pvBuffer;

        if ( scRet != SEC_I_CONTINUE_NEEDED ) {

            if ( !m_LdapConnection->GetSslContextAttributes( ) ) {
                return DecryptFailed;
            }
            if (IsSSL()) {
                if (m_LdapConnection->GetSslClientCertToken( )) {
                    m_LdapConnection->SetUsingSSLCreds();
                }
            }
            *pSslState = Sslbound;
        } else {

            *pSslState = Sslpartialbind;
        }

        //
        // No third leg?
        //

        if ( OutBuffers[0].cbBuffer == 0 ) {

            //
            // Start receive using this request object
            //

            IF_DEBUG(SSL) {
                DPRINT(0,"Missing 3rd leg. Starting receive pump.\n");
            }
            return NeedMoreInput;
        }

        //
        //  Send response to client.
        //

        IF_DEBUG(SSL) {
            DPRINT2(0,"Sending SSL response[err=%x,bytes=%d]\n", scRet,OutBuffers[0].cbBuffer);
        }

        ReferenceRequestOperation( );
        if (AtqWriteSocket( m_patqContext,
                            &wsaBuf,
                            1,
                            &m_ov )) {

            DereferenceRequest( );
            return ResponseSent;

        } else {

            DereferenceRequest( );
            DereferenceRequest( );

            IF_DEBUG(ERROR) {
                DPRINT1(0,"AtqWriteSocket failed  @ %08lX.\n", this);
            }
            return DecryptFailed;  // abandon connection
        }

    } else {

        if ( scRet == SEC_E_INCOMPLETE_MESSAGE ) {

            IF_DEBUG(SSL) {
                DPRINT1(0, 
                    "AcceptSecurityContext needs more data  @ %08lX.\n", this);
            }

            return NeedMoreInput;

        } else {
            IF_DEBUG(SSL) {
                DPRINT1(0,"Decrypt failed [%x]\n",scRet);
            }
            Assert(GetReceiveBufferUsed() == 0);
            return DecryptFailed;  // abandon connection
        }
    }
    return Processed;
} // LDAP_REQUEST::Authenticate


BOOL
LDAP_REQUEST::EncryptSslSend(
    IN CtxtHandle * phSslSecurityContext
    )
/*++

Routine Description:

    Used to seal the message to be sent.  At the beginning pUnsealedData points
    to the beginning of a buffer with unsealed data.  Data is copied into the
    buffer that pSealed data points to in chunks of maximumMessage size, and 
    then encrypted and headers and trailers are added.  The result is a new
    buffer with possibly several chunks of encrypted data.

Arguments:

    phSslSecurityContext - Required to seal the data,

Return Value:

    TRUE on success and FALSE if there is a failure.

--*/
{
    INT cbUnSealedData;
    PUCHAR pUnsealedData;
    PUCHAR pSealedData;
    PUCHAR pNextFree;
    INT MessageCount;
    int cbThisSize;

    SecBufferDesc   Message;
    SecBuffer       Buffers[3];

    SECURITY_STATUS scRet;
    PSecPkgContext_StreamSizes sizes;

    IF_DEBUG(SSL) {
        DPRINT1(0,"Encrypting send %x\n",this);
    }

    sizes = &m_LdapConnection->m_SslStreamSizes;

    Assert(m_wsaBufCount == 1);

    PackLastSendBuffer();
    cbUnSealedData = m_wsaBuf[0].len;
    pUnsealedData = (PUCHAR)m_wsaBuf[0].buf;

    // Get the count of messages for this stream...
    MessageCount = (cbUnSealedData/sizes->cbMaximumMessage) + 1;

    // ...and allocate enough space for both the encrypted data, and any
    //  headers/trailers.
    pSealedData = (PUCHAR)LdapAlloc(   cbUnSealedData +
                                    ( MessageCount *
                                        (sizes->cbHeader + sizes->cbTrailer)
                                    )
                                );
    if (!pSealedData) {
        IF_DEBUG(ERROR) {
            DPRINT1(0,"Unable to allocate sealed data buffer[err %x]\n",
                    GetLastError());
        }
        return FALSE;
    }

    pNextFree = pSealedData;

    Message.ulVersion = SECBUFFER_VERSION;
    Message.pBuffers = &Buffers[0];

    // Find out how many SEC_BUF's we need.
    Message.cBuffers = 1;

    // If we have data we'll need one for that.
    if (cbUnSealedData) {
        Message.cBuffers++;
    }

    // See if we need a buffer for the trailer.
    if (sizes->cbTrailer) {
        Message.cBuffers++;
    }

    // Start chunking the message into buffers no larger than the 
    //  maximum message size.  If there is data to encrypt then loop
    //  until it's all done.  If there is no data, then we are only
    //  doing this in order to get any control messages for the 
    //  stream that may need to be sent.  In that case go through
    //  the loop once to get any headers/trailers.
    cbThisSize = min( (int)sizes->cbMaximumMessage, cbUnSealedData);
    if (cbThisSize) {    
        cbUnSealedData -= cbThisSize;
    }
    for (;;) {    

        // Fill in the header.
        Buffers[0].BufferType = SECBUFFER_TOKEN;
        Buffers[0].cbBuffer = sizes->cbHeader;
        Buffers[0].pvBuffer = pNextFree;
        pNextFree += sizes->cbHeader;

        // The data for this chunk if any.
        if (cbThisSize) {        
            Buffers[1].BufferType = SECBUFFER_DATA;
            Buffers[1].cbBuffer = cbThisSize;
            Buffers[1].pvBuffer = pNextFree;

            CopyMemory( pNextFree,
                        pUnsealedData,
                        cbThisSize );
            pNextFree += cbThisSize;
            pUnsealedData += cbThisSize;
        }

        // and the trailer if necessary.
        if (sizes->cbTrailer) {
            Buffers[2].BufferType = SECBUFFER_TOKEN;
            Buffers[2].cbBuffer = sizes->cbTrailer;
            Buffers[2].pvBuffer = pNextFree;
        }

        // Do the actual encryption.
        scRet = EncryptMessage(phSslSecurityContext, 0, &Message, 0);
        if ( !SUCCEEDED( scRet ) ) {
            IF_DEBUG(ERROR) {
                DPRINT2(0, "Seal of  @ %08lX failed with @ %08lx.\n", 
                        this, scRet);
            }
            LdapFree(pSealedData);
            return FALSE;
        }

        //
        // Set the correct length
        //

        if ( sizes->cbTrailer ) {
            pNextFree += Buffers[2].cbBuffer;
        }

        // Continue?
        if (cbUnSealedData) {
            // More data to encrypt.
            cbThisSize = min( (int)sizes->cbMaximumMessage, cbUnSealedData);
            cbUnSealedData -= cbThisSize;
        } else {
            // No more data.  Get out.
            break;
        }
    }

    IF_DEBUG(SSL) {
        DPRINT2(0,"Freed %x replaced by %x\n", m_wsaBuf[0].buf, pSealedData);
    }

    LdapFree(m_wsaBuf[0].buf);
    m_wsaBuf[0].len = (DWORD)(pNextFree - pSealedData);
    m_wsaBuf[0].buf = (PCHAR)pSealedData;
    SetBufferPtr(pNextFree);
    
    return TRUE;
} // EncryptSslSend

BOOL
LDAP_REQUEST::SignSealMessage(
    VOID
    )
/*++

Routine Description:

    Used to sign/seal the message to be sent.

Arguments:

    None.

Return Value:

    TRUE on success and FALSE if there is a failure.

--*/
{

    SECURITY_STATUS scRet;
    PCtxtHandle    phContext;
    PSecBuffer     secBufs = NULL;
    SecBufferDesc  message;
    DWORD i;
    DWORD          msgSize = 0;
    DWORD          cEncryptChunks;
    PVOID          pTmpBuf = NULL;
    WSABUF         *pTmpWsaBufs = NULL;
    PUCHAR         pHeaderTrailerBuf = NULL;
    PUCHAR         pCurPos, pHeaderTrailerCurPos;
    DWORD          cHeaderTrailers;
    DWORD          cWsaBufs;
    DWORD          SecBufPos = 0;
    DWORD          WsaBufPos = 0;
    DWORD          subsize, cAllocs;
    DWORD          HeaderPos, TrailerPos;
    LPLDAP_SECURITY_CONTEXT pSecurityContext = NULL;

#define NUM_TMP_SEC_BUFS    16
    SecBuffer tmpBufs[NUM_TMP_SEC_BUFS];

    BOOL fRet = TRUE;

    IF_DEBUG(SSL) {
        DPRINT1(0,"Signing request %p.\n",this);
    }

    //
    // We need to unsign/unseal this packet
    //


    if (m_pOldSecContext) {
        pSecurityContext = m_pOldSecContext;
        phContext = pSecurityContext->GetSecurityContext();
    } else {
        EnterCriticalSection(&m_LdapConnection->m_csLock);
        
        pSecurityContext = m_LdapConnection->m_pSecurityContext;
        if ( pSecurityContext != NULL ) {

            phContext = pSecurityContext->GetSecurityContext();
            LeaveCriticalSection(&m_LdapConnection->m_csLock);

            Assert( pSecurityContext->NeedsSealing() || pSecurityContext->NeedsSigning() );

        } else {
            LeaveCriticalSection(&m_LdapConnection->m_csLock);
            IF_DEBUG(ERROR) {
                DPRINT1(0,"Request %p have inconsistent sign/seal flags\n",this);
            }
            fRet = FALSE;
            Assert(FALSE);
            goto exit;
        }
    }


    //
    // Call packlastsendbuffer so the length of the last buffer will be corrected.
    //

    PackLastSendBuffer();

    //
    // Count up how many buffers are going to be needed for data and store that
    // in cEncryptChunks.  Also count up how many header/trailer pairs there will
    // be and store that in cHeaderTrailers.
    //
    subsize = 0;
    cEncryptChunks = 0;
    cHeaderTrailers = 0;

    IF_DEBUG(SSL) {
        DPRINT1(0, "SignSealMessage: m_MaxEncryptSize = %d\n", m_MaxEncryptSize);
    }

    for (i=0; i < m_wsaBufCount; i++) {

        cEncryptChunks++;
        subsize += m_wsaBuf[i].len;

        IF_DEBUG(SSL) {
            DPRINT1(0, "SignSealMessage: incoming buf len %d\n", m_wsaBuf[i].len);
        }

        if (subsize >= m_MaxEncryptSize) {

            subsize -= m_MaxEncryptSize;
            cHeaderTrailers++;

            if (subsize) {
                cEncryptChunks += (subsize + (m_MaxEncryptSize - 1)) / m_MaxEncryptSize;
                cHeaderTrailers += subsize / m_MaxEncryptSize;
            }
        }

        subsize = subsize % m_MaxEncryptSize;
    }
    if (subsize) {
        cHeaderTrailers++;
    }

    IF_DEBUG(SSL) {
        DPRINT2(0, "SignSealMessage: cEncryptChunks = %d, cHeaderTrailers = %d\n", cEncryptChunks, cHeaderTrailers);
    }

    //
    // Make sure we have enough header/trailer buffer space.
    //
    if (cHeaderTrailers > 1 || (m_TrailerSize + m_HeaderSize > INITIAL_HEADER_TRAILER_SIZE)) {
        //
        // We need more header/trailer space than we have builtin to the request.
        // Go ahead and allocate some.
        //
        cAllocs = 1;

        IF_DEBUG(SSL) {
            DPRINT1(0, "SignSealMessage: Allocating space for %d headers and trailers\n", cHeaderTrailers);
            DPRINT2(0, "   m_HeaderSize = %d, m_TrailerSize = %d\n", m_HeaderSize, m_TrailerSize);
        }

        pHeaderTrailerBuf = (PUCHAR)LdapAlloc(cHeaderTrailers * (m_TrailerSize + m_HeaderSize));
        if (!pHeaderTrailerBuf) {
            fRet = FALSE;
            goto exit;
        }
    } else {
        cAllocs = 0;
        pHeaderTrailerBuf = m_builtinHeaderTrailerBuf;
    }

    //
    // Arrange to save off the pointers to the beginning of the buffers that were originally
    // alloced since we may fragment these buffers below.
    //
    // First make sure we have enough space for all the pointers.
    //
    cAllocs += m_wsaBufCount;
    if (cAllocs > NUM_BUILTIN_WSABUF) {

        IF_DEBUG(SSL) {
            DPRINT1(0, "SignSealMessage: Allocating space for %d pointers in the sendBufAllocList\n", cAllocs);
        }

        m_sendBufAllocList = (PUCHAR *)LdapAlloc((cAllocs + 1) * sizeof(PUCHAR));
        if (!m_sendBufAllocList) {
            if (cAllocs > m_wsaBufCount) {
                LdapFree(pHeaderTrailerBuf);
            }
            fRet = FALSE;
            goto exit;
        }
    } else {
        m_sendBufAllocList = m_builtinSendBufAllocList;
    }

    // 
    // Now actually save the pointers.
    //
    for (i=0; i<m_wsaBufCount; i++) {
        m_sendBufAllocList[i] = (PUCHAR)m_wsaBuf[i].buf;
    }

    //
    // If header/trailer space was allocated, save that now, and
    // NULL terminate the list of pointers.
    //
    if (cAllocs > m_wsaBufCount) {
        m_sendBufAllocList[m_wsaBufCount] = pHeaderTrailerBuf;
    }
    m_sendBufAllocList[cAllocs] = NULL;

    //
    // Any buffer fragments and each individual header and trailer
    // will require their own WSABUF's so requisition enough
    // of those.
    //
    cWsaBufs = cEncryptChunks + (2 * cHeaderTrailers);
    if (cWsaBufs > NUM_BUILTIN_WSABUF) {

        IF_DEBUG(SSL) {
            DPRINT1(0, "SignSealMessage: allocating %d wsabufs for encryption\n", cWsaBufs);
        }

        pTmpWsaBufs = (WSABUF *)LdapAlloc(cWsaBufs * sizeof(WSABUF));
        if (!pTmpWsaBufs) {
            fRet = FALSE;
            goto exit;
        }
    } else {
        pTmpWsaBufs = m_builtinEncryptBuf;
    }


    Assert(m_wsaBufCount > 0);

    //
    // Finally EncryptMessage requires that we have a SecBuffer for every fragment
    // and header or trailer.
    //
    if ( (cWsaBufs) > NUM_TMP_SEC_BUFS ) {
        pTmpBuf = LdapAlloc(sizeof(SecBuffer) * (cWsaBufs));
        if (!pTmpBuf) {
            fRet = FALSE;
            goto exit;
        }
        secBufs = (PSecBuffer)pTmpBuf;
    } else {
        secBufs = tmpBufs;
    }


    //
    // The following loop is the meat of the encryption pump.  The loop consists of
    // filling in the SecBuffer structures, as well as a second set of WSABUF's
    // with a header, m_MaxEncryptSize worth of data to be encrypted, and finally
    // a trailer.  This set of buffers is then encrypted by EncryptMessage.  We then
    // fix up header and trailer sizes and attach the SASL header.
    //
    pHeaderTrailerCurPos =  pHeaderTrailerBuf;
    SecBufPos = 0;
    WsaBufPos = 0;
    while (WsaBufPos < m_wsaBufCount) {
        
        msgSize = 0; // Used to keep track of how big each data section is


        //
        // Fill in this header in both SecBuffer and new WSABUF.  Leave space
        // for the SASL header which is included in m_HeaderSize.
        //
        secBufs[SecBufPos].BufferType = SECBUFFER_TOKEN;
        
        secBufs[SecBufPos].cbBuffer =
            pTmpWsaBufs[SecBufPos].len = m_HeaderSize - sizeof(DWORD);

        secBufs[SecBufPos].pvBuffer = pHeaderTrailerCurPos + sizeof(DWORD);

        pTmpWsaBufs[SecBufPos].buf = (PCHAR)pHeaderTrailerCurPos; 

        // remember where the header for this pass was.
        HeaderPos = SecBufPos;

        IF_DEBUG(SSL) {
            DPRINT2(0, "SignSealMessage: Adding header [%d] len = %d\n", HeaderPos, secBufs[SecBufPos].cbBuffer); 
        }

        pHeaderTrailerCurPos += m_HeaderSize;

        SecBufPos++;

        //
        // Now get as much data as we can fit into m_MaxEncryptSize
        //
        subsize = m_wsaBuf[WsaBufPos].len;

        IF_DEBUG(SSL) {
            DPRINT1(0, "SignSealMessage: Initial subsize = %d\n", subsize);
        }

        while (WsaBufPos < m_wsaBufCount && subsize <= m_MaxEncryptSize) {
            secBufs[SecBufPos].cbBuffer = 
                pTmpWsaBufs[SecBufPos].len = m_wsaBuf[WsaBufPos].len;
            secBufs[SecBufPos].pvBuffer = m_wsaBuf[WsaBufPos].buf;
            pTmpWsaBufs[SecBufPos].buf = (PCHAR)m_wsaBuf[WsaBufPos].buf;
            secBufs[SecBufPos].BufferType = SECBUFFER_DATA;


            msgSize += secBufs[SecBufPos].cbBuffer;
            IF_DEBUG(SSL) {
                DPRINT3(0,"Copying buffer [%d] %p len %d\n", SecBufPos, 
                    secBufs[SecBufPos].pvBuffer, secBufs[SecBufPos].cbBuffer);
            }
            SecBufPos++;
            WsaBufPos++;

            if (WsaBufPos < m_wsaBufCount) {
                subsize += m_wsaBuf[WsaBufPos].len;

                IF_DEBUG(SSL) {
                    DPRINT1(0, "SignSealMessage: subsize = %d\n", subsize)
                }
            }
        }
        if (WsaBufPos < m_wsaBufCount && subsize > m_MaxEncryptSize) {
            DWORD fragSize;
            //
            // There was more data in this buffer than would fit in this pass.
            // Save where we left off so that we can start here on the next pass.
            //
            
            subsize -= m_wsaBuf[WsaBufPos].len;
            fragSize = m_MaxEncryptSize - subsize;

            IF_DEBUG(SSL) {
                DPRINT2(0, "SignSealMessage: Buffer spilled over, using %d, leaving %d\n", 
                        fragSize, m_wsaBuf[WsaBufPos].len - fragSize);
                DPRINT2(0, "    SecBufPos = %d, WsaBufPos = %d\n", SecBufPos, WsaBufPos);
            }

            secBufs[SecBufPos].cbBuffer = pTmpWsaBufs[SecBufPos].len = fragSize;
            secBufs[SecBufPos].pvBuffer = pTmpWsaBufs[SecBufPos].buf = m_wsaBuf[WsaBufPos].buf;
            secBufs[SecBufPos].BufferType = SECBUFFER_DATA;
            msgSize += fragSize;
            m_wsaBuf[WsaBufPos].buf += fragSize;
            m_wsaBuf[WsaBufPos].len -= fragSize;
            SecBufPos++;
        }

        IF_DEBUG(SSL){
            DPRINT1(0,"Adding security trailer of length %d\n", m_TrailerSize);
        }

        //
        // Get the trailer buffer.
        //
        secBufs[SecBufPos].cbBuffer = pTmpWsaBufs[SecBufPos].len = m_TrailerSize;
        secBufs[SecBufPos].BufferType = SECBUFFER_PADDING;
        secBufs[SecBufPos].pvBuffer = pHeaderTrailerCurPos;
        pTmpWsaBufs[SecBufPos].buf = (PCHAR)pHeaderTrailerCurPos;
        // remember where the trailer was
        TrailerPos = SecBufPos;
        pHeaderTrailerCurPos += m_TrailerSize;
        SecBufPos++;

        //
        // Do it.
        //

        message.pBuffers = &secBufs[HeaderPos];
        message.ulVersion = SECBUFFER_VERSION;
        message.cBuffers = TrailerPos - HeaderPos + 1;


        IF_DEBUG(SSL) {
            DPRINT(0, "SignSealMessage: Calling EncryptMessage with the following buffers.\n");
            for (i=0; i<message.cBuffers; i++) {
                DPRINT1(0, "   Buffer %d\n", i);
                DPRINT1(0, "     pvBuffer   = %p\n", message.pBuffers[i].pvBuffer);
                DPRINT1(0, "     cbBuffer   = %d\n", message.pBuffers[i].cbBuffer);
                DPRINT1(0, "     BufferType = %d\n", message.pBuffers[i].BufferType);
            }
        }

        scRet = EncryptMessage(phContext,
            (pSecurityContext->NeedsSealing() ? 0 : KERB_WRAP_NO_ENCRYPT),
            &message,
            0 );
        IF_DEBUG(SSL) {
            DPRINT1(0,"EncryptMessage returned %x\n",scRet);
        }

        if ( FAILED(scRet) ) {

            IF_DEBUG(ERROR) {
                DPRINT1(0,"Sealing failed with %x\n", scRet);
            }

            fRet = FALSE;
            goto exit;
        }

        //
        // Fixup buffer lengths of header and trailer buffers 
        //

        IF_DEBUG(SSL) {
            DPRINT2(0,"Header Length %d Trailer Length %d\n",
                secBufs[HeaderPos].cbBuffer, secBufs[TrailerPos].cbBuffer);
        }

        pTmpWsaBufs[HeaderPos].len = sizeof(DWORD) + secBufs[HeaderPos].cbBuffer;
        pTmpWsaBufs[TrailerPos].len = secBufs[TrailerPos].cbBuffer;

        //
        // OK, fill in the header length. Length does not
        // include the header itself.
        //

        SET_MSG_LENGTH(pTmpWsaBufs[HeaderPos].buf,
            msgSize + secBufs[TrailerPos].cbBuffer + secBufs[HeaderPos].cbBuffer);
    }

    if (m_wsaBuf != m_builtinWsaBuf) {
        LdapFree(m_wsaBuf);
    }
    m_wsaBuf = pTmpWsaBufs;
    m_wsaBufCount = SecBufPos;
    m_wsaBufAlloc = m_wsaBufCount;
    SetBufferPtr(
        (PUCHAR)(m_wsaBuf[m_wsaBufCount - 1].buf + m_wsaBuf[m_wsaBufCount - 1].len)
        );

exit:

    if ( pSecurityContext != NULL ) {
        pSecurityContext->DereferenceSecurity( );
    }
    if (pTmpBuf != NULL) {
        LdapFree(pTmpBuf);
    }
    if ((m_wsaBuf != pTmpWsaBufs) && (pTmpWsaBufs != m_builtinEncryptBuf)) {
        LdapFree(pTmpWsaBufs);
    }

    return fRet;

} // SignSealMessage

DecryptReturnValues
LDAP_REQUEST::GetSealHeaderField(
    IN PUCHAR Buffer,
    IN DWORD BufferLen,
    IN PDWORD MsgSize
    )
/*++

Routine Description:

    Get the DWORD header from the message

Arguments:

    Buffer - points to the message
    BufferLen - length of the message
    MsgSize - the msg size obtained from the DWORD header

Return Value:

    NeedMoreInput - Buffer is too small to be a message
    Processed - success

--*/
{
    if ( BufferLen < sizeof(DWORD) ) {
        IF_DEBUG(SSL) {
            DPRINT(0,"Message length < sign header. Need more data\n");
        }
        return NeedMoreInput;
    }

    //
    // Check the signature. Get the lengths. See if we have enough.
    //
    *MsgSize = (Buffer[0] << 24) | (Buffer[1] << 16) | (Buffer[2] << 8) | Buffer[3];

    IF_DEBUG(SSL) {
        DPRINT2(0,"Buffer Size %d  MsgSize %d.\n", BufferLen, *MsgSize + sizeof(DWORD));
    }

    if ( (*MsgSize + sizeof(DWORD)) > BufferLen ) {
        IF_DEBUG(SSL) {
            DPRINT2(0,"Need %d got %d. Need more data\n", *MsgSize + sizeof(DWORD), BufferLen);
        }
        return NeedMoreInput;
    }

    return Processed;

} // GetSealHeaderFields



DecryptReturnValues
LDAP_REQUEST::DecryptSignedOrSealedMessage(
    OUT PDWORD pMsgSize
    )
/*++

Routine Description:

    Decrypt received data, if necessary.

Arguments:

    None.

Return Value:

    Indication to caller as to what to do next.  *pMsgSize will always be set
    to either 0 to indicate no more data is required, or the total receive buffer
    needed to complete decryption.

--*/
{
    PLDAP_CONN conn = m_LdapConnection;
    LPLDAP_SECURITY_CONTEXT pSecurityContext = NULL;
    DecryptReturnValues ret = Processed;
    PCtxtHandle phContext;

    SECURITY_STATUS scRet;

    SecBufferDesc   MessageIn;
    SecBuffer       InBuffers[2];
    DWORD qop;

    DWORD   msgSize = 0;

    Assert(IsSignSeal());

    //
    // Assume we will decrypt everything and so won't need to return 
    // a pMsgSize
    //
    *pMsgSize = 0;

    if (!m_cchSealedData) {
        //
        // Nothing to do here.  There should be some unsealed data left
        // though.
        //
        Assert(m_cchUnSealedData);
        return Processed;
    }

    m_ReceivedSealedData = FALSE;

    //
    // Get the length. See if we have enough
    //

    ret = GetSealHeaderField(m_pSealedData, 
                             m_cchSealedData,
                             &msgSize);

    if ( ret != Processed ) {
        *pMsgSize = msgSize + sizeof(DWORD);
        return ret;
    }

    //
    // We need to unsign/unseal this packet
    //

    EnterCriticalSection(&conn->m_csLock);

    pSecurityContext = conn->m_pSecurityContext;
    if ( pSecurityContext != NULL ) {

        phContext = pSecurityContext->GetSecurityContext();
        LeaveCriticalSection(&conn->m_csLock);

        Assert( pSecurityContext->NeedsSealing() || pSecurityContext->NeedsSigning() );

    } else {
        LeaveCriticalSection(&conn->m_csLock);
        IF_DEBUG(ERROR) {
            DPRINT1(0,"Request %p have inconsistent sign/seal flags.\n",this);
        }
        Assert(FALSE);
        ret = DecryptFailed;
        goto exit;
    }

    //
    // ok, decryption time
    //
    //  The ReceiveBuffer is used as follows:
    //
    //  1. m_cchUnSealedData bytes of data starting at pReceiveBuffer
    //  2. possibly a gap caused when unsealing the above data
    //  3. m_cchSealedData bytes starting at m_pSealedData.
    //
    //  The size of the gap is:
    //      GetReceiveBufferUsed() - m_cchSealedData - m_cchUnSealedData
    //
    //
    //  Unseal as many SSL messages as possible. When we have no more unsealed data
    //  or we only have a partial SSL message we exit.
    //
    //  Return values depend upon whether we unsealed anything. If we did then return
    //  processed.
    //


    while ((DWORD)(m_pSealedData - m_pReceiveBuffer) < m_cchReceiveBufferUsed) {
        //
        // Get the length. See if we have enough.  The first time through we are
        // guaranteed to have enough, so we know that if we get here and find
        // that we don't have enough sealed data some data was in fact decrypted
        // by this function.  Even if we can't decrypt everything return
        // Processed so that if we happen to have dercrypted an entire request
        // we can work on that before trying to receive anything else.
        //

        ret = GetSealHeaderField(m_pSealedData, 
                                 m_cchSealedData,
                                 &msgSize);

        if ( ret != Processed ) {
            //
            // Adjust the needed buffer to account for any already unsealed data.
            //
            *pMsgSize = msgSize + sizeof(DWORD) + ((DWORD)(m_pSealedData - m_pReceiveBuffer));
            return Processed;
        }

        MessageIn.ulVersion = SECBUFFER_VERSION;
        MessageIn.cBuffers = 2;
        MessageIn.pBuffers = InBuffers;

        IF_DEBUG(SSL) {
            DPRINT1(0,"Unsealing msg buffer %p\n", &MessageIn);
        }

        InBuffers[0].pvBuffer = m_pSealedData + sizeof(DWORD);
        InBuffers[0].cbBuffer = msgSize;
        InBuffers[0].BufferType = SECBUFFER_STREAM;

        InBuffers[1].BufferType = SECBUFFER_DATA;
        InBuffers[1].pvBuffer = NULL;
        InBuffers[1].cbBuffer = 0;

        //
        // Do the decryption or signature verification.
        //

        scRet = DecryptMessage(phContext, 
                               &MessageIn, 
                               0, 
                               &qop);

        IF_DEBUG(SSL) {
            DPRINT1(0,"DecryptMessage returned %x\n",scRet);
        }

        //
        //  Remove any gaps in the unsealed data and remember the unencrypted data
        //

        if (scRet == SEC_E_OK) {

            DWORD   totalSize = msgSize + sizeof(DWORD);
            Assert(InBuffers[1].cbBuffer <= InBuffers[0].cbBuffer);

            //
            // Overwrite the header
            //

            MoveMemory(m_pReceiveBuffer + m_cchUnSealedData,
                       InBuffers[1].pvBuffer,
                       InBuffers[1].cbBuffer);

            m_cchUnSealedData += InBuffers[1].cbBuffer;

            //
            // Move the sealed msgs up
            //

            m_pSealedData += totalSize;
            m_cchSealedData -= totalSize;

            //
            // If there are some unsealed data, move them up
            //

            if ( m_cchSealedData != 0 ) {
                MoveMemory(m_pReceiveBuffer + m_cchUnSealedData,
                           m_pSealedData,
                           m_cchSealedData
                          );
            }

            m_pSealedData = m_pReceiveBuffer + m_cchUnSealedData;
            m_cchReceiveBufferUsed = m_cchUnSealedData + m_cchSealedData;

            IF_DEBUG(SSL) {
                DPRINT4(0,"pSealedData %p sealedDataLeft %d ReceiveBufferUsed %d unsealed %d\n",
                        m_pSealedData, m_cchSealedData, m_cchReceiveBufferUsed, m_cchUnSealedData);
            }

        } else {
            //  When LDAP logs to eventvwr we should optionally
            //  log the error code here.

            IF_DEBUG(ERROR) {
                DPRINT3(0,"Decrypt %x Start %x Length %d.\n", 
                        this, m_pSealedData, m_cchSealedData);
            }
            ret = DecryptFailed;
            goto exit;
        }
    }

    IF_DEBUG(SSL) {
        DPRINT1(0,"Done processing. status %d\n",ret);
    }

exit:

    if ( pSecurityContext != NULL ) {
        pSecurityContext->DereferenceSecurity( );
    }

    return ret;
} // DecryptSignedOrSealedMessage


DecryptReturnValues
LDAP_REQUEST::SendTLSClose(
    CtxtHandle *        phSslSecurityContext
    )
/*++

Routine Description:

    Send a TLS close_notify alert.

Arguments:

    phSslSecurityContext - pointer to the SSL security context.
    
Return Value:

    Indication to caller as to what to do next.

--*/
{
    DWORD           dwType;
    PBYTE           pbMessage = NULL;
    DWORD           cbMessage;

    SecBufferDesc   OutBuffer;
    SecBuffer       OutBuffers[1];
    DWORD           dwSSPIFlags;
    DWORD           dwSSPIOutFlags;
    TimeStamp       tsExpiry;
    DWORD           Status;
    LONG            growSize;
    PUCHAR          pSendBuffer;
    DecryptReturnValues ret = ResponseSent;

    //
    // Notify schannel that we are about to close the connection.
    //

    dwType = SCHANNEL_SHUTDOWN;

    OutBuffers[0].pvBuffer   = &dwType;
    OutBuffers[0].BufferType = SECBUFFER_TOKEN;
    OutBuffers[0].cbBuffer   = sizeof(dwType);

    OutBuffer.cBuffers  = 1;
    OutBuffer.pBuffers  = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    Status = ApplyControlToken(phSslSecurityContext, &OutBuffer);

    if(FAILED(Status)) 
    {
        IF_DEBUG(SSL) {        
            DPRINT1(0, "**** Error 0x%x returned by ApplyControlToken\n", Status);
        }
        ret = DecryptFailed;
        goto cleanup;
    }

    //
    // Build an SSL close notify message.
    //

    dwSSPIFlags =   ASC_REQ_SEQUENCE_DETECT     |
                    ASC_REQ_REPLAY_DETECT       |
                    ASC_REQ_CONFIDENTIALITY     |
                    ASC_REQ_EXTENDED_ERROR      |
                    ASC_REQ_ALLOCATE_MEMORY     |
                    ASC_REQ_STREAM;

    OutBuffers[0].pvBuffer   = NULL;
    OutBuffers[0].BufferType = SECBUFFER_TOKEN;
    OutBuffers[0].cbBuffer   = 0;

    OutBuffer.cBuffers  = 1;
    OutBuffer.pBuffers  = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    INC(pcLdapThreadsInAuth);
    Status = AcceptSecurityContext(
                    &hSslCredential,
                    phSslSecurityContext,
                    NULL,
                    dwSSPIFlags,
                    SECURITY_NATIVE_DREP,
                    NULL,
                    &OutBuffer,
                    &dwSSPIOutFlags,
                    &tsExpiry);
    DEC(pcLdapThreadsInAuth);

    if(FAILED(Status)) 
    {
        IF_DEBUG(SSL) {        
            DPRINT1(0, "**** Error 0x%x returned by AcceptSecurityContext\n", Status);
        }
        ret = DecryptFailed;
        goto cleanup;
    }

    pbMessage = (PBYTE) OutBuffers[0].pvBuffer;
    cbMessage = OutBuffers[0].cbBuffer;

    //
    // Copy the message into the request output buffer.
    //
    growSize = cbMessage - (ULONG)GetSendBufferSize();

    if ( growSize > 0 ) {

        BOOL bResult = GrowSend(growSize);

        if ( bResult == FALSE ) {
            IF_DEBUG(SSL) {
                DPRINT(0,"Failed to grow output buffer to send close_notify.\n");
            }
            ret =  DecryptFailed;
            goto cleanup;
        }

    }

    pSendBuffer = GetSendBuffer();
    if (NULL == pSendBuffer) {
        ret = DecryptFailed;
        goto cleanup;
    }
    CopyMemory(pSendBuffer, pbMessage, cbMessage);
    SetBufferPtr(pSendBuffer + cbMessage);

    //
    // Send it.
    //
    m_fTLS = FALSE;
    if (!Send(FALSE, phSslSecurityContext)) {
        ret = DecryptFailed;
        goto cleanup;
    }

cleanup:

    if (pbMessage) {    
        FreeContextBuffer(pbMessage);
    }

    m_LdapConnection->ZapSSLSecurityContext();

    return ret;
}


VOID
LDAP_REQUEST::GetNetBufOpts( VOID )
/*++

Routine Description:

    This routine grabs the network buffer options from the associated 
    connection object.

Arguments:

    None.
    
Return Value:

    None.
    
--*/
{
    m_fCanScatterGather = m_LdapConnection->CanScatterGather();
    m_fNeedsHeader      = m_LdapConnection->NeedsHeader();
    m_fNeedsTrailer     = m_LdapConnection->NeedsTrailer();
    m_HeaderSize        = m_LdapConnection->GetHeaderSize();
    m_TrailerSize       = m_LdapConnection->GetTrailerSize();
    m_MaxEncryptSize    = m_LdapConnection->GetMaxEncryptSize();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\mkdit\mkdit.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1989 - 1999
//
//  File:       MKDIT.CXX
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Parses Schema Initialization File

Author:

    Rajivendra Nath (RajNath) 07-Jul-1996

Revision History:

--*/

#include <ntdspchX.h>
#include "SchGen.HXX"
#include "schema.hxx"


#define DEBSUB "mkdit:"
#define FILENO 1
extern "C" {
#include <prefix.h>
#include "..\src\schash.c"
    extern void DsInitializeCritSecs(void);
    extern BOOL DsInitHeapCacheManagement();
    extern void PerfInit(void);

    extern int ComputeCacheClassTransitiveClosure(BOOL fForce);
    extern BOOL gfRunningAsExe;
    extern BOOL gfRunningAsMkdit;

}

#define XFREE(_x_) { if(_x_) { XFree(_x_); _x_ = NULL; } }

extern WCHAR gDsaNode[MAX_PATH];
extern WCHAR ggSchemaname[MAX_PATH];

VOID
InitSchemaFromIniFile(THSTATE *pTHS );

VOID
CoreAndDblayerInit(THSTATE *pTHS);

NTSTATUS
AddObjectsToDit(char* NODE);

VOID
IniAddToAttributeCache(THSTATE *pTHS, ATTRIBUTESCHEMA* AS);

VOID
IniAddToClassCache(THSTATE *pTHS, CLASSSCHEMA* CS);

VOID
WriteDMDOnDSA (
        PDSNAME pDsaName,
        WCHAR*  pDmdName
        );





//-----------------------------------------------------------------------
//
// Routine Description:
//
//    Phase0Init
//
//    Main Entry for Boot Dit Create
//
// Author: RajNath
//
// Arguments:
//
// Return Value:
//
//    VOID        No Return
//
//-----------------------------------------------------------------------
VOID
Phase0Init()
{
    JET_ERR err;
    NTSTATUS   NtStatus = STATUS_SUCCESS;


    DPRINT(0, "NTDS:Phase0Init -- Creating a Fresh DS\n");

    DsaSetIsInstalling();
    gfRunningAsExe = TRUE;
    gfRunningAsMkdit = TRUE;

    DsInitializeCritSecs();
    if (!DsInitHeapCacheManagement()) {
        XOUTOFMEMORY();
    }
    PerfInit();

    //
    // Create a Thread State ( A global workspace for this thread)
    //
    THSTATE *pTHS;
    dwTSindex = TlsAlloc();
    pTHS = create_thread_state();



    if (!pTHS)
    {
        XOUTOFMEMORY();
    }

    HEAPVALIDATE
    DPRINT(0, "NTDS:Phase0Init -- Initializing Dblayer\n");
    if (err = DBInit())
    {
        DPRINT1(0, "DBINIT() Failed. Error %d\n",err);
        XRAISEGENEXCEPTION(err);
    }

    if (err = DBInitThread(pTHS))
    {
        DPRINT1(0, "DBInitThread() Failed. Error %d\n",err);
        XRAISEGENEXCEPTION(err);
    }

    DPRINT(0, "NTDS:Phase0Init -- Initializing Phase0 SchemaCache\n");
    err = SCCacheSchemaInit(4*START_ATTCOUNT,
                            4*START_CLSCOUNT,
                            4*START_PREFIXCOUNT);
    if (err)
    {
        // Don't free pTHS->CurrSchemaPtr or CurrSchemaPtr
        // Leave them around for debugging
        DPRINT1(0, "SCCacheSchemaInit() Failed. Error %d\n",err);
        XRAISEGENEXCEPTION(err);
    }

    InitSchemaFromIniFile(pTHS);

    HEAPVALIDATE

    ComputeCacheClassTransitiveClosure(FALSE);

    HEAPVALIDATE
    //
    // Setup some variables so that core is initialized.
    // The Core is bobby trapped - so just have to step
    // around it......
    //
    CoreAndDblayerInit(pTHS);
    HEAPVALIDATE
    (void) InitTHSTATE(CALLERTYPE_INTERNAL);
    HEAPVALIDATE

    NtStatus = AddObjectsToDit(ROOT);
    if (!NT_SUCCESS(NtStatus)) {
       XRAISEGENEXCEPTION(NtStatus);
    }

    DBOpen2(TRUE, &(pTHS->pDB));
    // Now, reload the schema cache from the copy in the DIT.  This has the side
    // effect of finding out what indices need to be created and creating them.

    err = SCCacheSchemaInit(0,0,0);
    if (err) {
      // Don't free pTHS->CurrSchemaPtr or CurrSchemaPtr
      // Leave them around for debugging
      DPRINT1(0,"Schema cache reload: SCCacheSchemaInit Failed: %d\n", err);
      XRAISEGENEXCEPTION(err);
    }
    err = SCCacheSchema2();
    if (err) {
      DPRINT1(0,"Schema cache reload: SCCacheSchema2 Failed: %d\n", err);
      XRAISEGENEXCEPTION(err);
    }
    // Set the phase to simulate running case so that all indices are created
    DsaSetIsRunning();
    err = SCCacheSchema3();
    if (err) {
      DPRINT1(0,"Schema cache reload: SCCacheSchema3 Failed: %d\n", err);
      XRAISEGENEXCEPTION(err);
    }
    DsaSetIsInstalling();

    {
#define MAGIC_DNT_BOOT         4
#define MAGIC_DNT_BOOT_SCHEMA  5
#define MAGIC_DNT_BOOT_MACHINE 7
        ATTRTYP objClass;
        DWORD err2, len;

        // Verify the boot schema container is at the correct place.  ntdsa.dll
        // depends on this..
        DBFindDNT(pTHS->pDB, MAGIC_DNT_BOOT_SCHEMA);
        err2 = DBGetSingleValue(pTHS->pDB,
                                ATT_OBJECT_CLASS,
                                &objClass,
                                sizeof(objClass),
                                &len);

        if(err2 || (pTHS->pDB->PDNT != MAGIC_DNT_BOOT)
           || (len != sizeof(DWORD)) || (objClass != CLASS_DMD)) {
            DPRINT2(0, "NTDS:Phase0Init -- Schema container not at DNT %d.\n"
                    "\t\tntdsa.dll requires that it be at DNT %d.  Failing.\n",
                    MAGIC_DNT_BOOT_SCHEMA,
                    MAGIC_DNT_BOOT_SCHEMA);
            XRAISEGENEXCEPTION(1);
        }

        // Verify the boot machine object is at the correct place.  ntdsa.dll
        // depends on this..
        DBFindDNT(pTHS->pDB, MAGIC_DNT_BOOT_MACHINE);
        err2 = DBGetSingleValue(pTHS->pDB,
                                ATT_OBJECT_CLASS,
                                &objClass,
                                sizeof(objClass),
                                &len);

        if(err2 || (pTHS->pDB->PDNT != MAGIC_DNT_BOOT)
           || (len != sizeof(DWORD)) || (objClass != CLASS_NTDS_DSA)) {
            DPRINT2(0, "NTDS:Phase0Init -- Boot machine not at DNT %d.\n"
                   "\t\tntdsa.dll requires that it be at DNT %d.  Failing.\n",
                    MAGIC_DNT_BOOT_MACHINE,
                    MAGIC_DNT_BOOT_MACHINE);
            XRAISEGENEXCEPTION(1);
        }

        // Verify the boot container is at the correct place.  ntdsa.dll
        // depends on this..
        DBFindDNT(pTHS->pDB, MAGIC_DNT_BOOT);
        err2 = DBGetSingleValue(pTHS->pDB,
                                ATT_OBJECT_CLASS,
                                &objClass,
                                sizeof(objClass),
                                &len);

        if(err2 || (pTHS->pDB->PDNT != ROOTTAG)
           || (len != sizeof(DWORD)) || (objClass != CLASS_ORGANIZATION)) {
            DPRINT2(0, "NTDS:Phase0Init -- Boot container not at DNT %d.\n"
                    "\t\tntdsa.dll requires that it be at DNT %d.  Failing.\n",
                    MAGIC_DNT_BOOT,
                    MAGIC_DNT_BOOT);
            XRAISEGENEXCEPTION(1);
        }
    }

    err = DBClose(pTHS->pDB, TRUE);
    if (err)
    {
        DPRINT1(0, "DBClose() Failed. Error %d\n",err);
        XRAISEGENEXCEPTION(err);
    }



    err=DBCloseThread(pTHS);
    if (err)
    {
        DPRINT1(0, "DBCloseThread() Failed. Error %d\n",err);
        XRAISEGENEXCEPTION(err);
    }

    DBEnd();


    CopyFile(szJetFilePath,"NEWNTDS.DIT",0);

    if (NT_SUCCESS(NtStatus)) {
        DPRINT(0, "Phase 0 Init Success\n");
    }
    else {
        DPRINT(0, "ERROR: Failure in Phase 0 Init adding objects to Dit\n");
    }

}

//-----------------------------------------------------------------------
//
// Function Name:   InitSchemaFromIniFile
//
// Routine Description:
//
//    Loads the Schema Cache from the Ini File
//
// Author: RajNath
//
// Arguments:
//
// Return Value:
//
//    VOID        No Return -- Raises Exception On Failure
//
//-----------------------------------------------------------------------

VOID
InitSchemaFromIniFile(THSTATE *pTHS )
{
    //
    // Open the gSchemaname
    //



    DPRINT(0, "NTDS:Phase0Init -- Initializing Rest of Schema Cache\n");
    NODE* dmd=new NODE(gSchemaname);

    if (!(dmd->Initialize()))
    {
        XINVALIDINIFILE();
    }

    YAHANDLE yh;
    for
    (
        NODE* Child=dmd->GetNextChild(yh);
        Child!=NULL;
        Child=dmd->GetNextChild(yh)
    )
    {
        if (_stricmp(Child->GetOneKey(DASHEDCLASSKEY),ATTRIBUTESCHEMAKEY)==0 )
        {
            ATTRIBUTESCHEMA* as=gSchemaObj.XGetAttributeSchema(Child);

            IniAddToAttributeCache(pTHS, as);
        }
        else if (_stricmp(Child->GetOneKey(DASHEDCLASSKEY),CLASSSCHEMAKEY)==0 )
        {
            CLASSSCHEMA* cs=gSchemaObj.XGetClassSchema(Child);

            IniAddToClassCache(pTHS, cs);
        }
        else if (_stricmp(Child->GetOneKey(DASHEDCLASSKEY),SUBSCHEMAKEY)==0 )
        {
            // the aggregate object. Do nothing
            continue;
        }
        else
        {
            XINVALIDINIFILE();
        }
    }

    // Now, tell the cache to recalc it's name index.
    DPRINT(0, "NTDS:Phase0Init -- Initialized Rest of Schema Cache\n");

    delete dmd;
}


//-----------------------------------------------------------------------
//
// Function Name:   CoreAndDblayerInit
//
// Routine Description:
//
//    Initializes the Core & Dblayer without a DIT
//
// Author: RajNath
//
// Arguments:
//
//    THSTATE pTHS       Thread State to use.
// Return Value:
//
//    VOID        No Return
//
//-----------------------------------------------------------------------
VOID
CoreAndDblayerInit(THSTATE *pTHS)
{
    DSNAME  dsname;
    NAMING_CONTEXT_LIST *pNCL;
    DWORD err;

    ZeroMemory(&dsname,sizeof(dsname));

    dsname.NameLen=0;
    dsname.structLen=sizeof(dsname);

    gUpdatesEnabled=TRUE;
    gfRunningInsideLsa = FALSE;
    fAssertLoop = FALSE;

    pTHS->fDSA=TRUE;

    ////ganchor
    SYNTAX_ADDRESS NodeAddr;
    NodeAddr.structLen=sizeof(NodeAddr);

    gAnchor.pDSA = (SYNTAX_DISTNAME_STRING*)
        XCalloc(1,
                (USHORT)DERIVE_NAME_DATA_SIZE(&dsname,
                                              &NodeAddr));

    BUILD_NAME_DATA(gAnchor.pDSA, &dsname, &NodeAddr);

    // We use the DN portion alone often, so make it a separate field
    gAnchor.pDSADN = (DSNAME*)XCalloc(1,dsname.structLen);
    memcpy(gAnchor.pDSADN, &dsname, dsname.structLen);
    //

    err = MakeNCEntry(&dsname, &pNCL);
    if (err == 0) {
        // insert into the master NC list
        // we could do "CatalogAddEntry(pNCL, CATALOG_MASTER_NC);",
        // but why bother with transactional data? just drop it into global list!
        pNCL->pNextNC = (NAMING_CONTEXT_LIST*)gAnchor.pMasterNC;
        gAnchor.pMasterNC = pNCL;
    }
    else {
        DPRINT2(0, "Failed to create NC entry for %ws, err=%d\n", dsname.StringName, err);
        Assert(!"Failed to create NC entry");
    }
}

//-----------------------------------------------------------------------
//
// Function Name:   AddObjectsToDit
//
// Routine Description:
//
//    Adds Object To Dit using the Schem.ini
//
// Author: RajNath
//
// Arguments:
//
//    char* StartNode,       The Name of the root Node
//
// Return Value:
//
//    VOID        No Return - Exception On Failure
//
//-----------------------------------------------------------------------

NTSTATUS
AddObjectsToDit(char* StartNode)
{
    NODE   troot(StartNode);
    WCHAR* cpath= L"";
    ULONG err;
    NTSTATUS NtStatus;


    NtStatus = WalkTree(&troot, cpath, NULL, FALSE);
    if (NT_SUCCESS(NtStatus))
    {
        //
        // Now we need to set the DSA in the Hidden Records
        //
        ULONG    err=0;
        PDSNAME  pdsa=NULL;

        // MAX_DSNAME_SIZE is no more. Use calculated size and malloc'ed memory.
        pdsa = (PDSNAME)XCalloc(1, (DWORD)DSNameSizeFromLen(wcslen(gDsaNode)));
        if (!pdsa) {
            XOUTOFMEMORY();
        }

        BuildDefDSName(pdsa,gDsaNode,NULL);

        // Going straight to DBLayer
        if ((err=DBReplaceHiddenDSA(pdsa))!=0)
        {
            XFREE(pdsa);
            DPRINT1(0, "DBReplaceHiddenDSA(pdsa) Failed. Error %d\n",err);
            return STATUS_UNSUCCESSFUL;
        }

        // Note DMD Name on the DSA

        WriteDMDOnDSA(pdsa,ggSchemaname);
        XFREE(pdsa);

        if (err = DBSetHiddenState(eBootDit))
        {
            DPRINT1(0, "DBSetHiddenState(eBootDit) Failed. Error %d\n",err);
            return STATUS_UNSUCCESSFUL;
        }
    }

    return NtStatus;
}





//-----------------------------------------------------------------------
//
// Function Name:   IniAddToClassCache
//
// Routine Description:
//
//    Adds a Class to the Schema Cache
//    Performs all allocations with the same allocator as the schema cache.
//
// Author: RajNath
//
// Arguments:
//
//    CLASSSCHEMA* CS       The Class Object to Add
//
// Return Value:
//
//    VOID        No Return - Exception on Failure
//
//-----------------------------------------------------------------------

VOID
IniAddToClassCache(THSTATE *pTHS, CLASSSCHEMA* CS)
{

    ULONG BigArray[1024];
    ULONG *tarray;
    ULONG i;

    CLASSCACHE *pcc;
    pcc = (CLASSCACHE*)calloc(1,sizeof(CLASSCACHE));
    if ( NULL == pcc )
        XOUTOFMEMORY();

    pcc->name               =  (UCHAR*)_strdup(CS->NodeName());
    if ( NULL == pcc->name )
        XOUTOFMEMORY();
    pcc->nameLen = strlen((const char *)pcc->name);

    pcc->ClassId            =  CS->ClassId();

    pcc->ClassCategory      =  atoi(CS->XGetOneKey(CLASSCATKEY));
    pcc->bSystemOnly        =  FALSE;

    // Null out the default security descriptor stuff.
    pcc->pSD = NULL;
    pcc->SDLen = 0;

    ATTRTYP AttId = 0;
    BOOL    ap=FALSE;
    {
        char* rc=CS->GetOneKey(RDNATTID);
        if (rc)
        {
            ATTRIBUTESCHEMA* as=gSchemaObj.GetAttributeSchema(rc);
            // PREFIX: claims 'as' may be NULL
            if (NULL == as) {
                DPRINT1(0, "GetAttributeSchema(%s) Failed.\n", rc);
                XINVALIDINIFILE();
            }
            AttId = as->AttrType();
            ap=TRUE;
        }

    }

    pcc->RDNAttIdPresent     =  ap;
    // The base schema must be composed of base schema objects.
    // Hence, msDS-IntId's are not assigned during mkdit and
    // the tokenized OID (AttId) is correct for both the internal
    // and external rdnattid for this class.
    pcc->RdnIntId        = AttId ;
    pcc->RdnExtId        = AttId ;


    {
        char* sc;
        YAHANDLE yh;
        CLASSSCHEMA *parent;
        i=0;

        parent= CS->GetNextParent(yh);
        if (parent == NULL)
        {
            DPRINT1(0, "NTDS:IniAddToClassCache(%s) Failed.\nSub-Class-Of Not found\n",
                    CS->NodeName());
            XINVALIDINIFILE();
        }
        BigArray[i++]=parent->ClassId();

        tarray= (ULONG*)calloc(i,sizeof(BigArray[0]));
        if ( NULL == tarray )
            XOUTOFMEMORY();

        CopyMemory(tarray,BigArray,i*sizeof(BigArray[0]));
    }

    pcc->SubClassCount      =  i;
    pcc->pSubClassOf        =  tarray;

    pcc->AuxClassCount      =  0;    // Auxilary classes not supported
    pcc->pAuxClass          =  NULL;

    {
        char* sc;
        YAHANDLE yh;

        for (i=0;sc = CS->GetNextKey(yh,SYSTEMPOSSSUPERIORKEY);i++)
        {
            CLASSSCHEMA* sup=gSchemaObj.XGetClassSchema(sc);
            BigArray[i]=sup->ClassId();
        }

        tarray= (ULONG*)calloc(i,sizeof(BigArray[0]));
        if ( NULL == tarray )
            XOUTOFMEMORY();

        CopyMemory(tarray,BigArray,i*sizeof(BigArray[0]));
    }
    pcc->PossSupCount       =  i;
    pcc->pPossSup           =  tarray;

    {
        char* sc;
        YAHANDLE yh;

        for (i=0;sc = CS->GetNextKey(yh,SYSTEMMUSTCONTAIN);i++)
        {
            ATTRIBUTESCHEMA* sup=gSchemaObj.XGetAttributeSchema(sc);
            BigArray[i]=sup->AttrType();
        }

        tarray= (ULONG*)calloc(i,sizeof(BigArray[0]));
        if ( NULL == tarray )
            XOUTOFMEMORY();

        CopyMemory(tarray,BigArray,i*sizeof(BigArray[0]));
    }
    pcc->MustCount          =  i;
    pcc->pMustAtts          =  tarray;

    {
        char* sc;
        YAHANDLE yh;

        for (i=0;sc = CS->GetNextKey(yh,SYSTEMMAYCONTAIN);i++)
        {
            ATTRIBUTESCHEMA* sup=gSchemaObj.XGetAttributeSchema(sc);
            BigArray[i]=sup->AttrType();
        }

        tarray= (ULONG*)calloc(i,sizeof(BigArray[0]));
        if ( NULL == tarray )
            XOUTOFMEMORY();

        CopyMemory(tarray,BigArray,i*sizeof(BigArray[0]));
    }
    pcc->MayCount           =  i;
    pcc->pMayAtts           =  tarray;


    {
        char* sc;
        YAHANDLE yh;

        for (i=0;sc = CS->GetNextKey(yh,SYSTEMAUXILIARYCLASS);i++)
        {
            CLASSSCHEMA* sup=gSchemaObj.XGetClassSchema(sc);
            BigArray[i]= sup->ClassId();
        }

        tarray= (ULONG*)calloc(i,sizeof(BigArray[0]));
        if ( NULL == tarray )
            XOUTOFMEMORY();

        CopyMemory(tarray,BigArray,i*sizeof(BigArray[0]));
    }
    pcc->AuxClassCount           =  i;
    pcc->pAuxClass               =  tarray;

    pcc->bClosed            =  FALSE;
    pcc->bClosureInProgress =  FALSE;
    pcc->bUsesMultInherit   =  (pcc->SubClassCount>1); // multiple inheritence
                                                       // not supported

    ((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->nClsInDB++;
    SCAddClassSchema(pTHS, pcc);
}





//-----------------------------------------------------------------------
//
// Function Name:   IniAddToAttributeCache
//
// Routine Description:
//
//    Adds an Attribute to the Schema Cache
//    Performs all allocations with the same allocator as the schema cache.
//
// Author: RajNath
//
// Arguments:
//
//    ATTRIBUTESCHEMA* AS,       The Attribute to Add to Schema
//
// Return Value:
//
//    VOID        No Return - exception On Failure
//
//-----------------------------------------------------------------------

VOID
IniAddToAttributeCache(THSTATE *pTHS, ATTRIBUTESCHEMA* AS)
{
    ATTCACHE  *pac;
    ATTRTYP   atp=AS->AttrType();
    DWORD     flags;
    SCHEMAPTR *tSchemaPtr = (SCHEMAPTR *) pTHS->CurrSchemaPtr;
    HASHCACHE *ahcId = tSchemaPtr->ahcId;
    ULONG     i, ATTCOUNT = tSchemaPtr->ATTCOUNT;
    BOOL      fLinkedAtt = FALSE;

    pac = SCGetAttById(pTHS, atp);

    if (NULL == pac) {
       // possibly a link att or a constructed att. If so,
       // create an attcache and add it to the cache (similar
       // to what we do in SCCacheSchema2 for these)

       fLinkedAtt = AS->IsLinkAtt();
       flags = AS->SystemFlags();
       if (fLinkedAtt || (flags & FLAG_ATTR_IS_CONSTRUCTED) ) {
          pac = (ATTCACHE *) malloc(sizeof(ATTCACHE));
          if (!pac) {
             XOUTOFMEMORY();
          }
          memset(pac, 0, sizeof(ATTCACHE));
          pac->id = atp;
          // add to id cache
          for (i=SChash(atp,ATTCOUNT);
              ahcId[i].pVal && (ahcId[i].pVal != FREE_ENTRY) ; i=(i+1)%ATTCOUNT){
          }
          ahcId[i].hKey = atp;
          ahcId[i].pVal = pac;
          Assert(SCGetAttById(pTHS, atp));
       }
       else {
          // Not linked/constructed, but not in cache -- Cannot happen

          XINVALIDINIFILE();
       }
    }


    pac->name    = (UCHAR*)_strdup(AS->NodeName());
    if ( NULL == pac->name )
        XOUTOFMEMORY();
    pac->nameLen = strlen((const char *)pac->name);

    pac->syntax  = AS->SyntaxNdx();
    pac->isSingleValued = AS->IsSingle();

    pac->rangeLowerPresent = FALSE;
    // No Checking reqd..
    pac->bSystemOnly=FALSE;
    pac->bExtendedChars=TRUE;

    // We do need to know if this is a replicated attribute, since we are
    // potentially using the metadata created.

    flags = AS->SystemFlags();
    if (flags & FLAG_ATTR_NOT_REPLICATED) {
        pac->bIsNotReplicated = TRUE;
    }
    if (flags & FLAG_ATTR_REQ_PARTIAL_SET_MEMBER) {
        pac->bMemberOfPartialSet = TRUE;
    }
    if (flags & FLAG_ATTR_IS_CONSTRUCTED) {
        pac->bIsConstructed = TRUE;
    }

    char* kv;
    if (kv = AS->GetOneKey(RANGELOWERKEY))
    {
        pac->rangeLowerPresent = TRUE;
        pac->rangeLower = atoi(kv);
    }

    if (kv = AS->GetOneKey(RANGEUPPERKEY))
    {
        pac->rangeUpperPresent = TRUE;
        pac->rangeUpper = atoi(kv);
    }

    char* tc;
    ULONG tl;
    {
        tl=0;
        tc = AS->MapiID();
        // It is an ssumption that MAPI IDs will never be negative
        if (tc) tl=strtoul(tc, (char **)NULL, 0);
    }
    pac->ulMapiID = tl;

    {
        tl=0;
        tc = AS->GetOneKey(LINKIDKEY);
        if (tc) tl=atoi(tc);
    }
    pac->ulLinkID = tl;

    //pac->accessCat= atoi(AS->XGetOneKey(ACCESSCATEGORYKEY));
    pac->OMsyntax = AS->OMSyntax();
    pac->fSearchFlags = atoi(AS->XGetOneKey(SEARCHFLAGKEY));

    BOOL fNoJetCol=FALSE;
    ((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->nAttInDB++;

    // The base schema must be composed of base schema objects.
    // Hence, msDS-IntId's are not assigned during mkdit and
    // the tokenized OID and internal Id are the same for these
    // attributes.
    pac->Extid = pac->id;
    SCAddAttSchema(pTHS, pac, fNoJetCol, FALSE);
}



//-----------------------------------------------------------------------
//
// Function Name:            WriteDMDOnDSA
//
// Routine Description:
//
//    Writes the Schema Container Location on the Machine Obj
//
// Author: RajNath
//
// Arguments:
//
//    pDSAName DSA Location,
//    pDmdName DMD Location
//
//
// Return Value:
//
//    VOID             No Return, Exception on failure
//
//-----------------------------------------------------------------------

VOID
WriteDMDOnDSA
(
    PDSNAME pDsaName,
    WCHAR*   pDmdName
)
{

    ULONG         err;
    MODIFYARG     ModArg;
    MODIFYRES   * pModRes;

    ATTR*         attr=&ModArg.FirstMod.AttrInf;
    ATTRVAL       AttrVal;
    COMMARG*      pcarg = &ModArg.CommArg;

    PDSNAME       pSchemaDsName = NULL;
    ULONG         Length = 0, Size = 0;

    ZeroMemory(&ModArg,sizeof(ModArg));
    ZeroMemory(&AttrVal,sizeof(AttrVal));

    ModArg.pObject = pDsaName;
    InitCommarg(pcarg);

    //
    // Prepare the schema location as a dsname
    //
    Length = wcslen( pDmdName );
    Size = DSNameSizeFromLen( Length );
    pSchemaDsName = (DSNAME*) alloca( Size );
    RtlZeroMemory( pSchemaDsName, Size );
    pSchemaDsName->structLen = Size;
    pSchemaDsName->NameLen = Length;
    wcscpy( pSchemaDsName->StringName, pDmdName );


    // Set the name on the anchor.  We need this later when we rebuild the
    // schema cache
    gAnchor.pDMD = (PDSNAME)malloc(pSchemaDsName->structLen);
    if (!gAnchor.pDMD) {
       XRAISEGENEXCEPTION(1);
    }
    memcpy(gAnchor.pDMD, pSchemaDsName, pSchemaDsName->structLen);
    //  Fill in the ldapdmd with a bogus value.  This is a quick hack that lets
    // us rebuild the cache later, where we have some code that expects a value
    // here, but that works fine in mkdit if it is a random dsname.
    gAnchor.pLDAPDMD = gAnchor.pDMD;

    //
    //  Get information about the type of attribute this is
    //
    ATTRIBUTESCHEMA* as=gSchemaObj.XGetAttributeSchema("DMD-Location");

    attr->attrTyp = as->AttrType();
    attr->AttrVal.valCount = 1;
    attr->AttrVal.pAVal = &AttrVal;

    AttrVal.valLen = pSchemaDsName->structLen;
    AttrVal.pVal = (BYTE*) pSchemaDsName;

    ModArg.count=1;
    ModArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;

    if ((err=DirModifyEntry(&ModArg, &pModRes))!=0)
    {
        DUMP_ERROR_INFO();
        XRAISEGENEXCEPTION(err);
    }

}

VOID
Usage(
    char *filename
    )
{
    printf("USAGE: %s <-d> Schema-Definition-File\n", filename);
    printf("      This will create the New Bootable DIB\n");
    exit(1);
}

int __cdecl main (int argc, char *argv[])
{
    char fp[MAX_PATH];
    char *path;
    int  i;

    // Initialize debug library.
    DEBUGINIT(argc, argv, "mkdit");

    path = NULL;
    for (i = 1; i < argc; ++i) {
        if (!strcmp(argv[i], "-d")) {
            continue;
        }
        if (path) {
            Usage(argv[0]);
        }
        path = argv[i];
    }
    if (!path) {
        Usage(argv[0]);
    }

    if (_fullpath(fp, path, sizeof(fp))==NULL)
    {
        printf("%s NOT FOUND\n",argv[argc-1]);
        return 1;
    }
    printf("Creating new ntds.dit from %s\n", fp);

    if (!SetIniGlobalInfo(fp))
    {
        printf("%s:Invalid Inifile\n",fp);
        return 1;
    }

    if (!InitSyntaxTable()) {
        printf("Failed to init the syntax table\n");
        return 1;
    }

    CreateStoreStructure();
    Phase0Init();

    DEBUGTERM( );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\ldap\sortlocales.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    sortlocales.c

Abstract:

    This module implements the OID to LCID mapping.

Author:

    Marios Zikos  [MariosZ] 21-March-2000

Revision History:

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <ntdsa.h>
#include <dsjet.h>
#include <scache.h>             // schema cache
#include <dbglobal.h>           // The header for the directory database
#include <dbopen.h>             // The header for opening database
#include <mdglobal.h>           // MD global definition header
#include <mdlocal.h>            // MD local definition header


#include "debug.h"              // standard debugging header
#define DEBSUB "SORTLOCALE:"       // define the subsystem for debugging


typedef struct _LANG_LCID_OID
{
    DWORD lcid;
    WCHAR *pwszOID;
} LANG_LCID_OID;

typedef struct _LANG_LCID_PREFIX
{
    DWORD prefix;
    DWORD lcid;
} LANG_LCID_PREFIX;


LANG_LCID_OID LangLcidOid[] = {
     { 0x0436, L"1.2.840.113556.1.4.1461"  },    // Afrikaans
     { 0x041c, L"1.2.840.113556.1.4.1462"  },    // Albanian
     { 0x0401, L"1.2.840.113556.1.4.1463"  },    // Arabic      Saudi Arabia
     { 0x0801, L"1.2.840.113556.1.4.1464"  },    // Arabic      Iraq
     { 0x0C01, L"1.2.840.113556.1.4.1465"  },    // Arabic      Egypt
     { 0x1001, L"1.2.840.113556.1.4.1466"  },    // Arabic      Libya
     { 0x1401, L"1.2.840.113556.1.4.1467"  },    // Arabic      Algeria
     { 0x1801, L"1.2.840.113556.1.4.1468"  },    // Arabic      Morocco
     { 0x1C01, L"1.2.840.113556.1.4.1469"  },    // Arabic      Tunisia
     { 0x2001, L"1.2.840.113556.1.4.1470"  },    // Arabic      Oman
     { 0x2401, L"1.2.840.113556.1.4.1471"  },    // Arabic      Yemen
     { 0x2801, L"1.2.840.113556.1.4.1472"  },    // Arabic      Syria
     { 0x2C01, L"1.2.840.113556.1.4.1473"  },    // Arabic      Jordan
     { 0x3001, L"1.2.840.113556.1.4.1474"  },    // Arabic      Lebanon
     { 0x3401, L"1.2.840.113556.1.4.1475"  },    // Arabic      Kuwait
     { 0x3801, L"1.2.840.113556.1.4.1476"  },    // Arabic      U.A.E.
     { 0x3C01, L"1.2.840.113556.1.4.1477"  },    // Arabic      Bahrain
     { 0x4001, L"1.2.840.113556.1.4.1478"  },    // Arabic      Qatar
     { 0x042b, L"1.2.840.113556.1.4.1479"  },    // Armenian
     { 0x044d, L"1.2.840.113556.1.4.1480"  },    // Assamese 
     { 0x042c, L"1.2.840.113556.1.4.1481"  },    // Azeri       Latin
     { 0x082c, L"1.2.840.113556.1.4.1482"  },    // Azeri       Cyrillic
     { 0x042D, L"1.2.840.113556.1.4.1483"  },    // Basque
     { 0x0423, L"1.2.840.113556.1.4.1484"  },    // Belarussian
     { 0x0445, L"1.2.840.113556.1.4.1485"  },    // Bengali
     { 0x0402, L"1.2.840.113556.1.4.1486"  },    // Bulgarian
     { 0x0455, L"1.2.840.113556.1.4.1487"  },    // Burmese
     { 0x0403, L"1.2.840.113556.1.4.1488"  },    // Catalan
     { 0x0404, L"1.2.840.113556.1.4.1489"  },    // Chinese      Taiwan
     { 0x0804, L"1.2.840.113556.1.4.1490"  },    // Chinese      PRC
     { 0x0C04, L"1.2.840.113556.1.4.1491"  },    // Chinese      (Hong Kong SAR)
     { 0x1004, L"1.2.840.113556.1.4.1492"  },    // Chinese      Singapore
     { 0x1404, L"1.2.840.113556.1.4.1493"  },    // Chinese      (Macau SAR)
     { 0x041a, L"1.2.840.113556.1.4.1494"  },    // Croatian
     { 0x0405, L"1.2.840.113556.1.4.1495"  },    // Czech
     { 0x0406, L"1.2.840.113556.1.4.1496"  },    // Danish
     { 0x0413, L"1.2.840.113556.1.4.1497"  },    // Dutch 
     { 0x0813, L"1.2.840.113556.1.4.1498"  },    // Dutch        Belgium
     { 0x0409, L"1.2.840.113556.1.4.1499"  },    // English      United States
     { 0x0809, L"1.2.840.113556.1.4.1500"  },    // English      United Kingdom
     { 0x0c09, L"1.2.840.113556.1.4.1665"  },    // English      Australia
     { 0x1009, L"1.2.840.113556.1.4.1666"  },    // English      Canada
     { 0x1409, L"1.2.840.113556.1.4.1667"  },    // English      New Zealand
     { 0x1809, L"1.2.840.113556.1.4.1668"  },    // English      Ireland
     { 0x1c09, L"1.2.840.113556.1.4.1505"  },    // English      South Africa
     { 0x2009, L"1.2.840.113556.1.4.1506"  },    // English      Jamaica
     { 0x2409, L"1.2.840.113556.1.4.1507"  },    // English      Caribbean
     { 0x2809, L"1.2.840.113556.1.4.1508"  },    // English      Belize
     { 0x2c09, L"1.2.840.113556.1.4.1509"  },    // English      Trinidad
     { 0x3009, L"1.2.840.113556.1.4.1510"  },    // English      Zimbabwe
     { 0x3409, L"1.2.840.113556.1.4.1511"  },    // English      Philippines
     { 0x0425, L"1.2.840.113556.1.4.1512"  },    // Estonian
     { 0x0438, L"1.2.840.113556.1.4.1513"  },    // Faeroese
     { 0x0429, L"1.2.840.113556.1.4.1514"  },    // Farsi
     { 0x040b, L"1.2.840.113556.1.4.1515"  },    // Finnish
     { 0x040c, L"1.2.840.113556.1.4.1516"  },    // French      France
     { 0x080c, L"1.2.840.113556.1.4.1517"  },    // French      Belgium
     { 0x0c0c, L"1.2.840.113556.1.4.1518"  },    // French      Canada
     { 0x100c, L"1.2.840.113556.1.4.1519"  },    // French      Switzerland
     { 0x140c, L"1.2.840.113556.1.4.1520"  },    // French      Luxembourg
     { 0x180c, L"1.2.840.113556.1.4.1521"  },    // French      Monaco
     { 0x0437, L"1.2.840.113556.1.4.1522"  },    // Georgian
     { 0x0407, L"1.2.840.113556.1.4.1523"  },    // German      Germany
     { 0x0807, L"1.2.840.113556.1.4.1524"  },    // German      Switzerland
     { 0x0c07, L"1.2.840.113556.1.4.1525"  },    // German      Austria
     { 0x1007, L"1.2.840.113556.1.4.1526"  },    // German      Luxembourg
     { 0x1407, L"1.2.840.113556.1.4.1527"  },    // German      Liechtenstein
     { 0x0408, L"1.2.840.113556.1.4.1528"  },    // Greek
     { 0x0447, L"1.2.840.113556.1.4.1529"  },    // Gujarati
     { 0x040D, L"1.2.840.113556.1.4.1530"  },    // Hebrew
     { 0x0439, L"1.2.840.113556.1.4.1531"  },    // Hindi
     { 0x040e, L"1.2.840.113556.1.4.1532"  },    // Hungarian
     { 0x040F, L"1.2.840.113556.1.4.1533"  },    // Icelandic
     { 0x0421, L"1.2.840.113556.1.4.1534"  },    // Indonesian
     { 0x045e, L"1.2.840.113556.1.4.1535"  },    // Inukitut
     { 0x0410, L"1.2.840.113556.1.4.1536"  },    // Italian      Italy
     { 0x0810, L"1.2.840.113556.1.4.1537"  },    // Italian      Switzerland
     { 0x0411, L"1.2.840.113556.1.4.1538"  },    // Japanese
     { 0x044b, L"1.2.840.113556.1.4.1539"  },    // Kannada
     { 0x0460, L"1.2.840.113556.1.4.1540"  },    // Kashmiri     Arabic
     { 0x0860, L"1.2.840.113556.1.4.1541"  },    // Kashmiri
     { 0x043f, L"1.2.840.113556.1.4.1542"  },    // Kazakh
     { 0x0453, L"1.2.840.113556.1.4.1543"  },    // Khmer
     { 0x0440, L"1.2.840.113556.1.4.1544"  },    // Kirghiz
     { 0x0457, L"1.2.840.113556.1.4.1545"  },    // Konkani
     { 0x0412, L"1.2.840.113556.1.4.1546"  },    // Korean
     { 0x0812, L"1.2.840.113556.1.4.1547"  },    // Korean       Johab
     { 0x0426, L"1.2.840.113556.1.4.1548"  },    // Latvian
     { 0x0427, L"1.2.840.113556.1.4.1549"  },    // Lithuanian
     { 0x042f, L"1.2.840.113556.1.4.1550"  },    // FYRO Macedonian
     { 0x043e, L"1.2.840.113556.1.4.1551"  },    // Malaysian
     { 0x083e, L"1.2.840.113556.1.4.1552"  },    // Malay Brunei Darussalam
     { 0x044c, L"1.2.840.113556.1.4.1553"  },    // Malayalam
     { 0x043a, L"1.2.840.113556.1.4.1554"  },    // Maltese
     { 0x0458, L"1.2.840.113556.1.4.1555"  },    // Manipuri
     { 0x044e, L"1.2.840.113556.1.4.1556"  },    // Marathi 
     { 0x0461, L"1.2.840.113556.1.4.1557"  },    // Nepali       Nepal
     { 0x0414, L"1.2.840.113556.1.4.1558"  },    // Norwegian    Bokmal
     { 0x0814, L"1.2.840.113556.1.4.1559"  },    // Norwegian    Nynorsk
     { 0x0448, L"1.2.840.113556.1.4.1560"  },    // Oriya
     { 0x0415, L"1.2.840.113556.1.4.1561"  },    // Polish
     { 0x0416, L"1.2.840.113556.1.4.1562"  },    // Portuguese      Brazil
     { 0x0816, L"1.2.840.113556.1.4.1563"  },    // Portuguese      Portugal
     { 0x0446, L"1.2.840.113556.1.4.1564"  },    // Punjabi
     { 0x0418, L"1.2.840.113556.1.4.1565"  },    // Romanian
     { 0x0419, L"1.2.840.113556.1.4.1566"  },    // Russian
     { 0x044f, L"1.2.840.113556.1.4.1567"  },    // Sanskrit
     { 0x0c1a, L"1.2.840.113556.1.4.1568"  },    // Serbian      Cyrillic
     { 0x081a, L"1.2.840.113556.1.4.1569"  },    // Serbian      Latin
     { 0x0459, L"1.2.840.113556.1.4.1570"  },    // Sindhi       India
     { 0x041b, L"1.2.840.113556.1.4.1571"  },    // Slovak
     { 0x0424, L"1.2.840.113556.1.4.1572"  },    // Slovenian
     { 0x040a, L"1.2.840.113556.1.4.1573"  },    // Spanish      Spain - Traditional Sort
     { 0x080a, L"1.2.840.113556.1.4.1574"  },    // Spanish      Mexico
     { 0x0c0a, L"1.2.840.113556.1.4.1575"  },    // Spanish      Spain  Modern Sort
     { 0x100a, L"1.2.840.113556.1.4.1576"  },    // Spanish      Guatemala
     { 0x140a, L"1.2.840.113556.1.4.1577"  },    // Spanish      Costa Rica
     { 0x180a, L"1.2.840.113556.1.4.1578"  },    // Spanish      Panama
     { 0x1c0a, L"1.2.840.113556.1.4.1579"  },    // Spanish      Dominican Republic
     { 0x200a, L"1.2.840.113556.1.4.1580"  },    // Spanish      Venezuela
     { 0x240a, L"1.2.840.113556.1.4.1581"  },    // Spanish      Colombia
     { 0x280a, L"1.2.840.113556.1.4.1582"  },    // Spanish      Peru
     { 0x2c0a, L"1.2.840.113556.1.4.1583"  },    // Spanish      Argentina
     { 0x300a, L"1.2.840.113556.1.4.1584"  },    // Spanish      Ecuador
     { 0x340a, L"1.2.840.113556.1.4.1585"  },    // Spanish      Chile
     { 0x380a, L"1.2.840.113556.1.4.1586"  },    // Spanish      Uruguay
     { 0x3c0a, L"1.2.840.113556.1.4.1587"  },    // Spanish      Paraguay
     { 0x400a, L"1.2.840.113556.1.4.1588"  },    // Spanish      Bolivia
     { 0x440a, L"1.2.840.113556.1.4.1589"  },    // Spanish      El Salvador
     { 0x480a, L"1.2.840.113556.1.4.1590"  },    // Spanish      Honduras
     { 0x4c0a, L"1.2.840.113556.1.4.1591"  },    // Spanish      Nicaragua
     { 0x500a, L"1.2.840.113556.1.4.1592"  },    // Spanish      Puerto Rico
     { 0x0441, L"1.2.840.113556.1.4.1593"  },    // Swahili      Kenya
     { 0x041D, L"1.2.840.113556.1.4.1594"  },    // Swedish
     { 0x081d, L"1.2.840.113556.1.4.1595"  },    // Swedish      Finland
     { 0x0449, L"1.2.840.113556.1.4.1596"  },    // Tamil
     { 0x0444, L"1.2.840.113556.1.4.1597"  },    // Tatar        Tatarstan
     { 0x044a, L"1.2.840.113556.1.4.1598"  },    // Telugu
     { 0x041E, L"1.2.840.113556.1.4.1599"  },    // Thai
     { 0x041f, L"1.2.840.113556.1.4.1600"  },    // Turkish
     { 0x0422, L"1.2.840.113556.1.4.1601"  },    // Ukrainian
     { 0x0420, L"1.2.840.113556.1.4.1602"  },    // Urdu         Pakistan
     { 0x0820, L"1.2.840.113556.1.4.1603"  },    // Urdu         India
     { 0x0443, L"1.2.840.113556.1.4.1604"  },    // Uzbek        Latin
     { 0x0843, L"1.2.840.113556.1.4.1605"  },    // Uzbek        Cyrillic
     { 0x042a, L"1.2.840.113556.1.4.1606"  },    // Vietnamese
     { 0x0,    L"1.2.840.113556.1.4.1607"  },    // JAPANESE_XJIS SORT
     { 0x1,    L"1.2.840.113556.1.4.1608"  },    // JAPANSE_UNICODE SORT
     { 0x0,    L"1.2.840.113556.1.4.1609"  },    // CHINESE_BIG5
     { 0x0,    L"1.2.840.113556.1.4.1610"  },    // CHINESE_PRCP
     { 0x1,    L"1.2.840.113556.1.4.1611"  },    // CHINESE_UNICODE
     { 0x2,    L"1.2.840.113556.1.4.1612"  },    // CHINESE_PRC
     { 0x3,    L"1.2.840.113556.1.4.1613"  },    // CHINESE_BOPOMOFO
     { 0x0,    L"1.2.840.113556.1.4.1614"  },    // KOREAN_KSC
     { 0x1,    L"1.2.840.113556.1.4.1615"  },    // KOREAN_UNICODE
     { 0x1,    L"1.2.840.113556.1.4.1616"  },    // GERMAN_PHONE_BOOK
     { 0x0,    L"1.2.840.113556.1.4.1617"  },    // HUNGARIAN_DEFAULT
     { 0x1,    L"1.2.840.113556.1.4.1618"  },    // HUNGARIAN_TECHNICAL
     { 0x0,    L"1.2.840.113556.1.4.1619"  },    // GEORGIAN_TRADITIONAL
     { 0x1,    L"1.2.840.113556.1.4.1620"  },    // GEORGIAN_MODERN
     { 0x0,    NULL } };

#define NUM_LANGLOCALES (sizeof(LangLcidOid)/sizeof(LANG_LCID_OID) - 1)

LANG_LCID_PREFIX LangLcidPrefix [NUM_LANGLOCALES];

BOOL gbLocaleSupportInitialised = FALSE;



int __cdecl
CompareLangLcidPrefix(
        const void * pv1,
        const void * pv2
        )
{
    return ((LANG_LCID_PREFIX *)pv1)->prefix - ((LANG_LCID_PREFIX *)pv2)->prefix ;
}

BOOL
InitLocaleSupport (THSTATE *pTHS)
{
    DWORD i, err = 0;
    ATTRTYP attrType;

    DPRINT (0, "Initializing Locale Support\n");

    for (i=0; i<NUM_LANGLOCALES; i++) {

        if (err = StringToAttrTyp (pTHS, 
                                   LangLcidOid[i].pwszOID, 
                                   wcslen (LangLcidOid[i].pwszOID), 
                                   &attrType) ) {
            
            break;
        }
        LangLcidPrefix[i].prefix = attrType;
        LangLcidPrefix[i].lcid = LangLcidOid[i].lcid;
    }

    if (!err) {
        qsort(LangLcidPrefix,
              NUM_LANGLOCALES,
              sizeof(LANG_LCID_PREFIX),
              CompareLangLcidPrefix);

        gbLocaleSupportInitialised = TRUE;

        DPRINT (0, "Succedded Initializing Locale Support\n");
    }

    return gbLocaleSupportInitialised;
}


BOOL
AttrTypToLCID (THSTATE *pTHS, 
               ATTRTYP attrType, 
               DWORD *pLcid) 
{
    LANG_LCID_PREFIX *pLcidPrefix, lcidPrefix;

    if (!gbLocaleSupportInitialised) {
        return FALSE;
    }

    lcidPrefix.prefix = attrType;
    
    pLcidPrefix = bsearch(&lcidPrefix,
                           LangLcidPrefix,
                           NUM_LANGLOCALES,
                           sizeof(LANG_LCID_PREFIX),
                           CompareLangLcidPrefix);

    if (!pLcidPrefix) {
        return FALSE;
    }

    *pLcid = pLcidPrefix->lcid;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\mkdit\mkhdr.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1989 - 1999
//
//  File:       mkhdr.cxx
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Parses Schema Initialization File

Author:

    Rajivendra Nath (RajNath) 07-Jul-1996

Revision History:

--*/

#include <ntdspchX.h>
#include "SchGen.HXX"
#include "schema.hxx"

extern "C" {
#include <prefix.h>
}

// Define variable from prefix.h constant, so that genh.cxx
// (which does not and does not need to otherwise include
// prefix.h) can use it

ULONG MaxUsableIndex = MAX_USABLE_HARDCODED_INDEX;


VOID PrintHelp()
{

    printf("USAGE: MKHDR <Schema Definition File> [/AGME] \n");
    printf("      This will create the Mapi and DS header files \n");
    printf("Option /AGME: \n");
    printf(" A    Creates Attids.h\n");
    printf(" G    Creates NTDSGuid.h\n");
    printf(" M    Creates MDSchema.H\n");
    printf(" E    Creates MSDSMAPI.H\n");
    printf(" T    Tees output to console\n");
}

int __cdecl main (int argc, char *argv[])
{
    THSTATE *pTHS;
    char  fp[MAX_PATH];
    char* opt="AGME";
    SCHEMAPTR *tSchemaPtr;
    ULONG i, PREFIXCOUNT = 64; // We only need to load MS prefixes
    PrefixTableEntry *PrefixTable;
    extern BOOL fDetails;

    // Initialize debug library.
    DEBUGINIT(0, NULL, "mkhdr");

    if (argc<2)
    {
        PrintHelp();
        return 1;
    }

    if (argv[2])
    {
        opt=&argv[2][1]; // skip the leading slash.
    }
    

    if (_fullpath(fp, argv[1], sizeof(fp))==NULL)
    {
        printf("%s NOT FOUND\n",argv[1]);
        return 1;
    }

    {
        //
        // Check if File Exists
        //
        FILE* f;
        if ((f=fopen(fp,"r"))==NULL)
        {
            printf("Schema File:%s Does Not Exist\n\n",fp);
            PrintHelp();
            return 1;
        }
        fclose(f);
    }
    

    if (!SetIniGlobalInfo(fp))
    {
        printf("%s:Invalid Inifile\n",fp);
        return 1;
    }


    if (!InitSyntaxTable()) {
        printf("Failed to init the syntax table\n");
        return 1;
    }
        
    // Load the prefix table for OID to AttrType and vice-versa mapping
    // For mkhdr, we load only the MS prefixes. Prefix Table loading 
    // assumes that pTHStls->CurrSchemaPtr is non-null, since accesses to the
    // prefix table are through these pointers. Since in this case we do not
    // care about schema cache, we simply allocate pTHStls in normal heap space
    // of the executable and just use the PrefixTable component.
    // The usual thread creation/initialization routine in dsatools.c is
    // mainly for DS-specific threads, and is not used here

    dwTSindex = TlsAlloc();
    pTHS = (THSTATE *)XCalloc(1,sizeof(THSTATE));
    TlsSetValue(dwTSindex, pTHS);
    if (pTHS==NULL) {
         printf("pTHStls allocation error\n");
         return 1;
    }
    pTHS->CurrSchemaPtr = tSchemaPtr = (SCHEMAPTR *) XCalloc(1,sizeof(SCHEMAPTR));
    if (tSchemaPtr == NULL) {
      printf("Cannot alloc schema ptr\n");
      return 1;
    }

    // Allocate space for the prefix table

    tSchemaPtr->PREFIXCOUNT = PREFIXCOUNT; 
    tSchemaPtr->PrefixTable.pPrefixEntry =  (PrefixTableEntry *) XCalloc(tSchemaPtr->PREFIXCOUNT,sizeof(PrefixTableEntry));
    if (tSchemaPtr->PrefixTable.pPrefixEntry==NULL) {
       printf("Error Allocating Prefix Table\n");
       return 1;
    }
    if (InitPrefixTable(tSchemaPtr->PrefixTable.pPrefixEntry, PREFIXCOUNT) != 0) {
      printf("Error Loading Prefix Table\n");
      return 1;
    }

    printf("Prefix table loaded\n");

    fDetails = FALSE; // do not tee output to console
    for (;*opt!='\0';opt++)
    {
    
        switch(tolower(*opt))
        {
            case 'a':
            printf("Creating AttIds.h\n");
            CreateAttids();
            break;
        
            case 'g':
            printf("Creating NTDSGuid.h\n");
            CreateGuid();
            break;
        
            case 'm':
            printf("Creating MDSchema.H\n");
            CreateMDS();
            break;
        
            case 'e':
            printf("Creating MSDSMAPI.H\n");
            CreateEMS();
            break;
        
            case 't':
            fDetails = TRUE;
            break;
	    
	  default:
	    printf("Unknown option '%c'\n", tolower(*opt));
        }
    }
    
    // Unload the prefix table

    SCFreePrefixTable(&tSchemaPtr->PrefixTable.pPrefixEntry, PREFIXCOUNT);
    XFree(tSchemaPtr);
    XFree(pTHS);
    TlsSetValue(dwTSindex, NULL);
    DEBUGTERM( );

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\ldap\secure.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    secure.cxx

Abstract:

    This module implements the LDAP server for the NT5 Directory Service.

    This file contains the information about a security context associated with
    some connection.

Author:

    Tim Willims     [TimWi]    9-Jun-1997

Revision History:

--*/

#include <NTDSpchx.h>
#pragma  hdrstop

#include "ldapsvr.hxx"

#define  FILENO FILENO_LDAP_SECURE


LDAP_SECURITY_CONTEXT::LDAP_SECURITY_CONTEXT(
    IN BOOL fSasl,
    IN BOOL fFastBind
    )
/*++
  This function creates a new UserData object for the information
    required to process requests from a new User connection.

  Returns:
     a newly constructed LDAP_SECURITY_CONTEXT object.

--*/
        :m_Padding(LSC_PADDING),
         m_References(1),
         m_fGssApi(FALSE),
         m_fUseLdapV3Response(FALSE),
         m_BindState(unbound)
{
    
    m_pCtxtPointer = &m_hSecurityContext;

    if ( fSasl ) {
        m_acceptSecurityContext = SaslAcceptSecurityContext;
    } else {
        m_acceptSecurityContext = AcceptSecurityContext;
    }

    m_fFastBind = fFastBind;

    IF_DEBUG(BIND) {
        DPRINT2(0,"ldap_security_context object created  @ %08lX. fSasl %x\n", 
                this, fSasl);
    }

} // LDAP_SECURITY_CONTEXT::LDAP_SECURITY_CONTEXT()



LDAP_SECURITY_CONTEXT::~LDAP_SECURITY_CONTEXT(VOID)
{

    Assert(m_Padding == LSC_PADDING);
    

    if ( m_BindState == Sslbind ) {

        IF_DEBUG(SSL) {
            DPRINT1(0,"deleting SSL context object %x.\n", this);
        }

    } else if(m_BindState != unbound) {
        IF_DEBUG(BIND) {
            DPRINT2(0,"delete ldap_security_context object @ %08lX, %d\n",
                this, m_BindState); 
        }
        DeleteSecurityContext(m_pCtxtPointer);
    } else {
        IF_DEBUG(BIND) {
            DPRINT2(0,"did not delete ldap_security_context object @ %08lX, %d\n",
                this, m_BindState);
        }
    }
    
} // LDAP_SECURITY_CONTEXT::~LDAP_SECURITY_CONTEXT()


CtxtHandle *
LDAP_SECURITY_CONTEXT::GetSecurityContext()
{
    Assert(m_Padding == LSC_PADDING);
    ReferenceSecurity();
    if( (m_BindState == bound) || (m_BindState == Sslbind) ) {

        Assert(((m_BindState == bound) && 
                            (m_pCtxtPointer == &m_hSecurityContext)) ||
               ((m_BindState == Sslbind) && 
                            (m_pCtxtPointer != &m_hSecurityContext)));

        IF_DEBUG(BIND) {
            DPRINT2(1, "Get reference to bound ldap_security_context  @ %08lX, %d\n",
                this, m_References); 
        }
        return m_pCtxtPointer;
    } else {
        IF_DEBUG(BIND) {
            DPRINT2(1,
                "Null reference to unbound ldap_security_context @ %08lX, %d\n",
                this, m_References); 
        }
        return NULL;
    }
}


SECURITY_STATUS
LDAP_SECURITY_CONTEXT::AcceptContext (
        IN PCredHandle phCredential,               // Cred to base context
        IN PSecBufferDesc pInput,                  // Input buffer
        IN DWORD fContextReq,                      // Context Requirements
        IN DWORD TargetDataRep,                    // Target Data Rep
        IN OUT PSecBufferDesc pOutput,             // (inout) Output buffers
        OUT DWORD SEC_FAR * pfContextAttr,         // (out) Context attributes
        OUT PTimeStamp ptsExpiry,                  // (out) Life span
        OUT PTimeStamp ptsHardExpiry               // (out) Hard Life span (OPT)
        )
{
    Assert(m_Padding == LSC_PADDING);
    SECURITY_STATUS scRet;
    if( (m_BindState == bound) || (m_BindState == Sslbind) ) {
        // Hey, you can't do this.
        DPRINT(0,"Attempting to do AcceptContext on a bound connection\n");
        return SEC_E_UNSUPPORTED_FUNCTION;
    }

    INC(pcLdapThreadsInAuth);
    scRet = m_acceptSecurityContext(
            phCredential,
            (m_BindState==partialbind)?&m_hSecurityContext:NULL,
            pInput,
            fContextReq,
            0,
            &m_hSecurityContext,
            pOutput,
            pfContextAttr,
            ptsExpiry );
    DEC(pcLdapThreadsInAuth);
    switch (scRet) {
    case SEC_I_CONTINUE_NEEDED:
        IF_DEBUG(BIND) {
            DPRINT1(0,
                "Accept to partial bind, ldap_security_context @ %08lX\n",
                this);
        }
        m_BindState = partialbind;
        break;

    case STATUS_SUCCESS:
        IF_DEBUG(BIND) {
            DPRINT1(0, "Accept to bind, ldap_security_context @ %08lX.\n", this);

            if ( pfContextAttr != NULL ) {
                DPRINT1(0, "Attr flags %x\n", *pfContextAttr);
            }
        }

        if (m_fFastBind) {
            m_BindState = bound;
            break;
        }

        //
        // Get additional information
        //

        scRet = QueryContextAttributes(
                                &m_hSecurityContext,
                                SECPKG_ATTR_SIZES,
                                &m_ContextSizes
                                );
    
        if ( scRet == ERROR_SUCCESS ) {
    
            IF_DEBUG(SSL) {

                DPRINT4(0,"Context sizes: Token %d Signature %d Block %d Trailer %d\n",
                       m_ContextSizes.cbMaxToken,
                       m_ContextSizes.cbMaxSignature,
                       m_ContextSizes.cbBlockSize,
                       m_ContextSizes.cbSecurityTrailer);

            }
        } else {
    
            IF_DEBUG(WARNING) {
                DPRINT1(0,"Cannot query context sizes. err %x\n", scRet);
            }
            ZeroMemory(&m_ContextSizes, sizeof(m_ContextSizes));
            scRet = ERROR_SUCCESS;
        }

        //
        // Get Hard Timeout
        //

        if ( ptsHardExpiry != NULL ) {

            SecPkgContext_Lifespan lifeSpan;

            scRet = QueryContextAttributes(
                                    &m_hSecurityContext,
                                    SECPKG_ATTR_LIFESPAN,
                                    &lifeSpan
                                    );
        
            if ( scRet == ERROR_SUCCESS ) {

                *ptsHardExpiry = lifeSpan.tsExpiry;

            } else {
        
                IF_DEBUG(WARNING) {
                    DPRINT1(0,"Cannot query hard context expiration time. err %x\n", scRet);
                }

                //
                // if this fails, just set hard to be equal to the soft timeout
                //

                *ptsHardExpiry = *ptsExpiry;
                scRet = ERROR_SUCCESS;
            }

        }

        m_BindState = bound;
        break;

    default:
        Assert(m_BindState != bound);
        
        IF_DEBUG(BIND) {
            DPRINT2(0,
                "Accept to unbound, ldap_security_context @ %08lX. Error %x\n",
                this, scRet);
        }

        //
        // if we have a partial context, free it
        //

        if( m_BindState != unbound) {
            Assert(m_BindState == partialbind);
            DeleteSecurityContext(&m_hSecurityContext);
            m_BindState = unbound;
        }
        break;
    }
    
    return scRet;
} // LDAP_SECURITY_CONTEXT::AcceptContext

BOOL
LDAP_SECURITY_CONTEXT::IsPartiallyBound (
        VOID
        )
{
    Assert(m_Padding == LSC_PADDING);
    return(m_BindState == partialbind);
} // LDAP_SECURITY_CONTEXT::IsPartiallyBound

VOID
LDAP_SECURITY_CONTEXT::GetUserName(
        OUT PWCHAR *UserName
        )
{
    SECURITY_STATUS scRet;
    SecPkgContext_NamesW names;

    if( (m_BindState != bound) && (m_BindState != Sslbind) ) {
        // Hey, you can't do this.
        DPRINT(0,"Attempting to GetUserName without a bind.\n");
        return;
    }

    scRet = QueryContextAttributesW(
                            m_pCtxtPointer,
                            SECPKG_ATTR_NAMES,
                            &names
                            );

    if ( scRet == ERROR_SUCCESS ) {
        IF_DEBUG(SSL) {
            DPRINT1(0,"UserName %ws returned by package\n",
                    names.sUserName);
        }

        *UserName = names.sUserName;
    } else {
        IF_DEBUG(WARNING) {
            DPRINT1(0,"Error %x querying for user name\n",scRet);
        }
    }

    return;

} // LDAP_SECURITY_CONTEXT::GetUserName


VOID
LDAP_SECURITY_CONTEXT::GetHardExpiry( OUT PTimeStamp pHardExpiry )
{
    SecPkgContext_Lifespan lifeSpan;
    SECURITY_STATUS        scRet;

    scRet = QueryContextAttributes(
        m_pCtxtPointer,
        SECPKG_ATTR_LIFESPAN,
        &lifeSpan
        );

    if (scRet != ERROR_SUCCESS) {
        IF_DEBUG(SSL) {
            DPRINT(0, "Failed to query TLS sec context for hard expiry.\n");
        }

        pHardExpiry->QuadPart = MAXLONGLONG;
    } else {                    
        *pHardExpiry = lifeSpan.tsExpiry;
    }

}


ULONG
LDAP_SECURITY_CONTEXT::GetSealingCipherStrength()
/*++
Routine Description:

    This routine gets the cipher strength from the security context on a sign/seal 
    connection.

Arguments:

    None.

Return Value:

    The cipher strength of the sign/seal security context.  If there are any
    errors the function will return 0 for the cipher strength.
    
--*/
{
    SecPkgContext_KeyInfo  KeyInfo;
    SECURITY_STATUS        scRet;

    if (!NeedsSealing()) {
        return 0;
    }

    scRet = QueryContextAttributes(
        &m_hSecurityContext,
        SECPKG_ATTR_KEY_INFO,
        &KeyInfo
        );

    if (scRet != ERROR_SUCCESS) {
        IF_DEBUG(SSL) {
            DPRINT1(0, "Failed to query sign/sealing sec context for cipher strength. scRet = 0x%x\n", scRet);
        }
        return 0;
    }

    return KeyInfo.KeySize;
}

DWORD
LDAP_SECURITY_CONTEXT::GetMaxEncryptSize( VOID )
{
    SecPkgContext_StreamSizes  StreamSizes;
    SECURITY_STATUS        scRet;

    if (!(NeedsSealing() || NeedsSigning())) {
        return MAXDWORD;
    }

    scRet = QueryContextAttributes(
        &m_hSecurityContext,
        SECPKG_ATTR_STREAM_SIZES,
        &StreamSizes
        );

    if (scRet != ERROR_SUCCESS) {
        IF_DEBUG(SSL) {
            DPRINT1(0, "Failed to query sign/sealing sec context for cipher strength. scRet = 0x%x\n", scRet);
        }
        return MAXDWORD;
    }

    return StreamSizes.cbMaximumMessage;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\mkdit\createdb.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1989 - 1999
//
//  File:       CreateDB.cxx
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Generate the JET DATABASE Structure

Author:

    Rajivendra Nath (RajNath) 16-Aug-1996

Revision History:

--*/

#include <ntdspchX.h>
#include "SchGen.HXX"
#include "schema.hxx"

extern "C" {
#include <dsjet.h>
#include <prefix.h>
#include <crypto\md5.h>
}

// Define various Jet values which we need in both Jet500 and Jet600
// cases but aren't defined in both header files.

#ifndef JET_bitIndexClustered
#define JET_bitIndexClustered       0x00000010
#endif
#ifndef JET_bitColumnEscrowUpdate
#define JET_bitColumnEscrowUpdate   0x00000800
#endif

extern "C" {

int
__cdecl
StrDefSearch(const void* elem1,const void* elem2);


}

#define ROOTDB            "Database"

//
// Well Known Keys
//
#define DATABASENAMEKEY "DATABASENAME"
#define DATATABLEKEY   "DATATABLE"
#define LINKTABLEKEY   "LINKTABLE"
#define CONFIGTABLEKEY "CONFIGTABLE"
#define SDPROPTABLEKEY "SDPROPTABLE"
#define SDTABLEKEY "SDTABLE"

#define COLUMNKEY    "COLUMN"
#define PAGESKEY     "PAGES"
#define INDEXKEY     "INDEX"
#define COLTYPEKEY   "COLUMNTYPE"
#define CPKEY        "CP"
#define GRBITKEY     "GRBIT"
#define FLAGKEY       "FLAG"
#define DENSITYKEY   "DENSITY"
#define MAXCOLSIZEKEY "MAXCOLSIZE"
#define JETALIASKEY    "JETALIAS"


#define MAXTABLECOUNT   32

ULONG   gcbDefaultSecurityDescriptor=sizeof(DEFSECDESC) - 1;
char *  gpDefaultSecurityDescriptor = DEFSECDESC;



typedef struct
{
    char* Name;
    DWORD Def;
}STRDEF;

typedef struct
{
    char*         Name;
    char*         JAlias;
    JET_COLUMNDEF JColDef;
    JET_COLUMNID  JColId;
}CREATECOL;

typedef struct
{
    char* Name;
    char* JAlias;
    char* Key;
    ULONG KeyLen;
    ULONG Grbit;
    ULONG Density;
}CREATENDX;


typedef struct
{
    char*       Name;
    ULONG       Pages;
    ULONG       Density;
    JET_TABLEID JTid;
    ULONG       ColCount;
    CREATECOL*  ColList;
    ULONG       NdxCount;
    CREATENDX*  NdxList;
}CREATETABLE;


//
// This table must be sorted for bsearch
//

STRDEF StrDef[]=
{
    {"JET_bitColumnAutoincrement  " ,JET_bitColumnAutoincrement  },
    {"JET_bitColumnEscrowUpdate   " ,JET_bitColumnEscrowUpdate   },
    {"JET_bitColumnFinalize       " ,JET_bitColumnFinalize       },
    {"JET_bitColumnFixed          " ,JET_bitColumnFixed          },
    {"JET_bitColumnMultiValued    " ,JET_bitColumnMultiValued    },
    {"JET_bitColumnNotNULL        " ,JET_bitColumnNotNULL        },
    {"JET_bitColumnTTDescending   " ,JET_bitColumnTTDescending   },
    {"JET_bitColumnTTKey          " ,JET_bitColumnTTKey          },
    {"JET_bitColumnTagged         " ,JET_bitColumnTagged         },
    {"JET_bitColumnUpdatable      " ,JET_bitColumnUpdatable      },
    {"JET_bitColumnVersion        " ,JET_bitColumnVersion        },
    {"JET_bitIndexClustered       " ,JET_bitIndexClustered       },
    {"JET_bitIndexDisallowNull    " ,JET_bitIndexDisallowNull    },
    {"JET_bitIndexIgnoreAnyNull   " ,JET_bitIndexIgnoreAnyNull   },
    {"JET_bitIndexIgnoreNull      " ,JET_bitIndexIgnoreNull      },
    {"JET_bitIndexPrimary         " ,JET_bitIndexPrimary         },
    {"JET_bitIndexUnique          " ,JET_bitIndexUnique          },
    {"JET_bitKeyDataZeroLength    " ,JET_bitKeyDataZeroLength    },
    {"JET_bitNewKey               " ,JET_bitNewKey               },
    {"JET_bitNormalizedKey        " ,JET_bitNormalizedKey        },
    {"JET_bitStrLimit             " ,JET_bitStrLimit             },
    {"JET_bitSubStrLimit          " ,JET_bitSubStrLimit          },
    {"JET_coltypBinary            " ,JET_coltypBinary            },
    {"JET_coltypBit               " ,JET_coltypBit               },
    {"JET_coltypCurrency          " ,JET_coltypCurrency          },
    {"JET_coltypDateTime          " ,JET_coltypDateTime          },
    {"JET_coltypIEEEDouble        " ,JET_coltypIEEEDouble        },
    {"JET_coltypIEEESingle        " ,JET_coltypIEEESingle        },
    {"JET_coltypLong              " ,JET_coltypLong              },
    {"JET_coltypLongBinary        " ,JET_coltypLongBinary        },
    {"JET_coltypLongText          " ,JET_coltypLongText          },
    {"JET_coltypMax               " ,JET_coltypMax               },
    {"JET_coltypNil               " ,JET_coltypNil               },
    {"JET_coltypShort             " ,JET_coltypShort             },
    {"JET_coltypText              " ,JET_coltypText              },
    {"JET_coltypUnsignedByte      " ,JET_coltypUnsignedByte      }
};

#define STRDEFCOUNT (sizeof(StrDef)/sizeof(StrDef[0]))

extern BOOL fGenGuid;
extern GUID GenGuid();


VOID
GetColInfo(INISECT& itbl,CREATETABLE* pTbl);

VOID
GetNDXInfo(INISECT& itbl,CREATETABLE* pTbl);

VOID
GetSchemaAttributes(CREATETABLE* CTbl,char* SchemaSec);

JET_ERR
CreateJetDatabaseStructure
(
    char* DBName,
    ULONG TableCount,
    CREATETABLE* Ctable,
    JET_INSTANCE *pInstance,
    JET_SESID    *pSesid,
    JET_DBID     *pDbid
);

JET_ERR
CreateRootDSA
(
    WCHAR*         Name,
    JET_INSTANCE  Instance,
    JET_SESID     Sesid,
    JET_DBID      Dbid,
    CREATETABLE& Ctbl,
    CREATETABLE& SDtbl,
    ULONG*       pDsaDnt,
    GUID         guid
);

JET_ERR
CreateZeroDNT
(
    WCHAR*         Name,
    JET_INSTANCE  Instance,
    JET_SESID     Sesid,
    JET_DBID      Dbid,
    CREATETABLE& Ctbl,
    GUID         guid
);

JET_ERR
CreateRootObjects
(
    JET_INSTANCE  Instance,
    JET_SESID     Sesid,
    JET_DBID      Dbid,
    CREATETABLE& Ctbl,
    CREATETABLE& SDtbl,
    ULONG*       pDsaDnt
) ;
 JET_ERR
SetJetColumn
(
    JET_SESID     Sesid,
    JET_DBID      Dbid,
    CREATETABLE& Ctbl,
    char*         ColName,
    PVOID         pData,
    ULONG         cbData
);

JET_ERR
WriteConfigInfo
(
    JET_SESID Sesid,
    JET_DBID   Dbid,
    CREATETABLE& Ctbl,
    ULONG        DsaDnt
);

JET_ERR
RetrieveJetColumn
(
    JET_SESID     Sesid,
    JET_DBID      Dbid,
    CREATETABLE& Ctbl,
    char*         ColName,
    PVOID         pData,
    ULONG*        cbData
);

int
__cdecl
StrDefSearch(const void* elem1,const void* elem2)
{
    char* e1=((STRDEF*)elem1)->Name;
    char* e2=((STRDEF*)elem2)->Name;

    while
    (
        *e1!='\0' &&
        *e1!=' '  &&
        *e2!='\0' &&
        *e2!=' '
    )
    {
        if (*e1!=*e2)
        {
            return (*e1-*e2);
        }
        e1++;
        e2++;
    }

    if (*e1!='\0' && !isspace(*e1))
    {
        return  1;
    }

    if (*e2!='\0' && !isspace(*e2))
    {
        return -1;
    }

    return 0;
}

DWORD
StrToDef(char* str)
{
    STRDEF* pd;
    STRDEF  key={str,0};
    pd=(STRDEF*)bsearch((PVOID)&key, (PVOID)StrDef,STRDEFCOUNT,sizeof(STRDEF),StrDefSearch);

    if (pd==NULL)
    {
        printf("[%s] StrToDef(%s) Failed. Error No such Str\n",__FILE__,str);
        XINVALIDINIFILE();
    }

    return pd->Def;
}




VOID
CreateStoreStructure()
{
    THSTATE   *pTHS;
    INISECT   idb(ROOTDB);
    YAHANDLE  dbHandle;
    char      DBName[MAX_PATH];

    CREATETABLE ctable[MAXTABLECOUNT];

    SCHEMAPTR *tSchemaPtr;
    ULONG PREFIXCOUNT = 64; // We only need to load MS prefixes
    PrefixTableEntry *PrefixTable;

    // Load the prefix table for OID to AttrType and vice-versa mapping
    // For mkhdr, we load only the MS prefixes. Prefix Table loading
    // assumes that pTHStls->CurrSchemaPtr is non-null, since accesses to the
    // prefix table are through these pointers. Since in this case we do not
    // care about schema cache, we simply allocate pTHStls in normal heap space
    // of the executable and just use the PrefixTable component.
    // The usual thread creation/initialization routine in dsatools.c is
    // mainly for DS-specific threads, and is not used here

    dwTSindex = TlsAlloc();
    pTHS = (THSTATE *)XCalloc(1,sizeof(THSTATE));
    TlsSetValue(dwTSindex, pTHS);
    if (pTHS==NULL) {
         printf("pTHStls allocation error\n");
         XINVALIDINIFILE();
    }
    pTHS->CurrSchemaPtr = tSchemaPtr = (SCHEMAPTR *) XCalloc(1,sizeof(SCHEMAPTR));
    if (tSchemaPtr == NULL) {
      printf("Cannot alloc schema ptr\n");
      XINVALIDINIFILE();
    }

    // Allocate space for the prefix table

    tSchemaPtr->PREFIXCOUNT = PREFIXCOUNT;
    tSchemaPtr->PrefixTable.pPrefixEntry =  (PrefixTableEntry *) XCalloc(tSchemaPtr->PREFIXCOUNT,sizeof(PrefixTableEntry));
    if (tSchemaPtr->PrefixTable.pPrefixEntry==NULL) {
       printf("Error Allocating Prefix Table\n");
       XINVALIDINIFILE();
    }
    if (InitPrefixTable(tSchemaPtr->PrefixTable.pPrefixEntry, PREFIXCOUNT) != 0) {
      printf("Error Loading Prefix Table\n");
      XINVALIDINIFILE();
    }

    printf("Prefix table loaded\n");

    if (!idb.IsInitialized())
    {
        printf("[%s] CreateStoreStructure() Failed. Error Database Sect Not Found\n",__FILE__);
        XINVALIDINIFILE();
    }

    ////////////////

   if (GetConfigParam(FILEPATH_KEY, DBName, sizeof(DBName)))
   {
      printf("FAILED To Read %s. Error %d\n",FILEPATH_KEY,GetLastError());
      puts("-- This means that the entire process has failed, but the lack");
      puts("-- of error handling here has to be seen to be believed, so this");
      puts("-- program will run for a while longer then crash or assert.");
      puts("-- To fix the problem, you need to run the 'instal' app to set");
      puts("-- a couple registry keys, then rerun mkdit");
      return ;
   }

   printf("NTDS:Phase0Init -- Creating the Database Structure:%s!!!\n",DBName);

    int iDataTable=-1;
    int iConfTable=-1;
    int iSDTable=-1;
    int tablecount=0;

    YAHANDLE yh;
    char* key;
    char* tbname;

    for (tablecount=0;tbname = idb.GetNextKey(yh,NULL,&key);tablecount++)
    {
        ctable[tablecount].Name=tbname;
        if (_stricmp(key,DATATABLEKEY)==0)
        {
            iDataTable=tablecount;
        }
        else if(_stricmp(key,CONFIGTABLEKEY)==0)
        {
            iConfTable=tablecount;
        }
        else if(_stricmp(key,SDTABLEKEY)==0)
        {
            iSDTable=tablecount;
        }
    }

    if (iDataTable==-1 || iConfTable==-1 || iSDTable==-1)
    {
        printf("Either %s Table or %s Table or Table %s Not Defined\n",DATATABLEKEY,CONFIGTABLEKEY, SDTABLEKEY);
        XINVALIDINIFILE();
    }
    fGenGuid=TRUE;

    for(int i=0;i<tablecount;i++)
    {

        INISECT itable(ctable[i].Name);


        if (!itable.IsInitialized())
        {
            printf("[%s] CreateStoreStructure() Failed. Error %s Not Found\n",__FILE__,ctable[i].Name);
            XINVALIDINIFILE();
        }

        ctable[i].Pages   = atoi(itable.XGetOneKey(PAGESKEY));
        ctable[i].Density = atoi(itable.XGetOneKey(DENSITYKEY));

        GetColInfo(itable,&ctable[i]);
        GetNDXInfo(itable,&ctable[i]);
    }

    //
    // DataTable has tagged columns defined for schema attribs
    //
    GetSchemaAttributes(&ctable[0],gSchemaname);

    JET_INSTANCE Instance;
    JET_SESID    Sesid;
    JET_DBID     Dbid;

    JET_ERR jerr=CreateJetDatabaseStructure(DBName,tablecount,ctable,&Instance,&Sesid,&Dbid);

    if (jerr!= JET_errSuccess)
    {
        XRAISEGENEXCEPTION(jerr);
    }

    ULONG DsaDnt;
    jerr = CreateRootObjects(Instance,Sesid,Dbid,ctable[iDataTable],ctable[iSDTable],&DsaDnt);
    if (jerr!= JET_errSuccess)
    {
        XRAISEGENEXCEPTION(jerr);
    }

    jerr = WriteConfigInfo(Sesid,Dbid,ctable[iConfTable],DsaDnt);
    if (jerr!= JET_errSuccess)
    {
        XRAISEGENEXCEPTION(jerr);
    }
    //
    // Close everything
    //


    jerr = JetEndSession(Sesid,0);
    if (jerr!= JET_errSuccess)
    {
        XRAISEGENEXCEPTION(jerr);
    }

    jerr = JetTerm(Instance);
    if (jerr!= JET_errSuccess)
    {
        XRAISEGENEXCEPTION(jerr);
    }

    //
    // Copy this to a Backup.
    //
    CopyFile
    (
        DBName,// LPCWSTR lpExistingFileName
        "NEWDS.DIT",// LPCWSTR lpNewFileName
        FALSE
    );

    // Void PTHStls so later create_thread_state calls don't choke.
    XFree(tSchemaPtr->PrefixTable.pPrefixEntry);
    XFree(tSchemaPtr);
    XFree(pTHS);
    TlsSetValue(dwTSindex, 0);
}

VOID
GetColInfo(INISECT& itbl,CREATETABLE* pTbl)
{
    YAHANDLE yh;
    CREATECOL *cc;

    //
    // Count number of columun and allocate space
    //
    for((pTbl->ColCount)=0; itbl.GetNextKey(yh,COLUMNKEY);(pTbl->ColCount)++);
    pTbl->ColList=cc=(CREATECOL*)XCalloc((pTbl->ColCount),sizeof(CREATECOL));

    yh.Reset();
    for (ULONG i=0;i<(pTbl->ColCount);i++)
    {
        cc[i].Name=cc[i].JAlias=XStrdup(itbl.XGetNextKey(yh,COLUMNKEY));
        INISECT icol(cc[i].Name);

        if (!icol.IsInitialized())
        {
            printf("[%s] GetColInfo() Failed. Error %s Not Found\n",__FILE__,cc[i].Name);
            XINVALIDINIFILE();
        }

        cc[i].JColDef.cbStruct = sizeof(JET_COLUMNDEF);
        cc[i].JColDef.columnid = 0;
        cc[i].JColDef.wCountry = 0;
        cc[i].JColDef.langid   = GetUserDefaultLangID();
        cc[i].JColDef.cp       = CP_NON_UNICODE_FOR_JET;
        cc[i].JColDef.wCollate = 0;
        cc[i].JColDef.cbMax    = 0;

        //
        // The following stuff are read from IniFile
        //

        cc[i].JColDef.coltyp   = StrToDef(icol.XGetOneKey(COLTYPEKEY));

        cc[i].JColDef.grbit    = 0;
        YAHANDLE h1;
        char* cgrbit;
        char* cmax;

        while(cgrbit=icol.GetNextKey(h1,GRBITKEY))
        {
            cc[i].JColDef.grbit    |= StrToDef(cgrbit);
        }

        if (cmax=icol.GetOneKey(MAXCOLSIZEKEY))
        {
            cc[i].JColDef.cbMax = atoi(cmax);
        }
    }
}


VOID
GetNDXInfo(INISECT& itbl,CREATETABLE* pTbl)
{
    YAHANDLE yh;
    CREATENDX *cc;

    //
    // Count number of index and allocate space
    //
    for((pTbl->NdxCount)=0; itbl.GetNextKey(yh,INDEXKEY);(pTbl->NdxCount)++);
    pTbl->NdxList=cc=(CREATENDX*)XCalloc((pTbl->NdxCount),sizeof(CREATENDX));


    yh.Reset();
    for (ULONG i=0;i<(pTbl->NdxCount);i++)
    {
        cc[i].Name=(char*)XStrdup(itbl.XGetNextKey(yh,INDEXKEY));
        INISECT indx(cc[i].Name);


        if (!indx.IsInitialized())
        {
            printf("[%s] GetNDXInfo(() Failed. Error %s Not Found\n",__FILE__,cc[i].Name);
            XINVALIDINIFILE();
        }

        cc[i].Density = atoi(indx.XGetOneKey(DENSITYKEY));

        char* ndxname;
        if (ndxname=indx.GetOneKey(JETALIASKEY))
        {
            cc[i].JAlias=XStrdup(ndxname);
        }
        else
        {
            cc[i].JAlias=cc[i].Name;
        }


        cc[i].Grbit    = 0;
        YAHANDLE h1;
        char* cgrbit;
        while(cgrbit=indx.GetNextKey(h1,GRBITKEY))
        {
            cc[i].Grbit    |= StrToDef(cgrbit);
        }


        YAHANDLE h2;
        CHAR     keyname[256];
        char*    kc=keyname;
        char* col;

        ZeroMemory(keyname,sizeof(keyname));

        while(col=indx.GetNextKey(h2,COLUMNKEY))
        {
            CHAR     tmpcol[256];
            if (col[1]=='%') {
                char colx[256];

                colx[0]=0;

                //
                // Its a Schema Attribute => the column name
                // has to be messed up.
                //
                sscanf(col,"%c%%%s",kc,colx);
                kc++;

                // Should always have a string of size at least 2 in colx
                // (at least one character for the attribute name and the last % sign
                if ( (strlen(colx) < 2) ||
                       (colx[strlen(colx)-1] != '%')) {
                    printf("GetNDXInfo failed: Invalid column name (less than two characters or no %% at end) in ini file\n");
                    XINVALIDINIFILE();
                }
                colx[strlen(colx)-1]='\0'; // get rid of the last % sign
                ATTRIBUTESCHEMA as(colx);

                if (!as.Initialize())
                {
                    printf("[%s] GetNDXInfo(() Failed. Error Column %s Not Found\n",__FILE__,colx);
                    XINVALIDINIFILE();
                }


                DWORD syntax = as.SyntaxNdx();
                ATTRTYP attrtyp=as.AttrType();

                kc+=ATTTOCOLNAME(kc,attrtyp,syntax);
            }
            else
            {
                kc+=sprintf(kc,col);
            }
            kc++;
        }
        kc++;

        cc[i].KeyLen=(DWORD)(kc-keyname);
        cc[i].Key   =(char*)XCalloc(1,cc[i].KeyLen);
        CopyMemory(cc[i].Key,keyname,cc[i].KeyLen);
    }
}

VOID
GetSchemaAttributes(CREATETABLE* CTbl,char* SchemaSec)
{
    INISECT sc(SchemaSec);
    int i;
    int next=CTbl->ColCount;
    char* cattr;
    DWORD systemFlags = 0;
    BOOL fLinkedAtt;

    if (!sc.IsInitialized())
    {
        printf("[%s] GetSchemaAttributes() Failed. Error Column %s Not Found\n",__FILE__,SchemaSec);
        XINVALIDINIFILE();
    }

    //
    // Count the # of Attributes
    //
    YAHANDLE yh;
    for (i=0;sc.GetNextKey(yh,CHILDKEY)!=NULL;i++);

    // Allocate max possible needed space. We will create columns for all
    // but linked and constructed atts

    CTbl->ColList=(CREATECOL*)XRealloc(CTbl->ColList,(CTbl->ColCount+i)*sizeof(CREATECOL));

    if (CTbl->ColList==NULL)
    {
        XOUTOFMEMORY();
    }

    yh.Reset();
    while (cattr=sc.GetNextKey(yh,CHILDKEY))
    {
        ATTRIBUTESCHEMA* as=gSchemaObj.GetAttributeSchema(cattr);

        if (as==NULL)
        {
            continue;
        }

        fLinkedAtt = as->IsLinkAtt();
        if (fLinkedAtt) {
           // link attribute, skip it
           continue;
        }

        systemFlags = as->SystemFlags();
        if (systemFlags & FLAG_ATTR_IS_CONSTRUCTED) {
           // Constructed att, don't create columns
           continue;
        }


        char* stroid = as->AttributeId();
        DWORD syntax = as->SyntaxNdx();
        ATTRTYP attrtyp;

        if (OidStrToAttrType(pTHStls, FALSE, stroid, &attrtyp))
        {
            printf("[%s] OidStrToAttrType(%s) Failed.\n",__FILE__,stroid);
            XINVALIDINIFILE();
        }

        char attname[32];
        ATTTOCOLNAME(attname,attrtyp,syntax);

        CTbl->ColList[next].Name    = as->NodeName();
        CTbl->ColList[next].JAlias  = XStrdup(attname);


        CTbl->ColList[next].JColDef.cbStruct = sizeof(JET_COLUMNDEF);
        CTbl->ColList[next].JColDef.columnid = 0;
        CTbl->ColList[next].JColDef.wCountry = 0;
        CTbl->ColList[next].JColDef.langid   = GetUserDefaultLangID();
        CTbl->ColList[next].JColDef.cp       = syntax_jet[syntax].cp;
        CTbl->ColList[next].JColDef.wCollate = 0;
        CTbl->ColList[next].JColDef.cbMax    = syntax_jet[syntax].colsize;
        CTbl->ColList[next].JColDef.coltyp   = syntax_jet[syntax].coltype;
        // Set each attribute to be multi-valued at the Jet level for
        // purposes of simplicity.  Real check is done by the schema code.
        CTbl->ColList[next].JColDef.grbit    = JET_bitColumnTagged | JET_bitColumnMultiValued;

        next++;
    }


    //
    // Fix the column count since we may have counted extra first time around.
    //
    CTbl->ColCount = next;

}

JET_ERR
CreateRootObjects
(
    JET_INSTANCE  Instance,
    JET_SESID     Sesid,
    JET_DBID      Dbid,
    CREATETABLE&  Ctbl,
    CREATETABLE&  SDtbl,
    ULONG        *pDsaDnt
)
{
    JET_ERR jerr;
    printf("NTDS:Phase0Init -- Creating DS ROOT Object!!!\n");

    //
    // We Create two records. The first at DNT=0 is a filler so that
    // no object has a DNT==0.
    // The Second Object is the ROOT Object of this DSA.
    //

    //we should already be here
    //jerr = JetMove(Sesid, Ctbl.JTid,0,JET_MoveFirst);
    //if (jerr!=JET_errSuccess)
    //{
    //    return jerr;
    //}


    // DNT = 1
    jerr = CreateZeroDNT(L"$NOT_AN_OBJECT1$",Instance,Sesid,Dbid,Ctbl,GenGuid());
    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }



    // DNT = 2
    jerr = CreateRootDSA(L"$ROOT_OBJECT$",Instance,Sesid,Dbid,Ctbl,SDtbl,pDsaDnt,GenGuid());
    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }



    return jerr;

}

JET_ERR
CreateRootDSA
(
    WCHAR*         Name,
    JET_INSTANCE  Instance,
    JET_SESID     Sesid,
    JET_DBID      Dbid,
    CREATETABLE& Ctbl,
    CREATETABLE& SDtbl,
    ULONG*       pDsaDnt,
    GUID         guid
)
{
    JET_ERR jerr;
    MD5_CTX md5ctx;
    SDID sdId;
    DWORD cbActual;

    // compute MD5 hash for the root SD
    MD5Init(&md5ctx);
    MD5Update(&md5ctx, (PUCHAR)gpDefaultSecurityDescriptor, gcbDefaultSecurityDescriptor);
    MD5Final(&md5ctx);

    // Jet600 doesn't allow updates of certain data types (long values
    // like binary in particular) to be updated at transaction level 0.
    // So begin and end a transaction appropriately.

    jerr = JetBeginTransaction(Sesid);

    if ( JET_errSuccess != jerr )
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    // first insert the SD into SD table
    jerr = JetPrepareUpdate(Sesid, SDtbl.JTid, JET_prepInsert);
    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    // sd_hash
    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        SDtbl,
        "sd_hash",
        md5ctx.digest,
        MD5DIGESTLEN
    );

    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    // sd_value
    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        SDtbl,
        "sd_value",
        gpDefaultSecurityDescriptor,
        gcbDefaultSecurityDescriptor
    );

    // don't need the SD anymore
    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    // no need to set sd_refcount -- defvalue is 1

    // update now
    char  bookmark[255];
    ULONG bcnt;
    jerr = JetUpdate(Sesid, SDtbl.JTid, bookmark, sizeof(bookmark), &bcnt);
    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    jerr = JetGotoBookmark(Sesid, SDtbl.JTid,bookmark,bcnt);
    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    jerr = RetrieveJetColumn(Sesid, Dbid, SDtbl, "sd_id", (PVOID)&sdId, &cbActual);
    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    // now the data table...
    jerr = JetPrepareUpdate(Sesid, Ctbl.JTid, JET_prepInsert);

    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        Ctbl,
        RDNCOLNAME,
        Name,
        (wcslen(Name)+1)*sizeof(WCHAR)
    );

    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }


    CHAR Obj=1;
    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        Ctbl,
        OBJCOLNAME,
        &Obj,
        sizeof(Obj)
    );

    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }


    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        Ctbl,
        GUIDCOLNAME,
        &guid,
        sizeof(GUID)
    );

    dsInitialObjectGuid.Data1++;

    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    // Get the instance type for this to work...
    DWORD intsttyp=IT_UNINSTANT | IT_NC_HEAD;
    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        Ctbl,
        INSTANCETYPE,
        &intsttyp,
        sizeof(intsttyp)
    );

    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    USN usn=0;
    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        Ctbl,
        USNCREATED,
        &usn,
        sizeof(usn)
    );
    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }


    DSTIME tim=0;
    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        Ctbl,
        WHENCREATED,
        &tim,
        sizeof(tim)
    );

    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    BYTE ab=0;
    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        Ctbl,
        SZISVISIBLEINAB,
        &ab,
        sizeof(ab)
    );

    ULONG  pdnt=0;
    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        Ctbl,
        SZPDNT,
        &pdnt,
        sizeof(pdnt)
    );


    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    ULONG clsid=CLASS_TOP;
    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        Ctbl,
        DASHEDCLASSKEY,
        &clsid,
        sizeof(clsid)
    );

    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        Ctbl,
        "NT-Security-Descriptor",
        (PVOID)&sdId,
        sizeof(sdId)
    );



    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }


    ULONG dnt=ROOTTAG;
    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        Ctbl,
        "Obj-Dist-Name",
        &dnt,
        sizeof(dnt)
    );


    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        Ctbl,
        SZANCESTORS,
        &dnt,
        sizeof(dnt)
    );


    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }


    ULONG ida;
    ida = 3;

    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        Ctbl,
        "DMD-Location",
        &ida,
        sizeof(ida)
    );

    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    jerr = JetUpdate(Sesid, Ctbl.JTid, bookmark, sizeof(bookmark), &bcnt);
    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    jerr = JetGotoBookmark(Sesid, Ctbl.JTid,bookmark,bcnt);
    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    ULONG len=sizeof(*pDsaDnt);
    jerr = RetrieveJetColumn(Sesid, Dbid, Ctbl, DNTCOL,pDsaDnt,&len);

    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    if (*pDsaDnt!=ROOTTAG)
    {
        printf("Root Object Not at Position %d\n",ROOTTAG);
        XINVALIDINIFILE();
    }

    jerr = JetCommitTransaction(Sesid, 0);

    if ( JET_errSuccess != jerr )
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    return jerr;
}

JET_ERR
CreateZeroDNT
(
    WCHAR*         Name,
    JET_INSTANCE  Instance,
    JET_SESID     Sesid,
    JET_DBID      Dbid,
    CREATETABLE& Ctbl,
    GUID         guid
)
{
    JET_ERR jerr;

    // Jet600 doesn't allow updates of certain data types (long values
    // like binary in particular) to be updated at transaction level 0.
    // So begin and end a transaction appropriately.

    jerr = JetBeginTransaction(Sesid);

    if ( JET_errSuccess != jerr )
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    jerr = JetPrepareUpdate(Sesid, Ctbl.JTid, JET_prepInsert);

    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        Ctbl,
        RDNCOLNAME,
        Name,
        (wcslen(Name)+1)*sizeof(WCHAR)
    );

    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    CHAR Obj=1;
    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        Ctbl,
        OBJCOLNAME,
        &Obj,
        sizeof(Obj)
    );

    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        Ctbl,
        GUIDCOLNAME,
        &guid,
        sizeof(GUID)
    );

    if (jerr!=JET_errSuccess)
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

/*
    // [rajnath]: Get the instance type for this to work...
    DWORD intsttyp=NC_MASTER;
    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        Ctbl,
        INSTANCETYPE,
        &intsttyp,
        sizeof(intsttyp)
    );

    if (jerr!=JET_errSuccess)
    {
        XINVALIDINIFILE();
    }

    USN usn=0;
    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        Ctbl,
        USNCREATED,
        &usn,
        sizeof(usn)
    );

    ULONG tim=0;
    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        Ctbl,
        WHENCREATED,
        &tim,
        sizeof(tim)
    );



    if (jerr!=JET_errSuccess)
    {
        XINVALIDINIFILE();
    }

    BYTE ab=0;
    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        Ctbl,
        SZISVISIBLEINAB,
        &ab,
        sizeof(ab)
    );



    ULONG  pdnt=0;
    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        Ctbl,
        SZPDNT,
        &pdnt,
        sizeof(pdnt)
    );


    if (jerr!=JET_errSuccess)
    {
        XINVALIDINIFILE();
    }

*/
    jerr = JetUpdate(Sesid, Ctbl.JTid, NULL, 0, 0);

    jerr = JetCommitTransaction(Sesid, 0);

    if ( JET_errSuccess != jerr )
    {
        printf("[%s] CreateRootObjects() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    return jerr;
}

JET_ERR
WriteConfigInfo
(
    JET_SESID Sesid,
    JET_DBID   Dbid,
    CREATETABLE& Ctbl,
    ULONG        DsaDnt
)
{
    JET_ERR jerr;

    // Jet600 doesn't allow updates of certain data types (long values
    // like binary in particular) to be updated at transaction level 0.
    // So begin and end a transaction appropriately.

    jerr = JetBeginTransaction(Sesid);

    if ( JET_errSuccess != jerr )
    {
        printf("[%s] WriteConfigInfo() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    jerr = JetPrepareUpdate(Sesid, Ctbl.JTid, JET_prepInsert);

    if (jerr!=JET_errSuccess)
    {
        XINVALIDINIFILE();
    }

    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        Ctbl,
        DSACOL,
        &DsaDnt,
        sizeof(DsaDnt)
    );

    if (jerr!=JET_errSuccess)
    {
        printf("[%s] WriteConfigInfo() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    ULONG state=eInitialDit;
    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        Ctbl,
        STATECOL,
        &state,
        sizeof(state)
    );

    if (jerr!=JET_errSuccess)
    {
        printf("[%s] WriteConfigInfo() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    USN usn=0;

    // USN signature
    char* cusn=(char*)&usn;
    cusn[7]='U';
    cusn[6]='S';
    cusn[5]='N';

    jerr = SetJetColumn
    (
        Sesid,
        Dbid,
        Ctbl,
        USNCOL,
        &usn,
        sizeof(USN)
    );

    if (jerr!=JET_errSuccess)
    {
        printf("[%s] WriteConfigInfo() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    jerr = JetUpdate(Sesid, Ctbl.JTid, NULL, 0, 0);

    jerr = JetCommitTransaction(Sesid, 0);

    if ( JET_errSuccess != jerr )
    {
        printf("[%s] WriteConfigInfo() Failed. Error %d\n",__FILE__,jerr);
        XINVALIDINIFILE();
    }

    return jerr;
}

JET_ERR
RetrieveJetColumn
(
    JET_SESID     Sesid,
    JET_DBID      Dbid,
    CREATETABLE& Ctbl,
    char*         ColName,
    PVOID         pData,
    ULONG*        cbData
)
{
    JET_ERR jerr;

    //
    // Get The Columnid from Ctbl
    //

    JET_COLUMNID jcolid=0;
    for (ULONG i=0;i<Ctbl.ColCount;i++)
    {
        if (strcmp(Ctbl.ColList[i].Name,ColName)==0)
        {
            break;
        }
    }

    if (Ctbl.ColCount==i)
    {
        return JET_errColumnNotFound;
    }

    jcolid = Ctbl.ColList[i].JColId;

    jerr= JetRetrieveColumn
    (
        Sesid,
        Ctbl.JTid,
            jcolid,
        pData,
        *cbData,
        cbData,
        0,NULL
    );

    return jerr;
}

JET_ERR
SetJetColumn
(
    JET_SESID     Sesid,
    JET_DBID      Dbid,
    CREATETABLE& Ctbl,
    char*         ColName,
    PVOID         pData,
    ULONG         cbData
)
{
    JET_ERR jerr;

    //
    // Get The Columnid from Ctbl
    //

    JET_COLUMNID jcolid=0;
    for (ULONG i=0;i<Ctbl.ColCount;i++)
    {
        if (strcmp(Ctbl.ColList[i].Name,ColName)==0)
        {
            break;
        }
    }

    if (Ctbl.ColCount==i)
    {
        return JET_errColumnNotFound;
    }

    jcolid = Ctbl.ColList[i].JColId;

    jerr= JetSetColumn
    (
        Sesid,
        Ctbl.JTid,
            jcolid,
        pData,
        cbData,
        0,NULL
    );


    return jerr;
}




JET_ERR
CreateJetDatabaseStructure
(
    char* DBName,
    ULONG TableCount,
    CREATETABLE* CTable,
    JET_INSTANCE *pInstance,
    JET_SESID    *pSesid,
    JET_DBID     *pDbid
)
{
    JET_ERR    jerr    =NULL;
    ULONG      Grbit;
    DWORD      defVal;
    ULONG      cDefVal;
    VOID       *pDefVal;
    JET_INDEXCREATE JetIndexData;
    JET_UNICODEINDEX JetUnicodeIndexData;

    remove(DBName);

    JetSetSystemParameter
    (
        pInstance,
        0,
        JET_paramRecovery,
            0,
        "Off"
    );

    JetSetSystemParameter
    (
        pInstance,
        0,
        JET_paramDatabasePageSize,
        (8 * 1024),
        NULL
    );

    jerr = JetInit(pInstance);

    if (jerr!= JET_errSuccess)
    {
        printf("[%s:%d]\n\tJetInit() returned %d\n",
               __FILE__,
               __LINE__,
               jerr);
        XRAISEGENEXCEPTION(jerr);
    }

    jerr = JetBeginSession
    (
        *pInstance,
        pSesid,
        NULL,
        NULL
    );

    if (jerr!= JET_errSuccess)
    {
        printf("[%s:%d]\n\tJetBeginSession() returned %d\n",
               __FILE__,
               __LINE__,
               jerr);

        XRAISEGENEXCEPTION(jerr);
    }


    jerr=JetCreateDatabase(*pSesid, DBName, "", pDbid, 0);

    if (jerr!= JET_errSuccess)
    {
        printf("[%s:%d]\n\tJetCreateDatabase() returned %d\n",
               __FILE__,
               __LINE__,
               jerr);
        printf("-- Odds are this means that %%SystemRoot%%\\ntds doesn't exist\n");
        XRAISEGENEXCEPTION(jerr);
    }

    for (ULONG i=0;i<TableCount;i++)
    {
        //
        // Create The table
        //
        printf("NTDS:Phase0Init -- Creating Col & Ndx For Table %s!!!\n",CTable[i].Name);
        jerr = JetCreateTable
          (
           *pSesid,
           *pDbid,
           CTable[i].Name,
           CTable[i].Pages,
           CTable[i].Density,
           &CTable[i].JTid
           );

        if (jerr!= JET_errSuccess)
        {
            printf("[%s:%d]\n\tJetCreateTable(%s) returned %d\n",
                   __FILE__,
                   __LINE__,
                   CTable[i].Name,
                   jerr);
            XRAISEGENEXCEPTION(jerr);
        }

        //
        // Create the Columns
        //
        for (ULONG j=0;j<CTable[i].ColCount;j++)
        {

            if ( CTable[i].ColList[j].JColDef.grbit & JET_bitColumnEscrowUpdate )
            {
                // At present, cnt_col, ab_cnt_col and sdrefcount_col are the only escrowed
                // columns and we know what their initial value should be.  We'd
                // need a new keyword:value pair in schema.ini if escrowed
                // columns were to be made generally available.
                if(!_stricmp("cnt_col", CTable[i].ColList[j].Name)) {
                    defVal = 1;
                }
                else if(!_stricmp("ab_cnt_col", CTable[i].ColList[j].Name)) {
                    defVal = 0;
                }
                else if(!_stricmp("sd_refcount", CTable[i].ColList[j].Name)) {
                    defVal = 1;
                }
                else {
                    // unknown escrowed update column
                    printf("[%s:%d] Column %s marked as escrowed, but we don't"
                           " know the default valuerror No such Str\n",
                           __FILE__,__LINE__, CTable[i].ColList[j].Name);
                        XINVALIDINIFILE();
                }
                cDefVal = sizeof(defVal);
                pDefVal = (VOID *) &defVal;
            }
            else
            {
                cDefVal = 0;
                pDefVal = NULL;
            }

            jerr = JetAddColumn
            (
                *pSesid,
                CTable[i].JTid,
                CTable[i].ColList[j].JAlias,
                &CTable[i].ColList[j].JColDef,
                pDefVal,
                cDefVal,
                &CTable[i].ColList[j].JColId
            );

            if (jerr!= JET_errSuccess)
            {
                printf("[%s:%d]\n\tJetAddColumn(%s[%s]) returned %d\n",
                       __FILE__,
                       __LINE__,
                       CTable[i].ColList[j].Name,
                       CTable[i].ColList[j].JAlias,
                       jerr);
                XRAISEGENEXCEPTION(jerr);
            }
        }

        for (j=0;j<CTable[i].NdxCount;j++)
        {
            // In Jet600, JET_bitIndexClustered has been removed.  What were
            // previously clustered indexes must now be replaced with a
            // primary index (ie. JET_bitIndexPrimary).  A primary index is
            // now defined as any unique index on which you wish to cluster
            // (in contrast to previous versions of Jet, where primary indexes
            // did not allow NULL values and you did not have to cluster on
            // the primary index).  There can and must be only one primary
            // index per table (if you don't specify one, one will be created
            // for you)  For best performance, do not choose a primary index
            // where the keys generated become excessively long.

            Grbit = CTable[i].NdxList[j].Grbit;

            // Rather than make schema.ini conditional on the JET600 flag, we
            // just map JET_bitIndexClustered to JET_bitIndexPrimary.

            if ( JET_bitIndexClustered & Grbit )
            {
                Grbit &= ~JET_bitIndexClustered;
                Grbit |= JET_bitIndexPrimary;
            }

            memset(&JetIndexData, 0, sizeof(JetIndexData));
            JetIndexData.cbStruct = sizeof(JetIndexData);
            JetIndexData.szIndexName = CTable[i].NdxList[j].JAlias;
            JetIndexData.szKey = CTable[i].NdxList[j].Key;
            JetIndexData.cbKey= CTable[i].NdxList[j].KeyLen;
            JetIndexData.grbit = (Grbit | JET_bitIndexUnicode);
            JetIndexData.ulDensity = CTable[i].NdxList[j].Density;
            JetIndexData.pidxunicode = &JetUnicodeIndexData;

            memset(&JetUnicodeIndexData, 0, sizeof(JetUnicodeIndexData));
            JetUnicodeIndexData.lcid = DS_DEFAULT_LOCALE;
            JetUnicodeIndexData.dwMapFlags = (DS_DEFAULT_LOCALE_COMPARE_FLAGS |
                                              LCMAP_SORTKEY);


            jerr = JetCreateIndex2(*pSesid,
                                   CTable[i].JTid,
                                   &JetIndexData,
                                   1);

            if (jerr!= JET_errSuccess)
            {
                printf("[%s:%d]\n\tJetCreateIndex(%s) returned %d\n",
                       __FILE__,
                       __LINE__,
                       CTable[i].NdxList[j].Name,
                       jerr);
                XRAISEGENEXCEPTION(jerr);
            }
        }

    }

    return jerr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\ldap\userdata.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    userdata.cxx

Abstract:

    This module implements the LDAP server for the NT5 Directory Service.

    This file contains the per connection user information which is
    implemented in the LDAP_CONN class. The code which processes each
    individual command is in command.cxx.

Author:

    Colin Watson     [ColinW]    23-Jul-1996

Revision History:

--*/

#include <NTDSpchx.h>
#pragma  hdrstop

#include "ldapsvr.hxx"
extern "C" {
#include <schnlsp.h>
#include <dstrace.h>
}

#define  FILENO FILENO_LDAP_USER


LDAPString DisconnectNotifyName=DEFINE_LDAP_STRING("1.3.6.1.4.1.1466.20036");
//
// The following strings are used in a DisconnectNotify message when either 
// the threadstate hasn't been created yet, and therefore SetLdapError won't work,
// or when the error indicates there is not enough memory so allocating a new
// string is not an option.
//
LDAPString OutOfMemoryError =
 DEFINE_LDAP_STRING("Insufficient resources available to process this command");
LDAPString ContextExpiredError = 
 DEFINE_LDAP_STRING("The server has timed out this connection");
LDAPString ServerShuttingDownError = 
 DEFINE_LDAP_STRING("The server is shutting down");

LDAPString NullMessage = {0,(PUCHAR)""};
DWORD GlobalClientCounter = 0;

//
// Cached LDAP_CONN objects
//

LIST_ENTRY  LdapConnFreeList;
    

LDAP_CONN::LDAP_CONN( VOID)
/*++
  This function creates a new UserData object for the information
    required to process requests from a new User connection.

  Returns:
     a newly constructed LDAP_CONN object.

--*/
{

    Reset( );

    //
    // Set up the default commarg for this session
    //

    InitializeListHead(&m_requestList);
    InitializeListHead( &m_listEntry);
    if ( !InitializeCriticalSectionAndSpinCount(&m_csLock, LDAP_SPIN_COUNT)) {

        m_State = BlockStateInvalid;

        DPRINT1(0,"Unable to initialize csLock critical section [err %d]\n", GetLastError());
        return;
    }

    if ( !InitializeCriticalSectionAndSpinCount(&m_csClientContext, LDAP_SPIN_COUNT)) {

        m_State = BlockStateInvalid;

        DPRINT1(0,"Unable to initialize csClientContext critical section [err %d]\n", GetLastError());
        return;
    }
    
    //
    // built in request object should not be cached
    //

    m_requestObject.m_fAllocated = FALSE;

    IF_DEBUG(CONN) {
        DPRINT1(0,"LDAP_CONN object created  @ %08lX.\n", this);
    }

} // LDAP_CONN::LDAP_CONN()


LDAP_CONN::~LDAP_CONN(VOID)
{

    IF_DEBUG(CONN) {
        DPRINT1(0,"Delete LDAP_CONN object @ %08lX.\n", this);
    }

    Assert(IsListEmpty(&m_requestList));

    Cleanup();
    DeleteCriticalSection( &m_csLock );
    DeleteCriticalSection( &m_csClientContext );

} // LDAP_CONN::~LDAP_CONN()


VOID
LDAP_CONN::Reset(
            VOID
            )
{
    m_signature         = SIGN_LDAP_CONN_FREE;
    m_request           = NULL;
    m_fInitRecv         = FALSE;
    m_RefCount          = 0;
    m_Version           = 3;
    m_endofrequest      = 0xEEEE;
    m_State             = BlockStateClosed;
    m_ClientNumber      = 0;
    m_nTotalRequests    = 0;
    m_userName          = NULL;

    m_CallState         = inactive;
    m_nRequests         = 0;
    m_CodePage          = CP_UTF8;
    m_countNotifies     = 0;

    InitializeListHead( &m_CookieList );
    m_CookieCount       = 0;

    m_atqContext        = NULL;

    m_dwClientID        = dsGetClientID();
    m_Notifications     = NULL;

    m_pSecurityContext  = NULL;
    m_pPartialSecContext= NULL;
    m_clientContext     = NULL;
    
    m_SslState          = Sslunbound;
    m_cipherStrength    = 0;

    m_softExpiry.QuadPart = MAXLONGLONG;
    m_hardExpiry.QuadPart = MAXLONGLONG;

    m_dwStartTime       = 0;
    m_dwTotalBindTime   = 0;
    
    m_fFastBindMode     = FALSE;

    m_fSign             = FALSE;
    m_fSeal             = FALSE;
    m_fSimple           = FALSE;
    m_fGssApi           = FALSE;
    m_fSpNego           = FALSE;
    m_fDigest           = FALSE;
    m_fUserNameSecAlloc = FALSE;

    m_fCanScatterGather = TRUE;
    m_fNeedsHeader      = FALSE;
    m_fNeedsTrailer     = FALSE;
    m_HeaderSize        = 0;
    m_TrailerSize       = 0;

    m_lastRequestStartTime  = 0;
    m_lastRequestFinishTime = 0;
    m_bIsAdmin              = FALSE;

    ZeroMemory(&m_RemoteSocket, sizeof(m_RemoteSocket));

} // LDAP_CONN::Reset


BOOL
LDAP_CONN::Init(IN PLDAP_ENDPOINT LdapEndpoint,
                IN SOCKADDR     *psockAddrRemote    /* = NULL */ ,
                IN PATQ_CONTEXT pNewAtqContext      /* = NULL */ ,
                IN DWORD        cbWritten
                )
{
    PCHAR        pcTmpAddrStr;
    SOCKADDR_IN  *pSockInet = (SOCKADDR_IN *) psockAddrRemote;
    LDAP_CONNECTION_TYPE ldapServiceType =
                (LDAP_CONNECTION_TYPE)LdapEndpoint->ConnectionType;

    Assert(ldapServiceType >= LdapTcpType);
    Assert(ldapServiceType <=  MaxLdapType);

    GetSystemTimeAsFileTime(&m_connectTime);

    m_atqContext = pNewAtqContext;

    if(NULL != psockAddrRemote  &&
       NULL != (pcTmpAddrStr = inet_ntoa(pSockInet->sin_addr))) {
        m_RemoteSocket = *psockAddrRemote;
        strcpy((char *)m_RemoteSocketString, pcTmpAddrStr);
    } else {
        ZeroMemory(&m_RemoteSocket, sizeof(m_RemoteSocket));
        m_RemoteSocketString[0] = '\0';
    }

    //
    // Is this SSL?
    //

    m_fUDP = FALSE;
    m_fSSL = FALSE;
    m_fTLS = FALSE;
    m_fGC  = FALSE;
    m_fUsingSSLCreds = FALSE;

    if ( ldapServiceType == LdapUdpType ) {
        m_fUDP = TRUE;
    } else if ( ldapServiceType == GcTcpType ) {
        m_fGC = TRUE;
    } else if ( ldapServiceType == GcSslType ) {
        m_fSSL = TRUE;
        m_fGC = TRUE;
    } else if ( ldapServiceType == LdapSslType ) {
        m_fSSL = TRUE;
    } else {
        Assert( ldapServiceType == LdapTcpType );
    }
    if (m_fSSL) {
        PERFINC(pcLdapSSLConnsPerSec);
    }

    SetNetBufOpts(NULL);

    // If this is a UDP connection it will be too short
    // lived to make much use of the m_MsgIds buffer anyway.
    if (!m_fUDP) {
        ZeroMemory(m_MsgIds, sizeof(m_MsgIds));
        m_MsgIdsPos = 0;
    }
    //
    // if this is ssl, try to get a cert
    //

    if ( m_fSSL && !InitializeSSL() ) {
        IF_DEBUG(ERR_NORMAL) {
            DPRINT(0,"No Cert. Rejecting SSL connection\n");
        }
        return FALSE;
    }

    //
    //  Set the context so that all calls to LdapCompletionRoutine
    //  have context pointing to the appropriate LDAP_CONN object.
    //

    AtqContextSetInfo(pNewAtqContext,
                      ATQ_INFO_COMPLETION_CONTEXT,
                      (DWORD_PTR)this);

    m_request = &m_requestObject;
    m_request->Init(pNewAtqContext,this);

    if ( cbWritten == 0 ) {

        //
        //  This is a connect with no data. Allocate the request and start
        //  a receive.
        //

        if (!m_request->PostReceive()) {

            DereferenceAndKillRequest(m_request);

            LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                     DS_EVENT_SEV_BASIC,
                     DIRLOG_ATQ_CLOSE_SOCKET_ERROR,
                     szInsertUL(GetLastError()),
                     szInsertHex(DSID(FILENO,__LINE__)),
                     szInsertUL(m_dwClientID));
            return FALSE;
        }
    }
    return TRUE;

} // LDAP_CONN::Init



VOID
LDAP_CONN::Cleanup( VOID)
/*++
  This cleans up data in the user data object.

 Returns:
    None

--*/
{
    PLDAP_NOTIFICATION pBack = NULL;
    NOTIFYRES         *pNotifyRes;
    BOOL               bFreeThreadState = FALSE;
    BOOL               bCallDeregister = TRUE;

    if (m_atqContext != NULL) {
        AtqFreeContext(m_atqContext,TRUE);
        m_atqContext = NULL;
    }

    (VOID)FreeAllPagedBlobs(this);

    if(m_Notifications) {

        // Need to deregister some notifications


        // Need a thread state to do this
        if(!pTHStls) {
            // Create a thread state.
            if (!InitTHSTATE(CALLERTYPE_LDAP)) {
                DPRINT(0, "Unable to allocate DS threadstate!\n");

                // Well, we won't call the deregister, but we still need to
                // call the free()
                bCallDeregister = FALSE;
            } else {

                // We created a thread state, so we should kill it.
                bFreeThreadState = TRUE;
            }
        }

        // Deregister and free any notifications
        IF_DEBUG(NOTIFICATION) {
            DPRINT(0,"Running down notifications on connection cleanup.\n");
        }

        while(m_Notifications) {
            pNotifyRes = NULL;
            pBack = m_Notifications;
            if(bCallDeregister) {
                IF_DEBUG(NOTIFICATION) {
                    DPRINT1(0,"Calling DirNotifyUnregister on %p\n", m_Notifications);
                }

                DirNotifyUnRegister( m_Notifications->hServer, &pNotifyRes);
            }
            m_Notifications = m_Notifications->pNext;
            LdapFree(pBack);
        }

        if(bFreeThreadState) {
            free_thread_state();
        }
    }

    //
    // If we have a security context, we don't want it.
    //

    ZapSecurityContext();

    // if we have a client context, we don't want it
    EnterCriticalSection(&m_csClientContext);
    __try {
        AssignAuthzClientContext(&m_clientContext, NULL);
    }
    __finally {
        LeaveCriticalSection(&m_csClientContext);
    }
    
    // also, clear the thread state
    THSTATE *pTHS = pTHStls;
    if (pTHS) {
        AssignAuthzClientContext(&pTHS->pAuthzCC, NULL);
    }

    //
    // if this is an SSL context, free it.
    //

    ZapSSLSecurityContext();

    //
    // Free the user name
    //

    if ( m_userName != NULL ) {
        if ( m_fUserNameSecAlloc) {
            FreeContextBuffer(m_userName);
        } else {
            LocalFree(m_userName);
        }
        m_userName = NULL;
    }

    return;

} // LDAP_CONN::Cleanup()



VOID
LDAP_CONN::IoCompletion(
                   IN PVOID pvContext,
                   IN PUCHAR pbBuffer,
                   IN DWORD cbWritten,
                   IN DWORD hrCompletionStatus,
                   IN OVERLAPPED *lpo,
                   IN LARGE_INTEGER *StartTickLarge
                   )
/*++

Routine Description:

    This routine will be called to process received data, send completions,
    the data received with a connect and error indications.

Arguments:

    pvContext   - Atq context object.

    pbBuffer    - Data transferred.

    cbWritten   - Number of bytes transferred.

    hrCompletionStatus - Final completion status of operation.

    lpo         - lpOverlapped associated with request.

Return Value:

    None.

--*/
{
    PATQ_CONTEXT patqContext = (PATQ_CONTEXT) pvContext;
    BOOL fResponseSent;

    IF_DEBUG(IO) {
        DPRINT4(0, "IoCompletion %08lx, lpo=%08lx, bytes=%d, status=%d\n",
            this, lpo, cbWritten, hrCompletionStatus);
    }

    if ((cbWritten == 0) && (hrCompletionStatus == NO_ERROR)) {

        PLDAP_REQUEST request;

        //
        //  Connection has dropped. Record it if necessary and wait for the
        //  reference count to drop to zero.
        //
        //  Note: Atq allows multiple closes on the same context. The socket
        //  will only be closed once.
        //

        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                 DS_EVENT_SEV_EXTENSIVE,
                 DIRLOG_ATQ_CLOSE_SOCKET_OK,
                 szInsertHex(DSID(FILENO,__LINE__)),
                 NULL,
                 NULL);

        Disconnect( );

        if (lpo != &m_atqContext->Overlapped) {

            //
            //  Write completion
            //

            request = CONTAINING_RECORD(lpo,LDAP_REQUEST,m_ov);
        } else {
            request = m_request;
        }

        request->DereferenceRequest( );
        DereferenceAndKillRequest(request);

    } else if ( (lpo == NULL) && (hrCompletionStatus == NO_ERROR) ) {

        //
        // Datagram
        //

        Assert(m_request != NULL);
        Assert(cbWritten != 0);
        Assert(m_fUDP);

        if ( m_request->ReceivedClientData(cbWritten,pbBuffer) ==
                SEC_E_INCOMPLETE_MESSAGE) {
            // !!!
            return;
        }

        m_request->m_StartTick = *StartTickLarge;
        ProcessRequest(m_request, &fResponseSent);

        //
        // If no response was sent, disconnect.
        //

        if ( !fResponseSent ) {
            Disconnect( );
        }
        return;

    } else {

        if (lpo != &m_atqContext->Overlapped) {

            PLDAP_REQUEST request = CONTAINING_RECORD(lpo,
                                                      LDAP_REQUEST,
                                                      m_ov);

            IF_DEBUG(IO) {
                DPRINT1(0,"Write completion on request %x\n",request);
            }

            //
            //  Write completion
            //

            request->DereferenceRequest( );
            if ( hrCompletionStatus == NO_ERROR ) {

                IF_DEBUG(IO) {
                    DPRINT1( 0, "AtqWriteFile complete @ %08lX.\n", request);
                }

                //
                //  The client can send multiple requests in the same
                //  packet. This is where we process the follow on request.
                //

                if (request->AnyBufferedData()) {
                    IF_DEBUG(IO) {
                        DPRINT(0, "Write completion with more buffer to process.\n");
                    }

                    Assert(request == m_request);

                    //
                    //  Avoid resending the same data again
                    //

                    request->ResetSend();
                    request->m_StartTick = *StartTickLarge;
                    ProcessRequest( request, &fResponseSent );
                } else {

                    IF_DEBUG(IO) {
                        DPRINT(0,"Write completion with no more buffer.\n");
                    }

                    if ( request == m_request ) {
                        DPRINT1(0,"LDAPIoCompletion: request[%x]==m_request\n", 
                                request);
                    }
                    DereferenceAndKillRequest(request);
                }
            } else {

                IF_DEBUG(ERROR) {
                    DPRINT2(0,"Failed write completion, status = 0x%x, substatus = 0x%x\n",
                            hrCompletionStatus,
                            lpo->Internal);
                }         
                
                Disconnect( );
                DereferenceAndKillRequest(request);
                goto error;
            }

        } else {

            IF_DEBUG(IO) {
                DPRINT1(0,"Got a read completion on request %x\n",m_request);
            }

            //
            //  Read completion
            //

            m_request->DereferenceRequest();
            if ( hrCompletionStatus == NO_ERROR ) {

                m_request->ReceivedClientData(cbWritten);
                m_request->m_StartTick = *StartTickLarge;
                ProcessRequest( m_request, &fResponseSent );
            } else {

                IF_DEBUG(ERROR) {
                    DPRINT2(0, "Read failed, status = 0x%x, substatus = 0x%x\n",
                            hrCompletionStatus,
                            lpo->Internal);
                }

                Disconnect( );
                DereferenceAndKillRequest(m_request);
                goto error;
            }
        }
    }

    return;

error:

    if ( hrCompletionStatus == ERROR_NETNAME_DELETED ) {

        //
        // TCP-IP pipe broke (often because client app quit without
        // shutting down pipe.)
        //

        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_ATQ_CLOSE_SOCKET_CONTACT_LOST,
                 szInsertHex(DSID(FILENO,__LINE__)),
                 NULL,
                 NULL);
    } else {

        //
        // tear down connection when all writes finish.
        //

        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_ATQ_CLOSE_SOCKET_ERROR,
                 szInsertUL(hrCompletionStatus),
                 szInsertHex(DSID(FILENO,__LINE__)),
                 szInsertUL(m_dwClientID));

    }

    return;

} // LDAP_CONN::IoCompletion


//
// Some useful macros, just for this routine
//

#define SetReturnValue(X,Y,Z,A)                              \
            {                                                \
               m.protocolOp.choice = X##_chosen;             \
               m.protocolOp.u.X.bit_mask = 0;                \
               m.protocolOp.u.X.resultCode = Y;              \
               m.protocolOp.u.X.errorMessage = A;            \
               m.protocolOp.u.X.matchedDN = Z;               \
            }

#define SetReferralValue(X,Y)                                  \
            {                                                  \
                switch(m_Version) {                            \
                case 2:                                        \
                    m.protocolOp.u.X.errorMessage = Y->value;  \
                        break;                                 \
                default:                                       \
                    m.protocolOp.u.X.bit_mask |=               \
                        LDAPResult_referral_present;           \
                    m.protocolOp.u.X.LDAPResult_referral= Y;   \
                }                                              \
             }

VOID
LDAP_CONN::ProcessRequest(
    IN PLDAP_REQUEST request,
    IN PBOOL fResponseSent
    )
/*++

Routine Description:

    This routine will be called to process received data.

Arguments:

    request     - Object used to track this transaction.
    fResponseSent - Did we send a response back?

Return Value:

    ZERO if the LDAP_CONN object must be deleted by the caller.

--*/
{
    LDAPMsg*    pMessage = NULL;
    LDAPMsg     message;

    int         rc = ERROR_SUCCESS;
    DecryptReturnValues Decryptrc = Processed;

    UINT        retryCount;
    UINT        messageID=0;
    UINT        choice;
    UINT        length=0;
    Referral    pReferral=NULL;
    Controls    pControls=NULL;
    LDAPDN      MatchedDN={0,NULL};
    LDAPString  ErrorMessage={0,NULL};
    LDAPString  ExtendedResponse={0,NULL};
    LDAPOID     ResponseName={0,NULL};
    BOOL        bSkipSearchResponse=FALSE;
    LDAP_SECURITY_CONTEXT *pLocalSecContext = NULL;
    CtxtHandle            *phSecurityContext;
    DWORD       errorLine=0;
    BOOL        fDontLog = FALSE;
    ULONGLONG   tmpBuffer[64];
    BOOL        resultNotEncoded = TRUE;
    THSTATE     *pTHS=NULL;
    DWORD       error;
    BOOL        fWMIEventOn = FALSE;
    MessageID   MsgID = 0;
    DWORD       dwActualSize = 0;
    DWORD       dwActualSealedSize = 0;
    RootDseFlags DseFlag = rdseNonDse;
    BOOL        fFastBind = FALSE;
    
    //
    // Variables we need for sending back the return code from the calls
    // below.
    //

    LDAPMsg m;
    _enum1  code= success;

    //
    //  Ensure this thread is initialized properly for the Oss routines
    //

    *fResponseSent = FALSE;

    if (eServiceShutdown) {
        rc = ERROR_SHUTDOWN_IN_PROGRESS;
        errorLine = DSID(FILENO, __LINE__);
        ErrorMessage = ServerShuttingDownError;
        code = unavailable;
        goto Abandon;
    }

    //
    // check if the context has expired. 
    //

    if ( IsContextExpired(&m_softExpiry, &m_timeNow) ) {

        IF_DEBUG(WARNING) {
            DPRINT1(0,"Context has expired for connection %p. Disconnecting.\n",
                     this);
        }

        rc = SEC_E_CONTEXT_EXPIRED;
        errorLine = DSID(FILENO, __LINE__);
        ErrorMessage = ContextExpiredError;
        code = unavailable;
        fDontLog = TRUE;
        goto Abandon;
    }

    // Create a thread state.
    if (!(pTHS = InitTHSTATE(CALLERTYPE_LDAP))) {
        IF_DEBUG(ERROR) {
            DPRINT(0, "Unable to allocate DS threadstate!\n");
        }
        rc = ERROR_NO_SYSTEM_RESOURCES;
        errorLine = DSID(FILENO, __LINE__);
        ErrorMessage = OutOfMemoryError;
        code = unavailable;
        goto Abandon;
    }

    //
    // Set the connection as the client context
    //

    pTHS->ClientContext = GetClientNumber();

    //
    //  Note sharing private data with ssl.
    //

    if ( request->HaveSealedData() ) {
        if ( IsSSLOrTLS() ) {
            Decryptrc = request->DecryptSSL( );
        } else {
            Decryptrc = request->DecryptSignedOrSealedMessage(&dwActualSealedSize);
            if (NeedMoreInput == Decryptrc) {
                dwActualSize = dwActualSealedSize;
            }
        }
    } 

    if (Decryptrc != Processed) {

        if (Decryptrc == NeedMoreInput) {

            rc = MORE_INPUT;    //  Fall through to normal code path.

        } else if (Decryptrc == ResponseSent) {

            if (request->UnencryptedDataAvailable() == 0) {

                //
                //  We sent a response, read next part of negotiation
                //

                m_request = LDAP_REQUEST::Alloc(m_atqContext,this);
                if (m_request == NULL) {
                    IF_DEBUG(NOMEM) {
                        DPRINT1(0, "Unable to create REQUEST for SSL negotiate\n",
                                GetLastError());
                    }
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    errorLine = DSID(FILENO, __LINE__);
                    ErrorMessage = OutOfMemoryError;
                    goto Abandon;
                }

                IF_DEBUG(SSL) {
                    DPRINT1(0, "Starting a receive for negotiation[req %x].\n",
                       m_request);
                }

                if (!m_request->PostReceive()) {
                    DereferenceAndKillRequest(m_request);
                    rc = GetLastError();
                    errorLine = DSID(FILENO, __LINE__);
                    code = SetLdapError(unavailable,
                                        rc,
                                        LdapNetworkError,
                                        0,
                                        &ErrorMessage);

                    goto Abandon;
                }
            } // else there is more data in the input buffer to process
            // after the send is complete.
            else {
                IF_DEBUG(SSL) {
                    DPRINT(0,
                     "Not starting a receive, we better get a write completion.\n");
                }
            }
            free_thread_state();
            return;

        } else {
            errorLine = DSID(FILENO,__LINE__);
            rc = Decryptrc;
            code = SetLdapError(unavailable,
                                rc,
                                LdapDecryptFailed,
                                0,
                                &ErrorMessage);
            
            goto Abandon;
        }
    } else {
        rc = 0;
    }

    BERVAL bv;
    bv.bv_len = request->UnencryptedDataAvailable();
    bv.bv_val = (PCHAR)request->m_pReceiveBuffer;
    
    if ( rc == 0 ) {
        BERVAL blob;
        blob.bv_len = sizeof(tmpBuffer);
        blob.bv_val = (PCHAR)tmpBuffer;

        rc = DecodeLdapRequest(&bv, &message, &blob, &dwActualSize, &error, &errorLine);
        if ( rc == ERROR_SUCCESS ) {
            pMessage = &message;
        } else if ( rc == ERROR_INSUFFICIENT_BUFFER ) {
            rc = MORE_INPUT;
            if (IsSSLOrTLS()) {
                // In this case the size returned is the size of the request,
                // and not the size of the network data that is required to 
                // decrypt a whole request.  Reset the size to zero so that 
                // GrowReceive can't make any bad assumptions.
                dwActualSize = 0;
            } else if (IsSignSeal()) {
                //
                // DecryptSignedOrSealedMessage may have already returned to us
                // the total buffer size needed so use that if it's there.
                //
                dwActualSize = dwActualSealedSize;
            }
        }
    }

    if (rc == MORE_INPUT) {

        //
        // We need more data, the packet didn't contain the entire LDAP
        // request.
        //

        if(m_fUDP) {

            //
            // UDP requests have to be entirely in one packet.
            //

            LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                     DS_EVENT_SEV_BASIC,
                     DIRLOG_ATQ_MULTI_PACKET_UDP,
                     szInsertUL(bv.bv_len),
                     NULL,
                     NULL);
            errorLine = DSID(FILENO,__LINE__);
            rc = ERROR_BAD_LENGTH;

        } else if (request->GrowReceive(dwActualSize)) {

            //
            // We're not UDP (where requests have to be entirely in one
            // packet) and we can grow the receive buffer to get more data.
            //

            Assert(request == m_request);

            IF_DEBUG(IO) {
                DPRINT1(0,"More input for request %x\n",m_request);
            }

            if (!m_request->PostReceive()) {
                errorLine = DSID(FILENO,__LINE__);
                rc = GetLastError();
                code = SetLdapError(unavailable,
                                    rc,
                                    LdapNetworkError,
                                    0,
                                    &ErrorMessage);
                
                goto Abandon;
            }

            free_thread_state();

            //
            //  We know that this thread should not delete this so
            //  return any non-zero value. Do not use QueryReference
            //  since we can have a race between this thread and
            //  the AtqReadFile we just started.
            //

            return;

        } else {
            IF_DEBUG(NOMEM) {
                DPRINT(0, "Unable to grow request\n");
            }
            errorLine = DSID(FILENO,__LINE__);
            rc = ERROR_NOT_ENOUGH_MEMORY;
            code = SetLdapError(unavailable,
                                rc,
                                LdapServerResourcesLow,
                                0,
                                &ErrorMessage);
            
        }

        goto Abandon;

    } else if ( rc != ERROR_SUCCESS ) {

        IF_DEBUG(WARNING) {
            DPRINT1(0, "Decoding LDAPMsg failed with return code = %d\n", rc);
        }
        code = DoSetLdapError(protocolError,
                            rc,
                            error,
                            0,
                            errorLine,
                            &ErrorMessage);
        
        goto Abandon;
    }


    //
    // Set up some locals
    //

    messageID = pMessage->messageID;
    choice = pMessage->protocolOp.choice;
    length = request->UnencryptedDataAvailable() - bv.bv_len;

        
    Assert(rc == 0); // We should have returned by now if rc is set.

    //
    // Either we decoded correctly or we failed to decode correctly but we
    // managed to decode enough to send back a protocol error.
    //

    ZeroMemory( &m, sizeof(LDAPMsg));

    //
    //  Read completed.
    //

    IF_DEBUG(IO) {
        DPRINT2(0, "Process Message @ %08lx type %d\n", messageID, choice );
    }

    //
    //  Move pointers on to account for the decoded data
    //

    request->ShrinkReceive( length );

    if(!m_fUDP) {

        if (choice != unbindRequest_chosen) {

            if ( !request->AnyBufferedData()) {

                //
                //  We have processed all the data received so far, put
                //  down a read for next set of LDAP operations.
                //

                m_request = LDAP_REQUEST::Alloc(m_atqContext,this);
                if ( m_request == NULL ) {
                    IF_DEBUG(NOMEM) {
                        DPRINT(0,"Unable to create request\n");
                    }

                    errorLine = DSID(FILENO,__LINE__);
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    ErrorMessage = OutOfMemoryError;
                    code = unavailable;
                    goto Abandon;
                }

                if (!m_request->PostReceive()) {
                    DereferenceAndKillRequest(m_request);
                    errorLine = DSID(FILENO,__LINE__);
                    rc = GetLastError();
                    code = SetLdapError(unavailable,
                                        rc,
                                        LdapNetworkError,
                                        0,
                                        &ErrorMessage);
                    goto Abandon;
                }

            } else {
                IF_DEBUG(IO) {
                    DPRINT(0, "Not starting a receive, we better get a write completion.\n");
                }
            }

        } else {

            //
            //  Special case unbind since there is no read to put down.
            //

            errorLine = DSID(FILENO,__LINE__);
            rc = ERROR_VC_DISCONNECTED;
            fDontLog = TRUE;
            goto Abandon;
        }
    } else {

        //
        // only search and abandon allowed for UDP. We can't send a response
        // since the responses for the other commands are not defined for
        // UDP.
        //

        if ( (choice != searchRequest_chosen) &&
             (choice != abandonRequest_chosen) ) {

            IF_DEBUG(WARNING) {
                DPRINT1(0,"LDAP: Illegal datagram operation[%d]\n",
                        choice);
            }
            fDontLog = TRUE;
            goto Abandon;
        }
    }

    request->m_MessageId = messageID;

    if(pMessage == NULL) {

        //
        // We don't actually have a message, which means the decode
        // above failed and we are only going through here to create an
        // error.
        //

        code = SetLdapError(protocolError,
                            ERROR_DS_DECODING_ERROR,
                            LdapDecodeError,
                            0,
                            &ErrorMessage);
    } else {
        if (choice == bindRequest_chosen) {
            //
            // PERFORMANCE: for now, if this is not a "fast bind" wrap all of 
            // bind inside this critical
            // section. It drastically serializes, but at least we know
            // our m_pSecurityContext will be safe.
            //
            
            if (IsFastBind(pMessage)) {
                fFastBind = TRUE;
            } else {        
                EnterCriticalSection(&m_csLock);
            }
        }
        __try {
            if (choice == bindRequest_chosen) {
                if ( m_countNotifies != 0 ) {
    
                    //
                    // if we have outstanding notifications, then fail this bind.
                    // The client was supposed to cancel them before doing a rebind.
                    //
    
                    IF_DEBUG(WARNING) {
                        DPRINT1(0,"%u notifications outstanding. Rejecting bind request.\n",
                                 m_countNotifies);
                    }
    
                    code = SetLdapError(unwillingToPerform,
                                        ERROR_DS_UNWILLING_TO_PERFORM,
                                        LdapNoRebindOnActiveNotifications,
                                        0,
                                        &ErrorMessage);
                    __leave;
    
                } else if (m_CallState != inactive) {
                    IF_DEBUG(WARNING) {
                        DPRINT(0,"Already in a bind CallState. Rejecting bind request.\n");
                    }
                    code = SetLdapError(busy,
                                        ERROR_DS_ADMIN_LIMIT_EXCEEDED,
                                        LdapBindAllowOne,
                                        0,
                                        &ErrorMessage);
                    __leave;
                }
                
                if (!fFastBind) {
                    m_CallState = activeBind;
                }
                
                // if we have a client context, we can't keep it around any longer 
                // since we are binding.
                EnterCriticalSection(&m_csClientContext);
                __try {
                    AssignAuthzClientContext(&m_clientContext, NULL);
                }
                __finally {
                    LeaveCriticalSection(&m_csClientContext);
                }
            }
    
            // Grab the security context we're going to use for this call.
            // We grab because another thread doing a bind could change the
            // value of m_pSecurityContext (but only one other thread, binds
            // are mutually exclusive).
    
            pLocalSecContext = m_pSecurityContext;
            if(pLocalSecContext) {
                phSecurityContext = pLocalSecContext->GetSecurityContext();
    
            }
            else {
                // No context, use NULL
                phSecurityContext = NULL;
            }
    
            // We passed the above thread count limit stuff.  Go ahead and try.
            // Remember to let go of the critical section stuff (in case of a bind)
    
            // Set up generic LDAP Request Event; some inner event will tell
            // us what actually took place.  This event captures more time

            fWMIEventOn = LdapRequestLogAndTraceEventStart((ULONG)choice);

            // Record the time at the start of the request.
            m_lastRequestStartTime = GetTickCount();
    
            // Move the connection to the back of the list, but
            // only if this connection is still open and on the
            // ActiveConnectionsList.
            ACQUIRE_LOCK(&csConnectionsListLock);
            if (BlockStateClosed != m_State) {            
                RemoveEntryList(&m_listEntry);
                InsertTailList(&ActiveConnectionsList, &m_listEntry);
            }
            RELEASE_LOCK(&csConnectionsListLock);
    
            // setup for retrying.
            retryCount = 5;
            do {
                // Count how many times we do this.
                retryCount--;
    
                //
                //  Set so that the DS can impersonate this client
                // 
                pTHS->phSecurityContext = phSecurityContext;
                pTHS->CipherStrength = m_cipherStrength;
                pTHS->dwClientID = m_dwClientID;
                pTHS->ClientIP = ((PSOCKADDR_IN)&m_RemoteSocket)->sin_addr.s_addr;
                
                // current client context is inherited by the thread
                EnterCriticalSection(&m_csClientContext);
                __try {
                    AssignAuthzClientContext(&pTHS->pAuthzCC, m_clientContext);
                }
                __finally {
                    LeaveCriticalSection(&m_csClientContext);
                }
    
                MatchedDN.length = 0;
                MatchedDN.value = NULL;
                ErrorMessage.length = 0;
                ErrorMessage.value =  NULL;
                THClearErrors();
    
                switch (choice) {
    
                case bindRequest_chosen:
    
                    if (!fFastBind) {
                        AbandonAllRequests();
                    }
    
                    code =
                        BindRequest( pTHS, request, pMessage,
                                    &m.protocolOp.u.bindResponse.serverCreds,
                                    &ErrorMessage,
                                    &MatchedDN);
                    break;
    
                case searchRequest_chosen:
                    
                    code = SearchRequest(pTHS,
                                         &bSkipSearchResponse,
                                         request, 
                                         pMessage,
                                         &pReferral,
                                         &pControls,
                                         &ErrorMessage,
                                         &MatchedDN);
    
                    resultNotEncoded = FALSE;
                    DseFlag = request->GetDseFlag();
                    break;
    
                case modifyRequest_chosen:
                    code = ModifyRequest( pTHS, request, pMessage,
                                         &pReferral,
                                         &pControls,
                                         &ErrorMessage,
                                         &MatchedDN);
                    break;
    
                case addRequest_chosen:
                    code = AddRequest( pTHS, request, pMessage, &pReferral,
                                      &pControls,
                                      &ErrorMessage,
                                      &MatchedDN);
                    break;
    
                case delRequest_chosen:
                    code = DelRequest( pTHS, request, pMessage, &pReferral,
                                      &pControls,
                                      &ErrorMessage,
                                      &MatchedDN);
                    break;
    
                case modDNRequest_chosen:
                    code = ModifyDNRequest( pTHS, request, pMessage,
                                           &pReferral,
                                           &pControls,
                                           &ErrorMessage,
                                           &MatchedDN);
                    break;
    
                case compareRequest_chosen:
                    code = CompareRequest( pTHS, request, pMessage,
                                          &pReferral,
                                          &pControls,
                                          &ErrorMessage,
                                          &MatchedDN);
                    break;
    
                case abandonRequest_chosen:
                    AbandonRequest( pTHS, request, pMessage);
                    break;
    
                case extendedReq_chosen:
                    code = ExtendedRequest( pTHS, request, pMessage,
                                           &pReferral,
                                           &ErrorMessage,
                                           &MatchedDN,
                                           &ResponseName,
                                           &ExtendedResponse);
                    break;
    
                default:
                    break;
                }
            } while(retryCount && code==busy);
    
            if (choice == bindRequest_chosen) {
                // if we were a bind, we need to grab the context from the thread and keep it
                // in our current context
                // current client context is inherited by the thread
                EnterCriticalSection(&m_csClientContext);
                __try {
                    AssignAuthzClientContext(&m_clientContext, pTHS->pAuthzCC);
                }
                __finally {
                    LeaveCriticalSection(&m_csClientContext);
                }
            }
        }
        __finally {
            pTHS->phSecurityContext = NULL;
            // OK, we've made the call.  Leave the critical section stuff.
            if(pLocalSecContext != NULL) {
                pLocalSecContext->DereferenceSecurity();
                pLocalSecContext = NULL;
            }
    
            if (choice == bindRequest_chosen && !fFastBind) {
                m_CallState = inactive;
                LeaveCriticalSection(&m_csLock);
            }
        }
    }

    //
    // Build the response
    //

    retryCount=0;
    do {
        m.bit_mask = 0;
        m.messageID = request->m_MessageId;
        switch (choice) {
        case bindRequest_chosen:
            SetReturnValue(bindResponse, code, MatchedDN, ErrorMessage);
            if(m.protocolOp.u.bindResponse.serverCreds.choice) {
                // Some serverCred was set
                m.protocolOp.u.bindResponse.bit_mask = serverCreds_present;
                if(m.protocolOp.u.bindResponse.serverCreds.choice == 
                   sasl_v3response_chosen) {
                   m.protocolOp.u.bindResponse.bit_mask |= BindResponse_ldapv3;
                }
            }
            break;

        case searchRequest_chosen:
            if(bSkipSearchResponse) {

                //
                // We're not actually returning anything (either the search was
                // abandonded or it was a notificaton registration)
                // No return from this
                //

                if ( fWMIEventOn ){
                    fWMIEventOn = LdapRequestLogAndTraceEventEnd(
                                      1,
                                      (ULONG)code,
                                      DseFlag);
                }

                free_thread_state();
                if (!request->AnyBufferedData()) {
                    IF_DEBUG(IO) {
                        DPRINT(0, "Killing a search request (no response sent)\n");
                    }
                    // We're completely done with this request.

                    DereferenceAndKillRequest(request);
                    return;
                } else {

                    BOOL fTemp;

                    Assert(!m_fUDP);
                    IF_DEBUG(IO) {
                        DPRINT(0, "Recursing a search request (no response sent)\n");
                    }

                    //
                    // Hmm.  More data in this request, but we won't get a write
                    // completion (our normal trigger to keep going).  Call
                    // recursively.
                    //

                    ProcessRequest(request, &fTemp);
                    return;
                }
            }

            //
            // result has been encoded by SearchRequest
            //

            if ( code == resultsTooLarge ) {

                //
                // Cant send back result
                //
                SetLdapError(code,
                             0,
                             LdapNetworkError,
                             0,
                             &ErrorMessage);
                code = protocolError;
                goto Abandon;
            }

            break;

        case modifyRequest_chosen:
            SetReturnValue(modifyResponse,code, MatchedDN, ErrorMessage);
            if(pReferral) {
                // A referral was returned
                SetReferralValue(modifyResponse, pReferral);
            }
            break;

        case addRequest_chosen:
            SetReturnValue(addResponse,code,MatchedDN, ErrorMessage);
            if(pReferral) {
                // A referral was returned
                SetReferralValue(addResponse, pReferral);
            }
            break;

        case delRequest_chosen:
            SetReturnValue(delResponse,code, MatchedDN, ErrorMessage);
            if(pReferral) {
                // A referral was returned
                SetReferralValue(delResponse, pReferral);
            }
            break;

        case modDNRequest_chosen:
            SetReturnValue(modDNResponse,code, MatchedDN, ErrorMessage);
            if(pReferral) {
                // A referral was returned
                SetReferralValue(modDNResponse, pReferral);
            }
            break;

        case compareRequest_chosen:
            SetReturnValue(compareResponse,code, MatchedDN, ErrorMessage);
            if(pReferral) {
                // A referral was returned
                SetReferralValue(compareResponse, pReferral);
            }
            break;

        case abandonRequest_chosen:

            //
            // No return from this
            //

            if ( fWMIEventOn ){
                fWMIEventOn = LdapRequestLogAndTraceEventEnd(
                                  2,
                                  (ULONG)code,
                                  DseFlag);
            }

            free_thread_state();
            if (!request->AnyBufferedData()) {

                //
                // We're completely done with this request.
                //

                IF_DEBUG(IO) {
                    DPRINT(0, "Killing an abandon request (no response sent).\n");
                }
                DereferenceAndKillRequest(request);
                return;
            } else {

                BOOL fTemp;

                Assert(!m_fUDP);

                IF_DEBUG(IO) {
                    DPRINT(0, "Recursing an abandon request (no response sent).\n");
                }

                //
                // Hmm.  More data in this request, but we won't get a write
                // completion (our normal trigger to keep going).  Call
                // recursively.
                //

                ProcessRequest(request, &fTemp);
                return;
            }
            break;

        case extendedReq_chosen:
            SetReturnValue(extendedResp, code, MatchedDN, ErrorMessage);
            if(pReferral) {
                // A referral was returned
                m.protocolOp.u.extendedResp.bit_mask |=               
                    ExtendedResponse_referral_present;           
                m.protocolOp.u.extendedResp.ExtendedResponse_referral = pReferral;                                                                 
            }
            if (ResponseName.length) {
                m.protocolOp.u.extendedResp.bit_mask |= 
                    responseName_present;
                m.protocolOp.u.extendedResp.responseName.length = ResponseName.length;
                m.protocolOp.u.extendedResp.responseName.value = ResponseName.value;
            }
            if (ExtendedResponse.length) {
                m.protocolOp.u.extendedResp.bit_mask |= 
                    response_present;
                m.protocolOp.u.extendedResp.response.length = ExtendedResponse.length;
                m.protocolOp.u.extendedResp.response.value = ExtendedResponse.value;
            }
            break;
        default:
            errorLine = DSID(FILENO,__LINE__);
            rc = choice;
            code = SetLdapError(protocolError,
                                rc,
                                LdapEncodeError,
                                0,
                                &ErrorMessage);
            goto Abandon;
            break;
        }

        if ( resultNotEncoded ) {

            //
            // if we get a search here, this means that the send below failed
            // and that this is a retry.
            //

            if ( choice == searchRequest_chosen ) {

                Assert(code == other);

                error = EncodeSearchResult(request,
                                           this,
                                           NULL,
                                           code,
                                           NULL,       // referrals
                                           NULL,       // controls
                                           &ErrorMessage,
                                           &MatchedDN,
                                           0,
                                           FALSE);

            } else {

                if (pControls) {
                    // one or more controls was returned
                    m.bit_mask |= controls_present;
                    m.controls = pControls;
                }

                error = EncodeLdapMsg(&m, request);
            }

            if ( error != ERROR_SUCCESS ) {

                IF_DEBUG(WARNING) {
                    DPRINT2(0,"Encoding response[choice %d] failed with return code = %d\n",
                        choice, error);
                }

                errorLine = DSID(FILENO,__LINE__);
                rc = error;
                code = SetLdapError(protocolError,
                                    rc,
                                    LdapEncodeError,
                                    0,
                                    &ErrorMessage);
                goto Abandon;
            }
        }

        // Save the message ID before the request gets freed by the send.
        MsgID = request->m_MessageId;

        if (request->Send(m_fUDP,
                          &m_hSslSecurityContext)) {
            // ********************************************************
            // * After a successful Send request may have been freed. *
            // * NULL it out so that it can't be used anymore.        * 
            // ********************************************************            
            request = NULL;

            if ( fWMIEventOn ){
                fWMIEventOn = LdapRequestLogAndTraceEventEnd(
                                  3,
                                  (ULONG)code,
                                  DseFlag);
            }

            if (!m_fUDP) {      
                // Record the completion of this msgId.
                Assert(MSGIDS_BUFFER_SIZE > m_MsgIdsPos);
                EnterCriticalSection(&m_csLock);
                m_MsgIds[m_MsgIdsPos++] = MsgID;
                if (MSGIDS_BUFFER_SIZE <= m_MsgIdsPos) {
                    m_MsgIdsPos = 0;
                }
                LeaveCriticalSection(&m_csLock);
            }

            free_thread_state();
            *fResponseSent = TRUE;
            
            // Record completion time of the request.

            m_lastRequestFinishTime = GetTickCount();

            //
            //  We know that this thread should not delete this so
            //  return any non-zero value. Do not use QueryReference
            //  since we can have a race between this thread and
            //  the AtqReadFile we just started.
            //

            return; //  Normal case !!!!!!
        }

        IF_DEBUG(WARNING) {
            DPRINT(0,"Failed to send encoded message\n");
        }
    
        rc = GetLastError();

        errorLine = DSID(FILENO,__LINE__);
        if(rc == ERROR_NO_SYSTEM_RESOURCES) {

            // Drat we failed because the return message was too big.  Clear out
            // the SendBuffer in the request object, tweak the message to be an
            // error, and try again.

            IF_DEBUG(WARNING) {
                DPRINT1(0,"Sending response with err %d. Sending back error\n",rc);
            }

            resultNotEncoded = TRUE;
            code = other;
            pReferral = NULL;
            MatchedDN.length = 0;
            MatchedDN.value = NULL;
            pControls = NULL;
            ErrorMessage = OutOfMemoryError;
            request->ResetSend();
        }
        retryCount++;
    } while((retryCount == 1) && // Only try to resend once.
            (rc == ERROR_NO_SYSTEM_RESOURCES )); // and only if this error

    // Yes, an error occurred, we're abandoning the socket.
    code = SetLdapError(other,
                        rc,
                        LdapNetworkError,
                        0,
                        &ErrorMessage);
Abandon:

    //
    // Send notice of disconnect
    //

    if (!m_fUDP && (rc != ERROR_VC_DISCONNECTED)) {
        IF_DEBUG(WARNING) {
            DPRINT1(0,"Sending disconnect notify. rc = %d\n", rc);
        }
        LdapDisconnectNotify(code, &ErrorMessage);
    }

    if ( fWMIEventOn ){
        fWMIEventOn = LdapRequestLogAndTraceEventEnd(
                          4,
                          (ULONG)code,
                          DseFlag);
    }

    free_thread_state();

    if ( !fDontLog ) {
        if(!errorLine) {
            errorLine = DSID(FILENO,__LINE__);
        }

        if(!rc) {
            rc = GetLastError();
            errorLine = DSID(FILENO,__LINE__);
        }

        LogEvent(DS_EVENT_CAT_LDAP_INTERFACE,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_ATQ_CLOSE_SOCKET_ERROR,
                 szInsertUL(rc),
                 szInsertHex(errorLine),
                 szInsertUL(m_dwClientID));
    }

    Disconnect( );
    DereferenceAndKillRequest(request);
    return;

} // ProcessRequest

#undef SetReturnValue
#undef SetReferralValue

VOID
LDAP_CONN::MarkRequestAsAbandonded(
        IN DWORD MessageID
        )
{
    LDAP_REQUEST *pRequest;
    PLIST_ENTRY  listEntry;

    EnterCriticalSection(&m_csLock);

    for ( listEntry = m_requestList.Flink;
          listEntry != &m_requestList;
          listEntry = listEntry->Flink
        ) {

        pRequest = CONTAINING_RECORD(
                                listEntry,
                                LDAP_REQUEST,
                                m_listEntry
                                );

        if(pRequest->m_MessageId == MessageID) {
            pRequest->m_fAbandoned = TRUE;
            break;
        }
    }

    LeaveCriticalSection(&m_csLock);
    return;
}


VOID
LDAP_CONN::DereferenceAndKillRequest(
        PLDAP_REQUEST pRequest
        )
/*++

Routine Description:

    This routine deassociates a request object with a connection object.
    it removes the request object from the request list and dereferences
    the request object.

Arguments:

    pRequest - request object to remove from list.

Return Value:

    None

--*/
{
    EnterCriticalSection(&m_csLock);

    if ( pRequest->m_State == BlockStateActive ) {

        pRequest->m_State = BlockStateClosed;

        RemoveEntryList(
            &pRequest->m_listEntry
            );

        LeaveCriticalSection(&m_csLock);

        //
        // remove the references to the request
        //

        pRequest->DereferenceRequest( );
        return;

    } else {
        LeaveCriticalSection(&m_csLock);
        return;
    }

} // LDAP_CONN::DereferenceAndKillRequest


_enum1
LDAP_CONN::PreRegisterNotify(
        MessageID messageID
        )
{
    PLDAP_NOTIFICATION pNew;
    _enum1 retVal = success;

    IF_DEBUG(NOTIFICATION) {
        DPRINT1(0,"PreRegisterNotify called with id %d\n",messageID);
    }

    if(!pTHStls->phSecurityContext) {
        // Don't allow unauthenticated clients to register notifications.
        IF_DEBUG(WARNING) {
            DPRINT(0,"Unauthenticated clients cannot do notifications\n");
        }
        SetLastError(ERROR_NOT_AUTHENTICATED);
        return unwillingToPerform;
    }

    // Go single threaded to add this to the notification list
    EnterCriticalSection(&m_csLock);
    __try {

        if(m_countNotifies >= LdapMaxNotifications) {
            // Too many already.
            retVal = adminLimitExceeded;
            IF_DEBUG(WARNING) {
                DPRINT2(0,"Notification limit[%d max=%d] exceeded\n",
                         m_countNotifies, LdapMaxNotifications);
            }
            SetLastError(ERROR_DS_ADMIN_LIMIT_EXCEEDED);
            _leave;
        }

        pNew = (PLDAP_NOTIFICATION)LdapAlloc(sizeof(LDAP_NOTIFICATION));
        if(!pNew) {
            // Failed to allocate a notification object.
            IF_DEBUG(NOMEM) {
                DPRINT(0,"LdapAlloc failed to allocate notification block\n");
            }
            retVal = other;
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            _leave;
        }

        // OK, init the new object and put it in the head of the queue
        pNew->hServer = 0;
        pNew->messageID = messageID;
        pNew->pNext =  m_Notifications;
        m_Notifications = pNew;
        m_countNotifies++;
    }
    __finally {
        LeaveCriticalSection(&m_csLock);
    }

    return retVal;
} // LDAP_CONN::PreRegisterNotify



BOOL
LDAP_CONN::RegisterNotify(
        IN ULONG hServer,
        MessageID messageID
        )
{
    PLDAP_NOTIFICATION pNew;
    BOOL               retVal = FALSE;

    // Find the notification that had better have been preregisterd.
    EnterCriticalSection(&m_csLock);
    __try {
        pNew = m_Notifications;
        while(pNew && pNew->messageID != messageID) {
            pNew = pNew->pNext;
        }
        if(pNew) {
            // Found it.
            // We had better not already have a server handle associated with
            // this.
            Assert(pNew->hServer == 0);
            pNew->hServer = hServer;
            retVal = TRUE;
        }
    }
    __finally {
        LeaveCriticalSection(&m_csLock);
    }

    return retVal;

} // LDAP_CONN::RegisterNotify




VOID
LDAP_CONN::UnregisterNotify(
        IN MessageID messageID,
        IN BOOLEAN fCoreUnregister
        )
{
    PLDAP_NOTIFICATION p1, p2;
    NOTIFYRES *pNotifyRes;

    // Go single threaded to avoid someone else messing with this list while we
    // are trying to remove something from the list.
    EnterCriticalSection(&m_csLock);
    __try {
        if(!m_Notifications) {
            _leave;
        }

        Assert(m_countNotifies);

        if(m_Notifications->messageID == messageID) {
            p1 = m_Notifications;
            if ( fCoreUnregister ) {
                DirNotifyUnRegister( m_Notifications->hServer, &pNotifyRes);
            }
            m_Notifications = m_Notifications->pNext;
            LdapFree(p1);
            m_countNotifies--;
            _leave;
        }

        p1 = m_Notifications;
        p2 = p1->pNext;
        while(p2) {
            if(p2->messageID == messageID) {
                p1->pNext = p2->pNext;
                if ( fCoreUnregister ) {
                    DirNotifyUnRegister( p2->hServer, &pNotifyRes);
                }
                m_countNotifies--;
                LdapFree(p2);
                _leave;
            }
            p1 = p2;
            p2 = p2->pNext;
        }
    }
    __finally {
        LeaveCriticalSection(&m_csLock);
    }

    return;
} // LDAP_CONN::UnregisterNotify



BOOL
LDAP_CONN::fGetMessageIDForNotifyHandle(
        IN ULONG hServer,
        OUT MessageID *pmessageID
        )
{
    PLDAP_NOTIFICATION p1;
    BOOL retVal = FALSE;

    // Go single threaded to avoid someone else messing with this list while we
    // are reading it.
    EnterCriticalSection(&m_csLock);
    __try {
        p1 = m_Notifications;
        while(p1) {
            if(p1->hServer == hServer) {
                *pmessageID = p1->messageID;
                retVal = TRUE;
                _leave;
            }
            p1 = p1->pNext;
        }
    }
    __finally {
        LeaveCriticalSection(&m_csLock);
    }

    return retVal;
} // LDAP_CONN::fGetMessageIDForNotifyHandle


VOID
LDAP_CONN::Disconnect(
        VOID
        )

/*++

Routine Description:

    This function closes the associated ATQ socket and removes the
    connection object from the global list

Arguments:

    None.

Return Value:

    None.

--*/
{

    ACQUIRE_LOCK(&csConnectionsListLock);

    if ( m_State != BlockStateClosed ) {

        m_State = BlockStateClosed;

        //
        // Remove from list of connections
        //

        RemoveEntryList( &m_listEntry);

        //
        // Decrement count of current users
        //

        if (!m_fUDP) {

            DEC(pcLDAPClients);
            PERFINC(pcLdapClosedConnsPerSec);
            InterlockedDecrement(&CurrentConnections);
            DPRINT1(VERBOSE, " CurrentConnections = %u\n", CurrentConnections);

        } else {
            UncountedConnections--;
            DPRINT1(VERBOSE," UncountedConnections = %u\n", UncountedConnections);
        }

        RELEASE_LOCK(&csConnectionsListLock);
        AtqCloseSocket(m_atqContext, TRUE);
        DereferenceConnection( );
    } else {
        RELEASE_LOCK(&csConnectionsListLock);
    }

} // LDAP_CONN::Disconnect



VOID
LDAP_CONN::Free(
    LDAP_CONN* pConn
    )

/*++

Routine Description:

    This function frees an LDAP_CONN object.

Arguments:

    pConn - object to be freed.

Return Value:

    None.

--*/
{
    pConn->Cleanup( );
    pConn->Reset( );

    IF_DEBUG(CONN) {
        DPRINT1(0,"Conn %p freed to ", pConn);
    }

    if ( LdapConnCached < LdapBlockCacheLimit ) {
        ACQUIRE_LOCK( &LdapConnCacheLock );
        LdapConnCached++;
        InsertHeadList( &LdapConnCacheList, &pConn->m_listEntry );
        RELEASE_LOCK( &LdapConnCacheLock );

        IF_DEBUG(CONN) {
            DPRINT1(0,"cache.\n", pConn);
        }

    } else {
        delete pConn;
        LdapConnAlloc--;

        IF_DEBUG(CONN) {
            DPRINT(0,"heap.\n");
        }
    }
    InterlockedDecrement(&ActiveLdapConnObjects);
    return;

} // Free


PLDAP_CONN
LDAP_CONN::Alloc(
    IN BOOL fUDP,
    OUT LPBOOL pfMaxExceeded
    )

/*++

Routine Description:

    This function creates a new (LDAP_CONN) object.

    It increments the counter of current connections and returns
    the allocated object (if non NULL).

Arguments:

    fUDP     do we exempt this from the connections count?

    pfMaxExceeded  pointer to BOOL which on return indicates if max
                       connections limit was exceeded.

Return Value:

    Pointer to the LDAP_CONN object allocated.

--*/
{
    PLDAP_CONN pConn = NULL;
    LONG oldCount;
    *pfMaxExceeded = FALSE;
    PLIST_ENTRY listEntry;

    //
    // We can add this new connection
    //

    ACQUIRE_LOCK( &LdapConnCacheLock );

    if ( !IsListEmpty( &LdapConnCacheList) ) {

        listEntry = RemoveHeadList(&LdapConnCacheList);

        LdapConnCached--;
        RELEASE_LOCK( &LdapConnCacheLock );

        pConn = CONTAINING_RECORD(listEntry,
                                  LDAP_CONN,
                                  m_listEntry
                                  );
        IF_DEBUG(CONN) {
            DPRINT1(0,"CONN %x alloc from cache\n", pConn);
        }

    } else {

        RELEASE_LOCK( &LdapConnCacheLock );

        pConn = new LDAP_CONN;
        if (pConn == NULL ) {
            IF_DEBUG(NOMEM) {
                DPRINT(0,"LDAP: Cannot allocate connection object\n");
            }
            return NULL;
        }

        if ( pConn->m_State == BlockStateInvalid ) {
            delete pConn;
            return NULL;
        }

        LdapConnAlloc++;
        if ( LdapConnAlloc > LdapConnMaxAlloc ) {
            LdapConnMaxAlloc = LdapConnAlloc;
        }

        IF_DEBUG(CONN) {
            DPRINT1(0,"CONN %x alloc from heap\n", pConn);
        }
    }

    if(!fUDP) {

        oldCount = InterlockedExchangeAdd(&CurrentConnections, 1);

        if ( ((DWORD)oldCount >= LdapMaxConnections) && 
             !fBypassLimitsChecks ) {

            //
            // Too many connections.  Find one to get rid of.
            //

            FindAndDisconnectConnection();

            IF_DEBUG(WARNING) {
                DPRINT2(0,"Too many connections %d [max %d]\n",
                    oldCount+1, LdapMaxConnections);
            }
        }

        //
        //  Increment the count of connected users
        //

        INC(pcLDAPClients);
        PERFINC(pcLdapNewConnsPerSec);
        DPRINT1(VERBOSE, "CurrentConnections = %u\n",
                CurrentConnections);

        //
        // Update the current maximum connections
        //

        if ( CurrentConnections > MaxCurrentConnections) {
            MaxCurrentConnections = CurrentConnections;
        }

    } else {
        PERFINC(pcLDAPUDPClientOpsPerSecond);
        UncountedConnections++;
        DPRINT1(VERBOSE, "UncountedConnections = %u\n",
                UncountedConnections);

    }

    pConn->m_signature = SIGN_LDAP_CONN;
    pConn->m_RefCount = 1;

    ACQUIRE_LOCK(&csConnectionsListLock);

    //
    // Insert into the list of connected users.
    //

    InsertTailList(
        &ActiveConnectionsList,
        &pConn->m_listEntry
        );

    pConn->m_State = BlockStateActive;
    pConn->m_ClientNumber = ++GlobalClientCounter;

    RELEASE_LOCK(&csConnectionsListLock);

    InterlockedIncrement(&ActiveLdapConnObjects);
    return pConn;

} // LDAP_CONN::Alloc


BOOL
LDAP_CONN::GetSslContextAttributes(
                         VOID
                         )
/*++

Routine Description:

    This function queries for the cipher strength of a connection.

Arguments:

    None.

Return Value:

    None.

--*/
{

    SECURITY_STATUS ret;
    SecPkgContext_ConnectionInfo connInfo;

    ret = QueryContextAttributes(
                            &m_hSslSecurityContext,
                            SECPKG_ATTR_CONNECTION_INFO,
                            &connInfo
                            );

    if ( ret == ERROR_SUCCESS ) {

        m_cipherStrength = connInfo.dwCipherStrength;
        IF_DEBUG(SSL) {
            DPRINT1(0,"Cipher Strength set to %d\n",connInfo.dwCipherStrength);
        }
    } else {

        DPRINT1(0,"Cannot query cipher strength. err %x\n", ret);
        goto error_exit;
    }

    ret = QueryContextAttributes(
                             &m_hSslSecurityContext,
                             SECPKG_ATTR_STREAM_SIZES,
                             &m_SslStreamSizes
                             );

    if ( ret == ERROR_SUCCESS ) {

        IF_DEBUG(SSL) {
            DPRINT5(0,"SSL Stream: Head %d Trail %d MaxMsg %d Buffer %d Block %d\n",
                    m_SslStreamSizes.cbHeader,
                    m_SslStreamSizes.cbTrailer,
                    m_SslStreamSizes.cbMaximumMessage,
                    m_SslStreamSizes.cBuffers,
                    m_SslStreamSizes.cbBlockSize);
        }

        //  Avoid off by one error in schanlsa.dll
        //  which manifests itself as internal error return when
        //  doing a deap search with 8000 bytes of results. Use -2
        //  to keep some sort of alignment.  RRandall 2/14/00 - I don't know
        //  if this is still necessary, but I do know that it works.
        //  Rather than go through a long testing process it might as
        //  well stay.
        m_SslStreamSizes.cbMaximumMessage -= 2;

        m_SslStreamSizes.cbMaximumMessage -=
            (m_SslStreamSizes.cbHeader + m_SslStreamSizes.cbTrailer);

    } else {

        DPRINT1(0,"Cannot query stream sizes. err %x\n", ret);
    }

error_exit:
    return (ret == NO_ERROR);

} // LDAP_CONN::GetSslContextAttributes



BOOL
LDAP_CONN::GetSslClientCertToken(
                         VOID
                         )
/*++

Routine Description:

    This function queries for the cipher strength of a connection.

Arguments:

    None.

Return Value:

    None.

--*/
{

    SECURITY_STATUS ret;
    CERT_CONTEXT cert;

    ret = QueryContextAttributes(
                            &m_hSslSecurityContext,
                            SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                            &cert

                            );

    if ( ret == ERROR_SUCCESS ) {

        IF_DEBUG(SSL) {
            DPRINT(0,"Got client cert!!\n");
        }
    } else {

        IF_DEBUG(WARNING) {
            DPRINT(0,"No client cert retrieved from QueryContextAttributes.\n");
        }
        return FALSE;
    }

    //
    // The client sent one. Register this security context as if the
    // client did a bind.
    //

    if (m_pPartialSecContext) {
        m_pPartialSecContext->DereferenceSecurity();
    }

    m_pPartialSecContext = new LDAP_SECURITY_CONTEXT(FALSE);
    if ( m_pPartialSecContext == NULL ) {
        IF_DEBUG(NOMEM) {
            DPRINT(0,"Cannot allocate LDAP security context\n");
        }
        return FALSE;
    }

    m_pPartialSecContext->GrabSslContext(&m_hSslSecurityContext);

#if DBG
    //
    // Try to get the client cert, if available
    //

    {
        PVOID token = NULL;
        SECURITY_STATUS sc;

        sc = QuerySecurityContextToken(
                                  &m_hSslSecurityContext,
                                  &token);

        IF_DEBUG(SSL) {
            DPRINT2(0,"QuerySecContextToken returns status %x token %x\n", sc, token);
        }
    }
#endif
    return TRUE;

} // LDAP_CONN::GetSslClientCertToken


BERVAL *
GenDisconnectNotify(
        IN _enum1           Errcode,
        IN LDAPString       *ErrorMessage
        )
/*++

Routine Description:

    This function constructs a disconnect notification.
        
Arguments:

    ErrCode - error to return to client.
    ErrorMessage - The error message to send back with the notification.
    
Return Value:

    On successful completion returns a pointer to a BERVAL, otherwise returns
    NULL.
    
--*/
{
    LDAPString * ldapText;
    BerElement* berElement;
    INT rc;
    BERVAL * bval = NULL;

    IF_DEBUG(ERROR) {
        PCHAR  errMsg;
        DPRINT2(0,"GenDisconnectNotify entered. code = %d\n\t%s\n", Errcode, ErrorMessage->value);
        errMsg = (PCHAR) LdapAlloc(ErrorMessage->length + 1);
        if (errMsg) {
            memcpy(errMsg, ErrorMessage->value, ErrorMessage->length);
            errMsg[ErrorMessage->length] = '\0';
            DPRINT1(0,"    %s\n",errMsg);
            LdapFree(errMsg);
        }
    }

    berElement = ber_alloc_t(LBER_USE_DER);
    if ( berElement == NULL ) {
        IF_DEBUG(WARNING) {
            DPRINT(0,"ber_alloc_t failed\n");
        }
        return NULL;
    }

    rc = ber_printf(berElement,"{it{tioo}to}",
                    0x0, LDAP_RES_EXTENDED,
                    0x0A, Errcode,
                    "", 0,
                    ErrorMessage->value, ErrorMessage->length,
                    0x8A, DisconnectNotifyName.value, DisconnectNotifyName.length);

    if ( rc == -1 ) {
        IF_DEBUG(WARNING) {
            DPRINT(0,"ber_printf failed\n");
        }
        ber_free(berElement,1);
        return NULL;
    }

    rc = ber_flatten(berElement, &bval);
    ber_free(berElement,1);
    if ( rc == -1 ) {
        IF_DEBUG(WARNING) {
            DPRINT(0,"ber_flatten failed\n");
        }
        return NULL;
    }

    return bval;
}


VOID
SendDisconnectNotify(
        IN PATQ_CONTEXT     pAtqContext,
        IN _enum1           Errcode,
        IN LDAPString       *ErrorMessage
        )
/*++

Routine Description:

    This function sends a disconnect notification.  This function is used when
    the connection does not yet have an LDAP_CONN.
        
Arguments:

    s - socket to send notification to.
    ErrCode - error to return to client.
    ErrorMessage - The error message to send back with the notification.
    
Return Value:

    None.  If the send times out, this function will close the connection so
    that the send buffers can be freed.

--*/

{
    WSABUF     wsaBuf;
    DWORD      dwBytesWritten;
    BERVAL     *bval = NULL;
    
    bval = GenDisconnectNotify(Errcode, ErrorMessage);

    if (!bval) {
        //
        // Oh well, we are disconnecting anyway.  Just give up.
        //
        return;
    }

    //
    // do a synchronous send
    //
    wsaBuf.len = bval->bv_len;
    wsaBuf.buf = bval->bv_val;
    AtqSyncWsaSend(pAtqContext, &wsaBuf, 0, &dwBytesWritten);
    ber_bvfree(bval);

    IF_DEBUG(NOTIFICATION) {
        DPRINT(0,"SendDisconnectNotify exited.\n");
    }
    return;
} // SendDisconnectNotify



VOID
LDAP_CONN::LdapDisconnectNotify(
    IN _enum1           Errcode,
    IN LDAPString       *ErrorMessage
    )
/*++
Routine Description:

    Sends a Notice of Disconnection for this connection, but only if the connection
    hasn't been closed already.         

Arguments:

    Errcode - the error code to be passed on to the disconnect notify function.
    
    ErrorMessage - the error message to be passed on. 

Return Value:

    N/A
    
--*/
{
    DWORD          dwErr;
    PLDAP_REQUEST  pRequest = NULL;
    BERVAL         *bval;
    PUCHAR         pBuff = NULL;

    //
    // If the connection is already closed don't bother generating the
    // notification.
    //
    if (BlockStateClosed == m_State) {
        return;
    }

    DPRINT(1, "LDAP disconnect notify entered!\n");
    
    // Now, get a request object
    pRequest = LDAP_REQUEST::Alloc(m_atqContext,this);
    if (pRequest == NULL) {
        IF_DEBUG(NOMEM) {
            DPRINT(0,"Unable to allocate request to send notification\n");
        }
        return;
    }

    bval = GenDisconnectNotify(Errcode, ErrorMessage);
    if (!bval) {
        //
        // Since we are disconnecting any way, just give up.
        //
        DereferenceAndKillRequest(pRequest);
        return;
    }

    if (bval->bv_len > pRequest->GetSendBufferSize()) {
        if(!pRequest->GrowSend(bval->bv_len)) {
            DereferenceAndKillRequest(pRequest);
            return;
        }
    }

    pBuff = pRequest->GetSendBuffer();

    CopyMemory(pBuff, bval->bv_val, bval->bv_len);

    pRequest->SetBufferPtr(pBuff + bval->bv_len);

    //
    // don't need this anymore.
    //
    ber_bvfree(bval);


    //
    // Finally send the message making sure that the connection is still up.
    //
    if ( m_State != BlockStateClosed ) {
        DPRINT(2, "Sending notify.\n");
        pRequest->SyncSend(&m_hSslSecurityContext);
    }

    DereferenceAndKillRequest(pRequest);
    return;
}



__forceinline
BOOL
LDAP_CONN::LdapRequestLogAndTraceEventStart(
    IN ULONG choice
    )
/*++
Routine Description:

    This function starts an ldap request trace event.  The following arguments 
    are passed to the capacity planning event:
    
         The type of LDAP request.
         The remote IP address.
         

Arguments:

    choice - What kind of LDAP request this is, i.e. Search, Modify . . .
 

Return Value:

    Bool indicating if the event is on (TRUE) or off (FALSE)

--*/
{
    
    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_BEGIN_LDAP_REQUEST,
                     EVENT_TRACE_TYPE_START,
                     DsGuidLdapRequest,
                     szInsertUL((ULONG)choice),
                     szInsertSz(m_RemoteSocketString),
                     m_fUDP ? szInsertSz("UDP") : szInsertSz("TCP"),
                     NULL, NULL, NULL, NULL, NULL);
    
    return TRUE;

} // LdapRequestLogAndTraceEventStart


__forceinline
BOOL
LDAP_CONN::LdapRequestLogAndTraceEventEnd(
    IN ULONG        ulExitID,
    IN ULONG        code,
    IN RootDseFlags rootDseSearchFlag
    )
/*++
Routine Description:

    This function ends a trace event for an ldap request.

Arguments:

    ulExitID - This number indicates how the request was completed.
        1 - The request was abandoned, or it was a notification registration.
        2 - The request was actually an abandon request.
        3 - The request completed normally.
        4 - The request was not completed due to an error.
        
    code -     The LDAPResult that was returned to the client.
    
    rootDseSearchFlag - Indicates whether the request was a rootDSE search, 
                          an LDAP ping, or some other operation.

Return Value:

    Bool indicating if the event is on (TRUE) or off (FALSE)

--*/
{
    PCHAR  pcDseFlagString;

    switch (rootDseSearchFlag) {
    case rdseNonDse:
        pcDseFlagString = "NonDSE";
        break;
    case rdseDseSearch:
        pcDseFlagString = "RootDSE";
        break;
    case rdseLdapPing:
        pcDseFlagString = "LDAPPing";
        break;
    default:
        Assert(FALSE);
        return FALSE;
    }

    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_END_LDAP_REQUEST,
                     EVENT_TRACE_TYPE_END,
                     DsGuidLdapRequest,
                     szInsertUL(ulExitID),
                     szInsertUL(code),
                     szInsertSz(pcDseFlagString),
                     NULL, NULL, NULL, NULL, NULL);
    
    return FALSE;

} // LdapRequestLogAndTraceEventEnd


VOID
LDAP_CONN::SetIsAdmin(
                      IN OUT THSTATE *pTHS
                     )
/*++

Routine Description:

    This function determines whether the currently bound user is a member of the 
    builtin administrators group, and then sets the appropriate boolean variable.
    
    Should only be called with the LDAP_CONN locked.

Arguments:

    pTHS  -  Pointer to the current thread state.

Return Value:

    None.

--*/
{
    DWORD                       dwError;
    PSID                        AdminSid = NULL;
    SID_IDENTIFIER_AUTHORITY    NtAuthority   = SECURITY_NT_AUTHORITY;

    m_bIsAdmin = FALSE;
    
    if (NULL == m_pSecurityContext) {
        return; // nope
    }

    pTHS->phSecurityContext = m_pSecurityContext->GetSecurityContext();
        
    // check to see whether it's the token of an admin.
    if (AllocateAndInitializeSid(&NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
                             DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0 ,0, 0,
                             &AdminSid )) {
        // check group membership (this will create client context if unavailable)
        CheckGroupMembershipAnyClient(pTHS, AdminSid, &m_bIsAdmin);

        IF_DEBUG(CONN) {
            if (m_bIsAdmin) {
                DPRINT(0, "Just bound a new admin!\n");
            }
        }
    }

    if (AdminSid) {
        FreeSid(AdminSid);
    }
    m_pSecurityContext->DereferenceSecurity();
    pTHS->phSecurityContext = NULL;
}


VOID
LDAP_CONN::AbandonAllRequests(
                          VOID
                         )
/*++

Routine Description:

    Abaondons all outstanding request on the connection.  
    
    NOTE: 
        Must be called with the connection locked!

Arguments:

    None.
    
Return Value:

    None.

--*/
{
    LDAP_REQUEST        *pRequest;
    PLIST_ENTRY         listEntry;
    PLDAP_NOTIFICATION  p1, p2;
    NOTIFYRES           *pNotifyRes;

    // First mark all the requests as abandoned.

    for ( listEntry = m_requestList.Flink;
         listEntry != &m_requestList;
         listEntry = listEntry->Flink
             ) {

        pRequest = CONTAINING_RECORD(listEntry,
                                     LDAP_REQUEST,
                                     m_listEntry);

        // Don't pre-abandon requests.  The request
        // that hasn't received any data yet
        // is ok to leave alone.
        if (pRequest != m_request) {        
            pRequest->m_fAbandoned = TRUE;
        }
    }

    // Then unregister any notifications that are still
    // outstanding.
    while (m_countNotifies) {        
        p1 = m_Notifications;
        DirNotifyUnRegister( m_Notifications->hServer, &pNotifyRes);
        m_Notifications = m_Notifications->pNext;
        LdapFree(p1);
        m_countNotifies--;
    }
    Assert(!m_Notifications);

    IF_DEBUG(CONN) {
        DPRINT1(0, "Abondoning all requests on conn %p\n", this);
    }
    return;
}


VOID
LDAP_CONN::FindAndDisconnectConnection(
                      VOID
                     )
/*++

Routine Description:

    This function applies the following algorithm to find a connection to kill.
    
    Examine the first 50 non-UDP connections at the head of the connection list, (These
    should be the connections that haven't had any activity for the longest time).  Score
    them according to the following.
    
        - if the security context handle is NULL, give it 8 points, else 0 points.
        - if the lastRequestFinishTime is greater than the lastRequestStartTime, and more
          than 15 seconds ago, add 4 points
        - if the lastRequestFinishTime is greater than the lastRequestStartTime, add 2 points.
        - if the entry is not for an admin, give it 1 point.
        
    Kill the connection with the highest score.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PLDAP_CONN   pConn;
    PLDAP_CONN   pBestCandidateConnection = NULL;
    DWORD        dwCurrentScore;
    DWORD        dwBestScore              = 0;
    LONG         lTimeDiff;
    LIST_ENTRY   *pListEntry;

    ACQUIRE_LOCK(&csConnectionsListLock);
    
    pListEntry = ActiveConnectionsList.Flink;
    for (int count=0; count < 50 && pListEntry != &ActiveConnectionsList; count++) {
        pConn = (PLDAP_CONN) CONTAINING_RECORD(pListEntry, LDAP_CONN, m_listEntry);

        dwCurrentScore = 0;

        if (pConn->m_fUDP) {
            // Don't count UDP connections.
            count--;
        } else {
        
            // Score the connection.
            if (NULL == pConn->m_pSecurityContext) {
                dwCurrentScore += 8;
            }
            if (!pConn->m_bIsAdmin) {
                dwCurrentScore += 1;
            }

            lTimeDiff = pConn->m_lastRequestFinishTime
                - pConn->m_lastRequestFinishTime;

            if (lTimeDiff < 0) {
                // Check for rollover.  If the time difference
                // is greater than half the longest time represented
                // by a tick count, then consider it rolled over.
                if (-lTimeDiff > ((~0L) >> 2) ) {
                    // This must be the rollover case, so 
                    // the last request finished already.
                    dwCurrentScore += 2;

                    // Was the last request finished more than
                    // 15 seconds ago.
                    if (-lTimeDiff > 15000) {
                        dwCurrentScore += 4;
                    }
                }
            } else {
                // Check for rollover.
                if (lTimeDiff < ((~0L) >> 2) ) {
                    // No rollover, so the last request
                    // really is finished.
                    dwCurrentScore += 2;

                    // Was the last request finished more than
                    // 15 seconds ago?
                    if (lTimeDiff > 15000) {
                        dwCurrentScore += 4;
                    }
                }
            }

            // Is this the largest score we've seen so far?
            if (dwCurrentScore > dwBestScore) {
                dwBestScore = dwCurrentScore;
                pBestCandidateConnection = pConn;
            } else if (NULL == pBestCandidateConnection) {
                pBestCandidateConnection = pConn;
            }
        }

        // Go on to the next connection.
        pListEntry = pListEntry->Flink;
    }

    Assert(NULL != pBestCandidateConnection);

    // Reference the connection so that it can't disappear before
    // we can disconnect it.
    pBestCandidateConnection->ReferenceConnection();

    RELEASE_LOCK(&csConnectionsListLock);

    pBestCandidateConnection->Disconnect();

    IF_DEBUG(WARNING) {    
        DPRINT(0, "DISCONNECT DUE TO TOO MANY CONNECTIONS");
    }
    

    pBestCandidateConnection->DereferenceConnection();

    return;
}


VOID
LDAP_CONN::SetNetBufOpts(
                      LPLDAP_SECURITY_CONTEXT pSecurityContext OPTIONAL
                     )
/*++

Routine Description:

    This function sets the network buffer options according to whether and what 
    kind of encryption is currently active on the connection.  If it's possible
    that the connection may require a header or trailer, then an 
    LDAP_SECURITY_CONTEXT MUST be passed in.
        
Arguments:

    pSecurityContext - May be NULL if the connection will definitely not require
                       a header or trailer.

Return Value:

    None.

--*/
{
    PSecPkgContext_Sizes sizes;
    
    if (IsSSLOrTLS()) {
        m_fCanScatterGather = FALSE;
        m_fNeedsHeader = FALSE;
        m_fNeedsTrailer = FALSE;
    } else if (IsSignSeal()) {
        Assert(NULL != pSecurityContext);
        m_fNeedsHeader = TRUE;
        m_fNeedsTrailer = TRUE;
        m_fCanScatterGather = TRUE;
    } else {
        m_fCanScatterGather = TRUE;
        m_fNeedsHeader = FALSE;
        m_fNeedsTrailer = FALSE;
    }

    if (IsSignSeal()) {
        sizes = pSecurityContext->GetContextSizes();

        //
        // The following lines come straight from the security group.  It's a
        // strange and wonderful land where you use the trailersize as the header 
        // size.
        //

        //
        // Need to save space for the SASL header in front of the
        // encryption header.
        //
        m_HeaderSize = sizes->cbSecurityTrailer + sizeof(DWORD);
        m_TrailerSize = sizes->cbBlockSize + sizes->cbMaxSignature;

        if (IsDigest()) {
            m_MaxEncryptSize = pSecurityContext->GetMaxEncryptSize();
        } else {
            m_MaxEncryptSize = MAXDWORD;
        }

    } else {
        m_HeaderSize = 0;
        m_TrailerSize = 0;
    }

    return;
}


extern "C"
DWORD
LdapEnumConnections(
    IN THSTATE *pTHS,
    IN PDWORD Count,
    IN PVOID *Buffer
    )
/*++

Routine Description:

    This function enumerates all outstanding connections

Arguments:

    pTHS - thread state
    Count - On return, number of array elements returned.
    Buffer - On return, an array of DS_DOMAIN_CONTROLLER_INFO_FFFFFFFF

Return Value:

    if successful, ERROR_SUCCESS
    otherwise, Win32 error code

--*/
{
    PLIST_ENTRY pEntry;
    PLDAP_CONN pConn;
    DWORD nConn = 0;
    DWORD err = ERROR_SUCCESS;
    PDS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW ldapConn;
    FILETIME currTime;
    LARGE_INTEGER liCurrent; 
    LARGE_INTEGER liConnect;

    GetSystemTimeAsFileTime(&currTime);
    liCurrent.LowPart = currTime.dwLowDateTime;
    liCurrent.HighPart = currTime.dwHighDateTime;

    ACQUIRE_LOCK( &csConnectionsListLock );
    
    __try {

        //
        // First, count the number of entries
        //

        pEntry = ActiveConnectionsList.Flink;
        while ( pEntry != &ActiveConnectionsList ) {
            nConn++;
            pEntry = pEntry->Flink;
        }
        
        //
        // allocate the buffer to be returned
        //

        ldapConn = (PDS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW)
            THAllocEx(pTHS, nConn * sizeof(DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW));

        if ( ldapConn == NULL ) {
            DPRINT(0,"Unable to allocate buffer to connection enum\n");
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        //
        // fill in the return buffer
        // 

        *Count = nConn;
        nConn = 0;
        pEntry = ActiveConnectionsList.Flink;

        while ( pEntry != &ActiveConnectionsList ) {

            PSOCKADDR_IN addr;
            DWORD flags;

            pConn = CONTAINING_RECORD(pEntry,
                                      LDAP_CONN,
                                      m_listEntry);

            addr = (PSOCKADDR_IN)&pConn->m_RemoteSocket;

            ldapConn[nConn].IPAddress = addr->sin_addr.s_addr;
            ldapConn[nConn].NotificationCount = pConn->m_countNotifies;
            ldapConn[nConn].TotalRequests = pConn->m_nTotalRequests;
            if ( pConn->m_userName != NULL ) {
                ldapConn[nConn].UserName = (PWCHAR)
                    THAllocEx(pTHS,
                              (wcslen(pConn->m_userName)+1) * sizeof(WCHAR));

                wcscpy(ldapConn[nConn].UserName, pConn->m_userName);

            } else {
                ldapConn[nConn].UserName = NULL;
            }

            //
            // compute the total time this guy has been connected
            //

            liConnect.LowPart = pConn->m_connectTime.dwLowDateTime;
            liConnect.HighPart = pConn->m_connectTime.dwHighDateTime;

            ldapConn[nConn].secTimeConnected = (DWORD)(
                ((liCurrent.QuadPart - liConnect.QuadPart) / 
                 (ULONGLONG)(10 * 1000 * 1000)));

            //
            // Set the correct flags
            //

            flags = 0;
            if ( pConn->m_pSecurityContext != NULL ) {
                flags |= LDAP_CONN_FLAG_BOUND;
            }

            if ( pConn->m_fSSL ) {
                flags |= LDAP_CONN_FLAG_SSL;
            }

            if ( pConn->m_fUDP ) {
                flags |= LDAP_CONN_FLAG_UDP;
            }

            if ( pConn->m_fGC ) {
                flags |= LDAP_CONN_FLAG_GC;
            }

            if ( pConn->m_fSign ) {
                flags |= LDAP_CONN_FLAG_SIGN;
            }

            if ( pConn->m_fSeal ) {
                flags |= LDAP_CONN_FLAG_SEAL;
            }

            if ( pConn->m_fSimple ) {
                flags |= LDAP_CONN_FLAG_SIMPLE;
            }

            if ( pConn->m_fGssApi ) {
                flags |= LDAP_CONN_FLAG_GSSAPI;
            }

            if ( pConn->m_fSpNego ) {
                flags |= LDAP_CONN_FLAG_SPNEGO;
            }

            if ( pConn->m_fDigest ) {
                flags |= LDAP_CONN_FLAG_DIGEST;
            }

            ldapConn[nConn].Flags = flags;

            pEntry = pEntry->Flink;
            nConn++;
        }

        *Buffer = (PVOID)ldapConn;
        Assert(nConn == *Count);
exit:;
    }__except(EXCEPTION_EXECUTE_HANDLER) {
        err = GetExceptionCode();
    }

    RELEASE_LOCK( &csConnectionsListLock );
    return err;
} // LdapEnumConnections
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\mkdit\genh.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1989 - 2000
//
//  File:       genh.cxx
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Generates Header File. Based on orginal Mr Schema stuff.

Author:

    Rajivendra Nath (RajNath) 18-Aug-1996

Revision History:

--*/

#include <ntdspchX.h>

#include "SchGen.HXX"
#include "schema.hxx"

#define MAPIHEADER   "MSDSMAPI.H"
#define MDSHEADER    "MDSchema.H"
#define ATTRHEADER   "ATTIDS.H"
#define GUIDHEADER   "NTDSGUID.H"
#define GUIDCFILE    "NTDSGUID.C"

#define DEFSTART     "OMP_O_DX_"


#define MSPREFIX        "\\x2A864886F714"
#define L0PREFIX        "\\x0992268993F22C64"
#define L1PREFIX        "\\x6086480186F84203"

BOOL fDetails=TRUE;

extern ULONG MaxUsableIndex;

char*
MakeGuid
(
    char* strguid

);


//
// Converts the Names of attr and classes in Schema.ini to a form which can
// be used as a C identifier.
//
char* MakeDef(char *s)
{
   static  char    dest[128];
   char                            *d;

   if (s == NULL) return(dest);

   strcpy(dest, s);
   _strupr(dest);
   d = dest;
   while(*d != 0)
   {
      if (*d == '-') *d = '_';
      d++;
   }
   return(dest);
}



//
// Converts attr and class names in schema.ini into the proper OMP format
//
char* gSchemanameToMSDef(NODE* pNode)
{
    static char Buffer[256];
    char ext = 0;     
    char space[5];
    char* defname=MakeDef(pNode->m_NodeName);
    char* oid = NULL;
    char  obuff[128];
    int   i;
    int   oidlen;

    if (strcmp(pNode->GetOneKey(DASHEDCLASSKEY),CLASSSCHEMAKEY)==0)
    {
            CLASSSCHEMA* cs=gSchemaObj.XGetClassSchema(pNode);
            ext='O';
            oid=cs->GovernsId();
    }
    else if (strcmp(pNode->GetOneKey(DASHEDCLASSKEY),ATTRIBUTESCHEMAKEY)==0)
    {
        ATTRIBUTESCHEMA* as=gSchemaObj.XGetAttributeSchema(pNode);
        ext='A';
        oid=as->AttributeId();
    }
    else
    {
        XINVALIDINIFILE();
    }

    
    if ( oid == strstr(oid, MSPREFIX) )
    {
        strcpy(space, "DX");
    }
    else if ( oid == strstr(oid, L0PREFIX) )
    {
        strcpy(space, "L0");
    }
    else if ( oid == strstr(oid, L1PREFIX) )
    {
        strcpy(space, "L1");
    }
    else
    {
        return NULL;
    }

    oidlen=strlen(oid);
    char* p=obuff;

    for (i=2;i<oidlen;i+=2)
    {
        p+=sprintf(p,"\\x%c%c",oid[i],oid[i+1]);
    }

    sprintf(Buffer,
            "#define OMP_O_%s_%c_%-40.40s \"%s\"\r\n",
            space,ext,defname,obuff);

    return Buffer;
}

//
// Creates the EMS Header File
//
HANDLE OpenEMSABHeader()

{
    char szNTBinDir[MAX_PATH];
    char szDSBinDir[MAX_PATH];
    char szTmp[MAX_PATH];

    char *sz = szTmp;
    char *szName;

    /*
    if (!GetEnvironmentVariable("_NTBINDIR", szNTBinDir, sizeof(szNTBinDir)))
    {
        strcpy(szNTBinDir,".");
    }

    if (!GetEnvironmentVariable("_DSROOT",   szDSBinDir, sizeof(szDSBinDir)))
    {
        strcpy(szDSBinDir,"DS");
    }
    sprintf(szTmp,"%s\\Private\\%s\\SRC\\XINC\\%s",szNTBinDir,szDSBinDir,MAPIHEADER);
    */
    HANDLE Handle;
    Handle=CreateFile
    (
        MAPIHEADER,// LPCWSTR lpFileName
        GENERIC_READ|GENERIC_WRITE,// DWORD dwDesiredAccess
        FILE_SHARE_READ,// DWORD dwShareMode
        NULL,// LPSECURITY_ATTRIBUTES lpSecurityAttributes
        CREATE_ALWAYS,// DWORD dwCreationDisposition
        FILE_ATTRIBUTE_NORMAL,// DWORD dwFlagsAndAttributes
        NULL// HANDLE hTemplateFil
    );

    if (Handle==INVALID_HANDLE_VALUE)
    {
        XRAISEGENEXCEPTION(GetLastError());
    }

    return Handle;
}


//
// Creates the MDS header file.
//
HANDLE OpenDSHeader()
{
    char szNTBinDir[MAX_PATH];
    char szDSBinDir[MAX_PATH];
    char szTmp[MAX_PATH];

    char *sz = szTmp;
    char *szName;
    /*
    if (!GetEnvironmentVariable("_NTBINDIR", szNTBinDir, sizeof(szNTBinDir)))
    {
        strcpy(szNTBinDir,".");
    }
    if (!GetEnvironmentVariable("_DSROOT",   szDSBinDir, sizeof(szDSBinDir)))
    {
        strcpy(szDSBinDir,"DS");
    }
    sprintf(szTmp,"%s\\Private\\%s\\SRC\\XINC\\%s",szNTBinDir,szDSBinDir,MDSHEADER);
    */
    HANDLE Handle;
    Handle=CreateFile
    (
        MDSHEADER,// LPCWSTR lpFileName
        GENERIC_READ|GENERIC_WRITE,// DWORD dwDesiredAccess
        FILE_SHARE_READ,// DWORD dwShareMode
        NULL,// LPSECURITY_ATTRIBUTES lpSecurityAttributes
        CREATE_ALWAYS,// DWORD dwCreationDisposition
        FILE_ATTRIBUTE_NORMAL,// DWORD dwFlagsAndAttributes
        NULL// HANDLE hTemplateFil
    );


    if (Handle==INVALID_HANDLE_VALUE)
    {
        XRAISEGENEXCEPTION(GetLastError());
    }

    return Handle;
}


//
// Creates the AttIds.h header file.
//
HANDLE OpenAttrHeader()
{
   HANDLE Handle;
    Handle=CreateFile
    (
        ATTRHEADER,// LPCWSTR lpFileName
        GENERIC_READ|GENERIC_WRITE,// DWORD dwDesiredAccess
        FILE_SHARE_READ,// DWORD dwShareMode
        NULL,// LPSECURITY_ATTRIBUTES lpSecurityAttributes
        CREATE_ALWAYS,// DWORD dwCreationDisposition
        FILE_ATTRIBUTE_NORMAL,// DWORD dwFlagsAndAttributes
        NULL// HANDLE hTemplateFil
    );


    if (Handle==INVALID_HANDLE_VALUE)
    {
        XRAISEGENEXCEPTION(GetLastError());
    }

    return Handle;
}


//
// Creates the NTDSGUID.H & NTDSGUID.C Files
//
HANDLE OpenGuidHeader(HANDLE *cFileHandle)
{
   HANDLE Handle;

    Handle=CreateFile
    (
        GUIDHEADER,// LPCWSTR lpFileName
        GENERIC_READ|GENERIC_WRITE,// DWORD dwDesiredAccess
        FILE_SHARE_READ,// DWORD dwShareMode
        NULL,// LPSECURITY_ATTRIBUTES lpSecurityAttributes
        CREATE_ALWAYS,// DWORD dwCreationDisposition
        FILE_ATTRIBUTE_NORMAL,// DWORD dwFlagsAndAttributes
        NULL// HANDLE hTemplateFil
    );


    if (Handle==INVALID_HANDLE_VALUE)
    {
        XRAISEGENEXCEPTION(GetLastError());
    }


    *cFileHandle=CreateFile
    (
        GUIDCFILE,// LPCWSTR lpFileName
        GENERIC_READ|GENERIC_WRITE,// DWORD dwDesiredAccess
        FILE_SHARE_READ,// DWORD dwShareMode
        NULL,// LPSECURITY_ATTRIBUTES lpSecurityAttributes
        CREATE_ALWAYS,// DWORD dwCreationDisposition
        FILE_ATTRIBUTE_NORMAL,// DWORD dwFlagsAndAttributes
        NULL// HANDLE hTemplateFil
    );


    if (*cFileHandle==INVALID_HANDLE_VALUE)
    {
        XRAISEGENEXCEPTION(GetLastError());
    }

    return Handle;
}

//
// Writes the Buffer (\0 terminated) to file Handle and to stdio.
//
VOID
WriteString(HANDLE Handle,char* Buffer)
{
    DWORD blen;
    if (!WriteFile
    (
        Handle,// HANDLE hFile
        Buffer,// LPCVOID lpBuffer
        strlen(Buffer),// DWORD nNumberOfBytesToWrite
        &blen,// LPDWORD lpNumberOfBytesWritten
        NULL// LPOVERLAPPED lpOverlappe
    ))
    {
        XRAISEGENEXCEPTION(GetLastError());
    }

    if (fDetails)
    {
        printf(Buffer);
    }


    return;
}

//
// Creates the MDS header file with content.
//
VOID
CreateMDS()
{
    HANDLE Handle=OpenDSHeader();
    NODE* rootnode;
    NODE* child;

    ATTRIBUTESCHEMA* as;
    CLASSSCHEMA*     cs;

    char*    buff;
    char* copyright=
    "//+---------------------------------"
        "----------------------------------------\r\n"
    "//\r\n"
    "//  Microsoft Windows\r\n"
    "//\r\n"
    "//  Copyright (C) Microsoft Corporation, 1996 - 2000\r\n"
    "//\r\n"
    "//  File:       mdschema.h\r\n"
    "//\r\n"
    "//-----------------------------------"
        "---------------------------------------\r\n"
    "\r\n"
    "\r\n"
    "\r\n";

    char* header1=
    "/*++\r\n"
    " File:    MDS.H\r\n"
    " Purpose: Contains the OID Definition for DS Pkg.\r\n"
    " Creator: Automatically Generated on\r\n"
    " Date:    ";

    char * header2=
    "\r\n"
    " ** This is a Generated File From Schema.INI **\r\n"
    " ** DO NOT MODIFY  DIRECTLY  **\r\n"
    " ** DO NOT INCLUDE DIRECTLY  **\r\n"
    "\r\n"
    "--*/\r\n";

    WriteString(Handle,copyright);
    WriteString(Handle,header1);

    time_t t = time(0);
    WriteString(Handle,asctime(localtime(&t)));

    WriteString(Handle,header2);

    char* al="//\r\n//Attribute Definitions\r\n//\r\n";
    WriteString(Handle,al);

    //
    // AttributeList
    //
    {
        YAHANDLE YAHandle;
        rootnode= new NODE(gSchemaname);

        if ( NULL == rootnode ) {
            XOUTOFMEMORY();
        }

        while (child=rootnode->GetNextChild(YAHandle))
        {

            as=gSchemaObj.GetAttributeSchema(child);

            if (as==NULL)
            {
                continue;
            }

            buff=gSchemanameToMSDef(child);
            if (buff) WriteString(Handle,buff);
        }

        delete rootnode;
    }

    char* cl="//\r\n//Class Definitions\r\n//\r\n";
    WriteString(Handle,cl);

    //
    // ClassList
    //
    {
        YAHANDLE YAHandle;
        rootnode= new NODE(gSchemaname);


        if ( NULL == rootnode ) {
            XOUTOFMEMORY();
        }

        while (child=rootnode->GetNextChild(YAHandle))
        {

            cs=gSchemaObj.GetClassSchema(child);

            if (cs==NULL)
            {
                continue;
            }
            buff=gSchemanameToMSDef(child);
            if (buff) WriteString(Handle,buff);
        }

        delete rootnode;
    }

    CloseHandle(Handle);
}


//
// Creates the MSDSMapi header file and content.
//
VOID
CreateEMS()
{
    HANDLE Handle=OpenEMSABHeader();
    INISECT* rootnode;
    char* child;

    char    Buff[256];
    char* copyright=
    "//+--------------------------------"
        "-----------------------------------------\r\n"
    "//\r\n"
    "//  Microsoft Windows\r\n"
    "//\r\n"
    "//  Copyright (C) Microsoft Corporation, 1996 - 2000\r\n"
    "//\r\n"
    "//  File:       msdsmapi.h\r\n"
    "//\r\n"
    "//----------------------------------"
        "----------------------------------------\r\n"
    "\r\n";

    char* header1=
        "/*++\r\n"
    " File:    MSDSMAPI.H\r\n"
    " Purpose: Contains the MAPI Definition .\r\n"
    " Creator: Automatically Generated on\n"
    " Date:    ";

    char * header2=
    "\r\n"
    " ** This is a Generated File From Schema.INI **\r\n"
    " ** DO NOT MODIFY  DIRECTLY  **\r\n"
    " ** DO NOT INCLUDE DIRECTLY  **\r\n"
    "\r\n"
    "--*/\r\n";

    WriteString(Handle,copyright);
    WriteString(Handle,header1);

    time_t t = time(0);
    WriteString(Handle,asctime(localtime(&t)));

    WriteString(Handle,header2);

        //
    // AttributeList
    //
    {
        YAHANDLE YAHandle;
        ATTRIBUTESCHEMA* as;
        rootnode= new INISECT(gSchemaname);
        EMAPITYPES em;
        char* ext;
        char* mt;

        // PREFIX: unlikely case
        if (!rootnode) {
            XRAISEGENEXCEPTION(ERROR_NOT_ENOUGH_MEMORY);
        }

        while (child=rootnode->GetNextKey(YAHandle,CHILDKEY))
        {
            char* mapiid;

            as=gSchemaObj.GetAttributeSchema(child);

            if (as==NULL || !(mapiid=as->MapiID()))
            {
                continue;
            }

            char* multi="";
            char* def=MakeDef(as->NodeName());

            if (!(as->IsSingle()))
            {
                multi="MV_";
            }

            em = emapiBaseType;
            ext="";
            mt = as->m_SD->m_mapiBaseType[as->m_ma];


            if (mt!=NULL)
            {
                char  tbuff1[64];
                char  tbuff2[64];

                sprintf(tbuff1,"PR_EMS_AB_%s%s",def,ext);
                sprintf(tbuff2,"PROP_TAG(PT_%s%s",multi,mt);
                sprintf(Buff,"#define %-55.55s %-30s , 0x%s)\r\n",
                        tbuff1,tbuff2,&mapiid[2]);
                WriteString(Handle,Buff);
            }

            em = emapiAnsiType;
            ext="_A";
            mt = as->m_SD->m_mapiAnsiType[as->m_ma];

            if (mt!=NULL)
            {
                char  tbuff1[64];
                char  tbuff2[64];

                sprintf(tbuff1,"PR_EMS_AB_%s%s",def,ext);
                sprintf(tbuff2,"PROP_TAG(PT_%s%s",multi,mt);
                sprintf(Buff,"#define %-55.55s %-30s , 0x%s)\r\n",
                        tbuff1,tbuff2,&mapiid[2]);
                WriteString(Handle,Buff);
            }

            em = emapiUnicodeType;
            ext="_W";
            mt = as->m_SD->m_mapiUnicodeType[as->m_ma];

            if (mt!=NULL)
            {
                char  tbuff1[64];
                char  tbuff2[64];

                sprintf(tbuff1,"PR_EMS_AB_%s%s",def,ext);
                sprintf(tbuff2,"PROP_TAG(PT_%s%s",multi,mt);
                sprintf(Buff,"#define %-55.55s %-30s , 0x%s)\r\n",
                        tbuff1,tbuff2,&mapiid[2]);
                WriteString(Handle,Buff);
            }

            em = emapiObjType;
            ext="_O";
            mt = as->m_SD->m_mapiObjType[as->m_ma];

            if (mt!=NULL)
            {
                char  tbuff1[64];
                char  tbuff2[64];

                sprintf(tbuff1,"PR_EMS_AB_%s%s",def,ext);
                sprintf(tbuff2,"PROP_TAG(PT_%s%s",multi,mt);
                sprintf(Buff,"#define %-55.55s %-30s , 0x%s)\r\n",
                        tbuff1,tbuff2,&mapiid[2]);
                WriteString(Handle,Buff);
            }

            em = emapiTType;
            ext="_T";
            mt = as->m_SD->m_mapiTType[as->m_ma];

            if (mt!=NULL)
            {
                char  tbuff1[64];
                char  tbuff2[64];

                sprintf(tbuff1,"PR_EMS_AB_%s%s",def,ext);
                sprintf(tbuff2,"PROP_TAG(PT_%s%s",multi,mt);
                sprintf(Buff,"#define %-55.55s %-30s , 0x%s)\r\n",
                        tbuff1,tbuff2,&mapiid[2]);
                WriteString(Handle,Buff);
            }


        }

        delete rootnode;
    }

    CloseHandle(Handle);

}

//
// Creates the attids.h header file with contents
//
VOID
CreateAttids()
{
    HANDLE Handle=OpenAttrHeader();
    INISECT* rootnode;
    char* child;

    char* copyright=
    "//+---------------------------------------"
        "----------------------------------\r\n"
    "//\r\n"
    "//  Microsoft Windows\r\n"
    "//\r\n"
    "//  Copyright (C) Microsoft Corporation, 1996 - 2000\r\n"
    "//\r\n"
    "//  File:       attids.h\r\n"
    "//\r\n"
    "//----------------------------------------"
        "----------------------------------\r\n"
    "\r\n"
    "\r\n"
    "\r\n";

    char* header1=
    "/*++\r\n"
    " File:    ATTIDS.H\r\n"
    " Purpose: ATTRID & CLASSID DEFINITION .\r\n"
    " Creator: Automatically generated on\r\n"
    " Date:    ";

    char * header2=
    "\r\n"
    " ** This is a Generated File From Schema.INI **\r\n"
    "\r\n"
    "--*/\r\n"
    "#ifndef _ATTIDS_\r\n"
    "#define _ATTIDS_\r\n\r\n";

    WriteString(Handle,copyright);
    WriteString(Handle,header1);

    time_t t = time(0);
    WriteString(Handle,asctime(localtime(&t)));

    WriteString(Handle,header2);


    //
    // AttributeList
    //
    {
        YAHANDLE YAHandle;
        ATTRIBUTESCHEMA* as;
        CLASSSCHEMA*     cs;
        rootnode= new INISECT(gSchemaname);
        EMAPITYPES em;
        char* ext;
        char* mt;

        char* h1="\r\n\r\n//--------------------------------------\r\n" \
              "// ATTRIBUTE MAPPINGS\r\n"
              "//--------------------------------------\r\n" ;

        WriteString(Handle,h1);

        char* AttStr="#define  ATT_%-30s 0x%-8x // ATT%c%-8d (%s)\r\n";
        char* CommentedAttStr="//Cannot use the next one in code, the actual id may vary from DC to DC\n// #define  ATT_%-30s 0x%-8x // ATT%c%-8d (%s)\r\n";

        if ( NULL == rootnode ) {
            XOUTOFMEMORY();
        }

        while (child=rootnode->GetNextKey(YAHandle,CHILDKEY))
        {
            char buff[256];

            as=gSchemaObj.GetAttributeSchema(child);

            if (as==NULL)
            {
                continue;
            }

            char* oid=as->AttributeId();
            ULONG attr=as->AttrType();
            char c = (char)as->SyntaxNdx() + 'a';
            ULONG index = (attr & 0xFFFF0000) >> 16;

            if ( index <= MaxUsableIndex) {
              // this is an id that can be used in code, so don't comment it

              sprintf(buff,AttStr,MakeDef(as->NodeName()),attr,c,attr,oid);
              WriteString(Handle,buff);
            }
            else {
              // this index is added to prefix.h after we started supporting
              // upgrades, so this is not usable in code since it may vary
              // from DC to DC just like a dynamically added attribute.
              // So do not put it in attids.h.

              // sprintf(buff,CommentedAttStr,MakeDef(as->NodeName()),attr,c,attr,oid);
              // WriteString(Handle,buff);
            }

        }

        char* h2="\r\n\r\n//--------------------------------------\r\n" \
              "// CLASS MAPPINGS\r\n"
              "//--------------------------------------\r\n" ;

        WriteString(Handle,h2);

        YAHandle.Reset();
        char* ClassStr="#define CLASS_%-30s %8d // 0x%-8x (%s)\r\n";
        char* CommentedClassStr="//Cannot use the next one in code, the actual id may vary from DC to DC\n//#define CLASS_%-30s %8d // 0x%-8x (%s)\r\n";

        while (child=rootnode->GetNextKey(YAHandle,CHILDKEY))
        {
            char buff[512];

            cs=gSchemaObj.GetClassSchema(child);

            if (cs==NULL)
            {
                continue;
            }

            char* oid=cs->GovernsId();
            ULONG attr=cs->ClassId();
            ULONG index = (attr & 0xFFFF0000) >> 16;

            if ( index <= MaxUsableIndex ) {
              // this is an id that can be used in code, so don't comment it

              sprintf(buff,ClassStr,MakeDef(cs->NodeName()),attr,attr,oid);
              WriteString(Handle,buff);
            }
            else {
              // this index is added to prefix.h after we started supporting
              // upgrades, so this is not usable in code since it may vary
              // from DC to DC just like a dynamically added attribute.
              // So do not put it in attids.h.

              // sprintf(buff,CommentedClassStr,MakeDef(cs->NodeName()),attr,attr,oid);
              // WriteString(Handle,buff);
            }

        }

        char* h4="\r\n\r\n//--------------------------------------\r\n" \
        "// ATTRIBUTE Syntax\r\n"
        "//--------------------------------------\r\n" ;

        char* AttrSyn="#define  SYNTAX_ID_%-30s %8d // 0x%-8x\r\n";
        WriteString(Handle,h4);

        YAHandle.Reset();
        while (child=rootnode->GetNextKey(YAHandle,CHILDKEY))
        {
            char buff[256];

            as=gSchemaObj.GetAttributeSchema(child);

            if (as==NULL)
            {
                continue;
            }

            char* oid=as->AttributeId();
            ULONG syntax=as->SyntaxNdx();
            ULONG attr=as->AttrType();
            ULONG omid=as->OMSyntax();

            sprintf(buff,AttrSyn,MakeDef(as->NodeName()),syntax,omid);
            WriteString(Handle,buff);

        }

    }

    char* h3="\r\n\r\n#endif \\\\_ATTIDS_\r\n";
    WriteString(Handle,h3);

    CloseHandle(Handle);
    return;

}


//
// Creates The NTDSGuid header files.
//
VOID
CreateGuid()
{
    HANDLE cHandle;
    HANDLE Handle=OpenGuidHeader(&cHandle);
    INISECT* rootnode;
    char* child;

    char* copyright=
    "//+-------------------------------------"
        "------------------------------------\r\n"
    "//\r\n"
    "//  Microsoft Windows\r\n"
    "//\r\n"
    "//  Copyright (C) Microsoft Corporation, 1996 - 2000\r\n"
    "//\r\n"
    "//  File:       ntdsguid.h\r\n"
    "//\r\n"
    "//--------------------------------------"
        "------------------------------------\r\n"
    "\r\n"
    "\r\n";

    char* ccopyright=
    "//+-------------------------------------"
        "------------------------------------\r\n"
    "//\r\n"
    "//  Microsoft Windows\r\n"
    "//\r\n"
    "//  Copyright (C) Microsoft Corporation, 1996 - 2000\r\n"
    "//\r\n"
    "//  File:       ntdsguid.c\r\n"
    "//\r\n"
    "//--------------------------------------"
        "------------------------------------\r\n"
    "\r\n"
    "\r\n";

    char* header1=
    "/*++\r\n"
    " File:    NTDSGUID.H\r\n"
    " Purpose: Contains the Schema Guids for the Attributes and Class\r\n"
    "          Schema Objects in NTDS.\r\n"
    " Creator: Automatically generated on\r\n"
    " Date:    ";

    char * header2=
    "\r\n"
    " ** This is a Generated File From Schema.INI **\r\n"
    "\r\n"
    "--*/\r\n"
    "#ifndef _NTDSGUID_\r\n"
    "#define _NTDSGUID_\r\n\r\n";

    char* header3=
    "// \r\n"
    "// The List of GUID Controls used in DS\r\n"
    "// \r\n"
    "\r\n"
    "extern const GUID GUID_CONTROL_DomainListAccounts       ;  \r\n"
    "extern const GUID GUID_CONTROL_DomainLookup             ;  \r\n"
    "extern const GUID GUID_CONTROL_DomainAdministerServer   ;  \r\n"
    "extern const GUID GUID_CONTROL_UserChangePassword       ;  \r\n"
    "extern const GUID GUID_CONTROL_UserForceChangePassword  ;  \r\n"
    "extern const GUID GUID_CONTROL_SendAs                   ;  \r\n"
    "extern const GUID GUID_CONTROL_SendTo                   ;  \r\n"
    "extern const GUID GUID_CONTROL_ReceiveAs                ;  \r\n"
    "extern const GUID GUID_CONTROL_ListGroupMembership      ;  \r\n"
    "extern const GUID GUID_CONTROL_DsInstallReplica         ;  \r\n"
    "extern const GUID GUID_CONTROL_DsSamEnumEntireDomain    ;  \r\n"
    "\r\n"
    "//\r\n"
    "// List of SAM property set GUIDS\r\n"
    "//\r\n\r\n"
    "extern const GUID GUID_PS_DOMAIN_PASSWORD               ;  \r\n"
    "extern const GUID GUID_PS_GENERAL_INFO                  ;  \r\n"
    "extern const GUID GUID_PS_USER_ACCOUNT_RESTRICTIONS     ;  \r\n"
    "extern const GUID GUID_PS_USER_LOGON                    ;  \r\n"
    "extern const GUID GUID_PS_MEMBERSHIP                    ;  \r\n"
    "extern const GUID GUID_PS_DOMAIN_OTHER_PARAMETERS       ;  \r\n"  
    "\r\n\r\n"
    "// \r\n"
    "// The list of Property Set GUIDS used by LSA\r\n"
    "// \r\n"
    "\r\n"
    "extern const GUID GUID_PS_PASSWORD_POLICY               ;   \r\n"
    "extern const GUID GUID_PS_LOCKOUT_POLICY                ;   \r\n"
    "extern const GUID GUID_PS_DOMAIN_CONFIGURATION          ;   \r\n"
    "extern const GUID GUID_PS_DOMAIN_POLICY                 ;   \r\n"
    "extern const GUID GUID_PS_PRIVILEGES                    ;   \r\n"
    "extern const GUID GUID_PS_ADMINISTRATIVE_ACCESS         ;   \r\n"
    "extern const GUID GUID_PS_LOCAL_POLICY                  ;   \r\n"
    "extern const GUID GUID_PS_AUDIT                         ;   \r\n"
    "extern const GUID GUID_PS_BUILTIN_LOCAL_GROUPS          ;   \r\n"
    "\r\n";

    char* cheader1=
    "/*++\r\n"
    " File:    NTDSGUID.C\r\n"
    " Purpose: Contains the Schema Guids for the Attributes and Class\r\n"
    "          Schema Objects in NTDS.\r\n"
    " Creator: Automatically generated on\r\n"
    " Date:    ";

    char * cheader2=
    "\r\n"
    " ** This is a Generated File From Schema.INI **\r\n"
    "\r\n"
    "--*/\r\n";

    char* cheader3=
    "\r\n"
    "#include <ntdspch.h>"
    "\r\n"
    "#include <ntdsguid.h>"
    "\r\n\r\n"
    "// \r\n"
    "// The List of GUID Controls used in DS\r\n"
    "// \r\n"
    "\r\n"
    "const GUID GUID_CONTROL_DomainListAccounts     = {0xab721a50,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b} ;   \r\n"
    "const GUID GUID_CONTROL_DomainLookup           = {0xab721a51,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b} ;   \r\n"
    "const GUID GUID_CONTROL_DomainAdministerServer = {0xab721a52,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b} ;   \r\n"
    "const GUID GUID_CONTROL_UserChangePassword     = {0xab721a53,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b} ;   \r\n"
    "const GUID GUID_CONTROL_UserForceChangePassword = {0x299570,0x246d, 0x11d0,0xa7,0x68,0x00,0xaa,0x00,0x6e,0x05,0x29} ;   \r\n"
    "const GUID GUID_CONTROL_SendAs                 = {0xab721a54,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b} ;   \r\n"
    "const GUID GUID_CONTROL_SendTo                 = {0xab721a55,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b} ;   \r\n"
    "const GUID GUID_CONTROL_ReceiveAs              = {0xab721a56,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b} ;   \r\n"
    "const GUID GUID_CONTROL_ListGroupMembership    = {0x65be5d30,0x20cf,0x11d0,0xa7,0x68,0x00,0xaa,0x00,0x6e,0x05,0x29} ;   \r\n"
    "const GUID GUID_CONTROL_DsInstallReplica       = {0x9923a32a,0x3607,0x11d2,0xb9,0xbe,0x00,0x00,0xf8,0x7a,0x36,0xb2} ;   \r\n"
    "const GUID GUID_CONTROL_DsSamEnumEntireDomain  = {0x91d67418,0x0135,0x4acc,0x8d,0x79,0xc0,0x8e,0x85,0x7c,0xfb,0xec} ;   \r\n"
    "\r\n\r\n"
    "// \r\n"
    "// The List of Property Set GUIDS used by SAM\r\n"
    "// \r\n"
    "\r\n"
    "const GUID GUID_PS_DOMAIN_PASSWORD              = {0xc7407360,0x20bf,0x11d0,0xa7,0x68,0x00,0xaa,0x00,0x6e,0x05,0x29} ;   \r\n"
    "const GUID GUID_PS_GENERAL_INFO                 = {0x59ba2f42,0x79a2,0x11d0,0x90,0x20,0x00,0xc0,0x4f,0xc2,0xd3,0xcf} ;   \r\n"
    "const GUID GUID_PS_USER_ACCOUNT_RESTRICTIONS    = {0x4c164200,0x20c0,0x11d0,0xa7,0x68,0x00,0xaa,0x00,0x6e,0x05,0x29} ;   \r\n"
    "const GUID GUID_PS_USER_LOGON                   = {0x5f202010,0x79a5,0x11d0,0x90,0x20,0x00,0xc0,0x4f,0xc2,0xd4,0xcf} ;   \r\n"
    "const GUID GUID_PS_MEMBERSHIP                   = {0xbc0ac240,0x79a9,0x11d0,0x90,0x20,0x00,0xc0,0x4f,0xc2,0xd4,0xcf} ;   \r\n"
    "const GUID GUID_PS_DOMAIN_OTHER_PARAMETERS      = {0xb8119fd0,0x04f6,0x4762,0xab,0x7a,0x49,0x86,0xc7,0x6b,0x3f,0x9a} ;   \r\n"
    "\r\n\r\n"
    "// \r\n"
    "// The list of Property Set GUIDS used by LSA\r\n"
    "// \r\n"
    "\r\n"
    "const GUID GUID_PS_PASSWORD_POLICY              = {0xa29b89fb,0xc7e8,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   \r\n"
    "const GUID GUID_PS_LOCKOUT_POLICY               = {0xa29b89fc,0xc7e8,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   \r\n"
    "const GUID GUID_PS_DOMAIN_CONFIGURATION         = {0xa29b89fd,0xc7e8,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   \r\n"
    "const GUID GUID_PS_DOMAIN_POLICY                = {0xa29b89fe,0xc7e8,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   \r\n"
    "const GUID GUID_PS_PRIVILEGES                   = {0xa29b89ff,0xc7e8,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   \r\n"
    "const GUID GUID_PS_ADMINISTRATIVE_ACCESS        = {0xa29b8a00,0xc7e8,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   \r\n"
    "const GUID GUID_PS_LOCAL_POLICY                 = {0xa29b8a01,0xc7e8,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   \r\n"
    "const GUID GUID_PS_AUDIT                        = {0xa29b8a02,0xc7e8,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   \r\n"
    "const GUID GUID_PS_BUILTIN_LOCAL_GROUPS         = {0xa29b8a03,0xc738,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   \r\n"
    "\r\n";

    WriteString(Handle,copyright);   //Write to HeaderFile
    WriteString(Handle,header1);     //Write to HeaderFile
    WriteString(cHandle,ccopyright); //Write to CFile
    WriteString(cHandle,cheader1);   //Write to CFile

    time_t t = time(0);

    WriteString(Handle ,asctime(localtime(&t)));  //Write to HeaderFile
    WriteString(cHandle,asctime(localtime(&t)));  //Write to CFile

    WriteString(Handle,header2);     //Write to HeaderFile
    WriteString(cHandle,cheader2);   //Write to CFile

    WriteString(Handle,header3);     //Write to HeaderFile
    WriteString(cHandle,cheader3);   //Write to CFile

    //
    // AttributeList
    //
    {
        YAHANDLE YAHandle;
        ATTRIBUTESCHEMA* as;
        CLASSSCHEMA*     cs;
        rootnode= new INISECT(gSchemaname);
        EMAPITYPES em;
        char* ext;
        char* mt;
        char* h5="\r\n\r\n//--------------------------------------\r\n" \
        "// ATTRIBUTE SCHEMA GUIDS\r\n"
        "//--------------------------------------\r\n" ;

        char* GuidAttrSynH="extern " "const GUID GUID_A_%-30s      ;\r\n";
        char* GuidAttrSynC=          "const GUID GUID_A_%-30s = %s ;\r\n";

        WriteString(Handle,h5);     //Write to HeaderFile
        WriteString(cHandle,h5);    //Write to CFile

        // PREFIX: unlikely case
        if (!rootnode) {
            XRAISEGENEXCEPTION(ERROR_NOT_ENOUGH_MEMORY);
        }

        YAHandle.Reset();
        while (child=rootnode->GetNextKey(YAHandle,CHILDKEY))
        {
            char  buff[256];
            char* guid;

            as=gSchemaObj.GetAttributeSchema(child);

            if (as==NULL)
            {
                continue;
            }

            guid=as->XGetOneKey("Schema-ID-GUID");


            sprintf(buff,GuidAttrSynH,MakeDef(as->NodeName()),MakeGuid(guid));
            WriteString(Handle,buff);


            sprintf(buff,GuidAttrSynC,MakeDef(as->NodeName()),MakeGuid(guid));
            WriteString(cHandle,buff);

        }



        char* h6="\r\n\r\n//--------------------------------------\r\n" \
              "// CLASS SCHEMA GUIDS\r\n"
              "//--------------------------------------\r\n" ;

        WriteString(Handle,h6);    //Write to HeaderFile
        WriteString(cHandle,h6);   //Write to CFile

        YAHandle.Reset();
        char* GuidClassStrH="extern " "const GUID GUID_C_%-30s     ;\r\n";
        char* GuidClassStrC=          "const GUID GUID_C_%-30s = %s;\r\n";

        while (child=rootnode->GetNextKey(YAHandle,CHILDKEY))
        {
            char buff[512];
            char* guid;

            cs=gSchemaObj.GetClassSchema(child);

            if (cs==NULL)
            {
                continue;
            }

            guid=cs->XGetOneKey("Schema-ID-GUID");

            sprintf(buff,GuidClassStrH,MakeDef(cs->NodeName()),MakeGuid(guid));
            WriteString(Handle,buff);


            sprintf(buff,GuidClassStrC,MakeDef(cs->NodeName()),MakeGuid(guid));
            WriteString(cHandle,buff);
        }

    }

    char* h3="\r\n\r\n#endif //_NTDSGUID_\r\n";
    WriteString(Handle,h3);

    CloseHandle(Handle);
    return;

}



//-----------------------------------------------------------------------
//
// Function Name:            MakeGuid
//
// Routine Description:
//
//    Converts from continuous string version to comma seperated string version of the GUID.
//
// Author: RajNath
//
// Arguments:
//
//    char* strguid
//
//
// Return Value:
//
//    char*                Properly Formated Version of a GUID
//
//-----------------------------------------------------------------------

DWORD  gGuidfmt[]={8,4,4,2,2,2,2,2,2,2,2};

char*
MakeGuid
(
    char* strguid

)
{
    static char sGuid[128];
    char*  dptr=sGuid;
    DWORD  i;

    strguid+=2; //skip the \x

    *dptr++='{';

    for (i=0;i<(sizeof(gGuidfmt)/sizeof(gGuidfmt[0]));i++)
    {
        *dptr++='0';
        *dptr++='x';

        memcpy(dptr,strguid,gGuidfmt[i]);
        dptr+=gGuidfmt[i];
        strguid+=gGuidfmt[i];

        *dptr++=',';

    }
    dptr--; // Remove the last , put in the last iteration of the loop

    *dptr++='}';
    *dptr++='\0';

    return sGuid;

} // End MakeGuid
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\mkdit\schema.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1989 - 1999
//
//  File:       ParseIni.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Parses Schema Initialization File

Author:

    Rajivendra Nath (RajNath) 18-Aug-1989

Revision History:

--*/

#include <ntdspchx.h>


#include "schgen.hxx"
#include "schema.hxx"

#define DEBSUB "PARSEINI:"

SyntaxDef*  gSD;
SCHEMACACHE gSchemaObj;

BOOL
InitSyntaxTable(VOID)
{
    gSD = new SyntaxDef();
    // PREFIX: claims gSD may be NULL
    if (NULL == gSD) {
        DPRINT(0, "SyntaxDef() returned NULL; giving up\n");
        XINVALIDINIFILE();
    }
    return (gSD->IsInitialized());
}

//////////////////////////////////////////////////////////
// SchemaDef Class Implementation
//////////////////////////////////////////////////////////
SyntaxDef::SyntaxDef():
    INISECT(SYNTAXSECTION),
    m_syntaxCount(0)
{
    INISECT* sm;
    char*    secname;
    YAHANDLE handle;


    int i;
    for ( i = 0; i < MAX_SYNTAX; i++ )
    {
        m_mapiBaseType[i] = NULL;
        m_mapiAnsiType[i] = NULL;
        m_mapiUnicodeType[i] = NULL;
        m_mapiObjType[i] = NULL;
        m_mapiTType[i] = NULL;
    }

    while(secname=GetNextKey(handle,SYNTAXKEY))
    {
        sm = new INISECT(secname);

        if (!sm || !sm->IsInitialized())
        {
            DPRINT1(0, "[%s] SyntaxDef::SyntaxDef Failed. Error No [Syntax]\n",__FILE__);
            XINVALIDINIFILE();
        }

        char* omsyntax=sm->GetOneKey(OMSYNTAXKEY);
        char* syntaxid=sm->GetOneKey(SYNTAXIDKEY);
        char* mapitype =sm->GetOneKey("MAPI_TYPE");
        char* mapitypeA=sm->GetOneKey("MAPI_TYPE_A");
        char* mapitypeW=sm->GetOneKey("MAPI_TYPE_W");
        char* mapitypeO=sm->GetOneKey("MAPI_TYPE_O");
        char* mapitypeT=sm->GetOneKey("MAPI_TYPE_T");

        if
        (
            omsyntax==NULL ||
            syntaxid==NULL ||
            m_syntaxCount>MAX_SYNTAX
        )
        {
            DPRINT1(0, "Error  Section [%s] Invalid\n", secname);
            XINVALIDINIFILE();
        }

        m_syntaxID[m_syntaxCount]=XStrdup(syntaxid);
        if (sscanf(m_syntaxID[m_syntaxCount],"\\x5505%x",&m_syntaxNdx[m_syntaxCount])!=1)
        {
            DPRINT1(0, "Error  Section [%s] Invalid\n", secname);
            XINVALIDINIFILE();
        }

        m_omsyntaxID[m_syntaxCount]=atoi(XStrdup(omsyntax));

        m_Name[m_syntaxCount]=XStrdup(secname);

        if (mapitype)
        {
            m_mapiBaseType[m_syntaxCount] = XStrdup(mapitype);
        }

        if (mapitypeA)
        {
            m_mapiAnsiType[m_syntaxCount] = XStrdup(mapitypeA);
        }

        if (mapitypeW)
        {
            m_mapiUnicodeType[m_syntaxCount] = XStrdup(mapitypeW);
        }

        if (mapitypeO)
        {
            m_mapiObjType[m_syntaxCount] = XStrdup(mapitypeO);
        }

        if (mapitypeT)
        {
            m_mapiTType[m_syntaxCount] = XStrdup(mapitypeT);
        }

        printf("%30s %6x %10s %2x\n",m_Name[m_syntaxCount],m_omsyntaxID[m_syntaxCount],m_syntaxID[m_syntaxCount],m_syntaxNdx[m_syntaxCount]);

        m_syntaxCount++;

        delete sm;

    }
}

DWORD
SyntaxDef::GetSyntax(ATTRIBUTESCHEMA* pNode)
{
    static DWORD ndx=0;
    DWORD sx=ndx;
    DWORD omsyn=pNode->OMSyntax();
    char* synid=pNode->SyntaxID();

    DWORD i=sx;
    do
    {
        // PREFIX: claims synid may be NULL
        if
        (
            (m_omsyntaxID[i] == omsyn)       &&
            (NULL != synid)                  &&
            (strcmp(m_syntaxID[i], synid)==0)
        )
        {
            ndx=i;
            break;
        }
        i=(i+1)%m_syntaxCount;

        if (i==sx)
        {
            // We checked all the syntaxes and didn't find this syntax
            // =>IniFile is bad.
            DPRINT1(0, "SyntaxDef::GetSyntax(%s) Failed. Error No Such Syntax\n", pNode->NodeName());
            XINVALIDINIFILE();
        }
    }while(TRUE);

    return i;
}

char*
SyntaxDef::GetMapiType(EMAPITYPES emt,DWORD Syntax)
{
     switch(emt)
    {
        case emapiBaseType: return m_mapiBaseType[Syntax];
        case emapiAnsiType: return m_mapiAnsiType[Syntax];
        case emapiUnicodeType: return m_mapiUnicodeType[Syntax];
        case emapiObjType: return m_mapiObjType[Syntax];
        case emapiTType: return m_mapiTType[Syntax];
    }

    return NULL;
}


///////////////////////////////////////////////////
// CLASSSCHEMA Class Implementation
///////////////////////////////////////////////////

CLASSSCHEMA::CLASSSCHEMA(char* ClassName):

    m_ParentCount(0)
{
    m_Node = new NODE(ClassName);
}

CLASSSCHEMA::CLASSSCHEMA(NODE* NewNode):
    m_ParentCount(0)
{
    m_Node = NewNode;
}

CLASSSCHEMA::~CLASSSCHEMA()
{

    if (m_Node)
    {
        delete m_Node;
    }

    m_ParentCount=0;
}


BOOL
CLASSSCHEMA::Initialize()
{
    if (m_Node == NULL)
    {
        return FALSE;
    }

    if (m_Node->Initialize()==FALSE)
    {
        return FALSE;
    }

    //
    // Make sure its a schema object
    //
    if (strcmp(m_Node->GetOneKey(DASHEDCLASSKEY),CLASSSCHEMAKEY)!=0)
    {
        return FALSE;
    }

    return TRUE;
}

char* CLASSSCHEMA::GovernsId()
{
    char* governsid=m_Node->GetOneKey(GOVERNSID);

    if (governsid==NULL)
    {
        DPRINT1(0, "CLASSSCHEMA::GovernsId(%s) Failed. Error GovernsId Not present\n", NodeName());
        XINVALIDINIFILE();
    }

    return governsid;
}

BOOL
CLASSSCHEMA::IsAttributeInMayContain(char* Attribute)
{
    CLASSSCHEMA* inherit=this;

    while(inherit)
    {
        char* m;
        YAHANDLE handle;
        YAHANDLE phand;

        while (m=GetNextKey(handle,MAYCONTAIN))
        {
            if (strcmp(m,Attribute)==0)
            {
                return TRUE;
            }
        }

        inherit = GetNextParent(phand);
    }

    return FALSE;
}

ULONG
CLASSSCHEMA::ClassId()
{
    ULONG attrtyp;
    if (OidStrToAttrType(pTHStls, FALSE, GovernsId(), &attrtyp))
    {
        DPRINT1(0, "CLASSSCHEMA::ClassId(%s) Failed. Error GovernsId Not present\n", NodeName());
        XINVALIDINIFILE();
    }

    return attrtyp;
}



BOOL
CLASSSCHEMA::IsAttributeInMustContain(char* Attribute)
{
    CLASSSCHEMA* inherit=this;


    while(inherit)
    {
        char* m;
        YAHANDLE handle;
        YAHANDLE phand;

        while (m=GetNextKey(handle,MAYCONTAIN))
        {
            if (strcmp(m,Attribute)==0)
            {
                return TRUE;
            }
        }

        inherit = GetNextParent(phand);
    }

    return FALSE;
}

void
CLASSSCHEMA::InitParentList()
{
    YAHANDLE handle;
    char*    parent;

    DWORD    cur=0;
    DWORD    fre=cur+1;
    m_ParentList[cur]=this;

    while (cur<fre)
    {
        CLASSSCHEMA* cn=m_ParentList[cur++];
        CLASSSCHEMA* nn;

        handle.Initialize(cn->m_Node,PARENTKEY);

        // Top is parent of Top check...
        if (strcmp(cn->NodeName(),TOPCLASS)!=0)
        {
            while (parent=cn->GetNextKey(handle,PARENTKEY))
            {
                if (fre>=MAX_SCHEMA_RDNS)
                {
                    XINVALIDINIFILE();
                }

                nn=m_ParentList[fre++]=gSchemaObj.GetClassSchema(parent);
            }

        }
    }

    m_ParentCount=fre;

    return;
}

CLASSSCHEMA*
CLASSSCHEMA::GetNextParent(YAHANDLE& Handle)
{
    if (!Handle.m_IsInitialized)
    {
        Handle.Initialize(this->m_Node,NULL);
        if (strcmp(TOPCLASS,NodeName())!=0)
        {
            // TOP IS ITS ON PARENT BUT REST ARE
            // NOT.
            Handle.m_ndx=1;
        }

    }

    if (m_ParentCount==0)
    {
        InitParentList();
    }

    if (Handle.m_ndx<m_ParentCount)
    {
        return m_ParentList[Handle.m_ndx++];
    }

    return NULL;

}

typedef struct {char* ClassName;char* Prefix;ULONG Attr;}RDNPREFIXTABLE;

RDNPREFIXTABLE RDNPrefixTable[]=
{
    {COUNTRYNAME,"C",ATT_COUNTRY_NAME},
    {COMMONNAME,"CN",ATT_COMMON_NAME},
    {ORGNAME,"O",ATT_ORGANIZATION_NAME},
    {ORGUNITNAME,"OU",ATT_ORGANIZATIONAL_UNIT_NAME},
    {"Locality","L",ATT_LOCALITY_NAME},

};

#define RDNPREFIXCOUNT (sizeof(RDNPrefixTable)/sizeof(RDNPrefixTable[0]))

char* CLASSSCHEMA::RDNPrefixName()
{
    char* rdnatt=XGetOneKey(RDNATTID);
    for (int i=0;i<RDNPREFIXCOUNT;i++)
    {
        if (strcmp(RDNPrefixTable[i].ClassName,rdnatt)==0)
        {
            break;
        }
    }

    if (i==RDNPREFIXCOUNT)
    {
        DPRINT1(0, "CLASSSCHEMA::RDNPrefix(%s) Failed. Error No Such RDN\n", NodeName());
        XINVALIDINIFILE();
    }

    return RDNPrefixTable[i].Prefix;
}

ULONG CLASSSCHEMA::RDNPrefixType()
{
    char* rdnatt=XGetOneKey(RDNATTID);
    for (int i=0;i<RDNPREFIXCOUNT;i++)
    {
        if (strcmp(RDNPrefixTable[i].ClassName,rdnatt)==0)
        {
            break;
        }
    }

    if (i==RDNPREFIXCOUNT)
    {
        DPRINT1(0, "CLASSSCHEMA::RDNPrefix(%s) Failed. Error No Such RDN\n", NodeName());
        XINVALIDINIFILE();
    }

    return RDNPrefixTable[i].Attr;
}


///////////////////////////////////////////////////
// ATTRIBUTESCHEMA Class Implementation
///////////////////////////////////////////////////

ATTRIBUTESCHEMA::ATTRIBUTESCHEMA(char* ClassName):
    m_SD(gSD)
{
    m_Node = new NODE(ClassName);
}

ATTRIBUTESCHEMA::ATTRIBUTESCHEMA(NODE* NewNode):
    m_SD(gSD)
{
    m_Node = NewNode;
}

ATTRIBUTESCHEMA::~ATTRIBUTESCHEMA()
{
    if (m_Node)
    {
        delete m_Node;
    }
}


BOOL
ATTRIBUTESCHEMA::Initialize()
{
    if (m_Node == NULL)
    {
        return FALSE;
    }

    if (m_Node->Initialize()==FALSE)
    {
        return FALSE;
    }

    //
    // Make sure its a schema object
    //

    if (strcmp(m_Node->GetOneKey(DASHEDCLASSKEY),ATTRIBUTESCHEMAKEY)!=0)
    {
        return FALSE;
    }

    m_ma=m_SD->GetSyntax(this);

    return TRUE;
}

char* ATTRIBUTESCHEMA::AttributeId()
{
    char* governsid=GetOneKey(ATTRIBUTEID);

    if (governsid==NULL)
    {
        DPRINT1(0, "ATTRIBUTESCHEMA::AttributeId(%s) Failed. Error No Such ID\n", NodeName());
        XINVALIDINIFILE();
    }

    return governsid;


}

#define MAPIIDKEY "Mapi-ID"
char* ATTRIBUTESCHEMA::MapiID()
{
    // This is a MAY-HAVE => can be NULL
    char* governsid=GetOneKey(MAPIIDKEY);

    return governsid;
}


#define ISSINGLEKEY "Is-Single-Valued"
BOOL ATTRIBUTESCHEMA::IsSingle()
{
    char* v=GetOneKey(ISSINGLEKEY);

    if (v==NULL)
    {
        DPRINT1(0, "ATTRIBUTESCHEMA::IsSingle(%s) Failed. Error No Key\n", NodeName());
        XINVALIDINIFILE();
    }

    return (strcmp(v,"TRUE")==0);

}


#define SYSTEMFLAGSKEY "System-Flags"

DWORD
ATTRIBUTESCHEMA::SystemFlags()
{
    char* v=GetOneKey(SYSTEMFLAGSKEY);
    if(v) {
        // It is an assumption that no one ever specifies a negative flag
        // value.
        return strtoul(v,(char **)NULL, 0);
    }
    else
        return 0;
}

#define OMSYNTAXIDKEY "OM-Syntax"
#define ATTRSYNTAXKEY "Attribute-Syntax"

DWORD
ATTRIBUTESCHEMA::OMSyntax()
{
    char* v=GetOneKey(OMSYNTAXIDKEY);
    // PREFIX: claims 'v' may be NULL
    if (NULL == v) {
        DPRINT1(0, "ATTRIBUTESCHEMA::OMSyntax(%s) Failed. Error No OM-Syntax\n", NodeName());
        XINVALIDINIFILE();
    }
    return atoi(v);
}

char*
ATTRIBUTESCHEMA::SyntaxID()
{
    char*  v=GetOneKey(ATTRSYNTAXKEY);
    return v;
}

DWORD
ATTRIBUTESCHEMA::SyntaxNdx()
{
    return m_SD->m_syntaxNdx[m_ma];
}

ULONG
ATTRIBUTESCHEMA::AttrType()
{
    ATTRTYP attrtyp;
    if (OidStrToAttrType(pTHStls, FALSE, AttributeId(), &attrtyp))
    {
        DPRINT1(0, "ATTRIBUTESCHEMA::ATTRIBUTESCHEMA::AttrType(%s) Failed. Error No such Attr\n", NodeName());
        XINVALIDINIFILE();
    }

    return attrtyp;
}


BOOL
ATTRIBUTESCHEMA::IsLinkAtt()
{
    char* v=GetOneKey(LINKIDKEY);
    if(v) {
        // link id present
        return TRUE;
    }
    else
        return FALSE;
}

//////////////////////////////////////////////////////////////////
// gSchemaObj
//////////////////////////////////////////////////////////////////


#define ATTRCACHESIZE  2048
#define CLASSCACHESIZE 2048

SCHEMACACHE::SCHEMACACHE()
{
    int cnt=ATTRCACHESIZE;

    for (int i=0;i<cnt;i++)
    {
        m_AttrCache[i]=0;
    }

    cnt=CLASSCACHESIZE;

    for (i=0;i<cnt;i++)
    {
        m_ClassCache[i]=0;
    }
}

void
SCHEMACACHE::Clear()
{
    int cnt=ATTRCACHESIZE;

    for (int i=0;i<cnt;i++)
    {
        m_AttrCache[i]=0;
    }

    cnt=CLASSCACHESIZE;

    for (i=0;i<cnt;i++)
    {
        m_ClassCache[i]=0;
    }
}

SCHEMACACHE::~SCHEMACACHE()
{
    int cnt=ATTRCACHESIZE;

    for (int i=0;i<cnt;i++)
    {
        if (m_AttrCache[i]!=0)
            delete m_AttrCache[i];
    }

    cnt=CLASSCACHESIZE;

    for (i=0;i<cnt;i++)
    {
        if (m_ClassCache[i]!=0)
            delete m_ClassCache[i];
    }
}

ATTRIBUTESCHEMA*
SCHEMACACHE::GetAttributeSchema(char* Name)
{
    DWORD hash = Hash(Name,ATTRCACHESIZE);

    while(m_AttrCache[hash]!=NULL)
    {
        if (strcmp(m_AttrCache[hash]->NodeName(),Name)==0)
        {
            return m_AttrCache[hash];
        }

        hash=(hash+1)%ATTRCACHESIZE;
    }


    m_AttrCache[hash]=new ATTRIBUTESCHEMA(Name);

    if (m_AttrCache[hash] && !m_AttrCache[hash]->Initialize())
    {
        delete m_AttrCache[hash];
        m_AttrCache[hash]=NULL;
        return NULL;
    }
    //printf("DBG:Loading Attr %s in Cache\n",Name);
    return m_AttrCache[hash];
}

CLASSSCHEMA*
SCHEMACACHE::GetClassSchema(char* Name)
{

    DWORD hash = Hash(Name,CLASSCACHESIZE);

    while(m_ClassCache[hash]!=NULL)
    {
        if (strcmp(m_ClassCache[hash]->NodeName(),Name)==0)
        {
            return m_ClassCache[hash];
        }

        hash=(hash+1)%CLASSCACHESIZE;
    }

    m_ClassCache[hash]=new CLASSSCHEMA(Name);

    if (m_ClassCache[hash] && !m_ClassCache[hash]->Initialize())
    {
        delete m_ClassCache[hash];
        m_ClassCache[hash]=NULL;
        return NULL;
    }
    //printf("DBG:Loading class %s in Cache\n",Name);
    return m_ClassCache[hash];
}

ATTRIBUTESCHEMA*
SCHEMACACHE::XGetAttributeSchema(char* Name)
{
    ATTRIBUTESCHEMA* as=GetAttributeSchema(Name);

    if (as==NULL)
    {
        DPRINT1(0, "ATTRIBUTESCHEMA::ATTRIBUTESCHEMA::AttrType(%s) Failed. Error No such Attr\n", Name);
        XINVALIDINIFILE();
    }
    return as;
}

CLASSSCHEMA*
SCHEMACACHE::XGetClassSchema(char* Name)
{

    CLASSSCHEMA* as=GetClassSchema(Name);
    if (as==NULL)
    {
        DPRINT1(0, "ATTRIBUTESCHEMA::XGetClassSchema(%s) Failed. Error No such Class\n", Name);
        XINVALIDINIFILE();
    }
    return as;
}

ATTRIBUTESCHEMA*
SCHEMACACHE::GetAttributeSchema(NODE* Node)
{
    DWORD hash = Hash(Node->NodeName(),ATTRCACHESIZE);

    while(m_AttrCache[hash]!=NULL)
    {
        if (strcmp(m_AttrCache[hash]->NodeName(),Node->NodeName())==0)
        {
            return m_AttrCache[hash];
        }

        hash=(hash+1)%ATTRCACHESIZE;
    }


    m_AttrCache[hash]=new ATTRIBUTESCHEMA(Node);

    if (m_AttrCache[hash] && !m_AttrCache[hash]->Initialize())
    {
        m_AttrCache[hash]->m_Node=NULL;
        delete m_AttrCache[hash];
        m_AttrCache[hash]=NULL;
        return NULL;
    }
    //printf("DBG:Loading Attr %s in Cache\n",m_AttrCache[hash]->NodeName());
    Node->m_Cached=TRUE;
    //printf("CACHED:%s\n",m_AttrCache[hash]->m_Node->NodeName());
    return m_AttrCache[hash];
}

CLASSSCHEMA    *
SCHEMACACHE::GetClassSchema(NODE* Node)
{
    DWORD hash = Hash(Node->NodeName(),CLASSCACHESIZE);

    while(m_ClassCache[hash]!=NULL)
    {
        if (strcmp(m_ClassCache[hash]->NodeName(),Node->NodeName())==0)
        {
            return m_ClassCache[hash];
        }

        hash=(hash+1)%CLASSCACHESIZE;
    }

    m_ClassCache[hash]=new CLASSSCHEMA(Node);

    if (m_ClassCache[hash] && !m_ClassCache[hash]->Initialize())
    {
        m_ClassCache[hash]->m_Node=NULL;
        delete m_ClassCache[hash];
        m_ClassCache[hash]=NULL;
        return NULL;
    }
    //printf("DBG:Loading class %s in Cache\n",m_ClassCache[hash]->NodeName());
    Node->m_Cached=TRUE;
    //printf("CACHED:%s\n",m_ClassCache[hash]->m_Node->NodeName());
    return m_ClassCache[hash];
}


ATTRIBUTESCHEMA*
SCHEMACACHE::XGetAttributeSchema(NODE* Node)
{
    ATTRIBUTESCHEMA* as=GetAttributeSchema(Node);

    if (as==NULL)
    {
        DPRINT1(0, "SCHEMACACHE::XGetAttributeSchema(%s) Failed. Error No such Attr\n", Node->NodeName());
        XINVALIDINIFILE();
    }
    return as;
}

CLASSSCHEMA    *
SCHEMACACHE::XGetClassSchema(NODE* Node)
{

    CLASSSCHEMA* as=GetClassSchema(Node);
    if (as==NULL)
    {
        DPRINT1(0, "SCHEMACACHE::XGetClassSchema(%s) Failed. Error No such Class\n", Node->NodeName());
        XINVALIDINIFILE();
    }
    return as;
}


DWORD
SCHEMACACHE::Hash(char* NameStr,DWORD Count)
{
    DWORD num=0;
    while (*NameStr!='\0')
    {
        num=(num*16+(*NameStr++))%Count;
    }

    return num;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\nspis\abdefs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       abdefs.h
//
//--------------------------------------------------------------------------

/*************************************************************
* Context handle structure
*************************************************************/
typedef struct _MAPI_SEC_CHECK_CACHE {
    DWORD DNT;
    BOOL  checkVal;
} MAPI_SEC_CHECK_CACHE;

#define MAPI_SEC_CHECK_CACHE_MAX 4
// 10 minutes, in seconds
#define MAPI_SEC_CHECK_CACHE_LIFETIME (10 * 60)
typedef struct _NSPI_CONTEXT {
    DWORD GAL;
    DWORD TemplateRoot;
    DWORD BindNumber;
    DWORD HierarchyIndex;
    DWORD HierarchyVersion;
    BOOL  PagedHierarchy;
    DSTIME CacheTime;
    DWORD CacheIndex;
    MAPI_SEC_CHECK_CACHE ContainerCache[MAPI_SEC_CHECK_CACHE_MAX];
    DWORD scrLines;
} NSPI_CONTEXT;

typedef struct _IndexSize {
    DWORD TotalCount;
    DWORD ContainerID;
    DWORD ContainerCount;
} INDEXSIZE, *PINDEXSIZE;


extern SCODE
ABUpdateStat_local (
        THSTATE *pTHS,
        DWORD dwFlags,
        PSTAT pStat,
        PINDEXSIZE pIndexSize,
        LPLONG plDelta
        );


extern SCODE
ABCompareDNTs_local (
        THSTATE *pTHS,
        DWORD dwFlags,
        PSTAT pStat,
        PINDEXSIZE pIndexSize,
        DWORD DNT1,
        DWORD DNT2,
        LPLONG plResult
        );


extern SCODE
ABQueryRows_local (
        THSTATE *pTHS,
        NSPI_CONTEXT *pMyContext,        
        DWORD dwFlags,
        PSTAT pStat,
        PINDEXSIZE pIndexSize,
        DWORD dwEphsCount,
        DWORD * lpdwEphs,
        DWORD Count,
        LPSPropTagArray_r pPropTags,
        LPLPSRowSet_r ppRows
        );


extern SCODE
ABSeekEntries_local (
        THSTATE *pTHS,
        NSPI_CONTEXT *pMyContext,        
        DWORD dwFlags,
        PSTAT pStat,
        PINDEXSIZE pIndexSize,
        LPSPropValue_r pTarget,
        LPSPropTagArray_r Restriction,
        LPSPropTagArray_r pPropTags,
        LPLPSRowSet_r ppRows
        );


extern SCODE
ABGetMatches_local (
        THSTATE *pTHS,
        DWORD               dwFlags,
        PSTAT               pStat,
        PINDEXSIZE          pIndexSize,
        LPSPropTagArray_r   pInDNTList,
        ULONG               ulInterfaceOptions,
        LPSRestriction_r    pRestriction,
        LPMAPINAMEID_r      lpPropName,
        ULONG               ulRequested,
        LPLPSPropTagArray_r ppDNTList,
        LPSPropTagArray_r   pPropTags,
        LPLPSRowSet_r       ppRows
        );

extern SCODE
ABResolveNames_local (
        THSTATE *pTHS,
        DWORD dwFlags,
        PSTAT pStat,
        PINDEXSIZE pIndexSize,
        LPSPropTagArray_r pPropTags,
        LPStringsArray_r paStr,
        LPWStringsArray_r paWStr,
        LPLPSPropTagArray_r ppFlags,
        LPLPSRowSet_r ppRows
        );

extern SCODE
ABDNToEph_local (
        THSTATE *pTHS,
        DWORD dwFlags,
        LPStringsArray_r pNames,
        LPLPSPropTagArray_r ppEphs
        );

extern SCODE
ABGetHierarchyInfo_local (
        THSTATE *pTHS,
        DWORD dwFlags,
        NSPI_CONTEXT *pMyContext,
        PSTAT pStat,
        LPDWORD lpVersion,
        LPLPSRowSet_r HierTabRows
        );

extern SCODE
ABResortRestriction_local (
        THSTATE            *pTHS,
        DWORD               dwFlags,
        PSTAT               pStat,
        LPSPropTagArray_r   pInDNTList,
        LPSPropTagArray_r  *ppOutDNTList
        );


extern SCODE
ABBind_local (
        THSTATE *pTHS,
        handle_t hRpc,
        DWORD dwFlags,
        PSTAT pStat,
        LPMUID_r pServerGuid,
        VOID **contextHandle
        );


extern SCODE
ABGetNamesFromIDs_local (
        THSTATE *pTHS,
        DWORD dwFlags,
        LPMUID_r lpguid,
        LPSPropTagArray_r  pInPropTags,
        LPLPSPropTagArray_r  ppOutPropTags,
        LPLPNameIDSet_r ppNames
        );

extern SCODE
ABGetIDsFromNames_local (
                    THSTATE *pTHS,
                    DWORD dwFlags,
                    ULONG ulFlags,
                    ULONG cPropNames,
                    LPMAPINAMEID_r *ppNames,
                    LPLPSPropTagArray_r  ppPropTags);

extern SCODE
ABGetPropList_local (
        THSTATE *pTHS,
        DWORD dwFlags,
        DWORD dwEph,
        ULONG CodePage,
        LPLPSPropTagArray_r ppPropTags);

extern SCODE
ABQueryColumns_local (
        THSTATE *pTHS,
        DWORD dwFlags,
        ULONG ulFlags,
        LPLPSPropTagArray_r ppColumns
        );

extern SCODE
ABGetProps_local (
        THSTATE *pTHS,
        DWORD dwFlags,
        PSTAT pStat,
        PINDEXSIZE pIndexSize,
        LPSPropTagArray_r pPropTags,
        LPLPSRow_r ppRow
        );

extern SCODE
ABGetTemplateInfo_local (
        THSTATE *pTHS,
        NSPI_CONTEXT *pMyContext,
        DWORD dwFlags,
        ULONG ulDispType,
        LPSTR pDN,
        DWORD dwCodePage,
        DWORD dwLocaleID,
        LPSRow_r * ppData
        );

extern SCODE
ABModProps_local (
        THSTATE *pTHS,
        DWORD dwFlag,
        PSTAT pStat,
        LPSPropTagArray_r pTags,
        LPSRow_r pSR);

extern SCODE
ABModLinkAtt_local (
        THSTATE *pTHS,
        DWORD dwFlags,
        DWORD ulPropTag,
        DWORD dwEph,
        LPENTRYLIST_r lpEntryIDs);

extern SCODE
ABDeleteEntries_local (
        THSTATE *pTHS,
        DWORD dwFlags,
        DWORD dwEph,
        LPENTRYLIST_r lpEntryIDs
        );

extern void
ABCheckContainerRights (
        THSTATE *pTHS,
        NSPI_CONTEXT *pMyContext,
        STAT *pStat,
        PINDEXSIZE pIndexSize
        );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\mkdit\stubs.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stubs.c
//
//--------------------------------------------------------------------------

/*
   This file contains stubbed out versions of routines that exist in
   ntdsa.dll, but that we do not want to link to and/or properly initialize
   in mkdit and mkhdr.  For every set of routines added into this file, one
   library should be omitted from the UMLIBS section of the boot\sources file.
 */
#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                   // schema cache
#include <dbglobal.h>                 // The header for the directory database
#include <mdglobal.h>                 // MD global definition header
#include <dsatools.h>                 // needed for output allocation
#include "dsevent.h"                  // header Audit\Alert logging
#include "mdcodes.h"                  // header for error codes
#include "dsexcept.h"
#include "debug.h"                    // standard debugging header
#include <taskq.h>
#include <nlwrap.h>                   // I_NetLogon* wrappers

/* replaces taskq.lib */

DWORD gTaskSchedulerTID = 0;

BOOL
InitTaskScheduler(
    IN  DWORD           cSpares,
    IN  SPAREFN_INFO *  pSpares
    )
{
    return TRUE;
}

void
ShutdownTaskSchedulerTrigger()
{
    return;
}

BOOL
ShutdownTaskSchedulerWait(
    DWORD   dwWaitTimeInMilliseconds
    )
{
    return TRUE;
}

BOOL gfIsTqRunning = TRUE;

BOOL
DoInsertInTaskQueue(
    PTASKQFN    pfnTaskQFn,
    void *      pvParm,
    DWORD       cSecsFromNow,
    BOOL        fReschedule,
    PCHAR       pfnName
    )
{
    return TRUE;
}

BOOL
DoCancelTask(
    PTASKQFN    pfnTaskQFn,    // task to remove
    void *      pvParm,        // task parameter
    PCHAR       pfnName
    )
{
    return TRUE;
}

DWORD
DoTriggerTaskSynchronously(
    PTASKQFN    pfnTaskQFn,
    void *      pvParm,
    PCHAR       pfnName
    )
{
    return ERROR_SUCCESS;
}

/* end of taskq.lib */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\nspis\abserv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       abserv.h
//
//--------------------------------------------------------------------------

/*************************************************************/
/*                                                           */
/* Defines the useful routines in jetnsp.c and details.c     */
/*                                                           */
/*                                                           */
/*   History                                                 */
/*   1/11/94  Created by Tim Williams                        */
/*   2/7/94   Added exports from details.c                   */
/*                                                           */
/*************************************************************/

#define ATTR_BUF_SIZE    1000    // I don't know, is this enough?

/* This is a validly formed exception
 * 0xE = (binary 1110), where the first two bits are the severity
 *
 *     Sev - is the severity code
 *
 *         00 - Success
 *         01 - Informational
 *         10 - Warning
 *         11 - Error
 *
 *    and the third bit is the Customer flag (1=an app, 0=the OS)
 *
 * The rest of the high word is the facility, and the low word
 * is the code.  For now, I have stated that the DSA is facility 1,
 * and the only exception code we have is 1.
 */

/*************************************************************
* In abtools.c
*************************************************************/

#include "abdefs.h"

#undef _JET_INCLUDED
#include <dsjet.h>


extern void R_Except( PSZ pszCall, JET_ERR err );

extern BOOL
ABDispTypeAndStringDNFromDSName (
        DSNAME *pDN,
        PUCHAR *ppChar,
        DWORD *pDispType);

extern DWORD
ABGetDword (
        THSTATE *pTHS,
        BOOL UseSortTable,
        ATTRTYP Att);

extern JET_ERR
ABSeek (
        THSTATE *pTHS,
        void * pvData,
        DWORD cbData,
        DWORD Flags,
        DWORD ContainerID,
        DWORD attrTyp);

extern JET_ERR
ABMove (THSTATE *pTHS,
        long Delta,
        DWORD ContainerID,
        BOOL fmakeRecordCurrent);

extern void
ABFreeSearchRes (
        SEARCHRES *pSearchRes);

extern void
ABGotoStat (
        THSTATE *pTHS,
        PSTAT pStat,
        PINDEXSIZE pIndexSize,
        LPLONG plDelta
        );

extern void
ABGetPos (
        THSTATE *pTHS,
        PSTAT pStat,
        PINDEXSIZE pIndexSize
        );

extern DWORD
ABDNToDNT (
        THSTATE *pTHS,
        LPSTR pDN);

extern void
ABMakePermEID (
        THSTATE *pTHS,
        LPUSR_PERMID *ppEid,
        LPDWORD pCb,
        ULONG ulType,
        LPSTR pDN 
        );

extern DWORD
ABSetIndexByHandle (
        THSTATE *pTHS,
        PSTAT pStat,
        BOOL MaintainCurrency);

extern ULONG
ABGetOneOffs (
        THSTATE *pTHS,
        NSPI_CONTEXT *pMyContext,
        PSTAT pStat,
        LPSTR ** papDispName,
        LPSTR ** papDN,
        LPSTR ** papAddrType,
        LPDWORD *paDNT);

extern SCODE
ABSearchIndex(
        ULONG hIndex,
        LPSTR indexName,
        DWORD ContainerID,
        DWORD MaxEntries,
        PSZ   pTarget,
        ULONG cbTarget,
        DWORD *pdwCount,
        DWORD matchType);

extern BOOL
abCheckReadRights(
        THSTATE *pTHS,
        PSECURITY_DESCRIPTOR pSec,
        ATTRTYP AttId
        );

extern BOOL
abCheckObjRights(
        THSTATE *pTHS
        );

extern DWORD
abGetLameName (
        CHAR **);

extern DWORD
ABDispTypeFromClass (
        DWORD dwClass);

extern DWORD
ABClassFromDispType (
        DWORD dwType);

extern DWORD
ABObjTypeFromClass (
        DWORD dwClass);

extern DWORD
ABObjTypeFromDispType (
        DWORD dwDispType);

extern DWORD
ABClassFromObjType (
        DWORD objType);

extern ULONG
ABMapiSyntaxFromDSASyntax (
        DWORD dwFlags,
        ULONG dsSyntax,
        ULONG ulLinkID,
        DWORD dwSpecifiedSyntax);

// The index names supported by handles for the address book.
extern char *aszIndexName[];

// In this macro, x is the index handle, y is the container.
#define INDEX_NAME_FROM_HANDLE(x,y) (aszIndexName[2 * x + (y?1:0)])

// The string name of the dnt index.
extern char szDNTIndex[];

// The string name of the PDNT index.
extern char szPDNTIndex[];

// The string name of the abview index.
extern char szABViewIndex[];

// The EMS address book provider's MAPIUID
extern MAPIUID muidEMSAB;

// The EMS address book provider's EMAIL type.
extern char    *lpszEMT_A;
extern DWORD   cbszEMT_A;
extern wchar_t *lpszEMT_W;
extern DWORD   cbszEMT_W;

/************************************************************
* In absearch.c
************************************************************/

extern DWORD
ABDispTypeRestriction (
        PSTAT pStat,
        LPSPropTagArray_r pInDNTList,
        LPSPropTagArray_r *ppDNTList,
        DWORD DispType,
        DWORD maxEntries);

extern SCODE
ABGetTable (
        THSTATE *pTHS,
        PSTAT pStat,
        ULONG ulInterfaceOptions,
        LPMAPINAMEID_r lpPropName,
        ULONG fWritable,
        DWORD ulRequested,
        ULONG *pulFound);

extern SCODE
ABGenericRestriction(
        THSTATE *pTHS,
        PSTAT pStat,
        BOOL  bOnlyOne,
        DWORD ulRequested,
        DWORD *pulFound,
        BOOL  bPutResultsInSortedTable,
        LPSRestriction_r pRestriction,
        SEARCHARG    **ppCachedSearchArg);

extern SCODE
ABProxySearch (
        THSTATE *pTHS,
        PSTAT pStat,
        PWCHAR pwTarget,
        DWORD cbTarget);


/************************************************************
* In details.c
************************************************************/

extern SCODE
GetSrowSet (
        THSTATE           *pTHS,
        PSTAT             pStat,
        PINDEXSIZE        pIndexSize,
        DWORD             dwEphsCount,
        DWORD             *lpdwEphs,
        DWORD             Count,
        LPSPropTagArray_r pPropTags,
        LPSRowSet_r *     Rows,
        DWORD	          Flags
        );

/* data used elsewhere. */
extern SPropTagArray_r DefPropsA[];     // default MAPI proptag array


// Constants for the largest byte count for unicode attributes
#define MAX_DISPNAME  256
#define CBMAX_DISPNAME (MAX_DISPNAME * sizeof(wchar_t))

/************************************************************
* In modprop.c
************************************************************/
extern void
PValToAttrVal (
        THSTATE *pTHS,
        ATTCACHE * pAC,
        DWORD cVals,
        PROP_VAL_UNION * pVu,
        ATTRVAL * pAV,
        ULONG ulPropTag,
        DWORD dwCodePage);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\nspis\abbind.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       abbind.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module implements the bind and unbind functions for the NSPI
    interface. 

Author:

    Dave Van Horn (davevh) and Tim Williams (timwi) 1990-1995

Revision History:
    
    25-Apr-1996 Split this file off from a single file containing all address
    book functions, rewrote to use DBLayer functions instead of direct database
    calls, reformatted to NT standard.
    
--*/
#include <NTDSpch.h>
#pragma  hdrstop


#include <ntdsctr.h>                   // PerfMon hooks

// Core headers.
#include <ntdsa.h>                      // Core data types 
#include <scache.h>                     // Schema cache code
#include <dbglobal.h>                   // DBLayer header.
#include <mdglobal.h>                   // THSTATE definition
#include <dsatools.h>                   // Memory, etc.

// Logging headers.
#include <mdcodes.h>                    // Only needed for dsevent.h
#include <dsevent.h>                    // Only needed for LogUnhandledError

// Assorted DSA headers.
#include <dsexcept.h>

// Assorted MAPI headers.
#include <mapidefs.h>                   // These two files have stuff we
#include <mapicode.h>                   //  need to be a MAPI provider

// Nspi interface headers.
#include "nspi.h"                       // defines the nspi wire interface
#include <nsp_both.h>                   // a few things both client/server need
#include <_entryid.h>                   // Defines format of an entryid
#include <abserv.h>                     // Address Book interface local stuff

#include <hiertab.h>                    // Hierarchy Table stuff

#include "debug.h"          // standard debugging header
#define DEBSUB "ABBIND:"              // define the subsystem for debugging

#include <sddl.h>

#include <fileno.h>
#define  FILENO FILENO_ABBIND


volatile DWORD BindNumber = 1;
SCODE
ABBind_local(
        THSTATE *pTHS,
        handle_t hRpc,
        DWORD dwFlags,
        PSTAT pStat,
        LPMUID_r pServerGuid,
        VOID **contextHandle
        )
/*++

Routine Description:       

    Nspi wire function.  Binds a client.  Checks for correct authentication,
    check that the code page the client is requesting is supported on this
    server.  Returns the servers guid and an RPC context handle.

Arguments:

    hRpc - the bare (non-context) RPC handle the client used to find us.

    dwFlags - unused.

    pStat - contains the code page the client wants us to support

    pServerGuid - [o] where we return the guid of this server.

    contextHandle - the RPC context handle for the client to use from now on.

ReturnValue:

    SCODE as per MAPI.

--*/
{
    BYTE *pSid = NULL;
    DWORD cbSid = 0;
    DWORD *pdwLastSidSubauthority;
    DWORD err=NO_ERROR;
    char *szAccount;
    DWORD cbAccount = 0;
    char *szDomain;
    DWORD cbDomain = 0;
    SID_NAME_USE snu;
    unsigned char *szStringBinding;
    NSPI_CONTEXT *pMyContext = NULL;
    DWORD         GALDNT = INVALIDDNT;
    DWORD         TemplateDNT = INVALIDDNT;
    RPC_BINDING_HANDLE hServerBinding;
    
    // make sure the context handle is NULL in case of error 
    *contextHandle = NULL;
    
    
    // Derive a partially bound handle with the client's network address.
    err = RpcBindingServerFromClient(hRpc, &hServerBinding);
    if (err) {
        DPRINT1(0, "RpcBindingServerFromClient() failed, error %d!\n", err);
    }
    else {
        // log the RPC connection
        if (!RpcBindingToStringBinding(hServerBinding, &szStringBinding)) {
            LogEvent(DS_EVENT_CAT_MAPI,
                 DS_EVENT_SEV_VERBOSE,
                 DIRLOG_RPC_CONNECTION,
                 szInsertSz(szStringBinding),
                 NULL,
                 NULL);
        
            DPRINT1 (1, "ABBinding client: %s\n", szStringBinding);

            RpcStringFree(&szStringBinding);
        }

        RpcBindingFree(&hServerBinding);
    }


    // Check the code page.
    if (!IsValidCodePage(pStat->CodePage)) {
        LogEvent(DS_EVENT_CAT_MAPI,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_BAD_CODEPAGE,
                 szInsertUL(pStat->CodePage),
                 NULL,
                 NULL);
        return  MAPI_E_UNKNOWN_CPID;
    }
    
    
    if(!(dwFlags & fAnonymousLogin)) {
        // They want us to validate them as a non-guest authentication,
    
        // make sure we can authenticate the client 
        if (!(pSid = GetCurrentUserSid())) {
            // can't authenticate client - return error
            LogEvent(DS_EVENT_CAT_SECURITY,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_UNAUTHENTICATED_LOGON,
                     NULL,
                     NULL,
                     NULL);
            return MAPI_E_LOGON_FAILED;
        }
        cbSid = GetLengthSid(pSid);
        
        // now check if the client isn't a guest (as is the case for a
        // nonauthenticated named pipe connection 
        pdwLastSidSubauthority =
            GetSidSubAuthority(pSid,
                               ((DWORD) (*GetSidSubAuthorityCount(pSid))) - 1);

        // Are we guest or the null session?
        if((*pdwLastSidSubauthority  == DOMAIN_USER_RID_GUEST) ||
           (*pdwLastSidSubauthority  == SECURITY_ANONYMOUS_LOGON_RID) ||
           (*pdwLastSidSubauthority  == SECURITY_WORLD_RID)) {

            #if DBG
            CHAR   *SidText;

            ConvertSidToStringSid(pSid, &SidText);
            DPRINT3 (1, "ABBind using SID: %s 0x%x(len=%d). Rejected\n", SidText, pSid, cbSid);

            if (SidText) {
                LocalFree (SidText);
            }
            #endif

            // client is guest - reject 
            free(pSid);
            LogEvent(DS_EVENT_CAT_SECURITY,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_UNAUTHENTICATED_LOGON,
                     NULL,
                     NULL,
                     NULL);
            return MAPI_E_LOGON_FAILED;
        }
    }

#ifdef DBG

    {
        CHAR   *SidText;

        if (!(dwFlags & fAnonymousLogin)) {
            ConvertSidToStringSid(pSid, &SidText);
            DPRINT3 (1, "ABBind using SID: %s 0x%x(len=%d)\n", SidText, pSid, cbSid);

            if (SidText) {
                LocalFree (SidText);
            }
        }
        else {
            DPRINT (1, "ABBind using Anonymous Login\n");
        }
    }

#endif

    HTGetGALAndTemplateDNT((NT4SID *)pSid, cbSid, &GALDNT, &TemplateDNT);
    if(pSid) {
        free(pSid);
    }

    LogEvent(DS_EVENT_CAT_MAPI,
             DS_EVENT_SEV_INTERNAL,
             DIRLOG_API_TRACE,
             szInsertSz("NspiBind"),
             NULL,
             NULL);
    
    
    // Allocate a context structure
    pMyContext = (NSPI_CONTEXT *) malloc(sizeof(NSPI_CONTEXT));
    if(!pMyContext) {
        return MAPI_E_LOGON_FAILED;
    }
    
    memset(pMyContext, 0, sizeof(NSPI_CONTEXT));
    // Count the number of binds we've done.
    pMyContext->BindNumber = BindNumber++;
    *contextHandle = (void *) pMyContext;
    pMyContext->GAL = GALDNT;
    pMyContext->TemplateRoot = TemplateDNT;
    
    // Grab the server Guid
    if(pServerGuid)
        memcpy(pServerGuid, &pTHS->InvocationID, sizeof(MAPIUID));
    
    return SUCCESS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\nspis\abserv.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       abserv.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module implements address book server functions and some worker
    routines to aid in implementation.

Author:

    Tim Williams (timwi) 1996

Revision History:
    
    8-May-1996 Split everything but the wire entrypoints from nspserv.c to here.
    
--*/


#include <NTDSpch.h>
#pragma  hdrstop


#include <ntdsctr.h>                   // PerfMon hooks

// Core headers.
#include <ntdsa.h>                      // Core data types 
#include <scache.h>                     // Schema cache code
#include <dbglobal.h>                   // DBLayer header.
#include <mdglobal.h>                   // THSTATE definition
#include <dsatools.h>                   // Memory, etc.

// Logging headers.
#include <mdcodes.h>                    // Only needed for dsevent.h
#include <dsevent.h>                    // Only needed for LogUnhandledError

// Assorted DSA headers.
#include <hiertab.h>                    // Hierarchy Table stuff
#include <dsexcept.h>
#include <objids.h>                     // need ATT_* consts
#include <debug.h>

// Assorted MAPI headers.
#include <mapidefs.h>                   // These four files
#include <mapitags.h>                   //  define MAPI
#include <mapicode.h>                   //  stuff that we need
#include <mapiguid.h>                   //  in order to be a provider.

// Nspi interface headers.
#include "nspi.h"                       // defines the nspi wire interface
#include <nsp_both.h>                   // a few things both client/server need
#include <_entryid.h>                   // Defines format of an entryid
#include <abserv.h>                     // Address Book interface local stuff
#include <msdstag.h>
#include <_hindex.h>                    // Defines index handles.


#include "debug.h"                      // standard debugging header 
#define DEBSUB "ABSERV:"                // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_ABSERV

DWORD gulDoNicknameResolution = FALSE;

SPropTagArray_r DefPropsDos[] =
{
    7,
    PR_EMS_AB_DOS_ENTRYID,
    PR_OBJECT_TYPE,
    PR_DISPLAY_TYPE,
    PR_DISPLAY_NAME_A,
    PR_PRIMARY_TELEPHONE_NUMBER_A,
    PR_DEPARTMENT_NAME_A,
    PR_OFFICE_LOCATION_A
};


                   
/******************** External Entry Points *****************/

SCODE
ABUpdateStat_local(
        THSTATE *pTHS,
        DWORD dwFlags,
        PSTAT pStat,
        PINDEXSIZE pIndexSize,
        LPLONG plDelta
        )
/*++
  
Routine Description:

    Internal wire function.  Updates a stat block, applying the movement
    specified in the stat block and fills in the current DNT.
    
Arguments:

    dwFlags - unused

    pStat - [o] The STAT block to move to (implies a current position followed
        by a delta move).

    plDelta - [o] If non-null, returns the number of rows actually moved.
    
Return Value:
    
    SCODE as per MAPI.
    
--*/       
{
    // Go to where the stat block tells us.
    ABGotoStat(pTHS, pStat, pIndexSize, plDelta);
    
    // Update the Stat to the new position.
    ABGetPos(pTHS, pStat, pIndexSize );
    
    return pTHS->errCode;
}


SCODE
ABCompareDNTs_local(
        THSTATE *pTHS,
        DWORD dwFlags,
        PSTAT pStat,
        PINDEXSIZE pIndexSize,
        DWORD DNT1,
        DWORD DNT2,
        LPLONG plResult
        )
/*++

Routine Description:       

    Internal wire function. Compare two DNTs for position in the container in
    the stat block, find out which is first in this index.  The special DNTs
    BOOKMARK_BEGINNING and BOOKMARK_END are supported.

    plResult <  0    -> DNT1 is first
    plResult == 0    -> DNT1 and DNT2 are the same
    plResult >  0    -> DNT2 is first
    
Arguments:

    dwFlags - unused
    
    pStat - [o] The stat block describing the table to use if no explicit list
        of DNTS has been given.  The stat block is updated to the next unread
        row.
    
    DNT1 - the first DNT.    

    DNT2 - the second DNT.    

    plResult - [o] the result of the comparison.

Return Value:

    Returns an SCODE, as per MAPI.

--*/
{
    ULONG   cb1, cb2;
        
    if(DNT1 == BOOKMARK_END || DNT2 == BOOKMARK_END) {
        if(DNT1 == BOOKMARK_BEGINNING || DNT2 == BOOKMARK_BEGINNING) {
            // Simple case, since BOOKMARK_BEGINNING < BOOKMARK_END
            *plResult = DNT1 - DNT2;
        }
        else {
            // Note, if DNTx != BOOKMARK_END, then DNTx > BOOKMARK_END 
            *plResult = DNT2 - DNT1;
        }
    }
    else {
        if(DNT1 == BOOKMARK_BEGINNING || DNT2 == BOOKMARK_BEGINNING) {
            // Find the real DNT of BOOKMARK_BEGINNING and reset the DNT of
            // the beginning into whoever is referencing it.
            STAT stat = *pStat; 
            stat.CurrentRec = BOOKMARK_BEGINNING;
            stat.Delta = 0;
            ABGotoStat(pTHS, &stat, pIndexSize, NULL );
            // Now at Stat position, in the right index
            if (DNT1 == BOOKMARK_BEGINNING)
                DNT1 = stat.CurrentRec;
            if (DNT2 == BOOKMARK_BEGINNING)
                DNT2 = stat.CurrentRec;
        }

        // set the correct locale in thread state
        pTHS->dwLcid = pStat->SortLocale;
        pTHS->fDefaultLcid = FALSE;
        
        // Neither DNT1 or DNT2 are special cases.  Use DB layer to compare.
        if(DBCompareDNTs(pTHS->pDB,
                         Idx_ABView,
                         NULL,
                         DNT1, DNT2, plResult))
            pTHS->errCode = (ULONG) MAPI_E_CALL_FAILED;
    }
    
    return pTHS->errCode;
}

SCODE
ABQueryRows_local(
        THSTATE *pTHS,
        NSPI_CONTEXT *pMyContext,        
        DWORD dwFlags,
        PSTAT pStat,
        PINDEXSIZE pIndexSize,
        DWORD dwEphsCount,
        DWORD * lpdwEphs,
        DWORD Count,
        LPSPropTagArray_r pPropTags,
        LPLPSRowSet_r ppRows
        )
/*++

Routine Description:       

    Internal wire function.  Returns a number of rows, either based on an
    explicit list of ephemeral IDs (DNTs) with a count, or a stat block.  Use
    the stat block if the count is 0 (Actually, the GetSrowSet makes the
    decision). 
    
    Note, there is no requirement here to return the number of entries actually
    asked for.  For example, if dwRequestCount is 20, the provider can return 20
    or less entries. 
    
Arguments:

    dwFlags - passed to GetSRowSet
    
    pStat - [o] The stat block describing the table to use if no explicit list
        of DNTS has been given.  The stat block is updated to the next unread
        row.
    
    dwEphsCount - The number of explicit DNTs given.  If 0, use the stat block.

    lpdwEphs - The explicit DNT list.
    
    Count - The number of rows requested.
    
    pPropTags - the properties to get for each row.
    
    ppRows - [o] The actual row set returned.

ReturnValue:

    Returns an SCODE, as per MAPI.

--*/
{
    LPSRowSet_r  tempSRowSet;
    SCODE        scode = SUCCESS_SUCCESS;
    
    if(!pPropTags)
        // No properties were specified, so use the default set.
        pPropTags = DefPropsDos;
    else if(pPropTags->cValues < 1) {
        // Negative values?  We don't do that.
        *ppRows = NULL;
        return MAPI_E_NOT_ENOUGH_RESOURCES;
    }

    Assert(dwEphsCount || pIndexSize->ContainerID == pStat->ContainerID);
    if(Count == 0) {
        // The haven't requested any rows.  Fake stuff up.
        tempSRowSet = THAllocEx(pTHS, sizeof(SRowSet));
        tempSRowSet->cRows = 0;
        
        // And update the Stat block while we are here.
        ABGotoStat(pTHS, pStat, pIndexSize, NULL );
        ABGetPos(pTHS, pStat, pIndexSize );
    }
    else if((!dwEphsCount && !pIndexSize->ContainerCount) || (pStat->ContainerID==INVALIDDNT)) {
        // They didn't supply any DNTs and the container they are interested in is empty. 
        // or don't have permissions to read container
        // Return an empty Row Set.
        tempSRowSet = THAllocEx(pTHS, sizeof(SRowSet));
        tempSRowSet->cRows = 0;
        
        // And set the stat block to the end of an empty table.
        pStat->TotalRecs = pStat->NumPos = pStat->CurrentRec
            = pStat->Delta = 0;
    }
    else {
        // Normal case, there are some rows to return.  Call to a local row
        // set retrieval routine.

        // adjust the number of lines we return on preemptive calls to QueryRows
        if (pMyContext->scrLines < Count && Count < DEF_SROW_COUNT) {
            pMyContext->scrLines = Count;
        }

        tempSRowSet = NULL;

        scode =GetSrowSet(pTHS,
                          pStat,
                          pIndexSize,
                          dwEphsCount,
                          lpdwEphs,
                          Count,
                          pPropTags,
                          &tempSRowSet,
                          dwFlags);
        if (scode == MAPI_W_ERRORS_RETURNED)
            scode = SUCCESS_SUCCESS;
    }
    *ppRows = tempSRowSet;

    return scode;
}

SCODE
abSeekInRestriction (
        THSTATE          *pTHS,
        PSTAT             pStat,
        wchar_t           *pwTarget,
        DWORD             cbTarget,
        LPSPropTagArray_r Restriction,
        DWORD            *pnRestrictEntries,
        LPDWORD          *ppRestrictEntry
        )
/*++
  Description:       
      Given a restriction, a stat block, and a unicode target, find the first
      element in the restriction with a value greater than or equal to the
      target.  Return the number of objects in the restriction greater than the
      target, a pointer to the first dnt in the restriciton greater than the
      target, and an updated stat block.

  Arguments:
    pStat - IN/OUT The stat block to use, and update.

    pwTarget - IN pointer to unicode value we're looking for.

    cbTarget - IN number of bytes in that value.

    Restriction - IN The list of DNTs that defines the restriction we're looking
                  in. 

    pnRestrictEntries - The number of objects in the restriction greater than
        the target.

    ppRestrictEntry - pointer to place to put a pointer to a list of DWORDS of
        the DNTs that are greater than the target.  Caller can use this to do a
        GetSrowSet. Gets set to some intermediate element in the Restriction,
        not to newly allocated memory.


  Return Values:        
    An SCODE.
  
--*/  
{
    int       ccDisplayName;
    int       ccTarget;
    wchar_t   DispNameBuff[CBMAX_DISPNAME];
    DWORD     dwBegin, dwEnd, dwMiddle;
    BOOL      fFound=FALSE;
    LONG      compValue;
    SCODE     scode = MAPI_E_NOT_FOUND;

    // If the restriction is empty, we can't find anything.
    if(Restriction->cValues  ==  0) {
        return MAPI_E_NOT_FOUND;
    }
    
    // We'll need to know how many unicode chars the target is. Since we
    // know the size in bytes, compute the size in wchar_t's.
    ccTarget = cbTarget / sizeof(wchar_t);
    
    DBFindDNT(pTHS->pDB,
              Restriction->aulPropTag[Restriction->cValues-1]);
    
    memset(DispNameBuff, 0, CBMAX_DISPNAME);
    DBGetSingleValue(pTHS->pDB,
                     ATT_DISPLAY_NAME,
                     DispNameBuff,
                     CBMAX_DISPNAME,&ccDisplayName);
    Assert(ccDisplayName < CBMAX_DISPNAME);
    ccDisplayName /= sizeof(wchar_t);
    
    if(CompareStringW(pStat->SortLocale,
                      LOCALE_SENSITIVE_COMPARE_FLAGS,
                      pwTarget,
                      ccTarget,
                      DispNameBuff,
                      ccDisplayName  )    > 2) {
        /* Nothing in restriction is GE the target. */
        return MAPI_E_NOT_FOUND;
    }
    
    // Set the bounds for our binary sort
    dwMiddle = dwBegin = 0;
    dwEnd = Restriction->cValues - 1;
    
    while(!fFound) {
        dwMiddle = (dwBegin + dwEnd ) / 2;
        DBFindDNT(pTHS->pDB, Restriction->aulPropTag[dwMiddle] );
        memset(DispNameBuff, 0, CBMAX_DISPNAME);
        
        DBGetSingleValue(pTHS->pDB,
                         ATT_DISPLAY_NAME,
                         DispNameBuff,
                         CBMAX_DISPNAME,&ccDisplayName);
        Assert(ccDisplayName < CBMAX_DISPNAME);
        ccDisplayName /= sizeof(wchar_t);
        
        compValue = CompareStringW(pStat->SortLocale,
                                   LOCALE_SENSITIVE_COMPARE_FLAGS,
                                   pwTarget,
                                   ccTarget,
                                   DispNameBuff,
                                   ccDisplayName);
        
        if(compValue <= 2) {
            // targ is LE this one, search front 
            if(dwEnd == dwMiddle) { // this last entry left?   
                dwMiddle = dwBegin; // then we're done         
                fFound = TRUE;      // break out of while loop 
            }
            dwEnd = dwMiddle;
        }
        else {
            // targ is GT this one, search back 
            if(dwBegin == dwMiddle) { // this last entry?        
                fFound = TRUE;        // break out of while loop 
                dwMiddle++;
            }
            dwBegin = dwMiddle;
        }
    }
    
    
    /* We're at the first dnt >= the target. */
    pStat->CurrentRec = Restriction->aulPropTag[dwMiddle];
    pStat->NumPos = dwMiddle;
    scode = SUCCESS_SUCCESS;
    *pnRestrictEntries = (Restriction->cValues - dwMiddle);
    *ppRestrictEntry = &Restriction->aulPropTag[dwMiddle];
    
    // Note: at this point, *pnRestrictEntries > 0, since we already errored out
    // if Restriction->cValues == 0, and  0 <= dwMiddle < Restriction->cValues.
    // We care about this since the GetSrowSet we are about to make needs
    // nRestrictEntries != 0 to imply that we are using the DNTs of a
    // restriction. 

    return scode;
}

SCODE
ABSeekEntries_local (
        THSTATE *pTHS,
        NSPI_CONTEXT *pMyContext,        
        DWORD dwFlags,
        PSTAT pStat,
        PINDEXSIZE pIndexSize,
        LPSPropValue_r pTarget,
        LPSPropTagArray_r Restriction,
        LPSPropTagArray_r pPropTags,
        LPLPSRowSet_r ppRows
        )
/*****************************************************************************
*   Seek Entries
*
* PSTAT  [out]  pStat       ptr to Status Block
* LPSTR    [in]    pszTarget   Text to search for
* LPSPropTagArray_r [in]  Restriction
* DWORD     [in]   dwFlags       flags for searching
*
* Search for and position Stat on first entry greater than or equal to
* the string given in Target.  If nothing is greater, return MAPI_E_NOT_FOUND
*
* If Restriction is not null, it is an array of DWORDs making up the
* DNTs of a restricted table.  Search in this array for a match, rather
* than in the index in the stat block.
*
* If index is proxy address index, do a whole DIT search looking for matches.
* Don't directly walk the index since this would bypass normal security.
******************************************************************************/
{
    SCODE       scode;
    wchar_t     *pwTarget = NULL;
    PUCHAR      pucTarget = NULL;
    ULONG       cb;
    DWORD       NumRows = 0;                  // start with zero preemptive buffer rows
                                              // and see what the client has
    DWORD       nRestrictEntries = 0;
    LPDWORD     pRestrictEntry = NULL;

    scode = MAPI_E_NOT_FOUND;                // assume the worst

    
    // if we have a value there, it means we have already adjusted for the client screen size
    if (pMyContext && pMyContext->scrLines) {
        NumRows = pMyContext->scrLines;
    }

    switch(pStat->hIndex) {
    case H_DISPLAYNAME_INDEX:
        // Normal Seek.
        if(PROP_ID(pTarget->ulPropTag) != PROP_ID(PR_DISPLAY_NAME)) {
            // Hey, you can't seek on something other than display name in this
            // index. 
            return MAPI_E_CALL_FAILED;
        }

        // Translate target to Unice
        switch (PROP_TYPE(pTarget->ulPropTag)) {
        case PT_STRING8:
            // convert target string to unicode 
            pwTarget = THAllocEx(pTHS, CBMAX_DISPNAME);
            memset(pwTarget, 0, CBMAX_DISPNAME);
            
            MultiByteToWideChar(pStat->CodePage,
                                0,
                                pTarget->Value.lpszA,
                                -1,
                                pwTarget,
                                CBMAX_DISPNAME);
            cb = wcslen(pwTarget)* sizeof(wchar_t);
            break;
            
        case PT_UNICODE:
            pwTarget = pTarget->Value.lpszW;
            cb = wcslen(pwTarget) * sizeof(wchar_t);
            break;
            
        default:
            /* I don't do this one. */
            return  MAPI_E_CALL_FAILED;
            break;
        }
        
        
        ABSetIndexByHandle(pTHS, pStat, 0 );
        if(!Restriction) {
            // Normal seek.
            if(!ABSeek(pTHS, pwTarget, cb, dwFlags,
                       pStat->ContainerID, ATT_DISPLAY_NAME)) {
                // found an object, get it's position.
                ABGetPos(pTHS, pStat, pIndexSize );
                scode = SUCCESS_SUCCESS;
            }
        }
        else {
            // Seek in a restriction.
            scode = abSeekInRestriction(pTHS,
                                        pStat,
                                        pwTarget,
                                        cb,
                                        Restriction,
                                        &nRestrictEntries,
                                        &pRestrictEntry);
            if(scode != SUCCESS_SUCCESS) {
                return scode;
            }
            NumRows = min(NumRows, nRestrictEntries);
        }
        break;
        
    case H_PROXY_INDEX:
        // Seek in the proxy index.  This is only done by the proxy API.
        if(PROP_ID(pTarget->ulPropTag) != PROP_ID(PR_EMS_AB_PROXY_ADDRESSES)) {
            // Hey, you can't seek on something other than proxy in this
            // index. 
            return MAPI_E_CALL_FAILED;
        }
        
        // Translate target to Unicode
        switch (PROP_TYPE(pTarget->ulPropTag)) {
        case PT_MV_STRING8:
        case PT_STRING8:
            // convert target string to unicode.  This call allocates space.
            pwTarget = UnicodeStringFromString8(pStat->CodePage,
                                                pTarget->Value.MVszA.lppszA[0],
                                                -1);
            cb = wcslen(pwTarget)* sizeof(wchar_t);
            break;
            
        case PT_UNICODE:
        case PT_MV_UNICODE:
            pwTarget = pTarget->Value.MVszW.lppszW[0];
            cb = wcslen(pwTarget) * sizeof(wchar_t);
            break;
            
            
        default:
            // I don't do this one. 
            return MAPI_E_CALL_FAILED;
            break;
        }
        // OK, go do the proxy search
        scode = ABProxySearch(pTHS, pStat, pwTarget, cb);
        break;

    default:
        // Hey, this shouldn't happen.
        return  MAPI_E_CALL_FAILED;
        break;
    }
    
    if(pPropTags && NumRows) {        
        // Make a pre-emptive strike and do a QueryRows 
        STAT    dummyStat = *pStat;

        // GetSrowSet will leave us at the end of the move.  We don't want that,
        // so we'll give it a dummy Stat to use. 
        GetSrowSet(pTHS,
                   &dummyStat,
                   pIndexSize,
                   nRestrictEntries,
                   pRestrictEntry,
                   NumRows,
                   pPropTags,
                   ppRows,
                   (dwFlags | fEPHID));
    }
    return scode;                                                
}

SCODE
ABGetMatches_local(
        THSTATE            *pTHS,
        DWORD               dwFlags,
        PSTAT               pStat,
        PINDEXSIZE          pIndexSize,
        LPSPropTagArray_r   pInDNTList,
        ULONG               ulInterfaceOptions,
        LPSRestriction_r    pRestriction,
        LPMAPINAMEID_r      lpPropName,
        ULONG               ulRequested,
        LPLPSPropTagArray_r ppDNTList,
        LPSPropTagArray_r   pPropTags,
        LPLPSRowSet_r       ppRows
        )
/*****************************************************************************
*   Get Match List
*
* DWORD               [in]              dwFlags
*        Flags for later expansion.
*
* PSTAT               [in,out]          pStat
*        Where are we?
*
* LPSPropTagArray_r   [in]              pInDNTList
*        A list of DNTs to further restrict.  This is used to apply a
*   Restriction to a table that is already a restriction (i.e. Member list,
*   link\backlink table, etc.)  If NULL, ignore.
*
* ULONG               [in]              ulInterfaceOptions
*        Special MAPI flags. Only useful when getting an attribute table
*   (GetTable()).
*
* LPRestriction_r     [in]              Filter
*        The restriction to apply.  If NULL, get an attribute table.
*
* LPMAPINAMEID        [in]              lpPropName
*        The name of the Property to get a table on if this is a restriction
*   getting an attribute table for OpenProperty.  Ignored if Filter != NULL.
*
* ULONG               [in]              ulRequested
*        Maximum Number of things to match. If exceeded, return
*   MAPI_E_TABLE_TOO_BIG.
*
* LPLPSPropTagArray_r [out]             ppDNTList
*        The DNTs the restriction matched.
*
* LPSPropTagArray_r   [in]              pPropTags
*        A column set to use for a pre-emptive QueryRows call.  We don't
*   do the pre-emptive call if this is NULL.
*
* LPLPSRowSet_r       [out]             ppRows
*        The row set for the pre-emptive QueryRows call.
*
******************************************************************************/
{
    SCODE         scode = SUCCESS_SUCCESS;
    DWORD         i;
    DB_ERR        err;
    DWORD         NumRows = DEF_SROW_COUNT;
    ULONG         ulFound = 0;
    ATTCACHE      *pAC;
    
    (*ppRows)=NULL;
    
    __try {  /* finally */
        
        pTHS->dwLcid = pStat->SortLocale;
        pTHS->fDefaultLcid = FALSE;
        
        if(pInDNTList) {
            /* The only restriction we support on pre-restricted lists
             * is DispType, which should already have been taken care of.
             * Therefore, this restriction is too complex.
             */
            pTHS->errCode = (ULONG) MAPI_E_TOO_COMPLEX;
            _leave;
        }
        
        if(!pRestriction &&
           (pStat->hIndex == H_READ_TABLE_INDEX ||
            pStat->hIndex == H_WRITE_TABLE_INDEX ))        {
            /* They want a table interface to a DN or ORName valued att */
            pTHS->errCode = ABGetTable(pTHS,
                                       pStat,
                                       ulInterfaceOptions,
                                       lpPropName,
                                       (pStat->hIndex ==H_WRITE_TABLE_INDEX),
                                       ulRequested,
                                       &ulFound);
        }
        else {
            // generic restriction
            pTHS->errCode = ABGenericRestriction(pTHS,
                                                 pStat,
                                                 FALSE,
                                                 ulRequested,
                                                 &ulFound,
                                                 TRUE,
                                                 pRestriction,
                                                 NULL);
        }
        
        /*
         * The sort table now has the sorted list, pull it out,
         * and do a GetSrowSet on it.
         */
        
        if (pTHS->errCode == SUCCESS_SUCCESS) {
            /* Init the return value. */
            *ppDNTList=(LPSPropTagArray_r)THAllocEx(pTHS, sizeof(SPropTagArray_r) +
                                                    (1+ulFound)*sizeof(DWORD));
            
            /* Pull the DNTs out of the table in order */
            err = DBMove(pTHS->pDB, TRUE, DB_MoveFirst);
            i = 0;
            while(err == DB_success)  {
                (*ppDNTList)->aulPropTag[i++] = ABGetDword(pTHS,
                                                           TRUE, FIXED_ATT_DNT);
                err = DBMove(pTHS->pDB, TRUE, DB_MoveNext);
            }
        
            Assert(i==ulFound);
        
            if(ulFound != 0 && pPropTags)  {
                /* Make a pre-emptive strike and do a QueryRows */
                STAT dummyStat = *pStat;
                if(ulFound < NumRows)
                    NumRows = ulFound;
                
                GetSrowSet(pTHS,
                           &dummyStat,
                           pIndexSize,
                           NumRows,
                           (*ppDNTList)->aulPropTag,
                           NumRows,
                           pPropTags,
                           ppRows,
                           (dwFlags | fEPHID));
            }
        }
    }
    __finally {
        DBCloseSortTable(pTHS->pDB);
    }

    scode = pTHS->errCode;

    /* Setup the return stuff */
    if(!scode) {
        if(!(*ppDNTList)) {
            /* Somehow, we got here and didn't have a table to return, and
             * had no scode.  As this is outside the try-except, it could be
             * fatal.  Fix that.
             */
            *ppRows = NULL;
            scode = MAPI_E_CALL_FAILED;
        }
        else { /* No errors found, ulFound objects found */
            (*ppDNTList)->cValues = ulFound;
        }
    }
    else {
        *ppRows = NULL;
        *ppDNTList = NULL;
    }

    return scode;
}

SCODE
ABResolveNames_local (
        THSTATE *pTHS,
        DWORD dwFlags,
        PSTAT pStat,
        PINDEXSIZE pIndexSize,
        LPSPropTagArray_r pPropTags,
        LPStringsArray_r paStr,
        LPWStringsArray_r paWStr,
        LPLPSPropTagArray_r ppFlags,
        LPLPSRowSet_r ppRows
        )
/*****************************************************************************
*   Resolve Names
*
*        Takes a sparse, counted array of strings (paStr) and a PropTagArray.
* Returns an array of flags (one for each string) telling how many matches
* were found for each string (0, 1, or >1) and an SRowSet with 1 row for
* each string that had exactly 1 match. (I'd like to re-use the strings
* array as the flags, but RPC wouldn't like it.  It would try to deref
* any non-zero flag as a string pointer.)
*
*         This call is critical to good performance, since it is used in our
* most critical benchmarks.  However, this version has been thrown together
* from available pieces.  Much improvement is clearly possible. Future
* enhancements:
*         Make GetSRowSet handle sparse DNT arrays so we don't have to compress.
*       Note: getsrowset handles sparse DNT arrays, so we should do this one
*           soon.
******************************************************************************/
{
    UINT              i, Count, cDNTs;
    LPSPropTagArray_r pFlags;
    LPDWORD           pFs;
    SRestriction_r    anrRestrict; 
    SPropValue_r      anrProp;
    BOOL              bUnicode = (BOOL) (paWStr != NULL);
    LPSTR pStr;
    SEARCHARG         *pCachedSearchArg = NULL;

    pTHS->dwLcid = pStat->SortLocale;
    pTHS->fDefaultLcid = FALSE;
    
    (*ppRows)=NULL;
    if(!pPropTags)
        pPropTags = DefPropsA;

    if(bUnicode) {
        Count = paWStr->Count;
    }
    else {
        Count = paStr->Count;
    }
    pFlags = (LPSPropTagArray_r)THAllocEx(pTHS, sizeof(DWORD) +
                                          Count * sizeof(DWORD));
    pFlags->cValues = Count;
    pFs = (LPDWORD)&pFlags->aulPropTag;   /* shortcut direct to DW array */
    *ppFlags = pFlags;                      /* output */
    cDNTs = 0;                              /* init number found */
    
    for(i=0; i<Count; i++) {
        LPSTR       tempChar;
        ULONG       ulFound;
        SCODE       scode;
        DWORD       matchType =bAPPROX;

        if((bUnicode && !paWStr->Strings[i]) ||
           (!bUnicode && !paStr->Strings[i]) )  {
            // nothing here 
            pFs[i] = MAPI_UNRESOLVED;
            // skip this one 
            continue;         
        }
        
        if(dwFlags & EMS_AB_ADDRESS_LOOKUP) {
            /* we are only interested in ANR that exact matches
             * a proxy address
             */
            STAT tempStat = *pStat;
            SPropValue_r sPropVal;
            LPSRowSet_r pRows=NULL;

            if(bUnicode) {
                // Unicode proxy passed in
                sPropVal.ulPropTag = PR_EMS_AB_PROXY_ADDRESSES_W;
                sPropVal.Value.MVszW.cValues = 1;
                sPropVal.Value.MVszW.lppszW = &paWStr->Strings[i];
            }
            else {
                // String 8 proxy passed in
                sPropVal.ulPropTag = PR_EMS_AB_PROXY_ADDRESSES;
                sPropVal.Value.MVszA.cValues = 1;
                sPropVal.Value.MVszA.lppszA = &paStr->Strings[i];
            }
            
            tempStat.hIndex = H_PROXY_INDEX;
            tempStat.CurrentRec = 0;

            PERFINC(pcNspiProxyLookup);        // PerfMon hook
            
            scode=ABSeekEntries_local(pTHS,
                                      NULL,
                                      bEXACT,
                                      &tempStat,
                                      pIndexSize,
                                      &sPropVal,
                                      NULL,
                                      NULL,
                                      &pRows);

            // Assume ulFound is the current record.
            ulFound = tempStat.CurrentRec;
            if(scode) {
                // Failed to find the object by proxy address.  See if it's a DN
                // style email address.
                if(bUnicode) {
                    // Unicode string was passed in.  ASCIIize it (we're going
                    // to pass it to ABDNToDNT, pVu->lpszAwhich only accepts ASCII DNs).
                    pStr = String8FromUnicodeString(TRUE,
                                                    pStat->CodePage,
                                                    paWStr->Strings[i],
                                                    -1,
                                                    NULL,
                                                    NULL);
                }
                else {
                    pStr = paStr->Strings[i];
                }
                
                // We have an ASCII string now.
                if ((_strnicmp(pStr, EMAIL_TYPE, sizeof(EMAIL_TYPE)-1) == 0) &&
                    (pStr[sizeof(EMAIL_TYPE)-1] == ':')                  &&
                    (pStr[sizeof(EMAIL_TYPE)] == '/')                  ) {
                    // Didn't find the proxy in the proxy index, and it
                    // starts out like a stringDN style EMAIL address 
                    //
                    // Try looking up the DN.  This will only do exact
                    // matches and we WILL NOT support prefix searches on
                    // this kind of address.
                    if (ulFound = ABDNToDNT(pTHS, pStr+sizeof(EMAIL_TYPE))) {
                        // OK, it's an object.  I don't have the slightest
                        // clue what kind of object, but, they asked for it,
                        // so.....
                        scode = SUCCESS_SUCCESS;
                    }
                }
                if(bUnicode) {
                    // We don't need this anymore.
                    THFreeEx(pTHS, pStr);
                }
            }
        }
        else { /* standard ANR behavior */
            ulFound = 0;
            scode = SUCCESS_SUCCESS;


            if(bUnicode) {
                // Unicode string was passed in.  ASCIIize it (we're going
                // to pass it to ABDNToDNT, which only accepts ASCII DNs).
                pStr = String8FromUnicodeString(TRUE,
                                                pStat->CodePage,
                                                paWStr->Strings[i],
                                                -1,
                                                NULL,
                                                NULL);
            }
            else {
                pStr = paStr->Strings[i];
            }

            // We have an ASCII string now.


            if ((pStr[0]=='/') ||
                ((_strnicmp(pStr, EMAIL_TYPE, sizeof(EMAIL_TYPE)-1) == 0) &&
                 (pStr[sizeof(EMAIL_TYPE)-1] == ':')                  &&
                 (pStr[sizeof(EMAIL_TYPE)] == '/') )  ) {
                
                // name starts out like a stringDN style EMAIL address 
                //
                // Try looking up the DN.  This will only do exact
                // matches and we WILL NOT support prefix searches on
                // this kind of address.
                if (ulFound = ABDNToDNT(pTHS, pStr + (pStr[0]=='/' ? 0 : sizeof(EMAIL_TYPE) ))) {
                    // OK, it's an object.  I don't have the slightest
                    // clue what kind of object, but, they asked for it,
                    // so.....
                    scode = SUCCESS_SUCCESS;
                }
            }
            if(bUnicode) {
                // We don't need this anymore.
                THFreeEx(pTHS, pStr);
            }


            if(gulDoNicknameResolution && !ulFound) {
                BOOL fSkip = FALSE;
                // We don't strip spaces in the beginning/end of the string
                // for the simple ANR.
                // if this fails/isn't done, the core has to handle the spaces
                // while doing the translation of the ANR filter to the real 
                // filter evaluated.
                
                // Build the exact match nickname restriction.
                anrRestrict.rt = RES_PROPERTY;
                anrRestrict.res.resProperty.relop = RELOP_EQ;
                anrRestrict.res.resProperty.lpProp = &anrProp;

                if(bUnicode) {
                    WCHAR *pTemp = paWStr->Strings[i];
                    // look through for spaces.  We don't do spaces
                    while(!fSkip && *pTemp != 0) {
                        if(*pTemp == L' ') {
                            fSkip = TRUE;
                        }
                        else {
                            pTemp++;
                        }
                    }
                    // If they've specified exact match ("=foo"), remember to
                    // skip over the leading equal sign.
                    pTemp = paWStr->Strings[i];
                    if (L'=' == *pTemp) {
                        ++pTemp;
                    }
                    anrRestrict.res.resProperty.ulPropTag = PR_ACCOUNT_W;
                    anrProp.ulPropTag = PR_ACCOUNT_W;
                    anrProp.Value.lpszW = pTemp;
                }
                else {
                    CHAR *pTemp = paStr->Strings[i];
                    // look through for spaces.  We don't do spaces
                    while(!fSkip && *pTemp != 0) {
                        if(*pTemp == ' ') {
                            fSkip = TRUE;
                        }
                        else {
                            pTemp++;
                        }
                    }                    
                    // If they've specified exact match ("=foo"), remember to
                    // skip over the leading equal sign.
                    pTemp = paStr->Strings[i];
                    if ('=' == *pTemp) {
                        ++pTemp;
                    }
                    anrRestrict.res.resProperty.ulPropTag = PR_ACCOUNT_A;
                    anrProp.ulPropTag = PR_ACCOUNT_A;
                    anrProp.Value.lpszA = pTemp;
                }
                
                if(!fSkip) {
                    // TODO: Possible add another perf counter for NickNameResolutions

                    scode = ABGenericRestriction(pTHS,
                                                 pStat,
                                                 TRUE,
                                                 2,
                                                 &ulFound,
                                                 FALSE,
                                                 &anrRestrict,
                                                 &pCachedSearchArg);
                }
            }

            if(!ulFound || scode != SUCCESS_SUCCESS) {
                // Didn't find anything via nickname restriction
                // Build the anr restriction.
                ulFound = 0;
                
                anrRestrict.rt = RES_PROPERTY;
                anrRestrict.res.resProperty.relop = RELOP_EQ;
                anrRestrict.res.resProperty.lpProp = &anrProp;
                if(bUnicode) {
                    anrRestrict.res.resProperty.ulPropTag =PR_ANR_W;
                    anrProp.ulPropTag = PR_ANR_W;
                    anrProp.Value.lpszW = paWStr->Strings[i];
                }
                else {
                    anrRestrict.res.resProperty.ulPropTag =PR_ANR_A;
                    anrProp.ulPropTag = PR_ANR_A;
                    anrProp.Value.lpszA = paStr->Strings[i];
                }
                
                scode = ABGenericRestriction(pTHS,
                                             pStat,
                                             TRUE,
                                             2,
                                             &ulFound,
                                             FALSE,
                                             &anrRestrict,
                                             &pCachedSearchArg);
            }
            
        }
        
        switch (scode) {
        case SUCCESS_SUCCESS:
            if(!ulFound) {
                pFs[i] = MAPI_UNRESOLVED;        /* none found */
            } else {
                pFs[i] = ulFound;
                cDNTs++;                        /* we'll do this one */
            }
            break;
        case MAPI_E_TABLE_TOO_BIG:
        case MAPI_E_AMBIGUOUS_RECIP:
            pFs[i] = MAPI_AMBIGUOUS;        /* more than 1 found */
            break;
        default:
            pFs[i] = MAPI_UNRESOLVED;        /* not found */
            break;
        }
    }
    if(cDNTs) {                         /* compress DNT array  */
        LPDWORD        pDNTs = (LPDWORD)THAllocEx(pTHS, cDNTs * sizeof(DWORD));
        UINT        j;
        
        for(i=j=0; i<Count; i++) {        /* walk the uncompressed array */
            if(pFs[i] != MAPI_UNRESOLVED && pFs[i] != MAPI_AMBIGUOUS) {
                pDNTs[j++] = pFs[i];                /* get unique DNT */
                pFs[i] = MAPI_RESOLVED;                /* mark it found */
            }
        }
        GetSrowSet(pTHS,pStat, pIndexSize, cDNTs, pDNTs, cDNTs, pPropTags,
                   ppRows, dwFlags); 
    }
    return pTHS->errCode;
}

SCODE
ABDNToEph_local(
        THSTATE *pTHS,
        DWORD dwFlags,
        LPStringsArray_r pNames,
        LPLPSPropTagArray_r ppEphs
        )
/*++

Routine Description:       

    Internal wire function.  Takes an array of string DNs and turns them into
    DNTs. If the string DN can not be found, a DNT of 0 is returned.
    
Arguments:

    dwFlags - unused (future expansion).

    pNames - an array of string DNs to turn into DNTs.

    ppEPhs - [o] the returned array of DNTs.

ReturnValue:

    SCODE as per MAPI.

--*/
{
    UINT       i;

    // Allocate room for the return value 
    *ppEphs = (LPSPropTagArray_r)
        THAllocEx(pTHS, sizeof(SPropTagArray_r) + pNames->Count * sizeof(DWORD));
    
    (*ppEphs)->cValues = pNames->Count;
    
    // Walk the array turning the strings into DNTs.  If no string is
    // specified, return a DNT of 0.
    for(i=0; i < pNames->Count; i++ ) {
        (*ppEphs)->aulPropTag[i] = (pNames->Strings[i] ?
                                    ABDNToDNT(pTHS, pNames->Strings[i]) : 0);
    }
    
    return SUCCESS_SUCCESS;
}

SCODE
ABGetOneOffTable (
        THSTATE *pTHS,
        NSPI_CONTEXT *pMyContext,
        PSTAT pStat,
        LPLPSRowSet_r OneOffTab
        )
/*****************************************************************************
*   Get One Off Template Table Info  -- This isn't actually an entry point,
* but only because we want to minimize the number of entry points (and
* corresponding RPC code).  It's an overloading of GetHierarchy, specified by
* a flag.
******************************************************************************/
{
    SCODE           scode = 0;
    LPSTR        *  apDispName, * apDN, * apAddrType;
    ULONG           cRows, i;
        LPDWORD                        aDNT;
    LPSPropValue_r  pPV;
    LPSRowSet_r     pSRSet;
    LPSRow_r        pRow;

    cRows = ABGetOneOffs(pTHS, pMyContext, pStat, &apDispName, &apDN,
                         &apAddrType, &aDNT ); 
    pSRSet = (LPSRowSet_r)THAllocEx(pTHS, 
               sizeof(SRowSet_r) + cRows * sizeof(SRow_r));
                                                 // alloc all propvals at once
    pPV = (LPSPropValue_r)THAllocEx(pTHS, 
               cRows * ONE_OFF_PROP_COUNT * sizeof(SPropValue_r));
                                
    pSRSet->cRows = cRows;                      // count of rows
    for(i=0; i<cRows; i++) {
        pRow = &pSRSet->aRow[i];                // fill in row values
        pRow->cValues = ONE_OFF_PROP_COUNT;
        pRow->lpProps = pPV;                    // now fill in the propvals

        pPV->Value.lpszA = apDispName[i];       // the display name.
        pPV->ulPropTag = (pStat->CodePage == CP_WINUNICODE ?
                                      PR_DISPLAY_NAME_W : PR_DISPLAY_NAME_A);
        pPV++;

        pPV->Value.lpszA = apAddrType[i];       // the email address type
        pPV->ulPropTag = PR_ADDRTYPE_A;
        pPV++;

        pPV->ulPropTag = PR_DISPLAY_TYPE;       // display type
        pPV->Value.l = DT_MAILUSER;
        pPV++;

        pPV->ulPropTag = PR_DEPTH;              // depth
        pPV->Value.l = 0;
        pPV++;

        pPV->ulPropTag = PR_SELECTABLE;         // selection flag
        pPV->Value.b = TRUE;
        pPV++;

        pPV->ulPropTag = PR_INSTANCE_KEY;       // unique instance key
        pPV->Value.bin.cb = sizeof(DWORD);
                pPV->Value.bin.lpb = (LPVOID)&aDNT[i];
        pPV++;

        pPV->ulPropTag = PR_ENTRYID;            // permanant id
        ABMakePermEID(pTHS,
                      (LPUSR_PERMID *)&pPV->Value.bin.lpb,
                      &pPV->Value.bin.cb,
                      AB_DT_OOUSER,
                      apDN[i]);
        pPV++;
        
    }
    *OneOffTab = pSRSet;
    return scode;
}

SCODE
ABGetHierarchyInfo_local (
        THSTATE *pTHS,
        DWORD dwFlags,
        NSPI_CONTEXT *pMyContext,
        PSTAT pStat,
        LPDWORD lpVersion,
        LPLPSRowSet_r HierTabRows
        )
/*****************************************************************************
*   Get Hierarchy Table Info
******************************************************************************/
{
#define MAX_HIERARCHY_ROWS_RETURNED 85    
    DWORD                  i, numVals;
    LONG                   currentDepth;
    LPSPropValue_r         tempPropVal;
    PHierarchyTableType    tHierTab;
    LPSRowSet_r            localRows;
    LPSRow_r               tempRows2, tempRows;
    LPSTR                  lpszGalName = NULL;
    DWORD                  CountRows = 0;
    DWORD                  PageSize;
    DWORD                 *pdwHierTabIndex=NULL;
    
    /* flag values:
     * AB_DOS , we are being called from DOS client.
     *
     *   This flag says that the hierarchy table should not include
     * the PARENT_ENTRY_ID column or the PR_ENTRY_ID column.  This is because
     * Dos doesn't really want the full blown ems entryids, and instead uses
     * the CONTAINER_INFO column as an entry id.
     *
     *
     * AB_UNICODE, we are being called by a client that understands Unicode.
     *
     *   This flag says that we should include both the PR_DISPLAYNAME_A
     * column (which we do always) and the PR_DISPLAYNAME_W column.
     *
     * AB_ONE_OFF, we are returning the oneoff table, not the hierarchy table.
     */

    /* The columns returned by in the hierarchy table are, in order:
     *
     *
     *  1)  PR_ENTRYID;
     *  2)  PR_CONTAINER_FLAGS;
     *  3)  PR_DEPTH;
     *  4)  PR_EMS_AB_CONTAINERID (Dos reads this as DOS_ENTRYID)
     *  5)  PR_DISPLAY_NAME;
     *  6)  PR_EMS_AB_IS_MASTER
     *  7)  PR_EMS_AB_PARENT_ENTRYID;
     *
     * column 5 is DISPLAY_NAME_A if the AB_UNICODE flag is not set,
     *     DISPLAY_NAME_W if it is.
     * columns 1, 2, 6, and 7 are ommitted if the fDos flag is set.
     *
     *
     */

    numVals = 7;
    if(dwFlags & AB_DOS)
        numVals -= 4;
    
    if(dwFlags & AB_ONE_OFF) {
        /* really a OneOff call? */
        return ABGetOneOffTable(pTHS, pMyContext, pStat, HierTabRows);
    }
    
    HTGetHierarchyTablePointer(&tHierTab, &pdwHierTabIndex, pStat->SortLocale);

    if (!tHierTab) {
        *HierTabRows = NULL;
        return  MAPI_E_NOT_ENOUGH_RESOURCES;
    }

    if(tHierTab->Version == *lpVersion) {
        /* The client has the same version as the server does. */
        *HierTabRows = NULL;
        return SUCCESS_SUCCESS;
    }


    // Is this paged?
    if(dwFlags & AB_PAGE_HIER) {
        PageSize = MAX_HIERARCHY_ROWS_RETURNED;
    }
    else {
        PageSize = 0xFFFFFFFF;
    }
        
     
    // Need to get a new hierarchy table for the client
    localRows = (LPSRowSet_r)THAllocEx(pTHS, 
            sizeof(SRowSet_r) + (1+ tHierTab->Size) * sizeof(SRow_r));
    
    tempRows = &(localRows->aRow[0]);
    
    tempRows->cValues = numVals;

    if(!pMyContext->PagedHierarchy) {
        // We are NOT continuing a paged hierarchy, so put the gal into this.
        if(!(dwFlags & AB_DOS)) {
            // If not AB_DOS, the count includes one for the Parent_EntryID
            // value, but the GAL does not have a Parent_EntryID
            tempRows->cValues--;
        }
        else {
            // Dos RPC barfs is we ship back a null for the GAL name, while MAPI
            // clients require it. 
            lpszGalName = "Dummy";
        }
        
        tempRows->lpProps =
            (LPSPropValue_r) THAllocEx(pTHS, numVals * sizeof(SPropValue_r));
        tempPropVal = tempRows->lpProps;

        // First, the EID
        if(!(dwFlags & AB_DOS)) {
            // Permanant id;
            tempPropVal->ulPropTag = PR_ENTRYID;
            
            ABMakePermEID(pTHS,
                    (LPUSR_PERMID *)&tempPropVal->Value.bin.lpb,
                    &tempPropVal->Value.bin.cb,
                    AB_DT_CONTAINER,
                    "/");
            tempPropVal++;
            
            // The container flags  
            tempPropVal->ulPropTag = PR_CONTAINER_FLAGS;
            tempPropVal->Value.l = AB_RECIPIENTS | AB_UNMODIFIABLE;
            tempPropVal++;
        }
        
        // The depth 
        tempPropVal->ulPropTag = PR_DEPTH;
        tempPropVal->Value.l = 0;
        tempPropVal++;
        
        // ContainerID, (Dos reads this as DOS_ENTRYID);
        tempPropVal->ulPropTag = PR_EMS_AB_CONTAINERID;
        tempPropVal->Value.l = 0;
        tempPropVal++;
        
        // Next, the display name.                                
        
        // Ship a Null back to the client (or a Dummy if DOS). The client has a
        // localized version of the GAL name. 
        if(!(dwFlags & AB_UNICODE)) {                
            tempPropVal->ulPropTag = PR_DISPLAY_NAME_A;
            tempPropVal->Value.lpszA = lpszGalName;
        } else {
            tempPropVal->ulPropTag = PR_DISPLAY_NAME_W;
            tempPropVal->Value.lpszW = NULL;
        }
        
        if(!(dwFlags & AB_DOS)) {  
            tempPropVal++;
            tempPropVal->ulPropTag = PR_EMS_AB_IS_MASTER;
            tempPropVal->Value.b = 0;
        }
        tempRows++;
        CountRows++;
    }
    else {
        // I don't care whether we thought we were paged, we are.
        PageSize = MAX_HIERARCHY_ROWS_RETURNED;
        // Are we still using the same table as last time?
        if(pMyContext->HierarchyVersion != tHierTab->Version) {
            // Nope.  Fail the call
            THFree(localRows);
            *HierTabRows = NULL;
            return  MAPI_E_NOT_ENOUGH_RESOURCES;
        }
    }
        
    
    for(i=pMyContext->HierarchyIndex;
        (i < tHierTab->Size) && (CountRows <  PageSize);
        i++) {

        currentDepth = (tHierTab->Table)[pdwHierTabIndex[i]].depth;
        if(currentDepth > 15) {
            // Too deep. Walk forward until we have the next object at a
            // lesser depth, then back up one so the for loop can correctly
            // increment. 
            i++;
            while((i<tHierTab->Size) &&
                  (tHierTab->Table)[pdwHierTabIndex[i]].depth > 15) {
                i++;
            }
            i--;
            // Back to the next iteration of the for loop
            continue;
        }
        
        // Find the object and see if it is visible
        if(DBTryToFindDNT(pTHS->pDB,
                          (tHierTab->Table)[pdwHierTabIndex[i]].dwEph) ||
           !abCheckObjRights(pTHS)    )  { 
            // Walk forward until we have the next object at this depth or at a
            // lesser depth, then back up one so the for loop can correctly
            // increment. 
            i++;
            while((i<tHierTab->Size) &&
                  ((ULONG)currentDepth <
                   (tHierTab->Table)[pdwHierTabIndex[i]].depth)) {
                i++;
            }
            i--;
            // Back to the next iteration of the for loop
            continue;
        }  
        tempRows->cValues = numVals;
        tempRows->lpProps = (LPSPropValue_r) THAllocEx(pTHS, 
                numVals * sizeof(SPropValue_r));
        
        tempPropVal = tempRows->lpProps;
        
        if(!(dwFlags & AB_DOS))  {          // Permanant id;
            tempPropVal->ulPropTag = PR_ENTRYID;
            ABMakePermEID(pTHS,
                    (LPUSR_PERMID *)&tempPropVal->Value.bin.lpb,
                    &tempPropVal->Value.bin.cb,
                    AB_DT_CONTAINER,
                    (tHierTab->Table)[pdwHierTabIndex[i]].pucStringDN);
            tempPropVal++;
            
            
            /* TheContainerFlags */
            tempPropVal->ulPropTag = PR_CONTAINER_FLAGS;
            tempPropVal->Value.l = (AB_UNMODIFIABLE |
                                    AB_RECIPIENTS   );

            if((i+1 < tHierTab->Size) &&
               (tHierTab->Table[i+1].depth ==(DWORD)currentDepth + 1))
                tempPropVal->Value.l |= AB_SUBCONTAINERS;
            
            tempPropVal++;
        }
        
        
        // Depth;
        tempPropVal->ulPropTag = PR_DEPTH;
        tempPropVal->Value.l = currentDepth;
        tempPropVal++;
        
        // ContainerID, (Dos reads this as DOS_ENTRYID);
        tempPropVal->ulPropTag = PR_EMS_AB_CONTAINERID;
        tempPropVal->Value.l = (tHierTab->Table)[pdwHierTabIndex[i]].dwEph;
        tempPropVal++;
        
        /* do we need subst name here? */
        if(!(dwFlags & AB_UNICODE)) {
            tempPropVal->ulPropTag = PR_DISPLAY_NAME_A;
            tempPropVal->Value.lpszA =String8FromUnicodeString(
                    TRUE,
                    pStat->CodePage,
                    (tHierTab->Table)[pdwHierTabIndex[i]].displayName,
                    -1, NULL, NULL);
        } else {
            tempPropVal->ulPropTag = PR_DISPLAY_NAME_W;
            tempPropVal->Value.lpszW =
                (tHierTab->Table)[pdwHierTabIndex[i]].displayName;
        }
        tempPropVal++;
        
        if(!(dwFlags & AB_DOS)) {                // PR_EMS_AB_IS_MASTER
            tempPropVal->ulPropTag = PR_EMS_AB_IS_MASTER;
            tempPropVal->Value.b = FALSE;
            tempPropVal++;
            
            if(tHierTab->Table[pdwHierTabIndex[i]].depth != 0) {
                // Not dos, and is a child in the hiertable, so
                // Give it a PARENT_ENTRYID
                
                tempPropVal->ulPropTag = PR_EMS_AB_PARENT_ENTRYID;
                // Find the parent;
                tempRows2 = tempRows;
                tempRows2--;
                while((tempRows2->lpProps[2].Value.l+1)!=currentDepth)
                    tempRows2--;
                
                tempPropVal->Value.bin=tempRows2->lpProps[0].Value.bin;
            } else {
                // If not AB_DOS, the count includes one for the
                // Parent_EntryID value, but objects at depth 0
                // don't have a Parent_EntryIDs
                
                tempRows->cValues--;
            }
        }
        tempRows++;
        CountRows++;
    }
    *lpVersion = tHierTab->Version;
    
    localRows->cRows = CountRows;
    if(i < tHierTab->Size) {
        DWORD version, index;
        // Didn't return all the table.  Store the info of how far we got away.
        pMyContext->HierarchyVersion = tHierTab->Version;
        pMyContext->HierarchyIndex = i;
        pMyContext->PagedHierarchy = TRUE;
        
        // And, signal there is more
        *lpVersion = 0;
    }
    else {
        pMyContext->HierarchyVersion = 0;
        pMyContext->HierarchyIndex = 0;
        pMyContext->PagedHierarchy = FALSE;
    }
    
    *HierTabRows = localRows;

    return SUCCESS_SUCCESS;
}

SCODE
ABResortRestriction_local(
        THSTATE            *pTHS,
        DWORD               dwFlags,
        PSTAT               pStat,
        LPSPropTagArray_r   pInDNTList,
        LPSPropTagArray_r  *ppOutDNTList)
/*++

Routine Description:
    Given a snaphsot table, resort it based on the index specified in the Stat
    block.

Arguments:

    dwFlags - unused

    pStat - pointer to the stat block describing the index to use.
    
    pInDNTList - the unsorted snapshot table.

    ppOUtDNTList - [o] the sorted list to return.

Return Values:    


--*/
{
    DWORD              i;
    DB_ERR             err;
    DWORD              cb;
    SCODE              scode=SUCCESS_SUCCESS;
    CHAR               DispNameBuff[CBMAX_DISPNAME];
    LPSPropTagArray_r  pOutDNTList;
    ATTCACHE           *pAC;
    DWORD              SortFlags=0;

    __try { // finally
        // Allocate a buffer big enough for the sorted list.
        pOutDNTList = (LPSPropTagArray_r)THAllocEx(pTHS,
                (sizeof(SPropTagArray) + (pInDNTList->cValues *
                                          sizeof(ULONG))));
        
        // Init a sort table.
        if (!(pAC = SCGetAttById(pTHS, ATT_DISPLAY_NAME)))
            return 0;

        if (pInDNTList->cValues >= MIN_NUM_ENTRIES_FOR_FORWARDONLY_SORT) {
            SortFlags = SortFlags | DB_SORT_FORWARDONLY;
        }

        if(DBOpenSortTable(pTHS->pDB,
                           pStat->SortLocale, 
                           SortFlags,
                           pAC)) {
            pTHS->errCode = (ULONG) MAPI_E_CALL_FAILED;
            _leave;
        }
        
        // Go through the list of DNT's we were given, getting the DNT
        // and the sort column from the DBLayer
        for(i=0 ; i<pInDNTList->cValues ; i++) {
            // Set currency on the given DNT
            if(!DBTryToFindDNT(pTHS->pDB, pInDNTList->aulPropTag[i])) {
                // The DNT in the restriction still exists,
                // Read the data and add it to the sort table. 
                
                err = DBGetSingleValue(pTHS->pDB, ATT_DISPLAY_NAME,
                                 DispNameBuff, CBMAX_DISPNAME,&cb);

                Assert(cb < CBMAX_DISPNAME);
                
                if(cb && err == 0) {
                    // add to Sort table
                    switch( DBInsertSortTable(pTHS->pDB,
                                              DispNameBuff,
                                              cb,
                                              pInDNTList->aulPropTag[i])) {
                    case DB_success:
                        break;
                    case DB_ERR_ALREADY_INSERTED:
                        // This is ok, it just means that we've already
                        // added this object to the sort table.  Don't
                        // inc the count.
                        break;
                    default:
                        // Something went wrong.
                        pTHS->errCode = (ULONG) MAPI_E_CALL_FAILED;
                        _leave;
                        break;
                    }
                }
            }
            // else, the DNT no longer exists, trim it from the table.
        }
        
        // The sort table now has the sorted list.  Pull the DNTs out of the
        // table in order 
        err= DBMove(pTHS->pDB, TRUE, DB_MoveFirst);
        i = 0;
        pStat->NumPos = 0;
        while(err == DB_success) {
            pOutDNTList->aulPropTag[i] = ABGetDword(pTHS, TRUE, FIXED_ATT_DNT);
            
            if(pOutDNTList->aulPropTag[i] == pStat->CurrentRec) {
                pStat->NumPos = i;
            }
            i++;
            err = DBMove(pTHS->pDB, TRUE, DB_MoveNext);
        }
        
        // Set up the return values.
        pOutDNTList->cValues = i;
        *ppOutDNTList = pOutDNTList;
        if(pStat->NumPos == 0)
            pStat->CurrentRec = 0;
        pStat->TotalRecs = i;
    }
    __finally {
        DBCloseSortTable(pTHS->pDB);
        
        scode = pTHS->errCode;
        
    }

    return scode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\nspis\abnameid.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       abnameid.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module implements address book NSPI wire functions for mapping MAPI
    names to IDs and IDs to Names.


    The mapping between MAPI names and IDs is as follows:

    A MAPI name is another method of referring to an attribute.  It is made up
    of two parts, a GUID and a DWORD.  These two parts encode the same
    information as the asn.1 encode octet string used to name the attribute
    through the XDS interface.
 
    Consider the following example.  The attribute COMMON-NAME has the asn.1
    encode 0x55 0x04 0x03.  The first part of this octet string is the package
    identifier.  It is 0x55 0x04, and is defined in xdsbdcp.h.  The suffix is
    0x03, and is also defined in xdsbdcp.h.  Then MAPI Name for this attribute
    is made up of two parts, the GUID and the DWORD.  The guid encodes the
    package indentifier.  The first byte of the guid is the length of the octet
    string which is the package identifier.  The next N bytes are the bytes of
    the package identifier.  The remainder of the bytes in the GUID must be 0.
    So, the guid for this package is 
 
    0x02 0x55 0x04 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0.
 
    The DWORD encodes the suffix.  The suffix may be 1 or 2 bytes, and is
    encoded in the following manner.  The high byte in the DWORD must be 0.  The
    next byte in the DWORD is 1 or 2, depending on the length of the suffix.
    The next byte is 0 if the suffix is one byte long, or the second byte of the
    suffix if the suffix is two bytes long.  The final byte in the DWORD is the
    first byte of the suffix.  So, the DWORD which encodes the suffix for common
    name is: 
 
    0x00010003
 
    Example: The attribute ADMIN_DISPLAY NAME has the ASN.1 encoding
    
    0x2A 0x86 0x48 0x86 0xF7 0x14 0x01 0x02 0x81 0x42
    
    The GUID for the name is
    
    0x08 0xsA 0x86 0x48 0x86 0xF7 0x14 0x01 0x02 0x0 0x0 0x0 0x0 0x0 0x0 0x0
    
    The suffix is
    
    0x00024281
    
    Final note.  This encoding scheme is not mandated by any spec. It is just
    what we came up with here.  If, in the future, a better scheme is devised, 
    there is no particular reason not to use it.
 
    Even more Final note.  Certain EMS_AB prop tags refer to values that are
    constructed from other values.  These, obviously, do not have schema cache 
    entries or X500 OIDs.  The prop ids for these are numbered down from
    0xFFFE. Their names are built using the EMS_AB guid, and the Prop ID for the
    DWORD. 


Author:

    Dave Van Horn (davevh) and Tim Williams (timwi) 1990-1995

Revision History:
    
    25-Apr-1996 Split this file off from a single file containing all address
    book functions, rewrote to use DBLayer functions instead of direct database
    calls, reformatted to NT standard.
    
--*/
#include <NTDSpch.h>
#pragma  hdrstop


#include <ntdsctr.h>                   // PerfMon hooks

// Core headers.
#include <ntdsa.h>                      // Core data types 
#include <scache.h>                     // Schema cache code
#include <dbglobal.h>                   // DBLayer header.
#include <mdglobal.h>                   // THSTATE definition
#include <mdlocal.h>
#include <dsatools.h>                   // Memory, etc.

// Logging headers.
#include <mdcodes.h>                    // Only needed for dsevent.h
#include <dsevent.h>                    // Only needed for LogUnhandledError

// Assorted DSA headers.
#include <dsexcept.h>
#include <objids.h>                     // need ATT_* consts
#include <hiertab.h>                    // Hierarchy Table stuff

// Assorted MAPI headers.
#define INITGUID
#define USES_PS_MAPI
#include <mapidefs.h>                   // These four files
#include <mapitags.h>                   //  define MAPI
#include <mapicode.h>                   //  stuff that we need
#include <mapiguid.h>                   //  in order to be a provider.

// Nspi interface headers.
#include "nspi.h"                       // defines the nspi wire interface
#include <nsp_both.h>                   // a few things both client/server need
#include <msdstag.h>                    // Defines proptags for ems properties
#include <_entryid.h>                   // Defines format of an entryid
#include <abserv.h>                     // Address Book interface local stuff
#include <_hindex.h>                    // Defines index handles.

#include <fileno.h>
#define  FILENO FILENO_ABNAMEID



SCODE
ABGetNamesFromIDs_local(
        THSTATE *pTHS,
        DWORD dwFlags,
        LPMUID_r lpguid,
        LPSPropTagArray_r  pInPropTags,
        LPLPSPropTagArray_r  ppOutPropTags,
        LPLPNameIDSet_r ppNames
        )
/*****************************************************************************
*   Get MAPI Names from IDs
******************************************************************************/
{
    LPNameIDSet_r           localNames;
    DWORD                   i,j;
    ATTCACHE               *pAC;
    OID_t                   OID;
    DWORD                   suffix=0;
    BYTE                    *elements;
    DWORD                   PropID;
    LPSPropTagArray_r       pLocalProps;
    LPMUID_r                thisLpguid = NULL;
    DWORD                   fDoMapi, fDoConstructed, fDoStored;

        
    fDoMapi = TRUE;
    fDoStored = TRUE;
    fDoConstructed = TRUE;
    
    // Set up the prop tag array. 
    if(!pInPropTags) {
        if(!lpguid) {
            // We will not tell you about PS_MAPI stuff 
            fDoMapi = FALSE;
        }
        
        // Get the pPropTag array 
        ABQueryColumns_local(pTHS, dwFlags, 0, &pLocalProps);
    }
    else
        pLocalProps = pInPropTags;
    
    
    // Set up the return value. 
    localNames = (LPNameIDSet_r)THAllocEx(pTHS,
                                          sizeof(NameIDSet_r) +
                                          (sizeof(MAPINAMEID_r) *
                                           pLocalProps->cValues  )  );
    
    memset(localNames->aNames,
           0,
           (sizeof(MAPINAMEID_r) * pLocalProps->cValues    ));
    
    
    
    // Decide what PropIDs we will do. 
    if(lpguid) {
        if(memcmp(&PS_MAPI, lpguid,sizeof(GUID)) == 0) {
            // they only want MAPI.
            if(!pInPropTags) {
                // MAPI doesn't allow this combination 
                return MAPI_E_NO_SUPPORT;
            }
            
            fDoStored = FALSE;
            fDoConstructed = FALSE;
        }
        else if(memcmp(&muidEMSAB,lpguid,sizeof(GUID)) == 0 ) {
            // they only want our constructed props. 
            fDoMapi = FALSE;
            fDoStored = FALSE;
        }
        else {
            // They want some subset of our stored props. 
            fDoMapi = FALSE;
            fDoConstructed = FALSE;
        }
    }
    
    
    for(i=0;i<pLocalProps->cValues;i++) {
        DWORD fOK;
        DWORD guidLen, suffixLen;
        
        PropID = PROP_ID(pLocalProps->aulPropTag[i]);
        
        if(fDoConstructed &&
           (PropID >= MIN_EMS_AB_CONSTRUCTED_PROP_ID)) {
            // This is a constructed prop tag, not in the cache 
            localNames->aNames[i].lpguid = (LPMUID_r) &muidEMSAB;
            localNames->aNames[i].ulKind=MNID_ID;
            localNames->aNames[i].lID=PropID;
        }
        else if(fDoStored &&
                (PropID >= 0x8000) &&
                (pAC = SCGetAttByMapiId(pTHS, PropID))) {
            // The ID is in the named ID space, and We recognize it 
            
            if(!AttrTypeToOid(pAC->id,&OID)) {
                // Turned the mapi id into an OID. now verify that
                // the OID has the appropriate GUID.
                
                fOK=FALSE;
                
                if(!lpguid) {
                    BYTE * lpbGuid;
                    // No guid, so we assume this thing
                    // is OK.  Set up the guid and the
                    // guidlen and suffixlen.
                    
                    if(((CHAR *)OID.elements)[OID.length - 2] >= 0x80)
                        suffixLen = 2;
                    else
                        suffixLen = 1;
                    
                    guidLen = OID.length - suffixLen;
                    
                    lpbGuid = (BYTE *)THAllocEx(pTHS, sizeof(MUID_r));
                    memset(lpbGuid,0,sizeof(MUID_r));
                    
                    lpbGuid[0] = (BYTE)guidLen;
                    
                    memcpy(&lpbGuid[1],
                           (BYTE  *)(OID.elements),
                           guidLen);
                    
                    thisLpguid = (LPMUID_r)lpbGuid;
                    
                    fOK=TRUE;
                }
                else {
                    guidLen = (DWORD) (lpguid->ab[0]);
                    suffixLen=1;
                    
                    if((pAC->id & 0xFFFF ) >= 0x80)
                        suffixLen++;
                    
                    if(!memcmp(&lpguid->ab[1],
                               OID.elements,
                               (DWORD)lpguid->ab[0]) &&
                       OID.length == (guidLen + suffixLen)      ) {
                        fOK=TRUE;
                        thisLpguid=lpguid;
                    }
                }
                
                if(fOK) {
                    // everything is ok.  OID.elements has the oid of the
                    // object. 
                    elements = OID.elements;
                    
                    // Encode the length 
                    suffix = suffixLen << 16;
                    suffix |= elements[guidLen];
                    if(suffixLen == 2 )
                        suffix |= ((DWORD)elements[guidLen+1]) << 8;
                    
                    
                    localNames->aNames[i].lpguid = thisLpguid;
                    localNames->aNames[i].ulKind=MNID_ID;
                    localNames->aNames[i].lID=suffix;
                }
            }
        }
        else if(fDoMapi &&
                (PropID < 0x8000)) {
            // The GUID given is PS_MAPI, so give this back to them
            localNames->aNames[i].lpguid = (LPMUID_r)&PS_MAPI;
            localNames->aNames[i].ulKind=MNID_ID;
            localNames->aNames[i].lID =         PropID;
        }
        
        if(!localNames->aNames[i].lpguid && !pInPropTags) {
            // Didn't find a name and the proptagarray passed in was null.
            // Therefore, this proptag shouldn't be returned to the user.
            pLocalProps->aulPropTag[i]=0;
        }
    }
    
    
    // If we were called with a null prop tag array, trim out the PropTags
    // which didn't have names in this name set.
    if(!pInPropTags) {
        for(i=0,j=0;i<pLocalProps->cValues;i++) {
            if(pLocalProps->aulPropTag[i]) {
                if(i!=j) {
                    pLocalProps->aulPropTag[j] =
                        pLocalProps->aulPropTag[i];
                    memcpy(&localNames->aNames[j],
                           &localNames->aNames[i],
                           sizeof(MAPINAMEID_r));
                }
                j++;
            }
        }
        pLocalProps->cValues = j;
        
        *ppOutPropTags = pLocalProps;
    }
    
    
    
    localNames->cNames = pLocalProps->cValues;
    *ppNames = localNames;
    
    return SUCCESS_SUCCESS;
}

SCODE
ABGetIDsFromNames_local (
        THSTATE *pTHS,
        DWORD dwFlags,
        ULONG ulFlags,
        ULONG cPropNames,
        LPMAPINAMEID_r *ppNames,
        LPLPSPropTagArray_r  ppPropTags
        )
/*++

Routine Description:       

    Given a bunch of MAPI names, turn them into IDs.
    
Arguments:

    ulFlags - MAPI flags generated by the client.  All are ignored except
    MAPI_CREATE, which, if specified, may cause us to return an error if they
    asked us to create something we didn't already have.

    cPropNames - the number of property names to look up.
    
    ppNames - the names.

    ppPropTags - the IDs.  This array corresponds to the names array.  If we
    can't find an ID for a name, return the ID 0.

ReturnValue:

    SCODE as per MAPI.

--*/
{
    SCODE                   scode = SUCCESS_SUCCESS;
    LPSPropTagArray_r       localIDs;
    DWORD                   i, GuidSize,lID;
    ATTCACHE               *pAC;
    OID_t                   OID;
    BYTE                    elements[sizeof(GUID)+sizeof(DWORD)];
    MUID_r                  zeroGuid, *lpguid;
    ULONG                   ulNotFound=0;

    // Set up some variables.
    memset(&zeroGuid,0,sizeof(MUID_r));
    OID.elements = elements;

    // Allocate enough space to hold the IDs and an extra space for the count of
    // IDs.
    localIDs =
        (LPSPropTagArray_r)THAllocEx(pTHS, ((1 + cPropNames) * sizeof(ULONG)));

        
    // Now look up all the attributes in the att cache
    for(i=0;i<cPropNames;i++) {
        // First, make sure they gave us a numerical name, since we don't handle
        // the string names. 
        if(ppNames[i]->ulKind != MNID_ID) {
            scode = MAPI_W_ERRORS_RETURNED;
            localIDs->aulPropTag[i] = PROP_TAG(PT_ERROR,0);
            ulNotFound++;
            continue;
        }
        
        // Now, handle the PS_MAPI stuff, and the constructed EMS_AB attributes
        if((memcmp(ppNames[i]->lpguid,
                   &PS_MAPI,
                   sizeof(MUID_r)) == 0) ||
           (memcmp(ppNames[i]->lpguid,
                   &muidEMSAB,
                   sizeof(MUID_r)) == 0)) {
            // PS_MAPI and contructed attributes simply take the number part of
            // the name and use it as the Property ID.
            localIDs->aulPropTag[i] = PROP_TAG(PT_UNSPECIFIED,ppNames[i]->lID);
            continue;
        }
        
        // Now, see if this is one of ours.
        
        // Speed hack
        GuidSize = ppNames[i]->lpguid->ab[0];
        lID = ppNames[i]->lID;
        lpguid = ppNames[i]->lpguid;

        
        if(GuidSize < sizeof(MUID_r)) {
            // Verify that the excess bits in the OID are 0 
            if(memcmp(&lpguid->ab[1+GuidSize],
                      &zeroGuid,
                      sizeof(MUID_r) - 1 - GuidSize )) {
                OID.length = 0;
                elements[0] = 0;
                continue;
            }
        
            // Turn the name into an OID
            memcpy(OID.elements,
                   &lpguid->ab[1],
                   GuidSize);
        
            OID.length = 0;
            switch((lID & 0xFF0000)>>16) {
            case 1:
                if(!(lID & 0xFF00FF00)) {
                    // Nothing is in the bytes that should be 0. Therefore, this
                    // is a name I might understand 
                    OID.length = GuidSize + 1;
                    elements[GuidSize] =(BYTE)(lID & 0xFF);
                }
                break;
                
            case 2:
                if(!(lID & 0xFF000000)) {
                    // nothing is in the byte that should be 0.  Therefore, this
                    // is a name I might understand 
                    OID.length = GuidSize + 2;
                    elements[GuidSize] = (BYTE)(lID & 0xFF);
                    elements[GuidSize + 1] = (BYTE)((lID & 0xFF00) >>8);
                }
                break;
                
            default:
                break;
            }
        }
        else {
            OID.length = 0;
            elements[0] = 0;
        }
        
        // Turn the OID into a attcache 
        if(OidToAttrCache(&OID, &pAC) ||
           !pAC->ulMapiID) {
            // Didn't find it
            localIDs->aulPropTag[i] = PROP_TAG(PT_ERROR, 0);
            ulNotFound++;
            scode = MAPI_W_ERRORS_RETURNED;
        }
        else
            localIDs->aulPropTag[i] = PROP_TAG(PT_UNSPECIFIED,pAC->ulMapiID);
        
    }
    
    if((ulFlags & MAPI_CREATE) && (ulNotFound == cPropNames)) {
        // They asked us to create ids (which we don't do) and then gave us only
        // names which don't already match ids.  Return the error
        // MAPI_E_NO_ACCESS, and no propIDs. 
        scode = MAPI_E_NO_ACCESS;
        *ppPropTags = NULL;
    }
    else {
        localIDs->cValues = cPropNames;
        *ppPropTags = localIDs;
    }

    return scode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\nspis\absearch.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       absearch.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module implements address book restriction and searching routines.

Author:

    Dave Van Horn (davevh) and Tim Williams (timwi) 1990-1995

Revision History:
    
    25-Apr-1996 Split this file off from a single file containing all address
    book functions, rewrote to use DBLayer functions instead of direct database
    calls, reformatted to NT standard.
    
--*/
#include <NTDSpch.h>
#pragma  hdrstop


#include <ntdsctr.h>                   // PerfMon hooks

// Core headers.
#include <ntdsa.h>                      // Core data types 
#include <scache.h>                     // Schema cache code
#include <dbglobal.h>                   // DBLayer header.
#include <mdglobal.h>                   // THSTATE definition
#include <mdlocal.h>                    // THSTATE definition
#include <dsatools.h>                   // Memory, etc.

// Logging headers.
#include <mdcodes.h>                    // Only needed for dsevent.h
#include <dsevent.h>                    // Only needed for LogUnhandledError

// Assorted DSA headers.
#include <dsexcept.h>
#include <objids.h>                     // need ATT_* consts
#include <filtypes.h>                   // Filter choice constants
#include <debug.h>

// Assorted MAPI headers.
#include <mapidefs.h>                   // These four files
#include <mapitags.h>                   //  define MAPI
#include <mapicode.h>                   //  stuff that we need
#include <mapiguid.h>                   //  in order to be a provider.

// Nspi interface headers.
#include "nspi.h"                       // defines the nspi wire interface
#include <nsp_both.h>                   // a few things both client/server need
#include <msdstag.h>                   // Defines proptags for ems properties
#include <_entryid.h>                   // Defines format of an entryid
#include <abserv.h>                     // Address Book interface local stuff
#include <_hindex.h>                    // Defines index handles.

#include "debug.h"                      // standard debugging header 
#define DEBSUB "ABSEARCH:"              // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_ABSEARCH

/************ Function Prototypes ****************/

extern BOOL gfUseANROptimizations;
                  
// from ldap
extern DWORD LdapMaxQueryDuration;

/******************** External Entry Points *****************/

SCODE
ABGetTable(
        THSTATE *pTHS,
        PSTAT pStat,
        ULONG ulInterfaceOptions,
        LPMAPINAMEID_r lpPropName,
        ULONG fWritable,
        DWORD ulRequested,
        ULONG *pulFound
        )
/*++

Routine Description:

    Get a MAPI table by reading the values of a DN or ORName attribute.  Reads
    the attribute requested, then returns the list of referenced objects by
    inserting them in the sort table.

Arguments:
    pStat - pointer to the stat block describing the clients state.  The
    attribute to return a table on is stored in the pStat->ContainerID.

    ulInterfaceOptions - Options specified by the client for this interface.

    lpPropName - pointer to the name of the property to get the table on.  Only
    specified if only a name is known.  If this is NULL, the property tag is
    already stored in pStat->ContainerID.

    fWritable - flag specifying whether a writable table must be returned.

    ulRequested - the maximum number of objects the returned table may contain.

    pulFound - place to put the number of entries actually in the table.

Return Values:    
    returns:
        SUCCESS_SUCCESS      == success
        MAPI_E_CALL_FAILED   == failure
        MAPI_E_TABLE_TOO_BIG == too many entries
        MAPI_E_TOO_COMPLEX   == too complex

--*/
{
    ATTCACHE             *pAC;
    DWORD                fIsComplexName;
    ENTINF               entry, tempEntry;
    ENTINFSEL            selection;
    ATTR                 Attr;
    ATTRTYP              ObjClass=0;
    ULONG                ulLen, i;
    PSECURITY_DESCRIPTOR pSec=NULL;
    DWORD                GetEntInfFlags = GETENTINF_FLAG_DONT_OPTIMIZE;
    BOOL                 fCheckReadMembers = FALSE;

    memset(&entry, 0, sizeof(entry));
    memset(&tempEntry, 0, sizeof(tempEntry));
    memset(&selection, 0, sizeof(selection));
    
    if(lpPropName) {
        // We have a PropName, not a propID.  Get the ID from the name,
        // then put it into the stat.  This way, the value is in place for
        // use here on the server, and sincd the stat is an in,out in the
        // idl interface, it will be returned to the client.

        LPSPropTagArray_r  lpPropTags=NULL;

        if(ABGetIDsFromNames_local(pTHS, 0, 0, 1, &lpPropName, &lpPropTags)) {
            // Something went wrong.  Bail out. 
            return  MAPI_E_NO_SUPPORT;
        }
        pStat->ContainerID = lpPropTags->aulPropTag[0];
    }

    if(!(pAC = SCGetAttByMapiId(pTHS, PROP_ID(pStat->ContainerID))) )
        return MAPI_E_NO_SUPPORT;

    // If they want a writable table, and this is is a backlink property,
    // return no support.
    if(fWritable && pAC->ulLinkID && !FIsLink(pAC->ulLinkID))
        return MAPI_E_NO_SUPPORT;

    // Make sure this is a DN or an ORName valued attribute.
    switch(pAC->syntax) {
    case SYNTAX_DISTNAME_TYPE:
        fIsComplexName = FALSE;
        break;
    case SYNTAX_DISTNAME_STRING_TYPE:
    case SYNTAX_DISTNAME_BINARY_TYPE:
        fIsComplexName = TRUE;
        break;
    default:
        return MAPI_E_NO_SUPPORT;
    }

    // Find the record we want to read attributes from.
    if(DBTryToFindDNT(pTHS->pDB, pStat->CurrentRec)) {
        // Couldn't find the object in question.
        return MAPI_E_CALL_FAILED;
    }
    
    if(!abCheckObjRights(pTHS)) {
        // But, we can't see it because of security.
        return MAPI_E_CALL_FAILED;
    }

    // Read the attributes.

    // First, get the security descriptor for this object.
    if (DBGetAttVal(pTHS->pDB, 1, ATT_NT_SECURITY_DESCRIPTOR,
                    0, 0, &ulLen, (PUCHAR *)&pSec)) {
        // Every object should have an SD.
        Assert(!DBCheckObj(pTHS->pDB));
        ulLen = 0;
        pSec = NULL;
    }

    // ATT_MEMBERS is a stored attribute and access is controlled in the usual manner.  
    // ATT_IS_MEMBER_OF_DL is computed, not stored.  
    // Suppose somebody had the rights to read my ATT_IS_MEMBER_OF_DL.  
    // Then you would see that I am a member of group X, even if you don't have
    // the rights to read ATT_MEMBERS of X  - unless we did extra processing.  

    if(pAC->id == ATT_IS_MEMBER_OF_DL) {
        if(!abCheckReadRights(pTHS,pSec,ATT_IS_MEMBER_OF_DL)) {
            // Note that we need to do the extended check of these candidates
            // (i.e. that we have read rights on the ATT_MEMBER property).
            fCheckReadMembers = TRUE;
        }

        // OK, we've checked security.  If we were granted read rights, we don't
        // need to check again.  If we weren't granted read rights, we still
        // don't need to check again, but we need to check for read rights on
        // the ATT_MEMBER property of every object we might return.
        // Regardless, we don't need to apply security again.
        GetEntInfFlags |= GETENTINF_NO_SECURITY;
    }
    
    // Now, make the getentinf call
    selection.attSel = EN_ATTSET_LIST;
    selection.infoTypes = EN_INFOTYPES_SHORTNAMES;
    selection.AttrTypBlock.attrCount = 1;
    selection.AttrTypBlock.pAttr = &Attr;
    Attr.attrTyp = pAC->id;
    Attr.AttrVal.valCount = 0;
    Attr.AttrVal.pAVal = NULL;
    
    if (GetEntInf(pTHS->pDB,
                  &selection,
                  NULL,
                  &entry,
                  NULL,
                  0,
                  pSec,
                  GetEntInfFlags,
                  NULL,
                  NULL)) {
        return MAPI_E_CALL_FAILED;
    }

    if(entry.AttrBlock.attrCount > ulRequested) {
        return MAPI_E_TABLE_TOO_BIG;
    }
    
    // Reset the selection for the loop below.
    selection.attSel = EN_ATTSET_LIST;
    selection.infoTypes = EN_INFOTYPES_SHORTNAMES;
    selection.AttrTypBlock.attrCount = 1;
    selection.AttrTypBlock.pAttr = &Attr;
    Attr.attrTyp = ATT_DISPLAY_NAME;

    if(entry.AttrBlock.attrCount == 1) {
        DWORD               i;
        ATTRVAL            *valPtr;
        // Reclaim the already allocated space used by pSec
        wchar_t            *pwString=pSec;
        DWORD               dnt;
        BOOL                fFoundName;
        ATTCACHE           *pAC;

        // Init a temporary table for sorting.
        if (!(pAC = SCGetAttById(pTHS, ATT_DISPLAY_NAME)))
            return MAPI_E_CALL_FAILED;
        
        Assert(!pTHS->pDB->JetSortTbl);
        
        if(DBOpenSortTable(pTHS->pDB,
                           pStat->SortLocale,
                           0,
                           pAC)) {
            return MAPI_E_CALL_FAILED;
        }
        
        for(i=entry.AttrBlock.pAttr->AttrVal.valCount; i; i--) {
            
            valPtr = &(entry.AttrBlock.pAttr->AttrVal.pAVal[i - 1]);
            
            // Get the DNT of the object referred to in this value.
            if(fIsComplexName) {
                dnt = DNTFromShortDSName(
                        NAMEPTR((SYNTAX_DISTNAME_BINARY *)(valPtr->pVal)));
            } else
                dnt = DNTFromShortDSName((DSNAME *)valPtr->pVal);
            // Look up the Display name
            if(!DBTryToFindDNT(pTHS->pDB, dnt)) {

                BOOL fGoodObj = FALSE;
                
                // OK, we're on the object in question. Can we see it?
                if(abCheckObjRights(pTHS) &&
                   (!fCheckReadMembers ||
                    abCheckReadRights(pTHS, NULL, ATT_MEMBER))) {

                    // Yep, get the displayname

                    if (!DBGetAttVal(pTHS->pDB,
                                     1,
                                     ATT_DISPLAY_NAME,
                                     DBGETATTVAL_fREALLOC,
                                     ulLen,
                                     &ulLen,
                                     (PUCHAR *)&pwString)) {
                        // OK, we have a display name.
                        fGoodObj = TRUE;
                    }
                }
                
                if(fGoodObj) {
                    //  Got something,  add it to the sort table
                    switch(DBInsertSortTable(
                            pTHS->pDB,
                            (PUCHAR)pwString,
                            ulLen,
                            dnt)) {
                    case DB_success:
                        (*pulFound)++;
                        break;
                    case DB_ERR_ALREADY_INSERTED:
                        // This is ok, it just means that we've already
                        // added this object to the sort table.  Don't
                        // inc the count.
                        break;
                    default:
                        // Something went wrong.
                        return MAPI_E_CALL_FAILED;
                        break;
                    }
                    
                    Assert(*pulFound < ulRequested);
                }
                
            }
        }                               // for
    }                                   // else
    return SUCCESS_SUCCESS;
}

// Take in a dir filter describing a search that we need to do and add in the
// stuff to only find things in the address book.
BOOL
MakeABFilter (
        THSTATE *pTHS,
        FILTER **ppFilter,
        FILTER *pCustomFilter,
        DWORD  dwContainer
        )
{
    FILTER *pFilter;
    PUCHAR pDN=NULL;
    DWORD  ulLen=0;
    DWORD  err;
    DWORD  entryCount, actualRead;

    
    // First, find the container to get it's dsname
    if(DBTryToFindDNT(pTHS->pDB, dwContainer)) {
        // the container doesn't exist, so this search isn't going to match
        // anything
        return FALSE;
    }

    if (DBGetAttVal(pTHS->pDB,
                    1,
                    ATT_OBJ_DIST_NAME,
                    DBGETATTVAL_fSHORTNAME,
                    0,
                    &ulLen,
                    &pDN)) {
        // Hmm couldn't get the distname for some reason.  This seach still
        // isn't going to work.
        return FALSE;
    }

    // Get the pre-calculated address book size
    if (err = DBGetSingleValue (pTHS->pDB,
                          FIXED_ATT_AB_REFCOUNT,
                          &entryCount,
                          sizeof (entryCount),
                          &actualRead)) {
        
        // there should be a value for this
        return FALSE;
    }
    
    // start by making a top level and filter
    *ppFilter = pFilter = THAllocEx(pTHS, sizeof(FILTER));
    pFilter->pNextFilter = NULL;
    pFilter->choice = FILTER_CHOICE_AND;
    pFilter->FilterTypes.And.count = (USHORT) 2;

    // first filter: Is in correct container
    pFilter->FilterTypes.And.pFirstFilter = THAllocEx(pTHS, sizeof(FILTER));
    pFilter = pFilter->FilterTypes.And.pFirstFilter;
    pFilter->choice = FILTER_CHOICE_ITEM;

    // Set estimated hint to the value we already retrieved so as to force override 
    // and don't calculate again the index size.
    pFilter->FilterTypes.Item.expectedSize = entryCount;

    pFilter->FilterTypes.Item.choice =  FI_CHOICE_EQUALITY;
    pFilter->FilterTypes.Item.FilTypes.ava.type = ATT_SHOW_IN_ADDRESS_BOOK;
    pFilter->FilterTypes.Item.FilTypes.ava.Value.valLen = ulLen;
    pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal = pDN;
    pFilter->FilterTypes.Item.FilTypes.pbSkip = NULL;

    // now set the user supplied filter
    pFilter->pNextFilter = pCustomFilter;

    return TRUE;
}

/* See if it's an attribute we don't save in the DIT but construct on the fly,
 * If so, then create an appropriate attrval for it here.  With luck, this will
 * be extensible.
 */
SCODE
SpecialAttrVal (
        THSTATE *pTHS,
        ULONG CodePage,
        PUCHAR pChoice,
        PROP_VAL_UNION * pVu,
        AVA *pAva,
        ULONG ulPropTag)
{
    ATTCACHE * pAC;
    LPUSR_PERMID        pID;
    LPUSR_ENTRYID       eID;
    DWORD               dwTemp;
    LONG                cb=0;
    DWORD               dnt;
    
    if(PT_UNICODE == PROP_TYPE(ulPropTag)) {
        cb = wcslen(pVu->lpszW) * sizeof(wchar_t);
    }
    
    switch(ulPropTag) {

    case PR_ANR_A:
        if ((_strnicmp(pVu->lpszA, EMAIL_TYPE, sizeof(EMAIL_TYPE)-1) == 0) &&
            (pVu->lpszA[sizeof(EMAIL_TYPE)-1] == ':')                      &&
            (pVu->lpszA[sizeof(EMAIL_TYPE)] == '/')                  ) {
                pVu->lpszW = UnicodeStringFromString8(CodePage, pVu->lpszA + sizeof (EMAIL_TYPE), -1);
        }
        else {
            pVu->lpszW = UnicodeStringFromString8(CodePage, pVu->lpszA, -1);
        }
        
        cb = wcslen(pVu->lpszW) * sizeof(wchar_t);
        // fall through
    case PR_ANR_W:
        // This is ambiguous name resolution.
        PERFINC(pcNspiANR);                     // PerfMon hook

        if ((_wcsnicmp(pVu->lpszW, EMAIL_TYPE_W, sizeof(EMAIL_TYPE_W)/sizeof (wchar_t)-1) == 0) &&
            (pVu->lpszW[sizeof(EMAIL_TYPE_W)/sizeof (wchar_t)-1] == ':')                      &&
            (pVu->lpszW[sizeof(EMAIL_TYPE_W)/sizeof (wchar_t)] == '/')                  ) {
                pVu->lpszW += sizeof(EMAIL_TYPE_W);
        }

        pAva->type = ATT_ANR;
        pAva->Value.valLen = cb;
        pAva->Value.pVal = (PUCHAR)pVu->lpszW;
        return 0;
        
    case PR_DISPLAY_NAME_A:
    case PR_TRANSMITABLE_DISPLAY_NAME_A:
        pVu->lpszW = UnicodeStringFromString8(CodePage, pVu->lpszA, -1);
        cb = wcslen(pVu->lpszW) * sizeof(wchar_t);
        // fall through
    case PR_DISPLAY_NAME_W:
    case PR_TRANSMITABLE_DISPLAY_NAME_W:
        pAC = SCGetAttById(pTHS, ATT_DISPLAY_NAME);
        if (pAC) {
            pAva->type = pAC->id;
            pAva->Value.valLen = cb;
            pAva->Value.pVal = (PUCHAR)pVu->lpszW;
        }
        else {
            *pChoice = FI_CHOICE_FALSE;
        }
        return 0;

    case PR_OBJECT_TYPE:
        // Note that this is no longer a 1->1 mapping, so we're just finding SOME of the
        // objects with this object type.
        pAC = SCGetAttById(pTHS, ATT_OBJECT_CLASS);
        if (pAC) {
            pAva->type = pAC->id;
            pAva->Value.valLen = sizeof(LONG);
            pVu->l = ABClassFromObjType(pVu->l);     /* convert to class # */
            pAva->Value.pVal = (PUCHAR)&pVu->l;
        }
        else {
            *pChoice = FI_CHOICE_FALSE;
        }
        return 0;

    case PR_DISPLAY_TYPE:
        // Note that this is no longer a 1->1 mapping, so we're just finding SOME of the
        // objects with this Display type.
        pAC = SCGetAttById(pTHS, ATT_OBJECT_CLASS);
        if (pAC) {
            pAva->type = pAC->id;
            pAva->Value.valLen = sizeof(LONG);
            pVu->l = ABClassFromDispType(pVu->l);    /* convert to class # */
            pAva->Value.pVal = (PUCHAR)&pVu->l;
        }
        else {
            *pChoice = FI_CHOICE_FALSE;
        }
        return 0;

    case PR_SEARCH_KEY:
        /* This should be the concatentation of our addrtype and an
         * email address.  First, verify the addrtype.
         */
        if((_strnicmp((char *)(pVu->bin.lpb),lpszEMT_A,cbszEMT_A-1)==0) &&
           (pVu->lpszA[cbszEMT_A-1]==':')     ) {
            /* Looks good so far.  adjust the pointer and fall through
             * the PR_EMAIL_ADDRESS case.
             */
            pVu->lpszA=(char *) &(pVu->bin.lpb[cbszEMT_A]);
        } else {
            /* bzzt! wrong answer. Make a filter which matches nothing*/
            *pChoice = FI_CHOICE_FALSE;
            return 0;
        }
        
    case PR_EMAIL_ADDRESS_W:
        // Convert the stringized version of the MAPI Name to a DNT.  This will
        // fail if the name doesn't map to a known name (i.e. it will return 0)
        dnt = ABDNToDNT(pTHS, pVu->lpszA);
        if(!dnt) {
            // Yep, unkown name.
            *pChoice = FI_CHOICE_FALSE;
            return 0;
        }
        // OK, the name is correct (and ABDNToDNT left us on the correct
        // object).  We need an external version of the name for the filter (DNT
        // won't work, we need a distname.)
        pAC = SCGetAttById(pTHS, ATT_OBJ_DIST_NAME);
        pAva->type = pAC->id;
        if (DBGetAttVal(pTHS->pDB,
                        1,
                        ATT_OBJ_DIST_NAME,
                        DBGETATTVAL_fSHORTNAME,
                        0,
                        &pAva->Value.valLen,
                        &(pAva->Value.pVal))) {
            // Hmm couldn't get the distname for some reason.  This seach still
            // isn't going to work.
            *pChoice = FI_CHOICE_FALSE;
        }
        return 0;

    case PR_ADDRTYPE:
        if(_stricmp(pVu->lpszA,lpszEMT_A)== 0) {
            /* They've given us our addrtype, make a filter that
             * will match everything. 
             */
            *pChoice = FI_CHOICE_TRUE;
            return 0;
        }
        else {
            /* They've not given us our addrtype, make a filter that
             * will match nothing. (objdistname == 0 works)
             */
            *pChoice = FI_CHOICE_FALSE;
            return 0;
        }
        break;

    case PR_ENTRYID:
    case PR_TEMPLATEID:
    case PR_RECORD_KEY:
        pID = (LPUSR_PERMID) pVu->bin.lpb;
        /* Verify the constant parts of any ENTRYID.
         *
         *  Note: we don't verify the pID->ulType field.
         */
        if((pID->abFlags[1]) || (pID->abFlags[2]) || (pID->abFlags[3]) ||
           (pID->ulVersion != EMS_VERSION)) {
            dnt = 0;
        }
        else {
            switch(pID->abFlags[0]) {
            case 0: /* Permanent */
                
                // verify the Guid.
                if(memcmp(&(pID->muid), &muidEMSAB, sizeof(UUID))) {
                    // Somethings wrong with this ID, it doesn't look like
                    // one of mine.
                    // Match nothing.
                    dnt = 0;
                }
                else {
                    if(dnt = ABDNToDNT(pTHS, pID->szAddr)) {
                        // Found a match, verify the Display type assume the
                        // ABDNToDNT above leave Database Currency on the
                        // correct object. 
                        pAC = SCGetAttById(pTHS, ATT_OBJECT_CLASS);
                        
                        dwTemp = ABGetDword(pTHS, FALSE, pAC->jColid);
                        if(pID->ulType != ABDispTypeFromClass(dwTemp)) {
                            dnt = 0;
                        }
                    }
                }
                break;
                
            case EPHEMERAL:
                eID =(LPUSR_ENTRYID) pVu->bin.lpb;
                if((ulPropTag == PR_RECORD_KEY) ||
                   (ulPropTag == PR_TEMPLATEID)    ) {
                    /* These values are NEVER ephemeral */
                    dnt = 0;
                }
                else if(memcmp(&(eID->muid), &pTHS->InvocationID, sizeof(UUID))) {
                    /* Not my GUID */
                    dnt = 0;
                }
                else {
                    dnt = eID->dwEph;
                    if(dnt) {
                        DB_ERR  err;
                        /* Found a match, verify the Display type */
                        if(DBTryToFindDNT(pTHS->pDB, dnt)) {
                            // Object doesn't exist.
                            dnt = 0;
                        }
                        else {
                            pAC = SCGetAttById(pTHS, ATT_OBJECT_CLASS);
                            
                            dwTemp = ABGetDword(pTHS, FALSE, pAC->id);
                            if(pID->ulType != ABDispTypeFromClass(dwTemp)) {
                                // wrong class;
                                dnt = 0;
                            }
                        }
                    }
                }
                break;
            default: /* Don't recognize this. */
                dnt = 0;
                break;
            }
        }

        if(!dnt) {
            *pChoice = FI_CHOICE_FALSE;
            return 0;
        }
        
        pAC = SCGetAttById(pTHS, ATT_OBJ_DIST_NAME);
        pAva->type = pAC->id;
        if (DBGetAttVal(pTHS->pDB,
                        1,
                        ATT_OBJ_DIST_NAME,
                        DBGETATTVAL_fSHORTNAME,
                        0,
                        &pAva->Value.valLen,
                        &(pAva->Value.pVal))) {
            // Hmm couldn't get the distname for some reason.  This seach still
            // isn't going to work.
            *pChoice = FI_CHOICE_FALSE;
        }
        return 0;

    default:
        return 1;
    }
}


/*
    The calls to PValToAttrVal in SRestrictToFilter routine will only
    turn the first value of a PT_MV_ PVal to an AttrVal.  
    This function checks to see whether this is correct and if not
    we will bounce any PT_MV_ PVals with > 1 value, since MAPI won't restrict
    on multiple values anyway.
*/
BOOL
CheckMultiValueValidRestriction (PROP_VAL_UNION *pValue,
                                 ULONG ulPropTag)
{
    if (ulPropTag & MV_FLAG) {
        switch (ulPropTag) {
            case PT_MV_STRING8:
                if (pValue->MVszA.cValues > 1) {
                    return FALSE;
                }
            break;

            case PT_MV_UNICODE:
                if (pValue->MVszW.cValues > 1) {
                    return FALSE;
                }
            break;

            case PT_MV_BINARY:
                if (pValue->MVbin.cValues > 1) {
                    return FALSE;
                }
            break;

            case PT_MV_LONG:
                if (pValue->MVl.cValues > 1) {
                    return FALSE;
                }
            break;
        
            // these are the MV values that PValToAttrVal does not handle
            case PT_MV_I2:
            case PT_MV_R4:
            case PT_MV_DOUBLE:
            case PT_MV_CURRENCY:
            case PT_MV_APPTIME:
            case PT_MV_SYSTIME:
            case PT_MV_CLSID:
            case PT_MV_I8:
                // fall through
            default:
                R_Except("CheckMultiValueValidRestriction default case: Unexpected PropTag", 
                         ulPropTag);
                break;
        }
    }

    return TRUE;
}


/*****************************************************************************
*   SRestrictToFilter - Convert an SRestriction to a filter
*
* Takes an SRestriction and an address of a pointer to a filter and converts
* the SRestriction recursively while allocating the filter objects
*
******************************************************************************/
DWORD
SRestrictToFilter(THSTATE *pTHS,
                  PSTAT pStat,
                  LPSRestriction_r pRestrict,
                  FILTER **ppFilter)
{
    FILTER *pFilter;
    ULONG  i, count;
    DWORD  dwStatus;
    AVA           *pAva;
    ATTCACHE * pAC;
    SUBSTRING *pSub;

    if (!pRestrict)
        return 0;

    *ppFilter = pFilter = THAllocEx(pTHS, sizeof(FILTER));
    pFilter->pNextFilter = NULL;


    switch (pRestrict->rt) {
        
    case RES_AND:
        pFilter->choice = FILTER_CHOICE_AND;
        count = pRestrict->res.resAnd.cRes;
        ppFilter = &pFilter->FilterTypes.And.pFirstFilter;
        pRestrict = pRestrict->res.resAnd.lpRes;
        pFilter->FilterTypes.And.count = (USHORT) count;
        for (i=0; i< count; i++,
             ppFilter=&(*ppFilter)->pNextFilter,pRestrict++) {
            if (dwStatus=SRestrictToFilter(pTHS,
                                           pStat,
                                           pRestrict,
                                           ppFilter))
                return dwStatus;
        }
        return 0;
        
    case RES_OR:
        pFilter->choice = FILTER_CHOICE_OR;
        count = pRestrict->res.resOr.cRes;
        ppFilter = &pFilter->FilterTypes.Or.pFirstFilter;
        pRestrict = pRestrict->res.resOr.lpRes;
        pFilter->FilterTypes.Or.count = (USHORT) count;
        for (i=0; i< count; i++, ppFilter=&(*ppFilter)->pNextFilter,
             pRestrict++) {
            if (dwStatus =SRestrictToFilter(pTHS,
                                            pStat,
                                            pRestrict,
                                            ppFilter))
                return dwStatus;
        }
        return 0;
        
    case RES_NOT:
        pFilter->choice = FILTER_CHOICE_NOT;
        count = pRestrict->res.resOr.cRes;
        return SRestrictToFilter(pTHS,
                                 pStat,
                                 pRestrict->res.resNot.lpRes,
                                 &pFilter->FilterTypes.pNot);
        
    case RES_CONTENT:
        pFilter->choice = FILTER_CHOICE_ITEM;
        pFilter->FilterTypes.Item.choice =  FI_CHOICE_SUBSTRING;
        pFilter->FilterTypes.Item.FilTypes.pbSkip = NULL;
        pSub = pFilter->FilterTypes.Item.FilTypes.pSubstring =
            THAllocEx(pTHS, sizeof(SUBSTRING));
        memset(pSub, 0, sizeof(SUBSTRING));
        if (!(pAC = SCGetAttByMapiId(pTHS, 
                             PROP_ID(pRestrict->res.resContent.ulPropTag))) ||
            !FLegalOperator(pAC->syntax,pFilter->FilterTypes.Item.choice)) {
            
            /* Special case check.  Is this display name ? */
            if((PROP_ID(pRestrict->res.resContent.ulPropTag) ==
                PROP_ID(PR_DISPLAY_NAME)                        ) ||
               (PROP_ID(pRestrict->res.resContent.ulPropTag) ==
                PROP_ID(PR_TRANSMITABLE_DISPLAY_NAME)           )    ) {
                if (!(pAC = SCGetAttById(pTHS, ATT_DISPLAY_NAME)) ||
                    !FLegalOperator(pAC->syntax,
                                    pFilter->FilterTypes.Item.choice)) {
                    return 1;
                }
            }
            else
                return 1;
        }
        pSub->type = pAC->id;
        
        if (pRestrict->res.resContent.ulFuzzyLevel & FL_PREFIX) {
            pSub->initialProvided = TRUE;

            if (!CheckMultiValueValidRestriction (&pRestrict->res.resContent.lpProp->Value,
                                                  pRestrict->res.resContent.ulPropTag)) {
                return 1;
            }

            PValToAttrVal(pTHS,
                          pAC, 1,
                          &pRestrict->res.resContent.lpProp->Value,
                          &pSub->InitialVal,
                          pRestrict->res.resContent.ulPropTag,
                          pStat->CodePage);
            return 0;
        }
        else if (pRestrict->res.resContent.ulFuzzyLevel & FL_SUBSTRING) {
            pSub->AnyVal.count = 1;

            if (!CheckMultiValueValidRestriction (&pRestrict->res.resContent.lpProp->Value,
                                                  pRestrict->res.resContent.ulPropTag)) {
                return 1;
            }

            PValToAttrVal(pTHS,
                          pAC,1,
                          &pRestrict->res.resContent.lpProp->Value,
                          &pSub->AnyVal.FirstAnyVal.AnyVal,
                          pRestrict->res.resContent.ulPropTag,
                          pStat->CodePage);
            return 0;
        }
        else
            return 1;                 // nothing else is supported
        
    case RES_PROPERTY:
        pFilter->choice = FILTER_CHOICE_ITEM;
        pFilter->FilterTypes.Item.FilTypes.pbSkip = NULL;
        switch (pRestrict->res.resProperty.relop) {
            
        case RELOP_LT:
            pFilter->FilterTypes.Item.choice =  FI_CHOICE_LESS;
            pAva = &pFilter->FilterTypes.Item.FilTypes.ava;
            break;
        case RELOP_LE:
            pFilter->FilterTypes.Item.choice =  FI_CHOICE_LESS_OR_EQ;
            pAva = &pFilter->FilterTypes.Item.FilTypes.ava;
            break;
        case RELOP_GT:
            pFilter->FilterTypes.Item.choice =  FI_CHOICE_GREATER;
            pAva = &pFilter->FilterTypes.Item.FilTypes.ava;
            break;
        case RELOP_GE:
            pFilter->FilterTypes.Item.choice =  FI_CHOICE_GREATER_OR_EQ;
            pAva = &pFilter->FilterTypes.Item.FilTypes.ava;
            break;
        case RELOP_EQ:
            pFilter->FilterTypes.Item.choice =  FI_CHOICE_EQUALITY;
            pAva = &pFilter->FilterTypes.Item.FilTypes.ava;
            break;
        case RELOP_NE:
            pFilter->FilterTypes.Item.choice =  FI_CHOICE_NOT_EQUAL;
            pAva = &pFilter->FilterTypes.Item.FilTypes.ava;
            break;
            
        case RELOP_RE:                // not supported
        default:
            return 1;
        }
        
        if (!(pAC = SCGetAttByMapiId(pTHS, 
                             PROP_ID(pRestrict->res.resProperty.ulPropTag))) ||
            !FLegalOperator(pAC->syntax,pFilter->FilterTypes.Item.choice)) {
            /* 2nd chance: handle special constructed attributes */

            /* Constructed attributes only allow == and !=, unless the
             * proptag is a variant of display name.
             */
            if((pRestrict->res.resProperty.ulPropTag == PR_DISPLAY_NAME) ||
               (pRestrict->res.resProperty.ulPropTag ==
                PR_TRANSMITABLE_DISPLAY_NAME) ||
               (pFilter->FilterTypes.Item.choice == FI_CHOICE_EQUALITY)  ||
               (pFilter->FilterTypes.Item.choice == FI_CHOICE_NOT_EQUAL)   )
                
                return SpecialAttrVal(pTHS,
                                      pStat->CodePage,
                                      &pFilter->FilterTypes.Item.choice,
                                      &pRestrict->res.resProperty.lpProp->Value,
                                      pAva,
                                      pRestrict->res.resProperty.ulPropTag);
            else
                return 1;
            
            
        }
        
        if(PROP_TYPE(pRestrict->res.resProperty.ulPropTag) & MV_FLAG) {
            if(pAC->isSingleValued)
                return 1;
        }
        else if(!(pAC->isSingleValued))
            return 1;
        
        pAva->type = pAC->id;           // normal attributes handled here

        if (!CheckMultiValueValidRestriction (&pRestrict->res.resContent.lpProp->Value,
                                              pRestrict->res.resContent.ulPropTag)) {
            return 1;
        }

        PValToAttrVal(pTHS,
                      pAC, 1,
                      &pRestrict->res.resProperty.lpProp->Value,
                      &pAva->Value,
                      pRestrict->res.resProperty.ulPropTag,
                      pStat->CodePage);
        return 0;
        
    case RES_EXIST:
        pFilter->choice = FILTER_CHOICE_ITEM;
        pFilter->FilterTypes.Item.choice =  FI_CHOICE_PRESENT;
        pFilter->FilterTypes.Item.FilTypes.pbSkip = NULL;
        if (!(pAC = SCGetAttByMapiId(pTHS,
                                     PROP_ID(pRestrict->res.resExist.ulPropTag))))
            return 1;
        pFilter->FilterTypes.Item.FilTypes.present = pAC->id;
        return 0;
        
        // restrictions we don't support
    case RES_COMPAREPROPS:
    case RES_BITMASK:
    case RES_SUBRESTRICTION:
    case RES_SIZE:
    default:
        return 1;
    }
}

SCODE
ABGenericRestriction(
        THSTATE *pTHS,
        PSTAT pStat,
        BOOL  bOnlyOne,
        DWORD ulRequested,
        DWORD *pulFound,
        BOOL  bPutResultsInSortedTable,
        LPSRestriction_r pRestriction,
        SEARCHARG        **ppCachedSearchArg
        )
/*****************************************************************************
*   Generic restriction
*   returns:
*        SUCCESS_SUCCESS      == success
*        MAPI_E_CALL_FAILED   == failure
*        MAPI_E_TABLE_TOO_BIG == too many entries
*        MAPI_E_TOO_COMPLEX   == too complex
*
*****************************************************************************/
{
    DWORD             i;
    DB_ERR            err;
    FILTER           *pFilter = NULL, *pABFilter= NULL;
    SEARCHARG         *pSearchArg;
    ENTINFSEL         *pSelection;
    ATTR              *pAttr;
    DSNAME            *pRootName;
    SEARCHRES        *pSearchRes=NULL;
    ENTINFLIST       *pEntList=NULL;
    ATTCACHE         *pAC;
    error_status_t    dscode;
    SCODE             scode = SUCCESS_SUCCESS;

    if(!bOnlyOne) {
        *pulFound = 0;
    }
    
    // Convert the MAPI SRestriction to a DS Filter
    if (SRestrictToFilter(pTHS,
                          pStat,
                          pRestriction,
                          &pFilter)) {
        return MAPI_E_TOO_COMPLEX;                // assume error too complex
    }
    
    // change filter to find stuff only in the address book
    if(!MakeABFilter(pTHS, &pABFilter, pFilter, pStat->ContainerID)) {
        // The filter didn't work, so we have a search with no objects in it.
        return SUCCESS_SUCCESS;
    }

    if (!(pAC = SCGetAttById(pTHS, ATT_DISPLAY_NAME))) {
        return MAPI_E_CALL_FAILED;
    }

    // see if we can used a cached SEARCHARG, otherwise build one
    // once you build it, it remains the same between calls
    // the only thing that changes is the filter
    // we leak memory here, but its ok
    if (ppCachedSearchArg && *ppCachedSearchArg) {
        pSearchArg = *ppCachedSearchArg;
    }
    else {
        pSearchArg = (SEARCHARG *) THAllocEx(pTHS, sizeof(SEARCHARG));

        if (ppCachedSearchArg) {
            *ppCachedSearchArg = pSearchArg;
        }

        memset(pSearchArg, 0, sizeof(SEARCHARG));

        // set the Root of the search (root of the tree)
        pRootName = (DSNAME *) THAllocEx(pTHS, sizeof(DSNAME));
        memset(pRootName,0,sizeof(DSNAME));
        pRootName->structLen = DSNameSizeFromLen(0);

        pSearchArg->pObject = pRootName;
        pSearchArg->choice = SE_CHOICE_WHOLE_SUBTREE;

        // Initialize search command
        InitCommarg(&pSearchArg->CommArg);
        pSearchArg->CommArg.ulSizeLimit = ulRequested;
        pSearchArg->CommArg.Svccntl.fDontOptimizeSel = TRUE;

        pSearchArg->CommArg.DeltaTick = 1000 * LdapMaxQueryDuration;
        pSearchArg->CommArg.StartTick = GetTickCount();
        if(!pSearchArg->CommArg.StartTick) {
            pSearchArg->CommArg.StartTick = 0xFFFFFFFF;
        }

        // set requested read attributes. only DisplayName
        pAttr = (ATTR *) THAllocEx(pTHS, sizeof(ATTR));
        pAttr->attrTyp = ATT_DISPLAY_NAME;
        pAttr->AttrVal.valCount=0;
        pAttr->AttrVal.pAVal=NULL;

        // set entry information selection
        pSelection = (ENTINFSEL *) THAllocEx(pTHS, sizeof(ENTINFSEL));
        memset(pSelection, 0, sizeof(ENTINFSEL));
        pSelection->attSel = EN_ATTSET_LIST;
        pSelection->infoTypes = EN_INFOTYPES_SHORTNAMES;
        pSelection->AttrTypBlock.attrCount = 1;
        pSelection->AttrTypBlock.pAttr = pAttr;
        pSearchArg->pSelection = pSelection;
        
        pSearchArg->pSelectionRange = NULL;

        // if the client asks for leaving the results in a sorted table
        // then we pass this flag in the localSearch
        // otherwise we use the default mechanism, which is creating 
        // a list of the returned entries in memory
        if (bPutResultsInSortedTable) {
            // specify attribute to sort on
            // as well that we need to keep the results on the sorted table
            pSearchArg->fPutResultsInSortedTable = TRUE;

            pSearchArg->CommArg.SortType = SORT_MANDATORY;
            pSearchArg->CommArg.SortAttr = pAC->id;

            // change the locale to sort on
            pTHS->dwLcid = pStat->SortLocale;
        }

        // search on the GC
        pSearchArg->bOneNC =  FALSE;
    }
    // set requested filter
    pSearchArg->pFilter = pABFilter;


    // the main search. similar to SearchBody but uses cached information

    pSearchRes = (SEARCHRES *)THAllocEx(pTHS, sizeof(SEARCHRES));

    {
        DWORD  dwNameResFlags = NAME_RES_QUERY_ONLY;

        // We perform name resolution. Set the children needed flag
        // according to if the search includes child objects.
        dwNameResFlags |= NAME_RES_CHILDREN_NEEDED;

        if (!pSearchArg->bOneNC) {
            // We are on a GC, thus it is OK to root a search from a phantom
            // as long as the search wasn't a base-only one.
            // Set the flags to show this.
            dwNameResFlags |= NAME_RES_PHANTOMS_ALLOWED;
        }
       
        // if this is available we can use cached information for this search
        // note that we have to reposition in order to take advantage of this 
        // cached information
        if (pSearchArg->pResObj &&
            (!DBTryToFindDNT(pTHS->pDB, pSearchArg->pResObj->DNT) )) {

                LocalSearch(pTHS, pSearchArg, pSearchRes, SEARCH_AB_FILTER | SEARCH_UNSECURE_SELECT);
                // Search may have opened a sort table.  Some callers require that it
                // be closed. 
                if (!bPutResultsInSortedTable) {
                    DBCloseSortTable(pTHS->pDB);
                }
        }
        else if( 0 == DoNameRes(pTHS,
                          dwNameResFlags,
            			  pSearchArg->pObject,
			              &pSearchArg->CommArg,
			              &pSearchRes->CommRes,
                          &pSearchArg->pResObj)) {

                LocalSearch(pTHS, pSearchArg, pSearchRes, SEARCH_AB_FILTER | SEARCH_UNSECURE_SELECT);
                // Search may have opened a sort table.  Some callers require that it
                // be closed. 
                if (!bPutResultsInSortedTable) {
                    DBCloseSortTable(pTHS->pDB);
                }
                
       }
       else {
           if (ppCachedSearchArg) {
               *ppCachedSearchArg = NULL;
           }
       }
    }

    if (bPutResultsInSortedTable && (pTHS->errCode == DB_ERR_CANT_SORT)) {
        LogEvent(DS_EVENT_CAT_MAPI,
             DS_EVENT_SEV_EXTENSIVE,
             DIRLOG_MAPI_TABLE_TOO_BIG,
             NULL,
             NULL,
             NULL);

        DBCloseSortTable(pTHS->pDB);

        return MAPI_E_TABLE_TOO_BIG;
    }

    if (pSearchRes->pPartialOutcomeQualifier && 
        pSearchRes->pPartialOutcomeQualifier->problem == PA_PROBLEM_TIME_LIMIT) {
        return MAPI_E_TABLE_TOO_BIG;
    }

    
    if(pTHS->errCode) {
        return MAPI_E_CALL_FAILED;
    }

    
    // Now, go through the returned objects and put them in a sort table.
    
    if(pSearchRes->count) { // Some results.

        DWORD dntFound = 0;

        if (bPutResultsInSortedTable) {
            // we already have the temp table
            Assert(pTHS->pDB->JetSortTbl);

            if(bOnlyOne) {
                if (err = DBMove(pTHS->pDB, TRUE, DB_MoveFirst)) {
                    scode = MAPI_E_CALL_FAILED;
                    goto ErrorOut;
                }

                dntFound = ABGetDword(pTHS, TRUE, FIXED_ATT_DNT);
            }
            else {
                *pulFound = pSearchRes->count;
            }
        }
        else {
            if(bOnlyOne) {
                dntFound = DNTFromShortDSName(pSearchRes->FirstEntInf.Entinf.pName);
            }
            else {
                // Init a temporary table for sorting.
                Assert(!pTHS->pDB->JetSortTbl);

                if(DBOpenSortTable(pTHS->pDB,
                                   pStat->SortLocale,
                                       0,
                                   pAC)) {
                    scode = MAPI_E_CALL_FAILED;
                    goto ErrorOut;
                }

                pEntList = &pSearchRes->FirstEntInf;
                for(i=0; i < pSearchRes->count;i++) {
                    // add to temporary table

                    Assert(pEntList->Entinf.pName->NameLen == 0);
                    Assert(pEntList->Entinf.pName->structLen >=
                           (DSNameSizeFromLen(0) + sizeof(DWORD)));; 

                    // Get the diplayname
                    if(pEntList->Entinf.AttrBlock.attrCount &&
                       pEntList->Entinf.AttrBlock.pAttr[0].AttrVal.valCount) {
                        // Got the name.
                        switch( DBInsertSortTable(
                                pTHS->pDB,
                                pEntList->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal,
                                pEntList->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[0].valLen,
                                DNTFromShortDSName(pEntList->Entinf.pName))) {

                        case DB_success:
                            (*pulFound)++;
                            break;
                        case DB_ERR_ALREADY_INSERTED:
                            // This is ok, it just means that we've already
                            // added this object to the sort table.  Don't
                            // inc the count.
                            break;
                        default:
                            // Something went wrong.
                            scode = MAPI_E_CALL_FAILED;
                            goto ErrorOut;
                            break;
                        }
                    }

                    if ((*pulFound > ulRequested) || eServiceShutdown) {
                        scode = MAPI_E_TABLE_TOO_BIG;
                        goto ErrorOut;
                    }

                    pEntList = pEntList->pNextEntInf;

                }
            }
        }

        if(bOnlyOne) {
            /* This case is looking for exactly one item, and
            * will store the DNT in the pdwCount field.  If
            * *pdwCount == 0, we haven't found anything yet,
            * so put the DNT we just found into it.  If
            * *pdwCount != 0, then we've already found a
            * match, so this dnt better be the same.
            */
            if(pSearchRes->count > 1) {
                scode = MAPI_E_TABLE_TOO_BIG;
            }
            else if(!*pulFound) {
                *pulFound = dntFound;
            }
            else if (*pulFound != dntFound ) {
                scode = MAPI_E_TABLE_TOO_BIG;
            }
        }

    ErrorOut:
        if (!bPutResultsInSortedTable) {
            ABFreeSearchRes(pSearchRes);
        }
    }
    
    return scode;
}

SCODE
ABProxySearch (
        THSTATE *pTHS,
        PSTAT pStat,
        PWCHAR pwTarget,
        DWORD cbTarget)
/*++

  Search the whole database for an exact match on the proxy address specified.

  Returns an scode: 

    SUCCESS_SUCCESS = found a unique proxy address
    MAPI_E_NOT_FOUND = found no such proxy address
    MAPI_E_AMBIGUOUS_RECIP = found more than one such proxy address.

  On success, sets the DNT of the object found in the stat block.
 
--*/
{
    DSNAME            RootName;
    SEARCHARG         SearchArg;
    SEARCHRES        *pSearchRes=NULL;
    ENTINFSEL         selection;
    SCODE             scode = MAPI_E_CALL_FAILED;
    FILTER            ProxyFilter;
    
    // OK, do a whole subtree search, filter of proxyaddresses == pwTarget
    memset(&SearchArg, 0, sizeof(SearchArg));
    memset(&selection, 0, sizeof(selection));

    // Root the search here
    memset(&RootName,0,sizeof(RootName));
    RootName.structLen = DSNameSizeFromLen(0);
    
    SearchArg.pObject = &RootName;
    SearchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
    InitCommarg(&SearchArg.CommArg);
    // Ask for two.  We need to know later if it was unique, non-unique, or
    // non-visible. 
    SearchArg.CommArg.ulSizeLimit = 2;
    SearchArg.CommArg.Svccntl.fDontOptimizeSel = TRUE;
    SearchArg.pFilter = &ProxyFilter;
    
    SearchArg.CommArg.DeltaTick = 1000 * LdapMaxQueryDuration;
    SearchArg.CommArg.StartTick = GetTickCount();
    if(!SearchArg.CommArg.StartTick) {
        SearchArg.CommArg.StartTick = 0xFFFFFFFF;
    }

    memset (&ProxyFilter, 0, sizeof (ProxyFilter));
    ProxyFilter.choice = FILTER_CHOICE_ITEM;
    ProxyFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    ProxyFilter.FilterTypes.Item.FilTypes.ava.type = ATT_PROXY_ADDRESSES;
    ProxyFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = cbTarget;
    ProxyFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (PUCHAR)pwTarget;


    // Selection of nothing (just need the name in the entinf)
    SearchArg.pSelection = &selection;
    selection.attSel = EN_ATTSET_LIST;
    selection.infoTypes = EN_INFOTYPES_SHORTNAMES;
    selection.AttrTypBlock.attrCount = 0;
    selection.AttrTypBlock.pAttr = NULL;

    SearchArg.pSelectionRange = NULL;
    SearchArg.bOneNC =  FALSE;
    
    pSearchRes = (SEARCHRES *)THAllocEx(pTHS, sizeof(SEARCHRES));
    SearchBody(pTHS, &SearchArg, pSearchRes, SEARCH_UNSECURE_SELECT);
    if(pTHS->errCode) {
        return MAPI_E_CALL_FAILED;
    }

    switch(pSearchRes->count) {
    case 0:
        // No such proxy.
        scode = MAPI_E_NOT_FOUND;
        break;

    case 1:
        // Exactly 1 (visible) proxy
        pStat->CurrentRec =
            DNTFromShortDSName(pSearchRes->FirstEntInf.Entinf.pName); 
        scode = SUCCESS_SUCCESS;
        break;

    default:
        // Ununique proxy.
        scode = MAPI_E_AMBIGUOUS_RECIP;
    }
    
    ABFreeSearchRes(pSearchRes);

    return scode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\nspis\abtools.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       abtools.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module implements address book tools and abstractions of the DBLayer to
    build a containerized address book view on top of the DBLayer.

Author:

    Dave Van Horn (davevh) and Tim Williams (timwi) 1990-1995

Revision History:
    
    25-Apr-1996 Split this file off from a single file containing all address
    book functions, rewrote to use DBLayer functions instead of direct database
    calls, reformatted to NT standard.
    
--*/
#include <NTDSpch.h>
#pragma  hdrstop

#include <ntdsctr.h>                   // PerfMon hooks

// Core headers.
#include <ntdsa.h>                      // Core data types 
#include <scache.h>                     // Schema cache code
#include <dbglobal.h>                   // DBLayer header.
#include <mdglobal.h>                   // THSTATE definition
#include <mdlocal.h>                    // THSTATE definition
#include <dsatools.h>                   // Memory, etc.

// Logging headers.
#include <mdcodes.h>                    // Only needed for dsevent.h
#include <dsevent.h>                    // Only needed for LogUnhandledError

// Assorted DSA headers.
#include <hiertab.h>                    // GetIndexSize
#include <dsexcept.h>
#include <objids.h>                     // need ATT_* consts
#include <permit.h>                     // RIGHT_DS_LIST_CONTENTS
#include <anchor.h>                     // for global anchor
#include <debug.h>                      // Assert
#include <filtypes.h>

// Assorted MAPI headers.
#include <mapidefs.h>                   // These four files
#include <mapitags.h>                   //  define MAPI
#include <mapicode.h>                   //  stuff that we need
#include <mapiguid.h>                   //  in order to be a provider.

// Nspi interface headers.
#include "nspi.h"                       // defines the nspi wire interface
#include <nsp_both.h>                   // a few things both client/server need
#include <_entryid.h>                   // Defines format of an entryid
#include <abserv.h>                     // Address Book interface local stuff
#include <_hindex.h>                    // Defines index handles.

#include <fileno.h>
#define  FILENO FILENO_ABTOOLS

// The EMS address book provider's MAPIUID
MAPIUID muidEMSAB = MUIDEMSAB;


// How close to ends do we get before doing our own positioning
#define EPSILON     100

// This provider's Email Type, both in string 8 and Unicode.
char    *lpszEMT_A = EMAIL_TYPE;
DWORD   cbszEMT_A = sizeof(EMAIL_TYPE);
wchar_t *lpszEMT_W = EMAIL_TYPE_W;
DWORD   cbszEMT_W = sizeof(EMAIL_TYPE_W);

// These two class-ids are referenced in the code here to map to and from
// mapi types to DS classes, but these classes are not in the base schema
// and so the ids are not in attids.h. The classes were removed when most
// Exchange attributes/classes were removed. Exchange has promised to keep
// the OIDs exactly same if they readd these classes later. If we had kept
// these in the base schema, we would also have to keep all their attributes,
// which would unnecessarily clutter the base schema. The OIDs for these
// are 1.2.840.113556.1.3.48 for Remote-Address, and 
// 1.2.840.113556.1.3.15 for Public-Folder

#define CLASS_REMOTE_ADDRESS                   196656 // 0x30030    (\x2A864886F714010330)
#define CLASS_PUBLIC_FOLDER                    196623 // 0x3000f    (\x2A864886F71401030F)



/************ Function Prototypes ****************/


void
R_Except(
        PSZ pszCall,
        DB_ERR err
        )
{
#if DBG
    printf("Jet%s error: %d\n", pszCall, err );
#endif /*DBG*/
    DsaExcept(DSA_DB_EXCEPTION, err,0);
    // doesn't return
}     

BOOL
ABIsInContainer (
        THSTATE *pTHS,
        DWORD ContainerID
        )
{
    DWORD dwThisContainerID=~ContainerID;
    
    // Read the container id FROM THE INDEX KEY! and see if it is the one passed
    // in.
    DBGetSingleValueFromIndex (
            pTHS->pDB,
            ATT_SHOW_IN_ADDRESS_BOOK,
            &dwThisContainerID,
            sizeof(DWORD),
            NULL);

    return (dwThisContainerID == ContainerID);
}

DWORD
ABGetDword (
        THSTATE *pTHS,
        BOOL UseSortTable,
        ATTRTYP Att
        )
/*++

Routine Description:

    Look up the first value of a given attribute on the current object in the
    database.  Value must be readable as a DWORD.  This is designed to be fast.
    UseSortTable is a flag to use the sort table or not.  If not, use the main
    database table.
    
Arguments:

    UseSortTable - flag to use the sort table or not.

    Att - the attribute to look up

Return Values:

    the data read, or 0 if no data was read (note that there is no way to
    differentiate between data of 0, no data, and an error.)

--*/
{
    DWORD   dwData;

    switch(Att) {
    case FIXED_ATT_DNT:
        if(UseSortTable) {
            if (DBGetDNTSortTable(pTHS->pDB, &dwData)) 
                dwData = 0;
        }
        else {
            dwData = pTHS->pDB->DNT;
        }
        break;

    default:
        if(UseSortTable) {
            return 0;
        }
        else if (DBGetSingleValue(pTHS->pDB, Att,
                                  &dwData, sizeof(DWORD),NULL)) {
            dwData = 0;
        }
        break;
    }
    
    return dwData;
}

DWORD
abSeekVerify (
        THSTATE *pTHS,
        char *pTarget,
        DWORD cbTarget,
        DWORD attrtyp
        )
/*++
Routine Description:

    This routine verifies that the object which has database currency has the
    correct attribute value (as specified in pTarget), that the object is not
    deleted, and that the attribute value is unique.
    
Arguments:


    pTarget - the attribute value we are looking for.

    cbTarget - the length of the value.

    attrtyp - the attrtyp of the value we're looking for for uniqueness, etc.

Return Values:
    
    Returns 0 for unique object, DB_ERR_ATTRIBUTE_EXISTS for non-unique object,
    other errors for other problems.
    
--*/
{
    DB_ERR              err=0;
    ATTCACHE            *pAC;
    DWORD               foundDNT = 0;
    BOOL                fVerifyValue = TRUE;
    DWORD               keyLen=0;
    DBBOOKMARK          dbBookMark = {0,0};
    
    if (!(pAC = SCGetAttById(pTHS, attrtyp)))
        return DB_ERR_UNKNOWN_ERROR;

    // Verify that
    // 1) the value is correct, and
    // 2) the object is not deleted.
    // 3) the value is unique.
    //
    // If the key wasn't truncated, then we don't actually have to read any
    // values, since we know we are doing an exact seek with an index range.
    DBGetKeyFromObjTable(pTHS->pDB, NULL, &keyLen);
    if(keyLen < DB_CB_MAX_KEY) {
        fVerifyValue = FALSE;
    }
    
    // NOTE: this works because we have an index range set from the
    // ABSeek we did which had bExact as a flag.
    while(err == DB_success) {
        if(!ABGetDword(pTHS,FALSE, ATT_IS_DELETED)) {
            // There is another value to consider, get it and compare it against
            // the target value.

            TRIBOOL retfil = eFALSE;
            
            if(!fVerifyValue ||
               ((retfil = DBEval(pTHS->pDB, FI_CHOICE_EQUALITY,
                                    pAC,
                                    cbTarget,
                                    pTarget)) == eTRUE) ) {
                // OK, the string is correct.
                
                if(!foundDNT) {
                    // This is the first correct string, remember the
                    // DNT.
                    foundDNT = pTHS->pDB->DNT;
                    DBGetBookMark(pTHS->pDB, &dbBookMark);
                }
                else if(pTHS->pDB->DNT != foundDNT) {
                    // This is not the only object with the correct
                    // string.  Therefore, the proxy is not unique.
                    // Return an errror.
                    DBFreeBookMark(pTHS, dbBookMark);
                    return DB_ERR_ATTRIBUTE_EXISTS;
                }
            }
            Assert (VALID_TRIBOOL(retfil));
        }           // if(!ABGetDword)
        err = DBMove(pTHS->pDB, FALSE, DB_MoveNext);
    }           // while

    if(foundDNT) {
        // ok, real object and it's unique.  Replace currency.
        DBGotoBookMark(pTHS->pDB, dbBookMark);
        DBFreeBookMark(pTHS, dbBookMark);
        return 0;
    }
    else {
        return DB_ERR_ATTRIBUTE_DOESNT_EXIST;
    }
}

DB_ERR
ABSeek (
        THSTATE *pTHS,
        void * pvData,
        DWORD cbData,
        DWORD dwFlags,
        DWORD ContainerID,
        DWORD attrTyp
      )
/*++

Routine Description:

    Abstracts a DBSeek inside an Address Book container.  Assumes at most one
    value to seek on.  If no values are specified, it seeks to the beginning of
    the appropriate container.  If bEXACT is set in the dwFlags, call DBSeek
    with Exact = TRUE.  We also set an index range.

    NOTE: assumes the DBPOS already is set up on the appropriate index for the
    Address Book Container in question.
    
Arguments:

    pvData - the Data to look for.

    cbData - the count of bytes of the data.

    dwFlags - the flags describing the kind of seek

    ContainerID - the Address Book Container to abstract this seek inside.

    attrTyp - the type of the value, used for verification in the seek exact
              case. 

Return Values:

    0 if all went well, an error code otherwise.
    if dwFlags & bEXACT, we verify that the seek brought us to a true match
    (i.e. we didn't get bitten by key truncation), the object is not-deleted,
    AND the objects value is unique.

--*/
{
    INDEX_VALUE index_values[2];
    ULONG       cVals = 0;
    ULONG       dataindex=0;
    DB_ERR      err;

    // For a seek on the MAPIDN index or the PROXYADDRESS index, we aren't given
    // a container value. 
    if(ContainerID) {
        index_values[0].pvData = &ContainerID;
        index_values[0].cbData = sizeof(DWORD);
        dataindex++;
        cVals++;
    }
    // PVData == 0 only for the abstraction of DB_MoveFirst in a container.  To
    // handle ascending and descending sorts correctly, this only seeks on
    // ContainerID.
    
    if(pvData) {
        index_values[dataindex].pvData = pvData;
        index_values[dataindex].cbData = cbData;
        cVals++;
    }

    // We should never be called both without a ContainerID and without data.
    Assert(cVals);
    
    err = DBSeek(pTHS->pDB, index_values, cVals,
                 ((dwFlags & bEXACT)?DB_SeekEQ:DB_SeekGE));

    // Make sure we are in the correct container.
    if((err != DB_ERR_RECORD_NOT_FOUND) &&
       ContainerID &&
       !ABIsInContainer(pTHS,ContainerID)) {
        err = DB_ERR_RECORD_NOT_FOUND;
    }
    
    if(!err && (dwFlags & bEXACT)) {
        // Set an index range
        err = DBSetIndexRange(pTHS->pDB, index_values, cVals);
        if(!err) {
            err = abSeekVerify(
                    pTHS,
                    pvData,
                    cbData,
                    attrTyp);
        }
    }
    
    return err;
}
DB_ERR
abFixCurrency(
        THSTATE *pTHS,
        DWORD ContainerID,
        DWORD SortLocale
        )
{
    INDEX_VALUE index_values[4];
    DB_ERR      err;
    UCHAR       DispNameBuff[CBMAX_DISPNAME];
    UCHAR       DispNameBuff2[CBMAX_DISPNAME];
    DWORD       cbData = 0, cbData2=0;
    DWORD       dnt;
    BYTE        pKey[DB_CB_MAX_KEY];
    DWORD       cbKey=DB_CB_MAX_KEY;
    BYTE        bVisible = 1;
    
    // MaintainCurrency no longer works here since we have changed the
    // definition of the index so that objects can appear multiple times, so 
    // maintaining the currency from the DNT index lands you in a random spot in
    // the ABView index.
    
    // First, see if the containerID from the index is the one we are on.
    if(ABIsInContainer(pTHS,ContainerID)) {
        // Currency was maintained, and we are in the correct container.  Life
        // is good.
        return 0;
    }

    // Ooops.  We thought we maintained currency, but we seem to be in the wrong
    // container.  See if the object exists in the correct container.  Remember,
    // we are on the correct object, so the display name is correct.

    // Build a key.  We use the ContainerID passed in and the display name from
    // the key of the object we're sitting on.
    DBGetSingleValueFromIndex (
            pTHS->pDB,
            ATT_DISPLAY_NAME,
            DispNameBuff,
            CBMAX_DISPNAME,
            &cbData);

    dnt = pTHS->pDB->DNT;
    
    index_values[0].pvData = &ContainerID;
    index_values[0].cbData = sizeof(DWORD);
    index_values[1].pvData = DispNameBuff;
    index_values[1].cbData = cbData;
    index_values[2].pvData = &bVisible;
    index_values[2].cbData = sizeof(bVisible);
    index_values[3].pvData = &dnt;
    index_values[3].cbData = sizeof(DWORD);
    

    err = DBSeek(pTHS->pDB, index_values, 4, DB_SeekEQ);
    switch (err) {
    case 0:
        // Found an object with that name.  Verify the DNT.
        DBGetKeyFromObjTable(pTHS->pDB, pKey, &cbKey);

        if(cbKey < DB_CB_MAX_KEY) {
            // Key wasn't truncated, therefore we had an exact match.
            return 0;
        }

        // Key was truncated, we might not really have a match.
        while(!err) {
            // Verify the container, display name and the DNT of this object.
            if(!ABIsInContainer(pTHS, ContainerID)) {
                // Oops, we're not in the correct container.
                err = DB_ERR_NO_CURRENT_RECORD;
            }
            else {
                // Container is ok, how about the display name.
                DBGetSingleValueFromIndex (
                        pTHS->pDB,
                        ATT_DISPLAY_NAME,
                        DispNameBuff2,
                        CBMAX_DISPNAME,
                        &cbData2);
                if(CompareStringW(SortLocale,
                                  LOCALE_SENSITIVE_COMPARE_FLAGS,
                                  (wchar_t *)DispNameBuff,
                                  cbData/sizeof(wchar_t),
                                  (wchar_t *)DispNameBuff2,
                                  cbData2/sizeof(wchar_t)  )    > 2) {
                    // Hey, this name is greater than the one we are looking
                    // for. So, the object we are looking for doesn't exist in
                    // this container.
                    err = DB_ERR_NO_CURRENT_RECORD;
                }
                else {
                    // Finally, is the DNT correct?
                    if(pTHS->pDB->DNT == dnt) {
                        // Yep, we're there.
                        return 0;
                    }
                    // Nope.  So, move to the next object.
                    err = DBMove(pTHS->pDB, FALSE, DB_MoveNext);
                }
            }
        }
        // We never found the object.
        return DB_ERR_NO_CURRENT_RECORD;
        
    case DB_ERR_RECORD_NOT_FOUND:
        // The object doesn't exist in this container.  Return the error that
        // callers are expecting.
        return DB_ERR_NO_CURRENT_RECORD;
        break;
        
    default:
        // Some other error, return it.
        return err;
    }
    
}

DB_ERR
ABSetLocalizedIndex (
        THSTATE *pTHS,
        ULONG ulSortLocale,
        eIndexId IndexId,
        BOOL MaintainCurrency,
        DWORD ContainerID
        )
/*++

Routine Description:

    Sets the current index of the Object Table to the named index.  Try to apply
    the locale specified to get a localized index.  If we can't get a localized
    index, fall back to the locale specified in the DS anchor (the default
    locale for this directory).  If even that fails, try using a non-localized
    version of the index.

    Note: localized versions of an index name are created by appending the
    string version of the sortlocale (in Hex, using 8 digits).
    
Arguments:

    ulSortLocale - the locale to use as a first choice for localized indices.

    IndexId - the index to set to.

    MaintainCurrency - Do we want to maintain the current object as the current
        object after the index change?

Return Values:

    0 if all went well, an error code otherwise.

--*/
{
    DB_ERR  err;
    
    // if we were passed a LocaleId - use it to try to find a localized index
    if (ulSortLocale) {
        
        err = DBSetLocalizedIndex(pTHS->pDB,
                                  IndexId,
                                  LANGIDFROMLCID(ulSortLocale),
                                  MaintainCurrency);
        
        if(!err && MaintainCurrency) {
            // We correctly flipped to the new index and maintained some kind of
            // currency, but is it the correct currency?  Verify, and fix if
            // necessary. 
            return abFixCurrency(pTHS, ContainerID, ulSortLocale);
        }
        if(err != DB_ERR_BAD_INDEX) {
            // We failed to set to the correct index with some weird error
            // code.  We will go home now without trying other fall bacck
            // indices. 
            return err;
        }
    }

    err = DBSetLocalizedIndex(pTHS->pDB,
                              IndexId,
                              LANGIDFROMLCID(gAnchor.ulDefaultLanguage),
                              MaintainCurrency); 
    if(!err && MaintainCurrency) {
        // We correctly flipped to the new index and maintained some kind of
        // currency, but is it the correct currency?  Verify, and fix if
        // necessary. 
        return abFixCurrency(pTHS, ContainerID,
                             LANGIDFROMLCID(gAnchor.ulDefaultLanguage)); 
    }
    if(err != DB_ERR_BAD_INDEX) {
        // We failed to set to the correct index with some weird error
        // code.  We will go home now without trying other fall bacck
        // indices. 
        return err;
    }
    
    // No localized index - use the default
    err = DBSetCurrentIndex(pTHS->pDB, IndexId, NULL, MaintainCurrency);
    if(!err && MaintainCurrency) {
        // We correctly flipped to the new index and maintained some kind of
        // currency, but is it the correct currency?  Verify, and fix if
        // necessary. 
        return abFixCurrency(pTHS, ContainerID, DS_DEFAULT_LOCALE);
    }
    return err;
}

DWORD
ABSetIndexByHandle(
        THSTATE *pTHS,
        PSTAT pStat,
        BOOL MaintainCurrency
        )
/*++

Routine Description:

    Sets the current index of the Object Table to the index specified by the
    index handle in the stat block.
    
Arguments:

    pStat - the Stat block to get the index handle from.

    MaintainCurrency - Do we want to maintain the current object as the current
        object after the index change?

Return Values:

    0 if all went well, an error code otherwise.

--*/
{
    ULONG   hIndex = pStat->hIndex;

    // Check the validity of the index handle.
    if (hIndex > AB_MAX_SUPPORTED_INDEX ||
        hIndex == H_WHEN_CHANGED_INDEX     )  {
        DsaExcept(DSA_EXCEPTION, hIndex,0);
    }

    // Pass through to the routine to set localized indices, looking up the
    // string name of the appropriate index in the array.
    return ABSetLocalizedIndex(pTHS,
                               pStat->SortLocale,
                               (hIndex == H_PROXY_INDEX)
                                ? Idx_Proxy:Idx_ABView,
                               MaintainCurrency,
                               pStat->ContainerID);
}

void
ABSetFractionalPosition (
        THSTATE *pTHS,
        DWORD Numerator,
        DWORD Denominator,
        DWORD ContainerID,
        INDEXSIZE *pIndexSize
        )
/*++

Routine Description:
    Abstracts fractional positioning within an address book container.

    Note that the GAL is one index, while the other containers are ranges within
    another (single) index.  Therefore, fractional positioning in a container
    other than the GAL requires that you set the postion to a fractional
    position withing a range of the index, not within the index as a whole.

    Note that the Denominator is assumed to be the actual count of objects in
    the container.
    
Arguments:

    Delta - The distance to move.  Accepts numeric arguments and DB_MoveFirst,
    DB_MoveLast, DB_MoveNext, DB_MovePrevious.

    ContainerID - the ID of the address book container to move around in.

Return Value:
    Returns 0 if successful, an error code otherwise.

--*/    
{
    DB_ERR   err;
    DWORD    tblsize = Denominator;     // Denominator may change.
    DWORD ContainerNumerator = 0;
    DWORD ContainerDenominator = 0;

    Assert(ContainerID);
    
    // Moving in a continer.  Fix up the Numerator and Denominator to refer
    // to the correct place in the whole subcontianers index assuming they
    // currently refer to a range in that index.  Do this by
    // 1) Get the fractional position of the beginning of the appropriate
    //  container.  This is the offset from the beginning of the index to
    //  the first element of the subcontainer.
    //
    // 2) Change the Denominator to be the size of the index.  Now,
    //   Numerator and Denominator refer to movement within the whole index,
    //   not just movement within the subcontainer.
    //
    // 3) Normalize the Numerator/Denominator and fractional position of the
    //   beginning of the container so they may be added together.  This
    //   gives you a new Denominator.
    //
    // 4) Add the Numerator and the numerator of the fractional position of
    //   the beginning of the container.  This gives you a new numerator.
    //
    // There, that wasn't that hard, was it?

    // Move to beginning of container.
    if(DB_ERR_NO_CURRENT_RECORD ==
       (err = ABMove(pTHS, DB_MoveFirst, ContainerID, FALSE)))
        R_Except("GotoPos", err);
    
    // Get fractional position of beginning.
    DBGetFractionalPosition(pTHS->pDB,
                            &ContainerNumerator,
                            &ContainerDenominator);
    
    // Reset the Denominator.
    Denominator = pIndexSize->TotalCount;
    
    // Normalize to the greater Denominator
    if(Denominator > ContainerDenominator) {
        ContainerNumerator = MulDiv(ContainerNumerator,
                                    Denominator,
                                    ContainerDenominator);
    }
    else {
        Numerator = MulDiv(Numerator,
                           ContainerDenominator,
                           Denominator);
        Denominator = ContainerDenominator;
    }
    
    // Add everything up.
    Numerator += ContainerNumerator;
    
    err = DBSetFractionalPosition(pTHS->pDB, Numerator, Denominator);
    if(err != DB_success )
        R_Except("GotoPos", err);

    if(!ABIsInContainer(pTHS, ContainerID)) {
        // Not in the right container.  Do this the long way.
        if((2 * Numerator) < Denominator ) {
            // Closer to the front. 
            ABMove(pTHS, DB_MoveFirst, ContainerID, FALSE );
            ABMove(pTHS, Numerator, ContainerID, TRUE );
        }
        else {
            ABMove(pTHS, DB_MoveLast,ContainerID, FALSE);
            // Now move back.  use -(tblsize - Numerator - 1) because our "end"
            // is past eof, but ABMove's is on eof.
            ABMove(pTHS, 1 - tblsize + Numerator, ContainerID, TRUE);
        }
    }

    return;
}

void
ABGetFractionalPosition (
        THSTATE *pTHS,
        PSTAT pStat,
        INDEXSIZE *pIndexSize
        )
/*++

Routine Description:
    Abstracts gettingfractional positioning within an address book container.

    Note that the all the containers are ranges within a single index.
    Therefore, fractional positioning in a container requires that you get the
    fractional position within a range of the index, not within the index as a
    whole.  

    Note that the Denominator is assumed to be the actual count of objects in
    the container.
    
Arguments:

    Delta - The distance to move.  Accepts numeric arguments and DB_MoveFirst,
    DB_MoveLast, DB_MoveNext, DB_MovePrevious.

    ContainerID - the ID of the address book container to move around in.

Return Value:
    Returns 0 if successful, an error code otherwise.

--*/    
{
    DWORD   i;
    DWORD   *Numerator = &pStat->NumPos;
    DWORD   *Denominator = &pStat->TotalRecs;
    DB_ERR  err;
    DWORD   ContainerNumerator = 0;
    DWORD   ContainerDenominator = 0;
    DWORD   fEOF;
    DBBOOKMARK dbBookMark = {0,0};

    Assert(pStat->ContainerID == pIndexSize->ContainerID);
    // NOTE: depends on pIndexSize being correct. 
    
    DBGetFractionalPosition(pTHS->pDB, Numerator, Denominator);
    
    // Remember where we are.  
    fEOF = pTHS->fEOF;
    DBGetBookMark(pTHS->pDB, &dbBookMark);
    
    Assert(pStat->ContainerID);
    
    // Adjust the fractional postion to account for position in
    // containerized index by
    // 1) Get the fractional position of where we are.
    // 2) Get the fractional positoin of the beginning of the container.
    // 3) Normalize those.
    // 4) Subtract the position of the container from where we are.  This
    //   leaves us with Numerator/Denominator now being the
    //   fraction of the Denominator from the beginning of the
    //   container to the end of the container.
    // 5) Adjust Numerator/Denomintaor to be a fraction in terms of the
    //   actual size of the index.  Now, Numerator is in units which are the
    //   same as the units of movement within the container.
    // 6) Set Denominator to be the size of the container.
    //

    // Get the fractional position of the beginning of the container.
    err = ABMove(pTHS, DB_MoveFirst, pStat->ContainerID, FALSE);
    if(DB_ERR_NO_CURRENT_RECORD ==  err)
        R_Except("GotoPos", err);
    DBGetFractionalPosition(pTHS->pDB,
                            &ContainerNumerator,
                            &ContainerDenominator); 
    
    // Go back to where we were.
    DBGotoBookMark(pTHS->pDB, dbBookMark);

    // Set back to the correct index.
    ABSetIndexByHandle(pTHS, pStat, TRUE);
    
    // Normalize to the greater Denominator
    if(ContainerDenominator < *Denominator) {
        ContainerNumerator = MulDiv(ContainerNumerator,
                                    *Denominator,
                                    ContainerDenominator);
    }
    else {
        *Numerator = MulDiv(*Numerator,
                            ContainerDenominator,
                            *Denominator);
        *Denominator = ContainerDenominator;
    }
    
    // Subtract (step 4 above)
    if(*Numerator < ContainerNumerator)
        *Numerator = 0;
    else
        *Numerator -= ContainerNumerator;
    
    // Normalize to the actual size of the index.
    *Numerator = MulDiv(*Numerator, pIndexSize->TotalCount,*Denominator);
    
    // Fix the denominator.
    *Denominator = pIndexSize->ContainerCount;

    // If the fractional position is > 1, set it to 1.
    if (*Numerator >= *Denominator)
        *Numerator = *Denominator -1;
    
    // We need to crawl forward and back EPSILON spaces to see if we're close
    // enough to the end that we need an accurate fractional position. 
    for(i=1;i<EPSILON;i++) {
        // crawl forward
        if(DB_ERR_NO_CURRENT_RECORD == ABMove(pTHS, DB_MoveNext,
                                        pStat->ContainerID, FALSE)) {
            *Denominator = pIndexSize->ContainerCount;
            *Numerator = *Denominator - i;
            goto End;               // off the back, set the frac & leave
        }
    }
    // Go back to where we were.
    DBGotoBookMark(pTHS->pDB, dbBookMark);
    // Set back to the correct index.
    ABSetIndexByHandle(pTHS, pStat, TRUE);
    
    for(i=0;i<EPSILON;i++) {        // crawl back
        if(DB_ERR_NO_CURRENT_RECORD==ABMove(pTHS,
                                      DB_MovePrevious, pStat->ContainerID, FALSE)) { 
            *Denominator = pIndexSize->ContainerCount;
            *Numerator = i;
            goto End;               // off the front, set the frac & leave
        }
    }
End:
    // Go back to where we were.
    DBGotoBookMark(pTHS->pDB, dbBookMark);
    // Set back to the correct index.
    ABSetIndexByHandle(pTHS, pStat, TRUE);
    // Make sure we think the same thing about EOF as we did on entry to this
    // routine. 
    pTHS->fEOF=fEOF;
    
    DBFreeBookMark(pTHS, dbBookMark);

    return;
}

void
ABGetPos (
        THSTATE *pTHS,
        PSTAT pStat,
        PINDEXSIZE pIndexSize
        )
/*++

Routine Description:
    Set up the stat block based on currency in the DBlayer.  Note that we will
    return  BOOKMARK_END if we are at the end, but we set currentDNT to the
    actual first DNT if we are at the beginning. 

    Called from various places, usually just before we return to the client.

Arguments:

    pStat - the stat block to fill in.

Return Value:
    None.

--*/    
{
    Assert(pIndexSize->ContainerID == pStat->ContainerID);
    pStat->TotalRecs = pIndexSize->ContainerCount;
    pStat->Delta = 0;                   // always
    
    if(pTHS->fEOF ) {                // off the end
        pStat->NumPos = pStat->TotalRecs;
        pStat->CurrentRec = 2;          // == BOOKMARK_END
    }
    else {
        pStat->CurrentRec = pTHS->pDB->DNT;
        
        if(ABMove(pTHS, DB_MovePrevious, pStat->ContainerID, TRUE)) {
            // At the front 
            pStat->NumPos = 0;
        }
        else {
            // somewhere in the middle, move back where we were 
            ABMove(pTHS, DB_MoveNext, pStat->ContainerID, TRUE);

            // *VERY* approximate pos 
            ABGetFractionalPosition(pTHS, pStat, pIndexSize);
        }
    }
    return;
}

DB_ERR
ABMove (
        THSTATE *pTHS,
        long Delta,
        DWORD ContainerID,
        BOOL fmakeRecordCurrent
        )
/*++

Routine Description:
    Abstracts movement within an address book container.

    Note that the GAL is one index, while the other containers are ranges within
    another (single) index.  Therefore, movement in a container other than the
    GAL might leave you on a record for an object in an innappropriate
    container.  We need to be careful of this.
    
    Note that moving backward past the beginning of the AB container leaves us
    on the first entry of the container, while moving forward past the end of
    the container leaves us one row past the end of the AB container.

Arguments:

    Delta - The distance to move.  Accepts numeric arguments and DB_MoveFirst,
        DB_MoveLast, DB_MoveNext, DB_MovePrevious.

    ContainerID - the ID of the address book container to move around in.
    
    fmakeRecordCurrent - flag whether to read data from the record once moved to it
       if only moving to see where you are located on the index it is better to
       have this to FALSE, since it won't touch the real data, only the index 

Return Value:
    Returns 0 if successful, an error code otherwise.

--*/    
{
    DB_ERR      err;
    
    if(!Delta )                         // check for the null case
        return DB_success;          // nothing to do, and we did it well!
    
    pTHS->fEOF = FALSE;              // clear off the end flag
    Assert(ContainerID);
    
    // Note that we aren't using the sort table.
    
    switch(Delta) {
    case DB_MoveFirst:
        err = ABSeek(pTHS, NULL, 0, bAPPROX, ContainerID, 0);
        if((err == DB_success &&
            (!ABIsInContainer(pTHS, ContainerID)) ||
            err == DB_ERR_NO_CURRENT_RECORD                         ||
            err == DB_ERR_RECORD_NOT_FOUND   )) {
            // Couldn't find the first object in this container.  The
            // container must be empty.  Adjust the error to be the
            // same error that is returned for the GAL is similar
            // circumstances 
            err = DB_ERR_NO_CURRENT_RECORD;
            pTHS->fEOF = TRUE;
        }
        break;
        
    case DB_MoveLast:
        // ABSeek will always leave us in the correct place (one past the
        // end of the container, even if the container is empty.)
        ABSeek(pTHS, NULL, 0, bAPPROX, ContainerID+1, 0);
        
        // Back up to the last object in the container.
        err = DBMovePartial(pTHS->pDB, DB_MovePrevious);
        if(err!= DB_success ||
           !ABIsInContainer(pTHS, ContainerID)) {
            // We couldn't back up to the last row or we did back up and we
            // weren't in the correct container after we did.  Either way,
            // set the flags to indicate we are not in the container.
            err = DB_ERR_NO_CURRENT_RECORD;
            pTHS->fEOF = TRUE;
        }
        break;
        
    default:
        err = DBMovePartial(pTHS->pDB, Delta);
        if((err != DB_ERR_NO_CURRENT_RECORD) &&
           !ABIsInContainer(pTHS, ContainerID)) {
            // we moved to a valid row, but ended up outside of the
            // container.  Set the error to be the same as the error for not
            // moving to a valid row. 
            err=DB_ERR_NO_CURRENT_RECORD;
        }
        
        switch( err ) {
        case DB_success:
            break;
            
        case DB_ERR_NO_CURRENT_RECORD:
            // After the move, we did not end up on a valid row.
            if (Delta < 0) {
                // Moving back, off the front, so move to the first record
                ABMove(pTHS, DB_MoveFirst, ContainerID, fmakeRecordCurrent);
            }
            else {
                // position on the first record of the next container, which
                // is the same thing as being one past the last row of the
                // current container.
                ABSeek(pTHS, NULL, 0, bAPPROX, ContainerID+1, 0);
                pTHS->fEOF = TRUE;
            }
            break;
            
        default:
            R_Except("Move", err);
        }                           // switch on err
        break;
    }                               // switch on Delta

    if (fmakeRecordCurrent && !err) {
        DBMakeCurrent(pTHS->pDB);
    }


    return err;
}

void
ABSetToElement (
        THSTATE *pTHS,
        DWORD NumPos,
        DWORD ContainerID,
        PINDEXSIZE pIndexSize
        )
/*++

Routine Description:

    Go to the NumPos-th element in the ContainerID container.

Arguments:
        
    NumPos - the numerical positon to settle on (i.e. 5 means go to the 5th
      object in the table.)

    ContainerID - the ID of the AB container to move around in.

Return Value:

    None.

--*/
{
    LONG        TotRecs, i;

    Assert(pIndexSize->ContainerID == ContainerID);
    TotRecs = pIndexSize->ContainerCount;
    if(NumPos > (DWORD) TotRecs)
        NumPos = TotRecs;               // cant' go past end. 

    // Special case near ends because ABSetFractionalPosition is only
    // approximate and some of our clients require accurate positioning near end
    // points. 
    
    if(NumPos < EPSILON ) {
        // goto start & count forward 
        ABMove(pTHS, DB_MoveFirst, ContainerID, FALSE );
        ABMove(pTHS, NumPos, ContainerID, TRUE );
    }
    else if((i = TotRecs - NumPos) <= EPSILON) {
        // Go to the end of the table
        ABMove(pTHS, DB_MoveLast,ContainerID, FALSE); 
        // Now move back.  use -(i-1) because our "end" is past eof, but
        // ABMove's is on eof.
        ABMove(pTHS, 1-i,ContainerID, TRUE); 
    }
    else {                               
        // Set approximate fractional position
        ABSetFractionalPosition(pTHS, NumPos, TotRecs, ContainerID, pIndexSize);
    }
    return;
}

void
ABGotoStat (
        THSTATE *pTHS,
        PSTAT pStat,
        PINDEXSIZE pIndexSize,
        LPLONG plDelta
        )
/*++
  
Routine Description:

    Moves currency to match the stat block.  Returns the number of rows moved if
    asked.
    
Arguments:

    pStat - the STAT block to move to (implies a current position followed by a
        delta move).

    plDelta - Returns the number of rows actually moved.

Return Value:
    
    None.
    
--*/       
{
    DB_ERR  err;
    
    // First, go to the current positon in the STAT block.
    switch(pStat->CurrentRec) {
    case BOOKMARK_BEGINNING:
        // Go to the beginning of the table.
        ABSetIndexByHandle(pTHS, pStat, 0 );
        ABMove(pTHS, DB_MoveFirst, pStat->ContainerID, FALSE );
        break;
        
    case BOOKMARK_CURRENT:
        // Set to a fractional position
        ABSetIndexByHandle(pTHS, pStat, 0 );
        ABSetToElement(pTHS, pStat->NumPos, pStat->ContainerID, pIndexSize );
        break;
        
    case  BOOKMARK_END:
        // Move to the End.
        ABSetIndexByHandle(pTHS, pStat, 0 );
        ABMove(pTHS, DB_MoveLast, pStat->ContainerID, FALSE );
        ABMove(pTHS, 1, pStat->ContainerID, FALSE );
        break;
        
    default:
        // Move to a specific DNT.
        if(DBTryToFindDNT(pTHS->pDB, pStat->CurrentRec)) {
            pTHS->errCode = (ULONG)MAPI_E_NOT_FOUND;
            DsaExcept(DSA_EXCEPTION, 0,0);
        }
        else {
            wchar_t        wzDispName[CBMAX_DISPNAME];
            DWORD          cbDispName;

            // Read the Displayname, we might need it.
            DBGetSingleValue(pTHS->pDB, ATT_DISPLAY_NAME,
                             wzDispName, CBMAX_DISPNAME,&cbDispName);
            Assert(cbDispName < CBMAX_DISPNAME);
            
            // Flip the index to the correct address book container index.
            if(DB_ERR_NO_CURRENT_RECORD == ABSetIndexByHandle(pTHS, pStat, TRUE)) {
                // The row we found is not in the address book index, so seek to
                // the next object which IS in the index.
                
                ABSeek(pTHS, wzDispName, cbDispName, bAPPROX,
                       pStat->ContainerID, 0); 
            }
        }
        break;
    }
    
    if(!plDelta ) {
        // We don't need to return how far we actually moved, so do it the fast
        // way.
        ABMove(pTHS, pStat->Delta, pStat->ContainerID, TRUE );
    }
    else {
        // We need to remember how far we move.  Go slower.
        int i = 0;
        if(pStat->Delta >= 0) {
            // We are moving forward, or not at all
            if(!pTHS->fEOF ) {
                // And we are not already at the end.
                for(; i<pStat->Delta; i++) {
                    if(ABMove(pTHS, DB_MoveNext, pStat->ContainerID, FALSE)) {
                        // We moved off the end.  Count it.
                        i++;           
                        break;
                    }
                }
            }
        }
        else {
            // We are moving backward.
            while(!ABMove(pTHS, DB_MovePrevious, pStat->ContainerID, FALSE))
                if(--i <= pStat->Delta)
                    break;
        }
        // Save count of records moved
        *plDelta = i;
        
    }
    if(!pTHS->fEOF) {
        DBMakeCurrent (pTHS->pDB);
    }
}

DWORD
ABDNToDNT (
        THSTATE *pTHS,
        LPSTR pDN
        )
/*++
  
Routine Description:

    Given a string DN, find the object it refers to.  First, we try to seek if
    it is a DN from the MAPIDN index, if it isn't we try pull a GUID out of it,
    assuming it is an NT5 default MAPI DN.  Return the DNT we map it to, or 0 if
    we don't map to anything.
Arguments:

    pDN - the string DN to look up.  Note that we are assuming the DN to be one
          of the MAPI style DNs, not a real RFC1779 style

Return Value:
    
    The DNT of the object we are looking for, or 0 if the object is not found,
    or is deleted, or is a phantom.
    
--*/       
{
    PUCHAR      pTemp;
    DWORD       i, j;
    DSNAME      DN;
    DWORD       DNLen = 0;
    DWORD       X500AddrLen;
    WCHAR      *pX500Addr=NULL;
    BOOL        fDoFixup;
    LPSTR       pDNTemp = NULL;

    // if DN length is zero there is no point in continuing
    if (pDN) {
         DNLen = strlen(pDN);
    }
    if (!DNLen) {
        return 0;
    }

    // a preliminary, look for instances of // in the string and turn them into
    // /.  This is optimized to assume no such exist.
    fDoFixup = FALSE;
    for(i=0;i<(DNLen - 1);i++) {
        if(pDN[i] == '/' && pDN[i+1] == '/') {
            fDoFixup = TRUE;
            break;
        }
    }
    if(fDoFixup) {
        pDNTemp = THAllocEx(pTHS, DNLen);
        for(i=0, j=0; j < DNLen ; i++,j++) {
            pDNTemp[i] = pDN[j];
            // remember, pDN is null terminated, and DNLen doesn't include the
            // NULL. 
            if((pDN[j] == '/') && (pDN[j+1] == '/')) {
                j++;
            }
        }
        pDN = pDNTemp;
        DNLen = i;
    }

    // First, try to look this thing up in the MAPIDN index.
    if(!DBSetCurrentIndex(pTHS->pDB, Idx_MapiDN, NULL, FALSE)) {
        switch (ABSeek(pTHS, pDN, DNLen, bEXACT, 0,
                       ATT_LEGACY_EXCHANGE_DN)) { 
        case 0:
            // Yeah, it's ours and it's unique.
            if(pDNTemp) {
                THFreeEx(pTHS, pDNTemp);
            }
            return pTHS->pDB->DNT;
            break;
            
        case DB_ERR_ATTRIBUTE_EXISTS:
            // Hmm.  Not unique.
            if(pDNTemp) {
                THFreeEx(pTHS, pDNTemp);
            }
            return 0;
            break;
            
        default:
            // continue on to see if it's the other flavor of DN
            break;
        }
    }

    // It's not known to us by a MAPI DN.  See if it is known to us as an X500
    // proxy address.
    pX500Addr = THAllocEx(pTHS,(DNLen + 5) * sizeof(WCHAR));
    
    memcpy(pX500Addr, L"X500:", 5 * sizeof(WCHAR));
    X500AddrLen = MultiByteToWideChar(CP_TELETEX,
                                      0,
                                      pDN,
                                      DNLen,
                                      &pX500Addr[5],
                                      DNLen);
    Assert(X500AddrLen <= DNLen);
    X500AddrLen = (X500AddrLen + 5) * sizeof(WCHAR);
    
    if(!DBSetCurrentIndex(pTHS->pDB, Idx_Proxy, NULL, FALSE)) {
        switch (ABSeek(pTHS, pX500Addr, X500AddrLen, bEXACT, 0,
                       ATT_PROXY_ADDRESSES)) { 
        case 0:
            // Yeah, it's ours and it's unique.
            if(pDNTemp) {
                THFreeEx(pTHS, pDNTemp);
            }
            THFreeEx(pTHS,pX500Addr);
            return pTHS->pDB->DNT;
            break;
            
        case DB_ERR_ATTRIBUTE_EXISTS:
            // Hmm.  Not unique.
            if(pDNTemp) {
                THFreeEx(pTHS, pDNTemp);
            }
            THFreeEx(pTHS,pX500Addr);
            return 0;
            break;
            
        default:
            // continue on to see if it's the other flavor of DN
            break;
        }
    }
    //pX500Addr is not used any more
    THFreeEx(pTHS,pX500Addr);

    // OK, it's not known to us by MAPI DN.  See if it is known to us by an NT5
    // default MAPI DN.
    memset(&DN,0,sizeof(DN));
    DN.NameLen = 0;
    DN.structLen = DSNameSizeFromLen(0);
    if(DBGetGuidFromMAPIDN(pDN, &(DN.Guid))) {
        // Nope doesn't appear to be mine.
        if(pDNTemp) {
            THFreeEx(pTHS, pDNTemp);
        }
        return 0;
    }
    
    // String is well formed,  See if it's a real object.
    if(DBFindDSName(pTHS->pDB, &DN)) {
        // Nope.
        if(pDNTemp) {
            THFreeEx(pTHS, pDNTemp);
        }
        return 0;
    }
    // Yeah, it's ours.
    if(pDNTemp) {
        THFreeEx(pTHS, pDNTemp);
    }
    return pTHS->pDB->DNT;
}

ULONG
ABGetOneOffs (
        THSTATE *pTHS,
        NSPI_CONTEXT *pMyContext,
        PSTAT pStat,
        LPSTR ** papDispName,
        LPSTR ** papDN,
        LPSTR ** papAddrType,
        LPDWORD *paDNT
        )
/*++
  
Routine Description:

    Reads the attributes associated with a set of one-off templates for a
    specific template locale.
    
Arguments:

    pStat - Stat block to get code page and template locale from to look up
        template information.

    papDispName - returns an array of display names for templates.

    papDN - returns an array of string DNs for one-off templates.

    papAddrType - returns an array of address types for one-off templates.

    paDNT - returns an array of DNTs for one-off templates.

Return Value:
    
    The number of templates actually found.  All the arrays mentioned above are
    this size.
    
--*/       
{
    LPSTR        psz;
    ULONG        Count = 0;
    PDSNAME      pDN0 = NULL;
    PDSNAME      pDN1;
    PDSNAME      pDN2;
    SEARCHARG    SearchArg;
    SEARCHRES    *pSearchRes=NULL;
    ENTINFSEL    selection;
    ENTINFLIST   *pEntList=NULL;
    ATTR          Attr[3];
    WCHAR        wcNum[ 9];
    PUCHAR       *apRDN=NULL;
    DWORD        *aDNT=NULL;
    PUCHAR       *apAT=NULL;
    PUCHAR       *apDN=NULL;
    FILTER       TemplateFilter;
    ATTRTYP      classAddressTemplate;
    DWORD        used, Size;
    ULONG        cbDN1, cbDN2;
    
    *papDispName = *papDN = *papAddrType = NULL;
    *paDNT = NULL;


    // Find the template root and get it's name
    if((pMyContext->TemplateRoot == INVALIDDNT) ||
       (DBTryToFindDNT(pTHS->pDB, pMyContext->TemplateRoot)) ||
       (DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                    0, 0,
                    &Size, (PUCHAR *)&pDN0))) {
        // Huh?
        return 0;
    }
    
    // Allocate more than enough space for pDN1 and pDN2
    cbDN1 = pDN0->structLen + 128*sizeof(WCHAR);
    cbDN2 = pDN0->structLen + 128*sizeof(WCHAR);
    pDN1 = (PDSNAME)THAllocEx(pTHS, cbDN1);
    pDN2 = (PDSNAME)THAllocEx(pTHS, cbDN2);
    
    //
    // Build up DN of template location, which should be
    //       /cn=<display-type>  (template object)
    //      /cn=<locale-id>      (stringized hex number)
    //     /cn=Address-Templates
    //   <DN of the templates root>
    //

    AppendRDN(pDN0, pDN1, cbDN1,
              L"Address-Templates", 0,ATT_COMMON_NAME);

    
    _ultow(pStat->TemplateLocale, wcNum, 16);
    AppendRDN(pDN1, pDN2, cbDN2, wcNum, 0, ATT_COMMON_NAME);

    THFreeEx(pTHS, pDN0);
    THFreeEx(pTHS, pDN1);
    // pDN2 is now the name of a container which will hold all the one-off 
    // address templates for a particular locale.
    if (!DBFindDSName(pTHS->pDB, pDN2)) {
        // The DN we constructed actually refers to an object.
        ULONG   i;

        // OK, do a one level search, filter of objectclass=addresstemplate
        memset(&SearchArg, 0, sizeof(SearchArg));
        memset(&selection, 0, sizeof(selection));
        
        SearchArg.pObject = pDN2;
        SearchArg.choice = SE_CHOICE_IMMED_CHLDRN;
        InitCommarg(&SearchArg.CommArg);
        SearchArg.CommArg.Svccntl.fDontOptimizeSel = TRUE;
        SearchArg.pFilter = &TemplateFilter;
        SearchArg.pSelection = &selection;
        selection.attSel = EN_ATTSET_LIST;
        selection.infoTypes = EN_INFOTYPES_SHORTNAMES;
        selection.AttrTypBlock.attrCount = 3;
        selection.AttrTypBlock.pAttr = Attr;
        Attr[0].attrTyp = ATT_DISPLAY_NAME;
        Attr[0].AttrVal.valCount=0;
        Attr[0].AttrVal.pAVal=NULL;
        Attr[1].attrTyp = ATT_RDN;
        Attr[1].AttrVal.valCount=0;
        Attr[1].AttrVal.pAVal=NULL;
        Attr[2].attrTyp = ATT_ADDRESS_TYPE;
        Attr[2].AttrVal.valCount=0;
        Attr[2].AttrVal.pAVal=NULL;

        memset (&TemplateFilter, 0, sizeof (TemplateFilter));
        TemplateFilter.choice = FILTER_CHOICE_ITEM;
        TemplateFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
        TemplateFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CLASS;
        TemplateFilter.FilterTypes.Item.FilTypes.ava.Value.valLen =
            sizeof(DWORD);
        TemplateFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
            (PUCHAR) &classAddressTemplate; 
        classAddressTemplate = CLASS_ADDRESS_TEMPLATE;
        
        SearchArg.pSelectionRange = NULL;
        SearchArg.bOneNC =  FALSE;
        
        pSearchRes = (SEARCHRES *)THAllocEx(pTHS, sizeof(SEARCHRES));
        SearchBody(pTHS, &SearchArg, pSearchRes, SEARCH_UNSECURE_SELECT);
        if(pTHS->errCode) {
            THFreeEx(pTHS, pDN2);
            return 0;
        }

        if(!pSearchRes->count) {
            // No templates
            ABFreeSearchRes(pSearchRes);
            THFreeEx(pTHS, pDN2);
            return 0;
        }
        Count = pSearchRes->count;
        
        // Allocate the space we will need to store the addressing template
        // info we are about to read.
        apRDN = THAllocEx(pTHS, 3*Count*sizeof(LPSTR) + Count*sizeof(DWORD));
        apDN = &apRDN[ Count];
        apAT = &apDN[ Count];
        aDNT = (LPDWORD)&apAT[ Count];
        
        // Walk through the results.
        pEntList = &pSearchRes->FirstEntInf;
        for(Count = 0, i=0; i < pSearchRes->count;i++) {
            DWORD fUsedDefChar;
            ATTR *pAttr = pEntList->Entinf.AttrBlock.pAttr;
            
            Assert(pEntList->Entinf.pName->NameLen == 0);
            Assert(pEntList->Entinf.pName->structLen >=
                   (DSNameSizeFromLen(0) + sizeof(DWORD)));; 
            

            // Verify what we got back.
            if(
               // First, did we get any attributes?
               pEntList->Entinf.AttrBlock.attrCount >= 2 &&
               // Now, was the first one the Display name?
               pAttr[0].attrTyp == ATT_DISPLAY_NAME &&
               // And did it have ONE value?
               pAttr[0].AttrVal.valCount == 1 &&
               // Was the second one the RDN?
               pAttr[1].attrTyp == ATT_RDN &&
               // And did it have ONE value?
               pAttr[1].AttrVal.valCount == 1 
               ) {
                // OK, we have the minimum we need.

                // Get the dnt
                aDNT[Count] = DNTFromShortDSName(pEntList->Entinf.pName);
                
                // We read a wide display name.  Now, translate it to string 8
                apRDN[Count] = String8FromUnicodeString(
                        TRUE,
                        pStat->CodePage,
                        (wchar_t *)pAttr[0].AttrVal.pAVal[0].pVal,
                        pAttr[0].AttrVal.pAVal[0].valLen/sizeof(wchar_t),
                        NULL,
                        &fUsedDefChar);

                // Now, get the AddrType if there, the RDN otherwise.
                if(pEntList->Entinf.AttrBlock.attrCount >= 3 &&
                   
                   pAttr[2].attrTyp == ATT_ADDRESS_TYPE && 
                   
                   pEntList->Entinf.AttrBlock.pAttr[2].AttrVal.valCount == 1) {
                    // We read an 8 bit attr type.  However, it's not null
                    // terminated.  Make a buffer and copy.
                    apAT[Count] = THAllocEx(pTHS,
                                            pAttr[2].AttrVal.pAVal[0].valLen+1);
                    memcpy(apAT[Count],
                           pAttr[2].AttrVal.pAVal[0].pVal,
                           pAttr[2].AttrVal.pAVal[0].valLen);
                }
                else {
                    // No attrtype name to use. Use the RDN otherwise
                    apAT[Count] = String8FromUnicodeString(
                            TRUE,
                            pStat->CodePage,
                            (wchar_t *)pAttr[1].AttrVal.pAVal[0].pVal,
                            pAttr[1].AttrVal.pAVal[0].valLen/sizeof(wchar_t),
                            NULL,
                            &fUsedDefChar);
                }
                
                // DN.  Use a default version.
                apDN[Count] = THAllocEx(pTHS, 80);
                used = DBMapiNameFromGuid_A(apDN[Count],
                                            80,
                                            &pEntList->Entinf.pName->Guid,
                                            &gNullUuid,
                                            &Size); 

                if(used != Size) {
                    // We had too small a buffer
                    apDN[Count] = THReAllocEx(pTHS, apDN[Count], Size);
                    DBMapiNameFromGuid_A(apDN[Count],
                                         Size,
                                         &pEntList->Entinf.pName->Guid,
                                         &gNullUuid,
                                         &Size);
                }
                
                Count++;
            }

                
            pEntList = pEntList->pNextEntInf;
                
        }
        
        
        // Set up the return values.
        *papDispName = apRDN;
        *papDN = apDN;
        *papAddrType = apAT;
        *paDNT = aDNT;
    }
    
    ABFreeSearchRes(pSearchRes);

    THFreeEx(pTHS, pDN2);
    return Count;
}

void
ABMakePermEID (
        THSTATE *pTHS,
        LPUSR_PERMID *ppEid,
        LPDWORD pCb,
        ULONG ulType,
        LPSTR pDN 
        )
/*++
  
Routine Description:

    Creates a long term entry id based on the ulType and string DN given.
    
Arguments:

    ppEID - the entry id created.

    ulType - the display type of the object the entry id refers to.

    pDN - the string DN the object the entry id refers to.

Return Value:
    
    Returns nothing.
    
--*/       
{
    ULONG           cb;
    LPUSR_PERMID    pEid;

    // Allocate room for the entry id.
    cb = strlen(pDN) + CBUSR_PERMID + 1;
    pEid = (LPUSR_PERMID) THAllocEx(pTHS, cb);

    // Set the appropriate fields.  The flags are all 0.
    pEid->abFlags[0]=pEid->abFlags[1] = pEid->abFlags[2] = pEid->abFlags[3] = 0;

    // Copy EMS address book guid into the EID.
    memcpy(&pEid->muid, &muidEMSAB, sizeof (UUID));

    // Set the version.
    pEid->ulVersion = EMS_VERSION;

    // Set the type.
    pEid->ulType = ulType;

    // Copy the string to the end of the entry id.
    lstrcpy((LPSTR)pEid->szAddr, pDN);

    *ppEid = pEid;

    *pCb = cb;
    return;
}

DWORD
ABDispTypeFromClass (
        DWORD dwClass
        )
/*++
  
Routine Description:

    Map from a DS internal class to a MAPI display type.
    
Arguments:

    dwClass - internal DS class.

Return Value:
    
    Returns the appropriate MAPI display type.
    
--*/       
{
    DWORD   dwType;
    CLASSCACHE *pCC;
    
    do {
        switch( dwClass ) {
        case CLASS_USER:
            dwType = DT_MAILUSER;
            break;
        case CLASS_GROUP:
        case CLASS_GROUP_OF_NAMES:
            dwType = DT_DISTLIST;
            break;
        case CLASS_ORGANIZATIONAL_UNIT:
            dwType = DT_ORGANIZATION;
            break;
        case CLASS_PUBLIC_FOLDER:
            dwType = DT_FORUM;
            break;
        case CLASS_REMOTE_ADDRESS:
        case CLASS_CONTACT:
            dwType = DT_REMOTE_MAILUSER;
            break;

        default:
            // What's this?  Beats me, make it default
            dwType = DT_AGENT;
            // We might be a subclass of something we recognize, so try again
            // with my immediate superclass.
            pCC = SCGetClassById(pTHStls, dwClass);
            dwClass = pCC ? pCC->MySubClass : CLASS_TOP;
            break;
        }
    } while ((dwType == DT_AGENT) && (dwClass != CLASS_TOP));
    return dwType;
}

DWORD
ABObjTypeFromClass (
        DWORD dwClass
        )
/*++
  
Routine Description:

    Map from a DS internal class to a MAPI object type.
    
Arguments:

    dwClass - internal DS class.

Return Value:
    
    Returns the appropriate MAPI object type.
    
--*/       
{
    DWORD   dwType;

    switch( dwClass ) {
    case CLASS_USER:
    case CLASS_REMOTE_ADDRESS:
    case CLASS_CONTACT:
        dwType = MAPI_MAILUSER;
        break;
    case CLASS_GROUP:
    case CLASS_GROUP_OF_NAMES:
        dwType = MAPI_DISTLIST;
        break;
    case CLASS_PUBLIC_FOLDER:
        dwType = MAPI_FOLDER;
        break;
    default:
	// Assume the default is caused by getprops on some random object in the
        // DIT.  This is done as though it were a MAILUSER. 
        dwType = MAPI_MAILUSER;
        break;
    }
    return dwType;
}

DWORD
ABObjTypeFromDispType (
        DWORD dwDispType
        )
/*++
  
Routine Description:

    Map from a MAPI display type to a MAPI object type.
    
Arguments:

    dwDispType - MAPI display type.

Return Value:
    
    Returns the appropriate MAPI object type.
    
--*/       
{
    DWORD   dwType;

    switch( dwDispType ) {
    case DT_MAILUSER:
    case DT_REMOTE_MAILUSER:
        dwType = MAPI_MAILUSER;
        break;
    case DT_DISTLIST:
        dwType = MAPI_DISTLIST;
        break;
    case DT_FORUM:
        dwType = MAPI_FOLDER;
        break;
    default:
	// Assume the default is caused by getprops on some random object in the
        // DIT.  This is done as though it were a MAILUSER. 
        dwType = MAPI_MAILUSER;
        break;
    }
    return dwType;
}

DWORD
ABClassFromObjType (
        DWORD dwType
        )
/*++
  
Routine Description:

    Map from a MAPI object type to a DS internal class.

    In the great bye-and-bye, we should convert this to using the class
    pointer. 

Arguments:

    dwType - the MAPI object type.

Return Value:
    
    Returns the appropriate DS internal class.
    
--*/       
{
    DWORD   dwClass;
    
    switch( dwType ) {
    case MAPI_MAILUSER:
        dwClass = CLASS_USER;
        break;
    case MAPI_DISTLIST:
        dwClass = CLASS_GROUP;
        break;
    case MAPI_FOLDER:
        dwClass = CLASS_PUBLIC_FOLDER;
        break;
    default:
        // Shouldn't really have anything else
        dwClass = CLASS_REMOTE_ADDRESS; 
        break;
    }
    return dwClass;
}

DWORD
ABClassFromDispType (
        DWORD dwType
        )
/*++
  
Routine Description:

    Map from a MAPI display type to a DS internal class.

    In the great bye-and-bye, we should convert this to using the class
    pointer. 

Arguments:

    dwType - the MAPI display type.

Return Value:
    
    Returns the appropriate DS internal class.
    
--*/       
{
    DWORD   dwClass;

    switch( dwType ) {
    case DT_MAILUSER:
        dwClass = CLASS_USER;
        break;
    case DT_DISTLIST:
        dwClass = CLASS_GROUP;
        break;
    case DT_ORGANIZATION:
        dwClass = CLASS_ORGANIZATIONAL_UNIT;
        break;
    case DT_FORUM:
        dwClass = CLASS_PUBLIC_FOLDER;
        break;
    case DT_REMOTE_MAILUSER:
        dwClass = CLASS_REMOTE_ADDRESS;
        break;
    default:
        // should never hit this one
        dwClass = CLASS_COMPUTER;
        break;
    }
    return dwClass;
}

ULONG
ABMapiSyntaxFromDSASyntax (
        DWORD dwFlags,
        ULONG dsSyntax,
        ULONG ulLinkID,
        DWORD dwSpecifiedSyntax
        )
/*++
  
Routine Description:

    Map from a DSA syntax to a MAPI syntax, taking into account whether the
    object is a link/backlink, a fake link, and whether or not the callee wants
    objects viewed as multi-valued strings.

Arguments:

    dsSyntax = the DSA syntax to convert

    ulLinkID - the link id of the attribute we are converting.  0 if it is not a
    link.

    dwSpecifiedSyntax - PT_STRING8 if the callee wants all string valued and
    object valued attributes viewed as (potentially multi) string8 valued
    attributes.  PT_UNICODE if the want to see things as unicode strings.
    Neither if they want whatever our most native format is.

Return Value:
    
    Returns the appropriate MAPI syntax.
    
--*/       
{
    if((ulLinkID)                             && // Its a link/backlink     
       ((dsSyntax == SYNTAX_DISTNAME_TYPE)        ||
        (dsSyntax == SYNTAX_DISTNAME_BINARY_TYPE) ||
	(dsSyntax == SYNTAX_DISTNAME_STRING_TYPE))   &&   // It's not a fake         
       (dwSpecifiedSyntax != PT_STRING8)      && // They don't want strings 
       (dwSpecifiedSyntax != PT_UNICODE)        ) {

	// This is a link/backlink attribute,
	//           AND
	// it is not a fake link attribute (one where we use the link table
	// to store many strings to work around Database limit of the number of
	// values on a multi-value column),
	//           AND
	// they are not asking for objects in terms of strings (all true
	// links can be viewed as mv text columns where we textize the dn
	// specified in the link.)
	//           THEREFORE
	// Tell them it is an object.
	return PT_OBJECT;
    }
    
    switch(dsSyntax) {
    case SYNTAX_DISTNAME_TYPE:
        // Return DNs as their string-ized equivalent
        return PT_STRING8;
        break;
        
    case SYNTAX_DISTNAME_STRING_TYPE:
    case SYNTAX_DISTNAME_BINARY_TYPE:
        // These will be specially processed binary, but we aren't
        // doing the special handling yet, so mark them as unsupported
        return PT_NULL;
        break;
        
    case SYNTAX_CASE_STRING_TYPE:
    case SYNTAX_NOCASE_STRING_TYPE:
    case SYNTAX_PRINT_CASE_STRING_TYPE:
    case SYNTAX_NUMERIC_STRING_TYPE:
        return  PT_STRING8;
        break;
        
    case SYNTAX_BOOLEAN_TYPE:
        return PT_BOOLEAN;
        break;
        
    case SYNTAX_I8_TYPE:
        // Our RPC interface doesn't handle these.  Deal with them as integers
    case SYNTAX_INTEGER_TYPE:
        return PT_LONG;
        break;
         
    case SYNTAX_SID_TYPE:
    case SYNTAX_OCTET_STRING_TYPE:
        return PT_BINARY;
        break;
        
    case SYNTAX_TIME_TYPE:
        // We don't handle APPTIME, it's all SYSTIME
        return PT_SYSTIME;
        break;
        
    case SYNTAX_UNICODE_TYPE:
        return PT_UNICODE;
        break;
        
    case SYNTAX_ADDRESS_TYPE:
    case SYNTAX_UNDEFINED_TYPE:
    case SYNTAX_OBJECT_ID_TYPE:
    case SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE:
        // We don't expect to ever handle these.
        return PT_NULL;
        break;
        
    default:
        // We don't handle these either.  What are they anyway?
        Assert(!"DS syntax to MAPI syntax found unrecognized DS syntax\n");
        return PT_NULL;
        break;
    }
}




void __fastcall
ABAddResultToContainerCache (
    NSPI_CONTEXT *pMyContext,        
    STAT * pStat,
    BOOL checkVal
    )

/*++

Routine Description:

    Adds the container specifies in pstat->ContainerID
    to the ContainerCache stored in the NSPI_CONTEXT using checkVal 

Arguments:
    
    pStat - a stat block specifying a container to look up.
    pMyContext - the context this call is in
    checkVal - TRUE if the user has permissions to read this container, FALSE otherwise

Return Values:

    None.

--*/
{
    if(pMyContext->CacheIndex < MAPI_SEC_CHECK_CACHE_MAX) {
        pMyContext->ContainerCache[pMyContext->CacheIndex].checkVal = checkVal;
        pMyContext->ContainerCache[pMyContext->CacheIndex].DNT = pStat->ContainerID;
        pMyContext->CacheIndex += 1;
    }
}


/*++

Routine Description:

    Find the container object specified in the stat and evaluate for
    RIGHT_DS_OPEN_ADDRESS_BOOK rights.  If the right is not granted, 
    set the container to INVALIDDNT, which is an invalid container 
    and will never have any children.  Bypass the check if the container
    specified is alread 1 or 0 (the GAL)

Arguments:
    
    pStat - a stat block specifying a container to look up.

Return Values:

    None.

--*/
void
ABCheckContainerRights (
        THSTATE *pTHS,
        NSPI_CONTEXT *pMyContext,        
        STAT * pStat,
        PINDEXSIZE pIndexSize
        )
{
    CLASSCACHE          *pCC=NULL;
    PSECURITY_DESCRIPTOR pNTSD=NULL;
    PDSNAME              pName=NULL;
    ATTCACHE            *pAC[2];
    DWORD                cOutAtts;
    ATTR                *pAttr=NULL;
    DWORD                i;
    ATTRTYP              classId;
    ATTRTYP              classTypeId;
    ATTCACHE            *pACmember;
    ATTCACHE            *rgpAC[1];
    DWORD               cInAtts;
    ULONG                ulLen;


    pIndexSize->TotalCount = GetIndexSize(pTHS, NOTOBJECTTAG);
    
    switch(pStat->hIndex) {
    case H_DISPLAYNAME_INDEX:
        // Is this over the GAL?
        if(!pStat->ContainerID) {
            // Yes, find the DNT of the real object which is the GAL.
            pStat->ContainerID = pMyContext->GAL;
        }
        break;
        
    case H_PROXY_INDEX:
        // The proxy index is over the entire DB, so if a container is
        // specified, error out.  No security check is done here because this
        // translates almost directly to a SearchBody (which applies security).
        if(pStat->ContainerID) {        
            R_Except("Unsupported index", pStat->hIndex);
        }
        return;
        break;
        
    case H_READ_TABLE_INDEX:
    case H_WRITE_TABLE_INDEX:
        // This means they are going to read a property of an object and build a
        // table. The code that does this checks security to see that the object
        // is visible and that the property is visible.  No security check is
        // needed here.
        return;
        break;
        
    default:
        R_Except("Unsupported index", pStat->hIndex);
        break;
    }
    

    // Assume container is empty until we find out otherwise.
    pIndexSize->ContainerID = pStat->ContainerID;
    pIndexSize->ContainerCount = 0;
    
    // look up the container object.
    if(DBTryToFindDNT(pTHS->pDB, pStat->ContainerID)) {
        // The container couldn't be found, hence it is empty.
        return;
    }
    
    
    if((!(0xFF & ABGetDword(pTHS,FALSE,FIXED_ATT_OBJ))) ||
       (ABGetDword(pTHS,FALSE, ATT_IS_DELETED))) {
        // This is not a good object.
        pStat->ContainerID = INVALIDDNT;
        return;
    }

    // See if we have the answer cached
    
    if((DBTime() - pMyContext->CacheTime) >  MAPI_SEC_CHECK_CACHE_LIFETIME)  {
        // Doesn't matter, the cache is stale.
        memset(&(pMyContext->ContainerCache),
               0,
               sizeof(pMyContext->ContainerCache));
        pMyContext->CacheTime = DBTime();
        pMyContext->CacheIndex = 0;
    }
    else {
        // Cache is not stale.  See if we have an answer
        for(i=0 ;i < pMyContext->CacheIndex; i++) {
            if(pMyContext->ContainerCache[i].DNT == pStat->ContainerID) {
                // Found it
                if(pMyContext->ContainerCache[i].checkVal) {
                    // Granted
                    pIndexSize->ContainerCount =
                        GetIndexSize(pTHS, pStat->ContainerID);
                    return;
                }
                else {
                    // Denied
                    pStat->ContainerID = INVALIDDNT;
                    return;
                }
            }
        }
    }

    // The answer is not cached.
    pAC[0] = SCGetAttById(pTHS, ATT_OBJECT_CLASS);
    pAC[1] = SCGetAttById(pTHS, ATT_OBJ_DIST_NAME);
    
    DBGetMultipleAtts(pTHS->pDB,
                      2,
                      pAC,
                      NULL,
                      NULL,
                      &cOutAtts,
                      &pAttr,
                      (DBGETMULTIPLEATTS_fGETVALS |
                       DBGETMULTIPLEATTS_fSHORTNAMES), 
                      0);
    
    if(cOutAtts != 2) {
        // The container didn't have the three things it needed.  Don't grant
        // access, and don't cache this answer.
        pStat->ContainerID = INVALIDDNT;
        return;
    }

    if (DBGetAttVal(pTHS->pDB, 1, ATT_NT_SECURITY_DESCRIPTOR,
                    0, 0, &ulLen, (PUCHAR *)&pNTSD)) {
        // Every object should have an SD.
        Assert(!DBCheckObj(pTHS->pDB));

        // Don't grant access, and don't cache this answer.
        pStat->ContainerID = INVALIDDNT;
        return;
    }
    

    classId = *((ATTRTYP *)pAttr[0].AttrVal.pAVal->pVal);
    classTypeId = 0;

    pCC = SCGetClassById(pTHS, classId);

    // see if it is an address book container or a subclass of
    if (classId == CLASS_ADDRESS_BOOK_CONTAINER) {
        classTypeId = CLASS_ADDRESS_BOOK_CONTAINER;
    }
    else {
        for (i=0; i<pCC->SubClassCount; i++){
            if (CLASS_ADDRESS_BOOK_CONTAINER == pCC->pSubClassOf[i]) {
                classTypeId = CLASS_ADDRESS_BOOK_CONTAINER;
                break;
            }
        }
    }

    // see if it is a group or a subclass of
    if (classTypeId == 0) {
        if (classId == CLASS_GROUP) {
            classTypeId = CLASS_GROUP;
        }
        else {
            for (i=0; i<pCC->SubClassCount; i++){
                if (CLASS_GROUP == pCC->pSubClassOf[i]) {
                    classTypeId = CLASS_GROUP;
                    break;
                }
            }
        }
    }


    if(classTypeId == 0 ) { 
        // Add to the cache
        ABAddResultToContainerCache (pMyContext, pStat, FALSE);
        // Wrong object class. Don't use this container.
        pStat->ContainerID = INVALIDDNT;
        return;
    }
    

    pName = (DSNAME *)pAttr[1].AttrVal.pAVal->pVal;

    if (classTypeId == CLASS_ADDRESS_BOOK_CONTAINER) {
        if (IsControlAccessGranted(pNTSD,
                                   pName,
                                   pCC,
                                   RIGHT_DS_OPEN_ADDRESS_BOOK,
                                   FALSE)) {
            // Add to the cache
            ABAddResultToContainerCache (pMyContext, pStat, TRUE);
        
            // OK, we have found a real ab container that corresponds to this
            // request.  Find out how big it is.
            pIndexSize->ContainerCount = GetIndexSize(pTHS, pStat->ContainerID);
        
            return;
        }
    }
    // else CLASS_GROUP
    else {
        
        pACmember = SCGetAttById(pTHS, ATT_MEMBER);
        
        if(!pACmember) {
            pStat->ContainerID = INVALIDDNT;
            return;
        }
        
        cInAtts = 1;
        rgpAC[0] = pACmember;

        CheckReadSecurity(pTHS,
                          0,
                          pNTSD,
                          pName,
                          &cInAtts,
                          pCC,
                          rgpAC);

        if(*rgpAC) {
            // Add to the cache
            ABAddResultToContainerCache (pMyContext, pStat, TRUE);
            
            // OK, we have found a real ab container that corresponds to this
            // request.  Find out how big it is.
            pIndexSize->ContainerCount = GetIndexSize(pTHS, pStat->ContainerID);

            return;
        }
    }
    
    // Add to the cache
    ABAddResultToContainerCache (pMyContext, pStat, FALSE);
    
    pStat->ContainerID = INVALIDDNT;

    return;
}

BOOL
abCheckObjRights (
        THSTATE *pTHS
        )
{
    DWORD fIsObject;


    fIsObject = 0xFF & ABGetDword(pTHS,FALSE,FIXED_ATT_OBJ);
    /* obj is really a byte, so we mask with 0xFF to get
     * correct results
     */
    
    if((!fIsObject) ||
       // It's a phantom 
       (ABGetDword(pTHS,FALSE, ATT_IS_DELETED)) ||
       // Not a phantom, but is deleted. 
       (!IsObjVisibleBySecurity(pTHS, TRUE))) {
        // Not a phantom, not deleted, but we can't see it, so it is
        // effectively a phantom. 
        return FALSE;
    }
    else {
        return TRUE;
    }
}


BOOL
abCheckReadRights(
        THSTATE *pTHS,
        PSECURITY_DESCRIPTOR pSec,
        ATTRTYP AttId
        )
{
    DSNAME     *pName=NULL;
    DWORD       cb;
    CLASSCACHE *pCC;
    ATTCACHE    *pAC;
    ATTCACHE    *rgpAC[1];
    DWORD       cInAtts;
    ATTRTYP     classid;
    PSECURITY_DESCRIPTOR pFreeVal=NULL;
    
    // Check for read privilege on the attribute requested.
    pAC = SCGetAttById(pTHS, AttId);
    if(!pAC) {
        return FALSE;
    }

    if(!pSec) {
        // 0) The caller didn't know the security descriptor.  Get it.
        if (DBGetAttVal(pTHS->pDB, 1, ATT_NT_SECURITY_DESCRIPTOR,
                        0, 0, &cb, (PUCHAR *)&pSec)) {
            // Every object should have an SD.
            Assert(!DBCheckObj(pTHS->pDB));
            pSec = NULL;
        }
        pFreeVal = pSec;
    }
    // Have to read a number of things.
    // 1) The name.
    if (DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                    0, 0, &cb, (PUCHAR *)&pName)) {
        LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_CANT_RETRIEVE_DN,
                 szInsertSz(""),
                 NULL,
                 NULL);
        if(pFreeVal) {
            THFreeEx(pTHS, pFreeVal);
        }
        return FALSE;
    }
    
    // 2) the class
    if(DBGetSingleValue(pTHS->pDB,
                        ATT_OBJECT_CLASS,
                        &classid, sizeof(classid),
                        NULL) ||
       !(pCC = SCGetClassById(pTHS, classid))) {
        if(pFreeVal) {
            THFreeEx(pTHS, pFreeVal);
        }
        THFreeEx(pTHS, pName);
        return FALSE;
    }
    
    cInAtts = 1;
    rgpAC[0] = pAC;
    
    CheckReadSecurity(pTHS,
                      0,
                      pSec,
                      pName,
                      &cInAtts,
                      pCC,
                      rgpAC);
    
    if(pFreeVal) {
        THFreeEx(pTHS, pFreeVal);
    }
    THFreeEx(pTHS, pName);

    if(*rgpAC) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}
    
BOOL
ABDispTypeAndStringDNFromDSName (
        DSNAME *pDN,
        PUCHAR *ppChar,
        DWORD *pDispType)
/*++
  Given a dsname which we expect to be in mapi format, return the string dn and
  the display type.  Remember, MAPI format is two string characters encoding the
  display type as a hex number, followed by the MAPI string DN.
--*/       
{
    UCHAR  acTmp[3];
    PUCHAR ptr;
    PUCHAR pChar = MakeDNPrintable(pDN);

    // In a mapi dn, the first two characters encode the display type.
    if(!pChar) {
        *ppChar = NULL;
        return FALSE;
    }
    
    if(!pChar[0] || !pChar[1]) {
        // badly formed
        *ppChar = NULL;
        THFreeEx (pTHStls, pChar);
        return FALSE;
    }

    ptr = pChar;
    
    // Get the display type from those two characters.
    acTmp[0] = (CHAR)tolower(*pChar++);      
    acTmp[1] = (CHAR)tolower(*pChar++);
    acTmp[2] = 0;
    if(isxdigit(acTmp[0]) && isxdigit(acTmp[1])) {
        *pDispType = strtol(acTmp, NULL, 16);
    }
    else {
        // Weird encoding.  Call it an agent 
        *pDispType = DT_AGENT;
    }

    *ppChar = ptr;

    while (*pChar) {
        *ptr++ = *pChar++;
    }
    *ptr='\0';
    
    // We better have a mapi style name here.
    Assert(*(*ppChar) == '/');

    return TRUE;
}

void
ABFreeSearchRes (
        SEARCHRES *pSearchRes
        )
{
    DWORD        i,j,k;
    ENTINFLIST  *pEntList=NULL, *pTemp;
    ATTR        *pAttr=NULL;
    ATTRVAL     *pAVal=NULL;
    THSTATE     *pTHS;
    
    if(!pSearchRes) {
        return;
    }

    pTHS = pTHStls;

    // We don't actually free most of the search result.
    pEntList = &pSearchRes->FirstEntInf;
    
    for(i=0;i < pSearchRes->count;i++) {
        // Free the values in the EntInf.
        THFreeEx(pTHS, pEntList->Entinf.pName);
        
        pAttr = pEntList->Entinf.AttrBlock.pAttr;
        for(j=0;j<pEntList->Entinf.AttrBlock.attrCount;j++) {
            pAVal = pAttr->AttrVal.pAVal;
            for(k=0;k<pAttr->AttrVal.valCount;k++) {
                THFreeEx(pTHS, pAVal->pVal);
                pAVal++;
            }
            THFreeEx(pTHS, pAttr->AttrVal.pAVal);
            pAttr++;
        }
        THFreeEx (pTHS, pEntList->Entinf.AttrBlock.pAttr);
        
        // hold a back pointer
        pTemp = pEntList;
        
        // step forward
        pEntList = pEntList->pNextEntInf;
        
        // free the back pointer.
        if(i) {
            // But, dont free the first one.
            THFreeEx(pTHS, pTemp);
        }
    }
    
    THFreeEx(pTHS, pSearchRes);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\nspis\nspi_server.c ===
#include <NTDSpch.h>
#pragma  hdrstop
#include <nspi_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\nspis\details.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       details.c
//
//--------------------------------------------------------------------------

/*
 *  MIR Name Service Provider Details
 */
#include <NTDSpch.h>
#pragma  hdrstop

#include <ntdsctr.h>                   // perfmon hooks

// Core headers.
#include <ntdsa.h>                      // Core data types 
#include <scache.h>                     // Schema cache code
#include <dbglobal.h>                   // DBLayer header.
#include <mdglobal.h>                   // THSTATE definition
#include <mdlocal.h>                    // THSTATE definition
#include <dsatools.h>                   // Memory, etc.

// Logging headers.
#include <mdcodes.h>                    // Only needed for dsevent.h
#include <dsevent.h>                    // Only needed for LogUnhandledError

// Assorted DSA headers.
#include <anchor.h>                     
#include <objids.h>                     // need ATT_* consts
#include <dsexcept.h>
#include <debug.h>                      // Assert
#include <permit.h>
#include <dsutil.h>

// Assorted MAPI headers.
#include <mapidefs.h>
#include <mapitags.h>
#include <mapicode.h>
#include <msdstag.h>

// Nspi interface headers.
#include "nspi.h"
#include <nsp_both.h>
#include <_entryid.h>
#include <abserv.h>                     // Useful routines for nsp

#include <fileno.h>
#define  FILENO FILENO_DETAILS

/*****************************************\
 *        Global Data -- Constants       *
 \*****************************************/

/*
 *  Static properties
 */
#define NUM_DEFAULT_PROPS 11
SPropTagArray_r DefPropsU[] =
{
    NUM_DEFAULT_PROPS,
    PR_OBJECT_TYPE,
    PR_ENTRYID,
    PR_SEARCH_KEY,
    PR_RECORD_KEY,
    PR_ADDRTYPE_W,
    PR_EMAIL_ADDRESS_W,
    PR_DISPLAY_TYPE,
    PR_TEMPLATEID,
    PR_TRANSMITABLE_DISPLAY_NAME_W,
    PR_DISPLAY_NAME_W,
    PR_MAPPING_SIGNATURE
};

SPropTagArray_r DefPropsA[] =
{
    NUM_DEFAULT_PROPS,
    PR_OBJECT_TYPE,
    PR_ENTRYID,
    PR_SEARCH_KEY,
    PR_RECORD_KEY,
    PR_ADDRTYPE_A,
    PR_EMAIL_ADDRESS_A,
    PR_DISPLAY_TYPE,
    PR_TEMPLATEID,
    PR_TRANSMITABLE_DISPLAY_NAME_A,
    PR_DISPLAY_NAME_A,
    PR_MAPPING_SIGNATURE
};

#define NUM_OTHER_CONSTRUCTED_PROPS 2
SPropTagArray_r OtherConstructedPropsU[] =
{
    NUM_OTHER_CONSTRUCTED_PROPS,
    PR_EMS_AB_DISPLAY_NAME_PRINTABLE_W,
    PR_EMS_AB_OBJ_DIST_NAME_W
};
SPropTagArray_r OtherConstructedPropsA[] =
{
    NUM_OTHER_CONSTRUCTED_PROPS,
    PR_EMS_AB_DISPLAY_NAME_PRINTABLE_A,
    PR_EMS_AB_OBJ_DIST_NAME_A
};

/************ Internal Functions ****************/




/******************** External Entry Points *****************/

/******************** External Entry Points *****************/


/*****************************************************************************
*   Get Property List
*
*   if fSkipObj, then put no things of type PT_OBJECT in the proplist.
*
******************************************************************************/
SCODE
ABGetPropList_local (
        THSTATE *pTHS,
        DWORD dwFlags,
        DWORD dwEph,
        ULONG CodePage,
        LPLPSPropTagArray_r ppPropTags)
{
    UINT        i,j;
    DWORD       mapiSyn=0;
    LPSPropTagArray_r tempPropTags=NULL;
    DWORD       fDistList;
    ULONG ulLen;
    PSECURITY_DESCRIPTOR pSec=NULL;
    ENTINF               entry;
    ENTINFSEL            selection;
    ATTRTYP              ObjClass;
    
    memset(&entry, 0, sizeof(entry));
    memset(&selection, 0, sizeof(selection));
    selection.attSel = EN_ATTSET_ALL;
    selection.infoTypes = EN_INFOTYPES_TYPES_ONLY;
    
    
    /* go to the right object */
    if(DBTryToFindDNT(pTHS->pDB, dwEph)) {
        // Object isn't there.
        return MAPI_E_CALL_FAILED;
    }
        
    /* First, find out if I'm a DL. */
    if(DBGetSingleValue(pTHS->pDB, ATT_OBJECT_CLASS, &ObjClass,
                        sizeof(ObjClass), NULL)) {
        return MAPI_E_CALL_FAILED;
    }
    
    if(ABObjTypeFromClass(ObjClass) != MAPI_DISTLIST)
        fDistList = FALSE;
    else
        fDistList = TRUE;
    
    // Now, query the database for all attributes on this object,
    // gettinf types only, using ENTINF, which applies security.
    
    // First, get the security descriptor for this object.
    if (DBGetAttVal(pTHS->pDB, 1, ATT_NT_SECURITY_DESCRIPTOR,
                    0, 0,
                    &ulLen, (PUCHAR *)&pSec)) {
        // Every object should have an SD.
        Assert(!DBCheckObj(pTHS->pDB));
        ulLen = 0;
        pSec = NULL;
    }
    
    if (GetEntInf(pTHS->pDB,
                  &selection,
                  NULL,
                  &entry,
                  NULL,
                  0,
                  pSec,
                  GETENTINF_FLAG_DONT_OPTIMIZE,        // flags
                  NULL,
                  NULL)) {
        return MAPI_E_CALL_FAILED;
    }


    // Now go through the returned types building the PropTagArray.
    tempPropTags = (LPSPropTagArray_r)THAllocEx(pTHS, CbNewSPropTagArray(
                                              NUM_DEFAULT_PROPS +
					      NUM_OTHER_CONSTRUCTED_PROPS +
					      entry.AttrBlock.attrCount + 1));
    if( CodePage == CP_WINUNICODE) { //check for Unicodeness here
        memcpy( (tempPropTags)->aulPropTag,
                DefPropsU->aulPropTag,
                NUM_DEFAULT_PROPS * sizeof(ULONG));
        memcpy( &(tempPropTags)->aulPropTag[NUM_DEFAULT_PROPS],
                OtherConstructedPropsU->aulPropTag,
                NUM_OTHER_CONSTRUCTED_PROPS * sizeof(ULONG));
				
    } else {
        memcpy( ((tempPropTags)->aulPropTag),
                DefPropsA->aulPropTag,
                NUM_DEFAULT_PROPS * sizeof(ULONG));
        memcpy( &(tempPropTags)->aulPropTag[NUM_DEFAULT_PROPS],
                OtherConstructedPropsA->aulPropTag,
                NUM_OTHER_CONSTRUCTED_PROPS * sizeof(ULONG));
    }

    
    for( j = NUM_DEFAULT_PROPS + NUM_OTHER_CONSTRUCTED_PROPS, i = 0;
        i < entry.AttrBlock.attrCount; i++) {
        
	int k;
        ATTCACHE *pAC = NULL;

        pAC = SCGetAttById(pTHS, entry.AttrBlock.pAttr[i].attrTyp);
        
        if(!pAC || !pAC->ulMapiID)          // skip zeros
            continue;
        
        mapiSyn = ABMapiSyntaxFromDSASyntax(dwFlags, pAC->syntax,
                                            pAC->ulLinkID, 0);
        switch( mapiSyn) {
        case PT_OBJECT:
            if( dwFlags & AB_SKIP_OBJECTS )
                continue;           // skip objs, next loop
            break;
        case PT_NULL:               // skip nulls; jump to next loop
            continue;
        case PT_UNICODE:
            if( CodePage != CP_WINUNICODE )
                mapiSyn = PT_STRING8;
            break;
        case PT_STRING8:
            if( CodePage == CP_WINUNICODE)
                mapiSyn = PT_UNICODE;
            break;
        }

        if( mapiSyn != PT_OBJECT  && !(pAC->isSingleValued))
            mapiSyn |= MV_FLAG;

        tempPropTags->aulPropTag[j] = PROP_TAG(mapiSyn,pAC->ulMapiID);
        j++;
    }

    if(!(dwFlags & AB_SKIP_OBJECTS) && fDistList) {
        (tempPropTags)->aulPropTag[j] = PR_CONTAINER_CONTENTS;
        j++;
    }
    
    (tempPropTags)->cValues = j;
    
    // Everything worked, give 'em back the proptag array.
    *ppPropTags = tempPropTags;
    
    return SUCCESS_SUCCESS;
}

/*****************************************************************************
*   QueryColumns
******************************************************************************/

SCODE
ABQueryColumns_local (
        THSTATE *pTHS,
        DWORD dwFlags,
        ULONG ulFlags,
        LPLPSPropTagArray_r ppColumns
        )
{
    unsigned	i;
    int		cp;
    ATTCACHE	**pACBuf;
    LPSPropTagArray_r pColumns;
    DWORD       mapiSyn;

    SCEnumMapiProps(&cp, &pACBuf);

    pColumns = THAllocEx(pTHS, CbNewSPropTagArray(cp + NUM_DEFAULT_PROPS));

    pColumns->cValues = cp + NUM_DEFAULT_PROPS;
    memcpy( pColumns->aulPropTag,
        (ulFlags & MAPI_UNICODE) ? DefPropsU->aulPropTag
                                 : DefPropsA->aulPropTag,
        NUM_DEFAULT_PROPS * sizeof(ULONG));

    for (i=NUM_DEFAULT_PROPS; i<pColumns->cValues; i++, pACBuf++) {
        mapiSyn = ABMapiSyntaxFromDSASyntax(dwFlags,
                                            (*pACBuf)->syntax,
                                            (*pACBuf)->ulLinkID, 0);
        if ((mapiSyn == PT_UNICODE) && !(ulFlags & MAPI_UNICODE))
            mapiSyn = PT_STRING8;

        if ((mapiSyn != PT_NULL && mapiSyn != PT_OBJECT)
                    && !((*pACBuf)->isSingleValued))
            mapiSyn |= MV_FLAG;

        pColumns->aulPropTag[i] = PROP_TAG(mapiSyn, (*pACBuf)->ulMapiID);
    }
    *ppColumns = pColumns;

    return SUCCESS_SUCCESS;
}

BOOL
MakeStoredMAPIValue (
        THSTATE *pTHS,
        DWORD dwCodePage,
        LPSPropValue_r pPropVal,
        ATTCACHE *pAC,
        ATTR *pAttr
        )
/*++

Routine Description:

    Creates a MAPI propval from an external data format. New MAPI syntaxes could
    be added to this routine when necessary. 

     Called from GetSRowSet, below.

--*/
{
    BOOL                errFlag=FALSE;
    PROP_VAL_UNION      *pVal = &pPropVal->Value;
    CHAR                *puc, *pStringDN = NULL;
    ULONG               ulLen;
    DWORD		cbT , k;
    DWORD               DispType=0;
    
    puc = pAttr->AttrVal.pAVal[0].pVal;
    ulLen = pAttr->AttrVal.pAVal[0].valLen;
    
    if(pAC->syntax == SYNTAX_DISTNAME_TYPE) {
        // It's in DistName format, string-ize it 
        
        if(!ABDispTypeAndStringDNFromDSName ((DSNAME *)puc,
                                             &puc,
                                             &DispType)) {
            errFlag = TRUE;
        }
        else {
            Assert(puc && *puc == '/');
            ulLen = strlen(puc);
            pStringDN = puc;
        }
    }
    
    if(!errFlag) {
	switch( PROP_TYPE(pPropVal->ulPropTag)) {
        case PT_I2:
	    pVal->i = *((short int *)puc);
	    break;
        case PT_SYSTIME:
            DSTimeToFileTime(*((DSTIME *)puc), (FILETIME *)&(pVal->ft));
	    break;
        case PT_LONG:
	    pVal->l = *((LONG *)puc);
	    break;
            
        case PT_BOOLEAN:
	    pVal->b = *((unsigned short int *)puc);
	    break;
            
        case PT_STRING8:
	    // If the DSA holds this in unicode, translate it 
	    if(pAC->syntax == SYNTAX_UNICODE_TYPE) {
		pVal->lpszA = String8FromUnicodeString(TRUE,
                                                       dwCodePage,
						       (wchar_t *)puc,
						       (ulLen/sizeof(wchar_t)),
						       NULL,
						       NULL);
                
		if(!pVal->lpszA)
		    errFlag = TRUE;
	    }
	    else {
		// The string is not null terminated. Copy to one that is.
                pVal->lpszA = THAllocEx(pTHS, ulLen+1);
		strncpy(pVal->lpszA, puc,ulLen);
		(pVal->lpszA)[ulLen] = '\0';
	    }
	    break;
            
        case PT_UNICODE:
	    // If we don't hold this in unicode, translate it 
	    if(pAC->syntax != SYNTAX_UNICODE_TYPE) {
		pVal->lpszW = UnicodeStringFromString8(CP_TELETEX,
						       puc,
						       ulLen);
		if(!pVal->lpszW)
		    errFlag = TRUE;
	    }
	    else {
		// The string is not null terminated, copy to one that is.
		pVal->lpszW = THAllocEx(pTHS, ulLen+sizeof(wchar_t));
		memcpy(pVal->lpszW, puc,ulLen);
		(pVal->lpszW)[ulLen/sizeof(wchar_t)] = 0;
	    }
	    break;
            
        case PT_BINARY:
	    if(pAC->syntax != SYNTAX_DISTNAME_TYPE) {
		pVal->bin.cb = ulLen;
		pVal->bin.lpb = puc;
                pAttr->AttrVal.pAVal[0].pVal = NULL;
	    }
	    else {
		// We have a distname, we want to return a PID
                ABMakePermEID(pTHS,
                              (LPUSR_PERMID *)&(pVal->bin.lpb),
                              &(pVal->bin.cb),
                              DispType,
                              puc);
	    }
	    break;
        case PT_MV_STRING8:
            // Once upon a time in Exchange, we checked to see if this was
	    // membership of a DL and if the HIDEDLMEMBERSHIP attribute on the
	    // object was set and if it was whether the caller had certain
	    // rights.   This is now taken care of using normal read rights on
	    // attributes.

            // Once upon a time in Exchange we checked to see if this was the
            // is-member-of attribute and if so whether the caller had certain
	    // rights.   This is now taken care of using normal read rights on
	    // attributes.

	    pVal->MVszA.lppszA = THAllocEx(pTHS, pAttr->AttrVal.valCount *
                                           sizeof(LPSTR));
	    pVal->MVszA.cValues = pAttr->AttrVal.valCount;
            
	    for(k=0; k<pAttr->AttrVal.valCount;k++) {
                puc = pAttr->AttrVal.pAVal[k].pVal;
                ulLen = pAttr->AttrVal.pAVal[k].valLen;
                switch(pAC->syntax) {
                case SYNTAX_UNICODE_TYPE:
                    pVal->MVszA.lppszA[k] =
                        String8FromUnicodeString(TRUE,
                                                 dwCodePage,
                                                 (wchar_t *)puc,
                                                 (ulLen/sizeof(wchar_t)),
                                                 NULL,
                                                 NULL);
                    
                    if(!pVal->MVszA.lppszA[k]) {
                        errFlag = TRUE;
                        break;
                    }
                    break;
                case SYNTAX_DISTNAME_TYPE:
                    // It's in DistName format, string-ize it 
                    if(!ABDispTypeAndStringDNFromDSName ((DSNAME *)puc,
                                                         &puc,
                                                         &DispType)) {
                        errFlag = TRUE;
                        break;
                    }
                    ulLen = strlen(puc);
                    pStringDN = puc;
                    Assert(puc && *puc == '/');
                    // Fall through
                    
                default:
                    // The string is not null terminated, copy to one that is.
                    pVal->MVszA.lppszA[k] = THAllocEx(pTHS, ulLen + 1);
                    strncpy(pVal->MVszA.lppszA[k], puc,ulLen);
                    (pVal->MVszA.lppszA[k])[ulLen] = '\0';
                    break;
                }
                if (pStringDN) {
                    THFreeEx (pTHS, pStringDN);
                    pStringDN = NULL;
                }

	    }
	    break;
            
	  case PT_MV_SYSTIME:
	    pVal->MVft.lpft =THAllocEx(pTHS, pAttr->AttrVal.valCount *
                                     sizeof(FILETIME_r));
            
	    pVal->MVft.cValues = pAttr->AttrVal.valCount;

	    for(k=0; k<pAttr->AttrVal.valCount;k++) {
                DSTimeToFileTime(*((DSTIME *)pAttr->AttrVal.pAVal[k].pVal),
                                 (FILETIME *)&(pVal->MVft.lpft[k]));
            }
	    break;
            
	  case PT_MV_LONG:
            pVal->MVl.lpl = THAllocEx(pTHS, pAttr->AttrVal.valCount * sizeof(LONG));
	    pVal->MVl.cValues = pAttr->AttrVal.valCount;
	    for(k=0; k<pAttr->AttrVal.valCount;k++) {
                pVal->MVl.lpl[k] = *((LONG *)pAttr->AttrVal.pAVal[k].pVal);
	    }
	    break;

	  case PT_MV_I2:
              pVal->MVi.lpi = THAllocEx(pTHS, pAttr->AttrVal.valCount *
                                        sizeof(short));
	    pVal->MVi.cValues = pAttr->AttrVal.valCount;
	    for(k=0; k<pAttr->AttrVal.valCount;k++) {
                pVal->MVi.lpi[k] =
                    *((short *)pAttr->AttrVal.pAVal[k].pVal);
	    }
	    break;
            
        case PT_MV_BINARY:
            pVal->MVbin.lpbin = THAllocEx(pTHS, pAttr->AttrVal.valCount *
                                          sizeof(SBinary_r));
	    pVal->MVbin.cValues = pAttr->AttrVal.valCount;
	    for(k=0; k<pAttr->AttrVal.valCount;k++) {
                puc = pAttr->AttrVal.pAVal[k].pVal;
                ulLen = pAttr->AttrVal.pAVal[k].valLen;
                if(pAC->syntax != SYNTAX_DISTNAME_TYPE) {
                    pVal->MVbin.lpbin[k].cb = ulLen;
                    pVal->MVbin.lpbin[k].lpb = puc;
                    pAttr->AttrVal.pAVal[k].pVal = NULL;
                }
                else {
                    // We have a distname, we want to return a PID
                    ABMakePermEID(
                            pTHS,
                            (LPUSR_PERMID *)&(pVal->MVbin.lpbin[k].lpb),
                            &(pVal->MVbin.lpbin[k].cb),
                            DispType,
                            puc);
                }
	    }
	    break;

        case PT_MV_UNICODE:
            // Once upon a time in Exchange, we checked to see if this was
	    // membership of a DL and if the HIDEDLMEMBERSHIP attribute on the
	    // object was set and if it was whether the caller had certain
	    // rights.   This is now taken care of using normal read rights on
	    // attributes.

            // Once upon a time in Exchange we checked to see if this was the
            // is-member-of attribute and if so whether the caller had certain
	    // rights.   This is now taken care of using normal read rights on
	    // attributes.

	    pVal->MVszW.lppszW = THAllocEx(pTHS, pAttr->AttrVal.valCount *
                                           sizeof(LPWSTR));
	    pVal->MVszW.cValues = pAttr->AttrVal.valCount;
            
	    for(k=0; k<pAttr->AttrVal.valCount;k++) {
                puc = pAttr->AttrVal.pAVal[k].pVal;
                ulLen = pAttr->AttrVal.pAVal[k].valLen;

                switch(pAC->syntax) {
                case SYNTAX_UNICODE_TYPE:
                    // The string is not null terminated,copy to one that is.
                    pVal->MVszW.lppszW[k]=THAllocEx(pTHS, ulLen+sizeof(wchar_t));
                    memcpy(pVal->MVszW.lppszW[k],puc,ulLen);
                    (pVal->MVszW.lppszW[k])[ulLen/sizeof(wchar_t)] = 0;
                    break;
                case  SYNTAX_DISTNAME_TYPE:
                    // It's in DistName format, string-ize it 
                    if(!ABDispTypeAndStringDNFromDSName ((DSNAME *)puc,
                                                         &puc,
                                                         &DispType)) {
                        errFlag = TRUE;
                        break;
                    }
                    ulLen = strlen(puc);
                    Assert(puc && *puc == '/');
                    pStringDN = puc;
                    // Fall through
                default:
                    pVal->MVszW.lppszW[k] =
                        UnicodeStringFromString8(CP_TELETEX,
                                                 puc,
                                                 ulLen);
                    if(!pVal->MVszW.lppszW[k]) {
                        errFlag = TRUE;
                        break;
                    }
                }

                if (pStringDN) {
                    THFreeEx (pTHS, pStringDN);
                    pStringDN = NULL;
                }
	    }
	    break;
            
        case PT_OBJECT:
	    pVal->x = 0;
	    break;
            
        case PT_NULL:
        case PT_UNSPECIFIED:
        case PT_CURRENCY:
        case PT_APPTIME:
        case PT_CLSID:
        case PT_ERROR:
        case PT_R4:     /* float data type */
        case PT_DOUBLE:
	    /* We don't have any attributes of these single
	     * valued types.
	     */
            
        case PT_MV_R4:
        case PT_MV_CLSID:
        case PT_MV_DOUBLE:
        case PT_MV_CURRENCY:
        case PT_MV_APPTIME:
	    /* We don't have any attributes of these multi
	     * valued types.
	     */
            
            
        default:
	    errFlag = TRUE;
	    break;
	}
    }

    if (pStringDN) {
        THFreeEx (pTHS, pStringDN);
        pStringDN = NULL;
    }

    return errFlag;
}

//**************************************
//
// Constructs a MAPI propval from multiple pieces of stored or constant
// data.  Different from MakeStoredMAPIValue because we do not explicitly
// store these MAPI values in the DIT as one piece, but rather build them
// from other data.
//
// New constructed MAPI values could be added to this routine when necessary.
//
// Called from GetSRowSet, below.
//
//
//**************************************

BOOL
MakeConstructedMAPIValue(
        THSTATE *pTHS,
        DWORD dwCodePage,
        LPSPropValue_r pPropVal,
        PUCHAR StringDN,
        PUCHAR *DispNamePrintable,
        PUCHAR *DispNameA,
        wchar_t **DispNameW,
        DWORD ObjType,
        DWORD DispType,
        DWORD CurrentDNT,
        DWORD Flags)
{
    BOOL                errFlag=FALSE;
    PROP_VAL_UNION      *pVal = &pPropVal->Value;
    CHAR                *puc;
    ULONG               ulLen;
    DWORD		cbT;
    LPUSR_PERMID        pID;
    LPUSR_ENTRYID       eID;
    DWORD               bTypeSpecified;
    DWORD               cb;

    bTypeSpecified = (PROP_TYPE(pPropVal->ulPropTag) != PT_UNSPECIFIED);

    // This might be one of the constructed MAPI attributes;
    if(PROP_TYPE(pPropVal->ulPropTag) & MV_FLAG)
	errFlag = TRUE;

    switch(PROP_ID(pPropVal->ulPropTag)) {
    case PROP_ID(PR_INSTANCE_KEY):
        if ((PROP_TYPE(pPropVal->ulPropTag) == PT_BINARY ) ||
            !bTypeSpecified ) {
            pPropVal->ulPropTag = PR_INSTANCE_KEY;
            
            pVal->bin.cb = sizeof(DWORD);
            pVal->bin.lpb = THAllocEx(pTHS, sizeof(DWORD));
            *((DWORD *)(pVal->bin.lpb)) = CurrentDNT;
        }
        else
            errFlag = TRUE;
        
        break;
        
    case PROP_ID(PR_INITIAL_DETAILS_PANE):
        if((PROP_TYPE(pPropVal->ulPropTag) ==
            PROP_TYPE(PR_INITIAL_DETAILS_PANE)) ||
           !bTypeSpecified ) {
            
            pPropVal->ulPropTag = PR_INITIAL_DETAILS_PANE;
            pVal->l = 0;
        }
        else
            errFlag = TRUE;
        break;

    case PROP_ID(PR_TRANSMITABLE_DISPLAY_NAME):
    case PROP_ID(PR_DISPLAY_NAME):
        switch(PROP_TYPE(pPropVal->ulPropTag)) {
        case PT_UNICODE:
            cb = wcslen( *DispNameW ) + 1;
            pVal->lpszW = THAllocEx (pTHS, cb * sizeof (wchar_t));
            wcscpy (pVal->lpszW, *DispNameW);
            break;
            
        case PT_STRING8:
        case PT_UNSPECIFIED:
            pPropVal->ulPropTag = PROP_TAG(PT_STRING8,
                                           PROP_ID(pPropVal->ulPropTag));
            cb = strlen (*DispNameA) + 1;
            pVal->lpszA = THAllocEx (pTHS, cb * sizeof (char));
            strcpy (pVal->lpszA, *DispNameA);
            break;
        default:
            errFlag = TRUE;
            break;
        }
        
        break;
        
    case PROP_ID(PR_EMS_AB_DISPLAY_NAME_PRINTABLE):
        switch(PROP_TYPE(pPropVal->ulPropTag)) {
        case PT_UNICODE:
            pVal->lpszW = UnicodeStringFromString8(CP_TELETEX,
                                                   *DispNamePrintable,
                                                   -1);
            break;
        case PT_STRING8:
        case PT_UNSPECIFIED:
            cb = strlen (*DispNamePrintable) + 1;
            pVal->lpszA = THAllocEx (pTHS, cb * sizeof (char));
            strcpy (pVal->lpszA, *DispNamePrintable);
            break;
        default:
            errFlag = TRUE;
            break;
        }
        break;
	
    case PROP_ID(PR_EMS_AB_DOS_ENTRYID):
        if((PROP_TYPE(pPropVal->ulPropTag) == PT_LONG) ||
           !bTypeSpecified ) {
            pPropVal->ulPropTag = PR_EMS_AB_DOS_ENTRYID;
            pVal->l=CurrentDNT;
        }
        else
            errFlag = TRUE;
        break;
        
    case PROP_ID(PR_OBJECT_TYPE):
        if((PROP_TYPE(pPropVal->ulPropTag) == PT_LONG ||
            !bTypeSpecified)) {
            
            pPropVal->ulPropTag = PR_OBJECT_TYPE;
            pVal->l = ObjType;
        }
        else
            errFlag = TRUE;
        
        break;
        
    case PROP_ID(PR_CONTAINER_CONTENTS):
        /* This is fine if the object is a DL, not fine otherwise. */
        if((PROP_TYPE(pPropVal->ulPropTag) == PT_OBJECT ||
            !bTypeSpecified) &&
           ObjType == MAPI_DISTLIST) {
            
            pPropVal->ulPropTag = PR_CONTAINER_CONTENTS;
            pVal->x = 0;
        }
        else
            errFlag = TRUE;
        break;
        
    case PROP_ID(PR_CONTAINER_FLAGS):
        if((PROP_TYPE(pPropVal->ulPropTag) == PT_LONG ||
            !bTypeSpecified ) &&
           (DispType == DT_DISTLIST)) {
            
            pPropVal->ulPropTag = PR_CONTAINER_FLAGS;
            pVal->l = AB_RECIPIENTS;
        }
        else
            errFlag = TRUE;
        break;
	
    case PROP_ID(PR_DISPLAY_TYPE):
        if((PROP_TYPE(pPropVal->ulPropTag) == PT_LONG ||
            !bTypeSpecified )) {
            pPropVal->ulPropTag = PR_DISPLAY_TYPE;
            pVal->l=DispType;
        }
        else
            errFlag =TRUE;
        break;
        
    case PROP_ID(PR_ADDRTYPE):
        switch (PROP_TYPE(pPropVal->ulPropTag))
	    {
            case PT_UNSPECIFIED:
            case PT_STRING8:
                pPropVal->ulPropTag = PR_ADDRTYPE_A;
                pVal->lpszA = lpszEMT_A;
                break;
            case PT_UNICODE:
                pVal->lpszW = lpszEMT_W;
                break;
            default:
                errFlag = TRUE;
                break;
	    }
        break;
        
    case PROP_ID(PR_TEMPLATEID):
        Flags &= ~fEPHID;
        /* fall through */
    case PROP_ID(PR_ENTRYID):
        if (PROP_TYPE(pPropVal->ulPropTag) != PT_BINARY && bTypeSpecified)
            errFlag = TRUE;
        else {
            pPropVal->ulPropTag= PROP_TAG(PT_BINARY,
                                          PROP_ID(pPropVal->ulPropTag));
            
            if(!(Flags & fEPHID)) {

                cbT = strlen(StringDN) + CBUSR_PERMID + 1;
                pID = THAllocEx(pTHS, cbT);
                pID->abFlags[0] = 0;
                pID->abFlags[1] = 0;
                pID->abFlags[2] = 0;
                pID->abFlags[3] = 0;
                
                pID->muid = muidEMSAB;
                pID->ulVersion = EMS_VERSION;
                pID->ulType = DispType;
                lstrcpy( (LPSTR)pID->szAddr, StringDN);
                
                pVal->bin.cb = cbT;
                pVal->bin.lpb = (VOID *)pID;
            }
            else {
                // Ephemeral;
                cbT = CBUSR_ENTRYID;
                eID = THAllocEx(pTHS, cbT);
                eID->abFlags[0] = EPHEMERAL;
                eID->abFlags[1] = 0;
                eID->abFlags[2] = 0;
                eID->abFlags[3] = 0;
		
                memcpy(&(eID->muid), &pTHS->InvocationID, sizeof(UUID));
                eID->ulVersion = EMS_VERSION;
                eID->ulType =DispType;
                eID->dwEph = CurrentDNT;
		
		
                pVal->bin.cb = cbT;
                pVal->bin.lpb = (VOID *)eID;
            }
        }
        break;
	
    case PROP_ID(PR_MAPPING_SIGNATURE):
        if(PROP_TYPE(pPropVal->ulPropTag) == PT_BINARY ||
           !bTypeSpecified ) {
            pPropVal->ulPropTag = PR_MAPPING_SIGNATURE;
            puc = THAllocEx(pTHS, sizeof(GUID));
            memcpy(puc, &muidEMSAB, sizeof(GUID));
            pVal->bin.cb = sizeof(GUID);
            pVal->bin.lpb = (VOID *) puc;
        }
        else
            errFlag = TRUE;
        break;
	
    case PROP_ID(PR_EMS_AB_OBJ_DIST_NAME):
        
        if(PROP_TYPE(pPropVal->ulPropTag) == PT_OBJECT) {
            pVal->x = 0;
        }
        else {
            /* Some sort of string */
            switch(PROP_TYPE(pPropVal->ulPropTag)) {
            case PT_UNSPECIFIED:
            case PT_STRING8:
                pPropVal->ulPropTag = PR_EMS_AB_OBJ_DIST_NAME_A;
                cbT = strlen(StringDN) + 1;
                pVal->lpszA = THAllocEx(pTHS, cbT * sizeof (char));
                strcpy( pVal->lpszA, StringDN);

                break;
            case PT_UNICODE:
                pVal->lpszW =
                    UnicodeStringFromString8(CP_TELETEX,
                                             StringDN,
                                             -1);
                if(!pVal->lpszW)
                    errFlag = TRUE;
                break;
            default:
                errFlag = TRUE;
                break;
            }
        }
        break;
        
    case PROP_ID(PR_RECORD_KEY):
        if((PROP_TYPE(pPropVal->ulPropTag) != PT_BINARY &&
            bTypeSpecified) ) {
            errFlag=TRUE;
        }
        else
	    {
		pPropVal->ulPropTag = PR_RECORD_KEY;
                
                cbT = strlen(StringDN) + CBUSR_PERMID + 1;
                pID = THAllocEx(pTHS, cbT);
		pID->abFlags[0] = 0;
		pID->abFlags[1] = 0;
		pID->abFlags[2] = 0;
		pID->abFlags[3] = 0;
		pID->muid = muidEMSAB;
		pID->ulVersion = EMS_VERSION;
                pID->ulType = DispType;
		lstrcpy( (LPSTR)pID->szAddr, StringDN);
		pVal->bin.cb = cbT;
		pVal->bin.lpb = (VOID *)pID;
	    }
	    break;

	case PROP_ID(PR_EMAIL_ADDRESS):
            switch(PROP_TYPE(pPropVal->ulPropTag)) {
            case PT_UNSPECIFIED:
            case PT_STRING8:
                pPropVal->ulPropTag = PR_EMAIL_ADDRESS_A;
                cbT = strlen(StringDN) + 1;
                pVal->lpszA = THAllocEx(pTHS, cbT * sizeof (char));
                strcpy( pVal->lpszA, StringDN);


                break;
            case PT_UNICODE:
                pVal->lpszW =
                    UnicodeStringFromString8(CP_TELETEX,
                                             StringDN,
                                             -1);
                if(!pVal->lpszW) {
                    errFlag = TRUE;
                }
                break;
            default:
                errFlag = TRUE;
                break;
	    }
	    break;

	case PROP_ID(PR_SEARCH_KEY):
	    if((PROP_TYPE(pPropVal->ulPropTag) != PT_BINARY &&
		bTypeSpecified) ) {
		errFlag = TRUE;
	    }
	    else
	    {
		pPropVal->ulPropTag = PR_SEARCH_KEY;
		pVal->bin.cb = strlen(StringDN) + cbszEMT_A + 1;
                pVal->bin.lpb=THAllocEx(pTHS, pVal->bin.cb);
		lstrcpy( pVal->bin.lpb, lpszEMT_A);         // add email type
		lstrcat( pVal->bin.lpb, ":");
		lstrcat( pVal->bin.lpb, StringDN);

		_strupr( pVal->bin.lpb);
	    }
	    break;

	default:
	    errFlag = TRUE;
	    break;
    }
    return errFlag;
}

#ifdef PROCESS_PHANTOM_CODE_ALIVE
/************************************************************
 *
 * Make a propval for a phantom entry.  Very few proptags are supported.
 *
 ************************************************************/
SCODE
ProcessPhantom (
        THSTATE          *pTHS,
        DWORD             dwCodePage,
        LPSPropTagArray_r pPropTags,
        LPSPropValue_r    tempPropVal
        )
{
    DWORD  i, cbRDN, cbStringDN=0, cbwRDN;
    char  *pwRDN = NULL, *pTemp, *pRDN;
    char   *stringDN;
    SCODE  scode = SUCCESS_SUCCESS;
    BOOL   errFlag=FALSE;
    
    /* Get the RDN */
    DBGetSingleValue( pTHS->pDB, ATT_RDN, pwRDN, 0,&cbwRDN);
    // we need to translate out of unicode.
    pRDN = String8FromUnicodeString(
            TRUE,
            dwCodePage,
            (LPWSTR)pwRDN,
            cbwRDN/sizeof(wchar_t),
            &cbRDN,
            NULL);

    THFreeEx(pTHS, pwRDN);
    
    pTemp = THAllocEx(pTHS, cbRDN + 3);
    pTemp[0] = '[';
    memcpy(&pTemp[1],pRDN,cbRDN);
    pTemp[1+cbRDN] = ']';
    pTemp[2+cbRDN] = 0;
    THFreeEx(pTHS, pRDN);
    pRDN=pTemp;

    stringDN = GetExtDN(pTHS, pTHS->pDB);
    cbStringDN = strlen(stringDN);

    for (i = 0; i < pPropTags->cValues; i++)  {
	switch(PROP_ID(pPropTags->aulPropTag[i])) {
        case PROP_ID(PR_TRANSMITABLE_DISPLAY_NAME):
        case PROP_ID(PR_DISPLAY_NAME):
            if(PT_UNICODE == PROP_TYPE(pPropTags->aulPropTag[i])) {
                errFlag = TRUE;
            }
            else {
                tempPropVal[i].ulPropTag = pPropTags->aulPropTag[i];
                tempPropVal[i].Value.lpszA = pRDN;
            }
            break;
            
        case PROP_ID(PR_ENTRYID):
            if (PROP_TYPE(pPropTags->aulPropTag[i]) != PT_BINARY) {
                errFlag = TRUE;
            }
            else {
                /* Permanent ID */
                LPUSR_PERMID        pID;
                DWORD               cbT;
		
                if(!cbStringDN) {
                    errFlag=TRUE;
                }
                else {
                    cbT = cbStringDN + CBUSR_PERMID + 1;
                    pID = THAllocEx(pTHS, cbT);
                    pID->abFlags[0] = 0;
                    pID->abFlags[1] = 0;
                    pID->abFlags[2] = 0;
                    pID->abFlags[3] = 0;
                    
                    pID->muid = muidEMSAB;
                    pID->ulVersion = EMS_VERSION;
                    pID->ulType = DT_AGENT;
                    
                    lstrcpy( (LPSTR)pID->szAddr, stringDN);
                    tempPropVal[i].ulPropTag = pPropTags->aulPropTag[i];
                    tempPropVal[i].Value.bin.cb = cbT;
                    tempPropVal[i].Value.bin.lpb = (VOID *)pID;
                }
            }
            break;
            
        case PROP_ID(PR_DISPLAY_TYPE):
            if (PROP_TYPE(pPropTags->aulPropTag[i]) != PT_LONG) {
                errFlag = TRUE;
            }
            else {
                tempPropVal[i].ulPropTag = pPropTags->aulPropTag[i];
                tempPropVal[i].Value.l = DT_AGENT;
            }
            break;
            
        default:
            errFlag = TRUE;
	}
	
	
	if(errFlag) {
	    tempPropVal[i].ulPropTag =
                PROP_TAG(PT_ERROR,
                         PROP_ID(pPropTags->aulPropTag[i]));
	    tempPropVal[i].Value.err = MAPI_E_NOT_FOUND;
	    scode = MAPI_W_ERRORS_RETURNED;
	    errFlag = FALSE;
	}
    }
    return scode;
    
}
#endif

void
abGetConstructionParts (
        THSTATE *pTHS,
        DWORD CodePage,
        PSECURITY_DESCRIPTOR pSec,
        DSNAME *pDN,
        PUCHAR *pStringDN,
        PUCHAR *pDispNamePrintable,
        PUCHAR *pDispNameA,
        wchar_t **pDispNameW,
        DWORD *pObjType,
        DWORD *pDispType)
{
    BOOL            fUsedDefChar=TRUE;
    DWORD           cb=0, cbPrintable = 0;
    ATTCACHE        *pAC;

    // NOTE:  The attributes read here are considered to be part of the
    //  "identity" of the object in question.  As such, through MAPI they are
    //  protected by LIST_CHILDREN or LIST_OBJECT, not through READ_PROPERTY.
    //  Thus, if you can read the object at all, you are granted rights on these
    //  attributes. 

    // First get the string DN.
    ABDispTypeAndStringDNFromDSName (pDN,
                                     pStringDN,
                                     pDispType);
    Assert(*pStringDN && (*(*pStringDN) == '/'));
    
    // Now get the object type from the object class.
    *pObjType = ABObjTypeFromDispType(*pDispType);
    
    // Now, set up the DisplayNames.
    *pDispNameA = NULL;

    // Guess at a size for the printable display name
    cb = CBMAX_DISPNAME;
    *pDispNamePrintable = THAllocEx(pTHS, cb+1);
    // First get the lamename.
    switch( DBGetSingleValue(
            pTHS->pDB,
            ATT_DISPLAY_NAME_PRINTABLE,
            *pDispNamePrintable,
            cb,
            &cb)) {
    case DB_ERR_VALUE_TRUNCATED:
        // There is a display name printable, but we didn't read it because we
        // had no space for it.
        
        *pDispNamePrintable = THReAllocEx(pTHS, *pDispNamePrintable, cb+1);
        
        DBGetSingleValue(pTHS->pDB,
                         ATT_DISPLAY_NAME_PRINTABLE,
                         *pDispNamePrintable,
                         cb,
                         &cb);
        (*pDispNamePrintable)[cb]=0;
        break;
        
    case 0:
        // We got the name, realloc down to size.
        *pDispNamePrintable = THReAllocEx(pTHS, *pDispNamePrintable, cb+1);
        (*pDispNamePrintable)[cb]=0;
        break;
         
    default:
        {
            wchar_t *pTempW=(wchar_t *)*pDispNamePrintable;
            *pDispNamePrintable = NULL;

#ifndef DO_NOT_USE_MAILNICKNAME_FOR_DISPLAYNAME_PRINTABLE

            // we use an attribute (mailNickName) that is not by default on the DS schema.
            // it is only when exchange is installed

            pAC = SCGetAttByMapiId(pTHS, PROP_ID(PR_ACCOUNT_A));

            if (pAC) {
                // Failed to read the printable display name for some reason.  Fall
                // back to the mailNickName, if this exists
                switch(DBGetSingleValue(pTHS->pDB, 
                                        pAC->id,
                                        pTempW,
                                        cb,
                                        &cb)) {
                case DB_ERR_VALUE_TRUNCATED:
                    // There is an rdn, but we didn't read it because we had no
                    // space for it.

                    pTempW = THReAllocEx(pTHS, pTempW, cb + sizeof(wchar_t));

                    DBGetSingleValue( pTHS->pDB, pAC->id, pTempW, cb, &cb);
                    pTempW[cb/sizeof(wchar_t)] = 0;

                    // Fall through to do the conversion to string8
                case 0:
                    // RDN is in unicode.  Turn it into string 8.
                    *pDispNamePrintable = String8FromUnicodeString(
                            TRUE,
                            CodePage,
                            pTempW,
                            -1,
                            NULL,
                            &fUsedDefChar);
                    
                    THFreeEx(pTHS, pTempW);
                    pTempW = NULL;
                    break;

                default:
                    break;
                }
            
            }
#endif

            if (*pDispNamePrintable == NULL) {
                // Failed to read the printable display name for some reason.  Fall
                // back to the RDN
                switch(DBGetSingleValue(pTHS->pDB, 
                                        ATT_RDN,
                                        pTempW,
                                        cb,
                                        &cb)) {
                case DB_ERR_VALUE_TRUNCATED:
                    // There is an rdn, but we didn't read it because we had no
                    // space for it.

                    pTempW = THReAllocEx(pTHS, pTempW, cb + sizeof(wchar_t));

                    DBGetSingleValue( pTHS->pDB, ATT_RDN, pTempW, cb, &cb);
                    pTempW[cb/sizeof(wchar_t)] = 0;

                    // Fall through to do the conversion to string8
                case 0:
                    // RDN is in unicode.  Turn it into string 8.
                    *pDispNamePrintable = String8FromUnicodeString(
                            TRUE,
                            CodePage,
                            pTempW,
                            -1,
                            NULL,
                            &fUsedDefChar);
                    // Fall through to free pTempW
                default:
                    THFreeEx(pTHS, pTempW);
                    pTempW = NULL;
                    break;
                }
            }
        }
    }
    
    if(!(*pDispNamePrintable)) {
        // we cannot free a constant, so copy it
        *pDispNamePrintable = THAllocEx (pTHS, sizeof(char) * 20);
        strcpy (*pDispNamePrintable, "Unavailable");
    }

    cbPrintable = cb + 1;       // keep the len

    
    // OK, now build the normal display names.
    cb = CBMAX_DISPNAME;
    *pDispNameW = THAllocEx(pTHS, cb+sizeof(wchar_t));
    switch(DBGetSingleValue(
            pTHS->pDB,
            ATT_DISPLAY_NAME,
            *pDispNameW,
            cb,
            &cb)) {
    case DB_ERR_VALUE_TRUNCATED:
        // There is a display name, but we didn't read it because we had no
        // space for it.
        *pDispNameW = THReAllocEx(pTHS, *pDispNameW,cb+sizeof(wchar_t));
        
        DBGetSingleValue(pTHS->pDB,
                         ATT_DISPLAY_NAME,
                         *pDispNameW,
                         cb,
                         &cb);
        (*pDispNameW)[cb/sizeof(wchar_t)] = 0;
        break;
        
    case 0:
        *pDispNameW = THReAllocEx(pTHS, *pDispNameW,cb+sizeof(wchar_t));
        (*pDispNameW)[cb/sizeof(wchar_t)] = 0;
        break;

    default:
        THFreeEx(pTHS, *pDispNameW);
        (*pDispNameW)=NULL;
        break;
    }
    
    if(*pDispNameW) {
        // We read a wide display name.  Now, translate it to string 8
        *pDispNameA = String8FromUnicodeString(
                TRUE,
                CodePage,
                *pDispNameW,
                -1,
                NULL,
                &fUsedDefChar);
        
        if( fUsedDefChar ) {
            // The conversion of the Unicode display name led to unprintable
            // characters, or just plain never took place. get the name.
            THFreeEx (pTHS, *pDispNameA);
            *pDispNameA = THAllocEx (pTHS, cbPrintable * sizeof (char));
            strcpy (*pDispNameA, *pDispNamePrintable);
        }
    }
    else {
        // No wide display names were read.  Get the name for the
        // string8 display name and stretch it to unicode for the wide
        // version
        THFreeEx (pTHS, *pDispNameA);
        *pDispNameA = THAllocEx (pTHS, cbPrintable * sizeof (char));
        strcpy (*pDispNameA, *pDispNamePrintable);
        
        *pDispNameW = UnicodeStringFromString8(
                CodePage,
                *pDispNameA,
                -1);
    }
    
}

SCODE
GetSrowSet(
        THSTATE *pTHS,
        PSTAT pStat,
        PINDEXSIZE pIndexSize,
        DWORD dwEphsCount,
        LPDWORD lpdwEphs,
        DWORD Count,
        LPSPropTagArray_r pPropTags,
        LPSRowSet_r * Rows,
        DWORD Flags
        )
{
    /* NOTE:  We assume that dwEphsCount != 0 if and only if this is
     * a restriction.  Therefore, we should NOT call here if this is a
     * query rows on an empty restriction, or on the end of an restriction
     * with objects in it.
     */
    
    PSECURITY_DESCRIPTOR pSec=NULL;
    ULONG           ulLen = 0;
    SCODE           scode=0;
    UINT            i, j, k;
    LPSPropValue_r  pPropVal;
    LPSPropValue_r  tempPropVal;
#ifdef PROCESS_PHANTOM_CODE_ALIVE
    BOOL            fProcessPhantom;
#endif    
    BOOL            fFoundDNT;
    DWORD           dntIndex, tempSyntax, tempSyntax2, CurrentDNT;
    LPSRowSet_r     tempSRowSet;
    DWORD           ObjType, DispType;
    PUCHAR          StringDN = NULL;
    PUCHAR          DisplayNamePrintable = NULL;
    PUCHAR          DisplayNameA = NULL;
    wchar_t        *DisplayNameW = NULL;
    ENTINF          entry;
    ENTINFSEL       selection;
    ATTCACHE       *pAC;
    CACHED_AC       CachedAC;
    
    memset(&CachedAC, 0, sizeof (CachedAC));
    memset(&entry, 0, sizeof(entry));
    memset(&selection, 0, sizeof(selection));
    selection.attSel = EN_ATTSET_LIST;
    selection.infoTypes = EN_INFOTYPES_MAPINAMES;

    __try {

        // A brief preliminary 
        if(dwEphsCount) {
            // We are in a restricted list.
            if(!lpdwEphs) {
                // But, we have no restricted list.
                return MAPI_E_CALL_FAILED;
            }
            // We're in a restriction.  We won't be giving back anymore than
            // what we were given.
            Count = min(Count, dwEphsCount);
        }
        
        // build a selection argument for GetEntInf
        selection.AttrTypBlock.attrCount = pPropTags->cValues;
        selection.AttrTypBlock.pAttr = (ATTR *)THAllocEx(pTHS, pPropTags->cValues *
                                                          sizeof(ATTR));

        for (i = 0; i < pPropTags->cValues; i++)  {
            BOOL fSingle =
                (PROP_TYPE(pPropTags->aulPropTag[i])& MV_FLAG ? FALSE : TRUE  );
            
            tempSyntax = PROP_TYPE(pPropTags->aulPropTag[i]) & ~(MV_FLAG);
            
            pAC = SCGetAttByMapiId(pTHS, PROP_ID(pPropTags->aulPropTag[i]));

            selection.AttrTypBlock.pAttr[i].attrTyp = INVALID_ATT;
            
            if (pAC) {
                /* The MAPI-ID refers to something we have in the cache */
                tempSyntax2 = ABMapiSyntaxFromDSASyntax(Flags,
                                                        pAC->syntax,
                                                        pAC->ulLinkID, 
                                                        tempSyntax);
                
                if(tempSyntax == PT_UNSPECIFIED) {
                    tempSyntax = tempSyntax2;
                    
                    pPropTags->aulPropTag[i] =
                        PROP_TAG(tempSyntax | (fSingle ? 0 : MV_FLAG),
                                 PROP_ID(pPropTags->aulPropTag[i]));
                }
                
                /* Verify the syntaxes, assume they're wrong */
                if((tempSyntax == tempSyntax2) ||
                   (tempSyntax == PT_STRING8 && tempSyntax2 == PT_UNICODE) ||
                   (tempSyntax2 == PT_STRING8 && tempSyntax == PT_UNICODE)   ) {
                    
                    if((!fSingle && !pAC->isSingleValued) ||
                       ( fSingle &&  pAC->isSingleValued) ||
                       ( tempSyntax == PT_OBJECT        )    )
                        // OK, the syntaxes are correct, so add this to the list
                        // properties we're going to read.
                        selection.AttrTypBlock.pAttr[i].attrTyp = pAC->id;
                }
            }
        }

        
        /* Allocate room for an SRowSet */
        tempSRowSet = (LPSRowSet_r)THAllocEx(pTHS, sizeof(SRowSet_r) +
                                             Count * sizeof(SRow_r));
        tempSRowSet->cRows = Count;
        
        if(!dwEphsCount)  {
            /* Not a restriction, so set position to the position specified
             * in the stat block
             */
            ABGotoStat(pTHS, pStat, pIndexSize, NULL);
            if(pTHS->fEOF)  {
                tempSRowSet->cRows = 0;
                _leave;
            }
            pTHS->pDB->JetNewRec = FALSE;
            pTHS->pDB->root = FALSE;
            pTHS->pDB->fFlushCacheOnUpdate = FALSE;
        }

        for(dntIndex = 0; dntIndex < Count; dntIndex++) {
            DWORD targetDNT;
            /* Allocate the room for this SROW */
            tempPropVal = THAllocEx(pTHS,
                                    sizeof(SPropValue_r) *(pPropTags->cValues));
            
            // Go to the right place in the table
            if(!dwEphsCount) {
                // Not a restriction, we should already be there.
                fFoundDNT = TRUE;
                targetDNT =  pTHS->pDB->DNT; 
            } else {
                /* A Restriction */
                
                if(!lpdwEphs[dntIndex] ||
                   DBTryToFindDNT( pTHS->pDB, lpdwEphs[dntIndex])) {
                    fFoundDNT = FALSE;
                }
                else {
                    fFoundDNT = TRUE;
                    targetDNT = lpdwEphs[dntIndex];
                }
            }

#ifdef PROCESS_PHANTOMS_ALIVE
            fProcessPhantom = FALSE;
            
            if(fFoundDNT) {
                // We're on some object make sure it's one we can see.
                if(abCheckObjRights(pTHS)) {
                    // Yep, we can see it normally.                    
                    CurrentDNT = targetDNT;
                    pStat->CurrentRec = targetDNT;
                }
                else {
                    // Wwe can't see it, so it is effectively a phantom. 
                    if(Flags & fPhantoms) {
                        fProcessPhantom = TRUE;
                    }
                    else {
                        fFoundDNT = FALSE;
                    }
                }
            }
            if(fProcessPhantom) {
                // We landed on a phantom or a tombstone, and the client
                // wants to see such things.
                scode = ProcessPhantom(pTHS,
                                       pStat->CodePage, pPropTags,tempPropVal);
            }
            else if(!fFoundDNT) {
#else
            if(fFoundDNT) {
                // We're on some object make sure it's one we can see.
                if(abCheckObjRights(pTHS)) {
                    // Yep, we can see it normally.                    
                    CurrentDNT = targetDNT;
                    pStat->CurrentRec = targetDNT;
                }
                else {
                    // Wee can't see it, so it's not there.
                    fFoundDNT = FALSE;
                }
            }
            if(!fFoundDNT) {
#endif                
                // We didn't find a row in the table, and we're not building a
                // phantom .  Build an error propval 
                for (i = 0; i < pPropTags->cValues; i++)  {
                    tempPropVal[i].ulPropTag =
                        PROP_TAG(PT_ERROR,
                                 PROP_ID(pPropTags->aulPropTag[i]));
                    tempPropVal[i].Value.err = MAPI_E_NOT_FOUND;
                    scode = MAPI_W_ERRORS_RETURNED;
                }
                fFoundDNT = TRUE;
            }
            else {
                // Ok, we are on a row, and it's one we can see.  Make the
                // GetEntInf call. 
                DWORD k;

                // First, get the security descriptor for this object.
                if (DBGetAttVal(pTHS->pDB, 1, ATT_NT_SECURITY_DESCRIPTOR,
                                DBGETATTVAL_fREALLOC, ulLen,
                                &ulLen, (PUCHAR *)&pSec)) {
                    // Every object should have an SD.
                    Assert(!DBCheckObj(pTHS->pDB));
                    ulLen = 0;
                    pSec = NULL;
                }
                
                // Now, make the getentinf call
                if (GetEntInf(pTHS->pDB,
                              &selection,
                              NULL,
                              &entry,
                              NULL,
                              0,
                              pSec,
                              0,                 // flags
                              &CachedAC,
                              NULL)) {
                    return MAPI_E_CALL_FAILED;
                }


                abGetConstructionParts(pTHS,
                                       pStat->CodePage,
                                       pSec,
                                       entry.pName,
                                       &StringDN,
                                       &DisplayNamePrintable,
                                       &DisplayNameA,
                                       &DisplayNameW,
                                       &ObjType,
                                       &DispType);
                
                // Turn the result into a MAPI style result. 
                //
                // Step Through the properties in the PropTag array, making
                // MAPI style propvals from the data we looked up in the
                // GetEntInf call.
                //
                // In this loop:
                //
                // i indexes through the proptags that we were asked for
                //
                // j indexes through the explicit ATTR array (things we read out
                //     of the database and expect to set up using
                //     MakeStoredMAPIValue) 
                //
                // pPropVal marches along through the srow we are returning so
                //     that it is always the propval to fill in right now.
                //
                
                for(i=0, j = 0, pPropVal = tempPropVal;
                    i< pPropTags->cValues;
                    i++, pPropVal++) {
                    
                    pPropVal->ulPropTag = pPropTags->aulPropTag[i];
                    pAC = SCGetAttByMapiId(pTHS, 
                                     PROP_ID(pPropTags->aulPropTag[i]));
                    
                    if((pAC) &&
                       (j < entry.AttrBlock.attrCount) &&  
                       (entry.AttrBlock.pAttr[j].attrTyp == pAC->id)) {
                        // There are explicit values left to process, and as a
                        // matter of fact the next prop tag to deal with matches
                        // the next explicit value.
                        if(MakeStoredMAPIValue(pTHS,
                                               pStat->CodePage,
                                               pPropVal,
                                               pAC,
                                               &entry.AttrBlock.pAttr[j])) {
                            
                            // Something went wrong with turning this ATTR into
                            // a propval.  Set up the error.
                            pPropVal->ulPropTag =
                                PROP_TAG(PT_ERROR,PROP_ID(pPropVal->ulPropTag));
                            pPropVal->Value.err = MAPI_E_NOT_FOUND;
                            scode = MAPI_W_ERRORS_RETURNED;
                        }

                        // No matter what, we've dealt with the next explict
                        // value. Increment the explicit value index and set up
                        // the attcache index
                        j++;
                    }
                    else if(MakeConstructedMAPIValue(pTHS,
                                                     pStat->CodePage,
                                                     pPropVal,
                                                     StringDN,
                                                     &DisplayNamePrintable,
                                                     &DisplayNameA,
                                                     &DisplayNameW,
                                                     ObjType,
                                                     DispType,
                                                     CurrentDNT,
                                                     Flags))  {
                        pPropVal->ulPropTag =
                            PROP_TAG(PT_ERROR,
                                     PROP_ID(pPropVal->ulPropTag));
                        pPropVal->Value.err = MAPI_E_NOT_FOUND;
                        scode = MAPI_W_ERRORS_RETURNED;
                    }       /* else if(MakeConst.. */
                }       /* for each proptag */

                // free ATTR
                {
                    PUCHAR puc;
                    ATTR  *pAttr;

                    for (j=0; j<entry.AttrBlock.attrCount; j++) {

                        pAttr = &entry.AttrBlock.pAttr[j];

                        for(k=0; k<pAttr->AttrVal.valCount;k++) {
                            puc = pAttr->AttrVal.pAVal[k].pVal;
                            if (puc) {
                                THFreeEx (pTHS, puc);
                            }
                            pAttr->AttrVal.pAVal[k].pVal = NULL;
                        }
                        THFreeEx (pTHS, pAttr->AttrVal.pAVal); 
                    }
                }

                THFreeEx (pTHS, entry.pName);           entry.pName = NULL;
                THFreeEx (pTHS, entry.AttrBlock.pAttr); entry.AttrBlock.pAttr = NULL;
                THFreeEx (pTHS, StringDN);              StringDN = NULL;

                THFreeEx (pTHS,DisplayNamePrintable); DisplayNamePrintable = NULL;
                THFreeEx (pTHS,DisplayNameA);         DisplayNameA = NULL;
                THFreeEx (pTHS,DisplayNameW);         DisplayNameW = NULL;
            }

            tempSRowSet->aRow[dntIndex].cValues = pPropTags->cValues;
            tempSRowSet->aRow[dntIndex].lpProps = tempPropVal;
            
            if(!dwEphsCount &&
               ABMove(pTHS, 1, pStat->ContainerID, TRUE))  {
                tempSRowSet->cRows = dntIndex + 1;
                break;                          // exit for loop
            }
        }       // for dntIndex < Count
    } __except(HandleMostExceptions(GetExceptionCode())) {
        scode = MAPI_E_NOT_ENOUGH_RESOURCES;
        tempSRowSet = NULL;
    }
    if(!dwEphsCount)
        ABGetPos(pTHS, pStat, pIndexSize);

    THFreeEx (pTHS, selection.AttrTypBlock.pAttr);
    THFreeEx (pTHS, pSec);

    THFreeEx (pTHS, CachedAC.AC);

    *Rows = tempSRowSet;
    return scode;
}

/*****************************************************************************
*   Get Properties
******************************************************************************/

SCODE
ABGetProps_local (
        THSTATE *pTHS,
        DWORD dwFlags,
        PSTAT pStat,
        PINDEXSIZE pIndexSize,
        LPSPropTagArray_r pPropTags,
        LPLPSRow_r ppRow
        )
{
    SCODE               scode;
    LPSRowSet_r		tempSRowSet;
    DWORD		dwEph;

    // First check for a null PropTag list.  If it is null, get a new one.
    if(pPropTags
        || (SUCCESS_SUCCESS == (scode = ABGetPropList_local(pTHS,
                                                            dwFlags,
                                                            pStat->CurrentRec,
                                                            pStat->CodePage,
                                                            &pPropTags)))) {

        dwEph = pStat->CurrentRec;
        scode = GetSrowSet(pTHS, pStat, pIndexSize, 1, &dwEph, 1,pPropTags,
                           &tempSRowSet, dwFlags);
        if(!scode || scode == MAPI_W_ERRORS_RETURNED) 	    // it worked.
            *ppRow = &(tempSRowSet->aRow[0]);
    }

    return(scode);
}

/*****************************************************************************
*   Get Template Info.
* General purpose routine to get template info.  The ulDispType and pDN
* together specify the template we want.  If pDN != NULL, then use it as
* the name of the template to look up.  This is the case when looking up
* addressing templates.  When pDN == NULL, use the ulDispType to make a DN
* in the display-templates container.
*
* ulFlag specifies the action to take values are:
*
* TI_HELP_FILE_16 - get the help file associated with this template.
* TI_HELP_FILE_32 - get the win32 help file associated with this template.
* TI_TEMPLATE  - get the template data associated with this template.
* TI_DOS_TEMPLATE - get the dos template data associated with this template.
*                   If the dos template doesn't exist, get the normal template.
* TI_SCRIPT    - get the addresing script associated with this template.
*
* dwCodePage and dwLocaleID are used to localize data.  Data is returned
* in ppData.
******************************************************************************/

SCODE
ABGetTemplateInfo_local (
        THSTATE *pTHS,
        NSPI_CONTEXT *pMyContext,
        DWORD dwFlags,
        ULONG ulDispType,
        LPSTR pDN,
        DWORD dwCodePage,
        DWORD dwLocaleID,
        LPSRow_r * ppData)
{
    LPSTR        psz=NULL;
    WCHAR        wcNum[ 9];
    ATTCACHE    *pAC;
    DWORD        valnum, cbSize=0;
    PDSNAME      pDN0=NULL;
    PDSNAME      pDN1;
    PDSNAME      pDN2;
    ULONG        cbDN1, cbDN2;

    if(!pDN) {
        DWORD err;

        // Find the template root and get it's name
        if((pMyContext->TemplateRoot == INVALIDDNT) ||
           (DBTryToFindDNT(pTHS->pDB, pMyContext->TemplateRoot)) ||
           (DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                        0, 0,
                        &cbSize, (PUCHAR *)&pDN0))) {
            // Huh?
            return MAPI_E_CALL_FAILED;
        }

        // Allocate more than enough space for pDN1 and pDN2
        cbDN1 = pDN0->structLen + 128*sizeof(WCHAR);
        cbDN2 = pDN0->structLen + 128*sizeof(WCHAR);

        pDN1 = (PDSNAME)THAllocEx(pTHS, cbDN1);
        pDN2 = (PDSNAME)THAllocEx(pTHS, cbDN2);
        
        //
        // Build up DN of template location, which should be
	//       /cn=<display-type>  (template object)
        //      /cn=<locale-id>      (stringized hex number)
        //     /cn=Display-Templates
        //   <DN of the templates root>
        //
        AppendRDN(pDN0, pDN1, cbDN1,
                  L"Display-Templates", 0,ATT_COMMON_NAME);
            
	_ultow(dwLocaleID, wcNum, 16);
	AppendRDN(pDN1, pDN2, cbDN2, wcNum, 0, ATT_COMMON_NAME);
        
	_ultow(ulDispType, wcNum, 16);
	AppendRDN(pDN2, pDN1, cbDN1, wcNum, 0, ATT_COMMON_NAME);

        err = DBFindDSName(pTHS->pDB, pDN1);
        THFreeEx(pTHS, pDN0);
        THFreeEx(pTHS, pDN1);
        THFreeEx(pTHS, pDN2);
	if (err) {
	    return MAPI_E_UNKNOWN_LCID;
	}
    }
    else {
        /* Go to the right object. */
	if(!ABDNToDNT(pTHS, pDN)) {
	    /* the DN points to an object that doesn't exist. */
	    return MAPI_E_UNKNOWN_LCID;
	}
    }
    
    // Ok, if we survived the above we're positioned on the template object

    *ppData = THAllocEx(pTHS, sizeof(SRow_r) +
                        TI_MAX_TEMPLATE_INFO * sizeof(SPropValue_r));
    (*ppData)->lpProps = (LPSPropValue_r) &(*ppData)[1];
    valnum = 0;
    
    /* Get the data */
    
    if(dwFlags & TI_HELPFILE_NAME) {
        BYTE data[26];
        BYTE *returnData=NULL;
        
        DBGetSingleValue( pTHS->pDB, ATT_HELP_FILE_NAME, data, 24, &cbSize);
        Assert(cbSize < 24);
        if(cbSize) {
            data[cbSize++]=0;
            data[cbSize++]=0;
            
            returnData = THAllocEx(pTHS, cbSize);
            
            (*ppData)->lpProps[valnum].ulPropTag =
                PROP_TAG(PT_STRING8,TI_HELPFILE_NAME);
            
            WideCharToMultiByte(dwCodePage, 0, (LPCWSTR)data, -1,
                                returnData, cbSize, NULL, NULL);
            
            (*ppData)->lpProps[valnum].Value.lpszA = returnData;
            valnum++;
        }
    }
    
    if(dwFlags & TI_HELPFILE32) {
        DWORD fGot32HelpFile = FALSE;
        BYTE *data=NULL;
        
        if(DB_ERR_VALUE_TRUNCATED ==
           DBGetSingleValue(pTHS->pDB,  ATT_HELP_DATA32, data, 0, &cbSize)) {
            data = THAllocEx(pTHS, cbSize);
            DBGetSingleValue(pTHS->pDB, ATT_HELP_DATA32, data, cbSize, NULL); 
            (*ppData)->lpProps[valnum].ulPropTag =
                PROP_TAG(PT_BINARY,TI_HELPFILE32);
            (*ppData)->lpProps[valnum].Value.bin.cb = cbSize;
            (*ppData)->lpProps[valnum].Value.bin.lpb = data;
            valnum++;
            fGot32HelpFile = TRUE;
        }
        if(!fGot32HelpFile) {
            dwFlags |= TI_HELPFILE16;
        }
    }
    
    if(dwFlags & TI_HELPFILE16) {
        BYTE *data=NULL;
        
        DBGetSingleValue(pTHS->pDB, ATT_HELP_DATA16, data, 0, &cbSize);
        if(cbSize) {
            data = THAllocEx(pTHS, cbSize);
            DBGetSingleValue(pTHS->pDB, ATT_HELP_DATA16, data, cbSize,NULL); 
            (*ppData)->lpProps[valnum].ulPropTag =
                PROP_TAG(PT_BINARY,TI_HELPFILE16);
            (*ppData)->lpProps[valnum].Value.bin.cb = cbSize;
            (*ppData)->lpProps[valnum].Value.bin.lpb = data;
            valnum++;
        }
    }
    
    if(dwFlags & TI_DOS_TEMPLATE) {
        DWORD fGotDosTemplate=FALSE;
        LPTRowSet pTRSet = NULL;
        
        if(DB_ERR_VALUE_TRUNCATED ==
           DBGetSingleValue(pTHS->pDB, ATT_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS,
                            pTRSet, 0, &cbSize)) {
            DWORD i;
            pTRSet = THAllocEx(pTHS, cbSize);
            DBGetSingleValue(pTHS->pDB, ATT_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS,
                             pTRSet, cbSize, NULL); 
            
            if(pTRSet->ulVersion == DSA_TEMPLATE) {
                /* The strings are in unicode.  Localize them. */
                for( i=0; i< pTRSet->cRows; i++) {
                    CHAR  psz[500];
                    LPWSTR lpwOriginal =
                        (LPWSTR)((UINT_PTR)(pTRSet) +
                              (UINT_PTR)(pTRSet->aRow[i].cnControlStruc.pszString));
                    
                    WideCharToMultiByte(dwCodePage, 0,
                                        lpwOriginal, -1,
                                        psz, 500, NULL, NULL);
                    
                    strcpy((LPSTR)lpwOriginal, psz);
                }
                
                (*ppData)->lpProps[valnum].ulPropTag =
                    PROP_TAG(PT_BINARY, TI_TEMPLATE);
                (*ppData)->lpProps[valnum].Value.bin.cb = cbSize;
                (*ppData)->lpProps[valnum].Value.bin.lpb = (BYTE *)
                    pTRSet; /* Yes, I meant to cast
                             * a trowset to a byte
                             * array. */
                valnum++;
                fGotDosTemplate=TRUE;
            }
            
        }
        
        if(!fGotDosTemplate) {
            /* We failed to get the dos template.  Fall back to the
             * standard template
             */
            dwFlags |= TI_TEMPLATE;
        }
    }
    
    if(dwFlags & TI_TEMPLATE) {
        LPTRowSet pTRSet = NULL;
        
        if(DB_ERR_VALUE_TRUNCATED ==
           DBGetSingleValue(pTHS->pDB, ATT_ADDRESS_ENTRY_DISPLAY_TABLE,
                            pTRSet, 0, &cbSize)) {
            DWORD i;
            pTRSet = THAllocEx(pTHS, cbSize);
            DBGetSingleValue(pTHS->pDB, ATT_ADDRESS_ENTRY_DISPLAY_TABLE,
                             pTRSet, cbSize,NULL);
            
            if(pTRSet->ulVersion == DSA_TEMPLATE) {
                
                /* The strings are in unicode.  Localize them. */
                for( i=0; i< pTRSet->cRows; i++) {
                    CHAR  psz[500];
                    LPWSTR lpwOriginal =
                        (LPWSTR)((UINT_PTR)(pTRSet) +
                              (UINT_PTR)(pTRSet->aRow[i].cnControlStruc.pszString));
                    
                    WideCharToMultiByte(dwCodePage, 0,
                                        lpwOriginal, -1,
                                        psz, 500, NULL, NULL);
                    
                    strcpy((LPSTR)lpwOriginal, psz);
                }
                
                (*ppData)->lpProps[valnum].ulPropTag =
                    PROP_TAG(PT_BINARY, TI_TEMPLATE);
                (*ppData)->lpProps[valnum].Value.bin.cb = cbSize;
                (*ppData)->lpProps[valnum].Value.bin.lpb = (BYTE *)
                    pTRSet; /* Yes, I meant to cast
                             * a trowset to a byte
                             * array. */
                valnum++;
            }
        }
    }
    
    if(dwFlags & TI_SCRIPT) {
        LPSPropTagArray_r pScript;
        DWORD temp;
        
        if(DB_ERR_VALUE_TRUNCATED ==
           DBGetSingleValue(pTHS->pDB, ATT_ADDRESS_SYNTAX, &temp, 0, &cbSize)) {
            /* There is a script here. */
            pScript = THAllocEx(pTHS, cbSize + sizeof(ULONG));    // alloc it
            DBGetSingleValue(pTHS->pDB, ATT_ADDRESS_SYNTAX,
                             pScript->aulPropTag, cbSize, NULL); 
            pScript->cValues = cbSize / sizeof(ULONG);
            cbSize += sizeof(ULONG);
        } else {
            /* There is no script here. */
            cbSize = 2 * sizeof(ULONG);
            pScript = THAllocEx(pTHS, cbSize);
            pScript->cValues = 1;
            pScript->aulPropTag[0] = 0;
            
        }
        
        (*ppData)->lpProps[valnum].ulPropTag =
            PROP_TAG(PT_BINARY, TI_SCRIPT);
        (*ppData)->lpProps[valnum].Value.bin.cb = cbSize;
        (*ppData)->lpProps[valnum].Value.bin.lpb = (BYTE *)pScript;
        /* Yes, I meant to  cast a prop tag array to a byte array */
        valnum++;
    }
    
    
    if(dwFlags & TI_EMT) {
        if(DB_ERR_VALUE_TRUNCATED ==
           DBGetSingleValue(pTHS->pDB, ATT_ADDRESS_TYPE, psz, 0, &cbSize)) {
            psz = THAllocEx(pTHS, cbSize+1);
            DBGetSingleValue(pTHS->pDB, ATT_ADDRESS_TYPE, psz, cbSize, NULL);
        } else {
            psz = lpszEMT_A;
        }
        
        (*ppData)->lpProps[valnum].ulPropTag =
            PROP_TAG(PT_STRING8, TI_EMT);
        (*ppData)->lpProps[valnum].Value.lpszA = psz;
        valnum++;
    }
    
    (*ppData)->cValues = valnum;
    
    return SUCCESS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\sdprop\propdmon.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       propdmon.c
//
//--------------------------------------------------------------------------

/*

Description:

    Implements the Security Descriptor Propagation Daemon.


*/


#include <NTDSpch.h>
#pragma  hdrstop

#include <sddl.h>

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "dsexcept.h"
#include "mdcodes.h"                    // header for error codes
#include "ntdsctr.h"
#include "taskq.h"

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected atts
#include "anchor.h"
#include "drautil.h"
#include <permit.h>                     // permission constants
#include "sdpint.h"
#include "sdprop.h"
#include "checkacl.h"

#include "debug.h"                      // standard debugging header
#define DEBSUB "SDPROP:"                // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_PROPDMON

#define SDPROP_RETRY_LIMIT  1000

#define SDP_CLIENT_ID ((DWORD)(-1))

extern
DWORD
DBPropExists (
        DBPOS * pDB,
        DWORD DNT
        );

// The security descriptor propagator is a single threaded daemon.  It is
// responsible for propagating changes in security descriptors due to ACL
// inheritance.  It is also responsible for propagating changes to ancestry due
// to moving and object in the DIT.  It makes use of four buffers, two for
// holding SDs, two for holding Ancestors values.  There are two buffers that
// hold the values that exist on the parent of the current object being
// fixed up, and two that hold scratch values pertaining to the current object.
// Since the SDP is single threaded, we make use of a set of global
// variables to track these four buffers.  This avoids a lot of passing of
// variables up and down the stack.
//
DWORD  sdpCurrentPDNT = 0;
DWORD  sdpCurrentDNT = 0;

// This triplet  tracks the security descriptor of the object whose DNT is
// sdpCurrentPDNT.
DWORD  sdpcbCurrentParentSDBuffMax = 0;
DWORD  sdpcbCurrentParentSDBuff = 0;
PUCHAR sdpCurrentParentSDBuff = NULL;

// This triplet tracks the ancestors of the object whose DNT is sdpCurrentPDNT.
DWORD  sdpcbAncestorsBuffMax=0;
DWORD  sdpcbAncestorsBuff=0;
DWORD  *sdpAncestorsBuff=NULL;

// This triplet tracks the security descriptor of the object being written in
// sdp_WriteNewSDAndAncestors.  It's global so that we can reuse the buffer.
DWORD  sdpcbScratchSDBuffMax=0;
DWORD  sdpcbScratchSDBuff=0;
PUCHAR sdpScratchSDBuff=NULL;

// This triplet tracks the ancestors of the object being written in
// sdp_WriteNewSDAndAncestors.  It's global so that we can reuse the buffer.
DWORD  sdpcbScratchAncestorsBuffMax;
DWORD  sdpcbScratchAncestorsBuff;
DWORD  *sdpScratchAncestorsBuff = NULL;

// this triplet tracks the object types passed in mergesecuritydescriptors
GUID         **sdpClassGuid = NULL;
DWORD          sdcClassGuid=0,  sdcClassGuid_alloced=0;


BOOL   sdp_DidReEnqueue = FALSE;
BOOL   sdp_DoingNewAncestors;
BOOL   sdp_PropToLeaves = TRUE;
DWORD  sdp_Flags;

HANDLE hevSDPropagatorDead;
HANDLE hevSDPropagationEvent;
HANDLE hevSDPropagatorStart;
extern HANDLE hServDoneEvent;

/* Internal functions */

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

ULONG   gulValidateSDs = 0;             // see heurist.h
BOOL    fBreakOnSdError = FALSE;

#if DBG
#define SD_BREAK DebugBreak()
#else
#define SD_BREAK if ( fBreakOnSdError ) DebugBreak()
#endif

// Set the following to 1 in the debugger and the name of each object
// written by the SD propagator will be emitted to the debugger.  Really
// slows things down so use sparingly.  Set to 0 to stop verbosity.

DWORD   dwSdAppliedCount = 0;

// Set the following to TRUE in the debugger to get a synopsis of each
// propagation - DNT, count of objects, retries, etc.

BOOL fSdSynopsis = FALSE;

// The following variables can be global as there is only
// one sdprop thread - so no concurrency issues.

DSNAME  *pLogStringDN = NULL;
ULONG   cbLogStringDN = 0;
CHAR    rLogDntDN[sizeof(DSNAME) + 100];
DSNAME  *pLogDntDN = (DSNAME *) rLogDntDN;


DWORD
sdp_GetPropInfoHelp(
        THSTATE    *pTHS,
        BOOL       *pbSkip,
        SDPropInfo *pInfo,
        DWORD       LastIndex
        );

/*++
Grow the global debug print buffer if necessary.
--*/
static
DSNAME *
GrowBufIfNecessary(
    ULONG   len
    )
{
    VOID    *pv;

    if ( len > cbLogStringDN )
    {
        if ( NULL == (pv = realloc(pLogStringDN, len)) )
        {
            return(NULL);
        }

        pLogStringDN = (DSNAME *) pv;
        cbLogStringDN = len;
    }

    return(pLogStringDN);
}

/*++
Derive either a good string name or a DSNAME whose string name
contains DNT=xxx for debug print and logging.
--*/
DSNAME *
GetDSNameForLogging(
    DBPOS   *pDB
    )
{
    DWORD   err;
    ULONG   len = 0;
    DSNAME  *pDN = NULL;

    Assert(VALID_DBPOS(pDB));

    err = DBGetAttVal(pDB, 1, ATT_OBJ_DIST_NAME, 0, 0, &len, (UCHAR **) &pDN);

    if ( err || !GrowBufIfNecessary(pDN->structLen) )
    {
        // construct DN in static buff which encodes DNT only
        memset(rLogDntDN, 0, sizeof(rLogDntDN));
        swprintf(pLogDntDN->StringName, L"DNT=0x%x", pDB->DNT);
        pLogDntDN->NameLen = wcslen(pLogDntDN->StringName);
        pLogDntDN->structLen = DSNameSizeFromLen(pLogDntDN->NameLen);
        if ( !err ) THFreeEx(pDB->pTHS,pDN);
        return(pLogDntDN);
    }

    // construct string DN
    memcpy(pLogStringDN, pDN, pDN->structLen);
    THFreeEx(pDB->pTHS,pDN);
    return(pLogStringDN);
}

#if DBG

VOID
sdp_CheckAclInheritance(
    PSECURITY_DESCRIPTOR pParentSD,
    PSECURITY_DESCRIPTOR pOldSD,
    PSECURITY_DESCRIPTOR pNewSD,
    GUID                *pChildClassGuid,
    AclPrintFunc        pfn,
    BOOL                fContinueOnError,
    DWORD               *pdwLastError
    )
/*++
    Perform various checks which to prove that all the ACLs which should have
    been inherited by child object really have been.
--*/
{
#if INCLUDE_UNIT_TESTS
    DWORD                   AclErr;

    AclErr = CheckAclInheritance(pParentSD, pNewSD, pChildClassGuid,
                                 DbgPrint, FALSE, FALSE, pdwLastError);
    if ( AclErr != AclErrorNone ) {
        DbgPrint("CheckAclInheritance error %d for DNT 0x%x\n",
                 AclErr, sdpCurrentDNT);
        Assert(!"Calculated ACL is wrong.");
        LogUnhandledError(AclErr);
    }
#endif
}

VOID
sdp_VerifyCurrentPosition (
        THSTATE *pTHS,
        ATTCACHE *pAC
        )
/*++
    Verify that global buffers truly contain values for the current parent
    and child being processed.  Do so in a separate DBPOS so as not to
    disturb the primary DBPOS' position and to insure "independent
    verification" by virtue of a new transaction level.
--*/
{
    DWORD  CurrentDNT = pTHS->pDB->DNT;
    DBPOS  *pDBTemp;
    DWORD  cbLocalSDBuff = 0;
    PUCHAR pLocalSDBuff = NULL;
    DWORD  cLocalParentAncestors=0;
    DWORD  cbLocalAncestorsBuff=0;
    DWORD  *pLocalAncestorsBuff=NULL;
    DWORD  err;
    BOOL   fCommit = FALSE;
    DWORD  it;
    DWORD  propNotExists = 0;

    // We have been called with an open transaction in pTHS->pDB.
    // The transaction we are about to begin via DBOpen2 is not a nested
    // transaction within the pTHS->pDB transaction, but is rather a
    // completely new transaction.  Thus pDBTemp is completely independent
    // of pTHS->pDB, and since pTHS->pDB has not committed yet, pDBTemp
    // does not see any of the writes already performed by pTHS->pDB.

    DBOpen2(TRUE, &pDBTemp);
    __try {

        // check to see if we are positioned on the object we say we are
        //
        if(CurrentDNT != sdpCurrentDNT) {
            Assert(!"Currency wrong");
            __leave;
        }

        // position on the object we are interested in the new transaction
        //
        if(err = DBTryToFindDNT(pDBTemp, CurrentDNT)) {
            Assert(!"Couldn't find current DNT");
            LogUnhandledError(err);
            __leave;
        }

        // see if we have a enqueued propagation for the object sdpCurrentPDNT
        // DBPropExists returns TRUE if a propagation for the object in question
        // object DOES NOT EXIST in JetSDPropTbl table

        // This operation does not reposition pDBTemp on JetObjTbl.
        // It only affects JetSDPropTbl.
        propNotExists = DBPropExists(pDBTemp, sdpCurrentPDNT) != 0;



        // then check to see if the positioned object has the same parent
        // as we think it has

        // there is the possibility that the object in question has been moved
        // between when pTHS->pDB and pDBTemp were opened, so we check that there
        // is no pending propagation for this

        if(pDBTemp->PDNT != pTHS->pDB->PDNT && propNotExists) {
            Assert(!"Current parent not correct");
            err = ERROR_DS_DATABASE_ERROR;
            LogUnhandledError(err);
            __leave;
        }

        // position on the parent
        //
        if(err = DBTryToFindDNT(pDBTemp, pDBTemp->PDNT)) {
            Assert(!"Couldn't find current parent");
            LogUnhandledError(err);
            __leave;
        }


        // check the parent one more time. this might be different as mentioned before

        if(pDBTemp->DNT != sdpCurrentPDNT && propNotExists) {
            Assert(!"Current global parent not correct");
            LogUnhandledError(err);
            __leave;
        }


        // allocate space for the Ancestors
        //
        cbLocalAncestorsBuff = 25 * sizeof(DWORD);
        pLocalAncestorsBuff = (DWORD *) THAllocEx(pTHS, cbLocalAncestorsBuff);


        // We are reading the ancestors of pDBTemp which is now positioned
        // at the same DNT as pTHS->pDB->PDNT.

        DBGetAncestors(
                pDBTemp,
                &cbLocalAncestorsBuff,
                &pLocalAncestorsBuff,
                &cLocalParentAncestors);



        if(propNotExists) {
            // The in memory parent ancestors is different from
            // the DB parent ancestors when the parent has been moved.
            // Check that if the ancestors are different (in size or value)
            // then there is an enqueued propagation from the parent.

            if (sdpcbAncestorsBuff != cbLocalAncestorsBuff) {
                Assert(!"Ancestors buff size mismatch");
            }
            else {
                if(memcmp(pLocalAncestorsBuff,
                       sdpAncestorsBuff,
                       cbLocalAncestorsBuff)) {
                    Assert(!"Ancestors buff bits mismatch");
                }
            }
        }
        else {
            // in case there is a pending propagation, the data should be different.

            if (sdp_DoingNewAncestors) {
                if ( (sdpcbAncestorsBuff == cbLocalAncestorsBuff) &&
                     !memcmp(pLocalAncestorsBuff,
                       sdpAncestorsBuff,
                       cbLocalAncestorsBuff)) {
                            DPRINT1 (0, "Ancestors buff size or bits should be different: DNT=%d\n", CurrentDNT);

                }
            }
        }

        THFreeEx(pTHS, pLocalAncestorsBuff);


        if(DBGetAttVal_AC(pDBTemp,
                          1,
                          pAC,
                          DBGETATTVAL_fREALLOC,
                          cbLocalSDBuff,
                          &cbLocalSDBuff,
                          &pLocalSDBuff)) {
            // No ParentSD
            if(sdpcbCurrentParentSDBuff) {
                // But there was supposed to be one
                Assert(!"Failed to read SD");
            }
            cbLocalSDBuff = 0;
            pLocalSDBuff = NULL;
        }


        // if we don't have an enqueued propagation on the parent,
        // we have to check for SD validity
        if (propNotExists) {

            // Get the instance type
            err = DBGetSingleValue(pDBTemp,
                                   ATT_INSTANCE_TYPE,
                                   &it,
                                   sizeof(it),
                                   NULL);

            switch(err) {
            case DB_ERR_NO_VALUE:
                // No instance type is an uninstantiated object
                it = IT_UNINSTANT;
                err=0;
                break;

            case 0:
                // No action.
                break;

            case DB_ERR_VALUE_TRUNCATED:
            default:
                // Something unexpected and bad happened.  Bail out.
                LogUnhandledErrorAnonymous(err);
                __leave;
            }


            // If the parent is in another NC, the in memory SD is NULL
            // and the SD in the DB is not NULL.
            // Check for the instance type of the object, and if IT_NC_HEAD,
            // verify that the in memory parent SD is NULL.
            if (sdpcbCurrentParentSDBuff != cbLocalSDBuff) {
                if ((it & IT_NC_HEAD) && (sdpcbCurrentParentSDBuff != 0)) {

                    DPRINT2 (0, "SDP  PDNT=%x  DNT=%x  \n", sdpCurrentPDNT, CurrentDNT);
                    DPRINT6 (0, "SDP  IT:%d parent(%d)=%x local(%d)=%x   exists:%d\n",
                         it, sdpcbCurrentParentSDBuff, sdpCurrentParentSDBuff,
                         cbLocalSDBuff, pLocalSDBuff, propNotExists);

                    Assert (!"In-memory Parent SD should be NULL. NC Head case");
                }
                else
                    Assert(!"SD buff size mismatch");
            }
            else if(memcmp(pLocalSDBuff, sdpCurrentParentSDBuff, cbLocalSDBuff)) {
                Assert(!"SD buff bits mismatch");
            }
        }

        if(pLocalSDBuff) {
            THFreeEx(pTHS, pLocalSDBuff);
        }

        fCommit = TRUE;

    }
    __finally {
        err = DBClose(pDBTemp, fCommit);
        Assert(!err);
    }
}

#endif  // DBG

/*++
Perform various sanity checks on security descriptors.  Violations
will cause DebugBreak if fBreakOnSdError is set.
--*/
VOID
ValidateSD(
    DBPOS   *pDB,
    VOID    *pv,
    DWORD   cb,
    CHAR    *text,
    BOOL    fNullOK
    )
{
    PSECURITY_DESCRIPTOR        pSD = pv;
    ACL                         *pDACL = NULL;
    BOOLEAN                     fDaclPresent = FALSE;
    BOOLEAN                     fDaclDefaulted = FALSE;
    NTSTATUS                    status;
    ULONG                       revision;
    SECURITY_DESCRIPTOR_CONTROL control;

    // No-op if neither heuristic nor debug break flag is set.

    if ( !gulValidateSDs && !fBreakOnSdError )
    {
        return;
    }

    // Parent SD can be legally NULL - caller tells us via fNullOK.

    if ( !pSD || !cb )
    {
        if ( !fNullOK )
        {
            DPRINT2(0, "SDP: Null SD (%s) for \"%ws\"\n",
                    text, (GetDSNameForLogging(pDB))->StringName);
        }

        return;
    }

    // Does base NT like this SD?

    status = RtlValidSecurityDescriptor(pSD);

    if ( !NT_SUCCESS(status) )
    {
        DPRINT3(0, "SDP: Error(0x%x) RtlValidSD (%s) for \"%ws\"\n",
                status, text, (GetDSNameForLogging(pDB))->StringName);
        SD_BREAK;
        return;
    }

    // Every SD should have a control field.

    status = RtlGetControlSecurityDescriptor(pSD, &control, &revision);

    if ( !NT_SUCCESS(status) )
    {
        DPRINT3(0, "SDP: Error(0x%x) getting SD control (%s) for \"%ws\"\n",
                status, text, (GetDSNameForLogging(pDB))->StringName);
        SD_BREAK;
        return;
    }

    // Emit warning if protected bit is set as this stops propagation
    // down the tree.

    if ( control & SE_DACL_PROTECTED )
    {
        DPRINT2(0, "SDP: Warning SE_DACL_PROTECTED (%s) for \"%ws\"\n",
                text, (GetDSNameForLogging(pDB))->StringName);
    }

    // Every SD in the DS should have a DACL.

    status = RtlGetDaclSecurityDescriptor(
                            pSD, &fDaclPresent, &pDACL, &fDaclDefaulted);

    if ( !NT_SUCCESS(status) )
    {
        DPRINT3(0, "SDP: Error(0x%x) getting DACL (%s) for \"%ws\"\n",
                status, text, (GetDSNameForLogging(pDB))->StringName);
        SD_BREAK;
        return;
    }

    if ( !fDaclPresent )
    {
        DPRINT2(0, "SDP: No DACL (%s) for \"%ws\"\n",
                text, (GetDSNameForLogging(pDB))->StringName);
        SD_BREAK;
        return;
    }

    // A NULL Dacl is equally bad.

    if ( NULL == pDACL )
    {
        DPRINT2(0, "SDP: NULL DACL (%s) for \"%ws\"\n",
                text, (GetDSNameForLogging(pDB))->StringName);
        SD_BREAK;
        return;
    }
    // A DACL without any ACEs is just as bad as no DACL at all.

    if ( 0 == pDACL->AceCount )
    {
        DPRINT2(0, "SDP: No ACEs in DACL (%s) for \"%ws\"\n",
                text, (GetDSNameForLogging(pDB))->StringName);
        SD_BREAK;
        return;
    }
}

BOOL
sdp_IsValidChild (
        THSTATE *pTHS
        )
/*++
  Routine Description:

  Checks that the current object in the DB is:
     1) In the same NC,
     2) A real object
     3) Not deleted.

Arguments:

Return Values:
    True/false as appropriate.

--*/
{
    // Jet does not guarantee to leave the output buffer as-is in the case
    // of a missing value.  So need to test DBGetSingleValue return code.

    DWORD err;

    DWORD val=0;
    CHAR objVal = 0;

    // check to see is object is deleted. if deleted we don't do propagation.
    // if this object happens to have any childs, they should have been to
    // the lostAndFound container

    if(sdp_PropToLeaves) {
        // All children must be considered if we're doing propagation all the
        // way to the leaves.
        return TRUE;
    }

    if(sdp_DoingNewAncestors) {
        // All children must be considered if we're doing ancestors propagation
        return TRUE;
    }


    err = DBGetSingleValue(pTHS->pDB,
                           FIXED_ATT_OBJ,
                           &objVal,
                           sizeof(objVal),
                           NULL);

    // Every object should have an obj attribute.
    Assert(!err);

    if (err) {
        DPRINT2(0, "SDP: Error(0x%x) reading FIXED_ATT_OBJ on \"%ws\"\n",
                err, (GetDSNameForLogging(pTHS->pDB))->StringName);
        SD_BREAK;
    }

    if(!objVal) {
        return FALSE;
    }

    // It's an object.
    val = 0;
    err = DBGetSingleValue(pTHS->pDB,
                           ATT_INSTANCE_TYPE,
                           &val,
                           sizeof(val),
                           NULL);

    // Every object should have an instance type.
    Assert(!err);

    if (err) {
        DPRINT2(0, "SDP: Error(0x%x) reading ATT_INSTANCE_TYPE on \"%ws\"\n",
                err, (GetDSNameForLogging(pTHS->pDB))->StringName);
        SD_BREAK;
    }

    // Get the instance type.
    if(val & IT_NC_HEAD) {
        return FALSE;
    }

    // Ok, it's not a new NC
    // if we are doing a forceUpdate propagation, we WANT to update deleted objects as well
    if (!(sdp_Flags & SD_PROP_FLAG_FORCEUPDATE)) {
        val = 0;
        err = DBGetSingleValue(pTHS->pDB,
                               ATT_IS_DELETED,
                               &val,
                               sizeof(val),
                               NULL);

        if((DB_success == err) && val) {
            return FALSE;
        }
    }

    return TRUE;
}

DWORD
sdp_WriteNewSDAndAncestors(
        IN  THSTATE  *pTHS,
        IN  ATTCACHE *pAC,
        OUT DWORD    *pdwChangeType
        )
/*++
Routine Description:
    Does the computation of a new SD for the current object in the DB, then
    writes it if necessary.  Also, does the same thing for the Ancestors
    column.  Returns what kind of change was made via the pdwChangeType value.

Arguments:
    pAC        - attcache pointer of the Security Descriptor att.
    ppObjSD    - pointer to pointer to the bytes of the objects SD.  Done this
                 way to let the DBLayer reuse the memory associated with
                 *ppObjSD everytime this routine is called.
    cbParentSD - size of current *ppObjSD
    pdwChangeType - return whether the object got a new SD and/or a new
                 ancestors value.

Return Values:
    0 if all went well.
    A non-zero error return indicates a problem that should trigger the
    infrequent retry logic in SDPropagatorMain (e.g. we read the instance type
    and get back the jet error VALUE_TRUNCATED.)
    An exception is generated for errors that are transient, and likely to be
    fixed up by a retry.

--*/
{
    PSECURITY_DESCRIPTOR pNewSD=NULL;
    ULONG  cbNewSD;
    DWORD  err;
    CLASSCACHE *pClassSch = NULL;
    ULONG       ObjClass;
    BOOL  flags = 0;
    DWORD it=0;
    BOOL fHadSD = TRUE;
    DWORD AclErr, dwLastError;
    ATTRTYP objClass;
    ATTCACHE            *pObjclassAC = NULL;
    DWORD    i;
    GUID     **ppGuidTemp;
    // the objectClass info of the object we are visiting
    ATTRTYP       *sdpObjClasses = NULL;
    CLASSCACHE   **sdppObjClassesCC = NULL;
    DWORD          sdcObjClasses=0, sdcObjClasses_alloced=0;
    BOOL           fIsDeleted = FALSE;


    // Get the instance type
    err = DBGetSingleValue(pTHS->pDB,
                           ATT_INSTANCE_TYPE,
                           &it,
                           sizeof(it),
                           NULL);
    switch(err) {
    case DB_ERR_NO_VALUE:
        // No instance type is an uninstantiated object
        it = IT_UNINSTANT;
        err=0;
        break;

    case 0:
        // No action.
        break;

    case DB_ERR_VALUE_TRUNCATED:
    default:
        // Something unexpected and bad happened.  Bail out.
        LogUnhandledErrorAnonymous(err);
        return err;
    }

    if (sdp_Flags & SD_PROP_FLAG_FORCEUPDATE) {
        // if we are doing forceUpdate, we can get here with a deleted object.
        // in this case, all we want to do is to rewrite the SD without
        // merging it with the parent
        err = DBGetSingleValue(pTHS->pDB,
                               ATT_IS_DELETED,
                               &fIsDeleted,
                               sizeof(fIsDeleted),
                               NULL);
        if (err == DB_ERR_NO_VALUE) {
            fIsDeleted = FALSE;
            err = DB_success;
        }
        Assert(err == DB_success);
    }

    // See if we need to do new ancestry.  We do this even if the object is
    // uninstantiated in order to keep the ancestry correct.
    // Don't do it for deleted objects
    if(sdpcbAncestorsBuff && !fIsDeleted) {
        DWORD cObjAncestors;
        // Yep, we at least need to check

        // Get the objects ancestors.  DBGetAncestors succeeds or excepts.
        sdpcbScratchAncestorsBuff = sdpcbScratchAncestorsBuffMax;
        Assert(sdpcbScratchAncestorsBuff);

        // read the ancestors of the current object
        DBGetAncestors(pTHS->pDB,
                       &sdpcbScratchAncestorsBuff,
                       &sdpScratchAncestorsBuff,
                       &cObjAncestors);
        sdpcbScratchAncestorsBuffMax = max(sdpcbScratchAncestorsBuffMax,
                                        sdpcbScratchAncestorsBuff);

        // if the ancestors we read are not one more that the parent's ancestors OR
        // the last stored ancestor is not the current object OR
        // the stored ancestors are totally different that the in memory ancestors

        if((sdpcbAncestorsBuff + sizeof(DWORD) != sdpcbScratchAncestorsBuff) ||
           (sdpScratchAncestorsBuff[cObjAncestors - 1] != pTHS->pDB->DNT)  ||
           (memcmp(sdpScratchAncestorsBuff,
                   sdpAncestorsBuff,
                   sdpcbAncestorsBuff))) {
            // Drat.  The ancestry is incorrect.

            // adjust the buffer size
            sdpcbScratchAncestorsBuff = sdpcbAncestorsBuff + sizeof(DWORD);
            if(sdpcbScratchAncestorsBuff > sdpcbScratchAncestorsBuffMax) {
                sdpScratchAncestorsBuff = THReAllocEx(pTHS,
                                                    sdpScratchAncestorsBuff,
                                                    sdpcbScratchAncestorsBuff);
                sdpcbScratchAncestorsBuffMax = sdpcbScratchAncestorsBuff;
            }

            // copy the calculated ancestors to the buffer and add ourself to the end
            memcpy(sdpScratchAncestorsBuff, sdpAncestorsBuff, sdpcbAncestorsBuff);
            sdpScratchAncestorsBuff[(sdpcbScratchAncestorsBuff/sizeof(DWORD)) - 1] =
                pTHS->pDB->DNT;

            // Reset the ancestors.  Succeeds or excepts.
            DBResetAtt(pTHS->pDB,
                       FIXED_ATT_ANCESTORS,
                       sdpcbScratchAncestorsBuff,
                       sdpScratchAncestorsBuff,
                       0);

            flags |= SDP_NEW_ANCESTORS;
            // We need to know if any of our propagations did new ancestry.
            sdp_DoingNewAncestors = TRUE;
        }
    }

    if(!(it&IT_UNINSTANT)) {
        // It has an instance type and therefore is NOT a phantom.
        DWORD cbParentSDUsed;
        PUCHAR pParentSDUsed;

        // The instance type of the object says we need to check for a Security
        // Descriptor propagation, if the SD has changed.
        if((it & IT_NC_HEAD) || fIsDeleted) {
            // This object is a new nc boundary.  SDs don't propagate over NC
            // boundaries.
            // Also, don't propagate into deleted objects
            pParentSDUsed = NULL;
            cbParentSDUsed = 0;
        }
        else {
            pParentSDUsed = sdpCurrentParentSDBuff;
            cbParentSDUsed = sdpcbCurrentParentSDBuff;
        }

        // Get the SD on the object.
        err = DBGetAttVal_AC(pTHS->pDB,
                             1,
                             pAC,
                             DBGETATTVAL_fREALLOC,
                             sdpcbScratchSDBuffMax,
                             &sdpcbScratchSDBuff,
                             &sdpScratchSDBuff);
        switch (err) {
        case 0:
            // No action
            sdpcbScratchSDBuffMax = max(sdpcbScratchSDBuffMax,
                                        sdpcbScratchSDBuff);
            break;
        default:
            // Object has no SD
            // Note that it's possible for the SD propagator to enqueue a DNT
            // corresponding to an object and for that object to be demoted to a
            // phantom before its SD is actually propagated (e.g., if that
            // object is in a read-only NC and the GC is demoted).  However, the
            // instance type shouldn't be filled in on such an object, and we
            // are sure that this object has an instance type and that it's
            // instance type is not IT_UNINSTANT.  That make this an anomolous
            // case (read as error).

            // What we're going to do about it is this:
            // 1) Use the default SD created for just such an incident.
            // 2) Log loudly that this occurred, since it can result in the SD
            //    being inconsistent on different machines.

            fHadSD = FALSE;

            if(sdpcbScratchSDBuffMax  < cbNoSDFoundSD) {
                if(sdpScratchSDBuff) {
                    sdpScratchSDBuff = THReAllocEx(pTHS,
                                                   sdpScratchSDBuff,
                                                   cbNoSDFoundSD);
                }
                else {
                    sdpScratchSDBuff = THAllocEx(pTHS,
                                                 cbNoSDFoundSD);
                }

                sdpcbScratchSDBuffMax = cbNoSDFoundSD;
            }
            sdpcbScratchSDBuff = cbNoSDFoundSD;
            memcpy(sdpScratchSDBuff, pNoSDFoundSD, cbNoSDFoundSD);

            DPRINT2(0, "SDP: Warning(0x%x) reading SD on \"%ws\"\n",
                    err, (GetDSNameForLogging(pTHS->pDB))->StringName);
//            SD_BREAK;
            LogAndAlertEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_SDPROP_NO_SD,
                             szInsertDN(GetDSNameForLogging(pTHS->pDB)),
                             szInsertHex(err),
                             NULL);

        }

        if (!fIsDeleted) {
            // get the needed information for the objectClass on this object
            if (! (pObjclassAC = SCGetAttById(pTHS, ATT_OBJECT_CLASS)) ) {
                err = ERROR_DS_OBJ_CLASS_NOT_DEFINED;
                SD_BREAK;
                LogAndAlertEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                                 DS_EVENT_SEV_ALWAYS,
                                 DIRLOG_SDPROP_OBJ_CLASS_PROBLEM,
                                 szInsertDN(GetDSNameForLogging(pTHS->pDB)),
                                 szInsertHex(err),
                                 NULL);
                goto End;
            }

            sdcObjClasses = 0;

            if (err = ReadClassInfoAttribute (pTHS->pDB,
                                        pObjclassAC,
                                        &sdpObjClasses,
                                        &sdcObjClasses_alloced,
                                        &sdcObjClasses,
                                        &sdppObjClassesCC) ) {

                err = ERROR_DS_OBJ_CLASS_NOT_DEFINED;
                SD_BREAK;
                LogAndAlertEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                                 DS_EVENT_SEV_ALWAYS,
                                 DIRLOG_SDPROP_OBJ_CLASS_PROBLEM,
                                 szInsertDN(GetDSNameForLogging(pTHS->pDB)),
                                 szInsertHex(err),
                                 NULL);
                goto End;
            }

            if (!sdcObjClasses) {
                // Object has no object class that we could get to.
                //
                // Note that it's possible for the SD propagator to enqueue a DNT
                // corresponding to an object and for that object to be demoted to a
                // phantom before its SD is actually propagated (e.g., if that
                // object is in a read-only NC and the GC is demoted).  However, the
                // instance type shouldn't be filled in on such an object, and we
                // are sure that this object has an instance type and that it's
                // instance type is not IT_UNINSTANT.  That make this an anomolous
                // case (read as error).
                err = ERROR_DS_OBJ_CLASS_NOT_DEFINED;
                DPRINT2(0, "SDP: Error(0x%x) reading ATT_OBJECT_CLASS on \"%ws\"\n",
                        err,
                        (GetDSNameForLogging(pTHS->pDB))->StringName);
                SD_BREAK;
                LogAndAlertEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                                 DS_EVENT_SEV_ALWAYS,
                                 DIRLOG_SDPROP_OBJ_CLASS_PROBLEM,
                                 szInsertDN(GetDSNameForLogging(pTHS->pDB)),
                                 szInsertHex(err),
                                 NULL);

                goto End;
            }

            ObjClass = sdpObjClasses[0];
            pClassSch = SCGetClassById(pTHS, ObjClass);

            if(!pClassSch) {
                // Got an object class but failed to get a class cache.
                err = ERROR_DS_OBJ_CLASS_NOT_DEFINED;
                LogAndAlertEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                                 DS_EVENT_SEV_ALWAYS,
                                 DIRLOG_SDPROP_NO_CLASS_CACHE,
                                 szInsertDN(GetDSNameForLogging(pTHS->pDB)),
                                 szInsertHex(ObjClass),
                                 NULL);
                goto End;
            }

            // make room for the needed objectTypes
            if (sdcClassGuid_alloced < sdcObjClasses) {
                sdpClassGuid = (GUID **)THReAllocEx(pTHS, sdpClassGuid, sizeof (GUID*) * sdcObjClasses);
                sdcClassGuid_alloced = sdcObjClasses;
            }

            // start with the structural object Class
            ppGuidTemp = sdpClassGuid;
            *ppGuidTemp++ = &(pClassSch->propGuid);
            sdcClassGuid = 1;

            // now do the auxClasses
            if (sdcObjClasses > pClassSch->SubClassCount) {

                for (i=pClassSch->SubClassCount; i<sdcObjClasses-1; i++) {
                    *ppGuidTemp++ = &(sdppObjClassesCC[i]->propGuid);
                    sdcClassGuid++;
                }

                DPRINT1 (1, "Doing Aux Classes in SD prop: %d\n", sdcClassGuid);
            }
        }

        Assert(sdpScratchSDBuff);
        Assert(sdpcbScratchSDBuffMax);
        Assert(sdpcbScratchSDBuff);

#if DBG
        if (!fIsDeleted) {
            sdp_VerifyCurrentPosition(pTHS, pAC);
        }
#endif

        // Merge to create a new one.
        if(err = MergeSecurityDescriptorAnyClient(
                pParentSDUsed,
                cbParentSDUsed,
                sdpScratchSDBuff,
                sdpcbScratchSDBuff,
                (SACL_SECURITY_INFORMATION  |
                 OWNER_SECURITY_INFORMATION |
                 GROUP_SECURITY_INFORMATION |
                 DACL_SECURITY_INFORMATION    ),
                MERGE_CREATE | MERGE_AS_DSA,
                sdpClassGuid,
                sdcClassGuid,
                &pNewSD,
                &cbNewSD)) {
            // Failed, what do I do now?
            DPRINT2(0, "SDP: Error(0x%x) merging SD for \"%ws\"\n",
                    err, (GetDSNameForLogging(pTHS->pDB))->StringName);
            LogAndAlertEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_SDPROP_MERGE_SD_FAIL,
                             szInsertDN(GetDSNameForLogging(pTHS->pDB)),
                             szInsertHex(err),
                             NULL);
            goto End;
        }

        Assert(pNewSD);
        Assert(cbNewSD);

#if DBG
        if ( pParentSDUsed ) {
            sdp_CheckAclInheritance(pParentSDUsed,
                                    sdpScratchSDBuff,
                                    pNewSD,
                                    &(pClassSch->propGuid), DbgPrint,
                                    FALSE, &dwLastError);
        }
#endif

        // Check before and after SDs.
        ValidateSD(pTHS->pDB, pParentSDUsed, cbParentSDUsed, "parent", TRUE);
        ValidateSD(pTHS->pDB, sdpScratchSDBuff, sdpcbScratchSDBuff,
                   "object", FALSE);
        ValidateSD(pTHS->pDB, pNewSD, cbNewSD, "merged", FALSE);

        // NOTE: a memcmp of SDs can yield false negatives and label two SDs
        // different even though they just differ in the order of the ACEs, and
        // hence are really equal.  We could conceivably do a heavier weight
        // test, but it is probably not necessary.
        if(!(sdp_Flags & SD_PROP_FLAG_FORCEUPDATE) &&
           (cbNewSD == sdpcbScratchSDBuff) &&
           (memcmp(pNewSD,
                   sdpScratchSDBuff,
                   cbNewSD) == 0)) {
            // Nothing needs to be changed.
            err = 0;
            goto End;
        }

        if(fHadSD) {
            // Remove the object's current SD
            err = DBRemAttVal_AC(pTHS->pDB,
                                 pAC,
                                 sdpcbScratchSDBuff,
                                 sdpScratchSDBuff);
            switch (err) {
            case 0:
                break;
            default:
                DPRINT2(0, "SDP: Error(0x%x removing SD for \"%ws\"\n",
                        err, (GetDSNameForLogging(pTHS->pDB))->StringName);
                SD_BREAK;
                LogAndAlertEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                                 DS_EVENT_SEV_ALWAYS,
                                 DIRLOG_SDPROP_REMOVE_SD_PROBLEM,
                                 szInsertDN(GetDSNameForLogging(pTHS->pDB)),
                                 szInsertHex(err),
                                 NULL);
                goto End;
            }
        }

        // Add the new SD.
        err = DBAddAttVal_AC(pTHS->pDB, pAC, cbNewSD, pNewSD);
        switch(err) {
        case 0:
            break;
        default:
            DPRINT2(0, "SDP: Error(0x%x adding SD for \"%ws\"\n",
                    err, (GetDSNameForLogging(pTHS->pDB))->StringName);
            SD_BREAK;
            LogAndAlertEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_SDPROP_ADD_SD_PROBLEM,
                             szInsertDN(GetDSNameForLogging(pTHS->pDB)),
                             szInsertHex(err),
                             NULL);
            goto End;
        }

        DPRINT2(2, "SDP: %d - \"%ws\"\n",
                ++dwSdAppliedCount,
                (GetDSNameForLogging(pTHS->pDB))->StringName);

        // If we got here, we wrote a new SD.
        flags |= SDP_NEW_SD;
    }
 End:
     if(pNewSD) {
         DestroyPrivateObjectSecurity(&pNewSD);
     }

     if (sdpObjClasses) {
         THFreeEx (pTHS, sdpObjClasses);
     }

     if (sdppObjClassesCC) {
         THFreeEx (pTHS, sdppObjClassesCC);
     }

    *pdwChangeType = 0;
    if(!err) {
        // Looks good.  See if we did anything.
        if(flags) {
            BYTE useFlags = (BYTE)flags;
            Assert(flags <= 0xFF);
            // Reset something.  Add the timestamp
            if(sdp_PropToLeaves) {
                useFlags |= SDP_TO_LEAVES;
            }
            DBAddSDPropTime(pTHS->pDB, useFlags);

            // Close the object
            if(!(err = DBUpdateRec(pTHS->pDB))) {
                // We really managed to change something.
                *pdwChangeType = flags;
            }
        }
    }

    return err;
}

DWORD
sdp_DoPropagationEvent(
        THSTATE  *pTHS,
        BOOL     *pbRetry,
        DWORD    *pdwChangeType
        )
{
    DWORD     err=0;
    ATTCACHE *pAC;
    BOOL      fCommit = FALSE;
    // We don't have an open DBPOS here.
    Assert(!pTHS->pDB);

    // Open the transaction we use to actually write a new security
    // descriptor or Ancestors value.  Do all this in a try-finally to force
    // release of the writer lock.
    // The retry loop is because we might conflict with a modify.

    if(!SDP_EnterAddAsWriter()) {
        Assert(eServiceShutdown);
        return DIRERR_SHUTTING_DOWN;
    }


    // The wait blocked for an arbitrary time.  Refresh our timestamp in the
    // thstate.
    THRefresh();
    pAC = SCGetAttById(pTHS, ATT_NT_SECURITY_DESCRIPTOR);
    Assert(pAC);
    Assert(!pTHS->pDB);
    fCommit = FALSE;
    DBOpen2(TRUE, &pTHS->pDB);
    __try {
        // Set DB currency to the next object to modify.
        if(DBTryToFindDNT(pTHS->pDB, sdpCurrentDNT)) {
            // It's not here.  Well, we can't very well propagate any more, now
            // can we.  Just leave.
            Assert(err=0);
            fCommit = TRUE;
            __leave;
        }


        // If we are on a new parent, get the parents SD and Ancestors.  Note
        // that since siblings are grouped together, we shouldn't go in to
        // this if too often
        if(pTHS->pDB->PDNT != sdpCurrentPDNT) {
            DWORD cParentAncestors;

            // locate the parent
            DBFindDNT(pTHS->pDB, pTHS->pDB->PDNT);

            // read the ancestors
            sdpcbAncestorsBuff = sdpcbAncestorsBuffMax;
            Assert(sdpcbAncestorsBuff);
            DBGetAncestors(
                    pTHS->pDB,
                    &sdpcbAncestorsBuff,
                    &sdpAncestorsBuff,
                    &cParentAncestors);

            // adjust buffer sizes
            sdpcbAncestorsBuffMax = max(sdpcbAncestorsBuffMax,
                                        sdpcbAncestorsBuff);

            // Get the parents SD.
            if(DBGetAttVal_AC(pTHS->pDB,
                              1,
                              pAC,
                              DBGETATTVAL_fREALLOC,
                              sdpcbCurrentParentSDBuffMax,
                              &sdpcbCurrentParentSDBuff,
                              &sdpCurrentParentSDBuff)) {
                // No ParentSD
                THFreeEx(pTHS,sdpCurrentParentSDBuff);
                sdpcbCurrentParentSDBuffMax = 0;
                sdpcbCurrentParentSDBuff = 0;
                sdpCurrentParentSDBuff = NULL;
            }

            // adjust buffer sizes
            sdpcbCurrentParentSDBuffMax =
                max(sdpcbCurrentParentSDBuffMax, sdpcbCurrentParentSDBuff);


            // our parent is the current object
            sdpCurrentPDNT = pTHS->pDB->DNT;

            // Go back to the object to modify.
            DBFindDNT(pTHS->pDB, sdpCurrentDNT);
        }

        if(!sdp_IsValidChild(pTHS)) {
            // For one reason or another, we aren't interested in propagating to
            // this object.  Just leave;
            err = 0;
            fCommit = TRUE;
            __leave;
        }

        // Failures through this point are deadly.  That is, they should never
        // happen, so we don't tell our callers to retry, instead we let them
        // deal with the error as fatal.

        // OK, do the modification we keep the pObjSD in this routine to
        // allow reallocing it.
        __try {
            err = sdp_WriteNewSDAndAncestors (
                    pTHS,
                    pAC,
                    pdwChangeType);
        }
        __except(HandleMostExceptions(err= GetExceptionCode())) {
            // We failed to commit the change.  We have to retry this.
            // Is the error not getting set for some reason?
            Assert(err);
            if(!err) {
                err = ERROR_DS_UNKNOWN_ERROR;
            }
            *pbRetry = TRUE;
        }

        if(err) {
            __leave;
        }

        // If we get here, we changed and updated the object, so we might as
        // well try to trim out all instances of this change from the prop
        // queue.

        if(*pdwChangeType) {
            // Thin out any trimmable events starting from the current
            // DNT, but only do so if there was a change.  If there
            // wasn't a change but the object is in the queue, we still
            // might have to do children.  We need to do them later, so
            // don't trim them.
            // BTW, we will ignore any errors from this call, since if
            // it fails for some reason, we don't really need it to
            // succeed.
            DBThinPropQueue(pTHS->pDB,sdpCurrentDNT);
        }
        fCommit = TRUE;
    }
    __finally {
        // We always try to close the DB.  If an error has already been set, we
        // try to rollback, otherwise, we commit.

        Assert(pTHS->pDB);
        if(fCommit) {
            err = DBClose(pTHS->pDB, TRUE);
        }
        else {
            if(!err) {
                err = ERROR_DS_UNKNOWN_ERROR;
            }
            // Just try to roll it back
            DBClose(pTHS->pDB, FALSE);
        }

        SDP_LeaveAddAsWriter();
    }

    // We don't have an open DBPOS here.
    Assert(!pTHS->pDB);

    return err;
}

DWORD
sdp_DoEntirePropagation(
        IN     THSTATE     *pTHS,
        IN     SDPropInfo  Info,
        IN OUT DWORD       *pLastIndex
        )
/*++
Routine Description:
    Does the actual work of an entire queued propagation.  Note that we do not
    have a DB Open, nor are we in the Add gate as a writer (see sdpgate.c ).
    This is also the state we are in when we return.

Arguments:
    Info  - information about the current propagation.

Return Values:
    0 if all went well, an error otherwise.

--*/
{
    DWORD err;
    DWORD SaveDNT = sdpCurrentDNT;
    DWORD cObjects = 0;
    DWORD cRetries = 0;
    BOOL  fCommit;
    DWORD Num_Done = 0;
#define SDPROP_DEAD_ENDS_MAX 32
    DWORD  dwDeadEnds[SDPROP_DEAD_ENDS_MAX];
    DWORD  cDeadEnds=0;

    sdp_DoingNewAncestors = FALSE;

    // We don't have an open DBPOS here.
    Assert(!pTHS->pDB);

    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
             DS_EVENT_SEV_BASIC,
             DIRLOG_SDPROP_DOING_PROPAGATION,
             szInsertUL(Info.index),
             szInsertHex(Info.beginDNT),
             NULL);

    // Now, loop doing the modification
    err = 0;
    while(!eServiceShutdown && sdpCurrentDNT && !err) {
        DWORD dwChangeType;
        BOOL bRetry;

        if(eServiceShutdown) {
            return DIRERR_SHUTTING_DOWN;
        }

        cObjects++;

        // Ok, do a single propagation event.  It's in a loop because we might
        // have a write conflict, bRetry controls this.
        do {
            bRetry = FALSE;
            err = sdp_DoPropagationEvent(
                    pTHS,
                    &bRetry,
                    &dwChangeType
                    );

            if ( bRetry ) {
                cRetries++;
                if(cRetries > SDPROP_RETRY_LIMIT) {
                    if(!err) {
                        err = ERROR_DS_BUSY;
                    }
                    // We're not going to retry an more.
                    bRetry = FALSE;
                }
                else {
                    // We need to retry this operation.  Presumably, this is for
                    // a transient problem.  Sleep for 1 second to let the
                    // problem clean itself up.
                    _sleep(1);
                }
            }
        } while(bRetry && !eServiceShutdown);

        if(eServiceShutdown) {
            return DIRERR_SHUTTING_DOWN;
        }

        if(err) {
            // Failed to do a propagation.  Add this object to the list of nodes
            // we failed on.  If the list is too large, bail
            cDeadEnds++;
            if(cDeadEnds == SDPROP_DEAD_ENDS_MAX) {
                // Too many.  just bail.
                // We retried to often.  Error this operation out.
                LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                         DS_EVENT_SEV_BASIC,
                         DIRLOG_SDPROP_TOO_BUSY_TO_PROPAGATE,
                         szInsertUL(cRetries),
                         szInsertHex(err),
                         NULL);
            }
            else {
                // We haven't seen too many dead ends yet.  Just keep track of
                // this one.
                dwDeadEnds[(cDeadEnds - 1)] = sdpCurrentDNT;
                err = 0;
            }
        }
        else if(dwChangeType || sdp_PropToLeaves || !Num_Done) {
            // dwChangeType -> WriteNewSD wrote a new SD or ancestors, so the
            //           inheritence of SDs or ancestry will change, so we have
            //           to deal with children.
            // sdp_PropToLeaves -> we were told to not trim parts of the tree
            //           just because we think nothing has changed.  Deal with
            //           children.
            // !Num_Done -> this is the first object. If this is the first
            //           object, we go ahead and force propagation to children
            //           even if the SD on the root was correct. The SD on the
            //           root will be correct for all propagations that were
            //           triggered by a modification by a normal client, but may
            //           be incorrect for modifications triggered by replication
            //           or adds done by replication.


            fCommit = FALSE;
            Assert(!pTHS->pDB);
            DBOpen2(TRUE, &pTHS->pDB);
            __try {
                // Identify all children, adding them to the list.
                if(err = sdp_AddChildrenToList(pTHS, sdpCurrentDNT)) {
                    __leave;
                }
                fCommit = TRUE;
            }
            __finally {
                // We always try to close the DB.  If an error has already been
                // set, we try to rollback, otherwise, we commit.

                Assert(pTHS->pDB);
                if(fCommit) {
                    err = DBClose(pTHS->pDB, TRUE);
                }
                else {
                    if(!err) {
                        err = ERROR_DS_UNKNOWN_ERROR;
                    }
                    // Just try to roll it back
                    DBClose(pTHS->pDB, FALSE);
                }
            }
        }
        // ELSE
        //       there was no change to the SD of the object, we get
        //       to trim this part of the tree from the propagation

        Num_Done++;

        // inc perfcounter (counting "activity" by the sd propagator)
        PERFINC(pcSDProps);

        if(!err) {
            sdp_GetNextObject(&sdpCurrentDNT);
        }
    }

    if(eServiceShutdown) {
        // we bailed.  Return an error.
        return DIRERR_SHUTTING_DOWN;
    }

    // No open DB at this point.
    Assert(!pTHS->pDB);

    // We're done with this propagation, Unenqueue it.
    fCommit = FALSE;
    DBOpen2(TRUE, &pTHS->pDB);
    __try {

        if(err) {
            // Some sort of global errror.  We didn't finish the propagation,
            // and we don't have a nice list of nodes that were unvisited.
            // Re-enqueue the whole propagation.
            // NOTE: we are sidestepping normal procedure here by simply setting
            // the DNT in the DBPOS.  DBEnqueue reads it from there, and doesn't
            // actually require currency.  THIS IS NOT NORMAL PROCEDURE FOR
            // DBPOS CURRENCY.
            pTHS->pDB->DNT = Info.beginDNT;
            if(!sdp_DidReEnqueue) {
                DBGetLastPropIndex(pTHS->pDB, pLastIndex);
            }
            err = DBEnqueueSDPropagationEx(pTHS->pDB, FALSE, sdp_Flags);
            sdp_DidReEnqueue = TRUE;
            if(err) {
                __leave;
            }
        }
        else if(cDeadEnds) {
            // We mostly finished the propagation.  We just have a short list of
            // DNTs to propagate from that we didn't get to during this pass.
            if(!sdp_DidReEnqueue) {
                DBGetLastPropIndex(pTHS->pDB, pLastIndex);
            }
            sdp_DidReEnqueue = TRUE;
            while(cDeadEnds) {
                cDeadEnds--;
                // NOTE: we are sidestepping normal procedure here by simply
                // setting the DNT in the DBPOS.  DBEnqueue reads it from there,
                // and doesn't actually require currency.  THIS IS NOT NORMAL
                // PROCEDURE FOR  DBPOS CURRENCY.
                pTHS->pDB->DNT = dwDeadEnds[cDeadEnds];
                err = DBEnqueueSDPropagationEx (pTHS->pDB, FALSE, sdp_Flags);
                if(err) {
                    __leave;
                }
            }
        }

        // OK, we have finished as much as we can and reenqueued the necessary
        // further propagations.
        err = DBPopSDPropagation(pTHS->pDB, Info.index);
        if(err) {
            __leave;
        }

        if ( fSdSynopsis ) {
            DPRINT4(0, "SDP: DNT(0x%x) PDNT(0x%x) Objects(%d) Retries(%d)\n",
                    SaveDNT, sdpCurrentPDNT, cObjects, cRetries);
        }

        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_SDPROP_REPORT_ON_PROPAGATION,
                 szInsertUL(Info.index),
                 szInsertUL(Num_Done),
                 NULL);

        fCommit = TRUE;
    }
    __finally {
        // We always try to close the DB.  If an error has already been
        // set, we try to rollback, otherwise, we commit.

        Assert(pTHS->pDB);
        if(fCommit) {
            err = DBClose(pTHS->pDB, TRUE);
        }
        else {
            if(!err) {
                err = ERROR_DS_UNKNOWN_ERROR;
            }
            // Just try to roll it back
            DBClose(pTHS->pDB, FALSE);
        }
    }

    // OK, back to having no DBPOS
    Assert(!pTHS->pDB);

    return err;
}


void
sdp_FirstPassInit(
        THSTATE *pTHS
        )
{
    DWORD count, err;
    BOOL  fCommit;

    // Open the database with a new transaction
    Assert(!pTHS->pDB);
    fCommit = FALSE;
    DBOpen2(TRUE, &pTHS->pDB);
    __try {

        sdp_InitGatePerfs();

        // This is the first time through, we can trim duplicate entries
        // from list. ignore this if it fails.
        err = DBThinPropQueue(pTHS->pDB, 0);
        if(err) {
            if(err == DIRERR_SHUTTING_DOWN) {
                Assert(eServiceShutdown);
                __leave;
            }
            else {
                LogUnhandledErrorAnonymous(err);
            }
        }

        // Ignore this if it fails.
        err = DBSDPropInitClientIDs(pTHS->pDB);
        if(err) {
            if(err == DIRERR_SHUTTING_DOWN) {
                Assert(eServiceShutdown);
                __leave;
            }
            else {
                LogUnhandledErrorAnonymous(err);
            }
        }

        // We recount the pending events to keep the count accurate.  This
        // count is used to set our perf counter.

        // See how many events we have
        err = DBSDPropagationInfo(pTHS->pDB,0,&count, NULL);
        if(err) {
            if(err != DIRERR_SHUTTING_DOWN) {
                LogUnhandledErrorAnonymous(err);
            }
            Assert(eServiceShutdown);
            __leave;
        }
        // Set the counter
        ISET(pcSDEvents,count);
        fCommit = TRUE;
    }
    __finally {
        Assert(pTHS->pDB);
        if(fCommit) {
            err = DBClose(pTHS->pDB, TRUE);
        }
        else {
            if(!err) {
                err = ERROR_DS_UNKNOWN_ERROR;
            }
            // Just try to roll it back
            DBClose(pTHS->pDB, FALSE);
        }
    }
    Assert(!pTHS->pDB);

    return;
}

NTSTATUS
__stdcall
SecurityDescriptorPropagationMain (
        PVOID StartupParam
        )
/*++
Routine Description:
    Main propagation daemon entry point.  Loops looking for propagation events,
    calls worker routines to deal with them.

Arguments:
    StartupParm - Ignored.

Return Values:

--*/
{
    DWORD err, index;
    HANDLE pObjects[2];
    HANDLE pStartObjects[2];
    SDPropInfo Info;
    DWORD LastIndex;
    BOOL  bFirst = TRUE;
    BOOL  bRestart = FALSE;
    DWORD id;
    BOOL  bSkip = FALSE;
    THSTATE *pTHS=pTHStls;

#define SDPROP_TIMEOUT (30 * 60 * 1000)
 BeginSDProp:

    Assert(!pTHS);

    __try { // except
        // Deal with the events the propdmon cares about/is responsible for
        ResetEvent(hevSDPropagatorDead);

        // Don't run unless the main process has told us it's OK to do so.
        pStartObjects[0] = hevSDPropagatorStart;
        pStartObjects[1] = hServDoneEvent;
        WaitForMultipleObjects(2, pStartObjects, FALSE, INFINITE);

        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_VERBOSE,
                 DIRLOG_SDPROP_STARTING,
                 NULL,
                 NULL,
                 NULL);

        // Users should not have to wait for this thread.
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL);

        // Set up the events which are triggered when someone makes a change
        // which causes us work.
        pObjects[0] = hevSDPropagationEvent;
        pObjects[1] = hServDoneEvent;

        if(bRestart) {
            // Hmm.  We errored out once, now we are trying again.  In this
            // case, we need to wait here, either for a normal event or for a
            // timeout.  The timeout is so that we try again to do what we were
            // doing before, so we will either get past the error or at worst
            // keep shoving the error into someones face.
            WaitForMultipleObjects(2, pObjects, FALSE, SDPROP_TIMEOUT);

            // OK, we've waited.  Now, forget the fact we were here for a
            // restart.
            bRestart = FALSE;

            // Also, since we are redoing something that caused an error before,
            // we have to do the propagation all the way to the leaves, since we
            // don't know how far along we got before.
            sdp_PropToLeaves = TRUE;
        }

        while(!eServiceShutdown && !DsaIsSingleUserMode()) {
            // This loop contains the wait for a signal.  There is an inner loop
            // which does not wait for the signal and instead loops over the
            // propagations that existed when we woke up.

            Assert(!pTHStls);
            pTHS = InitTHSTATE(CALLERTYPE_INTERNAL);
            if(!pTHS) {
                // Failed to get a thread state.
                RaiseDsaExcept(DSA_MEM_EXCEPTION, 0, 0,
                               DSID(FILENO, __LINE__),
                               DS_EVENT_SEV_MINIMAL);
            }
            pTHS->dwClientID = SDP_CLIENT_ID;
            __try {                     // finally to shutdown thread state
                pTHS->fSDP=TRUE;
                pTHS->fLazyCommit = TRUE;

                // Null these out (if they have values, the values point to
                // garbage or to memory from a previous THSTATE).
                sdpcbScratchSDBuffMax = 0;
                sdpScratchSDBuff = NULL;
                sdpcbScratchSDBuff = 0;

                sdpcbCurrentParentSDBuffMax = 0;
                sdpCurrentParentSDBuff = NULL;
                sdpcbCurrentParentSDBuff = 0;

                // Set these up with initial buffers.
                sdpcbScratchAncestorsBuffMax = 25 * sizeof(DWORD);
                sdpScratchAncestorsBuff =
                    THAllocEx(pTHS,
                              sdpcbScratchAncestorsBuffMax);
                sdpcbScratchAncestorsBuff = 0;

                sdpcbAncestorsBuffMax = 25 * sizeof(DWORD);
                sdpAncestorsBuff =
                    THAllocEx(pTHS,
                              sdpcbAncestorsBuffMax);
                sdpcbAncestorsBuff = 0;

                sdcClassGuid_alloced = 32;
                sdpClassGuid = THAllocEx(pTHS, sizeof (GUID*) * sdcClassGuid_alloced);

                sdpCurrentPDNT = 0;

                if(bFirst) {
                    // Do first pass init stuff
                    sdp_FirstPassInit(pTHS);
                    bFirst = FALSE;
                }

                // Set up the list we use to hold DNTs to visit
                if(err = sdp_InitDNTList()) {
                    LogUnhandledErrorAnonymous(err);
                    __leave;              // finally for threadstate
                }

                // loop while we think there is more to do and we aren't
                // shutting down.
                // LastIndex is the "High-Water mark".  We'll keep doing sd
                // events until we find an sd event with and index higher than
                // this. This gets set to MAX at first.  If we ever re-enqueue a
                // propagation because of an error, we will then get the value
                // of the highest existing index at that time, and only go till
                // then. This keeps us from spinning wildly trying to do a
                // propagation that we can't do because of some error.  In the
                // case where we don't ever re-enqueue, we go until we find no
                // more propagations to do.
                LastIndex = 0xFFFFFFFF;
                while (!eServiceShutdown  && !DsaIsSingleUserMode()) {
                    // We break out of this loop when we're done.

                    // This is the inner loop which does not wait for the signal
                    // and instead loops over all the events that are on the
                    // queue at the time we enter the loop.  We stop and wait
                    // for a new signal once we have dealt with all the events
                    // that are on the queue at this time.  This is necessary
                    // because we might enqueue new events in the code in this
                    // loop, and we want to avoid getting into an endless loop
                    // of looking at a constant set of unprocessable events.

                    sdp_ReInitDNTList();

                    // Get the info we need to do the next propagation.
                    err = sdp_GetPropInfoHelp(pTHS,
                                              &bSkip,
                                              &Info,
                                              LastIndex);
                    if(err ==  DB_ERR_NO_PROPAGATIONS) {
                        err = 0;
                        sdp_PropToLeaves = FALSE;
                        break; // Out of the while loop.
                    }

                    if(err) {
                        // So, we got here with an unidentified error.
                        // Something went wrong, we we need to bail.
                        __leave; // Goto __finally for threadstate
                    }


                    // Normal state.  Found an object.
                    if(!bSkip) {
                        sdpCurrentDNT = Info.beginDNT;
                        // Check to see if we need to propagate all the way to
                        // the leaves.
                        sdp_PropToLeaves |= (Info.clientID == SDP_CLIENT_ID);
                        sdp_Flags = Info.flags;
                        // Deal with the propagation
                        err = sdp_DoEntirePropagation(
                                pTHS,
                                Info,
                                &LastIndex);

                        switch(err) {
                        case DIRERR_SHUTTING_DOWN:
                            Assert(eServiceShutdown);
                            // Hey, we're shutting down.
                            __leave; // Goto __finally for threadstate
                            break;
                        case 0:
                            // Normal
                            break;

                        default:
                            LogUnhandledErrorAnonymous(err);
                            __leave;
                        }
                    }
                    // Note that we've been through the loop once.
                    sdp_PropToLeaves = FALSE;
                    sdpCurrentDNT = sdpCurrentPDNT = 0;
                }
            }

            __finally {
                // Destroy our THState
                free_thread_state();
                pTHS=NULL;
                // reinit some perfcounters.
                sdp_InitGatePerfs();
            }
            if(err) {
                // OK, we errored out completely.  Leave one more time.
                __leave; // Goto __except
            }
            // Ok, end loop.  Back to top to go to sleep.
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_INTERNAL,
                     DIRLOG_SDPROP_SLEEP,
                     NULL,
                     NULL,
                     NULL);
            if(sdp_DidReEnqueue) {
                sdp_DidReEnqueue = FALSE;
                // Wait for the signal, or wake up when the default time has
                // passed.
                WaitForMultipleObjects(2, pObjects, FALSE, SDPROP_TIMEOUT);
            }
            else {
                // Wait for the signal
                WaitForMultipleObjects(2, pObjects, FALSE, INFINITE);
            }

            // We woke up.
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_INTERNAL,
                     DIRLOG_SDPROP_AWAKE,
                     NULL,
                     NULL,
                     NULL);
        }
    }
    __except(HandleMostExceptions(err=GetExceptionCode())) {
        // We should have/will  shutdown everything in finally's
        ;
    }

    Assert(!pTHS);
    Assert(!pTHStls);

    // Ok, we fell out.  We either errored, or we are shutting down
    if(!eServiceShutdown  && !DsaIsSingleUserMode()) {
        // We must have errored.
        DWORD  valLen;
        DSNAME *pName;
        DWORD  localErr;
        // Get the DSName of the last object we were working on.
        __try {
            Assert(!pTHStls);
            pTHS=InitTHSTATE(CALLERTYPE_INTERNAL);

            if(!pTHS) {
                // Failed to get a thread state.
                RaiseDsaExcept(DSA_MEM_EXCEPTION, 0, 0,
                               DSID(FILENO, __LINE__),
                               DS_EVENT_SEV_MINIMAL);
            }
            Assert(!pTHS->pDB);
            DBOpen2(TRUE, &pTHS->pDB);
            if(!DBTryToFindDNT(pTHS->pDB, Info.beginDNT)) {
                LogAndAlertEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                                 DS_EVENT_SEV_ALWAYS,
                                 DIRLOG_SDPROP_END_ABNORMAL,
                                 szInsertHex(err),
                                 szInsertDN(GetDSNameForLogging(pTHS->pDB)),
                                 NULL);
            }
            DBClose(pTHS->pDB,TRUE);
            free_thread_state();
            pTHS=NULL;
        }
        __except(HandleMostExceptions(GetExceptionCode())) {
            if(pTHS) {
                if(pTHS->pDB) {
                    DBClose(pTHS->pDB, FALSE);
                }
                free_thread_state();
                pTHS=NULL;
            }
        }

        // We shouldn't be shutting down this thread, get back to where you once
        // belonged.
        bRestart = TRUE;

        goto BeginSDProp;
    }


    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
             DS_EVENT_SEV_VERBOSE,
             DIRLOG_SDPROP_END_NORMAL,
             NULL,
             NULL,
             NULL);

    SetEvent(hevSDPropagatorDead);

    #if DBG
    if(!eServiceShutdown  && DsaIsSingleUserMode()) {
        DPRINT (0, "Shutting down propagator because we are going to single user mode\n");
    }
    #endif


    return 0;
}

DWORD
SDPEnqueueTreeFixUp(
        THSTATE *pTHS,
        DWORD   dwFlags
        )
{
    DWORD err = 0;

    DBOpen2(TRUE, &pTHS->pDB);
    __try {
        pTHS->pDB->DNT = ROOTTAG;
        err = DBEnqueueSDPropagationEx(pTHS->pDB, FALSE, dwFlags);
    }
    __finally {
        DBClose(pTHS->pDB, !AbnormalTermination());
    }
    return err;
}

DWORD
sdp_GetPropInfoHelp(
        THSTATE    *pTHS,
        BOOL       *pbSkip,
        SDPropInfo *pInfo,
        DWORD       LastIndex
        )
{
    DWORD     fCommit = FALSE;
    DWORD     err;
    ATTCACHE *pAC;
    DWORD     val=0;
    DWORD     cDummy;

    Assert(!pTHS->pDB);
    fCommit = FALSE;
    DBOpen2(TRUE, &pTHS->pDB);
    __try { // for __finally for DBClose
        // We do have an open DBPOS
        Assert(pTHS->pDB);
        *pbSkip = FALSE;

        // Get the next propagation event from the queue
        err = DBGetNextPropEvent(pTHS->pDB, pInfo);
        switch(err) {
        case DB_ERR_NO_PROPAGATIONS:
            // Nothing to do.  Not really an error, just skip
            // and reset the error to 0.  Note that we are
            // setting fCommit to TRUE.  This is a valid exit
            // path.
            *pbSkip = TRUE;
            fCommit = TRUE;
            __leave;
            break;

        case 0:
            // Normal state.  Found an object.
            if(pInfo->index >= LastIndex) {
                // But, it's not one we want to deal with.  Pretend we got no
                // more propagations.
                err = DB_ERR_NO_PROPAGATIONS;
                *pbSkip = TRUE;
                fCommit = TRUE;
                __leave;
            }
            break;

        default:
            // Error of substance
            LogUnhandledErrorAnonymous(err);
            __leave;      // Goto _finally for DBCLose
            break;
        }


        // Since we have this event in the queue and it will
        // stay there until we successfully deal with it, might
        // as well remove other instances of it from the queue.
        err = DBThinPropQueue(pTHS->pDB, pInfo->beginDNT);
        switch(err) {
        case 0:
            // Normal state
            break;

        case DIRERR_SHUTTING_DOWN:
            // Hey, we're shutting down. ThinPropQueue can
            // return this error, since it is in a potentially
            // large loop. Note that we don't log anything, we
            // just go home.
            Assert(eServiceShutdown);
            __leave;      // Goto _finally for DBCLose
            break;


        default:
            // Error of substance
            LogUnhandledErrorAnonymous(err);
            __leave;      // Goto _finally for DBCLose
            break;
        }


        // Get the pointer to the SD att cache, we'll need it.
        // We do this again to avoid keeping hold of it for too
        // long, just in case it changes.


        // Start by finding the initial parents SD.  We do that
        // here because we don't want to get SDs from parents
        // from other NCs, and the only possible node we look at
        // that might have a parent in another NC is the root of
        // the propagation.
        if(pInfo->beginDNT == ROOTTAG) {
            // This is a signal to us that we should recalculate
            // the whole tree.
            pInfo->clientID = SDP_CLIENT_ID;
            sdpcbScratchSDBuff = 0;

            sdpcbCurrentParentSDBuff = 0;

            Assert(sdpScratchAncestorsBuff);
            Assert(sdpcbScratchAncestorsBuffMax);
            sdpcbScratchAncestorsBuff = 0;

            Assert(sdpAncestorsBuff);
            Assert(sdpcbAncestorsBuffMax);
            sdpcbAncestorsBuff = 0;

            sdpCurrentPDNT = 0;
        }
        else {
            if((err = DBTryToFindDNT(pTHS->pDB,
                                     pInfo->beginDNT)) ||
               (err = DBGetSingleValue(pTHS->pDB,
                                       ATT_INSTANCE_TYPE,
                                       &val,
                                       sizeof(val),
                                       NULL)) ) {
                // Cool.  In the interim between the enqueing of
                // the propagation and now, the object has been
                // deleted.  Or it's instance type is gone, same
                // effect.  Nothing to do.  However, we should
                // pop this event from the queue.  Note that we
                // are setting fCommit to TRUE, this is a normal
                // exit path.
                if(err = DBPopSDPropagation(pTHS->pDB,
                                            pInfo->index)) {
                    LogUnhandledErrorAnonymous(err);
                }
                else {
                    err = 0;
                    *pbSkip = TRUE; // if no error, we need to skip
                                  // the actual call to
                                  // doEntirePropagation
                    fCommit = TRUE;
                }
                __leave;        // Goto _finally for DBCLose
            }


            sdpCurrentPDNT = pTHS->pDB->PDNT;

            // val must have been set to the instance type of
            // the object at the root of the propagation.

            // Find the parent.
            err = DBTryToFindDNT(pTHS->pDB,
                                 pTHS->pDB->PDNT);

            // We had better have found a parent.
            Assert(!err);

            // Get the parents ancestors
            cDummy = 0;
            sdpcbAncestorsBuff = sdpcbAncestorsBuffMax;
            Assert(sdpcbAncestorsBuff);
            DBGetAncestors(
                    pTHS->pDB,
                    &sdpcbAncestorsBuff,
                    &sdpAncestorsBuff,
                    &cDummy);
            sdpcbAncestorsBuffMax = max(sdpcbAncestorsBuff,
                                        sdpcbAncestorsBuffMax);

            if(!(val & IT_NC_HEAD)) {
                // OK, the root of the propagation is NOT an NC
                // head, so the parent is in the same NC,
                // preload the parentSD.
                // Found the parent, get the SD.
                if(err = DBGetAttVal(pTHS->pDB,
                                     1,
                                     ATT_NT_SECURITY_DESCRIPTOR,
                                     DBGETATTVAL_fREALLOC,
                                     sdpcbCurrentParentSDBuffMax,
                                     &sdpcbCurrentParentSDBuff,
                                     &sdpCurrentParentSDBuff)) {
                    // No ParentSD.  SD is mandatory, so log
                    // that we couldn't find the SD on the
                    // parent
                    LogUnhandledErrorAnonymous(pTHS->pDB->PDNT);
                    err = 0;
                    // Oh, well, no parent SD, set up for null
                    // pointers.
                    sdpcbCurrentParentSDBuff = 0;
                }
                sdpcbCurrentParentSDBuffMax =
                    max(sdpcbCurrentParentSDBuffMax,
                        sdpcbCurrentParentSDBuff);
            }
            else {
                // The root of the propagation is an NC head.
                // Don't get the parent SD, it isn't used in
                // this case.
                sdpcbCurrentParentSDBuff = 0;
            }
        }

        fCommit = TRUE;
    } // __try
    __finally {
        Assert(pTHS->pDB);
        if(fCommit) {
            DBClose(pTHS->pDB, TRUE);
        }
        else {
            if(!err) {
                err = ERROR_DS_UNKNOWN_ERROR;
            }
            // Just try to roll it back
            DBClose(pTHS->pDB, FALSE);
        }
    }

    Assert(!pTHS->pDB);
    return err;
}

void
DelayedSDPropEnqueue(
    void *  pv,
    void ** ppvNext,
    DWORD * pcSecsUntilNextIteration
        )
{
    THSTATE *pTHS = pTHStls;
    DWORD DNT = PtrToUlong(pv);
    BOOL  fCommit = FALSE;

    *pcSecsUntilNextIteration = TASKQ_DONT_RESCHEDULE;

    DBOpen2(TRUE, &pTHS->pDB);
    __try {
        if(!DBTryToFindDNT(pTHS->pDB, DNT)) {
            DBEnqueueSDPropagation(pTHS->pDB, TRUE);
        }
        fCommit = TRUE;
    }
    __finally {
        DBClose(pTHS->pDB, fCommit);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\sdprop\propq.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       propq.c
//
//--------------------------------------------------------------------------

/*

Description:

    Implements the Security Descriptor Propagation Daemon's DNT list.


*/

#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>			// schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>			// MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>			// needed for output allocation

// Logging headers.
#include "dsevent.h"			// header Audit\Alert logging
#include "dsexcept.h"
#include "mdcodes.h"			// header for error codes
#include "ntdsctr.h"

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected atts
#include "anchor.h"
#include "drautil.h"
#include "sdpint.h"
#include <permit.h>                     // permission constants
#include "debug.h"			// standard debugging header
#define DEBSUB "SDPROP:"                // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_PROPQ

// Assume we'll get around 1000 DNTs left to process at any given time
#define MAX_OBJECTS_EXPECTED (0x400)



DWORD SDP_DNT_List_Size, SDP_DNT_List_Begin, SDP_DNT_List_End;
DWORD *SDP_DNT_List;
/* Internal functions */

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/


DWORD
sdp_InitDNTList (
        )
/*++
Routine Description:
    Sets up the data structure which holds the list of DNTs to visit during a
    propagation. The data structure is an array of DWORDs used as a circular
    FIFO.

Arguments:
    None.

Return Values:
    0 if all went well, error code otherwise.
--*/
{
    // Just reset some global variables and free space.
    DWORD *pList;

    pList = THAlloc(MAX_OBJECTS_EXPECTED * sizeof(DWORD));
    if(!pList) {
        MemoryPanic(MAX_OBJECTS_EXPECTED * sizeof(DWORD));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    SDP_DNT_List = pList;
    SDP_DNT_List_Size = MAX_OBJECTS_EXPECTED;

    SDP_DNT_List_Begin = 0;
    SDP_DNT_List_End = 0;
    ISET(pcSDPropRuntimeQueue, 0);


    return 0;
}

void
sdp_ReInitDNTList(
        )
/*++
  Routine Description:
      Reset the indices into the list.  Leaves the memory allocated by
      sdp_InitDNTList alone.
--*/
{
#if DBG
    ULONG ulSize;

    // Assert that we have some allocated memory.
    Assert(SDP_DNT_List_Size >= MAX_OBJECTS_EXPECTED);
    Assert(SDP_DNT_List);

    
    // In the right heap?  and is the buffer as big as we think it should be?
    ulSize = (ULONG)HeapSize(pTHStls->hHeap, 0, SDP_DNT_List);
    Assert((ulSize != 0xffffffff) &&
           (ulSize >= SDP_DNT_List_Size * sizeof(DWORD)));

    // Catch people reiniting a list that was abandoned during use.  This is
    // technically OK, I just want to know who did this.
    Assert(SDP_DNT_List_Begin == SDP_DNT_List_End);
#endif

    SDP_DNT_List_Begin = 0;
    SDP_DNT_List_End = 0;
    ISET(pcSDPropRuntimeQueue, 0);
    
    return;
}


VOID
sdp_CloseDNTList(
        )
/*++
Routine Description:
    Shutdown the DNTlist, resetting indices to 0 and freeing memory.

Arguments:
    None.

Return Values:
    None.
--*/
{
    // Just reset some global variables and free space.
    THFree(SDP_DNT_List);
    SDP_DNT_List = NULL;
    SDP_DNT_List_Size = 0;
    
    SDP_DNT_List_Begin = 0;
    SDP_DNT_List_End = 0;
    ISET(pcSDPropRuntimeQueue, 0);
    
}



DWORD
sdp_AddChildrenToList (
        THSTATE *pTHS,
        DWORD sdpCurrentDNT)
{
    return DBGetChildrenDNTs(pTHS->pDB,
                             sdpCurrentDNT,
                             &SDP_DNT_List,
                             &SDP_DNT_List_Begin,
                             &SDP_DNT_List_End,
                             &SDP_DNT_List_Size);
}

VOID
sdp_GetNextObject(
        DWORD *pNext
        )
/*++
Routine Description:
    Get the next object off the DNT queue.  Returns a DNT of 0 if the queue is
    empty.

    Indices are adjusted appropriately.

Arguments:
    pNext - place to put the next DNT to visit.

Return Values:
    None.
--*/
{
    // Get the next object from the dnt list.
    if(SDP_DNT_List_Begin == SDP_DNT_List_End) {
        // No objects in the list.
        *pNext = 0;
    }
    else {
        DEC(pcSDPropRuntimeQueue);
        *pNext = SDP_DNT_List[SDP_DNT_List_End++];
        if(SDP_DNT_List_End >= SDP_DNT_List_Size)
            SDP_DNT_List_End = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\nspis\modprop.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       modprop.c
//
//--------------------------------------------------------------------------


/*
 *  MIR Name Service Provider Modify Properties
 */


#include <NTDSpch.h>
#pragma  hdrstop


#include <ntdsctr.h>                   // PerfMon hooks

// Core headers.
#include <ntdsa.h>                      // Core data types
#include <scache.h>                     // Schema cache code
#include <dbglobal.h>                   // DBLayer header.
#include <mdglobal.h>                   // THSTATE definition
#include <mdlocal.h>                    // Core DS routines
#include <dsatools.h>                   // Memory, etc.

// Logging headers.
#include <mdcodes.h>                    // Only needed for dsevent.h
#include <dsevent.h>                    // Only needed for LogUnhandledError

// Assorted DSA headers.
#include <dsexcept.h>
#include <objids.h>                     // need ATT_* consts
#include "dsutil.h"

// Assorted MAPI headers.
#include <mapidefs.h>                   // These four files
#include <mapitags.h>                   //  define MAPI
#include <mapicode.h>                   //  stuff that we need
#include <mapiguid.h>                   //  in order to be a provider.

// Nspi interface headers.
#include "nspi.h"                       // defines the nspi wire interface
#include <nsp_both.h>                   // a few things both client/server need
#include <_entryid.h>                   // Defines format of an entryid
#include <abserv.h>                     // Address Book interface local stuff
#include <emsabtag.h>

#include <fileno.h>
#define  FILENO FILENO_MODPROP

#include "debug.h"

/************************************
            Defines
************************************/

typedef ATTRMODLIST * PAMOD;
typedef PAMOD * PPAMOD;

/************************************
        Internal Routines
************************************/



void
PValToAttrVal (
        THSTATE *pTHS,
        ATTCACHE * pAC,
        DWORD cVals,
        PROP_VAL_UNION * pVu,
        ATTRVAL * pAV,
        ULONG ulPropTag,
        DWORD dwCodePage)
{
    DWORD          i;

    switch( ulPropTag & PROP_TYPE_MASK) {
    case PT_I2:
        pAV->valLen = sizeof(short int);
        pAV->pVal = (PUCHAR)&pVu->i;
        break;
        
    case PT_BOOLEAN:
        pVu->l &= 0xFFFF;               // MAPI's BOOL is a short, so the hi
    case PT_LONG:                     // word is undefined -- we'll clear it
        pAV->valLen = sizeof(LONG);
        pAV->pVal = (PUCHAR)&pVu->l;
        break;
        
    case PT_CLSID:
        pAV->valLen = sizeof( GUID);
        pAV->pVal = (PUCHAR)pVu->lpguid;
        break;
        
    case PT_BINARY:
        if(pAC->syntax != SYNTAX_OBJECT_ID_TYPE) {
            pAV->valLen = pVu->bin.cb;
            pAV->pVal = (PUCHAR)(pVu->bin.lpb);
        }
        else {
            /* This thing is an OID.  That means that I have to
             * convert it here from Binary string to internal dword.
             */
            pAV->valLen = sizeof(DWORD);
            pAV->pVal = THAllocEx(pTHS, sizeof(DWORD));
            OidToAttrType (pTHS,
                           TRUE,
                           (OID_t *)pVu,
                           (ATTRTYP *)pAV->pVal);
        }
        
        break;
        
        
    case PT_SYSTIME:
        pAV->pVal = THAllocEx(pTHS, sizeof(DSTIME));
        FileTimeToDSTime(*((FILETIME *)&pVu->ft), (DSTIME *)pAV->pVal);
        pAV->valLen = sizeof(DSTIME);
        break;
        
        
    case PT_STRING8:      // If the DSA wants this in unicode, translate it
        if(pAC->syntax == SYNTAX_UNICODE_TYPE) {
            pAV->pVal = (PUCHAR)UnicodeStringFromString8(dwCodePage,
                                                         pVu->lpszA, -1);
            pAV->valLen = wcslen( (LPWSTR)pAV->pVal) * sizeof( wchar_t);
        }
        else {
            pAV->pVal = pVu->lpszA;
              pAV->valLen = strlen( pVu->lpszA);
        }
        break;
        
        
        
    case PT_UNICODE: /* If the DSA doesn't want this in unicode, translate */
        if(pAC->syntax != SYNTAX_UNICODE_TYPE) {
            pAV->pVal = (PUCHAR)String8FromUnicodeString(TRUE,dwCodePage,
                                                         pVu->lpszW, -1,
                                                         &(pAV->valLen), NULL);
        }
        else {
            pAV->pVal = (PUCHAR)pVu->lpszW;
            pAV->valLen = wcslen(pVu->lpszW) * sizeof(wchar_t);
        }
        break;
        
    case PT_MV_STRING8:
        for(i=0;i<cVals;i++) {
            /* If the DSA wants this in unicode, translate it */
            if(pAC->syntax == SYNTAX_UNICODE_TYPE) {
                pAV->pVal =
                    (PUCHAR)UnicodeStringFromString8(dwCodePage,
                                                     pVu->MVszA.lppszA[i],
                                                     -1);
                pAV->valLen = wcslen( (LPWSTR)pAV->pVal) * sizeof( wchar_t);
            }
            else {
                pAV->pVal = pVu->MVszA.lppszA[i];
                pAV->valLen = strlen( pVu->MVszA.lppszA[i]);
            }
            pAV++;
        }
        break;
        
    case PT_MV_UNICODE:
        for(i=0;i<cVals;i++) {
            /* If the DSA doesn't want this in unicode, translate it */
            if(pAC->syntax != SYNTAX_UNICODE_TYPE) {
                pAV->pVal =
                    (PUCHAR)String8FromUnicodeString(TRUE,dwCodePage,
                                                     pVu->MVszW.lppszW[i],
                                                     -1, &(pAV->valLen),
                                                     NULL);
            }
            else {
                pAV->pVal = (PUCHAR)pVu->MVszW.lppszW[i];
                pAV->valLen = wcslen(pVu->MVszW.lppszW[i]) * sizeof(wchar_t);
            }
        
            pAV++;
        }
        break;
        
    case PT_MV_BINARY:
        for(i=0;i<cVals;i++) {
        
            if(pAC->syntax != SYNTAX_OBJECT_ID_TYPE) {
                pAV->valLen = pVu->MVbin.lpbin[i].cb;
                pAV->pVal = pVu->MVbin.lpbin[i].lpb;
            }
            else {
                /* This thing is an OID.  That means that I have to
                 * convert it here from Binary string to internal dword.
                 */
                pAV->valLen = sizeof(DWORD);
                pAV->pVal = THAllocEx(pTHS, sizeof(DWORD));
                OidToAttrType (pTHS,
                               TRUE,
                               (OID_t *) &pVu->MVbin.lpbin[i],
                               (ATTRTYP *)pAV->pVal);
            }
            pAV++;
        }
        
        break;
        
    case PT_MV_LONG:
        for(i=0;i<cVals;i++) {
        
            pAV->valLen = sizeof(LONG);
            pAV->pVal = (PUCHAR)&pVu->MVl.lpl[i];
            pAV++;
        }
        break;


    default:     /* Shouldn't get here, we don't let you set anything else */
        R_Except("PValToAttrVal default case: Unexpected PropTag",ulPropTag);
    }
}

void
PropValToATTR (
        THSTATE *pTHS,
        ATTCACHE * pAC,
        LPSPropValue_r pVal,
        ATTR * pAttr,
        DWORD dwCodePage)
{
    int         cVals;

    pAttr->attrTyp = pAC->id;

    if(!(pVal->ulPropTag & MV_FLAG))        /* single valued? */
        cVals = 1;
    else
        cVals = pVal->Value.MVi.cValues;

    pAttr->AttrVal.valCount = cVals;
    pAttr->AttrVal.pAVal = (ATTRVAL *)THAllocEx(pTHS, cVals*sizeof(ATTRVAL));
    PValToAttrVal(pTHS, pAC, cVals, &pVal->Value, pAttr->AttrVal.pAVal,
                  pVal->ulPropTag, dwCodePage);

    return;
}


VOID
PropTagsToModList (
        THSTATE *pTHS,
        LPSPropTagArray_r pTags,
        LPSRow_r pSR,
        MODIFYARG *ModifyArg,
        DWORD dwCodePage
        )
/*++
Description
    Given a list of proptags that have changed (pTags) and an SRow Set of new
    values (pSR), create a modification list consisting of Deletes for all those
    attributes in pTags that don't have values in pSR, and for all the additions
    in the pSR.

    Returns the correct Modifications list.

--*/
{
    PAMOD       pAM, aAttr, Dummy;
    PAMOD   *   pLink;
    ATTCACHE *  pAC;
    ULONG       i, j,
                cDel=0,
                cAdd = 0,
                aAttrcnt = 0;
    BOOL        fFound;
    LPSPropValue_r  pVal;
    ULONG       totalEntries;


    Assert (ModifyArg->count == 0);

    // alloc all (after first) at once
    totalEntries = pTags->cValues + pSR->cValues;
    if ( totalEntries > 1 ) {
        totalEntries--;
    }
    else {
        totalEntries = 1;
    }
    aAttr = (PAMOD)THAllocEx(pTHS, totalEntries * sizeof(ATTRMODLIST));

    pAM = &ModifyArg->FirstMod;             // ptr to first AMod
    pLink = &Dummy;                         // throw away first link


    // do the deletions first

    if (pTags->cValues) {
        // walk the proptag array
        for (i = 0; i < pTags->cValues; i++) {
            if(!(pAC = SCGetAttByMapiId(pTHS, PROP_ID(pTags->aulPropTag[i])))) {
                pTHS->errCode = (ULONG)MAPI_E_INVALID_PARAMETER;
                DsaExcept( DSA_EXCEPTION, 0,0);
            }

            fFound = FALSE;
            // Look for this in pSR
            for(j=0; j< pSR->cValues;j++) {
                if((PROP_ID(pTags->aulPropTag[i])) ==
                    (PROP_ID(pSR->lpProps[j].ulPropTag))) {
                    // Yep, we should not do a delete on this one.
                    fFound = TRUE;
                }
            }

            if(!fFound) {
                // Didn't find it, so go ahead and make the "DELETE" modification.
                pAM->choice = AT_CHOICE_REMOVE_ATT;
                pAM->AttrInf.attrTyp = pAC->id;
                pAM->AttrInf.AttrVal.valCount = 0;
                cDel++;

                // Bookkeeping to build the chain of modifications.
                *pLink = pAM;
                pLink = &pAM->pNextMod;
                pAM = &aAttr[aAttrcnt];
                aAttrcnt++;
            }
        }
    }

    // continue with additions

    if (pSR->cValues) {
        for (i = 0; i < pSR->cValues; i++) { // walk the propvals
            pVal = &pSR->lpProps[i];
            if(!(pAC = SCGetAttByMapiId(pTHS, PROP_ID(pVal->ulPropTag)))) {
                pTHS->errCode = (ULONG)MAPI_E_INVALID_PARAMETER;
                DsaExcept( DSA_EXCEPTION, 0,0);
            }
            if( (pSR->lpProps[i].ulPropTag & MV_FLAG) && pAC->isSingleValued) {
                pTHS->errCode = (ULONG)MAPI_E_INVALID_PARAMETER;
                DsaExcept( DSA_EXCEPTION, 0,0);
            }

            PropValToATTR(pTHS, pAC, pVal, &pAM->AttrInf, dwCodePage);
            pAM->choice = AT_CHOICE_REPLACE_ATT; // make replace AM
            cAdd++;

            // Bookkeeping to build the chain of modifications.
            *pLink = pAM;                     // link
            pLink = &pAM->pNextMod;           // place for next link
            pAM = &aAttr[ aAttrcnt ];
            aAttrcnt++;
        }
    }

    *pLink = NULL;                           // end chain
    ModifyArg->count = (USHORT) (cDel + cAdd);

}



/*************************************************************************
*   Modify Properties Entry Point
**************************************************************************/
SCODE
ABModProps_local (
        THSTATE *pTHS,
        DWORD dwFlag,
        PSTAT pStat,
        LPSPropTagArray_r pTags,
        LPSRow_r pSR)
{
    MODIFYARG   ModifyArg;
    MODIFYRES * pModifyRes;
    ULONG       ulLen;
    SCODE       scode = SUCCESS_SUCCESS;

    if(dwFlag) {
        pTags = NULL;
        pSR = NULL;                       // don't ship them back
        // we used to support AB_ADD, but no longer.
        return MAPI_E_CALL_FAILED;
    }

    memset( &ModifyArg, 0, sizeof( ModifyArg ) );

    if(DBTryToFindDNT(pTHS->pDB, pStat->CurrentRec) ||
       DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                   0, 0,
                   &ulLen, (PUCHAR *)&ModifyArg.pObject)) {
        /* Oops, that DNT was no good */
        pTags=NULL;
        pSR = NULL;                       // don't ship them back
        pTHS->errCode = (ULONG)MAPI_E_INVALID_PARAMETER;
    }

    if(pTHS->errCode)
        return pTHS->errCode;

    InitCommarg( &ModifyArg.CommArg);    // get default commarg
    ModifyArg.CommArg.Svccntl.fDontOptimizeSel = TRUE;

    // pTags is a list of all tags that changed.  pSR holds a list of all the
    // new values.  Call PropTagsToModList to create "Delete attribute"
    // modifictions for all those attributes in pTags that are not in pSR.
    // and then add all the rows in pSR to the modification list as "Replace attribute"s.

    // does deletes and then additions
    PropTagsToModList(pTHS,
                      pTags,
                      pSR,
                      &ModifyArg,
                      pStat->CodePage);


    DBClose(pTHS->pDB, TRUE);

    if(!ModifyArg.count) {
        // modify without modifying anything.
        scode = SUCCESS_SUCCESS;
    }
    else {
        scode = (DirModifyEntry (&ModifyArg, &pModifyRes) ?
                 MAPI_E_NO_ACCESS : SUCCESS_SUCCESS);
    }

    pTags = NULL;
    pSR = NULL;                       // don't ship them back

    return scode;
}

/************************************
*
* Given a list of DNTs and a MAPI prop tag, create a data structure to use
* in a DIRMODIFYENTRY
*
*************************************/

void
MakeLinkMod (
        THSTATE *pTHS,
        DWORD ulPropTag,
        LPSPropTagArray_r DNTList,
        DWORD fDelete,
        PAMOD pAMList,
        USHORT * pusCount)
{
    PAMOD       pAM;
    ATTR        *pAtt;
    BYTE        *buff=NULL;
    ATTCACHE *  pAC;
    DWORD       i,fOK;
    USHORT      Count;
    ATTRVAL     tempAttrVal;
    ULONG       valLen;
    PUCHAR      pVal;

    if( !(pAC = SCGetAttByMapiId(pTHS, PROP_ID(ulPropTag)))) {
        pTHS->errCode = (ULONG)MAPI_E_NOT_FOUND;
        DsaExcept( DSA_EXCEPTION, 0,0);
    }

    if (!DNTList->cValues) {
        *pusCount = 0;
        pAMList = NULL;
        return;
    }

    buff = (BYTE *)THAllocEx(pTHS, (DNTList->cValues - 1) * sizeof(ATTRMODLIST));


    Count = 0;          
    pAM = pAMList;
    for (i = 0; i < DNTList->cValues; i++) {
        fOK = FALSE;

        if(pAC->syntax == SYNTAX_DISTNAME_STRING_TYPE ||
           pAC->syntax == SYNTAX_DISTNAME_BINARY_TYPE    ) {
            /* It is a complex DSNAME valued attribute */
            SYNTAX_DISTNAME_STRING *pComplexName;
            PDSNAME     pDN=NULL;
            ULONG       len;
            if(DBTryToFindDNT(pTHS->pDB, DNTList->aulPropTag[i]) ||
               DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                           0,
                           0,
                           &len,
                           (PUCHAR *)&pDN)) {
                /* Oops, that DNT was no good */
                DNTList->aulPropTag[i] = 0;
            }
            else {
                SYNTAX_ADDRESS Address;
                Address.structLen = STRUCTLEN_FROM_PAYLOAD_LEN( 0 );

                // OK, we have a DN.  Use it and an empty address structure
                // to create a DISTNAME_STRING_TYPE thing.
                pVal =  (PUCHAR)
                    THAllocEx(pTHS, DERIVE_NAME_DATA_SIZE(pDN,&Address));

                BUILD_NAME_DATA(((SYNTAX_DISTNAME_BINARY *)pVal),pDN,&Address);
                fOK=TRUE;
                if (pDN) {
                    THFree(pDN);
                }
            }
        }
        else if (pAC->syntax == SYNTAX_DISTNAME_TYPE) {
            /* It's a DN valued attribute */

            if(DBTryToFindDNT(pTHS->pDB, DNTList->aulPropTag[i]) ||
               DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                           0, 0,
                           &valLen,
                           (PUCHAR *)&pVal) ) {
                /* Oops, that DNT was no good */
                DNTList->aulPropTag[i] = 0;
            }
            else {
                fOK=TRUE;
            }
        }

        if(fOK) {
            // OK, got one

            if(i < (DNTList->cValues - 1))
                pAM->pNextMod = (ATTRMODLIST *)buff;
            else
                pAM->pNextMod = NULL;

            if(fDelete) {
                pAM->choice = AT_CHOICE_REMOVE_VALUES;
            }
            else {
                pAM->choice = AT_CHOICE_ADD_VALUES;
            }

            pAtt = &pAM->AttrInf;
        

            pAtt->attrTyp = pAC->id;
            pAtt->AttrVal.valCount = 1;
            pAtt->AttrVal.pAVal = THAllocEx(pTHS, sizeof(ATTRVAL));
            pAtt->AttrVal.pAVal->valLen = valLen;
        
            pAtt->AttrVal.pAVal->pVal = pVal;

            Count++;
            pAM = (ATTRMODLIST *)buff;
            buff += sizeof(ATTRMODLIST);
        }
    }
        
    *pusCount = Count;


}

/*********************************
*
* Take a list of Entry IDs and give back a list of DNTs.  Preserve order
*
**********************************/

void
EntryIDsToDNTs (
        THSTATE *pTHS,
        LPENTRYLIST_r lpEntryIDs,
        LPSPropTagArray_r * DNTList)
{
    DWORD i;
    LPSBinary_r lpEntryID;
    MAPIUID muid = MUIDEMSAB;
    *DNTList =(LPSPropTagArray_r)
        THAllocEx(pTHS, sizeof(SPropTagArray_r) +lpEntryIDs->cValues * sizeof(DWORD));


    (*DNTList)->cValues = lpEntryIDs->cValues;

    lpEntryID = (lpEntryIDs->lpbin);

    for(i=0;i< (*DNTList)->cValues; i++) {
        // Two cases, permanent and ephemeral;
        // Note that this will (and should) fail PermIDs for containers

        // (EXCHANGE) possible bad comparison for ephemerality.
        if( ((LPDIR_ENTRYID)lpEntryID->lpb)->abFlags[0] == EPHEMERAL ) {
            // Check the GUID.
            if(memcmp( &(((LPUSR_ENTRYID)lpEntryID->lpb)->muid),
                      &pTHS->InvocationID,
                      sizeof(MAPIUID)                        ) == 0) {

                // It's my ephemeral.
                (*DNTList)->aulPropTag[i] =
                    ((LPUSR_ENTRYID)lpEntryID->lpb)->dwEph;
            }
            else {
                // Not my eph id, monkey boy!
                (*DNTList)->aulPropTag[i] = 0;
            }
        }
        else  {
            // Check the GUID.
            if(memcmp( &(((LPUSR_PERMID)lpEntryID->lpb)->muid),
                       &muid,
                       sizeof(MAPIUID)                       ) == 0) {
                // It's my Permanent.
                (*DNTList)->aulPropTag[i] =
                    ABDNToDNT(pTHS, ((LPUSR_PERMID)lpEntryID->lpb)->szAddr);
            }
            else {
                // Not my perm id, monkey boy!
                (*DNTList)->aulPropTag[i] = 0;
            }
        
        }
        lpEntryID++;
    }
}

void
RemoveDups(
        THSTATE *pTHS,
        DWORD dwEph,
        LPSPropTagArray_r DNTList,
        DWORD dwAttID,
        DWORD fKeepExisting
        )
        
/*++

    Take a list of DNTs, the DNT of an object, and an attribute id.  Remove
    duplicates from the list, and if the fKeepExisting flag is true, remove all
    DNTs from the list which are NOT values of the attribute on the object.  If
    fKeepExisting is false, remove all DNTs from the list which ARE values of
    the attributue on the object.  This makes a DIRMODIFYENTRY call against
    the object later succeed.

Arguments:

    pDB - the DBLayer position block to use to move around in.

    dwEph - the object to look up.

    DNTList - the list of DNTs to remove dups and modify.

    dwAttID - the attribute to look up to use values to modify DNTList

    fKeepExisting - how to modify the DNTList

Return Values:

     None.

--*/
{
    DWORD       i,j;
    ATTCACHE    *pAC;

    DWORD       cOutAtts = 0;
    ATTR        *pAttr;

    // First, get the attcache for the attribute in question
    if( !(pAC = SCGetAttByMapiId(pTHS, PROP_ID(dwAttID))))  {
        pTHS->errCode = (ULONG)MAPI_E_NOT_FOUND;
        DsaExcept( DSA_EXCEPTION, 0,0);
    }

    // Find the object to look up.
    DBFindDNT(pTHS->pDB, dwEph);

    // Look up all the attribute values already on the object.
    DBGetMultipleAtts(pTHS->pDB, 1, &pAC, NULL, NULL, &cOutAtts,
                      &pAttr, DBGETMULTIPLEATTS_fGETVALS, 0);

    // Now loop through all the input atts and remove dups, preserving order,
    // and remove appropriate values from the list.
    for(i=0 ; i<DNTList->cValues ; i++)  {
        if(DNTList->aulPropTag[i])  {
            DWORD              fFound;

            if(DNTList->aulPropTag[i] == 0) {
                // This one is uninteresting.
                continue;
            }

            // Remove all duplicate of this value later in the list.
            for(j=i+1 ; j<DNTList->cValues ; j++) {
                if(DNTList->aulPropTag[j] == DNTList->aulPropTag[i])
                    DNTList->aulPropTag[j] = 0;
            }

            // Now scan through the values already on the object to see if the
            // value in question is there.
            fFound = FALSE;
            if(cOutAtts) {
                ATTRVAL *valPtr;
                // We actually have some values, so we might find the next value
                // in the list of values we read from the server.
                for(j=pAttr[0].AttrVal.valCount; j; j--) {
                    DWORD dnt;
                    valPtr = &(pAttr[0].AttrVal.pAVal[j-1]);

                    if(pAC->syntax == SYNTAX_DISTNAME_STRING_TYPE ||
                       pAC->syntax == SYNTAX_DISTNAME_BINARY_TYPE    ) {
                        // It is an ORNAME valued attribute, pluck the DNT out
                        // correctly.
                        dnt = ((INTERNAL_SYNTAX_DISTNAME_STRING *)
                               (valPtr->pVal))->tag;
                    }
                    else {
                        // Standard DNT valued thing.
                        dnt = *((DWORD *)(valPtr->pVal));
                    }

                    if(dnt == DNTList->aulPropTag[i])
                        fFound = TRUE;
                }
            }

            if((!fKeepExisting && fFound) ||
               (fKeepExisting && !fFound)    )
                DNTList->aulPropTag[i] = 0;
        }
    }
}


/*************************************************************************
*   Modify Link Attributes.
**************************************************************************/
SCODE
ABModLinkAtt_local (
        THSTATE *pTHS,
        DWORD dwFlags,
        DWORD ulPropTag,
        DWORD dwEph,
        LPENTRYLIST_r lpEntryIDs
        )
{
    MODIFYARG   ModifyArg;
    MODIFYRES  *pModifyRes;
    VOID       *tempPtr;
    ULONG       ulLen;
    LPSPropTagArray_r DNTList=NULL;

    memset( &ModifyArg, 0, sizeof( ModifyArg ) );

    if(DBTryToFindDNT(pTHS->pDB, dwEph) ||
       DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                   0, 0,
                   &ulLen, (PUCHAR *)&ModifyArg.pObject)) {
        /* Oops, that DNT was no good */
        pTHS->errCode = (ULONG)MAPI_E_INVALID_PARAMETER;
    }

    if(pTHS->errCode)
        return pTHS->errCode;


    InitCommarg( &ModifyArg.CommArg);    // get default commarg;
    ModifyArg.CommArg.Svccntl.fDontOptimizeSel = TRUE;

    // Turn the EntryIDs into DNTs;
    EntryIDsToDNTs(pTHS, lpEntryIDs, &DNTList);

    // if we're adding mems, Remove all DNTs already on the object;
    // else Remove all those DNTs not already on the object;
    RemoveDups(pTHS, dwEph, DNTList, ulPropTag, dwFlags & fDELETE);

    // Turn the list of DNTs into a modify arg;
    MakeLinkMod(pTHS, ulPropTag, DNTList, dwFlags & fDELETE,
                &ModifyArg.FirstMod, &ModifyArg.count);

    DBClose(pTHS->pDB, TRUE);

    if(!ModifyArg.count) {
        // modify without modifying anything.
        return SUCCESS_SUCCESS;
    }
    else {
        return (DirModifyEntry (&ModifyArg, &pModifyRes) ?
                MAPI_E_NO_ACCESS : SUCCESS_SUCCESS);
    }
}

/*************************************************************************
*   Delete Entries.
*
*  No longer supported.
*
**************************************************************************/
SCODE
ABDeleteEntries_local (
        THSTATE *pTHS,
        DWORD dwFlags,
        DWORD dwEph,
        LPENTRYLIST_r lpEntryIDs
        )
{
    REMOVEARG   RemoveArg;
    REMOVERES * pRemoveRes;
    LPSPropTagArray_r DNTList=NULL;
    ULONG       ulLen;
    DWORD       i, numDeleted=0;

    return MAPI_E_CALL_FAILED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\nspis\nspnotif.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       nspnotif.c
//
//--------------------------------------------------------------------------

/*
 * Description:
 *    Contains the RPC notification routines. The prototypes for
 *    these functions are in the MIDL-generated .h file, so that is
 *    included.
 */

#include <NTDSpch.h>
#pragma  hdrstop


#include "nspi.h"
#include <ntdsctr.h>
#include <fileno.h>
#define  FILENO FILENO_NSPNOTIF
void dsa_notify( void );
void NspiBind_notify(void)
{
    dsa_notify();
}

void NspiUnbind_notify(void)
{
    dsa_notify();
}


void NspiUpdateStat_notify(void)
{
    dsa_notify();
}

void NspiQueryRows_notify(void)
{
    dsa_notify();
}

void NspiSeekEntries_notify(void)
{
    dsa_notify();
}

void NspiGetMatches_notify(void)
{
    dsa_notify();
}

void NspiResortRestriction_notify(void)
{
    dsa_notify();
}

void NspiGetNamesFromIDs_notify(void)
{
    dsa_notify();
}

void NspiGetIDsFromNames_notify(void)
{
    dsa_notify();
}

void NspiDNToEph_notify(void)
{
    dsa_notify();
}

void NspiGetPropList_notify(void)
{
    dsa_notify();
}

void NspiGetProps_notify(void)
{
    dsa_notify();
}

void NspiCompareDNTs_notify(void)
{
    dsa_notify();
}

void NspiModProps_notify(void)
{
    dsa_notify();
}

void NspiGetHierarchyInfo_notify(void)
{
    dsa_notify();
}

void NspiGetTemplateInfo_notify(void)
{
    dsa_notify();
}

void  NspiModLinkAtt_notify(void)
{
    dsa_notify();
}

void  NspiDeleteEntries_notify(void)
{
    dsa_notify();
}

void NspiQueryColumns_notify(void)
{
    dsa_notify();
}

void NspiResolveNames_notify(void)
{
    dsa_notify();
}

void NspiResolveNamesW_notify(void)
{
    dsa_notify();
}

void __RPC_USER NSPI_HANDLE_rundown ( NSPI_HANDLE handle)
{
    /* We currently don't do much here, but we might later. */
    DEC(pcABClient);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\pek\pek.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       pek.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file contains services for encrypting and
    decrypting passwords at the DBlayer level

Author:

    Murlis

Environment:

    User Mode - Win32

Revision History:
    19 Jan 1998 Created


--*/


#include <ntdspch.h>
#pragma hdrstop

#include <nt.h>

// SAM headers
#include <ntsam.h>
#include <samrpc.h>
#include <ntsamp.h>

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>         // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>           // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>           // needed for output allocation
#include <attids.h>
#include <dstaskq.h>
#include <debug.h>
#include <dsexcept.h>
#include <dsevent.h>
#include <drsuapi.h>
#include <fileno.h>

// Other Headers
#include <pek.h>
#include <wxlpc.h>
#include <cryptdll.h>
#include <md5.h>
#include <rc4.h>
#include <sspi.h>
#include <kerbcon.h>

#include <lsarpc.h>
#include <lsaisrv.h>

#define FILENO FILENO_PEK
#define DEBSUB "PEK:"

#define PEK_MAX_ALLOCA_SIZE 256

//
// THEORY Of Operation
//
// The PEK library implements a set of routines that allows encryption
// and decryption of passwords before saving/reading from JET. The
// encryption and decryption calls are made by DBlayer.
//
// The sequence of envents upon a normal boot is as follows
//
// PEK initialize is called by the DS at startup time from DS initialize. Pek Initialize
// reads the encrypted PEK list from the domain object. The Pek list
// is nromally kept encrypted with a key provided by winlogon. The Pek list also
// maintains the bootOption in the clear. BootOption can be one of
//   1. None -- The PEK list is kept in the clear and no prompting is required
//              of winlogon in the future.
//   2. System -- The PEK list is kept encrypted with a key that winlogon has
//                saved in a "obfuscated" form in the system itself. Requires winlogon
//                to provide us the key at boot time. This will be the default
//                after installation. Currently however, the default is None, as
//                winlogon does not yet provide an API to communicate the Key to
//                winlogon. The SP3 utility "syskey" actually writes the key directly
//                to registry somewhere in the winlogon key space.
//   3. Floppy -- The PEK list is kept encrypted with a key, the key itself residing
//                on a floppy. At boot time winlogon prompts for a floppy to boot.
//                It reads the key and passes that to us.
//
//   4. Password -- The key to encrypt the PEK list is derived from the hash of a password
//                that the administrator supplied. Winlogon prompts for a boot password at
//                boot time. The hash is then computed by winlogon and the key derived from
//                it is passed to us. We use the key to decrypt the PEK list.
//
//  AT Install time the sequence of operations is as follows
//
//  PEKInitialize is called from within the install code path asking for a new key set.
//  A new key set for encrypting passwords is generated but not yet saved ( as the object
//  on which it needs to be saved need not as yet exist ).
//
// After the DS installation is comple ( fresh , or Replica ), the install path calls
// pek save Changes. This saves the key set for password encryption on the domain object.
// Currently the Pek set is saved in the clear. The utility syskey can be used to change
// the key to encrypt/ change the clear storage to an encrypted storage. When the API
// from winlogon arrives to pass in the key used for the encryption, then we will invent
// a new key for encrypting the pek list and pass that key to winlogon. Currently there is
// no security by default, but security can be provided by running syskey.exe
//
//
// Change of Boot Option, or change of keys is provided by syskey.key. This calls into
// PEKChangeBootOptions ( through SamrSetBootOptions ) to change the boot option.
// While upgrading NT4 SP3, SP3 settings are migrated by SAM calling into
// DSChangeBootOptions ( which calls into PEKChangeBootOptions ), with the Set flag specified.
// This preserves the SP3 options, and also re-encrypts the PEK list using the key that
// was used in SP3 ( for eg boot password does not change ).
//


// Global Initialization State of the PEK system
//

CLEAR_PEK_LIST * g_PekList = NULL;
GUID     g_PekListAuthenticator =
         {0x4881d956,0x91ec,0x11d1,0x90,0x5a,0x00,0xc0,0x4f,0xc2,0xd4,0xcf};
DSNAME * g_PekDataObject = NULL;
UCHAR    g_PekWinLogonKey[DS_PEK_KEY_SIZE];
BOOL     g_PekInitialized = FALSE;
CRITICAL_SECTION    g_PekCritSect;
PCHECKSUM_FUNCTION  g_PekCheckSumFunction = NULL;


//
// we have tracing code to enable debugging the password encryption system
// By default the tracing is turned off. If need be a special binary can 
// be built with the tracing.
//

#if 0

#define DBG_BUFFER_SIZE 256

static FILE * EncryptionTraceFile = NULL;

BOOLEAN EnableTracing = TRUE;

VOID
PekDumpBinaryDataFn(
    IN  CHAR    *Tag,
    IN  PBYTE   pData,
    IN  DWORD   cbData
    )
{
    DWORD i;
    BYTE AsciiLine[16];
    BYTE BinaryLine[16];
    CHAR Buffer[DBG_BUFFER_SIZE];
    ULONG ThreadId = GetCurrentThreadId();


    __try
    {

        //
        // if tracing has not been enabled then leave
        //

        if (!EnableTracing)
        {
            __leave;
        }

        //
        // If file has not been opened then try opening it
        //

        if (NULL==EncryptionTraceFile)
        {

         __leave;

        }

        //
        // output the tag
        //

        fprintf(EncryptionTraceFile,"Thread %d, tag %s\n", ThreadId, Tag);

        if (0 == cbData)
        {
            fprintf(EncryptionTraceFile,"Thread %d, Zero-Length Data\n", ThreadId);
            __leave;
        }

        if (cbData > DBG_BUFFER_SIZE)
        {
            fprintf(EncryptionTraceFile,"Thread %d, ShowBinaryData - truncating display to 256 bytes\n", ThreadId);
            cbData = 256;
        }

        for (; cbData > 0 ;)
        {
            for (i = 0; i < 16 && cbData > 0 ; i++, cbData--)
            {
                BinaryLine[i] = *pData;
                (isprint(*pData)) ? (AsciiLine[i] = *pData) : (AsciiLine[i] = '.');
                pData++;
            }

            if (i < 15)
            {
                for (; i < 16 ; i++)
                {
                    BinaryLine[i] = ' ';
                    AsciiLine[i] = ' ';
                }
            }

            fprintf(EncryptionTraceFile,
                    "Thread %d %02x %02x %02x %02x %02x %02x %02x %02x - %02x %02x %02x %02x %02x %02x %02x %02x\t%c%c%c%c%c%c%c%c - %c%c%c%c%c%c%c%c\n",
                    ThreadId,
                    BinaryLine[0],
                    BinaryLine[1],
                    BinaryLine[2],
                    BinaryLine[3],
                    BinaryLine[4],
                    BinaryLine[5],
                    BinaryLine[6],
                    BinaryLine[7],
                    BinaryLine[8],
                    BinaryLine[9],
                    BinaryLine[10],
                    BinaryLine[11],
                    BinaryLine[12],
                    BinaryLine[13],
                    BinaryLine[14],
                    BinaryLine[15],
                    AsciiLine[0],
                    AsciiLine[1],
                    AsciiLine[2],
                    AsciiLine[3],
                    AsciiLine[4],
                    AsciiLine[5],
                    AsciiLine[6],
                    AsciiLine[7],
                    AsciiLine[8],
                    AsciiLine[9],
                    AsciiLine[10],
                    AsciiLine[11],
                    AsciiLine[12],
                    AsciiLine[13],
                    AsciiLine[14],
                    AsciiLine[15]);
        }
    }
    __finally
    {

    }
}



VOID
PekInitializeTraceFn()
{
    CHAR DirectoryName[256];
    CHAR FileName[256];
    UINT ret;

     //
     // Open the encryption trace file
     //

     ret = GetWindowsDirectoryA(DirectoryName,sizeof(DirectoryName));
     if ((0==ret) || (ret>sizeof(DirectoryName)))
     {
         return;
     }

     //
     // Print out the name of the file
     //

     _snprintf(FileName,sizeof(FileName),"%s\\debug\\pek.log",DirectoryName);

     EncryptionTraceFile = fopen(FileName, "w+");
}

#define PEK_TRACE(x,y,z) PekDumpBinaryDataFn(x,y,z)

#define PEK_INITIALIZE_TRACE() PekInitializeTraceFn()

#else

#define PEK_TRACE(x,y,z)

#define PEK_INITIALIZE_TRACE()

#endif

BOOL
IsPekInitialized()
/*++

    Routine Description

        Checks to see if the PEK library is initialized.

    Parameters

        None

    Return Values

        TRUE -- If initilaized
        FALSE -- Otherwise
--*/
{
    return (TRUE==g_PekInitialized);
}



BOOL
PekEncryptionShouldBeEnabled()
/*++

    Routine Description

        Returns whether the PEK system is to be initialized.
        The sole purpose of the existance of this routine is
        because of the current state, where we may have to checkin
        this code before the schema changes that this gives this
        code the attributes to operate upon. Till the schema changes
        are effected, this library operates on some arbitary default
        attributes ( for test purposes only ) and should be kept
        disabled by default. ( That is just before checkin PekGlobalFlag
        will be turned back to 0 ).
--*/
{
    return (TRUE);
}

ATTRTYP
PekpListAttribute(VOID)
/*++
    Routine Description

        Returns the attribute that
        the PEK list is kept in. The purpose
        of this is schema bootstrapping. Till the
        new schema is in place, we keep this value
        in the property ATT_PRIVATE_KEY

--*/
{
    return (ATT_PEK_LIST);
}

NTSTATUS
PekInitializeCheckSum()
{

     NTSTATUS   Status = STATUS_SUCCESS;

    //
    // Query for the CRC32 Checksum function
    //

    Status = CDLocateCheckSum(
                    KERB_CHECKSUM_REAL_CRC32,
                    &g_PekCheckSumFunction
                    );

    if (NT_SUCCESS(Status))
    {
        Assert(g_PekCheckSumFunction->CheckSumSize==sizeof(ULONG));
    }
    return(Status);
}

VOID
PEKInPlaceEncryptDecryptDataWithKey(
    IN PVOID Key,
    IN ULONG cbKey,
    IN PVOID Salt,
    IN ULONG cbSalt,
    IN ULONG HashLength,
    IN PVOID Buffer,
    IN ULONG cbBuffer
    )
/*++

    Routine Description

    This routine encrypts/decrypts ( depending upon whether clear
    or encrypted data was passed ), the buffer that was passed in
    place. The encryption algorithm used is RC4. Therefore it is
    important that a salt be used to add to the key, as otherwise
    the key can extracted if the clear data were known.

    Parameters

        Key   The key to use to encrypt or decrypt
        cbKey The length of the key
        Salt  Pointer to a salt to be added to the key.
        HashLength -- Controls the number of times the salt is hashed
                      into the key before the key is used.
        Buffer The buffer to encrypt or decrypt
        cbBuffer The length of the buffer


    Return Values

        None, Function always succeeds

--*/
{

    MD5_CTX Md5Context;
    struct RC4_KEYSTRUCT Rc4Key;
    ULONG  i;


    //
    // Create an MD5 hash of the key and salt
    //


    MD5Init(&Md5Context);

    MD5Update(
        &Md5Context,
        Key,
        cbKey
        );

    if ((NULL!=Salt) && (cbSalt>0))
    {
        for (i=0;i<HashLength;i++)
        {
            MD5Update(
                &Md5Context,
                Salt,
                cbSalt
                );
        }
    }

    MD5Final(
        &Md5Context
        );


    //
    // Initialize the RC4 key sequence.
    //

    rc4_key(
        &Rc4Key,
        MD5DIGESTLEN,
        Md5Context.digest
        );

    //
    // Encrypt with RC4
    // Only encrypt/decrypt if the length is greater than zero - RC4 can't handle
    // zero length buffers.
    //

    if (cbBuffer > 0) {

        rc4(
            &Rc4Key,
            cbBuffer,
            Buffer
            );

    }
}

//
// Functions for computing various lengths
//


ULONG
EncryptedDataSize(
    IN ULONG ClearLength,
    IN ULONG AlgorithmId
    )
/*++

    Routine Description

        This routine computes the encrypted data size given a clear data
        data length and the algorithm ID to use

    Parameters

        ClearLength -- The length of the data in the clear
        AlgorithmId -- The algorithm to use

    Return Values

       The encrypted length, including the header
--*/
{
    switch(AlgorithmId)
    {
    case DS_PEK_DBLAYER_ENCRYPTION:
        return(ClearLength+sizeof(ENCRYPTED_DATA)-sizeof(UCHAR));
    case DS_PEK_DBLAYER_ENCRYPTION_WITH_SALT:
        return(ClearLength+sizeof(ENCRYPTED_DATA_WITH_SALT)-sizeof(UCHAR));
    case DS_PEK_DBLAYER_ENCRYPTION_FOR_REPLICATOR:
        return(ClearLength+sizeof(ENCRYPTED_DATA_FOR_REPLICATOR)-sizeof(UCHAR));
    default:
        Assert(FALSE && "Unknown Encryption Algorithm");
        break;
    }

    return(ClearLength);
}


ULONG ClearDataSize(
        IN ULONG EncryptedLength,
        IN ULONG AlgorithmId
        )
/*++

    Routine Description

        This routine computes the clear data size given the encrypted data
        data length and the algorithm ID to use

    Parameters

        EncryptedLength -- The length of the data in the clear
        AlgorithmId -- The algorithm to use

    Return Values

       The clear length
--*/
{
    switch(AlgorithmId)
    {
    case DS_PEK_DBLAYER_ENCRYPTION:
        return(EncryptedLength-sizeof(ENCRYPTED_DATA)+sizeof(UCHAR));
    case DS_PEK_DBLAYER_ENCRYPTION_WITH_SALT:
        return(EncryptedLength-sizeof(ENCRYPTED_DATA_WITH_SALT)+sizeof(UCHAR));
    case DS_PEK_DBLAYER_ENCRYPTION_FOR_REPLICATOR:
        return(EncryptedLength-sizeof(ENCRYPTED_DATA_FOR_REPLICATOR)+sizeof(UCHAR));
    default:
        Assert(FALSE && "Unknown Encryption Algorithm");
        break;
    }

    return(EncryptedLength);
}

NTSTATUS
PEKDecryptPekList(
    IN OUT ENCRYPTED_PEK_LIST * EncryptedPekList,
    IN ULONG cbEncryptedPekList,
    IN ULONG DecryptionKeyLength,
    IN PVOID DecryptionKey,
    IN ULONG OriginalPekListVersion
    )
/*++

    Routine Description

     This routine performs the actual decryption of the PEK list pointed
     to by EncryptedPekList. The entry pointed to by EncryptedPekList is
     always assumed to be in a format corresponding to the latest revision.
     The OriginalPekListVersion parameter indicates the original version,
     as retrieved from the database, so that appropriate encryption/decryption
     corrections can be made

     Arguments

        EncryptedPekList -- The pek list in encrypted form
        cbEncryptedPekList -- The size of the encrypted Pek list.
        DecryptionKeyLength -- The length of the decryption key
        DecryptionKey       -- Pointer to the decryption key
        OriginalPekListVarion -- tells the original version for appropriate encryption/
                                 decryption changes

     Return Values

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Decrypt the Blob passed in with the key supplied by winlogon
    //

    PEKInPlaceEncryptDecryptDataWithKey(
            DecryptionKey,
            DecryptionKeyLength,
            (OriginalPekListVersion==DS_PEK_PRE_RC2_W2K_VERSION)?
                NULL:EncryptedPekList->Salt,
            (OriginalPekListVersion==DS_PEK_PRE_RC2_W2K_VERSION)?
                0:sizeof(EncryptedPekList->Salt),
            1000, // Choose a very long hash length to slow down offline
                  // dictionary attacks.
            &EncryptedPekList->EncryptedData,
            cbEncryptedPekList - FIELD_OFFSET(ENCRYPTED_PEK_LIST,EncryptedData)
            );


    //
    // Verify that the key Made sense, by checking the Authenticator
    //

    if (memcmp(
            &(((CLEAR_PEK_LIST *)EncryptedPekList)->Authenticator),
            &g_PekListAuthenticator,
            sizeof(GUID))==0)
    {
        //
        // Yep, decrypted OK
        //

        Status = STATUS_SUCCESS;
    }
    else
    {
        Status = STATUS_WRONG_PASSWORD;
    }

    return(Status);
}

NTSTATUS
PEKUpgradeEncryptedPekListToCurrentVersion(
    IN OUT ENCRYPTED_PEK_LIST **EncryptedPekList,
    IN OUT PULONG pcbListSize,
    OUT PULONG OriginalVersion
    )
/*++

    This routine upgrades an encrypted Pek list to the current
    version.

    Parameters

          EncryptedPekList  , if upgrade was needed then the upgraded
                             list is returned in here

          pcbListSize        The new size of the list is returned in here

          pfUpgradeNeeded    -- Indicates that upgrade was needed

    Return Values

        STATUS_SUCCESS.
        Other error codes
--*/
{
    //
    // Carefully first check the revision no
    //

    if (DS_PEK_CURRENT_VERSION == (*EncryptedPekList)->Version )
    {
        //
        // Nothing is required
        //

        *OriginalVersion = DS_PEK_CURRENT_VERSION;
        return(STATUS_SUCCESS);
    }
    else if (DS_PEK_PRE_RC2_W2K_VERSION == (*EncryptedPekList)->Version)
    {
        //
        // Need to upgrade to the latest
        //

        ENCRYPTED_PEK_LIST_PRE_WIN2K_RC2 * OriginalList
            = (ENCRYPTED_PEK_LIST_PRE_WIN2K_RC2 * ) *EncryptedPekList;
        ULONG OriginalListSize = *pcbListSize;


        //
        // Generate the new list size
        //

        (*pcbListSize) += sizeof(ENCRYPTED_PEK_LIST)
                         - sizeof(ENCRYPTED_PEK_LIST_PRE_WIN2K_RC2);

        *EncryptedPekList = THAllocEx(pTHStls, *pcbListSize);

        //
        // Copy into the new list
        //

        (*EncryptedPekList)->BootOption = OriginalList->BootOption;
        (*EncryptedPekList)->Version = DS_PEK_CURRENT_VERSION;

        RtlCopyMemory(
            &((*EncryptedPekList)->EncryptedData),
            &OriginalList->EncryptedData,
            OriginalListSize
                - FIELD_OFFSET(ENCRYPTED_PEK_LIST_PRE_WIN2K_RC2,EncryptedData));


        //
        // Generate a new Clear Salt
        //

        if (!CDGenerateRandomBits(
                ((*EncryptedPekList)->Salt),
                sizeof((*EncryptedPekList)->Salt)))
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }


        *OriginalVersion = DS_PEK_PRE_RC2_W2K_VERSION;

        return(STATUS_SUCCESS);
    }
    else
    {
        return(STATUS_UNSUCCESSFUL);
    }
}



NTSTATUS
PEKGetClearPekList(
    IN OUT ENCRYPTED_PEK_LIST **EncryptedPekList,
    IN OUT PULONG             pcbEncryptedPekList,
    OUT    BOOLEAN            *pfTellLsaToGenerateSessionKeys,
    OUT    BOOLEAN            *pfSaveChanges,
    IN PVOID Syskey OPTIONAL,
    IN ULONG cbSyskey OPTIONAL
    )
/*++

    Routine Description

    This routines obtains the key to decrypt the PEK list from
    winlogon and then proceeds to decrypt the PEK list. The pek list
    is decrypted in place, and the structure can be cast into a
    Clear Pek list structure. If upgrading the list is required this
    routine upgrades it first and generates a new list.

    Parameters

        EncryptedPekList -- The list of PEKs encrypted with the session
                            key.

        pcbEncryptedPekList -- The count of bytes in the encrypted PEK list


        pfTellLsaToGenerateSessionKeys -- When upgrading a B3 or a RC1 DC to
                                          tell LSA to generate session keys.

        pfSaveChanges      -- Set to true if the list needs to be encrypted and
                              saved again using the new syskey. This occurs in
                              one of 2 cases -- A during a recovery from an error,
                              upon a syskey change, and B when upgrading to key
                              structures to most current revision
                              
        Syskey -- The key to use to Decrypt the PEK on this system
                  This key use used in the install from media case.
                  
        cbSyskey -- This the length of the syskey

    Return Values

        STATUS_SUCCESS
        Other NT error codes
--*/
{
    NTSTATUS       Status = STATUS_SUCCESS;
    NTSTATUS       DecryptStatus = STATUS_SUCCESS;
    HANDLE         WinlogonHandle=NULL;
    UCHAR          DecryptionKey[DS_PEK_KEY_SIZE];
    ULONG          DecryptionKeyLength = DS_PEK_KEY_SIZE;
    UCHAR          OldDecryptionKey[DS_PEK_KEY_SIZE];
    ULONG          OldDecryptionKeyLength = DS_PEK_KEY_SIZE;
    ULONG          Tries = 0;
    ULONG          KeyLength;
    UNICODE_STRING NewSessionKey;
    IN             ULONG OriginalVersion;

    *pfTellLsaToGenerateSessionKeys = FALSE;
    *pfSaveChanges = FALSE;


    //
    // Upgrade the list to most current version if necessary
    //

    Status = PEKUpgradeEncryptedPekListToCurrentVersion(
                    EncryptedPekList,
                    pcbEncryptedPekList,
                    &OriginalVersion
                    );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // O.K if we upgraded then set the save changes flag to true
    //

    if (OriginalVersion != DS_PEK_CURRENT_VERSION)
    {
        *pfSaveChanges = TRUE;
    }

    //
    // Call LSA to obtain the key information.
    //
    if(Syskey == NULL)
    {
    
        Status =    LsaIHealthCheck(
                        NULL,
                        LSAI_SAM_STATE_RETRIEVE_SESS_KEY,
                        DecryptionKey,
                        &DecryptionKeyLength
                        );
    } else {

        //We had the syskey passed into PEKInitialize
        //So we don't need to get it from LsaIHeathCheck

        RtlCopyMemory(DecryptionKey,Syskey,cbSyskey);
        DecryptionKeyLength=cbSyskey;

    }

    if (!NT_SUCCESS(Status))
    {
        //
        // This would happen when upgrading a win2K B3/RC1 DC. Note this code can be deleted post
        // RC2. Under normal circumstances this should happen only during GUI setup phase
        //

        Status = WxConnect(
                    &WinlogonHandle
                    );

        if (!NT_SUCCESS(Status))
        {
            //
            // Winlogon may fail if secret encryption is not enabled. In those
            // cases continue. Else Fail the boot
            //
            if (WxNone==(*EncryptedPekList)->BootOption)
            {
                Status = STATUS_SUCCESS;
            }

            goto Cleanup;
        }


        for (Tries = 0; Tries < DS_PEK_BOOT_KEY_RETRY_COUNT ; Tries++ )
        {

            //
            // Retry this RETRY_COUNT_TIMES, this allows the user a chance
            // to correct himself, in case he entered a wrong boot password
            //

            if (WxNone!=(*EncryptedPekList)->BootOption)
            {
                //
                // Get the key to be used to decrypt the PEK list
                //

                KeyLength = DS_PEK_KEY_SIZE;
                Status = WxGetKeyData(
                            WinlogonHandle,
                            (*EncryptedPekList)->BootOption,
                            DecryptionKeyLength,
                            DecryptionKey,
                            &DecryptionKeyLength
                            );
                if (!NT_SUCCESS(Status)) {
                    goto Cleanup;
                }

                Assert(DecryptionKeyLength==DS_PEK_KEY_SIZE);

                DecryptStatus = PEKDecryptPekList(
                                    *EncryptedPekList,
                                    *pcbEncryptedPekList,
                                    DecryptionKeyLength,
                                    DecryptionKey,
                                    OriginalVersion
                                    );

            }
            else
            {
                DecryptStatus = STATUS_SUCCESS;
                break;
            }
        }


        //
        // Tell winlogon regarding success or failure of the scheme
        //

        Status = WxReportResults(
                    WinlogonHandle,
                    DecryptStatus
                    );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }


       Status = DecryptStatus;

       if (NT_SUCCESS(Status))
       {
            *pfTellLsaToGenerateSessionKeys = TRUE;
       }

   }
   else
   {
       //
       // Normal case of getting the syskey from LSA.
       //

        if (WxNone!=(*EncryptedPekList)->BootOption)
        {

                //
                // Decrypt the Blob passed in with the key supplied by winlogon
                //

                Status = PEKDecryptPekList(
                                    *EncryptedPekList,
                                    *pcbEncryptedPekList,
                                    DecryptionKeyLength,
                                    DecryptionKey,
                                    OriginalVersion
                                    );

                if (!NT_SUCCESS(Status))
                {

                    //
                    // This could be the case of a syskey change erroring out such that the
                    // syskey provided by LSA corresponds to a more recent key and does not work.
                    // if So then proceed on obtaining the old key and verify decryption
                    //

                    Status = LsaIHealthCheck(
                                   NULL,
                                   LSAI_SAM_STATE_OLD_SESS_KEY,
                                   &OldDecryptionKey,
                                   &OldDecryptionKeyLength
                                   );

                    if (NT_SUCCESS(Status))
                    {
                        NTSTATUS IgnoreStatus;

                        //
                        // got back an old syskey value
                        //

                        //
                        // since the encryption is 2 way and in place, re-encrypt using new key
                        //

                        IgnoreStatus = PEKDecryptPekList(
                                            *EncryptedPekList,
                                            *pcbEncryptedPekList,
                                            DecryptionKeyLength,
                                            DecryptionKey,
                                            OriginalVersion
                                            );

                        Status = PEKDecryptPekList(
                                    *EncryptedPekList,
                                    *pcbEncryptedPekList,
                                    OldDecryptionKeyLength,
                                    OldDecryptionKey,
                                    OriginalVersion
                                    );

                        Assert((NT_SUCCESS(Status) && "Syskey Mismatch") || DsaIsInstallingFromMedia());

                        if (NT_SUCCESS(Status))
                        {
                            *pfSaveChanges = TRUE;
                        }



                    }
                    else
                    {
                        Assert(FALSE && "Syskey Mismatch and no old syskey");
                    }
                }
        }
   }

   if (NT_SUCCESS(Status))
   {
        RtlCopyMemory(
            g_PekWinLogonKey,
            DecryptionKey,
            DS_PEK_KEY_SIZE
            );
   }

Cleanup:

    if (WinlogonHandle != NULL) {
        NtClose(WinlogonHandle);
    }

    return(Status);
}

NTSTATUS
PekLetWinlogonProceed()
/*++

    Routine Description

        This routine connects to winlogon's wxlpc
        interface and tells it to proceed without
        prompting for floppy, password etc. This
        called in cases, where the secret encryption
        is not enabled, or the key is not yet setup
        ( eg upgrading current IDS builds ).

    Parameters:

        None

    Return Values

        NT Status error codes

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    HANDLE WinlogonHandle=NULL;

    NtStatus = WxConnect(
                &WinlogonHandle
                );

    if (NT_SUCCESS(NtStatus)) {
    {
        (VOID) WxReportResults(
                    WinlogonHandle,
                    STATUS_SUCCESS
                    );

        }
    }

    if (NULL!=WinlogonHandle)
        NtClose(WinlogonHandle);

    //
    // Return successful status. If secret
    // encryption is not actually turned
    // on then wxconnect will report a failure
    //

    return STATUS_SUCCESS;
}

NTSTATUS
PekGenerateNewKeySet(
   CLEAR_PEK_LIST **PekList)
/*++

   Routine Description

        This routine generates a new
        a new key set for DBlayer based
        encryption.

   Parameters:

        NewPekList -- The new PEK list is
        recieved under here

    Return Values

        Ntstatus Code. The global variable
        g_PekList contains the newly generated
        key set
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    SYSTEMTIME st;


    //
    // This is probably install time and we want
    // a new key set. Therefore allocate and initialize
    // a new key set and initialize it to good values
    //

    *PekList = malloc(ClearPekListSize(1));
    if (NULL==*PekList)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Error;
    }

    (*PekList)->Version = DS_PEK_CURRENT_VERSION;
    (*PekList)->BootOption = WxNone;

    if (!CDGenerateRandomBits(
            (*PekList)->Salt,
            sizeof((*PekList)->Salt)))
    {
        //
        // Could not generate a new salt
        // bail.

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;

    }

    RtlCopyMemory(
        &(*PekList)->Authenticator,
        &g_PekListAuthenticator,
        sizeof(GUID)
        );

    GetSystemTime(&st);
    SystemTimeToFileTime(&st,&g_PekList->LastKeyGenerationTime);
    (*PekList)->CurrentKey=0;
    (*PekList)->CountOfKeys = 1;
    (*PekList)->PekArray[0].V1.KeyId=0;
    if (!CDGenerateRandomBits(
            (*PekList)->PekArray[0].V1.Key,
            DS_PEK_KEY_SIZE
            ))
    {
        //
        // Could not generate the new session key
        // bail.

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

Error:

    return NtStatus;
}

NTSTATUS
PEKInitialize(
    IN DSNAME * Object OPTIONAL,
    IN ULONG Flags,
    IN PVOID Syskey OPTIONAL,
    IN ULONG cbSyskey OPTIONAL
    )
/*++

    Routine Description

    This routine initializes the PEK libarary

    Parameters

        Object -- DSNAME of the object where the
                  PEK data is stored

        Flags  -- Set of flags to control the operation
                  of this routine

                  DS_PEK_GENERATE_NEW_KEYSET implies that
                  a new key set be generated.

                  DS_PEK_READ_KEYSET Read and initialize the
                  Key Set from the domain object that is passed
                  in.
                  
        Syskey -- The key to use to Decrypt the PEK on this system
                  This key use used in the install from media case.
                  
        cbSyskey -- This the length of the syskey

    Return Values

        STATUS_SUCCESS
        Other Error Codes
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus = STATUS_SUCCESS;
    ULONG    err      = 0;
    DBPOS    *pDB=NULL;
    ATTCACHE *pACPekList = NULL;
    BOOLEAN  fCommit = FALSE;
    BOOLEAN  fSaveChanges = FALSE;
    THSTATE  *pTHS=pTHStls;
    BOOLEAN  fTellLsaToGenerateSessionKeys = FALSE;

    //
    // Validate parameters
    //

    Assert(VALID_THSTATE(pTHS));
    if ((NULL!=Syskey) && (cbSyskey!=DS_PEK_KEY_SIZE))
    {
        return(STATUS_INVALID_PARAMETER);
    }


    PEK_INITIALIZE_TRACE();

    //
    // Initialize a critical section for exclusion between writers.
    // No lock is taken by Readers, delayed free mechanism grants
    // exclusion among writers.
    //

    NtStatus = RtlInitializeCriticalSection(&g_PekCritSect);
    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    if (!PekEncryptionShouldBeEnabled())
    {
        //
        // If the encryption scheme is not to be enabled ( current status,
        // till required schema changes are made, and corresponding attids.h
        // and schema.ini is checked in ), proceed by simply returning a
        // STATUS_SUCCESS. However one more thing that we need to do is to
        // tell winlogon to proceed ( note SAM has stopped telling t
        // his to winlogon. Other wise winlogon would cause the system boot
        // to fail.
        //
       IgnoreStatus = PekLetWinlogonProceed();
       return STATUS_SUCCESS;
    }


    NtStatus = PekInitializeCheckSum();
    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    // the basic stuff are initialized up to here.
    // we have to exit at this point, since we cannot handle
    // secure keys if we are not running inside LSA.
    if (!gfRunningInsideLsa) {
        g_PekInitialized = TRUE;

        return NtStatus;
    }

    __try
    {
        //
        // Get the schema ptr to the PEK List attribute. This tests
        // wether the schema is ready for the DB layer encryption,
        // decryption stuff
        //

        if (!(pACPekList = SCGetAttById(pTHS, PekpListAttribute()))) {
            //
            // Well the attribute is not present in the
            // schema. ( say 1717.IDS was upgraded without
            // patching the schema). In this let the boot proceed,
            // without enabling the DBlayer based encryption
            //

            IgnoreStatus = PekLetWinlogonProceed();
            __leave;
        }


        if (Flags & DS_PEK_READ_KEYSET)
        {

            //
            // Normal Boot case, caller wants to read the
            // PEK list off of the domain object.
            //

            ULONG   cbEncryptedPekList=0;
            PVOID   EncryptedPekList=NULL;
            ULONG   cbClearPekList=0;
            PVOID   ClearPekList=NULL;


            Assert(ARGUMENT_PRESENT(Object));

            //
            // Save the DS Name of the object that was supplied
            //

            g_PekDataObject = (DSNAME *) malloc(Object->structLen);
            if (NULL==g_PekDataObject)
            {
                NtStatus = STATUS_NO_MEMORY;
                __leave;
            }

            RtlCopyMemory(g_PekDataObject,Object,Object->structLen);


            //
            // Begin a Transaction
            //

            DBOpen2(TRUE,&pDB);

            //
            // Position on the Domain Object
            //

            err = DBFindDSName(pDB,Object);
            if (0!=err)
            {
                Assert(FALSE && "Must Find Domain Object at Boot");
                NtStatus = STATUS_INTERNAL_ERROR;
                __leave;
            }

            //
            // READ the attribute
            //

            err = DBGetAttVal_AC (
	                pDB,
	                1,
	                pACPekList,
	                DBGETATTVAL_fINTERNAL|DBGETATTVAL_fREALLOC,
	                0,
	                &cbEncryptedPekList,
	                (PUCHAR *)&EncryptedPekList
	                );


            if (0==err)
            {
                //
                // We succeeded in reading the PEK list property out of
                // disk. Decrypt it ( by getting the key to decrypt ) from
                // winlogon if required. Note PEKGetClearPekList will let
                // winlogon proceed in the process of getting the key from
                // winlogon.
                //

                NtStatus = PEKGetClearPekList(
                                (ENCRYPTED_PEK_LIST **) &EncryptedPekList,
                                &cbEncryptedPekList,
                                &fTellLsaToGenerateSessionKeys,
                                &fSaveChanges,
                                Syskey,
                                cbSyskey
                                );

                if (!NT_SUCCESS(NtStatus))
                {
                    __leave;
                }

                //
                // O.K we have decrypted everything. Copy this
                // in global memory ( use malloc, as that's what
                // delayed memory free expects
                //

                g_PekList = malloc(cbEncryptedPekList);
                if (NULL==g_PekList)
                {
                    NtStatus = STATUS_NO_MEMORY;
                    __leave;
                }

                RtlCopyMemory(
                    g_PekList,
                    EncryptedPekList,
                    cbEncryptedPekList
                    );
            }
            else if (DB_ERR_NO_VALUE==err)
            {
                //
                // We could not read the attribute list, because one
                // did not exist. This is probably because, we are upgrading
                // a build such as 1717.IDS, and the schema change has now
                // propagated to this machine but the PEK list is not yet there
                // on the domain object. Handle this by creating a new
                // list and saving it so that encryption is enabled from now on
                //

                IgnoreStatus = PekLetWinlogonProceed();

                NtStatus = PekGenerateNewKeySet(&g_PekList);
                if (!NT_SUCCESS(NtStatus))
                {
                    __leave;
                }

                fSaveChanges = TRUE;

            }
            else
            {

                //
                // We could not read the attribute list for some other reason
                // ( Jet failures, resource failures etc. Fail the initialization
                //

                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                __leave;
            }

            fCommit = TRUE;
        }
        else if (Flags & DS_PEK_GENERATE_NEW_KEYSET)
        {

          //
          // This is the install case. The caller wants a new key set.
          // therefore generate one. Note that in this case it not necessary
          // to call into winlogon. This is because SAM would be booted into
          // registry mode and therefore would have made the necessary calls to
          // signal winlogon to proceed.
          //
          NtStatus = PekGenerateNewKeySet(&g_PekList);
        }
    }
    __finally
    {
        if (NULL!=pDB)
            DBClose(pDB,fCommit);
    }

	
    if (NT_SUCCESS(NtStatus))
    {
        ULONG DecryptionKeyLength = DS_PEK_KEY_SIZE;

        g_PekInitialized = TRUE;
        if (fTellLsaToGenerateSessionKeys)
        {
             NtStatus = LsaIHealthCheck(
                                NULL,
                                LSAI_SAM_STATE_SESS_KEY,
                                ( PVOID )g_PekWinLogonKey,
                                &DecryptionKeyLength);
        }

    }

    //
    // If we generated a new key and can save the changes then save
    // the changes
    //

    if ((fSaveChanges) && (NT_SUCCESS(NtStatus)))
    {
       NtStatus = PEKSaveChanges(Object);
    }

    //
    // Zero out the winlogon key ( ie the syskey )
    //

    RtlZeroMemory(g_PekWinLogonKey, DS_PEK_KEY_SIZE);



    return NtStatus;

}



ULONG
PEKComputeCheckSum(
    IN PBYTE Data,
    IN ULONG Length
    )
{
    ULONG CheckSum=0;
    PCHECKSUM_BUFFER Buffer;
    ULONG Seed = 12345678;
    NTSTATUS    Status = STATUS_SUCCESS;


    //
    // Use the check sum function to create the checksum
    //

    Status = g_PekCheckSumFunction->Initialize(Seed,&Buffer);
    if (!NT_SUCCESS(Status))
    {
        goto Error;
    }
    Status = g_PekCheckSumFunction->Sum(Buffer,Length,Data);
    if (!NT_SUCCESS(Status))
    {
        goto Error;
    }
    Status = g_PekCheckSumFunction->Finalize(Buffer,(UCHAR *)&CheckSum);
    if (!NT_SUCCESS(Status))
    {
        goto Error;
    }
    Status = g_PekCheckSumFunction->Finish(&Buffer);
    if (!NT_SUCCESS(Status))
    {
        goto Error;
    }



    return(CheckSum);

Error:

    Assert(FALSE && "Computation of Checksum Failed!");

    RaiseDsaExcept(
        DSA_CRYPTO_EXCEPTION,
        Status,
        0,
        DSID(FILENO,__LINE__),
        DS_EVENT_SEV_MINIMAL
        );

    return(0);

}


ULONG
PEKCheckSum(
    IN PBYTE Data,
    IN ULONG Length
    )
/*++
    Routine Description

        This routine does creates a checksum for the passed in data.

    Parameters

        Data - the data
        Length - the actual lenght of the data

--*/
{
    Assert(IsPekInitialized());

    if (!IsPekInitialized())
    {
        return 0;
    }
    else {
        return PEKComputeCheckSum (Data, Length);
    }
}


VOID
PEKEncrypt(
    IN THSTATE *pTHS,
    IN PVOID   PassedInData,
    IN ULONG   PassedInLength,
    OUT PVOID  EncryptedData OPTIONAL,
    OUT PULONG EncryptedLength
    )
/*++
    Routine Description

        This routine does the encryption using the current
        key in the key set of the Passed in data that is provided
        If the thread state has fDRA set then this routine checks whether
        the remote machine supports the strong encryption extension. If so
        then this routine will first decrypt the data with the session key
        established with the remote machine that is set on the thread state and
        then re-encrypt using the password encryption key. Encryption adds a header
        that is used for versioning the encryption algorithm.

    Parameters

        PassedInData        -- The Passed in Data
        PassedInDataLength  -- The Passed in data length
        EncryptedData       -- The encrypted Data
        EncryptedLength     -- The length of the encrypted data

--*/
{

    ULONG ClearLength = 0;
    ENCRYPTED_DATA_FOR_REPLICATOR * ReplicatorData = NULL;


    //
    // If encryption is not enabled bail. This condition should legally never
    // occur now, as we have encryption always initializeds. In the early days this
    // code was introduced we could disable it so that the condition below reduces to
    // one of no encryption
    //

    Assert(IsPekInitialized());

    if (!IsPekInitialized())
    {
        *EncryptedLength = PassedInLength;
        if ARGUMENT_PRESENT(EncryptedData)
        {
            RtlMoveMemory(
                EncryptedData,
                PassedInData,
                *EncryptedLength
                );
        }
    }
    else
    {


        //
        // If this is the DRA thread and the remote server supported the
        // strong encryption extension, then the data has been encrypted with the
        // session key established. Also the checksum is prepended before the
        // encryption, so account for that when computing the encrypted length
        //

        if (pTHS->fDRA &&
                IS_DRS_EXT_SUPPORTED(pTHS->pextRemote, DRS_EXT_STRONG_ENCRYPTION))
        {

            //
            // The data is encrypted using the session key. So get the correct clear
            // length by using the ClearDataLength Function
            //

            ClearLength = ClearDataSize(PassedInLength,DS_PEK_DBLAYER_ENCRYPTION_FOR_REPLICATOR);
        }
        else
        {
            ClearLength = PassedInLength;
        }

        //
        // While writing we now DBLAYER_ENCRYPTION_WITH_SALT algorithm. So compute the
        // encrypted length for the preferred algorithm
        //

        *EncryptedLength = EncryptedDataSize(ClearLength, DS_PEK_DBLAYER_ENCRYPTION_WITH_SALT);


        if (ARGUMENT_PRESENT(EncryptedData))
        {

            PVOID DataToEncrypt=NULL;
            ULONG ActualDataOffSet = 0;
            ENCRYPTED_DATA_WITH_SALT * EncryptedDataWithSalt = NULL;

            if (pTHS->fDRA &&
                IS_DRS_EXT_SUPPORTED(pTHS->pextRemote, DRS_EXT_STRONG_ENCRYPTION))
            {
                //
                // This is a DRA thread and the remote client supports strong encryption
                // over the wire and a session key has been established and set
                // on the thread state. Therefore first decrypt the data using the
                // session key
                //
                ULONG i=0;
                ULONG CheckSum=0;
                ULONG ComputedCheckSum=0;

                //
                // Since the encryption/decryption routines are called as part
                // of IntExtOct,and IntExt functions treat the input data striclty
                // as an in parameter, copy the data before decrypting it
                //

                ReplicatorData = THAllocEx(pTHS,PassedInLength);
                 
                RtlCopyMemory(ReplicatorData,PassedInData,PassedInLength);


                if (pTHS->SessionKey.SessionKeyLength>0)
                {
                    //
                    // We succeeded, in retrieving the key
                    // decrypt the data
                    //



                    PEK_TRACE("DECRYPT-R-B, key", pTHS->SessionKey.SessionKey, pTHS->SessionKey.SessionKeyLength);
                    PEK_TRACE("DECRYPT-R-B, salt",  ReplicatorData->Salt, sizeof(ReplicatorData->Salt));
                    PEK_TRACE("DECRYPT-R-B, data", (PBYTE)&ReplicatorData->CheckSum, ClearLength + sizeof(ReplicatorData->CheckSum));

                    PEKInPlaceEncryptDecryptDataWithKey(
                        pTHS->SessionKey.SessionKey,
                        pTHS->SessionKey.SessionKeyLength,
                        &ReplicatorData->Salt,
                        sizeof(ReplicatorData->Salt),
                        1,
                        &ReplicatorData->CheckSum, // the checksum is encrypted too
                        ClearLength + sizeof(ReplicatorData->CheckSum)
                        );

                    PEK_TRACE("DECRYPT-R-A, key", pTHS->SessionKey.SessionKey, pTHS->SessionKey.SessionKeyLength);
                    PEK_TRACE("DECRYPT-R-A, salt",  ReplicatorData->Salt, sizeof(ReplicatorData->Salt));
                    PEK_TRACE("DECRYPT-R-A, data", (PBYTE)&ReplicatorData->CheckSum, ClearLength + sizeof(ReplicatorData->CheckSum));

                }
                else
                {
                    //
                    // We do not have the session key, but the remote machine may
                    // have encrypted the data. Try the data without any decryption.
                    // In the remote chance that the remote machine also did not
                    // encrypt the data, the checksums will match resulting in us
                    // validating and accepting the data
                    //
                }


                //
                // Retrieve the CheckSum.
                //

                CheckSum = ReplicatorData->CheckSum;

                //
                // The data to encrypt now is the encrypted data for the replicator
                // that has been decrypted now
                //

                DataToEncrypt = ReplicatorData->EncryptedData;

                //
                // Compute the checksum of the decrypted data
                //

                ComputedCheckSum = PEKComputeCheckSum(
                                        DataToEncrypt,
                                        ClearLength
                                        );
                //
                // Check the Check Sums
                //

                if (CheckSum!=ComputedCheckSum)
                {
                    //
                    // The checksum did not match the computed CheckSum
                    //

                    Assert(FALSE && "Checksum did not match after decryption!");

                    //
                    // We error'd trying to decrypt the data
                    // Raise and Exception in this case

                    RaiseDsaExcept(
                        DSA_CRYPTO_EXCEPTION,
                        SEC_E_DECRYPT_FAILURE,
                        0,
                        DSID(FILENO,__LINE__),
                        DS_EVENT_SEV_MINIMAL
                        );

                }
                
            }
            else
            {
                DataToEncrypt = PassedInData;
            }


            //
            // Cast the pointer as a pointer to EncryptedDataWithSalt,
            // as that is what is now finally produced by this function
            //
            EncryptedDataWithSalt = (ENCRYPTED_DATA_WITH_SALT *)EncryptedData;

            //
            // Set the algorithm id, key id and flags
            //

            EncryptedDataWithSalt->AlgorithmId = DS_PEK_DBLAYER_ENCRYPTION_WITH_SALT;
            EncryptedDataWithSalt->Flags = 0;
            EncryptedDataWithSalt->KeyId = g_PekList->CurrentKey;

            //
            // Generate the Salt for encryption
            //

            CDGenerateRandomBits(
                EncryptedDataWithSalt->Salt,
                sizeof(EncryptedDataWithSalt->Salt)
                );

            RtlMoveMemory(
                &EncryptedDataWithSalt->EncryptedData,
                DataToEncrypt,
                ClearLength
                );


            //
            //  Encrypt the data
            //

            PEKInPlaceEncryptDecryptDataWithKey(
                g_PekList->PekArray[g_PekList->CurrentKey].V1.Key,
                DS_PEK_KEY_SIZE,
                &EncryptedDataWithSalt->Salt,
                sizeof(EncryptedDataWithSalt->Salt),
                1,
                &EncryptedDataWithSalt->EncryptedData,
                ClearLength
                );
        }

    }

    if (ReplicatorData) {
        THFreeEx(pTHS,ReplicatorData);
    }

    return;
}


BOOLEAN
IsValidPEKHeader(
    IN ENCRYPTED_DATA *EncryptedData,
    IN ULONG  EncryptedLength
)
{
    //
    // less that even the size of old SAM
    // header
    //

    if (EncryptedLength<sizeof(ULONG))
        return(FALSE);

    //
    // Probably the Old SAM encryption
    //

    if (EncryptedData->AlgorithmId < DS_PEK_DBLAYER_ENCRYPTION)
        return (TRUE);

    //
    // Not sufficient length for our encryption
    //

    if (EncryptedLength < sizeof(ENCRYPTED_DATA))
        return (FALSE);

    //
    // Unknown Algorithm ID ( for encrypted data encountered from database )
    //

    if ((EncryptedData->AlgorithmId!=DS_PEK_DBLAYER_ENCRYPTION)
        && (EncryptedData->AlgorithmId!=DS_PEK_DBLAYER_ENCRYPTION_WITH_SALT))
        return (FALSE);

    //
    // Says Our Encryption scheme. Check that we have a valid
    // Key ID
    //

    if (EncryptedData->KeyId>=g_PekList->CountOfKeys)
    {
       //
       // Key ID is not correct.
       //

       return(FALSE);
    }

    return (TRUE);
}

VOID
PekDecryptData(
    IN ENCRYPTED_DATA * EncryptedData,
    IN PVOID            BufferToDecrypt,
    IN ULONG            LengthToDecrypt
    )
/*++

    This routine does the actual work of decryption by looking at the algorithm id
    in the encrypted data structure. This is used to decrypt data retrieved from 
    the database

    Paramaters

        EncryptedData
        BufferToDecrypt
        LengthToDecrypt

    Return Values

        None
--*/
{


    //
    // Presently 2 types of encrypted data can be encounterd from the database
    // 1. Data encrypted using DS_PEK_DBLAYER_ENCRYPTION  This is used by win2k Beta2
    // 2. Data encrypted using DS_PEK_DBLAYER_ENCRYPTION_WITH_SALT. 
    //    This is used by win2k Beta3 and beyond
    //


    if (DS_PEK_DBLAYER_ENCRYPTION==EncryptedData->AlgorithmId)
    {
        ULONG KeyId = EncryptedData->KeyId;

        RtlMoveMemory(
            BufferToDecrypt,
            &EncryptedData->EncryptedData,
            LengthToDecrypt
            );

        PEKInPlaceEncryptDecryptDataWithKey(
            g_PekList->PekArray[KeyId].V1.Key,
            DS_PEK_KEY_SIZE,
            NULL, // No Salt is used in this encryption type
            0,
            0,
            BufferToDecrypt,
            LengthToDecrypt
            );
    }
    else
    {
        ENCRYPTED_DATA_WITH_SALT * EncryptedDataWithSalt = (ENCRYPTED_DATA_WITH_SALT *) EncryptedData;
        ULONG KeyId = EncryptedDataWithSalt->KeyId;


        //
        // The only other type of encryption that we should encounter should be based upon
        // DS_PEK_DBLAYER_ENCRYPTION_WITH_SALT
        //

        Assert(DS_PEK_DBLAYER_ENCRYPTION_WITH_SALT==EncryptedData->AlgorithmId);

        RtlMoveMemory(
            BufferToDecrypt,
            &EncryptedDataWithSalt->EncryptedData,
            LengthToDecrypt
            );

        PEKInPlaceEncryptDecryptDataWithKey(
            g_PekList->PekArray[KeyId].V1.Key,
            DS_PEK_KEY_SIZE,
            &EncryptedDataWithSalt->Salt,
            sizeof(EncryptedDataWithSalt->Salt),
            1,
            BufferToDecrypt,
            LengthToDecrypt
            );

    }
}


VOID
PEKDecrypt(
    IN THSTATE *pTHS,
    IN PVOID InputData,
    IN ULONG EncryptedLength,
    OUT PVOID  OutputData, OPTIONAL
    OUT PULONG OutputLength
    )
/*++
    Routine Description

        This routine does the decryption using the
        keyid in the header of the encrypted data that is provided.
        If the thread state has fDRA set then this routine checks whether
        the remote machine supports the strong encryption extension. If so
        then this routine will first decrypt the data and then re-encrypt
        with the session key established with the remote machine that is
        set on the thread state. Decryption removes the header that is used
        for versioning encryption. For the DRA case the re-encrypted data
        is re-encrypted with a checksum prepended to the front.

    Parameters

        ClearData -- The Clear Data
        ClearDataLength -- The Length of the Clear Data
        EncryptedData   -- The encrypted Data
        EncryptedLength -- The length of the encrypted data

--*/
{
    ENCRYPTED_DATA * EncryptedData = InputData;


    if ((!IsPekInitialized())
        ||(!IsValidPEKHeader(EncryptedData,EncryptedLength))
        ||(EncryptedData->AlgorithmId<DS_PEK_DBLAYER_ENCRYPTION))
    {
        //
        // If encryption is not enabled , or if it is the old format, not
        // encrypted using the new method of encryption then no decryption
        // is required. Further if the format is not something that we
        // understand then also let it go in the clear
        //


        *OutputLength = EncryptedLength;
        if (ARGUMENT_PRESENT(OutputData))
        {
            RtlMoveMemory(OutputData,EncryptedData,*OutputLength);
        }
    }
    else
    {
        //
        // The data is encrypted by the DBLAYER  Therefore proceed decrypting it
        //


        ULONG LengthToDecrypt=0;
        ULONG ActualDataOffSet =0;


        //
        // DS_PEK_DBLAYER_ENCRYPTION_WITH_SALT is the current encryption 
        // algorithm. Prior to that in very old implementations of the DS
        // a method that did not use a salt was used. We still have code to
        // read that encryption, just in case we chance upon in a domain like
        // ntdev that has a lot of history. The new encryption has been in force
        // ever since win2k Beta2
        //
 
        Assert((DS_PEK_DBLAYER_ENCRYPTION==EncryptedData->AlgorithmId)||
                (DS_PEK_DBLAYER_ENCRYPTION_WITH_SALT==EncryptedData->AlgorithmId));

        //
        // Compute the length to decrypt
        //

        LengthToDecrypt = ClearDataSize(EncryptedLength,EncryptedData->AlgorithmId);

        if (pTHS->fDRA &&
                IS_DRS_EXT_SUPPORTED(pTHS->pextRemote, DRS_EXT_STRONG_ENCRYPTION))
        {
            //
            // If it is the replicator and the remote machine supports the strong encryption
            // extension we need re-encrypt the data
            //

            *OutputLength = EncryptedDataSize(LengthToDecrypt,DS_PEK_DBLAYER_ENCRYPTION_FOR_REPLICATOR);
            ActualDataOffSet = FIELD_OFFSET(ENCRYPTED_DATA_FOR_REPLICATOR,EncryptedData);
        }
        else if (pTHS->fDRA &&
                    (!IS_DRS_EXT_SUPPORTED(pTHS->pextRemote, DRS_EXT_STRONG_ENCRYPTION)))
        {
            //
            // It is the replicator and the remote machine does not support strong encryption
            // It is a security hole to replicate with someone who does not support the strong encryption flag
            // as then passwords travel over the wire with the weak encryption flag
            //

            RaiseDsaExcept(
                        DSA_CRYPTO_EXCEPTION,
                        SEC_E_ALGORITHM_MISMATCH,
                        0,
                        DSID(FILENO,__LINE__),
                        DS_EVENT_SEV_MINIMAL
                        );
        }
        else
        {
            //
            // Not the replicator, return the data in the clear
            //

            *OutputLength = LengthToDecrypt;
            ActualDataOffSet = 0;
        }


        if (ARGUMENT_PRESENT(OutputData))
        {

            PBYTE DataToDecrypt = (PBYTE) OutputData +  (UINT_PTR) (ActualDataOffSet);

            //
            // Decrypt the data, using the algorithm and key specified in InputData
            // PekDecryptData decrypts the data and then moves the decrypted data into
            // DataToDecrypt
            //

            PekDecryptData(
                InputData,
                DataToDecrypt,
                LengthToDecrypt
                );


            if (pTHS->fDRA &&
                IS_DRS_EXT_SUPPORTED(pTHS->pextRemote, DRS_EXT_STRONG_ENCRYPTION))
            {
                //
                // This is a DRA thread and the remote client supports strong encryption
                // over the wire. In this case try re-encrypting the data with the session
                // key that has been established, using the following steps
                //

                ENCRYPTED_DATA_FOR_REPLICATOR * ReplicatorData = OutputData;

                //
                // 1. Compute a checksum. This checksum will be used to verify correct
                // decryption at the remote end
                //

                ULONG i=0;
                ULONG CheckSum = 0;

                CheckSum = PEKComputeCheckSum(
                             DataToDecrypt,
                             LengthToDecrypt
                             );



                ReplicatorData->CheckSum = CheckSum;


                //
                // 2. Invent a salt for MD5 hashing the key. Place the salt in the
                // clear as part of the replicator data stream. If CDGenerateRandom
                // bits failed, then an uninitialized variable is our salt. That is
                // O.K as we pass the salt in the clear
                //


                CDGenerateRandomBits(
                    ReplicatorData->Salt,
                    sizeof(ReplicatorData->Salt)
                    );

                //
                // 3. Check if a session key is available in pTHStls
                //

                if  ( pTHS->SessionKey.SessionKeyLength >0)
                {
                    //
                    // We succeeded, in retrieving the key
                    // re-encrypt the data, using the session key
                    // Encrypt the checksum too, as the checksum contains
                    // bits representing the data
                    //


                    PEK_TRACE("ENCRYPT-R-B, key", pTHS->SessionKey.SessionKey, pTHS->SessionKey.SessionKeyLength);
                    PEK_TRACE("ENCRYPT-R-B  salt",  ReplicatorData->Salt, sizeof(ReplicatorData->Salt));
                    PEK_TRACE("ENCRYPT-R-B  data", (PBYTE) &ReplicatorData->CheckSum, LengthToDecrypt + sizeof(ReplicatorData->CheckSum));

                    PEKInPlaceEncryptDecryptDataWithKey(
                        pTHS->SessionKey.SessionKey,
                        pTHS->SessionKey.SessionKeyLength,
                        &ReplicatorData->Salt,
                        sizeof(ReplicatorData->Salt),
                        1,
                        &ReplicatorData->CheckSum,
                        LengthToDecrypt + sizeof(ReplicatorData->CheckSum)
                        );

                    PEK_TRACE("ENCRYPT-R-A key", pTHS->SessionKey.SessionKey, pTHS->SessionKey.SessionKeyLength);
                    PEK_TRACE("ENCRYPT-R-A salt",  ReplicatorData->Salt, sizeof(ReplicatorData->Salt));
                    PEK_TRACE("ENCRYPT-R-A data", (PBYTE) &ReplicatorData->CheckSum, LengthToDecrypt + sizeof(ReplicatorData->CheckSum));
                }
                else
                {
                    //
                    // We are talking to a replica that supports the strong encryption
                    // extension. Still we have not established a session key with the
                    // replica. This condition should never ever happen in practice
                    //

                    Assert(FALSE && "Should not happen -- no session key");

                    RaiseDsaExcept(
                       DSA_CRYPTO_EXCEPTION,
                       SEC_E_ALGORITHM_MISMATCH,
                       0,
                       DSID(FILENO,__LINE__),
                       DS_EVENT_SEV_MINIMAL
                      );
                }
            }

        }
    }



    return;
}

NTSTATUS
PekSaveChangesWithKey(
    THSTATE *pTHS,
    DSNAME *ObjectToSave,
    CLEAR_PEK_LIST *PekList,
    PVOID Key,
    ULONG KeyLength
    )
/*++

    Encrypts the Data with the key provided
    and stores it on the object

    Parameters
        PekList  --- The PEK list to encrypt
        Key      --- The key to be used for encryption
        KeyLength -- The length of the key to be used for
                     encryption
    Return values

        STATUS_SUCCESS
        <Other Error Codes>

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ENCRYPTED_PEK_LIST * EncryptedPekList;
    ULONG                err=0;
    ATTCACHE            *pACPekList=NULL;
    DBPOS               *pDB=NULL;
    ULONG                pekListSize = 0;
    BOOLEAN             fCommit = FALSE;

    Assert(VALID_THSTATE(pTHStls));

    if (!IsPekInitialized())
    {
        //
        // Nothing to do
        //

        return STATUS_SUCCESS;
    }

    //
    // Encrypt the list with the passed in key
    //

    //
    // First copy in the data to a new buffer as we prefer not
    // to touch the original
    //

    pekListSize = ClearPekListSize(PekList->CountOfKeys);
    EncryptedPekList = (ENCRYPTED_PEK_LIST *) THAllocEx(pTHS, pekListSize);
    RtlCopyMemory(EncryptedPekList,PekList,pekListSize);

    if (WxNone!=PekList->BootOption)
    {
        PEKInPlaceEncryptDecryptDataWithKey(
            Key,
            KeyLength,
            EncryptedPekList->Salt, // No Salt
            sizeof(EncryptedPekList->Salt),
            1000,
            &EncryptedPekList->EncryptedData,
            pekListSize
                - FIELD_OFFSET(CLEAR_PEK_LIST,Authenticator)
            );
    }

    __try
    {
        //
        // Get the schema ptr to the PEK List attribute
        //

        if (!(pACPekList = SCGetAttById(pTHS, PekpListAttribute())))
        {
            //
            // Well the attribute is not present in the
            // schema. Maybe this is an old schema. In
            // this case secret encryption is not enabled
            //

            NtStatus = STATUS_UNSUCCESSFUL;
            __leave;
        }

        //
        // Save the data on the object that we need to save by default.
        //


        //
        // Begin a Transaction
        //

        DBOpen2(TRUE,&pDB);

        //
        // Position on the Domain Object
        //

        err = DBFindDSName(pDB,ObjectToSave);
        if (0!=err)
        {
            Assert(FALSE && "Must Find Domain Object at Boot");
            NtStatus = STATUS_INTERNAL_ERROR;
            __leave;
        }


        //
        // Set the attribute
        //

        err = DBReplaceAttVal_AC (
	        pDB,
	        1,
	        pACPekList,
                pekListSize,
	        (PUCHAR )EncryptedPekList
	        );

        if (0!=err)
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            __leave;
        }

        //
        // Update the record
        //

        err = DBUpdateRec(pDB);
        if (0!=err)
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            __leave;
        }

        fCommit = TRUE;

    }
    __finally
    {

        //
        // Commit the transaction
        //

        DBClose(pDB,fCommit);
    }


    return NtStatus;

}

NTSTATUS
PEKSaveChanges( DSNAME *ObjectToSave)
/*++

    Routine Description

    This routine saves the PEK list after encrypting it with
    the key that winlogon provided. This is called once during
    install time

--*/
{
    THSTATE *pTHS=pTHStls;

    if (!IsPekInitialized())
    {
        //
        // Nothing to do
        //

        return STATUS_SUCCESS;
    }

    //
    // Save the DS Name of the object that was supplied
    //

    g_PekDataObject = (DSNAME *) malloc(ObjectToSave->structLen);
    if (NULL==g_PekDataObject)
    {
        return (STATUS_NO_MEMORY);
    }

    RtlCopyMemory(g_PekDataObject,ObjectToSave,ObjectToSave->structLen);

    return(PekSaveChangesWithKey(
            pTHS,
            ObjectToSave,
            g_PekList,
            g_PekWinLogonKey,
            DS_PEK_KEY_SIZE));
}

NTSTATUS
PEKAddKey(
   IN PVOID NewKey,
   IN ULONG cbNewKey
   )
/*++

    Generates and adds a new key to the password encryption key list.

    Parameters:

        None

    Return Values

        STATUS_SUCCESS
        Other Error Codes
--*/
{
    THSTATE *pTHS=pTHStls;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    CLEAR_PEK_LIST *NewPekList = NULL;
    SYSTEMTIME  st;

    if (!IsPekInitialized())
    {
        //
        // Nothing to do
        //

        return STATUS_SUCCESS;
    }

    //
    // Enter the critical section to provide exclusion
    // with other writers. The only writers are AddKey
    // and Change Boot options. Both acquire the critical
    // section before making any modifications. The delayed
    // memory free technique is used to provide exclusion
    // with writers.
    //

    NtStatus = RtlEnterCriticalSection(&g_PekCritSect);
    if (!NT_SUCCESS(NtStatus))
        return NtStatus;

    __try
    {
        NewPekList = malloc(ClearPekListSize(g_PekList->CountOfKeys+1));
        if (NULL==NewPekList)
        {
            NtStatus = STATUS_NO_MEMORY;
            __leave;

        }

        RtlCopyMemory(NewPekList,g_PekList,ClearPekListSize(g_PekList->CountOfKeys));

        NewPekList->CountOfKeys++;

        NewPekList->CurrentKey=g_PekList->CountOfKeys;
        NewPekList->PekArray[g_PekList->CountOfKeys].V1.KeyId
            =g_PekList->CountOfKeys;
        if (!CDGenerateRandomBits(
                NewPekList->PekArray[g_PekList->CountOfKeys].V1.Key,
                DS_PEK_KEY_SIZE
                ))
        {
            //
            // Could not generate the new session key
            // bail.

            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            __leave;
        }

        GetSystemTime(&st);
        SystemTimeToFileTime(&st,&g_PekList->LastKeyGenerationTime);

        NtStatus = PekSaveChangesWithKey(
                        pTHS,
                        g_PekDataObject,
                        NewPekList,
                        NewKey,
                        cbNewKey
                        );
    }
    __finally
    {
        if (NT_SUCCESS(NtStatus))
        {
            PVOID     OldPekList;

            OldPekList = g_PekList;
            g_PekList = NewPekList;

            //
            // Insert PekList in task queue to free memory
            // in a delayed fashion ( after 1 hour )
            //
            DELAYED_FREE(OldPekList);

        }
        else
        {
            if (NULL!=NewPekList)
                free(NewPekList);
        }

        RtlLeaveCriticalSection(&g_PekCritSect);
    }

    return NtStatus;
}






FILETIME
PEKGetLastKeyGenerationTime()
{
    FILETIME Never = {0,0};

    if (IsPekInitialized())
    {
        return g_PekList->LastKeyGenerationTime;
    }
    else
    {
        return Never;
    }
}


NTSTATUS
PEKChangeBootOption(
    WX_AUTH_TYPE    BootOption,
    ULONG           Flags,
    PVOID           NewKey,
    ULONG           cbNewKey
    )
/*++

    Changes the system startup option, and also encrypts the password
    encryption key with the new syskey. This routine is called only
    by inprocess callers who when changing either the boot option or
    the syskey.

    Parameters:

        BootOption -- The new boot option

        Flags      --  Currently No flags are defined.

        NewKey,cbNewKey -- The new key to encrypt the
                           PEK list with.
--*/
{
    THSTATE *pTHS=pTHStls;
    NTSTATUS    NtStatus = STATUS_SUCCESS;

     if ((0==cbNewKey)||(NULL==NewKey))
            return (STATUS_INVALID_PARAMETER);

    if (!IsPekInitialized())
    {
        //
        // Nothing to DO
        //

        return (STATUS_SUCCESS);
    }

    if (NULL==g_PekDataObject)
    {
        //
        // Called at setup time, between the
        // PekInitialize and the PekSaveChanges
        //

        return (STATUS_UNSUCCESSFUL);
    }

    //
    // Enter the critical section to provide exclusion
    // with other writers. The only writers are AddKey
    // and Change Boot options. Both acquire the critical
    // section before making any modifications. The delayed
    // memory free technique is used to provide exclusion
    // with writers.
    //

    NtStatus = RtlEnterCriticalSection(&g_PekCritSect);
    if (!NT_SUCCESS(NtStatus))
        return NtStatus;

    __try
    {


        //
        // At this point this is either a set operation or
        // a change password operation, which has passed the
        // the old password test.
        //


        //
        // We access Boot option in g_PekList global variable.
        // This variable is only of interest
        // to ChangeBootOption or AddNewKey , both of which access
        // them while holding the PEK crit sect. Readers that
        // just want to decrypt their passwords do not access these
        // variables
        //
        g_PekList->BootOption = BootOption;

        NtStatus = PekSaveChangesWithKey(
                        pTHS,
                        g_PekDataObject,
                        g_PekList,
                        NewKey,
                        cbNewKey
                        );
    }
    __finally
    {

        RtlLeaveCriticalSection(&g_PekCritSect);
    }

    return NtStatus;


}



WX_AUTH_TYPE
PEKGetBootOptions(VOID)
{
    if (IsPekInitialized())
        return (g_PekList->BootOption);
    else
        return (WxNone);
}


VOID
PEKClearSessionKeys(
    THSTATE * pTHS
    )
/*++

    Routine Description

    This function clears the session keys in the thread state.

    Return Values:

    None
--*/
{


    if (pTHS->SessionKey.SessionKeyLength>0)
    {
        Assert(NULL!=pTHS->SessionKey.SessionKey);

        if (NULL!=pTHS->SessionKey.SessionKey)
        {
            //
            // First Zero the key.
            //

            RtlZeroMemory(
                pTHS->SessionKey.SessionKey,
                pTHS->SessionKey.SessionKeyLength
                );

            //
            // Now Free the session Key
            //

            THFreeOrg(pTHS,pTHS->SessionKey.SessionKey);
            pTHS->SessionKey.SessionKey = NULL;
        }

        pTHS->SessionKey.SessionKeyLength = 0;

        PEK_TRACE("CLEAR_SESSION KEY", 0,0);

    }


}

VOID
PEKUseSessionKey(
    THSTATE * pTHS,
    ULONG     SessionKeyLength,
    PVOID     SessionKey
    )
/*++

  Routine Description

  This function  Sets the session key on the thread state

  Parameters

  SessionKeyLength -- Length of the session key
  SessionKey       -- Pointer to the session key

--*/
{
    //
    // First Clear any existing session Key
    //

    PEKClearSessionKeys(pTHS);

    pTHS->SessionKey.SessionKey = THAllocOrgEx(pTHS,SessionKeyLength);
    RtlCopyMemory(
        pTHS->SessionKey.SessionKey,
        SessionKey,
        SessionKeyLength
        );

    pTHS->SessionKey.SessionKeyLength = SessionKeyLength;

    PEK_TRACE("USE SESSION KEY", SessionKey, SessionKeyLength);
}

NTSTATUS
PEKGetSessionKey(
    THSTATE * pTHS,
    VOID * RpcContext
    )
/*++

  Given an RPC binding handle this routine will retrieve the
  security context and retrieve the session key from the security
  context and set it on the thread state

  Parameters:

    pTHS -- Pointer to the thread state
    RpcContext -- Pointer to the RPC binding handle

--*/
{
    SECURITY_STATUS Status;
    SecPkgContext_SessionKey SessionKey;
    RPC_STATUS      RpcStatus;
    VOID            *SecurityContext;

#if DBG
    pTHS->pRpcCallHandle = RpcContext;
#endif

    PEK_TRACE("RPC CONTEXT", (PUCHAR) &RpcContext,sizeof(VOID *));

    //
    // Get the security context from the
    // RPC handle
    //

    RpcStatus = I_RpcBindingInqSecurityContext(
                    RpcContext,
                    &SecurityContext
                    );
    if (RpcStatus != RPC_S_OK)
    {
        return (RpcStatus);
    }

#if DBG
    pTHS->pRpcSecurityContext = SecurityContext;
#endif

    PEK_TRACE("SECURITY CONTEXT",(PUCHAR) &SecurityContext, sizeof(VOID *));

    Status = QueryContextAttributesW(
                SecurityContext,
                SECPKG_ATTR_SESSION_KEY,
                &SessionKey
                );
    if (0==Status)
    {
        //
        // Set the session key on the thread state.  PEKUseSessionKey
        // can except, so put cleanup in __finally.
        //

        __try {
            PEKUseSessionKey(
                pTHS,
                SessionKey.SessionKeyLength,
                SessionKey.SessionKey
                );
        } __finally {
            //
            // Cleanup memory allocated by QueryContextAttributesW
            //

            FreeContextBuffer(SessionKey.SessionKey);
        }
    }


    return(Status);
}

NTSTATUS
PEKGetSessionKey2(
    SESSION_KEY *SessionKeyOut,
    VOID * RpcContext
    )
/*++

  Given an RPC binding handle this routine will retrieve the
  security context and retrieve the session key from the security
  context and set it in the caller's SESSION_KEY struct.
  SessionKeyOut->SessionKey will be malloc'd.

  Parameters:

    SessionKeyOut -- Address of where to put the key.
    RpcContext -- Pointer to the RPC binding handle

--*/
{
    SECURITY_STATUS Status;
    SecPkgContext_SessionKey SessionKey;
    RPC_STATUS      RpcStatus;
    VOID            *SecurityContext;
    PUCHAR          puchar;


    //
    // Caller should always call with an empty SESSION_KEY.
    //

    Assert(!SessionKeyOut->SessionKeyLength && !SessionKeyOut->SessionKey);
    memset(SessionKeyOut, 0, sizeof(SESSION_KEY));

    //
    // Get the security context from the
    // RPC handle
    //

    RpcStatus = I_RpcBindingInqSecurityContext(
                    RpcContext,
                    &SecurityContext
                    );
    if (RpcStatus != RPC_S_OK)
    {
        return (RpcStatus);
    }



    Status = QueryContextAttributesW(
                SecurityContext,
                SECPKG_ATTR_SESSION_KEY,
                &SessionKey
                );

    if ( 0 == Status )
    {
        //
        // Set the out parameters.
        //

        if ( !(puchar = (PUCHAR) malloc(SessionKey.SessionKeyLength)) )
        {
            Status = STATUS_NO_MEMORY;
        }
        else
        {
            RtlCopyMemory(puchar,
                          SessionKey.SessionKey,
                          SessionKey.SessionKeyLength);
            SessionKeyOut->SessionKey = puchar;
            SessionKeyOut->SessionKeyLength = SessionKey.SessionKeyLength;
        }

        //
        // Cleanup memory allocated by QueryContextAttributesW
        //

        FreeContextBuffer(SessionKey.SessionKey);
    }

    return(Status);
}

VOID
PEKSecurityCallback(VOID * Context)
/*++

  Routine Description

  This routine is the call back routine from RPC,
  for the security context. THis call back is enabled
  by making a specific call into RPC before issuing an
  RPC call.

  Parameters

    Context -- A handle passed in by RPC that can
               be passed in as a binding handle to
               RPC to retreive the security context.
--*/
{
    THSTATE *pTHS = pTHStls;
    RPC_STATUS rpcStatus;
    NTSTATUS ntStatus;
    RPC_ASYNC_STATE * pRpcAsyncState;
    DRS_ASYNC_RPC_STATE * pAsyncState;

    rpcStatus = I_RpcBindingHandleToAsyncHandle(Context, &pRpcAsyncState);
    
    if (!rpcStatus) {
        // This callback was generated by an async RPC call.  Was it an async
        // DRS RPC call?

        pAsyncState = CONTAINING_RECORD(pRpcAsyncState,
                                        DRS_ASYNC_RPC_STATE,
                                        RpcState);

        if (DRSIsRegisteredAsyncRpcState(pAsyncState)) {
            // Destroy last saved session key, if any.
            PEKDestroySessionKeySavedByDiffThread(&pAsyncState->SessionKey);
    
            // Get the current session key from RPC.
            ntStatus = PEKGetSessionKey2(&pAsyncState->SessionKey, Context);

            // We (NTDSA) originated this RPC client call, so:
            // (1) we shouldn't be using LPC, as that would imply we're
            //     generating an RPC call to ourselves, and
            // (2) we shouldn't be using NTLM authentication (should be
            //     Kerberos).
            // This eliminates the known cases where we would not be able to
            // retrieve the associated session key, with the exception of local
            // resource (e.g., memory) exhaustion.
            //
            // If the following assertion fires, verify the machine is low on
            // resources.
            Assert(!ntStatus);

            Assert(NULL != pAsyncState->SessionKey.SessionKey);
            Assert(0 != pAsyncState->SessionKey.SessionKeyLength);
            
            DPRINT3(1, "Retrieved session key for DRS_ASYNC_RPC_STATE %p: %d bytes @ %p.\n",
                    pAsyncState, pAsyncState->SessionKey.SessionKeyLength,
                    pAsyncState->SessionKey.SessionKey);

            // We've successfully saved the session key for our async RPC call
            // (or made our best attempt) -- we're done.
            return;
        } else {
            // This is not necesarily a problem, but if this fires check it out
            // to make sure it's valid -- i.e., that someone else in lsass is
            // using async RPC, and that this isn't a case where it really is
            // our async call but we couldn't find it in our list for some
            // reason.
            Assert(!"PEKSecurityCallback invoked on async RPC call we didn't originate!");

            // Fall through to non-async RPC case.
        }
    }

    //
    // Firewall against a spurious thread state in case
    // we got this call back when we do not have a thread
    // state.
    //

    if (NULL==pTHS)
    {
        //
        // NULL thread state
        // Do nothing
        //

        return;
    }

    //
    // Use the call context to get the security context
    // Keeping all the logic in PEKGetSessionKey allows us to
    // keep all the logic in that one function, allowing us
    // to directly call that on the server side
    //

    PEKGetSessionKey(pTHS,Context);
}

VOID
PEKSaveSessionKeyForMyThread(
    IN OUT  THSTATE *       pTHS,
    OUT     SESSION_KEY *   pSessionKey
    )
/*++

Routine Description:

    Save the current THSTATE session key such that it can later be restored
    via PEKRestoreSessionKeySavedByMyThread().

Arguments:

    pTHS (IN)
    
    pSessionKey (OUT) - Repository for current session key.

Return Values:

    None.

--*/
{
    pSessionKey->SessionKey = pTHS->SessionKey.SessionKey;
    pSessionKey->SessionKeyLength = pTHS->SessionKey.SessionKeyLength;
    pTHS->SessionKey.SessionKey = NULL;
    pTHS->SessionKey.SessionKeyLength = 0;

    PEK_TRACE("SAVE SESSION KEY SAME THREAD", 0, 0);
}

VOID
PEKRestoreSessionKeySavedByMyThread(
    IN OUT  THSTATE *       pTHS,
    IN      SESSION_KEY *   pSessionKey
    )
/*++

Routine Description:

    Restore the THSTATE session key saved via a previous call to
    PEKSaveSessionKey().

Arguments:

    pTHS (IN)
    
    pSessionKey (IN) - Session key saved by PEKSaveSessionKeyForMyThread().

Return Values:

    None.

--*/
{
    PEKClearSessionKeys(pTHS);
    pTHS->SessionKey.SessionKey = pSessionKey->SessionKey;
    pTHS->SessionKey.SessionKeyLength = pSessionKey->SessionKeyLength;
    pSessionKey->SessionKey = NULL;
    pSessionKey->SessionKeyLength = 0;

    PEK_TRACE("RESTORE SESSION KEY SAME THREAD",
              pTHS->SessionKey.SessionKey,
              pTHS->SessionKey.SessionKeyLength);
}

VOID
PEKRestoreSessionKeySavedByDiffThread(
    IN OUT  THSTATE *       pTHS,
    IN      SESSION_KEY *   pSessionKey
    )
/*++

Routine Description:

    Restore the session key saved via a previous call to PEKGetSessionKey2().

Arguments:

    pTHS (IN)
    
    pSessionKey (IN) - Session key saved by PEKGetSessionKey2().

Return Values:

    None.

--*/
{
    if (0 == pSessionKey->SessionKeyLength) {
        Assert(NULL == pSessionKey->SessionKey);
        PEKClearSessionKeys(pTHS);
    }
    else {
        Assert(NULL != pSessionKey->SessionKey);

        __try {
            PEKUseSessionKey(pTHS, 
                             pSessionKey->SessionKeyLength,
                             pSessionKey->SessionKey);
        }
        __finally {
            free(pSessionKey->SessionKey);
            
            pSessionKey->SessionKey = NULL;
            pSessionKey->SessionKeyLength = 0;
        }
    }
}

VOID
PEKDestroySessionKeySavedByDiffThread(
    IN OUT  SESSION_KEY *   pSessionKey
    )
/*++

Routine Description:

    Destroy the session key saved via a previous call to PEKGetSessionKey2().

Arguments:

    pSessionKey (IN/OUT) - Session key saved by PEKGetSessionKey2().

Return Values:

    None.

--*/
{
    if (0 != pSessionKey->SessionKeyLength) {
        Assert(NULL != pSessionKey->SessionKey);
        free(pSessionKey->SessionKey);
        
        pSessionKey->SessionKey = NULL;
        pSessionKey->SessionKeyLength = 0;
    }
    else {
        Assert(NULL == pSessionKey->SessionKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\nspis\nspserv.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       nspserv.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module implements entry points for the NSPI wire functions.

Author:

    Tim Williams (timwi) 1996

Revision History:

NOTE:

    To enforce security, it is necessary for any routine that calls GetIndexSize
    to call ABCheckContainerSecurity in this module and to save and restore the
    containerID in the stat.  See abtools.c for the function
    ABCheckContainerSecurity.  See NspiUpdateStat for an example of how to
    implement the security check in this module.

--*/


#include <NTDSpch.h>
#pragma  hdrstop


#include <ntdsctr.h>                   // PerfMon hooks

// Core headers.
#include <ntdsa.h>                      // Core data types
#include <scache.h>                     // Schema cache code
#include <dbglobal.h>                   // DBLayer header.
#include <mdglobal.h>                   // THSTATE definition
#include <dsatools.h>                   // Memory, etc.

// Logging headers.
#include <mdcodes.h>                    // Only needed for dsevent.h
#include <dsevent.h>                    // Only needed for LogUnhandledError

// Assorted DSA headers.
#include <dsexcept.h>

// Assorted MAPI headers.
#include <mapidefs.h>                   // Definitions for the MAPI scodes
#include <mapicode.h>                   //  we need.

// Address book interface headers.
#include "nspi.h"                       // defines the nspi wire interface
#include "nsp_both.h"
#include "abdefs.h"

#include <dstrace.h>

#include <debug.h>
#include <fileno.h>
#define  FILENO FILENO_NSPSERV

// Useful macro
#define SCODE_FROM_THS(x) (x?(x->errCode?x->errCode:MAPI_E_CALL_FAILED):MAPI_E_NOT_ENOUGH_MEMORY)



SCODE
NspiUpdateStat(
        NSPI_HANDLE hRpc,
        DWORD dwFlags,
        PSTAT pStat,
        LPLONG plDelta
        )
/*++

Routine Description:

    Nspi wire function.  Just a wrapper around a local version.

    This routine may change the value of pStat->ContainerID to enforce security
    while inside the DSA.  Save and restore the ContainerID.

Arguments:

    See ABUpdateStat_local.

ReturnValue:

    See ABUpdateStat_local.

--*/
{
    SCODE         scode=SUCCESS_SUCCESS;
    DWORD         ContainerID=pStat->ContainerID;
    INDEXSIZE     IndexSize;
    
    THSTATE *pTHS;
    __try {
        PERFINC(pcBrowse);                  // PerfMon hook
        INC(pcThread);                  // PerfMon hook
        pTHS = InitTHSTATE(CALLERTYPE_NSPI);
        if(!pTHS) {
            scode = MAPI_E_CALL_FAILED;
            __leave;
        }

        LogAndTraceEvent(FALSE,
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_NSPI_BEGIN_UPDATE_STAT,
                         EVENT_TRACE_TYPE_START,
                         DsGuidNspiUpdateStat,
                         szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL);

        DBOpen2(TRUE, &pTHS->pDB);
        __try {
            ABCheckContainerRights(pTHS,
                                   (NSPI_CONTEXT *)hRpc,
                                   pStat,
                                   &IndexSize);
            
            scode=ABUpdateStat_local(pTHS,
                                     dwFlags,
                                     pStat,
                                     &IndexSize,
                                     plDelta);
        }
        __finally {
            DBClose(pTHS->pDB, TRUE);
        }
    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        if(!scode)
            scode = SCODE_FROM_THS(pTHS);
        if(plDelta)
            *plDelta=0;
    }
    DEC(pcThread);                      // PerfMon hook
    
    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_NSPI_END_UPDATE_STAT,
                     EVENT_TRACE_TYPE_END,
                     DsGuidNspiUpdateStat,
                     szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                     szInsertUL(scode), 
                     NULL, NULL, NULL, NULL, NULL, NULL);

    pStat->ContainerID = ContainerID;

    return scode;
}


SCODE
NspiCompareDNTs(
        NSPI_HANDLE hRpc,
        DWORD dwFlags,
        PSTAT pStat,
        DWORD DNT1,
        DWORD DNT2,
        LPLONG plResult
        )
/*++

Routine Description:

    Nspi wire function.  Just a wrapper around a local version.

    This routine may change the value of pStat->ContainerID to enforce security
    while inside the DSA.  Save and restore the ContainerID.

Arguments:

    See ABCompareDNTs_local.

ReturnValue:

    See ABCompareDNTs_local.

--*/
{
    SCODE         scode=SUCCESS_SUCCESS;
    DWORD  ContainerID=pStat->ContainerID;
    INDEXSIZE     IndexSize;
    THSTATE *pTHS;
    __try {
        PERFINC(pcBrowse);                  // PerfMon hook
        INC(pcThread);                  // PerfMon hook
        pTHS = InitTHSTATE(CALLERTYPE_NSPI);
        if(!pTHS) {
            scode = MAPI_E_CALL_FAILED;
            __leave;
        }
        
        LogAndTraceEvent(FALSE,
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_NSPI_BEGIN_COMPARE_DNT,
                         EVENT_TRACE_TYPE_START,
                         DsGuidNspiCompareDNTs,
                         szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        
        DBOpen2(TRUE, &pTHS->pDB);
        __try {
            ABCheckContainerRights(pTHS,
                                   (NSPI_CONTEXT *)hRpc,
                                   pStat,
                                   &IndexSize);
            
            scode=ABCompareDNTs_local(pTHS,
                                      dwFlags,
                                      pStat,
                                      &IndexSize,
                                      DNT1,
                                      DNT2,
                                      plResult);
        }
        __finally {
            DBClose(pTHS->pDB, TRUE);
        }
    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        if(!scode)
            scode = SCODE_FROM_THS(pTHS);
    }
    DEC(pcThread);                      // PerfMon hook
    
    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_NSPI_END_COMPARE_DNT,
                     EVENT_TRACE_TYPE_END,
                     DsGuidNspiCompareDNTs,
                     szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                     szInsertUL(scode), 
                     NULL, NULL, NULL, NULL, NULL, NULL);
    
    pStat->ContainerID = ContainerID;

    return scode;
}

SCODE
NspiQueryRows(
        NSPI_HANDLE hRpc,
        DWORD dwFlags,
        PSTAT pStat,
        DWORD dwEphsCount,
        DWORD * lpdwEphs,
        DWORD Count,
        LPSPropTagArray_r pPropTags,
        LPLPSRowSet_r ppRows
        )
/*++

Routine Description:

    Nspi wire function.  Just a wrapper around a local version.

    This routine may change the value of pStat->ContainerID to enforce security
    while inside the DSA.  Save and restore the ContainerID.

Arguments:

    See ABQueryRows_local.

ReturnValue:

    See ABQueryRows_local.

--*/
{
    SCODE         scode=SUCCESS_SUCCESS;
    DWORD         ContainerID=pStat->ContainerID;
    INDEXSIZE     IndexSize;
    
    THSTATE *pTHS;
    __try {
        PERFINC(pcBrowse);                  // PerfMon hook
        INC(pcThread);                  // PerfMon hook
        pTHS = InitTHSTATE(CALLERTYPE_NSPI);
        if(!pTHS) {
            scode = MAPI_E_CALL_FAILED;
            __leave;
        }
        
        LogAndTraceEvent(FALSE,
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_NSPI_BEGIN_QUERY_ROWS,
                         EVENT_TRACE_TYPE_START,
                         DsGuidNspiQueryRows,
                         szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                         szInsertUL( Count ),
                         NULL, NULL, NULL, NULL, NULL, NULL);

        DBOpen2(TRUE, &pTHS->pDB);
        __try {
            if (dwEphsCount == 0) {
                ABCheckContainerRights(pTHS,
                                   (NSPI_CONTEXT *)hRpc,
                                   pStat,
                                   &IndexSize);
            }

            scode=ABQueryRows_local(pTHS,
                                    (NSPI_CONTEXT *)hRpc,
                                    dwFlags,
                                    pStat,
                                    &IndexSize,
                                    dwEphsCount,
                                    lpdwEphs,
                                    Count,
                                    pPropTags,
                                    ppRows);
        }
        __finally {
            DBClose(pTHS->pDB, TRUE);
        }
    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        if(!scode)
            scode = SCODE_FROM_THS(pTHS);
    }
    DEC(pcThread);                      // PerfMon hook
    
    
    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_NSPI_END_QUERY_ROWS,
                     EVENT_TRACE_TYPE_END,
                     DsGuidNspiQueryRows,
                     szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                     szInsertUL(scode), 
                     NULL, NULL, NULL, NULL, NULL, NULL);
    
    
    pStat->ContainerID = ContainerID;

    return scode;
}

SCODE
NspiSeekEntries(NSPI_HANDLE hRpc,
                DWORD dwFlags,
                PSTAT pStat,
                LPSPropValue_r pTarget,
                LPSPropTagArray_r Restriction,
                LPSPropTagArray_r pPropTags,
                LPLPSRowSet_r ppRows)
/*++

Routine Description:

    Nspi wire function.  Just a wrapper around a local version.

    This routine may change the value of pStat->ContainerID to enforce security
    while inside the DSA.  Save and restore the ContainerID.

Arguments:

    See ABSeekEntries_local.

ReturnValue:

    See ABSeekEntries_local.

--*/
{
    SCODE scode=SUCCESS_SUCCESS;
    DWORD       ContainerID=pStat->ContainerID;
    INDEXSIZE   IndexSize;
    THSTATE *pTHS;
    __try {
        PERFINC(pcBrowse);                  // PerfMon hook
        PERFINC(pcNspiObjectSearch);        // PerfMon hook
        INC(pcThread);                  // PerfMon hook
        pTHS = InitTHSTATE(CALLERTYPE_NSPI);
        if(!pTHS) {
            scode = MAPI_E_CALL_FAILED;
            __leave;
        }
        
        LogAndTraceEvent(FALSE,
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_NSPI_BEGIN_SEEK_ENTRIES,
                         EVENT_TRACE_TYPE_START,
                         DsGuidNspiSeekEntries,
                         szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL);

        DBOpen2(TRUE, &pTHS->pDB);
        __try {
            ABCheckContainerRights(pTHS,
                                   (NSPI_CONTEXT *)hRpc,
                                   pStat,
                                   &IndexSize);
            
            scode = ABSeekEntries_local(pTHS,
                                        (NSPI_CONTEXT *)hRpc,
                                        dwFlags,
                                        pStat,
                                        &IndexSize,
                                        pTarget,
                                        Restriction,
                                        pPropTags,
                                        ppRows);
        }
        __finally {
            DBClose(pTHS->pDB, TRUE);
        }
    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        if(!scode)                      // no error set yet?
            scode = SCODE_FROM_THS(pTHS);
    }
    DEC(pcThread);                      // PerfMon hook
    
    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_NSPI_END_SEEK_ENTRIES,
                     EVENT_TRACE_TYPE_END,
                     DsGuidNspiSeekEntries,
                     szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                     szInsertUL(scode), 
                     NULL, NULL, NULL, NULL, NULL, NULL);
    
    pStat->ContainerID = ContainerID;
    return scode;

}

SCODE
NspiGetMatches(
        NSPI_HANDLE         hRpc,
        DWORD               dwFlags,
        PSTAT               pStat,
        LPSPropTagArray_r   pInDNTList,
        ULONG               ulInterfaceOptions,
        LPSRestriction_r    pRestriction,
        LPMAPINAMEID_r      lpPropName,
        ULONG               ulRequested,
        LPLPSPropTagArray_r ppDNTList,
        LPSPropTagArray_r   pPropTags,
        LPLPSRowSet_r       ppRows
        )
/*++

Routine Description:

    Nspi wire function.  Just a wrapper around a local version.

    This routine may change the value of pStat->ContainerID to enforce security
    while inside the DSA.  Save and restore the ContainerID.

Arguments:

    See ABGetMatches_local.

ReturnValue:

    See ABGetMatches_local.

--*/
{
    SCODE scode=SUCCESS_SUCCESS;
    DWORD       ContainerID=pStat->ContainerID;
    INDEXSIZE   IndexSize;
    
    THSTATE *pTHS;
    __try {
        PERFINC(pcBrowse);                  // PerfMon hook
        PERFINC(pcNspiObjectMatches);       // PerfMon hook
        INC(pcThread);                  // PerfMon hook
        pTHS = InitTHSTATE(CALLERTYPE_NSPI);
        if(!pTHS) {
            scode = MAPI_E_CALL_FAILED;
            __leave;
        }

        LogAndTraceEvent(FALSE,
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_NSPI_BEGIN_GET_MATCHES,
                         EVENT_TRACE_TYPE_START,
                         DsGuidNspiGetMatches,
                         szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL);

        DBOpen2(TRUE, &pTHS->pDB);
        __try {
            ABCheckContainerRights(pTHS,
                                   (NSPI_CONTEXT *)hRpc,
                                   pStat,
                                   &IndexSize);
            
            scode = ABGetMatches_local(pTHS,
                                       dwFlags,
                                       pStat,
                                       &IndexSize,
                                       pInDNTList,
                                       ulInterfaceOptions,
                                       pRestriction,
                                       lpPropName,
                                       ulRequested,
                                       ppDNTList,
                                       pPropTags,
                                       ppRows);
        }
        __finally {
            DBClose(pTHS->pDB, TRUE);
        }
    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        if(!scode)                      // no error set yet?
            scode = SCODE_FROM_THS(pTHS);
    }
    DEC(pcThread);                      // PerfMon hook
    
    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_NSPI_END_GET_MATCHES,
                     EVENT_TRACE_TYPE_END,
                     DsGuidNspiGetMatches,
                     szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                     szInsertUL(scode), 
                     NULL, NULL, NULL, NULL, NULL, NULL);
    
    pStat->ContainerID = ContainerID;
    return scode;

}

SCODE
NspiResolveNames (
        NSPI_HANDLE hRpc,
        DWORD dwFlags,
        PSTAT pStat,
        LPSPropTagArray_r pPropTags,
        LPStringsArray_r paStr,
        LPLPSPropTagArray_r ppFlags,
        LPLPSRowSet_r ppRows)
/*++

Routine Description:

    Nspi wire function.  Just a wrapper around a local version.

    This routine may change the value of pStat->ContainerID to enforce security
    while inside the DSA.  Save and restore the ContainerID.

Arguments:

    See ABResolveNames_local.

ReturnValue:

    See ABResolveNames_local.

--*/
{
    SCODE scode=SUCCESS_SUCCESS;
    DWORD       ContainerID=pStat->ContainerID;
    INDEXSIZE   IndexSize;
    THSTATE *pTHS;
    __try {
        PERFINC(pcBrowse);                  // PerfMon hook
        INC(pcThread);                  // PerfMon hook
        pTHS = InitTHSTATE(CALLERTYPE_NSPI);
        if(!pTHS) {
            scode = MAPI_E_CALL_FAILED;
            __leave;
        }
        
        LogAndTraceEvent(FALSE,
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_NSPI_BEGIN_RESOLVE_NAMES,
                         EVENT_TRACE_TYPE_START,
                         DsGuidNspiResolveNames,
                         szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL);

        DBOpen2(TRUE, &pTHS->pDB);
        __try {
            ABCheckContainerRights(pTHS,
                                   (NSPI_CONTEXT *)hRpc,
                                   pStat,
                                   &IndexSize);
            
            scode = ABResolveNames_local(pTHS,
                                         dwFlags,
                                         pStat,
                                         &IndexSize,
                                         pPropTags,
                                         paStr,
                                         NULL,
                                         ppFlags,
                                         ppRows);
        }
        __finally {
            DBClose(pTHS->pDB, TRUE);
        }
    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        if(!scode)                      // no error set yet?
            scode = SCODE_FROM_THS(pTHS);
    }
    DEC(pcThread);                      // PerfMon hook
    
    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_NSPI_END_RESOLVE_NAMES,
                     EVENT_TRACE_TYPE_END,
                     DsGuidNspiResolveNames,
                     szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                     szInsertUL(scode), 
                     NULL, NULL, NULL, NULL, NULL, NULL);
    
    pStat->ContainerID = ContainerID;
    return scode;

}

SCODE
NspiResolveNamesW (
        NSPI_HANDLE hRpc,
        DWORD dwFlags,
        PSTAT pStat,
        LPSPropTagArray_r pPropTags,
        LPWStringsArray_r paWStr,
        LPLPSPropTagArray_r ppFlags,
        LPLPSRowSet_r ppRows)
/*++

Routine Description:

    Nspi wire function.  Just a wrapper around a local version.

    This routine may change the value of pStat->ContainerID to enforce security
    while inside the DSA.  Save and restore the ContainerID.

Arguments:

    See ABResolveNames_local.

ReturnValue:

    See ABResolveNames_local.

--*/
{
    SCODE scode=SUCCESS_SUCCESS;
    DWORD       ContainerID=pStat->ContainerID;
    INDEXSIZE   IndexSize;
    THSTATE *pTHS;
    __try {
        PERFINC(pcBrowse);                  // PerfMon hook
        INC(pcThread);                  // PerfMon hook
        pTHS = InitTHSTATE(CALLERTYPE_NSPI);
        if(!pTHS) {
            scode = MAPI_E_CALL_FAILED;
            __leave;
        }
        
        LogAndTraceEvent(FALSE,
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_NSPI_BEGIN_RESOLVE_NAMES,
                         EVENT_TRACE_TYPE_START,
                         DsGuidNspiResolveNames,
                         szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL);

        DBOpen2(TRUE, &pTHS->pDB);
        __try {
            ABCheckContainerRights(pTHS,
                                   (NSPI_CONTEXT *)hRpc,
                                   pStat,
                                   &IndexSize);
            
            scode = ABResolveNames_local(pTHS,
                                         dwFlags,
                                         pStat,
                                         &IndexSize,
                                         pPropTags,
                                         NULL,
                                         paWStr,
                                         ppFlags,
                                         ppRows);
        }
        __finally {
            DBClose(pTHS->pDB, TRUE);
        }
    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        if(!scode)                      // no error set yet?
            scode = SCODE_FROM_THS(pTHS);
    }
    DEC(pcThread);                      // PerfMon hook
    
    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_NSPI_END_RESOLVE_NAMES,
                     EVENT_TRACE_TYPE_END,
                     DsGuidNspiResolveNames,
                     szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                     szInsertUL(scode), 
                     NULL, NULL, NULL, NULL, NULL, NULL);
    
    pStat->ContainerID = ContainerID;
    return scode;

}

SCODE
NspiDNToEph(
        NSPI_HANDLE hRpc,
        DWORD dwFlags,
        LPStringsArray_r pNames,
        LPLPSPropTagArray_r ppEphs
        )
/*++

Routine Description:

    Nspi wire function.  Just a wrapper around a local version.

Arguments:

    See ABDNToEph_local.

ReturnValue:

    See ABDNToEph_local.

--*/
{
    SCODE scode=SUCCESS_SUCCESS;
    THSTATE *pTHS;
    __try {
        PERFINC(pcBrowse);                  // PerfMon hook
        INC(pcThread);                  // PerfMon hook
        pTHS = InitTHSTATE(CALLERTYPE_NSPI);
        if(!pTHS) {
            scode = MAPI_E_CALL_FAILED;
            __leave;
        }
        
        LogAndTraceEvent(FALSE,
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_NSPI_BEGIN_DNT2EPH,
                         EVENT_TRACE_TYPE_START,
                         DsGuidNspiDNToEph,
                         szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL);


        DBOpen2(TRUE, &pTHS->pDB);
        __try {
            scode = ABDNToEph_local(pTHS,
                                    dwFlags,
                                    pNames,
                                    ppEphs);
        }
        __finally {
            DBClose(pTHS->pDB, TRUE);
        }
    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        if(!scode)                      // no error set yet?
            scode = SCODE_FROM_THS(pTHS);
        *ppEphs = NULL;
    }
    DEC(pcThread);                      // PerfMon hook
    
    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_NSPI_END_DNT2EPH,
                     EVENT_TRACE_TYPE_END,
                     DsGuidNspiDNToEph,
                     szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                     szInsertUL(scode), 
                     NULL, NULL, NULL, NULL, NULL, NULL);

    return scode;

}

SCODE
NspiGetHierarchyInfo (
        NSPI_HANDLE hRpc,
        DWORD dwFlags,
        PSTAT pStat,
        LPDWORD lpVersion,
        LPLPSRowSet_r HierTabRows
        )
/*++

Routine Description:

    Nspi wire function.  Just a wrapper around a local version.

Arguments:

    See ABGetHierarchyInfo_local.

ReturnValue:

    See ABGetHierarchyInfo_local.

--*/
{
    SCODE scode=SUCCESS_SUCCESS;
    THSTATE    *pTHS;
    __try {
        PERFINC(pcBrowse);                  // PerfMon hook
        INC(pcThread);                  // PerfMon hook
        pTHS = InitTHSTATE(CALLERTYPE_NSPI);
        if(!pTHS) {
            scode = MAPI_E_CALL_FAILED;
            __leave;
        }

        LogAndTraceEvent(FALSE,
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_NSPI_BEGIN_HIERARCHY_INFO,
                         EVENT_TRACE_TYPE_START,
                         DsGuidNspiGetHierarchyInfo,
                         szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL);

        DBOpen2(TRUE, &pTHS->pDB);
        __try {
            scode = ABGetHierarchyInfo_local(pTHS,
                                             dwFlags,
                                             (NSPI_CONTEXT *)hRpc,
                                             pStat,
                                             lpVersion,
                                             HierTabRows);
        }
        __finally {
            DBClose(pTHS->pDB, TRUE);
        }
    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        if(!scode)                      // no error set yet?
            scode = SCODE_FROM_THS(pTHS);
        *HierTabRows = NULL;
    }
    DEC(pcThread);                      // PerfMon hook
    
    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_NSPI_END_HIERARCHY_INFO,
                     EVENT_TRACE_TYPE_END,
                     DsGuidNspiGetHierarchyInfo,
                     szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                     szInsertUL(scode), 
                     NULL, NULL, NULL, NULL, NULL, NULL);

    return scode;
}

SCODE
NspiResortRestriction(
        NSPI_HANDLE         hRpc,
        DWORD               dwFlags,
        PSTAT               pStat,
        LPSPropTagArray_r   pInDNTList,
        LPSPropTagArray_r  *ppOutDNTList
        )
/*++

Routine Description:

    Nspi wire function.  Just a wrapper around a local version.

Arguments:

    See ABResortRestriction_local.

ReturnValue:

    See ABResortRestriction_local.

--*/
{
    SCODE scode=SUCCESS_SUCCESS;
    THSTATE *pTHS;
    __try {
        PERFINC(pcBrowse);                  // PerfMon hook
        INC(pcThread);                  // PerfMon hook
        pTHS = InitTHSTATE(CALLERTYPE_NSPI);
        if(!pTHS) {
            scode = MAPI_E_CALL_FAILED;
            __leave;
        }
        
        LogAndTraceEvent(FALSE,
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_NSPI_BEGIN_RESORT_RESTRICTION,
                         EVENT_TRACE_TYPE_START,
                         DsGuidNspiResortRestriction,
                         szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        
        DBOpen2(TRUE, &pTHS->pDB);
        __try {
            scode = ABResortRestriction_local(pTHS,
                                              dwFlags,
                                              pStat,
                                              pInDNTList,
                                              ppOutDNTList);
        }
        __finally {
            DBClose(pTHS->pDB, TRUE);
        }
    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        if(!scode)                      // no error set yet?
            scode = SCODE_FROM_THS(pTHS);
    }
    DEC(pcThread);                      // PerfMon hook
    
    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_NSPI_END_RESORT_RESTRICTION,
                     EVENT_TRACE_TYPE_END,
                     DsGuidNspiResortRestriction,
                     szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                     szInsertUL(scode), 
                     NULL, NULL, NULL, NULL, NULL, NULL);
    
    return scode;

}

SCODE
NspiBind(
        NSPI_HANDLE hRpc,
        DWORD dwFlags,
        PSTAT pStat,
        LPMUID_r pServerGuid,
        NSPI_HANDLE *contextHandle
        )
/*++

Routine Description:

    Nspi wire function.  Just a wrapper around a local version.

Arguments:

    See ABBind_local.

ReturnValue:

    See ABBind_local.

--*/
{
    SCODE scode=SUCCESS_SUCCESS;
    THSTATE *pTHS;
    DWORD sessionNumber = 0;
    
    __try {
        PERFINC(pcBrowse);                  // PerfMon hook
        INC(pcThread);                  // PerfMon hook
        pTHS = InitTHSTATE(CALLERTYPE_NSPI);
        if(!pTHS) {
            scode = MAPI_E_CALL_FAILED;
            __leave;
        }

        LogAndTraceEvent(FALSE,
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_NSPI_BEGIN_BIND,
                         EVENT_TRACE_TYPE_START,
                         DsGuidNspiBind,
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        
        DBOpen2(TRUE, &pTHS->pDB);
        __try {
            scode = ABBind_local(pTHS,
                                 hRpc,
                                 dwFlags,
                                 pStat,
                                 pServerGuid,
                                 contextHandle);
        }
        __finally {
            DBClose(pTHS->pDB, TRUE);
        }
    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        if(!scode)                      // no error set yet?
            scode = SCODE_FROM_THS(pTHS);
    }

    if(scode == SUCCESS_SUCCESS) {
        INC(pcABClient);                // PerfMon hook
    }
    DEC(pcThread);                      // PerfMon hook
    

    
    if (*contextHandle) {
        sessionNumber = ( ((NSPI_CONTEXT *)*contextHandle)->BindNumber );
    }

    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_NSPI_END_BIND,
                     EVENT_TRACE_TYPE_END,
                     DsGuidNspiBind,
                     szInsertUL (sessionNumber),
                     szInsertUL(scode), 
                     NULL, NULL, NULL, NULL, NULL, NULL);
    
    return scode;

}

DWORD
NspiUnbind(
        NSPI_HANDLE *contextHandle,
        DWORD dwFlags
        )
/*++

Routine Description:

    Nspi wire function.  Unbinds.  Doesn't do much as we don't make much use of
    the context handles.

Arguments:

    contextHandle - the RPC context handle

    dwFlags - unused.

ReturnValue:

    returns 1, 2 if something caused an exception.


--*/
{
    DWORD returnVal=0;
    NSPI_CONTEXT *pMyContext = *contextHandle;

    __try {
        PERFINC(pcBrowse);                  // PerfMon hook
        INC(pcThread);                  // PerfMon hook
        *contextHandle = NULL;
        
        free(pMyContext);

        returnVal = 1;
    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        if(!returnVal)                  // no error set yet?
            returnVal = 2;
    }
    DEC(pcThread);                      // PerfMon hook
    DEC(pcABClient);                    // PerfMon hook

    return returnVal;
}

SCODE
NspiGetNamesFromIDs(
        NSPI_HANDLE hRpc,
        DWORD dwFlags,
        LPMUID_r lpguid,
        LPSPropTagArray_r  pInPropTags,
        LPLPSPropTagArray_r  ppOutPropTags,
        LPLPNameIDSet_r ppNames
        )
/*++

Routine Description:

    Nspi wire function.  Just a wrapper around a local version.

Arguments:

    See ABGetNamesFromIDs_local.

ReturnValue:

    See ABGetNamesFromIDs_local.

--*/
{
    SCODE scode=SUCCESS_SUCCESS;
    THSTATE *pTHS;
    __try {
        PERFINC(pcBrowse);                  // PerfMon hook
        INC(pcThread);                  // PerfMon hook
        pTHS = InitTHSTATE(CALLERTYPE_NSPI);
        if(!pTHS) {
            scode = MAPI_E_CALL_FAILED;
            __leave;
        }

        LogAndTraceEvent(FALSE,
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_NSPI_BEGIN_NAME_FROM_ID,
                         EVENT_TRACE_TYPE_START,
                         DsGuidNspiGetNamesFromIDs,
                         szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL);


        DBOpen2(TRUE, &pTHS->pDB);
        __try {
            scode = ABGetNamesFromIDs_local(pTHS,
                                            dwFlags,
                                            lpguid,
                                            pInPropTags,
                                            ppOutPropTags,
                                            ppNames);
        }
        __finally {
            DBClose(pTHS->pDB, TRUE);
        }
    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        if(!scode)                      // no error set yet?
            scode = SCODE_FROM_THS(pTHS);
    }
    DEC(pcThread);                      // PerfMon hook

    LogAndTraceEvent(FALSE,
                      DS_EVENT_CAT_DIRECTORY_ACCESS,
                      DS_EVENT_SEV_VERBOSE,
                      DIRLOG_NSPI_END_NAME_FROM_ID,
                      EVENT_TRACE_TYPE_END,
                      DsGuidNspiGetNamesFromIDs,
                      szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                      szInsertUL(scode), 
                      NULL, NULL, NULL, NULL, NULL, NULL);

    if(scode != SUCCESS_SUCCESS)
        *ppNames = NULL;
    return scode;

}

SCODE
NspiGetIDsFromNames(NSPI_HANDLE hRpc,
                    DWORD dwFlags,
                    ULONG ulFlags,
                    ULONG cPropNames,
                    LPMAPINAMEID_r *ppNames,
                    LPLPSPropTagArray_r  ppPropTags)
/*++

Routine Description:

    Nspi wire function.  Just a wrapper around a local version.

Arguments:

    See ABGetIDsFromNames_local.

ReturnValue:

    See ABGetIDsFromNames_local.

--*/
{
    SCODE scode=SUCCESS_SUCCESS;
    THSTATE *pTHS;
    __try {
        PERFINC(pcBrowse);                  // PerfMon hook
        INC(pcThread);                  // PerfMon hook
        pTHS = InitTHSTATE(CALLERTYPE_NSPI);
        if(!pTHS) {
            scode = MAPI_E_CALL_FAILED;
            __leave;
        }

        LogAndTraceEvent(FALSE,
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_NSPI_BEGIN_ID_FROM_NAME,
                         EVENT_TRACE_TYPE_START,
                         DsGuidNspiGetIDsFromNames,
                         szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL);

        DBOpen2(TRUE, &pTHS->pDB);
        __try {
            scode = ABGetIDsFromNames_local(pTHS,
                                            dwFlags,
                                            ulFlags,
                                            cPropNames,
                                            ppNames,
                                            ppPropTags);
        }
        __finally {
            DBClose(pTHS->pDB, TRUE);
        }
    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        if(!scode)                      // no error set yet?
            scode = SCODE_FROM_THS(pTHS);
    }
    DEC(pcThread);                      // PerfMon hook
    
    LogAndTraceEvent(FALSE,
                      DS_EVENT_CAT_DIRECTORY_ACCESS,
                      DS_EVENT_SEV_VERBOSE,
                      DIRLOG_NSPI_END_ID_FROM_NAME,
                      EVENT_TRACE_TYPE_END,
                      DsGuidNspiGetIDsFromNames,
                      szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                      szInsertUL(scode), 
                      NULL, NULL, NULL, NULL, NULL, NULL);

    return scode;

}

SCODE
NspiGetPropList (
        NSPI_HANDLE hRpc,
        DWORD dwFlags,
        DWORD dwEph,
        ULONG CodePage,
        LPLPSPropTagArray_r ppPropTags)
/*++

Routine Description:

    Nspi wire function.  Just a wrapper around a local version.

Arguments:

    See ABGetPropList_local.

ReturnValue:

    See ABGetPropList_local.

--*/
{
    SCODE scode=SUCCESS_SUCCESS;
    THSTATE *pTHS;
    __try {
        PERFINC(pcBrowse);                  // PerfMon hook
        INC(pcThread);                  // PerfMon hook
        pTHS = InitTHSTATE(CALLERTYPE_NSPI);
        if(!pTHS) {
            scode = MAPI_E_CALL_FAILED;
            __leave;
        }

        LogAndTraceEvent(FALSE,
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_NSPI_BEGIN_GET_PROP_LIST,
                         EVENT_TRACE_TYPE_START,
                         DsGuidNspiGetPropList,
                         szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL);

        DBOpen2(TRUE, &pTHS->pDB);
        __try {
        scode = ABGetPropList_local(pTHS,
                                    dwFlags,
                                    dwEph,
                                    CodePage,
                                    ppPropTags);
        }
        __finally {
            DBClose(pTHS->pDB, TRUE);
        }
    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        if(!scode)                      // no error set yet?
            scode = SCODE_FROM_THS(pTHS);
    }
    DEC(pcThread);                      // PerfMon hook
    
    LogAndTraceEvent(FALSE,
                      DS_EVENT_CAT_DIRECTORY_ACCESS,
                      DS_EVENT_SEV_VERBOSE,
                      DIRLOG_NSPI_END_GET_PROP_LIST,
                      EVENT_TRACE_TYPE_END,
                      DsGuidNspiGetPropList,
                      szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                      szInsertUL(scode), 
                      NULL, NULL, NULL, NULL, NULL, NULL);
    
    return scode;

}

SCODE
NspiQueryColumns (
        NSPI_HANDLE hRpc,
        DWORD dwFlags,
        ULONG ulFlags,
        LPLPSPropTagArray_r ppColumns
        )
/*++

Routine Description:

    Nspi wire function.  Just a wrapper around a local version.

Arguments:

    See ABQueryColumns_local.

ReturnValue:

    See ABQueryColumns_local.

--*/
{
    SCODE scode=SUCCESS_SUCCESS;
    THSTATE *pTHS;
    __try {
        PERFINC(pcBrowse);                  // PerfMon hook
        INC(pcThread);                  // PerfMon hook
        pTHS = InitTHSTATE(CALLERTYPE_NSPI);
        if(!pTHS) {
            scode = MAPI_E_CALL_FAILED;
            __leave;
        }
        
        LogAndTraceEvent(FALSE,
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_NSPI_BEGIN_QUERY_COLUMNS,
                         EVENT_TRACE_TYPE_START,
                         DsGuidNspiQueryColumns,
                         szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL);

        DBOpen2(TRUE, &pTHS->pDB);
        __try {
            scode = ABQueryColumns_local(pTHS,
                                         dwFlags,
                                         ulFlags,
                                         ppColumns);
        }
        __finally {
            DBClose(pTHS->pDB, TRUE);
        }
    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        if(!scode)                      // no error set yet?
            scode = SCODE_FROM_THS(pTHS);
    }
    DEC(pcThread);                      // PerfMon hook
    
    LogAndTraceEvent(FALSE,
                      DS_EVENT_CAT_DIRECTORY_ACCESS,
                      DS_EVENT_SEV_VERBOSE,
                      DIRLOG_NSPI_END_QUERY_COLUMNS,
                      EVENT_TRACE_TYPE_END,
                      DsGuidNspiQueryColumns,
                      szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                      szInsertUL(scode), 
                      NULL, NULL, NULL, NULL, NULL, NULL);
    
    return scode;

}

SCODE
NspiGetProps (
        NSPI_HANDLE hRpc,
        DWORD dwFlags,
        PSTAT pStat,
        LPSPropTagArray_r pPropTags,
        LPLPSRow_r ppRow
        )
/*++

Routine Description:

    Nspi wire function.  Just a wrapper around a local version.

    This routine may change the value of pStat->ContainerID to enforce security
    while inside the DSA.  Save and restore the ContainerID.
    
Arguments:

    See ABGetProps_local.

ReturnValue:

    See ABGetProps_local.

--*/
{
    SCODE scode=SUCCESS_SUCCESS;
    DWORD  ContainerID=pStat->ContainerID;
    THSTATE *pTHS;
    INDEXSIZE IndexSize;
    __try {
        PERFINC(pcBrowse);                  // PerfMon hook
        PERFINC(pcNspiPropertyReads);       // PerfMon hook
        INC(pcThread);                  // PerfMon hook
        pTHS = InitTHSTATE(CALLERTYPE_NSPI);
        if(!pTHS) {
            scode = MAPI_E_CALL_FAILED;
            __leave;
        }

        LogAndTraceEvent(FALSE,
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_NSPI_BEGIN_GET_PROPS,
                         EVENT_TRACE_TYPE_START,
                         DsGuidNspiGetProps,
                         szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL);

        DBOpen2(TRUE, &pTHS->pDB);
        __try {
            ABCheckContainerRights(pTHS,
                                   (NSPI_CONTEXT *)hRpc,
                                   pStat,
                                   &IndexSize);
            
            scode = ABGetProps_local(pTHS,
                                     dwFlags,
                                     pStat,
                                     &IndexSize,
                                     pPropTags,
                                     ppRow);
        }
        __finally {
            DBClose(pTHS->pDB, TRUE);
        }
    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        if(!scode)                      // no error set yet?
            scode = SCODE_FROM_THS(pTHS);
        ppRow = NULL;
    }
    DEC(pcThread);                      // PerfMon hook
    
    LogAndTraceEvent(FALSE,
                      DS_EVENT_CAT_DIRECTORY_ACCESS,
                      DS_EVENT_SEV_VERBOSE,
                      DIRLOG_NSPI_END_GET_PROPS,
                      EVENT_TRACE_TYPE_END,
                      DsGuidNspiGetProps,
                      szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                      szInsertUL(scode), 
                      NULL, NULL, NULL, NULL, NULL, NULL);
    
    pStat->ContainerID = ContainerID;
    return scode;

}

SCODE
NspiGetTemplateInfo (
        NSPI_HANDLE hRpc,
        DWORD dwFlags,
        ULONG ulDispType,
        LPSTR pDN,
        DWORD dwCodePage,
        DWORD dwLocaleID,
        LPSRow_r * ppData
        )
/*++

Routine Description:

    Nspi wire function.  Just a wrapper around a local version.

Arguments:

    See ABGetTemplateInfo_local.

ReturnValue:

    See ABGetTemplateInfo_local.

--*/
{
    SCODE scode=SUCCESS_SUCCESS;
    THSTATE *pTHS;
    __try {
        PERFINC(pcBrowse);                  // PerfMon hook
        INC(pcThread);                  // PerfMon hook
        pTHS = InitTHSTATE(CALLERTYPE_NSPI);
        if(!pTHS) {
            scode = MAPI_E_CALL_FAILED;
            __leave;
        }
        
        LogAndTraceEvent(FALSE,
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_NSPI_BEGIN_GET_TEMPLATE_INFO,
                         EVENT_TRACE_TYPE_START,
                         DsGuidNspiGetTemplateInfo,
                         szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        
        DBOpen2(TRUE, &pTHS->pDB);
        __try {
            scode = ABGetTemplateInfo_local(pTHS,
                                            (NSPI_CONTEXT *)hRpc,
                                            dwFlags,
                                            ulDispType,
                                            pDN,
                                            dwCodePage,
                                            dwLocaleID,
                                            ppData);
        }
        __finally {           
            DBClose(pTHS->pDB, TRUE);
        }
    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        if(!scode)                      // no error set yet?
            scode = SCODE_FROM_THS(pTHS);
    }
    DEC(pcThread);                      // PerfMon hook
    
    LogAndTraceEvent(FALSE,
                      DS_EVENT_CAT_DIRECTORY_ACCESS,
                      DS_EVENT_SEV_VERBOSE,
                      DIRLOG_NSPI_END_GET_TEMPLATE_INFO,
                      EVENT_TRACE_TYPE_END,
                      DsGuidNspiGetTemplateInfo,
                      szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                      szInsertUL(scode), 
                      NULL, NULL, NULL, NULL, NULL, NULL);
    
    return scode;

}

SCODE
NspiModProps (
        NSPI_HANDLE hRpc,
        DWORD dwFlag,
        PSTAT pStat,
        LPSPropTagArray_r pTags,
        LPSRow_r pSR)
/*++

Routine Description:

    Nspi wire function.  Just a wrapper around a local version.

Arguments:

    See ABModProps_local.

ReturnValue:

    See ABModProps_local.

--*/
{
    SCODE scode=SUCCESS_SUCCESS;
    THSTATE *pTHS;
    __try {
        PERFINC(pcBrowse);                  // PerfMon hook
        INC(pcThread);                  // PerfMon hook
        pTHS = InitTHSTATE(CALLERTYPE_NSPI);
        if(!pTHS) {
            scode = MAPI_E_CALL_FAILED;
            __leave;
        }

        LogAndTraceEvent(FALSE,
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_NSPI_BEGIN_MOD_PROPS,
                         EVENT_TRACE_TYPE_START,
                         DsGuidNspiModProps,
                         szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL);

        DBOpen2(TRUE, &pTHS->pDB);
        __try {
            scode = ABModProps_local(pTHS,
                                     dwFlag,
                                     pStat,
                                     pTags,
                                     pSR);
        }
        __finally {
            if(pTHS->pDB) {
                DBClose(pTHS->pDB, TRUE);
            }
        }
    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        if(!scode)                      // no error set yet?
            scode = SCODE_FROM_THS(pTHS);
    }
    DEC(pcThread);                      // PerfMon hook
    
    LogAndTraceEvent(FALSE,
                      DS_EVENT_CAT_DIRECTORY_ACCESS,
                      DS_EVENT_SEV_VERBOSE,
                      DIRLOG_NSPI_END_MOD_PROPS,
                      EVENT_TRACE_TYPE_END,
                      DsGuidNspiModProps,
                      szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                      szInsertUL(scode), 
                      NULL, NULL, NULL, NULL, NULL, NULL);
    
    return scode;

}

SCODE
NspiModLinkAtt (
        NSPI_HANDLE hRpc,
        DWORD dwFlags,
        DWORD ulPropTag,
        DWORD dwEph,
        LPENTRYLIST_r lpEntryIDs)
/*++

Routine Description:

    Nspi wire function.  Just a wrapper around a local version.

Arguments:

    See ABModLinkAtt_local.

ReturnValue:

    See ABModLinkAtt_local.

--*/
{
    SCODE scode=SUCCESS_SUCCESS;
    THSTATE *pTHS;
    __try {
        PERFINC(pcBrowse);                  // PerfMon hook
        INC(pcThread);                  // PerfMon hook
        pTHS = InitTHSTATE(CALLERTYPE_NSPI);
        if(!pTHS) {
            scode = MAPI_E_CALL_FAILED;
            __leave;
        }
        
        LogAndTraceEvent(FALSE,
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_NSPI_BEGIN_MOD_LINKATT,
                         EVENT_TRACE_TYPE_START,
                         DsGuidNspiModLinkAtt,
                         szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        
        DBOpen2(TRUE, &pTHS->pDB);
        __try {
            scode = ABModLinkAtt_local(pTHS,
                                       dwFlags,
                                       ulPropTag,
                                       dwEph,
                                       lpEntryIDs);
        }
        __finally {
            if(pTHS->pDB) {
                DBClose(pTHS->pDB, TRUE);
            }
        }
    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        if(!scode)                      // no error set yet?
            scode = SCODE_FROM_THS(pTHS);
    }
    DEC(pcThread);                      // PerfMon hook
    
    LogAndTraceEvent(FALSE,
                      DS_EVENT_CAT_DIRECTORY_ACCESS,
                      DS_EVENT_SEV_VERBOSE,
                      DIRLOG_NSPI_END_MOD_LINKATT,
                      EVENT_TRACE_TYPE_END,
                      DsGuidNspiModLinkAtt,
                      szInsertUL( ((NSPI_CONTEXT *)hRpc)->BindNumber ),
                      szInsertUL(scode), 
                      NULL, NULL, NULL, NULL, NULL, NULL);
    
    return scode;

}

SCODE
NspiDeleteEntries (
        NSPI_HANDLE hRpc,
        DWORD dwFlags,
        DWORD dwEph,
        LPENTRYLIST_r lpEntryIDs
        )
/*++

Routine Description:

    Nspi wire function.  Just a wrapper around a local version.

Arguments:

    See ABDeleteEntries_local.

ReturnValue:

    See ABDeleteEntries_local.

--*/
{
    SCODE scode=SUCCESS_SUCCESS;
    THSTATE *pTHS;
    __try {
        PERFINC(pcBrowse);                  // PerfMon hook
        INC(pcThread);                  // PerfMon hook
        pTHS = InitTHSTATE(CALLERTYPE_NSPI);
        if(!pTHS) {
            scode = MAPI_E_CALL_FAILED;
            __leave;
   