tate (
    IN      PCTSTR Item
    )
{
    DWORD Value;
    TCHAR Node[MEMDB_MAX];

    MemDbBuildKey (Node, MEMDB_CATEGORY_STATE, Item, NULL, NULL);

    if (MemDbGetValue (Node, &Value)) {
        return Value;
    }

    return 0;
}


BOOL
MigMain_Init (
    VOID
    )

/*++

Routine Description:

  MigMain_Init is called for initialization, and has a better opportunity
  to fail than MigMain_Entry (which is called during DllMain).

Arguments:

  none

Return Value:

  TRUE if initialization succeeded, or FALSE if an error occurred.
  Call GetLastError() for error code.

--*/

{
    DWORD rc;       // Temp: return code
    TCHAR RelocWinDir[MAX_TCHAR_PATH];
    TCHAR SrcResBin[MAX_TCHAR_PATH];
    TCHAR IconFile[MAX_TCHAR_PATH];
    ICON_EXTRACT_CONTEXT Context;
    WORD CodePage;
    LCID Locale;
    TCHAR Node[MEMDB_MAX];
    DWORD minorVersion;

#ifdef DEBUG
    HANDLE hFile;
    HKEY DebugKey = NULL;
    CHAR Buf[32];
    DWORD Value;
#endif

#ifdef PRERELEASE
    //
    // !!! This is for internal use only !!!  It is used for auto stress.
    //

    if (g_ConfigOptions.AutoStress) {
        SuppressAllLogPopups (TRUE);
    }

#endif


    //
    // Dev: load c:\windbg.reg if it exists
    //

#ifdef DEBUG
    __try {

        TCHAR WindbgRegPath[MAX_PATH] = TEXT("c:\\windbg.reg");
        //
        // Intentional hard-coded path!!  This is for dev purposes only.
        //

        WindbgRegPath[0] = g_System32Dir[0];

        if (!DoesFileExist (WindbgRegPath)) {
            StringCopy  (WindbgRegPath, TEXT("d:\\tools\\windbg.reg"));
        }

        hFile = CreateFile (
                    WindbgRegPath,
                    GENERIC_READ,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

        if (hFile != INVALID_HANDLE_VALUE) {

            CloseHandle (hFile);

            rc = TrackedRegOpenKey (HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windbg"), &DebugKey);
            if (rc == ERROR_SUCCESS) {
                DEBUGMSG ((DBG_VERBOSE, "Not restoring windbg.reg because it was already restored."));
                __leave;
            }

            else {
                rc = TrackedRegCreateKey (HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windbg"), &DebugKey);
                if (rc == ERROR_SUCCESS) {
                    if (!pSetupEnablePrivilege (SE_BACKUP_NAME, TRUE)) {
                        DEBUGMSG ((DBG_ERROR, "Windbg restore: pSetupEnablePrivilege SE_BACKUP_NAME failed"));
                        //__leave;
                    }

                    if (!pSetupEnablePrivilege (SE_RESTORE_NAME, TRUE)) {
                        DEBUGMSG ((DBG_ERROR, "Windbg restore: pSetupEnablePrivilege SE_RESTORE_NAME failed"));
                        //__leave;
                    }

                    rc = RegRestoreKey (DebugKey, WindbgRegPath, 0);

                    if (rc != ERROR_SUCCESS) {
                        DEBUGMSG ((DBG_WARNING, "Unable to restore windbg.reg, gle=%u", rc));
                    }
                }
            }
        }
    }
    __finally {
        if (DebugKey) {
            CloseRegKey (DebugKey);
        }
    }

    //
    // If debug.inf has a line UserEnv=1, then add a registry key to debug userenv.dll
    //

    if (GetPrivateProfileStringA (
                "Debug",
                "UserEnv",
                "0",
                Buf,
                sizeof (Buf) / sizeof (Buf[0]),
                g_DebugInfPath
                )
        ) {
        if (atoi (Buf)) {
            rc = TrackedRegCreateKey (
                     HKEY_LOCAL_MACHINE,
                     TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                     &DebugKey
                     );

            if (rc == ERROR_SUCCESS) {
                Value = 0x00010002;

                RegSetValueEx (
                    DebugKey,
                    TEXT("UserEnvDebugLevel"),
                    0,
                    REG_DWORD,
                    (PBYTE) &Value,
                    sizeof (DWORD)
                    );

                CloseRegKey (DebugKey);
            }
        }
    }
#endif

    //
    // Initialize the registry APIs
    //
    // We look in memdb for the location of .default
    //

    if (!MemDbLoad (GetMemDbDat())) {
        LOG ((LOG_ERROR, "MigMain Init: MemDbLoad could not load %s", GetMemDbDat()));
        return FALSE;
    }

    //
    // Get platform name
    //

    if (!MemDbGetEndpointValueEx (
            MEMDB_CATEGORY_STATE,
            MEMDB_ITEM_PLATFORM_NAME,
            NULL,
            g_Win95Name
            )) {
        LOG ((LOG_ERROR, "Could not find product name for OS being upgraded."));
        StringCopy (g_Win95Name, TEXT("Windows 95"));
    }

    // Try Paths\Windir first
    if (!MemDbGetEndpointValueEx (
             MEMDB_CATEGORY_PATHS,
             MEMDB_ITEM_RELOC_WINDIR,
             NULL,
             RelocWinDir
             )) {
        LOG ((LOG_ERROR, "Could not find relocated windir!"));
        return FALSE;
    }

    //
    // if upgrading from Millennium, also map classes.dat
    //
    MemDbBuildKey (Node, MEMDB_CATEGORY_STATE, MEMDB_ITEM_MINOR_VERSION, NULL, NULL);
    if (!MemDbGetValue (Node, &minorVersion)) {
        LOG ((LOG_ERROR, "Could not get previous OS version information!"));
        minorVersion = 0;
    }
    rc = Win95RegInit (RelocWinDir, minorVersion == 90);

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        LOG ((LOG_ERROR, "Init Processor: Win95RegInit failed (path: %s)", RelocWinDir));
        return FALSE;
    }

    //
    // Update locale
    //

    CodePage = (WORD) pGetState (MEMDB_ITEM_CODE_PAGE);
    Locale   = (LCID) pGetState (MEMDB_ITEM_LOCALE);

    SetGlobalCodePage (CodePage, Locale);

    //
    // Prepare path to system.dat, then raise registry quota if necessary
    //

    StringCopy (AppendWack (RelocWinDir), TEXT("system.dat"));
    pRaiseRegistryQuota (RelocWinDir);

    //
    // Copy migisol.exe to migicons.exe
    //

    wsprintf (g_IconBin, TEXT("%s\\migicons.exe"), g_System32Dir);
    wsprintf (SrcResBin, TEXT("%s\\migisol.exe"), g_TempDir);

    if (!CopyFile (SrcResBin, g_IconBin, FALSE)) {
        LOG ((LOG_ERROR, "Can't copy %s to %s", SrcResBin, g_IconBin));
    }

    else {
        //
        // Insert all icons from migicons.dat into g_IconBin
        //

        __try {

            wsprintf (IconFile, TEXT("%s\\%s"), g_TempDir, S_MIGICONS_DAT);

            if (!BeginIconExtraction (&Context, g_IconBin)) {
                LOG ((LOG_ERROR, "Can't begin icon extraction"));
                __leave;
            }

            if (!OpenIconImageFile (&Context, IconFile, FALSE)) {
                LOG ((LOG_ERROR, "Can't open %s", IconFile));
                __leave;
            }

            while (CopyIcon (&Context, NULL, NULL, 0)) {
                // empty
            }

        }
        __finally {
            if (!EndIconExtraction (&Context)) {
                DEBUGMSG ((DBG_WARNING, "EndIconExtraction failed"));
            }
        }
    }

#ifdef DEBUG

    // Validate MEMDB_CATEGORY_NT_FILES category. We need to find if the files
    // that were supposed to be installed by NT are really there.
    if (g_ConfigOptions.CheckNtFiles) {
        pValidateNtFiles ();
    }

#endif

    return TRUE;
}


BOOL
MigMain_Migrate (
    VOID
    )

/*++

Routine Description:

  MigMain_Migrate is the main migration function in NT GUI mode setup.
  w95upgnt.dll calls this function, and it is here that users are migrated,
  the local machine settings are migrated, and files are adjusted appropriately.

  See the file progress.c for a list of functions that are called.

Arguments:

  none

Return Value:

  TRUE if migration succeeded, or FALSE if an error occurred.  Call
  GetLastError() for error code.

--*/


{
    BOOL Result;

    InitializeProgressBar (
        g_ProgressBar,
        NULL,
        NULL,
        NULL
        );

    PrepareMigrationProgressBar();

    pProcessAutoLogon (FALSE);

    g_BlowAwayTempShellFolders = TRUE;
    Result = CallAllMigrationFunctions();

    PushError();

    if (Result) {
        //
        // Save logon prompt settings and set up auto-logon
        //

        pProcessAutoLogon (TRUE);
    } else {
        g_BlowAwayTempShellFolders = FALSE;
        ClearAdminPassword();
    }

    //
    // All done!
    //

    TerminateProgressBar();

    PopError();

    return Result;
}


DWORD
ResolveDomains (
    DWORD Request
    )
{
    DWORD rc = ERROR_SUCCESS;
    TCHAR unattendFile[MAX_TCHAR_PATH];
    TCHAR buffer[32];

    switch (Request) {

    case REQUEST_QUERYTICKS:
        if (!IsMemberOfDomain()) {
            return 1;
        }

        return TICKS_DOMAIN_SEARCH;

    case REQUEST_RUN:
        //
        // If autologon is enabled, then force classic mode
        //

        wsprintf (unattendFile, TEXT("%s\\system32\\$winnt$.inf"), g_WinDir);
        if (GetPrivateProfileString (
                TEXT("GuiUnattended"),
                TEXT("AutoLogon"),
                TEXT(""),
                buffer,
                ARRAYSIZE(buffer),
                unattendFile
                )) {

            if (StringIMatch (buffer, TEXT("Yes"))) {
                DEBUGMSG ((DBG_VERBOSE, "Found autologon; forcing classic logon type"));
                SetClassicLogonType();
            }
        }

        //
        // Resolve the domains
        //

        if (!SearchDomainsForUserAccounts()) {
            LOG ((LOG_ERROR, "An error occurred searching for user domains.  The upgrade failed."));
            rc = GetLastError();
        } else {
            //
            // Fix up memdb for dynamic user profile paths
            //

            pFixUpMemDb();
        }

        if (IsMemberOfDomain()) {
            TickProgressBarDelta (TICKS_DOMAIN_SEARCH);
        } else {
            TickProgressBar();
        }

        break;
    }

    return rc;
}



DWORD
PrepareEnvironment (
    IN      DWORD Request
    )
{
    DWORD rc = ERROR_SUCCESS;

    switch (Request) {

    case REQUEST_QUERYTICKS:
        return TICKS_INIT;

    case REQUEST_RUN:
        //
        // Disable Win 3.1 migration dialog
        //

        pSetWin9xUpgValue();

        // Enable 16 bit environment boot
        pEnable16Boot();

        //
        // Enable privileges (req'd for several things)
        //

        if (!pSetupEnablePrivilege (SE_BACKUP_NAME, TRUE)) {
            LOG ((LOG_ERROR, "MigMain Migrate: pSetupEnablePrivilege SE_BACKUP_NAME failed"));
            //rc = GetLastError();
            //break;
        }

        if (!pSetupEnablePrivilege (SE_RESTORE_NAME, TRUE)) {
            LOG ((LOG_ERROR, "MigMain Migrate: pSetupEnablePrivilege SE_RESTORE_NAME failed"));
            //rc = GetLastError();
            //break;
        }

        TickProgressBarDelta (TICKS_INIT);

        break;
    }

    return rc;
}


BOOL
MigMain_Cleanup (
    VOID
    )

/*++

Routine Description:

  MigMain_Cleanup is called to perform file removal.  We delete everything
  that is in the memdb category DelFile, and we also try to clean up after
  MSN and other empty Win9x directories.  Before exiting we delete our
  temporary directory.

  This function is called very last in Setup and is part of syssetup's
  cleanup.

Arguments:

  none

Return Value:

  TRUE when all file deletes were successful, FALSE if an error occurred.
  Call GetLastError for the reason of failure.

--*/

{
    BOOL b = TRUE;
    PCTSTR TempDir;
    TCHAR normalPath[] = S_SHELL_TEMP_NORMAL_PATH;
    TCHAR longPath[] = S_SHELL_TEMP_LONG_PATH;
    DRIVELETTERS drives;
    UINT u;

#ifdef DEBUG
    INT n = 0;
#endif

    // Remove everything in memdb's DelFile category
    b = DoFileDel();

    //
    // Clean up any remaining directories that are now empty, including shell
    // folder temp dirs
    //

    InitializeDriveLetterStructure (&drives);

    if (!g_BlowAwayTempShellFolders) {

        for (u = 0 ; u < NUMDRIVELETTERS ; u++) {
            if (drives.ExistsOnSystem[u] && drives.Type[u] == DRIVE_FIXED) {
                normalPath[0] = drives.Letter[u];
                longPath[0] = drives.Letter[u];

                MemDbSetValueEx (MEMDB_CATEGORY_CLEAN_UP_DIR, normalPath, NULL, NULL, 1, NULL);
                MemDbSetValueEx (MEMDB_CATEGORY_CLEAN_UP_DIR, longPath, NULL, NULL, 1, NULL);
            }
        }
    }

    RemoveEmptyDirs();

    if (!g_BlowAwayTempShellFolders) {
        //
        // Setup failed, clean up temp dir but leave it in place
        //

        for (u = 0 ; u < NUMDRIVELETTERS ; u++) {
            if (drives.ExistsOnSystem[u] && drives.Type[u] == DRIVE_FIXED) {
                normalPath[0] = drives.Letter[u];
                longPath[0] = drives.Letter[u];

                RemoveDirectory (normalPath);
                if (DoesFileExist (normalPath)) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_LEFT_TEMP_SHELL_FOLDERS, normalPath));
                }

                RemoveDirectory (longPath);
                if (DoesFileExist (longPath)) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_LEFT_TEMP_SHELL_FOLDERS, longPath));
                }
            }
        }


    } else {
        //
        // Setup was successful, blow away entire temp dir regardless of its content
        //

        for (u = 0 ; u < NUMDRIVELETTERS ; u++) {
            if (drives.ExistsOnSystem[u] && drives.Type[u] == DRIVE_FIXED) {
                normalPath[0] = drives.Letter[u];
                longPath[0] = drives.Letter[u];

                RemoveCompleteDirectory (normalPath);
                DEBUGMSG_IF ((
                    DoesFileExist (normalPath),
                    DBG_ERROR,
                    "Temp dir cannot be removed: %s",
                    normalPath
                    ));

                RemoveCompleteDirectory (longPath);
                DEBUGMSG_IF ((
                    DoesFileExist (longPath),
                    DBG_ERROR,
                    "Temp dir cannot be removed: %s",
                    longPath
                    ));

            }
        }
    }


#ifdef DEBUG
    n = GetPrivateProfileIntA ("debug", "keeptempfiles", n, g_DebugInfPath);
    if (n) {
        return b;
    }

#endif

    if (g_ConfigOptions.KeepTempFiles) {
        return b;
    }

    //
    // Blow away temp dir
    //

    TempDir = JoinPaths (g_WinDir, S_SETUP);

    b = DeleteDirectoryContents (TempDir);

    if (b) {
        b = RemoveDirectory (TempDir);

        if (!b) {
            LOG ((LOG_ERROR, "Could not delete the tree %s.", TempDir));
        }
    }
    else {
        LOG ((LOG_ERROR, "Could not delete the contents of %s.", TempDir));
    }

    FreePathString (TempDir);

    return b;
}


PCTSTR
GetMemDbDat (
    VOID
    )

/*++

Routine Description:

    Returns a pointer to the path of the DAT file holding the Win9x memdb tree.

Arguments:

    none

Return Value:

    Returns a pointer to the Win32 path of ntsetup.dat.

--*/

{
    static TCHAR FileName[MAX_TCHAR_PATH];

    MYASSERT (!g_NoReloadsAllowed);

    StringCopy (FileName, g_TempDir);
    StringCopy (AppendWack (FileName), S_NTSETUPDAT);

    return FileName;
}


PCTSTR
GetUserDatLocation (
    IN      PCTSTR User,
    OUT     PBOOL CreateOnlyFlag            OPTIONAL
    )

/*++

Routine Description:

    Looks in memdb to locate the user.dat file for the specified user.  On
    Win9x, migapp.lib writes a line to memdb giving the location of user.dat
    for each user, and the default user.  This function retrieves that
    location to guarantee the same file is used on both NT and Win9x.

Arguments:

    User  - The fixed name of the user to process, or NULL for the default user.

    CreateOnlyFlag - Receives the create-only flag specified on the Win9x side
                     of the upgrade.  If this flag is TRUE, then the account
                     should not be migrated.

Return Value:

    Returns a pointer to the Win32 path of user.dat for the given user.
    If the entry does not exist, NULL will be returned, and the user
    will not be processed.

--*/


{
    MEMDB_ENUM e;
    static TCHAR UserDatLocation[MAX_TCHAR_PATH];

    if (!MemDbGetValueEx (&e, MEMDB_CATEGORY_USER_DAT_LOC, User, NULL)) {
        if (!StringIMatch (User, g_AdministratorStr)) {
            DEBUGMSG ((DBG_WARNING, "'UserDatLocation' for %s does not exist.", User?User:S_DOT_DEFAULT));
        }
        return NULL;
    }

    StringCopy (UserDatLocation, e.szName);

    if (CreateOnlyFlag) {
        *CreateOnlyFlag = (BOOL) e.dwValue;
    }

    return UserDatLocation;
}


VOID
pSaveVersionStr (
    IN      HKEY Key,
    IN      PCTSTR Name
    )
{
    TCHAR Data[MEMDB_MAX];

    if (MemDbGetEndpointValueEx (MEMDB_CATEGORY_STATE, Name, NULL, Data)) {
        RegSetValueEx (
            Key,
            Name,
            0,
            REG_SZ,
            (PBYTE) Data,
            SizeOfString (Data)
            );
    }
}


VOID
pSaveVersionDword (
    IN      HKEY Key,
    IN      PCTSTR Name
    )
{
    DWORD Data;
    TCHAR Node[MEMDB_MAX];

    MemDbBuildKey (Node, MEMDB_CATEGORY_STATE, Name, NULL, NULL);

    if (MemDbGetValue (Node, &Data)) {
        RegSetValueEx (
            Key,
            Name,
            0,
            REG_DWORD,
            (PBYTE) &Data,
            sizeof (Data)
            );
    }
}


BOOL
pSetWin9xUpgValue (
    VOID
    )

/*++

Routine Description:

    Create the value entry Win9xUpg on
    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\WinLogon
    This routine should always be called when setup is installing an NT system
    on top of Win9x, otherwise NT will think it has to migrate Win 3.1.

Arguments:

    None.

Return Value:

    Returns TRUE if the opearation succeeds.

--*/

{
    ULONG   Error;
    HKEY    Key;
    DWORD   Value;
    HKEY    VersionKey;

    Key = OpenRegKeyStr (S_WINLOGON_REGKEY);
    if (!Key) {
        return FALSE;
    }

    Value = 1;
    Error = RegSetValueEx (
                Key,
                S_WIN9XUPG_FLAG_VALNAME,
                0,
                REG_DWORD,
                (PBYTE) &Value,
                sizeof (DWORD)
                );

    //
    // Save the version info
    //

    VersionKey = CreateRegKey (Key, TEXT("PrevOsVersion"));

    if (VersionKey) {

        pSaveVersionStr (VersionKey, MEMDB_ITEM_PLATFORM_NAME);
        pSaveVersionStr (VersionKey, MEMDB_ITEM_VERSION_TEXT);

        pSaveVersionDword (VersionKey, MEMDB_ITEM_MAJOR_VERSION);
        pSaveVersionDword (VersionKey, MEMDB_ITEM_MINOR_VERSION);
        pSaveVersionDword (VersionKey, MEMDB_ITEM_BUILD_NUMBER);
        pSaveVersionDword (VersionKey, MEMDB_ITEM_PLATFORM_ID);

        CloseRegKey (VersionKey);
    }

    CloseRegKey (Key);
    if (Error != ERROR_SUCCESS) {
        SetLastError (Error);
        return FALSE;
    }

    return TRUE;
}


PCTSTR
GetString (
    WORD wMsg
    )

/*++

Routine Description:

    Load the string resource given in wMsg and copy it to a global string
    buffer.  Return the a pointer to the buffer.

Arguments:

    wMsg  - The identifier of the message to load.

Return Value:

    Returns a pointer to the loaded message, or NULL.  The message must be
    smaller than 2048 characters.

--*/

{
    PCTSTR String;

    String = GetStringResource (wMsg);
    if (!String) {
        return TEXT("Error: String resource could not be loaded");
    }

    _tcssafecpy (g_MsgBuf, String, ARRAYSIZE(g_MsgBuf));
    FreeStringResource (String);

    return g_MsgBuf;
}


VOID
pCountUsers (
    OUT     PDWORD TotalUsersPtr,
    OUT     PDWORD ActiveUsersPtr
    )

/*++

Routine Description:

    Counts all Win9x users, and determines how many of them are active
    for migration.  The count includes the Administrator account, the
    logon prompt account, and optional default user account.

    NOTE: Administrator may be counted twice in ActiveUsersPtr, once for
          a real Win9x user named Administrator, and again for the
          NT Administrator account that is always migrated.  The caller
          must handle this special case.

Arguments:

    TotalUsersPtr  - A DWORD that receives the total number of Win9x users,
                     including the NT-only users.
    ActiveUsersPtr - A DWORD that receives the number of users that require
                     migration.  Migration may or may not be enabled for any
                     user.

Return Value:

    none

--*/

{
    USERPOSITION up;
    TCHAR User[MAX_TCHAR_PATH];
    DWORD rc;
    PCTSTR UserDatLocation;

    *ActiveUsersPtr = 0;
    *TotalUsersPtr  = 3;        // include logon, default and administrator in the total

    rc = Win95RegGetFirstUser (&up, User);
    if (rc != ERROR_SUCCESS) {
        *TotalUsersPtr = 0;
        return;
    }

    while (Win95RegHaveUser (&up)) {

        GetFixedUserName (User);

        // see if this user requires migration
        UserDatLocation = GetUserDatLocation (User, NULL);
        if (UserDatLocation) {
            *ActiveUsersPtr += 1;
        }

        // count all users, migrated and non-migrated
        *TotalUsersPtr += 1;

        Win95RegGetNextUser (&up, User);
    }

    // test migration requirement of default user and adminsistrator
    UserDatLocation = GetUserDatLocation (g_AdministratorStr, NULL);
    if (UserDatLocation) {
        *ActiveUsersPtr += 1;
    }

    UserDatLocation = GetUserDatLocation (S_DOT_DEFAULT, NULL);
    if (UserDatLocation) {
        *ActiveUsersPtr += 1;
    }

    if (g_ConfigOptions.MigrateDefaultUser) {
        *ActiveUsersPtr += 1;
    }

    DEBUGMSG ((DBG_VERBOSE, "pCountUsers: %u users, %u require migration", *TotalUsersPtr, *ActiveUsersPtr));
}


CONVERTPATH_RC
ConvertWin9xPath (
    PTSTR PathBuf
    )
{
    TCHAR Buffer[MEMDB_MAX];
    DWORD status;

    status = GetFileInfoOnNt (PathBuf, Buffer, MEMDB_MAX);

    if (status & FILESTATUS_REPLACED) {
        if (status & FILESTATUS_MOVED) {
            _tcssafecpy (PathBuf, Buffer, MAX_TCHAR_PATH);
            return CONVERTPATH_REMAPPED;
        }
        return CONVERTPATH_NOT_REMAPPED;
    }
    if (status & FILESTATUS_MOVED) {
        _tcssafecpy (PathBuf, Buffer, MAX_TCHAR_PATH);
        return CONVERTPATH_REMAPPED;
    }
    if (status & FILESTATUS_DELETED) {
        return CONVERTPATH_DELETED;
    }
    return CONVERTPATH_NOT_REMAPPED;
}

VOID
pRaiseRegistryQuota (
    PCTSTR Win9xSystemDatSpec
    )
{
    NTSTATUS Status;
    SYSTEM_REGISTRY_QUOTA_INFORMATION RegQuotaInfo;
    HANDLE FileHandle;
    DWORD QuotaNeeded;
    ULARGE_INTEGER FreeBytes, dc1, dc2;
    LONGLONG FreeBytesNeeded;
    HKEY SaveKey;
    DWORD rc;

#ifdef PAGED_POOL_INCREASE
    SYSTEM_POOL_INFORMATION PoolInfo;

    //
    // Obtain current system settings
    //

    Status = NtQuerySystemInformation (
                 SystemPagedPoolInformation,
                 (PVOID) &PoolInfo,
                 sizeof(PoolInfo),
                 NULL
                 );

    if (Status != ERROR_SUCCESS) {
        LOG ((LOG_ERROR, "Cannot obtain PoolInfo"));
        return;
    }
#endif

    pSetupEnablePrivilege (SE_INCREASE_QUOTA_NAME, TRUE);

    Status = NtQuerySystemInformation (
                 SystemRegistryQuotaInformation,
                 (PVOID) &RegQuotaInfo,
                 sizeof(RegQuotaInfo),
                 NULL
                 );

    if (Status != ERROR_SUCCESS) {
        LOG ((LOG_ERROR, "Cannot obtain RegQuotaInfo"));
        return;
    }

    //
    // Obtain Win9x registry system.dat size
    //

    FileHandle = CreateFile (
                     Win9xSystemDatSpec,
                     GENERIC_READ,
                     FILE_SHARE_READ,
                     NULL,              // security attributes
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL               // template file
                     );

    if (FileHandle == INVALID_HANDLE_VALUE) {
        LOG ((LOG_ERROR, "Cannot open %s; cannot raise registry quota", Win9xSystemDatSpec));
        return;
    }

    QuotaNeeded = GetFileSize (FileHandle, NULL);
    CloseHandle (FileHandle);

    if (QuotaNeeded > 0x3fffffff) {
        LOG ((LOG_ERROR, "Cannot obtain size for %s; cannot raise registry quota", Win9xSystemDatSpec));
        return;
    }

    QuotaNeeded *= 6;

    //
    // Get free disk space on boot drive
    //

    if (!GetDiskFreeSpaceEx (
            g_WinDir,
            &FreeBytes,
            &dc1,
            &dc2
            )) {
        LOG ((LOG_ERROR, "Can't get free space on drive holding %s; cannot raise registry quota", g_WinDir));
        return;
    }

    //
    // Lots of disk space?  Raise paged pool by 5 times the size of system.dat.
    // Example: Win9x system.dat is 5M; must have 150M free to raise paged pool.
    //

    FreeBytesNeeded = (LONGLONG) QuotaNeeded * (LONGLONG) 6;
    if (FreeBytes.QuadPart >= (DWORDLONG) FreeBytesNeeded) {
        //
        // Unimplemented: Raise the paged pool and return
        //

        DEBUGMSG ((DBG_WARNING, "RegQuota: Really should be raising paged pool -- this machine has %u bytes free", FreeBytes.LowPart));

    }

    //
    // Last resort: raise the registry quota (if necessary)
    //

    if (RegQuotaInfo.RegistryQuotaAllowed < QuotaNeeded) {
        DEBUGMSG ((DBG_VERBOSE, "Raising registry quota from %u to %u", RegQuotaInfo.RegistryQuotaAllowed, QuotaNeeded));

        RegQuotaInfo.RegistryQuotaAllowed = QuotaNeeded;

        Status = NtSetSystemInformation (
                     SystemRegistryQuotaInformation,
                     &RegQuotaInfo,
                     sizeof (RegQuotaInfo)
                     );

        if (Status != ERROR_SUCCESS) {
            LOG ((LOG_ERROR, "Can't set raised registry quota"));
        }

        //
        // Set a permanent value in the registry
        //

        SaveKey = OpenRegKeyStr (TEXT("HKLM\\System\\CurrentControlSet\\Control"));
        if (SaveKey) {
            rc = RegSetValueEx (
                     SaveKey,
                     TEXT("RegistrySizeLimit"),
                     0,
                     REG_DWORD,
                     (PBYTE) &QuotaNeeded,
                     sizeof (DWORD)
                     );

            CloseRegKey (SaveKey);

            if (rc != ERROR_SUCCESS) {
                LOG ((LOG_ERROR, "Could not set HKLM\\System\\CurrentControlSet\\Control [RegistrySizeLimit]"));
            }
        }
        ELSE_DEBUGMSG ((DBG_ERROR, "Can't open HKLM\\System\\CurrentControlSet\\Control"));
    }
}


BOOL
pCopyDosFile (
    IN      PCTSTR FileName,
    IN      BOOL   InRootDir
    )

/*++

Routine Description:

    Copies a file from %windir%\setup\msdos7 into the designated DOS directory

Arguments:

    FileName - file to copy (no path).

Return Value:

    TRUE if succeeded, FALSE if not

--*/

{
    PTSTR sourcePath;
    PTSTR sourceFileName;
    PTSTR destPath;
    PTSTR destFileName;
    BOOL result;

    sourcePath = JoinPaths (g_TempDir, S_BOOT16_DOS_DIR);
    sourceFileName = JoinPaths (sourcePath, FileName);

    if (InRootDir) {
        destPath = NULL;
        destFileName = JoinPaths (ISPC98() ? g_Win9xBootDrivePath : g_BootDrivePath,
                                  FileName);
    }
    else {
        destPath = JoinPaths (ISPC98() ? g_Win9xBootDrivePath : g_BootDrivePath,
                              S_BOOT16_DOS_DIR);
        destFileName = JoinPaths (destPath, FileName);
    }

    SetFileAttributes (destFileName, FILE_ATTRIBUTE_NORMAL);

    result = CopyFile (sourceFileName, destFileName, FALSE);

    FreePathString (sourcePath);
    FreePathString (sourceFileName);
    if (destPath != NULL) {
        FreePathString (destPath);
    }
    FreePathString (destFileName);

    return result;
}


VOID
pWriteBoot16ConfigLines (
    IN HANDLE File,
    IN PCTSTR BaseSection,
    IN PCTSTR DosPath,
    IN BOOL Localized
    )

/*++

Routine Description:

  pWriteBoot16ConfigLines reads configuration lines from wkstamig.inf and
  writes them to the specified file handle. The caller can control wether the
  lines should contain first boot only items or not and can control wether to
  read in the base dos lines (same for all languages) or special lines used
  for specific languages.

Arguments:

  File        - An opened handle with appropriate access to the file  where
                the data should be written.
  BaseSection - Contains the Base Section name to read from the INF. This
                section may be modified with a code page if Localized is TRUE.
  DosPath     - Contains the full path to the dos boot files (typically
                c:\msdos7)
  Localized   - Controls wether data from the localized section is read. If
                this parameter is TRUE, then the code page will be appended to
                the BaseSection string for purposes of reading from wkstamig.inf.


Return Value:

    none
++*/
{

    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    GROWLIST list = GROWLIST_INIT;
    PTSTR line;
    TCHAR codePageSection[MAX_TCHAR_PATH];
    USHORT codePage;
    PCTSTR infSection;

    //
    // Add boot16 line specific environment variables.
    //
    GrowListAppendString (&list, TEXT("BOOTDRIVE"));
    GrowListAppendString (&list, g_BootDrive);
    GrowListAppendString (&list, TEXT("BOOT16DIR"));
    GrowListAppendString (&list, DosPath);

    //
    // Terminate the arg list with two NULLs
    //
    GrowListAppendEmptyItem (&list);
    GrowListAppendEmptyItem (&list);

    if (Localized) {
        //
        // Caller wants data from the localized section.
        //

        GetGlobalCodePage (&codePage, NULL);
        wsprintf (codePageSection, TEXT("%s %u"), BaseSection, codePage);
        infSection = codePageSection;
    }
    else {

        infSection = BaseSection;
    }


    //
    // Write lines from base section.
    //
    if (InfFindFirstLine (g_WkstaMigInf, infSection, NULL, &is)) {

        do {

            //
            // Get the line from the section and expand any environment
            // variables.
            //
            line = InfGetLineText (&is);
            MYASSERT (line);

            line = ExpandEnvironmentTextEx (line,GrowListGetStringPtrArray (&list));
            MYASSERT (line);

            //
            // Write the line to the file.
            //
            WriteFileString (File, line);
            WriteFileString (File, TEXT("\r\n"));
            FreeText (line);


        } while (InfFindNextLine (&is));
    }

    FreeGrowList (&list);
    InfCleanUpInfStruct (&is);
}



BOOL
pCreateConfigFile(
    IN PCTSTR DosPath
    )

/*++

Routine Description:

    Creates a CONFIG.SYS file containing default settings.

Arguments:

    DosPath - Contains the path to the dos files. (e.g. c:\msdos7)

Return Value:

    TRUE if file was created, FALSE if not

--*/

{
    PTSTR configName = NULL;
    HANDLE handle;

    configName = JoinPaths (ISPC98() ? g_Win9xBootDrivePath : g_BootDrivePath,
                            S_BOOT16_CONFIG_FILE);

    SetFileAttributes (configName, FILE_ATTRIBUTE_NORMAL);
    handle = CreateFile (
                 configName,
                 GENERIC_READ | GENERIC_WRITE,
                 0,
                 NULL,
                 CREATE_ALWAYS,
                 FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_NORMAL
                 ,
                 NULL
                 );

    if (handle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // Read lines from wkstamig.inf into this file.
    //
    pWriteBoot16ConfigLines (handle, S_BOOT16_CONFIGSYS_SECTION, DosPath, FALSE);
    pWriteBoot16ConfigLines (handle, S_BOOT16_CONFIGSYS_SECTION, DosPath, TRUE);

    CloseHandle (handle);
    FreePathString (configName);

    return TRUE;
}


BOOL
pCreateStartupFile(
    IN PCTSTR DosPath
    )

/*++

Routine Description:

    Creates an AUTOEXEC.BAT file containing default settings.

Arguments:

    DosPath - Contains the path to the dos files. (e.g. c:\msdos7)

Return Value:

    TRUE if file was created, FALSE if not

--*/

{
    PTSTR startupName = NULL;
    PCTSTR comment = NULL;
    HANDLE handle;
    PCTSTR args[2];

    args[0] = DosPath;
    args[1] = NULL;

    startupName = JoinPaths (ISPC98() ? g_Win9xBootDrivePath : g_BootDrivePath,
                             S_BOOT16_STARTUP_FILE);


    SetFileAttributes (startupName, FILE_ATTRIBUTE_NORMAL);
    handle = CreateFile (
                 startupName,
                 GENERIC_READ | GENERIC_WRITE,
                 0,
                 NULL,
                 CREATE_ALWAYS,
                 FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_HIDDEN,
                 NULL
                 );

    if (handle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    comment = ParseMessageID (MSG_BOOT16_STARTUP_COMMENT, args);

    //
    // Read lines from wkstamig.inf into this file.
    //
    pWriteBoot16ConfigLines (handle, S_BOOT16_AUTOEXEC_SECTION, DosPath, FALSE);
    pWriteBoot16ConfigLines (handle, S_BOOT16_AUTOEXEC_SECTION, DosPath, TRUE);

    //
    // Write localized comment.
    //
    WriteFileString (handle, comment);
    WriteFileString (handle, TEXT("\r\n"));

    FreeStringResource (comment);

    CloseHandle (handle);
    FreePathString (startupName);

    return TRUE;
}


VOID
pEliminateCollision (
    IN      PCTSTR FileSpec
    )

/*++

Routine Description:

  pEliminateCollision checks to see if the specified file spec already
  exists.  If it does, the file is renamed with a numeric .nnn extension.  If
  the file can't be renamed, it is removed.

Arguments:

  FileSpec - Specifies the file spec that is going to be used for a new file.
              If this file already exists, it is renamed.

Return Value:

  None.

--*/

{
    PTSTR p;
    PCTSTR NewFileSpec;
    UINT u;
    BOOL b;

    if (DoesFileExist (FileSpec)) {
        NewFileSpec = DuplicatePathString (FileSpec, 0);

        p = _tcsrchr (NewFileSpec, TEXT('.'));
        if (!p || _tcschr (p, TEXT('\\'))) {
            p = GetEndOfString (NewFileSpec);
        }

        u = 0;
        do {
            wsprintf (p, TEXT(".%03u"), u);
            u++;
        } while (DoesFileExist (NewFileSpec));

        b = OurMoveFile (FileSpec, NewFileSpec);

        LOG_IF ((
            !b,
            LOG_ERROR,
            "Could not rename %s to %s; source file might be lost",
            FileSpec,
            NewFileSpec
            ));

        if (!b) {
            SetFileAttributes (FileSpec, FILE_ATTRIBUTE_NORMAL);
            b = DeleteFile (FileSpec);

            LOG_IF ((
                !b,
                LOG_ERROR,
                "Could not remove %s to make room for a new file.  The new file is lost.",
                FileSpec
                ));
        }

        FreePathString (NewFileSpec);
    }
}


BOOL
pRenameCfgFiles (
    IN PCTSTR DosDrive
    )

/*++

Routine Description:

    Renames old CONFIG.SYS and AUTOEXEC.BAT to make room for automatically generated ones.

Arguments:

    DosDirectory - Contains the directory where the msdos files live (typeically c:\msdos7)

Return Value:

    TRUE if rename succeeded, FALSE if not

--*/

{
    PTSTR fileName1 = NULL;
    PTSTR fileName2 = NULL;

    fileName1 = JoinPaths (
                    ISPC98() ? g_Win9xBootDrivePath : g_BootDrivePath,
                    S_BOOT16_CONFIG_FILE
                    );

    fileName2 = JoinPaths (
                    DosDrive,
                    S_BOOT16_CONFIGUPG_FILE
                    );

    OurMoveFile (fileName1, fileName2);
    SetFileAttributes (fileName2, FILE_ATTRIBUTE_NORMAL);

    FreePathString (fileName1);
    FreePathString (fileName2);

    fileName1 = JoinPaths (
                    ISPC98() ? g_Win9xBootDrivePath : g_BootDrivePath,
                    S_BOOT16_STARTUP_FILE
                    );

    fileName2 = JoinPaths (
                    DosDrive,
                    S_BOOT16_STARTUPUPG_FILE
                    );

    OurMoveFile (fileName1, fileName2);
    SetFileAttributes (fileName2, FILE_ATTRIBUTE_NORMAL);

    FreePathString (fileName1);
    FreePathString (fileName2);

    return TRUE;
}


VOID
pCleanRootDir (
    VOID
    )

/*++

Routine Description:

    Blows away dos files in root directory.

Arguments:

    none

Return Value:

    none

--*/

{
    PTSTR fileName = NULL;

    fileName = JoinPaths (ISPC98() ? g_Win9xBootDrivePath : g_BootDrivePath,
                          S_BOOT16_SYSMAIN_FILE);
    MarkFileForDelete (fileName);
    FreePathString (fileName);

    fileName = JoinPaths (ISPC98() ? g_Win9xBootDrivePath : g_BootDrivePath,
                          S_BOOT16_DOSINI_FILE);
    MarkFileForDelete (fileName);
    FreePathString (fileName);
}

#define IoFile      TEXT("IO.SYS")

VOID
pEnable16Boot (
    VOID
    )

/*++

Routine Description:

    Creates a 16 bit environment boot option.
    First we will check to see if everything is OK, we have all the files we need etc.
    Then create DOS directory, rename old AUTOEXEC and CONFIG, create new ones and
    add an entry in BOOT.INI

Arguments:

    none

Return Value:

    TRUE if file was created, FALSE if not

--*/

{
    PTSTR fileName = NULL;
    PTSTR dosPath  = NULL;
    INFCONTEXT infContext;
    DWORD oldFileAttr;
    BOOL result = TRUE;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;

    if (g_Boot16 == BOOT16_NO) {
        pCleanRootDir ();
        return;
    }

    __try {

        //
        // first thing. Copy IO.SYS in root directory (BOOTSECT.DOS should be there)
        //
        pCopyDosFile (IoFile, TRUE);
        fileName = JoinPaths (ISPC98() ? g_Win9xBootDrivePath : g_BootDrivePath,
                              IoFile);
        SetFileAttributes (fileName, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM);
        FreePathString (fileName);

        //
        // Create DOS7 directory and copy dos files there
        //
        dosPath = JoinPaths (ISPC98() ? g_Win9xBootDrivePath : g_BootDrivePath,
                             S_BOOT16_DOS_DIR);
        if (!CreateDirectory (dosPath, NULL) && (GetLastError()!=ERROR_ALREADY_EXISTS)) {
            LOG ((LOG_ERROR,"BOOT16 : Unable to create DOS directory %s",dosPath));
            __leave;
        }

        //
        // If we find autoexec.bat and config.sys rename them as *.upg
        //
        if (!pRenameCfgFiles (dosPath)) {
            __leave;
        }



        if (g_WkstaMigInf == INVALID_HANDLE_VALUE) {
            LOG ((LOG_ERROR,"BOOT16 : WKSTAMIG.INF is not opened"));
            __leave;
        }

        //
        // Read the section, for every file, we are trying to read it from our temp dir
        // and copy it to the new DOS7 location
        //
        fileName = AllocPathString (MAX_TCHAR_PATH);

        if (!SetupFindFirstLine (
                g_WkstaMigInf,
                S_BOOT16_SECTION,
                NULL,
                &infContext
                )) {
            LOG ((LOG_ERROR,"BOOT16 : Cannot read from %s section (WKSTAMIG.INF)",S_BOOT16_SECTION));
            __leave;
        }

        do {
            if (SetupGetStringField (
                    &infContext,
                    0,
                    fileName,
                    MAX_TCHAR_PATH/sizeof(fileName[0]),
                    NULL
                    )) {

                pCopyDosFile (fileName, FALSE);
            }
        }
        while (SetupFindNextLine (&infContext, &infContext));

        //
        // Hide the msdos7 directory (not our idea...)
        //
        SetFileAttributes (dosPath, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);



        FreePathString (fileName);
        fileName = NULL;

        //
        // Next step, build MSDOS.SYS file.
        //
        fileName = JoinPaths (ISPC98() ? g_Win9xBootDrivePath : g_BootDrivePath,
                              S_BOOT16_DOSINI_FILE);
        if (SetFileAttributes (fileName, FILE_ATTRIBUTE_NORMAL)) {
            if (!DeleteFile (fileName)) {
                LOG ((LOG_ERROR, "BOOT16 : Unable to delete %s",fileName));
                __leave;
            }
        }
        result &= WritePrivateProfileString (TEXT("Paths"),   TEXT("WinDir"),  dosPath,   fileName);
        result &= WritePrivateProfileString (TEXT("Paths"),   TEXT("WinBootDir"), dosPath, fileName);
        result &= WritePrivateProfileString (TEXT("Options"), TEXT("LOGO"),    TEXT("0"), fileName);
        result &= WritePrivateProfileString (TEXT("Options"), TEXT("BootGUI"), TEXT("0"), fileName);
        if (!result) {
            LOG((LOG_ERROR,"Unable to write to %s",fileName));
            __leave;
        }

        FreePathString (fileName);
        fileName = NULL;

        //
        // Generate config.sys and autoexec.bat files.
        //

        if (!pCreateConfigFile (dosPath)) {
            LOG ((LOG_ERROR, "BOOT16 : Unable to create %s",S_BOOT16_CONFIG_FILE));
            __leave;
        }

        if (!pCreateStartupFile (dosPath)) {
            LOG ((LOG_ERROR, "BOOT16 : Unable to create %s",S_BOOT16_STARTUP_FILE));
            __leave;
        }


        if ((!ISPC98()) || (g_BootDrivePath[0] == g_Win9xBootDrivePath[0])) {

            //
            // If boot16 is set to BOOT16_AUTOMATIC, we create a boot.dos file,
            // but don't actually modify boot.ini. If it is BOOT16_YES, then
            // we modify boot.ini
            //
            // The result is that DOS will not show up as a boot option unless
            // there was a specific reason it was turned on originally. However,
            // there will be a way to enable it if needed.
            //
            if (g_Boot16 == BOOT16_AUTOMATIC) {

                fileName = JoinPaths (g_BootDrivePath, S_BOOT16_BOOTDOS_FILE);
                fileHandle = CreateFile (
                    fileName,
                    GENERIC_READ | GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE,
                    NULL
                    );

                if (fileHandle != INVALID_HANDLE_VALUE) {

                    WriteFileString (fileHandle, ISPC98() ? L"C:\\" : g_BootDrivePath);
                    WriteFileString (fileHandle, TEXT("="));
                    WriteFileString (fileHandle, S_BOOT16_OS_ENTRY);
                }
            }
            else {

                fileName = JoinPaths (g_BootDrivePath, S_BOOT16_BOOTINI_FILE);
                oldFileAttr = GetFileAttributes (fileName);
                SetFileAttributes (fileName, FILE_ATTRIBUTE_NORMAL);

                if (!WritePrivateProfileString (
                        S_BOOT16_OS_SECTION,
                        ISPC98() ? L"C:\\" : g_BootDrivePath,
                        S_BOOT16_OS_ENTRY,
                        fileName
                        )) {
                    LOG((LOG_ERROR,"Unable to write to %s",fileName));
                    SetFileAttributes (fileName, oldFileAttr);
                    __leave;
                }

                SetFileAttributes (fileName, oldFileAttr);
            }
        }

    }
    __finally {
        if (fileName != NULL) {
            FreePathString (fileName);
            fileName = NULL;
        }
        if (dosPath != NULL) {
            FreePathString (dosPath);
            dosPath = NULL;
        }

    }

}


VOID
pCopyRegString (
    IN      HKEY DestKey,
    IN      HKEY SrcKey,
    IN      PCTSTR SrcValue
    )
{
    PCTSTR Data;

    Data = GetRegValueString (SrcKey, SrcValue);
    if (Data) {
        RegSetValueEx (DestKey, SrcValue, 0, REG_SZ, (PBYTE) Data, SizeOfString (Data));
        MemFree (g_hHeap, 0, Data);
    }
}


#ifdef PRERELEASE

//
// !!! This is for internal use only !!!  It is used for auto stress.
//

VOID
pTransferAutoStressVal (
    IN      HKEY StressKey,
    IN      PCTSTR ValueName
    )
{
    TCHAR Data[MEMDB_MAX];
    LONG rc;

    if (!MemDbGetEndpointValueEx (
            MEMDB_CATEGORY_STATE,
            ValueName,
            NULL,       // no field
            Data
            )) {
        return;
    }

    rc = RegSetValueEx (
            StressKey,
            ValueName,
            0,
            REG_SZ,
            (PBYTE) Data,
            SizeOfString (Data)
            );

    DEBUGMSG_IF ((rc == ERROR_SUCCESS, DBG_VERBOSE, "Transferred autostress value %s", ValueName));

}

#endif

VOID
pProcessAutoLogon (
    BOOL Final
    )

/*++

Routine Description:

  pProcessAutoLogon copies the logon defaults to a special key, so the
  migpwd.exe tool can restore them if it runs.  Then, the function calls
  AutoStartProcessing to set up RunOnce and AutoAdminLogon.

  This function is called early in migration to save the clean install
  autologon, and then again at the end to prepare migpwd.exe.

Arguments:

  Final - Specifies FALSE if this is the early call, TRUE if it is the
          final call.

Return Value:

  None.

--*/

{
    HKEY SrcKey, DestKey;
    PCTSTR Data;
    BOOL copyNow = FALSE;
    static BOOL alreadyCopied = FALSE;

    //
    // If autologon is enabled, preserve it in Win9xUpg key, so that
    // migpwd.exe will restore it.
    //

    SrcKey = OpenRegKeyStr (S_WINLOGON_REGKEY);
    if (SrcKey) {

        if (!Final) {
            //
            // Early in migration, we get the clean install autologon values.
            // If autologon is enabled, preserve the settings.
            //

            Data = GetRegValueString (SrcKey, S_AUTOADMIN_LOGON_VALUE);
            if (Data) {

                if (_ttoi (Data)) {
                    //
                    // on PER, don't want to preserve this value;
                    // instead, we need to preserve the name of
                    // the Win9x username as migrated via wkstamig.inf (see below)
                    //
                    copyNow = !g_PersonalSKU;
                }

                MemFree (g_hHeap, 0, Data);
            }
        } else if (!alreadyCopied) {

            //
            // Near the end of migration, we get the default logon prompt
            // settings via wkstamig.inf migration. We want the attended case
            // to work properly (preserving default user name & password).
            //
            // But if we've already preserved autologon, then we don't get
            // here.
            //

            copyNow = TRUE;
        }

        if (copyNow) {

            MYASSERT (!alreadyCopied);
            alreadyCopied = TRUE;

            DestKey = CreateRegKeyStr (S_WIN9XUPG_KEY);
            if (DestKey) {
                pCopyRegString (DestKey, SrcKey, S_AUTOADMIN_LOGON_VALUE);
                pCopyRegString (DestKey, SrcKey, S_DEFAULT_PASSWORD_VALUE);
                pCopyRegString (DestKey, SrcKey, S_DEFAULT_USER_NAME_VALUE);
                pCopyRegString (DestKey, SrcKey, S_DEFAULT_DOMAIN_NAME_VALUE);
                CloseRegKey (DestKey);
            }
        }

        CloseRegKey (SrcKey);
    }

    if (!Final) {
        return;
    }

    AutoStartProcessing();

#ifdef PRERELEASE
    //
    // !!! This is for internal use only !!!  It is used for auto stress.
    //

    if (g_ConfigOptions.AutoStress) {
        HKEY StressKey;

        StressKey = CreateRegKeyStr (S_AUTOSTRESS_KEY);
        MYASSERT (StressKey);

        pTransferAutoStressVal (StressKey, S_AUTOSTRESS_USER);
        pTransferAutoStressVal (StressKey, S_AUTOSTRESS_PASSWORD);
        pTransferAutoStressVal (StressKey, S_AUTOSTRESS_OFFICE);
        pTransferAutoStressVal (StressKey, S_AUTOSTRESS_DBG);
        pTransferAutoStressVal (StressKey, S_AUTOSTRESS_FLAGS);

        CloseRegKey (StressKey);
    }

#endif

}

PCTSTR
GetProfilePathForAllUsers (
    VOID
    )
{
    PTSTR result = NULL;
    DWORD size = 0;

    if (!GetAllUsersProfileDirectory (NULL, &size) &&
        ERROR_INSUFFICIENT_BUFFER != GetLastError()) {
        return NULL;
    }

    result = AllocPathString (size + 1);
    if (!GetAllUsersProfileDirectory (result, &size)) {
        FreePathString (result);
        return NULL;
    }
    return result;
}


PCTSTR
pGetDefaultShellFolderLocationFromInf (
    IN      PCTSTR FolderName,
    IN      PCTSTR ProfilePath
    )
{
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PCTSTR data;
    PCTSTR result = NULL;

    MYASSERT (g_WkstaMigInf && g_WkstaMigInf != INVALID_HANDLE_VALUE);

    if (InfFindFirstLine (g_WkstaMigInf, TEXT("ShellFolders.DefaultNtLocation"), FolderName, &is)) {
        data = InfGetStringField (&is, 1);
        if (data) {
            result = StringSearchAndReplace (data, S_USERPROFILE_ENV, ProfilePath);
            if (!result) {
                result = DuplicatePathString (data, 0);
            }
        }
    }

    InfCleanUpInfStruct (&is);

    return result;
}

VOID
pFixUpDynamicPaths (
    PCTSTR Category
    )
{
    MEMDB_ENUM e;
    TCHAR Pattern[MEMDB_MAX];
    PTSTR p;
    GROWBUFFER Roots = GROWBUF_INIT;
    MULTISZ_ENUM e2;
    TCHAR NewRoot[MEMDB_MAX];
    TCHAR AllProfilePath[MAX_TCHAR_PATH];
    PCTSTR ProfilePath;
    DWORD Size;
    PTSTR UserName;
    HKEY sfKey = NULL;
    PCTSTR sfPath = NULL;
    PTSTR NtLocation;
    PCTSTR tempExpand;
    BOOL regFolder;
    BOOL mkDir;

    //
    // Collect all the roots that need to be renamed
    //

    StringCopy (Pattern, Category);
    p = AppendWack (Pattern);
    StringCopy (p, TEXT("*"));

    if (MemDbEnumFirstValue (&e, Pattern, MEMDB_THIS_LEVEL_ONLY, MEMDB_ALL_BUT_PROXY)) {
        do {
            if ((_tcsnextc (e.szName) == TEXT('>')) ||
                (_tcsnextc (e.szName) == TEXT('<'))
                ) {
                StringCopy (p, e.szName);
                MultiSzAppend (&Roots, Pattern);
            }
        } while (MemDbEnumNextValue (&e));
    }

    //
    // Now change each root
    //

    if (EnumFirstMultiSz (&e2, (PCTSTR) Roots.Buf)) {
        do {
            //
            // Compute NewRoot
            //

            StringCopy (NewRoot, e2.CurrentString);

            p = _tcschr (NewRoot, TEXT('<'));

            if (p) {

                UserName = _tcschr (p, TEXT('>'));
                MYASSERT (UserName);
                StringCopyAB (Pattern, _tcsinc (p), UserName);
                UserName = _tcsinc (UserName);

                regFolder = TRUE;
                if (StringIMatch (Pattern, TEXT("Profiles"))) {
                    regFolder = FALSE;
                }
                if (StringIMatch (Pattern, TEXT("Common Profiles"))) {
                    regFolder = FALSE;
                }

                //
                // Get the profile root
                //

                if (StringIMatch (UserName, S_DOT_ALLUSERS)) {
                    Size = MAX_TCHAR_PATH;
                    if (regFolder) {
                        if (!GetAllUsersProfileDirectory (AllProfilePath, &Size)) {
                            DEBUGMSG ((DBG_WHOOPS, "Cannot get All Users profile path."));
                            continue;
                        }
                        sfKey = OpenRegKeyStr (S_USHELL_FOLDERS_KEY_SYSTEM);
                    } else {
                        if (!GetProfilesDirectory (AllProfilePath, &Size)) {
                            DEBUGMSG ((DBG_WHOOPS, "Cannot get All Users profile path."));
                            continue;
                        }
                    }
                } else if (StringMatch (UserName, S_DEFAULT_USER)) {
                    Size = MAX_TCHAR_PATH;
                    if (regFolder) {
                        if (!GetDefaultUserProfileDirectory (AllProfilePath, &Size)) {
                            DEBUGMSG ((DBG_WHOOPS, "Cannot get Default User profile path."));
                            continue;
                        }
                        sfKey = OpenRegKey (HKEY_CURRENT_USER, S_USHELL_FOLDERS_KEY_USER);
                    } else {
                        if (!GetProfilesDirectory (AllProfilePath, &Size)) {
                            DEBUGMSG ((DBG_WHOOPS, "Cannot get All Users profile path."));
                            continue;
                        }
                    }
                } else {
                    ProfilePath = GetProfilePathForUser (UserName);
                    if (!ProfilePath) {
                        DEBUGMSG ((DBG_WHOOPS, "Cannot get profile path for user:%s", UserName));
                        continue;
                    }
                    StringCopy (AllProfilePath, ProfilePath);
                    if (regFolder) {
                        sfKey = OpenRegKey (HKEY_CURRENT_USER, S_USHELL_FOLDERS_KEY_USER);
                    }
                }

                //
                // If a specific reg folder is specified, get its path
                //

                mkDir = FALSE;

                if (regFolder) {
                    if (!sfKey) {
                        DEBUGMSG ((DBG_ERROR, "Could not open Shell folders key."));
                        continue;
                    }
                    sfPath = GetRegValueString (sfKey, Pattern);
                    CloseRegKey (sfKey);

                    if (!sfPath || *sfPath == 0) {

                        DEBUGMSG ((DBG_WARNING, "Could not get Shell Folder path for: %s", Pattern));

                        tempExpand = pGetDefaultShellFolderLocationFromInf (Pattern, AllProfilePath);
                        if (!tempExpand) {
                            DEBUGMSG ((
                                DBG_WHOOPS,
                                "Shell folder %s is not in registry nor is it in [ShellFolders.DefaultNtLocation] of wkstamig.inf",
                                Pattern
                                ));
                            continue;
                        }

                        //
                        // Special case: Shell wants read-only on this folder. Create it now.
                        //

                        mkDir = TRUE;

                    } else {
                        tempExpand = StringSearchAndReplace (
                                        sfPath,
                                        S_USERPROFILE_ENV,
                                        AllProfilePath
                                        );

                        if (!tempExpand) {
                            tempExpand = DuplicatePathString (sfPath, 0);
                        }
                    }

                    if (sfPath) {
                        MemFree (g_hHeap, 0, sfPath);
                    }
                } else {
                    tempExpand = DuplicatePathString (AllProfilePath, 0);
                }

                //
                // Move symbolic name to full path
                //

                NtLocation = ExpandEnvironmentText (tempExpand);

                if (mkDir) {
                    MakeSurePathExists (NtLocation, TRUE);
                    SetFileAttributes (NtLocation, FILE_ATTRIBUTE_READONLY);
                }

                StringCopy (p, NtLocation);

                MemDbMoveTree (e2.CurrentString, NewRoot);

                FreeText (NtLocation);

                FreePathString (tempExpand);
            } else {

                p = _tcschr (NewRoot, TEXT('>'));
                MYASSERT (p);

                if (StringIMatch (_tcsinc (p), S_DOT_ALLUSERS)) {
                    Size = MAX_TCHAR_PATH;
                    if (!GetAllUsersProfileDirectory (AllProfilePath, &Size)) {
                        DEBUGMSG ((DBG_WARNING, "Dynamic path for %s could not be resolved", e2.CurrentString));
                    }
                    else {
                        StringCopy (p, AllProfilePath);
                        MemDbMoveTree (e2.CurrentString, NewRoot);
                    }
                } else if (StringMatch (_tcsinc (p), S_DEFAULT_USER)) {
                    Size = MAX_TCHAR_PATH;
                    if (!GetDefaultUserProfileDirectory (AllProfilePath, &Size)) {
                        DEBUGMSG ((DBG_WARNING, "Dynamic path for %s could not be resolved", e2.CurrentString));
                    }
                    else {
                        StringCopy (p, AllProfilePath);
                        MemDbMoveTree (e2.CurrentString, NewRoot);
                    }
                } else {
                    ProfilePath = GetProfilePathForUser (_tcsinc (p));
                    if (ProfilePath) {
                        StringCopy (p, ProfilePath);
                        MemDbMoveTree (e2.CurrentString, NewRoot);
                    }
                    else {
                        DEBUGMSG ((DBG_WARNING, "Dynamic path for %s could not be resolved", e2.CurrentString));
                    }
                }

            }

        } while (EnumNextMultiSz (&e2));
    }

    FreeGrowBuffer (&Roots);
}


VOID
pFixUpMemDb (
    VOID
    )
{
    MEMDB_ENUM e;
    TCHAR node[MEMDB_MAX];

    pFixUpDynamicPaths (MEMDB_CATEGORY_PATHROOT);
    //pFixUpDynamicPaths (MEMDB_CATEGORY_DATA);         OPTIMIZATION -- Data overlaps PathRoot
    pFixUpDynamicPaths (MEMDB_CATEGORY_USERFILEMOVE_DEST);
    pFixUpDynamicPaths (MEMDB_CATEGORY_SHELLFOLDERS_DEST);
    pFixUpDynamicPaths (MEMDB_CATEGORY_SHELLFOLDERS_SRC);
    pFixUpDynamicPaths (MEMDB_CATEGORY_LINKEDIT_TARGET);
    pFixUpDynamicPaths (MEMDB_CATEGORY_LINKEDIT_WORKDIR);
    pFixUpDynamicPaths (MEMDB_CATEGORY_LINKEDIT_ICONPATH);
    pFixUpDynamicPaths (MEMDB_CATEGORY_LINKSTUB_TARGET);
    pFixUpDynamicPaths (MEMDB_CATEGORY_LINKSTUB_WORKDIR);
    pFixUpDynamicPaths (MEMDB_CATEGORY_LINKSTUB_ICONPATH);

    //
    // Enumerate each user in MyDocsMoveWarning, then update dynamic paths
    //

    // MyDocsMoveWarning\<user>\<path>
    MemDbBuildKey (
        node,
        MEMDB_CATEGORY_MYDOCS_WARNING,
        TEXT("*"),
        NULL,
        NULL
        );

    if (MemDbEnumFirstValue (&e, node, MEMDB_THIS_LEVEL_ONLY, MEMDB_ALL_MATCHES)) {
        do {
            MemDbBuildKey (
                node,
                MEMDB_CATEGORY_MYDOCS_WARNING,
                e.szName,                           // <user>
                NULL,
                NULL
                );

            pFixUpDynamicPaths (node);

        } while (MemDbEnumNextValue (&e));
    }

}



BOOL
EnumFirstUserToMigrate (
    OUT     PMIGRATE_USER_ENUM e,
    IN      DWORD Flags
    )
{
    ZeroMemory (e, sizeof (MIGRATE_USER_ENUM));
    e->Flags = Flags;

    pCountUsers (&e->TotalUsers, &e->ActiveUsers);
    e->UserNumber = e->TotalUsers;

    Win95RegGetFirstUser (&e->up, e->Win95RegName);

    return EnumNextUserToMigrate (e);
}


BOOL
EnumNextUserToMigrate (
    IN OUT  PMIGRATE_USER_ENUM e
    )
{
    LONG rc;
    PCTSTR Domain;
    TCHAR Win9xAccount[MEMDB_MAX];
    TCHAR EnumAccount[MAX_TCHAR_PATH];
    USERPOSITION *AdminPosPtr;
    USERPOSITION AdminPos;
    BOOL Loop = TRUE;
    PCTSTR UserDatLocation;

    while (Loop) {

        if (e->UserNumber == 0) {
            return FALSE;
        }

        Loop = FALSE;
        e->UserNumber--;

        __try {
            e->UserDoingTheUpgrade = FALSE;

            if (e->UserNumber == INDEX_ADMINISTRATOR) {

                _tcssafecpy (e->FixedUserName, g_AdministratorStr, MAX_USER_NAME);
                StringCopy (e->Win9xUserName, e->FixedUserName);
                e->AccountType = ADMINISTRATOR_ACCOUNT;

            } else if (e->UserNumber == INDEX_LOGON_PROMPT) {

                StringCopy (e->FixedUserName, S_DOT_DEFAULT);
                StringCopy (e->Win9xUserName, e->FixedUserName);
                e->AccountType = LOGON_USER_SETTINGS;

            } else if (e->UserNumber == INDEX_DEFAULT_USER) {
                //
                // Do not process unless default user migration is enabled
                //

                if (!g_ConfigOptions.MigrateDefaultUser) {
                    Loop = (e->Flags & ENUM_ALL_USERS) == 0;
                    __leave;
                }

                StringCopy (e->FixedUserName, S_DEFAULT_USER);
                StringCopy (e->Win9xUserName, e->FixedUserName);
                e->AccountType = DEFAULT_USER_ACCOUNT;

            } else {

                _tcssafecpy (e->Win9xUserName, e->Win95RegName, MAX_USER_NAME);
                StringCopy (e->FixedUserName, e->Win95RegName);
                GetFixedUserName (e->FixedUserName);
                e->AccountType = WIN9X_USER_ACCOUNT;

                //
                // Special case: Account named Administrator exists.  In this
                //               case, we'd have two Administrator users unless
                //               one was skipped.  So here is the test to skip
                //               if the user is named Administrator.
                //

                if (StringIMatch (e->Win9xUserName, g_AdministratorStr)) {
                    Loop = TRUE;
                    __leave;
                }
            }

            StringCopy (e->FixedDomainName, e->FixedUserName);

            //
            // See if we are to migrate this user, and if so, perpare
            // the Win95 registry and call ProcessUser.
            //

            UserDatLocation = GetUserDatLocation (e->FixedUserName, &e->CreateOnly);

            if (UserDatLocation && DoesFileExist (UserDatLocation)) {
                e->Valid = TRUE;
                StringCopy (e->UserDatLocation, UserDatLocation);
            } else {
                e->Valid = FALSE;
                e->UserDatLocation[0] = 0;
            }

            if (e->Flags & ENUM_SET_WIN9X_HKR) {
                //
                // Make HKCU equal to the enumerated user
                //

                g_hKeyRoot95 = HKEY_CURRENT_USER;
            }

            if (e->Valid) {

                //
                // Is this user the user doing migration?
                //

                if (MemDbGetEndpointValueEx (
                        MEMDB_CATEGORY_ADMINISTRATOR_INFO,
                        MEMDB_ITEM_AI_USER_DOING_MIG,
                        NULL,       // no field
                        Win9xAccount
                        )) {
                    //
                    // Win9xAccount is unfixed name, convert to fixed name then
                    // compare with the current enumerated user.
                    //

                    GetFixedUserName (Win9xAccount);

                    DEBUGMSG ((DBG_NAUSEA, "Comparing %s to %s", e->FixedUserName, Win9xAccount));

                    if (StringIMatch (e->FixedUserName, Win9xAccount)) {
                        e->UserDoingTheUpgrade = TRUE;
                    }
                }

                //
                // Perform special init depending on the user type
                //

                if (e->AccountType == WIN9X_USER_ACCOUNT) {

                    if (e->Flags & ENUM_SET_WIN9X_HKR) {
                        //
                        // Map HKCU on Win95 to current user
                        //

                        rc = Win95RegSetCurrentUserNt (&e->up, e->UserDatLocation);

                        if (rc != ERROR_SUCCESS) {
                            SetLastError (rc);
                            LOG ((
                                LOG_ERROR,
                                "Migrate Users: Win95RegSetCurrentUserNt could not set user "
                                    "to %s (user path %s)",
                                e->FixedUserName,
                                e->UserDatLocation
                                ));

                            LOG ((LOG_ERROR, "Could not load %s", e->UserDatLocation));
                            Loop = (e->Flags & ENUM_ALL_USERS) == 0;
                            __leave;
                        }
                    }

                    // Obtain the full user name
                    Domain = GetDomainForUser (e->FixedUserName);
                    if (Domain) {
                        StringCopy (e->FixedDomainName, Domain);
                        StringCopy (AppendWack (e->FixedDomainName), e->FixedUserName);
                    }
                }

                else if (e->AccountType == ADMINISTRATOR_ACCOUNT) {

                    //
                    // Map Win9x registry appropriate for the Administrator hive
                    //

                    if (e->Flags & ENUM_SET_WIN9X_HKR) {
                        AdminPosPtr = NULL;

                        // Obtain user account from memdb and find USERPOSITION for it
                        if (MemDbGetEndpointValueEx (
                                MEMDB_CATEGORY_ADMINISTRATOR_INFO,
                                MEMDB_ITEM_AI_ACCOUNT,
                                NULL,       // no field
                                Win9xAccount
                                )) {

                            // Search Win9x user list for user
                            Win95RegGetFirstUser (&AdminPos, EnumAccount);
                            while (Win95RegHaveUser (&AdminPos)) {
                                GetFixedUserName (EnumAccount);

                                if (StringIMatch (Win9xAccount, EnumAccount)) {
                                    AdminPosPtr = &AdminPos;
                                    break;
                                }

                                Win95RegGetNextUser (&AdminPos, EnumAccount);
                            }

                            if (!AdminPosPtr) {
                                DEBUGMSG ((
                                    DBG_WARNING,
                                    "pMigrateUsers: Account %s not found",
                                    Win9xAccount
                                    ));
                            }
                        }

                        //
                        // Map HKCU on Win95 to match, or default user if no match or
                        // no memdb entry
                        //

                        rc = Win95RegSetCurrentUserNt (AdminPosPtr, e->UserDatLocation);

                        if (rc != ERROR_SUCCESS) {
                            SetLastError (rc);
                            LOG ((LOG_ERROR, "Could not load %s for Administrator", e->UserDatLocation));
                            Loop = (e->Flags & ENUM_ALL_USERS) == 0;
                            __leave;
                        }
                    }
                }

                else if (e->AccountType == LOGON_USER_SETTINGS || e->AccountType == DEFAULT_USER_ACCOUNT) {

                    //
                    // Map HKCU on Win95 to default user
                    //

                    if (e->Flags & ENUM_SET_WIN9X_HKR) {
                        rc = Win95RegSetCurrentUserNt (NULL, e->UserDatLocation);

                        if (rc != ERROR_SUCCESS) {
                            SetLastError (rc);
                            LOG ((LOG_ERROR, "Could not load default user hive"));
                            Loop = (e->Flags & ENUM_ALL_USERS) == 0;
                            __leave;
                        }
                    }
                }

            } /* if (e->Valid) */

            else {
                Loop = (e->Flags & ENUM_ALL_USERS) == 0;
            }

        } /* try */

        __finally {
            //
            // Get the next user for next time through loop, ignore errors
            //

            if (e->AccountType == WIN9X_USER_ACCOUNT) {
                Win95RegGetNextUser (&e->up, e->Win95RegName);
            }
        }
    } /* while (Loop) */

    DEBUGMSG_IF ((
        e->Flags & ENUM_SET_WIN9X_HKR,
        DBG_VERBOSE,
        "--- User Info ---\n"
            " User Name: %s (%s)\n"
            " Domain User Name: %s\n"
            " Win95Reg Name: %s\n"
            " User Hive: %s\n"
            " Account Type: %s\n"
            " Create Only: %s\n"
            " Valid: %s\n"
            " UserDoingTheUpgrade: %s\n",
        e->Win9xUserName,
        e->FixedUserName,
        e->FixedDomainName,
        e->Win95RegName,
        e->UserDatLocation,
        e->AccountType == WIN9X_USER_ACCOUNT ? TEXT("User") :
            e->AccountType == ADMINISTRATOR_ACCOUNT ? TEXT("Administrator") :
            e->AccountType == LOGON_USER_SETTINGS ? TEXT("Logon User") :
            e->AccountType == DEFAULT_USER_ACCOUNT ? TEXT("Default User") : TEXT("Unknown"),
        e->CreateOnly ? TEXT("Yes") : TEXT("No"),
        e->Valid ? TEXT("Yes") : TEXT("No"),
        e->UserDoingTheUpgrade ? TEXT("Yes") : TEXT("No")
        ));

    return TRUE;
}


VOID
RunExternalProcesses (
    IN      HINF Inf,
    IN      PMIGRATE_USER_ENUM EnumPtr          OPTIONAL
    )
{
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    GROWLIST List = GROWLIST_INIT;
    PCTSTR RawCmdLine;
    PCTSTR ExpandedCmdLine;
    BOOL ProcessResult;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    DWORD rc;

    GrowListAppendString (&List, TEXT("SYSTEMDIR"));
    GrowListAppendString (&List, g_System32Dir);

    if (EnumPtr) {

        GrowListAppendString (&List, TEXT("USERNAME"));
        GrowListAppendString (&List, EnumPtr->FixedUserName);

        GrowListAppendString (&List, TEXT("USERNAMEWITHDOMAIN"));
        GrowListAppendString (&List, EnumPtr->FixedDomainName);

        GrowListAppendString (&List, TEXT("PREVOS_USERNAME"));
        GrowListAppendString (&List, EnumPtr->Win9xUserName);

        if (EnumPtr->AccountType != LOGON_USER_SETTINGS) {

            GrowListAppendString (&List, TEXT("USERHIVEROOT"));
            GrowListAppendString (&List, S_FULL_TEMP_USER_KEY);

        } else {

            GrowListAppendString (&List, TEXT("USERHIVEROOT"));
            GrowListAppendString (&List, S_DEFAULT_USER_KEY);

        }

        if (EnumPtr->ExtraData) {
            GrowListAppendString (&List, TEXT("USERPROFILE"));
            GrowListAppendString (&List, EnumPtr->ExtraData->TempProfile);
        }
    }

    //
    // Terminate the arg list with two NULLs
    //

    GrowListAppendEmptyItem (&List);
    GrowListAppendEmptyItem (&List);

    if (InfFindFirstLine (Inf, S_EXTERNAL_PROCESSES, NULL, (&is))) {
        do {
            //
            // Get the command line
            //

            RawCmdLine = InfGetLineText (&is);

            //
            // Expand environment variables
            //

            ExpandedCmdLine = ExpandEnvironmentTextEx (
                                    RawCmdLine,
                                    GrowListGetStringPtrArray (&List)
                                    );

            //
            // Launch the process
            //

            ZeroMemory (&si, sizeof (si));
            si.cb = sizeof (si);
            si.dwFlags = STARTF_FORCEOFFFEEDBACK;

            ProcessResult = CreateProcess (
                                NULL,
                                (PTSTR) ExpandedCmdLine,
                                NULL,
                                NULL,
                                FALSE,
                                CREATE_DEFAULT_ERROR_MODE,
                                NULL,
                                NULL,
                                &si,
                                &pi
                                );

            if (ProcessResult) {

                CloseHandle (pi.hThread);

                //
                // Wait 60 seconds for the process to complete
                //

                rc = WaitForSingleObject (pi.hProcess, 60000);
                if (rc != WAIT_OBJECT_0) {
                    TerminateProcess (pi.hProcess, 0);
                    DEBUGMSG ((DBG_ERROR, "Process %s timed out and was aborted", ExpandedCmdLine));
                }
                ELSE_DEBUGMSG ((DBG_VERBOSE, "External process completed: %s", ExpandedCmdLine));

                CloseHandle (pi.hProcess);

            }
            ELSE_DEBUGMSG ((DBG_ERROR, "Cannot launch %s", ExpandedCmdLine));

            FreeText (ExpandedCmdLine);

        } while (InfFindNextLine (&is));
    }

    FreeGrowList (&List);
    InfCleanUpInfStruct (&is);
}


DWORD
MigrateGhostSystemFiles (
    IN      DWORD Request
    )
{
    /*
    TREE_ENUM e;
    PCTSTR systemName;
    DWORD status;
    */

    if (Request == REQUEST_QUERYTICKS) {
        return TICKS_GHOST_SYSTEM_MIGRATION;
    } else if (Request != REQUEST_RUN) {
        return ERROR_SUCCESS;
    }

    /*
    if (EnumFirstFileInTreeEx (&e, g_System32Dir, NULL, FALSE, FALSE, FILE_ENUM_THIS_LEVEL)) {
        do {
            systemName = JoinPaths (g_SystemDir, e.Name);
            status = GetFileStatusOnNt (systemName);

            if ((status & FILESTATUS_NTINSTALLED) &&
                !(status & FILESTATUS_MOVED)
                ) {
                if (!DoesFileExist (systemName)) {
                    MarkFileForMove (systemName, e.FullPath);
                }
            }
            FreePathString (systemName);

        } while (EnumNextFileInTree (&e));
    }
    */
    return ERROR_SUCCESS;
}


typedef struct _KNOWN_DIRS {
    PCTSTR DirId;
    PCTSTR Translation;
}
KNOWN_DIRS, *PKNOWN_DIRS;

KNOWN_DIRS g_KnownDirs [] = {
    {TEXT("10"), g_WinDir},
    {NULL,  NULL}
    };

typedef struct {
    PCTSTR  ShellFolderName;
    PCTSTR  DirId;
    PCTSTR  ShellFolderNameDefault;
    BOOL    bUsed;
} SHELL_TO_DIRS, *PSHELL_TO_DIRS;

SHELL_TO_DIRS g_ShellToDirs[] = {
    {TEXT("Administrative Tools"), TEXT("7501"), TEXT("7517\\Administrative Tools")},
    {TEXT("Common Administrative Tools"), TEXT("7501"), TEXT("7517\\Administrative Tools")},
    {TEXT("AppData"), TEXT("7502"), TEXT("Application Data")},
    {TEXT("Common AppData"), TEXT("7502"), TEXT("Application Data")},
    {TEXT("Cache"), TEXT("7503"), NULL},
    {TEXT("Cookies"), TEXT("7504"), NULL},
    {TEXT("Desktop"), TEXT("7505"), NULL},
    {TEXT("Common Desktop"), TEXT("7505"), TEXT("Desktop")},
    {TEXT("Favorites"), TEXT("7506"), NULL},
    {TEXT("Common Favorites"), TEXT("7506"), TEXT("Favorites")},
    {TEXT("Local Settings"), TEXT("7510"), NULL},
    {TEXT("History"), TEXT("7508"), TEXT("7510\\History")},
    {TEXT("Local AppData"), TEXT("7509"), TEXT("7510\\Application Data")},
    {TEXT("Personal"), TEXT("7515"), TEXT("My Documents")},
    {TEXT("Common Documents"), TEXT("7515"), TEXT("My Documents")},
    {TEXT("My Music"), TEXT("7511"), TEXT("7515\\My Music")},
    {TEXT("CommonMusic"), TEXT("7511"), TEXT("7515\\My Music")},
    {TEXT("My Pictures"), TEXT("7512"), TEXT("7515\\My Pictures")},
    {TEXT("CommonPictures"), TEXT("7512"), TEXT("7515\\My Pictures")},
    {TEXT("My Video"), TEXT("7513"), TEXT("7515\\My Video")},
    {TEXT("CommonVideo"), TEXT("7513"), TEXT("7515\\My Video")},
    {TEXT("NetHood"), TEXT("7514"), NULL},
    {TEXT("PrintHood"), TEXT("7516"), NULL},
    {TEXT("Start Menu"), TEXT("7520"), NULL},
    {TEXT("Common Start Menu"), TEXT("7520"), TEXT("Start Menu")},
    {TEXT("Programs"), TEXT("7517"), TEXT("7520\\Programs")},
    {TEXT("Common Programs"), TEXT("7517"), TEXT("7520\\Programs")},
    {TEXT("Recent"), TEXT("7518"), NULL},
    {TEXT("SendTo"), TEXT("7519"), NULL},
    {TEXT("Startup"), TEXT("7521"), TEXT("7517\\Startup")},
    {TEXT("Common Startup"), TEXT("7521"), TEXT("7517\\Startup")},
    {TEXT("Templates"), TEXT("7522"), NULL},
    {TEXT("Common Templates"), TEXT("7522"), TEXT("Templates")},
    {TEXT("Fonts"), TEXT("7507"), TEXT("10\\Fonts")},
    {NULL, NULL, NULL, FALSE}
    };

GROWLIST g_KnownDirIds = GROWLIST_INIT;
GROWLIST g_KnownDirPaths = GROWLIST_INIT;

VOID
pAddKnownShellFolder (
    IN      PCTSTR ShellFolderName,
    IN      PCTSTR SrcPath
    )
{
    PSHELL_TO_DIRS p;

    for (p = g_ShellToDirs ; p->ShellFolderName ; p++) {
        if (StringIMatch (ShellFolderName, p->ShellFolderName)) {
            break;
        }
    }

    if (!p->ShellFolderName) {
        DEBUGMSG ((DBG_ERROR, "This system has an unsupported shell folder tag: %s", ShellFolderName));
        return;
    }

    p->bUsed = TRUE;

    GrowListAppendString (&g_KnownDirIds, p->DirId);
    GrowListAppendString (&g_KnownDirPaths, SrcPath);
}

typedef struct {
    PCTSTR sfName;
    PCTSTR sfPath;
    HKEY SfKey;
    REGVALUE_ENUM SfKeyEnum;
    BOOL UserSf;
} SF_ENUM, *PSF_ENUM;

BOOL
EnumFirstRegShellFolder (
    IN OUT  PSF_ENUM e,
    IN      BOOL UserSf
    );
BOOL
EnumNextRegShellFolder (
    IN OUT  PSF_ENUM e
    );

BOOL
pConvertDirName (
    PCTSTR OldDirName,
    PTSTR  NewDirName,
    PINT NameNumber
    );

VOID
pInitKnownDirs (
    IN      BOOL bUser
    )
{
    SF_ENUM e;
    PCTSTR profileForAllUsers;
    PCTSTR profileForAllUsersVar = TEXT("%ALLUSERSPROFILE%");
    PCTSTR sfPathPtr;
    TCHAR shellPartialPath[MAX_PATH];
    UINT charCount;
    UINT charCountProfileVar;
    UINT charCountProfile;
    PSHELL_TO_DIRS p;
    KNOWN_DIRS * pKnownDirs;
    INT nameNumber;

    for (p = g_ShellToDirs ; p->ShellFolderName; p++){
        p->bUsed = FALSE;
    }

    if(bUser){
        if (EnumFirstRegShellFolder(&e, TRUE)) {
            do {
                pAddKnownShellFolder(e.sfName, e.sfPath);
                DEBUGMSG((DBG_VERBOSE, "USER: ShellFolderPath=%s\nCutedFolderPath=%s", e.sfPath, e.sfPath));
            } while (EnumNextRegShellFolder(&e));
        }
    }
    else{
        profileForAllUsers = GetProfilePathForAllUsers();
        MYASSERT(profileForAllUsers);
        if(profileForAllUsers){
            charCountProfile = TcharCount(profileForAllUsers);
        }

        charCountProfileVar = TcharCount(profileForAllUsersVar);

        if (EnumFirstRegShellFolder(&e, FALSE)) {
            do {
                if(profileForAllUsers){
                    charCount = 0;
                    if(StringIMatchCharCount(e.sfPath, profileForAllUsers, charCountProfile)){
                        charCount = charCountProfile;
                    }
                    else{
                        if(StringIMatchCharCount(e.sfPath, profileForAllUsersVar, charCountProfileVar)){
                            charCount = charCountProfileVar;
                        }
                    }

                    StringCopy(shellPartialPath, TEXT("%USERPROFILE%"));
                    StringCat(shellPartialPath, &e.sfPath[charCount]);
                    sfPathPtr = shellPartialPath;
                }
                else{
                    sfPathPtr = e.sfPath;
                }
                DEBUGMSG((DBG_VERBOSE, "SYSTEM: ShellFolderPath=%s\r\nCutedFolderPath=%s", e.sfPath, shellPartialPath));
                pAddKnownShellFolder(e.sfName, sfPathPtr);
            } while (EnumNextRegShellFolder(&e));
        }

        FreePathString (profileForAllUsers);
    }

    for (pKnownDirs = g_KnownDirs ; pKnownDirs->DirId ; pKnownDirs++) {
        GrowListAppendString (&g_KnownDirIds, pKnownDirs->DirId);
        GrowListAppendString (&g_KnownDirPaths, pKnownDirs->Translation);
    }

    for (p = g_ShellToDirs ; p->ShellFolderName; p++){
        if(p->bUsed){
            continue;
        }

        shellPartialPath[0] = '\0';

        nameNumber = 0;
        pConvertDirName(p->DirId, shellPartialPath, &nameNumber);
        if(!StringMatch (p->DirId, shellPartialPath)){
            p->bUsed = TRUE;
            continue;
        }

        if(p->ShellFolderNameDefault){
            if(_istdigit(p->ShellFolderNameDefault[0])){
                nameNumber = 0;
                pConvertDirName(
                    p->ShellFolderNameDefault,
                    shellPartialPath,
                    &nameNumber);
            }
            else{
                StringCopy(shellPartialPath, TEXT("%USERPROFILE%\\"));
                StringCat(shellPartialPath, p->ShellFolderNameDefault);
            }
        }
        else{
            StringCopy(shellPartialPath, TEXT("%USERPROFILE%\\"));
            StringCat(shellPartialPath, p->ShellFolderName);
        }

        pAddKnownShellFolder(p->ShellFolderName, shellPartialPath);
        DEBUGMSG((DBG_VERBOSE, "REST: ShellFolderPath=%s\nCutedFolderPath=%s", p->ShellFolderName, shellPartialPath));
    }
}

VOID
pCleanUpKnownDirs (
    VOID
    )
{
    FreeGrowList (&g_KnownDirPaths);
    FreeGrowList (&g_KnownDirIds);
}

BOOL
pConvertDirName (
    PCTSTR OldDirName,
    PTSTR  NewDirName,
    PINT NameNumber
    )
{
    PCTSTR OldDirCurr = OldDirName;
    PCTSTR OldDirNext;
    BOOL match = FALSE;
    INT index;
    PCTSTR listStr;

    if (*NameNumber == -1) {
        return FALSE;
    }

    //
    // Extract the dir id, keeping a pointer to the subdir
    //

    NewDirName[0] = 0;
    OldDirNext = _tcschr (OldDirCurr, '\\');
    if (OldDirNext == NULL) {
        OldDirNext = GetEndOfString (OldDirCurr);
    }

    StringCopyAB (NewDirName, OldDirCurr, OldDirNext);

    //
    // Find the next match in the known dir ID list
    //

    listStr = GrowListGetString (&g_KnownDirIds, *NameNumber);

    while (listStr) {

        *NameNumber += 1;

        if (StringMatch (NewDirName, listStr)) {
            listStr = GrowListGetString (&g_KnownDirPaths, (*NameNumber) - 1);
            MYASSERT (listStr);
            StringCopy (NewDirName, listStr);
            break;
        }

        listStr = GrowListGetString (&g_KnownDirIds, *NameNumber);
    }

    //
    // Cat the subpath to the output string and return
    //

    StringCat (NewDirName, OldDirNext);

    if (!listStr) {
        *NameNumber = -1;
        return FALSE;
    }

    return TRUE;
}

VOID
pUninstallUserProfileCleanupPreparation (
    IN      HINF Inf,
    IN      PTSTR UserNamePtr,
    IN      PCTSTR PathProfileRootPtr,
    IN      PCTSTR DocsAndSettingsRoot,
    IN      GROWLIST * ListOfLogicalPathsPtr,
    IN OUT  GROWLIST * ListOfPaths
    )
{
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    GROWLIST List = GROWLIST_INIT;
    PTSTR rawDir;
    TCHAR rawPath[MAX_PATH];
    PTSTR ExpandedPath;
    PTSTR fileName;
    TCHAR shellPath[MAX_PATH];
    INT nameNumber;
    INT i;
    INT listSize;
    PCTSTR pathLogicalPath;


    GrowListAppendString (&List, TEXT("USERPROFILE"));
    GrowListAppendString (&List, PathProfileRootPtr);

    GrowListAppendString (&List, TEXT("PROFILES"));
    GrowListAppendString (&List, DocsAndSettingsRoot);

    GrowListAppendString (&List, TEXT("USERNAME"));
    GrowListAppendString (&List, UserNamePtr);

    GrowListAppendEmptyItem (&List);
    GrowListAppendEmptyItem (&List);

    DEBUGMSG ((DBG_VERBOSE, "USERPROFILE.pathProfileRoot=%s\n", PathProfileRootPtr));

    if (InfFindFirstLine (Inf, S_UNINSTALL_PROFILE_CLEAN_OUT, NULL, (&is))) {
        do{
            rawDir = InfGetStringField (&is, 1);
            if(!rawDir || *rawDir == 0){
                DEBUGMSG ((DBG_VERBOSE, "rawDir == NULL"));
                continue;
            }

            StringCopy (rawPath, rawDir);

            fileName = InfGetStringField (&is, 2);
            if (fileName && *fileName) {
                StringCopy (AppendWack(rawPath), fileName);
            }

            nameNumber = 0;
            pConvertDirName(rawPath, shellPath, &nameNumber);

            ExpandedPath = ExpandEnvironmentTextEx (
                                shellPath,
                                GrowListGetStringPtrArray (&List)
                                );

            DEBUGMSG ((DBG_VERBOSE, "rawPath=%s\nExpandedPath=%s\nShellPath=%s", rawPath, ExpandedPath, shellPath));

            GrowListAppendString (ListOfPaths, ExpandedPath);

            FreeText (ExpandedPath);

        } while (InfFindNextLine (&is));
    }

    if(ListOfLogicalPathsPtr){
        for(i = 0, listSize = GrowListGetSize (ListOfLogicalPathsPtr); i < listSize; i++) {
            pathLogicalPath = GrowListGetString(ListOfLogicalPathsPtr, i);
            if(!pathLogicalPath){
                continue;
            }

            nameNumber = 0;
            pConvertDirName(pathLogicalPath, shellPath, &nameNumber);

            ExpandedPath = ExpandEnvironmentTextEx (
                                shellPath,
                                GrowListGetStringPtrArray (&List)
                                );

            GrowListAppendString (ListOfPaths, ExpandedPath);

            FreeText (ExpandedPath);
        }
    }

    FreeGrowList (&List);
    InfCleanUpInfStruct (&is);

    DEBUGMSG ((DBG_VERBOSE, "UninstallUserProfileCleanupPreparation end"));
}

BOOL
pGetProfilePathForAllUsers(
    OUT     PTSTR AccountName,
    OUT     PTSTR PathProfile
    )
{
    PCTSTR pathProfileForAllUser;

    MYASSERT(AccountName && PathProfile);
    if(!AccountName || !PathProfile){
        MYASSERT(FALSE);
        return FALSE;
    }

    pathProfileForAllUser = GetProfilePathForAllUsers();
    if(!pathProfileForAllUser) {
        return FALSE;
    }

    StringCopy (AccountName, S_ALL_USERS);
    StringCopy (PathProfile, pathProfileForAllUser);

    return TRUE;
}

BOOL
pGetProfilePathForDefaultUser(
       OUT      PTSTR AccountName,
       OUT      PTSTR PathProfile
       )
{
    DWORD bufferSize;

    MYASSERT(AccountName && PathProfile);
    if(!AccountName || !PathProfile){
        MYASSERT(FALSE);
        return FALSE;
    }

    bufferSize = MAX_PATH;
    if(!GetDefaultUserProfileDirectory(PathProfile, &bufferSize) ||
       !PathProfile[0]) {
        return FALSE;
    }

    StringCopy (AccountName, S_DEFAULT_USER);

    return TRUE;
}

BOOL
pGetProfilePathForUser(
       IN       PCTSTR UserName,
       OUT      PTSTR AccountName,
       OUT      PTSTR PathProfile
       )
{
    DWORD bufferSize;

    MYASSERT(UserName && UserName[0] && AccountName && PathProfile);
    if(!UserName || !UserName[0] || !AccountName || !PathProfile){
        MYASSERT(FALSE);
        return FALSE;
    }

    bufferSize = MAX_PATH;
    if(!GetProfilesDirectory(PathProfile, &bufferSize) ||
       !PathProfile[0]) {
        MYASSERT(FALSE);
        return FALSE;
    }
    StringCat(AppendWack(PathProfile), UserName);

    StringCopy (AccountName, UserName);

    return TRUE;
}

BOOL
pGetProfilePathForLocalService(
       OUT      PTSTR AccountName,
       OUT      PTSTR PathProfile
       )
{
    return pGetProfilePathForUser(S_LOCALSERVICE_USER, AccountName, PathProfile);
}

BOOL
pGetProfilePathForNetworkService(
       OUT      PTSTR AccountName,
       OUT      PTSTR PathProfile
       )
{
    return pGetProfilePathForUser(S_NETWORKSERVICE_USER, AccountName, PathProfile);
}

BOOL
pGetProfilePathForMachineName(
       OUT      PTSTR AccountName,
       OUT      PTSTR PathProfile
       )
{
    TCHAR machineName[MAX_COMPUTERNAME_LENGTH + 2];
    PTSTR machineNamePtr = ExpandEnvironmentTextEx (TEXT("%COMPUTERNAME%"), NULL);
    BOOL bResult;

    if(!machineNamePtr || machineNamePtr[0] == '%'){
        MYASSERT(FALSE);
        DEBUGMSG((DBG_VERBOSE, "ComputerName is NULL"));
        return FALSE;
    }
    DEBUGMSG ((DBG_VERBOSE, "machineName=%s", machineNamePtr? machineNamePtr: TEXT("NULL")));

    StringCopy(machineName, machineNamePtr);
    StringCat(machineName, TEXT("$"));

    return pGetProfilePathForUser(machineName, AccountName, PathProfile);
}

VOID
UninstallUserProfileCleanupPreparation (
    IN      HINF Inf,
    IN      PMIGRATE_USER_ENUM EnumPtr,
    IN      BOOL Playback
    )
{
    static GROWLIST listOfPaths = GROWLIST_INIT;
    static PROFILE_PATH_PROVIDER profilePathProviders[] =
            {
                pGetProfilePathForAllUsers,
                pGetProfilePathForDefaultUser,
                pGetProfilePathForLocalService,
                pGetProfilePathForNetworkService,
                pGetProfilePathForMachineName
            };

    TCHAR accountName[MAX_PATH];
    TCHAR pathProfile[MAX_PATH];
    TCHAR docsAndSettingsRoot[MAX_PATH];
    PCTSTR pathProfileRootPtr;
    UINT i;
    UINT listSize;
    DWORD bufferSize;
    INT stringLen;
    INT cleanOutType;
    TCHAR pathDir[MAX_PATH];

    bufferSize = ARRAYSIZE (docsAndSettingsRoot);
    if (!GetProfilesDirectory (docsAndSettingsRoot, &bufferSize)) {
        DEBUGMSG ((DBG_ERROR, "Can't get Documents and Settings root"));
        *docsAndSettingsRoot = 0;
    }

    if (EnumPtr) {
        pathProfileRootPtr = GetProfilePathForUser(EnumPtr->FixedUserName);
        if(pathProfileRootPtr) {

            pInitKnownDirs(TRUE);

            pUninstallUserProfileCleanupPreparation(
                Inf,
                EnumPtr->FixedUserName,
                pathProfileRootPtr,
                docsAndSettingsRoot,
                &g_StartMenuItemsForCleanUpPrivate,
                &listOfPaths
                );

            pCleanUpKnownDirs();
        }
    } else {
        pInitKnownDirs(FALSE);

        for(i = 0; i < ARRAYSIZE(profilePathProviders); i++){
            if(profilePathProviders[i](accountName, pathProfile)){
                pUninstallUserProfileCleanupPreparation(
                    Inf,
                    accountName,
                    pathProfile,
                    docsAndSettingsRoot,
                    &g_StartMenuItemsForCleanUpCommon,
                    &listOfPaths
                    );
            }
        }

        pCleanUpKnownDirs();
    }

    if (Playback) {
        for(i = 0, listSize = GrowListGetSize (&listOfPaths); i < listSize; i++) {

            pathProfileRootPtr = GrowListGetString(&listOfPaths, i);
            if (pathProfileRootPtr){

                stringLen = TcharCount(pathProfileRootPtr);
                if(stringLen > 2 && '*' == pathProfileRootPtr[stringLen - 1]){
                    MYASSERT('\\' == pathProfileRootPtr[stringLen - 2] || '/' == pathProfileRootPtr[stringLen - 2]);
                    StringCopyTcharCount(pathDir, pathProfileRootPtr, stringLen - 1);
                    pathProfileRootPtr = pathDir;
                    cleanOutType = BACKUP_AND_CLEAN_TREE;
                }
                else{
                    cleanOutType = BACKUP_FILE;
                }

                if (!MemDbSetValueEx (
                        MEMDB_CATEGORY_CLEAN_OUT,
                        pathProfileRootPtr,
                        NULL,
                        NULL,
                        cleanOutType,
                        NULL
                        )){
                    DEBUGMSG ((DBG_VERBOSE, "MemDbSetValueEx - failed"));
                }
            }
        }
        FreeGrowList (&listOfPaths);

        FreeGrowList (&g_StartMenuItemsForCleanUpCommon);
        FreeGrowList (&g_StartMenuItemsForCleanUpPrivate);
    }
}


VOID
SetClassicLogonType (
    VOID
    )
{
    static BOOL logonTypeChanged = FALSE;
    DWORD d;
    HKEY key;
    LONG regResult;

    if (!logonTypeChanged) {
        key = OpenRegKeyStr (S_WINLOGON_REGKEY);
        if (key) {
            d = 0;      // classic logon style
            regResult = RegSetValueEx (
                            key,
                            TEXT("LogonType"),
                            0,
                            REG_DWORD,
                            (PCBYTE)(&d),
                            sizeof (d)
                            );

            if (regResult == ERROR_SUCCESS) {
                logonTypeChanged = TRUE;
                LOG ((LOG_INFORMATION, "Logon type set to classic style because of MigrateUserAs answer file settings"));
            }

            CloseRegKey (key);
        }

        if (!logonTypeChanged) {
            LOG ((LOG_ERROR, "Failed to set logon type to classic style; users will not appear in the logon menu"));
            logonTypeChanged = TRUE;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\migmainp.h ===
//
// migmainp.h - private declarations for migmain library
//

#pragma once

#ifdef DEBUG

extern BOOL g_NoReloadsAllowed;

#endif


//
// Externs
//

extern HKEY g_hKeyRoot95, g_hKeyRootNT;
extern PCTSTR g_DomainUserName;
extern PCTSTR g_Win9xUserName;
extern PCTSTR g_FixedUserName;
extern PVOID g_HiveTable;
extern POOLHANDLE g_HivePool;
extern TCHAR g_UserDatLocation[MAX_TCHAR_PATH];
extern PVOID g_NulSessionTable;
extern BOOL g_WorkgroupFlag;
extern BOOL g_DomainProblem;
extern INT g_RetryCount;
extern PCTSTR g_EveryoneStr;
extern PCTSTR g_AdministratorsGroupStr;
extern PCTSTR g_PowerUsersGroupStr;
extern PCTSTR g_DomainUsersGroupStr;
extern PCTSTR g_NoneGroupStr;
extern TCHAR g_DefaultUserName[MAX_USER_NAME];
extern BOOL g_PersonalSKU;
extern GROWLIST g_StartMenuItemsForCleanUpCommon;
extern GROWLIST g_StartMenuItemsForCleanUpPrivate;
extern BOOL g_BlowAwayTempShellFolders;

//
// Defines
//

#define INDEX_MAX               3
#define INDEX_ADMINISTRATOR     2
#define INDEX_LOGON_PROMPT      1
#define INDEX_DEFAULT_USER      0

#define MAX_SID_SIZE    1024

#define DOMAIN_RETRY_ABORT  -2
#define DOMAIN_RETRY_NO     -1
#define DOMAIN_RETRY_RESET  0
#define DOMAIN_RETRY_MAX    3

//
// Bit test macros
//

#define BITSARESET(bits,mask)     (((bits) & (mask)) == (mask))
#define BITSARECLEAR(bits,mask)   (((bits) & (mask)) == 0)

//
// Typedefs
//
typedef struct {
    PCWSTR User;
    PCWSTR Password;
    PCWSTR EncryptedPassword;
    DWORD PasswordAttribs;
    PCWSTR AdminComment;
    PCWSTR FullName;
} ACCOUNTPROPERTIES, *PACCOUNTPROPERTIES;

typedef struct {
    PCWSTR DomainName;
    PCWSTR Server;
    INT DomainNumber;       // for enumeration
} TRUST_ENUM, *PTRUST_ENUM;

typedef struct _tagACCT_POSSIBLE_DOMAINS {
    struct _tagACCT_DOMAINS *DomainPtr;
    struct _tagACCT_POSSIBLE_DOMAINS *Next;
} ACCT_POSSIBLE_DOMAINS, *PACCT_POSSIBLE_DOMAINS;

typedef struct _tagACCT_USERS {
    PCWSTR User;
    INT PossibleDomains;
    struct _tagACCT_USERS *Next, *Prev;
    struct _tagACCT_DOMAINS *DomainPtr;

    // for users with unknown domains
    struct _tagACCT_POSSIBLE_DOMAINS *FirstPossibleDomain;
} ACCT_USERS, *PACCT_USERS;

typedef struct _tagACCT_DOMAINS {
    PCWSTR Domain;
    PCWSTR Server;         // NULL if nul session not established
    INT UserCount;
    struct _tagACCT_DOMAINS *Next;
    struct _tagACCT_USERS *FirstUserPtr;
} ACCT_DOMAINS, *PACCT_DOMAINS;

typedef struct {
    PACCT_DOMAINS DomainPtr;
    PACCT_USERS UserPtr;
    PACCT_POSSIBLE_DOMAINS PossibleDomainPtr;
} ACCT_ENUM, *PACCT_ENUM;

typedef struct {
    DWORD Attribs;
    BOOL Enabled;
    BOOL Failed;
    PSID Sid;           // used only in CreateAclFromMemberList
    TCHAR UserOrGroup[];
} ACLMEMBER, *PACLMEMBER;




//
// Prototypes
//
PCTSTR
GetMemDbDat (
    VOID
    );

VOID
RunExternalProcesses (
    IN      HINF Inf,
    IN      PMIGRATE_USER_ENUM EnumPtr
    );

VOID
UninstallUserProfileCleanupPreparation (
    IN      HINF Inf,
    IN      PMIGRATE_USER_ENUM EnumPtr,
    IN      BOOL bPlayback
    );

DWORD
ProcessUser (
    IN      DWORD Request,
    IN      PMIGRATE_USER_ENUM EnumPtr
    );

DWORD
ProcessLocalMachine_First (
    DWORD Request
    );

DWORD
ProcessLocalMachine_Last (
    DWORD Request
    );

DWORD
ProcessMigrationDLLs (
    DWORD Request
    );

PCTSTR GetString (WORD wMsg);

VOID
PrepareMigrationProgressBar (
    VOID
    );

BOOL
CallAllMigrationFunctions (
    VOID
    );

VOID
FindAccountInit (
    VOID
    );

VOID
FindAccountTerminate (
    VOID
    );

BOOL
SearchDomainsForUserAccounts (
    VOID
    );

BOOL
RetryMessageBox (
    DWORD Id,
    PCTSTR *ArgArray
    );

PCWSTR
GetDomainForUser (
    IN      PCWSTR User
    );

PSID
GetSidForUser (
    PCWSTR User
    );

PCTSTR
GetUserProfilePath (
    IN      PCTSTR AccountName,
    OUT     PTSTR *BufferPtr
    );

PCTSTR
GetUserDatLocation (
    IN      PCTSTR User,
    OUT     PBOOL CreateOnlyFlag            OPTIONAL
    );

//
// acctlist.c functions
//

VOID
InitAccountList (
    VOID
    );

VOID
TerminateAccountList (
    VOID
    );

PCWSTR
ListFirstDomain (
    OUT     PACCT_ENUM DomainEnumPtr
    );

PCWSTR
ListNextDomain (
    IN OUT  PACCT_ENUM DomainEnumPtr
    );

BOOL
IsTrustedDomain (
    IN      PACCT_ENUM DomainEnumPtr
    );

BOOL
FindDomainInList (
    OUT     PACCT_ENUM DomainEnumPtr,
    IN      PCWSTR DomainToFind
    );

PCWSTR
ListFirstUserInDomain (
    IN      PACCT_ENUM DomainEnumPtr,
    OUT     PACCT_ENUM UserEnumPtr
    );

PCWSTR
ListNextUserInDomain (
    IN OUT  PACCT_ENUM UserEnumPtr
    );

BOOL
FindUserInDomain (
    IN      PACCT_ENUM DomainEnumPtr,
    OUT     PACCT_ENUM UserEnumPtr,
    IN      PCWSTR UserToFind
    );

INT
CountUsersInDomain (
    IN      PACCT_ENUM DomainEnumPtr
    );

VOID
AddDomainToList (
    IN      PCWSTR Domain
    );

BOOL
AddUserToDomainList (
    IN      PCWSTR User,
    IN      PCWSTR Domain
    );

VOID
DeleteUserFromDomainList (
    IN      PACCT_ENUM UserEnumPtr
    );

BOOL
MoveUserToNewDomain (
    IN OUT  PACCT_ENUM UserEnumPtr,
    IN      PCWSTR NewDomain
    );

VOID
UserMayBeInDomain (
    IN      PACCT_ENUM UserEnumPtr,
    IN      PACCT_ENUM DomainEnumPtr
    );

VOID
ClearPossibleDomains (
    IN      PACCT_ENUM UserEnumPtr
    );

VOID
PrepareForRetry (
    VOID
    );

PCWSTR
ListFirstPossibleDomain (
    IN      PACCT_ENUM UserEnumPtr,
    OUT     PACCT_ENUM PossibleDomainEnumPtr
    );


PCWSTR
ListNextPossibleDomain (
    IN OUT  PACCT_ENUM PossibleDomainEnumPtr
    );

INT
CountPossibleDomains (
    IN OUT  PACCT_ENUM UserEnumPtr
    );

BOOL
BuildDomainList (
    VOID
    );

BOOL
QueryDomainForUser (
    IN      PACCT_ENUM DomainEnumPtr,
    IN      PACCT_ENUM UserEnumPtr
    );

BOOL
GetUserSid (
    IN      PCWSTR User,
    IN      PCWSTR Domain,
    IN OUT  PGROWBUFFER SidBufPtr
    );

BOOL
GetUserType (
    IN      PCWSTR User,
    IN      PCWSTR Domain,
    OUT     SID_NAME_USE *UseType
    );

PCWSTR
GetProfilePathForUser (
    IN      PCWSTR User
    );

VOID
AutoStartProcessing (
    VOID
    );


//
// security.c functions
//

DWORD
AddAclMember (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCTSTR UserOrGroup,
    IN      DWORD Attributes
    );

VOID
GetNextAclMember (
    IN OUT  PACLMEMBER *AclMemberPtrToPtr
    );

PACL
CreateAclFromMemberList (
    IN OUT  PBYTE AclMemberList,
    IN      DWORD MemberCount
    );


VOID
FreeMemberListAcl (
    PACL Acl
    );

LONG
CreateLocalAccount (
    IN     PACCOUNTPROPERTIES Properties,
    IN     PCWSTR User             OPTIONAL
    );

BOOL
AddSidToLocalGroup (
    IN      PSID Sid,
    IN      PCWSTR Group
    );

BOOL
IsMemberOfDomain (
    VOID
    );

LONG
GetAnyDC (
    IN      PCWSTR Domain,
    IN      PWSTR ServerBuf,
    IN      BOOL GetNewServer
    );

VOID
ClearAdminPassword (
    VOID
    );


#define SF_EVERYONE_NONE            0x00000001
#define SF_EVERYONE_READ            0x00000002
#define SF_EVERYONE_WRITE           0x00000004
#define SF_EVERYONE_FULL            0x0000000e
#define SF_EVERYONE_MASK            0x0000000f

#define SF_ADMINISTRATORS_NONE      0x00000010
#define SF_ADMINISTRATORS_READ      0x00000020
#define SF_ADMINISTRATORS_WRITE     0x00000040
#define SF_ADMINISTRATORS_FULL      0x000000e0
#define SF_ADMINISTRATORS_MASK      0x000000f0

DWORD
SetRegKeySecurity (
    IN      PCTSTR KeyStr,
    IN      DWORD DaclFlags,    OPTIONAL        // see SF_* constants above
    IN      PSID Owner,         OPTIONAL
    IN      PSID PrimaryGroup,  OPTIONAL
    IN      BOOL Recursive
    );

//
// FileMig stuff
//

BOOL
DoFileDel (
    VOID
    );

BOOL
DoLinkEdit (
    VOID
    );

DWORD
DoCopyFile (
    DWORD Request
    );

DWORD
DoMoveFile (
    DWORD Request
    );

BOOL
RemoveEmptyDirs (
    VOID
    );

BOOL
ProcessStfFiles (
    VOID
    );

BOOL
UpdateBriefcaseDatabasePaths (
    VOID
    );

//
// iniact.c
//

typedef enum {
    INIACT_WKS_FIRST,
    INIACT_WKS_LAST
} INIACT_CONTEXT;


BOOL
DoIniActions (
    IN      INIACT_CONTEXT Context
    );

//
// inifiles.c
//

BOOL
ProcessIniFileMapping (
    IN      BOOL UserMode
    );


BOOL
MoveIniSettings (
    VOID
    );

BOOL
MergeIniFile (
    IN      PCTSTR FileNtLocation,
    IN      PCTSTR FileTempLocation,
    IN      BOOL TempHasPriority
    );


BOOL
ConvertIniFile (
    IN      PCTSTR IniFilePath
    );

BOOL
ConvertIniFiles (
    VOID
    );

BOOL
MergeIniSettings (
    VOID
    );

BOOL
RestoreMMSettings_System (
    VOID
    );

BOOL
RestoreMMSettings_User (
    IN      PCTSTR UserName,
    IN      HKEY UserRoot
    );

//
// shllink.c
//

BOOL
ModifyShellLink(
        IN      PCWSTR FileName,
        IN      PCWSTR NewTarget,
        IN      PCWSTR NewArgs,
        IN      PCWSTR NewWorkDir,
        IN      PCWSTR NewIconPath,
        IN      INT NewIconNumber,
        IN      BOOL ConvertToLnk,
        IN      PLNK_EXTRA_DATA ExtraData,   OPTIONAL
        IN      BOOL ForceToShowNormal
        );

BOOL
RestoreInfoFromDefaultPif (
    IN      PCTSTR UserName,
    IN      HKEY KeyRoot
    );

BOOL
OurMoveFileExW (
    IN      PCWSTR ExistingFile,
    IN      PCWSTR DestinationFile,
    IN      DWORD Flags
    );

#define OurMoveFileW(exist,dest)    OurMoveFileExW(exist,dest,0)

BOOL
OurMoveFileExA (
    IN      PCSTR ExistingFile,
    IN      PCSTR DestinationFile,
    IN      DWORD Flags
    );

#define OurMoveFileA(exist,dest)    OurMoveFileExA(exist,dest,0)

BOOL
OurCopyFileW (
    IN      PCWSTR ExistingFile,
    IN      PCWSTR DestinationFile
    );

VOID
SetClassicLogonType (
    VOID
    );

#ifdef UNICODE

#define OurMoveFileEx               OurMoveFileExW
#define OurMoveFile                 OurMoveFileW

#else

#define OurMoveFileEx               OurMoveFileExA
#define OurMoveFile                 OurMoveFileA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\mmedia.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    mmedia.c

Abstract:

    Multimedia settings migration functions for Win2000

Author:

    Calin Negreanu (calinn) 02-Dec-1997

Revision History:

    Ovidiu Temereanca (ovidiut) 29-Jan-1999
    Ovidiu Temereanca (ovidiut) 05-Apr-1999  See NT bug 313357 for the story of all #if 0

--*/

#include "pch.h"
#include "mmediap.h"

#include <initguid.h>
#include <dsound.h>
#include <dsprv.h>          // windows\inc


POOLHANDLE g_MmediaPool = NULL;

#define MM_POOLGETMEM(STRUCT,COUNT)  (STRUCT*)PoolMemGetMemory(g_MmediaPool,COUNT*sizeof(STRUCT))


static PCTSTR g_UserData = NULL;
static HKEY g_UserRoot = NULL;


typedef HRESULT (STDAPICALLTYPE *PFNDLLGETCLASSOBJECT)(REFCLSID, REFIID, LPVOID FAR*);


BOOL
pRestoreSystemValue (
    IN      PCTSTR KeyName,
    IN      PCTSTR Field,       OPTIONAL
    IN      PCTSTR StrValue,    OPTIONAL
    OUT     PDWORD NumValue
    )
{
    TCHAR Key[MEMDB_MAX];

    MemDbBuildKey (Key, MEMDB_CATEGORY_MMEDIA_SYSTEM, KeyName, Field, StrValue);
    return MemDbGetValue (Key, NumValue);
}


PVOID
pRestoreSystemBinaryValue (
    IN      PCTSTR KeyName,
    IN      PCTSTR Field,       OPTIONAL
    OUT     PDWORD DataSize
    )
{
    TCHAR Key[MEMDB_MAX];

    MemDbBuildKey (Key, MEMDB_CATEGORY_MMEDIA_SYSTEM, KeyName, Field, NULL);
    return (PVOID)MemDbGetBinaryValue (Key, DataSize);
}


BOOL
pRestoreMMSystemMixerSettings (
    VOID
    )
{
#if 0

    UINT MixerID, MixerMaxID;
    HMIXER mixer;
    MIXERCAPS mixerCaps;
    MIXERLINE mixerLine, mixerLineSource;
    MIXERLINECONTROLS mixerLineControls;
    MIXERCONTROL* pmxControl;
    MIXERCONTROLDETAILS mixerControlDetails;
    LONG rc;
    DWORD Dest, Src, Control;
    TCHAR MixerKey[MAX_PATH], LineKey[MAX_PATH], SrcKey[MAX_PATH], SubKey[MAX_PATH];
    DWORD ValuesCount;
    DWORD Value;
    PVOID SetData;
    BOOL b;

    if (!pRestoreSystemValue (S_MIXERNUMDEVS, NULL, NULL, &MixerMaxID)) {
        return FALSE;
    }

    MixerID = mixerGetNumDevs ();
    if (!MixerID) {
        DEBUGMSG ((DBG_MMEDIA, "pRestoreMMSystemMixerSettings: mixerGetNumDevs returned 0"));
        return FALSE;
    }

    if (MixerMaxID != MixerID) {
        return FALSE;
    }

    for (MixerID = 0; MixerID < MixerMaxID; MixerID++) {

        rc = mixerGetDevCaps (MixerID, &mixerCaps, sizeof (MIXERCAPS));
        if (rc != MMSYSERR_NOERROR) {
            DEBUGMSG ((DBG_MMEDIA, "mixerGetDevCaps failed for mixer %lu [rc=%#X]. No settings will be restored.", MixerID, rc));
            continue;
        }

        wsprintf (MixerKey, S_MIXERID, MixerID);
        if (!pRestoreSystemValue (MixerKey, S_NUMLINES, NULL, &Value)) {
            continue;
        }

        if (mixerCaps.cDestinations > Value) {
            //
            // only try to restore first Value lines
            //
            mixerCaps.cDestinations = Value;
        }

        rc = mixerOpen (&mixer, MixerID, 0L, 0L, MIXER_OBJECTF_MIXER);
        if (rc != MMSYSERR_NOERROR) {
            DEBUGMSG ((DBG_MMEDIA, "mixerOpen failed for mixer %lu [rc=%#X]. No settings will be restored.", MixerID, rc));
            continue;
        }

        for (Dest = 0; Dest < mixerCaps.cDestinations; Dest++) {

            ZeroMemory (&mixerLine, sizeof (MIXERLINE));

            mixerLine.cbStruct = sizeof (MIXERLINE);
            mixerLine.dwDestination = Dest;

            rc = mixerGetLineInfo ((HMIXEROBJ)mixer, &mixerLine, MIXER_GETLINEINFOF_DESTINATION);
            if (rc == MMSYSERR_NOERROR) {

                wsprintf (LineKey, S_LINEID, Dest);

                b = pRestoreSystemValue (MixerKey, LineKey, S_NUMSOURCES, &Value) &&
                    Value == mixerLine.cConnections;

                b = b &&
                    pRestoreSystemValue (MixerKey, LineKey, S_NUMCONTROLS, &Value) &&
                    Value == mixerLine.cControls;

                if (b && mixerLine.cControls > 0) {
                    //
                    // get all control values for the destination
                    //
                    ZeroMemory (&mixerLineControls, sizeof (MIXERLINECONTROLS));

                    mixerLineControls.cbStruct = sizeof (MIXERLINECONTROLS);
                    mixerLineControls.dwLineID = mixerLine.dwLineID;
                    mixerLineControls.cControls = mixerLine.cControls;
                    mixerLineControls.cbmxctrl = sizeof (MIXERCONTROL);
                    mixerLineControls.pamxctrl = MM_POOLGETMEM (MIXERCONTROL, mixerLineControls.cControls);
                    if (mixerLineControls.pamxctrl) {

                        rc = mixerGetLineControls((HMIXEROBJ)mixer, &mixerLineControls, MIXER_GETLINECONTROLSF_ALL);
                        if (rc == MMSYSERR_NOERROR) {

                            for (
                                Control = 0, pmxControl = mixerLineControls.pamxctrl;
                                Control < mixerLineControls.cControls;
                                Control++, pmxControl++
                                ) {

                                ZeroMemory (&mixerControlDetails, sizeof (MIXERCONTROLDETAILS));

                                mixerControlDetails.cbStruct = sizeof (MIXERCONTROLDETAILS);
                                mixerControlDetails.dwControlID = pmxControl->dwControlID;
                                mixerControlDetails.cMultipleItems = pmxControl->cMultipleItems;
                                mixerControlDetails.cChannels = mixerLine.cChannels;
                                if (pmxControl->fdwControl & MIXERCONTROL_CONTROLF_UNIFORM) {
                                    mixerControlDetails.cChannels = 1;
                                }
                                ValuesCount = mixerControlDetails.cChannels;
                                if (pmxControl->fdwControl & MIXERCONTROL_CONTROLF_MULTIPLE) {
                                    ValuesCount *= mixerControlDetails.cMultipleItems;
                                }
                                mixerControlDetails.cbDetails = sizeof (DWORD);
                                wsprintf (SubKey, TEXT("%s\\%lu"), LineKey, Control);
                                SetData = pRestoreSystemBinaryValue (MixerKey, SubKey, &Value);
                                if (SetData &&
                                    Value == ValuesCount * mixerControlDetails.cbDetails
                                    ) {
                                    mixerControlDetails.paDetails = SetData;
                                    rc = mixerSetControlDetails ((HMIXEROBJ)mixer, &mixerControlDetails, MIXER_SETCONTROLDETAILSF_VALUE);
                                    if (rc != MMSYSERR_NOERROR) {
                                        DEBUGMSG ((DBG_MMEDIA, "mixerSetControlDetails failed for mixer %lu, Line=%lu, Ctl=%lu [rc=%#X]", MixerID, Dest, Control, rc));
                                    }
                                }
                            }
                        } else {
                            DEBUGMSG ((DBG_MMEDIA, "mixerGetLineControls failed for mixer %lu, Line=%#X [rc=%#X].", MixerID, mixerLineControls.dwLineID, rc));
                        }
                    }
                }

                //
                // set this information for all source connections
                //
                for (Src = 0; Src < mixerLine.cConnections; Src++) {

                    ZeroMemory (&mixerLineSource, sizeof (MIXERLINE));

                    mixerLineSource.cbStruct = sizeof(MIXERLINE);
                    mixerLineSource.dwDestination = Dest;
                    mixerLineSource.dwSource = Src;

                    rc = mixerGetLineInfo((HMIXEROBJ)mixer, &mixerLineSource, MIXER_GETLINEINFOF_SOURCE);
                    if (rc == MMSYSERR_NOERROR) {

                        wsprintf (SrcKey, S_SRCID, Src);
                        wsprintf (SubKey, TEXT("%s\\%s"), SrcKey, S_NUMCONTROLS);
                        if (!pRestoreSystemValue (MixerKey, LineKey, SubKey, &Value) ||
                            Value != mixerLineSource.cControls ||
                            mixerLineSource.cControls <= 0
                            ) {
                            continue;
                        }

                        //
                        // set all control values
                        //
                        ZeroMemory (&mixerLineControls, sizeof (MIXERLINECONTROLS));

                        mixerLineControls.cbStruct = sizeof (MIXERLINECONTROLS);
                        mixerLineControls.dwLineID = mixerLineSource.dwLineID;
                        mixerLineControls.cControls = mixerLineSource.cControls;
                        mixerLineControls.cbmxctrl = sizeof (MIXERCONTROL);
                        mixerLineControls.pamxctrl = MM_POOLGETMEM (MIXERCONTROL, mixerLineControls.cControls);
                        if (mixerLineControls.pamxctrl) {

                            rc = mixerGetLineControls((HMIXEROBJ)mixer, &mixerLineControls, MIXER_GETLINECONTROLSF_ALL);
                            if (rc == MMSYSERR_NOERROR) {

                                for (
                                    Control = 0, pmxControl = mixerLineControls.pamxctrl;
                                    Control < mixerLineControls.cControls;
                                    Control++, pmxControl++
                                    ) {

                                    ZeroMemory (&mixerControlDetails, sizeof (MIXERCONTROLDETAILS));

                                    mixerControlDetails.cbStruct = sizeof (MIXERCONTROLDETAILS);
                                    mixerControlDetails.dwControlID = pmxControl->dwControlID;
                                    mixerControlDetails.cMultipleItems = pmxControl->cMultipleItems;
                                    mixerControlDetails.cChannels = mixerLineSource.cChannels;
                                    if (pmxControl->fdwControl & MIXERCONTROL_CONTROLF_UNIFORM) {
                                        mixerControlDetails.cChannels = 1;
                                    }
                                    ValuesCount = mixerControlDetails.cChannels;
                                    if (pmxControl->fdwControl & MIXERCONTROL_CONTROLF_MULTIPLE) {
                                        ValuesCount *= mixerControlDetails.cMultipleItems;
                                    }
                                    mixerControlDetails.cbDetails = sizeof (DWORD);
                                    wsprintf (SubKey, TEXT("%s\\%s\\%lu"), LineKey, SrcKey, Control);
                                    SetData = pRestoreSystemBinaryValue (MixerKey, SubKey, &Value);
                                    if (SetData &&
                                        Value == ValuesCount * mixerControlDetails.cbDetails
                                        ) {
                                        mixerControlDetails.paDetails = SetData;
                                        rc = mixerSetControlDetails ((HMIXEROBJ)mixer, &mixerControlDetails, MIXER_SETCONTROLDETAILSF_VALUE);
                                        if (rc != MMSYSERR_NOERROR) {
                                            DEBUGMSG ((DBG_MMEDIA, "mixerSetControlDetails failed for mixer %lu, Line=%lu, Src=%lu, Ctl=%lu [rc=%#X]", MixerID, Dest, Src, Control, rc));
                                        }
                                    }
                                }
                            } else {
                                DEBUGMSG ((DBG_MMEDIA, "mixerGetLineControls failed for mixer %lu, Src=%lu, Line=%#X [rc=%#X].", MixerID, Src, mixerLineControls.dwLineID, rc));
                            }
                        }
                    } else {
                        DEBUGMSG ((DBG_MMEDIA, "mixerGetLineInfo failed for mixer %lu, Src=%lu [rc=%#X].", MixerID, Src, rc));
                    }
                }
            } else {
                DEBUGMSG ((DBG_MMEDIA, "mixerGetLineInfo failed for mixer %lu [rc=%#X]. No settings will be preserved.", MixerID, rc));
            }
        }

        mixerClose (mixer);
    }

#endif

    return TRUE;
}


BOOL
CALLBACK
pDSDeviceCountCallback (
    IN      PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA pDSDescData,
    IN      LPVOID UserData
    )
{
    PDWORD pWaveDeviceCount;

    //
    // don't count emulated devices
    //
    if (pDSDescData->Type == DIRECTSOUNDDEVICE_TYPE_EMULATED) {
        return TRUE;
    }

    pWaveDeviceCount = (PDWORD)UserData;

    if (pDSDescData->DataFlow == DIRECTSOUNDDEVICE_DATAFLOW_RENDER) {

        pWaveDeviceCount[0]++;

    } else if (pDSDescData->DataFlow == DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE) {

        pWaveDeviceCount[1]++;

    }

    return TRUE;
}


BOOL
pGetDSWaveCount (
    IN      LPKSPROPERTYSET pKsPropertySet,
    OUT     PDWORD pWaveDeviceCount
    )
{
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA Data;

    pWaveDeviceCount[0] = pWaveDeviceCount[1] = 0;

    Data.Callback = pDSDeviceCountCallback;
    Data.Context = pWaveDeviceCount;
    if (FAILED (IKsPropertySet_Get (
                    pKsPropertySet,
                    &DSPROPSETID_DirectSoundDevice,
                    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE,
                    NULL,
                    0,
                    &Data,
                    sizeof(Data),
                    NULL
                    ))) {
        return FALSE;
    }

    return TRUE;
}


typedef struct {
    DWORD HWLevel;
    DWORD SRCLevel;
    DWORD SpeakerConfig;
    DWORD SpeakerType;
} DS_DATA, *PDS_DATA;


typedef struct {
    DWORD HWLevel;
    DWORD SRCLevel;
} DSC_DATA, *PDSC_DATA;


BOOL
pRestoreDSValues (
    IN      DWORD DeviceID,
    OUT     PDS_DATA DSData
    )
{
    TCHAR Device[MAX_PATH];

    wsprintf (Device, S_WAVEID, DeviceID);

    if (!pRestoreSystemValue (Device, S_DIRECTSOUND, S_ACCELERATION, &DSData->HWLevel)) {
        return FALSE;
    }
    if (!pRestoreSystemValue (Device, S_DIRECTSOUND, S_SRCQUALITY, &DSData->SRCLevel)) {
        return FALSE;
    }
    if (!pRestoreSystemValue (Device, S_DIRECTSOUND, S_SPEAKERCONFIG, &DSData->SpeakerConfig)) {
        return FALSE;
    }
    if (!pRestoreSystemValue (Device, S_DIRECTSOUND, S_SPEAKERTYPE, &DSData->SpeakerType)) {
        return FALSE;
    }

    return TRUE;
}


BOOL
pRestoreDSCValues (
    IN      DWORD DeviceID,
    OUT     PDSC_DATA DSCData
    )
{
    TCHAR Device[MAX_PATH];

    wsprintf (Device, S_WAVEID, DeviceID);

    if (!pRestoreSystemValue (Device, S_DIRECTSOUNDCAPTURE, S_ACCELERATION, &DSCData->HWLevel)) {
        return FALSE;
    }
    if (!pRestoreSystemValue (Device, S_DIRECTSOUNDCAPTURE, S_SRCQUALITY, &DSCData->SRCLevel)) {
        return FALSE;
    }

    return TRUE;
}


BOOL
pSetDSValues (
    IN      LPKSPROPERTYSET pKsPropertySet,
    IN      REFGUID DeviceGuid,
    IN      const PDS_DATA Data
    )
{
    DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA BasicAcceleration;
    DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA SrcQuality;
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA SpeakerConfig;
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA SpeakerType;
    HRESULT hr;

    BasicAcceleration.DeviceId = *DeviceGuid;
    BasicAcceleration.Level = (DIRECTSOUNDBASICACCELERATION_LEVEL)Data->HWLevel;
    hr = IKsPropertySet_Set (
            pKsPropertySet,
            &DSPROPSETID_DirectSoundBasicAcceleration, 
            DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION, 
            NULL, 
            0, 
            &BasicAcceleration, 
            sizeof(BasicAcceleration)
            );

    if(SUCCEEDED (hr)) {
        SrcQuality.DeviceId = *DeviceGuid;
        SrcQuality.Quality = (DIRECTSOUNDMIXER_SRCQUALITY)Data->SRCLevel;
        hr = IKsPropertySet_Set (
                pKsPropertySet,
                &DSPROPSETID_DirectSoundMixer, 
                DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY, 
                NULL, 
                0, 
                &SrcQuality, 
                sizeof(SrcQuality)
                );
    }

    if(SUCCEEDED (hr)) {
        SpeakerConfig.DeviceId = *DeviceGuid;
        SpeakerConfig.SubKeyName = S_SPEAKERCONFIG;
        SpeakerConfig.ValueName = S_SPEAKERCONFIG;
        SpeakerConfig.RegistryDataType = REG_DWORD;
        SpeakerConfig.Data = &Data->SpeakerConfig;
        SpeakerConfig.DataSize = sizeof(Data->SpeakerConfig);

        hr = IKsPropertySet_Set (
                pKsPropertySet,
                &DSPROPSETID_DirectSoundPersistentData,
                DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA,
                NULL,
                0,
                &SpeakerConfig,
                sizeof(SpeakerConfig)
                );
    }

    if(SUCCEEDED (hr)) {
        SpeakerType.DeviceId = *DeviceGuid;
        SpeakerType.SubKeyName = S_SPEAKERTYPE;
        SpeakerType.ValueName = S_SPEAKERTYPE;
        SpeakerType.RegistryDataType = REG_DWORD;
        SpeakerType.Data = &Data->SpeakerType;
        SpeakerType.DataSize = sizeof(Data->SpeakerType);

        hr = IKsPropertySet_Set (
                pKsPropertySet,
                &DSPROPSETID_DirectSoundPersistentData,
                DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA,
                NULL,
                0,
                &SpeakerType,
                sizeof(SpeakerType)
                );
    }

    return SUCCEEDED (hr);
}


BOOL
pSetDSCValues (
    IN      LPKSPROPERTYSET pKsPropertySet,
    IN      REFGUID DeviceGuid,
    IN      const PDSC_DATA Data
    )
{
    DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA BasicAcceleration;
    DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA SrcQuality;
    HRESULT hr;

    BasicAcceleration.DeviceId = *DeviceGuid;
    BasicAcceleration.Level = (DIRECTSOUNDBASICACCELERATION_LEVEL)Data->HWLevel;
    hr = IKsPropertySet_Set (
            pKsPropertySet,
            &DSPROPSETID_DirectSoundBasicAcceleration, 
            DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION, 
            NULL, 
            0, 
            &BasicAcceleration, 
            sizeof(BasicAcceleration)
            );

    if(SUCCEEDED (hr)) {
        SrcQuality.DeviceId = *DeviceGuid;
        SrcQuality.Quality = (DIRECTSOUNDMIXER_SRCQUALITY)Data->SRCLevel;
        hr = IKsPropertySet_Set (
                pKsPropertySet,
                &DSPROPSETID_DirectSoundMixer, 
                DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY, 
                NULL, 
                0, 
                &SrcQuality, 
                sizeof(SrcQuality)
                );
    }

    return SUCCEEDED (hr);
}


BOOL
CALLBACK
pRestoreDeviceSettings (
    IN      PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA pDSDescData,
    IN      LPVOID UserData
    )
{
    LPKSPROPERTYSET pKsPropertySet = (LPKSPROPERTYSET)UserData;
    DS_DATA DSData;
    DSC_DATA DSCData;

    if (pDSDescData->DataFlow == DIRECTSOUNDDEVICE_DATAFLOW_RENDER) {

        if (pRestoreDSValues (pDSDescData->WaveDeviceId, &DSData)) {

            pSetDSValues (
                pKsPropertySet,
                &pDSDescData->DeviceId,
                &DSData
                );
        }

    } else if (pDSDescData->DataFlow == DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE) {

        if (pRestoreDSCValues (pDSDescData->WaveDeviceId, &DSCData)) {

            pSetDSCValues (
                pKsPropertySet,
                &pDSDescData->DeviceId,
                &DSCData
                );
        }

    }

    return TRUE;
}


BOOL
pRestoreWaveDevicesDSSettings (
    IN      LPKSPROPERTYSET pKsPropertySet
    )
{
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA Data;
    HRESULT hr;
    DWORD WaveNumDevs;
    //
    // array of 2 longs; first counts wave-out devices, second wave-ins
    //
    DWORD WaveDeviceCount[2];

    if (!pGetDSWaveCount (pKsPropertySet, WaveDeviceCount)) {
        return FALSE;
    }

    if (!pRestoreSystemValue (S_WAVENUMDEVS, NULL, NULL, &WaveNumDevs)) {
        return FALSE;
    }

    if (WaveDeviceCount[0] != WaveNumDevs || WaveDeviceCount[1] != WaveNumDevs) {
        DEBUGMSG ((DBG_MMEDIA, "pRestoreWaveDevicesDSSettings: number of wave devices changed, no settings will be restored"));
        return FALSE;
    }

    Data.Callback = pRestoreDeviceSettings;
    Data.Context = pKsPropertySet;
    hr = IKsPropertySet_Get (
                    pKsPropertySet,
                    &DSPROPSETID_DirectSoundDevice,
                    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE,
                    NULL,
                    0,
                    &Data,
                    sizeof(Data),
                    NULL
                    );

    return SUCCEEDED (hr);
}


BOOL
pDirectSoundPrivateCreate (
    IN      HINSTANCE LibDsound,
    OUT     LPKSPROPERTYSET* ppKsPropertySet
    )
{
    PFNDLLGETCLASSOBJECT pfnDllGetClassObject = NULL;
    LPCLASSFACTORY pClassFactory = NULL;
    LPKSPROPERTYSET pKsPropertySet = NULL;
    HRESULT hr = DS_OK;

    pfnDllGetClassObject = (PFNDLLGETCLASSOBJECT)GetProcAddress (
                                LibDsound, 
                                "DllGetClassObject"
                                );
    if(!pfnDllGetClassObject) {
        hr = DSERR_GENERIC;
    }

    if(SUCCEEDED(hr)) {
        hr = pfnDllGetClassObject (
                &CLSID_DirectSoundPrivate, 
                &IID_IClassFactory, 
                (LPVOID*)&pClassFactory
                );
    }

    //
    // Create the DirectSoundPrivate object and query for an IKsPropertySet interface
    //
    if(SUCCEEDED(hr)) {
        hr = pClassFactory->lpVtbl->CreateInstance (
                                        pClassFactory,
                                        NULL,
                                        &IID_IKsPropertySet,
                                        (LPVOID*)&pKsPropertySet
                                        );
    }

    // Release the class factory
    if(pClassFactory) {
        pClassFactory->lpVtbl->Release (pClassFactory);
    }

    // Handle final success or failure
    if(SUCCEEDED(hr)) {
        *ppKsPropertySet = pKsPropertySet;
    }
    else if(pKsPropertySet) {
        IKsPropertySet_Release (pKsPropertySet);
    }

    return SUCCEEDED (hr);
}


BOOL
pRestoreMMSystemDirectSound (
    VOID
    )
{
#if 0

    HINSTANCE LibDsound = NULL;
    LPKSPROPERTYSET pKsPropertySet;
    BOOL b = FALSE;

    LibDsound = LoadLibrary (S_DSOUNDLIB);
    if(LibDsound) {

        if (pDirectSoundPrivateCreate (LibDsound, &pKsPropertySet)) {

            b = pRestoreWaveDevicesDSSettings (pKsPropertySet);

            IKsPropertySet_Release (pKsPropertySet);
        }

        FreeLibrary (LibDsound);
    }

    return b;

#endif

    return TRUE;
}


BOOL
pRestoreMMSystemCDSettings (
    VOID
    )
{
    DWORD Unit, Volume;
    HKEY key, keyUnit;
    BYTE defDrive[4] = {0,0,0,0};
    BYTE defVolume[8] = {0,0,0,0,0,0,0,0};
    TCHAR unitKeyStr [MAX_TCHAR_PATH];
    LONG rc;
    BOOL b = FALSE;

    if (pRestoreSystemValue (S_CDROM, S_DEFAULTDRIVE, NULL, &Unit)) {

        defDrive [0] = (BYTE)Unit;

        key = CreateRegKey (HKEY_LOCAL_MACHINE, S_SKEY_CDAUDIO);
        if (key) {

            rc = RegSetValueEx (key, S_DEFAULTDRIVE, 0, REG_BINARY, defDrive, sizeof(defDrive));
            if (rc == ERROR_SUCCESS) {

                if (pRestoreSystemValue (S_CDROM, S_VOLUMESETTINGS, NULL, &Volume)) {

                    wsprintf (unitKeyStr, S_SKEY_CDUNIT, Unit);

                    keyUnit = CreateRegKey (HKEY_LOCAL_MACHINE, unitKeyStr);
                    if (keyUnit) {

                        defVolume [4] = (BYTE)Volume;

                        rc = RegSetValueEx (
                                keyUnit,
                                S_VOLUMESETTINGS,
                                0,
                                REG_BINARY,
                                defVolume,
                                sizeof(defVolume)
                                );

                        b = (rc == ERROR_SUCCESS);

                        CloseRegKey (keyUnit);
                    }
                }
            }
            CloseRegKey (key);
        }
    }

    return b;
}


BOOL
pRestoreMMSystemMCISoundSettings (
    VOID
    )
{
    TCHAR DriverName[MAX_PATH], Param[2];
    DWORD Size, Value;
    HKEY KeyMCI32;
    BOOL b = FALSE;
    LONG rc;

    rc = TrackedRegOpenKeyEx (HKEY_LOCAL_MACHINE, S_SKEY_WINNT_MCI, 0, KEY_READ, &KeyMCI32);
    if (rc == ERROR_SUCCESS) {

        Size = sizeof (DriverName);
        rc = RegQueryValueEx (KeyMCI32, S_WAVEAUDIO, NULL, NULL, (LPBYTE)DriverName, &Size);
        if (rc == ERROR_SUCCESS) {

            if (pRestoreSystemValue (S_MCI, S_WAVEAUDIO, NULL, &Value)) {
                if (Value >= 2 && Value <= 9) {

                    wsprintf (Param, TEXT("%lu"), Value);
                    if (WriteProfileString (DriverName, S_WAVEAUDIO, Param)) {
                        b = TRUE;
                    }
                }
            }
        }

        CloseRegKey (KeyMCI32);
    }

    return b;
}


BOOL
pRestoreUserValue (
    IN      PCTSTR KeyName,
    IN      PCTSTR Field,       OPTIONAL
    IN      PCTSTR StrValue,    OPTIONAL
    OUT     PDWORD NumValue
    )

/*++

Routine Description:

  pRestoreUserValue gets a numeric value from MemDB database,
  specific for the current user.

Arguments:

  KeyName - Specifies the name of key

  Field - Specifies an optional field

  StrValue - Specifies an optional value name

  NumValue - Receives the value, if present

Return Value:

  TRUE if value was present and read successfully, FALSE if not

--*/

{
    TCHAR Key[MEMDB_MAX];

    MemDbBuildKey (Key, g_UserData, KeyName, Field, StrValue);
    return MemDbGetValue (Key, NumValue);
}


BOOL
pRestoreMMUserPreferredOnly (
    VOID
    )

/*++

Routine Description:

  pRestoreMMUserPreferredOnly restores user's preference to use only
  selected devices for playback and record

Arguments:

  none

Return Value:

  TRUE if settings were restored properly

--*/

{
    HKEY soundMapperKey;
    DWORD preferredOnly;
    LONG rc;
    BOOL b = FALSE;

    if (pRestoreUserValue (S_AUDIO, S_PREFERREDONLY, NULL, &preferredOnly)) {

        soundMapperKey = CreateRegKey (g_UserRoot, S_SKEY_SOUNDMAPPER);
        if (soundMapperKey != NULL) {

            rc = RegSetValueEx (
                    soundMapperKey,
                    S_PREFERREDONLY,
                    0,
                    REG_DWORD,
                    (PCBYTE)&preferredOnly,
                    sizeof (preferredOnly)
                    );

            b = (rc == ERROR_SUCCESS);

            CloseRegKey (soundMapperKey);
        }
    }

    return b;
}


BOOL
pRestoreMMUserShowVolume (
    VOID
    )

/*++

Routine Description:

  pRestoreMMUserShowVolume restores user's preference to have Volume settings
  displayed on the taskbar or not

Arguments:

  none

Return Value:

  TRUE if settings were restored properly

--*/

{
    HKEY sysTrayKey;
    DWORD ShowVolume;
    PDWORD Services;
    LONG rc;
    BOOL b = FALSE;

    if (pRestoreUserValue (S_AUDIO, S_SHOWVOLUME, NULL, &ShowVolume)) {

        sysTrayKey = CreateRegKey (g_UserRoot, S_SKEY_SYSTRAY);
        if (sysTrayKey != NULL) {

            Services = GetRegValueDword (sysTrayKey, S_SERVICES);
            if (Services != NULL) {

                if (ShowVolume) {
                    *Services |= SERVICE_SHOWVOLUME;
                } else {
                    *Services &= ~SERVICE_SHOWVOLUME;
                }

                rc = RegSetValueEx (
                        sysTrayKey,
                        S_SERVICES,
                        0,
                        REG_DWORD,
                        (PCBYTE)Services,
                        sizeof (*Services)
                        );

                b = (rc == ERROR_SUCCESS);

                MemFreeWrapper (Services);
            }

            CloseRegKey (sysTrayKey);
        }
    }

    return b;
}


BOOL
pRestoreMMUserVideoSettings (
    VOID
    )

/*++

Routine Description:

  pRestoreMMUserVideoSettings restores user's preferred Video for Windows settings.

Arguments:

  none

Return Value:

  TRUE if settings were restored properly

--*/

{
    HKEY videoSetKey;
    DWORD VideoSettings;
    LONG rc;
    BOOL b = FALSE;

    if (pRestoreUserValue (S_VIDEO, S_VIDEOSETTINGS, NULL, &VideoSettings)) {

        videoSetKey = CreateRegKey (g_UserRoot, S_SKEY_VIDEOUSER);
        if (videoSetKey != NULL) {

            rc = RegSetValueEx (
                    videoSetKey,
                    S_DEFAULTOPTIONS,
                    0,
                    REG_DWORD,
                    (PCBYTE)&VideoSettings,
                    sizeof (VideoSettings)
                    );

            b = (rc == ERROR_SUCCESS);

            CloseRegKey (videoSetKey);
        }
    }

    return b;
}


BOOL
pRestoreMMUserPreferredPlayback (
    VOID
    )

/*++

Routine Description:

  pRestoreMMUserPreferredPlayback restores user's preferred playback device.
  If the system doesn't have at least 2 wave out devices, nothing is changed.
  If there are multiple devices, selection is based on the device ID number,
  which is supposed to be left unchanged.

Arguments:

  none

Return Value:

  TRUE if settings were restored properly

--*/

{
#if 0

    HKEY soundMapperKey;
    UINT waveOutNumDevs;
    DWORD UserPlayback, Value;
    WAVEOUTCAPS waveOutCaps;
    LONG rc;

    BOOL b = FALSE;

    waveOutNumDevs = waveOutGetNumDevs();
    if (!waveOutNumDevs) {
        DEBUGMSG ((DBG_MMEDIA, "pRestoreMMUserPreferredPlayback: waveOutGetNumDevs returned 0"));
        return FALSE;
    }

    if (waveOutNumDevs <= 1) {
        return TRUE;
    }

    if (!pRestoreSystemValue (S_WAVEOUTNUMDEVS, NULL, NULL, &Value) ||
        Value != (DWORD)waveOutNumDevs) {
        return FALSE;
    }

    if (pRestoreUserValue (S_AUDIO, S_PREFERREDPLAY, NULL, &UserPlayback)) {

        rc = waveOutGetDevCaps (UserPlayback, &waveOutCaps, sizeof (waveOutCaps));
        if (rc == MMSYSERR_NOERROR) {

            soundMapperKey = CreateRegKey (g_UserRoot, S_SKEY_SOUNDMAPPER);
            if (soundMapperKey != NULL) {

                rc = RegSetValueEx (
                        soundMapperKey,
                        S_PLAYBACK,
                        0,
                        REG_SZ,
                        (PCBYTE)waveOutCaps.szPname,
                        SizeOfString (waveOutCaps.szPname)
                        );

                b = (rc == ERROR_SUCCESS);

                CloseRegKey (soundMapperKey);
            }
        }
    }

    return b;

#endif

    return TRUE;
}


BOOL
pRestoreMMUserPreferredRecord (
    VOID
    )

/*++

Routine Description:

  pRestoreMMUserPreferredRecord restores user's preferred record device.
  If the system doesn't have at least 2 wave in devices, nothing is changed.
  If there are multiple devices, selection is based on the device ID number,
  which is supposed to be left unchanged.

Arguments:

  none

Return Value:

  TRUE if settings were restored properly

--*/

{
#if 0

    HKEY soundMapperKey;
    UINT waveInNumDevs;
    DWORD UserRecord, Value;
    WAVEINCAPS waveInCaps;
    LONG rc;
    BOOL b = FALSE;

    waveInNumDevs = waveInGetNumDevs();
    if (!waveInNumDevs) {
        DEBUGMSG ((DBG_MMEDIA, "pRestoreMMUserPreferredRecord: waveInGetNumDevs returned 0"));
        return FALSE;
    }

    if (waveInNumDevs <= 1) {
        return TRUE;
    }

    if (!pRestoreSystemValue (S_WAVEINNUMDEVS, NULL, NULL, &Value) ||
        Value != (DWORD)waveInNumDevs) {
        return FALSE;
    }

    if (pRestoreUserValue (S_AUDIO, S_PREFERREDREC, NULL, &UserRecord)) {

        rc = waveInGetDevCaps (UserRecord, &waveInCaps, sizeof (waveInCaps));
        if (rc == MMSYSERR_NOERROR) {

            soundMapperKey = CreateRegKey (g_UserRoot, S_SKEY_SOUNDMAPPER);
            if (soundMapperKey != NULL) {

                rc = RegSetValueEx (
                        soundMapperKey,
                        S_RECORD,
                        0,
                        REG_SZ,
                        (PCBYTE)waveInCaps.szPname,
                        SizeOfString (waveInCaps.szPname)
                        );

                b = (rc == ERROR_SUCCESS);

                CloseRegKey (soundMapperKey);
            }
        }
    }

    return b;

#endif

    return TRUE;
}


BOOL
pRestoreMMUserSndVol32 (
    VOID
    )

/*++

Routine Description:

  pRestoreMMUserSndVol32 restores SndVol32 options for the current user

Arguments:

  none

Return Value:

  TRUE if settings were restored properly

--*/

{
    HKEY Options;
    PDWORD Style;
    DWORD NewStyle;
    BOOL ShowAdvanced;

#if 0

    HKEY VolControl, MixerKey;
    DWORD Value;
    UINT MixerID, MixerMaxID;
    MIXERCAPS mixerCaps;
    TCHAR MixerNum[MAX_PATH];
    LONG rc;

#endif

    if (pRestoreUserValue (S_SNDVOL32, S_SHOWADVANCED, NULL, &ShowAdvanced)) {

        Options = CreateRegKey (g_UserRoot, S_SKEY_VOLCTL_OPTIONS);
        if (Options != NULL) {

            Style = GetRegValueDword (Options, S_STYLE);
            if (Style != NULL) {
                NewStyle = *Style;
                MemFreeWrapper (Style);
            } else {
                NewStyle = 0;
            }

            if (ShowAdvanced) {
                NewStyle |= STYLE_SHOWADVANCED;
            } else {
                NewStyle &= ~STYLE_SHOWADVANCED;
            }

            RegSetValueEx (
                    Options,
                    S_STYLE,
                    0,
                    REG_DWORD,
                    (PCBYTE)&NewStyle,
                    sizeof (NewStyle)
                    );

            CloseRegKey (Options);
        }
    }

#if 0

    //
    // restore window position for each mixer device
    //
    if (!pRestoreSystemValue (S_MIXERNUMDEVS, NULL, NULL, &MixerMaxID)) {
        return FALSE;
    }

    MixerID = mixerGetNumDevs ();
    if (!MixerID) {
        DEBUGMSG ((DBG_MMEDIA, "pRestoreMMUserSndVol32: mixerGetNumDevs returned 0"));
        return FALSE;
    }

    if (MixerMaxID != MixerID) {
        return FALSE;
    }

    VolControl = CreateRegKey (g_UserRoot, S_SKEY_VOLUMECONTROL);
    if (VolControl != NULL) {

        for (MixerID = 0; MixerID < MixerMaxID; MixerID++) {

            rc = mixerGetDevCaps (MixerID, &mixerCaps, sizeof (MIXERCAPS));
            if (rc == MMSYSERR_NOERROR) {

                wsprintf (MixerNum, S_MIXERID, MixerID);

                MixerKey = CreateRegKey (VolControl, mixerCaps.szPname);
                if (MixerKey) {

                    if (pRestoreUserValue (S_SNDVOL32, MixerNum, S_X, &Value)) {
                        RegSetValueEx (
                                MixerKey,
                                S_X,
                                0,
                                REG_DWORD,
                                (PCBYTE)&Value,
                                sizeof (Value)
                                );
                    }
                    if (pRestoreUserValue (S_SNDVOL32, MixerNum, S_Y, &Value)) {
                        RegSetValueEx (
                                MixerKey,
                                S_Y,
                                0,
                                REG_DWORD,
                                (PCBYTE)&Value,
                                sizeof (Value)
                                );
                    }

                    CloseRegKey (MixerKey);
                }
            }
        }

        CloseRegKey (VolControl);
    }

#endif

    return TRUE;
}


BOOL
pPreserveCurrentSoundScheme (
    VOID
    )
{
    HKEY Sounds;
    LONG rc = E_FAIL;

    //
    // if WinMM finds HKCU\Control Panel\Sounds [SystemDefault] = ","
    // it doesn't override user's current sound scheme
    //
    Sounds = CreateRegKey (g_UserRoot, S_SKEY_CPANEL_SOUNDS);
    if (Sounds != NULL) {

        rc = RegSetValueEx (
                Sounds,
                S_SYSTEMDEFAULT,
                0,
                REG_SZ,
                (PCBYTE)S_DUMMYVALUE,
                SizeOfString (S_DUMMYVALUE)
                );

        CloseRegKey (Sounds);
    }

    return rc == ERROR_SUCCESS;
}


#define DEFMAC(Item)         pRestore##Item,

static MM_SETTING_ACTION g_MMRestoreSystemSettings [] = {
    MM_SYSTEM_SETTINGS
};

static MM_SETTING_ACTION g_MMRestoreUserSettings [] = {
    MM_USER_SETTINGS
};

#undef DEFMAC


BOOL
RestoreMMSettings_System (
    VOID
    )
{
    int i;

    g_MmediaPool = PoolMemInitNamedPool ("MMediaNT");
    if (!g_MmediaPool) {
        return FALSE;
    }

    for (i = 0; i < sizeof (g_MMRestoreSystemSettings) / sizeof (MM_SETTING_ACTION); i++) {
        (* g_MMRestoreSystemSettings[i]) ();
    }

    PoolMemDestroyPool (g_MmediaPool);
    g_MmediaPool = NULL;

    return TRUE;
}


BOOL
RestoreMMSettings_User (
    IN      PCTSTR UserName,
    IN      HKEY UserRoot
    )
{
    INT i;

    if (!UserName || UserName[0] == 0) {
        return TRUE;
    }

    MYASSERT (g_UserData == NULL);
    g_UserData = JoinPaths (MEMDB_CATEGORY_MMEDIA_USERS, UserName);
    g_UserRoot = UserRoot;

    __try {
        for (i = 0; i < sizeof (g_MMRestoreUserSettings) / sizeof (MM_SETTING_ACTION); i++) {
            (* g_MMRestoreUserSettings[i]) ();
        }

        //
        // special action to prevent WinMM overriding current sound scheme
        //
        pPreserveCurrentSoundScheme ();
    }
    __finally {
        FreePathString (g_UserData);
        g_UserData = NULL;
        g_UserRoot = NULL;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\security.h ===
#pragma warning (disable:4121)
#include "ntsecapi.h"

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS                  ((NTSTATUS)0x00000000L)
#define STATUS_MORE_ENTRIES             ((NTSTATUS)0x00000105L)
#define STATUS_NO_MORE_ENTRIES          ((NTSTATUS)0x8000001AL)
#endif
#define POLICY_PRIMARY_DOMAIN_INFORMATION PolicyPrimaryDomainInformation

VOID
InitLsaString (
    OUT     PLSA_UNICODE_STRING LsaString,
    IN      PWSTR String
    );

NTSTATUS
OpenPolicy (
    IN      PWSTR ServerName,
    IN      DWORD DesiredAccess,
    OUT     PLSA_HANDLE PolicyHandle
    );


BOOL
GetPrimaryDomainName (
    OUT     PTSTR DomainName
    );

BOOL
GetPrimaryDomainSid (
    OUT     PBYTE DomainSid,
    IN      UINT BufferSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\rasnt.c ===
/*++

Copyright (c) 1997-2001 Microsoft Corporation

Module Name:

    rasnt.c

Abstract:

    rasnt.c builds phonebook files for all of the users on win9x that had
    Dial-Up networking connections.

Author:

    Marc R. Whitten (marcw) 23-Nov-1997

Revision History:

    Marc R. Whitten marcw 23-Jul-1998 - Major cleanup.
    Jeff Sigman           09-Apr-2001 - Whistler cleanup.

      Whistler bugs:
        34270  Win9x: Upgrade: Require Data Encryption setting for VPN
               connections is not migrated
        125693 UpgLab9x: DUN Connectoids don't migrate selected modem properly
               from Win9x
        208318 Win9x Upg: Username and Password for DUN connectoid not migrated
               from Win9x to Whistler

--*/

#include "pch.h"    // Pre-compiled
#include "pcache.h" // Private pcache header
#include <rascmn.h> // RAS migration constants
#include <sddl.h>   // ConvertSidToStringSid

#define MAX_SPEED_DIAL  8
#define MAX_SID_SIZE    1024
#define RAS_BUFFER_SIZE MEMDB_MAX
//
// For each entry, the following basic information is stored.
//
#define ENTRY_SETTINGS                              \
    FUNSETTING(Type)                                \
    STRSETTING(AutoLogon,S_ZERO)                    \
    STRSETTING(UseRasCredentials,S_ONE)             \
    FUNSETTING(DialParamsUID)                       \
    STRSETTING(Guid,S_EMPTY)                        \
    FUNSETTING(BaseProtocol)                        \
    FUNSETTING(VpnStrategy)                         \
    FUNSETTING(ExcludedProtocols)                   \
    STRSETTING(LcpExtensions,S_ONE)                 \
    FUNSETTING(DataEncryption)                      \
    FUNSETTING(SwCompression)                       \
    STRSETTING(NegotiateMultilinkAlways,S_ONE)      \
    STRSETTING(SkipNwcWarning,S_ZERO)               \
    STRSETTING(SkipDownLevelDialog,S_ZERO)          \
    STRSETTING(SkipDoubleDialDialog,S_ZERO)         \
    STRSETTING(DialMode,DEF_DialMode)               \
    STRSETTING(DialPercent,DEF_DialPercent)         \
    STRSETTING(DialSeconds,DEF_DialSeconds)         \
    STRSETTING(HangUpPercent,DEF_HangUpPercent)     \
    STRSETTING(HangUpSeconds,DEF_HangUpSeconds)     \
    STRSETTING(OverridePref,DEF_OverridePref)       \
    FUNSETTING(RedialAttempts)                      \
    FUNSETTING(RedialSeconds)                       \
    FUNSETTING(IdleDisconnectSeconds)               \
    STRSETTING(RedialOnLinkFailure,S_ZERO)          \
    STRSETTING(CallbackMode,S_ZERO)                 \
    STRSETTING(CustomDialDll,S_EMPTY)               \
    STRSETTING(CustomDialFunc,S_EMPTY)              \
    STRSETTING(CustomRasDialDll,S_EMPTY)            \
    STRSETTING(AuthenticateServer,S_ZERO)           \
    FUNSETTING(ShareMsFilePrint)                    \
    STRSETTING(BindMsNetClient,S_ONE)               \
    FUNSETTING(SharedPhoneNumbers)                  \
    STRSETTING(GlobalDeviceSettings,S_ZERO)         \
    STRSETTING(PrerequisiteEntry,S_EMPTY)           \
    STRSETTING(PrerequisitePbk,S_EMPTY)             \
    STRSETTING(PreferredPort,S_EMPTY)               \
    STRSETTING(PreferredDevice,S_EMPTY)             \
    FUNSETTING(PreviewUserPw)                       \
    FUNSETTING(PreviewDomain)                       \
    FUNSETTING(PreviewPhoneNumber)                  \
    STRSETTING(ShowDialingProgress,S_ONE)           \
    FUNSETTING(ShowMonitorIconInTaskBar)            \
    STRSETTING(CustomAuthKey,DEF_CustomAuthKey)     \
    FUNSETTING(AuthRestrictions)                    \
    FUNSETTING(TypicalAuth)                         \
    FUNSETTING(IpPrioritizeRemote)                  \
    FUNSETTING(IpHeaderCompression)                 \
    FUNSETTING(IpAddress)                           \
    FUNSETTING(IpDnsAddress)                        \
    FUNSETTING(IpDns2Address)                       \
    FUNSETTING(IpWinsAddress)                       \
    FUNSETTING(IpWins2Address)                      \
    FUNSETTING(IpAssign)                            \
    FUNSETTING(IpNameAssign)                        \
    STRSETTING(IpFrameSize,DEF_IpFrameSize)         \
    STRSETTING(IpDnsFlags,S_ZERO)                   \
    STRSETTING(IpNBTFlags,S_ONE)                    \
    STRSETTING(TcpWindowSize,S_ZERO)                \
    STRSETTING(UseFlags,S_ZERO)                     \
    STRSETTING(IpSecFlags,S_ZERO)                   \
    STRSETTING(IpDnsSuffix,S_EMPTY)                 \

#define NETCOMPONENT_SETTINGS                       \
    STRSETTING(NETCOMPONENTS,S_EMPTY)               \
    FUNSETTING(ms_server)                           \
    STRSETTING(ms_msclient,S_ONE)                   \

#define MEDIA_SETTINGS                              \
    FUNSETTING(MEDIA)                               \
    FUNSETTING(Port)                                \
    FUNSETTING(Device)                              \
    FUNSETTING(ConnectBPS)                          \

#define GENERAL_DEVICE_SETTINGS                     \
    FUNSETTING(DEVICE)                              \
    FUNSETTING(PhoneNumber)                         \
    FUNSETTING(AreaCode)                            \
    FUNSETTING(CountryCode)                         \
    FUNSETTING(CountryID)                           \
    FUNSETTING(UseDialingRules)                     \
    STRSETTING(Comment,S_EMPTY)                     \
    STRSETTING(LastSelectedPhone,S_ZERO)            \
    STRSETTING(PromoteAlternates,S_ZERO)            \
    STRSETTING(TryNextAlternateOnFail,S_ONE)        \

#define MODEM_DEVICE_SETTINGS                       \
    FUNSETTING(HwFlowControl)                       \
    FUNSETTING(Protocol)                            \
    FUNSETTING(Compression)                         \
    FUNSETTING(Speaker)                             \
    STRSETTING(MdmProtocol,S_ZERO)                  \

#define ISDN_DEVICE_SETTINGS                        \
    STRSETTING(LineType,S_ZERO)                     \
    STRSETTING(Fallback,S_ONE)                      \
    STRSETTING(EnableCompression,S_ONE)             \
    STRSETTING(ChannelAggregation,S_ONE)            \
    STRSETTING(Proprietary,S_ZERO)                  \

#define SWITCH_DEVICE_SETTINGS                      \
    FUNSETTING(DEVICE)                              \
    FUNSETTING(Name)                                \
    FUNSETTING(Terminal)                            \
    FUNSETTING(Script)                              \

//
// Function prototypes.
//
typedef PCTSTR (DATA_FUNCTION_PROTOTYPE)(VOID);
typedef DATA_FUNCTION_PROTOTYPE * DATA_FUNCTION;

#define FUNSETTING(Data) DATA_FUNCTION_PROTOTYPE pGet##Data;
#define STRSETTING(x,y)

ENTRY_SETTINGS
NETCOMPONENT_SETTINGS
MEDIA_SETTINGS
GENERAL_DEVICE_SETTINGS
SWITCH_DEVICE_SETTINGS
MODEM_DEVICE_SETTINGS
ISDN_DEVICE_SETTINGS

#undef FUNSETTING
#undef STRSETTING

//
// Variable declerations.
//
typedef struct {

    PCTSTR SettingName;
    DATA_FUNCTION SettingFunction;
    PCTSTR SettingValue;

} RAS_SETTING, * PRAS_SETTING;

typedef struct {

    PCTSTR Name;
    PCTSTR Number;

} SPEEDDIAL,*PSPEEDDIAL;

typedef struct {

    PCTSTR String;
    UINT   Value;
    WORD   DataType;

} MEMDB_RAS_DATA, *PMEMDB_RAS_DATA;

#define FUNSETTING(x) {TEXT(#x), pGet##x, NULL},
#define STRSETTING(x,y) {TEXT(#x), NULL, y},
#define LASTSETTING {NULL,NULL,NULL}

RAS_SETTING g_EntrySettings[]        = {ENTRY_SETTINGS LASTSETTING};
RAS_SETTING g_NetCompSettings[]      = {NETCOMPONENT_SETTINGS LASTSETTING};
RAS_SETTING g_MediaSettings[]        = {MEDIA_SETTINGS LASTSETTING};
RAS_SETTING g_GeneralSettings[]      = {GENERAL_DEVICE_SETTINGS LASTSETTING};
RAS_SETTING g_SwitchDeviceSettings[] = {SWITCH_DEVICE_SETTINGS LASTSETTING};
RAS_SETTING g_ModemDeviceSettings[]  = {MODEM_DEVICE_SETTINGS LASTSETTING};
RAS_SETTING g_IsdnDeviceSettings[]   = {ISDN_DEVICE_SETTINGS LASTSETTING};

DEFINE_GUID(GUID_DEVCLASS_MODEM,
 0x4d36e96dL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );

BOOL       g_SpeedDialSettingsExist = FALSE;
BOOL       g_InSwitchSection = FALSE;
BOOL       g_RasmansInit = FALSE;
UINT       g_CurrentDevice = 0;
UINT       g_CurrentDeviceType = 0;
HKEY       g_UserRootKey = NULL;
DWORD      g_dwDialParamsUID = 0;
DWORD      g_dwDialUIDOffset = 0;
TCHAR      g_TempBuffer[RAS_BUFFER_SIZE];
LPTSTR     g_ptszSid = NULL;
PCTSTR     g_CurrentConnection;
PCTSTR     g_CurrentUser;
SPEEDDIAL  g_Settings[MAX_SPEED_DIAL];
HINSTANCE  g_RasmansLib = NULL;
POOLHANDLE g_RasPool;

VOID
pInitLibs (
    VOID
    )
{
    do {

        g_RasmansLib = LoadLibrary (S_RASMANSLIB);
        if (!g_RasmansLib) {

            DEBUGMSG((S_DBG_RAS,"Could not load library %s. Passwords will not be migrated.",
                      S_RASMANSLIB));
            break;
        }

        (FARPROC) g_SetEntryDialParams = GetProcAddress (
                                            g_RasmansLib,
                                            S_SETENTRYDIALPARAMS);

        if (!g_SetEntryDialParams) {

            DEBUGMSG((S_DBG_RAS,"Could not load Procedure %s. Passwords will not be migrated.",
                      S_SETENTRYDIALPARAMS));
            break;
        }

        g_RasmansInit = TRUE;

    } while ( FALSE );

    return;
}

VOID
pCleanUpLibs (
    VOID
    )
{
    if (g_RasmansLib) {
        FreeLibrary(g_RasmansLib);
    }

    return;
}

BOOL
GetRasUserSid (
    IN PCTSTR User
    )
{
    PSID   pSid = NULL;
    BOOL   bReturn = FALSE;
    TCHAR  DontCareStr[MAX_SERVER_NAME];
    DWORD  DontCareSize = sizeof (DontCareStr);
    DWORD  SizeOfSidBuf = 0;
    SID_NAME_USE SidNameUse;

    do
    {
        if (LookupAccountName (
                    NULL,
                    User,
                    pSid,
                    &SizeOfSidBuf,
                    DontCareStr,
                    &DontCareSize,
                    &SidNameUse) || !SizeOfSidBuf)
        {
            break;
        }

        pSid = LocalAlloc (LMEM_ZEROINIT, SizeOfSidBuf);
        if (!pSid) {break;}

        if (!LookupAccountName (
                    NULL,
                    User,
                    pSid,
                    &SizeOfSidBuf,
                    DontCareStr,
                    &DontCareSize,
                    &SidNameUse) || (SidNameUse != SidTypeUser))
        {
            DEBUGMSG ((S_DBG_RAS, "LookupAccountName failed: %d",
                       GetLastError()));
            break;
        }

        if (!ConvertSidToStringSid (pSid, &g_ptszSid) || !g_ptszSid) {break;}

        bReturn = TRUE;

    } while (FALSE);
    //
    // Clean up
    //
    if (pSid)
    {
        LocalFree (pSid);
    }

    return bReturn;
}

PCTSTR
GetFriendlyNamefromPnpId (
    IN PCTSTR pszPnpId,
    IN BOOL   bType
    )
{
    DWORD i = 0;
    TCHAR szHardwareId[MAX_PATH + 1];
    TCHAR szDeviceName[MAX_PATH + 1];
    PCTSTR pszReturn = NULL;
    LPGUID pguidModem = (LPGUID)&GUID_DEVCLASS_MODEM;
    HDEVINFO hdi;
    SP_DEVINFO_DATA devInfoData = {sizeof (devInfoData), 0};

    //
    // I need to use the real reg API, not the custom's ones. this prevents the
    // reg tracking code from barking. the reason this is necessary is because
    // i am using a setup api to open the reg key.
    //
    #undef RegCloseKey

    DEBUGMSG ((S_DBG_RAS, "GetFriendlyNamefromPnpId: %s", pszPnpId));

    do
    {
        hdi = SetupDiGetClassDevs (pguidModem, NULL, NULL, DIGCF_PRESENT);
        if (INVALID_HANDLE_VALUE == hdi)
        {
            break;
        }

        for (i; SetupDiEnumDeviceInfo (hdi, i, &devInfoData) && !pszReturn; i++)
        {
            if (SetupDiGetDeviceRegistryProperty (
                    hdi, &devInfoData, SPDRP_HARDWAREID,
                    NULL, (PBYTE)szHardwareId, MAX_PATH, NULL)         &&
                !_wcsnicmp (szHardwareId, pszPnpId, lstrlen(pszPnpId)) &&
                SetupDiGetDeviceRegistryProperty (
                    hdi, &devInfoData, SPDRP_FRIENDLYNAME,
                    NULL, (PBYTE)szDeviceName, MAX_PATH, NULL) )
            {
                //
                // Get the device name
                //
                if (bType)
                {
                    pszReturn = PoolMemDuplicateString (g_RasPool, szDeviceName);
                    DEBUGMSG ((S_DBG_RAS, "GetFriendlyNamefromPnpId - Found: %s",
                               pszReturn));
                }
                //
                // Get the COM port
                //
                else
                {
                    HKEY key = NULL;
                    PTSTR pszAttach = NULL;

                    key = SetupDiOpenDevRegKey (hdi, &devInfoData,
                            DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ);
                    if (INVALID_HANDLE_VALUE == key) {break;}

                    pszAttach = GetRegValueString (key, S_ATTACHEDTO);
                    if (!pszAttach)
                    {
                        RegCloseKey(key);
                        break;
                    }

                    pszReturn = PoolMemDuplicateString (g_RasPool, pszAttach);
                    DEBUGMSG ((S_DBG_RAS, "GetFriendlyNamefromPnpId - Found: %s",
                               pszReturn));
                    MemFree (g_hHeap, 0, pszAttach);
                    RegCloseKey (key);
                }
            }
            ELSE_DEBUGMSG ((S_DBG_RAS, "GetFriendlyNamefromPnpId - szHardwareId: %s",
                            szHardwareId));
        }

    } while (FALSE);
    //
    // Clean up
    //
    if (INVALID_HANDLE_VALUE != hdi)
    {
        SetupDiDestroyDeviceInfoList (hdi);
    }

    //
    // Put it back the way it was
    //
    #define RegCloseKey USE_CloseRegKey

    return pszReturn;
}

BOOL pGetRasDataFromMemDb (
    IN  PCTSTR          DataName,
    OUT PMEMDB_RAS_DATA Data
    )
{
    BOOL rSuccess = FALSE;
    TCHAR key[MEMDB_MAX];
    DWORD value;
    DWORD flags;

    MYASSERT(DataName && Data && g_CurrentUser && g_CurrentConnection);

    MemDbBuildKey (key, MEMDB_CATEGORY_RAS_INFO, g_CurrentUser,
                    g_CurrentConnection, DataName);
    rSuccess = MemDbGetValueAndFlags (key, &value, &flags);
    //
    // If that wasn't successful, we need to look in the per-user settings.
    //
    if (!rSuccess) {
        MemDbBuildKey (key, MEMDB_CATEGORY_RAS_INFO, MEMDB_FIELD_USER_SETTINGS,
                        g_CurrentUser, DataName);
        rSuccess = MemDbGetValueAndFlags (key, &value, &flags);
        flags = REG_DWORD;
    }

    if (rSuccess) {
        //
        // There is information stored here. Fill it in and send it back to the
        // user.
        //
        if (flags == REG_SZ) {
            //
            // String data, the value points to the offset for the string.
            //
            if (!MemDbBuildKeyFromOffset (value, g_TempBuffer, 1, NULL)) {

                DEBUGMSG ((
                    DBG_ERROR,
                    "Could not retrieve RAS string information stored in Memdb. User=%s,Entry=%s,Setting=%s",
                    g_CurrentUser,
                    g_CurrentConnection,
                    DataName
                    ));

                 return FALSE;
            }

            Data -> String = PoolMemDuplicateString (g_RasPool, g_TempBuffer);
        }
        else {
            //
            // Not string data. The data is stored as the value.
            //
            Data -> Value = value;
        }

        Data -> DataType = (WORD) flags;
    }

    return rSuccess;
}

//
// Whistler bug: 417745 INTL:Win9x Upg: DBCS chars cause User,Domain,
// Passwrds to not be migrated for DUN
//
VOID
AttemptUserDomainMigrate (
    IN OUT PRAS_DIALPARAMS prdp,
    IN OUT PDWORD          pdwFlag
    )
{
    MEMDB_RAS_DATA user, domain;

    if (pGetRasDataFromMemDb (S_USER, &user) &&
        user.String && user.String[0] != '\0')
    {
        lstrcpyn(prdp->DP_UserName, user.String, UNLEN);
        *pdwFlag |= DLPARAMS_MASK_USERNAME;
        DEBUGMSG ((S_DBG_RAS, "AttemptUserDomainMigrate success user"));
    }

    if (pGetRasDataFromMemDb (S_DOMAIN, &domain) &&
        domain.String && domain.String[0] != '\0')
    {
        lstrcpyn(prdp->DP_Domain, domain.String, DNLEN);
        *pdwFlag |= DLPARAMS_MASK_DOMAIN;
        DEBUGMSG ((S_DBG_RAS, "AttemptUserDomainMigrate success dom"));
    }
}

PCTSTR
pGetNetAddress (
    IN PCTSTR Setting
    )
{
    MEMDB_RAS_DATA d;
    BYTE address[4];

    if (!pGetRasDataFromMemDb (Setting, &d) || !d.Value) {
        return DEF_NetAddress; // default
    }
    //
    // Data is stored as a REG_DWORD.
    // We need to write it in dotted decimal form.
    //
    *((LPDWORD)address) = d.Value;
    wsprintf (
        g_TempBuffer,
        TEXT("%d.%d.%d.%d"),
        address[3],
        address[2],
        address[1],
        address[0]
        );

    return g_TempBuffer;
}

BOOL
IsTermEnabled(
    VOID
    )
{
    MEMDB_RAS_DATA d;

    //
    // Whistler bug: 423598 INTL: Win9x Upg: DUN's country is set to U.S. when
    // upgrading DUNs that don't use dialing rules
    //
    if ((g_CurrentDeviceType == RASDT_Modem_V)   &&
        (pGetRasDataFromMemDb (S_PPPSCRIPT, &d)) &&
        (d.String) && (d.String[0] != '\0')) {
        return TRUE;
    }

    if ((pGetRasDataFromMemDb (S_MODEM_UI_OPTIONS, &d)) &&
        (d.Value & (RAS_UI_FLAG_TERMBEFOREDIAL | RAS_UI_FLAG_TERMAFTERDIAL))) {
        return TRUE;
    }

    return FALSE;
}

//
// BEGIN ENTRY_SETTINGS
//

PCTSTR
pGetType (
    VOID
    )
{
    if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return RASET_Vpn;
    }
    else {
        return RASET_Phone; // default
    }
}

PCTSTR
pGetDialParamsUID (
    VOID
    )
{
    if (g_dwDialParamsUID)
    {
        wsprintf (g_TempBuffer, TEXT("%d"), g_dwDialParamsUID);
        g_dwDialParamsUID = 0;

        return g_TempBuffer;
    }
    else
    {
        return S_EMPTY;
    }
}

PCTSTR
pGetBaseProtocol (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_SMM, &d) || StringIMatch (d.String, S_PPP)) {
        return BP_Ppp; // default
    }
    //
    // Map CSLIP to SLIP - Header Compression will be on turned on/off in
    // pGetIpHeaderCompression
    //
    if (StringIMatch (d.String, S_SLIP) || StringIMatch (d.String, S_CSLIP)) {
        return BP_Slip;
    }

    DEBUGMSG ((
        DBG_WARNING,
        "RAS Migrate: Unusable base protocol type (%s) for %s's entry %s. Forcing PPP.",
        d.String,
        g_CurrentUser,
        g_CurrentConnection
        ));

    return BP_Ppp;
}

PCTSTR
pGetVpnStrategy (
    VOID
    )
{
    if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return VS_PptpOnly;
    }
    else {
        return S_ZERO; // default
    }
}

PCTSTR
pGetExcludedProtocols (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    //
    // Excluded protocols lists what protocols
    // are _not_ available for a particular ras connection.
    // This is a bit field where bits are set for each protocol
    // that is excluded.
    // NP_Nbf (0x1), NP_Ipx (0x2), NP_Ip (0x4)
    // Luckily, these are the same definitions as for win9x, except
    // each bit represents a protocol that is _enabled_ not
    // _disabled_. Therefore, all we need to do is reverse the bottom
    // three bits of the number.
    //
    if (!pGetRasDataFromMemDb (S_PROTOCOLS, &d)) {
        return S_ZERO; // default
    }

    wsprintf (g_TempBuffer, TEXT("%d"), ~d.Value & 0x7);

    return g_TempBuffer;
}

PCTSTR
pGetDataEncryption (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_SMM_OPTIONS, &d)) {

        if (g_CurrentDeviceType == RASDT_Vpn_V) {
            return DE_Require; // vpn default
        }
        else {
            return DE_IfPossible; // default
        }
    }

    if ((d.Value & SMMCFG_SW_ENCRYPTION) ||
        (d.Value & SMMCFG_UNUSED)) {
        return DE_Require;
    }
    else if (d.Value & SMMCFG_SW_ENCRYPTION_STRONG) {
        return DE_RequireMax;
    }
    else if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return DE_Require; // vpn default
    }
    else {
        return DE_IfPossible; // default
    }
}

PCTSTR
pGetSwCompression (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_SMM_OPTIONS, &d)) {
        return S_ONE; // default
    }
    //
    // the 1 bit in SMM_OPTIONS controls software based compression.
    // if it is set, the connection is able to handled compression,
    // otherwise, it cannot.
    //
    if (d.Value & SMMCFG_SW_COMPRESSION) {
        return S_ONE;
    }
    else {
        return S_ZERO;
    }

}

PCTSTR
pGetRedialAttempts (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_REDIAL_TRY, &d)) {
        return DEF_RedialAttempts; // default
    }

    wsprintf (g_TempBuffer, TEXT("%d"), d.Value);

    return g_TempBuffer;
}

PCTSTR
pGetRedialSeconds (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    //
    // NT wants this as a total number of seconds. The data we have from 9x has
    // the number of minutes in the hiword and the number of seconds in the
    // loword.
    //
    if (!pGetRasDataFromMemDb (S_REDIAL_WAIT, &d)) {
        return DEF_RedialSeconds; // default
    }

    wsprintf (g_TempBuffer, TEXT("%d"), d.Value);

    return g_TempBuffer;
}

PCTSTR
pGetIdleDisconnectSeconds (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_MODEM_IDLE_DISCONNECT_SECONDS, &d)) {
        return S_ZERO; // default
    }

    wsprintf (g_TempBuffer, TEXT("%d"), d.Value);

    return g_TempBuffer;
}

PCTSTR
pGetShareMsFilePrint (
    VOID
    )
{
    if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return S_ONE; // vpn default
    }
    else {
        return S_ZERO; // default
    }
}

PCTSTR
pGetSharedPhoneNumbers (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return S_ZERO; // vpn default
    }
    else if (pGetRasDataFromMemDb (S_DEVICECOUNT, &d) && (d.Value > 1)) {
        return S_ZERO; // multilink
    }
    else {
        return S_ONE; // default
    }
}

PCTSTR
pGetPreviewUserPw (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_DIALUI, &d)) {
        return S_ONE; // default
    }

    if (d.Value & DIALUI_NO_PROMPT) {
        return S_ZERO;
    }
    else {
        return S_ONE;
    }
}

PCTSTR
pGetPreviewDomain (
    VOID
    )
{
    MEMDB_RAS_DATA d, d2;

    //
    // Whistler bug: 417745 INTL:Win9x Upg: DBCS chars cause User,Domain,
    // Passwrds to not be migrated for DUN
    //
    if (!pGetRasDataFromMemDb (S_SMM_OPTIONS, &d) ||
        !pGetRasDataFromMemDb (S_DOMAIN, &d2)) {
        return S_ZERO; // default
    }

    if ((d.Value & SMMCFG_NW_LOGON) ||
        (d2.String != NULL && d2.String[0] != '\0')) {
        return S_ONE;
    }
    else {
        return S_ZERO;
    }
}

PCTSTR
pGetPreviewPhoneNumber (
    VOID
    )
{
    if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return S_ZERO; // vpn default
    }
    else {
        return pGetPreviewUserPw();
    }
}

PCTSTR
pGetShowMonitorIconInTaskBar (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    //
    // This information is stored packed with other Dialing UI on
    // windows 9x. All we need to do is look for the specific
    // bit which is set when this is turned off.
    //
    if (pGetRasDataFromMemDb (S_DIALUI, &d) && (d.Value & DIALUI_NO_TRAY)) {
        return S_ZERO;
    }
    else {
        return S_ONE; // default
    }
}

PCTSTR
pGetAuthRestrictions (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_SMM_OPTIONS, &d)) {

        if (g_CurrentDeviceType == RASDT_Vpn_V) {
            return AR_F_TypicalSecure; // vpn default
        }
        else {
            return AR_F_TypicalUnsecure; // default
        }
    }

    if (d.Value & SMMCFG_PW_ENCRYPTED) {
        return AR_F_TypicalSecure;
    }
    else if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return AR_F_TypicalSecure; // vpn default
    }
    else {
        return AR_F_TypicalUnsecure; // default
    }
}

PCTSTR
pGetTypicalAuth (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return TA_Secure; // vpn default
    }
    else if ((pGetRasDataFromMemDb (S_SMM_OPTIONS, &d)) &&
             ((d.Value & SMMCFG_SW_ENCRYPTION) ||
              (d.Value & SMMCFG_UNUSED) ||
              (d.Value & SMMCFG_SW_ENCRYPTION_STRONG) ||
              (d.Value & SMMCFG_PW_ENCRYPTED))) {

        return TA_Secure;
    }
    else {
        return TA_Unsecure; // default
    }
}

PCTSTR
pGetIpPrioritizeRemote (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_IP_FTCPIP, &d)) {
        return S_ONE; // default
    }
    else if (d.Value & IPF_NO_WAN_PRI) {
        return S_ZERO;
    }
    else {
        return S_ONE;
    }
}

PCTSTR
pGetIpHeaderCompression (
    VOID
    )
{
    MEMDB_RAS_DATA d1, d2;

    if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return S_ZERO; // vpn default
    }
    else if (pGetRasDataFromMemDb (S_SMM, &d1)) {

        if (StringIMatch (d1.String, S_CSLIP)) {
            return S_ONE;
        }
        else if (StringIMatch (d1.String, S_SLIP)) {
            return S_ZERO;
        }
    }

    if (!pGetRasDataFromMemDb (S_IP_FTCPIP, &d2)) {
        return S_ONE; // default
    }
    else if (d2.Value & IPF_NO_COMPRESS) {
        return S_ZERO;
    }
    else {
        return S_ONE;
    }
}

PCTSTR
pGetIpAddress (
    VOID
    )
{
    return pGetNetAddress (S_IP_IPADDR);
}

PCTSTR
pGetIpDnsAddress (
    VOID
    )
{
    return pGetNetAddress (S_IP_DNSADDR);
}

PCTSTR
pGetIpDns2Address (
    VOID
    )
{
    return pGetNetAddress (S_IP_DNSADDR2);
}

PCTSTR
pGetIpWinsAddress (
    VOID
    )
{
    return pGetNetAddress (S_IP_WINSADDR);
}

PCTSTR
pGetIpWins2Address (
    VOID
    )
{
   return pGetNetAddress (S_IP_WINSADDR2);
}

PCTSTR
pGetIpAssign (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_IP_FTCPIP, &d)) {
        return ASRC_ServerAssigned; // default
    }
    else if (d.Value & IPF_IP_SPECIFIED) {
        return ASRC_RequireSpecific;
    }
    else {
        return ASRC_ServerAssigned;
    }
}

PCTSTR
pGetIpNameAssign (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_IP_FTCPIP, &d)) {
        return ASRC_ServerAssigned; // default
    }
    else if (d.Value & IPF_NAME_SPECIFIED) {
        return ASRC_RequireSpecific;
    }
    else {
        return ASRC_ServerAssigned;
    }
}

//
// END ENTRY_SETTINGS
//

//
// BEGIN NETCOMPONENT_SETTINGS
//

PCTSTR
pGetms_server (
    VOID
    )
{
    if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return S_ONE; // vpn default
    }
    else {
        return S_ZERO; // default
    }
}

//
// END NETCOMPONENT_SETTINGS
//

//
// BEGIN MEDIA_SETTINGS
//

PCTSTR
pGetMEDIA (
    VOID
    )
{
    if (g_CurrentDeviceType == RASDT_Vpn_V ||
        g_CurrentDeviceType == RASDT_Atm_V) {
        return RASMT_Rastapi;
    }
    else if (g_CurrentDeviceType == RASDT_Isdn_V) {
        return RASDT_Isdn;
    }
    else {
        //
        // Couldn't find a matching device, use serial
        //
        return RASMT_Serial;
    }
}

PCTSTR
pGetPort (
    VOID
    )
{
    if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return DEF_VPNPort;
    }
    else if (g_CurrentDeviceType == RASDT_Atm_V) {
        return DEF_ATMPort;
    }
    else if (g_CurrentDeviceType == RASDT_Modem_V) {
        PTSTR p = S_DEVICE_ID;
        PCTSTR Com = NULL;
        MEMDB_RAS_DATA d;

        if (g_CurrentDevice)
        {
            wsprintf (g_TempBuffer, TEXT("ml%d%s"), g_CurrentDevice,
                        S_DEVICE_ID);
            p = g_TempBuffer;
        }

        if (!pGetRasDataFromMemDb (p, &d)) {
            return S_EMPTY;
        }

        Com = GetFriendlyNamefromPnpId (d.String, FALSE);
        if (Com)
        {
            return Com;
        }

        p = S_MODEM_COM_PORT;

        if (g_CurrentDevice) {
            wsprintf (g_TempBuffer, TEXT("ml%d%s"), g_CurrentDevice,
                        S_MODEM_COM_PORT);
            p = g_TempBuffer;
        }

        if (!pGetRasDataFromMemDb (p, &d)) {
            return S_EMPTY;
        }

        return d.String;
    }
    else {
        return S_EMPTY; // Leave it to the NT PBK code to figure this out
    }
}

PCTSTR
pGetDevice (
    VOID
    )
{
    if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return RASMT_Vpn;
    }

    else if (g_CurrentDeviceType == RASDT_Modem_V) {
        PTSTR p = S_DEVICE_ID;
        PCTSTR Device = NULL;
        MEMDB_RAS_DATA d;

        if (g_CurrentDevice)
        {
            wsprintf (g_TempBuffer, TEXT("ml%d%s"), g_CurrentDevice,
                        S_DEVICE_ID);
            p = g_TempBuffer;
        }

        if (!pGetRasDataFromMemDb (p, &d)) {
            return S_EMPTY;
        }

        Device = GetFriendlyNamefromPnpId (d.String, TRUE);
        if (Device)
        {
            return Device;
        }
        else
        {
            return S_EMPTY;
        }
    }
    else {
        return S_EMPTY; // Leave it to the NT PBK code to figure this out
    }
}

PCTSTR
pGetConnectBPS (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if ((g_CurrentDeviceType != RASDT_Modem_V) ||
        (!pGetRasDataFromMemDb (S_MODEM_SPEED, &d))) {
        return S_EMPTY; // Leave it to the NT PBK code to figure this out
    }

    wsprintf (g_TempBuffer, TEXT("%d"), d.Value);

    return g_TempBuffer;
}

//
// END MEDIA_SETTINGS
//

//
// BEGIN GENERAL_DEVICE_SETTINGS
//

PCTSTR
pGetDEVICE (
    VOID
    )
{
    if (g_InSwitchSection) {
        return MXS_SWITCH_TXT;
    }
    else if (g_CurrentDeviceType == RASDT_Isdn_V) {
        return RASDT_Isdn_NT;
    }
    else if (g_CurrentDeviceType == RASDT_Vpn_V) {
        return RASDT_Vpn_NT;
    }
    else if (g_CurrentDeviceType == RASDT_Atm_V) {
        return RASDT_Atm_NT;
    }
    else {
        return RASDT_Modem_NT; //default to modem
    }
}

PCTSTR
pGetPhoneNumber (
    VOID
    )
{
    MEMDB_RAS_DATA d;
    TCHAR buffer[MAX_TCHAR_PATH];

    if (g_CurrentDevice == 0) {
        if (!pGetRasDataFromMemDb(S_PHONE_NUMBER, &d)) {
            return S_EMPTY;
        }
    }
    else {

        wsprintf(buffer,TEXT("ml%d%s"),g_CurrentDevice,S_PHONE_NUMBER);
        if (!pGetRasDataFromMemDb(buffer, &d)) {
            return S_EMPTY;
        }
    }

    return d.String;
}

PCTSTR
pGetAreaCode (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb(S_AREA_CODE, &d)) {
        return S_EMPTY;
    }

    return d.String;
}

PCTSTR
pGetCountryCode (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    //
    // Whistler bug: 423598 INTL: Win9x Upg: DUN's country is set to U.S. when
    // upgrading DUNs that don't use dialing rules
    //
    if (!pGetRasDataFromMemDb(S_COUNTRY_CODE, &d) || !d.Value) {
        return S_ZERO; // default
    }

    wsprintf(g_TempBuffer,TEXT("%d"),d.Value);

    return g_TempBuffer;
}

PCTSTR
pGetCountryID (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    //
    // Whistler bug: 423598 INTL: Win9x Upg: DUN's country is set to U.S. when
    // upgrading DUNs that don't use dialing rules
    //
    if (!pGetRasDataFromMemDb(S_COUNTRY_ID, &d) || !d.Value) {
        return S_ZERO; // default
    }

    wsprintf(g_TempBuffer,TEXT("%d"),d.Value);

    return g_TempBuffer;
}

PCTSTR
pGetUseDialingRules (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    //
    // Whistler bug: 423598 INTL: Win9x Upg: DUN's country is set to U.S. when
    // upgrading DUNs that don't use dialing rules
    //
    if (!pGetRasDataFromMemDb(S_AREA_CODE, &d)
        || !d.String || d.String[0] == '\0' ) {
        return S_ZERO;
    }
    else {
        return S_ONE;
    }
}

//
// END GENERAL_DEVICE_SETTINGS
//

//
// BEGIN MODEM_DEVICE_SETTINGS
//

PCTSTR
pGetHwFlowControl (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_MODEM_CFG_OPTIONS, &d)) {
        return S_ZERO; // default
    }

    if (d.Value & RAS_CFG_FLAG_HARDWARE_FLOW_CONTROL) {
        return S_ONE;
    }
    else {
        return S_ZERO;
    }
}

PCTSTR
pGetProtocol (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_MODEM_CFG_OPTIONS, &d)) {
        return S_ZERO; // default
    }

    if (d.Value & RAS_CFG_FLAG_USE_ERROR_CONTROL) {
        return S_ONE;
    }
    else {
        return S_ZERO;
    }
}

PCTSTR
pGetCompression (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_MODEM_CFG_OPTIONS, &d)) {
        return S_ZERO; // default
    }

    if (d.Value & RAS_CFG_FLAG_COMPRESS_DATA) {
        return S_ONE;
    }
    else {
        return S_ZERO;
    }
}

PCTSTR
pGetSpeaker (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_MODEM_SPEAKER_VOLUME, &d)) {
        return S_ONE; // default
    }

    if (d.Value) {
        return S_ONE;
    }
    else {
        return S_ZERO;
    }
}

//
// END MODEM_DEVICE_SETTINGS
//

//
// BEGIN SWITCH_DEVICE_SETTINGS
//

PCTSTR
pGetName (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_PPPSCRIPT, &d)) {
        return S_EMPTY;
    }
    else {
        return d.String;
    }
}

PCTSTR
pGetTerminal (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    if (!pGetRasDataFromMemDb (S_MODEM_UI_OPTIONS, &d)) {
        return S_ZERO;
    }

    if (d.Value & (RAS_UI_FLAG_TERMBEFOREDIAL | RAS_UI_FLAG_TERMAFTERDIAL)) {
        return S_ONE;
    }
    else {
        return S_ZERO;
    }
}

PCTSTR
pGetScript (
    VOID
    )
{
    MEMDB_RAS_DATA d;

    //
    // Whistler bug: 423598 INTL: Win9x Upg: DUN's country is set to U.S. when
    // upgrading DUNs that don't use dialing rules
    //
    if ((!pGetRasDataFromMemDb (S_PPPSCRIPT, &d)) ||
        (!d.String) || d.String[0] == '\0') {
        return S_ZERO;
    }
    else {
        return S_ONE;
    }
}

//
// END SWITCH_DEVICE_SETTINGS
//

BOOL
pWritePhoneBookLine (
    IN HANDLE FileHandle,
    IN PCTSTR SettingName,
    IN PCTSTR SettingValue
    )
{
    BOOL rSuccess = TRUE;

    rSuccess &= WriteFileString (FileHandle, SettingName);
    rSuccess &= WriteFileString (FileHandle, TEXT("="));
    rSuccess &= WriteFileString (FileHandle, SettingValue ?
                    SettingValue : S_EMPTY);
    rSuccess &= WriteFileString (FileHandle, TEXT("\r\n"));

    return rSuccess;
}

BOOL
pWriteSettings (
    IN HANDLE FileHandle,
    IN PRAS_SETTING SettingList
    )
{
    BOOL rSuccess = TRUE;

    while (SettingList->SettingName) {
        rSuccess &= pWritePhoneBookLine (
            FileHandle,
            SettingList->SettingName,
            SettingList->SettingValue ?
                SettingList->SettingValue :
                SettingList->SettingFunction ());

        SettingList++;
    }

    return rSuccess;
}

BOOL
pCreateUserPhonebook (
    IN PCTSTR UserName
    )
{
    BOOL rSuccess = TRUE;
    BOOL noError;
    MEMDB_RAS_DATA d;
    MEMDB_ENUM e;
    HANDLE file;
    PCTSTR path;
    UINT i;
    UINT count;

    //
    // Set current user global.
    //
    g_CurrentUser = UserName;

    if (MemDbEnumFields (&e, MEMDB_CATEGORY_RAS_INFO, UserName)) {

        DEBUGMSG ((S_DBG_RAS, "Processing dial-up entries for user: %s",
                   UserName));
        //
        // Open the phonebook file and set the file pointer to the EOF.
        //
        path = JoinPaths (g_WinDir, S_RASPHONE_SUBPATH);
        file = CreateFile (
            path,
            GENERIC_READ | GENERIC_WRITE,
            0,                                  // No sharing.
            NULL,                               // No inheritance
            OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL                                // No template file.
            );

        if (file == INVALID_HANDLE_VALUE) {
            DEBUGMSG ((DBG_ERROR, "Unable to open the phonebook file (%s)",
                       path));
            return TRUE;
        }

        SetFilePointer (file, 0, NULL, FILE_END);
        FreePathString (path);
        //
        // Now, enumerate all of the entries and write a phonebook entry to
        // this file for each.
        //
        do {
            g_CurrentConnection = e.szName;
            g_CurrentDevice = 0;

            DEBUGMSG ((S_DBG_RAS, "---Processing %s's entry settings: %s---",
                       UserName, g_CurrentConnection));

            if (g_ptszSid && g_RasmansInit)
            {
                BOOL  bMigrate = TRUE;
                DWORD dwSetMask = 0, dwDialParamsUID;
                RAS_DIALPARAMS rdp;

                g_dwDialParamsUID = 0;
                ZeroMemory (&rdp, sizeof (rdp));
                //
                // Whistler bug: 417745 INTL:Win9x Upg: DBCS chars cause User,
                // Domain, Passwrds to not be migrated for DUN
                //
                AttemptUserDomainMigrate(&rdp, &dwSetMask);

                bMigrate = MigrateEntryCreds (&rdp, g_CurrentConnection,
                                g_CurrentUser, &dwSetMask);
                DEBUGMSG ((S_DBG_RAS, "MigrateEntryCreds: %d", bMigrate));

                dwDialParamsUID = rdp.DP_Uid = GetTickCount() +
                                                    (++g_dwDialUIDOffset);

                if (dwDialParamsUID && !bMigrate)
                {
                    if (!g_SetEntryDialParams ( g_ptszSid, dwDialParamsUID,
                            dwSetMask, 0, &rdp))
                    {
                        g_dwDialParamsUID = dwDialParamsUID;
                        DEBUGMSG ((S_DBG_RAS, "SetEntryDialParams success"));
                    }
                    DEBUGMSG ((S_DBG_RAS, "g_dwDialParamsUID: %d",
                               g_dwDialParamsUID));
                    DEBUGMSG ((S_DBG_RAS, "dwSetMask: %x", dwSetMask));
                }
                //
                // Clean up
                //
                ZeroMemory (&rdp, sizeof (rdp));
            }
            //
            // Whistler 417479 RAS upgrade code does not migrate the default
            // internet connection setting from WinME to XP
            //
            do
            {
                MEMDB_RAS_DATA defInet;
                HKEY hKeyLM = NULL;
                HKEY hKeyCU = NULL;
                PCTSTR Path = NULL;

                if (!pGetRasDataFromMemDb (S_DEFINTERNETCON, &defInet) ||
                    !(defInet.Value))
                {
                    DEBUGMSG ((S_DBG_RAS, "No Internet Connection setting present or disabled"));
                    break;
                }
                //
                // Get key for the HKLM path
                //
                Path = JoinPaths(TEXT("HKLM\\"),S_AUTODIAL_KEY);
                if (Path)
                {
                    hKeyLM = CreateRegKeyStr(Path);
                    FreePathString(Path);
                }
                //
                // Get key for the HKCU path
                //
                hKeyCU = CreateRegKey (g_UserRootKey, S_AUTODIAL_KEY);
                //
                // Set the value for both
                //
                if (hKeyLM)
                {
                    RegSetValueEx(hKeyLM, S_DEFINTERNETCON, 0, REG_SZ,
                        (PBYTE) g_CurrentConnection,
                        SizeOfString(g_CurrentConnection));

                    DEBUGMSG ((S_DBG_RAS, "Default Internet Connection = 1 (HKLM)"));
                    CloseRegKey(hKeyLM);
                }
                else
                {
                    DEBUGMSG ((S_DBG_RAS, "Error creating/opening HKLM internet reg_key"));
                }

                if (hKeyCU)
                {
                    RegSetValueEx(hKeyCU, S_DEFINTERNETCON, 0, REG_SZ,
                        (PBYTE) g_CurrentConnection,
                        SizeOfString(g_CurrentConnection));

                    DEBUGMSG ((S_DBG_RAS, "Default Internet Connection = 1 (HKCU)"));
                    CloseRegKey(hKeyCU);
                }
                else
                {
                    DEBUGMSG ((S_DBG_RAS, "Error creating/opening HKCU internet reg_key"));
                }

            } while (FALSE);

            if (!pGetRasDataFromMemDb (S_DEVICE_TYPE, &d)) {
                g_CurrentDeviceType = RASDT_Modem_V;
            }
            else {
                if (StringIMatch (d.String, RASDT_Modem)) {
                    g_CurrentDeviceType = RASDT_Modem_V;
                }
                else if (StringIMatch (d.String, RASDT_Isdn)) {
                    g_CurrentDeviceType = RASDT_Isdn_V;
                }
                else if (StringIMatch (d.String, RASDT_Vpn)) {
                    g_CurrentDeviceType = RASDT_Vpn_V;
                }
                else if (StringIMatch (d.String, RASDT_Atm)) {
                    g_CurrentDeviceType = RASDT_Atm_V;
                }
                else {
                    g_CurrentDeviceType = RASDT_Modem_V;
                }
            }

            noError = TRUE;
            //
            // Add this entry to the phonebook.
            //
            // Write title.
            //
            // Whistler bug: 417745 INTL:Win9x Upg: DBCS chars cause User,
            // Domain, Passwrds to not be migrated for DUN
            //
            // We truncate the connection name because XP PBK freaks out
            //
            if (SizeOfString(g_CurrentConnection) >= RAS_MaxPortName / 2 )
            {
                TCHAR Truncate[RAS_MaxPortName];

                lstrcpyn(Truncate, g_CurrentConnection, RAS_MaxPortName / 2);
                noError &= WriteFileString (file, TEXT("["));
                noError &= WriteFileString (file, Truncate);
                noError &= WriteFileString (file, TEXT("]\r\n"));

                DEBUGMSG ((S_DBG_RAS, "Truncating Connection Name: %s", Truncate));
            }
            else
            {
                noError &= WriteFileString (file, TEXT("["));
                noError &= WriteFileString (file, g_CurrentConnection);
                noError &= WriteFileString (file, TEXT("]\r\n"));
            }
            //
            // Write base entry settings.
            //
            noError &= pWriteSettings (file, g_EntrySettings);
            noError &= WriteFileString (file, TEXT("\r\n"));
            //
            // Write NetComponent settings
            //
            noError &= pWriteSettings (file, g_NetCompSettings);

            if (!pGetRasDataFromMemDb (S_DEVICECOUNT, &d)) {
                count = 1;
                DEBUGMSG ((DBG_WHOOPS, "No devices listed in memdb for connections %s.",
                           g_CurrentConnection));
            }
            else {
                count = d.Value;
            }

            for (i = 0; i < count; i++) {

                g_CurrentDevice = i;
                //
                // Write media settings.
                //
                noError &= WriteFileString (file, TEXT("\r\n"));
                noError &= pWriteSettings (file, g_MediaSettings);
                //
                // Write Device settings.
                //
                noError &= WriteFileString (file, TEXT("\r\n"));
                noError &= pWriteSettings (file, g_GeneralSettings);

                if (g_CurrentDeviceType == RASDT_Modem_V) {
                    noError &= pWriteSettings (file, g_ModemDeviceSettings);
                }
                else if (g_CurrentDeviceType == RASDT_Isdn_V) {
                    noError &= pWriteSettings (file, g_IsdnDeviceSettings);
                }
                //
                // Write switch settings
                //
                if (IsTermEnabled()) {

                    g_InSwitchSection = TRUE;

                    noError &= WriteFileString (file, TEXT("\r\n"));
                    noError &= pWriteSettings (file, g_SwitchDeviceSettings);

                    g_InSwitchSection = FALSE;
                }
            }

            noError &= WriteFileString (file, TEXT("\r\n"));

            if (!noError) {
                LOG ((
                    LOG_ERROR,
                    "Error while writing phonebook for %s's %s setting.",
                    g_CurrentUser,
                    g_CurrentConnection
                    ));
            }

        } while (MemDbEnumNextValue (&e));
        //
        // Close the handle to the phone book file.
        //
        CloseHandle (file);
    }
    ELSE_DEBUGMSG ((S_DBG_RAS, "No dial-up entries for user  %s.", UserName));

    return rSuccess;
}

/*++
Routine Description:

  pGatherPhoneDialerSettings gathers information on phonedialer speeddial
  settings. This information is then used to create each user's speed dial
  settings. Note that this information is per system in win9x, but per user
  in NT.

  There are multiple types of entries on Windows NT, but only one entry type
  on win9x. All entries are migrated as type "POTS" and "PhoneNumber"

  These entries are within the User hive at
  HKCU\Software\Microsoft\Dialer\Speeddial\[SpeedDial<n>] =
  "POTS", "PhoneNumber", "<number>", "<name>"

Arguments:

  None.

Return Value:

--*/
VOID
pGatherPhoneDialerSettings (
    VOID
    )
{
    PCTSTR dialerIniPath = NULL;
    HINF   hDialerIni = NULL;
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    PCTSTR curKey;
    UINT num;
    PCTSTR tempPath = NULL;

    //
    // Open %windir%\dialer.ini
    //
    dialerIniPath = JoinPaths (g_WinDir, S_DIALER_INI);
    tempPath = GetTemporaryLocationForFile (dialerIniPath);

    if (tempPath) {
        //
        // telephon ini is in a temporary location. Use that.
        //
        DEBUGMSG ((S_DBG_RAS, "Using %s for %s.", tempPath, dialerIniPath));
        FreePathString (dialerIniPath);
        dialerIniPath = tempPath;
    }

    hDialerIni = InfOpenInfFile (dialerIniPath);

    if (hDialerIni != INVALID_HANDLE_VALUE) {
        //
        // For each location in [Speed Dial Settings], gather the data and
        // save it into our settings array.
        //
        if (InfFindFirstLine (hDialerIni, S_SPEED_DIAL_SETTINGS, NULL, &is)) {

            do {

                curKey = InfGetStringField (&is, 0);

                if (IsPatternMatch (TEXT("Name*"), curKey)) {

                    num = _ttoi (_tcsinc (_tcschr (curKey, TEXT('e'))));
                    g_Settings[num].Name = InfGetStringField (&is,1);
                    g_SpeedDialSettingsExist = TRUE;

                }
                else if (IsPatternMatch (TEXT("Number*"), curKey)) {

                    num = _ttoi (_tcsinc (_tcschr (curKey, TEXT('r'))));
                    g_Settings[num].Number = InfGetStringField (&is,1);
                    g_SpeedDialSettingsExist = TRUE;
                }
                ELSE_DEBUGMSG ((DBG_WHOOPS, "Unexpected key found in speed dial settings: %s",
                                curKey));

            } while (InfFindNextLine (&is));
        }

        InfCloseInfFile (hDialerIni);
    }
}

BOOL
pCreateUserPhoneDialerSettings (
    IN HKEY UserRootKey
    )
{
    BOOL rSuccess = TRUE;
    HKEY key;
    UINT num;
    TCHAR valueName[40];
    TCHAR dialerSetting[MEMDB_MAX];
    UINT rc;

    if (!g_SpeedDialSettingsExist) {
        return TRUE;
    }

    rc = TrackedRegCreateKey (UserRootKey, S_SPEEDDIALKEY, &key);

    if (rc == ERROR_SUCCESS) {

        for (num = 0; num < MAX_SPEED_DIAL; num++) {

            if (g_Settings[num].Number && g_Settings[num].Name &&
                *g_Settings[num].Name) {

                wsprintf (valueName, TEXT("Speeddial%u"), num);
                wsprintf (
                    dialerSetting,
                    TEXT("\"POTS\",\"PhoneNumber\",\"%s\",\"%s\""),
                    g_Settings[num].Number,
                    g_Settings[num].Name
                    );

                rc = RegSetValueEx(
                        key,
                        valueName,
                        0,
                        REG_SZ,
                        (PBYTE) dialerSetting,
                        SizeOfString (dialerSetting)
                        );

                DEBUGMSG_IF ((
                    rc != ERROR_SUCCESS,
                    DBG_ERROR,
                    "Error settings speeddial settings for %s. (%s/%s)",
                    valueName,
                    g_Settings[num].Name,
                    g_Settings[num].Number
                    ));
            }
        }

        CloseRegKey(key);
    }
    ELSE_DEBUGMSG ((DBG_WARNING, "Could not open speed dial key. Speed dial settings will not be upgraded."));

    return rSuccess;
}

BOOL
Ras_MigrateUser (
    IN PCTSTR User,
    IN HKEY   UserRootKey
    )
{
    BOOL rSuccess = TRUE;
    static BOOL firstTime = TRUE;
    g_UserRootKey = UserRootKey;

    if (firstTime) {
        pGatherPhoneDialerSettings ();
        firstTime = FALSE;
    }

    GetRasUserSid (User);

    if (!pCreateUserPhonebook (User)) {
        DEBUGMSG ((DBG_ERROR, "Failure while creating user phonebook for %s.",
                   User));
    }

    if (!pCreateUserPhoneDialerSettings (UserRootKey)) {
        DEBUGMSG ((DBG_ERROR, "Failure while creating user phone dialer settings for %s.",
                   User));
    }
    //
    // Clean up
    //
    if (g_ptszSid)
    {
        LocalFree(g_ptszSid);
        g_ptszSid = NULL;
    }

    return rSuccess;
}

BOOL
Ras_MigrateSystem (
    VOID
    )
{
    //
    // Nothing to do here currently.
    //
    return TRUE;
}

BOOL
Ras_Entry (
    IN HINSTANCE Instance,
    IN DWORD     Reason,
    IN PVOID     Reserved
    )
{
    BOOL rSuccess = TRUE;

    switch (Reason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // Initialize Memory pool.
        //
        g_RasPool = PoolMemInitNamedPool ("RAS - NT Side");
        if (!g_RasPool) {
            DEBUGMSG((DBG_ERROR,
                      "Ras Migrate: Pool Memory failed to initialize..."));
            rSuccess = FALSE;
        }

        pInitLibs ();

        break;

    case DLL_PROCESS_DETACH:
        //
        // Free memory pool.
        //
        if (g_RasPool) {
            PoolMemDestroyPool(g_RasPool);
        }
        if (g_RasmansInit) {
            pCleanUpLibs();
        }
        //
        // Attempt to delete %windir%\pwls\*.*
        //
        DeleteAllPwls ();
        break;
    }

    return rSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\security.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    security.c

Abstract:

    Helpers for NT security API.

Author:

    Jim Schmidt (jimschm) 05-Feb-1997

Revision History:


    ovidiut     14-Mar-2000 Updated CreateLocalAccount for encrypted password feature
    jimschm     02-Jun-1999 Added SetRegKeySecurity
    jimschm     18-Mar-1998 Updated CreateLocalAccount for random password
                            feature.  Added password change if account
                            already exists.

--*/

#include "pch.h"
#include "migmainp.h"
#include "security.h"
#include "encrypt.h"
#include <ntdsapi.h>
#include <dsgetdc.h>


#ifndef UNICODE
#error UNICODE definition required for account lookup code
#endif

#define UNDOCUMENTED_UI_FLAG        0x0200

//
// NT 5 - net share-specific flag
//


DWORD
ConvertNetRightsToAccessMask (
    IN      DWORD Flags
    )

/*++

Routine Description:

    Routine that converts LAN Man flags into NT security flags.

Arguments:

    Flags   - Access flags used with NetAccess* APIs

Return value:

    A DWORD containing the NT security flags.

--*/

{
    DWORD OutFlags;

    if (Flags == ACCESS_READ) {
        //
        // Read only permissions
        //

        OutFlags = FILE_GENERIC_READ|FILE_GENERIC_EXECUTE;

    } else if (Flags == ACCESS_WRITE) {
        //
        // Change only permission
        //

        OutFlags = FILE_GENERIC_WRITE|DELETE;

    } else if (Flags == (ACCESS_READ|ACCESS_WRITE)) {
        //
        // Full control permissions
        //

        OutFlags = FILE_ALL_ACCESS|UNDOCUMENTED_UI_FLAG;

    } else {
        //
        // Unsupported options... disable the share
        //

        OutFlags = 0;
        DEBUGMSG ((DBG_VERBOSE, "Unsupported permission %u was translated to disable permission", Flags));
    }

    return OutFlags;
}


DWORD
AddAclMember (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCTSTR UserOrGroup,
    IN      DWORD Attributes
    )

/*++

Routine Description:

    Appends user/group account, attributes and enable flag to a list
    of members.  This funciton is used to build a list of members which
    is passed to CreateAclFromMemberList to create an ACL.

Arguments:

    GrowBuf     - A GROWBUFFER variable that is zero-initialized

    UserOrGroup - String specifying user name or group

    Attributes  - A list of access rights (a combination of flags
                  from NetAccess* APIs).  Currently the only flags
                  that are used are:

                  0 - Deny all access

                  ACCESS_READ - Read-Only access

                  ACCESS_WRITE - Change-Only access

                  ACCESS_READ|ACCESS_WRITE - Full access

Return value:

    The number of bytes needed to store UserOrGroup, Attributes and Enabled,
    or zero if the function fails.  GrowBuf may be expanded to hold the
    new data.

    GrowBuf must be freed by the caller after the ACL is generated.

--*/

{
    DWORD Size;
    PACLMEMBER AclMemberPtr;
    TCHAR RealName[MAX_USER_NAME];
    DWORD OriginalAttribs;
    BOOL Everyone;
    PCTSTR p;

    p = _tcschr (UserOrGroup, TEXT('\\'));
    if (p) {
        UserOrGroup = _tcsinc (p);
    }

    if (StringMatch (UserOrGroup, TEXT("*"))) {
        _tcssafecpy (RealName, g_EveryoneStr, MAX_USER_NAME);
    } else {
        _tcssafecpy (RealName, UserOrGroup, MAX_USER_NAME);
    }

    Everyone = StringIMatch (RealName, g_EveryoneStr);

    Size = SizeOfString (RealName) + sizeof (ACLMEMBER);
    AclMemberPtr = (PACLMEMBER) GrowBuffer (GrowBuf, Size);

    OriginalAttribs = Attributes;
    if (!Attributes && !Everyone) {
        Attributes = ACCESS_READ|ACCESS_WRITE;
    }

    AclMemberPtr->Attribs = ConvertNetRightsToAccessMask (Attributes);
    AclMemberPtr->Enabled = Everyone || OriginalAttribs != 0;
    AclMemberPtr->Failed  = FALSE;
    StringCopy (AclMemberPtr->UserOrGroup, RealName);

    return Size;
}


PACL
CreateAclFromMemberList (
    PBYTE AclMemberList,
    DWORD MemberCount
    )

/*++

Routine Description:

    CreateAclFromMemberList takes a member list (prepared by AddAclMember)
    and generates an ACL.

Arguments:

    AclMemberList  - A pointer to the buffer maintained by AddAclMember.  This
                     is usually the Buf member of a GROWBUFFER variable.

    MemberCount    - The number of members in AclMemberList (i.e. the number of
                     AddAclMember calls)

Return value:

    A pointer to a MemAlloc'd ACL, or NULL if an error occurred.  Call
    FreeMemberListAcl to free a non-NULL return value.

--*/

{
    PACLMEMBER AclMemberPtr;
    DWORD AllowedAceCount;
    DWORD DeniedAceCount;
    DWORD d;
    PACL Acl = NULL;
    DWORD AclSize;
    BOOL b = FALSE;
    UINT SidSize = 0;

    __try {

        //
        // Create SID array for all members
        //

        AclMemberPtr = (PACLMEMBER) AclMemberList;
        AllowedAceCount = 0;
        DeniedAceCount = 0;

        for (d = 0 ; d < MemberCount ; d++) {
            AclMemberPtr->Sid = GetSidForUser (AclMemberPtr->UserOrGroup);
            if (!AclMemberPtr->Sid) {
                // Mark an error
                AclMemberPtr->Failed = TRUE;
            } else {
                // Found SID, adjust ace count and sid size
                if (AclMemberPtr->Enabled) {
                    AllowedAceCount++;
                } else {
                    DeniedAceCount++;
                }

                SidSize += GetLengthSid (AclMemberPtr->Sid);
            }

            GetNextAclMember (&AclMemberPtr);
        }

        //
        // Calculate size of ACL (an ACL struct plus the ACEs) and allocate it.
        //
        // We subtract a DWORD from the struct size because the actual size of all
        // SidStart members is given by SidSize.
        //

        AclSize = sizeof (ACL) +
                  AllowedAceCount * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (DWORD)) +
                  DeniedAceCount *  (sizeof (ACCESS_DENIED_ACE)  - sizeof (DWORD)) +
                  SidSize;

        Acl = (PACL) MemAlloc (g_hHeap, 0, AclSize);
        if (!Acl) {
            LOG ((LOG_ERROR, "Couldn't allocate an ACL"));
            __leave;
        }


        //
        // Create the ACL
        //

        if (!InitializeAcl (Acl, AclSize, ACL_REVISION)) {
            LOG ((LOG_ERROR, "Couldn't initialize ACL"));
            __leave;
        }

        //
        // Add the access-denied ACLs first
        //

        AclMemberPtr = (PACLMEMBER) AclMemberList;

        for (d = 0 ; d < MemberCount ; d++) {
            if (AclMemberPtr->Failed) {
                continue;
            }

            if (!AclMemberPtr->Enabled) {
                if (!AddAccessDeniedAce (
                        Acl,
                        ACL_REVISION,
                        AclMemberPtr->Attribs,
                        AclMemberPtr->Sid
                        )) {

                    LOG ((
                        LOG_ERROR,
                        "Couldn't add denied ACE for %s",
                        AclMemberPtr->UserOrGroup
                        ));
                }
            }

            GetNextAclMember (&AclMemberPtr);
        }

        //
        // Add the access-enabled ACLs last
        //
        // Reset the SID pointer because CreateAclFromMemberList is the
        // only ones who uses this member
        //

        AclMemberPtr = (PACLMEMBER) AclMemberList;

        for (d = 0 ; d < MemberCount ; d++) {
            if (AclMemberPtr->Failed) {
                continue;
            }

            //
            // Add member to list
            //
            if (AclMemberPtr->Enabled) {
                if (!AddAccessAllowedAce (
                        Acl,
                        ACL_REVISION,
                        AclMemberPtr->Attribs,
                        AclMemberPtr->Sid
                        )) {

                    LOG ((
                        LOG_ERROR,
                        "Couldn't add allowed ACE for %s",
                        AclMemberPtr->UserOrGroup
                        ));
                }
            }

            AclMemberPtr->Sid = NULL;

            GetNextAclMember (&AclMemberPtr);
        }

        b = TRUE;
    }

    __finally {
        if (!b) {
            if (Acl) {
                MemFree (g_hHeap, 0, Acl);
            }
            Acl = NULL;
        }
    }

    return Acl;
}


VOID
FreeMemberListAcl (
    PACL Acl
    )

/*++

Routine Description:

    Routine to free the value returned by CreateAclFromMemberList

Arguments:

    Acl - The return value of CreateAclFromMemberList

Return value:

    none

--*/

{
    if (Acl) {
        MemFree (g_hHeap, 0, (LPVOID) Acl);
    }
}


VOID
GetNextAclMember (
    PACLMEMBER *AclMemberPtrToPtr
    )

/*++

Routine Description:

    GetNextAclMember adjusts an ACLMEMBER pointer to point to the next
    member.  Each member is a variable-length structure, so this funciton
    is required to walk the structure array.

Arguments:

    AclMemberPtrToPtr  - A pointer to a PACLMEMBER variable.

Return value:

    none

--*/

{
    *AclMemberPtrToPtr = (PACLMEMBER) ((PBYTE) (*AclMemberPtrToPtr) +
                                       sizeof (ACLMEMBER) +
                                       SizeOfString ((*AclMemberPtrToPtr)->UserOrGroup)
                                       );
}


LONG
CreateLocalAccount (
    IN     PACCOUNTPROPERTIES Properties,
    IN     PCWSTR User             OPTIONAL
    )

/*++

Routine Description:

    CreateLocalAccount creates an account for a local user

Arguments:

    Properties  - Specifies a set of attributes for a user

    User        - An optional name to override Properties->User

Return value:

    A Win32 error code

--*/

{
    USER_INFO_3 ui;
    PUSER_INFO_3 ExistingInfo;
    DWORD rc;
    LONG ErrParam;
    PCWSTR UnicodeUser;
    PCWSTR UnicodePassword;
    PCWSTR UnicodeFullName;
    PCWSTR UnicodeComment;

    //
    // Create local account
    //

    if (!User) {
        User = Properties->User;
    }

    UnicodeUser         = CreateUnicode (User);
    UnicodePassword     = CreateUnicode (Properties->Password);
    UnicodeComment      = CreateUnicode (Properties->AdminComment);
    UnicodeFullName     = CreateUnicode (Properties->FullName);

    ZeroMemory (&ui, sizeof (ui));
    ui.usri3_name       = (PWSTR) UnicodeUser;
    ui.usri3_password   = (PWSTR) UnicodePassword;
    ui.usri3_comment    = (PWSTR) UnicodeComment;
    ui.usri3_full_name  = (PWSTR) UnicodeFullName;

    ui.usri3_priv         = USER_PRIV_USER; // do not change
    //
    // don't expire nor require a password for this account
    //
    ui.usri3_flags        = UF_SCRIPT|UF_NORMAL_ACCOUNT|UF_DONT_EXPIRE_PASSWD|UF_PASSWD_NOTREQD;
    ui.usri3_acct_expires = TIMEQ_FOREVER;
    ui.usri3_max_storage  = USER_MAXSTORAGE_UNLIMITED;

    ui.usri3_primary_group_id = DOMAIN_GROUP_RID_USERS;
    ui.usri3_max_storage = USER_MAXSTORAGE_UNLIMITED;
    ui.usri3_acct_expires = TIMEQ_FOREVER;

    ui.usri3_password_expired = (INT) g_ConfigOptions.ForcePasswordChange;

    rc = NetUserAdd (NULL, 3, (PBYTE) &ui, &ErrParam);

    if (rc == ERROR_SUCCESS) {
        if (Properties->PasswordAttribs & PASSWORD_ATTR_ENCRYPTED) {
            //
            // change user's password using encrypted password APIs
            //
            rc = SetLocalUserEncryptedPassword (
                    User,
                    Properties->Password,
                    FALSE,
                    Properties->EncryptedPassword,
                    TRUE
                    );
            if (rc != ERROR_SUCCESS) {
                if (rc == ERROR_PASSWORD_RESTRICTION) {
                    LOG ((
                        LOG_WARNING,
                        "Unable to set supplied password on user %s because a password rule has been violated.",
                        User
                        ));
                } else if (rc == ERROR_INVALID_PARAMETER) {
                    LOG ((
                        LOG_WARNING,
                        "Illegal encrypted password supplied for user %s.",
                        User
                        ));
                } else {
                    LOG ((
                        LOG_WARNING,
                        "Unable to set password on user %s, rc=%u",
                        User,
                        rc
                        ));

                    rc = ERROR_INVALID_PARAMETER;
                }
            }
        }
    } else if (rc == NERR_UserExists) {
        //
        // Try to change password if user already exists and this is the intent
        //

        DEBUGMSG ((DBG_WARNING, "User %s already exists", User));

        if ((Properties->PasswordAttribs & PASSWORD_ATTR_DONT_CHANGE_IF_EXIST) == 0) {
            if (Properties->PasswordAttribs & PASSWORD_ATTR_ENCRYPTED) {
                rc = SetLocalUserEncryptedPassword (
                        User,
                        Properties->Password,
                        FALSE,
                        Properties->EncryptedPassword,
                        TRUE
                        );
                if (rc != ERROR_SUCCESS) {
                    if (rc == ERROR_PASSWORD_RESTRICTION) {
                        LOG ((
                            LOG_WARNING,
                            "Unable to set supplied password on user %s because a password rule has been violated.",
                            User
                            ));
                    } else if (rc == ERROR_INVALID_PARAMETER) {
                        LOG ((
                            LOG_WARNING,
                            "Illegal encrypted password supplied for user %s.",
                            User
                            ));
                    } else {
                        LOG ((
                            LOG_WARNING,
                            "Unable to set password on user %s, rc=%u",
                            User,
                            rc
                            ));

                        rc = ERROR_INVALID_PARAMETER;
                    }
                }
            } else {
                rc = NetUserGetInfo (NULL, User, 3, (PBYTE *) &ExistingInfo);
                if (rc == ERROR_SUCCESS) {
                    ExistingInfo->usri3_password  = ui.usri3_password;
                    ExistingInfo->usri3_comment   = ui.usri3_comment;
                    ExistingInfo->usri3_full_name = ui.usri3_full_name;
                    ExistingInfo->usri3_flags     = ui.usri3_flags;
                    ExistingInfo->usri3_password_expired = ui.usri3_password_expired;

                    rc = NetUserSetInfo (NULL, User, 3, (PBYTE) ExistingInfo, &ErrParam);

                    NetApiBufferFree ((PVOID) ExistingInfo);

                    if (rc != ERROR_SUCCESS) {
                        LOG ((LOG_WARNING, "NetUserSetInfo failed for %s. rc=%u.", User, rc));
                        rc = ERROR_INVALID_PARAMETER;
                    }
                } else {
                    LOG ((LOG_WARNING, "NetUserGetInfo failed for %s. rc=%u.", User, rc));
                    rc = ERROR_INVALID_PARAMETER;
                }
            }
        } else {
            rc = ERROR_SUCCESS;
        }
    } else {
        LOG ((LOG_ERROR, "NetUserAdd failed for %s. ErrParam=%i.", User, ErrParam));
    }

    DestroyUnicode (UnicodeUser);
    DestroyUnicode (UnicodePassword);
    DestroyUnicode (UnicodeComment);
    DestroyUnicode (UnicodeFullName);

    return rc;
}


VOID
ClearAdminPassword (
    VOID
    )
{
    ACCOUNTPROPERTIES Properties;

    Properties.Password = L"";
    Properties.AdminComment = L"";
    Properties.User = g_AdministratorStr;
    Properties.FullName = g_AdministratorStr;

    CreateLocalAccount (&Properties, NULL);
}


BOOL
AddSidToLocalGroup (
    PSID Sid,
    PCWSTR Group
    )

/*++

Routine Description:

    Routine that adds the supplied SID to the Administrators group.

Arguments:

    Sid - A valid security id for the user to be added to the
          Administrators group

    Group - Specifies the group name to join the user to

Return value:

    TRUE if the member was added successfully

--*/

{
    LOCALGROUP_MEMBERS_INFO_0 lgrmi0;
    DWORD rc;

    lgrmi0.lgrmi0_sid = Sid;
    rc = NetLocalGroupAddMembers (
               NULL,
               Group,
               0,                    // level 0
               (PBYTE) &lgrmi0,
               1                     // member count
               );

    return rc == ERROR_SUCCESS;
}


NTSTATUS
pGetPrimaryDomainInfo (
    POLICY_PRIMARY_DOMAIN_INFO **PrimaryInfoPtr
    )

/*++

Routine Description:

    Private function that retrieves the primary domain info.

Arguments:

    PrimaryInfoPtr - Pointer to a variable to receive the address
                     of the POLICY_PRIMARY_DOMAIN_INFO structure
                     allocated by the Lsa APIs.  Free memory by
                     calling LsaFreeMemory.

Return value:

    NT status code indicating outcome

--*/


{
    LSA_HANDLE  policyHandle;
    NTSTATUS    status;

    //
    // Open local LSA policy to retrieve domain name
    //

    status = OpenPolicy (
                NULL,                           // local target machine
                POLICY_VIEW_LOCAL_INFORMATION,  // Access type
                &policyHandle                   // resultant policy handle
                );

    if (status == ERROR_SUCCESS) {
        //
        // Query LSA Primary domain info
        //

        status = LsaQueryInformationPolicy (
                     policyHandle,
                     PolicyPrimaryDomainInformation,
                     (PVOID *) PrimaryInfoPtr
                     );

        LsaClose (policyHandle);
    }

    return status;
}


BOOL
GetPrimaryDomainName (
    OUT     PTSTR DomainName
    )
{
    NTSTATUS status;
    POLICY_PRIMARY_DOMAIN_INFO *PrimaryInfo;
    PCTSTR TcharName;

    status = pGetPrimaryDomainInfo (&PrimaryInfo);
    if (status == ERROR_SUCCESS) {
        TcharName = ConvertWtoT (PrimaryInfo->Name.Buffer);
        MYASSERT (TcharName);

        StringCopy (DomainName, TcharName);
        FreeWtoT (TcharName);

        LsaFreeMemory (PrimaryInfo);
    }
    ELSE_DEBUGMSG ((DBG_WARNING, "Can't get primary domain info.  rc=%u", status));

    return status == ERROR_SUCCESS;
}


BOOL
GetPrimaryDomainSid (
    OUT     PBYTE DomainSid,
    IN      UINT MaxBytes
    )
{
    NTSTATUS status;
    POLICY_PRIMARY_DOMAIN_INFO *PrimaryInfo;
    UINT Size;

    status = pGetPrimaryDomainInfo (&PrimaryInfo);
    if (status == ERROR_SUCCESS) {
        Size = GetLengthSid (PrimaryInfo->Sid);
        if (MaxBytes < Size) {
            status = ERROR_INSUFFICIENT_BUFFER;
        } else {
            CopyMemory (DomainSid, PrimaryInfo->Sid, Size);
        }

        LsaFreeMemory (PrimaryInfo);
    }
    ELSE_DEBUGMSG ((DBG_WARNING, "Can't get primary domain SID.  rc=%u", status));

    return status == ERROR_SUCCESS;
}



BOOL
IsMemberOfDomain (
    VOID
    )

/*++

Routine Description:

    Determines if the machine is participating in a domain, or if it is
    only participating in a workgroup.  This determination is done by
    obtaining the primary domain information, looking for the server's
    SID.  If the SID is NULL, the machine is not in a domain.

Arguments:

    none

Return value:

    TRUE if the machine is in a domain, FALSE if its in a workgroup.

--*/

{
    NET_API_STATUS rc;
    PWSTR WorkgroupOrDomain = NULL;
    NETSETUP_JOIN_STATUS Type;

    rc = NetGetJoinInformation (NULL, &WorkgroupOrDomain, &Type);

    DEBUGMSG ((DBG_VERBOSE, "NetGetJoinInformation: name=%s, type=%u", WorkgroupOrDomain, Type));

    if (WorkgroupOrDomain) {
        NetApiBufferFree (WorkgroupOrDomain);
    }

    if (rc != ERROR_SUCCESS) {
        LOG ((LOG_ERROR, "NetGetJoinInformation failed: error %u", rc));
    }

    return rc == ERROR_SUCCESS && Type == NetSetupDomainName;


#if 0
    POLICY_PRIMARY_DOMAIN_INFO *PrimaryInfo;
    BOOL b;
    NTSTATUS rc;

    rc = pGetPrimaryDomainInfo (&PrimaryInfo);
    if (rc == ERROR_SUCCESS) {
        b = PrimaryInfo->Sid != NULL;
    } else {
        b = FALSE;
        SetLastError (rc);
        LOG ((LOG_ERROR, "Can't get domain security info"));
    }

    // Domain name is in PrimaryInfo->Name.Buffer

    LsaFreeMemory (PrimaryInfo) ;

    return b;
#endif

}


LONG
GetAnyDC (
    IN PCWSTR  Domain,
    IN PWSTR   ServerBuf,
    IN BOOL     GetNewServer
    )

/*++

  Routine Description:

    Gets the list of all domain controllers and randomly chooses one.  If
    the listed DC is not online, other listed DCs are queried until an
    alive DC is found.

  Arguments:

    Domain    - The name of the domain to find DCs for
    ServerBuf - A buffer to hold the name of the server

  Return value:

    NT status code indicating outcome.

--*/

{
    DWORD rc;
    PDOMAIN_CONTROLLER_INFO dci;
    DWORD Flags = DS_IS_FLAT_NAME;

    //
    // This API is fast because its WINS based...
    //

    rc = DsGetDcName (
            NULL,           // computer to remote to
            Domain,
            NULL,           // Domain GUID
            NULL,           // Site GUID
            Flags | (GetNewServer ? DS_FORCE_REDISCOVERY : 0),
            &dci
            );

    if (rc == NO_ERROR) {
        StringCopyW (ServerBuf, dci->DomainControllerAddress);
        NetApiBufferFree (dci);

        DEBUGMSG ((DBG_VERBOSE, "Found server %s for the %s domain", ServerBuf, Domain));
        return rc;
    }

    return rc;

}


VOID
InitLsaString (
    OUT     PLSA_UNICODE_STRING LsaString,
    IN      PWSTR String
    )

/*++

Routine Description:

    LSA uses a special Pascal-style string structure.  This
    routine assigns String to a member of LsaString, and computes
    its length and maximum length.

Arguments:

    LsaString - A pointer to the structure to receive a pointer
                to the nul-terminated string, the length in bytes
                (excluding the nul), and the maximum length including
                the nul.

Return value:

    none

--*/


{
    USHORT StringLength;

    if (!String) {
        ZeroMemory (LsaString, sizeof (LSA_UNICODE_STRING));
        return;
    }

    StringLength = ByteCountW (String);
    LsaString->Buffer = String;
    LsaString->Length = StringLength;
    LsaString->MaximumLength = StringLength + sizeof(WCHAR);
}


NTSTATUS
OpenPolicy (
    IN      PWSTR ServerName,
    IN      DWORD DesiredAccess,
    OUT     PLSA_HANDLE policyHandle
    )

/*++

Routine Description:

    A wrapper to simplify LsaOpenPolicy

Arguments:

    ServerName - Supplies the server to open the policy on.  Specify
                 NULL for local machine.

    DesiredAccess - The access flags passed to the LSA API

    policyHandle - Receives the policy handle if successful

Return value:

    NT status code indicating outcome

--*/

{
    LSA_OBJECT_ATTRIBUTES objectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server;

    //
    // Always initialize the object attributes to all zeroes
    //
    ZeroMemory (&objectAttributes, sizeof(objectAttributes));

    if (ServerName != NULL) {
        //
        // Make a LSA_UNICODE_STRING out of the PWSTR passed in
        //
        InitLsaString (&ServerString, ServerName);

        Server = &ServerString;
    } else {
        Server = NULL;
    }

    //
    // Attempt to open the policy
    //
    return LsaOpenPolicy (
                Server,
                &objectAttributes,
                DesiredAccess,
                policyHandle
                );
}


BOOL
IsDomainController(
    IN      PWSTR Server,
    OUT     PBOOL DomainControllerFlag
    )

/*++

Routine Description:

    Queries if the machine is a server or workstation via
    the NetServerGetInfo API.

Arguments:

    Server - The machine to query, or NULL for the local machine

    DomainControllerFlag - Receives TRUE if the machine is a
                           domain controller, or FALSE if the
                           machine is a workstation.

Return value:

    TRUE if the API was successful, or FALSE if not.  GetLastError
    gives failure code.

--*/


{
    PSERVER_INFO_101 si101;
    NET_API_STATUS nas;

    nas = NetServerGetInfo(
        Server,
        101,    // info-level
        (PBYTE *) &si101
        );

    if (nas != NO_ERROR) {
        SetLastError (nas);
        return FALSE;
    }

    if ((si101->sv101_type & SV_TYPE_DOMAIN_CTRL) ||
        (si101->sv101_type & SV_TYPE_DOMAIN_BAKCTRL)) {
        //
        // We are dealing with a DC
        //
        *DomainControllerFlag = TRUE;
    } else {
        *DomainControllerFlag = FALSE;
    }

    NetApiBufferFree (si101);

    return TRUE;
}


DWORD
pConvertFlagsToRights (
    DWORD Flags
    )
{
    while (Flags > 0x0f) {
        Flags >>= 4;
    }

    if (Flags & 0x01) {
        return 0;
    }

    if (Flags == 0x02) {
        return ACCESS_READ;
    }

    if (Flags == 0x04) {
        return ACCESS_WRITE;
    }

    if ((Flags & 0x06) == 0x06) {
        return ACCESS_READ|ACCESS_WRITE;
    }

    DEBUGMSG ((DBG_WHOOPS, "Undefined access flags specified: 0x%X", Flags));

    return 0;
}


DWORD
SetRegKeySecurity (
    IN      PCTSTR KeyStr,
    IN      DWORD DaclFlags,            OPTIONAL
    IN      PSID Owner,                 OPTIONAL
    IN      PSID PrimaryGroup,          OPTIONAL
    IN      BOOL Recursive
    )

/*++

Routine Description:

  SetRegKeySecurity updates the security of a registry key, or an entire
  registry node.  The caller can change the DACL, owner or primary group.
  Change of the SACL is intentionally not implemented.

Arguments:

  KeyStr       - Specifies the key to modify the permissions.  If Recursive
                 is set to TRUE, this key will be updated along with all
                 subkeys.
  DaclFlags    - Specifies zero or more SF_* flags, indicating how access to
                 the key should be set.
  Owner        - Specifies the SID of the new owner.
  PrimaryGroup - Specifies the SID of the primary group.
  Recursive    - Specifies TRUE to apply the security to the key and all of
                 its subkeys, or FALSE to update the key only, leaving the
                 subkeys alone.

Return Value:

  A Win32 status code.

--*/

{
    DWORD rc = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR sd;
    GROWBUFFER AclMemberList = GROWBUF_INIT;
    HKEY Key = NULL;
    REGSAM OldSam;
    DWORD AclMembers = 0;
    PACL Acl = NULL;
    SECURITY_INFORMATION WhatToSet = 0;
    REGTREE_ENUM e;
    LONG rc2;

    _try {

        //
        // Open key with full permission
        //

        OldSam = SetRegOpenAccessMode (KEY_ALL_ACCESS);

        Key = OpenRegKeyStr (KeyStr);
        if (!Key) {
            rc = GetLastError();
            __leave;
        }

        //
        // Prepare a security descriptor
        //

        InitializeSecurityDescriptor (&sd, SECURITY_DESCRIPTOR_REVISION);

        if (Owner) {
            if (!SetSecurityDescriptorOwner (&sd, Owner, FALSE)) {
                rc = GetLastError();
                __leave;
            }

            WhatToSet |= OWNER_SECURITY_INFORMATION;
        }

        if (PrimaryGroup) {
            if (!SetSecurityDescriptorGroup (&sd, PrimaryGroup, FALSE)) {
                rc = GetLastError();
                __leave;
            }

            WhatToSet |= GROUP_SECURITY_INFORMATION;
        }

        //
        // Add the DACL
        //

        if (DaclFlags & SF_EVERYONE_MASK) {
            AddAclMember (
                &AclMemberList,
                g_EveryoneStr,
                pConvertFlagsToRights (DaclFlags & SF_EVERYONE_MASK)
                );
            AclMembers++;

        }

        if (DaclFlags & SF_ADMINISTRATORS_MASK) {
            AddAclMember (
                &AclMemberList,
                g_AdministratorsGroupStr,
                pConvertFlagsToRights (DaclFlags & SF_ADMINISTRATORS_MASK)
                );
            AclMembers++;
        }

        if (AclMembers) {
            Acl = CreateAclFromMemberList (AclMemberList.Buf, AclMembers);
            if (!Acl) {
                rc = GetLastError();
                __leave;
            }

            WhatToSet |= DACL_SECURITY_INFORMATION;
        }

        //
        // Set the security
        //

        if (Recursive) {
            DEBUGMSG_IF ((
                rc != ERROR_SUCCESS,
                DBG_WARNING,
                "RegSetKeySecurity failed for %s with rc=%u",
                KeyStr,
                rc
                ));

            if (EnumFirstRegKeyInTree (&e, KeyStr)) {
                do {

                    rc2 = RegSetKeySecurity (e.CurrentKey->KeyHandle, WhatToSet, &sd);
                    if (rc2 != ERROR_SUCCESS) {
                        rc = (DWORD) rc2;
                    }

                    DEBUGMSG_IF ((
                        rc2 != ERROR_SUCCESS,
                        DBG_WARNING,
                        "RegSetKeySecurity failed for %s with rc=%u",
                        e.FullKeyName,
                        rc2
                        ));

                } while (EnumNextRegKeyInTree (&e));
            }
        } else {
            rc = (DWORD) RegSetKeySecurity (Key, WhatToSet, &sd);
        }
    }
    __finally {
        FreeGrowBuffer (&AclMemberList);
        if (Key) {
            CloseRegKey (Key);
        }

        SetRegOpenAccessMode (OldSam);

        if (Acl) {
            FreeMemberListAcl (Acl);
        }
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\pcache.c ===
/* Copyright (c) 1992-2001, Microsoft Corporation, all rights reserved
**
** pcache.c
** Remote Access Phonebook - Win9x Password cache (PWL) decrypter
** Main routines
**
** Portions of this code have been ported from:
** Win9x\proj\net\user\src\WNET\PCACHE
**
** Whistler bug: 208318 Win9x Upg: Username and Password for DUN connectoid not
** migrated from Win9x to Whistler
**
** 06/24/92 gregj
** 03/06/01 Jeff Sigman
*/

#include "pch.h"    // Pre-compiled
#include "pcache.h" // Private pcache header
#include <rc4.h>    // RSA RC4 MD5 library
#include <md5.h>    // RSA RC4 MD5 library

//----------------------------------------------------------------------------
// Globals
//----------------------------------------------------------------------------

CHAR                 g_szPWLUsername[ UNLEN + 1 ];
CHAR                 g_szPWLPassword[ PWLEN + 1 ];
HANDLE               g_hFile = NULL;
RC4_KEYSTRUCT        g_ks;
NEW_PLAINTEXT_HEADER g_hdrPlaintext;
NEW_ENCRYPTED_HEADER g_hdrEncrypted;

//-----------------------------------------------------------------------------
// Routines
//-----------------------------------------------------------------------------

UINT
HashName (
    const CHAR* pbResource,
    WORD        cbResource
    )
{
    return cbResource ? ( ( *pbResource ) % BUCKET_COUNT ) : 0;
}

VOID
Encrypt (
    CHAR *pbSource,
    WORD cbSource,
    CHAR *pbDest
    )
{
    if ( pbDest )
    {
        memcpy ( pbDest, pbSource, cbSource );
        pbSource = pbDest;
    }

    rc4 ( &g_ks, cbSource, pbSource );

    return;
}

VOID
Decrypt (
    CHAR *pbSource,
    WORD cbSource
    )
{
    Encrypt ( pbSource, cbSource, NULL );

    return;
}

VOID
ENCRYPTER (
    const CHAR* pszUsername,
    const CHAR* pszPassword,
    UINT        iBucket,
    DWORD       dwSalt
    )
{
    UCHAR   md5_hash[ 16 ];
    MD5_CTX ctxBucketNumber;
    MD5_CTX ctx;

    MD5Init ( &ctxBucketNumber );

    MD5Update (
        &ctxBucketNumber,
        (UCHAR* )&iBucket,
        sizeof( iBucket ) );

    MD5Update (
        &ctxBucketNumber,
        (UCHAR* )pszUsername,
        strlen ( pszUsername ) + 1 );

    MD5Update ( &ctxBucketNumber, (UCHAR* )&dwSalt, sizeof( dwSalt ) );
    MD5Final ( &ctxBucketNumber );

    MD5Init ( &ctx );
    MD5Update (
        &ctx,
        (UCHAR* )pszPassword,
        strlen ( pszPassword ) + 1 );

    MD5Update (
        &ctx,
        (UCHAR* )ctxBucketNumber.digest,
        sizeof( ctxBucketNumber.digest ) );

    MD5Final ( &ctx );

    memcpy ( md5_hash, ctx.digest, sizeof( md5_hash ) );
    memset ( (CHAR * )&ctx, '\0', sizeof( ctx ));
    memset ( (CHAR * )&ctxBucketNumber, '\0', sizeof( ctxBucketNumber ) );

    rc4_key ( &g_ks, sizeof( md5_hash ), (UCHAR * )&md5_hash );
}

DWORD
ReadData (
    WORD  ibSeek,
    PVOID pbBuffer,
    WORD  cbBuffer
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD cbRead = 0;

    if ( ( SetFilePointer (
            g_hFile, ibSeek, NULL,
            FILE_BEGIN ) == 0xffffffff ) ||
        ( !ReadFile (
            g_hFile, pbBuffer, cbBuffer,
            &cbRead, NULL ) ) )
    {
        return GetLastError ( );
    }

    return ( cbRead < cbBuffer ) ? IERR_CacheCorrupt : ERROR_SUCCESS;
}

VOID
AssembleFindCacheName (
    CHAR* pszWindir,
    CHAR* pszResult
    )
{
    CHAR  szFind[ 6 ];
    CHAR* Current = szFind;
    DWORD i;

    strncpy ( pszResult, pszWindir, MAX_PATH - strlen(pszResult) );
    strncat ( pszResult, S_PWLDIR, MAX_PATH - strlen(pszResult) );
    strncat ( pszResult, "\\", MAX_PATH - strlen(pszResult) );

    for ( i = 0; (i < 5) && (i < strlen(g_szPWLUsername)); i++ )
    {
        *(Current++) = g_szPWLUsername[ i ];
        *Current = '\0';
    }

    if ( Current != szFind )
    {
        strncat ( pszResult, szFind, MAX_PATH - strlen(pszResult) );
    }

    strncat ( pszResult, S_SRCHPWL, MAX_PATH - strlen(pszResult) );
}

DWORD
OpenCacheFile (
    VOID
    )
{
    CHAR   szFind[ MAX_PATH + 1 ];
    CHAR   szWindir[ MAX_PATH + 1 ];
    CHAR   szFilename[ MAX_PATH + 1 ];
    DWORD  dwErr;
    HANDLE hFile;

    do
    {
        if ( !GetWindowsDirectoryA (szWindir, sizeof(szWindir) ) )
        {
            dwErr = ERROR_FILE_NOT_FOUND;
            break;
        }

        AssembleFindCacheName ( szWindir, szFind );

        DEBUGMSGA ((S_DBG_RAS, "AssembleFindCacheName: %s", szFind));

        dwErr = FindNewestFile ( szFind );
        BREAK_ON_DWERR( dwErr );

        strcpy ( szFilename, szWindir );
        strcat ( szFilename, S_PWLDIR );
        strcat ( szFilename, szFind );

        DEBUGMSGA ((S_DBG_RAS, "FindNewestFile: %s", szFind));

        hFile = CreateFileA (
                        szFilename,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_RANDOM_ACCESS,
                        NULL );
        if ( hFile == INVALID_HANDLE_VALUE )
        {
            dwErr = GetLastError ( );
            break;
        }

        DEBUGMSGA ((S_DBG_RAS, "CreateFileA: %s", szFilename));

        g_hFile = hFile;

    } while ( FALSE );

    return dwErr;
}

DWORD
ReadAndDecrypt (
    WORD  ibSeek,
    PVOID pbBuffer,
    WORD  cbBuffer
    )
{
    DWORD dwErr = ReadData ( ibSeek, pbBuffer, cbBuffer );

    if ( dwErr )
    {
        return dwErr;
    }

    Decrypt ( (CHAR* )pbBuffer, cbBuffer );

    return ERROR_SUCCESS;
}

INT
CompareCacheNames (
    const CHAR* pbRes1,
    WORD        cbRes1,
    const CHAR* pbRes2,
    WORD        cbRes2
    )
{
    INT nRet = memcmp ( pbRes1, pbRes2, min ( cbRes1, cbRes2 ) );

//    DEBUGMSGA ((S_DBG_RAS, "CompareCacheNames"));
//    DEBUGMSGA ((S_DBG_RAS, "1 - %s", pbRes1));
//    DEBUGMSGA ((S_DBG_RAS, "2 - %s", pbRes2));

    if (nRet != 0)
    {
        return nRet;
    }

    return ( cbRes1 < cbRes2 ) ? -1 : ( ( cbRes1 == cbRes2 ) ? 0 : 1 );
}

DWORD
LoadEncryptedHeader (
    VOID
    )
{
    const UINT cbFirst = FIELDOFFSET ( NEW_ENCRYPTED_HEADER, aibBuckets );
    const UINT IBUCKET_HEADER = 0xffffffff;
    DWORD dwErr = ERROR_SUCCESS;

    do
    {
        ENCRYPTER (
            g_szPWLUsername,
            g_szPWLPassword,
            IBUCKET_HEADER,
            g_hdrPlaintext.adwBucketSalts[ BUCKET_COUNT ] );

        dwErr = ReadAndDecrypt (
                    (WORD )g_hdrPlaintext.cbHeader,
                    &g_hdrEncrypted,
                    (WORD )cbFirst );
        BREAK_ON_DWERR( dwErr );

        // All aibBuckets except the first and last are stored in the file
        //
        dwErr = ReadAndDecrypt (
                    (WORD )g_hdrPlaintext.cbHeader + cbFirst,
                    (LPSTR )( &g_hdrEncrypted.aibBuckets[ 1 ] ),
                    sizeof( g_hdrEncrypted.aibBuckets ) -
                        ( sizeof( g_hdrEncrypted.aibBuckets[ 0 ] ) * 2) );
        BREAK_ON_DWERR( dwErr );

        // Generate the first and last aibBuckets values on the fly
        //
        g_hdrEncrypted.aibBuckets[ 0 ] =
            (USHORT )( g_hdrPlaintext.cbHeader + sizeof( NEW_ENCRYPTED_HEADER )
                       - sizeof( g_hdrEncrypted.aibBuckets[ 0 ] ) * 2 );

        g_hdrEncrypted.aibBuckets[ BUCKET_COUNT ] =
            (USHORT )GetFileSize ( g_hFile, NULL );

    } while ( FALSE );

    return dwErr;
}

DWORD
LoadPlaintextHeader (
    VOID
    )
{
    DWORD dwErr = ReadData ( 0, &g_hdrPlaintext, sizeof( g_hdrPlaintext ) );

    if ( dwErr )
    {
        return dwErr;
    }

    if ( g_hdrPlaintext.ulSig != NEW_PLAINTEXT_SIGNATURE )
    {
        return ERROR_SUCCESS; // no key blobs, for sure 
    }

    // If there are any key blobs, read them all in a chunk (the remainder of
    // the header) Otherwise we've already got the whole thing
    //
    if ( g_hdrPlaintext.cbHeader > sizeof( g_hdrPlaintext ) )
    {
        return ReadData (
                sizeof( g_hdrPlaintext ),
                ((CHAR* )&g_hdrPlaintext) + sizeof( g_hdrPlaintext ),
                ((WORD )g_hdrPlaintext.cbHeader) - sizeof( g_hdrPlaintext ) );
    }
    else
    {
        return ERROR_SUCCESS;
    }
}

DWORD
LookupEntry (
    const CHAR*            pbResource,
    WORD                   cbResource,
    UCHAR                  nType,
    PASSWORD_CACHE_ENTRY** ppce
    )
{
    UINT  iBucket = HashName ( pbResource, cbResource );
    WORD  ibEntry = g_hdrEncrypted.aibBuckets[ iBucket ]; // offs of 1st entry
    WORD  cbEntry;
    DWORD dwErr;
    PASSWORD_CACHE_ENTRY* pce = NULL;

    ENCRYPTER ( g_szPWLUsername, g_szPWLPassword, iBucket,
        g_hdrPlaintext.adwBucketSalts[ iBucket ] );

    dwErr = ReadAndDecrypt ( ibEntry, &cbEntry, sizeof( cbEntry ) );
    if ( dwErr )
    {
        return dwErr;
    }

    ibEntry += sizeof( cbEntry );

    if ( !cbEntry )
    {
        return IERR_CacheEntryNotFound;
    }

    pce = ( PASSWORD_CACHE_ENTRY* ) LocalAlloc (
                                        LMEM_FIXED,
                                        MAX_ENTRY_SIZE + sizeof( cbEntry ) );
    if ( pce == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    while ( !( cbEntry & PCE_END_MARKER ) )
    {

        if ( cbEntry > MAX_ENTRY_SIZE )
        {
            dwErr = IERR_CacheCorrupt;
            break;
        }

        dwErr = ReadAndDecrypt ( ibEntry,
                    ((CHAR* )pce) + sizeof( cbEntry ),
                    cbEntry );
        BREAK_ON_DWERR( dwErr );

        pce->cbEntry = cbEntry; // we read this earlier, set it manually


//        DEBUGMSGA ((S_DBG_RAS, "LookupEntry: Searching for %s", pbResource));
        if (nType == pce->nType && !CompareCacheNames ( pbResource, cbResource,
                                        pce->abResource, pce->cbResource ))
        {
            DEBUGMSGA ((S_DBG_RAS, "LookupEntry: Match Found"));
            break; // dwErr == ERROR_SUCCESS
        }

        ibEntry += cbEntry;
        cbEntry = NEXT_PCE(pce)->cbEntry; // fetch next entry's length
    }

    if ( ( cbEntry & PCE_END_MARKER ) || dwErr != ERROR_SUCCESS )
    {
        LocalFree ( pce );
        pce = NULL;
        DEBUGMSGA ((S_DBG_RAS, "LookupEntry: Nothing Found"));
        return ( cbEntry & PCE_END_MARKER ) ? IERR_CacheEntryNotFound : dwErr;
    }

    *ppce = pce;

    return ERROR_SUCCESS;
}

DWORD
ValidateEncryptedHeader (
    VOID
    )
{
    MD5_CTX ctx;

    MD5Init ( &ctx );
    MD5Update ( &ctx, (UCHAR* )g_szPWLUsername,
        strlen( g_szPWLUsername ) + 1 );

    MD5Update (
        &ctx,
        (UCHAR* )g_hdrEncrypted.abRandomPadding,
        sizeof( g_hdrEncrypted.abRandomPadding ) );

    MD5Final ( &ctx );

    if ( memcmp (
            ctx.digest,
            g_hdrEncrypted.abAuthenticationHash,
            sizeof( ctx.digest ) ) )
    {
        return IERR_IncorrectUsername;
    }

    return ERROR_SUCCESS;
}

DWORD
FindPWLResource (
    const CHAR* pbResource,
    WORD        cbResource,
    CHAR*       pbBuffer,
    WORD        cbBuffer,
    UCHAR       nType
    )
{
    DWORD                 dwErr = ERROR_SUCCESS;
    CACHE_ENTRY_INFO*     pcei = (CACHE_ENTRY_INFO* )pbBuffer;
    PASSWORD_CACHE_ENTRY* pce = NULL;

    do
    {
        if ( cbBuffer < sizeof( CACHE_ENTRY_INFO ) )
        {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        dwErr = LookupEntry ( pbResource, cbResource, nType, &pce );
        BREAK_ON_DWERR( dwErr );

        pcei->cbResource = pce->cbResource;
        pcei->cbPassword = pce->cbPassword;
        pcei->iEntry = pce->iEntry;
        pcei->nType = pce->nType;
        pcei->dchResource = 0;
        pcei->dchPassword = 0;

        cbBuffer -= sizeof( CACHE_ENTRY_INFO );
        if ( pce->cbResource > cbBuffer )
        {
            dwErr = ERROR_MORE_DATA;
            break;
        }

        pcei->dchResource = sizeof( CACHE_ENTRY_INFO );
        memcpy ( pbBuffer + pcei->dchResource,
            pce->abResource, pce->cbResource );

        cbBuffer -= pce->cbResource;
        if ( pce->cbPassword > cbBuffer )
        {
            dwErr = ERROR_MORE_DATA;
            break;
        }

        pcei->dchPassword = pcei->dchResource + pcei->cbResource;
        memcpy ( pbBuffer + pcei->dchPassword,
            pce->abResource + pce->cbResource,
            pce->cbPassword );

    } while ( FALSE );
    //
    // Clean up
    //
    if ( pce )
    {
        LocalFree ( pce );
        pce = NULL;
    }

    return dwErr;
}

DWORD
FindNewestFile (
    IN OUT CHAR* SourceName
    )
{
    CHAR             szCurFile[ MAX_PATH + 1 ];
    HANDLE           SourceHandle;
    LARGE_INTEGER    SourceFileTime, NextFileTime;
    WIN32_FIND_DATAA SourceFileData;

    SourceHandle = FindFirstFileA ( SourceName, &SourceFileData );
    if ( INVALID_HANDLE_VALUE == SourceHandle )
    {
        return ERROR_FILE_NOT_FOUND;
    }

    SourceFileTime.LowPart  = SourceFileData.ftLastWriteTime.dwLowDateTime;
    SourceFileTime.HighPart = SourceFileData.ftLastWriteTime.dwHighDateTime;
    strcpy ( szCurFile, SourceFileData.cFileName );

    do
    {
        if ( !FindNextFileA (SourceHandle, &SourceFileData) )
        {
            break;
        }

        NextFileTime.LowPart  = SourceFileData.ftLastWriteTime.dwLowDateTime;
        NextFileTime.HighPart = SourceFileData.ftLastWriteTime.dwHighDateTime;

        if ( NextFileTime.QuadPart > SourceFileTime.QuadPart )
        {
            SourceFileTime.LowPart  = NextFileTime.LowPart;
            SourceFileTime.HighPart = NextFileTime.HighPart;
            strcpy ( szCurFile, SourceFileData.cFileName );
        }

    } while ( TRUE );

    strcpy ( SourceName, "\\" );
    strcat ( SourceName, szCurFile );
    //
    // Clean up
    //
    FindClose ( SourceHandle );

    return ERROR_SUCCESS;
}

VOID
DeleteAllPwls (
    VOID
    )
{
    CHAR  szWindir[ MAX_PATH + 1 ];
    PCSTR pszPath = NULL;

    DEBUGMSGA ((S_DBG_RAS, "DeleteAllPwls"));

    do
    {
        //
        // Whistler bug: 427175 427176 PREFIX
        //
        if ( !GetWindowsDirectoryA ( szWindir, MAX_PATH ) ) {break;}
        DEBUGMSGA ((S_DBG_RAS, "GetWindowsDirectoryA %s", szWindir ));

        pszPath = JoinPathsA (szWindir, S_PWLDIR);
        if (!pszPath) {break;}

        if (DeleteDirectoryContentsA (pszPath))
        {
            if (RemoveDirectoryA (pszPath))
            {
                DEBUGMSGA ((S_DBG_RAS, "DeleteAllPwls: Success!"));
            }
            ELSE_DEBUGMSGA ((S_DBG_RAS, "Could not delete the tree %s.", pszPath));
        }
        ELSE_DEBUGMSGA ((S_DBG_RAS, "Could not delete the contents of %s.", pszPath));

    } while ( FALSE );
    //
    // Clean up
    //
    if (pszPath)
    {
        FreePathStringA (pszPath);
    }

    return;
}

//
// Whistler bug: 417745 INTL:Win9x Upg: DBCS chars cause User,Domain,
// Passwrds to not be migrated for DUN
//
BOOL
StrCpyAFromWUsingAnsiEncoding(
    LPSTR   pszDst,
    LPCWSTR pszSrc,
    DWORD   dwDstChars
    )
{
    DWORD cb;

    cb = WideCharToMultiByte(
            CP_ACP, 0, pszSrc, -1,
            pszDst, dwDstChars, NULL, NULL );

    if (cb == 0)
    {
        DEBUGMSGA ((S_DBG_RAS, "StrCpyAFromWUsingAnsiEncoding fail"));
        return TRUE;
    }

    // Success
    return FALSE;
}

//
// Whistler bug: 417745 INTL:Win9x Upg: DBCS chars cause User,Domain,
// Passwrds to not be migrated for DUN
//
BOOL
StrCpyWFromAUsingAnsiEncoding(
    WCHAR* pszDst,
    LPCSTR pszSrc,
    DWORD  dwDstChars
    )
{
    DWORD cb;

    *pszDst = L'\0';
    cb = MultiByteToWideChar( CP_ACP, 0, pszSrc, -1, pszDst, dwDstChars );
    if (cb == 0)
    {
        DEBUGMSGA ((S_DBG_RAS, "StrCpyWFromAUsingAnsiEncoding fail"));
        return TRUE;
    }

    // Success
    return FALSE;
}

VOID
CopyAndTruncate (
    LPSTR  lpszDest,
    LPCSTR lpszSrc,
    UINT   cbDest,
    BOOL   flag
    )
{
    strncpy ( lpszDest, lpszSrc, cbDest - 1 );
    //
    // strncpyf() won't null-terminate if src > dest
    //
    lpszDest[ cbDest - 1 ] = '\0';

    if ( flag )
    {
        CharUpperBuffA ( lpszDest, cbDest - 1 );
        CharToOemA ( lpszDest, lpszDest );
    }
}

DWORD
OpenPWL (
    CHAR* Username,
    CHAR* Password,
    BOOL  flag
    )
{
    DWORD dwErr = ERROR_SUCCESS;

    do
    {
        CopyAndTruncate ( g_szPWLUsername, Username,
            sizeof( g_szPWLUsername ), flag );

        CopyAndTruncate ( g_szPWLPassword, Password,
            sizeof( g_szPWLPassword ), flag );

        ZeroMemory ( &g_hdrPlaintext, sizeof(g_hdrPlaintext) );
        ZeroMemory ( &g_hdrEncrypted, sizeof(g_hdrEncrypted) );

        dwErr = OpenCacheFile ( );
        if ( dwErr )
        {
            DEBUGMSGA ((S_DBG_RAS, "OpenCacheFile fail"));
            break;
        }

        dwErr = LoadPlaintextHeader ( );
        if ( dwErr )
        {
            DEBUGMSGA ((S_DBG_RAS, "LoadPlaintextHeader fail"));
            break;
        }

        if ( g_hdrPlaintext.ulSig == PLAINTEXT_SIGNATURE )
        {
            DEBUGMSGA ((S_DBG_RAS, "PLAINTEXT_SIGNATURE fail"));
            dwErr = IERR_BadSig;
            break;
        }

        if ( g_hdrPlaintext.ulSig != NEW_PLAINTEXT_SIGNATURE )
        {
            DEBUGMSGA ((S_DBG_RAS, "NEW_PLAINTEXT_SIGNATURE fail"));
            dwErr = IERR_BadSig;
            break;
        }

        dwErr = LoadEncryptedHeader ( );
        if ( dwErr )
        {
            DEBUGMSGA ((S_DBG_RAS, "LoadEncryptedHeader fail"));
            break;
        }

        dwErr = ValidateEncryptedHeader ( );
        if ( dwErr )
        {
            DEBUGMSGA ((S_DBG_RAS, "ValidateEncryptedHeader fail"));
            break;
        }

    } while ( FALSE );

    return dwErr;
}

DWORD
FindPWLString (
    IN CHAR*     EntryName,
    IN CHAR*     ConnUser,
    IN OUT CHAR* Output
    )
{
    CHAR   resource[ MAX_PATH * 2 ];
    DWORD  dwErr = ERROR_SUCCESS;
    DWORD  cbCopied = 0;
    LPBYTE pcei = NULL;

    do
    {
        // Allocate a buffer for the cache entry info
        //
        if ( ( pcei = (LPBYTE )LocalAlloc ( LMEM_FIXED,
                                sizeof( CACHE_ENTRY_INFO ) +
                                ( RAS_MaxPortName + 1 ) +
                                ( MAX_PATH + 1 ) ) ) == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        //
        // Whistler bug: 417745 INTL:Win9x Upg: DBCS chars cause User,Domain,
        // Passwrds to not be migrated for DUN
        //
        _snprintf(resource, sizeof(resource) - 1,
            S_RESOURCEMASK2, EntryName, ConnUser);

        DEBUGMSGA ((S_DBG_RAS, "FindPWLString: %s", resource));

        dwErr = FindPWLResource ( resource, (WORD )strlen( resource ), pcei,
                    sizeof( CACHE_ENTRY_INFO ) + ( RAS_MaxPortName + 1 ) +
                    ( MAX_PATH + 1 ), PCE_MISC );
        if ( dwErr )
        {
          dwErr = ERROR_INVALID_PASSWORD;
          break;
        }

        cbCopied = min( MAX_PATH,((CACHE_ENTRY_INFO* )pcei)->cbPassword );

        // Copy a non null-terminated string for password and terminate it with
        // a null character
        //
        if ( !cbCopied )
        {
            dwErr = ERROR_INVALID_PASSWORD;
            break;
        }

        memcpy ( Output,
            pcei+(((CACHE_ENTRY_INFO*)pcei)->dchPassword),
            cbCopied );

        Output[ cbCopied ] = '\0';

    } while ( FALSE );

    // Clean up
    //
    if ( pcei )
    {
        ZeroMemory ( pcei, sizeof( CACHE_ENTRY_INFO ) +
                            ( RAS_MaxPortName + 1 ) +
                            ( MAX_PATH + 1 ) );
        LocalFree ( pcei );
        pcei = NULL;
    }

    return dwErr;
}

BOOL
MigrateEntryCreds (
    IN OUT PRAS_DIALPARAMS prdp,
    IN     PCTSTR          pszEntryName,
    IN     PCTSTR          pszUserName,
    IN     PDWORD          pdwFlag
    )
{
    CHAR szEntryName[RAS_MaxPortName + 1];
    CHAR szUserName[UNLEN + 1];
    CHAR szConnUser[UNLEN + 1];
    CHAR szPassword[MAX_PATH * 2];

    do
    {
        ZeroMemory ( szEntryName, sizeof(szEntryName) );
        ZeroMemory ( szUserName, sizeof(szUserName) );
        ZeroMemory ( szConnUser, sizeof(szConnUser) );
        ZeroMemory ( szPassword, sizeof(szPassword) );
        //
        // Whistler bug: 417745 INTL:Win9x Upg: DBCS chars cause User,Domain,
        // Passwrds to not be migrated for DUN
        //
        if ( StrCpyAFromWUsingAnsiEncoding ( szEntryName, pszEntryName,
                sizeof (szEntryName) ) ||
             StrCpyAFromWUsingAnsiEncoding ( szUserName, pszUserName,
                sizeof (szUserName) ) ||
             StrCpyAFromWUsingAnsiEncoding ( szConnUser, prdp->DP_UserName,
                sizeof (szConnUser) ) )
        {
            DEBUGMSGA ((S_DBG_RAS, "MigrateEntryCreds: Init Conversion Fail" ));
            break;
        }

        if (OpenPWL ( szUserName, "", TRUE ))
        {
            DEBUGMSGA ((S_DBG_RAS, "MigrateEntryCreds: OpenPWL fail"));
            break;
        }

        if (FindPWLString ( szEntryName, szConnUser, szPassword ))
        {
            DEBUGMSGA ((S_DBG_RAS, "MigrateEntryCreds: FindPWLString fail"));
            break;
        }

        if (StrCpyWFromAUsingAnsiEncoding (prdp->DP_Password, szPassword,
            PWLEN ))
        {
            DEBUGMSGA ((S_DBG_RAS, "MigrateEntryCreds: Password Conversion Fail" ));
            break;
        }

        DEBUGMSGA ((S_DBG_RAS, "MigrateEntryCreds success"));
        *pdwFlag |= DLPARAMS_MASK_PASSWORD;

    } while ( FALSE );
    //
    // Clean up
    //
    ZeroMemory( szPassword, sizeof( szPassword ) );

    if ( g_hFile )
    {
        CloseHandle ( g_hFile );
        g_hFile = NULL;
    }

    if (*pdwFlag)
    {
        // Success
        *pdwFlag |= DLPARAMS_MASK_OLDSTYLE;
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\shell.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    shell.c

Abstract:

    Contains code that implements shell folder migration.  Shell folders
    are moved into new NT locations whenever possible.  Also, a set of
    filters alter the content of the shell folders.

Author:

    Jim Schmidt (jimschm) 24-Aug-1998

Revision History:

    Calin Negreanu (calinn) 09-Sep-1998     Obsolete links, fixes and other changes

--*/

#include "pch.h"
#include <linkpif.h>
#include "migmainp.h"

#define DBG_SHELL       "Shell"

#define SHELL_FOLDER_FILTERS_9X_NT                          \
    DEFMAC(pObsoleteLinksFilter)                            \
    DEFMAC(pStartupDisableFilter)                           \
    DEFMAC(pFontNameFilter)                                 \
    DEFMAC(pCollisionDetection9xNt)                         \

#define SHELL_FOLDER_FILTERS_NT_9X                          \
    DEFMAC(pDetectOtherShellFolder)                         \
    DEFMAC(pCollisionDetectionNt9x)                         \


typedef enum {
    INITIALIZE,
    PROCESS_PATH,
    TERMINATE
} CALL_CONTEXT;


#define SHELLFILTER_OK              0
#define SHELLFILTER_SKIP_FILE       1
#define SHELLFILTER_SKIP_DIRECTORY  2
#define SHELLFILTER_ERROR           3
#define SHELLFILTER_FORCE_CHANGE    4


typedef struct {
    IN      PCWSTR Win9xUser;                       OPTIONAL
    IN      PCWSTR FixedUserName;                   OPTIONAL
    IN      HKEY UserHiveRoot;                      // HKLM or the Default User hive
    IN      PCWSTR ShellFolderIdentifier;           // i.e., Fonts, Programs, etc...
    IN OUT  WCHAR TempSourcePath[MEMDB_MAX];        // full path, a child of SrcRootPath
    IN OUT  WCHAR DestinationPath[MEMDB_MAX];
    IN      PCWSTR DefaultShellFolder;              OPTIONAL
    IN      PCWSTR UserDefaultLocation;
    IN      PCWSTR SrcRootPath;                     // the temp root dir
    IN      PCWSTR DestRootPath;                    // the dest root dir
    IN      PCWSTR OrigRootPath;                    // the Win9x root dir
    IN OUT  DWORD Attributes;
    IN      DWORD UserFlags;
    IN OUT  DWORD State;
    IN      PMIGRATE_USER_ENUM EnumPtr;
    IN      CALL_CONTEXT Context;
} PROFILE_MERGE_DATA, *PPROFILE_MERGE_DATA;

typedef DWORD(PROFILEMERGEFILTER_PROTOTYPE)(IN OUT PPROFILE_MERGE_DATA Data);
typedef PROFILEMERGEFILTER_PROTOTYPE * PROFILEMERGEFILTER;

typedef struct {
    PROFILEMERGEFILTER Fn;
    PCSTR Name;
    DWORD State;
} SHELL_FOLDER_FILTER, *PSHELL_FOLDER_FILTER;


#define DEFMAC(fn)      PROFILEMERGEFILTER_PROTOTYPE fn;

SHELL_FOLDER_FILTERS_9X_NT

SHELL_FOLDER_FILTERS_NT_9X

#undef DEFMAC



#define DEFMAC(fn)      {fn, #fn},

static SHELL_FOLDER_FILTER g_Filters_9xNt[] = {
    SHELL_FOLDER_FILTERS_9X_NT /* , */
    {NULL}
};

static SHELL_FOLDER_FILTER g_Filters_Nt9x[] = {
    SHELL_FOLDER_FILTERS_NT_9X /* , */
    {NULL}
};

#undef DEFMAC

GROWLIST g_SfQueueSrc;
GROWLIST g_SfQueueDest;

PVOID g_SystemSfList;
PVOID g_UserSfList;

typedef struct {
    PCTSTR sfName;
    PCTSTR sfPath;
    HKEY SfKey;
    REGVALUE_ENUM SfKeyEnum;
    BOOL UserSf;
} SF_ENUM, *PSF_ENUM;

#define MAX_SHELL_TAG       64

typedef struct {
    INT CsidlValue;
    PCTSTR Tag;
} CSIDLMAP, *PCSIDLMAP;

CSIDLMAP g_CsidlMap[] = {
    CSIDL_ADMINTOOLS, TEXT("Administrative Tools"),
    CSIDL_ALTSTARTUP, TEXT("AltStartup"),
    CSIDL_APPDATA, TEXT("AppData"),
    CSIDL_BITBUCKET, TEXT("RecycleBinFolder"),
    CSIDL_CONNECTIONS, TEXT("ConnectionsFolder"),
    CSIDL_CONTROLS, TEXT("ControlPanelFolder"),
    CSIDL_COOKIES, TEXT("Cookies"),
    CSIDL_DESKTOP, TEXT("Desktop"),
    CSIDL_DRIVES, TEXT("DriveFolder"),
    CSIDL_FAVORITES, TEXT("Favorites"),
    CSIDL_FONTS, TEXT("Fonts"),
    CSIDL_HISTORY, TEXT("History"),
    CSIDL_INTERNET, TEXT("InternetFolder"),
    CSIDL_INTERNET_CACHE, TEXT("Cache"),
    CSIDL_LOCAL_APPDATA, TEXT("Local AppData"),
    CSIDL_MYDOCUMENTS, TEXT("My Documents"),
    CSIDL_MYMUSIC, TEXT("My Music"),
    CSIDL_MYPICTURES, TEXT("My Pictures"),
    CSIDL_MYVIDEO, TEXT("My Video"),
    CSIDL_NETHOOD, TEXT("NetHood"),
    CSIDL_NETWORK, TEXT("NetworkFolder"),
    CSIDL_PERSONAL, TEXT("Personal"),
    CSIDL_PROGRAMS, TEXT("Programs"),
    CSIDL_RECENT, TEXT("Recent"),
    CSIDL_SENDTO, TEXT("SendTo"),
    CSIDL_STARTMENU, TEXT("Start Menu"),
    CSIDL_STARTUP, TEXT("Startup"),
    CSIDL_TEMPLATES, TEXT("Templates"),
    CSIDL_COMMON_ADMINTOOLS, TEXT("Common Administrative Tools"),
    CSIDL_COMMON_ALTSTARTUP, TEXT("Common AltStartup"),
    CSIDL_COMMON_APPDATA, TEXT("Common AppData"),
    CSIDL_COMMON_DESKTOPDIRECTORY, TEXT("Common Desktop"),
    CSIDL_COMMON_DOCUMENTS, TEXT("Common Documents"),
    CSIDL_COMMON_FAVORITES, TEXT("Common Favorites"),
    CSIDL_COMMON_PROGRAMS, TEXT("Common Programs"),
    CSIDL_COMMON_STARTMENU, TEXT("Common Start Menu"),
    CSIDL_COMMON_STARTUP, TEXT("Common Startup"),
    CSIDL_COMMON_TEMPLATES, TEXT("Common Templates"),
    CSIDL_COMMON_DOCUMENTS, TEXT("Common Personal"),
    CSIDL_COMMON_MUSIC, TEXT("CommonMusic"),
    CSIDL_COMMON_PICTURES, TEXT("CommonPictures"),
    CSIDL_COMMON_VIDEO, TEXT("CommonVideo"),
    0, NULL
};



VOID
pConvertCommonSfToPerUser (
    IN      PCTSTR CommonSf,
    OUT     PTSTR PerUserSf         // must hold MAX_SHELL_TAG chars
    );

BOOL
pIsCommonSf (
    IN      PCTSTR ShellFolderTag
    );

VOID
pConvertPerUserSfToCommon (
    IN      PCTSTR PerUserSf,
    OUT     PTSTR CommonSf          // must hold MAX_SHELL_TAG chars
    );


/*++

Routine Description:

  EnumFirstRegShellFolder and EnumNextRegShellFolder are enumeration routines that
  enumerate all shell folders per system or for a particular user.

Arguments:

  e         - enumeration structure
  EnumPtr   - user enumeration structure

Return Value:

  Both routines return TRUE if a new shell folder could be found, FALSE otherwise

--*/


BOOL
EnumFirstRegShellFolder (
    IN OUT  PSF_ENUM e,
    IN      BOOL UserSf
    )
{
    HKEY UsfKey;

    e->UserSf = UserSf;
    e->sfPath = NULL;

    if (UserSf) {
        e->SfKey = OpenRegKey (HKEY_CURRENT_USER, S_SHELL_FOLDERS_KEY_USER);
    } else {
        e->SfKey = OpenRegKeyStr (S_SHELL_FOLDERS_KEY_SYSTEM);
    }

    if (!e->SfKey) {
        return FALSE;
    }

    if (EnumFirstRegValue (&e->SfKeyEnum, e->SfKey)) {
        e->sfName = e->SfKeyEnum.ValueName;
        e->sfPath = NULL;

        if (UserSf) {
            UsfKey = OpenRegKey (HKEY_CURRENT_USER, S_USHELL_FOLDERS_KEY_USER);
        } else {
            UsfKey = OpenRegKeyStr (S_USHELL_FOLDERS_KEY_SYSTEM);
        }

        if (UsfKey) {
            e->sfPath = GetRegValueString (UsfKey, e->SfKeyEnum.ValueName);
            CloseRegKey (UsfKey);
        }

        if (e->sfPath == NULL) {
            e->sfPath = GetRegValueString (e->SfKey, e->SfKeyEnum.ValueName);
        }

        return TRUE;
    }

    CloseRegKey (e->SfKey);
    return FALSE;
}


BOOL
EnumNextRegShellFolder (
    IN OUT  PSF_ENUM e
    )
{
    HKEY UsfKey;

    if (e->sfPath) {
        MemFree (g_hHeap, 0, e->sfPath);
        e->sfPath = NULL;
    }

    if (EnumNextRegValue (&e->SfKeyEnum)) {

        e->sfName = e->SfKeyEnum.ValueName;
        e->sfPath = NULL;

        if (e->UserSf) {
            UsfKey = OpenRegKey (HKEY_CURRENT_USER, S_USHELL_FOLDERS_KEY_USER);
        } else {
            UsfKey = OpenRegKeyStr (S_USHELL_FOLDERS_KEY_SYSTEM);
        }

        if (UsfKey) {
            e->sfPath = GetRegValueString (UsfKey, e->SfKeyEnum.ValueName);
            CloseRegKey (UsfKey);
        }

        if (e->sfPath == NULL) {
            e->sfPath = GetRegValueString (e->SfKey, e->SfKeyEnum.ValueName);
        }

        return TRUE;
    }

    CloseRegKey (e->SfKey);
    return FALSE;
}

VOID
AbortEnumRegShellFolder (
    IN OUT  PSF_ENUM e
    )
{
    if (e->sfPath) {
        MemFree (g_hHeap, 0, e->sfPath);
        e->sfPath = NULL;
    }
}

VOID
pPrepareSfRestartability(
    VOID
    )
{
    PTSTR userProfilePath = NULL;
    DWORD Size;
    MIGRATE_USER_ENUM e;

    if (EnumFirstUserToMigrate (&e, ENUM_NO_FLAGS)) {
        do {
            if (!e.CreateOnly &&
                (e.AccountType != DEFAULT_USER_ACCOUNT) &&
                (e.AccountType != LOGON_USER_SETTINGS)
                ) {
                if (GetUserProfilePath (e.FixedUserName, &userProfilePath)) {
                    RenameOnRestartOfGuiMode (userProfilePath, NULL);
                    FreePathString (userProfilePath);
                }
            }
        } while (EnumNextUserToMigrate (&e));
    }
}

VOID
pFlushSfQueue (
    VOID
    )
{
    UINT u;
    UINT count;
    PCTSTR source;
    PCTSTR dest;

    //
    // For files that need to be copied, do that now before writing to the journal
    //

    count = GrowListGetSize (&g_SfQueueSrc);
    if (!count) {
        return;
    }

    for (u = 0 ; u < count ; u++) {

        dest = GrowListGetString (&g_SfQueueDest, u);
        if (!dest) {
            continue;
        }

        if (DoesFileExist (dest)) {

            source = GrowListGetString (&g_SfQueueSrc, u);
            MYASSERT (source);

            if (!OurCopyFileW (source, dest)) {
                LOG ((LOG_WARNING, (PCSTR)MSG_COULD_NOT_MOVE_FILE_LOG, dest, GetLastError ()));
                g_BlowAwayTempShellFolders = FALSE;
            }

            //
            // Make the string pointers NULL for this item
            //

            GrowListResetItem (&g_SfQueueSrc, u);
            GrowListResetItem (&g_SfQueueDest, u);
        }
    }

    //
    // Now record the remaining items in the journal (before the move
    // happens). Ignore journal failures. Since we are undoing the move,
    // source and dest must be flipped.
    //

    RenameListOnRestartOfGuiMode (&g_SfQueueDest, &g_SfQueueSrc);

    //
    // Do the move
    //

    for (u = 0 ; u < count ; u++) {

        source = GrowListGetString (&g_SfQueueSrc, u);
        dest = GrowListGetString (&g_SfQueueDest, u);

        if (!source || !dest) {
            continue;
        }

        if (!OurMoveFileEx (source, dest, MOVEFILE_COPY_ALLOWED | MOVEFILE_WRITE_THROUGH)) {
            if (GetLastError() == ERROR_ALREADY_EXISTS) {
                DEBUGMSG ((DBG_WARNING, "%s already exists", dest));
            } else {
                LOG ((LOG_WARNING, (PCSTR)MSG_COULD_NOT_MOVE_FILE_LOG, dest, GetLastError ()));
                g_BlowAwayTempShellFolders = FALSE;
            }
        }
    }

    //
    // Clean up -- grow lists are ready for reuse after FreeGrowList
    //

    FreeGrowList (&g_SfQueueSrc);
    FreeGrowList (&g_SfQueueDest);
}


VOID
pQueueSfMove (
    IN      PCTSTR Source,
    IN      PCTSTR Destination
    )
{
    UINT count;

    MYASSERT (Source && Destination);

    count = GrowListGetSize (&g_SfQueueSrc);
    if (count == 1000) {
        //
        // Do 1,000 moves at once
        //

        pFlushSfQueue();
    }

    GrowListAppendString (&g_SfQueueSrc, Source);
    GrowListAppendString (&g_SfQueueDest, Destination);
}


PVOID
pCreateSystemSfList (
    )
{
    PCTSTR expandedPath;
    PVOID Table;
    SF_ENUM e;

    Table = pSetupStringTableInitialize();

    if (!Table) {
        return NULL;
    }

    //
    // Load all the System shell folders into this table
    //

    if (EnumFirstRegShellFolder (&e, FALSE)) {

        do {
            expandedPath = ExpandEnvironmentText (e.sfPath);
            pSetupStringTableAddString (Table, (PVOID) expandedPath, STRTAB_CASE_INSENSITIVE);
            FreeText (expandedPath);
        } while (EnumNextRegShellFolder (&e));
    }
    return Table;
}

PVOID
pCreateUserSfList (
    IN      PPROFILE_MERGE_DATA Data
    )
{
    PTSTR CurrentUserProfilePath = NULL;
    TCHAR DefaultUserProfilePath[MAX_TCHAR_PATH];
    DWORD Size;
    PCTSTR expandedPath;
    PCTSTR tempExpand;
    PVOID Table;
    SF_ENUM e;

    if (Data && Data->FixedUserName) {

        if (!GetUserProfilePath (Data->FixedUserName, &CurrentUserProfilePath)) {
            return NULL;
        }
    }
    else {
        Size = sizeof (DefaultUserProfilePath);

        if (!GetDefaultUserProfileDirectory (DefaultUserProfilePath, &Size)) {
            return NULL;
        }
    }

    Table = pSetupStringTableInitialize();

    if (!Table) {
        return NULL;
    }

    //
    // Load all the System shell folders into this table
    //

    if (EnumFirstRegShellFolder (&e, TRUE)) {

        do {
            tempExpand = StringSearchAndReplace (
                            e.sfPath,
                            S_USERPROFILE_ENV,
                            CurrentUserProfilePath?CurrentUserProfilePath:DefaultUserProfilePath
                            );

            if (!tempExpand) {
                tempExpand = DuplicatePathString (e.sfPath, 0);
            }

            expandedPath = ExpandEnvironmentText (tempExpand);

            FreePathString (tempExpand);

            pSetupStringTableAddString (Table, (PVOID) expandedPath, STRTAB_CASE_INSENSITIVE);

            FreeText (expandedPath);

        } while (EnumNextRegShellFolder (&e));
    }

    if (CurrentUserProfilePath) {
        FreePathString (CurrentUserProfilePath);
        CurrentUserProfilePath = NULL;
    }
    return Table;
}

VOID
pDestroySfList (
    IN      PVOID Table
    )
{
    if (Table) {
        pSetupStringTableDestroy (Table);
    }
}

PVOID g_LinkDataPool = NULL;

typedef struct _LINK_DATA {
    PCTSTR Target;
    PCTSTR Arguments;
    PCTSTR ShellFolderName;
    struct _LINK_DATA *Next;
} LINK_DATA, *PLINK_DATA;

PVOID g_FoldersTable;
PVOID g_Merged9xFolders;

typedef struct _LINK_RENAME_DATA {
    PCTSTR OldTarget;
    PCTSTR NewTarget;
    PCTSTR OldArguments;
    PCTSTR NewArguments;
    PCTSTR ShellFolderName;
    struct _LINK_RENAME_DATA *Next;
} LINK_RENAME_DATA, *PLINK_RENAME_DATA;

PLINK_RENAME_DATA g_LinkRenameData;

VOID
pAddAllLinksToList (
    PTSTR AllocBuffer,          // MEMDB_MAX * 4, caller-owned for less allocs
    PCTSTR ShellFolderName,
    PCTSTR RootPath,
    IShellLink *ShellLink,
    IPersistFile *PersistFile
    )
{
    TREE_ENUM e;
    PTSTR ShortcutTarget;
    PTSTR ShortcutArgs;
    PTSTR ShortcutWorkDir;
    PTSTR ShortcutIconPath;
    INT   ShortcutIcon;
    WORD  ShortcutHotKey;
    BOOL  dosApp;
    BOOL  msDosMode;
    PLINK_DATA linkData;
    LONG stringId;

    ShortcutTarget = AllocBuffer + MEMDB_MAX;
    ShortcutArgs = ShortcutTarget + MEMDB_MAX;
    ShortcutWorkDir = ShortcutArgs + MEMDB_MAX;
    ShortcutIconPath = ShortcutWorkDir + MEMDB_MAX;

    if (EnumFirstFileInTree (&e, RootPath, NULL, FALSE)) {

        do {
            if (e.Directory) {
                if (((g_SystemSfList) && (pSetupStringTableLookUpString (g_SystemSfList, (PVOID) e.FullPath, STRTAB_CASE_INSENSITIVE) != -1)) ||
                    ((g_UserSfList) && (pSetupStringTableLookUpString (g_UserSfList, (PVOID) e.FullPath, STRTAB_CASE_INSENSITIVE) != -1))
                    ) {
                    AbortEnumCurrentDir (&e);
                }
                continue;
            }

            DEBUGMSG ((DBG_SHELL, "Extracting shortcut info for enumerated file %s", e.FullPath));

            if (ExtractShortcutInfo (
                    ShortcutTarget,
                    ShortcutArgs,
                    ShortcutWorkDir,
                    ShortcutIconPath,
                    &ShortcutIcon,
                    &ShortcutHotKey,
                    &dosApp,
                    &msDosMode,
                    NULL,
                    NULL,
                    e.FullPath,
                    ShellLink,
                    PersistFile
                    )) {
                linkData = (PLINK_DATA) (PoolMemGetMemory (g_LinkDataPool, sizeof (LINK_DATA)));
                ZeroMemory (linkData, sizeof (LINK_DATA));

                linkData->Target = PoolMemDuplicateString (g_LinkDataPool, ShortcutTarget);
                linkData->Arguments = PoolMemDuplicateString (g_LinkDataPool, ShortcutArgs);
                linkData->ShellFolderName = PoolMemDuplicateString (g_LinkDataPool, ShellFolderName);
                linkData->Next = NULL;

                DEBUGMSG ((DBG_SHELL, "Recording NT default shortcut: %s in %s", e.FullPath, ShellFolderName));

                stringId = pSetupStringTableLookUpString (g_FoldersTable, (PTSTR)ShellFolderName, 0);

                if (stringId != -1) {
                    pSetupStringTableGetExtraData (g_FoldersTable, stringId, &linkData->Next, sizeof (PLINK_DATA));
                    pSetupStringTableSetExtraData (g_FoldersTable, stringId, &linkData, sizeof (PLINK_DATA));
                }
                else {
                    pSetupStringTableAddStringEx (
                        g_FoldersTable,
                        (PTSTR)ShellFolderName,
                        STRTAB_CASE_INSENSITIVE,
                        &linkData,
                        sizeof (PLINK_DATA)
                        );
                }
            }
        } while (EnumNextFileInTree (&e));
    }
}

VOID
pAddKnownLinks (
    VOID
    )
{
    INFCONTEXT context;
    TCHAR field[MEMDB_MAX];
    BOOL result = FALSE;
    PLINK_DATA linkData;
    PCTSTR pathExp;
    LONG stringId;

    PCTSTR ArgList [4] = {TEXT("ProgramFiles"), g_ProgramFiles, NULL, NULL};

    MYASSERT (g_WkstaMigInf);

    if (SetupFindFirstLine (g_WkstaMigInf, S_KNOWN_NT_LINKS, NULL, &context)) {

        do {
            linkData = (PLINK_DATA) (PoolMemGetMemory (g_LinkDataPool, sizeof (LINK_DATA)));
            ZeroMemory (linkData, sizeof (LINK_DATA));
            result = FALSE;

            __try {

                if (!SetupGetStringField (&context, 1, field, MEMDB_MAX, NULL)) {
                    __leave;
                }
                pathExp = ExpandEnvironmentTextEx (field, ArgList);
                linkData->Target = PoolMemDuplicateString (g_LinkDataPool, pathExp);
                FreeText (pathExp);

                if (!SetupGetStringField (&context, 2, field, MEMDB_MAX, NULL)) {
                    __leave;
                }
                pathExp = ExpandEnvironmentTextEx (field, ArgList);
                linkData->Arguments = PoolMemDuplicateString (g_LinkDataPool, pathExp);
                FreeText (pathExp);

                if (!SetupGetStringField (&context, 3, field, MEMDB_MAX, NULL)) {
                    __leave;
                }
                linkData->ShellFolderName = PoolMemDuplicateString (g_LinkDataPool, field);
                linkData->Next = NULL;
                result = TRUE;
            }
            __finally {

                if (result) {
                    DEBUGMSG ((DBG_SHELL, "Recording known link: %s in %s", linkData->Target, linkData->ShellFolderName));

                    stringId = pSetupStringTableLookUpString (g_FoldersTable, (PTSTR)linkData->ShellFolderName, 0);

                    if (stringId != -1) {
                        pSetupStringTableGetExtraData (g_FoldersTable, stringId, &linkData->Next, sizeof (PLINK_DATA));
                        pSetupStringTableSetExtraData (g_FoldersTable, stringId, &linkData, sizeof (PLINK_DATA));
                    }
                    else {
                        pSetupStringTableAddStringEx (
                            g_FoldersTable,
                            (PTSTR)linkData->ShellFolderName,
                            STRTAB_CASE_INSENSITIVE,
                            &linkData,
                            sizeof (PLINK_DATA)
                            );
                    }
                }
                else {

                    if (linkData->Target) {
                        PoolMemReleaseMemory (g_LinkDataPool, (PVOID)linkData->Target);
                    }

                    if (linkData->Arguments) {
                        PoolMemReleaseMemory (g_LinkDataPool, (PVOID)linkData->Arguments);
                    }

                    if (linkData->ShellFolderName) {
                        PoolMemReleaseMemory (g_LinkDataPool, (PVOID)linkData->ShellFolderName);
                    }
                    PoolMemReleaseMemory (g_LinkDataPool, (PVOID)linkData);
                    linkData = NULL;
                }
            }
        } while (SetupFindNextLine (&context, &context));
    }
}

VOID
pCreateLinksList (
    VOID
    )
{
    SF_ENUM e;
    PCTSTR expandedPath;
    UINT commonLen;
    DWORD Size;
    PCTSTR tempExpand;
    PTSTR DefaultUserProfilePath;
    IShellLink *shellLink;
    IPersistFile *persistFile;
    PTSTR perUserName;
    PTSTR bigBuf = NULL;

    __try {
        bigBuf = (PTSTR) MemAllocUninit ((MEMDB_MAX * 4 + MAX_TCHAR_PATH + MAX_SHELL_TAG) * sizeof (TCHAR));
        if (!bigBuf) {
            __leave;
        }

        DefaultUserProfilePath = bigBuf + MEMDB_MAX * 4;
        perUserName = DefaultUserProfilePath + MAX_TCHAR_PATH;

        g_LinkDataPool = PoolMemInitNamedPool ("LinkData Pool");

        g_FoldersTable = pSetupStringTableInitializeEx (sizeof (PLINK_DATA), 0);

        if (!g_FoldersTable) {
            DEBUGMSG((DBG_ERROR, "Cannot initialize Shell Folders table."));
            __leave;
        }

        //
        // First thing: Load links from the INF files. These are links that we know NT is going to install
        //
        pAddKnownLinks ();

        if (InitCOMLink (&shellLink, &persistFile)) {

            //
            // Go through all system shell folders and list the links
            //

            if (EnumFirstRegShellFolder (&e, FALSE)) {

                do {
                    if (*e.sfPath) {
                        expandedPath = ExpandEnvironmentText (e.sfPath);

                        pConvertCommonSfToPerUser (e.sfName, perUserName);

                        pAddAllLinksToList (bigBuf, perUserName, expandedPath, shellLink, persistFile);
                        FreeText (expandedPath);
                    }
                    ELSE_DEBUGMSG ((DBG_WARNING, "Shell Folder <%s> data is empty!", e.sfName));
                } while (EnumNextRegShellFolder (&e));
            }

            Size = MAX_TCHAR_PATH;

            if (!GetDefaultUserProfileDirectory (DefaultUserProfilePath, &Size)) {
                __leave;
            }

            //
            // Go through all user shell folders and list the links from the default user dirs
            //

            if (EnumFirstRegShellFolder (&e, TRUE)) {

                do {
                    if (*e.sfPath) {
                        tempExpand = StringSearchAndReplace (
                                        e.sfPath,
                                        S_USERPROFILE_ENV,
                                        DefaultUserProfilePath
                                        );

                        if (!tempExpand) {
                            tempExpand = DuplicatePathString (e.sfPath, 0);
                        }

                        expandedPath = ExpandEnvironmentText (tempExpand);

                        FreePathString (tempExpand);

                        pAddAllLinksToList (bigBuf, e.sfName, expandedPath, shellLink, persistFile);

                        FreeText (expandedPath);
                    }
                    ELSE_DEBUGMSG ((DBG_WARNING, "Shell Folder <%s> data is empty!", e.sfName));
                } while (EnumNextRegShellFolder (&e));
            }

            FreeCOMLink (&shellLink, &persistFile);

        }
        else {
            DEBUGMSG((DBG_ERROR, "Cannot initialize COM. Obsolete links filter will not work."));
        }
    }
    __finally {
        if (bigBuf) {
            FreeMem (bigBuf);
        }
    }
}

VOID
pCreateLinksRenameList (
    VOID
    )
{
    INFCONTEXT context;
    TCHAR field[MEMDB_MAX];
    BOOL result = FALSE;
    PLINK_RENAME_DATA linkData;
    PCTSTR pathExp;
    PCTSTR ArgList [4] = {TEXT("ProgramFiles"), g_ProgramFiles, NULL, NULL};

    MYASSERT (g_WkstaMigInf);

    if (SetupFindFirstLine (g_WkstaMigInf, S_OBSOLETE_LINKS, NULL, &context)) {

        do {
            linkData = (PLINK_RENAME_DATA) (PoolMemGetMemory (g_LinkDataPool, sizeof (LINK_RENAME_DATA)));
            ZeroMemory (linkData, sizeof (LINK_RENAME_DATA));
            result = FALSE;

            __try {

                if (!SetupGetStringField (&context, 1, field, MEMDB_MAX, NULL)) {
                    __leave;
                }
                pathExp = ExpandEnvironmentTextEx (field, ArgList);
                linkData->OldTarget = PoolMemDuplicateString (g_LinkDataPool, pathExp);
                FreeText (pathExp);

                if (!SetupGetStringField (&context, 2, field, MEMDB_MAX, NULL)) {
                    __leave;
                }
                pathExp = ExpandEnvironmentTextEx (field, ArgList);
                linkData->OldArguments = PoolMemDuplicateString (g_LinkDataPool, pathExp);
                FreeText (pathExp);

                if (!SetupGetStringField (&context, 3, field, MEMDB_MAX, NULL)) {
                    __leave;
                }
                pathExp = ExpandEnvironmentTextEx (field, ArgList);
                linkData->NewTarget = PoolMemDuplicateString (g_LinkDataPool, pathExp);
                FreeText (pathExp);

                if (!SetupGetStringField (&context, 4, field, MEMDB_MAX, NULL)) {
                    __leave;
                }
                pathExp = ExpandEnvironmentTextEx (field, ArgList);
                linkData->NewArguments = PoolMemDuplicateString (g_LinkDataPool, pathExp);
                FreeText (pathExp);

                if (!SetupGetStringField (&context, 5, field, MEMDB_MAX, NULL)) {
                    __leave;
                }
                linkData->ShellFolderName = PoolMemDuplicateString (g_LinkDataPool, field);
                result = TRUE;
            }
            __finally {

                if (result) {
                    linkData->Next = g_LinkRenameData;
                    g_LinkRenameData = linkData;
                }
                else {

                    if (linkData->OldTarget) {
                        PoolMemReleaseMemory (g_LinkDataPool, (PVOID)linkData->OldTarget);
                    }

                    if (linkData->NewTarget) {
                        PoolMemReleaseMemory (g_LinkDataPool, (PVOID)linkData->NewTarget);
                    }

                    if (linkData->OldArguments) {
                        PoolMemReleaseMemory (g_LinkDataPool, (PVOID)linkData->OldArguments);
                    }

                    if (linkData->NewArguments) {
                        PoolMemReleaseMemory (g_LinkDataPool, (PVOID)linkData->NewArguments);
                    }

                    if (linkData->ShellFolderName) {
                        PoolMemReleaseMemory (g_LinkDataPool, (PVOID)linkData->ShellFolderName);
                    }
                    PoolMemReleaseMemory (g_LinkDataPool, (PVOID)linkData);
                    linkData = NULL;
                }
            }
        } while (SetupFindNextLine (&context, &context));
    }
}

VOID
pDestroyLinksData (
    VOID
    )
{
    if (g_LinkDataPool != NULL) {
        PoolMemDestroyPool (g_LinkDataPool);
        g_LinkDataPool = NULL;
    }

    if (g_FoldersTable != NULL) {
        pSetupStringTableDestroy (g_FoldersTable);
    }
    g_LinkRenameData = NULL;
}


BOOL
pMigrateShellFolder (
    IN      PCTSTR Win9xUser,                   OPTIONAL
    IN      PCTSTR FixedUserName,               OPTIONAL
    IN      BOOL SystemShellFolder,
    IN      PCTSTR ShellFolderIdentifier,
    IN      PCTSTR SourcePath,
    IN      PCTSTR DestinationPath,
    IN      PCTSTR OrigSourcePath,
    IN      DWORD UserFlags,
    IN      PMIGRATE_USER_ENUM EnumPtr
    );

TCHAR g_DefaultHivePath[MAX_TCHAR_PATH];
HKEY g_DefaultHiveRoot;
INT g_DefaultHiveMapped;


VOID
pMigrateSystemShellFolders (
    VOID
    )
{
    FILEOP_ENUM eOp;
    FILEOP_PROP_ENUM eOpProp;
    PTSTR NewDest;
    PTSTR OrigSrc;

    if (EnumFirstPathInOperation (&eOp, OPERATION_SHELL_FOLDER)) {

        do {
            if (IsPatternMatch (S_DOT_ALLUSERS TEXT("\\*"), eOp.Path)) {

                NewDest = NULL;
                OrigSrc = NULL;
                if (EnumFirstFileOpProperty (&eOpProp, eOp.Sequencer, OPERATION_SHELL_FOLDER)) {

                    do {

                        if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_SHELLFOLDERS_DEST)) {
                            NewDest = DuplicatePathString (eOpProp.Property, 0);
                        }

                        if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_SHELLFOLDERS_ORIGINAL_SRC)) {
                            OrigSrc = DuplicatePathString (eOpProp.Property, 0);
                        }

                        if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_SHELLFOLDERS_SRC)) {

                            MYASSERT (NewDest);
                            MYASSERT (OrigSrc);

                            DEBUGMSG ((DBG_NAUSEA, "System SourcePath: %s", eOpProp.Property));

                            pMigrateShellFolder (
                                NULL,
                                NULL,
                                TRUE,
                                _tcsinc(_tcschr (eOp.Path, '\\')),
                                eOpProp.Property,
                                NewDest,
                                OrigSrc,
                                0,
                                NULL
                                );
                        }
                    } while (EnumNextFileOpProperty (&eOpProp));
                }
                if (NewDest) {
                    FreePathString (NewDest);
                    NewDest = NULL;
                }
                if (OrigSrc) {
                    FreePathString (OrigSrc);
                    OrigSrc = NULL;
                }
            }
        } while (EnumNextPathInOperation (&eOp));
    }
}


VOID
pWriteMyDocsHelpFile (
    IN      PCTSTR SubDir
    )

/*++

Routine Description:

  pWriteMyDocsHelpFile outputs a text file to the given path. This assists
  the user in locating their documents, when the My Documents shell folder
  goes to Shared Documents.

Arguments:

  SubDir - Specifies the path to the subdir where the file should be written

Return Value:

  None.

--*/

{
    HANDLE file;
    PCTSTR fileName;
    PCTSTR msg;
    DWORD bytesWritten;
    PCTSTR path;

    fileName = GetStringResource (MSG_EMPTY_MYDOCS_TITLE);
    msg = GetStringResource (MSG_EMPTY_MYDOCS_TEXT);
    path = JoinPaths (SubDir, fileName);

    if (fileName && msg && path) {
        //
        // For uninstall, mark the file as create. Because of a bug, we have
        // to treat this file as an OS file. What we really want to do is
        // call:
        //
        //  MarkFileForCreation (path);
        //
        // but this does not work. So we call MarkFileAsOsFile.
        //

        MarkFileAsOsFile (path);         // allows uninstall to work properly

        file = CreateFile (
                    path,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

        if (file != INVALID_HANDLE_VALUE) {
#ifdef UNICODE
            WriteFile (file, "\xff\xfe", 2, &bytesWritten, NULL);
#endif
            WriteFile (file, msg, SizeOfString (msg), &bytesWritten, NULL);
            CloseHandle (file);
        }
    }

    FreeStringResource (msg);
    FreeStringResource (fileName);
    FreePathString (path);
}


VOID
pMigrateUserShellFolders (
    IN      PMIGRATE_USER_ENUM EnumPtr
    )
{
    FILEOP_ENUM eOp;
    FILEOP_PROP_ENUM eOpProp;
    PTSTR NewDest;
    PTSTR OrigSrc;
    TCHAR node[MEMDB_MAX];
    MEMDB_ENUM e;

    if (EnumFirstPathInOperation (&eOp, OPERATION_SHELL_FOLDER)) {

        do {
            MemDbBuildKey (node, EnumPtr->FixedUserName, TEXT("*"), NULL, NULL);

            if (IsPatternMatch (node, eOp.Path)) {

                NewDest = NULL;
                OrigSrc = NULL;

                if (EnumFirstFileOpProperty (&eOpProp, eOp.Sequencer, OPERATION_SHELL_FOLDER)) {

                    do {

                        if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_SHELLFOLDERS_DEST)) {
                            NewDest = DuplicatePathString (eOpProp.Property, 0);
                        }

                        if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_SHELLFOLDERS_ORIGINAL_SRC)) {
                            OrigSrc = DuplicatePathString (eOpProp.Property, 0);
                        }

                        if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_SHELLFOLDERS_SRC)) {

                            MYASSERT (NewDest);
                            MYASSERT (OrigSrc);

                            DEBUGMSG ((DBG_NAUSEA, "Per-User SourcePath: %s", eOpProp.Property));

                            pMigrateShellFolder (
                                EnumPtr->Win9xUserName,
                                EnumPtr->FixedUserName,
                                FALSE,
                                _tcsinc(_tcschr (eOp.Path, '\\')),
                                eOpProp.Property,
                                NewDest,
                                OrigSrc,
                                0,
                                NULL
                                );
                        }
                    } while (EnumNextFileOpProperty (&eOpProp));
                }
                if (NewDest) {
                    FreePathString (NewDest);
                    NewDest = NULL;
                }
                if (OrigSrc) {
                    FreePathString (OrigSrc);
                    OrigSrc = NULL;
                }
            }
        } while (EnumNextPathInOperation (&eOp));
    }

    if (EnumPtr->FixedUserName) {
        MemDbBuildKey (
            node,
            MEMDB_CATEGORY_MYDOCS_WARNING,
            EnumPtr->FixedUserName,
            TEXT("*"),
            NULL
            );

        if (MemDbEnumFirstValue (&e, node, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
            do {

                DEBUGMSG ((DBG_SHELL, "Creating mydocs help file %s", e.szName));

                pWriteMyDocsHelpFile (e.szName);

            } while (MemDbEnumNextValue (&e));
        }
    }
}


BOOL
pCleanupDir (
    IN      PCTSTR Path,
    IN      BOOL CleanUpRoot
    )
{
    TREE_ENUM e;
    DWORD oldAttributes;

    if (EnumFirstFileInTreeEx (&e, Path, NULL, TRUE, TRUE, FILE_ENUM_ALL_LEVELS)) {

        do {

            if (e.Directory) {
                //
                // This is a dir. Let's see if we enter another shell folder
                //

                if (((g_SystemSfList) && (pSetupStringTableLookUpString (g_SystemSfList, (PVOID) e.FullPath, STRTAB_CASE_INSENSITIVE) != -1)) ||
                    ((g_UserSfList) && (pSetupStringTableLookUpString (g_UserSfList, (PVOID) e.FullPath, STRTAB_CASE_INSENSITIVE) != -1)) ||
                    (IsDirectoryMarkedAsEmpty (e.FullPath))
                    ) {
                    //
                    // we are just getting into another shell folder. Let's skip it
                    //
                    AbortEnumCurrentDir (&e);
                }
                else {
                    SetLongPathAttributes (e.FullPath, FILE_ATTRIBUTE_NORMAL);

                    if (!RemoveLongDirectoryPath (e.FullPath)) {
                        SetLongPathAttributes (e.FullPath, e.FindData->dwFileAttributes);
                    }
                }
            }
        } while (EnumNextFileInTree (&e));
    }
    AbortEnumFileInTree (&e);

    if (CleanUpRoot) {

        oldAttributes = GetLongPathAttributes (Path);

        SetLongPathAttributes (Path, FILE_ATTRIBUTE_NORMAL);

        if (!RemoveLongDirectoryPath (Path)) {
            SetLongPathAttributes (Path, oldAttributes);
        }
    }

    return TRUE;
}


INT
pGetCsidlFromTag (
    IN      PCTSTR ShellFolderIdentifier
    )
{
    PCSIDLMAP map;

    for (map = g_CsidlMap ; map->Tag ; map++) {
        if (StringIMatch (map->Tag, ShellFolderIdentifier)) {
            return map->CsidlValue;
        }
    }

    return -1;
}


INT
CALLBACK
pSfCopyCallback (
    PCTSTR FullFileSpec,
    PCTSTR DestSpec,
    WIN32_FIND_DATA *FindData,
    DWORD EnumTreeID,
    PVOID Param,
    PDWORD CurrentDirData
    )
{
    //
    // Put this file in the cleanout category, so that it gets removed unless
    // it has been backed up.
    //

    MemDbSetValueEx (
        MEMDB_CATEGORY_CLEAN_OUT,
        DestSpec,
        NULL,
        NULL,
        BACKUP_FILE,
        NULL
        );

    return CALLBACK_CONTINUE;
}


BOOL
pCreateSfWithApi (
    IN      PCTSTR ShellFolderIdentifier,
    IN      PCTSTR FolderToCreate
    )
{
    HRESULT hr;
    INT csidl;
    TCHAR folderPath[MAX_PATH];
    BOOL destroy = FALSE;
    BOOL result = TRUE;
    DWORD attribs;

    //
    // Convert the tag to a CSIDL constant
    //

    csidl = pGetCsidlFromTag (ShellFolderIdentifier);
    if (csidl < 0) {
        DEBUGMSG ((DBG_VERBOSE, "CSIDL ID for %s not known", ShellFolderIdentifier));
        return FALSE;
    }

    //
    // Query the shell for an existing shell folder
    //

    hr = SHGetFolderPath (NULL, csidl, NULL, SHGFP_TYPE_CURRENT, folderPath);

    if (hr != S_OK && hr != S_FALSE) {
        DEBUGMSG ((DBG_WARNING, "Can't get shell folder path for ID %s", ShellFolderIdentifier));
        return FALSE;
    }

    //
    // Get the attributes of the existing shell folder
    //

    if (hr == S_OK) {
        DEBUGMSG ((DBG_VERBOSE, "Shell folder %s already exists at %s", ShellFolderIdentifier, folderPath));
        attribs = GetLongPathAttributes (folderPath);
    } else {
        attribs = INVALID_ATTRIBUTES;
    }

    //
    // If existing shell folder is not present, create it temporarily
    //

    if (attribs == INVALID_ATTRIBUTES) {
        DEBUGMSG ((DBG_VERBOSE, "Shell folder %s needs to be created", ShellFolderIdentifier));
        destroy = TRUE;

        hr = SHGetFolderPath (
                NULL,
                csidl | CSIDL_FLAG_CREATE,
                NULL,
                SHGFP_TYPE_CURRENT,
                folderPath
                );

        if (hr != S_OK) {
            LOG ((LOG_ERROR, "Can't create shell folder path for ID %s", ShellFolderIdentifier));
            return FALSE;
        }

        attribs = GetLongPathAttributes (folderPath);

        if (attribs == INVALID_ATTRIBUTES) {
            LOG ((LOG_ERROR, "Can't get attributes of %s for ID %s", folderPath, ShellFolderIdentifier));
            result = FALSE;
        }
    }

    //
    // On success (either existing sf or we created it), make a copy of the whole folder
    //

    if (result) {
        MakeSurePathExists (FolderToCreate, TRUE);
        attribs = GetLongPathAttributes (folderPath);
        if (attribs != INVALID_ATTRIBUTES) {
            SetLongPathAttributes (FolderToCreate, attribs);
        }

        CopyTree (
            folderPath,
            FolderToCreate,
            0,              // no EnumTree ID
            COPYTREE_DOCOPY | COPYTREE_NOOVERWRITE,
            ENUM_ALL_LEVELS,
            FILTER_ALL,
            NULL,           // no exclude.inf struct
            pSfCopyCallback,
            NULL            // no error callback
            );
    }

    //
    // If we created the sf, we must destroy it to return the system back
    // to its original state. We punt the case where power goes out and
    // GUI mode restarts.
    //

    if (destroy) {
        RemoveCompleteDirectory (folderPath);
    }

    return result;
}


BOOL
pMigrateShellFolder (
    IN      PCTSTR Win9xUser,                   OPTIONAL
    IN      PCTSTR FixedUserName,               OPTIONAL
    IN      BOOL SystemShellFolder,
    IN      PCTSTR ShellFolderIdentifier,
    IN      PCTSTR SourcePath,
    IN      PCTSTR OrgDestinationPath,
    IN      PCTSTR OrigSourcePath,
    IN      DWORD UserFlags,
    IN      PMIGRATE_USER_ENUM EnumPtr
    )
{
    TREE_ENUM e;
    PSHELL_FOLDER_FILTER Filter;
    TCHAR DefaultShellFolder[MAX_TCHAR_PATH];
    PCTSTR DestPath = NULL;
    PROFILE_MERGE_DATA Data;
    BOOL Result = FALSE;
    TCHAR UserRoot[MAX_TCHAR_PATH];
    PCTSTR NtDefaultLocation = NULL;
    PCTSTR DefaultUserLocation = NULL;
    PCTSTR tempExpand = NULL;
    PCTSTR nextExpand;
    TCHAR ShellFolderPath[MAX_TCHAR_PATH];
    DWORD Offset;
    DWORD Size;
    HKEY Key;
    DWORD Attributes;
    PCTSTR ValData = NULL;
    PTSTR p;
    DWORD d;
    HKEY UserHiveRoot;
    LONG rc;
    PCTSTR EncodedKey;
    PCTSTR NewDestPath;
    BOOL AlreadyMoved;
    PCTSTR OrigFullPath;
    BOOL regFolder;
    PCTSTR freeMe;
    TCHAR driveLetter[] = TEXT("?:");
    BOOL allUsers;
    BOOL keep;
    PCWSTR OrigRootPath, DestRootPath;
    PBYTE bufferRoot;
    PTSTR destPathBuffer;
    DWORD fileStatus;

    __try {

        bufferRoot = MemAllocUninit (MEMDB_MAX * sizeof (TCHAR));
        if (!bufferRoot) {
            __leave;
        }

        destPathBuffer = (PTSTR) bufferRoot;

        DEBUGMSG ((DBG_SHELL, "Entering shell folder %s", ShellFolderIdentifier));

        regFolder = TRUE;

        if (StringIMatch (ShellFolderIdentifier, S_SF_PROFILES)) {
            regFolder = FALSE;
        }
        if (StringIMatch (ShellFolderIdentifier, S_SF_COMMON_PROFILES)) {
            regFolder = FALSE;
        }

        //
        // Get root default folder
        //

        Size = sizeof (DefaultShellFolder);

        if (!GetDefaultUserProfileDirectory (DefaultShellFolder, &Size)) {
            MYASSERT (FALSE);
            __leave;
        }

        if (regFolder) {
            //
            // Get ShellFolderPath (with environment variables in it)
            //

            if (SystemShellFolder) {
                UserHiveRoot = HKEY_LOCAL_MACHINE;
            } else {
                UserHiveRoot = g_DefaultHiveRoot;
            }

            Key = OpenRegKey (UserHiveRoot, S_USER_SHELL_FOLDERS_KEY);

            if (Key) {
                ValData = GetRegValueString (Key, ShellFolderIdentifier);
                DEBUGMSG_IF ((!ValData, DBG_WARNING, "Can't get NT default for %s from registry", ShellFolderIdentifier));

                CloseRegKey (Key);
            }
            ELSE_DEBUGMSG ((DBG_ERROR, "Can't open %s", S_USER_SHELL_FOLDERS_KEY));

            if (ValData) {
                StringCopy (ShellFolderPath, ValData);
                MemFree (g_hHeap, 0, ValData);
                ValData = NULL;
            } else {
                wsprintf (ShellFolderPath, TEXT("%s\\%s"), S_USERPROFILE_ENV, ShellFolderIdentifier);
            }
        }

        //
        // Get the user's profile root
        //

        if (FixedUserName) {

            if (!GetUserProfilePath (FixedUserName, &p)) {
                MYASSERT (FALSE);
                __leave;
            }

            StringCopy (UserRoot, p);
            allUsers = FALSE;

            FreePathString (p);

        } else {

            Size = sizeof (UserRoot);

            if (regFolder) {
                if (!GetAllUsersProfileDirectory (UserRoot, &Size)) {
                    MYASSERT (FALSE);
                    __leave;
                }

                allUsers = TRUE;

            } else {
                if (!GetProfilesDirectory (UserRoot, &Size)) {
                    MYASSERT (FALSE);
                    __leave;
                }

                allUsers = FALSE;
            }
        }

        if (regFolder) {
            //
            // Compute the default NT location and the Default User location
            //

            tempExpand = StringSearchAndReplace (
                            ShellFolderPath,
                            S_USERPROFILE_ENV,
                            UserRoot
                            );

            if (!tempExpand) {
                tempExpand = DuplicatePathString (ShellFolderPath, 0);
            }
        } else {
            tempExpand = DuplicatePathString (UserRoot, 0);
        }

        NtDefaultLocation = ExpandEnvironmentText (tempExpand);

        FreePathString (tempExpand);

        if (regFolder) {
            tempExpand = StringSearchAndReplace (
                            ShellFolderPath,
                            S_USERPROFILE_ENV,
                            DefaultShellFolder
                            );

            if (!tempExpand) {
                tempExpand = DuplicatePathString (ShellFolderPath, 0);
            }
        } else {
            tempExpand = StringSearchAndReplace (
                            UserRoot,
                            S_USERPROFILE_ENV,
                            DefaultShellFolder
                            );

            if (!tempExpand) {
                tempExpand = DuplicatePathString (UserRoot, 0);
            }
        }

        DefaultUserLocation = ExpandEnvironmentText (tempExpand);

        FreePathString (tempExpand);

        //
        // Init the filter data struct
        //

        ZeroMemory (&Data, sizeof (Data));

        Data.Win9xUser = Win9xUser;
        Data.FixedUserName = FixedUserName;
        Data.UserHiveRoot = UserHiveRoot;
        Data.ShellFolderIdentifier = ShellFolderIdentifier;
        Data.DefaultShellFolder = DefaultUserLocation;
        Data.UserDefaultLocation = NtDefaultLocation;
        Data.UserFlags = UserFlags;
        Data.Context = INITIALIZE;
        StringCopyByteCount (Data.TempSourcePath, SourcePath, sizeof (Data.TempSourcePath));
        StringCopyByteCount (Data.DestinationPath, OrgDestinationPath, sizeof (Data.DestinationPath));
        Data.SrcRootPath = SourcePath;
        Data.DestRootPath = OrgDestinationPath;
        Data.OrigRootPath = OrigSourcePath;
        Data.EnumPtr = EnumPtr;
        Data.Attributes = GetLongPathAttributes (OrgDestinationPath);

        //
        // Establish the shell folder using the shell APIs
        //

        if (pCreateSfWithApi (
                ShellFolderIdentifier,
                OrgDestinationPath
                )) {

            DEBUGMSG ((
                DBG_VERBOSE,
                "Using API defaults for shell folder %s",
                ShellFolderIdentifier
                ));

            Data.Attributes = GetLongPathAttributes (OrgDestinationPath);
        }

        if (Data.Attributes == INVALID_ATTRIBUTES) {
            //
            // We don't care about this shell folder's desktop.ini or
            // attributes -- use the NT default attributes, or the
            // Win9x attributes if there is no default.
            //

            Data.Attributes = GetLongPathAttributes (NtDefaultLocation);

            if (Data.Attributes == INVALID_ATTRIBUTES) {
                Data.Attributes = GetLongPathAttributes (Data.TempSourcePath);
            }

            if (Data.Attributes == INVALID_ATTRIBUTES) {
                //
                // This happens for shell folders like My Music & My Video
                // which don't exist on Win9x
                //
                Data.Attributes = FILE_ATTRIBUTE_READONLY;
            }

            MakeSureLongPathExists (OrgDestinationPath, TRUE);
            SetLongPathAttributes (OrgDestinationPath, Data.Attributes);

            DEBUGMSG ((
                DBG_VERBOSE,
                "Using previous OS desktop.ini for shell folder %s, attribs=%08X",
                ShellFolderIdentifier,
                Data.Attributes
                ));

        }

        //
        // Now add string mappings for this shell folder. The reason for doing
        // this is that we want to catch the case of paths to non-existent files
        // within shell stored in the registry.
        //

        OrigRootPath = JoinPaths (Data.OrigRootPath, TEXT(""));
        DestRootPath = JoinPaths (Data.DestRootPath, TEXT(""));
        AddStringMappingPair (g_SubStringMap, OrigRootPath, DestRootPath);
        FreePathString (DestRootPath);
        FreePathString (OrigRootPath);

        //
        // PHASE ONE - move the files from 9x shell folder to their NT locations
        //

        //
        // Call filters for init
        //

        for (Filter = g_Filters_9xNt ; Filter->Fn ; Filter++) {
            //DEBUGMSGA ((DBG_SHELL, "9X->NT: INIT: %s (enter)", Filter->Name));

            Data.State = 0;
            Filter->Fn (&Data);
            Filter->State = Data.State;

            //DEBUGMSGA ((DBG_SHELL, "9X->NT: INIT: %s (done)", Filter->Name));
        }

        //
        // Enumerate the shell folder and move it to the destination
        //

        DEBUGMSG ((DBG_SHELL, "9X->NT: Enumerating %s", SourcePath));

        if (EnumFirstFileInTree (&e, SourcePath, NULL, FALSE)) {

            do {
                //
                // Update the filter data struct
                //

                OrigFullPath = JoinPaths (OrigSourcePath, e.SubPath);
                fileStatus = GetFileInfoOnNt (OrigFullPath, destPathBuffer, MEMDB_MAX);
                DestPath = destPathBuffer;

                if (fileStatus == FILESTATUS_UNCHANGED) {
                    //
                    // No reason not to move this file too
                    //

                    MYASSERT (StringIMatch (destPathBuffer, OrigFullPath));

                    DestPath = JoinPaths (Data.DestRootPath, e.SubPath);

                    if (!StringIMatch (OrigFullPath, DestPath)) {
                        MarkFileForMoveExternal (OrigFullPath, DestPath);
                    }
                }

                Data.Attributes = e.FindData->dwFileAttributes;
                StringCopyByteCount (Data.TempSourcePath, e.FullPath, sizeof (Data.TempSourcePath));
                StringCopyByteCount (Data.DestinationPath, DestPath, sizeof (Data.DestinationPath));
                Data.Context = PROCESS_PATH;

                DEBUGMSG ((DBG_SHELL, "9X->NT: Original temp source path: %s", Data.TempSourcePath));

                //
                // Allow filters to change source or dest, or to skip copy
                //

                keep = TRUE;

                for (Filter = g_Filters_9xNt ; Filter->Fn ; Filter++) {

                    //DEBUGMSGA ((DBG_SHELL, "9X->NT: FILTER: %s (enter)", Filter->Name));

                    Data.State = Filter->State;
                    d = Filter->Fn (&Data);
                    Filter->State = Data.State;

                    //DEBUGMSGA ((DBG_SHELL, "9X->NT: FILTER: %s (result=%u)", Filter->Name, d));

                    // ignore SHELLFILTER_ERROR & try to complete processing

                    if (d == SHELLFILTER_FORCE_CHANGE) {
                        DEBUGMSG ((DBG_SHELL, "9X->NT: Skipping additional filters because shell folder filter %hs said so", Filter->Name));
                        break;
                    }

                    if (d == SHELLFILTER_SKIP_FILE) {
                        DEBUGMSG ((DBG_SHELL, "9X->NT:Skipping %s because shell folder filter %hs said so", DestPath, Filter->Name));
                        keep = FALSE;
                        break;
                    }

                    if (d == SHELLFILTER_SKIP_DIRECTORY) {
                        AbortEnumCurrentDir (&e);
                        keep = FALSE;
                        break;
                    }
                }

                if (keep && !(Data.Attributes & FILE_ATTRIBUTE_DIRECTORY)) {
                    //
                    // Is source different from the dest?
                    //

                    if (!StringIMatch (Data.TempSourcePath, Data.DestinationPath)) {

                        //
                        // Make sure dest exists
                        //

                        MakeSureLongPathExists (Data.DestinationPath, FALSE);       // FALSE == not path only

                        //
                        // Move or copy the file.
                        //
                        pQueueSfMove (Data.TempSourcePath, Data.DestinationPath);
                    }

                } else if (keep) {

                    MakeSureLongPathExists (Data.DestinationPath, TRUE);       // TRUE == path only
                    SetLongPathAttributes (Data.DestinationPath, Data.Attributes);

                } else if (d == SHELLFILTER_SKIP_FILE) {
                    //
                    // Mark this file for deletion if it won't be moved from temp to dest
                    //
                    if (!StringIMatch (Data.TempSourcePath, Data.DestinationPath)) {
                        DEBUGMSG ((DBG_SHELL, "Deleting shell folder file %s", e.FullPath));
                        ForceOperationOnPath (e.FullPath, OPERATION_CLEANUP);
                    }
                }

                if (DestPath && DestPath != destPathBuffer) {
                    FreePathString (DestPath);
                }

                DestPath = NULL;
                FreePathString (OrigFullPath);
                OrigFullPath = NULL;

            } while (EnumNextFileInTree (&e));
        }

        pFlushSfQueue();

        //
        // Call filters one last time
        //

        Data.Attributes = 0;
        Data.Context = TERMINATE;
        StringCopyByteCount (Data.TempSourcePath, SourcePath, sizeof (Data.TempSourcePath));
        StringCopyByteCount (Data.DestinationPath, OrgDestinationPath, sizeof (Data.DestinationPath));

        for (Filter = g_Filters_9xNt ; Filter->Fn ; Filter++) {
            //DEBUGMSGA ((DBG_SHELL, "9X->NT: TERMINATE: %s (enter)", Filter->Name));

            Data.State = Filter->State;
            Filter->Fn (&Data);
            Filter->State = Data.State;

            //DEBUGMSGA ((DBG_SHELL, "9X->NT: TERMINATE: %s (done)", Filter->Name));
        }

        //
        // Now cleanup this directory for all empty dirs (excluding the root)
        // Do not cleanup non reg folders!!
        //
        if (regFolder) {
            DEBUGMSG ((DBG_NAUSEA, "Cleaning up %s", Data.DestinationPath));
            pCleanupDir (Data.DestinationPath, FALSE);
        }

        //
        // PHASE TWO - if necessary, merge files from NT default shell folder
        //             to the new location and update the registry
        //

        if (regFolder) {

            //
            // Encode string with %USERPROFILE%/%ALLUSERSPROFILE%, %SYSTEMROOT%
            // or %SYSTEMDRIVE% if possible
            //

            // %USERPROFILE% or %ALLUSERSPROFILE%
            tempExpand = OrgDestinationPath;

            if (allUsers) {
                nextExpand = StringSearchAndReplace (
                                tempExpand,
                                UserRoot,
                                S_ALLUSERSPROFILE_ENV
                                );
            } else {
                nextExpand = StringSearchAndReplace (
                                tempExpand,
                                UserRoot,
                                S_USERPROFILE_ENV
                                );
            }

            if (nextExpand) {
                tempExpand = nextExpand;
            }

            // %SYSTEMROOT%
            nextExpand = StringSearchAndReplace (
                            tempExpand,
                            g_WinDir,
                            S_SYSTEMROOT_ENV
                            );

            if (nextExpand) {
                if (tempExpand != OrgDestinationPath) {
                    FreePathString (tempExpand);
                }

                tempExpand = nextExpand;
            }

            // %SYSTEMDRIVE%
            driveLetter[0] = g_WinDir[0];

            nextExpand = StringSearchAndReplace (
                            tempExpand,
                            driveLetter,
                            S_SYSTEMDRIVE_ENV
                            );

            if (nextExpand) {
                if (tempExpand != OrgDestinationPath) {
                    FreePathString (tempExpand);
                }

                tempExpand = nextExpand;
            }

            // tempExpand points to OrgDestinationPath or a expanded path from the path pool
            MYASSERT (tempExpand);

            //
            // Now store it. If HKLM, put it in the registry. Otherwise, put it
            // in memdb, which will later be put in the user's hive.
            //

            if (Data.UserHiveRoot == HKEY_LOCAL_MACHINE) {

                //
                // Update the registry, User Shell Folder must point to original
                // location
                //

                Key = OpenRegKey (Data.UserHiveRoot, S_USER_SHELL_FOLDERS_KEY);

                if (Key) {
                    rc = RegSetValueEx (
                            Key,
                            Data.ShellFolderIdentifier,
                            0,
                            REG_EXPAND_SZ,
                            (PBYTE) tempExpand,
                            SizeOfString (tempExpand)
                            );

                    DEBUGMSG_IF ((
                        rc != ERROR_SUCCESS,
                        DBG_ERROR,
                        "Can't save %s for %s",
                        tempExpand,
                        Data.ShellFolderIdentifier
                        ));

                    DEBUGMSG_IF ((
                        rc == ERROR_SUCCESS,
                        DBG_SHELL,
                        "Win9x shell location preserved: %s (%s)",
                        tempExpand,
                        Data.ShellFolderIdentifier
                        ));

                    CloseRegKey (Key);
                }
                ELSE_DEBUGMSG ((DBG_ERROR, "Can't open %s", S_USER_SHELL_FOLDERS_KEY));

            } else {

                EncodedKey = CreateEncodedRegistryStringEx (
                                S_USER_SHELL_FOLDERS_KEY,
                                Data.ShellFolderIdentifier,
                                FALSE
                                );

                MemDbSetValueEx (
                    MEMDB_CATEGORY_USER_REGISTRY_VALUE,
                    tempExpand,
                    NULL,
                    NULL,
                    REG_EXPAND_SZ,
                    &Offset
                    );

                MemDbSetValueEx (
                    MEMDB_CATEGORY_SET_USER_REGISTRY,
                    Data.FixedUserName,
                    EncodedKey,
                    NULL,
                    Offset,
                    NULL
                    );

                FreeEncodedRegistryString (EncodedKey);
            }

            if (tempExpand != OrgDestinationPath) {
                FreePathString (tempExpand);
            }

        }

        if (!StringIMatch (OrgDestinationPath, NtDefaultLocation)) {
            //
            // Now move from the NT default location into the preserved location
            //

            //
            // Fix the Data structure
            //

            Data.UserFlags = UserFlags;
            Data.Context = INITIALIZE;
            StringCopyByteCount (Data.TempSourcePath, NtDefaultLocation, sizeof (Data.TempSourcePath));
            StringCopyByteCount (Data.DestinationPath, OrgDestinationPath, sizeof (Data.DestinationPath));
            Data.SrcRootPath = NtDefaultLocation;
            Data.DestRootPath = OrgDestinationPath;
            Data.OrigRootPath = OrigSourcePath;

            //
            // Now check to see if we already moved something into the preserved directory.
            // If we did, we will not make the move (we will only delete the default files).
            //
            if (g_Merged9xFolders && (pSetupStringTableLookUpString (g_Merged9xFolders, (PTSTR)Data.DestRootPath, 0) != -1)) {
                AlreadyMoved = TRUE;
            }
            else {
                AlreadyMoved = FALSE;
                pSetupStringTableAddString (g_Merged9xFolders, (PVOID) Data.DestRootPath, STRTAB_CASE_INSENSITIVE);
            }

            //
            // Call filters for init
            //

            for (Filter = g_Filters_Nt9x ; Filter->Fn ; Filter++) {
                //DEBUGMSGA ((DBG_SHELL, "NT->9X: INIT: %s (enter)", Filter->Name));

                Data.State = 0;
                Filter->Fn (&Data);
                Filter->State = Data.State;

                //DEBUGMSGA ((DBG_SHELL, "NT->9X: INIT: %s (done)", Filter->Name));
            }

            DEBUGMSG ((DBG_SHELL, "NT->9X: Enumerating %s", Data.TempSourcePath));

            MYASSERT (Data.TempSourcePath && *Data.TempSourcePath);
            if (EnumFirstFileInTree (&e, Data.TempSourcePath, NULL, FALSE)) {

                do {

                    //
                    // This is only needed for user shell folders but does not hurt.
                    //

                    if (StringIMatch (TEXT("ntuser.dat"), e.Name)) {
                        continue;
                    }

                    //
                    // start with the assumption that the dest file is under the original
                    // destination path
                    //

                    NewDestPath = JoinPaths (OrgDestinationPath, e.SubPath);

                    //
                    // If this is desktop.ini, merge it with the existing one
                    //

                    if (StringIMatch (TEXT("desktop.ini"), e.Name)) {
                        DEBUGMSG ((
                            DBG_VERBOSE,
                            "Merging clean install %s with the one in Default User",
                            e.FullPath
                            ));
                        MergeIniFile (NewDestPath, e.FullPath, FALSE);
                        continue;
                    }

                    //
                    // Not the root shell folder desktop.ini -- continue processing
                    //

                    Data.Attributes = e.FindData->dwFileAttributes;
                    StringCopyByteCount (Data.TempSourcePath, e.FullPath, sizeof (Data.TempSourcePath));
                    StringCopyByteCount (Data.DestinationPath, NewDestPath, sizeof (Data.DestinationPath));
                    Data.Context = PROCESS_PATH;

                    DEBUGMSG ((DBG_SHELL, "NT->9X: Original temp source path: %s", Data.TempSourcePath));

                    //
                    // if we only need to delete the default files, skip the filters
                    //

                    if (AlreadyMoved) {

                        SetLongPathAttributes (Data.TempSourcePath, FILE_ATTRIBUTE_NORMAL);
                        if (!DeleteLongPath (Data.TempSourcePath)) {
                            SetLongPathAttributes (Data.TempSourcePath, Data.Attributes);
                            DEBUGMSG ((DBG_WARNING, "%s could not be removed.", Data.TempSourcePath));
                        }
                    }
                    else {

                        //
                        // Allow filters to change source or dest, or to skip copy
                        //

                        keep = TRUE;

                        for (Filter = g_Filters_Nt9x ; Filter->Fn ; Filter++) {
                            //DEBUGMSGA ((DBG_SHELL, "NT->9X: FILTER: %s (enter)", Filter->Name));

                            Data.State = Filter->State;
                            d = Filter->Fn (&Data);
                            Filter->State = Data.State;

                            //DEBUGMSGA ((DBG_SHELL, "NT->9X: FILTER: %s (result=%u)", Filter->Name, d));

                            if (d == SHELLFILTER_FORCE_CHANGE) {
                                break;
                            }

                            if (d == SHELLFILTER_SKIP_FILE) {
                                keep = FALSE;
                                break;
                            }

                            if (d == SHELLFILTER_SKIP_DIRECTORY) {
                                AbortEnumCurrentDir (&e);
                                keep = FALSE;
                                break;
                            }
                        }

                        if (keep) {

                            if (!(e.FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

                                pQueueSfMove (Data.TempSourcePath, Data.DestinationPath);
                            }
                            else {

                                MakeSureLongPathExists (Data.DestinationPath, TRUE);       // TRUE == path only
                                SetLongPathAttributes (Data.DestinationPath, Data.Attributes);

                            }
                        }
                    }

                    FreePathString (NewDestPath);

                } while (EnumNextFileInTree (&e));
            }

            pFlushSfQueue();

            //
            // Call filters one last time
            //

            Data.Attributes = 0;
            Data.Context = TERMINATE;
            StringCopyByteCount (Data.TempSourcePath, NtDefaultLocation, sizeof (Data.TempSourcePath));
            StringCopyByteCount (Data.DestinationPath, OrgDestinationPath, sizeof (Data.DestinationPath));

            for (Filter = g_Filters_Nt9x ; Filter->Fn ; Filter++) {
                //DEBUGMSGA ((DBG_SHELL, "NT->9X: TERMINATE: %s (enter)", Filter->Name));

                Data.State = Filter->State;
                Filter->Fn (&Data);
                Filter->State = Data.State;

                //DEBUGMSGA ((DBG_SHELL, "NT->9X: TERMINATE: %s (done)", Filter->Name));
            }

            //
            // Now cleanup this directory for all empty dirs (including the root)
            // Do not cleanup non reg folders!!
            //
            if (regFolder) {
                DEBUGMSG ((DBG_NAUSEA, "Cleaning up %s (including root)", Data.TempSourcePath));
                pCleanupDir (Data.TempSourcePath, TRUE);
            }

        }

        //
        // Loop through the whole tree and add desktop.ini to cleanup
        //

        if (EnumFirstFileInTree (&e, OrgDestinationPath, NULL, FALSE)) {
            do {
                if (!e.Directory) {
                    continue;
                }

                MemDbSetValueEx (
                    MEMDB_CATEGORY_CLEAN_OUT,
                    e.FullPath,
                    TEXT("desktop.ini"),
                    NULL,
                    BACKUP_FILE,
                    NULL
                    );
            } while (EnumNextFileInTree (&e));
        }

        Result = TRUE;

    }
    __finally {
        PushError();
        AbortEnumFileInTree (&e);
        FreeText (NtDefaultLocation);
        FreeText (DefaultUserLocation);

        if (bufferRoot) {
            FreeMem (bufferRoot);
        }

        PopError();
    }

    DEBUGMSG ((
        DBG_SHELL,
        "Leaving shell folder %s with result %s",
        ShellFolderIdentifier,
        Result ? TEXT("TRUE") : TEXT("FALSE")
        ));

    return Result;
}


HKEY
pLoadDefaultUserHive (
    VOID
    )
{
    DWORD Size;
    BOOL b;
    LONG rc;

    if (!g_DefaultHiveMapped) {

        if (!g_DefaultHivePath[0]) {
            Size = sizeof (g_DefaultHivePath);
            b = GetDefaultUserProfileDirectory (g_DefaultHivePath, &Size);
            MYASSERT (b);

            if (!b) {
                wsprintf (g_DefaultHivePath, TEXT("%s\\profiles\\default user"), g_WinDir);
            }

            StringCopy (AppendWack (g_DefaultHivePath), TEXT("ntuser.dat"));
        }

        rc = RegLoadKey (HKEY_USERS, S_DEFAULT_USER, g_DefaultHivePath);

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_ERROR, "Can't load default user hive from %s", g_DefaultHivePath));
            g_DefaultHiveRoot = NULL;
            return NULL;
        }

        g_DefaultHiveRoot = OpenRegKey (HKEY_USERS, S_DEFAULT_USER);

        if (!g_DefaultHiveRoot) {
            DEBUGMSG ((DBG_WHOOPS, "Loaded hive %s but could not open it", g_DefaultHivePath));
        }
    }

    g_DefaultHiveMapped++;

    return g_DefaultHiveRoot;
}


VOID
pUnloadDefaultUserHive (
    VOID
    )
{
    if (!g_DefaultHiveMapped) {
        return;
    }

    g_DefaultHiveMapped--;

    if (!g_DefaultHiveMapped) {
        CloseRegKey (g_DefaultHiveRoot);
        RegUnLoadKey (HKEY_USERS, S_DEFAULT_USER);
    }
}

VOID
pLoadIgnoredCollisions (
    VOID
    )
{
    INFCONTEXT context;
    TCHAR sfId[MEMDB_MAX];
    TCHAR file[MEMDB_MAX];
    INT value;

    MYASSERT (g_WkstaMigInf);

    if (SetupFindFirstLine (g_WkstaMigInf, S_IGNORED_COLLISIONS, NULL, &context)) {

        do {
            if (SetupGetStringField (&context, 1, sfId, MEMDB_MAX, NULL) &&
                SetupGetStringField (&context, 2, file, MEMDB_MAX, NULL) &&
                SetupGetIntField (&context, 3, &value)
                ) {
                MemDbSetValueEx (MEMDB_CATEGORY_IGNORED_COLLISIONS, sfId, file, NULL, value, NULL);
            }
        } while (SetupFindNextLine (&context, &context));
    }
}

DWORD
MigrateShellFolders (
    IN      DWORD Request
    )
{
    MIGRATE_USER_ENUM e;

    if (Request == REQUEST_QUERYTICKS) {
        return TICKS_SYSTEM_SHELL_MIGRATION;
    } else if (Request != REQUEST_RUN) {
        return ERROR_SUCCESS;
    }

    pPrepareSfRestartability();

    pLoadIgnoredCollisions ();

    g_SystemSfList = pCreateSystemSfList ();
    g_UserSfList = pCreateUserSfList (NULL);

    pCreateLinksList ();

    pCreateLinksRenameList ();

    pDestroySfList (g_UserSfList);

    pLoadDefaultUserHive();

    g_Merged9xFolders = pSetupStringTableInitialize();

    pMigrateSystemShellFolders();

    if (EnumFirstUserToMigrate (&e, ENUM_NO_FLAGS)) {

        do {

            if (!e.CreateOnly && e.AccountType != DEFAULT_USER_ACCOUNT) {
                pMigrateUserShellFolders (&e);
            }

        } while (EnumNextUserToMigrate (&e));
    }

    if (g_Merged9xFolders) {

        pSetupStringTableDestroy (g_Merged9xFolders);
    }

    pFlushSfQueue();

    pUnloadDefaultUserHive();

    pDestroyLinksData ();

    pDestroySfList (g_SystemSfList);

    return ERROR_SUCCESS;
}


PCTSTR
GenerateNewFileName (
    IN      PCTSTR OldName,
    IN      WORD Sequencer,
    IN      BOOL CheckExistence
    )
{
    PCTSTR extPtr;
    PTSTR newName;
    PTSTR result;

    extPtr = GetFileExtensionFromPath (OldName);

    if (!extPtr) {
        extPtr = GetEndOfString (OldName);
    }
    else {
        extPtr = _tcsdec (OldName, extPtr);
    }
    newName = DuplicatePathString (OldName, 0);
    result  = DuplicatePathString (OldName, 10);
    StringCopyAB (newName, OldName, extPtr);

    do {
        Sequencer ++;
        wsprintf (result, TEXT("%s (%u)%s"), newName, Sequencer, extPtr);
    } while ((CheckExistence) && (DoesFileExist (result)));
    FreePathString (newName);
    return result;
}


BOOL
pIgnoredCollisions (
    IN      PPROFILE_MERGE_DATA Data
    )
{
    TCHAR key[MEMDB_MAX];
    DWORD value;

    MemDbBuildKey (
        key,
        MEMDB_CATEGORY_IGNORED_COLLISIONS,
        Data->ShellFolderIdentifier,
        GetFileNameFromPath (Data->DestinationPath),
        NULL);
    if (MemDbGetPatternValue (key, &value)) {
        return value;
    } else {
        return 0;
    }
}

//
// Filters 9X -> NT
//


DWORD
pCollisionDetection9xNt (
    IN OUT  PPROFILE_MERGE_DATA Data
    )
{
    //
    // this filter will detect name collision while copying win9x shell folders files.
    // If we have a name collision, it means that NT already installed a file with the
    // same name. In this case, we want the new file to be survive even with a different
    // name. We will build a new file name starting with filename.ext. The new file will
    // look something like filename001.ext. In all cases we want to keep the extension,
    // since there might be some shell extensions active for this file.
    // Important: we do not care about directory collisions.
    //

    PCTSTR newName;
    PCTSTR OriginalSource;
    PCTSTR extPtr;
    DWORD value;

    switch (Data->Context) {

    case INITIALIZE:
        break;

    case PROCESS_PATH:

        if ((!(Data->Attributes & FILE_ATTRIBUTE_DIRECTORY)) &&
            (!StringIMatch (Data->SrcRootPath, Data->DestRootPath)) &&
            (DoesFileExist (Data->DestinationPath))
            ) {

            value = pIgnoredCollisions (Data);
            if (value) {

                if (value == 1) {

                    // we should keep the NT file
                    // By returning SHELLFILTER_SKIP_FILE we are instructing the copy routine
                    // not to copy this file. As a result the already installed NT file will
                    // survive

                    return SHELLFILTER_SKIP_FILE;

                } else {

                    // we should keep the 9x file
                    // We want to delete the NT file installed here to make room for the 9x
                    // file that should be copied when we return from this filter

                    SetLongPathAttributes (Data->DestinationPath, FILE_ATTRIBUTE_NORMAL);
                    DeleteLongPath (Data->DestinationPath);
                }

            } else {

                newName = GenerateNewFileName (Data->DestinationPath, 0, TRUE);  //TRUE - check unique
                StringCopyByteCount (Data->DestinationPath, newName, sizeof (Data->DestinationPath));
                FreePathString (newName);

                //
                // now if this was a link we need to fix the destination of the move external operation
                // We have two reasons to do this. One is that the LinkEdit code needs the actual destination
                // to be able to edit the link, and secondly we need this new target for the uninstall programs
                // to work properly. If this file is not a LNK or a PIF, we don't care, we want everybody to
                // use the NT installed file. BTW, there is a collision here only because NT installed a file
                // with the same name in this location.
                //
                extPtr = GetFileExtensionFromPath (Data->DestinationPath);
                if ((extPtr) &&
                    ((StringIMatch (extPtr, TEXT("LNK"))) ||
                     (StringIMatch (extPtr, TEXT("PIF")))
                     )
                    ) {
                    //
                    // Get the original source for this file
                    //
                    OriginalSource = StringSearchAndReplace (Data->TempSourcePath, Data->SrcRootPath, Data->OrigRootPath);
                    MYASSERT (OriginalSource);

                    if (IsFileMarkedForOperation (OriginalSource, OPERATION_FILE_MOVE_SHELL_FOLDER)) {
                        RemoveOperationsFromPath (OriginalSource, OPERATION_FILE_MOVE_SHELL_FOLDER);
                        MarkFileForShellFolderMove (OriginalSource, Data->DestinationPath);
                    }
                    FreePathString (OriginalSource);
                }
            }
        }
        break;

    case TERMINATE:
        break;
    }

    return SHELLFILTER_OK;
}


DWORD
pFontNameFilter (
    IN OUT  PPROFILE_MERGE_DATA Data
    )
{
    static HASHTABLE HashTable;
    HKEY FontKey;
    REGVALUE_ENUM e;
    PCTSTR Font;

    switch (Data->Context) {

    case INITIALIZE:
        //
        // Preload a hash table with all the font names
        //

        HashTable = HtAlloc();

        FontKey = OpenRegKeyStr (TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts"));
        if (FontKey) {

            if (EnumFirstRegValue (&e, FontKey)) {
                do {

                    Font = GetRegValueString (FontKey, e.ValueName);

                    if (Font) {
                        HtAddString (HashTable, Font);
                        MemFree (g_hHeap, 0, Font);
                    }
                    ELSE_DEBUGMSG ((DBG_ERROR, "Can't get value data for %s in fonts key", e.ValueName));

                } while (EnumNextRegValue (&e));
            }

            CloseRegKey (FontKey);
        }
        ELSE_LOG ((LOG_ERROR, "Can't open Fonts registry key. There may be duplicate font files."));

        break;

    case PROCESS_PATH:
        //
        // If the shell folder is Fonts, and the font is already
        // registered, skip the Win9x copy.
        //

        if (StringIMatch (Data->ShellFolderIdentifier, TEXT("Fonts"))) {

            if (!(Data->Attributes & FILE_ATTRIBUTE_DIRECTORY)) {

                if (DoesFileExist (Data->DestinationPath)) {
                    //
                    // NT already installed this file. We won't overwrite this
                    // with the 9x copy.
                    //

                    DEBUGMSG ((
                        DBG_SHELL,
                        "Skipping copy of already existent font file: %s",
                        Data->DestinationPath
                        ));

                    return SHELLFILTER_SKIP_FILE;
                }

                if (HtFindString (HashTable, GetFileNameFromPath (Data->DestinationPath))) {

                    DEBUGMSG ((
                        DBG_SHELL,
                        "Skipping copy of already registered font file: %s",
                        Data->DestinationPath
                        ));

                    return SHELLFILTER_SKIP_FILE;
                }
            }
        }

        break;

    case TERMINATE:
        HtFree (HashTable);
        HashTable = NULL;
        break;
    }

    return SHELLFILTER_OK;
}


BOOL
pIsCommonSf (
    IN      PCTSTR ShellFolderTag
    )
{
    TCHAR memdbKey[MAX_SHELL_TAG + 32];

    if (StringIPrefix (ShellFolderTag, TEXT("Common"))) {
        return TRUE;
    }

    MemDbBuildKey (memdbKey, MEMDB_CATEGORY_SF_COMMON, ShellFolderTag, NULL, NULL);

    return MemDbGetValue (memdbKey, NULL);
}


VOID
pConvertPerUserSfToCommon (
    IN      PCTSTR PerUserSf,
    OUT     PTSTR CommonSf          // must hold MAX_SHELL_TAG chars
    )
{
    TCHAR memdbKey[MAX_SHELL_TAG + 32];
    DWORD offset;
    BOOL useDefault = TRUE;

    MemDbBuildKey (memdbKey, MEMDB_CATEGORY_SF_PERUSER, PerUserSf, NULL, NULL);
    if (MemDbGetValue (memdbKey, &offset)) {
        if (MemDbBuildKeyFromOffset (offset, CommonSf, 1, NULL)) {
            useDefault = FALSE;
        }
    }

    if (useDefault) {
        wsprintf (CommonSf, TEXT("Common %s"), PerUserSf);
    }
}

VOID
pConvertCommonSfToPerUser (
    IN      PCTSTR CommonSf,
    OUT     PTSTR PerUserSf         // must hold MAX_SHELL_TAG chars
    )
{
    TCHAR memdbKey[MAX_SHELL_TAG + 32];
    DWORD offset;
    BOOL useDefault = TRUE;

    MemDbBuildKey (memdbKey, MEMDB_CATEGORY_SF_COMMON, CommonSf, NULL, NULL);
    if (MemDbGetValue (memdbKey, &offset)) {
        if (MemDbBuildKeyFromOffset (offset, PerUserSf, 1, NULL)) {
            useDefault = FALSE;
        }
    }

    if (useDefault) {
        if (StringIPrefix (CommonSf, TEXT("Common"))) {
            CommonSf += 6;
            if (_tcsnextc (CommonSf) == TEXT(' ')) {
                CommonSf++;
            }
        }

        StringCopy (PerUserSf, CommonSf);
    }
}


BOOL
pIsObsoleteLink (
    IN      PCTSTR ShortcutName,
    IN      PCTSTR ShortcutTarget,
    IN      PCTSTR ShortcutArgs,
    IN      PCTSTR CurrentShellFolder,
    IN      PCTSTR CurrentShellFolderPath
    )
{
    PLINK_DATA linkData = NULL;
    PLINK_RENAME_DATA linkRenameData = NULL;
    LONG stringId;
    TCHAR perUserName[MAX_SHELL_TAG];

    DEBUGMSG ((
        DBG_SHELL,
        "pIsObsoleteLink: Checking %s\n"
        "  Input Target: %s\n"
        "  Input Args: %s\n"
        "  Current Shell Folder: %s\n"
        "  Current Shell Folder Path: %s",
        ShortcutName,
        ShortcutTarget,
        ShortcutArgs,
        CurrentShellFolder,
        CurrentShellFolderPath
        ));

    pConvertCommonSfToPerUser (CurrentShellFolder, perUserName);

    stringId = pSetupStringTableLookUpString (g_FoldersTable, perUserName, 0);

    if (stringId != -1) {

        pSetupStringTableGetExtraData (g_FoldersTable, stringId, &linkData, sizeof (PLINK_DATA));
        while (linkData) {

#if 0
            DEBUGMSG ((
                DBG_SHELL,
                "Checking NT-installed LNK:\n"
                "  Target: %s\n"
                "  Args: %s",
                linkData->Target,
                linkData->Arguments
                ));
#endif

            if ((IsPatternMatch (linkData->Target, ShortcutTarget)) &&
                (IsPatternMatch (linkData->Arguments, ShortcutArgs))
                ) {
                DEBUGMSG ((
                    DBG_SHELL,
                    "Obsolete link:\n"
                    "  \"%s\" matched \"%s\"\n"
                    "  \"%s\" matched \"%s\"",
                    linkData->Target,
                    ShortcutTarget,
                    linkData->Arguments,
                    ShortcutArgs
                    ));
                return TRUE;
            }

            linkRenameData = g_LinkRenameData;
            while (linkRenameData) {

#if 0
                DEBUGMSG ((
                    DBG_SHELL,
                    "Checking NT rename data:\n"
                    "  Old Target: %s\n"
                    "  New Target: %s\n"
                    "  Old Args: %s\n"
                    "  New Args: %s",
                    linkRenameData->OldTarget,
                    linkRenameData->NewTarget,
                    linkRenameData->OldArguments,
                    linkRenameData->NewArguments
                    ));
#endif

                if (StringIMatch (linkRenameData->ShellFolderName, perUserName)) {

                    if ((IsPatternMatch (linkRenameData->OldTarget, ShortcutTarget)) &&
                        (IsPatternMatch (linkRenameData->NewTarget, linkData->Target)) &&
                        (IsPatternMatch (linkRenameData->OldArguments, ShortcutArgs)) &&
                        (IsPatternMatch (linkRenameData->NewArguments, linkData->Arguments))
                        ) {
                        DEBUGMSG ((
                            DBG_SHELL,
                            "Obsolete link:\n"
                            "  \"%s\" matched \"%s\"\n"
                            "  \"%s\" matched \"%s\"\n"
                            "  \"%s\" matched \"%s\"\n"
                            "  \"%s\" matched \"%s\"\n",
                            linkRenameData->OldTarget, ShortcutTarget,
                            linkRenameData->NewTarget, linkData->Target,
                            linkRenameData->OldArguments, ShortcutArgs,
                            linkRenameData->NewArguments, linkData->Arguments
                            ));
                        return TRUE;
                    }
                }
                linkRenameData = linkRenameData->Next;
            }
            linkData = linkData->Next;
        }
    }
    ELSE_DEBUGMSG ((DBG_SHELL, "Nothing in shell folder %s is obsolete", perUserName));

    return FALSE;
}


DWORD
pStartupDisableFilter (
    IN OUT  PPROFILE_MERGE_DATA Data
    )
{
    DWORD status;
    PCTSTR originalSource;
    PCTSTR newSource;
    PCTSTR path;
    TCHAR disablePath[MAX_TCHAR_PATH];
    PTSTR dontCare;
    DWORD result = SHELLFILTER_OK;

    switch (Data->Context) {

    case INITIALIZE:
        break;

    case PROCESS_PATH:
        DEBUGMSG ((
            DBG_SHELL,
            __FUNCTION__ ": Processing %s in %s",
            Data->TempSourcePath,
            Data->ShellFolderIdentifier
            ));

        if (!StringIMatch (Data->ShellFolderIdentifier, TEXT("startup")) &&
            !StringIMatch (Data->ShellFolderIdentifier, TEXT("common startup"))
            ) {
            DEBUGMSG ((
                DBG_SHELL,
                "Shell folder ID %s does not match startup or common startup",
                Data->ShellFolderIdentifier
                ));
            break;
        }

        if (Data->DestRootPath[0] == 0 ||
            Data->DestRootPath[1] == 0 ||
            Data->DestRootPath[2] == 0 ||
            Data->DestRootPath[3] == 0
            ) {
            DEBUGMSG ((
                DBG_SHELL,
                "Skipping disable of startup item %s because its dest is a root directory",
                Data->DestinationPath
                ));
            break;
        }

        originalSource = StringSearchAndReplace (Data->TempSourcePath, Data->SrcRootPath, Data->OrigRootPath);
        MYASSERT (originalSource);

        DEBUGMSG ((DBG_SHELL, "Checking if %s is disabled", originalSource));

        if (IsFileDisabled (originalSource)) {
            //
            // Redirect disabled startup items to ..\Disabled Startup
            //

            path = JoinPaths (Data->DestRootPath, TEXT("..\\Disabled Startup"));
            MakeSureLongPathExists (path, TRUE);    // TRUE == path only
            GetFullPathName (path, ARRAYSIZE(disablePath), disablePath, &dontCare);
            FreePathString (path);

            DEBUGMSG ((DBG_SHELL, "Disabled startup dest is %s", disablePath));
            SetLongPathAttributes (disablePath, FILE_ATTRIBUTE_HIDDEN);

            newSource = StringSearchAndReplace (Data->TempSourcePath, Data->SrcRootPath, disablePath);
            StringCopy (Data->DestinationPath, newSource);
            FreePathString (newSource);

            DEBUGMSG ((DBG_SHELL, "Startup item moved to %s", Data->DestinationPath));

            RemoveOperationsFromPath (originalSource, OPERATION_FILE_DISABLED);

            if (IsFileMarkedForOperation (originalSource, OPERATION_FILE_MOVE_SHELL_FOLDER)) {
                RemoveOperationsFromPath (originalSource, OPERATION_FILE_MOVE_SHELL_FOLDER);
                MarkFileForShellFolderMove (originalSource, Data->DestinationPath);
            }

            //
            // By returning SHELLFILTER_FORCE_CHANGE, we are instructing the
            // shell folder algorithm to use our destination and not call anyone
            // else.
            //

            result = SHELLFILTER_FORCE_CHANGE;
        }

        FreePathString (originalSource);
        break;

    case TERMINATE:
        break;
    }

    return result;
}


DWORD
pObsoleteLinksFilter (
    IN OUT  PPROFILE_MERGE_DATA Data
    )
{
    static IShellLink *shellLink = NULL;
    static IPersistFile *persistFile = NULL;
    static PTSTR bigBuf;
    static PTSTR ShortcutTarget;
    static PTSTR ShortcutArgs;
    static PTSTR ShortcutWorkDir;
    static PTSTR ShortcutIconPath;
    INT   ShortcutIcon;
    WORD  ShortcutHotKey;
    BOOL  result = FALSE;
    BOOL  dosApp;
    BOOL  msDosMode;
    PCTSTR extPtr;
    FILEOP_PROP_ENUM eOpProp;
    PTSTR NewTarget;
    PCTSTR OriginalSource;

    switch (Data->Context) {

    case INITIALIZE:

        if (!InitCOMLink (&shellLink, &persistFile)) {
            DEBUGMSG ((DBG_ERROR, "Cannot initialize COM. Obsolete links filter will not work."));
            return SHELLFILTER_ERROR;
        }

        bigBuf = (PTSTR) MemAllocUninit ((MEMDB_MAX * 4) * sizeof (TCHAR));
        if (!bigBuf) {
            return SHELLFILTER_ERROR;
        }

        ShortcutTarget = bigBuf;
        ShortcutArgs = ShortcutTarget + MEMDB_MAX;
        ShortcutWorkDir = ShortcutArgs + MEMDB_MAX;
        ShortcutIconPath = ShortcutWorkDir + MEMDB_MAX;
        break;

    case PROCESS_PATH:

        extPtr = GetFileExtensionFromPath (Data->DestinationPath);

        if (!extPtr) {
            return SHELLFILTER_OK;
        }

        if ((!StringIMatch (extPtr, TEXT("LNK"))) &&
            (!StringIMatch (extPtr, TEXT("PIF")))
            ) {
            return SHELLFILTER_OK;
        }

        DEBUGMSG ((DBG_SHELL, "Extracting shortcut info for temp file %s", Data->TempSourcePath));

        if ((shellLink) &&
            (persistFile) &&
            (ExtractShortcutInfo (
                ShortcutTarget,
                ShortcutArgs,
                ShortcutWorkDir,
                ShortcutIconPath,
                &ShortcutIcon,
                &ShortcutHotKey,
                &dosApp,
                &msDosMode,
                NULL,
                NULL,
                Data->TempSourcePath,
                shellLink,
                persistFile
                ))) {

            // get the new destination if this shortcut is to be edited
            NewTarget = NULL;

            //
            // Get the original source for this file
            //
            OriginalSource = StringSearchAndReplace (Data->TempSourcePath, Data->SrcRootPath, Data->OrigRootPath);
            MYASSERT (OriginalSource);

            DEBUGMSG ((DBG_SHELL, "OriginalSource for shortcut is %s", OriginalSource));

            if (IsFileMarkedForOperation (OriginalSource, OPERATION_LINK_EDIT)) {

                DEBUGMSG ((DBG_SHELL, "OriginalSource is marked for file edit"));

                if (EnumFirstFileOpProperty (&eOpProp, GetSequencerFromPath (OriginalSource), OPERATION_LINK_EDIT)) {

                    do {

                        if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKEDIT_TARGET)) {
                            NewTarget = DuplicatePathString (eOpProp.Property, 0);
                            break;
                        }
                    } while (EnumNextFileOpProperty (&eOpProp));
                }
            }

            FreePathString (OriginalSource);

            if (!NewTarget) {
                NewTarget = DuplicatePathString (ShortcutTarget, 0);
            }

            result = pIsObsoleteLink (Data->DestinationPath, NewTarget, ShortcutArgs, Data->ShellFolderIdentifier, Data->DestRootPath);

            DEBUGMSG_IF ((result, DBG_SHELL, "%s is obsolete", Data->DestinationPath));
            DEBUGMSG_IF ((!result, DBG_SHELL, "%s is not obsolete", Data->DestinationPath));

            FreePathString (NewTarget);
        }

        if (result) {
            //
            // If this link is to be edited by the LinkEdit code we should remove this
            // operation because the file will not be available.
            //

            DEBUGMSG ((DBG_SHELL, "File %s will not be available for LinkEdit", Data->TempSourcePath));

            //
            // Get the original source for this file
            //
            OriginalSource = StringSearchAndReplace (Data->TempSourcePath, Data->SrcRootPath, Data->OrigRootPath);
            MYASSERT (OriginalSource);

            if (IsFileMarkedForOperation (OriginalSource, OPERATION_LINK_EDIT)) {
                RemoveOperationsFromPath (OriginalSource, OPERATION_LINK_EDIT);
            }
            FreePathString (OriginalSource);

            //
            // Now remove the source file. We cannot keep this file to be restored by the UNDO code.
            // The reason for this is that we might have some other
            // shell folder pointing to the same source and destination. In this case, obsolete links
            // filter will not work since we just removed the file from OPERATION_LINK_EDIT.
            //
            MYASSERT ((Data->Attributes & FILE_ATTRIBUTE_DIRECTORY) == 0);

            SetLongPathAttributes (Data->TempSourcePath, FILE_ATTRIBUTE_NORMAL);
            if (!DeleteLongPath (Data->TempSourcePath)) {
                DEBUGMSG ((DBG_ERROR, "Cannot remove file %s", Data->TempSourcePath));
                SetLongPathAttributes (Data->TempSourcePath, Data->Attributes);
            }

            return SHELLFILTER_SKIP_FILE;
        }
        return SHELLFILTER_OK;

    case TERMINATE:

        if (bigBuf) {
            FreeMem (bigBuf);
        }

        FreeCOMLink (&shellLink, &persistFile);
        break;
    }

    return SHELLFILTER_OK;
}



//
// Filters NT -> 9X
//


DWORD
pCollisionDetectionNt9x (
    IN OUT  PPROFILE_MERGE_DATA Data
    )
{
    //
    // this filter will detect name collision while copying files from NT shell folders
    // or default user to migrated 9x shell folder.
    // If we have a name collision, we want to keep the NT file original name and to rename
    // the migrated Win9x file. We will build a new file name starting with filename.ext.
    // The new file will look something like filename001.ext. In all cases we want to keep
    // the extension, since there might be some shell extensions active for this file.
    // Important: we do not care about directory collisions.
    //

    PCTSTR newName;
    PCTSTR extPtr;
    PCTSTR OriginalSource;
    DWORD value;

    switch (Data->Context) {

    case INITIALIZE:
        break;

    case PROCESS_PATH:

        if ((!(Data->Attributes & FILE_ATTRIBUTE_DIRECTORY)) &&
            (!StringIMatch (Data->SrcRootPath, Data->DestRootPath)) &&
            (DoesFileExist (Data->DestinationPath))
            ) {

            value = pIgnoredCollisions (Data);
            if (value) {

                if (value == 1) {

                    // we should keep the 9x file
                    // By returning SHELLFILTER_SKIP_FILE we are instructing the copy routine
                    // not to copy this file. As a result the already installed 9x file will
                    // survive

                    return SHELLFILTER_SKIP_FILE;

                } else {

                    // we should keep the NT file
                    // We want to delete the 9x file installed here to make room for the NT
                    // file that should be copied when we return from this filter

                    SetLongPathAttributes (Data->DestinationPath, FILE_ATTRIBUTE_NORMAL);
                    DeleteLongPath (Data->DestinationPath);
                }

            } else {

                newName = GenerateNewFileName (Data->DestinationPath, 0, TRUE);  //TRUE - check unique

                DEBUGMSG ((
                    DBG_SHELL,
                    "9x file collides with NT file -- renaming 9x file from %s to %s",
                    Data->DestinationPath,
                    newName
                    ));

                pQueueSfMove (Data->DestinationPath, newName);

                //
                // now if this was a link we need to fix the destination of the move external operation
                // We have two reasons to do this. One is that the LinkEdit code needs the actual destination
                // to be able to edit the link, and secondly we need this new target for the uninstall programs
                // to work properly. If this file is not a LNK or a PIF, we don't care, we want everybody to
                // use the NT installed file. BTW, there is a collision here only because NT installed a file
                // with the same name in this location.
                //
                extPtr = GetFileExtensionFromPath (Data->DestinationPath);

                if ((extPtr) &&
                    ((StringIMatch (extPtr, TEXT("LNK"))) ||
                     (StringIMatch (extPtr, TEXT("PIF")))
                     )
                    ) {
                    //
                    // Get the original source for this file
                    //
                    OriginalSource = StringSearchAndReplace (Data->TempSourcePath, Data->SrcRootPath, Data->OrigRootPath);
                    MYASSERT (OriginalSource);

                    if (IsFileMarkedForOperation (OriginalSource, OPERATION_FILE_MOVE_SHELL_FOLDER)) {
                        DEBUGMSG ((
                            DBG_SHELL,
                            "Removing shell move op from %s",
                            OriginalSource
                            ));

                        RemoveOperationsFromPath (OriginalSource, OPERATION_FILE_MOVE_SHELL_FOLDER);
                        MarkFileForShellFolderMove (OriginalSource, newName);
                    }
                    FreePathString (OriginalSource);
                }

                FreePathString (newName);
            }
        }
        break;

    case TERMINATE:
        break;
    }

    return SHELLFILTER_OK;
}


DWORD
pDetectOtherShellFolder (
    IN OUT  PPROFILE_MERGE_DATA Data
    )
{
    switch (Data->Context) {

    case INITIALIZE:
        g_UserSfList = pCreateUserSfList (Data);
        break;

    case PROCESS_PATH:

        if (Data->Attributes & FILE_ATTRIBUTE_DIRECTORY) {
            //
            // This is a dir. Let's see if we enter another shell folder
            //

            if (((g_SystemSfList) && (pSetupStringTableLookUpString (g_SystemSfList, (PVOID) Data->TempSourcePath, STRTAB_CASE_INSENSITIVE) != -1)) ||
                ((g_UserSfList) && (pSetupStringTableLookUpString (g_UserSfList, (PVOID) Data->TempSourcePath, STRTAB_CASE_INSENSITIVE) != -1))
                ) {
                //
                // we are just getting into another shell folder. Let's skip it
                //
                return SHELLFILTER_SKIP_DIRECTORY;
            }
        }
        break;

    case TERMINATE:
        pDestroySfList (g_UserSfList);
        break;
    }

    return SHELLFILTER_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\pcache.h ===
/* Copyright (c) 1992-2001, Microsoft Corporation, all rights reserved
**
** pcache.h
** Remote Access Phonebook - Win9x Password cache (PWL) decrypter
** Private header
**
** Portions of this code have been ported from:
** Win9x\proj\net\user\src\WNET\PCACHE
**
** Whistler bug: 208318 Win9x Upg: Username and Password for DUN connectoid not
** migrated from Win9x to Whistler
**
** 06/24/92 gregj
** 03/06/01 Jeff Sigman
*/

#ifndef _PCACHE_H_
#define _PCACHE_H_

//----------------------------------------------------------------------------
// Constants
//----------------------------------------------------------------------------

#define IERR_PCACHE_BASE        7200
#define IERR_BadSig             (IERR_PCACHE_BASE + 1)
#define IERR_CacheEntryNotFound (IERR_PCACHE_BASE + 4)
#define IERR_IncorrectUsername  (IERR_PCACHE_BASE + 6)
#define IERR_CacheCorrupt       (IERR_PCACHE_BASE + 7)

#define PLAINTEXT_SIGNATURE     0x4E464DB0
#define NEW_PLAINTEXT_SIGNATURE 0x968582E3
#define PCE_END_MARKER          0x8000
#define BUCKET_COUNT            16
#define RAS_MaxPortName         MAX_PATH
#define MAX_ENTRY_SIZE          250  // so total file size < 64K
#define PCE_MISC                0x06 // entry is for some other resource

#define MAX_PHONENUMBER_SIZE    128
#define MAX_CALLBACKNUMBER_SIZE MAX_PHONENUMBER_SIZE
#define DLPARAMS_MASK_USERNAME  0x00000001
#define DLPARAMS_MASK_PASSWORD  0x00000002
#define DLPARAMS_MASK_DOMAIN    0x00000004
#define DLPARAMS_MASK_OLDSTYLE  0x80000000

#define S_RESOURCEMASK2         "*Rna\\%s\\%s"
#define S_SRCHPWL               "*.PWL"
#define S_PWLDIR                "\\Pwls"

//----------------------------------------------------------------------------
// Datatypes
//----------------------------------------------------------------------------

typedef struct
{
    USHORT cbResource;
    USHORT cbPassword;
    UCHAR  iEntry;
    UCHAR  nType;
    USHORT dchResource;
    USHORT dchPassword;
}
CACHE_ENTRY_INFO;

typedef struct
{
    USHORT cbEntry;
    USHORT cbResource;
    USHORT cbPassword;
    UCHAR  iEntry;
    UCHAR  nType;
    CHAR   abResource[ 1 ];
}
PASSWORD_CACHE_ENTRY;

typedef struct
{
    CHAR   abRandomPadding[ 16 ];
    CHAR   abAuthenticationHash[ 16 ];
    USHORT aibBuckets[ BUCKET_COUNT + 1 ];
}
NEW_ENCRYPTED_HEADER;

typedef struct
{
    USHORT cbBlob;
}
KEYBLOB;

typedef struct
{
    ULONG   ulSig;
    ULONG   ulSerial;
    USHORT  cMRUEntries;
    UCHAR   aiOrder[ 255 ];
    UCHAR   aiBucket[ 255 ];
    DWORD   cbHeader;
    DWORD   adwBucketSalts[ BUCKET_COUNT + 1 ];
    KEYBLOB keyBlobs;
}
NEW_PLAINTEXT_HEADER;

typedef struct _RAS_DIALPARAMS {

    DWORD DP_Uid;
    WCHAR DP_PhoneNumber[MAX_PHONENUMBER_SIZE + 1];
    WCHAR DP_CallbackNumber[MAX_CALLBACKNUMBER_SIZE + 1];
    WCHAR DP_UserName[UNLEN + 1];
    WCHAR DP_Password[PWLEN + 1];
    WCHAR DP_Domain[DNLEN + 1];
    DWORD DP_SubEntry;

} RAS_DIALPARAMS, *PRAS_DIALPARAMS;

//----------------------------------------------------------------------------
// Macros
//----------------------------------------------------------------------------

#define FIELDOFFSET(type,field) (((CHAR*)&(((type*)NULL)->field))-((CHAR*)NULL))
#define BREAK_ON_DWERR(_e) if ((_e)) break;
#define NEXT_PCE(pce) ((PASSWORD_CACHE_ENTRY*)(((CHAR*)(pce))+(pce)->cbEntry))
#undef  min
#define min(a,b) ((a)<(b)?(a):(b))

//----------------------------------------------------------------------------
// Prototypes
//----------------------------------------------------------------------------

DWORD (* g_SetEntryDialParams) (
    IN PWCHAR          pszSid,
    IN DWORD           dwUID,
    IN DWORD           dwSetMask,
    IN DWORD           dwClearMask,
    IN PRAS_DIALPARAMS lpRasDialParams
    );

UINT
HashName (
    const CHAR* pbResource,
    WORD        cbResource
    );

VOID
Encrypt (
    CHAR *pbSource,
    WORD cbSource,
    CHAR *pbDest
    );

VOID
Decrypt (
    CHAR *pbSource,
    WORD cbSource
    );

VOID
ENCRYPTER (
    const CHAR* pszUsername,
    const CHAR* pszPassword,
    UINT        iBucket,
    DWORD       dwSalt
    );

DWORD
ReadData (
    WORD  ibSeek,
    PVOID pbBuffer,
    WORD  cbBuffer
    );

VOID
AssembleFindCacheName (
    CHAR* pszWindir,
    CHAR* pszResult
    );

DWORD
OpenCacheFile (
    VOID
    );

DWORD
ReadAndDecrypt (
    WORD  ibSeek,
    PVOID pbBuffer,
    WORD  cbBuffer
    );

INT
CompareCacheNames (
    const CHAR* pbRes1,
    WORD        cbRes1,
    const CHAR* pbRes2,
    WORD        cbRes2
    );

DWORD
LoadEncryptedHeader (
    VOID
    );

DWORD
LoadPlaintextHeader (
    VOID
    );

DWORD
LookupEntry (
    const CHAR*            pbResource,
    WORD                   cbResource,
    UCHAR                  nType,
    PASSWORD_CACHE_ENTRY** ppce
    );

DWORD
ValidateEncryptedHeader (
    VOID
    );

DWORD
FindPWLResource (
    const CHAR* pbResource,
    WORD        cbResource,
    CHAR*       pbBuffer,
    WORD        cbBuffer,
    UCHAR       nType
    );

DWORD
FindNewestFile (
    IN OUT CHAR* SourceName
    );

VOID
DeleteAllPwls (
    VOID
    );

BOOL
StrCpyAFromWUsingAnsiEncoding(
    LPSTR   pszDst,
    LPCWSTR pszSrc,
    DWORD   dwDstChars
    );

BOOL
StrCpyWFromAUsingAnsiEncoding(
    WCHAR* pszDst,
    LPCSTR pszSrc,
    DWORD  dwDstChars
    );

VOID
CopyAndTruncate (
    LPSTR  lpszDest,
    LPCSTR lpszSrc,
    UINT   cbDest,
    BOOL   flag
    );

DWORD
OpenPWL (
    CHAR* Username,
    CHAR* Password,
    BOOL  flag
    );

DWORD
FindPWLString (
    IN CHAR*     EntryName,
    IN CHAR*     ConnUser,
    IN OUT CHAR* Output
    );

BOOL
MigrateEntryCreds (
    IN OUT PRAS_DIALPARAMS prdp,
    IN     PCTSTR          pszEntryName,
    IN     PCTSTR          pszUserName,
    IN     PDWORD          pdwFlag
    );

#endif // _PCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\quota.h ===
//
// This was extracted from ntexapi.h because it
// won't compile along with windows.h.
//

typedef struct _SYSTEM_REGISTRY_QUOTA_INFORMATION {
    ULONG RegistryQuotaAllowed;
    ULONG RegistryQuotaUsed;
    ULONG PagedPoolSize;
} SYSTEM_REGISTRY_QUOTA_INFORMATION, *PSYSTEM_REGISTRY_QUOTA_INFORMATION;

typedef struct _SYSTEM_POOL_ENTRY {
    BOOLEAN Allocated;
    BOOLEAN Spare0;
    USHORT AllocatorBackTraceIndex;
    ULONG Size;
    union {
        UCHAR Tag[4];
        ULONG TagUlong;
        PVOID ProcessChargedQuota;
    };
} SYSTEM_POOL_ENTRY, *PSYSTEM_POOL_ENTRY;

typedef struct _SYSTEM_POOL_INFORMATION {
    ULONG TotalSize;
    PVOID FirstEntry;
    USHORT EntryOverhead;
    BOOLEAN PoolTagPresent;
    BOOLEAN Spare0;
    ULONG NumberOfEntries;
    SYSTEM_POOL_ENTRY Entries[1];
} SYSTEM_POOL_INFORMATION, *PSYSTEM_POOL_INFORMATION;

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation,
    SystemProcessorInformation,             // obsolete...delete
    SystemPerformanceInformation,
    SystemTimeOfDayInformation,
    SystemPathInformation,
    SystemProcessInformation,
    SystemCallCountInformation,
    SystemDeviceInformation,
    SystemProcessorPerformanceInformation,
    SystemFlagsInformation,
    SystemCallTimeInformation,
    SystemModuleInformation,
    SystemLocksInformation,
    SystemStackTraceInformation,
    SystemPagedPoolInformation,
    SystemNonPagedPoolInformation,
    SystemHandleInformation,
    SystemObjectInformation,
    SystemPageFileInformation,
    SystemVdmInstemulInformation,
    SystemVdmBopInformation,
    SystemFileCacheInformation,
    SystemPoolTagInformation,
    SystemInterruptInformation,
    SystemDpcBehaviorInformation,
    SystemFullMemoryInformation,
    SystemLoadGdiDriverInformation,
    SystemUnloadGdiDriverInformation,
    SystemTimeAdjustmentInformation,
    SystemSummaryMemoryInformation,
    SystemUnused1,
    SystemUnused2,
    SystemCrashDumpInformation,
    SystemExceptionInformation,
    SystemCrashDumpStateInformation,
    SystemKernelDebuggerInformation,
    SystemContextSwitchInformation,
    SystemRegistryQuotaInformation,
    SystemExtendServiceTableInformation,
    SystemPrioritySeperation,
    SystemUnused3,
    SystemUnused4,
    SystemUnused5,
    SystemUnused6,
    SystemCurrentTimeZoneInformation,
    SystemLookasideInformation,
    SystemTimeSlipNotification
} SYSTEM_INFORMATION_CLASS;

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
NtSetSystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\shllink.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    shllink.c

Abstract:

    Functions to modify shell links (LNKs) and PIFs.

Author:

    Mike Condra (mikeco)        (Date unknown)

Revision History:

    calinn      23-Sep-1998 Substantial redesign
    calinn      15-May-1998 added GetLnkTarget and GetPifTarget

--*/


#include "pch.h"
#include "migmainp.h"
#include <shlobjp.h>
#include <shlguidp.h>

#ifndef UNICODE
#error UNICODE required for shllink.c
#endif


//
// Static prototypes
//

BOOL
pModifyLnkFile (
    IN      PCTSTR ShortcutName,
    IN      PCTSTR ShortcutTarget,
    IN      PCTSTR ShortcutArgs,
    IN      PCTSTR ShortcutWorkDir,
    IN      PCTSTR ShortcutIconPath,
    IN      INT ShortcutIconNr,
    IN      PLNK_EXTRA_DATA ExtraData,   OPTIONAL
    IN      BOOL ForceToShowNormal
    )
{
    PTSTR NewShortcutName;
    PTSTR fileExt;
    IShellLink   *psl = NULL;
    IPersistFile *ppf = NULL;

    HRESULT comResult;

    if (FAILED (CoInitialize (NULL))) {
        return FALSE;
    }

    __try {
        if (!DoesFileExist (ShortcutName)) {
            __leave;
        }
        if (((ShortcutTarget   == NULL) || (ShortcutTarget   [0] == 0)) &&
            ((ShortcutWorkDir  == NULL) || (ShortcutWorkDir  [0] == 0)) &&
            ((ShortcutIconPath == NULL) || (ShortcutIconPath [0] == 0)) &&
            (ShortcutIconNr == 0) &&
            (ExtraData == NULL)
            ) {
            __leave;
        }

        if (ExtraData) {
            NewShortcutName = DuplicatePathString (ShortcutName, 0);
            fileExt = (PTSTR)GetFileExtensionFromPath (NewShortcutName);
            MYASSERT (fileExt);
            //
            // We know for sure that this had PIF as extension so this copy is safe
            //
            StringCopy (fileExt, TEXT("LNK"));
        } else {
            NewShortcutName = (PTSTR)ShortcutName;
        }

        comResult = CoCreateInstance (
                        &CLSID_ShellLink,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        &IID_IShellLink,
                        (void **) &psl);
        if (comResult != S_OK) {
            LOG ((LOG_ERROR, "LINKEDIT: CoCreateInstance failed for %s", NewShortcutName));
            __leave;
        }

        comResult = psl->lpVtbl->QueryInterface (psl, &IID_IPersistFile, (void **) &ppf);
        if (comResult != S_OK) {
            LOG ((LOG_ERROR, "LINKEDIT: QueryInterface failed for %s", NewShortcutName));
            __leave;
        }

        //
        // We only load if the file was really a LNK
        //
        if (!ExtraData) {
            comResult = ppf->lpVtbl->Load(ppf, NewShortcutName, STGM_READ);
            if (comResult != S_OK) {
                LOG ((LOG_ERROR, "LINKEDIT: Load failed for %s", NewShortcutName));
                __leave;
            }
        }

        if (ShortcutTarget != NULL) {
            comResult = psl->lpVtbl->SetPath (psl, ShortcutTarget);
            if (comResult != S_OK) {
                DEBUGMSG ((DBG_WARNING, "LINKEDIT: SetPath failed for %s", NewShortcutName));
            }
        }
        if (ShortcutArgs != NULL) {
            comResult = psl->lpVtbl->SetArguments (psl, ShortcutArgs);
            if (comResult != S_OK) {
                DEBUGMSG ((DBG_WARNING, "LINKEDIT: SetArguments failed for %s", ShortcutArgs));
            }
        }
        if (ShortcutWorkDir != NULL) {
            comResult = psl->lpVtbl->SetWorkingDirectory (psl, ShortcutWorkDir);
            if (comResult != S_OK) {
                DEBUGMSG ((DBG_WARNING, "LINKEDIT: SetWorkingDirectory failed for %s", NewShortcutName));
            }
        }
        if (ShortcutIconPath != NULL) {
            comResult = psl->lpVtbl->SetIconLocation (psl, ShortcutIconPath, ShortcutIconNr);
            if (comResult != S_OK) {
                DEBUGMSG ((DBG_WARNING, "LINKEDIT: SetIconLocation failed for %s", NewShortcutName));
            }
        }

        if (ForceToShowNormal) {
            comResult = psl->lpVtbl->SetShowCmd (psl, SW_SHOWNORMAL);
            if (comResult != S_OK) {
                DEBUGMSG ((DBG_WARNING, "LINKEDIT: SetShowCmd failed for %s", NewShortcutName));
            }
        }

        //
        // add NT_CONSOLE_PROPS here
        //
        if (ExtraData) {

            HRESULT hres;
            NT_CONSOLE_PROPS props;

            IShellLinkDataList *psldl;
            //
            // Get a pointer to the IShellLinkDataList interface.
            //
            hres = psl->lpVtbl->QueryInterface (psl, &IID_IShellLinkDataList, &psldl);

            if (!SUCCEEDED (hres)) {
                DEBUGMSG ((DBG_WARNING, "Cannot get IShellLinkDataList interface"));
                __leave;
            }

            ZeroMemory (&props, sizeof (NT_CONSOLE_PROPS));
            props.cbSize = sizeof (NT_CONSOLE_PROPS);
            props.dwSignature = NT_CONSOLE_PROPS_SIG;

            //
            // We know that no extra data exists in this LNK because we just created it.
            // We need to fill some good data for this console
            //

            props.wFillAttribute = 0x0007;
            props.wPopupFillAttribute = 0x00f5;
            props.dwScreenBufferSize.X = (SHORT)ExtraData->xSize;
            props.dwScreenBufferSize.Y = (SHORT)ExtraData->ySize;
            props.dwWindowSize.X = (SHORT)ExtraData->xSize;
            props.dwWindowSize.Y = (SHORT)ExtraData->ySize;
            props.dwWindowOrigin.X = 0;
            props.dwWindowOrigin.Y = 0;
            props.nFont = 0;
            props.nInputBufferSize = 0;
            props.dwFontSize.X = (UINT)ExtraData->xFontSize;
            props.dwFontSize.Y = (UINT)ExtraData->yFontSize;
            props.uFontFamily = ExtraData->FontFamily;
            props.uFontWeight = ExtraData->FontWeight;
            StringCopy (props.FaceName, ExtraData->FontName);
            props.uCursorSize = 0x0019;
            props.bFullScreen = ExtraData->FullScreen;
            props.bQuickEdit = ExtraData->QuickEdit;
            props.bInsertMode = FALSE;
            props.bAutoPosition = TRUE;
            props.uHistoryBufferSize = 0x0032;
            props.uNumberOfHistoryBuffers = 0x0004;
            props.bHistoryNoDup = FALSE;
            props.ColorTable [0] = 0x00000000;
            props.ColorTable [1] = 0x00800000;
            props.ColorTable [2] = 0x00008000;
            props.ColorTable [3] = 0x00808000;
            props.ColorTable [4] = 0x00000080;
            props.ColorTable [5] = 0x00800080;
            props.ColorTable [6] = 0x00008080;
            props.ColorTable [7] = 0x00c0c0c0;
            props.ColorTable [8] = 0x00808080;
            props.ColorTable [9] = 0x00ff0000;
            props.ColorTable [10] = 0x0000ff00;
            props.ColorTable [11] = 0x00ffff00;
            props.ColorTable [12] = 0x000000ff;
            props.ColorTable [13] = 0x00ff00ff;
            props.ColorTable [14] = 0x0000ffff;
            props.ColorTable [15] = 0x00ffffff;
            comResult = psldl->lpVtbl->AddDataBlock (psldl, &props);
            if (comResult != S_OK) {
                DEBUGMSG ((DBG_WARNING, "LINKEDIT: AddDataBlock failed for %s", NewShortcutName));
            }
        }

        comResult = ppf->lpVtbl->Save (ppf, NewShortcutName, FALSE);
        if (comResult != S_OK) {
            DEBUGMSG ((DBG_WARNING, "LINKEDIT: Save failed for %s", NewShortcutName));
        }

        if (ExtraData) {
            ForceOperationOnPath (ShortcutName, OPERATION_CLEANUP);
        }

        comResult = ppf->lpVtbl->SaveCompleted (ppf, NewShortcutName);
        if (comResult != S_OK) {
            DEBUGMSG ((DBG_WARNING, "LINKEDIT: SaveCompleted failed for %s", NewShortcutName));
        }
    }
    __finally {
        if (ppf != NULL) {
            ppf->lpVtbl->Release (ppf);
            ppf = NULL;
        }
        if (psl != NULL) {
            psl->lpVtbl->Release (psl);
            psl = NULL;
        }
        CoUninitialize ();
    }
    return TRUE;
}

BOOL
pModifyPifFile (
        IN      PCTSTR ShortcutName,
        IN      PCTSTR ShortcutTarget,
        IN      PCTSTR ShortcutArgs,
        IN      PCTSTR ShortcutWorkDir,
        IN      PCTSTR ShortcutIconPath,
        IN      INT  ShortcutIconNr
        )
{
    PCSTR fileImage  = NULL;
    HANDLE mapHandle  = NULL;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    PCSTR AnsiStr = NULL;
    PSTDPIF stdPif;
    PWENHPIF40 wenhPif40;
    PW386PIF30 w386ext30;

    __try {
        fileImage = MapFileIntoMemoryEx (ShortcutName, &fileHandle, &mapHandle, TRUE);
        if (fileImage == NULL) {
            __leave;
        }
        __try {
            stdPif = (PSTDPIF) fileImage;
            if (ShortcutTarget != NULL) {

                AnsiStr = CreateDbcs (ShortcutTarget);
                strncpy (stdPif->startfile, AnsiStr, PIFSTARTLOCSIZE);
                DestroyDbcs (AnsiStr);
            }

            if (ShortcutArgs != NULL) {

                AnsiStr = CreateDbcs (ShortcutArgs);
                strncpy (stdPif->params, AnsiStr, PIFPARAMSSIZE);
                DestroyDbcs (AnsiStr);
            }

            if (ShortcutWorkDir != NULL) {

                AnsiStr = CreateDbcs (ShortcutWorkDir);
                strncpy (stdPif->defpath, AnsiStr, PIFDEFPATHSIZE);
                DestroyDbcs (AnsiStr);
            }

            if (ShortcutIconPath != NULL) {
                wenhPif40 = (PWENHPIF40) FindEnhPifSignature ((PVOID)fileImage, WENHHDRSIG40);

                if (wenhPif40 != NULL) {

                    AnsiStr = CreateDbcs (ShortcutIconPath);
                    strncpy (wenhPif40->achIconFileProp, AnsiStr, PIFDEFFILESIZE);
                    DestroyDbcs (AnsiStr);

                    wenhPif40->wIconIndexProp = (WORD)ShortcutIconNr;
                }
            }
            // in all cases we want to take off MSDOS mode otherwise NT won't start these PIFs
            w386ext30 = FindEnhPifSignature ((PVOID)fileImage, W386HDRSIG30);
            if (w386ext30) {
                w386ext30->PfW386Flags = w386ext30->PfW386Flags & (~fRealMode);
                w386ext30->PfW386Flags = w386ext30->PfW386Flags & (~fRealModeSilent);
            }
        }
        __except (1) {
            // something went wrong when we tried to read or write PIF file,
            // let's just do nothing and exit from here

            DEBUGMSG ((DBG_WARNING, "Exception thrown when processing %s", ShortcutName));
        }
    }
    __finally {
        UnmapFile ((PVOID) fileImage, mapHandle, fileHandle);
    }

    return TRUE;
}


BOOL
ModifyShellLink(
    IN      PCWSTR ShortcutName,
    IN      PCWSTR ShortcutTarget,
    IN      PCWSTR ShortcutArgs,
    IN      PCWSTR ShortcutWorkDir,
    IN      PCWSTR ShortcutIconPath,
    IN      INT ShortcutIconNr,
    IN      BOOL ConvertToLnk,
    IN      PLNK_EXTRA_DATA ExtraData,   OPTIONAL
    IN      BOOL ForceToShowNormal
    )
{
    PCTSTR shortcutExt;

    __try {

        shortcutExt = GetFileExtensionFromPath (ShortcutName);

        MYASSERT (shortcutExt);

        if (StringIMatch (shortcutExt, TEXT("LNK"))) {
            return pModifyLnkFile (
                        ShortcutName,
                        ShortcutTarget,
                        ShortcutArgs,
                        ShortcutWorkDir,
                        ShortcutIconPath,
                        ShortcutIconNr,
                        NULL,
                        ForceToShowNormal
                        );

        } else if (StringIMatch (shortcutExt, TEXT("PIF"))) {
            if (ConvertToLnk) {
                MYASSERT (ExtraData);
                return pModifyLnkFile (
                            ShortcutName,
                            ShortcutTarget,
                            ShortcutArgs,
                            ShortcutWorkDir,
                            ShortcutIconPath,
                            ShortcutIconNr,
                            ExtraData,
                            ForceToShowNormal
                            );
            } else {
                return pModifyPifFile (
                            ShortcutName,
                            ShortcutTarget,
                            ShortcutArgs,
                            ShortcutWorkDir,
                            ShortcutIconPath,
                            ShortcutIconNr
                            );
            }
        }
    }
    __except (1) {
        LOG ((LOG_ERROR, "Cannot process shortcut %s", ShortcutName));
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\stf.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  stf.c

Abstract:

  Applications that use the ACME Setup toolkit leave .STF files with their
  installation, so ACME can reinstall or uninstall the application.  During
  the upgrade, we move paths around, and we confuse ACME Setup to the point
  where it won't run.

  The routines in this file update all STF files found on the system.  Each
  STF has an associated INF file, and the code here parses the STF and INF
  files into memory structures, and then enumerates the structures in
  various ways, updating all the paths.

  Entry points:

  ProcessStfFiles - Enumerates all STF files and processes those that have
                    not already been handled in another way.  The older
                    STF files are overwritten.

  See the ACME Setup specification for more details on the format of STF
  files and their associated INFs.

Author:

  Jim Schmidt (jimschm) 12-Sep-1997

Revision History:

  jimschm   28-Sep-1998     Updated to change all altered dirs

--*/

#include "pch.h"
#include "migmainp.h"

#include "stftable.h"
#include "fileops.h"
#include "stfp.h"


#define DBG_STF  "STF"

#define S_SECTIONNAME_SPRINTF TEXT("Win9xUpg_%u")

#define COLUMN_OBJECT_ID            0
#define COLUMN_COMMAND              4
#define COLUMN_OBJECT_DATA          5
#define COLUMN_DEST_DIR             10
#define COLUMN_INSTALL_DESTDIR      14


PVOID
pBuildObjectIdTable (
    IN      PSETUPTABLE TablePtr,
    OUT     PUINT FirstLinePtr,         OPTIONAL
    OUT     PUINT LastLinePtr           OPTIONAL
    );


BOOL
pIsObjIdValid (
    IN      PVOID ObjIdTable,
    IN      UINT ObjId,
    OUT     PUINT Line          OPTIONAL
    );



BOOL
ProcessStfFiles (
    VOID
    )

/*++

Routine Description:

  ProcessStfFiles enumerates the memdb category Stf and converts
  the paths in the STF to the new locations.

Arguments:

  none

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    MEMDB_ENUM e;
    DWORD ops;

    if (MemDbGetValueEx (&e, MEMDB_CATEGORY_STF, NULL, NULL)) {
        do {
            //
            // Is file handled?  If so, skip it.
            //

            ops = GetOperationsOnPath (e.szName);
            if (ops & (OPERATION_MIGDLL_HANDLED|ALL_DELETE_OPERATIONS|OPERATION_FILE_DISABLED)) {
                continue;
            }

            //
            // Process the file
            //

            DEBUGMSG ((DBG_STF, "Processing %s", e.szName));

            if (!pProcessSetupTableFile (e.szName)) {
                //
                // Log the failure
                //

                LOG ((LOG_INFORMATION, (PCSTR)MSG_COULD_NOT_PROCESS_STF_LOG, e.szName));
            } else {
                TickProgressBar ();
            }

        } while (MemDbEnumNextValue (&e));
    }

    return TRUE;
}


BOOL
pProcessSetupTable (
    IN OUT  PSETUPTABLE TablePtr
    )

/*++

Routine Description:

  pProcessSetupTable scans the entire setup table file specified, looking
  for CopyFile, CopySection, RemoveFile or RemoveSection lines.  If any are
  found, any paths that point to moved or deleted files are adjusted, and
  any STF group references are updated.

Arguments:

  TablePtr - Specifies the setup table file to process

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    UINT MaxObj;
    UINT Line;
    UINT Obj;
    PCTSTR EntryStr;
    PCTSTR DataStr;
    PCTSTR InstallDestDir;
    PCTSTR *ArgArray;
    PCTSTR p;
    UINT ArgCount;
    PTABLEENTRY Entry;
    TCHAR SystemDir[MAX_TCHAR_PATH];
    UINT SystemDirLen;
    PCTSTR UpdatedDir;
    PVOID ObjTable;
    TCHAR MovedPath[MAX_TCHAR_PATH];
    DWORD MovedPathLen;
    PCTSTR NewPath;
    PTSTR q;
    DWORD FileStatus;
    PTSTR *ListOfWacks;
    PTSTR *WackPos;
    BOOL Result = TRUE;

    MaxObj = TablePtr->MaxObj;

    if (TablePtr->SourceInfFile != INVALID_HANDLE_VALUE) {
        //
        // If an INF is specified, scan the STF/INF pair for references to moved files.
        // If found, correct the files.
        //

        for (Line = 0 ; Line < TablePtr->LineCount ; Line++) {

            if (!pGetNonEmptyTableEntry (TablePtr, Line, COLUMN_OBJECT_ID, NULL, &EntryStr)) {
                continue;
            }

            Obj = _ttoi (EntryStr);
            if (Obj < 1 || Obj > MaxObj) {
                continue;
            }

            //
            // CopySection or RemoveSection: Data column has INF section name
            //

            if (!pGetNonEmptyTableEntry (TablePtr, Line, COLUMN_COMMAND, NULL, &EntryStr)) {
                continue;
            }

            if (!pGetNonEmptyTableEntry (TablePtr, Line, COLUMN_OBJECT_DATA, NULL, &DataStr)) {
                continue;
            }

            InstallDestDir = GetDestDir (TablePtr, Line);
            if (!InstallDestDir) {
                continue;
            }

            ArgArray = ParseCommaList (TablePtr, DataStr);
            if (!ArgArray) {
                continue;
            }

            for (ArgCount = 0 ; ArgArray[ArgCount] ; ArgCount++) {
                // empty
            }

            __try {

                if (StringIMatch (EntryStr, TEXT("CopySection")) ||
                    StringIMatch (EntryStr, TEXT("RemoveSection"))
                    ) {
                    if (ArgCount != 1) {
                        continue;
                    }

                    if (!pProcessSectionCommand (TablePtr, Line, ArgArray[0], InstallDestDir)) {
                        DEBUGMSG ((DBG_STF, "%s [%s] could not be processed", EntryStr, ArgArray[0]));
                        Result = FALSE;
                        __leave;
                    }
                }

                else if (StringIMatch (EntryStr, TEXT("CopyFile")) ||
                         StringIMatch (EntryStr, TEXT("RemoveFile")) ||
                         StringIMatch (EntryStr, TEXT("InstallSysFile"))
                         ) {

                    if (ArgCount != 2) {
                        continue;
                    }

                    if (!pProcessLineCommand (TablePtr, Line, ArgArray[0], ArgArray[1], InstallDestDir)) {
                        DEBUGMSG ((DBG_STF, "%s [%s] %s could not be processed", EntryStr, ArgArray[0], ArgArray[1]));
                        Result = FALSE;
                        __leave;
                    }
                }

                else if (StringIMatch (EntryStr, TEXT("CompanionFile"))) {

                    if (ArgCount != 2) {
                        continue;
                    }

                    // First arg has a colon -- skip past it
                    p = _tcschr (ArgArray[0], TEXT(':'));
                    if (!p) {
                        continue;
                    }
                    p = SkipSpace (_tcsinc (p));

                    if (!pProcessLineCommand (TablePtr, Line, p, ArgArray[1], InstallDestDir)) {
                        DEBUGMSG ((DBG_STF, "%s [%s] %s could not be processed", EntryStr, ArgArray[0], ArgArray[1]));
                        Result = FALSE;
                        __leave;
                    }
                }

                else if (StringIMatch (EntryStr, TEXT("InstallShared"))) {

                    if (ArgCount != 5) {
                        continue;
                    }

                    if (!pProcessLineCommand (TablePtr, Line, ArgArray[0], ArgArray[1], InstallDestDir)) {
                        DEBUGMSG ((DBG_STF, "%s [%s] %s could not be processed", EntryStr, ArgArray[0], ArgArray[1]));
                        Result = FALSE;
                        __leave;
                    }
                }
            }
            __finally {
                FreeDestDir (TablePtr, InstallDestDir);
                FreeCommaList (TablePtr, ArgArray);
            }
        }
    }

    //
    // Perform STF-only processing
    //

    SystemDirLen = wsprintf (SystemDir, TEXT("%s\\system\\"), g_WinDir);
    ObjTable = pBuildObjectIdTable (TablePtr, NULL, NULL);

    __try {
        for (Line = 0 ; Line < TablePtr->LineCount ; Line++) {

            //
            // Get InstallDestDir and Entry from the line that needs to be modified.
            //

            if (!pGetNonEmptyTableEntry (
                    TablePtr,
                    Line,
                    COLUMN_INSTALL_DESTDIR,
                    &Entry,
                    &InstallDestDir
                    )) {
                continue;
            }

            //
            // If InstallDestDir has a %windir%\system in it, we must adjust the path
            // to point to system32.
            //

            if (StringIMatchCharCount (InstallDestDir, SystemDir, SystemDirLen)) {
                UpdatedDir = JoinPaths (
                                g_System32Dir,
                                CharCountToPointer (InstallDestDir, SystemDirLen - 1)
                                );

                if (!ReplaceTableEntryStr (TablePtr, Entry, UpdatedDir)) {
                    LOG ((LOG_ERROR, "Could not replace a %%M path"));
                    Result = FALSE;
                }

                FreePathString (UpdatedDir);

                if (!Result) {
                    __leave;
                }
            }

            //
            // If InstallDestDir points to a moved dir, we must fix it
            //

            else if (*InstallDestDir && _tcsnextc (_tcsinc (InstallDestDir)) == TEXT(':')) {
                //
                // Build list of wacks in the path
                //

                ListOfWacks = (PTSTR *) MemAlloc (g_hHeap, 0, sizeof (PTSTR) * MAX_TCHAR_PATH);
                MYASSERT (ListOfWacks);

                StringCopy (MovedPath, InstallDestDir);
                q = _tcschr (MovedPath, TEXT('\\'));
                WackPos = ListOfWacks;

                if (q) {

                    while (*q) {
                        if (_tcsnextc (q) == TEXT('\\')) {
                            *WackPos = q;
                            WackPos++;
                        }

                        q = _tcsinc (q);
                    }

                    //
                    // We assume the STF always has an extra wack at the end
                    // of the path.
                    //

                    //
                    // Test each path from longest to shortest, skipping the root
                    //

                    FileStatus = FILESTATUS_UNCHANGED;

                    while (WackPos > ListOfWacks) {

                        WackPos--;
                        q = *WackPos;
                        *q = 0;

                        FileStatus = GetFileStatusOnNt (MovedPath);
                        if (FileStatus == FILESTATUS_MOVED) {
                            break;
                        }

                        DEBUGMSG_IF ((
                            FileStatus != FILESTATUS_UNCHANGED,
                            DBG_WARNING,
                            "STF may point to changed dir: %s",
                            MovedPath
                            ));
                    }

                    if (FileStatus == FILESTATUS_MOVED) {
                        //
                        // Adjust the STF path
                        //

                        NewPath = GetPathStringOnNt (MovedPath);

                        if (NewPath) {
                            MovedPathLen = (PBYTE) q - (PBYTE) MovedPath;

                            UpdatedDir = JoinPaths (
                                            NewPath,
                                            ByteCountToPointer (InstallDestDir, MovedPathLen)
                                            );

                            DEBUGMSG ((
                                DBG_STF,
                                "Line %u has a new install destination: %s",
                                Line,
                                UpdatedDir
                                ));

                            if (!ReplaceTableEntryStr (TablePtr, Entry, UpdatedDir)) {
                                LOG ((LOG_ERROR, "Could not replace a moved path"));
                                Result = FALSE;
                            }

                            FreePathString (UpdatedDir);
                            FreePathString (NewPath);

                            if (!Result) {
                                __leave;
                            }
                        }
                    }
                }

                MemFree (g_hHeap, 0, ListOfWacks);
            }
        }
    }
    __finally {
        if (ObjTable) {
            pSetupStringTableDestroy (ObjTable);
        }
    }

    //
    // Update all the lines that reference other OBJs.  This includes GROUP,
    // DEPEND and COMPANIONFILE lines.
    //

    return Result && pUpdateObjReferences (TablePtr);
}


PVOID
pBuildObjectIdTable (
    IN      PSETUPTABLE TablePtr,
    OUT     PUINT FirstLinePtr,         OPTIONAL
    OUT     PUINT LastLinePtr           OPTIONAL
    )
{
    PVOID ObjIds;
    UINT FirstLine, LastLine;
    UINT Line;
    UINT Obj;
    UINT MaxObj;
    PCTSTR EntryStr;
    TCHAR NumBuf[32];

    MaxObj = TablePtr->MaxObj;

    //
    // Alloc string table
    //

    ObjIds = pSetupStringTableInitializeEx (sizeof (DWORD), 0);
    if (!ObjIds) {
        LOG ((LOG_ERROR, "STF: Can't init string table"));
        return NULL;
    }

    //
    // Fill string table with list of ObjIDs
    //

    FirstLine = 0;
    LastLine = TablePtr->LineCount;

    for (Line = 0 ; Line < LastLine ; Line++) {
        if (!pGetNonEmptyTableEntry (TablePtr, Line, COLUMN_OBJECT_ID, NULL, &EntryStr)) {
            continue;
        }

        Obj = _ttoi (EntryStr);
        if (Obj < 1 || Obj > MaxObj) {
            continue;
        }

        if (!FirstLine) {
            FirstLine = Line;
        }

        wsprintf (NumBuf, TEXT("%u"), Obj);
        if (-1 == pSetupStringTableAddStringEx (
                        ObjIds,
                        NumBuf,
                        STRTAB_CASE_SENSITIVE,
                        (PBYTE) &Line,
                        sizeof (DWORD)
                        )) {
            LOG ((LOG_ERROR, "STF: Can't add to string table"));
            break;
        }
    }

    if (FirstLinePtr) {
        *FirstLinePtr = FirstLine;
    }

    if (LastLinePtr) {
        *LastLinePtr = LastLine;
    }

    return ObjIds;
}



BOOL
pIsObjIdValid (
    IN      PVOID ObjIdTable,
    IN      UINT ObjId,
    OUT     PUINT Line          OPTIONAL
    )
{
    TCHAR NumBuf[32];
    LONG rc;
    DWORD LineData;

    wsprintf (NumBuf, TEXT("%u"), ObjId);

    rc = pSetupStringTableLookUpStringEx (
            ObjIdTable,
            NumBuf,
            STRTAB_CASE_SENSITIVE|STRTAB_BUFFER_WRITEABLE,
            (PBYTE) &LineData,
            sizeof (DWORD)
            );

    if (Line && rc != -1) {
        *Line = LineData;
    }

    return rc != -1;
}


PCTSTR
pValidateGroup (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR EntryStr,
    IN      PVOID ObjIds
    )

/*++

Routine Description:

  pValidateGroup parses all object IDs in the EntryStr, compares them against
  the string table ObjIds, and adds only those IDs that are in both EntryStr
  and ObjIds.  The caller receives a text pool string, which may be
  empty.

  The buffer must be freed by the caller with FreeText.

Arguments:

  TablePtr - Specifies the setup table being processed
  EntryStr - Specifies the entry string that contains zero or more numeric
             object ID references, sparated by spaces.
  ObjIds   - Specifies the string table of valid object IDs.

Return Value:

  A pointer to the validated object ID string, or NULL if memory allocation
  failed.

--*/

{
    PTSTR Buffer;
    PTSTR p;
    PCTSTR q;
    CHARTYPE ch;
    UINT Obj;
    TCHAR NumBuf[32];

    //
    // Validate EntryStr
    //

    Buffer = AllocText (CharCount (EntryStr) + 1);
    if (!Buffer) {
        return NULL;
    }

    p = Buffer;
    *p = 0;

    q = EntryStr;
    while (*q) {
        ch = (CHARTYPE)_tcsnextc (q);

        if (ch >= TEXT('0') && ch <= TEXT('9')) {
            //
            // Extract object ID reference
            //

            Obj = 0;

            for (;;) {
                ch = (CHARTYPE)_tcsnextc (q);

                if (ch >= TEXT('0') && ch <= TEXT('9')) {
                    Obj = Obj * 10 + (ch - TEXT('0'));
                } else {
                    break;
                }

                q = _tcsinc (q);
            }

            //
            // If match found, add obj ID to data
            //

            if (pIsObjIdValid (ObjIds, Obj, NULL)) {
                wsprintf (NumBuf, TEXT("%u"), Obj);
                p = _tcsappend (p, NumBuf);
            }
        } else {
            _copytchar (p, q);
            p = _tcsinc (p);
            *p = 0;
            q = _tcsinc (q);
        }
    }

    return Buffer;
}



BOOL
pUpdateObjReferences (
    IN      PSETUPTABLE TablePtr
    )

/*++

Routine Description:

  pUpdateObjReferences scans the specified table for GROUP, DEPEND and COMPANIONFILE
  lines, and for each line found, the line is updated.

  In the case of a GROUP line, the data argument is updated if it points to one or
  more invalid object IDs.  If the cleanup operation causes a group to have zero
  items, the group line itself is deleted, and the update is restarted.

  In the case of a DEPEND line, if the first object ID no longer exists, then
  the line is deleted, and the update is restarted.  If an obj in the group
  following the ? no longer exists, then the obj reference is deleted.  If the
  delete causes no objects to be listed, then the line is deleted.

  In the case of a COMPANIONFILE line, the object ID is extracted from the data
  argument, and the line is deleted if its original line is gone.

  NOTE: This routine has a lot of exit conditions that cause leaks, but all of them
        can only be hit by memory allocation failures

Arguments:

  TablePtr - Specifies the setup table file to process

Return Value:

  TRUE if processing was successful, or FALSE if an error occured.  FALSE will cause
  STF processing to fail for the current STF, and will likely generate an error log
  entry.

--*/

{
    UINT Line;
    PVOID ObjIds;
    PCTSTR EntryStr;
    UINT Obj;
    BOOL b = FALSE;
    UINT FirstLine, LastLine;
    PTSTR Buffer;
    PTSTR DependBuf;
    PTSTR p;
    BOOL StartOver;
    PTABLEENTRY Entry;
    BOOL GroupMode;
    BOOL CompanionFileMode;
    BOOL DependMode;

    do {

        StartOver = FALSE;

        ObjIds = pBuildObjectIdTable (TablePtr, &FirstLine, &LastLine);
        if (!ObjIds) {
            return FALSE;
        }

        Line = TablePtr->LineCount;
        if (!FirstLine) {
            //
            // Small table -- no object IDs at all!  Return TRUE to caller.
            //

            b = TRUE;
            Line = 0;
        }

        //
        // Look for lines that have object ID references
        //

        if (Line == TablePtr->LineCount) {
            for (Line = FirstLine ; !StartOver && Line < LastLine ; Line++) {
                if (!pGetNonEmptyTableEntry (TablePtr, Line, COLUMN_COMMAND, NULL, &EntryStr)) {
                    continue;
                }

                GroupMode = StringIMatch (EntryStr, TEXT("Group"));
                CompanionFileMode = StringIMatch (EntryStr, TEXT("CompanionFile"));
                DependMode = StringIMatch (EntryStr, TEXT("Depend"));

                if (!GroupMode && !CompanionFileMode && !DependMode) {
                    continue;
                }

                if (!pGetNonEmptyTableEntry (TablePtr, Line, COLUMN_OBJECT_DATA, NULL, &EntryStr)) {
                    continue;
                }

                if (GroupMode) {

                    Buffer = (PTSTR) pValidateGroup (TablePtr, EntryStr, ObjIds);
                    if (!Buffer) {
                        break;
                    }

                    //
                    // If Buffer is empty, delete the group line, then start over
                    //

                    if (*Buffer == 0) {
                        pDeleteStfLine (TablePtr, Line);
                        StartOver = TRUE;

                        DEBUGMSG ((
                            DBG_STF,
                            "Group line %u references only deleted lines, so it was deleted as well.",
                            Line
                            ));
                    }

                    //
                    // If Buffer is not empty, replace the data on the current line
                    //

                    else if (!StringMatch (EntryStr, Buffer)) {
                        DEBUGMSG ((
                            DBG_STF,
                            "Group has reference to one or more deleted objects.  Original: %s  New: %s",
                            EntryStr,
                            Buffer
                            ));

                        Entry = GetTableEntry (TablePtr, Line, COLUMN_OBJECT_DATA, NULL);
                        MYASSERT (Entry);

                        if (Entry) {
                            if (!ReplaceTableEntryStr (TablePtr, Entry, Buffer)) {
                                break;
                            }
                        }
                    }

                    FreeText (Buffer);
                }

                if (!StartOver && (DependMode || CompanionFileMode)) {
                    //
                    // Extract the obj ID from the data arg
                    //

                    Obj = _ttoi (EntryStr);
                    if (Obj || EntryStr[0] == TEXT('0')) {

                        if (!pIsObjIdValid (ObjIds, Obj, NULL)) {
                            //
                            // CompanionFile/Depend is for a line that was deleted.  Delete
                            // the line and start over.
                            //

                            pDeleteStfLine (TablePtr, Line);
                            StartOver = TRUE;

                            DEBUGMSG_IF ((
                                CompanionFileMode,
                                DBG_STF,
                                "CompanionFile line %u references a deleted line %u, so it was deleted as well.",
                                Line,
                                Obj
                                ));

                            DEBUGMSG_IF ((
                                DependMode,
                                DBG_STF,
                                "Depend line %u references a deleted line %u, so it was deleted as well.",
                                Line,
                                Obj
                                ));
                        }
                    }
                }

                if (!StartOver && DependMode) {
                    //
                    // Go beyond question mark, then validate group
                    //

                    p = _tcschr (EntryStr, TEXT('?'));
                    if (p) {
                        p = _tcsinc (p);
                        while (*p == TEXT(' ')) {
                            p++;
                        }

                        Buffer = (PTSTR) pValidateGroup (TablePtr, p, ObjIds);
                        if (!Buffer) {
                            break;
                        }

                        if (*Buffer == 0) {
                            pDeleteStfLine (TablePtr, Line);
                            StartOver = TRUE;

                            DEBUGMSG ((
                                DBG_STF,
                                "Depend line %u references only deleted lines, so it was deleted as well.",
                                Line
                                ));
                        }

                        //
                        // If Buffer is not empty, replace the data on the current line
                        //

                        else if (!StringMatch (p, Buffer)) {
                            DependBuf = AllocText (ByteCount (Buffer) + 32);
                            if (!DependBuf) {
                                break;
                            }

                            StringCopyAB (DependBuf, EntryStr, p);
                            StringCat (DependBuf, Buffer);

                            DEBUGMSG ((
                                DBG_STF,
                                "Depend line has reference to one or more deleted objects.  Original: %s  New: %s",
                                EntryStr,
                                DependBuf
                                ));

                            Entry = GetTableEntry (TablePtr, Line, COLUMN_OBJECT_DATA, NULL);
                            MYASSERT (Entry);

                            if (Entry) {
                                if (!ReplaceTableEntryStr (TablePtr, Entry, DependBuf)) {
                                    break;
                                }
                            }

                            FreeText (DependBuf);
                        }

                        FreeText (Buffer);

                    }

                }
            }

            //
            // If we managed to get through the loop, we are done!  Return TRUE to caller.
            //

            if (Line == LastLine) {
                b = TRUE;
            }
        }

        pSetupStringTableDestroy (ObjIds);

    } while (StartOver);

    return b;
}


BOOL
pGetNonEmptyTableEntry (
    IN      PSETUPTABLE TablePtr,
    IN      UINT Line,
    IN      UINT Col,
    OUT     PTABLEENTRY *EntryPtr,          OPTIONAL
    OUT     PCTSTR *EntryStr
    )

/*++

Routine Description:

  pGetNonEmptyTableEntry is a wrapper routine that gets an entry in the
  STF table and returns TRUE only if the string actually exists and is
  not empty.  If a non-empty string is found, the pointer is returned to
  the caller.

Arguments:

  TablePtr - Specifies the setup table file to process

  Line - Specifies the line to get the entry for

  Col - Specifies the column on the line to get the entry for

  EntryPtr - Receives a pointer to the entry struct

  EntryStr - Receives a pointer to the entry string

Return Value:

  TRUE if entry exists and is not empty, FALSE if the entry does not exist
  or is empty.

--*/

{
    PCTSTR String;
    PTABLEENTRY Entry;

    Entry = GetTableEntry (TablePtr, Line, Col, &String);
    if (!Entry) {
        return FALSE;
    }

    if (!String || !String[0]) {
        return FALSE;
    }

    if (EntryPtr) {
        *EntryPtr = Entry;
    }

    if (EntryStr) {
        *EntryStr = String;
    }

    return TRUE;
}


PCTSTR
pQuoteThis (
    IN      PCTSTR String
    )
{
    static TCHAR Buffer[128];

    MYASSERT (ByteCount (String) < (sizeof (Buffer) - 2));
    Buffer[0] = TEXT('\"');
    StringCopy (&Buffer[1], String);
    StringCat (Buffer, TEXT("\""));

    return Buffer;
}


BOOL
pProcessSectionCommand (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT StfLine,
    IN      PCTSTR InfSection,
    IN      PCTSTR InstallDestDir
    )

/*++

Routine Description:

  pProcessSectionCommand scans an INF section, determining which files
  are deleted, moved or unchanged.  If a file is moved or unchanged,
  it is added to memdb.  After the INF section is completely scanned,
  the memdb structure is processed, causing additional INF sections
  to be generated if any changes were made to the file paths.

Arguments:

  TablePtr - Specifies the setup table file to process

  StfLine - Specifies the STF line that has a CopySection or RemoveSection
            command.

  InfSection - Specifies the INF section that lists files to be processed

  InstallDestDir - Specifies destination directory specified by STF line

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    BOOL DeletedOrMoved = FALSE;
    PSTFINFLINE InfLine;
    PCTSTR * InfFields;
    UINT Fields;
    TCHAR FileName[MAX_TCHAR_PATH];
    TCHAR FullPath[MAX_TCHAR_PATH * 2];
    MEMDB_ENUM e;
    CONVERTPATH_RC rc;
    BOOL FirstSectionDone;
    BOOL CreatedFlag;
    PSTFINFSECTION NewInfSection;
    PSTFINFLINE SrcInfLine;
    PTSTR UpdatedData;
    TCHAR DirPart[MAX_TCHAR_PATH];
    PCTSTR FilePart;
    PTSTR p, q;
    PTABLEENTRY DataEntry;
    PCTSTR *Array;

    //
    // Step one: scan all files in the corresponding INF section,
    //           moving them to memdb.
    //

    InfLine = StfGetFirstLineInSectionStr (TablePtr, InfSection);
    if (!InfLine) {
        //
        // Workaround: sometimes the people who write the STFs embed all kinds of
        //             quotes in a section name.
        //
        Array = ParseCommaList (TablePtr, InfSection);
        if (Array) {
            if (Array[0]) {
                InfLine = StfGetFirstLineInSectionStr (TablePtr, Array[0]);
            }
            FreeCommaList (TablePtr, Array);
        }
    }

    if (!InfLine) {
        MYASSERT(InfSection);
        DEBUGMSG ((DBG_STF, "STF file references section %s that does not exist", InfSection));
        return TRUE;
    }

    __try {
        do {
            //
            // Parse the INF line into fields
            //

            InfFields = ParseCommaList (TablePtr, InfLine->Data);
            if (!InfFields) {
                MYASSERT(InfLine->Data);
                DEBUGMSG ((DBG_WARNING, "INF file has non-parsable data", InfLine->Data));
            } else {
                for (Fields = 0 ; InfFields[Fields] ; Fields++) {
                }

                if (Fields < 19) {
                    MYASSERT(InfLine->Data);
                    DEBUGMSG ((DBG_WARNING, "INF file line %s has less than 19 fields", InfLine->Data));
                } else {
                    //
                    // Get the file name from this INF line (field #2)
                    //

                    pGetFileNameFromInfField (FileName, InfFields[1]);

                    StringCopy (FullPath, InstallDestDir);
                    StringCat (AppendPathWack (FullPath), FileName);

                    rc = ConvertWin9xPath (FullPath);

                    if (rc != CONVERTPATH_NOT_REMAPPED) {
                        DeletedOrMoved = TRUE;
                    }

                    if (rc != CONVERTPATH_DELETED) {
                        //
                        // Add this file to memdb
                        //

                        if (!MemDbSetValueEx (
                                MEMDB_CATEGORY_STF_TEMP,
                                FullPath,
                                NULL,
                                NULL,
                                (DWORD) InfLine,
                                NULL
                                )) {
                            LOG ((LOG_ERROR, "STF: MemDbSetValueEx failed"));
                            return FALSE;
                        }
                    }
                }

                FreeCommaList (TablePtr, InfFields);
            }

            InfLine = StfGetNextLineInSection (InfLine);
        } while (InfLine);

        if (!DeletedOrMoved) {
            //
            // No changes necessary
            //
            return TRUE;
        }

        //
        // Now write out each unique directory to the INF.  Update
        // the STF line to point to the first new INF section.
        //

        FirstSectionDone = FALSE;

        if (MemDbGetValueEx (&e, MEMDB_CATEGORY_STF_TEMP, NULL, NULL)) {
            do {
                //
                // Name gives full path of new file location.
                // Value points to INF line that is to be copied.
                //

                NewInfSection = pGetNewInfSection (TablePtr, e.szName, &CreatedFlag);
                if (!NewInfSection) {
                    LOG ((LOG_ERROR, "Process Section Command failed because Get New Inf Section failed"));
                    return FALSE;
                }

                SrcInfLine = (PSTFINFLINE) e.dwValue;

                _tcssafecpy (DirPart, e.szName, MAX_TCHAR_PATH);
                FilePart = GetFileNameFromPath (DirPart);
                MYASSERT (FilePart && FilePart > DirPart);
                *_tcsdec2 (DirPart, FilePart) = 0;

                //
                // File name may have changed.  If so, specify the file name in the
                // angle brackets.
                //

                UpdatedData = DuplicatePathString (
                                  SrcInfLine->Data,
                                  SizeOfString (FilePart) + 2 * sizeof (TCHAR)
                                  );

                p = _tcschr (SrcInfLine->Data, TEXT(','));
                MYASSERT(p);
                p = _tcsinc (p);
                q = _tcschr (p, TEXT(','));
                MYASSERT(q);
                p = _tcschr (p, TEXT('<'));
                if (!p || p > q) {
                    p = q;
                }

                StringCopyAB (UpdatedData, SrcInfLine->Data, q);
                wsprintf (_tcschr (UpdatedData, 0), TEXT("<%s>"), FilePart);
                StringCat (UpdatedData, q);

                DEBUGMSG ((DBG_STF, "INF changed from %s to %s", SrcInfLine->Data, UpdatedData));
                StfAddInfLineToTable (TablePtr, NewInfSection, SrcInfLine->Key, UpdatedData, SrcInfLine->LineFlags);

                //
                // If first section, update STF line to use new section
                //

                if (!FirstSectionDone) {
                    DataEntry = GetTableEntry (TablePtr, StfLine, COLUMN_OBJECT_DATA, NULL);
                    if (!ReplaceTableEntryStr (TablePtr, DataEntry, pQuoteThis (NewInfSection->Name))) {
                        LOG ((LOG_ERROR, "Could not update table entry"));
                        return FALSE;
                    }
                    FirstSectionDone = TRUE;
                }

                //
                // If not first section and CreateFlag is TRUE, create a new STF line
                // and point it to new INF section.
                //

                else if (CreatedFlag) {
                    if (!pCreateNewStfLine (TablePtr, StfLine, pQuoteThis (NewInfSection->Name), DirPart)) {
                        LOG ((LOG_ERROR, "Could not create a new line"));
                        return FALSE;
                    }
                }
            } while (MemDbEnumNextValue (&e));
        } else {
            //
            // All files were deleted, and this STF line is no longer needed.
            //

            DEBUGMSG ((DBG_STF, "STF Line %u is no longer needed", StfLine));

            if (!pReplaceDirReferences (TablePtr, StfLine, InstallDestDir)) {
                return FALSE;
            }

            if (!pDeleteStfLine (TablePtr, StfLine)) {
                return FALSE;
            }
        }
    }
    __finally {
        MemDbDeleteTree (MEMDB_CATEGORY_STF_TEMP);
        MemDbDeleteTree (MEMDB_CATEGORY_STF_SECTIONS);
    }

    return TRUE;
}


VOID
pGenerateUniqueKeyName (
    IN      PSETUPTABLE TablePtr,
    IN      PSTFINFSECTION Section,
    IN      PCTSTR Root,
    OUT     PTSTR UniqueKey
    )
{
    UINT Sequencer = 0;
    PTSTR p;

    UniqueKey[0] = 0;
    p = _tcsappend (UniqueKey, Root);

    for (;;) {
        Sequencer++;
        wsprintf (p, TEXT("%03u"), Sequencer);

        if (!StfFindLineInInfSection (TablePtr, Section, UniqueKey)) {
            break;
        }
    }
}


BOOL
pProcessLineCommand (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT StfLine,
    IN      PCTSTR InfSection,
    IN      PCTSTR InfKey,
    IN      PCTSTR InstallDestDir
    )

/*++

Routine Description:

  pProcessLineCommand determinins if the file assoicated with the command
  was deleted, moved or unchanged.  If the file was deleted, the STF line
  is deleted.  If the file was moved, the STF line is adjusted.  If the
  file has no change, the routine does not modify the STF table.

Arguments:

  TablePtr - Specifies the setup table file to process

  StfLine - Specifies the STF line that has a CopySection or RemoveSection
            command.

  InfSection - Specifies the INF section that lists the file to be processed

  InfKey - Specifies the INF key in InfSection identifing the file

  InstallDestDir - Specifies destination directory specified by STF line

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    PSTFINFSECTION Section;
    PSTFINFLINE InfLine;
    PCTSTR *InfFields;
    UINT Fields;
    TCHAR FileName[MAX_TCHAR_PATH];
    TCHAR FullPath[MAX_TCHAR_PATH * 2];
    CONVERTPATH_RC rc;
    TCHAR OrgDirPart[MAX_TCHAR_PATH];
    PCTSTR OrgFilePart;
    TCHAR DirPart[MAX_TCHAR_PATH];
    PCTSTR FilePart;
    PTABLEENTRY DataEntry;
    PTABLEENTRY FileEntry;
    PCTSTR *Array;
    TCHAR NewKeyName[MAX_TCHAR_PATH];
    PTSTR NewLine;
    PTSTR p;
    UINT Size;
    PCTSTR OldField;

    Section = StfFindInfSectionInTable (TablePtr, InfSection);

    if (!Section) {
        //
        // Workaround: sometimes the people who write the STFs embed all kinds of
        //             quotes in a section name.
        //
        Array = ParseCommaList (TablePtr, InfSection);
        if (Array) {
            if (Array[0]) {
                Section = StfFindInfSectionInTable (TablePtr, Array[0]);
            }

            FreeCommaList (TablePtr, Array);
        }
    }

    if (!Section) {
        MYASSERT(InfSection);
        DEBUGMSG ((
            DBG_STF,
            "STF has reference to non-existent INF section ([%s])",
            InfSection
            ));
        return TRUE;
    }

    InfLine = StfFindLineInInfSection (TablePtr, Section, InfKey);
    if (!InfLine) {
        MYASSERT(InfSection && InfKey);
        DEBUGMSG ((
            DBG_STF,
            "STF has reference to non-existent INF key ([%s], %s)",
            InfSection,
            InfKey
            ));
        return TRUE;
    }

    //
    // Build full path
    //

    InfFields = ParseCommaList (TablePtr, InfLine->Data);

    __try {
        if (!InfFields) {
            MYASSERT(InfLine->Data);
            DEBUGMSG ((DBG_WARNING, "INF file has non-parsable data", InfLine->Data));
            return TRUE;
        }

        for (Fields = 0 ; InfFields[Fields] ; Fields++) {
            /* empty */
        }

        if (Fields < 19) {
            MYASSERT(InfLine->Data);
            DEBUGMSG ((DBG_WARNING, "INF file line %s has less than 19 fields", InfLine->Data));
            return TRUE;
        }

        //
        // Get the file name from this INF line (field #2)
        //

        pGetFileNameFromInfField (FileName, InfFields[1]);

        StringCopy (FullPath, InstallDestDir);
        StringCopy (AppendPathWack (FullPath), FileName);
    }

    __finally {
        FreeCommaList (TablePtr, InfFields);
    }

    //
    // Determine mapping
    //

    _tcssafecpy (OrgDirPart, FullPath, MAX_TCHAR_PATH);
    OrgFilePart = GetFileNameFromPath (OrgDirPart);
    if (OrgFilePart <= OrgDirPart) {
        // File probably wasn't installed
        return TRUE;
    }

    *_tcsdec2 (OrgDirPart, OrgFilePart) = 0;

    rc = ConvertWin9xPath (FullPath);

    _tcssafecpy (DirPart, FullPath, MAX_TCHAR_PATH);
    FilePart = GetFileNameFromPath (DirPart);
    MYASSERT (FilePart && FilePart > DirPart);
    *_tcsdec2 (DirPart, FilePart) = 0;

    //
    // Deleted?  Delete the STF line.
    //

    if (rc == CONVERTPATH_DELETED) {
        DEBUGMSG ((DBG_STF, "STF Line %u is no longer needed", StfLine));

        if (!pReplaceDirReferences (TablePtr, StfLine, InstallDestDir)) {
            return FALSE;
        }

        if (!pDeleteStfLine (TablePtr, StfLine)) {
            return FALSE;
        }
    }

    //
    // Moved?  Update the STF line.
    //

    else if (rc == CONVERTPATH_REMAPPED) {
        //
        // Has the file name changed?  If so, point it to the new location.
        //

        if (!StringIMatch (OrgFilePart, FilePart)) {
            //
            // Update INI file by duplicating the INI line
            //

            // Generate a unique key name
            pGenerateUniqueKeyName (TablePtr, Section, TEXT("WIN9XUPG_"), NewKeyName);

            // Compute size needed
            Size = 0;
            for (Fields = 0 ; InfFields[Fields] ; Fields++) {
                if (Fields != 1) {
                    Size += ByteCount (InfFields[Fields]);
                    Size += sizeof (TCHAR);
                } else {
                    Size += ByteCount (FilePart);
                }
            }

            // Generate the INF line
            NewLine = AllocText (Size);
            if (NewLine) {
                p = NewLine;
                *p = 0;

                for (Fields = 0 ; InfFields[Fields] ; Fields++) {
                    if (Fields) {
                        p = _tcsappend (p, TEXT(","));
                    }

                    if (Fields == 1) {
                        p = _tcsappend (p, FilePart);
                    } else {
                        p = _tcsappend (p, InfFields[Fields]);
                    }
                }

                // Write the new line
                StfAddInfLineToTable (
                    TablePtr,
                    Section,
                    NewKeyName,
                    NewLine,
                    LINEFLAG_KEY_QUOTED
                    );

                FreeText (NewLine);

                // Update the STF
                FileEntry = GetTableEntry (TablePtr, StfLine, COLUMN_OBJECT_DATA, NULL);
                MYASSERT (FileEntry);

                OldField = GetTableEntryStr (TablePtr, FileEntry);
                NewLine = AllocText (
                            ByteCount (FilePart) +
                            ByteCount (OldField) +
                            ByteCount (InfSection)
                            );

                StringCopy (NewLine, OldField);
                p = _tcschr (NewLine, TEXT(':'));
                if (!p) {
                    p = NewLine;
                } else {
                    p = _tcsinc (p);
                    MYASSERT (*p == TEXT(' '));
                    p = _tcsinc (p);
                }

                *p = 0;
                p = _tcsappend (p, InfSection);
                p = _tcsappend (p, TEXT(", "));
                p = _tcsappend (p, NewKeyName);

                // ignore memory failure, it will be picked up below
                ReplaceTableEntryStr (TablePtr, FileEntry, NewLine);

                FreeText (NewLine);
            }
        }

        //
        // Store the directory change in the STF table.
        //

        DataEntry = GetTableEntry (TablePtr, StfLine, COLUMN_INSTALL_DESTDIR, NULL);
        AppendWack (DirPart);

        if (!ReplaceTableEntryStr (TablePtr, DataEntry, DirPart)) {
            LOG ((
                LOG_ERROR,
                "Could not update table entry for single command"
                ));
            return FALSE;
        }
    }

    return TRUE;
}



PSTFINFSECTION
pGetNewInfSection (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR FileSpec,
    OUT     PBOOL CreatedFlag
    )

/*++

Routine Description:

  pGetNewInfSection determines if a section already exists for the specified
  file specification, and if so it returns the pointer to the existing
  section.  If the section does not exist, it creates a new section (making
  sure there are no other sections with the same name), and returns a
  pointer to the new section.

  This routine is used by the code that splits one section into several.

Arguments:

  TablePtr - Specifies the setup table file to process

  FileSpec - Specifies the full file path of the file being processed

  CreatedFlag - Receives TRUE if a new section had to be created

Return Value:

  A pointer to the INF section in which the file should be added to, or
  NULL if an error occurred.

--*/

{
    TCHAR DirName[MAX_TCHAR_PATH];
    TCHAR Node[MEMDB_MAX];
    DWORD SectionNum;
    PTSTR p;
    TCHAR SectionName[64];
    static DWORD SectionSeq = 0;

    *CreatedFlag = FALSE;

    //
    // See if section already exists, and if it does, return the section
    // pointer.
    //

    _tcssafecpy (DirName, FileSpec, MAX_TCHAR_PATH);
    p = _tcsrchr (DirName, TEXT('\\'));
    if (p) {
        *p = 0;
    }

    MemDbBuildKey (Node, MEMDB_CATEGORY_STF_SECTIONS, DirName, NULL, NULL);

    if (MemDbGetValue (Node, &SectionNum)) {
        wsprintf (SectionName, S_SECTIONNAME_SPRINTF, SectionNum);
        return StfFindInfSectionInTable (TablePtr, SectionName);
    }

    //
    // The section does not exist.  Find an unused section, write the
    // reference to memdb and return the section pointer.
    //

    while (TRUE) {
        SectionSeq++;
        wsprintf (SectionName, S_SECTIONNAME_SPRINTF, SectionSeq);
        if (!StfFindInfSectionInTable (TablePtr, SectionName)) {
            break;
        }
    }

    *CreatedFlag = TRUE;
    MemDbSetValue (Node, SectionSeq);
    return StfAddInfSectionToTable (TablePtr, SectionName);
}



VOID
pGetFileNameFromInfField (
    OUT     PTSTR FileName,
    IN      PCTSTR InfField
    )

/*++

Routine Description:

  pGetFileNameFromInfField extracts a long file name, enclosed between
  angle-brackets.  According to the STF spec, the syntax is shortname<longname>.
  This routine returns longname.

Arguments:

  FileName - Supplies a MAX_TCHAR_PATH buffer that receives the long file name.

  InfField - Specifies the text from the INF field conforming to the
             shortname<longname> syntax.

Return Value:

  None.

--*/

{
    PTSTR LongName;
    PCTSTR p;

    LongName = _tcschr (InfField, TEXT('<'));
    if (LongName) {
        _tcssafecpy (FileName, _tcsinc (LongName), MAX_TCHAR_PATH);
        LongName = _tcschr (FileName, TEXT('>'));
        if (LongName) {
            *LongName = 0;
        }
    } else {
        p = _tcsrchr (InfField, TEXT('\\'));
        if (!p) {
            p = InfField;
        } else {
            p = _tcsinc (p);
        }

        _tcssafecpy (FileName, p, MAX_TCHAR_PATH);
    }
}


BOOL
pDeleteStfLine (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT StfLine
    )

/*++

Routine Description:

  pDeleteStfLine removes an STF line from the table.  It first checks to
  see if a destination directory is specified, and if one is, it moves it
  to the next line, unless the next line also has a destination directory.

Arguments:

  TablePtr - Specifies the setup table file to process

  StfLine - Specifies the STF line to delete

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    PTABLEENTRY TitleEntry;
    PTABLEENTRY DataEntry;
    BOOL b;

    //
    // We simply replace the command with CreateIniLine, which is harmless
    //

    TitleEntry = GetTableEntry (TablePtr, StfLine, COLUMN_COMMAND, NULL);
    DataEntry = GetTableEntry (TablePtr, StfLine, COLUMN_OBJECT_DATA, NULL);

    if (!TitleEntry || !DataEntry) {
        MYASSERT (FALSE);
        return TRUE;
    }


    b = ReplaceTableEntryStr (TablePtr, TitleEntry, TEXT("CreateIniLine"));

    if (b) {
        b = ReplaceTableEntryStr (
                TablePtr,
                DataEntry,
                TEXT("\"WIN.INI\", \"Old Win9x Setting\", \"DummyKey\", \"unused\"")
                );
    }

    return b;


#if 0
    PTABLEENTRY NextLineEntry;
    PCTSTR InstallDestDir;
    PCTSTR NextInstallDestDir;

    __try {
        //
        // Test for last line
        //

        if (StfLine + 1 >= TablePtr->LineCount) {
            __leave;
        }

        //
        // Obtain StfLine dest dir (column 10)
        //

        if (!GetTableEntry (TablePtr, StfLine, COLUMN_DEST_DIR, &InstallDestDir)) {
            //
            // StfLine is not valid (unexpected)
            //

            DEBUGMSG ((DBG_STF, "Line %u does not have column 10", StfLine));
            __leave;
        }

        //
        // If no dest dir, do not modify the next line
        //

        if (!InstallDestDir || !InstallDestDir[0]) {
            __leave;
        }

        //
        // Obtain next line's dest dir (column 10)
        //

        NextLineEntry = GetTableEntry (TablePtr, StfLine + 1, COLUMN_DEST_DIR, &NextInstallDestDir);
        if (!NextLineEntry) {
            //
            // Next StfLine is not valid (unexpected)
            //

            DEBUGMSG ((DBG_WHOOPS, "pDeleteStfLine: Next line %u does not have column 10", StfLine+1));
            __leave;
        }

        //
        // If next line's dest dir is not empty, do not modify the line
        //

        if (NextInstallDestDir && NextInstallDestDir[0]) {
            __leave;
        }

        //
        // Now set InstallDestDir on NextLineEntry line
        //

        if (!ReplaceTableEntryStr (TablePtr, NextLineEntry, InstallDestDir)) {
            DEBUGMSG ((
                DBG_ERROR,
                "Cannot replace a destination dir in STF file. "
                    "Line=%u, InstallDestDir=%s",
                StfLine + 1,
                InstallDestDir
                ));

            return FALSE;
        }
    }
    __finally {
    }

    return DeleteLineInTable (TablePtr, StfLine);
#endif
}


BOOL
pReplaceDirReferences (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT StfLine,
    IN      PCTSTR DirSpec
    )

/*++

Routine Description:

  pReplaceDirReferences scans column 14, looking for all references
  to StfLine, and replaces the reference with DirSpec.

Arguments:

  TablePtr - Specifies the setup table file to process

  StfLine - Specifies the STF line to substitute

  DirSpec - Specifies the effective directory for the STF line.
            This directory is used if the STF line has to be
            deleted.

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    UINT Line, Count;
    PTABLEENTRY InstallDestDirEntry;
    PCTSTR InstallDestDir;
    TCHAR NumStr[32];
    UINT NumStrLen;
    PCTSTR AfterPercentNum;
    CHARTYPE c;
    PCTSTR NewInstallDestDir;

    NumStrLen = wsprintf (NumStr, TEXT("%%%u"), StfLine);
    Count = TablePtr->LineCount;

    for (Line = 0 ; Line < Count ; Line++) {
        InstallDestDirEntry = GetTableEntry (TablePtr, Line, COLUMN_DEST_DIR, &InstallDestDir);
        if (!InstallDestDirEntry) {
            continue;
        }

        //
        // Does InstallDestDir have %<n> (where <n> equals StfLine)?
        //

        if (StringIMatchCharCount (InstallDestDir, NumStr, NumStrLen)) {
            //
            // The next character must be a wack or nul
            //

            AfterPercentNum = CharCountToPointer (InstallDestDir, NumStrLen);

            c = (CHARTYPE)_tcsnextc (AfterPercentNum);
            if (c == 0 || c == TEXT('\\')) {
                //
                // Create new dest dir
                //

                if (c) {
                    NewInstallDestDir = JoinPaths (DirSpec, _tcsinc (AfterPercentNum));
                } else {
                    NewInstallDestDir = DuplicatePathString (DirSpec, 0);
                }

                __try {
                    if (!ReplaceTableEntryStr (TablePtr, InstallDestDirEntry, NewInstallDestDir)) {
                        LOG ((
                            LOG_ERROR,
                            "Cannot replace a destination dir in STF file. "
                                "Line=%u, NewInstallDestDir=%s",
                            Line,
                            NewInstallDestDir
                            ));

                        return FALSE;
                    }
                    ELSE_DEBUGMSG ((
                        DBG_STF,
                        "Line %u: Dest dir %s replaced with %s",
                        Line,
                        InstallDestDir,
                        NewInstallDestDir
                        ));
                }
                __finally {
                    FreePathString (NewInstallDestDir);
                }
            }
        }
    }

    return TRUE;
}


BOOL
pCreateNewStfLine (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT StfLine,
    IN      PCTSTR ObjectData,
    IN      PCTSTR InstallDestDir
    )

/*++

Routine Description:

  pCreateNewStfLine inserts a new line immediately following
  StfLine, using the maximum object number.  It copies the
  STF line specified and modifies the ObjectData (column 5)
  and InstallDestDir (column 14).

Arguments:

  TablePtr - Specifies the setup table file to process

  StfLine - Specifies the prototype STF line

  ObjectData - Specifies the replacement for the ObjectData
               column

  InstallDestDir - Specifies the replacement for the DestDir
                   column

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    UINT NewLine;
    UINT NewObj;
    PTABLEENTRY CopyEntry, NewEntry;
    UINT Col;
    TCHAR Buf[32], ReplaceBuf[32];

    //
    // Copy StfLine to StfLine+1, updating fields as necessary
    //

    NewLine = StfLine + 1;
    TablePtr->MaxObj++;
    NewObj = TablePtr->MaxObj;

    if (!InsertEmptyLineInTable (TablePtr, NewLine)) {
        LOG ((LOG_ERROR, "Unable to insert new line in STF table"));
        return FALSE;
    }

    Col = 0;
    while (TRUE) {
        CopyEntry = GetTableEntry (TablePtr, StfLine, Col, NULL);
        if (!CopyEntry) {
            break;
        }

        if (!AppendTableEntry (TablePtr, NewLine, CopyEntry)) {
            LOG ((LOG_ERROR, "Unable to append all entries to line"));
            return FALSE;
        }

        NewEntry = GetTableEntry (TablePtr, NewLine, Col, NULL);
        MYASSERT(NewEntry);
        if (!NewEntry) {
            return FALSE;
        }

        if (Col == 0) {
            wsprintf (Buf, TEXT("%u"), NewObj);

            if (!ReplaceTableEntryStr (TablePtr, NewEntry, Buf)) {
                LOG ((LOG_ERROR, "Unable to replace ObjID on line"));
                return FALSE;
            }
        } else if (Col == COLUMN_OBJECT_DATA) {
            if (!ReplaceTableEntryStr (TablePtr, NewEntry, ObjectData)) {
                LOG ((LOG_ERROR, "Unable to replace ObjectData on line"));
                return FALSE;
            }
        } else if (Col == COLUMN_INSTALL_DESTDIR) {
            if (!ReplaceTableEntryStr (TablePtr, NewEntry, InstallDestDir)) {
                LOG ((LOG_ERROR, "Unable to replace ObjectData on line"));
                return FALSE;
            }
        }

        Col++;
    }

    //
    // Find all lines with references to StfLine and add in NewLine
    //

    wsprintf (Buf, TEXT("%u"), StfLine);
    wsprintf (ReplaceBuf, TEXT("%u %u"), StfLine, NewLine);

    return pSearchAndReplaceObjectRefs (TablePtr, Buf, ReplaceBuf);
}


BOOL
pSearchAndReplaceObjectRefs (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PCTSTR SrcStr,
    IN      PCTSTR DestStr
    )

/*++

Routine Description:

  pSearchAndReplaceObjectRefs scans column 5 of the setup table,
  looking for any occurance of SrcStr and replacing it with
  DestStr.

Arguments:

  TablePtr - Specifies the STF table to process

  SrcStr - Specifies the string to locate and replace

  DestStr - Specifies the replacement string

Return Value:

  TRUE if the STF file was converted, FALSE if failure.

--*/

{
    UINT Line;
    UINT Count;
    PTABLEENTRY Entry;
    PCTSTR LineString;
    PCTSTR UpdatedString;

    Count = TablePtr->LineCount;

    for (Line = 0 ; Line < Count ; Line++) {
        Entry = GetTableEntry (TablePtr, Line, COLUMN_OBJECT_DATA, &LineString);
        if (!Entry || !LineString || !LineString[0]) {
            continue;
        }

        UpdatedString = StringSearchAndReplace (LineString, SrcStr, DestStr);

        if (UpdatedString) {
            __try {
                if (!ReplaceTableEntryStr (TablePtr, Entry, UpdatedString)) {
                    LOG ((LOG_ERROR, "Unable to replace text on line"));
                    return FALSE;
                }
            }
            __finally {
                FreePathString (UpdatedString);
            }
        }
    }

    return TRUE;
}



BOOL
pProcessSetupTableFile (
    IN      PCTSTR StfFileSpec
    )

/*++

Routine Description:

  pProcessSetupTableFile performs all processing on the file specified.
  Here are the steps involved in converting an STF file:

    - Determine the associated INF
    - Prepare the SETUPTABLE structure
    - Scan the table for file-based actions
    - Convert file paths used by the actions
    - Convert group references when STF lines are split
    - Write the modifications to disk
    - Replace the original INF and STF with the new versions

Arguments:

  StfFileSpec - Specifies the full file path to the STF file needing processing.
                The associated INF must be in the same directory as the STF
                file referencing it.

Return Value:

  TRUE if the STF file was converted, FALSE if failure.

--*/

{
    SETUPTABLE Table;
    DWORD StfAttribs, InfAttribs;
    BOOL b;
    TCHAR SourceStf[MAX_TCHAR_PATH];
    TCHAR DestStf[MAX_TCHAR_PATH];
    TCHAR SourceInf[MAX_TCHAR_PATH];
    TCHAR DestInf[MAX_TCHAR_PATH];

    if (!CreateSetupTable (StfFileSpec, &Table)) {
        DEBUGMSG ((DBG_STF, "ProcessSetupTableFile: Error parsing file %s.", StfFileSpec));
        return FALSE;
    }

    __try {
        //
        // Process the table
        //

        if (!pProcessSetupTable (&Table)) {
            DEBUGMSG ((DBG_STF, "ProcessSetupTableFile: Error processing table for %s.", StfFileSpec));
            return FALSE;
        }

        //
        // Write changes to temporary files
        //

        if (!WriteSetupTable (&Table)) {
            LOG ((LOG_ERROR, "Cannot write setup table for %s.", StfFileSpec));
            return FALSE;
        }

        //
        // Copy paths before we destroy the table struct
        //

        _tcssafecpy (SourceStf, Table.SourceStfFileSpec, MAX_TCHAR_PATH);
        _tcssafecpy (DestStf, Table.DestStfFileSpec, MAX_TCHAR_PATH);
        _tcssafecpy (SourceInf, Table.SourceInfFileSpec, MAX_TCHAR_PATH);
        if (Table.DestInfFileSpec) {
            _tcssafecpy (DestInf, Table.DestInfFileSpec, MAX_TCHAR_PATH);
        } else {
            *DestInf = 0;
        }
    }
    __finally {
        DestroySetupTable (&Table);
    }


    //
    // Replace the original files with temporary files
    //

    StfAttribs = GetFileAttributes (SourceStf);
    if (StfAttribs != 0xffffffff) {
        LONG rc;

        SetFileAttributes (SourceStf, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (SourceStf);

        rc = GetLastError();

        b = OurMoveFile (DestStf, SourceStf);
        if (!b) {
            return FALSE;
        }

        SetFileAttributes (SourceStf, StfAttribs);
    }

    InfAttribs = GetFileAttributes (SourceInf);
    if (InfAttribs != 0xffffffff && *DestInf) {
        SetFileAttributes (SourceInf, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (SourceInf);

        b = OurMoveFile (DestInf, SourceInf);
        if (!b) {
            return FALSE;
        }

        SetFileAttributes (SourceInf, InfAttribs);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\progress.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    progress.c

Abstract:

    This file implements routines that estimate the size of the progress
    bar.

Author:

    Jim Schmidt (jimschm) 02-Jul-1998

Revision History:

    jimschm     23-Sep-1998 MigrateShellFolders & split of usermig.c

--*/


/*++

Macro Expansion List Description:

   The macro expansion lists FIRST_SYSTEM_ROUTINES, USER_ROUTINES and
   LAST_SYSTEM_ROUTINES list all the functions called to perform the migration
   of user and system settings.  The functions are executed in the order they
   appear.  Each function is responsible for estimating a tick count and ticking
   the progress bar.

Line Syntax:

   SYSFUNCTION(Function, Flag) (for FIRST_SYSTEM_ROUTINES and LAST_SYSTEM_ROUTINES)

   or

   USERFUNCTION(Function, Flag) (for USER_ROUTINES)

Arguments:

   Function   - These functions must return DWORD and are called with a request as a parameter,
                request that can be either REQUEST_QUERYTICKS (the function should estimate the
                number of ticks it needs) or REQUEST_RUN (the function should do it's job).
                For user functions there are also three more parameters (UserName, UserAccount,
                and a handle to HKCU)

   Flag - Specifies NOFAIL if the function terminates migration when it fails, or
          CANFAIL if migration can proceed even if the function fails

Variables Generated From List:

   g_MigrationFnList

For accessing the arrays there are the following functions:

   PrepareMigrationProgressBar
   PerformMigration

--*/

#include "pch.h"

#define NOFAIL      FALSE
#define CANFAIL     TRUE


#define FIRST_SYSTEM_ROUTINES \
        SYSFUNCTION(PrepareEnvironment, NOFAIL)             \
        SYSFUNCTION(ResolveDomains, NOFAIL)                 \
        SYSFUNCTION(DeleteSysTapiSettings, NOFAIL)          \
        SYSFUNCTION(ProcessLocalMachine_First, CANFAIL)     \
        SYSFUNCTION(UninstallStartMenuCleanupPreparation, CANFAIL)              \
        SYSFUNCTION(RemoveBootIniCancelOption, CANFAIL)     \
        SYSFUNCTION(MigrateShellFolders, CANFAIL)           \
        SYSFUNCTION(MigrateGhostSystemFiles, CANFAIL)       \


#define USER_ROUTINES \
        USERFUNCTION(RunPerUserUninstallUserProfileCleanupPreparation, CANFAIL) \
        USERFUNCTION(PrepareUserForMigration, NOFAIL)       \
        USERFUNCTION(DeleteUserTapiSettings, NOFAIL)        \
        USERFUNCTION(MigrateUserRegistry, CANFAIL)          \
        USERFUNCTION(MigrateLogonPromptSettings, CANFAIL)   \
        USERFUNCTION(MigrateUserSettings, CANFAIL)          \
        USERFUNCTION(RunPerUserExternalProcesses, CANFAIL)  \
        USERFUNCTION(SaveMigratedUserHive, CANFAIL)         \

#define LAST_SYSTEM_ROUTINES \
        SYSFUNCTION(DoCopyFile, CANFAIL)                    \
        SYSFUNCTION(ProcessLocalMachine_Last, CANFAIL)      \
        SYSFUNCTION(ConvertHiveFiles, CANFAIL)              \
        SYSFUNCTION(MigrateBriefcases, CANFAIL)             \
        SYSFUNCTION(MigrateAtmFonts, CANFAIL)               \
        SYSFUNCTION(AddOptionsDiskCleaner, CANFAIL)         \
        SYSFUNCTION(DoFileEdit, CANFAIL)                    \
        SYSFUNCTION(RunSystemExternalProcesses, CANFAIL)    \
        SYSFUNCTION(ProcessMigrationDLLs, CANFAIL)          \
        SYSFUNCTION(DisableFiles, CANFAIL)                  \
        SYSFUNCTION(RunSystemUninstallUserProfileCleanupPreparation, CANFAIL)   \
        SYSFUNCTION(WriteBackupInfo, CANFAIL)               \


//
// Declare tables of processing structures
//

// Create a combined list
#define MIGRATION_ROUTINES  FIRST_SYSTEM_ROUTINES USER_ROUTINES LAST_SYSTEM_ROUTINES

// Processing functions types
typedef DWORD (MIGMAIN_SYS_PROTOTYPE) (DWORD Request);
typedef MIGMAIN_SYS_PROTOTYPE * MIGMAIN_SYS_FN;

typedef DWORD (MIGMAIN_USER_PROTOTYPE) (DWORD Request, PMIGRATE_USER_ENUM EnumPtr);
typedef MIGMAIN_USER_PROTOTYPE * MIGMAIN_USER_FN;

// Structure holding state for processing functions
typedef struct {
    // One of the two will be NULL, the other will be a valid fn ptr:
    MIGMAIN_SYS_FN SysFnPtr;
    MIGMAIN_USER_FN UserFnPtr;

    BOOL CanFail;
    UINT Ticks;
    PCTSTR FnName;
    GROWBUFFER SliceIdArray;
} PROCESSING_ROUTINE, *PPROCESSING_ROUTINE;

#define PROCESSING_ROUTINE_TERMINATOR   {NULL, NULL, FALSE, 0, NULL, GROWBUF_INIT}


// Declaration of prototypes
#define SYSFUNCTION(fn,flag)     MIGMAIN_SYS_PROTOTYPE fn;
#define USERFUNCTION(fn,flag)    MIGMAIN_USER_PROTOTYPE fn;

MIGRATION_ROUTINES

#undef SYSFUNCTION
#undef USERFUNCTION


// Declaration of table
#define SYSFUNCTION(fn,flag) {fn, NULL, flag, 0, L###fn, GROWBUF_INIT},
#define USERFUNCTION(fn,flag) {NULL, fn, flag, 0, L###fn, GROWBUF_INIT},

static PROCESSING_ROUTINE g_FirstSystemRoutines[] = {
                              FIRST_SYSTEM_ROUTINES /* , */
                              PROCESSING_ROUTINE_TERMINATOR
                              };

static PROCESSING_ROUTINE g_UserRoutines [] = {
                              USER_ROUTINES /* , */
                              PROCESSING_ROUTINE_TERMINATOR
                              };

static PROCESSING_ROUTINE g_LastSystemRoutines[] = {
                              LAST_SYSTEM_ROUTINES /* , */
                              PROCESSING_ROUTINE_TERMINATOR
                              };

#undef SYSFUNCTION
#undef USERFUNCTION


//
// Prototypes
//

BOOL
pProcessTable (
    IN      DWORD Request,
    IN      PPROCESSING_ROUTINE Table
    );


//
// Implementation
//


VOID
pInitTable (
    PPROCESSING_ROUTINE p
    )
{
    while (p->SysFnPtr || p->UserFnPtr) {
        p->SliceIdArray.GrowSize = sizeof (DWORD) * 8;
        p++;
    }
}


VOID
InitProcessingTable (
    VOID
    )
{
    pInitTable (g_FirstSystemRoutines);
    pInitTable (g_UserRoutines);
    pInitTable (g_LastSystemRoutines);
}


VOID
pTerminateTable (
    PPROCESSING_ROUTINE p
    )
{
    while (p->SysFnPtr || p->UserFnPtr) {
        FreeGrowBuffer (&p->SliceIdArray);
        p++;
    }
}


VOID
TerminateProcessingTable (
    VOID
    )
{
    pTerminateTable (g_FirstSystemRoutines);
    pTerminateTable (g_UserRoutines);
    pTerminateTable (g_LastSystemRoutines);
}


BOOL
pCallAllRoutines (
    BOOL Run
    )
{
    BOOL b;
    DWORD Request;

    Request = Run ? REQUEST_RUN : REQUEST_QUERYTICKS;

    b = pProcessTable (Request, g_FirstSystemRoutines);

    if (b && Run) {
        b = pProcessTable (REQUEST_BEGINUSERPROCESSING, g_UserRoutines);
    }

    if (b) {
        b = pProcessTable (Request, g_UserRoutines);
    }

    if (b && Run) {
        b = pProcessTable (REQUEST_ENDUSERPROCESSING, g_UserRoutines);
    }

    if (b) {
        b = pProcessTable (Request, g_LastSystemRoutines);
    }

    return b;
}


VOID
PrepareMigrationProgressBar (
    VOID
    )
{
    InitProcessingTable();
    pCallAllRoutines (FALSE);
}


BOOL
CallAllMigrationFunctions (
    VOID
    )
{
    return pCallAllRoutines (TRUE);
}


BOOL
pProcessWorker (
    IN      DWORD Request,
    IN      PPROCESSING_ROUTINE fn,
    IN      PMIGRATE_USER_ENUM EnumPtr      OPTIONAL
    )
{
    DWORD rc;
    PDWORD SliceId;
    DWORD Size;
    BOOL Result = TRUE;

    //
    // If running the function, start the progress bar slice
    //

    if (Request == REQUEST_RUN) {
        if (fn->Ticks == 0) {
            return TRUE;
        }

        Size = fn->SliceIdArray.End / sizeof (DWORD);
        if (fn->SliceIdArray.UserIndex >= Size) {
            DEBUGMSG ((DBG_WHOOPS, "pProcessWorker: QUERYTICKS vs. RUN mismatch"));
            return fn->CanFail;
        }

        SliceId = (PDWORD) fn->SliceIdArray.Buf + fn->SliceIdArray.UserIndex;
        fn->SliceIdArray.UserIndex += 1;

        BeginSliceProcessing (*SliceId);

        DEBUGLOGTIME (("Starting function: %ls", fn->FnName));
    }

    //
    // Now call the function
    //

    if (fn->SysFnPtr) {

        //
        // System processing
        //

        MYASSERT (!EnumPtr);
        rc = fn->SysFnPtr (Request);

        if (Request != REQUEST_QUERYTICKS && rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_ERROR, "%s failed with rc=%u", fn->FnName, rc));
            Result = fn->CanFail;
        }

   } else {

        //
        // User processing
        //
        MYASSERT (fn->UserFnPtr);
        rc = fn->UserFnPtr (Request, EnumPtr);

        if (Request != REQUEST_QUERYTICKS && rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_ERROR, "%s failed with rc=%u", fn->FnName, rc));
            Result = fn->CanFail;
        }

    }

    //
    // If running the function, end the progress bar slice
    //

    if (Request == REQUEST_RUN) {
        if (rc != ERROR_SUCCESS) {
            LOG ((LOG_ERROR, "Failure in %s, rc=%u", fn->FnName, rc));
        }

        EndSliceProcessing();

        DEBUGLOGTIME (("Function complete: %ls", fn->FnName));
    }


    if (Request != REQUEST_QUERYTICKS) {
        SetLastError (rc);
    }

    //
    // If querying the ticks, register them and add slice ID to grow buffer
    //

    else {
        fn->Ticks += rc;

        SliceId = (PDWORD) GrowBuffer (&fn->SliceIdArray, sizeof (DWORD));
        *SliceId = RegisterProgressBarSlice (rc);
    }

    return Result;
}


BOOL
pProcessTable (
    IN      DWORD Request,
    IN      PPROCESSING_ROUTINE Table
    )

/*++

Routine Description:

  pProcessTable calls all routines in the specified table to perform
  the specified request.

Arguments:

  Request - Specifies REQUEST_QUERYTICKS when a tick estimate is needed,
            or REQUEST_RUN when the function needs to perform its
            processing. For User routines, there are the additional two
            requests REQUEST_BEGINUSERPROCESSING and REQUEST_ENDUSERPROCESSING
            Functions can use these requests to init/free needed resources
            for user processing.

Return Value:

  none

--*/

{
    MIGRATE_USER_ENUM e;
    PPROCESSING_ROUTINE OrgStart;
    DWORD Flags;

    g_DomainUserName = NULL;
    g_Win9xUserName  = NULL;
    g_FixedUserName  = NULL;

    MYASSERT (Table->SysFnPtr || Table->UserFnPtr);

    while (Table->SysFnPtr || Table->UserFnPtr) {

        if (Table->SysFnPtr ||
            Request == REQUEST_BEGINUSERPROCESSING  ||
            Request == REQUEST_ENDUSERPROCESSING
            ) {

            //
            // Call system routine, or call per-user routine with begin or
            // end request
            //

            __try {
                if (!pProcessWorker (Request, Table, NULL)) {
                    return FALSE;
                }
            } __except (1) {

                LOG ((LOG_WARNING, "Unhandled exception occurred during processing of function %s.", Table->FnName));
                SafeModeExceptionOccured ();
                if (!Table->CanFail) {
                    return FALSE;
                }
            }

            //
            // Loop inc
            //

            Table++;

        } else {

            //
            // Enumerate each user, and run through all the per-user
            // routines in the group.
            //

            OrgStart = Table;

            if (Request == REQUEST_QUERYTICKS) {
                Flags = ENUM_NO_FLAGS;
            } else {
                Flags = ENUM_SET_WIN9X_HKR;
            }

            if (EnumFirstUserToMigrate (&e, Flags)) {

                do {
                    if (!e.CreateOnly) {

                        for (Table = OrgStart ; Table->UserFnPtr ; Table++) {

                            __try {
                                if (!pProcessWorker (Request, Table, &e)) {
                                    return FALSE;
                                }
                            } __except (1) {
                                LOG ((LOG_WARNING, "Unhandled exception occurred during processing of function %s.", Table->FnName));
                                SafeModeExceptionOccured ();
                                if (!Table->CanFail) {
                                    return FALSE;
                                }
                            }
                        }

                    }

                } while (EnumNextUserToMigrate (&e));
            }
            ELSE_DEBUGMSG ((DBG_WARNING, "No active users to process!"));

            //
            // Loop inc
            //

            while (Table->UserFnPtr) {
                Table++;
            }
        }

        TickProgressBar ();
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\stftable.h ===
#define STF_HASH_BUCKETS    509
#define BUCKET_GROW_RATE    32

typedef struct {
    UINT Count;
    UINT Size;
    UINT Elements[];
} HASHBUCKET, *PHASHBUCKET;

typedef struct _tagTABLEENTRY {
    //
    // Entry string members
    //
    PCTSTR String;
    BOOL StringReplaced;
    BOOL Quoted;
    BOOL Binary;
    // If more added, update pFreeTableEntryPtr

    //
    // Linkage
    //
    UINT Line;
    struct _tagTABLEENTRY *Next, *Prev;
} TABLEENTRY, *PTABLEENTRY;

typedef struct {
    PTABLEENTRY FirstCol;           // The head of the column list
} TABLELINE, *PTABLELINE;

typedef struct _tagSTFINFLINE {
    PCTSTR Key;             OPTIONAL
    PCTSTR Data;
    DWORD LineFlags;
    struct _tagSTFINFLINE *Next, *Prev;
    struct _tagSTFINFSECTION *Section;
} STFINFLINE, *PSTFINFLINE;

#define LINEFLAG_KEY_QUOTED         0x0001
#define LINEFLAG_ALL_COMMENTS       0x0002
#define LINEFLAG_TRAILING_COMMENTS  0x0004


typedef struct _tagSTFINFSECTION {
    PCTSTR Name;
    PSTFINFLINE FirstLine;
    PSTFINFLINE LastLine;
    UINT LineCount;
    struct _tagSTFINFSECTION *Next, *Prev;
} STFINFSECTION, *PSTFINFSECTION;

typedef struct {
    //
    // File spec
    //

    PCTSTR DirSpec;

    PCTSTR SourceStfFileSpec;
    PCTSTR SourceInfFileSpec;
    PCTSTR DestStfFileSpec;
    PCTSTR DestInfFileSpec;

    HANDLE SourceStfFile;
    HANDLE SourceInfFile;
    HANDLE DestStfFile;
    HANDLE DestInfFile;

    HINF SourceInfHandle;

    //
    // Memory structure of setup table
    //

    HANDLE FileMapping;             // handle for performing file mapping of SourceStfFileSpec
    PCSTR FileText;                 // A pointer to the mapped text
    GROWBUFFER Lines;               // An array of PTABLELINE pointers
    UINT LineCount;                 // The number of elements in the array
    POOLHANDLE ColumnStructPool;    // A pool for TABLEENTRY structs
    POOLHANDLE ReplacePool;         // A pool for TABLEENTRY strings that are replaced
    POOLHANDLE TextPool;            // A pool for TABLEENTRY strings converted to UNICODE
    POOLHANDLE InfPool;             // A pool for appended INF data
    PHASHBUCKET * HashBuckets;      // A pointer to an array of HASKBUCKET structs
    UINT MaxObj;                    // The highest sequencer used for an object line
    PSTFINFSECTION FirstInfSection;    // The first section of the parsed INF
    PSTFINFSECTION LastInfSection;     // The last section of the parsed INF
    BOOL InfIsUnicode;
} SETUPTABLE, *PSETUPTABLE;

#define INSERT_COL_LAST     0xffffffff
#define NO_OFFSET           0xffffffff
#define NO_LENGTH           0xffffffff
#define NO_LINE             0xffffffff
#define INVALID_COL         0xffffffff
#define INSERT_LINE_LAST    0xffffffff



BOOL
CreateSetupTable (
    IN      PCTSTR SourceStfFileSpec,
    OUT     PSETUPTABLE TablePtr
    );

BOOL
WriteSetupTable (
    IN      PSETUPTABLE TablePtr
    );

VOID
DestroySetupTable (
    IN OUT  PSETUPTABLE TablePtr
    );

PTABLEENTRY
FindTableEntry (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR FirstColText,
    IN      UINT Col,
    OUT     PUINT Line,            OPTIONAL
    OUT     PCTSTR *String          OPTIONAL
    );

PTABLEENTRY
GetTableEntry (
    IN      PSETUPTABLE TablePtr,
    IN      UINT Line,
    IN      UINT Col,
    OUT     PCTSTR *StringPtr      OPTIONAL
    );

PCTSTR
GetTableEntryStr (
    IN      PSETUPTABLE TablePtr,
    IN      PTABLEENTRY TableEntry
    );

BOOL
ReplaceTableEntryStr (
    IN OUT  PSETUPTABLE TablePtr,
    IN OUT  PTABLEENTRY TableEntryPtr,
    IN      PCTSTR NewString
    );

BOOL
InsertTableEntryStr (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PTABLEENTRY InsertBeforePtr,
    IN      PCTSTR NewString
    );

BOOL
DeleteTableEntryStr (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PTABLEENTRY DeleteEntryPtr
    );

BOOL
AppendTableEntryStr (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT Line,
    IN      PCTSTR NewString
    );

BOOL
AppendTableEntry (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT DestLine,
    IN      PTABLEENTRY SrcEntry
    );

BOOL
InsertEmptyLineInTable (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT InsertBeforeLine
    );

BOOL
DeleteLineInTable (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT LineToDelete
    );

PCTSTR *
ParseCommaList (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR CommaListString
    );

VOID
FreeCommaList (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR *ArgList
    );

PCTSTR
GetDestDir (
    IN      PSETUPTABLE TablePtr,
    IN      UINT Line
    );

VOID
FreeDestDir (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR DestDir
    );

PSTFINFSECTION
StfAddInfSectionToTable (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR SectionName
    );

PSTFINFLINE
StfAddInfLineToTable (
    IN      PSETUPTABLE TablePtr,
    IN      PSTFINFSECTION SectionPtr,
    IN      PCTSTR Key,                     OPTIONAL
    IN      PCTSTR Data,
    IN      DWORD LineFlags
    );

PSTFINFSECTION
StfFindInfSectionInTable (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR SectionName
    );

PSTFINFLINE
StfFindLineInInfSection (
    IN      PSETUPTABLE TablePtr,
    IN      PSTFINFSECTION Section,
    IN      PCTSTR Key
    );

BOOL
StfDeleteLineInInfSection (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PSTFINFLINE InfLine
    );

BOOL
StfDeleteSectionInInfFile (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PSTFINFSECTION Section
    );

UINT
StfGetInfSectionLineCount (
    IN      PSTFINFSECTION Section
    );

PSTFINFLINE
StfGetFirstLineInSectionStruct (
    IN      PSTFINFSECTION Section
    );

PSTFINFLINE
StfGetNextLineInSection (
    IN      PSTFINFLINE PrevLine
    );

PSTFINFLINE
StfGetFirstLineInSectionStr (
    IN      PSETUPTABLE Table,
    IN      PCTSTR Section
    );


BOOL
InfParse_ReadInfIntoTable (
    IN OUT  PSETUPTABLE TablePtr
    );

BOOL
InfParse_WriteInfToDisk (
    IN      PSETUPTABLE TablePtr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\pch\empty.c ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\stftable.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    stftable.c

Abstract:

    The routines in this file manipulate the STF/INF pair used by
    ACME Setup.

Author:

    Jim Schmidt (jimschm) 12-Sept-1997

Revision History:


--*/


#include "pch.h"
#include "migmainp.h"

#include "stftable.h"

#define DBG_STF  "STF"

#define USE_FILE_MAPPING    1
#define DBLQUOTECHAR TEXT('\"')


#define FIELD_QUOTED        0x0001
#define FIELD_BINARY        0x0002


//
// Declaration of functions for use only in this file
//
VOID
pFreeTableEntryString (
    IN OUT  PSETUPTABLE TablePtr,
    IN OUT  PTABLEENTRY TableEntryPtr
    );

VOID
pFreeTableEntryPtr (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PTABLEENTRY TableEntryPtr,
    IN      BOOL DeallocateStruct,
    OUT     PTABLEENTRY *NextTableEntryPtr      OPTIONAL
    );

PTABLELINE
pInsertEmptyLineInTable (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT InsertBeforeLine
    );

BOOL
pInitHashTable (
    IN      PSETUPTABLE TablePtr
    );

BOOL
pAddToHashTable (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PCTSTR Text,
    IN      UINT Len,
    IN      UINT Line
    );

PHASHBUCKET
pFindInHashTable (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR Text,
    OUT     PUINT Item
    );

BOOL
pRemoveFromHashTable (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PCTSTR Text
    );

VOID
pFreeHashTable (
    IN OUT  PSETUPTABLE TablePtr
    );


//
// Table access functions
//

PTABLELINE
pGetTableLinePtr (
    IN      PSETUPTABLE TablePtr,
    IN      UINT Line
    )

/*++

Routine Description:

  pGetTableLinePtr returns a pointer to the PTABLELINE structure
  for the specified line.  The PTABLELINE pointers are kept in
  an array, so lookup for the line is very fast.

Arguments:

  TablePtr - Specifies the table that contains the line

  Line - Specifies the zero-based line to look up

Return Value:

  A pointer to the table line

--*/

{
    PTABLELINE TableLinePtr;

    if (Line >= TablePtr->LineCount) {
        return NULL;
    }

    TableLinePtr = (PTABLELINE) TablePtr->Lines.Buf;
    return &TableLinePtr[Line];
}


PTABLEENTRY
pGetFirstTableEntryPtr (
    IN      PSETUPTABLE TablePtr,
    IN      UINT Line              // zero-based
    )

/*++

Routine Description:

  pGetFirstTableEntryPtr provides a pointer to the first column
  for a line.

Arguments:

  TablePtr - Specifies the table that contains the line

  Line - Specifies the zero-based line to enumerate

Return Value:

  A pointer to the first column's TABLEENTRY structure, or
  NULL if the line has no columns.

--*/

{
    PTABLELINE TableLinePtr;

    TableLinePtr = pGetTableLinePtr (TablePtr, Line);
    if (!TableLinePtr) {
        return NULL;
    }

    return TableLinePtr->FirstCol;
}


PTABLEENTRY
pGetNextTableEntryPtr (
    IN      PTABLEENTRY CurrentEntryPtr
    )

/*++

Routine Description:

  pGetNextTableEntryPtr returns a pointer to the next column's
  TABLEENTRY structure, or NULL if no more columns exist on
  the line.

Arguments:

  CurrentEntryPtr - Specifies the entry returned by
                    pGetFirstTableEntryPtr or pGetNextTableEntryPtr.

Return Value:

  A pointer to the next column's TABLEENTRY structure, or NULL
  if the line has no more columns.

--*/

{
    return CurrentEntryPtr->Next;
}


PTABLEENTRY
GetTableEntry (
    IN      PSETUPTABLE TablePtr,
    IN      UINT Line,
    IN      UINT Col,
    OUT     PCTSTR *StringPtr       OPTIONAL
    )

/*++

Routine Description:

  GetTableEntry is the exposed entry point that finds a column
  on a line and returns a pointer to it.  It also optionally
  copies the read-only pointer to the entry text.

Arguments:

  TablePtr - Specifies the setup table that contains the line and col

  Line - Specifies the zero-based line in the table

  Col - Specifies the col in the table

  StringPtr - Receives a pointer to the entry's read-only string

Return Value:

  A pointer to the TABLEENTRY structure, or NULL if the line/
  column part does not exist.

--*/

{
    PTABLEENTRY TableEntryPtr;

    TableEntryPtr = pGetFirstTableEntryPtr (TablePtr, Line);
    while (TableEntryPtr) {
        if (!Col) {
            if (StringPtr) {
                *StringPtr = TableEntryPtr->String;
            }

            return TableEntryPtr;
        }
        Col--;

        TableEntryPtr = pGetNextTableEntryPtr (TableEntryPtr);
    }

    return NULL;
}


//
// String mapping, unmapping and conversion functions
//

VOID
pFreeTableEntryString (
    IN OUT  PSETUPTABLE TablePtr,
    IN OUT  PTABLEENTRY TableEntryPtr
    )

/*++

Routine Description:

  pFreeTableEntryString is used to free the allocation of a replaced
  string before it is replaced again.  This routine is called by
  ReplaceTableEntryStr.

Arguments:

  TablePtr - Specifies the table containing the entry

  TableEntryPtr - Specifies the entry containing the resources to deallocate

Return Value:

  none

--*/

{
    if (TableEntryPtr->String) {
        if (TableEntryPtr->StringReplaced) {
            PoolMemReleaseMemory (TablePtr->ReplacePool, (PVOID) TableEntryPtr->String);
        }
    }

    TableEntryPtr->String = NULL;
    TableEntryPtr->StringReplaced = FALSE;
}


PCSTR
pGenerateUnquotedText (
    IN      POOLHANDLE Pool,
    IN      PCSTR Text,
    IN      INT Chars
    )

/*++

Routine Description:

  pGenerateUnqutoedText converts the pairs of dbl quotes in the specified
  string into a single set of dbl quotes.  This routine is used by the
  STF file parser, because quoted STF entries have pairs of dbl quotes
  to indicate a single dbl-quote symbol.

Arguments:

  Pool - Specifies the pool to allocate memory from

  Text - Specifies the text that may contain the pairs of dbl quotes

  Chars - Specifies the number of characters in Text.  If -1,
          Text is nul-terminated.

Return Value:

  A pointer to the converted string, or NULL if the pool allocation
  failed.

--*/

{
    PSTR Buf;
    PSTR d, p;
    PCSTR s;

    if (Chars < 0) {
        Chars = CharCountA (Text);
    }

    Buf = (PSTR) PoolMemGetAlignedMemory (
                       Pool,
                       (Chars + 1) * sizeof (WCHAR)
                       );

    if (!Buf) {
        return NULL;
    }

    s = Text;
    d = Buf;

    //
    // Remove double-quotes
    //

    while (Chars > 0) {
        if (Chars > 1 && _mbsnextc (s) == '\"') {
            p = _mbsinc (s);
            if (_mbsnextc (p) == '\"') {
                // Skip the first of two dbl quotes
                Chars--;
                s = p;
            }
        }

        // Copy character
        if (isleadbyte (*s)) {
            *d++ = *s++;
        }
        *d++ = *s++;

        Chars--;
    }

    *d = 0;

    return Buf;
}


PCSTR
pGenerateQuotedText (
    IN      POOLHANDLE Pool,
    IN      PCSTR Text,
    IN      INT Chars
    )

/*++

Routine Description:

  pGenerateQuotedText converts dbl quote characters in a string into
  pairs of dbl quotes.

Arguments:

  Pool - Specifies the pool to allocate memory from

  Text - Specifies the string to convert

  Chars - Specifies the number of characters to convert.  If -1,
          Text is nul terminated.

Return Value:

  A pointer to the converted text, or NULL if an allocation failed.

--*/

{
    PSTR Buf;
    PSTR d;
    PCSTR s;

    if (Chars < 0) {
        Chars = CharCountA (Text);
    }

    Buf = (PSTR) PoolMemGetAlignedMemory (
                      Pool,
                      (Chars + 3) * (sizeof (WCHAR) * 2)
                      );

    if (!Buf) {
        return NULL;
    }

    s = Text;
    d = Buf;

    //
    // Add quotes, double quotes already in the string
    //

    *d++ = '\"';

    while (Chars > 0) {
        if (_mbsnextc (s) == '\"') {
            *d++ = '\"';
        }

        if (isleadbyte (*s)) {
            *d++ = *s++;
        }
        *d++ = *s++;

        Chars--;
    }

    *d++ = '\"';
    *d = 0;

    return Buf;
}


VOID
pFreeQuoteConvertedText (
    IN      POOLHANDLE Pool,
    IN      PCSTR Text
    )

/*++

Routine Description:

  Frees the text converted by pGenerateUnquotedText or
  pGenerateQuotedText.

Arguments:

  Pool - Specifies the pool that the string was allocated
         from

  Text - Specifies the pointer returned by the conversion
         function

Return Value:

  none

--*/

{
    if (Text) {
        PoolMemReleaseMemory (Pool, (PVOID) Text);
    }
}


PCTSTR
GetTableEntryStr (
    IN OUT  PSETUPTABLE TablePtr,
    IN OUT  PTABLEENTRY TableEntryPtr
    )

/*++

Routine Description:

  Returns a pointer to the read-only string for
  the specified table entry.

Arguments:

  TablePtr - Specifies the table holding the entry

  TableEntryPtr - Specifies the entry to obtain the
                  string for

Return Value:

  A pointer to the string.

--*/

{
    return TableEntryPtr->String;
}


BOOL
ReplaceTableEntryStr (
    IN OUT  PSETUPTABLE TablePtr,
    IN OUT  PTABLEENTRY TableEntryPtr,
    IN      PCTSTR NewString
    )

/*++

Routine Description:

  ReplaceTableEntryStr replaces a string for a table
  entry.  The specified string is duplicated.

Arguments:

  TablePtr - Specifies the table holding the entry

  TableEntryPtr - Specifies the entry whos string is
                  to be replaced

  NewString - Specifies the new string

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    INT ch;
    PCTSTR p;

    //
    // First free all the resources associated wit the table entry
    //

    pFreeTableEntryPtr (
        TablePtr,
        TableEntryPtr,
        FALSE,              // don't dealloc
        NULL                // we don't need next entry ptr
        );

    //
    // Then duplicate the string and use it
    //

    TableEntryPtr->String = PoolMemDuplicateString (TablePtr->ReplacePool, NewString);
    TableEntryPtr->StringReplaced = (TableEntryPtr->String != NULL);

    //
    // Determine if new string needs quotes
    //

    TableEntryPtr->Quoted = FALSE;

    p = NewString;
    while (*p) {
        ch = _tcsnextc (p);
        if (ch < 32 || ch > 127 || ch == '\"') {
            TableEntryPtr->Quoted = TRUE;
            break;
        }

        p = _tcsinc (p);
    }

    return TableEntryPtr->StringReplaced;
}


BOOL
pInsertTableEntry (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT Line,             // zero-based
    IN      UINT Col,
    IN      DWORD Flags,
    IN      PCTSTR String,         // ownership taken over
    IN      BOOL Replaced
    )

/*++

Routine Description:

  pInsertTableEntry inserts a column into a line, and possibly
  creates the line if it does not exist.

Arguments:

  TablePtr - Specifies the table to insert an entry into

  Line - Specifies the line to insert the entry on, or INSERT_LINE_LAST
         to add a line.

  Col - Specifies the column to insert before, or INSERT_LAST_COL to
        append to the end of the line.

  Flags - Specifies any of the following:

            FIELD_QUOTED
            FIELD_BINARY

  String - Specifies the string to insert.

  Replaced - Specifies TRUE if the text comes from the ReplacePool, or
             FALSE if it comes from the TextPool.  All memory in ReplacePool
             must be freed, while all memory in the TextPool is freed at
             once during termination.  (The TextPool is used for parsed
             strings, the ReplacePool is used for modifications.)

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    PTABLELINE TableLinePtr;
    PTABLEENTRY NextTableEntryPtr, PrevTableEntryPtr, ThisTableEntryPtr;
    UINT OrgCol;
    BOOL Quoted;
    BOOL Binary;

    Quoted = (Flags & FIELD_QUOTED) != 0;
    Binary = (Flags & FIELD_BINARY) != 0;

    //
    // Make sure Line exists
    //

    TableLinePtr = pGetTableLinePtr (TablePtr, Line);
    if (!TableLinePtr) {
        //
        // Add a line to the end if Line is 1 more than the current count
        //

        if (Line > TablePtr->LineCount) {
            return FALSE;
        }

        TableLinePtr = pInsertEmptyLineInTable (TablePtr, INSERT_LINE_LAST);

        if (!TableLinePtr) {
            return FALSE;
        }
    }

    //
    // Locate the previous table entry (for linkage update)
    //

    PrevTableEntryPtr = NULL;
    OrgCol = Col;

    NextTableEntryPtr = pGetFirstTableEntryPtr (TablePtr, Line);

    while (Col > 0) {
        if (!NextTableEntryPtr) {
            if (OrgCol == INSERT_COL_LAST) {
                break;
            }

            DEBUGMSG ((DBG_WHOOPS, "pInsertTableEntry cannot insert beyond end of line"));
            return FALSE;
        }

        PrevTableEntryPtr = NextTableEntryPtr;
        NextTableEntryPtr = pGetNextTableEntryPtr (NextTableEntryPtr);
        Col--;
    }

    //
    // Allocate a new entry
    //

    ThisTableEntryPtr = (PTABLEENTRY) PoolMemGetAlignedMemory (
                                            TablePtr->ColumnStructPool,
                                            sizeof (TABLEENTRY)
                                            );

    if (!ThisTableEntryPtr) {
        return FALSE;
    }
    ZeroMemory (ThisTableEntryPtr, sizeof (TABLEENTRY));

    //
    // Adjust linkage
    //

    if (PrevTableEntryPtr) {
        PrevTableEntryPtr->Next = ThisTableEntryPtr;
    } else {
        TableLinePtr->FirstCol = ThisTableEntryPtr;
    }

    if (NextTableEntryPtr) {
        NextTableEntryPtr->Prev = ThisTableEntryPtr;
    }

    ThisTableEntryPtr->Next = NextTableEntryPtr;
    ThisTableEntryPtr->Prev = PrevTableEntryPtr;

    //
    // Fill members
    //

    ThisTableEntryPtr->Line = Line;
    ThisTableEntryPtr->Quoted = Quoted;
    ThisTableEntryPtr->Binary = Binary;
    ThisTableEntryPtr->String = String;
    ThisTableEntryPtr->StringReplaced = Replaced;

    //
    // Add to hash table
    //

    if (!PrevTableEntryPtr) {
        pAddToHashTable (TablePtr, String, CharCount (String), Line);
        if ((UINT) _ttoi (String) > TablePtr->MaxObj) {
            TablePtr->MaxObj = (UINT) _ttoi (String);
        }
    }

    return TRUE;
}


VOID
pFreeTableEntryPtr (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PTABLEENTRY TableEntryPtr,
    IN      BOOL DeallocateStruct,
    OUT     PTABLEENTRY *NextTableEntryPtr      OPTIONAL
    )

/*++

Routine Description:

  pFreeTableEntryPtr deallocates all resources associated with
  a table entry and is used for the delete routines.

Arguments:

  TablePtr - Specifies the table containing the entyr

  TableEntryPtr - Specifies the table entry to free

  DeallocateStruct - Specifies TRUE to completely deallocate the
                     entry, or FALSE if the entry is to be reset
                     but not deallocated.

  NextTableEntryPtr - Receives a pointer to the next table entry,
                      useful for deleting a chain of entries.

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    //
    // Give caller a pointer to the next table entry if requested
    //

    if (NextTableEntryPtr) {
        *NextTableEntryPtr = TableEntryPtr->Next;
    }

    //
    // Free any text pointers
    //
    pFreeTableEntryString (TablePtr, TableEntryPtr);

    //
    // Free the struct if necessary
    //
    if (DeallocateStruct) {
        PoolMemReleaseMemory (TablePtr->ColumnStructPool, TableEntryPtr);
    }
}


BOOL
pDeleteTableEntry (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PTABLEENTRY EntryToDeletePtr
    )

/*++

Routine Description:

  pDeleteTableEntry removes the specific table line, adjusts the
  SETUPTABLE struct accordingly, and cleans up resources.

Arguments:

  TablePtr - Specifies the table to process

  EntryToDeletePtr - Specifies the entry to delete from the table

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    PTABLELINE TableLinePtr;

    //
    // Update linkage
    //

    if (EntryToDeletePtr->Prev) {
        EntryToDeletePtr->Prev->Next = EntryToDeletePtr->Next;
    } else {
        TableLinePtr = pGetTableLinePtr (TablePtr, EntryToDeletePtr->Line);
        MYASSERT(TableLinePtr);
        TableLinePtr->FirstCol = EntryToDeletePtr->Next;
    }

    if (EntryToDeletePtr->Next) {
        EntryToDeletePtr->Next->Prev = EntryToDeletePtr->Prev;
    }

    // Deallocate the entry's resources
    pFreeTableEntryPtr (
        TablePtr,
        EntryToDeletePtr,
        TRUE,               // dealloc
        NULL                // we don't need the next entry ptr
        );

    return TRUE;
}


UINT
pGetColFromTableEntryPtr (
    IN      PSETUPTABLE TablePtr,
    IN      PTABLEENTRY FindMePtr
    )

/*++

Routine Description:

  pGetColFromTableEntryPtr returns the column number of the specified
  table entry.

Arguments:

  TablePtr - Specifies the table to process

  FindMePtr - Specifies the table entry to find

Return Value:

  The zero-based column number, or INVALID_COL if the column was not
  found.

--*/

{
    UINT Col;
    PTABLEENTRY ColSearchPtr;

    MYASSERT(FindMePtr);

    Col = 0;
    ColSearchPtr = pGetFirstTableEntryPtr (TablePtr, FindMePtr->Line);
    while (ColSearchPtr && ColSearchPtr != FindMePtr) {
        Col++;
        ColSearchPtr = pGetNextTableEntryPtr (ColSearchPtr);
    }

    if (!ColSearchPtr) {
        DEBUGMSG ((DBG_WHOOPS, "Col not found for specified entry"));
        return INVALID_COL;
    }

    return Col;
}



BOOL
InsertTableEntryStr (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PTABLEENTRY InsertBeforePtr,
    IN      PCTSTR NewString
    )

/*++

Routine Description:

  InsertTableEntryStr inserts a string in a line, shifting columns to the
  right.  This routine increases the number of columns on the line.

  To append a string to the line, call AppendTableEntryStr instead.

Arguments:

  TablePtr - Specifies the table to process

  InsertBeforePtr - Specifies the column to insert the string ahead of.

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    UINT Col;
    PCTSTR DupStr;

    MYASSERT (NewString);
    MYASSERT (InsertBeforePtr);

    Col = pGetColFromTableEntryPtr (TablePtr, InsertBeforePtr);
    if (Col == INVALID_COL) {
        return FALSE;
    }

    DupStr = PoolMemDuplicateString (TablePtr->ReplacePool, NewString);
    if (!DupStr) {
        return FALSE;
    }

    return pInsertTableEntry (
                TablePtr,
                InsertBeforePtr->Line,
                Col,
                0,                      // not quoted, not binary
                DupStr,
                TRUE                    // from ReplacePool
                );
}


BOOL
DeleteTableEntryStr (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PTABLEENTRY DeleteEntryPtr
    )

/*++

Routine Description:

  DeleteTableEntryStr removes the specific table entry, shifting columns
  to the left.  This routine reduces the number of columns on the line by
  one.

Arguments:

  TablePtr - Specifies the table to process

  DeleteEntryPtr - Specifies the entry to delete from the table

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    return pDeleteTableEntry (TablePtr, DeleteEntryPtr);
}


BOOL
AppendTableEntryStr (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT Line,
    IN      PCTSTR NewString
    )

/*++

Routine Description:

  AppendTableEntryStr adds a new column to the end of the specified
  line, increasing the number of columns on the line by one.

Arguments:

  TablePtr - Specifies the table to process

  Line - Specifies the zero-based line to append to

  NewString - Specifies the text for the new column

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    PCTSTR DupStr;

    MYASSERT (NewString);

    DupStr = PoolMemDuplicateString (TablePtr->ReplacePool, NewString);
    if (!DupStr) {
        return FALSE;
    }

    return pInsertTableEntry (
                TablePtr,
                Line,
                INSERT_COL_LAST,
                0,                      // not quoted, not binary
                DupStr,
                TRUE                    // from ReplacePool
                );
}

BOOL
AppendTableEntry (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT DestLine,
    IN      PTABLEENTRY SrcEntry
    )

/*++

Routine Description:

  AppendTableEntry adds a new column to the end of the specified
  line, increasing the number of columns on the line by one.  It
  copies the data specified from the entry, including the formatting
  information.

Arguments:

  TablePtr - Specifies the table to process

  DestLine - Specifies the zero-based line to append to

  SrcEntry - Specifies the entry to duplicate to the new column

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    PCTSTR DupStr;

    MYASSERT (SrcEntry);
    MYASSERT (SrcEntry->String);

    DupStr = PoolMemDuplicateString (TablePtr->ReplacePool, SrcEntry->String);
    if (!DupStr) {
        return FALSE;
    }

    return pInsertTableEntry (
                TablePtr,
                DestLine,
                INSERT_COL_LAST,
                SrcEntry->Quoted ? FIELD_QUOTED : 0,
                DupStr,
                TRUE                    // from ReplacePool
                );
}


PTABLEENTRY
FindTableEntry (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR FirstColText,
    IN      UINT Col,
    OUT     PUINT Line,            OPTIONAL
    OUT     PCTSTR *String         OPTIONAL
    )

/*++

Routine Description:

  FindTableEntry searches the setup table for caller-specified text
  by scaning the first column.  This routine is fast because it
  first searches a hash table to determine if the string actually
  exists in the table.

  While the search is done on the first column, the routine actually
  returns the column specified by the Col parameter.

Arguments:

  TablePtr - Specifies the table to process

  FirstColText - Specifies the text to find

  Col - Specifies the column to return

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    PHASHBUCKET BucketPtr;
    UINT Item;

    BucketPtr = pFindInHashTable (TablePtr, FirstColText, &Item);
    if (!BucketPtr) {
        //
        // Not found
        //

        return NULL;
    }

    if (Line) {
        *Line = BucketPtr->Elements[Item];
    }

    return GetTableEntry (TablePtr, BucketPtr->Elements[Item], Col, String);
}


PTABLELINE
pInsertEmptyLineInTable (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT InsertBeforeLine
    )

/*++

Routine Description:

  pInsertEmptyLineInTable creates a table line that has no columns.  This
  routine is used to establish a line where columns can be added.

Arguments:

  TablePtr - Specifies the table to process

  InsertBeforeLine - Specifies the line that is moved down to make room for
                     the blank line

Return Value:

  A pointer to the new line, or NULL if the routine fails.

--*/

{
    PTABLELINE LastLinePtr;
    PTABLELINE InsertBeforePtr = NULL;
    UINT BytesToMove;

    //
    // Validate InsertBeforeLine
    //

    if (InsertBeforeLine != INSERT_LINE_LAST) {
        InsertBeforePtr = pGetTableLinePtr (TablePtr, InsertBeforeLine);

        if (!InsertBeforePtr) {
            LOG ((
                LOG_ERROR,
                "Can't find InsertBeforeLine (which is %u, total lines=%u)",
                InsertBeforeLine,
                TablePtr->LineCount
                ));

            return NULL;
        }
    }

    //
    // Grow the array
    //

    LastLinePtr = (PTABLELINE) GrowBuffer (&TablePtr->Lines, sizeof (TABLELINE));
    if (!LastLinePtr) {
        return NULL;
    }

    ZeroMemory (LastLinePtr, sizeof (TABLELINE));

    //
    // If adding to the end, simply inc line count
    //

    TablePtr->LineCount++;
    if (InsertBeforeLine == INSERT_LINE_LAST) {
        return LastLinePtr;
    }

    //
    // Otherwise move memory to make room for new entry
    //

    BytesToMove = sizeof (TABLELINE) * (TablePtr->LineCount - InsertBeforeLine);
    MoveMemory (&InsertBeforePtr[1], InsertBeforePtr, BytesToMove);

    //
    // Zero new entry
    //

    ZeroMemory (InsertBeforePtr, sizeof (TABLELINE));
    return InsertBeforePtr;
}


BOOL
InsertEmptyLineInTable (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT InsertBeforeLine
    )

/*++

Routine Description:

  InsertEmptyLineInTable is a wrapper of pInsertEmptyLineInTable and is
  used by callers who shouldn't have knowledge of the TABLELINE struct.

Arguments:

  TablePtr - Specifies the table to process

  InsertBeforeLine - Specifies the line that is moved down to make room for
                     the blank line

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    if (InsertBeforeLine == TablePtr->LineCount) {
        InsertBeforeLine = INSERT_LINE_LAST;
    }

    if (!pInsertEmptyLineInTable (TablePtr, InsertBeforeLine)) {
        return FALSE;
    }
    return TRUE;
}


BOOL
DeleteLineInTable (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT LineToDelete
    )

/*++

Routine Description:

  DeleteLineInTable removes a complete line from the table, cleaning up
  all resources used by the line structs.

Arguments:

  TablePtr - Specifies the table to process

  LineToDelete - Specifies the line to delete from the table.  This line
                 is validated before delete occurs.

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    PTABLELINE DeletePtr;
    PTABLEENTRY TableEntryPtr;
    UINT BytesToMove;

    //
    // Validate line number
    //

    DeletePtr = pGetTableLinePtr (TablePtr, LineToDelete);
    if (!DeletePtr) {
        LOG ((
            LOG_ERROR,
            "Can't find LineToDelete (which is %u, total lines=%u)",
            LineToDelete,
            TablePtr->LineCount
            ));

        return FALSE;
    }

    //
    // Free the entire line's entries
    //

    TableEntryPtr = pGetFirstTableEntryPtr (TablePtr, LineToDelete);
    while (TableEntryPtr) {
        pFreeTableEntryPtr (
            TablePtr,
            TableEntryPtr,
            TRUE,               // dealloc
            &TableEntryPtr
            );
    }

    //
    // If not deleting the last line, move memory
    //

    TablePtr->LineCount--;
    if (TablePtr->LineCount != LineToDelete) {
        BytesToMove = sizeof (TABLELINE) * (TablePtr->LineCount + 1 - LineToDelete);
        MoveMemory (DeletePtr, &DeletePtr[1], BytesToMove);
    }

    //
    // Adjust growbuffer
    //

    TablePtr->Lines.End -= sizeof (TABLELINE);

    return TRUE;
}


//
// .STF file parser
//

PSTR
pIncrementStrPos (
    IN      PCSTR p,
    IN      PCSTR End
    )

/*++

Routine Description:

  Increments the specified string pointer, returning NULL if the pointer
  is incremented beyond the specified end.

Arguments:

  p - Specifies the pointer to increment

  End - Specifies the address of the first character beyond the end

Return Value:

  The incremented pointer, or NULL if the pointer extends beyond the end.

--*/

{
    if (!p || p >= End) {
        return NULL;
    }
    if (p + 1 == End) {
        return NULL;
    }

    return _mbsinc (p);
}


MBCHAR
pGetCharAtStrPos (
    IN      PCSTR p,
    IN      PCSTR End
    )

/*++

Routine Description:

  pGetCharAtStrPos returns the DBCS character at the specified position.
  It returns an incomplete character of a DBCS lead byte is at the end
  of the file, and it returns \n if the pointer is beyond the end of the
  file.

Arguments:

  p - Specifies the address to get the character

  End - Specifies the address of the first character beyond the end

Return Value:

  The DBCS character at position p.

--*/

{
    if (!p || p >= End) {
        return '\n';
    }
    if (p + 1 == End) {
        return *p;
    }

    return _mbsnextc (p);
}


BOOL
pIsCharColSeperator (
    IN      MBCHAR ch
    )

/*++

Routine Description:

  pIsCharColSeparator returns TRUE if the specified character can be used
  to separate columns in an STF file.  The list of characters comes from
  the STF spec.

Arguments:

  ch - Specifies the character to examine

Return Value:

  TRUE if the character is a column separator, or FALSE if it is not.

--*/

{
    return ch == '\t' || ch == '\r' || ch == '\n';
}


PCSTR
pCreateDbcsStr (
    IN      POOLHANDLE Pool,
    IN      PCSTR Text,
    IN      UINT ByteCount
    )

/*++

Routine Description:

  pCreateDbcsStr allocates a string from the specifies pool and copies
  the data up to a specified byte count.

Arguments:

  Pool - Specifies the pool to allocate memory from

  Text - Specifies the source string to copy into the newly allocated string

  ByteCount - Specifies the length of the source string, in bytes

Return Value:

  A pointer to the zero-terminated string, or NULL if memory could not
  be allocated.

--*/

{
    UINT Size;
    PSTR p;

    Size = ByteCount + 1;
    p = (PSTR) PoolMemGetAlignedMemory (Pool, Size);
    if (!p) {
        return NULL;
    }

    CopyMemory (p, Text, ByteCount);
    p[ByteCount] = 0;

    return p;
}


BOOL
pParseLine (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PCSTR FileText,
    IN      UINT MaxOffset,
    IN      UINT StartOffset,
    OUT     PUINT EndOffset,
    IN OUT  PUINT LinePtr
    )

/*++

Routine Description:

  pParseLine scans the STF file, extracting the current line, updating
  the SETUPTABLE structure, and returning the offset to the next line.

Arguments:

  TablePtr - Specifies the table to process

  FileText - Specifies the complete file text (mapped in to memory)

  MaxOffset - Specifies the number of bytes in FileText

  StartOffset - Specifies the offset of the start of the current line

  EndOffset - Receives the offset to the start of the next line

  LinePtr - Specifies the current line number and is incremented

Return Value:

  TRUE if the line was parsed successfully, or FALSE if an error was
  encountered.

--*/

{
    PCSTR p, q;
    PCSTR LastNonSpace;
    MBCHAR ch = 0;
    PCSTR End;
    PCSTR Start;
    UINT Length;
    BOOL QuoteMode;
    PCSTR QuoteStart, QuoteEnd;
    PCTSTR Text;
    UINT Chars;
    PCSTR CopyStart;
    PBYTE CopyDest;

#ifdef UNICODE
    PCSTR UnquotedAnsiText;
#endif

    End = &FileText[MaxOffset];
    Start = &FileText[StartOffset];

    if (Start >= End) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    //
    // Special case: Setup Status is a binary line
    //

    if (StringIMatchCharCountA (Start, "Setup Status\t", 13)) {
        //
        // Locate the end of the line.  We know it must have "\r\n at the end.
        // When the loop completes, p will point to the character after the
        // ending dbl quote, and q will point to the \n in the line.
        //

        p = Start;
        q = NULL;

        do {
            if (*p == 0) {
                LOG ((LOG_ERROR, "Nul found in STF status!"));
                return FALSE;
            }

            ch = pGetCharAtStrPos (p, End);

            if (ch == '\r') {
                //
                // Break while loop when line break is found
                //

                q = pIncrementStrPos (p, End);
                ch = pGetCharAtStrPos (q, End);

                if (ch != '\n') {
                    q = p;
                }

                break;

            } else if (ch == '\n') {

                break;

            }

            p = pIncrementStrPos (p, End);

        } while (p);

        MYASSERT (p);           // we did not hit the end of the file
        MYASSERT (q);           // we have a valid end-of-line pointer
        if (!p || !q) {
            return FALSE;
        }

        //
        // Copy binary line into buffer.  We know that the binary line cannot have
        // \r, \n or nul in it.  Terminate the line with a nul.
        //

        Length = p - Start;
        CopyDest = (PBYTE) PoolMemGetAlignedMemory (TablePtr->TextPool, Length + 2);
        if (!CopyDest) {
            return FALSE;
        }

        CopyMemory (CopyDest, Start, Length);
        CopyDest[Length] = 0;
        CopyDest[Length + 1] = 0;

        //
        // Add binary line as a single field
        //

        if (!pInsertTableEntry (
                TablePtr,
                *LinePtr,
                INSERT_COL_LAST,
                FIELD_BINARY,
                (PCTSTR) CopyDest,
                FALSE                           // from text pool
                )) {
            return FALSE;
        }

        //
        // Advance pointer beyond end of line and return
        //

        q++;
        *EndOffset = q - FileText;
        *LinePtr += 1;
        return TRUE;
    }

    //
    // Normal case: line is all text
    //

    p = Start;
    QuoteMode = FALSE;
    QuoteStart = NULL;
    QuoteEnd = NULL;

    //
    // Find item in tab-separated list
    //

    while (p) {
        if (*p == 0) {
            LOG ((LOG_ERROR, "Nul found in STF field!"));
            return FALSE;
        }

        ch = pGetCharAtStrPos (p, End);
        if (ch == '\"') {
            if (!QuoteMode && p == Start) {
                QuoteMode = TRUE;
                p = pIncrementStrPos (p, End);
                QuoteStart = p;
                continue;
            } else if (QuoteMode) {
                q = pIncrementStrPos (p, End);
                if (!q || pGetCharAtStrPos (q, End) != '\"') {
                    QuoteEnd = p;
                    QuoteMode = FALSE;
                    p = q;
                    continue;

                } else {
                    p = q;
                }
            }
        }

        if (!QuoteMode) {
            if (pIsCharColSeperator (ch)) {
                break;
            }
        } else {
            if (pIsCharColSeperator (ch) && ch != '\t') {
                QuoteEnd = p;
                QuoteMode = FALSE;
                break;
            }
        }


        p = pIncrementStrPos (p, End);
    }

    if (!p) {
        p = End;
    }

    if (QuoteStart && QuoteEnd) {
        StartOffset = QuoteStart - FileText;
        Length = QuoteEnd - QuoteStart;
    } else {
        //
        // Trim spaces on both sides of string
        //

        //
        // Find first non space in string
        //
        q = Start;
        while (pGetCharAtStrPos (q, End) == ' ' && q < p) {
            q = pIncrementStrPos (q, End);
        }

        if (q) {
            StartOffset = q - FileText;

            //
            // Find last non space in string
            //
            LastNonSpace = q;
            Start = q;

            while (q && q < p) {
                if (pGetCharAtStrPos (q, End) != ' ') {
                    LastNonSpace = q;
                }
                q = pIncrementStrPos (q, End);
            }

            if (!q) {
                LastNonSpace = p;
            } else {
                LastNonSpace = pIncrementStrPos (LastNonSpace, End);
                if (!LastNonSpace || LastNonSpace > p) {
                    LastNonSpace = p;
                }
            }

            Length = LastNonSpace - Start;
        } else {
            StartOffset = Start - FileText;
            Length = p - Start;
        }
    }

    if (Length > 1024) {
        SetLastError (ERROR_BAD_FORMAT);
        return FALSE;
    }


    //
    // Remove pairs of dbl quotes
    //

    CopyStart = &FileText[StartOffset];
    Chars = ByteCountToCharsA (CopyStart, Length);

    if (QuoteStart != NULL && QuoteEnd != NULL) {
        #ifdef UNICODE
            UnquotedAnsiText = pGenerateUnquotedText (
                                    TablePtr->ReplacePool,
                                    CopyStart,
                                    Chars
                                    );
            //
            // Convert text to UNICODE
            //

            Text = DbcsToUnicode (TablePtr->TextPool, UnquotedAnsiText);
            PoolMemReleaseMemory (TablePtr->ReplacePool, (PVOID) UnquotedAnsiText);
            if (!Text) {
                return FALSE;
            }
        #else
            //
            // No conversion needed for DBCS
            //

            Text = pGenerateUnquotedText (
                       TablePtr->TextPool,
                       CopyStart,
                       Chars
                       );
        #endif
    } else {
        //
        // For text that didn't need quote processing, allocate a
        // string in TextPool
        //

        #ifdef UNICODE
            Text = DbcsToUnicodeN (TablePtr->TextPool, CopyStart, Chars);
        #else
            Text = pCreateDbcsStr (TablePtr->TextPool, CopyStart, Length);
        #endif

        if (!Text) {
            return FALSE;
        }
    }

    if (!pInsertTableEntry (
                TablePtr,
                *LinePtr,
                INSERT_COL_LAST,
                QuoteStart != NULL && QuoteEnd != NULL ? FIELD_QUOTED : 0,
                Text,
                FALSE                           // from text pool
                )) {
        return FALSE;
    }

    //
    // Find next item
    //

    if (ch == '\r' || ch == '\n') {
        *LinePtr += 1;
    }

    if (ch == '\r' && p < End) {
        q = pIncrementStrPos (p, End);
        if (pGetCharAtStrPos (q, End) == '\n') {
            p = q;
        }
    }
    p = pIncrementStrPos (p, End);

    if (!p) {
        p = End;
    }

    *EndOffset = p - FileText;
    return TRUE;
}


VOID
pResetTableStruct (
    OUT     PSETUPTABLE TablePtr
    )

/*++

Routine Description:

  pResetTableStruct initializes the specified table

Arguments:

  TablePtr - Specifies the uninitialized table struct

Return Value:

  none

--*/

{
    ZeroMemory (TablePtr, sizeof (SETUPTABLE));

    TablePtr->SourceStfFile = INVALID_HANDLE_VALUE;
    TablePtr->SourceInfFile = INVALID_HANDLE_VALUE;
    TablePtr->DestStfFile = INVALID_HANDLE_VALUE;
    TablePtr->DestInfFile = INVALID_HANDLE_VALUE;
    TablePtr->SourceInfHandle = INVALID_HANDLE_VALUE;
}


BOOL
pCreateViewOfFile (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT FileSize
    )

/*++

Routine Description:

  pCreateViewOfFile establishes a pointer that points to a continuous
  buffer for the file.

Arguments:

  TablePtr - Specifies the table that provides file names, handles and
             so on.

  FileSize - Specifies the size of the STF file

Return Value:

  TRUE if the file was read or mapped into memory, FALSE if an error
  occurred.

--*/

{
#if USE_FILE_MAPPING
    TablePtr->FileMapping =  CreateFileMapping (
                                 TablePtr->SourceStfFile,
                                 NULL,
                                 PAGE_READONLY|SEC_RESERVE,
                                 0,
                                 0,
                                 NULL
                                 );

    if (!TablePtr->FileMapping) {
        LOG ((LOG_ERROR, "Create Setup Table: Can't create file mapping."));
        return FALSE;
    }

    TablePtr->FileText = (PCSTR) MapViewOfFile (
                                    TablePtr->FileMapping,
                                    FILE_MAP_READ,
                                    0,                  // start offset high
                                    0,                  // start offset low
                                    0                   // bytes to map - 0=all
                                    );

    if (!TablePtr->FileText) {
        LOG ((LOG_ERROR, "Create Setup Table: Can't map file into memory."));
        return FALSE;
    }

#else

    TablePtr->FileText = MemAlloc (g_hHeap, 0, FileSize);
    if (!TablePtr->FileText) {
        LOG ((LOG_ERROR, "Create Setup Table: Cannot allocate %u bytes", FileSize));
        return FALSE;
    }

    SetFilePointer (TablePtr->SourceStfFile, 0, NULL, FILE_BEGIN);

    if (!ReadFile (
            TablePtr->SourceStfFile,
            (PBYTE) (TablePtr->FileText),
            FileSize,
            &Offset,
            NULL
            )) {
        LOG ((LOG_ERROR, "Create Setup Table: Cannot read %u bytes", FileSize));
        return FALSE;
    }

#endif

    return TRUE;

}

VOID
pFreeViewOfFile (
    IN OUT  PSETUPTABLE TablePtr
    )

/*++

Routine Description:

  pFreeViewOfFile cleans up the resources allocated by pCreateViewOfFile.

Arguments:

  TablePtr - Specifies the table to process

Return Value:

  none

--*/

{
#ifdef USE_FILE_MAPPING
    //
    // Free all views of the file
    //

    if (TablePtr->FileText) {
        UnmapViewOfFile (TablePtr->FileText);
    }

    //
    // Close file mapping handle
    //

    if (TablePtr->FileMapping) {
        CloseHandle (TablePtr->FileMapping);
        TablePtr->FileMapping = NULL;
    }

#else
    //
    // Free memory used for file
    //

    if (TablePtr->FileText) {
        MemFree (g_hHeap, 0, TablePtr->FileText);
        TablePtr->FileText = NULL;
    }

#endif
}


BOOL
CreateSetupTable (
    IN      PCTSTR SourceStfFileSpec,
    OUT     PSETUPTABLE TablePtr
    )

/*++

Routine Description:

  CreateSetupTable is the master STF parsing routine.  Given a file
  spec, it performs all steps necessary to prepare the SETUPTABLE
  structure so that other routines can access and modify the table.

Arguments:

  SourceStfFileSpec - Specifies the STF file name to open

  TablePtr - Receives all data structures needed to manipulate the
             STF, including the INF associated with it.

Return Value:

  TRUE if parsing was successful, or FALSE if an error occurred.

--*/

{
    UINT Offset;
    BOOL b = FALSE;
    UINT FileSize;
    UINT LineNum;
    PCTSTR Text;
    TCHAR DestSpec[MAX_TCHAR_PATH];
    TCHAR DirSpec[MAX_TCHAR_PATH];
    PTSTR FilePart;

    pResetTableStruct (TablePtr);

    __try {
        //
        // Extract directory from SourceStfFileSpec
        //

        if (!OurGetFullPathName (SourceStfFileSpec, MAX_TCHAR_PATH, DirSpec, &FilePart)) {
            LOG ((LOG_ERROR, "Create Setup Table: GetFullPathName failed"));
            __leave;
        }

        if (FilePart) {
            FilePart = _tcsdec2 (DirSpec, FilePart);
            MYASSERT (FilePart);

            if (FilePart) {
                *FilePart = 0;
            }
        }

        //
        // Allocate memory pools
        //

        TablePtr->ColumnStructPool = PoolMemInitNamedPool ("STF: Column Structs");
        TablePtr->ReplacePool = PoolMemInitNamedPool ("STF: Replacement Text");
        TablePtr->TextPool = PoolMemInitNamedPool ("STF: Read-Only Text");
        TablePtr->InfPool = PoolMemInitNamedPool("STF: INF structs");

        if (!TablePtr->ColumnStructPool ||
            !TablePtr->ReplacePool ||
            !TablePtr->TextPool ||
            !TablePtr->InfPool
            ) {
            DEBUGMSG ((DBG_WARNING, "CreateSetupTable: Could not allocate a pool"));
            __leave;
        }

        //
        // Disable checked-build tracking on these pools
        //

        PoolMemDisableTracking (TablePtr->ColumnStructPool);
        PoolMemDisableTracking (TablePtr->TextPool);
        PoolMemDisableTracking (TablePtr->ReplacePool);
        PoolMemDisableTracking (TablePtr->InfPool);

        if (!pInitHashTable (TablePtr)) {
            DEBUGMSG ((DBG_WARNING, "CreateSetupTable: Could not init hash table"));
            __leave;
        }

        //
        // Open STF file
        //

        TablePtr->SourceStfFile = CreateFile (
                                      SourceStfFileSpec,
                                      GENERIC_READ,
                                      0,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL
                                      );

        if (TablePtr->SourceStfFile == INVALID_HANDLE_VALUE) {
            LOG ((LOG_ERROR, "Create Setup Table: Could not open %s", SourceStfFileSpec));
            __leave;
        }

        //
        // Limit file size to 4M
        //

        FileSize = SetFilePointer (TablePtr->SourceStfFile, 0, NULL, FILE_END);
        if (FileSize > 0x400000) {
            LOG ((LOG_ERROR, "Create Setup Table: File too big to parse"));
            __leave;
        }

        //
        // Copy SourceStfFileSpec to table struct
        //

        TablePtr->SourceStfFileSpec = PoolMemDuplicateString (
                                            TablePtr->ReplacePool,
                                            SourceStfFileSpec
                                            );

        if (!TablePtr->SourceStfFileSpec) {
            __leave;
        }

        //
        // Copy DirSpec to table struct
        //

        TablePtr->DirSpec = PoolMemDuplicateString (TablePtr->ReplacePool, DirSpec);

        if (!TablePtr->DirSpec) {
            __leave;
        }

        //
        // Generate DestStfFileSpec but do not open yet (see WriteSetupTable)
        //

        _tcssafecpy (DestSpec, TablePtr->SourceStfFileSpec, MAX_TCHAR_PATH - 4);
        StringCat (DestSpec, TEXT(".$$$"));

        TablePtr->DestStfFileSpec = PoolMemDuplicateString (
                                        TablePtr->ReplacePool,
                                        DestSpec
                                        );

        if (!TablePtr->DestStfFileSpec) {
            __leave;
        }

        //
        // Map the file into memory
        //

        if (!pCreateViewOfFile (TablePtr, FileSize)) {
            __leave;
        }

        //
        // Parse each line of the file until there are no more lines left
        //

        Offset = 0;
        LineNum = 0;
        while (TRUE) {
            if (!pParseLine (
                    TablePtr,
                    TablePtr->FileText,
                    FileSize,
                    Offset,
                    &Offset,
                    &LineNum
                    )) {

                if (GetLastError() != ERROR_SUCCESS) {
                    __leave;
                }

                break;
            }
        }

        //
        // Obtain name of INF file
        //

        if (!FindTableEntry (TablePtr, TEXT("Inf File Name"), 1, &LineNum, &Text)) {
            DEBUGMSG ((
                DBG_WARNING,
                "CreateSetupTable: File %s does not have an 'Inf File Name' entry",
                SourceStfFileSpec
                ));
            __leave;
        }

        if (!Text[0]) {
            DEBUGMSG ((
                DBG_WARNING,
                "CreateSetupTable: File %s has an empty 'Inf File Name' entry",
                SourceStfFileSpec
                ));
            __leave;
        }

        StringCopy (DestSpec, DirSpec);
        StringCopy (AppendWack (DestSpec), Text);

        TablePtr->SourceInfFileSpec = PoolMemDuplicateString (
                                         TablePtr->ReplacePool,
                                         DestSpec
                                         );

        if (!TablePtr->SourceInfFileSpec) {
            __leave;
        }

        //
        // Open the INF file, then parse it into our structures for later
        // modification.
        //

#if 0
        TablePtr->SourceInfFile = CreateFile (
                                      TablePtr->SourceInfFileSpec,
                                      GENERIC_READ,
                                      0,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL
                                      );
#else

        //
        // We can't modify the INF
        //

        TablePtr->SourceInfFile = INVALID_HANDLE_VALUE;

#endif

        if (TablePtr->SourceInfFile != INVALID_HANDLE_VALUE) {

            if (!InfParse_ReadInfIntoTable (TablePtr)) {
                DEBUGMSG ((
                    DBG_WARNING,
                    "CreateSetupTable: Can't parse %s",
                    TablePtr->SourceInfFileSpec
                    ));

                __leave;
            }

            //
            // Generate output name for INF file
            //

            _tcssafecpy (DestSpec, TablePtr->SourceInfFileSpec, MAX_TCHAR_PATH - 4);
            StringCat (DestSpec, TEXT(".$$$"));

            TablePtr->DestInfFileSpec = PoolMemDuplicateString (
                                            TablePtr->ReplacePool,
                                            DestSpec
                                            );

            if (!TablePtr->DestInfFileSpec) {
                __leave;
            }
        } else {
            LOG ((
                LOG_INFORMATION,
                (PCSTR)MSG_STF_MISSING_INF_LOG,
                TablePtr->SourceStfFileSpec,
                TablePtr->SourceInfFileSpec
                ));
        }

        b = TRUE;
    }
    __finally {
        pFreeViewOfFile (TablePtr);

        if (!b) {
            DestroySetupTable (TablePtr);
        }
    }

    return b;
}


VOID
DestroySetupTable (
    IN OUT  PSETUPTABLE TablePtr
    )

/*++

Routine Description:

  DestroySetupTable cleans up all resources associated with the specified
  table.  The table is reset.

Arguments:

  TablePtr - Specifies the table to clean up

Return Value:

  none

--*/

{
    //
    // Close all file handles
    //

    if (TablePtr->SourceStfFile != INVALID_HANDLE_VALUE) {
        CloseHandle (TablePtr->SourceStfFile);
    }

    if (TablePtr->SourceInfFile != INVALID_HANDLE_VALUE) {
        CloseHandle (TablePtr->SourceInfFile);
    }

    if (TablePtr->DestStfFile != INVALID_HANDLE_VALUE) {
        CloseHandle (TablePtr->DestStfFile);
    }

    if (TablePtr->DestInfFile != INVALID_HANDLE_VALUE) {
        CloseHandle (TablePtr->DestInfFile);
    }

    if (TablePtr->SourceInfHandle != INVALID_HANDLE_VALUE) {
        InfCloseInfFile (TablePtr->SourceInfHandle);
    }

    //
    // Free pools
    //

    FreeGrowBuffer (&TablePtr->Lines);
    if (TablePtr->ColumnStructPool) {
        PoolMemDestroyPool (TablePtr->ColumnStructPool);
    }

    if (TablePtr->ReplacePool) {
        PoolMemDestroyPool (TablePtr->ReplacePool);
    }

    if (TablePtr->TextPool) {
        PoolMemDestroyPool (TablePtr->TextPool);
    }

    if (TablePtr->InfPool) {
        PoolMemDestroyPool (TablePtr->InfPool);
    }

    pFreeHashTable (TablePtr);

    pResetTableStruct (TablePtr);
}


BOOL
pWriteTableEntry (
    IN      HANDLE File,
    IN      PSETUPTABLE TablePtr,
    IN      PTABLEENTRY TableEntryPtr
    )

/*++

Routine Description:

  pWriteTableEntry is a worker that writes out an STF table entry to
  disk, enclosing the entry in quotes if necessary.

Arguments:

  File - Specifies the output file handle

  TablePtr - Specifies the table being processed

  TableEntryPtr - Specifies the entry to write

Return Value:

  TRUE if successful, FALSE if an error occurred.

--*/

{
    PCSTR AnsiStr;
    BOOL b = TRUE;
    PCSTR QuotedText;
    BOOL FreeQuotedText = FALSE;
    PCTSTR EntryStr;
    DWORD DontCare;


    EntryStr = GetTableEntryStr (TablePtr, TableEntryPtr);
    if (!EntryStr) {
        return FALSE;
    }

    //
    // If binary, write the binary line and return
    //

    if (TableEntryPtr->Binary) {
        b = WriteFile (
                File,
                EntryStr,
                strchr ((PSTR) EntryStr, 0) - (PSTR) EntryStr,
                &DontCare,
                NULL
                );

        return b;
    }

    AnsiStr = CreateDbcs (EntryStr);
    if (!AnsiStr) {
        return FALSE;
    }

    //
    // Quote string if necessary
    //

    if (TableEntryPtr->Quoted) {
        QuotedText = pGenerateQuotedText (TablePtr->ReplacePool, AnsiStr, -1);
        if (!QuotedText) {
            b = FALSE;
        } else {
            FreeQuotedText = TRUE;
        }
    } else {
        QuotedText = AnsiStr;
    }

    //
    // Write the ANSI string to disk
    //
    if (b && *QuotedText) {
        b = WriteFileStringA (File, QuotedText);
    }

    //
    // Clean up string
    //

    DestroyDbcs (AnsiStr);

    if (FreeQuotedText) {
        pFreeQuoteConvertedText (TablePtr->ReplacePool, QuotedText);
    }

    return b;
}


BOOL
pWriteStfToDisk (
    IN      PSETUPTABLE TablePtr
    )

/*++

Routine Description:

  pWriteStfToDisk dumps an entire STF file to disk by enumerating all
  lines in the file and writing all columns for each line.

Arguments:

  TablePtr - Specifies the table to write

Return Value:

  TRUE if successful, FALSE if an error occurred.

--*/

{
    UINT Line;
    BOOL b = TRUE;
    PTABLELINE TableLinePtr;
    PTABLEENTRY TableEntryPtr;

    MYASSERT (TablePtr->DestStfFile != INVALID_HANDLE_VALUE);

    Line = 0;

    SetFilePointer (TablePtr->DestStfFile, 0, NULL, FILE_BEGIN);
    SetEndOfFile (TablePtr->DestStfFile);

    do {
        TableLinePtr = pGetTableLinePtr (TablePtr, Line);
        if (TableLinePtr) {
            //
            // Write the line by enumerating each entry, then writing a tab
            //
            TableEntryPtr = pGetFirstTableEntryPtr (TablePtr, Line);
            while (TableEntryPtr) {
                //
                // Write the entry
                //

                if (!pWriteTableEntry (TablePtr->DestStfFile, TablePtr, TableEntryPtr)) {
                    b = FALSE;
                    break;
                }

                //
                // Continue to next entry
                //

                TableEntryPtr = pGetNextTableEntryPtr (TableEntryPtr);

                //
                // Write a tab
                //

                if (TableEntryPtr) {
                    if (!WriteFileStringA (TablePtr->DestStfFile, "\t")) {
                        b = FALSE;
                        break;
                    }
                }
            }

            if (!b) {
                break;
            }

            //
            // Write a return/line-feed to end the line
            //

            if (!WriteFileStringA (TablePtr->DestStfFile, "\r\n")) {
                b = FALSE;
                break;
            }

            Line++;
        }
    } while (TableLinePtr);

    return b;
}


BOOL
WriteSetupTable (
    IN      PSETUPTABLE TablePtr
    )

/*++

Routine Description:

  WriteSetupTable writes the STF and INF represented by TablePtr.  This
  saves all changes to disk, writing to the output files indicated within
  the TablePtr structure.

Arguments:

  TablePtr - Specifies the table to write

Return Value:

  TRUE if successful, FALSE if an error occurred.

--*/

{
    BOOL b = FALSE;

    //
    // Open INF file for reading
    //

    __try {
        //
        // Create the output STF file
        //

        if (TablePtr->DestStfFile != INVALID_HANDLE_VALUE) {
            CloseHandle (TablePtr->DestStfFile);
        }

        TablePtr->DestStfFile = CreateFile (
                                    TablePtr->DestStfFileSpec,
                                    GENERIC_WRITE,
                                    0,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );

        if (TablePtr->DestStfFile == INVALID_HANDLE_VALUE) {
            LOG ((LOG_ERROR, "Write Setup Table: Could not create %s (STF file)", TablePtr->DestStfFileSpec));
            __leave;
        }

        //
        // Write the STF structure to disk
        //

        if (!pWriteStfToDisk (TablePtr)) {
            LOG ((LOG_ERROR, "Write Setup Table: Error while writing %s (STF file)", TablePtr->DestStfFileSpec));
            __leave;
        }

        if (TablePtr->SourceInfFile != INVALID_HANDLE_VALUE) {
            //
            // Create the output INF file
            //

            DEBUGMSG ((DBG_STF, "Writing new INF file for STF"));

            if (TablePtr->DestInfFile != INVALID_HANDLE_VALUE) {
                CloseHandle (TablePtr->DestInfFile);
            }

            TablePtr->DestInfFile = CreateFile (
                                        TablePtr->DestInfFileSpec,
                                        GENERIC_WRITE,
                                        0,
                                        NULL,
                                        CREATE_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL
                                        );


            if (TablePtr->DestInfFile == INVALID_HANDLE_VALUE) {
                LOG ((LOG_ERROR, "Write Setup Table: Could not create %s (INF file)", TablePtr->DestInfFileSpec));
                __leave;
            }

            //
            // Write the modified INF to disk
            //

            if (!InfParse_WriteInfToDisk (TablePtr)) {
                LOG ((LOG_ERROR, "Write Setup Table: Error while writing %s (INF file)", TablePtr->DestInfFileSpec));
                __leave;
            }
        }

        b = TRUE;
    }
    __finally {
        //
        // Close new STF, and on failure, delete the new STF
        //

        if (TablePtr->DestStfFile != INVALID_HANDLE_VALUE) {
            CloseHandle (TablePtr->DestStfFile);
            TablePtr->DestStfFile = INVALID_HANDLE_VALUE;
        }

        if (!b) {
            DeleteFile (TablePtr->DestStfFileSpec);
        }

        //
        // Close new INF, and on failure, delete the new INF
        //

        if (TablePtr->SourceInfFile != INVALID_HANDLE_VALUE) {

            if (TablePtr->DestInfFile != INVALID_HANDLE_VALUE) {
                CloseHandle (TablePtr->DestInfFile);
                TablePtr->DestInfFile = INVALID_HANDLE_VALUE;
            }

            if (!b) {
                DeleteFile (TablePtr->DestInfFileSpec);
            }
        }
    }

    return b;
}



PCTSTR *
ParseCommaList (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR CommaListString
    )

/*++

Routine Description:

  ParseCommaList divides a comma-separated list into an array of string pointers.
  The array is cleaned up by FreeCommaList.

Arguments:

  TablePtr - Specifies the table being processed and is used for memory allocation

  CommaListString - Specifies the string to parse

Return Value:

  An array of string pointers, with the last element set to NULL, or NULL if an
  error occurred.

--*/

{
    PCTSTR p;
    PTSTR *ArgArray;
    UINT Args = 1;
    UINT PoolSize;
    PTSTR DestBuf;
    PTSTR d;
    PTSTR SpaceTrim;
    BOOL QuoteEnclosed;

    //
    // Pass 1: Count the commas
    //

    p = SkipSpace (CommaListString);
    if (*p) {
        Args++;
    }

    while (*p) {
        if (_tcsnextc (p) == DBLQUOTECHAR) {
            p = _tcsinc (p);

            while (*p) {
                if (_tcsnextc (p) == DBLQUOTECHAR) {
                    if (_tcsnextc (_tcsinc (p)) == DBLQUOTECHAR) {
                        p = _tcsinc (p);
                    } else {
                        break;
                    }
                }

                p = _tcsinc (p);
            }

            if (*p) {
                p = _tcsinc (p);
                DEBUGMSG_IF ((*p && _tcsnextc(SkipSpace(p)) != TEXT(','), DBG_STF, "Comma List String %s has text outside the quotes", CommaListString));
            }
            ELSE_DEBUGMSG ((DBG_STF, "Comma List String %s does not have balanced dbl quotes", CommaListString));
        } else {
            while (*p && _tcsnextc (p) != TEXT(',')) {
                p = _tcsinc (p);
            }
        }

        if (_tcsnextc (p) == TEXT(',')) {
            Args++;
        }

        if (*p) {
            p = SkipSpace (_tcsinc (p));
        }
    }

    //
    // Pass 2: Prepare list of args
    //

    ArgArray = (PTSTR *) PoolMemGetAlignedMemory (TablePtr->ReplacePool, sizeof (PCTSTR *) * Args);
    if (!ArgArray) {
        return NULL;
    }

    p = SkipSpace (CommaListString);

    if (!(*p)) {
        *ArgArray = NULL;
        return ArgArray;
    }

    PoolSize = SizeOfString (CommaListString) + Args * sizeof (TCHAR);
    DestBuf = (PTSTR) PoolMemGetAlignedMemory (TablePtr->ReplacePool, PoolSize);
    if (!DestBuf) {
        PoolMemReleaseMemory (TablePtr->ReplacePool, (PVOID) ArgArray);
        return NULL;
    }

    d = DestBuf;
    Args = 0;
    while (*p) {
        //
        // Extract next string
        //

        ArgArray[Args] = d;
        SpaceTrim = d;
        Args++;

        if (_tcsnextc (p) == DBLQUOTECHAR) {
            //
            // Quote-enclosed arg
            //

            QuoteEnclosed = TRUE;

            while (TRUE) {
                p = _tcsinc (p);
                if (!(*p)) {
                    break;
                }

                if (_tcsnextc (p) == DBLQUOTECHAR) {
                    p = _tcsinc (p);
                    if (_tcsnextc (p) != DBLQUOTECHAR) {
                        break;
                    }
                }
                _copytchar (d, p);
                d = _tcsinc (d);
            }

            while (*p && _tcsnextc (p) != TEXT(',')) {
                p = _tcsinc (p);
            }
        } else {
            //
            // Non-quote-enclosed arg
            //

            QuoteEnclosed = FALSE;

            while (*p && _tcsnextc (p) != TEXT(',')) {
                _copytchar (d, p);
                d = _tcsinc (d);
                p = _tcsinc (p);
            }
        }

        //
        // Terminate string
        //

        *d = 0;
        if (!QuoteEnclosed) {
            SpaceTrim = (PTSTR) SkipSpaceR (SpaceTrim, d);
            if (SpaceTrim) {
                d = _tcsinc (SpaceTrim);
                *d = 0;
            }
        }

        d = _tcsinc (d);

        if (*p) {
            // Skip past comma
            p = SkipSpace (_tcsinc (p));
        }
    }

    ArgArray[Args] = NULL;

    return ArgArray;
}


VOID
FreeCommaList (
    PSETUPTABLE TablePtr,
    PCTSTR *ArgArray
    )

/*++

Routine Description:

  FreeCommaList cleans up the resources allocated by ParseCommaList.

Arguments:

  TablePtr - Specifies the table to that holds the resources

  ArgArray - Specifies the return value from ParseCommaList

Return Value:

  none

--*/

{
    if (ArgArray) {
        if (*ArgArray) {
            PoolMemReleaseMemory (TablePtr->ReplacePool, (PVOID) *ArgArray);
        }

        PoolMemReleaseMemory (TablePtr->ReplacePool, (PVOID) ArgArray);
    }
}


PCTSTR
pUnencodeDestDir (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR EncodedDestDir
    )

/*++

Routine Description:

  pUnencodeDestDir translates the directory encoding as defined by the
  STF spec.  It scans for certain fields that point to other STF lines
  and generates the full path.

Arguments:

  TablePtr - Specifies the table to process

  EncodedDestDir - Specifies the encoded directory string, as obtained
                   from the STF

Return Value:

  A pointer to the converted string, or NULL if an error occurred.

--*/

{
    GROWBUFFER String = GROWBUF_INIT;
    PTSTR Base, p, q;
    PCTSTR SubDestDir;
    PTSTR DestDir = NULL;
    CHARTYPE c;
    UINT Line;

    p = (PTSTR) GrowBuffer (&String, SizeOfString (EncodedDestDir));
    if (!p) {
        return NULL;
    }

    Base = p;

    __try {
        //
        // Copy until a percent symbol is encountered
        //

        while (*EncodedDestDir) {
            c = (CHARTYPE)_tcsnextc (EncodedDestDir);

            if (c == TEXT('%')) {
                EncodedDestDir = _tcsinc (EncodedDestDir);
                c = (CHARTYPE)_tcsnextc (EncodedDestDir);

                DEBUGMSG ((DBG_VERBOSE, "Percent processing"));

                if (_istdigit (c)) {
                    Line = _tcstoul (EncodedDestDir, &q, 10);
                    EncodedDestDir = q;

                    SubDestDir = GetDestDir (TablePtr, Line);
                    if (!SubDestDir) {
                        __leave;
                    }

                    __try {
                        // Expand buffer
                        GrowBuffer (&String, ByteCount (SubDestDir));

                        // Recalculate p because buffer may have moved
                        p = (PTSTR) (String.Buf + (p - Base));
                        Base = (PTSTR) String.Buf;

                        // Copy SubDestDir into string
                        *p = 0;
                        p = _tcsappend (p, SubDestDir);
                    }
                    __finally {
                        FreeDestDir (TablePtr, SubDestDir);
                    }
                } else {
                    DEBUGMSG ((DBG_WARNING, "STF uses option %%%c which is ignored", c));
                    EncodedDestDir = _tcsinc (EncodedDestDir);
                }
            }
            else {
                _copytchar (p, EncodedDestDir);
                p = _tcsinc (p);
            }

            EncodedDestDir = _tcsinc (EncodedDestDir);
        }

        //
        // Terminate string
        //

        *p = 0;

        //
        // Copy string into a pool mem buffer
        //

        DestDir = (PTSTR) PoolMemGetAlignedMemory (
                                TablePtr->ReplacePool,
                                SizeOfString ((PTSTR) String.Buf)
                                );

        StringCopy (DestDir, (PCTSTR) String.Buf);
    }
    __finally {
        FreeGrowBuffer (&String);
    }

    return DestDir;
}


VOID
FreeDestDir (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR DestDir
    )


/*++

Routine Description:

  FreeDestDir cleans up the string allocated by pUnencodeDestDir or
  GetDestDir.

Arguments:

  TablePtr - Specifies the table being processed

  DestDir - Specifies the string to clean up

Return Value:

  none

--*/


{
    if (DestDir) {
        PoolMemReleaseMemory (TablePtr->ReplacePool, (PVOID) DestDir);
    }
}


PCTSTR
GetDestDir (
    IN      PSETUPTABLE TablePtr,
    IN      UINT Line
    )

/*++

Routine Description:

  GetDestDir returns the destination directory stored for the caller-
  specified line.  The destination directory is column 14 in the STF file
  line.

Arguments:

  TablePtr - Specifies the table to process

  Line - Specifies the table zero-based line to access

Return Value:

  A pointer to the full destination directory, or NULL if an error occurred
  or the destination directory field does not exist on the STF line.

--*/

{
    PCTSTR EncodedDestDir;
    PCTSTR DestDir;

    if (!GetTableEntry (TablePtr, Line, 14, &EncodedDestDir)) {
        return NULL;
    }

    DestDir = pUnencodeDestDir (TablePtr, EncodedDestDir);
    return DestDir;
}


//
// Hash table routines
//

BOOL
pInitHashTable (
    IN OUT  PSETUPTABLE TablePtr
    )

/*++

Routine Description:

  pInitHashTable allocates an array of bucket pointers for the hash
  table, and zero-initializes them.  Each element of the hash bucket
  array holds a pointer to an a bucket of items, or is NULL if no
  items exist.

Arguments:

  TablePtr - Specifies the table to process

Return Value:

  Always TRUE

--*/

{
    TablePtr->HashBuckets = (PHASHBUCKET *) MemAlloc (
                                                g_hHeap,
                                                HEAP_ZERO_MEMORY,
                                                sizeof (PHASHBUCKET) * STF_HASH_BUCKETS
                                                );

    return TRUE;
}


VOID
pFreeHashTable (
    IN OUT  PSETUPTABLE TablePtr
    )

/*++

Routine Description:

  pFreeHashTable frees all allocated buckets, and then frees the
  bucket array.

Arguments:

  TablePtr - Specifies the table to process

Return Value:

  none

--*/

{
    INT i;

    for (i = 0 ; i < STF_HASH_BUCKETS ; i++) {
        if (TablePtr->HashBuckets[i]) {
            MemFree (g_hHeap, 0, TablePtr->HashBuckets[i]);
        }
    }

    MemFree (g_hHeap, 0, TablePtr->HashBuckets);
    TablePtr->HashBuckets = NULL;
}


UINT
pCalculateHashValue (
    IN      PCTSTR Text,
    IN      UINT Len
    )

/*++

Routine Description:

  pCalculateHashValue produces a hash value based on the number
  embedded at the start of the string (if any), or a shifted
  and xor'd combination of all characters in the string.

Arguments:

  Text - Specifies the text to process

  Len - Specifies the length fo the text

Return Value:

  The hash value.

--*/

{
    UINT Value = 0;

    if (Len == NO_LENGTH) {
        Len = CharCount (Text);
    }

    if (Len && _tcsnextc(Text) >= '0' && _tcsnextc(Text) <= '9') {
        do {
            Value = Value * 10 + (_tcsnextc (Text) - '0');
            Text = _tcsinc (Text);
            Len--;
        } while (Len && _tcsnextc(Text) >= '0' && _tcsnextc(Text) <= '9');

        if (!Len) {
            return Value % STF_HASH_BUCKETS;
        }
    }

    while (Len > 0) {
        Value = (Value << 2) | (Value >> 30);
        Value ^= _totlower ((WORD) _tcsnextc (Text));

        Text = _tcsinc (Text);
        Len--;
    }

    Value = Value % STF_HASH_BUCKETS;

    return Value;
}


BOOL
pAddToHashTable (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PCTSTR Text,
    IN      UINT Len,
    IN      UINT Line
    )

/*++

Routine Description:

  pAddToHashTable adds a line reference to the bucket.  The bucket
  number is calculated from the specified text.

Arguments:

  TablePtr - Specifies the table to process

  Text - Specifies the text to hash

  Len - Specifies the length of Text

  Line - Specifies the line to add to the bucket

Return Value:

  none

--*/

{
    UINT HashValue;
    PHASHBUCKET HashBucket, NewBucket;
    PHASHBUCKET *HashBucketPtr;
    UINT Size;

#ifdef DEBUG
    UINT Item;
#endif

    // Ignore empty strings
    if (!(*Text)) {
        return TRUE;
    }

#ifdef DEBUG
    if (pFindInHashTable (TablePtr, Text, &Item)) {
        DEBUGMSG ((DBG_WARNING, "String %s already in hash table", Text));
    }
#endif

    HashValue = pCalculateHashValue (Text, Len);
    HashBucketPtr = &TablePtr->HashBuckets[HashValue];
    HashBucket = *HashBucketPtr;

    //
    // Grow the bucket as necessary
    //

    if (HashBucket) {
        if (HashBucket->Count == HashBucket->Size) {
            Size = sizeof (Line) *
                    (HashBucket->Size + BUCKET_GROW_RATE) +
                    sizeof (HASHBUCKET);

            NewBucket = (PHASHBUCKET) MemReAlloc (
                                            g_hHeap,
                                            0,
                                            HashBucket,
                                            Size
                                            );

            if (!NewBucket) {
                return FALSE;
            }

            *HashBucketPtr = NewBucket;
            HashBucket = NewBucket;
            HashBucket->Size += BUCKET_GROW_RATE;
        }
    } else {
        Size = sizeof (Line) * BUCKET_GROW_RATE + sizeof (HASHBUCKET);
        NewBucket = (PHASHBUCKET) MemAlloc (
                                      g_hHeap,
                                      HEAP_ZERO_MEMORY,
                                      Size
                                      );

        *HashBucketPtr = NewBucket;
        HashBucket = NewBucket;
        HashBucket->Size = BUCKET_GROW_RATE;
    }

    //
    // Get a pointer to the end of the bucket and stick the line in there
    //

    HashBucket->Elements[HashBucket->Count] = Line;
    HashBucket->Count++;

    return TRUE;
}


PHASHBUCKET
pFindInHashTable (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR Text,
    OUT     PUINT BucketItem
    )

/*++

Routine Description:

  pFindInHashTable scans the hash bucket for an exact match with
  the specified text.  If a match if found, a pointer to the hash
  bucket is returned, along with an index to the bucket item.

Arguments:

  TablePtr - Specifies the table to process

  Text - Specifies the text to find

  BucketItem - Receives the index to the hash bucket if a match was
               found, otherwise has an undetermined value.

Return Value:

  A pointer to the hash bucket that contains the item corresponding
  to the matched text, or NULL if no match was found.

--*/

{
    UINT HashValue;
    PHASHBUCKET HashBucket;
    PCTSTR EntryString;
    UINT d;

    HashValue = pCalculateHashValue (Text, NO_LENGTH);
    HashBucket = TablePtr->HashBuckets[HashValue];
    if (!HashBucket) {
        return NULL;
    }

    for (d = 0 ; d < HashBucket->Count ; d++) {
        if (!GetTableEntry (TablePtr, HashBucket->Elements[d], 0, &EntryString)) {
            DEBUGMSG ((DBG_WHOOPS, "pFindInHashTable could not get string"));
            return NULL;
        }

        if (StringIMatch (Text, EntryString)) {
            *BucketItem = d;
            return HashBucket;
        }
    }

    return NULL;
}


BOOL
pRemoveFromHashTable (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PCTSTR Text
    )

/*++

Routine Description:

  pRemoveFromHashTable removes the specified text entry from the
  hash table.  The bucket item count is reduced, but the memory
  allocation is not reduced.

Arguments:

  TablePtr - Specifies the table to process

  Text - Specifies the text to remove from the hash table

Return Value:

  TRUE if delete was sucessful, or FALSE if the item was not found.

--*/

{
    PHASHBUCKET DelBucket;
    UINT Item;
    PUINT LastItem, ThisItem;

    DelBucket = pFindInHashTable (TablePtr, Text, &Item);
    if (!DelBucket) {
        LOG ((LOG_ERROR, "Remove From Hash Table:  Could not find string %s", Text));
        return FALSE;
    }

    ThisItem = &DelBucket->Elements[Item];
    LastItem = &DelBucket->Elements[DelBucket->Count - 1];

    if (ThisItem != LastItem) {
        *ThisItem = *LastItem;
    }

    DelBucket->Count--;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\stfp.h ===
//
// Prototypes
//

BOOL
pProcessSetupTableFile (
    IN      PCTSTR StfFileSpec
    );

BOOL
pProcessSectionCommand (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT StfLine,
    IN      PCTSTR InfSection,
    IN      PCTSTR InstallDestDir
    );

BOOL
pProcessLineCommand (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT StfLine,
    IN      PCTSTR InfSection,
    IN      PCTSTR InfKey,
    IN      PCTSTR InstallDestDir
    );

BOOL
pGetNonEmptyTableEntry (
    IN      PSETUPTABLE TablePtr,
    IN      UINT Line,
    IN      UINT Col,
    OUT     PTABLEENTRY *EntryPtr,          OPTIONAL
    OUT     PCTSTR *EntryStr                OPTIONAL
    );

PSTFINFSECTION
pGetNewInfSection (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR FileSpec,
    OUT     PBOOL CreatedFlag
    );

VOID
pGetFileNameFromInfField (
    OUT     PTSTR FileName,
    IN      PCTSTR InfField
    );


BOOL
pDeleteStfLine (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT StfLine
    );

BOOL
pReplaceDirReferences (
    IN      PSETUPTABLE TablePtr,
    IN      UINT StfLine,
    IN      PCTSTR DirSpec
    );

BOOL
pRemoveDeletedFiles (
    IN OUT  PSETUPTABLE TablePtr
    );

BOOL
pCreateNewStfLine (
    IN OUT  PSETUPTABLE TablePtr,
    IN      UINT StfLine,
    IN      PCTSTR ObjectData,
    IN      PCTSTR InstallDestDir
    );

BOOL
pSearchAndReplaceObjectRefs (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PCTSTR SrcStr,
    IN      PCTSTR DestStr
    );


BOOL
pUpdateObjReferences (
    IN      PSETUPTABLE TablePtr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\tapi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tapi.c

Abstract:

    This file implements WindowsNT side functionality for TAPI migration.

Author:

    Marc R. Whitten (marcw) 21-Nov-1997

Revision History:


--*/


#include "pch.h"

typedef struct {

    PTSTR   Name;
    PTSTR   AreaCode;
    DWORD   Country;
    PTSTR   DisableCallWaiting;
    DWORD   Flags;
    DWORD   Id;
    PTSTR   LongDistanceAccess;
    DWORD   PulseDial;
    PTSTR   OutsideAccess;
    DWORD   CallingCard;
    TCHAR   EntryName[40];

} LOCATION, * PLOCATION;

typedef struct {

    PTSTR Name;
    TCHAR EntryName[60];
    DWORD Id;
    PTSTR Pin;
    PTSTR Locale;
    PTSTR LongDistance;
    PTSTR International;
    DWORD Flags;

} CALLINGCARD, * PCALLINGCARD;

#define DBG_TAPI    "TAPI"

#define DEFAULT_LOCATION_FLAGS 1
#define NO_CURRENT_LOCATION_FOUND -1


GROWLIST g_LocationsList = GROWLIST_INIT;
GROWLIST g_CallingCardList = GROWLIST_INIT;
BOOL g_LocationsRead = FALSE;
UINT g_CurrentLocation = 0;
POOLHANDLE g_TapiPool;


//
// Location flags to set.
//
#define LOCATION_USETONEDIALING  0x01
#define LOCATION_USECALLINGCARD  0x02
#define LOCATION_HASCALLWAITING  0x04

//
// CallingCard flags to set.
//
#define CALLINGCARD_BUILTIN 0x01
#define CALLINGCARD_HIDE 0x02

//
// Location key field specifiers (in telephon.ini)
//
enum {
    FIELD_ID                    = 1,
    FIELD_NAME                  = 2,
    FIELD_OUTSIDEACCESS         = 3,
    FIELD_LONGDISTANCEACCESS    = 4,
    FIELD_AREACODE              = 5,
    FIELD_COUNTRY               = 6,
    FIELD_CALLINGCARD           = 7,
    FIELD_PULSEDIAL             = 11,
    FIELD_DISABLECALLWAITING    = 12
};

enum {

    FIELD_CC_ID                 = 1,
    FIELD_CC_NAME               = 2,
    FIELD_CC_PIN                = 3,
    FIELD_CC_LOCALE             = 4,
    FIELD_CC_LONGDISTANCE       = 5,
    FIELD_CC_INTERNATIONAL      = 6,
    FIELD_CC_FLAGS              = 7

};

#define S_USERLOCATIONSKEY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations")
#define S_USERCALLINGCARDSKEY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Cards")
#define S_LOCALRULE TEXT("LocalRule")
#define S_LDRULE TEXT("LDRule")
#define S_INTERNATIONALRULE TEXT("InternationalRule")
#define S_PIN TEXT("Pin")
#define S_CALLINGCARD TEXT("CallingCard")
#define S_CARDS TEXT("Cards")


BOOL
pReadCardFromIniFile (
    IN PINFSTRUCT Is,
    OUT PCALLINGCARD Card
    )
{

    BOOL rSuccess = TRUE;
    PTSTR p;

    MYASSERT(Is);
    MYASSERT(Card);



    p = InfGetStringField (Is, FIELD_CC_NAME);

    if (p) {
        Card->Name = PoolMemDuplicateString (g_TapiPool, p);
    }
    else {
        rSuccess = FALSE;
    }

    if (!InfGetIntField (Is, FIELD_CC_ID, &Card->Id)) {
        rSuccess = FALSE;
    }

    p = InfGetStringField (Is, FIELD_CC_LOCALE);

    if (p) {
        Card->Locale = PoolMemDuplicateString (g_TapiPool, p);
    }
    else {
        rSuccess = FALSE;
    }

    p = InfGetStringField (Is, FIELD_CC_LONGDISTANCE);

    if (p) {
        Card->LongDistance = PoolMemDuplicateString (g_TapiPool, p);
    }
    else {
        rSuccess = FALSE;
    }

    p = InfGetStringField (Is, FIELD_CC_INTERNATIONAL);

    if (p) {
        Card->International = PoolMemDuplicateString (g_TapiPool, p);
    }
    else {
        rSuccess = FALSE;
    }

    p = InfGetStringField (Is, FIELD_CC_PIN);

    if (p) {
        Card->Pin = PoolMemDuplicateString (g_TapiPool, p);
    }
    else {
        rSuccess = FALSE;
    }

    if (!InfGetIntField (Is, FIELD_CC_FLAGS, &Card->Flags)) {
        rSuccess = FALSE;
    }


    return rSuccess;
}


/*++

Routine Description:

  pReadLocationFromIniFile reads the data located at the line in the ini file
  referenced by the InfStruct passed in and parses that information into a
  LOCATION structure.

Arguments:

  Is       - Initialized InfStruct pointing to a location line in an ini
             file.

  Location - Pointer to a location struct that recieves the parsed data.

Return Value:

  TRUE if the line was successfully parsed, FALSE otherwise.

--*/


BOOL
pReadLocationFromIniFile (
    IN  PINFSTRUCT  Is,
    OUT PLOCATION   Location
    )
{
    BOOL rSuccess = TRUE;
    PTSTR p;


    MYASSERT(Is);
    MYASSERT(Location);

    ZeroMemory(Location,sizeof(LOCATION));

    p = InfGetStringField (Is, FIELD_NAME);

    if (p) {
        Location -> Name = PoolMemDuplicateString (g_TapiPool, p);
    }
    else {
        rSuccess = FALSE;
    }

    p = InfGetStringField (Is, FIELD_AREACODE);

    if (p) {
        Location -> AreaCode = PoolMemDuplicateString (g_TapiPool, p);
    }
    else {
        rSuccess = FALSE;
    }


    if (!InfGetIntField(Is,FIELD_COUNTRY,&(Location -> Country))) {
        rSuccess = FALSE;
    }

    p = InfGetStringField (Is, FIELD_DISABLECALLWAITING);

    if (p) {
        Location -> DisableCallWaiting = PoolMemDuplicateString (g_TapiPool, p);
    }
    else {
        rSuccess = FALSE;
    }

    p = InfGetStringField (Is, FIELD_LONGDISTANCEACCESS);

    if (p) {
        Location -> LongDistanceAccess = PoolMemDuplicateString (g_TapiPool, p);
    }
    else {
        rSuccess = FALSE;
    }

    p = InfGetStringField (Is, FIELD_OUTSIDEACCESS);

    if (p) {
        Location -> OutsideAccess = PoolMemDuplicateString (g_TapiPool, p);
    }
    else {
        rSuccess = FALSE;
    }

    if (!InfGetIntField(Is,FIELD_ID, &(Location -> Id))) {
        rSuccess = FALSE;
    }

    if (!InfGetIntField(Is,FIELD_PULSEDIAL, &(Location -> PulseDial))) {
        rSuccess = FALSE;
    }

    if (!InfGetIntField(Is,FIELD_CALLINGCARD, &(Location -> CallingCard))) {
        rSuccess = FALSE;
    }

    //
    // Set TAPI flags for this location.
    //
    if (Location->CallingCard) {
        //
        // Non-zero calling card indicates this user calls using a card.
        //
        Location->Flags |= LOCATION_USECALLINGCARD;
    }
    if (Location->DisableCallWaiting &&
        *Location->DisableCallWaiting &&
        *Location->DisableCallWaiting != TEXT(' ')) {
        //
        // Non-empty disable string means the user has call waiting.
        //
        Location->Flags |= LOCATION_HASCALLWAITING;

    }
    if (!Location->PulseDial) {

        Location->Flags |= LOCATION_USETONEDIALING;
    }


    return rSuccess;
}


/*++

Routine Description:

  pSetStringRegValue is a simplification wrapper for RegSetValueEx. It is
  used to set a string value in a currently opened key.

Arguments:

  Key  - a valid handle to a registry key.
  Name - The name of the value to set
  Data - The data to set in the value.

Return Value:

  TRUE if the value was set successfully, FALSE otherwise.

--*/


BOOL
pSetStringRegValue (
    IN HKEY     Key,
    IN PTSTR    Name,
    IN PTSTR    Data
    )
{
    BOOL rSuccess = TRUE;

    MYASSERT(Key);
    MYASSERT(Name);
    MYASSERT(Data);

    if (ERROR_SUCCESS != RegSetValueEx(Key,Name,0,REG_SZ,(PBYTE) Data,SizeOfString(Data))) {
        rSuccess = FALSE;
        LOG ((LOG_ERROR,"SetStringRegValue failed! Value name: %s Value Data: %s",Name,Data));
    }

    return rSuccess;
}

/*++

Routine Description:

  pSetDwordRegValue is a simplification wrapper for RegSetValueEx. It is
  used to set a DWORD value in a currently opened key.

Arguments:

  Key  - a valid handle to a registry key.
  Name - The name of the value to set
  Data - The data to set in the value.

Return Value:

  TRUE if the value was set successfully, FALSE otherwise.

--*/
BOOL
pSetDwordRegValue (
    IN HKEY     Key,
    IN PTSTR    Name,
    IN DWORD    Data
    )
{
    BOOL rSuccess = TRUE;

    MYASSERT(Key);
    MYASSERT(Name);

    if (ERROR_SUCCESS != RegSetValueEx(Key,Name,0,REG_DWORD,(PBYTE) &Data,sizeof(DWORD))) {
        rSuccess = FALSE;
        LOG ((LOG_ERROR,"SetDwordRegValue failed! Value name: %s Value Data: %u",Name,Data));
    }

    return rSuccess;
}



/*++

Routine Description:

  pWriteLocationToRegistry is responsible for saving a LOCATION structure
  away into the NT 5.0 Registry.

Arguments:

  DialingLocation - The name of the dialing location to create in the NT
                    registry.
  LocationData    - The LOCATION structure containing the data to write into
                    the NT 5 registry.

Return Value:

  TRUE if the the function successfully saved the Dialing Location Data into
  the NT 5 Registry, FALSE otherwise.

--*/
BOOL
pWriteLocationToRegistry (
    IN PLOCATION       LocationData
    )

{
    BOOL        rSuccess        = TRUE;
    PTSTR       regKeyString    = NULL;
    HKEY        regKey          = NULL;

    MYASSERT(LocationData);

    //
    // Create %CURRENTVERSION%\Telephony\Locations\Location<n> Key
    //
    regKeyString = JoinPaths(S_LOCATIONS_REGKEY, LocationData->EntryName);
    regKey = CreateRegKeyStr(regKeyString);

    if (regKey) {

        //
        // Create Name String
        //
        rSuccess &= pSetStringRegValue(regKey,S_NAME,LocationData -> Name);

        //
        // Create AreaCode String
        //
        rSuccess &= pSetStringRegValue(regKey,S_AREACODE,LocationData -> AreaCode);

        //
        // Create Country Value
        //
        rSuccess &= pSetDwordRegValue(regKey,S_COUNTRY,LocationData -> Country);


        //
        // Create DisableCallWating String
        //
        rSuccess &= pSetStringRegValue(regKey,S_DISABLECALLWAITING,LocationData -> DisableCallWaiting);

        //
        // Create LongDistanceAccess String
        //
        rSuccess &= pSetStringRegValue(regKey,S_LONGDISTANCEACCESS,LocationData -> LongDistanceAccess);

        //
        // Create OutSideAccessString
        //
        rSuccess &= pSetStringRegValue(regKey,S_OUTSIDEACCESS,LocationData -> OutsideAccess);

        //
        // Create Flags Value
        //
        rSuccess &= pSetDwordRegValue(regKey,S_FLAGS,LocationData -> Flags);

        //
        // Create ID Value
        //
        rSuccess &= pSetDwordRegValue(regKey,S_ID,LocationData -> Id);

        CloseRegKey(regKey);

    }
    else {
        rSuccess = FALSE;
        LOG ((LOG_ERROR,"Migrate Location: Error creating registry key %s.",regKeyString));
    }


    FreePathString(regKeyString);

    if (!rSuccess) {
        LOG ((
            LOG_ERROR,
            "Error creating Location registry entries for location %s.",
            LocationData->EntryName
            ));
    }

    return rSuccess;
}


/*++

Routine Description:

  pMigrateDialingLocations migrates all dialing locations from
  %windir%\telephon.ini and into the NT registry.

Arguments:

  None.

Return Value:

  TRUE if dialing locations were successfully migrated, FALSE otherwise.

--*/

BOOL
pMigrateDialingLocations (
    VOID
    )
{
    BOOL        rSuccess = TRUE;
    HKEY        locationsKey = NULL;
    PLOCATION   location;
    UINT        i;
    UINT        count = GrowListGetSize (&g_LocationsList);

    //
    // Migrate individual locations.
    //
    for (i = 0; i < count; i++) {

        location = (PLOCATION) GrowListGetItem (&g_LocationsList, i);

        if (!pWriteLocationToRegistry (location)) {

            rSuccess = FALSE;
            DEBUGMSG ((DBG_ERROR, "Error writing TAPI location %s (%s) to the registry.", location->Name, location->EntryName));

        }

    }

    if (count) {

        locationsKey = OpenRegKeyStr(S_LOCATIONS_REGKEY);

        if (locationsKey) {

            //
            //  Update %CURRENTVERSION%\Telephony\Locations\[CurrentID]
            //
            if (!pSetDwordRegValue (locationsKey, S_CURRENTID, g_CurrentLocation)) {
                rSuccess = FALSE;
            }

            //
            //  Update %CURRENTVERSION%\Telephony\Locations\[NextID]
            //
            if (!pSetDwordRegValue (locationsKey, S_NEXTID, count + 1)) {
                rSuccess = FALSE;
            }

            //
            //  Update %CURRENTVERSION%\Telephony\Locations\[NumEntries]
            //
            if (!pSetDwordRegValue (locationsKey, S_NUMENTRIES, count)) {
                rSuccess = FALSE;
            }

            CloseRegKey(locationsKey);
        }
        else {
            rSuccess = FALSE;
            LOG ((LOG_ERROR,"Tapi: Error opening %s key.",S_LOCATIONS_REGKEY));
        }

    }

    return rSuccess;
}

VOID
pGatherLocationsData (
    VOID
    )
{
    HINF        hTelephonIni        = INVALID_HANDLE_VALUE;
    INFSTRUCT   is                  = INITINFSTRUCT_POOLHANDLE;
    BOOL        rSuccess            = TRUE;
    PCTSTR       telephonIniPath    = NULL;
    PTSTR       curKey              = NULL;
    LOCATION    location;
    CALLINGCARD card;
    HKEY        locationsKey        = NULL;
    PCTSTR      tempPath            = NULL;


    g_LocationsRead = TRUE;

    //
    // Open %windir%\telephon.ini
    //

    telephonIniPath = JoinPaths(g_WinDir,S_TELEPHON_INI);
    tempPath = GetTemporaryLocationForFile (telephonIniPath);

    if (tempPath) {

        //
        // telephon ini is in a temporary location. Use that.
        //
        DEBUGMSG ((DBG_TAPI, "Using %s for %s.", tempPath, telephonIniPath));
        FreePathString (telephonIniPath);
        telephonIniPath = tempPath;
    }

    hTelephonIni = InfOpenInfFile(telephonIniPath);

    if (hTelephonIni) {


        //
        // For each location in [locations],
        //
        if (InfFindFirstLine(hTelephonIni,S_LOCATIONS,NULL,&is)) {

            do {

                curKey = InfGetStringField(&is,0);
                if (!curKey) {
                    continue;
                }

                if (StringIMatch(curKey,S_LOCATIONS)) {

                    DEBUGMSG((DBG_TAPI,"From %s: Locations = %s",telephonIniPath,InfGetLineText(&is)));

                    //
                    // Nothing to do here right now..
                    //

                }
                else if (StringIMatch (curKey, S_CURRENTLOCATION)) {

                    if (!InfGetIntField (&is, 1, &g_CurrentLocation)) {
                        rSuccess = FALSE;
                        LOG((LOG_ERROR,"TAPI: Error retrieving current location information."));
                    }
                }

                else if (IsPatternMatch(TEXT("Location*"),curKey)) {

                    //
                    // Add this location to the list of locations.
                    //

                    if (!pReadLocationFromIniFile (&is, &location)) {
                        rSuccess = FALSE;
                        LOG ((LOG_ERROR,"TAPI: Error migrating location %s.",curKey));

                    }

                    StringCopy (location.EntryName, curKey);

                    GrowListAppend (&g_LocationsList, (PBYTE) &location, sizeof (LOCATION));

                }
                else if (StringIMatch(curKey,TEXT("Inited"))) {

                    DEBUGMSG((DBG_TAPI,"Inited key unused during migration."));

                }
                ELSE_DEBUGMSG((DBG_WHOOPS,"TAPI Dialing Location Migration: Ingored or Unknown key: %s",curKey));

                InfResetInfStruct (&is);

            } while (InfFindNextLine(&is));


            //
            // Read in all the calling card information.
            //
            if (InfFindFirstLine(hTelephonIni,S_CARDS,NULL,&is)) {

                do {

                    curKey = InfGetStringField(&is,0);

                    if (!StringIMatch (curKey, S_CARDS) && IsPatternMatch (TEXT("Card*"),curKey)) {

                        ZeroMemory (&card, sizeof (CALLINGCARD));
                        StringCopy (card.EntryName, curKey);

                        if (!pReadCardFromIniFile (&is, &card)) {
                            rSuccess = FALSE;
                            LOG ((LOG_ERROR,"TAPI: Error migrating location %s.",curKey));

                        }

                        GrowListAppend (&g_CallingCardList, (PBYTE) &card, sizeof (CALLINGCARD));
                    }

                    InfResetInfStruct (&is);

                } while (InfFindNextLine(&is));
            }



        }

        DEBUGMSG((DBG_TAPI,"%u dialing locations found in telephon.ini.",GrowListGetSize (&g_LocationsList)));

        InfCloseInfFile(hTelephonIni);
    }
    ELSE_DEBUGMSG((DBG_TAPI,"No telephon.ini file found, or, telephon.ini coudl not be opened."));


    FreePathString(telephonIniPath);
    InfCleanUpInfStruct(&is);

}


BOOL
Tapi_MigrateUser (
    IN PCTSTR UserName,
    IN HKEY UserRoot
    )
{
    BOOL rSuccess = TRUE;
    UINT i;
    UINT count;
    HKEY hKey;
    PTSTR keyString;
    PLOCATION location;
    PCALLINGCARD card;

    if (!g_LocationsRead) {

        pGatherLocationsData ();

    }


    //
    // First, migrate user specific location information into the user
    // registry..
    //
    count = GrowListGetSize (&g_LocationsList);

    for (i = 0; i < count; i++) {

        location = (PLOCATION) GrowListGetItem (&g_LocationsList, i);

        keyString = JoinPaths (S_USERLOCATIONSKEY, location->EntryName);
        hKey = CreateRegKey (UserRoot, keyString);

        if (hKey) {

            rSuccess &= pSetDwordRegValue (hKey, S_CALLINGCARD, location->CallingCard);

            CloseRegKey (hKey);

        }

        FreePathString (keyString);
    }

    count = GrowListGetSize (&g_CallingCardList);

    for (i = 0; i < count; i++) {

        card = (PCALLINGCARD) GrowListGetItem (&g_CallingCardList, i);

        keyString = JoinPaths (S_USERCALLINGCARDSKEY, card->EntryName);
        hKey = CreateRegKey (UserRoot, keyString);

        if (hKey) {

            rSuccess &= pSetDwordRegValue (hKey, S_ID, card->Id);
            rSuccess &= pSetStringRegValue (hKey, S_NAME, card->Name);
            rSuccess &= pSetStringRegValue (hKey, S_LOCALRULE, card->Locale);
            rSuccess &= pSetStringRegValue (hKey, S_LDRULE, card->LongDistance);
            rSuccess &= pSetStringRegValue (hKey, S_INTERNATIONALRULE, card->International);
            rSuccess &= pSetStringRegValue (hKey, S_PIN, card->Pin);
            rSuccess &= pSetDwordRegValue (hKey, S_FLAGS, card->Flags);

            CloseRegKey (hKey);

        }
        ELSE_DEBUGMSG ((DBG_ERROR, "TAPI: Could not open key %s for user %s.", card->EntryName, UserName));

        FreePathString (keyString);

        hKey = CreateRegKey (UserRoot, S_USERCALLINGCARDSKEY);

        if (hKey) {

            rSuccess &= pSetDwordRegValue (hKey, S_NEXTID, count);
            rSuccess &= pSetDwordRegValue (hKey, S_NUMENTRIES, count);

            CloseRegKey (hKey);
        }
        ELSE_DEBUGMSG ((DBG_ERROR, "TAPI: Could not open key %s for user %s.", S_USERCALLINGCARDSKEY, UserName));

    }

    //
    // Next, we need to create calling card entries
    //

    if (!pMigrateDialingLocations()) {

        ERROR_NONCRITICAL;
        LOG ((LOG_ERROR, (PCSTR)MSG_UNABLE_TO_MIGRATE_TAPI_DIALING_LOCATIONS));
    }

    return rSuccess;
}




/*++

Routine Description:

  Tapi_MigrateSystem is responsible for migrating all system-wide TAPI
  settings from 95 to Windows NT5.

Arguments:

  None.

Return Value:

  TRUE if TAPI settings were successfully migrated, FALSE otherwise.

--*/
BOOL
Tapi_MigrateSystem (
    VOID
    )
{
    BOOL rSuccess = TRUE;

    if (!g_LocationsRead) {

        pGatherLocationsData ();

    }

    if (!pMigrateDialingLocations()) {

        ERROR_NONCRITICAL;
        LOG ((LOG_ERROR, (PCSTR)MSG_UNABLE_TO_MIGRATE_TAPI_DIALING_LOCATIONS));
    }

    return rSuccess;
}


BOOL
Tapi_Entry (
    IN HINSTANCE Instance,
    IN DWORD     Reason,
    IN PVOID     Reserved
    )

{
    BOOL rSuccess = TRUE;

    switch (Reason)
    {
    case DLL_PROCESS_ATTACH:

        //
        // Initialize Memory pool.
        //
        g_TapiPool = PoolMemInitNamedPool ("Tapi");
        if (!g_TapiPool) {
            DEBUGMSG((DBG_ERROR,"Ras Migration: Pool Memory failed to initialize..."));
            rSuccess = FALSE;
        }

        break;

    case DLL_PROCESS_DETACH:

        //
        // Free memory pool.
        //
        FreeGrowList (&g_CallingCardList);
        FreeGrowList (&g_LocationsList);
        if (g_TapiPool) {
            PoolMemDestroyPool(g_TapiPool);
        }
        break;
    }

    return rSuccess;
}

DWORD
DeleteSysTapiSettings (
    IN DWORD Request
    )
{

    //
    // Delete previous TAPI settings (OCM initiated.)
    //
    if (Request == REQUEST_QUERYTICKS) {
        return TICKS_DELETESYSTAPI;
    }

    pSetupRegistryDelnode (HKEY_LOCAL_MACHINE, TEXT("software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations"));

    return ERROR_SUCCESS;

}

DWORD
DeleteUserTapiSettings (
    IN DWORD Request,
    IN PMIGRATE_USER_ENUM EnumPtr
    )
{
    if (Request == REQUEST_QUERYTICKS) {
        return TICKS_DELETEUSERTAPI;
    }


    pSetupRegistryDelnode (g_hKeyRootNT, TEXT("software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Cards"));
    pSetupRegistryDelnode (g_hKeyRootNT, TEXT("software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations"));

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\pch\pch.h ===
#include "master.h"
#include "masternt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\wkstamig.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    wkstamig.c

Abstract:

    The functions in this module are called to perform migration of
    system-wide settings.

Author:

    Jim Schmidt (jimschm) 04-Feb-1997

Revision History:

    ovidiut     10-May-1999 Added DoIniActions
    jimschm     16-Dec-1998 Changed ATM font migration to use Adobe's
                            APIs.
    jimschm     25-Nov-1998 ATM.INI migration; Win9x hive migration
    jimschm     23-Sep-1998 Consolidated memdb saves into usermig.c
    jimschm     19-Feb-1998 Added "none" group support, fixed
                            share problems.
    calinn      12-Dec-1997 Added RestoreMMSettings_System

--*/

#include "pch.h"
#include "migmainp.h"
#include "brfcasep.h"

#include <lm.h>

//
// Constants, types, declarations
//

#define W95_ACCESS_READ      0x1
#define W95_ACCESS_WRITE     0x2
#define W95_ACCESS_CREATE    0x4
#define W95_ACCESS_EXEC      0x8
#define W95_ACCESS_DELETE    0x10
#define W95_ACCESS_ATRIB     0x20
#define W95_ACCESS_PERM      0x40
#define W95_ACCESS_FINDFIRST 0x80
#define W95_ACCESS_FULL      0xff
#define W95_ACCESS_GROUP     0x8000

#define W95_GENERIC_READ    (W95_ACCESS_READ|W95_ACCESS_FINDFIRST)
#define W95_GENERIC_WRITE   (W95_ACCESS_WRITE|W95_ACCESS_CREATE|W95_ACCESS_DELETE|W95_ACCESS_ATRIB)
#define W95_GENERIC_FULL    (W95_GENERIC_READ|W95_GENERIC_WRITE|W95_ACCESS_PERM)
#define W95_GENERIC_NONE    0

#define S_DEFAULT_USER_NAME     TEXT("DefaultUserName")
#define S_DEFAULT_DOMAIN_NAME   TEXT("DefaultDomainName")


// from private\net\svcdlls\srvsvc\server
#define SHARES_REGISTRY_PATH L"LanmanServer\\Shares"
#define SHARES_SECURITY_REGISTRY_PATH L"LanmanServer\\Shares\\Security"
#define CSCFLAGS_VARIABLE_NAME L"CSCFlags"
#define MAXUSES_VARIABLE_NAME L"MaxUses"
#define PATH_VARIABLE_NAME L"Path"
#define PERMISSIONS_VARIABLE_NAME L"Permissions"
#define REMARK_VARIABLE_NAME L"Remark"
#define TYPE_VARIABLE_NAME L"Type"

// Win9x-specific flags for NetShareEnum
#define SHI50F_RDONLY       0x0001
#define SHI50F_FULL         0x0002
#define SHI50F_DEPENDSON    (SHI50F_RDONLY|SHI50F_FULL)
#define SHI50F_ACCESSMASK   (SHI50F_RDONLY|SHI50F_FULL)

#ifndef UNICODE
#error UNICODE required
#endif

#define DBG_NETSHARES "NetShares"
#define DBG_INIFILES "IniFiles"

#define S_CLEANER_GUID          TEXT("{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}")
#define S_CLEANER_ALL_FILES     TEXT("*")

typedef struct {
    // Enumeration return data
    TCHAR PfmFile[MAX_TCHAR_PATH];
    TCHAR PfbFile[MAX_TCHAR_PATH];
    TCHAR MmmFile[MAX_TCHAR_PATH];

    TCHAR InfName[MAX_TCHAR_PATH];

    // Internal state
    PTSTR KeyNames;
    POOLHANDLE Pool;
} ATM_FONT_ENUM, *PATM_FONT_ENUM;

typedef INT (WINAPI ATMADDFONTEXW) (
                IN OUT  PWSTR MenuName,
                IN OUT  PWORD StyleAndType,
                IN      PCWSTR MetricsFile,
                IN      PCWSTR FontFile,
                IN      PCWSTR MMMFile
                );

typedef ATMADDFONTEXW * PATMADDFONTEXW;

PATMADDFONTEXW AtmAddFontEx;
typedef VOID (SHUPDATERECYCLEBINICON_PROTOTYPE)(VOID);
typedef SHUPDATERECYCLEBINICON_PROTOTYPE * SHUPDATERECYCLEBINICON_PROC;

typedef struct {
    // enumeration output
    PCTSTR Source;
    PCTSTR Dest;

    // private members
    POOLHANDLE Pool;
    INFSTRUCT is;
} HIVEFILE_ENUM, *PHIVEFILE_ENUM;

#define MAX_KEY_NAME_LIST       32768


typedef struct {
    // enumeration output
    PCTSTR      BrfcaseDb;
    // private
    MEMDB_ENUM  mde;
} BRIEFCASE_ENUM, *PBRIEFCASE_ENUM;


//
// Implementation
//

DWORD
Simplify9xAccessFlags (
    IN      DWORD Win9xFlags
    )

/*++

Routine Description:

    Translates the Win9x LanMan flags into NT LanMan flags (for use with Net* APIs).

    Full permission requires:

        W95_ACCESS_READ
        W95_ACCESS_WRITE
        W95_ACCESS_CREATE
        W95_ACCESS_DELETE
        W95_ACCESS_ATRIB
        W95_ACCESS_FINDFIRST

    Read-only permission requires:

        W95_ACCESS_READ
        W95_ACCESS_FINDFIRST

    Change-only permission requires:

        W95_ACCESS_WRITE
        W95_ACCESS_CREATE
        W95_ACCESS_DELETE
        W95_ACCESS_ATRIB

    Any other combination results in

    The returned flags are currently converted to security flags based on the
    following mapping:

    0 - Deny All Rights
    ACCESS_READ - Read-Only Rights
    ACCESS_WRITE - Change-Only Rights
    ACCESS_READ|ACCESS_WRITE - Full Rights

    See AddAclMember for details.

Arguments:

    Flags - The set of Win9x flags as returned by an API on Win9x

Return value:

    The NT equivalent of the flags.

--*/

{
    DWORD NtFlags = 0;

    if (BITSARESET (Win9xFlags, W95_GENERIC_WRITE)) {

        NtFlags |= ACCESS_WRITE;

    }

    if (BITSARESET (Win9xFlags, W95_GENERIC_READ)) {

        NtFlags |= ACCESS_READ;

    }

    DEBUGMSG_IF ((
        !NtFlags,
        DBG_VERBOSE,
        "Unsupported permission %u was translated to disable permission",
        Win9xFlags
        ));

    return NtFlags;
}


NET_API_STATUS
MigNetShareAdd (
    IN      PTSTR ServerName,
    IN      DWORD Level,
    IN      PBYTE Buf,
    OUT     PDWORD ErrParam
    )

/*++

Routine Description:

  Our private version of NetShareAdd.  The real NetShareAdd does not work
  in GUI mode.  We emulate the real thing carefully because maybe some day
  it WILL work and we should use it.

  For now, we write directly to the registry.  (This function is a reverse-
  engineer of the NetShareAdd function.)

Arguments:

  ServerName    - Always NULL

  Level         - Always 2

  Buf           - A pointer to a caller-allocated SHARE_INFO_2 buffer cast
                  as an PBYTE

  ErrParam      - Not supported

Return value:

  The Win32 result

--*/

{
    SHARE_INFO_2 *psi;
    DWORD rc;
    HKEY hKey = NULL, hKeyShares = NULL;
    DWORD DontCare;
    GROWBUFFER GrowBuf = GROWBUF_INIT;

    //
    // This function is for compatibility with NetShareAdd, because one day
    // the real NetShareAdd might be improved to work in GUI mode setup.
    //

    if (Level != 2) {
        return ERROR_INVALID_LEVEL;
    }

    psi = (SHARE_INFO_2 *) Buf;


    rc = TrackedRegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                L"SYSTEM\\CurrentControlSet\\Services",
                0,
                KEY_WRITE,
                &hKey
                );

    if (rc != ERROR_SUCCESS) {
        goto cleanup;
    }

    rc = TrackedRegCreateKeyEx (
              hKey,
              SHARES_REGISTRY_PATH,
              0,
              S_EMPTY,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hKeyShares,
              &DontCare
              );

    if (rc != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Prepare multisz
    //

    if (!MultiSzAppendVal (&GrowBuf, CSCFLAGS_VARIABLE_NAME, 0)) {
        rc = GetLastError();
        goto cleanup;
    }

    if (!MultiSzAppendVal (&GrowBuf, MAXUSES_VARIABLE_NAME, psi->shi2_max_uses)) {
        rc = GetLastError();
        goto cleanup;
    }

    if (!psi->shi2_path || !(*psi->shi2_path)) {
        rc = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (!MultiSzAppendString (&GrowBuf, PATH_VARIABLE_NAME, psi->shi2_path)) {
        rc = GetLastError();
        goto cleanup;
    }

    if (!MultiSzAppendVal (&GrowBuf, PERMISSIONS_VARIABLE_NAME, psi->shi2_permissions)) {
        rc = GetLastError();
        goto cleanup;
    }

    if (psi->shi2_remark && *psi->shi2_remark) {
        // Safety
        if (TcharCount (psi->shi2_remark) >= MAXCOMMENTSZ) {
            psi->shi2_remark[MAXCOMMENTSZ-1] = 0;
        }

        if (!MultiSzAppendString (&GrowBuf, REMARK_VARIABLE_NAME, psi->shi2_remark)) {
            rc = GetLastError();
            goto cleanup;
        }
    }

    if (!MultiSzAppendVal (&GrowBuf, TYPE_VARIABLE_NAME, psi->shi2_type)) {
        rc = GetLastError();

        goto cleanup;
    }

    // terminate multi-sz string chain
    if (!MultiSzAppend (&GrowBuf, S_EMPTY)) {
        rc = GetLastError();
        goto cleanup;
    }

    //
    // Save to registry
    //

    rc = RegSetValueEx (hKeyShares, psi->shi2_netname, 0, REG_MULTI_SZ,
                        GrowBuf.Buf, GrowBuf.End);

cleanup:
    if (hKeyShares) {
        CloseRegKey (hKeyShares);
    }
    if (hKey) {
        CloseRegKey (hKey);
    }
    FreeGrowBuffer (&GrowBuf);
    return rc;
}


NET_API_STATUS
MigNetShareSetInfo (
    IN      PTSTR Server,               // ignored
    IN      PTSTR NetName,
    IN      DWORD Level,
    IN      PBYTE Buf,
    OUT     PDWORD ErrParam             // ignored
    )

/*++

Routine Description:

  MigNetShareSetInfo implements a NetShareSetInfo emulation routine, because
  the real routine does not work properly in GUI mode setup. See SDK
  documentation for details.

Arguments:

  Server   - Unused
  NetName  - Specifies the share name to create.
  Level    - Specifies the API level (must be 1501)
  Buf      - Specifies a filled SHARE_INFO_1501 structure.
  ErrParam - Unused

Return Value:

  The Win32 status code.

--*/

{
    SHARE_INFO_1501 *psi;
    DWORD rc;
    HKEY hKey;
    DWORD DontCare;
    TCHAR KeyName[MAX_TCHAR_PATH];
    DWORD Len;

    if (Level != 1501) {
        return ERROR_INVALID_LEVEL;
    }

    psi = (SHARE_INFO_1501 *) Buf;

    //
    // Verify share exists
    //

    StringCopyW (
        KeyName,
        L"SYSTEM\\CurrentControlSet\\Services\\" SHARES_REGISTRY_PATH
        );

    rc = TrackedRegOpenKeyEx (
             HKEY_LOCAL_MACHINE,
             KeyName,
             0,
             KEY_READ,
             &hKey
             );

    if (rc != ERROR_SUCCESS) {
        return rc;
    }

    rc = RegQueryValueEx (hKey, NetName, NULL, NULL, NULL, NULL);
    CloseRegKey (hKey);

    if (rc != ERROR_SUCCESS) {
        if (rc == ERROR_FILE_NOT_FOUND) {
            rc = ERROR_INVALID_SHARENAME;
        }

        return rc;
    }

    //
    // Save security descriptor as binary type in registry
    //

    StringCopy (
        KeyName,
        L"SYSTEM\\CurrentControlSet\\Services\\" SHARES_SECURITY_REGISTRY_PATH
        );

    rc = TrackedRegCreateKeyEx (
              HKEY_LOCAL_MACHINE,
              KeyName,
              0,
              S_EMPTY,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hKey,
              &DontCare
              );

    if (rc != ERROR_SUCCESS) {
        return rc;
    }

    Len = GetSecurityDescriptorLength (psi->shi1501_security_descriptor);

    rc = RegSetValueEx (
              hKey,
              NetName,
              0,
              REG_BINARY,
              (PBYTE) psi->shi1501_security_descriptor,
              Len
              );

    CloseRegKey (hKey);
    return rc;
}


BOOL
pCreateNetShare (
    IN      PCTSTR NetName,
    IN      PCTSTR Path,
    IN      PCTSTR Remark,
    IN      DWORD Type,
    IN      DWORD Permissions
    )

/*++

Routine Description:

  pCreateNetShare is a wrapper to the Net APIs.

Arguments:

  NetName     - Specifies the share name
  Path        - Specifies the local path to be shared
  Remark      - Specifies the remark to register with the share
  Type        - Specifies the share type
  Permissions - Specifies the Win9x share permissions, used only for logging
                errors.

Return Value:

  TRUE if the share was created, FALSE otherwise.

--*/

{
    SHARE_INFO_2 si2;
    DWORD rc;
    PWSTR UnicodePath;
    BOOL b = FALSE;

    UnicodePath = (PWSTR) CreateUnicode (Path);
    MYASSERT (UnicodePath);

    __try {
        //
        // Make NetShareAdd call
        //

        ZeroMemory (&si2, sizeof (si2));
        si2.shi2_netname      = (PTSTR) NetName;
        si2.shi2_type         = (WORD) Type;
        si2.shi2_remark       = (PTSTR) Remark;
        si2.shi2_permissions  = 0;
        si2.shi2_max_uses     = 0xffffffff;
        si2.shi2_path         = UnicodePath;
        si2.shi2_passwd       = NULL;

        rc = MigNetShareAdd (NULL, 2, (PBYTE) (&si2), NULL);

        if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            DEBUGMSG ((
                DBG_ERROR,
                "CreateShares: NetShareAdd failed for %s ('%s'), permissions=%x",
                NetName,
                Path,
                Permissions
                ));

            if (Permissions == W95_GENERIC_NONE) {
                LOG ((LOG_ERROR, (PCSTR)MSG_UNABLE_TO_CREATE_ACL_SHARE, NetName, Path));
            } else if (Permissions != W95_GENERIC_READ) {
                LOG ((LOG_ERROR, (PCSTR)MSG_UNABLE_TO_CREATE_RO_SHARE, NetName, Path));
            } else {
                LOG ((LOG_ERROR, (PCSTR)MSG_UNABLE_TO_CREATE_SHARE, NetName, Path));
            }

            __leave;
        }

        b = TRUE;
    }

    __finally {
        DestroyUnicode (UnicodePath);
    }

    return b;
}


VOID
LogUsersWhoFailed (
    PBYTE AclMemberList,
    DWORD Members,
    PCTSTR Share,
    PCTSTR Path
    )

/*++

Routine Description:

  LogUsersWhoFailed implements logic to log the users who could not be added
  to a share. If there are a small number of users, a popup is given with
  each name.  Otherwise, the share users are logged, and a popup tells the
  installer to look in the log for the list.

Arguments:

  AclMemberList - Specifies the ACL data structure containing all the user
                  names that need to be logged.

  Members - Specifies the number of members in AclMemberList.

  Share - Specifies the share name that could not be added.

  Path - Specifies the share path that could not be added.

Return Value:

  None.

--*/

{
    PACLMEMBER AclMember;
    DWORD d;
    DWORD GoodCount;
    DWORD BadCount;
    HWND Parent;

    GoodCount = 0;
    BadCount = 0;
    AclMember = (PACLMEMBER) AclMemberList;
    for (d = 0 ; d < Members ; d++) {
        if (AclMember->Failed) {
            BadCount++;
        } else {
            GoodCount++;
        }

        GetNextAclMember (&AclMember);
    }

    if (!BadCount) {
        return;
    }

    if (BadCount < 5) {
        Parent = g_ParentWnd;
    } else {
        if (!GoodCount) {
            LOG ((LOG_ERROR, (PCSTR)MSG_ALL_SIDS_BAD, Share, Path));
        } else {
            LOG ((LOG_ERROR, (PCSTR)MSG_MANY_SIDS_BAD,
                 BadCount, BadCount + GoodCount, Share, Path));
        }

        Parent = NULL;
    }

    AclMember = (PACLMEMBER) AclMemberList;
    for (d = 0 ; d < Members ; d++) {
        if (AclMember->Failed) {
            LOG ((LOG_ERROR, (PCSTR)MSG_NO_USER_SID, AclMember->UserOrGroup, Share, Path));
        }

        GetNextAclMember (&AclMember);
    }
}


BOOL
SetShareAcl (
    IN      PCTSTR Share,
    IN      PCTSTR Path,
    IN      PBYTE AclMemberList,
    IN      DWORD MemberCount
    )

/*++

Routine Description:

  SetShareAcl applies the access control list to a share that was previously
  created.

Arguments:

  Share         - Specifies the share name
  Path          - Specifies the share path
  AclMemberList - Specifies the ACL data structure giving the user(s) with
                  rights to the share
  MemberCount   - Specifies the number of members in AclMemberList.

Return Value:

  TRUE if the ACL was successfully applied to the share, FALSE otherwise.

--*/

{
    BYTE Buf[8192];
    PSECURITY_DESCRIPTOR pSD;
    SECURITY_DESCRIPTOR desc;
    PSID Sid;
    PACL Acl;
    SHARE_INFO_1501 shi1501;
    DWORD rc;
    DWORD Size;
    PWSTR UnicodeShare;

    pSD = (PSECURITY_DESCRIPTOR) Buf;

    //
    // Get Administrator's SID--they are the owner of the share
    //

    Sid = GetSidForUser (g_AdministratorsGroupStr);
    if (!Sid) {
        return FALSE;
    }

    //
    // Start building security descriptor
    //

    InitializeSecurityDescriptor (&desc, SECURITY_DESCRIPTOR_REVISION);
    if (!SetSecurityDescriptorOwner (&desc, Sid, FALSE)) {
        LOG ((LOG_ERROR, "Could not set %s as owner", g_AdministratorsGroupStr));
        return FALSE;
    }

    //
    // Set the defaulted group to Domain\Domain Users (if it exists),
    // otherwise get SID of none
    //

    Sid = GetSidForUser (g_DomainUsersGroupStr);
    if (!Sid) {
        Sid = GetSidForUser (g_NoneGroupStr);
    }

    if (Sid) {
        SetSecurityDescriptorGroup (&desc, Sid, FALSE);
    }

    //
    // Create access allowed ACL from member list
    //

    Acl = CreateAclFromMemberList (AclMemberList, MemberCount);
    if (!Acl) {
        DEBUGMSG ((DBG_WARNING, "SetShareAcl failed because CreateAclFromMemberList failed"));
        return FALSE;
    }

    __try {
        UnicodeShare = (PWSTR) CreateUnicode (Share);
        MYASSERT (UnicodeShare);

        if (!SetSecurityDescriptorDacl (&desc, TRUE, Acl, FALSE)) {
            DEBUGMSG ((DBG_WARNING, "SetShareAcl failed because SetSecurityDescriptorDacl failed"));
            return FALSE;
        }

        //
        // Set security descriptor on share
        //

        Size = sizeof (Buf);
        if (!MakeSelfRelativeSD (&desc, pSD, &Size)) {
            LOG ((LOG_ERROR, "MakeSelfRelativeSD failed"));
            return FALSE;
        }

        ZeroMemory (&shi1501, sizeof (shi1501));
        shi1501.shi1501_security_descriptor = pSD;

        rc = MigNetShareSetInfo (NULL, UnicodeShare, 1501, (PBYTE) &shi1501, NULL);
        if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            LOG ((LOG_ERROR, "NetShareSetInfo failed"));
            return FALSE;
        }
    }

    __finally {

        if (Acl) {
            FreeMemberListAcl (Acl);
        }

        DestroyUnicode (UnicodeShare);
    }

    return TRUE;
}


VOID
DoCreateShares (
    VOID
    )

/*++

Routine Description:

  DoCreateShares enumerates all the shares registered in memdb by WINNT32.
  For each enumeration, a share is created, and permissions or an ACL is
  applied.

Arguments:

  None.

Return Value:

  None.

--*/

{
    MEMDB_ENUM e, e2;
    TCHAR Path[MEMDB_MAX];
    TCHAR Remark[MEMDB_MAX];
// we overlap the Remark stack buffer instead of making another
#define flagKey Remark
    TCHAR Password[MEMDB_MAX];
    DWORD Flags;
    DWORD Members;
    DWORD shareType;
    GROWBUFFER NameList = GROWBUF_INIT;
    PCTSTR pathNT;

    //
    // Obtain shares from memdb
    //

    if (MemDbEnumItems (&e, MEMDB_CATEGORY_NETSHARES)) {
        do {
            //
            // Get share attributes
            //

            Flags = e.dwValue;

            if (!MemDbGetEndpointValueEx (
                    MEMDB_CATEGORY_NETSHARES,
                    e.szName,
                    MEMDB_FIELD_PATH,
                    Path
                    )) {

                DEBUGMSG ((DBG_WARNING, "DoCreateShares: No path found for %s", e.szName));
                continue;
            }

            // IF YOU CHANGE CODE HERE: Note that flagKey is the same variable as Remark
            MemDbBuildKey (flagKey, MEMDB_CATEGORY_NETSHARES, e.szName, MEMDB_FIELD_TYPE, NULL);

            if (!MemDbGetValue (flagKey, &shareType)) {
                DEBUGMSG ((DBG_WARNING, "DoCreateShares: No type found for %s", e.szName));
                continue;
            }

            // IF YOU CHANGE CODE HERE: Note that flagKey is the same variable as Remark
            if (!MemDbGetEndpointValueEx (
                    MEMDB_CATEGORY_NETSHARES,
                    e.szName,
                    MEMDB_FIELD_REMARK,
                    Remark
                    )) {

                Remark[0] = 0;
            }

            //
            // first check if the path changed
            //
            pathNT = GetPathStringOnNt (Path);

            //
            // Create the share and set appropriate security
            //

            if (Flags & SHI50F_ACLS) {
                //
                // Share has an ACL
                //

                if (pCreateNetShare (e.szName, pathNT, Remark, shareType, W95_GENERIC_NONE)) {

                    //
                    // For each user indexed, put them in an ACL member list
                    //

                    Members = 0;
                    if (MemDbGetValueEx (
                            &e2,
                            MEMDB_CATEGORY_NETSHARES,
                            e.szName,
                            MEMDB_FIELD_ACCESS_LIST
                            )) {

                        do {
                            //
                            // On Win9x, per-user flags have a 8 flags that control access.  We translate
                            // them to one of four flavors on NT:
                            //
                            // 1. Deny All Access: (Flags == 0)
                            // 2. Read-Only Access: (Flags & W95_GENERIC_READ) && !(Flags & W95_GENERIC_WRITE)
                            // 3. Change-Only Access: !(Flags & W95_GENERIC_READ) && (Flags & W95_GENERIC_WRITE)
                            // 4. Full Access: (Flags & W95_GENERIC_FULL) == W95_GENERIC_FULL
                            //

                            DEBUGMSG ((DBG_NETSHARES, "Share %s user %s flags %u", e.szName, e2.szName, e2.dwValue));

                            if (AddAclMember (
                                    &NameList,
                                    e2.szName,
                                    Simplify9xAccessFlags (e2.dwValue)
                                    )) {

                                Members++;

                            }

                        } while (MemDbEnumNextValue (&e2));
                    }

                    //
                    // Convert member list into a real ACL and apply it to the share
                    //

                    if (NameList.Buf) {
                        SetShareAcl (e.szName, pathNT, NameList.Buf, Members);
                        LogUsersWhoFailed (NameList.Buf, Members, e.szName, pathNT);
                        FreeGrowBuffer (&NameList);
                    }
                }
            }
            else {
                //
                // Determine if a password is set
                //

                Password[0] = 0;

                if (Flags & SHI50F_RDONLY) {
                    MemDbGetEndpointValueEx (
                        MEMDB_CATEGORY_NETSHARES,
                        e.szName,
                        MEMDB_FIELD_RO_PASSWORD,
                        Password
                        );
                }

                if (!Password[0] && (Flags & SHI50F_FULL)) {
                    MemDbGetEndpointValueEx (
                        MEMDB_CATEGORY_NETSHARES,
                        e.szName,
                        MEMDB_FIELD_RW_PASSWORD,
                        Password
                        );
                }

                //
                // Enable all permissions for full access
                // Enable read-only permissions for read-only shares
                // Disable all permissions for no access
                //

                if (!Password[0]) {

                    if (Flags & SHI50F_FULL) {

                        Flags = W95_GENERIC_FULL;

                    } else if (Flags & SHI50F_RDONLY) {

                        Flags = W95_GENERIC_READ;

                    } else if (Flags) {

                        DEBUGMSG ((DBG_WHOOPS, "Flags (0x%X) is not 0, SHI50F_FULL or SHI50F_RDONLY", Flags));
                        Flags = W95_GENERIC_NONE;

                    }

                } else {

                    DEBUGMSG ((DBG_VERBOSE, "Password on share %s is not supported", e.szName));
                    Flags = W95_GENERIC_NONE;

                }

                //
                // We do not support share-level security with passwords.  We
                // always create the share, but if a password exists, we
                // deny everyone access.
                //

                pCreateNetShare (e.szName, pathNT, Remark, shareType, Flags);

                Members = 0;
                if (AddAclMember (
                        &NameList,
                        g_EveryoneStr,
                        Simplify9xAccessFlags (Flags)
                        )) {

                    Members++;

                }

                //
                // Convert member list into a real ACL and apply it to the share
                //

                if (NameList.Buf) {
                    SetShareAcl (e.szName, pathNT, NameList.Buf, Members);
                    FreeGrowBuffer (&NameList);
                }
            }

            FreePathString (pathNT);

        } while (MemDbEnumNextValue (&e));
    }
}


BOOL
pUpdateRecycleBin (
    VOID
    )

/*++

Routine Description:

  Calls SHUpdateRecycleBinIcon to reset the status of the recycle bin.  This
  operation takes a few seconds as all hard drives are scanned, the recycle
  bin database is read, and each entry in the database is verified.

Arguments:

  None

Return value:

  TRUE - the operation was successful
  FALSE - the operation failed (either LoadLibrary or GetProcAddress)

--*/

{
    SHUPDATERECYCLEBINICON_PROC Fn;
    HINSTANCE LibInst;
    BOOL b = TRUE;

    LibInst = LoadLibrary (S_SHELL32_DLL);
    if (!LibInst) {
        return FALSE;
    }

    Fn = (SHUPDATERECYCLEBINICON_PROC) GetProcAddress (
                                            LibInst,
                                            S_ANSI_SHUPDATERECYCLEBINICON
                                            );

    if (Fn) {

        //
        // Scan all hard disks and validate the recycle bin status
        //

        Fn();

    } else {
        b = FALSE;
    }

    FreeLibrary (LibInst);

    return TRUE;
}


VOID
pFixLogonDomainIfUserIsAdministrator (
    VOID
    )

/*++

Routine Description:

  pFixLogonDomainIfUserIsAdministrator handles a special error case where
  the logon domain is not equivalent to the computer name, but the user
  is named Administrator.  In this case, we change the default logon domain
  to be the computer name.

Arguments:

  None

Return value:

  none

--*/

{
    PCTSTR AdministratorAcct;
    HKEY Key;
    PCTSTR Data;

    AdministratorAcct = GetStringResource (MSG_ADMINISTRATOR_ACCOUNT);

    if (AdministratorAcct) {
        Key = OpenRegKeyStr (S_WINLOGON_KEY);
        if (Key) {
            Data = GetRegValueString (Key, S_DEFAULT_USER_NAME);
            if (Data) {
                if (!StringCompare (Data, AdministratorAcct)) {
                    //
                    // Account name exactly matches our Administrator
                    // string, so there is a good chance we wrote
                    // this string.  Therefore, we need to write the
                    // computer name as the default domain.
                    //

                    if (g_ComputerName[0]) {
                        RegSetValueEx (
                            Key,
                            S_DEFAULT_DOMAIN_NAME,
                            0,
                            REG_SZ,
                            (PBYTE) g_ComputerName,
                            SizeOfString (g_ComputerName)
                            );
                    }
                }

                MemFree (g_hHeap, 0, Data);
            }

            CloseRegKey (Key);
        }

        FreeStringResource (AdministratorAcct);
    }
}


DWORD
ProcessLocalMachine_First (
    DWORD Request
    )

{
    if (Request == REQUEST_QUERYTICKS) {
        return TICKS_INI_ACTIONS_FIRST +
               TICKS_INI_MOVE +
               TICKS_INI_CONVERSION +
               TICKS_INI_MIGRATION;
    }

    //
    // We process the local machine in the following order:
    //
    //  Initialization:
    //    (1) Reload memdb
    //
    //  Ini files conversion and mapping
    //

    DEBUGMSG ((DBG_INIFILES, "INI Files Actions.First - START"));
    DEBUGLOGTIME (("Starting function: DoIniActions"));
    if (!DoIniActions (INIACT_WKS_FIRST)) {
        LOG ((LOG_ERROR, "Process Local Machine: Could not perform one or more INI Files Actions.First"));
    }
    DEBUGLOGTIME (("Function complete: DoIniActions"));
    TickProgressBarDelta (TICKS_INI_ACTIONS_FIRST);
    DEBUGMSG ((DBG_INIFILES, "INI Files Actions.First - STOP"));

    DEBUGMSG ((DBG_INIFILES, "INI file moving - START"));
    DEBUGLOGTIME (("Starting function: MoveIniSettings"));
    if (!MoveIniSettings ()) {
        LOG ((LOG_ERROR, "Process Local Machine: Could not move one or more .INI files settings."));
        return GetLastError();
    }
    DEBUGLOGTIME (("Function complete: MoveIniSettings"));
    TickProgressBarDelta (TICKS_INI_MOVE);
    DEBUGMSG ((DBG_INIFILES, "INI file moving - STOP"));

    DEBUGMSG ((DBG_INIFILES, "INI file conversion - START"));
    DEBUGLOGTIME (("Starting function: ConvertIniFiles"));
    if (!ConvertIniFiles ()) {
        LOG ((LOG_ERROR, "Process Local Machine: Could not convert one or more .INI files."));
        return GetLastError();
    }
    DEBUGLOGTIME (("Function complete: ConvertIniFiles"));
    TickProgressBarDelta (TICKS_INI_CONVERSION);
    DEBUGMSG ((DBG_INIFILES, "INI file conversion - STOP"));

    DEBUGMSG ((DBG_INIFILES, "INI file migration - START"));
    DEBUGLOGTIME (("Starting function: ProcessIniFileMapping"));
    if (!ProcessIniFileMapping (FALSE)) {
        LOG ((LOG_ERROR, "Process Local Machine: Could not migrate one or more .INI files."));
        return GetLastError();
    }
    DEBUGLOGTIME (("Function complete: ProcessIniFileMapping"));
    TickProgressBarDelta (TICKS_INI_MIGRATION);
    DEBUGMSG ((DBG_INIFILES, "INI file migration - STOP"));

    return ERROR_SUCCESS;
}


VOID
pTurnOffNetAccountWizard (
    VOID
    )

/*++

Routine Description:

  pTurnOffNetAccountWizard removes the RunNetAccessWizard key to keep the
  network account wizard from appearing before the first logon.

Arguments:

  None.

Return Value:

  None.

--*/

{
    HKEY Key;

    Key = OpenRegKeyStr (TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"));
    if (Key) {
        RegDeleteValue (Key, TEXT("RunNetAccessWizard"));
        CloseRegKey (Key);
    } else {
        DEBUGMSG ((DBG_WARNING, "Could not open key for RunNetAccessWizard value"));
    }
}


typedef struct _OLE_CONTROL_DATA {
    LPWSTR FullPath;
    LPCWSTR RegType;
} OLE_CONTROL_DATA, *POLE_CONTROL_DATA;



DWORD
RegisterIndividualOleControl(
    POLE_CONTROL_DATA OleControlData
    )
{
    PROCESS_INFORMATION processInfo;
    STARTUPINFO startupInfo;
    WCHAR cmdLine [MAX_PATH] = L"";
    WCHAR cmdOptions [MAX_PATH] = L"";
    DWORD WaitResult;
    BOOL b = TRUE;

    ZeroMemory (&startupInfo, sizeof (STARTUPINFO));
    startupInfo.cb = sizeof (STARTUPINFO);

    if (OleControlData->RegType && (*OleControlData->RegType == L'B')) {
        // install and register
        wcscpy (cmdOptions, L"/s /i");
    } else if (OleControlData->RegType && (*OleControlData->RegType == L'R')) {
        // register
        wcscpy (cmdOptions, L"/s");
    } else if (OleControlData->RegType && (*OleControlData->RegType == L'I')) {
        // install
        wcscpy (cmdOptions, L"/s /i /n");
    } else if ((OleControlData->RegType == NULL) || (*OleControlData->RegType == L'\0')) {
        // register
        wcscpy (cmdOptions, L"/s");
    }

    wsprintf (cmdLine, L"%s\\regsvr32.exe %s %s", g_System32Dir, cmdOptions, OleControlData->FullPath);

    if (CreateProcess (NULL, cmdLine, NULL, NULL, TRUE, 0, NULL, NULL, &startupInfo, &processInfo)) {

        WaitResult = WaitForSingleObject (processInfo.hProcess, 1000 * 60 * 10 );

        if (WaitResult == WAIT_TIMEOUT) {
            DEBUGMSG ((DBG_ERROR, "Timeout installing and/or registering OLE control %s", OleControlData->FullPath));
            b = FALSE;
        }

        CloseHandle (processInfo.hProcess);
        CloseHandle (processInfo.hThread);
    }
    else {
        DEBUGMSG ((DBG_ERROR, "Create process failed: %s", cmdLine));
        b = FALSE;
    }
    return b;
}


typedef struct _KNOWN_DIRS {
    PCWSTR DirId;
    PCWSTR Translation;
}
KNOWN_DIRSW, *PKNOWN_DIRSW;

KNOWN_DIRSW g_KnownDirsW [] = {
    {L"10"      , g_WinDir},
    {L"11"      , g_System32Dir},
    {L"24"      , g_WinDrive},
    {L"16422"   , g_ProgramFiles},
    {L"16427"   , g_ProgramFilesCommon},
    {NULL,  NULL}
    };

BOOL
pConvertDirName (
    PCWSTR OldDirName,
    PWSTR  NewDirName
    )
{
    PCWSTR OldDirCurr = OldDirName;
    PCWSTR OldDirNext;
    PKNOWN_DIRSW p;

    NewDirName[0] = 0;
    OldDirNext = wcschr (OldDirCurr, L'\\');
    if (OldDirNext == NULL) {
        OldDirNext = wcschr (OldDirCurr, 0);
    }
    StringCopyABW (NewDirName, OldDirCurr, OldDirNext);
    p = g_KnownDirsW;
    while (p->DirId!= NULL) {
        if (StringIMatchW (NewDirName, p->DirId)) {
            StringCopyW (NewDirName, p->Translation);
            break;
        }
        p++;
    }
    StringCatW (NewDirName, OldDirNext);
    return TRUE;
}

BOOL
RegisterOleControls(
    VOID
    )
{
    INFCONTEXT InfLine;
    WCHAR DirId [MAX_PATH];
    WCHAR SubDir [MAX_PATH];
    WCHAR Filename [MAX_PATH];
    WCHAR RegType [MAX_PATH];
    WCHAR FullPathTemp[MAX_PATH];
    WCHAR FullPath[MAX_PATH];
    BOOL b;
    DWORD d;
    UINT Line;
    WCHAR OldCD[MAX_PATH];
    OLE_CONTROL_DATA OleControlData;

    b = TRUE;
    Line = 0;

    //
    // Preserve current directory just in case
    //
    d = GetCurrentDirectory(MAX_PATH,OldCD);
    if(!d || (d >= MAX_PATH)) {
        OldCD[0] = 0;
    }

    if(SetupFindFirstLine(g_WkstaMigInf, L"Win9xUpg_OleControls", NULL, &InfLine)) {

        do {
            Line++;
            if (!SetupGetStringField (&InfLine, 1, DirId, MAX_PATH, NULL) ||
                !SetupGetStringField (&InfLine, 2, SubDir, MAX_PATH, NULL) ||
                !SetupGetStringField (&InfLine, 3, Filename, MAX_PATH, NULL) ||
                !SetupGetStringField (&InfLine, 4, RegType, MAX_PATH, NULL)
                ) {
                DEBUGMSGW ((DBG_ERROR, "Bad line while registering controls %d", Line));
            } else {

                DEBUGMSG ((DBG_VERBOSE, "SETUP: filename for file to register is %s", Filename));
                //
                // Get full path to dll
                //
                if (pConvertDirName (DirId, FullPathTemp)) {
                    wcscpy (FullPath, FullPathTemp);
                    if (*SubDir) {
                        wcscat (FullPath, L"\\");
                        wcscat (FullPath, SubDir);
                    }
                    SetCurrentDirectory(FullPath);
                    wcscat (FullPath, L"\\");
                    wcscat (FullPath, Filename);
                    OleControlData.FullPath = FullPath;
                    OleControlData.RegType = RegType;
                    RegisterIndividualOleControl (&OleControlData);
                } else {
                    DEBUGMSG ((DBG_ERROR, "SETUP: dll skipped, bad dirid %s", DirId));
                    b = FALSE;
                }
            }
        } while(SetupFindNextLine(&InfLine,&InfLine));
    }

    if(OldCD[0]) {
        SetCurrentDirectory(OldCD);
    }

    return(b);
}


DWORD
ProcessLocalMachine_Last (
    DWORD Request
    )

{
    DWORD rc;

#ifdef VAR_PROGRESS_BAR

    CHAR SystemDatPath[MAX_MBCHAR_PATH];
    WIN32_FIND_DATAA fd;
    HANDLE h;
    DWORD SizeKB;

#endif

    static LONG g_TicksHklm;

    if (Request == REQUEST_QUERYTICKS) {

#ifdef VAR_PROGRESS_BAR

        //
        // estimate g_TicksHklm function of size of file system.dat
        //
        StringCopyA (SystemDatPath, g_SystemHiveDir);
        StringCatA (SystemDatPath, "system.dat");
        h = FindFirstFileA (SystemDatPath, &fd);
        if (h != INVALID_HANDLE_VALUE) {
            FindClose (h);
            MYASSERT (!fd.nFileSizeHigh);
            SizeKB = (fd.nFileSizeLow + 511) / 1024;
            DEBUGLOGTIME (("ProcessLocalMachine_Last: system.dat size = %lu KB", SizeKB));
            //
            // statistics show that average time is 243 * (filesize in KB) - 372000
            // I'll use 256 instead just to make sure the progress bar will not stop
            // at the end looking like it's hanged
            // The checked build is much slower (about 1.5 times)
            //
#ifdef DEBUG
            g_TicksHklm = SizeKB * 400;
#else
            g_TicksHklm = SizeKB * 256;
#endif
        } else {
            //
            // what's wrong here?
            //
            MYASSERT (FALSE);
            g_TicksHklm = TICKS_HKLM;
        }

#else // !defined VAR_PROGRESS_BAR

        g_TicksHklm = TICKS_HKLM;

#endif
        return TICKS_INI_MERGE +
               g_TicksHklm +
               TICKS_SHARES +
               TICKS_LINK_EDIT +
               TICKS_DOSMIG_SYS +
               TICKS_UPDATERECYCLEBIN +
               TICKS_STF +
               TICKS_RAS +
               TICKS_TAPI +
               TICKS_MULTIMEDIA +
               TICKS_INI_ACTIONS_LAST;
    }

    //
    // We process the local machine in the following order:
    //
    //  Initialization:
    //    (1) Reload memdb
    //
    //  Local machine registry preparation:
    //
    //    (1) Process wkstamig.inf
    //    (2) Merge Win95 registry with NT hive
    //
    //  Process instructions written to memdb:
    //
    //    (1) Create Win95 shares
    //    (2) Process LinkEdit section
    //

    //
    // Load in default MemDb state, or at least delete everything if
    // memdb.dat does not exist.
    //

    MemDbLoad (GetMemDbDat());

    DEBUGMSG ((DBG_INIFILES, "INI file merge - START"));
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Starting function: MergeIniSettings"));
    if (!MergeIniSettings ()) {
        LOG ((LOG_ERROR, "Process Local Machine: Could not merge one or more .INI files."));
        return GetLastError();
    }
    TickProgressBarDelta (TICKS_INI_MERGE);
    DEBUGMSG ((DBG_INIFILES, "INI file merge - STOP"));
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Function complete: MergeIniSettings"));

    //
    // Process local machine migration rules
    //

    DEBUGLOGTIME (("ProcessLocalMachine_Last: Starting function: MergeRegistry"));
    if (!MergeRegistry (S_WKSTAMIG_INF, NULL)) {
        LOG ((LOG_ERROR, "Process Local Machine: MergeRegistry failed for wkstamig.inf"));
        return GetLastError();
    }
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Function complete: MergeRegistry"));
    TickProgressBarDelta (g_TicksHklm);

    //
    // Process memdb nodes
    //

    DEBUGLOGTIME (("ProcessLocalMachine_Last: Starting function: DoCreateShares"));
    DoCreateShares();  // we ignore all errors
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Function complete: DoCreateShares"));
    TickProgressBarDelta (TICKS_SHARES);

    DEBUGLOGTIME (("ProcessLocalMachine_Last: Starting function: DoLinkEdit"));
    if (!DoLinkEdit()) {
        LOG ((LOG_ERROR, "Process Local Machine: DoLinkEdit failed."));
        return GetLastError();
    }
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Function complete: DoLinkEdit"));
    TickProgressBarDelta (TICKS_LINK_EDIT);

    //
    // Handle DOS system migration.
    //

    DEBUGLOGTIME (("ProcessLocalMachine_Last: Starting function: DosMigNt_System"));
    __try {
        if (DosMigNt_System() != EXIT_SUCCESS) {
            LOG((LOG_ERROR, "Process Local Machine: DosMigNt_System failed."));
        }
    }
    __except(TRUE) {
        DEBUGMSG ((DBG_WHOOPS, "Exception in DosMigNt_System"));
    }
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Function complete: DosMigNt_System"));
    TickProgressBarDelta (TICKS_DOSMIG_SYS);


    //
    // Make the recycled bin the correct status
    //

    DEBUGLOGTIME (("ProcessLocalMachine_Last: Starting function: pUpdateRecycleBin"));
    if (!pUpdateRecycleBin ()) {
        LOG ((LOG_ERROR, "Process Local Machine: Could not update recycle bin."));
    }
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Function complete: pUpdateRecycleBin"));
    TickProgressBarDelta (TICKS_UPDATERECYCLEBIN);

    //
    // Migrate all .STF files (ACME Setup)
    //

    DEBUGLOGTIME (("ProcessLocalMachine_Last: Starting function: ProcessStfFiles"));
    if (!ProcessStfFiles()) {
        LOG ((LOG_ERROR, "Process Local Machine: Could not migrate one or more .STF files."));
    }
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Function complete: ProcessStfFiles"));
    TickProgressBarDelta (TICKS_STF);

    DEBUGLOGTIME (("ProcessLocalMachine_Last: Starting function: Ras_MigrateSystem"));
    if (!Ras_MigrateSystem()) {
        LOG ((LOG_ERROR, "Ras MigrateSystem: Error migrating system."));
    }
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Function complete: Ras_MigrateSystem"));
    TickProgressBarDelta (TICKS_RAS);

    DEBUGLOGTIME (("ProcessLocalMachine_Last: Starting function: Tapi_MigrateSystem"));
    if (!Tapi_MigrateSystem()) {
        LOG ((LOG_ERROR, "Tapi MigrateSystem: Error migrating system TAPI settings."));
    }
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Function complete: Tapi_MigrateSystem"));
    TickProgressBarDelta (TICKS_TAPI);

    DEBUGLOGTIME (("ProcessLocalMachine_Last: Starting function: RestoreMMSettings_System"));
    if (!RestoreMMSettings_System ()) {
        LOG ((LOG_ERROR, "Process Local Machine: Could not restore multimedia settings."));
        return GetLastError();
    }
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Function complete: RestoreMMSettings_System"));
    TickProgressBarDelta (TICKS_MULTIMEDIA);

    DEBUGLOGTIME (("ProcessLocalMachine_Last: Starting function: DoIniActions.Last"));
    DEBUGMSG ((DBG_INIFILES, "INI Files Actions.Last - START"));
    if (!DoIniActions (INIACT_WKS_LAST)) {
        LOG ((LOG_ERROR, "Process Local Machine: Could not perform one or more INI Files Actions.Last"));
    }
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Function complete: DoIniActions.Last"));
    TickProgressBarDelta (TICKS_INI_ACTIONS_LAST);
    DEBUGMSG ((DBG_INIFILES, "INI Files Actions.Last - STOP"));

    DEBUGLOGTIME (("ProcessLocalMachine_Last: Starting function: RegisterOleControls"));
    RegisterOleControls ();
    DEBUGLOGTIME (("ProcessLocalMachine_Last: Function complete: RegisterOleControls"));

    //
    // Blow away the Network Account Wizard (so fast it doesn't need ticks)
    //

    pTurnOffNetAccountWizard();

    //
    // Update security for Crypto group
    //

    rc = SetRegKeySecurity (
            TEXT("HKLM\\Software\\Microsoft\\Cryptography\\MachineKeys"),
            SF_EVERYONE_FULL,
            NULL,
            NULL,
            TRUE
            );

    return ERROR_SUCCESS;
}


BOOL
pEnumWin9xHiveFileWorker (
    IN OUT  PHIVEFILE_ENUM EnumPtr
    )

/*++

Routine Description:

  pEnumWin9xHiveFileWorker parses wkstamig.inf to get the source path to a
  Win9x registry hive, and it gets the destination of where the hive should
  be migrated to.  The source is tested, and if it doesn't exist, the
  function returns FALSE.

  Environment variables in both the source or dest are expanded before
  this function returns success.

Arguments:

  EnumPtr - Specifies partially completed enumeration structure (the
            EnumPtr->is member must be valid).  Receives the source and
            destination of the hive to  be migrated.

Return Value:

  Returns TRUE if a hive needs to be transfered from EnumPtr->Source to
  EnumPtr->Dest, otherwise FALSE.

--*/

{
    PCTSTR Source;
    PCTSTR Dest;

    //
    // Get the source and dest from the INF
    //

    Source = InfGetStringField (&EnumPtr->is, 0);
    Dest = InfGetStringField (&EnumPtr->is, 1);

    if (!Source || !Dest) {
        DEBUGMSG ((DBG_WHOOPS, "wkstamig.inf HiveFilesToConvert is not correct"));
        return FALSE;
    }

    //
    // Expand the source and dest
    //

    if (EnumPtr->Source) {
        FreeText (EnumPtr->Source);
    }

    EnumPtr->Source = ExpandEnvironmentText (Source);

    if (EnumPtr->Dest) {
        FreeText (EnumPtr->Dest);
    }

    EnumPtr->Dest = ExpandEnvironmentText (Dest);

    //
    // The source must exist
    //

    if (!DoesFileExist (EnumPtr->Source)) {
        return FALSE;
    }

    return TRUE;
}


VOID
pAbortHiveFileEnum (
    IN OUT  PHIVEFILE_ENUM EnumPtr
    )

/*++

Routine Description:

  pAbortHiveFileEnum cleans up the allocations from an active enumeration of
  Win9x hive files.  This routine must be called by the enum first/next when
  the enumeration completes, or it must be called by the code using the
  enumeration.  It is safe to call this routine in both places.

Arguments:

  EnumPtr - Specifies the enumeration that needs to be aborted or that has
            completed successfully.  Receives a zero'd struct.

Return Value:

  None.

--*/

{
    if (EnumPtr->Pool) {
        PoolMemDestroyPool (EnumPtr->Pool);
    }

    if (EnumPtr->Source) {
        FreeText (EnumPtr->Source);
    }

    if (EnumPtr->Dest) {
        FreeText (EnumPtr->Dest);
    }

    ZeroMemory (EnumPtr, sizeof (HIVEFILE_ENUM));
}


BOOL
pEnumNextWin9xHiveFile (
    IN OUT  PHIVEFILE_ENUM EnumPtr
    )

/*++

Routine Description:

  pEnumNextWin9xHiveFile continues the enumeration wksatmig.inf until  either
  a hive needing migration is found, or no more INF entries are left.

Arguments:

  EnumPtr - Specifies an enumeration structure that was initialized by
            pEnumFirstWin9xHiveFile. Receives the next hive file source &
            dest enumeration if one is available.

Return Value:

  TRUE if a Win9x hive file needs to be migrated (its source and dest
  specified in EnumPtr). FALSE if no more hive files are to be processed.

--*/

{
    do {
        if (!InfFindNextLine (&EnumPtr->is)) {
            pAbortHiveFileEnum (EnumPtr);
            return FALSE;
        }
    } while (!pEnumWin9xHiveFileWorker (EnumPtr));

    return TRUE;
}


BOOL
pEnumFirstWin9xHiveFile (
    OUT     PHIVEFILE_ENUM EnumPtr
    )

/*++

Routine Description:

  pEnumFirstWin9xHiveFile begins an enumeration of Win9x registry files that
  need to be migrated either to the NT registry, or to an NT registry hive
  file.

Arguments:

  EnumPtr - Receives the source Win9x hive file and the destination (either a
            file or a registry path).

Return Value:

  TRUE if a Win9x hive file was found and needs to be migrated, FALSE if no
  hive file migration is needed.

--*/

{
    ZeroMemory (EnumPtr, sizeof (HIVEFILE_ENUM));

    //
    // Begin the enumeration of the Hive Files section of wkstamig.inf
    //

    EnumPtr->Pool = PoolMemInitNamedPool ("Hive File Enum");

    InitInfStruct (&EnumPtr->is, NULL, EnumPtr->Pool);

    if (!InfFindFirstLine (g_WkstaMigInf, S_WKSTAMIG_HIVE_FILES, NULL, &EnumPtr->is)) {
        pAbortHiveFileEnum (EnumPtr);
        return FALSE;
    }

    //
    // Attempt to return the first hive
    //

    if (pEnumWin9xHiveFileWorker (EnumPtr)) {
        return TRUE;
    }

    //
    // Hive does not exist, continue enumeration
    //

    return pEnumNextWin9xHiveFile (EnumPtr);
}


BOOL
pTransferWin9xHiveToRegKey (
    IN      PCTSTR Win9xHive,
    IN      PCTSTR NtRootKey
    )

/*++

Routine Description:

  pTransferWin9xHiveToRegKey maps in a Win9x hive file, enumerates all the
  keys and values, and transfers them to the NT registry.

Arguments:

  Win9xHive - Specifies the registry hive file (a Win9x hive)
  NtRootKey - Specifies the path to the NT registry destination, such as
              HKLM\foo.

Return Value:

  TRUE if the hive file was transferred without an error, FALSE otherwise.
  Use GetLastError to get the error code.

--*/

{
    LONG rc;
    HKEY DestKey;
    BOOL b = FALSE;
    REGTREE_ENUM e;
    REGVALUE_ENUM e2;
    PCTSTR SubKey;
    HKEY DestSubKey;
    BOOL EnumAbort = FALSE;
    PBYTE DataBuf;
    GROWBUFFER Data = GROWBUF_INIT;
    DWORD Type;
    DWORD Size;
    BOOL CloseDestSubKey = FALSE;

    //
    // Map the hive into a temporary key
    //

    rc = Win95RegLoadKey (
            HKEY_LOCAL_MACHINE,
            S_HIVE_TEMP,
            Win9xHive
            );

    if (rc != ERROR_SUCCESS) {
        DEBUGMSG ((DBG_ERROR, "Can't load %s for transfer", Win9xHive));
        return FALSE;
    }

    __try {
        DestKey = CreateRegKeyStr (NtRootKey);

        if (!DestKey) {
            DEBUGMSG ((DBG_ERROR, "Can't create %s", NtRootKey));
            __leave;
        }

        if (EnumFirstRegKeyInTree95 (&e, TEXT("HKLM\\") S_HIVE_TEMP)) {

            EnumAbort = TRUE;

            do {
                //
                // Create the NT destination; if SubKey is empty, then
                // use the root key for the destination.
                //

                SubKey = (PCTSTR) ((PBYTE) e.FullKeyName + e.EnumBaseBytes);

                if (*SubKey) {
                    DestSubKey = CreateRegKey (DestKey, SubKey);
                    if (!DestSubKey) {
                        DEBUGMSG ((DBG_ERROR, "Can't create subkey %s", SubKey));
                        __leave;
                    }

                    CloseDestSubKey = TRUE;

                } else {
                    DestSubKey = DestKey;
                }

                //
                // Copy all values in 9x key to NT
                //

                if (EnumFirstRegValue95 (&e2, e.CurrentKey->KeyHandle)) {
                    do {
                        Data.End = 0;
                        DataBuf = GrowBuffer (&Data, e2.DataSize);
                        if (!DataBuf) {
                            DEBUGMSG ((DBG_ERROR, "Data size is too big: %s", e2.DataSize));
                            __leave;
                        }

                        Size = e2.DataSize;
                        rc = Win95RegQueryValueEx (
                                e2.KeyHandle,
                                e2.ValueName,
                                NULL,
                                &Type,
                                DataBuf,
                                &Size
                                );

                        if (rc != ERROR_SUCCESS) {
                            DEBUGMSG ((
                                DBG_ERROR,
                                "Can't read enumerated value:\n"
                                    "  %s\n"
                                    "  %s [%s]",
                                Win9xHive,
                                e.FullKeyName,
                                e2.ValueName
                                ));

                            __leave;
                        }

                        MYASSERT (Size == e2.DataSize);

                        rc = RegSetValueEx (
                                DestSubKey,
                                e2.ValueName,
                                0,
                                e2.Type,
                                DataBuf,
                                Size
                                );

                        if (rc != ERROR_SUCCESS) {
                            DEBUGMSG ((
                                DBG_ERROR,
                                "Can't write enumerated value:\n"
                                    "  %s\n"
                                    "  %s\\%s [%s]",
                                Win9xHive,
                                NtRootKey,
                                SubKey,
                                e2.ValueName
                                ));

                            __leave;
                        }

                    } while (EnumNextRegValue95 (&e2));
                }

                if (CloseDestSubKey) {
                    CloseRegKey (DestSubKey);
                    CloseDestSubKey = FALSE;
                }

            } while (EnumNextRegKeyInTree95 (&e));

            EnumAbort = FALSE;
        }
        ELSE_DEBUGMSG ((DBG_WARNING, "%s is empty", Win9xHive));

        b = TRUE;
    }
    __finally {
        PushError();

        if (CloseDestSubKey) {
            CloseRegKey (DestSubKey);
        }

        if (EnumAbort) {
            AbortRegKeyTreeEnum95 (&e);
        }

        Win95RegUnLoadKey (HKEY_LOCAL_MACHINE, TEXT("$$$"));

        if (DestKey) {
            CloseRegKey (DestKey);
        }

        FreeGrowBuffer (&Data);

        PopError();
    }

    return b;
}


BOOL
pTransferWin9xHive (
    IN      PCTSTR Win9xHive,
    IN      PCTSTR Destination
    )

/*++

Routine Description:

  pTransferWin9xHive transfers a Win9x registry hive file (foo.dat) to either
  an NT registry file, or a key in the NT registry.  The source and
  destination can be the same file.

Arguments:

  Win9xHive   - Specifies the registry hive file path (a Win9x hive file).
  Destination - Specifies either a path or NT registry location where the
                Win9xHive should be transfered to.

Return Value:

  TRUE if the hive was transfered, FALSE otherwise.  Call GetLastError for an
  error code.

--*/

{
    PCTSTR DestHive;
    BOOL ToHiveFile;
    HKEY Key;
    LONG rc;

    //
    // Determine if destination is a hive file or a reg location
    //

    if (_istalpha (Destination[0]) && Destination[1] == TEXT(':')) {
        ToHiveFile = TRUE;
        DestHive = TEXT("HKLM\\") S_TRANSFER_HIVE;
    } else {
        ToHiveFile = FALSE;
        DestHive = Destination;
    }

    //
    // Blast the Win9x hive data to the temp location
    //

    if (!pTransferWin9xHiveToRegKey (Win9xHive, DestHive)) {
        RegDeleteKey (HKEY_LOCAL_MACHINE, S_TRANSFER_HIVE);
        return FALSE;
    }

    //
    // Save the key if the destination is a hive file
    //

    if (ToHiveFile) {
        Key = OpenRegKeyStr (DestHive);

        if (!Key) {
            DEBUGMSG ((DBG_ERROR, "Transfer hive key %s does not exist", DestHive));
            return FALSE;
        }

        rc = RegSaveKey (Key, Destination, NULL);

        CloseRegKey (Key);
        RegDeleteKey (HKEY_LOCAL_MACHINE, S_TRANSFER_HIVE);

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_ERROR, "Win9x hive %s could not be saved to %s", Win9xHive, Destination));
            return FALSE;
        }
    }

    //
    // Delete the source file if the destination is not the same
    //

    if (!ToHiveFile || !StringIMatch (Win9xHive, DestHive)) {
        //
        // By adding info to memdb, we must enforce a rule that
        // memdb cannot be reloaded.  Otherwise we lose our
        // changes.
        //

        DeclareTemporaryFile (Win9xHive);

#ifdef DEBUG
        g_NoReloadsAllowed = TRUE;
#endif
    }

    return TRUE;
}


DWORD
ConvertHiveFiles (
    DWORD Request
    )

/*++

Routine Description:

  ConvertHiveFiles enumerates all the hive files on the system that need
  conversion, and calls pTransferWin9xHive to migrate them to the destination
  specified in wkstamig.inf.

Arguments:

  Request - Specifies the progress bar-driven request.

Return Value:

  If Request is REQUEST_QUERYTICKS, the return value is the number of ticks
  this routine is expected to take.  Otherwise, the return value is
  ERROR_SUCCESS.

--*/

{
    HIVEFILE_ENUM e;

    switch (Request) {

    case REQUEST_QUERYTICKS:
        return TICKS_HIVE_CONVERSION;

    case REQUEST_RUN:
        //
        // Enumerate all the hives that need to be processed
        //

        if (pEnumFirstWin9xHiveFile (&e)) {
            do {

                pTransferWin9xHive (e.Source, e.Dest);

            } while (pEnumNextWin9xHiveFile (&e));
        }
        ELSE_DEBUGMSG ((DBG_NAUSEA, "ConvertHiveFiles: Nothing to do"));
        break;

    default:
        break;

    }

    return ERROR_SUCCESS;
}


BOOL
pRegisterAtmFont (
    IN      PCTSTR PfmFile,
    IN      PCTSTR PfbFile,
    IN      PCTSTR MmmFile      OPTIONAL
    )

/*++

Routine Description:

  pRegisterAtmFont calls the AtmFontExW API to register an Adobe PS font.

Arguments:

  PfmFile - Specifies the path to the PFM file (the font metrics)
  PfbFile - Specifies the path to the PFB file (the font bits)
  MmmFile - Specifies the path to the MMM file (the new style metrics file)

Return Value:

  TRUE if the font was registered, FALSE otherwise.

--*/

{
    WORD StyleAndType = 0x2000;
    INT Result;

    if (AtmAddFontEx == NULL) {
        return FALSE;
    }

    Result = AtmAddFontEx (
                NULL,
                &StyleAndType,
                PfmFile,
                PfbFile,
                MmmFile
                );

    DEBUGMSG_IF ((
        Result != ERROR_SUCCESS,
        Result == - 1 ? DBG_WARNING : DBG_ERROR,
        "Font not added, result = %i.\n"
        " PFM: %s\n"
        " PFB: %s\n"
        " MMM: %s\n",
        Result,
        PfmFile,
        PfbFile,
        MmmFile
        ));

    return Result == ERROR_SUCCESS;
}


PCTSTR
pGetAtmMultiSz (
    POOLHANDLE Pool,
    PCTSTR InfName,
    PCTSTR SectionName,
    PCTSTR KeyName
    )

/*++

Routine Description:

  pGetAtmMultiSz returns a multi-sz of the ATM font file names in the order
  of PFM, PFB and MMM.  Profile APIs are used because the key names have
  commas, and they are unquoted.

Arguments:

  Pool        - Specifies the pool where the multi-sz will allocate buffer
                space from.
  InfName     - Specifies the full path to the INF, to be used with the
                profile APIs.
  SectionName - Specifies the section name in InfName that is being processed.
  KeyName     - Specifies the key name to process

Return Value:

  A pointer to a multi-sz allocated in the specified pool.

--*/

{
    PTSTR MultiSz;
    PTSTR d;
    TCHAR FileBuf[MAX_TCHAR_PATH * 2];
    UINT Bytes;

    GetPrivateProfileString (
        SectionName,
        KeyName,
        TEXT(""),
        FileBuf,
        sizeof (FileBuf) / sizeof (FileBuf[0]),
        InfName
        );

    //
    // Turn all commas into nuls
    //

    d = FileBuf;

    while (*d) {
        if (_tcsnextc (d) == TEXT(',')) {
            *d = 0;
        }

        d = _tcsinc (d);
    }

    //
    // Terminate the multi-sz
    //

    d++;
    *d = 0;
    d++;

    //
    // Transfer to a pool-based allocation and return it
    //

    Bytes = (UINT) ((PBYTE) d - (PBYTE) FileBuf);

    MultiSz = (PTSTR) PoolMemGetAlignedMemory (Pool, Bytes);

    CopyMemory (MultiSz, FileBuf, Bytes);

    return MultiSz;
}


BOOL
pEnumAtmFontWorker (
    IN OUT  PATM_FONT_ENUM EnumPtr
    )

/*++

Routine Description:

  pEnumAtmFontWorker implements the logic of parsing ATM.INI to get the Adobe
  font names. This routine completes an enumeration started by
  pEnumFirstAtmFont or pEnumNextAtmFont.

Arguments:

  EnumPtr - Specifies a partially completed enumeration structure, receives a
            fully completed structure.

Return Value:

  TRUE if an ATM font was enumerated, FALSE otherwise.

--*/

{
    PTSTR p;
    PCTSTR MultiSz;
    BOOL MetricFileExists;

    //
    // Get PFM, PFB and MMM files
    //

    MultiSz = pGetAtmMultiSz (
                    EnumPtr->Pool,
                    EnumPtr->InfName,
                    S_FONTS,
                    EnumPtr->KeyNames
                    );

    if (!MultiSz) {
        return FALSE;
    }

    if (*MultiSz) {
        _tcssafecpy (EnumPtr->PfmFile, MultiSz, MAX_TCHAR_PATH);
        MultiSz = GetEndOfString (MultiSz) + 1;
    }

    if (*MultiSz) {
        _tcssafecpy (EnumPtr->PfbFile, MultiSz, MAX_TCHAR_PATH);
    } else {
        return FALSE;
    }

    MultiSz = pGetAtmMultiSz (
                    EnumPtr->Pool,
                    EnumPtr->InfName,
                    S_MMFONTS,
                    EnumPtr->KeyNames
                    );

    if (MultiSz) {
        _tcssafecpy (EnumPtr->MmmFile, MultiSz, MAX_TCHAR_PATH);
        MultiSz = GetEndOfString (MultiSz) + 1;

        if (*MultiSz) {
            DEBUGMSG_IF ((
                !StringIMatch (MultiSz, EnumPtr->PfbFile),
                DBG_ERROR,
                "ATM.INI: MMFonts and Fonts specify two different PFBs: %s and %s",
                MultiSz,
                EnumPtr->PfbFile
                ));
        }
    } else {
        EnumPtr->MmmFile[0] = 0;
    }

    //
    // Special case: .MMM is listed in [Fonts]
    //

    p = _tcsrchr (EnumPtr->PfmFile, TEXT('.'));
    if (p && p < _tcschr (p, TEXT('\\'))) {
        p = NULL;
    }

    if (p && StringIMatch (p, TEXT(".mmm"))) {
        EnumPtr->PfmFile[0] = 0;
    }

    //
    // Special case: .MMM exists but is not listed in atm.ini
    //

    if (!EnumPtr->MmmFile[0]) {

        StringCopy (EnumPtr->MmmFile, EnumPtr->PfmFile);

        p = _tcsrchr (EnumPtr->MmmFile, TEXT('.'));
        if (p && p < _tcschr (p, TEXT('\\'))) {
            p = NULL;
        }

        if (p) {
            StringCopy (p, TEXT(".mmm"));
            if (!DoesFileExist (EnumPtr->MmmFile)) {
                EnumPtr->MmmFile[0] = 0;
            }
        } else {
            EnumPtr->MmmFile[0] = 0;
        }
    }

    //
    // Verify all files exist
    //

    MetricFileExists = FALSE;

    if (EnumPtr->PfmFile[0] && DoesFileExist (EnumPtr->PfmFile)) {
        MetricFileExists = TRUE;
    }

    if (EnumPtr->MmmFile[0] && DoesFileExist (EnumPtr->MmmFile)) {
        MetricFileExists = TRUE;
    }

    if (!DoesFileExist (EnumPtr->PfbFile) || !MetricFileExists) {

        DEBUGMSG ((
            DBG_VERBOSE,
            "At least one file is missing: %s, %s or %s",
            EnumPtr->PfmFile[0] ? EnumPtr->PfmFile : TEXT("(no PFM specified)"),
            EnumPtr->MmmFile[0] ? EnumPtr->MmmFile : TEXT("(no MMM specified)"),
            EnumPtr->PfbFile
            ));

        return FALSE;
    }

    return TRUE;
}


VOID
pAbortAtmFontEnum (
    IN OUT  PATM_FONT_ENUM EnumPtr
    )

/*++

Routine Description:

  pAbortAtmFontEnum cleans up an enumeration structure after enumeration
  completes or if enumeration needs to be aborted. This routine can safely be
  called multiple times on the same structure.

Arguments:

  EnumPtr - Specifies an initialized and possibly used enumeration structure.

Return Value:

  None.

--*/

{
    if (EnumPtr->Pool) {
        PoolMemDestroyPool (EnumPtr->Pool);
    }

    ZeroMemory (EnumPtr, sizeof (ATM_FONT_ENUM));
}


BOOL
pEnumNextAtmFont (
    IN OUT  PATM_FONT_ENUM EnumPtr
    )

/*++

Routine Description:

  pEnumNextAtmFont continues enumeration, returning either another set of ATM
  font paths, or FALSE.

Arguments:

  EnumPtr - Specifies the enumeration structure started by pEnumNextAtmFont.

Return Value:

  TRUE if another set of font paths is available, FALSE otherwise.

--*/

{
    if (!EnumPtr->KeyNames || !(*EnumPtr->KeyNames)) {
        pAbortAtmFontEnum (EnumPtr);
        return FALSE;
    }

    //
    // Continue enumeration, looping until a font path set was found,
    // or there are no more atm.ini lines to enumerate.
    //

    do {
        EnumPtr->KeyNames = GetEndOfString (EnumPtr->KeyNames) + 1;

        if (!(*EnumPtr->KeyNames)) {
            pAbortAtmFontEnum (EnumPtr);
            return FALSE;
        }

    } while (!pEnumAtmFontWorker (EnumPtr));

    return TRUE;
}


BOOL
pEnumFirstAtmFont (
    OUT     PATM_FONT_ENUM EnumPtr
    )

/*++

Routine Description:

  pEnumFirstAtmFont begins the enumeration of font path sets in ATM.INI.

Arguments:

  EnumPtr - Receivies the first set of font paths found (if any).

Return Value:

  TRUE if a font path set was found, FALSE otherwise.

--*/

{
    TCHAR AtmIni[MAX_TCHAR_PATH];
    PTSTR FilePart;
    PTSTR KeyNames;
    UINT Bytes;

    //
    // Init structure
    //

    ZeroMemory (EnumPtr, sizeof (ATM_FONT_ENUM));

    //
    // Find full path to atm.ini (usually in %windir%)
    //

    if (!SearchPath (NULL, TEXT("atm.ini"), NULL, MAX_TCHAR_PATH, AtmIni, &FilePart)) {
        DEBUGMSG ((DBG_VERBOSE, "ATM.INI not found in search path"));
        return FALSE;
    }

    StringCopy (EnumPtr->InfName, AtmIni);

    //
    // Establish processing pool and get all key names in [Fonts]
    //

    EnumPtr->Pool = PoolMemInitNamedPool ("ATM Font Enum");
    MYASSERT (EnumPtr->Pool);

    KeyNames = MemAlloc (g_hHeap, 0, MAX_KEY_NAME_LIST);

    GetPrivateProfileString (
        S_FONTS,
        NULL,
        TEXT(""),
        KeyNames,
        MAX_KEY_NAME_LIST,
        AtmIni
        );

    Bytes = SizeOfMultiSz (KeyNames);

    EnumPtr->KeyNames = (PTSTR) PoolMemGetAlignedMemory (EnumPtr->Pool, Bytes);
    CopyMemory (EnumPtr->KeyNames, KeyNames, Bytes);

    MemFree (g_hHeap, 0, KeyNames);

    //
    // Begin enumeration
    //

    if (!(*EnumPtr->KeyNames)) {
        pAbortAtmFontEnum (EnumPtr);
        return FALSE;
    }

    if (pEnumAtmFontWorker (EnumPtr)) {
        return TRUE;
    }

    return pEnumNextAtmFont (EnumPtr);
}


DWORD
MigrateAtmFonts (
    DWORD Request
    )

/*++

Routine Description:

  MigrateAtmFonts is called by the progress bar to query ticks or to migrate
  ATM fonts.

Arguments:

  Request - Specifies the reason the progress bar is calling the routine.

Return Value:

  If Request is REQUEST_QUERYTICKS, then the return value is the number of
  estimated ticks needed to complete processing.  Otherwise the return value
  is ERROR_SUCCESS.

--*/

{
    ATM_FONT_ENUM e;
    static HANDLE AtmLib;
    TCHAR AtmIniPath[MAX_TCHAR_PATH];

    if (Request == REQUEST_QUERYTICKS) {

        //
        // Dynamically load atmlib.dll
        //

        AtmAddFontEx = NULL;

        AtmLib = LoadLibrary (TEXT("atmlib.dll"));
        if (!AtmLib) {
            DEBUGMSG ((DBG_ERROR, "Cannot load entry point from atmlib.dll!"));
        } else {
            (FARPROC) AtmAddFontEx = GetProcAddress (AtmLib, "ATMAddFontExW");
            DEBUGMSG_IF ((!AtmAddFontEx, DBG_ERROR, "Cannot get entry point ATMAddFontExW in atmlib.dll!"));
        }

        return AtmAddFontEx ? TICKS_ATM_MIGRATION : 0;

    } else if (Request != REQUEST_RUN) {
        return ERROR_SUCCESS;
    }

    if (AtmAddFontEx) {
        //
        // Do the ATM font migration
        //

        if (pEnumFirstAtmFont (&e)) {

            StringCopy (AtmIniPath, e.InfName);

            do {

                if (pRegisterAtmFont (e.PfmFile, e.PfbFile, e.MmmFile)) {
                    DEBUGMSG ((DBG_VERBOSE, "ATM font registered %s", e.PfbFile));
                }

            } while (pEnumNextAtmFont (&e));

            DeclareTemporaryFile (AtmIniPath);

#ifdef DEBUG
            g_NoReloadsAllowed = TRUE;
#endif

        }

        //
        // Clean up use of atmlib.dll - we're finished
        //

        FreeLibrary (AtmLib);
        AtmLib = NULL;
        AtmAddFontEx = NULL;
    }

    return ERROR_SUCCESS;
}



DWORD
RunSystemExternalProcesses (
    IN      DWORD Request
    )
{
    LONG Count;

    if (Request == REQUEST_QUERYTICKS) {
        //
        // Count the number of entries and multiply by a constant
        //

        Count = SetupGetLineCount (g_WkstaMigInf, S_EXTERNAL_PROCESSES);

#ifdef PROGRESS_BAR
        DEBUGLOGTIME (("RunSystemExternalProcesses: ExternalProcesses=%ld", Count));
#endif

        if (Count < 1) {
            return 0;
        }

        return Count * TICKS_SYSTEM_EXTERN_PROCESSES;
    }

    if (Request != REQUEST_RUN) {
        return ERROR_SUCCESS;
    }

    //
    // Loop through the processes and run each of them
    //
    RunExternalProcesses (g_WkstaMigInf, NULL);
    return ERROR_SUCCESS;
}


BOOL
pEnumFirstWin9xBriefcase (
    OUT     PBRIEFCASE_ENUM e
    )
{
    if (!MemDbGetValueEx (&e->mde, MEMDB_CATEGORY_BRIEFCASES, NULL, NULL)) {
        return FALSE;
    }
    e->BrfcaseDb = e->mde.szName;
    return TRUE;
}


BOOL
pEnumNextWin9xBriefcase (
    IN OUT  PBRIEFCASE_ENUM e
    )
{
    if (!MemDbEnumNextValue (&e->mde)) {
        return FALSE;
    }
    e->BrfcaseDb = e->mde.szName;
    return TRUE;
}


BOOL
pMigrateBriefcase (
    IN      PCTSTR BriefcaseDatabase,
    IN      PCTSTR BriefcaseDir
    )
{
    HBRFCASE hbrfcase;
    PTSTR NtPath;
    BOOL Save, Success;
    TWINRESULT tr;
    BRFPATH_ENUM e;
    BOOL Result = TRUE;

    __try {

        g_BrfcasePool = PoolMemInitNamedPool ("Briefcase");
        if (!g_BrfcasePool) {
            return FALSE;
        }

        tr = OpenBriefcase (BriefcaseDatabase, OB_FL_OPEN_DATABASE, NULL, &hbrfcase);
        if (tr == TR_SUCCESS) {

            if (EnumFirstBrfcasePath (hbrfcase, &e)) {

                Save = FALSE;
                Success = TRUE;

                do {
                    if (StringIMatch (BriefcaseDir, e.PathString)) {
                        //
                        // ignore this path
                        //
                        continue;
                    }

                    NtPath = GetPathStringOnNt (e.PathString);
                    MYASSERT (NtPath);

                    if (!StringIMatch (NtPath, e.PathString)) {
                        //
                        // try to replace Win9x path with NT path
                        //
                        if (!ReplaceBrfcasePath (&e, NtPath)) {
                            Success = FALSE;
                            break;
                        }
                        Save = TRUE;
                    }

                    FreePathString (NtPath);

                } while (EnumNextBrfcasePath (&e));

                if (!Success || Save && SaveBriefcase (hbrfcase) != TR_SUCCESS) {
                    Result = FALSE;
                }
            }

            CloseBriefcase(hbrfcase);
        }
    }
    __finally {
        PoolMemDestroyPool (g_BrfcasePool);
        g_BrfcasePool = NULL;
    }

    return Result;
}


DWORD
MigrateBriefcases (
    DWORD Request
    )

/*++

Routine Description:

  MigrateBriefcases is called by the progress bar to query ticks or to migrate
  briefcases.

Arguments:

  Request - Specifies the reason the progress bar is calling the routine.

Return Value:

  If Request is REQUEST_QUERYTICKS, then the return value is the number of
  estimated ticks needed to complete processing.  Otherwise the return value
  is ERROR_SUCCESS.

--*/

{
    BRIEFCASE_ENUM e;
    TCHAR BrfcaseDir[MAX_PATH + 2];
    PTSTR p;
    PTSTR BrfcaseDbOnNt;

    switch (Request) {

    case REQUEST_QUERYTICKS:
        return TICKS_MIGRATE_BRIEFCASES;

    case REQUEST_RUN:
        //
        // Enumerate all the briefcases that need to be processed
        //
        if (pEnumFirstWin9xBriefcase (&e)) {
            do {
                BrfcaseDbOnNt = GetPathStringOnNt (e.BrfcaseDb);
                MYASSERT (BrfcaseDbOnNt);
                //
                // get directory name first
                //
                if (CharCount (BrfcaseDbOnNt) <= MAX_PATH) {
                    StringCopy (BrfcaseDir, BrfcaseDbOnNt);
                    p = _tcsrchr (BrfcaseDir, TEXT('\\'));
                    if (p) {
                        *p = 0;
                        if (!pMigrateBriefcase (BrfcaseDbOnNt, BrfcaseDir)) {
                            LOG ((
                                LOG_WARNING,
                                (PCSTR)MSG_ERROR_MIGRATING_BRIEFCASE,
                                BrfcaseDir
                                ));
                        }
                    }
                }
                FreePathString (BrfcaseDbOnNt);
            } while (pEnumNextWin9xBriefcase (&e));
        }
        ELSE_DEBUGMSG ((DBG_NAUSEA, "MigrateBriefcases: Nothing to do"));
        break;
    }

    return ERROR_SUCCESS;
}

DWORD
RunSystemUninstallUserProfileCleanupPreparation (
    IN      DWORD Request
    )
{
    LONG Count;

    if (Request == REQUEST_QUERYTICKS) {
        //
        // Count the number of entries and multiply by a constant
        //

        Count = SetupGetLineCount (g_WkstaMigInf, S_UNINSTALL_PROFILE_CLEAN_OUT);

#ifdef PROGRESS_BAR
        DEBUGLOGTIME (("RunSystemUninstallUserProfileCleanupPreparation: FileNumber=%ld", Count));
#endif

        if (Count < 1) {
            return 1;
        }

        return Count * TICKS_SYSTEM_UNINSTALL_CLEANUP;
    }

    if (Request != REQUEST_RUN) {
        return ERROR_SUCCESS;
    }

    //
    // Loop through the files and mark them to be deleted during uninstall
    //
    UninstallUserProfileCleanupPreparation (g_WkstaMigInf, NULL, TRUE);

    return ERROR_SUCCESS;
}


DWORD
AddOptionsDiskCleaner (
    DWORD Request
    )
{
    HKEY key = NULL;
    HKEY subKey = NULL;
    PCTSTR optionsPath;
    LONG rc;
    PCTSTR descText = NULL;
    DWORD d;

    if (Request == REQUEST_QUERYTICKS) {
        return 1;
    }

    if (Request != REQUEST_RUN) {
        return ERROR_SUCCESS;
    }

    optionsPath = JoinPaths (g_WinDir, TEXT("OPTIONS"));

    __try {
        if (!DoesFileExist (optionsPath)) {
            __leave;
        }

        key = OpenRegKeyStr (TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VolumeCaches"));

        if (!key) {
            DEBUGMSG ((DBG_ERROR, "Can't open VolumeCaches"));
            __leave;
        }

        subKey = CreateRegKey (key, TEXT("Options Folder"));

        if (!subKey) {
            DEBUGMSG ((DBG_ERROR, "Can't create Options Folder"));
            __leave;
        }

        rc = RegSetValueEx (
                subKey,
                TEXT(""),
                0,
                REG_SZ,
                (PBYTE) S_CLEANER_GUID,
                sizeof (S_CLEANER_GUID)
                );

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_ERROR, "Can't write default value to Options Folder key"));
        }

        descText = GetStringResource (MSG_OPTIONS_CLEANER);
        rc = RegSetValueEx (
                subKey,
                TEXT("Description"),
                0,
                REG_SZ,
                (PBYTE) descText,
                SizeOfString (descText)
                );

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_ERROR, "Can't write Description value to Options Folder key"));
        }

        FreeStringResource (descText);

        descText = GetStringResource (MSG_OPTIONS_CLEANER_TITLE);
        rc = RegSetValueEx (
                subKey,
                TEXT("Display"),
                0,
                REG_SZ,
                (PBYTE) descText,
                SizeOfString (descText)
                );

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_ERROR, "Can't write Display value to Options Folder key"));
        }

        rc = RegSetValueEx (
                subKey,
                TEXT("FileList"),
                0,
                REG_SZ,
                (PBYTE) S_CLEANER_ALL_FILES,
                sizeof (S_CLEANER_ALL_FILES)
                );

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_ERROR, "Can't write FileList value to Options Folder key"));
        }

        rc = RegSetValueEx (
                subKey,
                TEXT("Folder"),
                0,
                REG_SZ,
                (PBYTE) optionsPath,
                SizeOfString (optionsPath)
                );

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_ERROR, "Can't write Folder value to Options Folder key"));
        }

        d = 0x17F;      // see shell\applets\cleaner\dataclen\common.h DDEVCF_* flags
        rc = RegSetValueEx (
                subKey,
                TEXT("Flags"),
                0,
                REG_DWORD,
                (PBYTE) &d,
                sizeof (d)
                );

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_ERROR, "Can't write flags to Options Folder key"));
        }
    }
    __finally {
        FreePathString (optionsPath);
        if (key) {
            CloseRegKey (key);
        }
        if (subKey) {
            CloseRegKey (subKey);
        }

        FreeStringResource (descText);
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\ntui\ntui.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    ntui.c

Abstract:

    Processing indicator dialog shows percentage of completion
    in a progress bar.  The progress is updated by the caller.

Author:

    Jim Schmidt (jimschm) 13-Aug-1996

Revision History:

    jimschm     19-Oct-1998 Updated to use wizard status line
    jimschm     23-Sep-1998 Redesigned domain account resolution
    jimschm     02-Jul-1998 Finally rewrote progress bar
    jimschm     18-Dec-1996 Moved to new lib, slated to be rewritten

--*/

#include "pch.h"


static PCTSTR g_LocalAccountString;
static PCTSTR g_SearchAgainString;
static HWND g_StatusPopup;
static OUR_CRITICAL_SECTION g_StatusPopupCs;
static HANDLE g_AbortDelayEvent;
static HANDLE g_DelayThread;
static BOOL g_ClassRegistered = FALSE;
static DWORD g_ThreadId;

#define WMX_SETTEXT     (WM_USER+500)
#define S_STATUS_CLASS  TEXT("StatusWnd")

typedef struct {
    INT ConversionX;
    INT ConversionY;
} CONVERSIONFACTORS, *PCONVERSIONFACTORS;

#define CONVERSION_RESOLUTION   100


VOID
pShowStatusPopup (
    VOID
    );

VOID
pKillDelayThread (
    VOID
    );


VOID
pUpdateDialog (
    HWND hdlg,
    PRESOLVE_ACCOUNTS_ARRAY Array,
    BOOL UserList,
    BOOL DomainList
    )
{
    HWND hwndUsers;
    HWND hwndDomain;
    UINT Count;
    TCHAR Buf[256];
    UINT Selection;
    UINT Index;
    UINT Item;
    PCTSTR *DomainNamePtr;
    PCTSTR Message;
    PCTSTR ArgArray[1];

    hwndUsers = GetDlgItem (hdlg, IDC_USER_LIST);
    hwndDomain = GetDlgItem (hdlg, IDC_DOMAIN_LIST);

    if (UserList) {
        //
        // Populate the list box with <user> logs onto <domain>
        //

        Selection = SendMessage (hwndUsers, LB_GETCURSEL, 0, 0);
        if (Selection == LB_ERR) {
            Selection = 0;
        }

        SendMessage (hwndUsers, LB_RESETCONTENT, 0, 0);

        for (Count = 0 ; Array[Count].UserName ; Count++) {
            if (Array[Count].RetryFlag) {

                wsprintf (
                    Buf, TEXT("%s\t%s"),
                    Array[Count].UserName,
                    g_SearchAgainString
                    );

            } else {

                wsprintf (
                    Buf, TEXT("%s\t%s"),
                    Array[Count].UserName,
                    Array[Count].OutboundDomain ? Array[Count].OutboundDomain : g_LocalAccountString
                    );
            }

            Item = SendMessage (hwndUsers, LB_ADDSTRING, 0, (LPARAM) Buf);
            SendMessage (hwndUsers, LB_SETITEMDATA, Item, Count);
        }

        SendMessage (hwndUsers, LB_SETCURSEL, Selection, 0);
    }

    if (DomainList) {
        //
        // Get the current user selection
        //

        Selection = SendMessage (hwndUsers, LB_GETCURSEL, 0, 0);
        if (Selection == LB_ERR) {
            Selection = 0;
        }

        Index = SendMessage (hwndUsers, LB_GETITEMDATA, Selection, 0);

        //
        // Fill the combo box
        //

        SendMessage (hwndDomain, CB_RESETCONTENT, 0, 0);

        DomainNamePtr = Array[Index].DomainArray;

        // Insert all domain names
        while (*DomainNamePtr) {
            Item = SendMessage (hwndDomain, CB_ADDSTRING, 0, (LPARAM) (*DomainNamePtr));
            SendMessage (hwndDomain, CB_SETITEMDATA, Item, (LPARAM) (*DomainNamePtr));

            DomainNamePtr++;
        }

        // Insert standard strings
        Item = SendMessage (hwndDomain, CB_ADDSTRING, 0, (LPARAM) g_LocalAccountString);
        SendMessage (hwndDomain, CB_SETITEMDATA, Item, (LPARAM) g_LocalAccountString);

        Item = SendMessage (hwndDomain, CB_ADDSTRING, 0, (LPARAM) g_SearchAgainString);
        SendMessage (hwndDomain, CB_SETITEMDATA, Item, (LPARAM) g_SearchAgainString);

        // Restore selection
        if (Array[Index].RetryFlag) {
            Item = SendMessage (hwndDomain, CB_FINDSTRINGEXACT, 0, (LPARAM) g_SearchAgainString);
            SendMessage (hwndDomain, CB_SETCURSEL, Item, 0);
        } else if (Array[Index].OutboundDomain) {
            Item = SendMessage (hwndDomain, CB_FINDSTRINGEXACT, 0, (LPARAM) (Array[Index].OutboundDomain));
            SendMessage (hwndDomain, CB_SETCURSEL, Item, 0);
        } else {
            Item = SendMessage (hwndDomain, CB_FINDSTRINGEXACT, 0, (LPARAM) g_LocalAccountString);
            SendMessage (hwndDomain, CB_SETCURSEL, Item, 0);
        }

        ArgArray[0] = Array[Index].UserName;

        Message = ParseMessageID (MSG_USER_DOMAIN_LOGON_DLG, ArgArray);

        SetDlgItemText (hdlg, IDC_DOMAIN_LIST_TITLE, Message);

        FreeStringResource (Message);
    }
}


VOID
pInitConversionFactors (
    IN      HWND hdlg,
    OUT     PCONVERSIONFACTORS Factors
    )
{
    RECT rect;

    rect.left = 0;
    rect.right = CONVERSION_RESOLUTION;
    rect.top = 0;
    rect.bottom = CONVERSION_RESOLUTION;

    MapDialogRect (hdlg, &rect);

    Factors->ConversionX = rect.right - rect.left;
    Factors->ConversionY = rect.bottom - rect.top;
}


INT
pConvertPixelsToDialogX (
    IN      PCONVERSIONFACTORS Factors,
    IN      INT Pixels
    )
{
    return CONVERSION_RESOLUTION * Pixels / Factors->ConversionX;
}


INT
pConvertPixelsToDialogY (
    IN      PCONVERSIONFACTORS Factors,
    IN      INT Pixels
    )
{
    return CONVERSION_RESOLUTION * Pixels / Factors->ConversionY;
}


BOOL
CALLBACK
pResolveAccountsDlgProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

  pResolveAccountsDlgProc prompts the user with a list of domain choices,
  the local machine, or retry the network search.

  Upon init, the lParam specifies the RESULT_ACCOUNTS_ARRAY pointer that
  provides the user list and initial state.  Upon exit, the array is
  updated to reflect the user's choices.

Arguments:

    hdlg    - The dialog handle

    uMsg    - The message to process

    wParam  - The wParam for the message

    lParam  - The lParam for the message

Return value:

    The dialog always ends with IDOK.

--*/

{
    static PRESOLVE_ACCOUNTS_ARRAY Array;
    static CONVERSIONFACTORS Factors;
    RECT rect;
    INT Tabs;
    UINT Selection;
    UINT Index;
    HWND hwndList;
    PCTSTR NewDomain;

    switch (uMsg) {
    case WM_INITDIALOG:
        CenterWindow (hdlg, GetDesktopWindow());

        Array = (PRESOLVE_ACCOUNTS_ARRAY) lParam;
        MYASSERT (Array);

        pInitConversionFactors (hdlg, &Factors);

        //
        // Get the strings
        //

        g_LocalAccountString = GetStringResource (MSG_LOCAL_ACCOUNT_DLG);
        g_SearchAgainString = GetStringResource (MSG_DOMAIN_NOT_LISTED_DLG);

        //
        // Set the tab stops
        //

        GetWindowRect (GetDlgItem (hdlg, IDC_USER_TITLE), &rect);
        Tabs = pConvertPixelsToDialogX (&Factors, (rect.right - rect.left) + 8);

        SendMessage (GetDlgItem (hdlg, IDC_USER_LIST), LB_SETTABSTOPS, 1, (LPARAM) &Tabs);

        //
        // Clear the retry flag
        //

        for (Index = 0 ; Array[Index].UserName ; Index++) {
            Array[Index].RetryFlag = FALSE;
        }

        //
        // Fill the controls
        //

        pUpdateDialog (hdlg, Array, TRUE, TRUE);

        return TRUE;

    case WM_COMMAND:
        switch (LOWORD (wParam)) {
        case IDOK:
            FreeStringResource (g_LocalAccountString);
            g_LocalAccountString = NULL;

            FreeStringResource (g_SearchAgainString);
            g_SearchAgainString = NULL;

            EndDialog (hdlg, IDOK);
            return TRUE;

        case IDC_USER_LIST:
            if (HIWORD (wParam) == LBN_SELCHANGE) {
                pUpdateDialog (hdlg, Array, FALSE, TRUE);
            }

            return TRUE;

        case IDC_DOMAIN_LIST:
            if (HIWORD (wParam) == CBN_SELCHANGE) {

                hwndList = GetDlgItem (hdlg, IDC_USER_LIST);
                Selection = SendMessage (hwndList, LB_GETCURSEL, 0, 0);
                Index = SendMessage (hwndList, LB_GETITEMDATA, Selection, 0);

                hwndList = GetDlgItem (hdlg, IDC_DOMAIN_LIST);
                Selection = SendMessage (hwndList, CB_GETCURSEL, 0, 0);

                NewDomain = (PCTSTR) SendMessage (hwndList, CB_GETITEMDATA, Selection, 0);

                if (NewDomain == g_LocalAccountString) {
                    Array[Index].OutboundDomain = NULL;
                    Array[Index].RetryFlag = FALSE;
                } else if (NewDomain == g_SearchAgainString) {
                    Array[Index].OutboundDomain = NULL;
                    Array[Index].RetryFlag = TRUE;
                } else {
                    Array[Index].OutboundDomain = NewDomain;
                    Array[Index].RetryFlag = FALSE;
                }

                pUpdateDialog (hdlg, Array, TRUE, FALSE);
            }
        }

        break;
    }

    return FALSE;
}


BOOL
CALLBACK
NetworkDownDlgProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

  NetworkDownDlgProc asks the user if they want to:

    (A) Continue searching with retry prompts
    (B) Continue searching, skipping down domains
    (C) Stop searching

Arguments:

    hdlg    - The dialog handle

    uMsg    - The message to process

    wParam  - The wParam for the message

    lParam  - The lParam for the message

Return value:

    The call to DialogBox returns:

        IDC_STOP      - Stop searching
        IDC_RETRY     - Continue with retry
        IDC_NO_RETRY  - Continue without retry

--*/

{
    switch (uMsg) {
    case WM_INITDIALOG:
        CenterWindow (hdlg, GetDesktopWindow());

        CheckDlgButton (hdlg, IDC_RETRY, TRUE);
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD (wParam)) {
        case IDOK:
            if (IsDlgButtonChecked (hdlg, IDC_RETRY)) {
                EndDialog (hdlg, IDC_RETRY);
            } else if (IsDlgButtonChecked (hdlg, IDC_NO_RETRY)) {
                EndDialog (hdlg, IDC_NO_RETRY);
            } else if (IsDlgButtonChecked (hdlg, IDC_STOP)) {
                EndDialog (hdlg, IDC_STOP);
            }

            return TRUE;
        }

        break;
    }

    return FALSE;
}



VOID
ResolveAccounts (
    PRESOLVE_ACCOUNTS_ARRAY Array
    )
{
    DialogBoxParam (
        g_hInst,
        MAKEINTRESOURCE (IDD_CHOOSE_DOMAIN),
        g_ParentWnd,
        pResolveAccountsDlgProc,
        (LPARAM) Array
        );
}


LRESULT
CALLBACK
pStatusWndProc (
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    RECT Desktop;
    RECT Client;
    INT Top, Left;
    INT Width, Height;
    INT TextWidth, TextHeight;
    static HWND StatusText;
    PCTSTR InitialMsg;
    TEXTMETRIC tm;
    HDC hdc;

    switch (uMsg) {

    case WM_CREATE:

        g_StatusPopup = hwnd;

        InitialMsg = GetStringResource (MSG_INITIAL_STATUS_MSG);

        MYASSERT (InitialMsg);

        //
        // Compute proper size
        //

        GetWindowRect (GetDesktopWindow(), &Desktop);

        hdc = CreateDC (TEXT("DISPLAY"), NULL, NULL, NULL);

        SelectObject (hdc, GetStockObject (DEFAULT_GUI_FONT));
        GetTextMetrics (hdc, &tm);

        DeleteDC (hdc);

        Width = (Desktop.right - Desktop.left) / 2;
        Height = (Desktop.bottom - Desktop.top) / 20;

        TextWidth  = tm.tmAveCharWidth * 3 * CharCount (InitialMsg);
        TextHeight = tm.tmHeight * 3;

        Width  = min (Width, TextWidth);
        Height = min (Height, TextHeight);

        Top  = Desktop.bottom - Height - tm.tmAveCharWidth;
        Left = Desktop.right - Width - tm.tmHeight;

        SetWindowPos (hwnd, HWND_TOPMOST, Left, Top, Width, Height, SWP_NOACTIVATE);

        //
        // Create text window
        //

        GetClientRect (hwnd, &Client);

        Width  = (Client.right - Client.left) * 7 / 8;
        Height = (Client.bottom - Client.top) * 7 / 8;

        Top  = (Client.right - Client.left) / 16;
        Left = (Client.bottom - Client.top) / 16;

        StatusText = CreateWindow (
                        TEXT("STATIC"),
                        InitialMsg,
                        WS_CHILD|WS_VISIBLE|SS_NOPREFIX|SS_CENTERIMAGE,
                        Top, Left,
                        Width, Height,
                        hwnd,
                        (PVOID) 100,
                        g_hInst,
                        NULL
                        );

        SendMessage (StatusText, WM_SETFONT, (WPARAM) GetStockObject (DEFAULT_GUI_FONT), 0);

        //
        // Make window initially hidden
        //

        HideStatusPopup (STATUS_DELAY);

        FreeStringResource (InitialMsg);

        return TRUE;

    case WMX_SETTEXT:
        SetWindowText (StatusText, (PCTSTR) lParam);
        break;

    case WM_DESTROY:
        if (StatusText) {
            DestroyWindow (StatusText);
            StatusText = NULL;
        }

        break;
    }

    return DefWindowProc (hwnd, uMsg, wParam, lParam);
}


DWORD
WINAPI
pStatusDlgThread (
    PVOID Arg
    )
{
    WNDCLASS wc;
    HWND hwnd;
    MSG msg;

    if (!g_ClassRegistered) {
        ZeroMemory (&wc, sizeof (wc));

        wc.lpfnWndProc = pStatusWndProc;
        wc.hInstance = g_hInst;
        wc.hbrBackground = (HBRUSH) COLOR_WINDOW;
        wc.lpszClassName = S_STATUS_CLASS;

        RegisterClass (&wc);
        g_ClassRegistered = TRUE;
    }

    hwnd = CreateWindowEx (
                0,
                S_STATUS_CLASS,
                TEXT(""),
                WS_POPUP|WS_BORDER|WS_THICKFRAME,
                CW_USEDEFAULT, CW_USEDEFAULT,
                CW_USEDEFAULT, CW_USEDEFAULT,
                g_ParentWnd,
                NULL,
                g_hInst,
                NULL
                );

    while (GetMessage (&msg, NULL, 0, 0)) {
        if (msg.hwnd == NULL) {
            if (msg.message == WM_CLOSE) {
                break;
            }
        }

        TranslateMessage (&msg);
        DispatchMessage (&msg);
    }

    DestroyWindow (g_StatusPopup);
    g_StatusPopup = NULL;

    return 0;
}


VOID
CreateStatusPopup (
    VOID
    )
{
    HWND Child;
    PCTSTR InitialMsg;

    g_StatusPopup = GetDlgItem (g_ParentWnd, IDC_PROGRESS_BAR_LABEL);

    if (!g_StatusPopup) {
        //
        // Scan all children for IDC_PROGRESS_BAR_LABEL
        //

        Child = GetWindow (g_ParentWnd, GW_CHILD);

        while (Child) {

            g_StatusPopup = GetDlgItem (Child, IDC_PROGRESS_BAR_LABEL);
            if (g_StatusPopup) {
                break;
            }

            Child = GetWindow (Child, GW_HWNDNEXT);
        }
    }

    MYASSERT (g_StatusPopup);
    HideStatusPopup (STATUS_DELAY);

    InitialMsg = GetStringResource (MSG_INITIAL_STATUS_MSG);
    if (InitialMsg) {
        SetWindowText (g_StatusPopup, InitialMsg);
        FreeStringResource (InitialMsg);
    }

#if 0

    HANDLE Thread;

    InitializeOurCriticalSection (&g_StatusPopupCs);
    Thread = CreateThread (
                NULL,
                0,
                pStatusDlgThread,
                NULL,
                0,
                &g_ThreadId
                );

    MYASSERT (Thread);
    CloseHandle (Thread);

#endif
}


VOID
DestroyStatusPopup (
    VOID
    )
{
    pKillDelayThread();

    EnterOurCriticalSection (&g_StatusPopupCs);

    if (g_StatusPopup) {
        ShowWindow (g_StatusPopup, SW_HIDE);
        //PostThreadMessage (g_ThreadId, WM_CLOSE, 0, 0);
    }

    if (g_AbortDelayEvent) {
        CloseHandle (g_AbortDelayEvent);
        g_AbortDelayEvent = NULL;
    }

    LeaveOurCriticalSection (&g_StatusPopupCs);

    DeleteOurCriticalSection (&g_StatusPopupCs);
}


VOID
UpdateStatusPopup (
    PCTSTR NewMessage
    )
{
    EnterOurCriticalSection (&g_StatusPopupCs);

    if (g_StatusPopup) {
        SetWindowText (g_StatusPopup, NewMessage);

#if 0
        SendMessage (g_StatusPopup, WMX_SETTEXT, 0, (LPARAM) NewMessage);
#endif
    }

    LeaveOurCriticalSection (&g_StatusPopupCs);
}


DWORD
WINAPI
pDelayThenShowStatus (
    PVOID Arg
    )
{
    DWORD Result;

    Result = WaitForSingleObject (g_AbortDelayEvent, (UINT) Arg);

    if (WAIT_TIMEOUT == Result) {
        EnterOurCriticalSection (&g_StatusPopupCs);
        pShowStatusPopup();
        LeaveOurCriticalSection (&g_StatusPopupCs);
    }

    EnterOurCriticalSection (&g_StatusPopupCs);

    if (g_AbortDelayEvent) {
        CloseHandle (g_AbortDelayEvent);
        g_AbortDelayEvent = NULL;
    }

    LeaveOurCriticalSection (&g_StatusPopupCs);

    return 0;
}


VOID
pKillDelayThread (
    VOID
    )
{
    //
    // This routine makes sure the delay thread is stopped,
    // that the thread handle is closed, and that the show event
    // is cleaned up.
    //
    // There is no affect on the visibility of the status dialog.
    //

    if (!g_DelayThread) {
        return;
    }

    EnterOurCriticalSection (&g_StatusPopupCs);

    if (g_AbortDelayEvent) {
        SetEvent (g_AbortDelayEvent);
    }

    LeaveOurCriticalSection (&g_StatusPopupCs);

    WaitForSingleObject (g_DelayThread, INFINITE);

    EnterOurCriticalSection (&g_StatusPopupCs);

    CloseHandle (g_DelayThread);
    g_DelayThread = NULL;

    LeaveOurCriticalSection (&g_StatusPopupCs);
}


VOID
HideStatusPopup (
    UINT Timeout
    )
{
    pKillDelayThread();

    EnterOurCriticalSection (&g_StatusPopupCs);

    ShowWindow (g_StatusPopup, SW_HIDE);

    if (Timeout != INFINITE) {
        MYASSERT (!g_DelayThread);
        MYASSERT (!g_AbortDelayEvent);

        g_AbortDelayEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
        g_DelayThread = StartThread (pDelayThenShowStatus, (PVOID) Timeout);
    }

    LeaveOurCriticalSection (&g_StatusPopupCs);
}


VOID
pShowStatusPopup (
    VOID
    )
{
    //
    // Caller handles mutex
    //

    if (g_StatusPopup) {
        ShowWindow (g_StatusPopup, SW_SHOW);
        UpdateWindow (g_StatusPopup);
    }

#if 0
    if (g_StatusPopup) {
        SetWindowPos (
            g_StatusPopup,
            HWND_TOPMOST,
            0, 0, 0, 0,
            SWP_NOMOVE|SWP_NOSIZE|SWP_SHOWWINDOW|SWP_NOACTIVATE
            );

        UpdateWindow (g_StatusPopup);
    }
#endif

}


VOID
ShowStatusPopup (
    VOID
    )
{
    pKillDelayThread();

    EnterOurCriticalSection (&g_StatusPopupCs);
    pShowStatusPopup();
    LeaveOurCriticalSection (&g_StatusPopupCs);
}


BOOL
IsStatusPopupVisible (
    VOID
    )
{
    BOOL b;

    EnterOurCriticalSection (&g_StatusPopupCs);

    b = IsWindowVisible (g_StatusPopup);

    LeaveOurCriticalSection (&g_StatusPopupCs);

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\rulehlpr\keyboard.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    keyboard.c

Abstract:

    Implements routines to merge keyboard layouts from the upgraded win9x
    system and a clean win2k install. The result is that Windows 2000 has
    the base keyboard layout support it expects and any additional layouts
    (third party IMEs, newer Microsoft IMEs) that may have been present in
    the original operating system.

    This code was modified from a base originally in Rulehlpr.c

Author:

    Marc R. Whitten (marcw) 26-Jan-1999

Revision History:

    marcw 26-Apr-1999 Add support for mapping changed keyboard layouts.

--*/

#include "pch.h"



FILTERRETURN
pKeyboardLayoutsFilter (
    IN      CPDATAOBJECT SrcObject,
    IN      CPDATAOBJECT DstObject,
    IN      FILTERTYPE FilterType,
    IN      PVOID Arg
    )
{
    FILTERRETURN rState = FILTER_RETURN_CONTINUE;
    DATAOBJECT object;
    BOOL freeObject = FALSE;
    TCHAR layoutFile[MAX_TCHAR_PATH];
    PTSTR extension = NULL;
    TCHAR key[MEMDB_MAX];
    DWORD unused;



    __try {

        rState = Standard9xSuppressFilter (SrcObject, DstObject, FilterType, Arg);
        if (rState != FILTER_RETURN_CONTINUE) {

            return rState;
        }



        //
        // Check to make sure we want to enumerate this entry.
        //
        if (FilterType == FILTER_KEY_ENUM) {

            //
            // If the Keyboard Layout begins with a '0' It is a locale specific keyboard layout. In these cases, we
            // use the NT value.
            //
            if (*SrcObject->ChildKey == TEXT('0')) {
                //
                // This is a standard locale keyboard layout. We want this to go to the NT default after migration.
                // Skip copying this over from win95.
                //
                rState = FILTER_RETURN_HANDLED;
                __leave;

            }

            if (*SrcObject->ChildKey != TEXT('E') && *SrcObject->ChildKey != TEXT('e')) {
                DEBUGMSG ((DBG_WHOOPS, "Unknown format. Skipping %s.", DEBUGENCODER(SrcObject)));
                rState = FILTER_RETURN_HANDLED;
                __leave;

            }





        }

        //
        // Don't create empty object. This may be suppressed.
        //
        if (FilterType == FILTER_CREATE_KEY) {

            rState = FILTER_RETURN_HANDLED;
            __leave;
        }


        if (FilterType == FILTER_PROCESS_VALUES) {


            //
            // We need to look at the value of Ime File.
            // This will determine what we do with this entry.
            //
            if (!DuplicateObjectStruct (&object, SrcObject)) {
                rState = FILTER_RETURN_FAIL;
            }
            freeObject = TRUE;

            FreeObjectVal (&object);
            SetRegistryValueName (&object, TEXT("IME File"));

            if (!ReadObject (&object) || object.Type != REG_SZ) {
                DEBUGMSG ((
                    DBG_WARNING,
                    "No usable IME File data for %s. It will be suppressed.",
                    DEBUGENCODER(SrcObject)
                    ));
                rState = FILTER_RETURN_HANDLED;
                __leave;
            }

            if (object.Value.Size > (MAX_PATH * sizeof (WCHAR))) {
                rState = FILTER_RETURN_HANDLED;
                __leave;
            }

            //
            // Suppress this setting unless we are going to leave the file alone
            // (or at worst move it around somewhere...)
            //
            MemDbBuildKey (key, MEMDB_CATEGORY_GOOD_IMES, (PCTSTR) object.Value.Buffer, NULL, NULL);
            if (!MemDbGetValue (key, &unused)) {

                rState = FILTER_RETURN_HANDLED;
                DEBUGMSG ((
                    DBG_WARNING,
                    "Ime Layout Entry for %s will be suppressed.",
                    DEBUGENCODER(SrcObject)
                    ));

                __leave;
            }


        }


        if (FilterType == FILTER_VALUE_COPY) {

            //
            // We need to massage the layout file if we are bringing this over.
            //
            if (StringIMatch (SrcObject->ValueName, S_LAYOUT_FILE)) {


                //
                // Convert layout file.
                //

                _tcssafecpy (layoutFile, (PTSTR) SrcObject->Value.Buffer, MAX_TCHAR_PATH);


                //
                // We must map kbdjp.kbd to kbdjpn.dll In all other cases, we simply replace the
                // .kbd extension with .dll.
                //
                if (StringIMatch (layoutFile, S_KBDJPDOTKBD)) {

                    StringCopy (layoutFile, S_KBDJPNDOTDLL);

                }
                else if (IsPatternMatch (TEXT("*.KBD"), layoutFile)) {

                    extension = _tcsrchr (layoutFile, TEXT('.'));
                    if (extension) {
                        StringCopy (extension, S_DLL);
                    }

                }




                //
                // Now, we need to write this object.
                //
                if (!DuplicateObjectStruct (&object, DstObject)) {
                    rState = FILTER_RETURN_FAIL;
                    __leave;

                }

                freeObject = TRUE;

                if (!ReplaceValueWithString (&object, layoutFile)) {

                    rState = FILTER_RETURN_FAIL;
                    __leave;
                }

                SetRegistryType (&object, REG_SZ);

                if (!WriteObject (&object)) {
                    rState = FILTER_RETURN_FAIL;
                    __leave;
                }

                rState = FILTER_RETURN_HANDLED;


            }

        }
    }
    __finally {

        if (freeObject) {

            FreeObjectStruct (&object);
        }
    }


    return rState;
}


/*++

Routine Description:

  Migrate Keyboard Layouts is responsible for doing a smart merge between the
  win9x and windows NT keyboard layout registry entries.  The following rules
  are
  used:
(1) For basic locale keyboard layouts, we always use the NT default e
  ntry.
(2) For IME entries, we examine the IME File entry. If the IME file w
  as deleted, we will not use it and will skip the entry. Only if we leave
  the IME file alone do we bring across the
  setting.



Arguments:

  None.

Return Value:



--*/


BOOL
RuleHlpr_MigrateKeyboardLayouts (
    IN      PCTSTR SrcObjectStr,
    IN      PCTSTR DestObjectStr,
    IN      PCTSTR User,
    IN      PVOID Data
    )
{
    DATAOBJECT source;
    DATAOBJECT destination;
    BOOL rSuccess = FALSE;


    //
    // If not local machine, don't process
    //
    if (User) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    //
    // We need to enumerate all keys in SrcObjectStr.  For each key,
    // we examine the default Win9x value, which may cause us to change
    // the default value, or skip the key altogether.
    //

    __try {
        ZeroMemory (&source, sizeof (DATAOBJECT));
        ZeroMemory (&destination, sizeof (DATAOBJECT));

        if (!CreateObjectStruct (SrcObjectStr, &source, WIN95OBJECT)) {
            DEBUGMSG ((DBG_WARNING, "MigrateKeyboardLayouts: %s is invalid", SrcObjectStr));
            __leave;
        }

        if (!(source.ObjectType & OT_TREE)) {
            DEBUGMSG ((DBG_WARNING, "MigrateKeyboardLayouts %s does not specify subkeys -- skipping rule", SrcObjectStr));
            rSuccess = TRUE;
            __leave;
        }


        //
        // Our filter function will do the real copying, removing any entries that need to be skipped.
        //
        DuplicateObjectStruct (&destination, &source);
        SetPlatformType (&destination, WINNTOBJECT);

        rSuccess = CopyObject (&source, &destination, pKeyboardLayoutsFilter, NULL);

        //
        // If there were no entries, return success
        //
        if (!rSuccess) {
            if (GetLastError() == ERROR_FILE_NOT_FOUND ||
                GetLastError() == ERROR_NO_MORE_ITEMS
                ) {
                rSuccess = TRUE;
            }
        }
    }
    __finally {
        FreeObjectStruct (&destination);
        FreeObjectStruct (&source);
    }

    return rSuccess;
}


#define S_KEYBOARD_LAYOUT_MAPPINGS TEXT("Keyboard.Layout.Mappings")
PCTSTR
pMapKeyboardLayoutIfNecessary (
    IN PCTSTR Layout
    )
{
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PTSTR rData = NULL;
    PCTSTR p = NULL;


    if (InfFindFirstLine (g_UserMigInf, S_KEYBOARD_LAYOUT_MAPPINGS, Layout, &is)) {

        //
        // This keyboard layout should be mapped.
        //
        p = InfGetStringField (&is, 1);
        MYASSERT (p);
    }

    if (p) {

        rData = MemAlloc (g_hHeap, 0, SizeOfString (p));
        StringCopy (rData, p);
    }
    else {
        rData = (PTSTR) Layout;
    }

    InfCleanUpInfStruct (&is);

    return rData;
}



FILTERRETURN
pMigrateKeyboardSubstitutesFilter (
    IN CPDATAOBJECT SrcObject,
    IN CPDATAOBJECT DstObject,
    IN FILTERTYPE   Type,
    IN PVOID        Arg
    )
{

    DATAOBJECT newObject;
    PKEYTOVALUEARG keyToValueArgs = (PKEYTOVALUEARG) Arg;
    PCTSTR data;


    //
    // We want to create the initial key, but not any of the subkeys.
    //
    if (Type == FILTER_CREATE_KEY) {

        if (keyToValueArgs -> EnumeratingSubKeys) {
            return FILTER_RETURN_HANDLED;
        }
        else {
            return FILTER_RETURN_CONTINUE;
        }

    } else if (Type == FILTER_KEY_ENUM) {


        if (!keyToValueArgs -> EnumeratingSubKeys) {

            keyToValueArgs -> EnumeratingSubKeys = TRUE;

        }

        return FILTER_RETURN_CONTINUE;

    } else if (Type == FILTER_VALUENAME_ENUM && keyToValueArgs -> EnumeratingSubKeys) {

        if (!*SrcObject -> ValueName) {

            return FILTER_RETURN_CONTINUE;
        }
        ELSE_DEBUGMSG((DBG_WHOOPS,"Keyboard Substitutes: Unexpected value names."));

        return FILTER_RETURN_HANDLED;
    }
    else if (Type == FILTER_VALUE_COPY && keyToValueArgs -> EnumeratingSubKeys) {


        //
        // If this is the default value, we have the information we need to create the value for this.
        //
        if (!*SrcObject -> ValueName) {

            //
            // Create the object struct for the Nt setting.
            //
            DuplicateObjectStruct (&newObject, &(keyToValueArgs->Object));
            SetRegistryValueName (&newObject, _tcsrchr(SrcObject->KeyPtr->KeyString, TEXT('\\')) + 1);

            //
            // We need to see if this keyboard layout string needs to be mapped.
            //
            data = pMapKeyboardLayoutIfNecessary ((PTSTR) SrcObject->Value.Buffer);
            if (!data) {
                return FILTER_RETURN_FAIL;
            }

            //
            // Write this into the nt registry.
            //
            ReplaceValueWithString (&newObject, data);
            SetRegistryType (&newObject,REG_SZ);
            WriteObject (&newObject);


            //
            // Clean up resources.
            //
            if (!StringIMatch (data, (PTSTR) SrcObject->Value.Buffer)) {
                MemFree (g_hHeap, 0, data);
            }
            FreeObjectStruct (&newObject);


        }
        ELSE_DEBUGMSG((DBG_WHOOPS,"Keyboard Substitutes: Unexpected value names.."));

        return FILTER_RETURN_HANDLED;
    }

    return FILTER_RETURN_CONTINUE;

}


BOOL
RuleHlpr_MigrateKeyboardSubstitutes (
    IN PCTSTR SrcObjectStr,
    IN PCTSTR DestObjectStr,
    IN PCTSTR User,
    IN PVOID Data
    )
{
    BOOL rSuccess = TRUE;
    FILTERRETURN fr;
    DATAOBJECT srcObject;
    DATAOBJECT dstObject;
    KEYTOVALUEARG args;

    //
    // We need to enumerate all keys in SrcObjectStr.  For each key,
    // we will change the subkey to a value.
    //

    __try {
        ZeroMemory (&srcObject, sizeof (DATAOBJECT));
        ZeroMemory (&dstObject, sizeof (DATAOBJECT));

        if (!CreateObjectStruct (SrcObjectStr, &srcObject, WIN95OBJECT)) {
            DEBUGMSG ((DBG_WARNING, "MigrateKeyboardSubstitutes: %s is invalid", SrcObjectStr));
            return FALSE;
        }

        if (!(srcObject.ObjectType & OT_TREE)) {
            DEBUGMSG ((DBG_WARNING, "MigrateKeyboardSubstitutes: %s does not specify subkeys -- skipping rule", SrcObjectStr));
            return TRUE;
        }

        DuplicateObjectStruct (&dstObject, &srcObject);
        SetPlatformType (&dstObject, WINNTOBJECT);

        ZeroMemory(&args,sizeof(KEYTOVALUEARG));
        DuplicateObjectStruct(&(args.Object),&dstObject);
        fr = CopyObject (&srcObject, &dstObject, pMigrateKeyboardSubstitutesFilter,&args);
        FreeObjectStruct(&(args.Object));
        DEBUGMSG_IF((fr == FILTER_RETURN_FAIL,DBG_WHOOPS,"MigrateKeyboardSubstitutes: CopyObject returned false."));

    }
    __finally {
        FreeObjectStruct (&dstObject);
        FreeObjectStruct (&srcObject);
    }

    SetLastError(ERROR_SUCCESS);
    return rSuccess;



}


BOOL
pGetKeyboardSubstitutes (
    IN      PCTSTR LocaleID,
    OUT     PGROWBUFFER Gb
    )
{
    HINF inf;
    INFCONTEXT ic;
    DWORD fields;
    DWORD index;
    DWORD dLocaleID;
    PTSTR substLocaleID;
    DWORD dSubstLocaleID;
    TCHAR mapping[20];
    TCHAR key[MEMDB_MAX];
    TCHAR strLocaleID[10];
    PTSTR final;
    BOOL b = FALSE;

    inf = SetupOpenInfFile (TEXT("intl.inf"), NULL, INF_STYLE_WIN4, NULL);
    if (inf != INVALID_HANDLE_VALUE) {
        if (SetupFindFirstLine (inf, TEXT("Locales"), LocaleID, &ic)) {
            fields = SetupGetFieldCount (&ic);
            for (index = 5; index <= fields; index++) {
                if (SetupGetStringField (&ic, index, mapping, 20, NULL)) {
                    //
                    // the format is LCID:SubstituteKLID
                    //
                    dLocaleID = _tcstoul (mapping, &substLocaleID, 16);
                    while (_istspace (*substLocaleID)) {
                        substLocaleID++;
                    }
                    if (*substLocaleID != TEXT(':')) {
                        //
                        // unknown field format
                        //
                        continue;
                    }
                    substLocaleID++;
                    dSubstLocaleID = _tcstoul (substLocaleID, &final, 16);
                    if (*final) {
                        //
                        // unknown field format
                        //
                        continue;
                    }
                    if (dSubstLocaleID == dLocaleID) {
                        continue;
                    }
                    //
                    // record this pair
                    //
                    wsprintf (strLocaleID, TEXT("%08x"), dLocaleID);
                    MemDbBuildKey (key, MEMDB_CATEGORY_KEYBOARD_LAYOUTS, strLocaleID, NULL, NULL);
                    if (MemDbGetValue (key, NULL)) {
                        MultiSzAppend (Gb, strLocaleID);
                        MultiSzAppend (Gb, substLocaleID);
                        b = TRUE;
                    }
                }
            }
        }
        SetupCloseInfFile (inf);
    }

    return b;
}


#define S_KEYBOARD_LAYOUT_PRELOAD_REG TEXT("HKCU\\Keyboard Layout\\Preload")
BOOL
RuleHlpr_MigrateKeyboardPreloads (
    IN      PCTSTR SrcObjectStr,
    IN      PCTSTR DestObjectStr,
    IN      PCTSTR User,
    IN      PVOID Data
    )
{

    DATAOBJECT source;
    DATAOBJECT destination;
    REGKEY_ENUM eKey;
    REGVALUE_ENUM eValue;
    PCTSTR data = NULL;
    TCHAR sequencerStr[20];
    UINT sequencer;
    PCTSTR imeFile = NULL;
    BOOL keepPreload = FALSE;
    TCHAR key[MEMDB_MAX];
    BOOL rSuccess = TRUE;
    MEMDB_ENUM e;
    UINT unused = 0;
    HKEY regKey;
    PTSTR regStr = NULL;
    PTSTR p;
    GROWBUFFER gb = GROWBUF_INIT;
    MULTISZ_ENUM sze;
    PTSTR localeIDStr;

    //
    // If not User, don't process.
    //
    if (!User) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    __try {

        ZeroMemory (&source, sizeof (DATAOBJECT));
        ZeroMemory (&destination, sizeof (DATAOBJECT));


        if (!CreateObjectStruct (SrcObjectStr, &source, WIN95OBJECT)) {
            DEBUGMSG ((DBG_WARNING, "MigrateKeyboardPreloads: %s is invalid", SrcObjectStr));
            rSuccess = FALSE;
            __leave;
        }



        if (!OpenObject (&source)) {
            DEBUGMSG ((DBG_WARNING, "MigrateKeyboardPreloads: Unable to open %s.", SrcObjectStr));
            rSuccess = FALSE;
            __leave;
        }


        if (!(source.ObjectType & OT_TREE)) {
            DEBUGMSG ((DBG_WARNING, "MigrateKeyboardPreloads %s does not specify subkeys -- skipping rule", SrcObjectStr));
            __leave;
        }


        //
        // First, enumerate the win9x preloads and throw them in memdb.
        //
        if (EnumFirstRegKey95 (&eKey, source.KeyPtr->OpenKey)) {
            do {

                keepPreload = FALSE;
                data = NULL;
                imeFile = NULL;

                regKey = OpenRegKey95 (eKey.KeyHandle, eKey.SubKeyName);
                if (regKey) {

                    StringCopy (sequencerStr, eKey.SubKeyName);
                    data = GetRegValueString95 (regKey, TEXT(""));
                    CloseRegKey95 (regKey);
                }

                if (data) {

                    keepPreload = TRUE;

                    //
                    // If this is an IME entry, we have to make sure it will be migrated.
                    //
                    if (*data == TEXT('E') || *data == TEXT('e')) {
                        //
                        // Determine if this IME will be migrated.
                        //
                        regStr = JoinPaths (S_KEYBOARD_LAYOUT_REG, data);
                        regKey = OpenRegKeyStr95 (regStr);
                        FreePathString (regStr);
                        if (regKey) {
                            imeFile = GetRegValueString95 (regKey, TEXT("IME File"));
                            CloseRegKey95 (regKey);
                        }


                        if (imeFile) {


                            MemDbBuildKey (key, MEMDB_CATEGORY_GOOD_IMES, imeFile, NULL, NULL);
                            if (!MemDbGetValue (key, &unused)) {
                                //
                                // This layout entry will not be migrated. Blast the preload away.
                                //
                                keepPreload = FALSE;
                            }

                            MemFree (g_hHeap, 0, imeFile);
                        }
                        else {
                            keepPreload = FALSE;
                        }

                    }


                    //
                    // See if we need to map the 9x keyboard layout to the proper NT layout.
                    //
                    data = pMapKeyboardLayoutIfNecessary (data);



                    if (keepPreload) {

                        //
                        // Usable preload. Save this into memdb. We'll use it later to actually write
                        // the user preload entries.
                        //
                        MemDbSetValueEx (MEMDB_CATEGORY_KEYBOARD_LAYOUTS, sequencerStr, data, NULL, 0, NULL);
                    }

                    if (data) {
                        MemFree (g_hHeap, 0, data);
                    }
                }

            } while (EnumNextRegKey95 (&eKey));
        }


        //
        // Now we need to look at what the NT default preloads are. We will move those preloads behind any preloads that will be migrated.
        //
        sequencer = 900;
        regKey = OpenRegKeyStr (S_KEYBOARD_LAYOUT_PRELOAD_REG);
        if (regKey) {
            if (EnumFirstRegValue (&eValue, regKey)) {

                do {

                    data = GetRegValueString (eValue.KeyHandle, eValue.ValueName);
                    if (data) {

                        //
                        // Check to see if we have already added this entry into memdb.
                        //
                        MemDbBuildKey (key, MEMDB_CATEGORY_KEYBOARD_LAYOUTS, TEXT("*"), data, NULL);
                        if (!MemDbGetValueWithPattern (key, NULL)) {

                            //
                            // Preload that was *not* on Windows 9x. We need to add this to our list.
                            //
                            wsprintf (sequencerStr, TEXT("%d"), sequencer);
                            MemDbSetValueEx (MEMDB_CATEGORY_KEYBOARD_LAYOUTS, sequencerStr, data, NULL, 1, NULL);
                            sequencer++;
                        }

                        MemFree (g_hHeap, 0, data);
                    }


                } while (EnumNextRegValue (&eValue));
            }

            CloseRegKey (regKey);
        }



        //
        // Now we have the complete list of preloads to migrate. We only need to enumerate through memdb and create
        // entries for all of the data collected.
        //
        sequencer = 1;
        if (MemDbGetValueEx (&e, MEMDB_CATEGORY_KEYBOARD_LAYOUTS, NULL, NULL)) {

            do {

                localeIDStr = _tcschr (e.szName, TEXT('\\'));
                if (localeIDStr) {
                    localeIDStr = _tcsinc (localeIDStr);
                } else {
                    MYASSERT (FALSE);
                }

                //
                // Create the object to write and fill in the valuename and data.
                //
                ZeroMemory (&destination, sizeof (DATAOBJECT));
                DuplicateObjectStruct (&destination, &source);
                SetPlatformType (&destination, WINNTOBJECT);
                wsprintf (sequencerStr, TEXT("%d"), sequencer);
                sequencer++;
                SetRegistryValueName (&destination, sequencerStr);
                SetRegistryType (&destination, REG_SZ);
                ReplaceValueWithString (&destination, localeIDStr);

                //
                // Write the object.
                //
                WriteObject (&destination);
                FreeObjectStruct (&destination);
                //
                // also write the corresponding substitute, if appropriate
                //
                if (pGetKeyboardSubstitutes (localeIDStr, &gb)) {
                    StringCopy (key, DestObjectStr);
                    p = _tcsrchr (key, TEXT('\\'));
                    if (!p) {
                        DEBUGMSG ((DBG_WARNING, "MigrateKeyboardPreloads: %s is invalid", DestObjectStr));
                        continue;
                    }
                    StringCopy (p + 1, TEXT("Substitutes"));
                    if (!CreateObjectStruct (key, &destination, WINNTOBJECT)) {
                        DEBUGMSG ((DBG_WARNING, "MigrateKeyboardPreloads: CreateObjectStruct failed with %s", key));
                        continue;
                    }
                    if (EnumFirstMultiSz (&sze, (PCTSTR)gb.Buf)) {
                        SetRegistryValueName (&destination, sze.CurrentString);
                        SetRegistryType (&destination, REG_SZ);
                        if (EnumNextMultiSz (&sze)) {
                            ReplaceValueWithString (&destination, sze.CurrentString);
                            WriteObject (&destination);
                        }
                    }
                    FreeObjectStruct (&destination);
                    FreeGrowBuffer (&gb);
                }
            } while (MemDbEnumNextValue (&e));
        }
    }
    __finally {

        FreeObjectStruct (&source);
        FreeObjectStruct (&destination);

    }

    //
    // Delete this every time through.
    //
    MemDbDeleteTree (MEMDB_CATEGORY_KEYBOARD_LAYOUTS);

    SetLastError (ERROR_SUCCESS);
    return rSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\rulehlpr\cpls.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    cpls.c

Abstract:

    Control Panel applet converters

    This source file implements functions needed to convert
    Win95 control panel settings into NT format.  The most
    complex of the structures are the accessibility flag
    conversions.

Author:

    Jim Schmidt (jimschm) 9-Aug-1996

Revision History:

    Jim Schmidt     (jimschm) 27-Jul-1998  Added ValFn_AntiAlias

--*/


#include "pch.h"
#include <wingdip.h>

extern PVOID g_NtFontFiles;                 // in rulehlpr.c

#define BASICS_ON               0x00000001
#define BASICS_AVAILABLE        0x00000002
#define BASICS_HOTKEYACTIVE     0x00000004
#define BASICS_CONFIRMHOTKEY    0x00000008
#define BASICS_HOTKEYSOUND      0x00000010
#define BASICS_INDICATOR        0x00000020

#define SPECIAL_INVERT_OPTION   0x80000000

typedef struct {
    LPCTSTR ValueName;
    DWORD   FlagVal;
} ACCESS_OPTION, *PACCESS_OPTION;

ACCESS_OPTION g_FilterKeys[] = {
    S_ACCESS_ON,                     BASICS_ON,
    S_ACCESS_AVAILABLE,              BASICS_AVAILABLE,
    S_ACCESS_HOTKEYACTIVE,           BASICS_HOTKEYACTIVE,
    S_ACCESS_CONFIRMHOTKEY,          BASICS_CONFIRMHOTKEY,
    S_ACCESS_HOTKEYSOUND,            BASICS_HOTKEYSOUND,
    S_ACCESS_SHOWSTATUSINDICATOR,    BASICS_INDICATOR,
    S_ACCESS_CLICKON,                FKF_CLICKON,
    NULL,                       0
};

ACCESS_OPTION g_MouseKeys[] = {
    S_ACCESS_ON,                     BASICS_ON,
    S_ACCESS_AVAILABLE,              BASICS_AVAILABLE,
    S_ACCESS_HOTKEYACTIVE,           BASICS_HOTKEYACTIVE,
    S_ACCESS_CONFIRMHOTKEY,          BASICS_CONFIRMHOTKEY,
    S_ACCESS_HOTKEYSOUND,            BASICS_HOTKEYSOUND,
    S_ACCESS_SHOWSTATUSINDICATOR,    BASICS_INDICATOR,
    S_ACCESS_MODIFIERS,              MKF_MODIFIERS|SPECIAL_INVERT_OPTION,
    S_ACCESS_REPLACENUMBERS,         MKF_REPLACENUMBERS,
    NULL,                       0
};

ACCESS_OPTION g_StickyKeys[] = {
    S_ACCESS_ON,                     BASICS_ON,
    S_ACCESS_AVAILABLE,              BASICS_AVAILABLE,
    S_ACCESS_HOTKEYACTIVE,           BASICS_HOTKEYACTIVE,
    S_ACCESS_CONFIRMHOTKEY,          BASICS_CONFIRMHOTKEY,
    S_ACCESS_HOTKEYSOUND,            BASICS_HOTKEYSOUND,
    S_ACCESS_SHOWSTATUSINDICATOR,    BASICS_INDICATOR,
    S_ACCESS_AUDIBLEFEEDBACK,        SKF_AUDIBLEFEEDBACK,
    S_ACCESS_TRISTATE,               SKF_TRISTATE,
    S_ACCESS_TWOKEYSOFF,             SKF_TWOKEYSOFF,
    NULL,                       0
};

ACCESS_OPTION g_SoundSentry[] = {
    S_ACCESS_ON,                     BASICS_ON,
    S_ACCESS_AVAILABLE,              BASICS_AVAILABLE,
    S_ACCESS_SHOWSTATUSINDICATOR,    BASICS_INDICATOR,
    NULL,                       0
};

ACCESS_OPTION g_TimeOut[] = {
    S_ACCESS_ON,                     BASICS_ON,
    S_ACCESS_ONOFFFEEDBACK,          ATF_ONOFFFEEDBACK,
    NULL,                       0
};

ACCESS_OPTION g_ToggleKeys[] = {
    S_ACCESS_ON,                     BASICS_ON,
    S_ACCESS_AVAILABLE,              BASICS_AVAILABLE,
    S_ACCESS_HOTKEYACTIVE,           BASICS_HOTKEYACTIVE,
    S_ACCESS_CONFIRMHOTKEY,          BASICS_CONFIRMHOTKEY,
    S_ACCESS_HOTKEYSOUND,            BASICS_HOTKEYSOUND,
    S_ACCESS_SHOWSTATUSINDICATOR,    BASICS_INDICATOR,
    NULL,                       0
};

ACCESS_OPTION g_HighContrast[] = {
    S_ACCESS_ON,                     BASICS_ON,
    S_ACCESS_AVAILABLE,              BASICS_AVAILABLE,
    S_ACCESS_HOTKEYACTIVE,           BASICS_HOTKEYACTIVE,
    S_ACCESS_CONFIRMHOTKEY,          BASICS_CONFIRMHOTKEY,
    S_ACCESS_HOTKEYSOUND,            BASICS_HOTKEYSOUND,
    S_ACCESS_SHOWSTATUSINDICATOR,    BASICS_INDICATOR,
    S_ACCESS_HOTKEYAVAILABLE,        HCF_HOTKEYAVAILABLE,
    NULL,                       0
};

DWORD
ConvertFlags (
    IN  LPCTSTR Object,
    IN  PACCESS_OPTION OptionArray
    )
{
    DATAOBJECT Ob;
    DWORD Flags;
    DWORD d;

    if (!CreateObjectStruct (Object, &Ob, WIN95OBJECT)) {
        LOG ((LOG_ERROR, "%s is not a valid object", Object));
        return 0;
    }

    if (!OpenObject (&Ob)) {
        DEBUGMSG ((DBG_WARNING, "%s does not exist", Object));
        return 0;
    }

    //
    // Get flag settings from Win95 registry and convert them to Flags
    //

    Flags = 0;

    while (OptionArray->ValueName) {
        SetRegistryValueName (&Ob, OptionArray->ValueName);

        if (GetDwordFromObject (&Ob, &d)) {
            //
            // Most flags are identical on Win9x and NT, but there's one
            // MouseKey flag that needs to be inverted.
            //

            if (OptionArray->FlagVal & SPECIAL_INVERT_OPTION) {
                if (!d) {
                    Flags |= (OptionArray->FlagVal & (~SPECIAL_INVERT_OPTION));
                }
            } else if (d) {
                Flags |= OptionArray->FlagVal;
            }
        }

        OptionArray++;
        FreeObjectVal (&Ob);
    }

    FreeObjectStruct (&Ob);

    return Flags;
}


BOOL
SaveAccessibilityFlags (
    IN  LPCTSTR ObjectStr,
    IN  DWORD dw
    )
{
    DATAOBJECT Ob;
    BOOL b = FALSE;
    TCHAR FlagBuf[32];

    SetLastError (ERROR_SUCCESS);

    if (!CreateObjectStruct (ObjectStr, &Ob, WINNTOBJECT)) {
        LOG ((LOG_ERROR, "Save Accessibility Flags: can't create object %s", ObjectStr));
        return FALSE;
    }

    if (!(Ob.ValueName)) {
        if (!SetRegistryValueName (&Ob, TEXT("Flags"))) {
            return FALSE;
        }
    } else {
        DEBUGMSG ((DBG_WARNING, "SaveAccessibilityFlags: Name already exists"));
    }

    wsprintf (FlagBuf, TEXT("%u"), dw);

    SetRegistryType (&Ob, REG_SZ);
    ReplaceValue (&Ob, (LPBYTE) FlagBuf, SizeOfString (FlagBuf));

    b = WriteObject (&Ob);

    FreeObjectStruct (&Ob);
    return b;
}


BOOL
pConvertFlagsAndSave (
    IN  LPCTSTR SrcObject,
    IN  LPCTSTR DestObject,
    IN  PACCESS_OPTION OptionArray,
    IN  DWORD ForceValues
    )
{
    DWORD d;

    d = ConvertFlags (SrcObject, OptionArray);
    if (!d) {
        return TRUE;
    }

    DEBUGMSG ((DBG_VERBOSE, "Setting %x and forcing %x for %s", d, ForceValues, DestObject));

    return SaveAccessibilityFlags (DestObject, d | ForceValues);
}



//
// Exported helper functions
//

BOOL
RuleHlpr_ConvertFilterKeys (
    IN      LPCTSTR SrcObjectStr,
    IN      LPCTSTR DestObjectStr,
    IN      LPCTSTR User,
    IN      LPVOID  Data
    )
{
    return pConvertFlagsAndSave (
                SrcObjectStr,
                DestObjectStr,
                g_FilterKeys,
                BASICS_HOTKEYSOUND | BASICS_CONFIRMHOTKEY | BASICS_AVAILABLE
                );
}



BOOL
RuleHlpr_ConvertOldDisabled (
    IN      LPCTSTR SrcObjectStr,
    IN      LPCTSTR DestObjectStr,
    IN      LPCTSTR User,
    IN      LPVOID  Data
    )
{
    DATAOBJECT Ob;
    DWORD Val;
    BOOL b = FALSE;

    if (!ReadWin95ObjectString (SrcObjectStr, &Ob)) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertOldDisabled failed because ReadWin95ObjectString failed"));
        goto c0;
    }

    //
    // Obtain Val from DWORD or string
    //

    if (!GetDwordFromObject (&Ob, &Val)) {
        goto c1;
    }

    // Our little fixup
    if (Val == 32760) {
        Val = 0;
    } else {
        b = TRUE;
        goto c1;
    }

    //
    // Regenerate registry value
    //

    if (Ob.Type == REG_DWORD) {
        *((PDWORD) Ob.Value.Buffer) = Val;
    } else {
        TCHAR NumStr[32];

        wsprintf (NumStr, TEXT("%u"), Val);
        if (!ReplaceValueWithString (&Ob, NumStr)) {
            goto c1;
        }
    }

    if (!WriteWinNTObjectString (DestObjectStr, &Ob)) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertOldDisabled failed because WriteWinNTObjectString failed"));
        goto c1;
    }

    b = TRUE;

c1:
    FreeObjectStruct (&Ob);
c0:
    return b;
}


BOOL
RuleHlpr_ConvertMouseKeys (
    IN      LPCTSTR SrcObjectStr,
    IN      LPCTSTR DestObjectStr,
    IN      LPCTSTR User,
    IN      LPVOID  Data
    )
{
    return pConvertFlagsAndSave (
                SrcObjectStr,
                DestObjectStr,
                g_MouseKeys,
                BASICS_HOTKEYSOUND | BASICS_CONFIRMHOTKEY | BASICS_AVAILABLE
                );
}


BOOL
RuleHlpr_ConvertStickyKeys (
    IN      LPCTSTR SrcObjectStr,
    IN      LPCTSTR DestObjectStr,
    IN      LPCTSTR User,
    IN      LPVOID  Data
    )
{
    return pConvertFlagsAndSave (
                SrcObjectStr,
                DestObjectStr,
                g_StickyKeys,
                BASICS_HOTKEYSOUND | BASICS_CONFIRMHOTKEY | BASICS_AVAILABLE
                );
}


BOOL
RuleHlpr_ConvertSoundSentry (
    IN      LPCTSTR SrcObjectStr,
    IN      LPCTSTR DestObjectStr,
    IN      LPCTSTR User,
    IN      LPVOID  Data
    )
{
    return pConvertFlagsAndSave (
                SrcObjectStr,
                DestObjectStr,
                g_SoundSentry,
                BASICS_AVAILABLE
                );
}


BOOL
RuleHlpr_ConvertTimeOut (
    IN      LPCTSTR SrcObjectStr,
    IN      LPCTSTR DestObjectStr,
    IN      LPCTSTR User,
    IN      LPVOID  Data
    )
{
    return pConvertFlagsAndSave (
                SrcObjectStr,

                DestObjectStr,
                g_TimeOut,
                0
                );
}


BOOL
RuleHlpr_ConvertToggleKeys (
    IN      LPCTSTR SrcObjectStr,
    IN      LPCTSTR DestObjectStr,
    IN      LPCTSTR User,
    IN      LPVOID  Data
    )
{
    return pConvertFlagsAndSave (
                SrcObjectStr,
                DestObjectStr,
                g_ToggleKeys,
                BASICS_HOTKEYSOUND | BASICS_CONFIRMHOTKEY | BASICS_AVAILABLE
                );
}


BOOL
RuleHlpr_ConvertHighContrast (
    IN      LPCTSTR SrcObjectStr,
    IN      LPCTSTR DestObjectStr,
    IN      LPCTSTR User,
    IN      LPVOID  Data
    )
{
    return pConvertFlagsAndSave (
                SrcObjectStr,
                DestObjectStr,
                g_HighContrast,
                BASICS_AVAILABLE | BASICS_CONFIRMHOTKEY |
                    BASICS_INDICATOR | HCF_HOTKEYAVAILABLE |
                    BASICS_HOTKEYSOUND
                );
}



BOOL
ValFn_Fonts (
    IN OUT  PDATAOBJECT ObPtr
    )

/*++

Routine Description:

  This routine uses the RuleHlpr_ConvertRegVal simplification routine.  See
  rulehlpr.c for details. The simplification routine does almost all the work
  for us; all we need to do is update the value.

  ValFn_Fonts compares the value data against the string table g_NtFontFiles
  to suppress copy of font names of files that NT installs.  This allows the
  font names to change.

Arguments:

  ObPtr - Specifies the Win95 data object as specified in wkstamig.inf,
          [Win9x Data Conversion] section. The object value is then modified.
          After returning, the merge code then copies the data to the NT
          destination, which has a new location (specified in wkstamig.inf,
          [Map Win9x to WinNT] section).

Return Value:

  Tri-state:

      TRUE to allow merge code to continue processing (it writes the value)
      FALSE and last error == ERROR_SUCCESS to continue, but skip the write
      FALSE and last error != ERROR_SUCCESS if an error occurred

--*/

{
    LONG rc;
    TCHAR FontName[MAX_TCHAR_PATH];
    PTSTR p;
    BOOL Check;
    DATAOBJECT NtObject;
    BOOL AlreadyExists;

    //
    // Require non-empty value data
    //

    if (!IsObjectRegistryKeyAndVal (ObPtr) ||
        !IsRegistryTypeSpecified (ObPtr) ||
        !ObPtr->Value.Size ||
        !g_NtFontFiles
        ) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    //
    // Ignore Win9x font entry if same value name exists on NT
    //

    if (!DuplicateObjectStruct (&NtObject, ObPtr)) {
        return FALSE;
    }

    DEBUGMSG ((DBG_VERBOSE, "Working on %s [%s]", ObPtr->KeyPtr->KeyString, ObPtr->ValueName));

    SetPlatformType (&NtObject, WINNTOBJECT);
    SetRegistryKey (&NtObject, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Fonts"));

    FreeObjectVal (&NtObject);

    DEBUGMSG ((DBG_VERBOSE, "Reading %s [%s]", NtObject.KeyPtr->KeyString, NtObject.ValueName));
    AlreadyExists = ReadObject (&NtObject);

    FreeObjectStruct (&NtObject);

    if (AlreadyExists) {
        DEBUGMSG ((DBG_VERBOSE, "[%s] Already exists", ObPtr->ValueName));
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    //
    // Look in string table for file name
    //

    rc = pSetupStringTableLookUpString (
             g_NtFontFiles,
             (PTSTR) ObPtr->Value.Buffer,
             STRTAB_CASE_INSENSITIVE
             );

    if (rc == -1) {
        //
        // Check for TTF/TTC match
        //

        _tcssafecpy (FontName, (PCTSTR) ObPtr->Value.Buffer, MAX_TCHAR_PATH);
        p = _tcschr (FontName, TEXT('.'));

        if (p) {
            p = _tcsinc (p);

            if (StringIMatch (p, TEXT("TTF"))) {
                StringCopy (p, TEXT("TTC"));
                Check = TRUE;
            } else if (StringIMatch (p, TEXT("TTC"))) {
                StringCopy (p, TEXT("TTF"));
                Check = TRUE;
            } else {
                Check = FALSE;
            }

            if (Check) {
                rc = pSetupStringTableLookUpString (
                         g_NtFontFiles,
                         FontName,
                         STRTAB_CASE_INSENSITIVE
                         );
            }
        }
    }

    if (rc == -1) {
        //
        // Check for an NT font named FONTU.TTF or FONTU.TTC
        //

        _tcssafecpy (FontName, (PCTSTR) ObPtr->Value.Buffer, MAX_TCHAR_PATH);
        p = _tcschr (FontName, TEXT('.'));

        if (p) {
            StringCopy (p, TEXT("U.TTF"));

            rc = pSetupStringTableLookUpString (
                     g_NtFontFiles,
                     FontName,
                     STRTAB_CASE_INSENSITIVE
                     );

            if (rc == -1) {
                StringCopy (p, TEXT("U.TTC"));

                rc = pSetupStringTableLookUpString (
                         g_NtFontFiles,
                         FontName,
                         STRTAB_CASE_INSENSITIVE
                         );
            }
        }
    }

    if (rc != -1) {
        //
        // Font name was in the table, so don't add it twice
        //
        DEBUGMSG ((DBG_NAUSEA, "Suppressing Win9x font registration for %s", ObPtr->Value.Buffer));
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    } else {
        DEBUGMSG ((DBG_VERBOSE, "[%s] Preserving Win9x font info: %s", ObPtr->ValueName, (PCTSTR) ObPtr->Value.Buffer));
    }

    return TRUE;
}


BOOL
ValFn_AntiAlias (
    IN OUT  PDATAOBJECT ObPtr
    )

/*++

Routine Description:

  This routine uses the RuleHlpr_ConvertRegVal simplification routine.  See
  rulehlpr.c for details. The simplification routine does almost all the work
  for us; all we need to do is update the value.

  ValFn_AntiAlias changes a 1 to a 2.  Win9x uses 1, but NT uses FE_AA_ON,
  which is currently 2.

Return Value:

  Tri-state:

      TRUE to allow merge code to continue processing (it writes the value)
      FALSE and last error == ERROR_SUCCESS to continue, but skip the write
      FALSE and last error != ERROR_SUCCESS if an error occurred

--*/

{
    TCHAR Number[8];

    //
    // Require non-empty REG_SZ
    //

    if (!IsObjectRegistryKeyAndVal (ObPtr) ||
        !IsRegistryTypeSpecified (ObPtr) ||
        !ObPtr->Value.Size ||
        !g_NtFontFiles ||
        ObPtr->Type != REG_SZ
        ) {
        DEBUGMSG ((DBG_WARNING, "ValFn_AntiAlias: Data is not valid"));
        ReplaceValueWithString (ObPtr, TEXT("0"));
    }

    else if (_ttoi ((PCTSTR) ObPtr->Value.Buffer)) {
        DEBUGMSG ((DBG_NAUSEA, "Switching anti-alias value from 1 to %u", FE_AA_ON));
        wsprintf (Number, TEXT("%u"), FE_AA_ON);
        ReplaceValueWithString (ObPtr, Number);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\rulehlpr\explorer.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    explorer.c

Abstract:

    Explorer-related converters

    Explorer-related conversion functions needed to convert
    MRU lists and other structures are implemented here.

Author:

    Jim Schmidt (jimschm) 9-Aug-1996

Revision History:

    Calin Negreanu  (calinn)  04-Mar-1998  Minor bug in ConvertCommandToCmd
    Jim Schmidt     (jimschm) 20-Feb-1998  Added ValFn_ModuleUsage

--*/


#include "pch.h"

#include <mbstring.h>
#include <shlobj.h>


#define S_OWNER     TEXT(".Owner")

typedef struct {
    // Link structure
    WORD wSize;
    //ITEMIDLIST idl; // variable-length struct
    // String, plus three bytes appended to struct
} LINKSTRUCT, *PLINKSTRUCT;

//
// This list of extensions is ordered in the way Win9x processes extensions
//
static PCTSTR g_RunMruExtensions[] = {
                    TEXT("PIF"),
                    TEXT("COM"),
                    TEXT("EXE"),
                    TEXT("BAT"),
                    TEXT("LNK"),
                    NULL
                    };

BOOL
ValFn_ConvertRecentDocsMRU (
    IN      PDATAOBJECT ObPtr
    )
{
    LPSTR str, strEnd;
    PLINKSTRUCT pls95, plsNT;
    DWORD dwStrSize, dwSize;
    DWORD dwNewSize, dwLinkSize;
    PWSTR wstr, wstrEnd;
    BOOL b;

    // Skip MRUList
    MYASSERT(ObPtr->ValueName);
    if (StringIMatch (ObPtr->ValueName, TEXT("MRUList"))) {
        return TRUE;
    }

    // Calculate all the pointers to this nasty struct
    str = (LPSTR) ObPtr->Value.Buffer;
    strEnd = GetEndOfStringA (str);
    strEnd = _mbsinc (strEnd);
    dwStrSize = (DWORD) strEnd - (DWORD) str;
    pls95 = (PLINKSTRUCT) strEnd;
    dwLinkSize = pls95->wSize + sizeof (WORD);
    dwSize = dwStrSize + dwLinkSize;

    // Make sure the key is the struct we expect
    if (dwSize != ObPtr->Value.Size) {
        SetLastError (ERROR_SUCCESS);   // ignore this error

        DEBUGMSG ((
            DBG_NAUSEA,
            "ValFn_ConvertRecentDocsMRU failed because size was not correct.  "
                   "%u should have been %u",
            ObPtr->Value.Size,
            dwSize
            ));

        return FALSE;
    }

    // Calc UNICODE size & alloc a new buffer
    dwNewSize = (CharCountA (str) + 1) * sizeof (WCHAR);
    dwNewSize += dwLinkSize;

    wstr = (PWSTR) PoolMemGetMemory (g_TempPool, dwNewSize);
    if (!wstr) {
        return FALSE;
    }

    // Fill new buffer with converted struct
    MultiByteToWideChar (OurGetACP(),
                         0,
                         str,
                         -1,
                         wstr,
                         dwNewSize);

    wstrEnd = GetEndOfStringW (wstr) + 1;
    plsNT = (PLINKSTRUCT) ((LPBYTE) wstr + ((DWORD) wstrEnd - (DWORD) wstr));
    CopyMemory (plsNT, pls95, dwLinkSize);

    b = ReplaceValue (ObPtr, (LPBYTE) wstr, dwNewSize);

    PoolMemReleaseMemory (g_TempPool, wstr);
    return b;
}


BOOL
ConvertCommandToCmd (
    PCTSTR InputLine,
    PTSTR CmdLine
    )
{
    PCTSTR p, q;
    PCTSTR end;
    PTSTR dest;
    BOOL QuoteMode;
    TCHAR Redirect[256];
    int ParamsToCopy = 0;
    int ParamsToSkip = 0;
    int ParamNum;

    p = InputLine;

    //
    // Parse command line
    //

    p += 7; // skip "command"
    if (StringIMatchCharCount (p, TEXT(".com"), 4)) {
        p += 4;
    }

    if (_tcsnextc (p) == TEXT('\\') || !(*p)) {
        //
        // no params case
        //
        wsprintf (CmdLine, TEXT("cmd%s"), p);
    } else if (*p == TEXT(' ')) {
        //
        // Extract all params
        //
        StringCopy (CmdLine, TEXT("cmd.exe"));
        Redirect[0] = 0;
        ParamNum = 0;

        do {
            // Skip leading spaces
            p = SkipSpace (p);

            // Command line option
            if (*p == TEXT('-') || *p == TEXT('/')) {
                ParamsToCopy = 0;
                ParamsToSkip = 0;

                // Test multi-character options
                if (StringIMatchCharCount (&p[1], TEXT("msg"), 3) ||
                    StringIMatchCharCount (&p[1], TEXT("low"), 3)
                    ) {
                    // These are obsolete options
                    ParamsToSkip = 1;
                }

                // Test single-character options
                else {

                    switch (_totlower (p[1])) {
                    case 'c':
                    case 'k':
                        // These are compatible options - copy to command line
                        ParamsToCopy = -1;
                        break;

                    case '>':
                    case '<':
                        // Redirection is supported
                        ParamsToCopy = -1;  // rest of line
                        break;

                    case 'e':
                    case 'l':
                    case 'u':
                    case 'p':
                        // These are obsolete options
                        ParamsToSkip = 1;
                        break;

                    case 'y':
                        // These options really require command.com, not cmd.exe
                        return FALSE;
                    default:
                        ParamsToSkip = 1;
                        break;
                    }
                }
            } /* if p is a dash or slash */

            // Else it's a directory containing command.com, device redirection or syntax error
            else {
                if (ParamNum == 0) {

                    //
                    // Directory containing command.com - obsolete
                    //

                    ParamsToCopy = 0;
                    ParamsToSkip = 1;

                } else if (ParamNum == 1) {

                    //
                    // Extract redirection command
                    //

                    ParamNum++;
                    end = p;
                    while (*end && _tcsnextc (end) != TEXT(' ') && _tcsnextc (end) != TEXT('\\')) {
                        end = _tcsinc (end);
                    }
                    StringCopyAB (Redirect, p, end);
                    p = end;
                } else {
                    // Unexpected, perhaps a syntax error -- leave this line alone
                    return FALSE;
                }
            }

            // Copy rest of line
            if (ParamsToCopy == -1) {
                if (CmdLine[0]) {
                    StringCat (CmdLine, TEXT(" "));
                }

                StringCat (CmdLine, p);
                p = GetEndOfString (p);
            }

            // Copy one or more params
            else {
                while (ParamsToCopy > 0) {
                    QuoteMode = FALSE;
                    q = p;

                    while (*q) {
                        if (_tcsnextc (q) == TEXT('\"')) {
                            QuoteMode = !QuoteMode;
                        } else if (!QuoteMode && _tcsnextc (q) == TEXT(' ')) {
                            break;
                        }

                        q = _tcsinc (q);
                    }

                    ParamNum++;

                    if (CmdLine[0]) {
                        StringCat (CmdLine, TEXT(" "));
                    }

                    StringCopyAB (GetEndOfString (CmdLine), p, q);
                    p = q;

                    ParamsToCopy--;
                }
            }

            while (ParamsToSkip > 0) {
                QuoteMode = FALSE;
                q = p;

                while (*q) {
                    if (_tcsnextc (q) == TEXT('\"')) {
                        QuoteMode = !QuoteMode;
                    } else if (!QuoteMode && _tcsnextc (q) == TEXT(' ')) {
                        break;
                    }

                    q = _tcsinc (q);
                }

                ParamNum++;
                p = q;
                ParamsToSkip--;
            }
        } while (*p);

        if (Redirect[0]) {
            TCHAR WackNum[8];

            // Look for \1 in cmd line (made by Explorer)
            WackNum[0] = 0;
            dest = _tcsrchr (CmdLine, TEXT('\\'));
            if (*dest) {
                if (_istdigit ((CHARTYPE) _tcsnextc (_tcsinc (dest)))) {
                    if (!(*(_tcsinc (_tcsinc (dest))))) {
                        StringCopy (WackNum, dest);
                        *dest = 0;
                    }
                }
            }

            wsprintf (GetEndOfString (CmdLine), TEXT(" >%s <%s%s"),
                      Redirect, Redirect, WackNum);
        }
    } else {
        //
        // not command or command.com
        //
        return FALSE;
    }

    return TRUE;
}


BOOL
ValFn_ConvertRunMRU (
    IN      PDATAOBJECT ObPtr
    )
{
    PCTSTR p;
    TCHAR CmdLine[1024];
    GROWBUFFER NewCmdLine = GROWBUF_INIT;
    GROWBUFFER GrowBuf = GROWBUF_INIT;
    PCMDLINE ParsedCmdLine;
    UINT u;
    DWORD Status;
    PCTSTR NewPath;
    BOOL Quotes;
    BOOL b = TRUE;
    PTSTR CmdLineCopy;
    PTSTR WackOne;
    PTSTR Dot;
    PTSTR Ext;
    INT i;
    PCTSTR MatchingArg;

    // Skip MRUList
    MYASSERT(ObPtr->ValueName);
    if (StringIMatch (ObPtr->ValueName, TEXT("MRUList"))) {
        return TRUE;
    }

    //
    // Convert command to cmd
    //

    p = (PCTSTR) ObPtr->Value.Buffer;
    if (StringIMatchCharCount (p, TEXT("command"), 7)) {
        //
        // Convert command.com to cmd.exe
        //

        if (ConvertCommandToCmd (p, CmdLine)) {
            // If able to convert, update the line
            b = ReplaceValueWithString (ObPtr, CmdLine);
        }

    } else {
        //
        // Look at each arg for paths to moved files, and fix them.
        //

        CmdLineCopy = DuplicateText ((PCTSTR) ObPtr->Value.Buffer);
        WackOne = _tcsrchr (CmdLineCopy, TEXT('\\'));

        if (WackOne && WackOne[1] == TEXT('1') && WackOne[2] == 0) {
            *WackOne = 0;
        } else {
            WackOne = NULL;
        }

        ParsedCmdLine = ParseCmdLine (CmdLineCopy, &GrowBuf);

        if (ParsedCmdLine) {

            for (u = 0 ; u < ParsedCmdLine->ArgCount ; u++) {

                if (u) {
                    GrowBufAppendString (&NewCmdLine, TEXT(" "));
                }

                MatchingArg = ParsedCmdLine->Args[u].CleanedUpArg;

                if (!_tcschr (ParsedCmdLine->Args[u].OriginalArg, TEXT('\\'))) {
                    Status = FILESTATUS_UNCHANGED;
                } else {

                    Status = GetFileStatusOnNt (MatchingArg);

                    if ((Status & FILESTATUS_MOVED) == 0) {

                        //
                        // If the true path didn't match, try various extensions
                        //

                        _tcssafecpy (CmdLine, MatchingArg, (sizeof (CmdLine) - 10) / sizeof (TCHAR));
                        Dot = _tcsrchr (CmdLine, TEXT('.'));
                        if (!Dot || _tcschr (Dot, TEXT('\\'))) {
                            Dot = GetEndOfString (CmdLine);
                        }

                        *Dot = TEXT('.');
                        Ext = Dot + 1;

                        MatchingArg = CmdLine;

                        for (i = 0 ; g_RunMruExtensions[i] ; i++) {

                            StringCopy (Ext, g_RunMruExtensions[i]);

                            Status = GetFileStatusOnNt (MatchingArg);
                            if (Status & FILESTATUS_MOVED) {
                                break;
                            }
                        }
                    }
                }

                if (Status & FILESTATUS_MOVED) {
                    NewPath = GetPathStringOnNt (MatchingArg);

                    Quotes = FALSE;
                    if (_tcschr (NewPath, TEXT('\"'))) {
                        Quotes = TRUE;
                        GrowBufAppendString (&NewCmdLine, TEXT("\""));
                    }

                    GrowBufAppendString (&NewCmdLine, NewPath);
                    FreePathStringW (NewPath);

                } else {
                    GrowBufAppendString (&NewCmdLine, ParsedCmdLine->Args[u].OriginalArg);
                }
            }

            if (WackOne) {
                GrowBufAppendString (&NewCmdLine, TEXT("\\1"));
            }

            b = ReplaceValueWithString (ObPtr, (PCTSTR) NewCmdLine.Buf);
            FreeGrowBuffer (&NewCmdLine);
        }

        FreeText (CmdLineCopy);
    }

    FreeGrowBuffer (&GrowBuf);

    return b;
}



BOOL
ValFn_ModuleUsage (
    IN OUT  PDATAOBJECT ObPtr
    )

/*++

Routine Description:

  This routine uses the RuleHlpr_ConvertRegVal simplification routine.  See
  rulehlpr.c for details. The simplification routine does almost all the work
  for us; all we need to do is update the value.

  ValFn_ModuleUsage determines if the registry object should be changed,
  so it is merged with the NT settings.  The algorithm is:

  1. Get GUID and file name from object
  2. If file name is already registred, add another value entry
  3. If file name is not already registred, add it and make an .Owner entry

Arguments:

  ObPtr - Specifies the Win95 data object as specified in wkstamig.inf,
          [Win9x Data Conversion] section. The object value is then modified.
          After returning, the merge code then copies the data to the NT
          destination, which has a new location (specified in wkstamig.inf,
          [Map Win9x to WinNT] section).

Return Value:

  Tri-state:

      TRUE to allow merge code to continue processing (it writes the value)
      FALSE and last error == ERROR_SUCCESS to continue, but skip the write
      FALSE and last error != ERROR_SUCCESS if an error occurred

--*/

{
    TCHAR FileName[MAX_TCHAR_PATH];
    TCHAR Guid[64];
    PTSTR p;
    TCHAR KeyStr[MAX_REGISTRY_KEY];
    HKEY Key;
    PCTSTR Data;

    //
    // Skip no-value keys
    //

    if (!IsObjectRegistryKeyAndVal (ObPtr) ||
        !IsRegistryTypeSpecified (ObPtr) ||
        !ObPtr->Value.Size
        ) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    //
    // Step 1: Extract GUID and file name
    //

    // File name is the subkey name
    StackStringCopy (FileName, ObPtr->KeyPtr->KeyString);

    // Convert backslashes to foreslashes
    p = _tcschr (FileName, TEXT('\\'));
    while (p) {
        *p = TEXT('/');
        p = _tcschr (_tcsinc (p), TEXT('\\'));
    }

    // GUID is the value
    if (ObPtr->Type != REG_SZ && ObPtr->Type != REG_EXPAND_SZ) {
        SetLastError (ERROR_SUCCESS);
        DEBUGMSG ((DBG_WARNING, "Skipping non-string value for key %s", FileName));
        return FALSE;
    }

    _tcssafecpy (Guid, ObPtr->ValueName, sizeof(Guid)/sizeof(Guid[0]));

    // If Guid is .Owner, then GUID is value data
    if (StringIMatch (Guid, S_OWNER)) {
        _tcssafecpy (Guid, (PCTSTR) ObPtr->Value.Buffer, sizeof(Guid)/sizeof(Guid[0]));
    }


    //
    // Step 2: Does NT key already exist?
    //

    wsprintf (
        KeyStr,
        TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\ModuleUsage\\%s"),
        FileName
        );

    Key = OpenRegKeyStr (KeyStr);

    if (Key) {
        //
        // Yes, look for .Owner
        //

        Data = GetRegValueString (Key, S_OWNER);
        if (!Data) {
            //
            // .Owner does not exist, assume key is empty, and re-create it
            //

            CloseRegKey (Key);
            Key = NULL;
        } else {
            MemFree (g_hHeap, 0, Data);
        }
    }

    //
    // Step 3: If NT key does not exist or has no owner, create the initial
    //         usage reference, otherwise add non-owner reference entry
    //

    if (!Key) {
        //
        // Key does not exist or does not have owner.  Create it.
        //

        Key = CreateRegKeyStr (KeyStr);
        if (!Key) {
            LOG ((LOG_ERROR, "Can't create %s", KeyStr));
            SetLastError (ERROR_SUCCESS);
            return FALSE;
        }

        // Add .Owner entry
        RegSetValueEx (Key, S_OWNER, 0, REG_SZ, (PBYTE) Guid, SizeOfString (Guid));

    } else {
        //
        // .Owner does exist, just add GUID as a value (with no value data)
        //

        RegSetValueEx (Key, Guid, 0, REG_SZ, (PBYTE) S_EMPTY, sizeof (TCHAR));
    }

    CloseRegKey (Key);

    SetLastError (ERROR_SUCCESS);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\rulehlpr\net.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    net.c

Abstract:

    Network connection setting conversions

Author:

    Jim Schmidt (jimschm) 03-Jan-1997

Revision History:

--*/


#include "pch.h"
#include "memdb.h"
#include "msg.h"

#include <mpr.h>            // in private\inc

#define DBG_NET "Net"


//
// Structs
//

typedef struct {
    PCTSTR User;
} NETCONNFILTERARG, *PNETCONNFILTERARG;


//
// Import function
//

typedef DWORD (* I_MPRSAVECONN) (
    IN HKEY             HiveRoot,
    IN PCWSTR           ProviderName,
    IN DWORD            ProviderType,
    IN PCWSTR           UserName,
    IN PCWSTR           LocalName,
    IN PCWSTR           RemoteName,
    IN DWORD            ConnectionType,
    IN BYTE             ProviderFlags,
    IN DWORD            DeferFlags
    );


DWORD
pMprSaveConn(
    IN HKEY             HiveRoot,
    IN PCWSTR           ProviderName,
    IN DWORD            ProviderType,
    IN PCWSTR           UserName,
    IN PCWSTR           LocalName,
    IN PCWSTR           RemoteName,
    IN DWORD            ConnectionType,
    IN BYTE             ProviderFlags,
    IN DWORD            DeferFlags
    )

/*++

Routine Description:

    This routine wraps the internal routine I_MprSaveConn that is exported from
    mpr.dll.

    I_MprSaveConn was written to support the migration code.  It writes the
    information about a connection to the network connection section of a
    user's registry path.

    NOTE:  If connection information is already stored in the registry for
    this drive, the current information will be overwritten with the new
    information.

Arguments:

    HiveRoot - A handle to the root of the user hive in which this information
    should be written, such as HKEY_CURRENT_USER.

    ProviderName - The provider that completed the connection.

    ProviderType - The provider type, if known.  If not known, zero should
        be passed, and a type will not be written to the registry.  (This
        is used by setup when upgrading from Win95 to NT.)

    UserName - The name of the user on whose behalf the connection was made.

    LocalName - The name of the local device that is redirected,  with or without a
        trailing colon, such as "J:" or "J" or "LPT1:" or "LPT1".

    RemoteName - The network path to which the connection was made.

    ConnectionType - either RESOURCETYPE_DISK or RESOURCETYPE_PRINT.

    ProviderFlags - A byte of data to be saved along with the connection, and
        passed back to the provider when the connection is restored.

    DeferFlags - A DWORD to be saved in the connection's "Defer" value.  If
        this is zero, the value is not stored.
        The meaning of the bits of this DWORD are as follows:
        DEFER_EXPLICIT_PASSWORD - a password was explicitly specified when
        the connection was made.
        DEFER_UNKNOWN - it is not known whether a password was explicitly
        specified when the connection was made.

Return Value:

    ERROR_SUCCESS - If the operation was successful.

    Other Win32 errors - If the operation failed in any way.  If a failure occurs, the
            information is not stored in the registry.

--*/

{
    HINSTANCE hMprInst;
    I_MPRSAVECONN fn;
    DWORD rc;

    hMprInst = LoadLibrary (TEXT("mpr.dll"));
    if (!hMprInst) {
        LOG ((LOG_ERROR, "Cannot load mpr.dll"));
        return GetLastError();
    }

    fn = (I_MPRSAVECONN) GetProcAddress (hMprInst, "I_MprSaveConn");    // ANSI string!
    if (!fn) {
        LOG ((LOG_ERROR, "I_MprSaveConn is not in mpr.dll"));
        rc = GetLastError();
    } else {
        rc = fn (HiveRoot, ProviderName, ProviderType, UserName, LocalName,
                 RemoteName, ConnectionType, ProviderFlags, DeferFlags);
    }

    FreeLibrary (hMprInst);

    return rc;
}


BOOL
pNetConnGetValue (
    IN OUT  PDATAOBJECT Win95ObPtr,
    IN      PCTSTR ValueName,
    OUT     PTSTR Buffer,
    IN      PCTSTR LocalName           // debug messages only
    )

/*++

Routine Description:

  This function retrieves a caller-specified value that exists in the network
  connection registry.

Arguments:

  Win95ObPtr    - Specifies the Win95 registry hive and key.  It is updated
                  via ReadObject.

  ValueName     - Specifies the value to query

  Buffer        - Receives the registry contents for the specified value name,
                  must be at least MAX_TCHAR_PATH characters big.

  LocalName     - Specifies the local share name (for messages only)

Return Value:

  TRUE if successful.

--*/

{
    SetRegistryValueName (Win95ObPtr, ValueName);
    FreeObjectVal (Win95ObPtr);

    if (ReadObject (Win95ObPtr)) {
        MYASSERT (Win95ObPtr->ObjectType & OT_REGISTRY_TYPE);

        if (Win95ObPtr->Type == REG_SZ) {
            _tcssafecpy (Buffer, (PCTSTR) Win95ObPtr->Value.Buffer, MAX_TCHAR_PATH);
            if (!Buffer[0]) {

                DEBUGMSG ((DBG_WARNING, "NetConnFilter: %s has an empty %s value", LocalName, ValueName));
            }
        } else {
            DEBUGMSG ((DBG_WARNING, "NetConnFilter: %s for %s not REG_SZ", ValueName, LocalName));
        }
    } else {
        DEBUGMSG ((DBG_WARNING, "NetConnFilter: %s for %s cannot be read", ValueName, LocalName));
    }

    return Buffer[0] != 0;
}


VOID
pConvertProviderName (
    IN OUT  PTSTR Name
    )

/*++

Routine Description:

  This function translates Win9x provider names into WinNT equivalents.  Currently
  the only supported provider is Microsoft Network (LANMAN).

Arguments:

  Name      - Specifies name to translate and must be big enough to receive the
              translated name.

Return Value:

  TRUE if successful.

--*/

{
    INFCONTEXT ic;
    TCHAR NameBuf[MAX_TCHAR_PATH];

    //
    // Scan list of redirector mappings to begin using a new name
    //

    if (SetupFindFirstLine (g_WkstaMigInf, S_WKSTAMIG_REDIR_MAPPING, NULL, &ic)) {
        do {
            if (SetupGetStringField (&ic, 0, NameBuf, MAX_TCHAR_PATH, NULL)) {
                if (StringIMatch (Name, NameBuf)) {
                    if (SetupGetStringField (&ic, 1, NameBuf, MAX_TCHAR_PATH, NULL)) {
                        StringCopy (Name, NameBuf);
                        break;
                    }
                }
            }
        } while (SetupFindNextLine (&ic, &ic));
    }
}


FILTERRETURN
NetConnFilter (
    IN      CPDATAOBJECT SrcObjectPtr,
    IN      CPDATAOBJECT DestObjectPtr,
    IN      FILTERTYPE   FilterType,
    IN      PVOID        FilterArg
    )

/*++

Routine Description:

  NetConnFilter is called for each registry key in the network connection settings.
  It converts each network connection and saves it to the NT registry.

Arguments:

  SrcObjectPtr      - Specifies Win9x registry key being enumerated (copy source)

  DestObjectPtr     - Specifies WinNT registry key (copy destination)

  FilterType        - Specifies the reason the filter is being called

  FilterArg         - Caller's arg passed in to CopyObject

Return Value:

  FILTER_RETURN_FAIL for failures
  FILTER_RETURN_CONTINUE to proceed to next value or key
  FILTER_RETURN_HANDLED to skip default registry copy

--*/

{
    PNETCONNFILTERARG ArgStruct = (PNETCONNFILTERARG) FilterArg;

    if (FilterType == FILTER_PROCESS_VALUES) {

        //
        // Do not process this value for local Administrator account,
        // logon account or Default User
        //

        if (!g_DomainUserName) {
            return FILTER_RETURN_HANDLED;
        }

        if (StringIMatch (g_DomainUserName, g_AdministratorStr)) {
            return FILTER_RETURN_HANDLED;
        }

        if (StringMatch (g_DomainUserName, S_DEFAULT_USER)) {
            return FILTER_RETURN_HANDLED;
        }

        //
        // Re-establish drive mappings (unless child key is not empty, meaning
        // we are in some bogus subkey).
        //

        if (SrcObjectPtr->ChildKey) {
            DATAOBJECT Win95Ob;
            PCTSTR LocalName;
            TCHAR ProviderName[MAX_TCHAR_PATH];
            TCHAR RemotePath[MAX_TCHAR_PATH];
            TCHAR UserName[MAX_TCHAR_PATH];
            PCTSTR p;
            DWORD rc;

            ZeroMemory (&Win95Ob, sizeof (Win95Ob));

            __try {

                if (!DuplicateObjectStruct (&Win95Ob, SrcObjectPtr)) {
                    __leave;       // out of memory
                }

                MYASSERT (IsWin95Object (SrcObjectPtr));
                MYASSERT (SrcObjectPtr->KeyPtr);
                MYASSERT (SrcObjectPtr->KeyPtr->KeyString);
                MYASSERT (SrcObjectPtr->ChildKey);

                //
                // Make LocalName point to registry key name (i.e. the drive letter)
                //

                LocalName = SrcObjectPtr->ChildKey;

                //
                // Obtain provider name
                //

                ProviderName[0] = 0;
                if (!pNetConnGetValue (&Win95Ob, TEXT("ProviderName"), ProviderName, LocalName)) {
                    __leave;
                }

                //
                // Convert Win9x provider name to NT provider name
                //

                pConvertProviderName (ProviderName);

                //
                // Obtain remote path
                //

                RemotePath[0] = 0;
                if (!pNetConnGetValue (&Win95Ob, TEXT("RemotePath"), RemotePath, LocalName)) {
                    __leave;
                }

                //
                // Obtain user name
                //

                StringCopy (UserName, ArgStruct->User);
                if (!pNetConnGetValue (&Win95Ob, TEXT("UserName"), UserName, LocalName)) {
                    __leave;
                }

                p = _tcschr (ArgStruct->User, TEXT('\\'));
                if (p) {
                    // If share user is the same as current user and there is a domain version,
                    // use the domain version
                    p = _tcsinc (p);
                    if (StringIMatch (UserName, p)) {
                        StringCopy (UserName, ArgStruct->User);
                    }
                }

                //
                // Now create NT mapping
                //

                DEBUGMSG ((DBG_NET, "Adding net mapping for %s=%s", LocalName, RemotePath));

                rc = pMprSaveConn (g_hKeyRootNT,
                                   ProviderName,
                                   0,                  // we do not know provider type
                                   UserName,
                                   LocalName,
                                   RemotePath,
                                   TcharCount (LocalName) == 1 ? RESOURCETYPE_DISK : RESOURCETYPE_PRINT,
                                   0,
                                   DEFER_UNKNOWN       // may or may not require a password
                                   );

                if (rc != ERROR_SUCCESS) {
                    SetLastError (rc);
                    LOG ((LOG_ERROR, "Failed to save %s (%s)", LocalName, RemotePath));
                }
            }
            __finally {
                FreeObjectStruct (&Win95Ob);
            }
        }
        ELSE_DEBUGMSG ((DBG_WARNING, "NetConnFilter: ChildKey is empty for %s",
                        SrcObjectPtr->KeyPtr->KeyString));

        return FILTER_RETURN_HANDLED;

    } else if (FilterType == FILTER_CREATE_KEY) {

        return FILTER_RETURN_HANDLED;
    }

    return FILTER_RETURN_CONTINUE;
}


VOID
pAddToPersistentList (
    IN      PCTSTR PersistentItem,
    IN      PCTSTR UserKeyStr          // reg key off of HKR
    )

/*++

Routine Description:

  Creates a persistent connection entry, using the standard persistent list
  format.  A persistent list has entries from a to z, and an order key that
  specifies the order of the entries.  This routine finds the next available
  a to z entry and appends it to the order string.

Arguments:

  PersistentItem - Specifies the value data for the a through z registry
                   key

  UserKeyStr     - Specifies the subkey where the persistent list is stored.
                   It does not include HKR.

Return Value:

  none -- errors are ignored

--*/

{
    //
    // Find a letter that is not used yet
    //

    HKEY PersistentConnections;
    TCHAR HighLetter[2];
    LPBYTE Data;
    TCHAR Order[MAX_TCHAR_PATH];
    LONG rc;

    DEBUGMSG ((DBG_NET, "Adding %s to peristent list (HKR\\%s)", PersistentItem, UserKeyStr));

    PersistentConnections = CreateRegKey (g_hKeyRootNT, UserKeyStr);
    if (!PersistentConnections) {
        return;
    }

    HighLetter[0] = TEXT('a');
    HighLetter[1] = 0;

    // Find unused letter
    do {
        Data = GetRegValueData (PersistentConnections, HighLetter);
        if (Data) {
            MemFree (g_hHeap, 0, Data);
            HighLetter[0] += 1;
        }
    } while (Data && HighLetter[0] <= TEXT('z'));

    if (Data) {
        DEBUGMSG ((DBG_VERBOSE, "pAddToPersistentList: Could not find a free letter"));
        return;
    }

    rc = RegSetValueEx (PersistentConnections, HighLetter, 0, REG_SZ,
                        (LPBYTE) PersistentItem, SizeOfString (PersistentItem));
    SetLastError (rc);

    if (rc == ERROR_SUCCESS) {
        //
        // Open Order key and append HighLetter to it
        //

        Data = GetRegValueData (PersistentConnections, S_ORDER);
        if (Data) {
            StringCopy (Order, (PCTSTR) Data);
            MemFree (g_hHeap, 0, Data);
        } else {
            Order[0] = 0;
        }

        StringCat (Order, HighLetter);

        rc = RegSetValueEx (PersistentConnections, S_ORDER, 0, REG_SZ,
                            (LPBYTE) Order, SizeOfString (Order));
        SetLastError (rc);

        if (rc != ERROR_SUCCESS) {
            LOG ((LOG_ERROR, "Persistent Connections: Could not set %s=%s", S_ORDER, Order));
        }
    }
    ELSE_DEBUGMSG ((DBG_WARNING, "pAddToPersistentList: Could not set %s=%s", HighLetter, PersistentItem));

    CloseRegKey (PersistentConnections);
}


FILTERRETURN
PersistentConnFilter (
    IN      CPDATAOBJECT SrcObjectPtr,
    IN      CPDATAOBJECT DestObjectPtr,
    IN      FILTERTYPE   FilterType,
    IN      PVOID        FilterArg
    )

/*++

Routine Description:

  PersistentConnFilter is called once per persistent connection item.  It converts
  each item into the NT format and saves the converted item to the NT registry.

Arguments:

  SrcObjectPtr      - Specifies Win9x registry key being enumerated (copy source)

  DestObjectPtr     - Specifies WinNT registry key (copy destination)

  FilterType        - Specifies the reason the filter is being called

  FilterArg         - Caller's arg passed in to CopyObject

Return Value:

  FILTER_RETURN_FAIL for failures
  FILTER_RETURN_HANDLED to skip all sub keys, values, etc.

--*/

{
    if (FilterType == FILTER_KEY_ENUM && SrcObjectPtr->ChildKey) {
        //
        // Do not process this value for local Administrator account
        //

        if (g_DomainUserName && StringIMatch (g_DomainUserName, g_AdministratorStr)) {
            return FILTER_RETURN_HANDLED;
        }

        //
        // The Win95 code stores connections as
        // ././computer./share..name (dot is used for escaping)
        //
        // NT stores connections as \\computer\share and does not
        // need things like provider, user name or whatever nonsense
        // Win95 is storing.
        //

        if (SrcObjectPtr->ChildKey &&
            SrcObjectPtr->ChildKey[0] == TEXT('.') &&
            SrcObjectPtr->ChildKey[1] == TEXT('/') &&
            TcharCount (SrcObjectPtr->ChildKey) < 64
            ) {
            TCHAR TranslatedShareName[MAX_TCHAR_PATH];
            PCTSTR p;
            PTSTR Dest;

            p = SrcObjectPtr->ChildKey;
            Dest = TranslatedShareName;

            while (*p) {
                if (_tcsnextc (p) == TEXT('.')) {
                    p = _tcsinc (p);
                    if (!(*p)) {
                        break;
                    }
                }

                if (_tcsnextc (p) == TEXT('/')) {
                    *Dest = TEXT('\\');
                } else {
                    _copytchar (Dest, p);
                }

                Dest = _tcsinc (Dest);
                p = _tcsinc (p);
            }

            *Dest = 0;

            if (Dest) {
                pAddToPersistentList (TranslatedShareName, S_PERSISTENT_CONNECTIONS);
            }
        }
    }

    return FILTER_RETURN_HANDLED;
}


BOOL
RuleHlpr_CreateNetMappings (
    IN      PCTSTR SrcObjectStr,
    IN      PCTSTR DestObjectStr,
    IN      PCTSTR User,
    IN      PVOID Data
    )

/*++

Routine Description:

  This function is an enumerated rule helper callback that copies network mappings.
  It is called for each network mapping using the key enumeration in rulehlpr.c.

Arguments:

  SrcObjectStr      - Specifies Win9x registry key being enumerated (copy source)

  DestObjectStr     - Specifies WinNT registry key (copy destination)

  User              - Specifies the current user name (or NULL for default)

  Data              - Specifies caller-supplied data (see table in rulehlpr.c)

Return Value:

  Tri-state:

      TRUE to continue enumeration
      FALSE and last error != ERROR_SUCCESS if an error occurred
      FALSE and last error == ERROR_SUCCESS to stop enumeration silently

--*/

{
    DATAOBJECT PersistentRegOb;
    DATAOBJECT DestOb;
    NETCONNFILTERARG ArgStruct;
    BOOL b = FALSE;

    // If Administrator, default user or local machine, ignore this rule
    if (!User || (!User[0]) || StringIMatch (User, g_AdministratorStr)) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    //
    // We need to enumerate all keys in SrcObjectStr.  For each key,
    // create a drive mapping.
    //

    __try {
        ZeroMemory (&PersistentRegOb, sizeof (DATAOBJECT));
        ZeroMemory (&DestOb, sizeof (DATAOBJECT));

        if (!CreateObjectStruct (SrcObjectStr, &PersistentRegOb, WIN95OBJECT)) {
            DEBUGMSG ((DBG_WARNING, "CreateNetMappings: %s is invalid", SrcObjectStr));
            __leave;
        }

        if (!(PersistentRegOb.ObjectType & OT_TREE)) {
            DEBUGMSG ((DBG_WARNING, "CreateNetMappings: %s does not specify subkeys -- skipping rule", SrcObjectStr));
            b = TRUE;
            __leave;
        }

        DuplicateObjectStruct (&DestOb, &PersistentRegOb);
        SetPlatformType (&DestOb, WINNTOBJECT);

        ArgStruct.User = User;
        b = (FILTER_RETURN_FAIL != CopyObject (&PersistentRegOb, &DestOb, NetConnFilter, &ArgStruct));

        // If there were no mappings, return success
        if (!b) {
            if (GetLastError() == ERROR_FILE_NOT_FOUND ||
                GetLastError() == ERROR_NO_MORE_ITEMS
                ) {
                b = TRUE;
            }
        }
    }
    __finally {
        FreeObjectStruct (&DestOb);
        FreeObjectStruct (&PersistentRegOb);
    }

    return b;
}


BOOL
RuleHlpr_ConvertRecentMappings (
    IN      PCTSTR SrcObjectStr,
    IN      PCTSTR DestObjectStr,
    IN      PCTSTR User,
    IN      PVOID Data
    )

/*++

Routine Description:

  This function is an enumerated rule helper callback that copies recent network
  mappings.  It is called for each network mapping using the key enumeration in
  rulehlpr.c.

Arguments:

  SrcObjectStr      - Specifies Win9x registry key being enumerated (copy source)

  DestObjectStr     - Specifies WinNT registry key (copy destination)

  User              - Specifies the current user name (or NULL for default)

  Data              - Specifies caller-supplied data (see table in rulehlpr.c)

Return Value:

  Tri-state:

      TRUE to continue enumeration
      FALSE and last error != ERROR_SUCCESS if an error occurred
      FALSE and last error == ERROR_SUCCESS to stop enumeration silently

--*/

{
    DATAOBJECT PersistentRegOb;
    DATAOBJECT DestOb;
    BOOL b = FALSE;

    // If Administrator, default user or local machine, ignore this rule
    if (!User || (!User[0]) || StringIMatch (User, g_AdministratorStr)) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    //
    // We need to enumerate all keys in SrcObjectStr.  For each key,
    // create a drive mapping.
    //

    __try {
        ZeroMemory (&PersistentRegOb, sizeof (DATAOBJECT));
        ZeroMemory (&DestOb, sizeof (DATAOBJECT));

        if (!CreateObjectStruct (SrcObjectStr, &PersistentRegOb, WIN95OBJECT)) {
            DEBUGMSG ((DBG_WARNING, "PersistentConnections: %s is invalid", SrcObjectStr));
            __leave;
        }

        if (!(PersistentRegOb.ObjectType & OT_TREE)) {
            DEBUGMSG ((DBG_WARNING, "PersistentConnections: %s does not specify subkeys -- skipping rule", SrcObjectStr));
            b = TRUE;
            __leave;
        }

        DuplicateObjectStruct (&DestOb, &PersistentRegOb);
        SetPlatformType (&DestOb, WINNTOBJECT);

        b = CopyObject (&PersistentRegOb, &DestOb, PersistentConnFilter, NULL);

        // If CopyObject completed, or there were no mappings, return success
        if (!b) {
            if (GetLastError() == ERROR_FILE_NOT_FOUND ||
                GetLastError() == ERROR_NO_MORE_ITEMS
                ) {
                b = TRUE;
            }
        }
    }
    __finally {
        FreeObjectStruct (&DestOb);
        FreeObjectStruct (&PersistentRegOb);
    }

    return b;
}


BOOL
pWasAccountMigrated (
    IN      PCTSTR UserName
    )

/*++

Routine Description:

  pWasAccountMigrated queries the UserDatLoc category to determine if the
  specified user was scheduled migration.  If they are listed in UserDatLoc,
  then they will be migrated.

Arguments:

  UserName - Specifies user to look up.  Must be fixed version.

Return Value:

  TRUE if the user was migrated, FALSE if not.

--*/

{
    MEMDB_ENUM e;

    return MemDbEnumFields (&e, MEMDB_CATEGORY_USER_DAT_LOC, UserName);
}


BOOL
ValFn_VerifyLastLoggedOnUser (
    IN OUT  PDATAOBJECT ObPtr
    )

/*++

Routine Description:

  This routine uses the RuleHlpr_ConvertRegVal simplification routine.  See
  rulehlpr.c for details. The simplification routine does almost all the work
  for us; all we need to do is update the value.

  ValFn_VerifyLastLoggedOnUser is used to validate the user being copied
  into the default logon user setting.  If the user account was not migrated,
  then "Administrator" is used as the default logon user.

Arguments:

  ObPtr - Specifies the Win95 data object as specified in wkstamig.inf,
          [Win9x Data Conversion] section. The object value is then modified.
          After returning, the merge code then copies the data to the NT
          destination, which has a new location (specified in wkstamig.inf,
          [Map Win9x to WinNT] section).

Return Value:

  Tri-state:

      TRUE to allow merge code to continue processing (it writes the value)
      FALSE and last error == ERROR_SUCCESS to continue, but skip the write
      FALSE and last error != ERROR_SUCCESS if an error occurred

--*/

{
    PCTSTR UserName;
    PCTSTR AdministratorAcct;
    BOOL ForceAdministrator;
    TCHAR FixedUserName[MAX_USER_NAME];

    //
    // Verify user was migrated.  If not, change value to Administrator.
    //

    UserName = (PCTSTR) ObPtr->Value.Buffer;
    if (SizeOfString (UserName) > ObPtr->Value.Size) {
        DEBUGMSG ((DBG_WHOOPS, "User Name string not nul-terminated"));
        ForceAdministrator = TRUE;
        FixedUserName[0] = 0;
    } else {

        _tcssafecpy (FixedUserName, UserName, MAX_USER_NAME);
        GetFixedUserName (FixedUserName);

        if (pWasAccountMigrated (FixedUserName)) {
            ForceAdministrator = FALSE;
        } else {
            ForceAdministrator = TRUE;
        }
    }

    if (ForceAdministrator) {
        AdministratorAcct = GetStringResource (MSG_ADMINISTRATOR_ACCOUNT);

        __try {
            if (!ReplaceValue (
                    ObPtr,
                    (PBYTE) AdministratorAcct,
                    SizeOfString (AdministratorAcct)
                    )) {
                return FALSE;
            }
        }
        __finally {
            FreeStringResource (AdministratorAcct);
        }
    } else {
        if (!StringMatch (UserName, FixedUserName)) {
            if (!ReplaceValue (
                    ObPtr,
                    (PBYTE) FixedUserName,
                    SizeOfString (FixedUserName)
                    )) {
                return FALSE;
            }
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\rulehlpr\rulehlpr.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    rulehlpr.c

Abstract:

    Migration rule helper DLL

    This source file implements helper functions needed to migrate the
    system applications.  Inside usermig.inf are rules that call this
    DLL to do various data conversions.  Two examples of these are
    conversion of the accessibility cpl and desktop scheme conversions.

Author:

    Jim Schmidt (jimschm) 06-Aug-1996

Revision History:

    jimschm     17-Feb-1999 Now calling ismig.dll
    ovidiut     02-Feb-1999 Added ConvertCDPlayerSettings
    jimschm     20-Jan-1999 pAddRemoveProgramsFilter
    jimschm     23-Sep-1998 Changed for new fileop code
    jimschm     27-Jul-1998 Added ValFn_AntiAlias
    calinn      19-May-1998 Added MigrateFreeCell
    jimschm     30-Apr-1998 Added ShellIcons support
    jimschm     25-Mar-1998 Added MergeClasses support
    jimschm     24-Feb-1998 Added ValFn_Fonts
    jimschm     20-Feb-1998 Added ValFn_ModuleUsage
    calinn      19-Jan-1998 Modified ValidateRunKey
    jimschm     25-Nov-1997 Added RuleHlpr_ConvertAppPaths

--*/


#include "pch.h"
#include "ismig.h"

//
// Types
//

typedef struct {
    REGVALFN RegValFn;
    BOOL Tree;
} MERGEFILTERARG, *PMERGEFILTERARG;

typedef struct {
    PCTSTR  Old;
    PCTSTR  New;
} STRINGREPLACEARGS, *PSTRINGREPLACEARGS;


typedef struct {
    PCTSTR FunctionName;
    PROCESSINGFN ProcessingFn;
    PVOID Arg;
} HELPER_FUNCTION, *PHELPER_FUNCTION;

HANDLE g_ISMigDll;
PISUGETALLSTRINGS ISUGetAllStrings;
PISUMIGRATE ISUMigrate;



//
// Processing functions get the chance to do any
// kind of translation necessary, including ones
// that involve other keys, values or value data.
//

#define PROCESSING_FUNCITON_LIST                                \
    DECLARE_PROCESSING_FN(ConvertFilterKeys)                    \
    DECLARE_PROCESSING_FN(ConvertOldDisabled)                   \
    DECLARE_PROCESSING_FN(CreateNetMappings)                    \
    DECLARE_PROCESSING_FN(ConvertRecentMappings)                \
    DECLARE_PROCESSING_FN(ConvertMouseKeys)                     \
    DECLARE_PROCESSING_FN(ConvertStickyKeys)                    \
    DECLARE_PROCESSING_FN(ConvertSoundSentry)                   \
    DECLARE_PROCESSING_FN(ConvertTimeOut)                       \
    DECLARE_PROCESSING_FN(ConvertToggleKeys)                    \
    DECLARE_PROCESSING_FN(ConvertHighContrast)                  \
    DECLARE_PROCESSING_FN(ConvertAppPaths)                      \
    DECLARE_PROCESSING_FN(ConvertKeysToValues)                  \
    DECLARE_PROCESSING_FN(MergeClasses)                         \
    DECLARE_PROCESSING_FN(ShellIcons)                           \
    DECLARE_PROCESSING_FN(MigrateFreeCell)                      \
    DECLARE_PROCESSING_FN(MigrateAddRemovePrograms)             \
    DECLARE_PROCESSING_FN(MigrateKeyboardLayouts)               \
    DECLARE_PROCESSING_FN(MigrateKeyboardPreloads)              \
    DECLARE_PROCESSING_FN(MigrateKeyboardSubstitutes)           \
    DECLARE_PROCESSING_FN(ValidateRunKey)                       \


//
// To simplify things, you can write a reg val function when you only need
// to translate registry value settings.  Depending on the pattern stored
// in usermig.inf or wkstamig.inf, your reg val function will be called for
// a single value, all values of a key, or all values of all keys and
// subkeys.  You will *not* be called for the key or subkey itself.
//
// The text comment describes which values are expected by the reg val
// function.
//
//     Name               INF Syntax     Description
//
//    "key values"      HKR\Foo\Bar     Routine processes the values of a single key
//    "key tree values" HKR\Foo\Bar\*   Routine processes all values including subkeys
//    "value"           HKR\Foo\[Bar]   Routine processes one value
//    "any value"       (any syntax)    Routine doesn't care about keys
//

#define VAL_FN_LIST                                             \
    DECLARE_REGVAL(ConvertRunMRU, "key values")                 \
    DECLARE_REGVAL(ConvertRecentDocsMRU, "key values")          \
    DECLARE_REGVAL(ConvertLogFont, "key tree values")           \
    DECLARE_REGVAL(ConvertAppearanceScheme, "key tree values")  \
    DECLARE_REGVAL(ConvertToDword, "any value")                 \
    DECLARE_REGVAL(ConvertToString, "any value")                \
    DECLARE_REGVAL(VerifyLastLoggedOnUser, "value")             \
    DECLARE_REGVAL(AddSharedDlls, "key values")                 \
    DECLARE_REGVAL(ConvertIndeoSettings, "key tree values")     \
    DECLARE_REGVAL(ModuleUsage, "key tree values")              \
    DECLARE_REGVAL(Fonts, "key values")                         \
    DECLARE_REGVAL(AntiAlias, "any value")                      \
    DECLARE_REGVAL(ConvertDarwinPaths, "key tree value")        \
    DECLARE_REGVAL(FixActiveDesktop, "any value")               \
    DECLARE_REGVAL(ConvertCDPlayerSettings, "value")            \



//
// Make the necessary declarations
//

#define DECLARE PROCESSING_FUNCITON_LIST VAL_FN_LIST

PROCESSINGFN_PROTOTYPE RuleHlpr_ConvertReg;
PROCESSINGFN_PROTOTYPE RuleHlpr_ConvertRegVal;
PROCESSINGFN_PROTOTYPE RuleHlpr_ConvertRegKey;
PROCESSINGFN_PROTOTYPE RuleHlpr_ConvertRegTree;

#define DECLARE_PROCESSING_FN(fn)   PROCESSINGFN_PROTOTYPE RuleHlpr_##fn;
#define DECLARE_REGVAL(fn,type)     REGVALFN_PROTOTYPE ValFn_##fn;

DECLARE

#undef DECLARE_PROCESSING_FN
#undef DECLARE_REGVAL

#define DECLARE_PROCESSING_FN(fn)   TEXT(#fn), RuleHlpr_##fn, NULL,
#define DECLARE_REGVAL(fn,type)     TEXT(#fn), RuleHlpr_ConvertReg, ValFn_##fn,

HELPER_FUNCTION g_HelperFunctions[] = {
    DECLARE /* , */
    NULL, NULL, NULL
};

#undef DECLARE_PROCESSING_FN
#undef DECLARE_REGVAL

#undef DECLARE



//
// Prototypes
//

FILTERRETURN
AppPathsKeyFilter (
    IN      CPDATAOBJECT SrcObjectPtr,
    IN      CPDATAOBJECT DestObjectPtr,
    IN      FILTERTYPE   FilterType,
    IN      PVOID        FilterArg
    );

FILTERRETURN
pConvertKeysToValuesFilter (
    IN CPDATAOBJECT SrcObject,
    IN CPDATAOBJECT DstObject,
    IN FILTERTYPE   Type,
    IN PVOID        Arg
    );

FILTERRETURN
Standard9xSuppressFilter (
    IN      CPDATAOBJECT SrcObject,
    IN      CPDATAOBJECT DstObject,
    IN      FILTERTYPE FilterType,
    IN      PVOID Arg
    );

FILTERRETURN
pNtPreferredSuppressFilter (
    IN      CPDATAOBJECT SrcObject,
    IN      CPDATAOBJECT DstObject,
    IN      FILTERTYPE FilterType,
    IN      PVOID Arg
    );


//
// Globals
//

PVOID g_NtFontFiles;

#define S_FONTS_KEY         TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts")


//
// Implementation
//


BOOL
WINAPI
RuleHlpr_Entry (
    IN HINSTANCE hinstDLL,
    IN DWORD dwReason,
    IN PVOID lpv
    )

/*++

Routine Description:

  DllMain is called after the C runtime is initialized, and its purpose
  is to initialize the globals for this process.  For this DLL, DllMain
  is provided as a stub.

Arguments:

  hinstDLL  - (OS-supplied) Instance handle for the DLL
  dwReason  - (OS-supplied) Type of initialization or termination
  lpv       - (OS-supplied) Unused

Return Value:

  TRUE because DLL always initializes properly.

--*/

{
    HKEY Key;
    REGVALUE_ENUM e;
    PCTSTR Data;

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        if(!pSetupInitializeUtils()) {
            return FALSE;
        }
        g_NtFontFiles = pSetupStringTableInitialize();
        if (!g_NtFontFiles) {
            return FALSE;
        }

        Key = OpenRegKeyStr (S_FONTS_KEY);
        if (!Key) {
            DEBUGMSG ((DBG_WHOOPS, "Can't open %s", S_FONTS_KEY));
        } else {
            if (EnumFirstRegValue (&e, Key)) {
                do {
                    Data = GetRegValueString (Key, e.ValueName);
                    if (Data) {
                        pSetupStringTableAddString (
                            g_NtFontFiles,
                            (PTSTR) Data,
                            STRTAB_CASE_INSENSITIVE
                            );
                        MemFree (g_hHeap, 0, Data);
                    }
                } while (EnumNextRegValue (&e));
            }
            CloseRegKey (Key);
        }

        break;


    case DLL_PROCESS_DETACH:
        if (g_NtFontFiles) {
            pSetupStringTableDestroy (g_NtFontFiles);
            g_NtFontFiles = NULL;
        }

        if (g_ISMigDll) {
            FreeLibrary (g_ISMigDll);
            g_ISMigDll = NULL;
        }
        pSetupUninitializeUtils();

        break;
    }

    return TRUE;
}


PROCESSINGFN
RuleHlpr_GetFunctionAddr (
    PCTSTR Function,
    PVOID *ArgPtrToPtr
    )
{
    PHELPER_FUNCTION p;

    p = g_HelperFunctions;
    while (p->FunctionName) {
        if (StringIMatch (p->FunctionName, Function)) {
            *ArgPtrToPtr = p->Arg;
            return p->ProcessingFn;
        }

        p++;
    }

    SetLastError (ERROR_PROC_NOT_FOUND);
    return NULL;
}


BOOL
RuleHlpr_ConvertReg (
    IN      PCTSTR SrcObjectStr,
    IN      PCTSTR DestObjectStr,
    IN      PCTSTR User,
    IN      PVOID  Data
    )
{
    DATAOBJECT Ob;
    BOOL b;

    if (!CreateObjectStruct (SrcObjectStr, &Ob, WIN95OBJECT)) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertReg: %s is invalid", SrcObjectStr));
        return FALSE;
    }

    if (IsObjectRegistryKeyOnly (&Ob)) {
        if (Ob.ObjectType & OT_TREE) {
            b = RuleHlpr_ConvertRegTree (SrcObjectStr, DestObjectStr, User, Data);
        } else {
            b = RuleHlpr_ConvertRegKey (SrcObjectStr, DestObjectStr, User, Data);
        }
    } else if (IsObjectRegistryKeyAndVal (&Ob)) {
        b = RuleHlpr_ConvertRegVal (SrcObjectStr, DestObjectStr, User, Data);
    } else {
        DEBUGMSG ((DBG_WHOOPS, "RuleHlpr_ConvertReg: %s is not a supported object type", SrcObjectStr));
        b = FALSE;
    }

    FreeObjectStruct (&Ob);
    return b;
}


BOOL
RuleHlpr_ConvertRegVal (
    IN      PCTSTR SrcObjectStr,
    IN      PCTSTR DestObjectStr,
    IN      PCTSTR User,
    IN      PVOID  Data
    )

/*++

Routine Description:

  RuleHlpr_ConvertRegVal calls a value function for just one value. It makes
  sure the value is supposed to be processed, then it calls the value
  function and writes the value to the destination.

Arguments:

  SrcObjectStr  - Specifies the source object string, as specified by the INF
  DestObjectStr - Specifies the destination object string. In most cases,
                  this string is the same as SrcObjectStr.  Registry key
                  mapping can influence the destination.
  User          - Specifies the user name (for the value function's use)
  Data          - Specifies data for the value function's use

Return Value:

  TRUE if the value was processed, FALSE if an error occurred.

--*/

{
    DATAOBJECT SrcObject;
    DATAOBJECT DstObject;
    BOOL b = FALSE;
    REGVALFN RegValFn;
    FILTERRETURN StdRc;
    DWORD Err;

    RegValFn = (REGVALFN) Data;

    //
    // If this value is Force NT value, and the NT value exists
    // already, then don't call the value function.
    //

    if (!CreateObjectStruct (SrcObjectStr, &SrcObject, WIN95OBJECT)) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertRegVal: %s is not a valid source", SrcObjectStr));
        return FALSE;
    }

    if (!CreateObjectStruct (DestObjectStr, &DstObject, WINNTOBJECT)) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertRegVal: %s is not a valid source", SrcObjectStr));
        goto c0;
    }

    StdRc = Standard9xSuppressFilter (
                &SrcObject,
                &DstObject,
                FILTER_VALUENAME_ENUM,
                NULL
                );

    if (StdRc != FILTER_RETURN_CONTINUE) {

        DEBUGMSG ((
            DBG_NAUSEA,
            "A value-based rule helper was skipped for %s",
            SrcObjectStr
            ));

        b = TRUE;
        goto c1;
    }

    StdRc = pNtPreferredSuppressFilter (
                &SrcObject,
                &DstObject,
                FILTER_VALUENAME_ENUM,
                NULL
                );

    if (StdRc != FILTER_RETURN_CONTINUE) {
        DEBUGMSG ((
            DBG_NAUSEA,
            "A value-based rule helper was skipped for %s because the NT value exists already",
            SrcObjectStr
            ));

        b = TRUE;
        goto c1;
    }

    //
    // Read registry value
    //

    if (!ReadObject (&SrcObject)) {

        Err = GetLastError();

        if (Err == ERROR_SUCCESS || Err == ERROR_FILE_NOT_FOUND) {
            b = TRUE;
            DEBUGMSG ((DBG_VERBOSE, "RuleHlpr_ConvertRegVal failed because %s does not exist", SrcObjectStr));
        } else {
            DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertRegVal failed because ReadObject failed"));
        }

        goto c1;
    }

    //
    // Call conversion function
    //

    if (!RegValFn (&SrcObject)) {
        if (GetLastError() == ERROR_SUCCESS) {
            b = TRUE;
        }
        goto c1;
    }

    //
    // Write changed value to destination (which takes into account renaming)
    //

    if (!WriteWinNTObjectString (DestObjectStr, &SrcObject)) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertRegVal failed because WriteWinNTObjectString failed"));
        goto c1;
    }

    b = TRUE;

c1:
    FreeObjectStruct (&DstObject);
c0:
    FreeObjectStruct (&SrcObject);

    return b;
}


FILTERRETURN
RegKeyMergeFilter (
    IN  CPDATAOBJECT InObPtr,
    IN  CPDATAOBJECT OutObPtr,
    IN  FILTERTYPE    Type,
    IN  PVOID        Arg
    )

/*++

Routine Description:

  RegKeyMergeFilter is the filter that calls value functions.

Arguments:

  InObPtr  - Specifies the source object.
  OutObPtr - Specifies the destination object.
  Type     - Specifies the filter type.  See Standard9xSuppressFilter for
             a good description.
  Arg      - Specifies the value function to run.  See the VAL_FN_LIST macro
             expansion list.

Return Value:

  A FILTERRETURN value that specifies how to proceed with the enumeration.

--*/

{
    PMERGEFILTERARG ArgPtr;
    FILTERRETURN StdRc;

    ArgPtr = (PMERGEFILTERARG) Arg;

    if (Type != FILTER_CREATE_KEY) {
        StdRc = Standard9xSuppressFilter (InObPtr, OutObPtr, Type, Arg);

        if (StdRc != FILTER_RETURN_CONTINUE) {

            DEBUGMSG ((
                DBG_NAUSEA,
                "A value-based rule helper was skipped for %s",
                DEBUGENCODER (InObPtr)
                ));

            return StdRc;
        }
    }

    StdRc = pNtPreferredSuppressFilter (InObPtr, OutObPtr, Type, NULL);

    if (StdRc != FILTER_RETURN_CONTINUE) {
        DEBUGMSG ((
            DBG_NAUSEA,
            "A value-based rule helper was skipped for %s because NT value exists",
            DEBUGENCODER (InObPtr)
            ));

        return StdRc;
    }

    if (Type == FILTER_CREATE_KEY) {
        return FILTER_RETURN_HANDLED;
    }

    if (Type == FILTER_KEY_ENUM) {
        return ArgPtr->Tree ? FILTER_RETURN_CONTINUE : FILTER_RETURN_HANDLED;
    }

    if (Type == FILTER_VALUE_COPY) {
        DATAOBJECT SrcOb, DestOb;
        BOOL b = FALSE;

        if (!DuplicateObjectStruct (&SrcOb, InObPtr)) {
            return FILTER_RETURN_FAIL;
        }

        // This guy has a value
        MYASSERT (SrcOb.ObjectType & OT_VALUE);

        //
        // Process data
        //

        if (!ArgPtr->RegValFn (&SrcOb)) {
            if (GetLastError() == ERROR_SUCCESS) {
                b = TRUE;
            } else {
                DEBUGMSG ((DBG_VERBOSE, "RegKeyMergeFilter: RegValFn failed with gle=%u", GetLastError()));
            }
        } else {
            //
            // Write results
            //

            if (DuplicateObjectStruct (&DestOb, OutObPtr)) {
                if (ReplaceValue (&DestOb, SrcOb.Value.Buffer, SrcOb.Value.Size)) {
                    if (SrcOb.ObjectType & OT_REGISTRY_TYPE) {
                        DestOb.ObjectType |= OT_REGISTRY_TYPE;
                        DestOb.Type = SrcOb.Type;
                    }

                    if (WriteObject (&DestOb)) {
                        b = TRUE;
                    }
                }

                FreeObjectStruct (&DestOb);
            }
        }

        FreeObjectStruct (&SrcOb);

        return b ? FILTER_RETURN_HANDLED : FILTER_RETURN_FAIL;
    }

    return FILTER_RETURN_CONTINUE;
}


BOOL
RuleHlpr_ConvertRegKey (
    IN      PCTSTR SrcObjectStr,
    IN      PCTSTR DestObjectStr,
    IN      PCTSTR User,
    IN      PVOID  Data
    )
{
    DATAOBJECT Ob, DestOb;
    BOOL b = FALSE;
    MERGEFILTERARG FilterArg;
    FILTERRETURN fr;

    //
    // Create object structs
    //

    if (!CreateObjectStruct (SrcObjectStr, &Ob, WIN95OBJECT)) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertRegKey: %s is not a valid source", SrcObjectStr));
        goto c0;
    }
    Ob.ObjectType &= ~OT_TREE;


    if (!CreateObjectStruct (DestObjectStr, &DestOb, WINNTOBJECT)) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertRegKey: %s is not a valid dest", DestObjectStr));
        goto c1;
    }

    if (DestOb.ObjectType & OT_TREE || DestOb.ValueName) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertRegKey: dest %s is not a key only", DestObjectStr));
        goto c2;
    }

    //
    // Call RegValFn for all values in the key
    //

    FilterArg.Tree = FALSE;
    FilterArg.RegValFn = (REGVALFN) Data;
    fr = CopyObject (&Ob, &DestOb, RegKeyMergeFilter, &FilterArg);
    if (fr == FILTER_RETURN_FAIL) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertRegKey: CopyObject failed"));
        goto c2;
    }

    b = TRUE;

c2:
    FreeObjectStruct (&DestOb);
c1:
    FreeObjectStruct (&Ob);
c0:
    return b;
}


BOOL
RuleHlpr_ConvertRegTree (
    IN      PCTSTR SrcObjectStr,
    IN      PCTSTR DestObjectStr,
    IN      PCTSTR User,
    IN      PVOID  Data
    )
{
    DATAOBJECT Ob, DestOb;
    BOOL b = FALSE;
    MERGEFILTERARG FilterArg;
    FILTERRETURN fr;

    //
    // Create object structs
    //

    if (!CreateObjectStruct (SrcObjectStr, &Ob, WIN95OBJECT)) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertRegKey: %s is not a valid source", SrcObjectStr));
        goto c0;
    }
    Ob.ObjectType |= OT_TREE;

    if (!CreateObjectStruct (DestObjectStr, &DestOb, WINNTOBJECT)) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertRegKey: %s is not a valid dest", DestObjectStr));
        goto c1;
    }

    //
    // Call RegValFn for all subkeys and values in the key
    //

    FilterArg.Tree = TRUE;
    FilterArg.RegValFn = (REGVALFN) Data;
    fr = CopyObject (&Ob, &DestOb, RegKeyMergeFilter, &FilterArg);
    if (fr == FILTER_RETURN_FAIL) {
        DEBUGMSG ((DBG_WARNING, "RuleHlpr_ConvertRegKey: CopyObject failed"));
        goto c2;
    }

    b = TRUE;

c2:
    FreeObjectStruct (&DestOb);
c1:
    FreeObjectStruct (&Ob);
c0:
    return b;
}


BOOL
ValFn_ConvertToDword (
    PDATAOBJECT ObPtr
    )
{
    DWORD d;

    if (!GetDwordFromObject (ObPtr, &d)) {
        SetLastError(ERROR_SUCCESS);
        return FALSE;
    }

    if (ReplaceValue (ObPtr, (PBYTE) &d, sizeof (d))) {
        ObPtr->ObjectType |= OT_REGISTRY_TYPE;
        ObPtr->Type = REG_DWORD;
        return TRUE;
    }

    return FALSE;
}


BOOL
ValFn_ConvertToString (
    PDATAOBJECT ObPtr
    )
{
    PCTSTR result;

    result = GetStringFromObject (ObPtr);

    if (!result) {
        SetLastError(ERROR_SUCCESS);
        return FALSE;
    }

    if (ReplaceValueWithString (ObPtr, result)) {
        ObPtr->ObjectType |= OT_REGISTRY_TYPE;
        ObPtr->Type = REG_SZ;
        FreePathString (result);
        return TRUE;
    }
    FreePathString (result);
    return FALSE;
}


BOOL
ValFn_AddSharedDlls (
    IN OUT  PDATAOBJECT ObPtr
    )
{
    DWORD d, d2;
    DATAOBJECT NtOb;
    PTSTR TempValueName;
    CONVERTPATH_RC C_Result;
    BOOL Result = TRUE;

    if (!GetDwordFromObject (ObPtr, &d)) {
        SetLastError(ERROR_SUCCESS);
        return FALSE;
    }

    if (!DuplicateObjectStruct (&NtOb, ObPtr)) {
        return FALSE;
    }

    SetPlatformType (&NtOb, WINNTOBJECT);

    if (GetDwordFromObject (&NtOb, &d2)) {
        d += d2;
    }

    FreeObjectStruct (&NtOb);

    ObPtr->Type = REG_DWORD;

    TempValueName = MemAlloc (g_hHeap, 0, MAX_TCHAR_PATH * sizeof (TCHAR));

    __try {

        StringCopy (TempValueName, (PTSTR) ObPtr->ValueName);

        C_Result = ConvertWin9xPath ((PTSTR) TempValueName);

        switch (C_Result) {
        case CONVERTPATH_DELETED:
            //
            // nothing to do
            //
            SetLastError (ERROR_SUCCESS);
            break;

        case CONVERTPATH_NOT_REMAPPED:
            //
            // just changing the value
            //
            d -= 1;
            Result = ReplaceValue (ObPtr, (PBYTE) &d, sizeof (d));
            break;

        default:
            //
            // we have to change value name and we'll have to do it by ourselves
            // actually value name has been already changed by calling ConvertWin9xPath
            // so just changing the value and writting the object
            //
            Result = Result && SetPlatformType (ObPtr, WINNTOBJECT);
            Result = Result && SetRegistryValueName (ObPtr, TempValueName);
            Result = Result && ReplaceValue (ObPtr, (PBYTE) &d, sizeof (d));
            Result = Result && WriteObject(ObPtr);

            if (!Result) {
                // we had an error somewhere so sending this to the log.
                LOG ((LOG_ERROR, "The SharedDll reference count cannot be updated"));
            }

            SetLastError (ERROR_SUCCESS);
            break;
        }
    }
    __finally {
        MemFree (g_hHeap, 0, TempValueName);
    }

    return Result;
}




#define S_INDEO_KEYDES TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\drivers.desc")
#define S_INDEO_KEYDRV TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32")
#define S_INDEO_DESCR  TEXT("description")
#define S_INDEO_DRIVER TEXT("driver")

BOOL
ValFn_ConvertIndeoSettings (
    PDATAOBJECT ObPtr
    )
{
    PCTSTR KeyName;
    DATAOBJECT TmpObj;
    BOOL Result = TRUE;

    //
    // we are interested only in "drivers" and "description" value names.
    // Everything else is suppressed. So, we are going to return false
    // setting Error_Success in order to be sure that no value is migrated.
    // For those particular value names ("drivers" and "description") we
    // are going to migrate them directly by writing a NT Object.
    //

    if (StringIMatch (ObPtr->ValueName, S_INDEO_DRIVER)) {

        // extracting the last part of the key path
        KeyName = _tcsrchr (ObPtr->KeyPtr->KeyString, TEXT('\\'));
        if (!KeyName) {
            KeyName = ObPtr->KeyPtr->KeyString;
        }
        else {
            KeyName++;
        }

        // converting to WinNtObject, modifying and writing the registry key.
        Result = Result && SetPlatformType (ObPtr, WINNTOBJECT);
        Result = Result && SetRegistryValueName (ObPtr, KeyName);
        Result = Result && SetRegistryKey (ObPtr, S_INDEO_KEYDRV);
        Result = Result && WriteObject(ObPtr);

    }
    else
    if (StringIMatch (ObPtr->ValueName, S_INDEO_DESCR)) {

        // searching for a particular value name in Win95 key
        Result = Result && DuplicateObjectStruct (&TmpObj, ObPtr);

        if (Result) {

            FreeObjectVal (&TmpObj);
            Result = Result && SetRegistryValueName (&TmpObj, S_INDEO_DRIVER);

            if (ReadObject (&TmpObj)) {

                // converting to WinNtObject, modifying and writing the registry key.
                Result = Result && SetPlatformType (ObPtr, WINNTOBJECT);
                Result = Result && SetRegistryValueName (ObPtr, (PCTSTR)TmpObj.Value.Buffer);
                Result = Result && SetRegistryKey (ObPtr, S_INDEO_KEYDES);
                Result = Result && WriteObject(ObPtr);
            }

            FreeObjectStruct (&TmpObj);
        }

    }

    if (!Result) {

        // we had an error somewhere so sending this to the log.
        LOG ((LOG_ERROR, "Intel Indeo settings could not be migrated"));
    }

    SetLastError (ERROR_SUCCESS);
    return FALSE;
}


BOOL
RuleHlpr_ConvertKeysToValues (
    IN PCTSTR SrcObjectStr,
    IN PCTSTR DestObjectStr,
    IN PCTSTR User,
    IN PVOID Data
    )

{
    BOOL rSuccess = TRUE;
    FILTERRETURN fr;
    DATAOBJECT srcObject;
    DATAOBJECT dstObject;
    KEYTOVALUEARG args;

    //
    // We need to enumerate all keys in SrcObjectStr.  For each key,
    // we will change the subkey to a value.
    //

    __try {
        ZeroMemory (&srcObject, sizeof (DATAOBJECT));
        ZeroMemory (&dstObject, sizeof (DATAOBJECT));

        if (!CreateObjectStruct (SrcObjectStr, &srcObject, WIN95OBJECT)) {
            DEBUGMSG ((DBG_WARNING, "ConvertKeysToValues: %s is invalid", SrcObjectStr));
            return FALSE;
        }

        if (!(srcObject.ObjectType & OT_TREE)) {
            DEBUGMSG ((DBG_WARNING, "ConvertKeysToValues: %s does not specify subkeys -- skipping rule", SrcObjectStr));
            return TRUE;
        }

        DuplicateObjectStruct (&dstObject, &srcObject);
        SetPlatformType (&dstObject, WINNTOBJECT);

        ZeroMemory(&args,sizeof(KEYTOVALUEARG));
        DuplicateObjectStruct(&(args.Object),&dstObject);
        fr = CopyObject (&srcObject, &dstObject, pConvertKeysToValuesFilter,&args);
        FreeObjectStruct(&(args.Object));
        DEBUGMSG_IF((fr == FILTER_RETURN_FAIL,DBG_WHOOPS,"ConvertKeysToValues: CopyObject returned false."));

    }
    __finally {
        FreeObjectStruct (&dstObject);
        FreeObjectStruct (&srcObject);
    }

    SetLastError(ERROR_SUCCESS);
    return rSuccess;
}


FILTERRETURN
pRunKeyFilter (
    IN      CPDATAOBJECT SrcObjectPtr,
    IN      CPDATAOBJECT DestObjectPtr,
    IN      FILTERTYPE   FilterType,
    IN      PVOID        FilterArg
    )
{
    TCHAR key [MEMDB_MAX];
    DATAOBJECT destOb;
    BOOL b = FALSE;
    PTSTR path = NULL;
    UINT len;
    DWORD status;
    BOOL knownGood = FALSE;
    BOOL knownBad = FALSE;
    FILTERRETURN fr;

    fr = Standard9xSuppressFilter (SrcObjectPtr, DestObjectPtr, FilterType, FilterArg);

    if (fr != FILTER_RETURN_CONTINUE) {

        DEBUGMSG ((
            DBG_NAUSEA,
            "The following Run key was suppressed: %s",
            DEBUGENCODER (SrcObjectPtr)
            ));

        return fr;
    }

    switch (FilterType) {

    case FILTER_CREATE_KEY:
    case FILTER_KEY_ENUM:
    case FILTER_PROCESS_VALUES:
    case FILTER_VALUENAME_ENUM:
        break;

    case FILTER_VALUE_COPY:
        __try {
            //
            // Is expected value data?
            //

            if (SrcObjectPtr->Type != REG_SZ) {
                DEBUGMSG ((
                    DBG_NAUSEA,
                    "The following Run key is not REG_SZ: %s",
                    DEBUGENCODER (SrcObjectPtr)
                    ));
                __leave;
            }

            //
            // Is this Run key known good?
            //

            MemDbBuildKey (
                key,
                MEMDB_CATEGORY_COMPATIBLE_RUNKEY_NT,
                SrcObjectPtr->ValueName,
                NULL,
                NULL
                );

            knownGood = MemDbGetValue (key, NULL);

            //
            // Is value name known bad?
            //

            MemDbBuildKey (
                key,
                MEMDB_CATEGORY_INCOMPATIBLE_RUNKEY_NT,
                SrcObjectPtr->ValueName,
                NULL,
                NULL
                );

            knownBad = MemDbGetValue (key, NULL);

            //
            // Is target known bad? We need to check the string, which is a command line.
            // If it points to anything deleted, then it is bad.
            //
            // NOTE: Data in DestObjectPtr is already converted to NT
            //

            if (!knownBad) {
                len = SrcObjectPtr->Value.Size / sizeof (TCHAR);
                len = min (len, MAX_CMDLINE);
                path = AllocPathString (len + 1);

                CopyMemory (path, SrcObjectPtr->Value.Buffer, len * sizeof (TCHAR));
                path[len] = 0;

                ConvertWin9xCmdLine (path, NULL, &knownBad);
            }

            //
            // If it is known good, write it to the same location as it was on Win9x.
            // If it is known bad, skip it.
            // If it is unknown, leave it, relying in INF to move it.
            //

            if (!knownGood && knownBad) {
                DEBUGMSG ((
                    DBG_NAUSEA,
                    "The following Run key is known bad: %s",
                    DEBUGENCODER (SrcObjectPtr)
                    ));

            } else {

                //
                // Create a destination object. The inbound dest object
                // (DestObjectPtr) does not yet have a value. It does
                // have other information, such as a destination
                // registry key.
                //
                // The source object has a value, and it was filtered already
                // (it has NT paths).
                //

                if (!DuplicateObjectStruct (&destOb, DestObjectPtr)) {
                    fr = FILTER_RETURN_FAIL;
                }
                SetPlatformType (&destOb, WINNTOBJECT);

                if (ReplaceValue (&destOb, SrcObjectPtr->Value.Buffer, SrcObjectPtr->Value.Size)) {
                    destOb.ObjectType |= OT_REGISTRY_TYPE;
                    destOb.Type = SrcObjectPtr->Type;
                }

                //
                // Now output the object. Either write it to the expected
                // destination (known good case) or redirect it to the setup
                // key (unknown case).
                //

                if (knownGood) {

                    DEBUGMSG ((
                        DBG_NAUSEA,
                        "The following Run key is known good: %s",
                        DEBUGENCODER (SrcObjectPtr)
                        ));

                } else {
                    DEBUGMSG ((
                        DBG_NAUSEA,
                        "The following Run key is unknown: %s",
                        DEBUGENCODER (SrcObjectPtr)
                        ));

                    //
                    // Redirect to Windows\CurrentVersion\Setup\DisabledRunKeys
                    //

                    SetRegistryKey (
                        &destOb,
                        TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\DisabledRunKeys")
                        );
                }

                b = WriteObject (&destOb);
                FreeObjectStruct (&destOb);

                if (!b) {
                    return FILTER_RETURN_FAIL;
                }
            }

            fr = FILTER_RETURN_HANDLED;
        }
        __finally {
            FreePathString (path);
        }

        return fr;
    }

    return FILTER_RETURN_CONTINUE;
}

BOOL
RuleHlpr_ValidateRunKey (
    IN PCTSTR SrcObjectStr,
    IN PCTSTR DestObjectStr,
    IN PCTSTR User,
    IN PVOID Data
    )
{
    DATAOBJECT runKeyOb;
    DATAOBJECT destOb;
    BOOL b = FALSE;

    //
    // We need to enumerate all values in SrcObjectStr.  For each key,
    // we examine the default Win9x value, which may cause us to change
    // the default value, or skip the key altogether.
    //

    __try {
        ZeroMemory (&runKeyOb, sizeof (DATAOBJECT));
        ZeroMemory (&destOb, sizeof (DATAOBJECT));

        DEBUGMSG ((DBG_VERBOSE, "ValidateRunKey: Processing %s", SrcObjectStr));

        if (!CreateObjectStruct (SrcObjectStr, &runKeyOb, WIN95OBJECT)) {
            DEBUGMSG ((DBG_WARNING, "ValidateRunKey: %s is invalid", SrcObjectStr));
            __leave;
        }

        if (runKeyOb.ObjectType & OT_TREE) {
            DEBUGMSG ((DBG_WARNING, "ValidateRunKey: %s specifies subkeys -- skipping rule", SrcObjectStr));
            b = TRUE;
            __leave;
        }

        DuplicateObjectStruct (&destOb, &runKeyOb);
        SetPlatformType (&destOb, WINNTOBJECT);

        b = CopyObject (&runKeyOb, &destOb, pRunKeyFilter, NULL);

        // If there were no entries, return success
        if (!b) {
            if (GetLastError() == ERROR_FILE_NOT_FOUND ||
                GetLastError() == ERROR_NO_MORE_ITEMS
                ) {
                b = TRUE;
            }
        }
    }
    __finally {
        FreeObjectStruct (&destOb);
        FreeObjectStruct (&runKeyOb);
    }

    return b;
}


BOOL
RuleHlpr_ConvertAppPaths (
    IN      PCTSTR SrcObjectStr,
    IN      PCTSTR DestObjectStr,
    IN      PCTSTR User,
    IN      PVOID Data
    )

/*++

Routine Description:

  RuleHlpr_ConvertAppPaths determines if a specific EXE referenced by an App
  Paths entry (in HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion) has been
  moved or deleted.

  If the EXE has been moved, the default value is updated to point to the
  potentially new directory.

  If the EXE has been deleted, the subkey is suppressed from being copied.

  This function gets called by the usermig.inf/wkstamig.inf parser, not by
  CopyObject.  It gets called only once, and it is responsible for transferring
  the entire key specified by SrcObjectStr to the key specified by DestObjectStr.

Arguments:

  SrcObjectStr      - Specifies Win9x registry key being enumerated (copy source)

  DestObjectStr     - Specifies WinNT registry key (copy destination)

  User              - Specifies the current user name (or NULL for default)

  Data              - Specifies caller-supplied data (see table in rulehlpr.c)

Return Value:

  Tri-state:

      TRUE to continue procesing
      FALSE and last error == ERROR_SUCCESS to continue on to the next rule
      FALSE and last error != ERROR_SUCCESS if a fatal error occurred

--*/

{
    DATAOBJECT AppPathsOb;
    DATAOBJECT DestOb;
    BOOL b = FALSE;

    // If not local machine, don't process
    if (User) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    //
    // We need to enumerate all keys in SrcObjectStr.  For each key,
    // we examine the default Win9x value, which may cause us to change
    // the default value, or skip the key altogether.
    //

    __try {
        ZeroMemory (&AppPathsOb, sizeof (DATAOBJECT));
        ZeroMemory (&DestOb, sizeof (DATAOBJECT));

        if (!CreateObjectStruct (SrcObjectStr, &AppPathsOb, WIN95OBJECT)) {
            DEBUGMSG ((DBG_WARNING, "ConvertAppPaths: %s is invalid", SrcObjectStr));
            __leave;
        }

        if (!(AppPathsOb.ObjectType & OT_TREE)) {
            DEBUGMSG ((DBG_WARNING, "ConvertAppPaths: %s does not specify subkeys -- skipping rule", SrcObjectStr));
            b = TRUE;
            __leave;
        }

        DuplicateObjectStruct (&DestOb, &AppPathsOb);
        SetPlatformType (&DestOb, WINNTOBJECT);

        b = CopyObject (&AppPathsOb, &DestOb, AppPathsKeyFilter, NULL);

        // If there were no mappings, return success
        if (!b) {
            if (GetLastError() == ERROR_FILE_NOT_FOUND ||
                GetLastError() == ERROR_NO_MORE_ITEMS
                ) {
                b = TRUE;
            }
        }
    }
    __finally {
        FreeObjectStruct (&DestOb);
        FreeObjectStruct (&AppPathsOb);
    }

    return b;
}


FILTERRETURN
pConvertKeysToValuesFilter (
    IN CPDATAOBJECT SrcObject,
    IN CPDATAOBJECT DstObject,
    IN FILTERTYPE   Type,
    IN PVOID        Arg
    )
{

    DATAOBJECT      newObject;
    PKEYTOVALUEARG  keyToValueArgs = (PKEYTOVALUEARG) Arg;


    //
    // We want to create the initial key, but not any of the subkeys.
    //
    if (Type == FILTER_CREATE_KEY) {

        if (keyToValueArgs -> EnumeratingSubKeys) {
            return FILTER_RETURN_HANDLED;
        }
        else {
            return FILTER_RETURN_CONTINUE;
        }

    } else if (Type == FILTER_KEY_ENUM) {


        if (!keyToValueArgs -> EnumeratingSubKeys) {

            keyToValueArgs -> EnumeratingSubKeys = TRUE;

        }

        return FILTER_RETURN_CONTINUE;

    } else if (Type == FILTER_VALUENAME_ENUM && keyToValueArgs -> EnumeratingSubKeys) {

        if (!*SrcObject -> ValueName) {

            return FILTER_RETURN_CONTINUE;
        }
        ELSE_DEBUGMSG((DBG_WHOOPS,"ConvertKeysToValues: Unexpected value names."));

        return FILTER_RETURN_HANDLED;
    }
    else if (Type == FILTER_VALUE_COPY && keyToValueArgs -> EnumeratingSubKeys) {


        //
        // If this is the default value, we have the information we need to create the value for this.
        //
        if (!*SrcObject -> ValueName) {

            DuplicateObjectStruct(&newObject,&(keyToValueArgs -> Object));
            SetRegistryValueName(&newObject,_tcsrchr(SrcObject -> KeyPtr -> KeyString,TEXT('\\')) + 1);
            ReplaceValueWithString(&newObject,(PTSTR)SrcObject -> Value.Buffer);
            SetRegistryType(&newObject,REG_SZ);
            WriteObject (&newObject);
            FreeObjectStruct (&newObject);
        }
        ELSE_DEBUGMSG((DBG_WHOOPS,"ConvertKeysToValues: Unexpected value names.."));

        return FILTER_RETURN_HANDLED;
    }

    return FILTER_RETURN_CONTINUE;

}


FILTERRETURN
StringReplaceFilter (
    IN      CPDATAOBJECT SrcObjectPtr,
    IN      CPDATAOBJECT DestObjectPtr,
    IN      FILTERTYPE   FilterType,
    IN      PVOID        FilterArg
    )

/*++

Routine Description:

  StringReplaceFilter processes all values that pass through it, searching
  and replacing based on the filter arg (a STRINGREPLACEARGS struct).

Arguments:

  SrcObjectPtr      - Specifies Win9x registry key being enumerated (copy source)

  DestObjectPtr     - Specifies WinNT registry key (copy destination)

  FilterType        - Specifies the reason the filter is being called

  FilterArg         - Sepcifies a STIRNGREPLACEARGS struct.

Return Value:

  FILTER_RETURN_FAIL for failures
  FILTER_RETURN_CONTINUE otherwise.

--*/

{
    PSTRINGREPLACEARGS Args;
    PCTSTR NewString;
    DATAOBJECT NewDestOb;
    FILTERRETURN fr = FILTER_RETURN_CONTINUE;

    Args = (PSTRINGREPLACEARGS) FilterArg;

    if (FilterType == FILTER_VALUE_COPY) {
        if (SrcObjectPtr->Type == REG_SZ) {
            //
            // Get a new string
            //

            NewString = StringSearchAndReplace (
                            (PCTSTR) SrcObjectPtr->Value.Buffer,
                            Args->Old,
                            Args->New
                            );

            if (NewString && !StringMatch (NewString, (PCTSTR) SrcObjectPtr->Value.Buffer)) {
                //
                // Here's the offical way to change the value of an object, and
                // then save the changes:
                //

                DuplicateObjectStruct (&NewDestOb, DestObjectPtr);
                ReplaceValueWithString (&NewDestOb, NewString);
                WriteObject (&NewDestOb);
                FreeObjectStruct (&NewDestOb);

                //
                // In the case above, I could have optimized by replacing
                // the value of the SrcObjectPtr, but the SrcObjectPtr is
                // typed as const because it is unsafe to replace other
                // parts of it, such as the value name, key handle, and
                // so on.
                //
                // We end up paying a little extra for the DuplicateObjectStruct
                // call, but it's not very expensive.
                //

                // Do not carry out the copy -- we just did it ourselves
                fr = FILTER_RETURN_HANDLED;
            }

            FreePathString (NewString);
        }
    }

    return fr;
}



FILTERRETURN
AppPathsKeyFilter (
    IN      CPDATAOBJECT SrcObjectPtr,
    IN      CPDATAOBJECT DestObjectPtr,
    IN      FILTERTYPE   FilterType,
    IN      PVOID        FilterArg
    )

/*++

Routine Description:

  AppPathsKeyFilter is called for every subkey under

    HKLM\Software\Microsoft\Windows\CurrentVersion\AppPaths

  We determine if the key needs to be copied by examining the default value
  of the key.  If the value points to a deleted EXE, AppPathsKeyFilter
  returns FILTER_RETURN_HANDLED.  If the value points to a moved EXE, the
  values are updated to use the new path.

  If this routine is called for anything other than FILTER_KEY_ENUM, we
  return FILTER_RETURN_HANDLED, so garbage values and subkeys don't get
  processed.

Arguments:

  SrcObjectPtr      - Specifies Win9x registry key being enumerated (copy source)

  DestObjectPtr     - Specifies WinNT registry key (copy destination)

  FilterType        - Specifies the reason the filter is being called

  FilterArg         - Caller's arg passed in to CopyObject

Return Value:

  FILTER_RETURN_FAIL for failures
  FILTER_RETURN_HANDLED to skip all sub keys, values, etc.

--*/

{
    DATAOBJECT LocalObject;
    PCTSTR DefaultValue;
    DWORD Status;
    TCHAR NewPath[MEMDB_MAX];
    FILTERRETURN fr;
    PCTSTR p, q;
    PCTSTR Start;
    UINT SysDirTchars;
    GROWBUFFER Buf = GROWBUF_INIT;
    WCHAR c;

    fr = Standard9xSuppressFilter (SrcObjectPtr, DestObjectPtr, FilterType, FilterArg);

    if (fr != FILTER_RETURN_CONTINUE) {

        DEBUGMSG ((
            DBG_NAUSEA,
            "The following AppPaths key was suppressed: %s",
            DEBUGENCODER (SrcObjectPtr)
            ));

        return fr;
    }

    //
    // Do not create an empty key -- we might want to suppress it
    //

    if (FilterType == FILTER_CREATE_KEY) {
        return FILTER_RETURN_HANDLED;
    }

    //
    // Determine how to handle App Path subkey before processing the values
    //

    else if (FilterType == FILTER_PROCESS_VALUES) {
        //
        // Create object that points to default value
        //

        if (!DuplicateObjectStruct (&LocalObject, SrcObjectPtr)) {
            return FILTER_RETURN_FAIL;
        }

        __try {
            FreeObjectVal (&LocalObject);
            SetRegistryValueName (&LocalObject, S_EMPTY);

            if (!ReadObject (&LocalObject) || LocalObject.Type != REG_SZ) {
                //
                // Maybe this key is garbage and has no default value
                // or the default value is not a string.
                //

                return FILTER_RETURN_CONTINUE;
            }

            DefaultValue = (PCTSTR) LocalObject.Value.Buffer;

            //
            // Skip empty values or big values
            //

            if (*DefaultValue == 0 || (TcharCount (DefaultValue) >= MAX_PATH)) {
                return FILTER_RETURN_CONTINUE;
            }

            Status = GetFileInfoOnNt (DefaultValue, NewPath, MEMDB_MAX);

            //
            // Was the file deleted or moved?  If so, abandon the key.
            //
            if (Status & (FILESTATUS_NTINSTALLED|FILESTATUS_DELETED)) {
                return FILTER_RETURN_HANDLED;
            }
        }
        __finally {
            FreeObjectStruct (&LocalObject);
        }

    } else if (FilterType == FILTER_VALUE_COPY) {
        //
        // If we have %windir%\system in the value.  If so, change
        // it to %windir%\system32.
        //

        if (!(*SrcObjectPtr->ValueName)) {
            return FILTER_RETURN_CONTINUE;
        }

        if (SrcObjectPtr->Type != REG_SZ && SrcObjectPtr->Type != REG_EXPAND_SZ) {
            return FILTER_RETURN_CONTINUE;
        }

        MYASSERT (DoesObjectHaveValue (SrcObjectPtr));

        Start = (PCTSTR) SrcObjectPtr->Value.Buffer;

        p = _tcsistr (Start, g_SystemDir);
        if (p) {
            SysDirTchars = TcharCount (g_SystemDir);

            do {

                q = p + SysDirTchars;

                //
                // Ignore if text comes after system, and that text
                // is not a semicolon, and is not a wack followed
                // by a semicolon or nul.
                //

                if (*q) {
                    c = (WCHAR)_tcsnextc (q);
                    if (c == TEXT('\\')) {
                        c = (WCHAR)_tcsnextc (q + 1);
                    }
                } else {
                    c = 0;
                }

                if (!c || c == TEXT(';')) {
                    //
                    // Replace with system32
                    //

                    if (Start < p) {
                        GrowBufAppendStringAB (&Buf, Start, p);
                    }

                    GrowBufAppendString (&Buf, g_System32Dir);

                    //
                    // Continue loop
                    //

                    Start = q;
                }

                p = _tcsistr (q, g_SystemDir);

            } while (p);
        }

        if (*Start && Buf.End) {
            GrowBufAppendString (&Buf, Start);
        }

        if (Buf.End) {
            //
            // At least one instance of %windir%\system was changed.
            //

            DuplicateObjectStruct (&LocalObject, DestObjectPtr);
            SetRegistryType (&LocalObject, REG_SZ);
            ReplaceValue (&LocalObject, Buf.Buf, Buf.End);
            WriteObject (&LocalObject);
            FreeObjectStruct (&LocalObject);

            fr = FILTER_RETURN_HANDLED;

        } else {
            fr = FILTER_RETURN_CONTINUE;
        }

        FreeGrowBuffer (&Buf);
        return fr;
    }


    return FILTER_RETURN_CONTINUE;
}



BOOL
RuleHlpr_MergeClasses (
    IN PCTSTR SrcObjectStr,
    IN PCTSTR DestObjectStr,
    IN PCTSTR User,
    IN PVOID Data
    )
{
    DATAOBJECT SrcOb;
    BOOL b;
    TCHAR RegKeyStr[MAX_REGISTRY_KEY];

    if (!CreateObjectStruct (SrcObjectStr, &SrcOb, WIN95OBJECT)) {
        DEBUGMSG ((DBG_WARNING, "MergeClasses: %s is invalid", SrcObjectStr));
        return FALSE;
    }

    if (SrcOb.RootItem) {
        StringCopy (RegKeyStr, GetRootStringFromOffset (SrcOb.RootItem));
    } else {
        RegKeyStr[0] = 0;
    }

    StringCopy (AppendWack (RegKeyStr), SrcOb.KeyPtr->KeyString);

    b = MergeRegistryNode (RegKeyStr, ROOT_BASE);

    if (!b) {
        LOG ((LOG_ERROR, "The merge of HKCR failed; random application problems are likely"));
    }

    return TRUE;
}


BOOL
RuleHlpr_ShellIcons (
    IN PCTSTR SrcObjectStr,
    IN PCTSTR DestObjectStr,
    IN PCTSTR User,
    IN PVOID Data
    )
{
    DATAOBJECT SrcOb;
    BOOL b;
    TCHAR RegKeyStr[MAX_REGISTRY_KEY];

    if (!CreateObjectStruct (SrcObjectStr, &SrcOb, WIN95OBJECT)) {
        DEBUGMSG ((DBG_WARNING, "ShellIcons: %s is invalid", SrcObjectStr));
        return FALSE;
    }

    if (SrcOb.RootItem) {
        StringCopy (RegKeyStr, GetRootStringFromOffset (SrcOb.RootItem));
    } else {
        RegKeyStr[0] = 0;
    }

    StringCopy (AppendWack (RegKeyStr), SrcOb.KeyPtr->KeyString);

    b = MergeRegistryNode (RegKeyStr, COPY_DEFAULT_ICON);

    if (!b) {
        LOG ((LOG_ERROR, "The migration of some shell icons failed"));
    }

    return TRUE;
}


BOOL
RuleHlpr_MigrateFreeCell (
    IN      LPCTSTR SrcObjectStr,
    IN      LPCTSTR DestObjectStr,
    IN      LPCTSTR User,
    IN      LPVOID  Data
    )
{
    DATAOBJECT SrcOb;
    DATAOBJECT DestOb;
    BYTE data[4] = {1,0,0,0};

    ZeroMemory (&SrcOb,  sizeof (DATAOBJECT));
    ZeroMemory (&DestOb, sizeof (DATAOBJECT));

    if (!CreateObjectStruct (SrcObjectStr, &SrcOb, WIN95OBJECT)) {
        DEBUGMSG ((DBG_WARNING, "MigrateFreeCell: %s is invalid", SrcObjectStr));
        return TRUE;
    }

    if (!CreateObjectStruct (DestObjectStr, &DestOb, WINNTOBJECT)) {
        DEBUGMSG ((DBG_WARNING, "MigrateFreeCell: %s is invalid", DestObjectStr));
        FreeObjectStruct (&SrcOb);
        return TRUE;
    }

    CopyObject (&SrcOb, &DestOb, NULL, NULL);

    SetRegistryValueName (&DestOb, S_FREECELL_PLAYED);
    SetRegistryType (&DestOb, REG_BINARY);
    ReplaceValue (&DestOb, data, 4);

    WriteObject (&DestOb);

    FreeObjectStruct (&DestOb);
    FreeObjectStruct (&SrcOb);

    return TRUE;
}


BOOL
ValFn_ConvertDarwinPaths (
    PDATAOBJECT ObPtr
    )

{
    BOOL    rSuccess = TRUE;
    PTSTR   newPath = NULL;
    DWORD   size = 0;
    BOOL    flaggedPath = FALSE;

    //
    // Because they do some odd encoding in there
    // paths, we have to ensure that darwin paths are
    // properly updated.
    //
    size = SizeOfString ((PTSTR) ObPtr->Value.Buffer);
    newPath = (PTSTR) ReuseAlloc (g_hHeap, NULL, size);

    if (newPath && size > 1) {

        StringCopy (newPath, (PTSTR) ObPtr->Value.Buffer);
        if (newPath[1] == TEXT('?')) {

            newPath[1] = TEXT(':');
            flaggedPath = TRUE;
        }

        newPath = (PTSTR) FilterRegValue (
                                (PBYTE) newPath,
                                size,
                                REG_SZ,
                                TEXT("Darwin"),
                                &size
                                );


        if (flaggedPath) {

            newPath[1] = TEXT('?');
        }

        ReplaceValueWithString (ObPtr, newPath);
        ReuseFree (g_hHeap, newPath);

    }

    return rSuccess;
}


VOID
pProcessInstallShieldLog (
    IN      PCTSTR CmdLine,
    IN      PCMDLINE Table
    )
{
    UINT u;
    PCTSTR LogFileArg;
    TCHAR LogFilePath[MAX_TCHAR_PATH];
    PCSTR AnsiLogFilePath = NULL;
    PCSTR AnsiTempDir = NULL;
    PTSTR p;
    HGLOBAL IsuStringMultiSz = NULL;
    PCSTR MultiSz;
    GROWBUFFER SearchMultiSz = GROWBUF_INIT;
    GROWBUFFER ReplaceMultiSz = GROWBUF_INIT;
    MULTISZ_ENUMA e;
    DWORD Status;
    INT Result;
    PCSTR NtPath;
    PCTSTR Arg;
    BOOL InIsuFn = FALSE;

    //
    // Search for the -f arg
    //

    LogFileArg = NULL;

    for (u = 1 ; u < Table->ArgCount ; u++) {

        Arg = Table->Args[u].CleanedUpArg;

        if (Arg[0] == TEXT('-') || Arg[0] == TEXT('/')) {
            if (_totlower (Arg[1]) == TEXT('f')) {

                if (Arg[2]) {

                    LogFileArg = &Arg[2];
                    break;

                }
            }
        }
    }

    if (!LogFileArg) {
        DEBUGMSG ((
            DBG_WARNING,
            "InstallShield command line %s does not have -f arg",
            CmdLine
            ));

        return;
    }

    //
    // Fix up the arg
    //

    if (_tcsnextc (LogFileArg) == TEXT('\"')) {
        _tcssafecpy (LogFilePath, LogFileArg + 1, MAX_TCHAR_PATH);
        p = _tcsrchr (LogFilePath, TEXT('\"'));
        if (p && p[1] == 0) {
            *p = 0;
        }
    } else {
        _tcssafecpy (LogFilePath, LogFileArg, MAX_TCHAR_PATH);
    }

    if (!DoesFileExist (LogFilePath)) {
        DEBUGMSG ((
            DBG_WARNING,
            "InstallShield log file %s does not exist.  CmdLine=%s",
            LogFilePath,
            CmdLine
            ));

        return;
    }

    //
    // Get the list of strings
    //

    if (!ISUGetAllStrings || !ISUMigrate) {
        DEBUGMSG ((DBG_WARNING, "Can't process %s because ismig.dll was not loaded", LogFilePath));
        return;
    }

    __try {
        __try {
            AnsiLogFilePath = CreateDbcs (LogFilePath);

            InIsuFn = TRUE;
            IsuStringMultiSz = ISUGetAllStrings (AnsiLogFilePath);
            InIsuFn = FALSE;

            if (!IsuStringMultiSz) {
                DEBUGMSG ((
                    DBG_WARNING,
                    "No strings or error reading %s, rc=%u",
                    LogFilePath,
                    GetLastError()
                    ));
                __leave;
            }

            //
            // Build a list of changed paths
            //

            MultiSz = GlobalLock (IsuStringMultiSz);

#ifdef DEBUG
            {
                INT Count = 0;

                if (EnumFirstMultiSzA (&e, MultiSz)) {
                    do {
                        Count++;
                    } while (EnumNextMultiSzA (&e));
                }

                DEBUGMSG ((
                    DBG_NAUSEA,
                    "ISUGetAllStrings returned %i strings for %s",
                    Count,
                    LogFilePath
                    ));
            }
#endif

            if (EnumFirstMultiSzA (&e, MultiSz)) {
                do {
                    Status = GetFileStatusOnNtA (e.CurrentString);

                    if (Status & FILESTATUS_MOVED) {

                        NtPath = GetPathStringOnNtA (e.CurrentString);

                        DEBUGMSGA ((
                            DBG_NAUSEA,
                            "ISLOG: %s -> %s",
                            e.CurrentString,
                            NtPath
                            ));

                        MultiSzAppendA (&SearchMultiSz, e.CurrentString);
                        MultiSzAppendA (&ReplaceMultiSz, NtPath);

                        FreePathStringA (NtPath);
                    }
                } while (EnumNextMultiSzA (&e));
            }

            GlobalUnlock (IsuStringMultiSz);

            //
            // If there was a change, update the log file
            //

            if (SearchMultiSz.End) {

                AnsiTempDir = CreateDbcs (g_TempDir);

                InIsuFn = TRUE;
                Result = ISUMigrate (
                            AnsiLogFilePath,
                            (PCSTR) SearchMultiSz.Buf,
                            (PCSTR) ReplaceMultiSz.Buf,
                            AnsiTempDir
                            );
                InIsuFn = FALSE;

                DestroyDbcs (AnsiTempDir);
                AnsiTempDir = NULL;

                if (Result != ERROR_SUCCESS) {
                    SetLastError (Result);
                    DEBUGMSG ((
                        DBG_ERROR,
                        "Could not update paths in IS log file %s",
                        LogFilePath
                        ));
                }
            }
        }
        __except (TRUE) {
            DEBUGMSG_IF ((
                InIsuFn,
                DBG_ERROR,
                "An InstallShield function threw an unhandled exception"
                ));

            DEBUGMSG_IF ((
                !InIsuFn,
                DBG_WHOOPS,
                "An unhandled exception was hit processing data returned by InstallShield"
                ));

            if (AnsiTempDir) {
                DestroyDbcs (AnsiTempDir);
            }
        }
    }
    __finally {
        //
        // Clean up
        //

        if (IsuStringMultiSz) {
            GlobalFree (IsuStringMultiSz);
        }

        FreeGrowBuffer (&SearchMultiSz);
        FreeGrowBuffer (&ReplaceMultiSz);
        DestroyDbcs (AnsiLogFilePath);
    }

    return;
}


FILTERRETURN
Standard9xSuppressFilter (
    IN      CPDATAOBJECT SrcObject,
    IN      CPDATAOBJECT DstObject,
    IN      FILTERTYPE FilterType,
    IN      PVOID Arg
    )
{
    TCHAR RegKey[MAX_REGISTRY_KEY];

    switch (FilterType) {

    case FILTER_CREATE_KEY:
        //
        // Before enumerating subkeys and processing values,
        // we first have to create the destination key.  This
        // gives us a good opportunity to suppress the
        // entire key if necessary.
        //
        // If the source object tree is suppressed, then
        // don't create the key.
        //

        if (GetRegistryKeyStrFromObject (SrcObject, RegKey)) {
            if (Is95RegKeyTreeSuppressed (RegKey)) {
                //
                // Is this key NT priority?  If so, don't suppress.
                //

                if (!IsRegObjectMarkedForOperation (
                        RegKey,
                        NULL,
                        KEY_TREE,
                        REGMERGE_NT_PRIORITY_NT
                        )) {

                    //
                    // It's official -- this key tree is suppressed
                    //

                    return FILTER_RETURN_DONE;
                }
            }
        }

        break;

    case FILTER_KEY_ENUM:
        //
        // This is the case where a subkey was just
        // enumerated.  We don't care to test the subkeys,
        // because the FILTER_CREATE_KEY will take care
        // of this next, and we don't want to duplicate the
        // test when the value is not suppressed.
        //

        break;

    case FILTER_PROCESS_VALUES:
        //
        // After a subkey has been enumerated and created,
        // we get a chance to intercept the processing of
        // key values.
        //
        // If the source object is suppressed, and not the
        // entire tree, then don't process its values.
        // However, continue to process the subkeys.
        //

        if (GetRegistryKeyStrFromObject (SrcObject, RegKey)) {
            if (Is95RegKeySuppressed (RegKey)) {
                //
                // Is this key NT priority?  If so, don't suppress.
                //

                if (!IsRegObjectMarkedForOperation (
                        RegKey,
                        NULL,
                        KEY_ONLY,
                        REGMERGE_NT_PRIORITY_NT
                        )) {
                    //
                    // This key is suppressed
                    //

                    return FILTER_RETURN_HANDLED;
                }


            }
        }

        break;

    case FILTER_VALUENAME_ENUM:
        //
        // Now we have a specific value name that is ready to
        // be copied to the destination.
        //
        // If the specific source object is suppressed, then
        // don't create the key.
        //

        if (GetRegistryKeyStrFromObject (SrcObject, RegKey)) {
            if (Is95RegObjectSuppressed (RegKey, SrcObject->ValueName)) {
                //
                // Is this key NT priority?  If so, don't suppress.
                //

                if (!IsRegObjectMarkedForOperation (
                        RegKey,
                        SrcObject->ValueName,
                        TREE_OPTIONAL,
                        REGMERGE_NT_PRIORITY_NT
                        )) {
                    //
                    // This key is suppressed
                    //

                    return FILTER_RETURN_HANDLED;
                }


                //
                // Yes, this key is NT priority.  If the NT value
                // exists, then don't overwrite it.
                //

                if (CheckIfNtKeyExists (DstObject)) {
                    return FILTER_RETURN_HANDLED;
                }
            }
        }

        break;

    case FILTER_VALUE_COPY:
        //
        // This is the case where the value is in the process of
        // being copied.  We've already handled the suppression,
        // so there is no work here.
        //

        break;
    }

    return FILTER_RETURN_CONTINUE;
}


FILTERRETURN
pNtPreferredSuppressFilter (
    IN      CPDATAOBJECT SrcObject,
    IN      CPDATAOBJECT DstObject,
    IN      FILTERTYPE FilterType,
    IN      PVOID Arg
    )
{
    TCHAR RegKey[MAX_REGISTRY_KEY];

    switch (FilterType) {

    case FILTER_CREATE_KEY:
        //
        // The key is just about to be processed.  Since we care
        // only about values, there is no work here.
        //

        break;

    case FILTER_KEY_ENUM:
        //
        // Subkeys are going to be enumerated.  We don't care about
        // subkeys.
        //

        break;

    case FILTER_PROCESS_VALUES:
        //
        // We are just about ready to process values within the key.
        // Since we don't have a specific value yet, we don't care.
        //

        break;


    case FILTER_VALUENAME_ENUM:
        //
        // Now we have a specific value name that is ready to be
        // processed. If the value is set for Force NT, and it exists
        // already, then don't process the value.
        //

        if (GetRegistryKeyStrFromObject (SrcObject, RegKey)) {
            if (IsRegObjectMarkedForOperation (
                    RegKey,
                    SrcObject->ValueName,
                    KEY_ONLY,
                    REGMERGE_NT_PRIORITY_NT
                    )) {
                //
                // If NT destination exists, then don't overwrite it
                //

                if (CheckIfNtKeyExists (SrcObject)) {

                    return FILTER_RETURN_HANDLED;

                }
            }
        }

        break;

    case FILTER_VALUE_COPY:
        //
        // This is the case where the value is in the process of
        // being copied.  We've already handled the suppression,
        // so there is no work here.
        //

        break;
    }

    return FILTER_RETURN_CONTINUE;
}


FILTERRETURN
pAddRemoveProgramsFilter (
    IN      CPDATAOBJECT SrcObject,
    IN      CPDATAOBJECT DstObject,
    IN      FILTERTYPE FilterType,
    IN      PVOID Arg
    )
{
    DATAOBJECT UninstallStringOb;
    PCTSTR UninstallString;
    FILTERRETURN rc = FILTER_RETURN_CONTINUE;
    GROWBUFFER CmdLineArgs = GROWBUF_INIT;
    PCMDLINE Table;
    BOOL Suppress = TRUE;
    DWORD Status;
    BOOL FreeOb = FALSE;
    UINT u;
    PCTSTR p;
    VERSION_STRUCT Version;
    BOOL InstallShield = FALSE;
    PCTSTR CompanyName;
    FILTERRETURN StdRc;

    __try {
        //
        // Chain to the suppress filter
        //

        StdRc = Standard9xSuppressFilter (SrcObject, DstObject, FilterType, Arg);

        if (StdRc != FILTER_RETURN_CONTINUE) {

            DEBUGMSG ((
                DBG_NAUSEA,
                "The following ARP key was suppressed: %s",
                DEBUGENCODER (SrcObject)
                ));

            rc = StdRc;
            __leave;
        }

        //
        // Do not create an empty key -- we might want to suppress it
        //

        if (FilterType == FILTER_CREATE_KEY) {
            rc = FILTER_RETURN_HANDLED;
            __leave;
        }

        //
        // Determine if Add/Remove Programs is still valid before copying
        //

        if (FilterType == FILTER_PROCESS_VALUES) {

            //
            // Create object that points to UninstallString value
            //

            if (!DuplicateObjectStruct (&UninstallStringOb, SrcObject)) {
                rc = FILTER_RETURN_FAIL;
                __leave;
            }

            FreeOb = TRUE;

            FreeObjectVal (&UninstallStringOb);
            SetRegistryValueName (&UninstallStringOb, TEXT("UninstallString"));

            if (!ReadObject (&UninstallStringOb) || (UninstallStringOb.Type != REG_SZ && UninstallStringOb.Type != REG_EXPAND_SZ)) {
                //
                // Maybe this key is garbage and has no default value
                // or the default value is not a string.
                //

                DEBUGMSG ((
                    DBG_WARNING,
                    "Uninstall key has no UninstallString: %s",
                    DEBUGENCODER (SrcObject)
                    ));


                __leave;
            }

            UninstallString = (PCTSTR) UninstallStringOb.Value.Buffer;

            Table = ParseCmdLine (UninstallString, &CmdLineArgs);

            //
            // Check for InstallShield, and if found, convert paths in the
            // log file (provided by the -f arg)
            //

            if (Table->ArgCount > 0) {

                p = GetFileNameFromPath (Table->Args[0].CleanedUpArg);

                if (CreateVersionStruct (&Version, p)) {

                    //
                    // Check CompanyName for InstallShield
                    //

                    CompanyName = EnumFirstVersionValue (&Version, TEXT("CompanyName"));

                    while (CompanyName) {

                        DEBUGMSG ((DBG_NAUSEA, "%s has CompanyName: %s", p, CompanyName));

                        if (_tcsistr (CompanyName, TEXT("InstallShield"))) {
                            InstallShield = TRUE;
                            break;
                        }

                        CompanyName = EnumNextVersionValue (&Version);
                    }

                    DestroyVersionStruct (&Version);
                }

                if (InstallShield) {

                    pProcessInstallShieldLog (UninstallString, Table);

                }
            }

            //
            // Examine each command line arg for validity
            //

            for (u = 0 ; u < Table->ArgCount ; u++) {

                if (Table->Args[u].Attributes != INVALID_ATTRIBUTES) {

                    Suppress = FALSE;

                    Status = GetFileStatusOnNt (Table->Args[u].CleanedUpArg);

                    if (Status == FILESTATUS_UNCHANGED) {
                        p = _tcschr (Table->Args[u].CleanedUpArg, TEXT(':'));

                        while (p) {

                            p = _tcsdec (Table->Args[u].CleanedUpArg, p);

                            Status = GetFileStatusOnNt (Table->Args[u].CleanedUpArg);
                            if (Status != FILESTATUS_UNCHANGED) {
                                break;
                            }

                            p = _tcschr (p + 2, TEXT(':'));
                        }
                    }

                    if ((Status & FILESTATUS_DELETED) ||
                        ((Status & FILESTATUS_NTINSTALLED) && u)
                        ) {

                        DEBUGMSG ((
                            DBG_VERBOSE,
                            "Add/Remove Programs entry %s suppressed because of arg %s",
                            DEBUGENCODER (SrcObject),
                            Table->Args[u].CleanedUpArg
                            ));

                        Suppress = TRUE;
                        break;
                    }
                }
            }

            //
            // If we are to suppress this key, then return handled
            //

            if (Suppress) {
                rc = FILTER_RETURN_HANDLED;
            }
        }
    }
    __finally {
        if (FreeOb) {
            FreeObjectStruct (&UninstallStringOb);
        }

        FreeGrowBuffer (&CmdLineArgs);
    }

    return rc;
}



BOOL
RuleHlpr_MigrateAddRemovePrograms (
    IN      PCTSTR SrcObjectStr,
    IN      PCTSTR DestObjectStr,
    IN      PCTSTR User,
    IN      PVOID Data
    )
{
    DATAOBJECT SrcOb;
    DATAOBJECT DestOb;
    BOOL b = FALSE;
    PCTSTR Path;

    // If not local machine, don't process
    if (User) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    //
    // We need to enumerate all keys in SrcObjectStr.  For each key,
    // we examine the default Win9x value, which may cause us to change
    // the default value, or skip the key altogether.
    //

    __try {
        ZeroMemory (&SrcOb, sizeof (DATAOBJECT));
        ZeroMemory (&DestOb, sizeof (DATAOBJECT));

        if (!CreateObjectStruct (SrcObjectStr, &SrcOb, WIN95OBJECT)) {
            DEBUGMSG ((DBG_WARNING, "MigrateAddRemovePrograms: %s is invalid", SrcObjectStr));
            __leave;
        }

        if (!(SrcOb.ObjectType & OT_TREE)) {
            DEBUGMSG ((DBG_WARNING, "MigrateAddRemovePrograms %s does not specify subkeys -- skipping rule", SrcObjectStr));
            b = TRUE;
            __leave;
        }

        DuplicateObjectStruct (&DestOb, &SrcOb);
        SetPlatformType (&DestOb, WINNTOBJECT);

        if (!g_ISMigDll) {
            Path = JoinPaths (g_TempDir, TEXT("ismig.dll"));
            g_ISMigDll = LoadLibrary (Path);

            if (g_ISMigDll) {
                ISUMigrate = (PISUMIGRATE) GetProcAddress (g_ISMigDll, "ISUMigrate");
                ISUGetAllStrings = (PISUGETALLSTRINGS) GetProcAddress (g_ISMigDll, "ISUGetAllStrings");
            }
            ELSE_DEBUGMSG ((DBG_ERROR, "Could not load %s", Path));
        }

        FreePathString (Path);

        b = CopyObject (&SrcOb, &DestOb, pAddRemoveProgramsFilter, NULL);

        // If there were no entries, return success
        if (!b) {
            if (GetLastError() == ERROR_FILE_NOT_FOUND ||
                GetLastError() == ERROR_NO_MORE_ITEMS
                ) {
                b = TRUE;
            }
        }
    }
    __finally {
        FreeObjectStruct (&DestOb);
        FreeObjectStruct (&SrcOb);

        if (g_ISMigDll) {
            FreeLibrary (g_ISMigDll);
            g_ISMigDll = NULL;
        }

    }

    return b;
}


BOOL
ValFn_FixActiveDesktop (
    IN OUT  PDATAOBJECT ObPtr
    )

/*++

Routine Description:

  This routine uses the RuleHlpr_ConvertRegVal simplification routine.  See
  rulehlpr.c for details. The simplification routine does almost all the work
  for us; all we need to do is update the value.

  ValFn_AntiAlias checks if ShellState has bogus data. This usually happens when you have
  fresh installed Win98 and you never switched ActiveDesktop on and off. If bogus data is
  found, we writes some valid data so that the state of Active Desktop is preserved during
  migration

Return Value:

  Tri-state:

      TRUE to allow merge code to continue processing (it writes the value)
      FALSE and last error == ERROR_SUCCESS to continue, but skip the write
      FALSE and last error != ERROR_SUCCESS if an error occurred

--*/

{
    #define BadBufferSize   16
    #define GoodBufferSize  28

    BYTE BadBuffer[BadBufferSize] =
        {0x10, 0x00, 0x00, 0x00,
         0x01, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00};

    BYTE GoodBuffer[GoodBufferSize] =
        {0x1C, 0x00, 0x00, 0x00,
         0x20, 0x08, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x0A, 0x00, 0x00, 0x00};

    INT i;
    BOOL shouldChange = TRUE;

    //
    // Require 16 bytes REG_BINARY data like in BadBuffer
    //

    if (!IsObjectRegistryKeyAndVal (ObPtr) ||
        !IsRegistryTypeSpecified (ObPtr) ||
        !ObPtr->Value.Size ||
        (ObPtr->Value.Size != 16) ||
        ObPtr->Type != REG_BINARY
        ) {
        DEBUGMSG ((DBG_WARNING, "ValFn_FixActiveDesktop: Data is not valid"));
    } else {
        for (i = 0; i<BadBufferSize; i++) {
            if (ObPtr->Value.Buffer[i] != BadBuffer [i]) {
                shouldChange = FALSE;
            }
        }
        if (shouldChange) {
            ReplaceValue (ObPtr, GoodBuffer, GoodBufferSize);
        }
    }
    return TRUE;
}

//
// magic values for CD Player Deluxe
//

#define PM_BASE             0x8CA0
#define PM_STANDARD         0x0005
#define PM_REPEATTRACK      0x0006
#define PM_REPEATALL        0x0007
#define PM_RANDOM           0x0008
#define PM_PREVIEW          0x0009

#define DM_CDELA            0x0001
#define DM_CDREM            0x0002
#define DM_TRELA            0x0004
#define DM_TRREM            0x0008


DWORD
pConvertPlayMode (
    IN      PCTSTR OldSetting,
    IN      DWORD OldValue
    )
{
    if (StringIMatch (OldSetting, TEXT("ContinuousPlay"))) {
        //
        // if set, this will become Repeat All
        //
        if (OldValue) {
            return PM_BASE | PM_REPEATALL;
        }
    } else if (StringIMatch (OldSetting, TEXT("InOrderPlay"))) {
        //
        // if not set, this will become Random
        //
        if (OldValue == 0) {
            return PM_BASE | PM_RANDOM;
        }
    } else if (StringIMatch (OldSetting, TEXT("IntroPlay"))) {
        //
        // if set, this will become Preview
        //
        if (OldValue) {
            return PM_BASE | PM_PREVIEW;
        }
    }

    return 0;
}


DWORD
pConvertDispMode (
    IN      PCTSTR OldSetting,
    IN      DWORD OldValue
    )
{
    if (StringIMatch (OldSetting, TEXT("DisplayDr"))) {
        //
        // if set, this will become CD Time Elapsed
        //
        if (OldValue) {
            return DM_CDREM;
        }
    } else if (StringIMatch (OldSetting, TEXT("DisplayT"))) {
        //
        // if set, this will become Track Time Elapsed
        //
        if (OldValue) {
            return DM_TRELA;
        }
    } else if (StringIMatch (OldSetting, TEXT("DisplayTr"))) {
        //
        // if set, this will become Track Time Remaining
        //
        if (OldValue) {
            return DM_TRREM;
        }
    }

    return 0;
}


BOOL
ValFn_ConvertCDPlayerSettings (
    PDATAOBJECT ObPtr
    )
{
    DWORD PlayMode;
    DWORD DispMode;

    //
    // all values must be REG_DWORD
    //
    if (!(ObPtr->ObjectType & OT_REGISTRY_TYPE) || ObPtr->Type != REG_DWORD) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    }

    PlayMode = pConvertPlayMode (ObPtr->ValueName, *(DWORD*)ObPtr->Value.Buffer);
    if (PlayMode) {
        //
        // set this last option; it will override previously set option
        //
        return ReplaceValue (ObPtr, (PBYTE)&PlayMode, sizeof (PlayMode));
    }

    DispMode = pConvertDispMode (ObPtr->ValueName, *(DWORD*)ObPtr->Value.Buffer);
    if (DispMode) {
        //
        // only one of these options can be set
        //
        return ReplaceValue (ObPtr, (PBYTE)&DispMode, sizeof (DispMode));
    }

    SetLastError (ERROR_SUCCESS);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\usermig.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    usermig.c

Abstract:

    The functions in this module are called to perform migration of
    per-user settings.

Author:

    Jim Schmidt (jimschm) 04-Feb-1997

Revision History:

    jimschm     23-Sep-1998 Redesigned for new progress bar and
                            shell code
    jimschm     11-Jul-1998 Support for dynamic user profile dir,
                            removal of MikeCo code.
    calinn      12-Dec-1997 Added RestoreMMSettings_User
    jimschm     21-Apr-1997 Added UserProfileExt

--*/

#include "pch.h"
#include "migmainp.h"

#ifndef UNICODE
#error UNICODE required
#endif

VOID
pSuppressEmptyWallpaper (
    VOID
    );


VOID
pCheckY2KCompliance (
    VOID
    );


DWORD
PrepareUserForMigration (
    IN      DWORD Request,
    IN      PMIGRATE_USER_ENUM EnumPtr
    )
{
    static USERMIGDATA Data;
    static BOOL DefaultHiveLoaded = FALSE;
    LONG rc;
    MEMDB_ENUM e;
    TCHAR RegKey[MAX_REGISTRY_KEY];
    TCHAR RegValueName[MAX_REGISTRY_VALUE_NAME];
    TCHAR RegValueKey[MEMDB_MAX];
    PCTSTR RegValue;
    TCHAR DefaultUserHive[MAX_TCHAR_PATH];
    static TCHAR ReferenceDefaultUserHive[MAX_TCHAR_PATH];
    PTSTR p, q;
    HKEY Key;
    DWORD Size;
    PTSTR LogFile;
    DWORD valueType;

    if (Request == REQUEST_QUERYTICKS) {

        return TICKS_PERUSER_INIT;

    } else if (Request == REQUEST_BEGINUSERPROCESSING) {

        //
        // Save current state of memdb (to be reloaded for each user)
        //

        MemDbSave (GetMemDbDat());
        return ERROR_SUCCESS;

    } else if (Request != REQUEST_RUN &&
               Request != REQUEST_ENDUSERPROCESSING
               ) {
        return ERROR_SUCCESS;
    }

    //
    // We are now begining to process another user, or we are being
    // called one last time after all users are processed.  Clean up
    // the previous state.
    //

    if (Data.UserHiveRootOpen) {
        CloseRegKey (Data.UserHiveRoot);
    }

    if (Data.UserHiveRootCreated) {
        pSetupRegistryDelnode (HKEY_CURRENT_CONFIG, S_TEMP_USER_KEY);
    }

    if (Data.LastUserWasDefault) {
        RegUnLoadKey (HKEY_LOCAL_MACHINE, S_TEMP_USER_KEY);
    }

    if (Data.ProfileToDelete[0]) {
        if (Data.LastUserWasDefault && !Data.DefaultHiveSaved) {
            //
            // Default User hive could not be saved, so restore the file
            //

            OurMoveFile (Data.ProfileToDelete, Data.TempProfile);

        } else {

            //
            // The original default hive needs to be removed
            //

            DeleteFile (Data.ProfileToDelete);

            LogFile = DuplicatePathString (Data.ProfileToDelete, 5);
            StringCat (LogFile, TEXT(".log"));

            DeleteFile (LogFile);

            FreePathString (LogFile);
        }
    }

    ZeroMemory (&Data, sizeof (Data));

    if (Request == REQUEST_ENDUSERPROCESSING) {

        if (DefaultHiveLoaded) {
            rc = RegUnLoadKey (HKEY_LOCAL_MACHINE, S_MAPPED_DEFAULT_USER_KEY);
            if (rc != ERROR_SUCCESS) {
                SetLastError (rc);
                DEBUGMSG ((DBG_ERROR, "Can't unload Default User hive in cleanup"));
            }

            SetFileAttributes (ReferenceDefaultUserHive, FILE_ATTRIBUTE_NORMAL);
            DeleteFile (ReferenceDefaultUserHive);

            DefaultHiveLoaded = FALSE;
        }

        return ERROR_SUCCESS;

    }

    MYASSERT (Request == REQUEST_RUN);

    //
    // Initialize globals
    //

    if (EnumPtr->AccountType != LOGON_USER_SETTINGS) {
        g_DomainUserName = EnumPtr->FixedDomainName;
        g_Win9xUserName  = EnumPtr->Win9xUserName;
        g_FixedUserName  = EnumPtr->FixedUserName;
    } else {
        g_DomainUserName = NULL;
        g_Win9xUserName  = NULL;
        g_FixedUserName  = NULL;
    }

    //
    // If default user hive has not been mapped in yet, map it in now.
    // This will stay open as a reference.
    //

    if (!DefaultHiveLoaded) {

        Size = ARRAYSIZE(DefaultUserHive)- 12;
        if (!GetDefaultUserProfileDirectory (DefaultUserHive, &Size)) {
            LOG ((
                LOG_ERROR,
                "Process User: Can't get default user profile directory"
                ));

            return GetLastError();
        }

        StringCopy (AppendWack (DefaultUserHive), TEXT("ntuser.dat"));

        StringCopy (ReferenceDefaultUserHive, DefaultUserHive);
        StringCat (ReferenceDefaultUserHive, TEXT(".ref"));

        SetFileAttributes (ReferenceDefaultUserHive, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (ReferenceDefaultUserHive);

        if (!CopyFile (DefaultUserHive, ReferenceDefaultUserHive, FALSE)) {
            LOG ((
                LOG_ERROR,
                "Process User: Can't copy default user hive %s",
                DefaultUserHive
                ));

            return GetLastError();
        }

        rc = RegLoadKey (
                HKEY_LOCAL_MACHINE,
                S_MAPPED_DEFAULT_USER_KEY,
                ReferenceDefaultUserHive
                );

        if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            LOG ((
                LOG_ERROR,
                "Process User: RegLoadKey could not load NT Default User from %s",
                ReferenceDefaultUserHive
                ));
            return rc;
        }

        DefaultHiveLoaded = TRUE;
    }

    //
    // Prepare temp registry key
    //

    ZeroMemory (&Data, sizeof (Data));
    EnumPtr->ExtraData = &Data;

    switch (EnumPtr->AccountType) {

    case DEFAULT_USER_ACCOUNT:

        Size = MAX_TCHAR_PATH;
        GetDefaultUserProfileDirectory (Data.TempProfile, &Size);
        StringCopy (AppendWack (Data.TempProfile), TEXT("ntuser.dat"));

        //
        // Move the default user hive to a new file, so we can update
        // it with RegSaveKey later.
        //

        wsprintf (
            Data.ProfileToDelete,
            TEXT("%s.$$$"),
            Data.TempProfile
            );

        SetFileAttributes (Data.ProfileToDelete, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (Data.ProfileToDelete);

        MYASSERT (!DoesFileExist (Data.ProfileToDelete));

        if (!OurMoveFile (Data.TempProfile, Data.ProfileToDelete)) {

            rc = GetLastError();

            LOG ((
                LOG_ERROR,
                "Process User: OurMoveFile failed to move %s to %s",
                Data.TempProfile,
                Data.ProfileToDelete
                ));

            return rc;

        }

        //
        // Load the true Default User hive from its new location
        //

        rc = RegLoadKey (
                HKEY_LOCAL_MACHINE,
                S_TEMP_USER_KEY,
                Data.ProfileToDelete
                );

        if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            LOG ((
                LOG_ERROR,
                "Process User: RegLoadKey could not load NT Default User from %s",
                Data.ProfileToDelete
                ));
            return rc;
        }

        Data.UserHiveRoot = OpenRegKey (HKEY_LOCAL_MACHINE, S_TEMP_USER_KEY);
        if (!Data.UserHiveRoot) {
            LOG ((LOG_ERROR, "Process User: RegOpenKey could not open NT Default User hive"));
            return GetLastError();
        }

        Data.UserHiveRootOpen = TRUE;
        Data.LastUserWasDefault = TRUE;

        break;

    case LOGON_USER_SETTINGS:
        //
        // Set Data.UserHiveRoot to HKU\.Default
        //

        Data.UserHiveRoot = OpenRegKey (HKEY_USERS, S_DOT_DEFAULT);
        if (!Data.UserHiveRoot) {
            LOG ((LOG_ERROR, "Process User: RegOpenKey could not open HKU\\.Default"));
            return GetLastError();
        }

        Data.UserHiveRootOpen = TRUE;

        //
        // Suppress wallpaper if it is an empty string
        //

        pSuppressEmptyWallpaper();

        break;

    default:
        MYASSERT (g_Win9xUserName);

        //
        // Prepare the string "c:\windows\setup\ntuser.dat"
        //

        StringCopy (Data.TempProfile, g_TempDir);
        StringCopy (AppendWack (Data.TempProfile), TEXT("NTUSER.DAT"));

        //
        // Save this string in ProfileToDelete for cleanup later
        //

        StringCopy (Data.ProfileToDelete, Data.TempProfile);

        //
        // Create HKCC\$$$ and set Data.UserHiveRoot
        //

        rc = TrackedRegCreateKey (HKEY_CURRENT_CONFIG, S_TEMP_USER_KEY, &Data.UserHiveRoot);
        if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            LOG ((LOG_ERROR, "Process User: WinNTRegCreateKey failed to make %s in HKCC", S_TEMP_USER_KEY));
            return rc;
        }

        Data.UserHiveRootCreated = TRUE;
        Data.UserHiveRootOpen = TRUE;

        //
        // Set the per-user registry values
        //

        if (MemDbGetValueEx (&e, MEMDB_CATEGORY_SET_USER_REGISTRY, g_FixedUserName, NULL)) {
            do {

                p = _tcschr (e.szName, TEXT('['));
                if (p) {
                    DecodeRuleCharsAB (RegKey, e.szName, p);
                    q = _tcsrchr (RegKey, TEXT('\\'));
                    if (!q[1]) {
                        *q = 0;
                    }

                    p = _tcsinc (p);
                    q = _tcschr (p, TEXT(']'));

                    if (q) {
                        DecodeRuleCharsAB (RegValueName, p, q);

                        MemDbBuildKeyFromOffset (e.dwValue, RegValueKey, 0, NULL);
                        RegValue = _tcschr (RegValueKey, TEXT('\\'));
                        MYASSERT (RegValue);
                        if (!RegValue) {
                            RegValue = RegValueKey;
                        } else {
                            RegValue = _tcsinc (RegValue);
                        }

                        if (!MemDbGetValue (RegValueKey, &valueType) || valueType == 0) {
                            valueType = REG_SZ;
                        }

                        Key = CreateRegKey (Data.UserHiveRoot, RegKey);
                        if (!Key) {
                            DEBUGMSG ((DBG_WHOOPS, "Can't create %s", RegKey));
                        } else {
                            rc = RegSetValueEx (
                                    Key,
                                    RegValueName,
                                    0,
                                    valueType,
                                    (PBYTE) RegValue,
                                    SizeOfString (RegValue)
                                    );

                            CloseRegKey (Key);

                            DEBUGMSG_IF ((
                                rc != ERROR_SUCCESS,
                                DBG_WHOOPS,
                                "Can't save %s [%s] = %s (rc = %u)",
                                RegKey,
                                RegValueName,
                                RegValue,
                                rc
                                ));
                        }
                    }
                    ELSE_DEBUGMSG ((DBG_WHOOPS, "Key not encoded properly: %s", e.szName));
                }
                ELSE_DEBUGMSG ((DBG_WHOOPS, "Key not encoded properly: %s", e.szName));

            } while (MemDbEnumNextValue (&e));
        }

        break;
    }

    //
    // Data.UserHiveRoot is either HKCU\$$$ or HKU\.Default
    //

    g_hKeyRootNT = Data.UserHiveRoot;

    //
    // Load in default MemDb state
    //

    MemDbLoad (GetMemDbDat());

    return ERROR_SUCCESS;
}


DWORD
MigrateUserRegistry (
    IN      DWORD Request,
    IN      PMIGRATE_USER_ENUM EnumPtr
    )
{
    if (Request == REQUEST_QUERYTICKS) {

        return TICKS_USER_REGISTRY_MIGRATION;

    } else if (Request != REQUEST_RUN) {

        return ERROR_SUCCESS;

    }

    if (!MergeRegistry (S_USERMIG_INF, g_DomainUserName ? g_DomainUserName : S_EMPTY)) {
        LOG ((LOG_ERROR, "Process User: MergeRegistry failed"));
        return GetLastError();
    }

    return ERROR_SUCCESS;
}


DWORD
MigrateLogonPromptSettings (
    IN      DWORD Request,
    IN      PMIGRATE_USER_ENUM EnumPtr
    )
{
    if (Request == REQUEST_QUERYTICKS) {

        return TICKS_LOGON_PROMPT_SETTINGS;

    } else if (Request != REQUEST_RUN) {

        return ERROR_SUCCESS;

    }

    if (EnumPtr->AccountType != LOGON_USER_SETTINGS) {
        return ERROR_SUCCESS;
    }

    MYASSERT (EnumPtr->ExtraData);

    return ERROR_SUCCESS;
}


DWORD
MigrateUserSettings (
    IN      DWORD Request,
    IN      PMIGRATE_USER_ENUM EnumPtr
    )
{
    if (Request == REQUEST_QUERYTICKS) {

        return TICKS_USER_SETTINGS;

    } else if (Request != REQUEST_RUN) {

        return ERROR_SUCCESS;

    }

    if (EnumPtr->AccountType == LOGON_USER_SETTINGS) {
        return ERROR_SUCCESS;
    }

    MYASSERT (EnumPtr->ExtraData);

    //
    // Copy any settings from DOS configuration files that need to be
    // saved into the per user configuration.
    //

    if (EnumPtr->AccountType != DEFAULT_USER_ACCOUNT) {

        if (DosMigNt_User (g_hKeyRootNT) != EXIT_SUCCESS) {
            LOG ((LOG_ERROR,"DosMigNt failed."));
        }

    }

    //
    // Pull in all the per-user INI settings  (TRUE indicates per-user settings)
    //

    if (!ProcessIniFileMapping (TRUE)) {
        LOG ((LOG_ERROR, "Process User: Could not migrate one or more .INI files."));
    }

    //
    // Now look for Short Date format settings
    //
    pCheckY2KCompliance ();

    //
    // Restore multimedia settings
    //

    if (!RestoreMMSettings_User (g_FixedUserName, g_hKeyRootNT)) {
        LOG ((LOG_ERROR, "Process User: Could not restore multimedia settings."));
    }

    //
    // Create the RAS entries for the user.
    //
    if (!Ras_MigrateUser (g_FixedUserName, g_hKeyRootNT)) {
        LOG ((LOG_ERROR,"Ras user migration failed."));
    }

    //
    // Create the TAPI entries that are per user.
    //
    if (!Tapi_MigrateUser (g_FixedUserName, g_hKeyRootNT)) {
        LOG ((LOG_ERROR,"Tapi user migration failed."));
    }


    return ERROR_SUCCESS;
}


DWORD
SaveMigratedUserHive (
    IN      DWORD Request,
    IN      PMIGRATE_USER_ENUM EnumPtr
    )
{
    PTSTR UserProfile = NULL;
    PCTSTR UserNameWithSuffix;
    PSID Sid;
    LONG rc = ERROR_SUCCESS;
    PUSERMIGDATA Data;
    PCTSTR CopyOfProfile;
    PTSTR Path;
    MIGRATE_USER_ENUM e;

    if (Request == REQUEST_QUERYTICKS) {

        return TICKS_SAVE_USER_HIVE;

    } else if (Request != REQUEST_RUN) {

        return ERROR_SUCCESS;

    }

    MYASSERT (EnumPtr->ExtraData);
    Data = EnumPtr->ExtraData;

    if (EnumPtr->AccountType == LOGON_USER_SETTINGS) {
        return ERROR_SUCCESS;
    }

    if (Data->TempProfile[0] && !Data->LastUserWasDefault) {

        //
        // Save the hive to disk
        //

        SetFileAttributes (Data->TempProfile, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (Data->TempProfile);

        MYASSERT (Data->UserHiveRootOpen);

        rc = RegSaveKey (Data->UserHiveRoot, Data->TempProfile, NULL);

        if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            LOG ((LOG_ERROR, "RegSaveKey failed to save %s", Data->TempProfile));
            return rc;

        } else {

            SetFileAttributes (Data->TempProfile, FILE_ATTRIBUTE_HIDDEN);

        }

        //
        // Look up account SID
        //

        Sid = GetSidForUser (g_FixedUserName);
        if (!Sid) {
            DEBUGMSG ((DBG_WARNING, "Could not obtain SID for %s", g_FixedUserName));
            return GetLastError();
        }

        //
        // Add the user to the local power users or administrators group
        //

        if (g_PersonalSKU) {
            if (EnumPtr->AccountType != ADMINISTRATOR_ACCOUNT) {

                LOG_IF ((
                    g_ConfigOptions.MigrateUsersAsPowerUsers,
                    LOG_WARNING,
                    "MigrateUsersAsPowerUsers option is ignored on upgrade to Personal SKU"
                    ));

                LOG_IF ((
                    g_ConfigOptions.MigrateUsersAsAdmin,
                    LOG_WARNING,
                    "MigrateUsersAsAdmin option is ignored on upgrade to Personal SKU"
                    ));

                if (!AddSidToLocalGroup (Sid, g_AdministratorsGroupStr)) {
                    DEBUGMSG ((DBG_WARNING, "Could not add %s to %s group", g_FixedUserName, g_AdministratorsGroupStr));
                }
            }
        } else {
            if (g_ConfigOptions.MigrateUsersAsPowerUsers) {

                if (!AddSidToLocalGroup (Sid, g_PowerUsersGroupStr)) {
                    DEBUGMSG ((DBG_WARNING, "Could not add %s to %s group", g_FixedUserName, g_PowerUsersGroupStr));
                }

            } else if (EnumPtr->AccountType != ADMINISTRATOR_ACCOUNT &&
                       g_ConfigOptions.MigrateUsersAsAdmin
                       ) {

                if (!AddSidToLocalGroup (Sid, g_AdministratorsGroupStr)) {
                    DEBUGMSG ((DBG_WARNING, "Could not add %s to %s group", g_FixedUserName, g_AdministratorsGroupStr));
                }
            } else {
                SetClassicLogonType();
            }
        }

        __try {

            //
            // Prepare profile directory
            //

            UserNameWithSuffix = GetUserProfilePath (g_FixedUserName, &UserProfile);
            MYASSERT (UserNameWithSuffix);
            MYASSERT (UserProfile);

            if (!UserNameWithSuffix) {
                rc = GetLastError();
                __leave;
            }

            //
            // The recommendation here (UserNameWithSuffix) is no longer used, because
            // we already created the user profile dir before processing the user.
            //

            if (!CreateUserProfile (
                    Sid,
                    UserNameWithSuffix,         // User or User.000
                    Data->TempProfile,
                    NULL,
                    0
                    )) {
                LOG ((LOG_ERROR, "Create User Profile failed"));
                rc = GetLastError();
                __leave;
            }

            //
            // Build the final location of the user's hive, so migdlls.c
            // can load the hive.
            //

            wsprintf (
                Data->TempProfile,
                TEXT("%s\\ntuser.dat"),
                UserProfile
                );
        }
        __finally {
            FreePathString (UserProfile);
        }

    } else if (Data->LastUserWasDefault) {

        SetFileAttributes (Data->TempProfile, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (Data->TempProfile);

        //
        // Save the hive
        //

        rc = RegSaveKey (Data->UserHiveRoot, Data->TempProfile, NULL);

        if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            LOG ((LOG_ERROR, "Process User: RegSaveKey failed to save %s", Data->TempProfile));

        } else {

            SetFileAttributes (Data->TempProfile, FILE_ATTRIBUTE_HIDDEN);

            Data->DefaultHiveSaved = TRUE;

            //
            // Find Administrator
            //

            if (EnumFirstUserToMigrate (&e, ENUM_ALL_USERS)) {
                do {
                    if (e.AccountType == ADMINISTRATOR_ACCOUNT) {
                        break;
                    }
                } while (EnumNextUserToMigrate (&e));
            }

            if (e.AccountType == ADMINISTRATOR_ACCOUNT && e.CreateOnly) {

                //
                // Copy the hive to Administrator if (A) the Administrator is
                // not a migrated user, and (B) the hive exists
                //

                if (GetUserProfilePath (e.FixedUserName, &Path)) {

                    DeleteDirectoryContents (Path);

                    SetFileAttributes (Path, FILE_ATTRIBUTE_NORMAL);
                    if (!RemoveDirectory (Path)) {
                        DEBUGMSG ((DBG_ERROR, "Can't remove %s", Path));
                    }
                    ELSE_DEBUGMSG ((DBG_VERBOSE, "Administrator profile %s removed", Path));

                    FreePathString (Path);
                }
                ELSE_DEBUGMSG ((DBG_WHOOPS, "User %s does not have a profile path", e.FixedUserName));
            }
        }
    }

    if (rc == ERROR_SUCCESS) {

        //
        // Add hive location to string table
        //

        CopyOfProfile = PoolMemDuplicateString (g_HivePool, Data->TempProfile);

        DEBUGMSG ((
            DBG_NAUSEA,
            "ProcessUser: Adding hive location %s for user %s",
            CopyOfProfile,
            g_FixedUserName
            ));

        pSetupStringTableAddStringEx (
            g_HiveTable,
            (PTSTR) g_FixedUserName,
            STRTAB_CASE_INSENSITIVE,
            (PTSTR) CopyOfProfile,
            SizeOfString (CopyOfProfile)
            );
    } else {

        //
        // The hive couldn't be saved for this user!!  Tell the user.
        //

        LOG ((LOG_ERROR, (PCSTR)MSG_PROFILE_ERROR, g_FixedUserName));

    }

    return rc;
}


PCTSTR
GetUserProfilePath (
    IN      PCTSTR AccountName,
    OUT     PTSTR *BufferPtr
    )

/*++

Routine Description:

  Generates the full path to a user's profile.  The user profile directory may have
  an extension (joeuser.001), and we must maintain that extension.

Arguments:

  AccountName   - Supplies the name of the user (fixed version, without the domain)

  BufferPtr     - Receives the full path to the user's profile directory, for example:

                      c:\windows\profiles\joeuser.001

                  This buffer must be freed with FreePathString.

Return Value:

  A pointer to the user name with extension (joeuser.001) or NULL if something went
  terribly wrong.

--*/

{
    PTSTR p;
    TCHAR ProfileNameWithExt[MEMDB_MAX];

    //
    // Get the profile path obtained from CreateUserProfile
    //

    p = (PTSTR) GetProfilePathForUser (AccountName);

    if (p) {

        *BufferPtr = DuplicatePathString (p, 0);

    } else {
        //
        // This is to guard against unexpected errors.  The user
        // will lose profile folder contents, but they can be recovered.
        //
        // Create %windir%\<user> (or <ProfileNameWithExt> if it exists)
        //

        MYASSERT (FALSE);       // this should not happen

        ProfileNameWithExt[0] = 0;
        MemDbGetEndpointValueEx (
            MEMDB_CATEGORY_USER_PROFILE_EXT,
            AccountName,
            NULL,
            ProfileNameWithExt
            );

        *BufferPtr = JoinPaths (g_WinDir, ProfileNameWithExt[0] ? ProfileNameWithExt : AccountName);
    }

    //
    // Return user name with suffix (i.e. joeuser.001)
    //

    p = _tcsrchr (*BufferPtr, TEXT('\\'));
    if (p) {
        p = _tcsinc (p);
    }

    DEBUGMSG ((DBG_VERBOSE, "GetUserProfilePath: Account %s profile extension is %s", AccountName, p));

    return p;
}


BOOL
pCopyDefaultShellFolders (
    IN      PCTSTR DestRoot
    )
{
    TCHAR DefFolders[MAX_TCHAR_PATH];

    GetEnvironmentVariable (S_USERPROFILE, DefFolders, MAX_TCHAR_PATH);

    return CopyTree (
                DefFolders,
                DestRoot,
                0,              // no EnumTree ID
                COPYTREE_DOCOPY | COPYTREE_NOOVERWRITE,
                ENUM_ALL_LEVELS,
                FILTER_ALL,
                NULL,           // no exclude.inf struct
                NULL,           // no callback
                NULL            // no error callback
                );
}


VOID
pSuppressEmptyWallpaper(
    VOID
    )
{
    HKEY Key;
    LONG rc;
    DWORD Size;
    TCHAR Buffer[MAX_TCHAR_PATH];

    rc = TrackedRegOpenKeyEx95 (g_hKeyRoot95, S_DESKTOP_KEY, 0, KEY_READ, &Key);
    if (rc == ERROR_SUCCESS) {

        Size = sizeof (Buffer);
        rc = Win95RegQueryValueEx (
                Key,
                S_WALLPAPER,
                NULL,
                NULL,
                (PBYTE) Buffer,
                &Size
                );

        if (rc == ERROR_SUCCESS) {
            if (!Buffer[0]) {
                TCHAR Node[MEMDB_MAX];

                wsprintf (
                    Node,
                    TEXT("%s\\%s\\[%s]"),
                    S_HKR,
                    S_DESKTOP_KEY,
                    S_WALLPAPER
                    );

                DEBUGMSG ((DBG_VERBOSE, "Logon wallpaper is (none), suppressing %s", Node));

                SuppressWin95Object (Node);

                wsprintf (
                    Node,
                    TEXT("%s\\%s\\[%s]"),
                    S_HKR,
                    S_DESKTOP_KEY,
                    S_WALLPAPER_STYLE
                    );

                SuppressWin95Object (Node);

                wsprintf (
                    Node,
                    TEXT("%s\\%s\\[%s]"),
                    S_HKR,
                    S_DESKTOP_KEY,
                    S_TILE_WALLPAPER
                    );

                SuppressWin95Object (Node);
            }
            ELSE_DEBUGMSG ((DBG_VERBOSE, "Logon wallpaper is '%s'", Buffer));
        }
        ELSE_DEBUGMSG ((DBG_VERBOSE, "Logon wallpaper not specified in desktop key"));

        CloseRegKey95 (Key);
    }
    ELSE_DEBUGMSG ((DBG_VERBOSE, "Logon wallpaper not specified"));
}


DWORD
RunPerUserExternalProcesses (
    IN      DWORD Request,
    IN      PMIGRATE_USER_ENUM EnumPtr
    )
{
    LONG Count;

    if (Request == REQUEST_QUERYTICKS) {
        //
        // Count the number of entries and multiply by a constant
        //

        Count = SetupGetLineCount (g_UserMigInf, S_EXTERNAL_PROCESSES);

        if (Count < 1) {
            return 0;
        }

        return Count * TICKS_USER_EXTERN_PROCESSES;
    }

    if (Request != REQUEST_RUN) {
        return ERROR_SUCCESS;
    }

    //
    // Loop through the processes and run each of them
    //

    RunExternalProcesses (g_UserMigInf, EnumPtr);
    return ERROR_SUCCESS;
}


VOID
pCheckY2KCompliance (
    VOID
    )
{
    HKEY Key95, KeyNT;
    LONG rc;
    TCHAR Buffer[100];
    DWORD Locale;
    int Result;
    PCTSTR ShortDate;

    //
    // read registry setting for sShortDate from Win9x registry
    //
    Key95 = OpenRegKey95 (g_hKeyRoot95, S_INTERNATIONAL_KEY);
    if (Key95) {

        ShortDate = GetRegValueString95 (Key95, S_SHORT_DATE_VALUE);
        if (!ShortDate) {
            //
            // set the new date format
            //
            GetGlobalCodePage (NULL, &Locale);

            Result = GetLocaleInfo (
                        Locale,
                        LOCALE_SSHORTDATE | LOCALE_NOUSEROVERRIDE,
                        Buffer,
                        sizeof (Buffer) / sizeof (TCHAR)
                        );
            if (Result > 0) {

                KeyNT = OpenRegKey (g_hKeyRootNT, S_INTERNATIONAL_KEY);
                if (KeyNT) {

                    rc = RegSetValueEx (
                            KeyNT,
                            S_SHORT_DATE_VALUE,
                            0,
                            REG_SZ,
                            (PCBYTE)Buffer,
                            SizeOfString (Buffer)
                            );
                    LOG_IF ((rc != ERROR_SUCCESS, LOG_ERROR, "Could not set [sShortDate] default format"));

                    CloseRegKey (KeyNT);
                }
            }
            ELSE_DEBUGMSG ((DBG_ERROR, "GetLocaleInfo returned 0 for LOCALE_SSHORTDATE | LOCALE_NOUSEROVERRIDE"));

        } else {

            DEBUGMSG ((
                DBG_VERBOSE,
                "HKR\\Control Panel\\International [sShortDate] already set to [%s] for user %s",
                ShortDate,
                g_FixedUserName
                ));

            MemFree (g_hHeap, 0, (PVOID)ShortDate);
        }

        CloseRegKey95 (Key95);
    }
}

DWORD
RunPerUserUninstallUserProfileCleanupPreparation(
    IN      DWORD Request,
    IN      PMIGRATE_USER_ENUM EnumPtr
    )
{
    LONG Count;

    if (Request == REQUEST_QUERYTICKS) {
        //
        // Count the number of entries and multiply by a constant
        //

        Count = SetupGetLineCount (g_UserMigInf, S_UNINSTALL_PROFILE_CLEAN_OUT);

#ifdef PROGRESS_BAR
        DEBUGLOGTIME (("RunPerUserUninstallUserProfileCleanupPreparation: FileNumber=%ld", Count));
#endif

        if (Count < 1) {
            return 0;
        }

        return Count * TICKS_USER_UNINSTALL_CLEANUP;
    }

    if (Request != REQUEST_RUN) {
        return ERROR_SUCCESS;
    }

    //
    // Loop through the files and mark them to be deleted during uninstall
    //
    UninstallUserProfileCleanupPreparation (g_UserMigInf, EnumPtr, FALSE);

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\rulehlpr\scheme.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    scheme.c

Abstract:

    Control Panel scheme converters

    The helper functions in this source file converts an ANSI-
    based Win95 scheme into a UNICODE-based NT scheme.  Also
    supplied is a logical font converter, closely related
    to the scheme converter.

Author:

    Jim Schmidt (jimschm) 9-Aug-1996

Revision History:

--*/


#include "pch.h"


#define COLOR_MAX_V1 25
#define COLOR_MAX_V3 25
#define COLOR_MAX_V4 29
#define COLOR_MAX_NT 29     // this is a modified version 2 format, similar to 4

//
// Win95 uses a mix of LOGFONTA and a weird 16-bit LOGFONT
// structure that uses SHORTs instead of LONGs.
//

typedef struct {
    SHORT lfHeight;
    SHORT lfWidth;
    SHORT lfEscapement;
    SHORT lfOrientation;
    SHORT lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    char lfFaceName[LF_FACESIZE];
} SHORT_LOGFONT, *PSHORT_LOGFONT;

//
// NT uses only UNICODE structures, and pads the members
// to 32-bit boundaries.
//

typedef struct {
    SHORT version;              // 2 for NT UNICODE
    WORD  wDummy;               // for alignment
    NONCLIENTMETRICSW ncm;
    LOGFONTW lfIconTitle;
    COLORREF rgb[COLOR_MAX_NT];
} SCHEMEDATA_NT, *PSCHEMEDATA_NT;

//
// Win95 uses NONCLIENTMETRICSA which has LOGFONTA members,
// but it uses a 16-bit LOGFONT as well.
//

#pragma pack(push)
#pragma pack(1)

typedef struct {
    SHORT version;              // 1 for Win95 ANSI
    NONCLIENTMETRICSA ncm;
    SHORT_LOGFONT lfIconTitle;
    COLORREF rgb[COLOR_MAX_V1];
} SCHEMEDATA_V1, *PSCHEMEDATA_V1;

typedef struct {
    SHORT version;              // 1 for Win95 ANSI

    NONCLIENTMETRICSA ncm;
    SHORT_LOGFONT lfIconTitle;
    COLORREF rgb[COLOR_MAX_V4];
} SCHEMEDATA_V1A, *PSCHEMEDATA_V1A;


typedef struct {
    SHORT version;              // 3 for Win98 ANSI, 4 for portable format
    WORD Dummy;
    NONCLIENTMETRICSA ncm;
    LOGFONTA lfIconTitle;
    COLORREF rgb[COLOR_MAX_V3];
} SCHEMEDATA_V3, *PSCHEMEDATA_V3;

typedef struct {
    SHORT version;              // 4 for Win32 format (whatever that means)
    WORD Dummy;
    NONCLIENTMETRICSA ncm;
    LOGFONTA lfIconTitle;
    COLORREF rgb[COLOR_MAX_V4];
} SCHEMEDATA_V4, *PSCHEMEDATA_V4;

#pragma pack(pop)


//
// Some utility functions
//

void
ConvertLF (LOGFONTW *plfDest, const LOGFONTA *plfSrc)
{
    plfDest->lfHeight = plfSrc->lfHeight;
    plfDest->lfWidth = plfSrc->lfWidth;
    plfDest->lfEscapement = plfSrc->lfEscapement;
    plfDest->lfOrientation = plfSrc->lfOrientation;
    plfDest->lfWeight = plfSrc->lfWeight;
    plfDest->lfItalic = plfSrc->lfItalic;
    plfDest->lfUnderline = plfSrc->lfUnderline;
    plfDest->lfStrikeOut = plfSrc->lfStrikeOut;
    plfDest->lfCharSet = plfSrc->lfCharSet;
    plfDest->lfOutPrecision = plfSrc->lfOutPrecision;
    plfDest->lfClipPrecision = plfSrc->lfClipPrecision;
    plfDest->lfQuality = plfSrc->lfQuality;
    plfDest->lfPitchAndFamily = plfSrc->lfPitchAndFamily;

    MultiByteToWideChar (OurGetACP(),
                         0,
                         plfSrc->lfFaceName,
                         -1,
                         plfDest->lfFaceName,
                         sizeof (plfDest->lfFaceName) / sizeof (WCHAR));
}


void
ConvertLFShort (LOGFONTW *plfDest, const SHORT_LOGFONT *plfSrc)
{
    plfDest->lfHeight = plfSrc->lfHeight;
    plfDest->lfWidth = plfSrc->lfWidth;
    plfDest->lfEscapement = plfSrc->lfEscapement;
    plfDest->lfOrientation = plfSrc->lfOrientation;
    plfDest->lfWeight = plfSrc->lfWeight;
    plfDest->lfItalic = plfSrc->lfItalic;
    plfDest->lfUnderline = plfSrc->lfUnderline;
    plfDest->lfStrikeOut = plfSrc->lfStrikeOut;
    plfDest->lfCharSet = plfSrc->lfCharSet;
    plfDest->lfOutPrecision = plfSrc->lfOutPrecision;
    plfDest->lfClipPrecision = plfSrc->lfClipPrecision;
    plfDest->lfQuality = plfSrc->lfQuality;
    plfDest->lfPitchAndFamily = plfSrc->lfPitchAndFamily;

    MultiByteToWideChar (OurGetACP(),
                         0,
                         plfSrc->lfFaceName,
                         -1,
                         plfDest->lfFaceName,
                         sizeof (plfDest->lfFaceName) / sizeof (WCHAR));
}


VOID
ConvertNonClientMetrics (
    OUT     NONCLIENTMETRICSW *Dest,
    IN      NONCLIENTMETRICSA *Src
    )
{
    Dest->cbSize = sizeof (NONCLIENTMETRICSW);
    Dest->iBorderWidth = Src->iBorderWidth;
    Dest->iScrollWidth = Src->iScrollWidth;
    Dest->iScrollHeight = Src->iScrollHeight;
    Dest->iCaptionWidth = Src->iCaptionWidth;
    Dest->iCaptionHeight = Src->iCaptionHeight;
    Dest->iSmCaptionWidth = Src->iSmCaptionWidth;
    Dest->iSmCaptionHeight = Src->iSmCaptionHeight;
    Dest->iMenuWidth = Src->iMenuWidth;
    Dest->iMenuHeight = Src->iMenuHeight;

    ConvertLF (&Dest->lfCaptionFont, &Src->lfCaptionFont);
    ConvertLF (&Dest->lfSmCaptionFont, &Src->lfSmCaptionFont);
    ConvertLF (&Dest->lfMenuFont, &Src->lfMenuFont);
    ConvertLF (&Dest->lfStatusFont, &Src->lfStatusFont);
    ConvertLF (&Dest->lfMessageFont, &Src->lfMessageFont);
}


//
// And now the scheme converter
//

BOOL
ValFn_ConvertAppearanceScheme (
    IN      PDATAOBJECT ObPtr
    )
{
    SCHEMEDATA_NT sd_nt;
    PSCHEMEDATA_V1 psd_v1;
    PSCHEMEDATA_V3 psd_v3;
    PSCHEMEDATA_V4 psd_v4;
    PSCHEMEDATA_V1A psd_v1a;
    BOOL Copy3dValues = FALSE;

    psd_v1 = (PSCHEMEDATA_V1) ObPtr->Value.Buffer;

    //
    // Validate the size (must be a known size)
    //

    if (ObPtr->Value.Size != sizeof (SCHEMEDATA_V1) &&
        ObPtr->Value.Size != sizeof (SCHEMEDATA_V3) &&
        ObPtr->Value.Size != sizeof (SCHEMEDATA_V4) &&
        ObPtr->Value.Size != sizeof (SCHEMEDATA_V1A)
        ) {
        DEBUGMSG ((
            DBG_WARNING,
            "ValFn_ConvertAppearanceScheme doesn't support scheme size of %u bytes. "
                "The supported sizes are %u, %u, %u,  and %u.",
            ObPtr->Value.Size,
            sizeof (SCHEMEDATA_V1),
            sizeof (SCHEMEDATA_V1A),
            sizeof (SCHEMEDATA_V3),
            sizeof (SCHEMEDATA_V4)
            ));

        return TRUE;
    }

    //
    // Make sure the structure is a known version
    //

    if (psd_v1->version != 1 && psd_v1->version != 3 && psd_v1->version != 4) {
        DEBUGMSG ((
            DBG_WARNING,
            "ValFn_ConvertAppearanceScheme doesn't support version %u",
            psd_v1->version
            ));

        return TRUE;
    }


    //
    // Convert the structure
    //

    if (psd_v1->version == 1) {
        sd_nt.version = 2;
        ConvertNonClientMetrics (&sd_nt.ncm, &psd_v1->ncm);
        ConvertLFShort (&sd_nt.lfIconTitle, &psd_v1->lfIconTitle);

        ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
        CopyMemory (
            &sd_nt.rgb,
            &psd_v1->rgb,
            min (sizeof (psd_v1->rgb), sizeof (sd_nt.rgb))
            );

        Copy3dValues = TRUE;

    } else if (psd_v1->version == 3 && ObPtr->Value.Size == sizeof (SCHEMEDATA_V1A)) {

        psd_v1a = (PSCHEMEDATA_V1A) psd_v1;

        sd_nt.version = 2;
        ConvertNonClientMetrics (&sd_nt.ncm, &psd_v1a->ncm);
        ConvertLFShort (&sd_nt.lfIconTitle, &psd_v1a->lfIconTitle);

        ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
        CopyMemory (
            &sd_nt.rgb,
            &psd_v1a->rgb,
            min (sizeof (psd_v1a->rgb), sizeof (sd_nt.rgb))
            );

        Copy3dValues = TRUE;


    } else if (psd_v1->version == 3 && ObPtr->Value.Size == sizeof (SCHEMEDATA_V3)) {
        psd_v3 = (PSCHEMEDATA_V3) psd_v1;

        sd_nt.version = 2;
        ConvertNonClientMetrics (&sd_nt.ncm, &psd_v3->ncm);
        ConvertLF (&sd_nt.lfIconTitle, &psd_v3->lfIconTitle);

        ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
        CopyMemory (
            &sd_nt.rgb,
            &psd_v3->rgb,
            min (sizeof (psd_v3->rgb), sizeof (sd_nt.rgb))
            );

        Copy3dValues = TRUE;

    } else if (psd_v1->version == 4) {
        psd_v4 = (PSCHEMEDATA_V4) psd_v1;

        sd_nt.version = 2;
        ConvertNonClientMetrics (&sd_nt.ncm, &psd_v4->ncm);
        ConvertLF (&sd_nt.lfIconTitle, &psd_v4->lfIconTitle);

        ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
        CopyMemory (
            &sd_nt.rgb,
            &psd_v4->rgb,
            min (sizeof (psd_v4->rgb), sizeof (sd_nt.rgb))
            );

    } else {
        // not a possible case
        MYASSERT (FALSE);
    }

    if (Copy3dValues) {
        //
        // Make sure the NT structure has values for 3D colors
        //

        sd_nt.rgb[COLOR_HOTLIGHT] = sd_nt.rgb[COLOR_ACTIVECAPTION];
        sd_nt.rgb[COLOR_GRADIENTACTIVECAPTION] = sd_nt.rgb[COLOR_ACTIVECAPTION];
        sd_nt.rgb[COLOR_GRADIENTINACTIVECAPTION] = sd_nt.rgb[COLOR_INACTIVECAPTION];
    }

     return ReplaceValue (ObPtr, (LPBYTE) &sd_nt, sizeof (sd_nt));
}


//
// And logfont converter
//

BOOL
ValFn_ConvertLogFont (
    IN      PDATAOBJECT ObPtr
    )
{
    LOGFONTW lfNT;
    PSHORT_LOGFONT plf95;

    plf95 = (PSHORT_LOGFONT) ObPtr->Value.Buffer;
    if (ObPtr->Value.Size != sizeof (SHORT_LOGFONT)) {
        SetLastError (ERROR_SUCCESS);
        DEBUGMSG ((
            DBG_NAUSEA,
            "ValFn_ConvertLogFont skipped because data wasn't the right size. "
                  "%u bytes, should be %u",
            ObPtr->Value.Size,
            sizeof (SHORT_LOGFONT)
            ));

        return FALSE;
    }

    ConvertLFShort (&lfNT, plf95);

    return ReplaceValue (ObPtr, (LPBYTE) &lfNT, sizeof (lfNT));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\apmupgrd\apmrsrc.h ===
// Used by apmupgrd.rc
#define APM_STR_WARNING_DIALOG_CAPTION	1000
#define APM_STR_CONFLICT_DESCRIPTION	1001
#define APM_STR_SYSTEMSOFTPP_DISABLE	1002
#define APM_STR_SYSTEMSOFTCW_DISABLE	1003
#define APM_STR_AWARDCW_DISABLE		1004
#define APM_STR_SOFTEXP_DISABLE		1005
#define APM_STR_IBM_DISABLE		1006
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\boscomp\boscomp.h ===
#pragma once
#ifndef _BOSCOMP_H
#define _BOSCOMP_H

/* ----------------------------------------------------------------------

Copyright (c) 1998 Microsoft Corporation

Module Name:

    boscomp.h

Abstract:

    Header file for Windows NT BOS/SBS upgrade DLL

Author:

    wnelson : 2 Apr 99

    ShaoYin : 9 Sep 99 revised, add support for Exchange Server  

Revision History:

 ---------------------------------------------------------------------- */

// Required Entry points
BOOL WINAPI BosHardBlockCheck(PCOMPAIBILITYCALLBACK CompatibilityCallback,LPVOID Context);
BOOL WINAPI BosSoftBlockCheck(PCOMPAIBILITYCALLBACK CompatibilityCallback,LPVOID Context);

// Variables
extern HINSTANCE g_hinst;

// BOS/SBS version enum
typedef enum 
{
	VER_BOS25,
	VER_BOS40,
	VER_BOS45,
	VER_SBS40,
	VER_SBS40A,
	VER_SBS45,
	VER_SBSREST,
	VER_POST45,
	VER_NONE
} SuiteVersion;

// Exchange version enum
typedef enum 
{
	EXCHANGE_VER_PRE55SP3,
	EXCHANGE_VER_POST55SP3,
	EXCHANGE_VER_NONE
} ExchangeVersion;



// Functions
SuiteVersion DetermineInstalledSuite();
ExchangeVersion DetermineExchangeVersion();
void GetSuiteMessage(SuiteVersion eSV, TCHAR* szMsg, UINT nLen);
bool ProductSuiteContains(const TCHAR* szTest);
bool IsBosVersion(SuiteVersion eVersion);
bool IsSbsVersion(SuiteVersion eVersion);
void LoadResString(UINT nRes, TCHAR* szString, UINT nLen);

	


#endif _BOSCOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\apmupgrd\apmupgrd.h ===
#pragma once
#ifndef _APMUPGRD_H
#define _APMUPGRD_H

/* ----------------------------------------------------------------------

Copyright (c) 1998 Microsoft Corporation

Module Name:

    apmupgrd.h

Abstract:

    Header file for Windows NT APM upgrade DLL

Author:

    Susan Dey : 17 June 98

Revision History:

 ---------------------------------------------------------------------- */

// Required Entry points
BOOL WINAPI ApmUpgradeCompatibilityCheck(PCOMPAIBILITYCALLBACK CompatibilityCallback,
					 LPVOID Context);
DWORD WINAPI ApmUpgradeHandleHaveDisk(HWND hwndParent, LPVOID SaveValue);

// Private Functions
HRESULT HrDetectAPMConflicts();
int DisplayAPMDisableWarningDialog(DWORD dwCaptionID, DWORD dwMessageID);

HRESULT HrDetectAndDisableSystemSoftAPMDrivers();
BOOL DetectSystemSoftPowerProfiler();
HRESULT HrDisableSystemSoftPowerProfiler();
BOOL DetectSystemSoftCardWizard();
HRESULT HrDisableSystemSoftCardWizard();

HRESULT HrDetectAndDisableAwardAPMDrivers();
BOOL DetectAwardCardWare();
HRESULT HrDisableAwardCardWare();

HRESULT HrDetectAndDisableSoftexAPMDrivers();
BOOL DetectSoftexPhoenix();
HRESULT HrDisableSoftexPhoenix();

HRESULT HrDetectAndDisableIBMAPMDrivers();
BOOL DetectIBMDrivers();
HRESULT HrDisableIBMDrivers();

BOOL RemoveSubString(TCHAR* szString, TCHAR* szSubString, TCHAR** pszRemoved);
LONG DeleteRegKeyAndSubkeys(HKEY hKey, LPTSTR lpszSubKey);
HRESULT CallUninstallFunction(LPTSTR szRegKey, LPTSTR szSilentFlag);

// Variables
extern HINSTANCE g_hinst;
extern TCHAR g_APM_ERROR_HTML_FILE[];
extern TCHAR g_APM_ERROR_TEXT_FILE[];

#endif // _APMUPGRD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\boscomp\resource.h ===
//#define APM_STR_CONFLICT_DESCRIPTION	1001

#define IDS_Bos45Msg    1001
#define IDS_Bos40Msg    1002
#define IDS_Bos25Msg    1003
#define IDS_Sbs45Msg    1004
#define IDS_Sbs40Msg    1005
#define IDS_Sbs40AMsg   1006
#define IDS_SbsRestMsg  1007
#define IDS_Exchange    1008
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\apmupgrd\apmdetct.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       apmdetct.cpp
//
//  Contents:   Private functions for detection and disabling of APM drivers and
//              services from various vendors
//
//  Notes:
//
//  Author:     t-sdey   29 June 98
//
//----------------------------------------------------------------------------

#include <winnt32.h>
#include "apmupgrd.h"
#include "apmrsrc.h"


/******************************************************************************
 *
 *   SYSTEMSOFT DRIVERS
 *
 ******************************************************************************/


//+---------------------------------------------------------------------------
//
//  Function:   HrDetectAndDisableSystemSoftAPMDrivers
//
//  Purpose:    Detect SystemSoft drivers/services which will not work under
//              NT 5.0 and disable them.
//
//  Arguments:
//
//  Returns:    S_OK if detect/disable was successful
//              S_FALSE if unsuccessful/cancelled -- must ABORT SETUP!
//
//  Author:     t-sdey    29 June 98
//
//  Notes:      Services detected: PowerProfiler, CardWizard
//
HRESULT HrDetectAndDisableSystemSoftAPMDrivers()
{
   HRESULT hrStatus = S_OK;

   // If PowerProfiler is present, pop up a dialog box warning the
   // user that it is about to be disabled, and then disable it.
   while ((hrStatus == S_OK) && DetectSystemSoftPowerProfiler()) {
      int button = DisplayAPMDisableWarningDialog(APM_STR_WARNING_DIALOG_CAPTION,
						  APM_STR_SYSTEMSOFTPP_DISABLE);

      // Check to see if the user clicked "OK"
      if (button == IDOK) {
	 // Disable PowerProfiler
	 hrStatus = HrDisableSystemSoftPowerProfiler();
      } else {
	 // The user clicked "Cancel"
	 hrStatus = S_FALSE;
      }
   }

   // If CardWizard is present, pop up a dialog box warning the
   // user that it is about to be disabled, and then disable it.
   while ((hrStatus == S_OK) && DetectSystemSoftCardWizard()) {
      int button = DisplayAPMDisableWarningDialog(APM_STR_WARNING_DIALOG_CAPTION,
						  APM_STR_SYSTEMSOFTCW_DISABLE);

      // Check to see if the user clicked "OK"
      if (button == IDOK) {
	 // Disable PowerProfiler
	 hrStatus = HrDisableSystemSoftCardWizard();
      } else {
	 // The user clicked "Cancel"
	 hrStatus = S_FALSE;
      }
   }

   return hrStatus;
}


//+---------------------------------------------------------------------------
//
//  Function:   DetectSystemSoftPowerProfiler
//
//  Purpose:    Detect SystemSoft PowerProfiler, which will not work under NT 5.0.
//
//  Arguments:
//
//  Returns:    TRUE if PowerProfiler is detected
//              FALSE otherwise
//
//  Author:     t-sdey    2 July 98
//
//  Notes:
//
BOOL DetectSystemSoftPowerProfiler()
{
   BOOL fFound = FALSE;

   // Look in the registry to see if PowerProfiler is present
   HKEY hkPP = NULL;
   HKEY hkPPUninst = NULL;
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		    TEXT("SOFTWARE\\SystemSoft\\PowerProfiler"),
		    0,
		    KEY_READ,
		    &hkPP) == ERROR_SUCCESS) {
      /* Also look for the uninstall utility, because sometimes "ghosts" of
	 PowerProfiler stay in the registry at
	 HKLM\Software\SystemSoft\PowerProfiler after it has been uninstalled.
	 If the uninstall utility is present, then we assume that PowerProfiler
	 really is there.  -- Do we need to triple-check???
	 */
      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		       TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\PowerProNT1DeinstKey"),
		       0,
		       KEY_READ,
		       &hkPP) == ERROR_SUCCESS) {
	 // Found PowerProfiler
	 fFound = TRUE;
      }
   }

   if (hkPP)
      RegCloseKey(hkPP);
   if (hkPPUninst)
      RegCloseKey(hkPPUninst);

   return fFound;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrDisableSystemSoftPowerProfiler
//
//  Purpose:    Disable SystemSoft PowerProfiler, which will not work under NT 5.0.
//
//  Arguments:
//
//  Returns:    S_OK if disable was successful
//              S_FALSE if unsuccessful -- must ABORT SETUP!
//
//  Author:     t-sdey    29 June 98
//
//  Notes:
//
HRESULT HrDisableSystemSoftPowerProfiler()
{
   // Call the uninstall function in the registry
   if (CallUninstallFunction(TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\PowerProNT1DeinstKey"),
			     TEXT("\" -a")) == S_OK) {
      // Uninstall worked
      return S_OK;
   } else {
      // An error occurred
      return S_FALSE;
   }
}


//+---------------------------------------------------------------------------
//
//  Function:   DetectSystemSoftCardWizard
//
//  Purpose:    Detect SystemSoft CardWizard, which will not work under NT 5.0.
//
//  Arguments:
//
//  Returns:    TRUE if CardWizard is detected
//              FALSE otherwise
//
//  Author:     t-sdey    7 July 98
//
//  Notes:
//
BOOL DetectSystemSoftCardWizard()
{
   BOOL fFound = FALSE;

   // Look in the registry to see if CardWizard is present
   HKEY hkCW = NULL;
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		    TEXT("SOFTWARE\\SystemSoft\\CardWizard for Windows NT"),
		    0,
		    KEY_READ,
		    &hkCW) == ERROR_SUCCESS) {
	 // Found CardWizard
	 fFound = TRUE;
   }

   if (hkCW)
      RegCloseKey(hkCW);

   return fFound;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrDisableSystemSoftCardWizard
//
//  Purpose:    Disable SystemSoft CardWizard, which will not work under NT 5.0.
//
//  Arguments:
//
//  Returns:    S_OK if disable was successful
//              S_FALSE if unsuccessful -- must ABORT SETUP!
//
//  Author:     t-sdey    7 July 98
//
//  Notes:
//
HRESULT HrDisableSystemSoftCardWizard()
{
   HRESULT hrStatus = S_OK;

   // Use the registry to locate the CardWizard uninstall utility
   if (CallUninstallFunction(TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\CardWizard for Windows NT"),
			     TEXT(" -a")) == S_OK) {
      // Uninstall worked
      return S_OK;
   } else {
      // Could not find (or could not run) CardWizard uninstall utility -
      // do it by hand :(
      // This case happens if someone has CardWizard 2.0, which has no uninstall

      /*
       *  REMOVE ALL CARDWIZARD KEYS FROM THE REGISTRY
       */

      HKEY hkCW = NULL;

      // Go down the list of registry keys that are supposed to be there and
      // delete them if they are present.
      if (RegOpenKeyEx(HKEY_USERS,
		       TEXT(".DEFAULT\\Software\\SystemSoft"),
		       0,
		       KEY_WRITE,
		       &hkCW) == ERROR_SUCCESS) {
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("CardWizard for Windows NT"));
	 RegCloseKey(hkCW);
      }

      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		       TEXT("SOFTWARE\\SystemSoft"),
		       0,
		       KEY_ALL_ACCESS,
		       &hkCW) == ERROR_SUCCESS) {
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("CardWizard for Windows NT"));
      }

      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		       TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run"),
		       0,
		       KEY_WRITE,
		       &hkCW) == ERROR_SUCCESS) {
	 RegDeleteValue(hkCW, TEXT("CardView"));
	 RegCloseKey(hkCW);
      }

      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		       TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon"),
		       0,
		       KEY_ALL_ACCESS,
		       &hkCW) == ERROR_SUCCESS) {
	 // Flag to stop this key adjustment without stopping the whole removal process
	 BOOL fStop = FALSE;
	
	 // First, we get the string
	 const long c_lMax = (65535 / sizeof(TCHAR)) + 1;
	 TCHAR* szVal;
	 szVal = new TCHAR[c_lMax];
	 if (!szVal) {
	    // Out of memory
	    hrStatus = S_FALSE;
	    fStop = TRUE;
	 }
	 DWORD dwValType;
	 DWORD dwValSz = c_lMax;
	 if ((!fStop) && (RegQueryValueEx(hkCW,
					  TEXT("UserInit"),
					  NULL,
					  &dwValType,
					  (LPBYTE)szVal,
					  &dwValSz) != ERROR_SUCCESS)) {
	    // Some error occurred
	    hrStatus = S_FALSE;
	    fStop = TRUE;
	 }

	 // Construct our substring to be removed.  It will be something like
	 // ",C:\Program Files\SystemSoft\CardWizard\WizNT.exe -L".  But we can't
	 // be sure it's in that directory, so we have to look for the beginning
	 // comma and the "WizNT.exe -L".
	 TCHAR* szSubString = NULL;
	 if (!fStop) {
	    // Find the start and end characters
	    TCHAR* pszStart = NULL;
	    TCHAR* pszEnd = NULL;
	    pszEnd = _tcsstr(szVal, TEXT("WizNT.exe -L"));
	    if (pszEnd) {
	       pszEnd = pszEnd + 12;
	    } else {
	       // Did not find the string; don't continue trying to remove it
	       fStop = TRUE;
	    }
	    if (!fStop) {
	       TCHAR* pszTemp = szVal;
	       while (pszTemp < pszEnd) {
		  pszStart = pszTemp;
		  pszTemp = _tcsstr(pszStart + 1, TEXT(","));
		  if (!pszTemp)
		     break;
	       }
	       if (pszStart == NULL) {
		  // There was some error
		  fStop = TRUE;
	       }
	    }

	    // Copy into a new string
	    if (!fStop) {
	       int sslen = (int)(pszEnd - pszStart);
	       szSubString = new TCHAR[sslen + 1];
	       for (int i = 0; i < sslen; i++) {
		  szSubString[i] = pszStart[i];
	       }
	       szSubString[i] = '\0';
	    }
	 }

	 // Finally we search the string to find our substring and construct a new
	 // one with the substring removed
	 TCHAR* szRemoved = NULL;
	 if (!fStop) {
	    // We can't really assume this is the exact string, can we??
	    if (RemoveSubString(szVal, szSubString, &szRemoved)) {
	       // Store the result in the registry
	       RegSetValueEx(hkCW,
			     TEXT("UserInit"),
			     NULL,
			     REG_SZ,
			     (LPBYTE)szRemoved,
			     (lstrlen(szRemoved) + 1) * sizeof(TCHAR));
	    }
	 }

	 // Clean up
	 if (szVal)
	    delete[] szVal;
	 if (szSubString)
	    delete[] szSubString;
	 if (szRemoved)
	    delete[] szRemoved;
         RegCloseKey(hkCW);
      }

      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		       TEXT("SYSTEM\\CurrentControlSet\\Control\\GroupOrderList"),
		       0,
		       KEY_WRITE,
		       &hkCW) == ERROR_SUCCESS) {
	 // Is it safe to delete this value?
	 RegDeleteValue(hkCW, TEXT("System Bus Extender"));
	 RegCloseKey(hkCW);
      }

      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		       TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application"),
		       0,
		       KEY_WRITE,
		       &hkCW) == ERROR_SUCCESS) {
	 RegDeleteKey(hkCW, TEXT("DrvMgr"));
	 RegCloseKey(hkCW);
      }

      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		       TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\System"),
		       0,
		       KEY_WRITE,
		       &hkCW) == ERROR_SUCCESS) {
	 RegDeleteKey(hkCW, TEXT("FlashCrd"));
	 RegDeleteKey(hkCW, TEXT("PatDisk"));
	 RegDeleteKey(hkCW, TEXT("PCCard"));
	 RegDeleteKey(hkCW, TEXT("PCICnfg"));
	 RegDeleteKey(hkCW, TEXT("Platform"));
	 RegDeleteKey(hkCW, TEXT("PSerial"));
	 RegDeleteKey(hkCW, TEXT("Resman"));
	 RegDeleteKey(hkCW, TEXT("SRAMCard"));
	 RegDeleteKey(hkCW, TEXT("SSCrdBus"));
	 RegDeleteKey(hkCW, TEXT("SSI365"));
	 RegCloseKey(hkCW);
      }

      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		       TEXT("SYSTEM\\CurrentControlSet\\Services"),
		       0,
		       KEY_WRITE,
		       &hkCW) == ERROR_SUCCESS) {
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("FlashCrd"));
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("patdisk"));
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("PCCard"));
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("PCICnfg"));
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("Platform"));
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("pndis"));
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("pserial"));
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("resman"));
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("SRAMCard"));
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("SSCrdBus"));
	 DeleteRegKeyAndSubkeys(hkCW, TEXT("SSI365"));
	 RegCloseKey(hkCW);
      }

      /*
       *  REMOVE CARDWIZARD FROM THE SYSTEM TRAY??
       */


      /*
       *  REMOVE CARDWIZARD LINKS FROM THE START MENU
       */


      /*
       *  REMOVE CARDWIZARD FILES FROM THE COMPUTER
       */

	
      // Now, no matter how much of the above failed, CardWizard is disabled
      hrStatus = S_OK;
   }

   return hrStatus;
}


/******************************************************************************
 *
 *   AWARD DRIVERS
 *
 ******************************************************************************/


//+---------------------------------------------------------------------------
//
//  Function:   HrDetectAndDisableAwardAPMDrivers
//
//  Purpose:    Detect Award APM drivers/services which will not work under
//              NT 5.0 and disable them.
//
//  Arguments:
//
//  Returns:    S_OK if detect/disable was successful
//              S_FALSE if unsuccessful/cancelled -- must ABORT SETUP!
//
//  Author:     t-sdey    6 July 98
//
//  Notes:      Services detected: CardWare
//
HRESULT HrDetectAndDisableAwardAPMDrivers()
{
   HRESULT hrStatus = S_OK;

   // If Award CardWare is present, pop up a dialog box warning the
   // user that it is about to be disabled, and then disable it.
   while (DetectAwardCardWare() && (hrStatus == S_OK)) {
      int button = DisplayAPMDisableWarningDialog(APM_STR_WARNING_DIALOG_CAPTION,
						  APM_STR_AWARDCW_DISABLE);

      // Check to see if the user clicked "OK"
      if (button == IDOK) {
	 // Disable PowerProfiler
	 hrStatus = HrDisableAwardCardWare();
      } else {
	 // The user clicked "Cancel"
	 hrStatus = S_FALSE;
      }
   }

   return hrStatus;
}


//+---------------------------------------------------------------------------
//
//  Function:   DetectAwardCardWare
//
//  Purpose:    Detect Award CardWare, which will not work under NT 5.0.
//
//  Arguments:
//
//  Returns:    TRUE if CardWare is detected
//              FALSE otherwise
//
//  Author:     t-sdey    6 July 98
//
//  Notes:
//
BOOL DetectAwardCardWare()
{
   BOOL fFound = FALSE;

   // Look in the registry to see if CardWare is present
   HKEY hkCWUninst = NULL;
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\CardWare"),
		    0,
		    KEY_READ,
		    &hkCWUninst) == ERROR_SUCCESS) {
      // Found CardWare
      fFound = TRUE;
   }

   if (hkCWUninst)
      RegCloseKey(hkCWUninst);

   return fFound;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrDisableAwardCardWare
//
//  Purpose:    Disable Award CardWare, which will not work under NT 5.0.
//
//  Arguments:
//
//  Returns:    S_OK if disable was successful
//              S_FALSE if unsuccessful -- must ABORT SETUP!
//
//  Author:     t-sdey    6 July 98
//
//  Notes:
//
HRESULT HrDisableAwardCardWare()
{
   if (CallUninstallFunction(TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\CardWare"),
			     TEXT(" -a")) == S_OK) {
      // Uninstall worked
      return S_OK;

   } else {
      // An error occurred
      return S_FALSE;
   }
}


/******************************************************************************
 *
 *   SOFTEX DRIVERS
 *
 ******************************************************************************/


//+---------------------------------------------------------------------------
//
//  Function:   HrDetectAndDisableSoftexAPMDrivers
//
//  Purpose:    Detect Softex drivers/services which will not work under
//              NT 5.0 and disable them.
//
//  Arguments:
//
//  Returns:    S_OK if detect/disable was successful
//              S_FALSE if unsuccessful/cancelled -- must ABORT SETUP!
//
//  Author:     t-sdey    6 July 98
//
//  Notes:      Services detected: Phoenix
//
HRESULT HrDetectAndDisableSoftexAPMDrivers()
{
   HRESULT hrStatus = S_OK;

   // If Softex Phoenix is present, pop up a dialog box warning the
   // user that it is about to be disabled, and then disable it.
   while (DetectSoftexPhoenix() && (hrStatus == S_OK)) {
      int button = DisplayAPMDisableWarningDialog(APM_STR_WARNING_DIALOG_CAPTION,
						  APM_STR_SOFTEXP_DISABLE);

      // Check to see if the user clicked "OK"
      if (button == IDOK) {
	 // Disable Phoenix
	 hrStatus = HrDisableSoftexPhoenix();
      } else {
	 // The user clicked "Cancel"
	 hrStatus = S_FALSE;
      }
   }

   return hrStatus;
}


//+---------------------------------------------------------------------------
//
//  Function:   DetectSoftexPhoenix
//
//  Purpose:    Detect Softex Phoenix, which will not work under NT 5.0.
//
//  Arguments:
//
//  Returns:    TRUE if Softex Phoenix is detected
//              FALSE otherwise
//
//  Author:     t-sdey    6 July 98
//
//  Notes:
//
BOOL DetectSoftexPhoenix()
{
   BOOL fFound = FALSE;

   // Look for a couple of keys in the registry
   HKEY hkPhoenix = NULL;
   if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		     TEXT("SYSTEM\\CurrentControlSet\\Services\\pwrstart"),
		     0,
		     KEY_READ,
		     &hkPhoenix) == ERROR_SUCCESS) ||
       (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		     TEXT("SYSTEM\\CurrentControlSet\\Services\\power"),
		     0,
		     KEY_READ,
		     &hkPhoenix) == ERROR_SUCCESS)) {
      fFound = TRUE;
   }
   if (hkPhoenix)
      RegCloseKey(hkPhoenix);

   return fFound;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrDisableSoftexPhoenix
//
//  Purpose:    Disable Softex Phoenix, which will not work under NT 5.0.
//
//  Arguments:
//
//  Returns:    S_OK if disable was successful
//              S_FALSE if unsuccessful -- must ABORT SETUP!
//
//  Author:     t-sdey    6 July 98
//
//  Notes:
//
HRESULT HrDisableSoftexPhoenix()
{
   // Call the uninstall function in the registry
   if (CallUninstallFunction(TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Softex APM Software"),
			     NULL) == S_OK) {
      // Uninstall worked
      return S_OK;

   }

   // Could not find (or could not run) Phoenix uninstall - do it by hand :(
   
   HRESULT hrStatus = S_OK;

   // Delete registry entries
   HKEY hkPhoenix = NULL;

   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		    TEXT("SYSTEM\\CurrentControlSet\\Services"),
		    0,
		    KEY_WRITE,
		    &hkPhoenix) == ERROR_SUCCESS) {
      DeleteRegKeyAndSubkeys(hkPhoenix, TEXT("pwrstart"));
      DeleteRegKeyAndSubkeys(hkPhoenix, TEXT("power"));
      RegCloseKey(hkPhoenix);
   }

   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		    TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon"),
		    0,
		    KEY_WRITE,
		    &hkPhoenix) == ERROR_SUCCESS) {
      // First, we get the string
      DWORD dwValType;
      const long c_lMax = (65535 / sizeof(TCHAR)) + 1;
      DWORD dwValSz = c_lMax;
      TCHAR* szComplete = new TCHAR[c_lMax];
      if (!szComplete) {
	 // Out of memory
	 RegCloseKey(hkPhoenix);
	 return (S_FALSE);
      }
      if (RegQueryValueEx(hkPhoenix,
			  TEXT("UserInit"),
			  NULL,
			  &dwValType,
			  (LPBYTE) szComplete,
			  &dwValSz) != ERROR_SUCCESS) {
	 // Some error occurred
	 hrStatus = S_FALSE;
      }

      // Now we search the string to find our substring and construct a new
      // one with the substring removed
      TCHAR* szRemoved = NULL;
      if (hrStatus == S_OK) {
	 if (!RemoveSubString(szComplete, TEXT(",power"), &szRemoved))
	    hrStatus = S_FALSE;
	 else {
	    // Store the result in the registry
	    hrStatus = RegSetValueEx(hkPhoenix,
				     TEXT("UserInit"),
				     NULL,
				     REG_SZ,
				     (LPBYTE)szRemoved,
				     (lstrlen(szRemoved) + 1) * sizeof(TCHAR));
	 }
      }
	
      // Clean up
      if (szRemoved)
	 delete[] szRemoved;
      if (szComplete)
	 delete[] szComplete;
      RegCloseKey(hkPhoenix);
   }

   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		    TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon"),
		    0,
		    KEY_WRITE,
		    &hkPhoenix) == ERROR_SUCCESS) {
      RegSetValueEx(hkPhoenix,
		    TEXT("PowerdownAfterShutdown"),
		    NULL,
		    REG_SZ,
		    (LPBYTE)TEXT("0"),
		    2*sizeof(TCHAR));
      RegCloseKey(hkPhoenix);
   }

   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run"),
		    0,
		    KEY_WRITE,
		    &hkPhoenix) == ERROR_SUCCESS) {
      RegDeleteValue(hkPhoenix, TEXT("power"));
      RegCloseKey(hkPhoenix);
   }

   // Delete files in system directory
/*
    ' delete .cpl file
    On Error Resume Next
    Kill gstrWinSysDir & "power.cpl"
    On Error Resume Next
    Name (gstrWinSysDir & "power.cpl") As (gstrWinSysDir & "power.cpk")
*/

   return hrStatus;
}


/******************************************************************************
 *
 *   IBM DRIVERS
 *
 ******************************************************************************/


//+---------------------------------------------------------------------------
//
//  Function:   HrDetectAndDisableIBMAPMDrivers
//
//  Purpose:    Detect IBM APM drivers/services which will not work under
//              NT 5.0 and disable them.
//
//  Arguments:
//
//  Returns:    S_OK if detect/disable was successful
//              S_FALSE if unsuccessful/cancelled -- must ABORT SETUP!
//
//  Author:     t-sdey    13 July 98
//
//  Notes:
//
HRESULT HrDetectAndDisableIBMAPMDrivers()
{
   HRESULT hrStatus = S_OK;

   // If IBM drivers are present, pop up a dialog box warning the
   // user that they are about to be disabled, and then disable them.
   while (DetectIBMDrivers() && (hrStatus == S_OK)) {
      int button = DisplayAPMDisableWarningDialog(APM_STR_WARNING_DIALOG_CAPTION,
						  APM_STR_IBM_DISABLE);

      // Check to see if the user clicked "OK"
      if (button == IDOK) {
	 // Disable PowerProfiler
	 hrStatus = HrDisableIBMDrivers();
      } else {
	 // The user clicked "Cancel"
	 hrStatus = S_FALSE;
      }
   }

   return hrStatus;
}


//+---------------------------------------------------------------------------
//
//  Function:   DetectIBMDrivers
//
//  Purpose:    Detect IBM APM drivers which will not work under NT 5.0.
//
//  Arguments:
//
//  Returns:    TRUE if drivers are detected
//              FALSE otherwise
//
//  Author:     t-sdey    13 July 98
//
//  Notes:
//
BOOL DetectIBMDrivers()
{
   BOOL fFound = FALSE;

   // Look in the registry to see if IBM drivers are present
   HKEY hkIBM = NULL;
   if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		     TEXT("SYSTEM\\CurrentControlSet\\Services\\TpChrSrv"),
		     0,
		     KEY_READ,
		     &hkIBM) == ERROR_SUCCESS) ||
       (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		     TEXT("SYSTEM\\CurrentControlSet\\Services\\TpPmPort"),
		     0,
		     KEY_READ,
		     &hkIBM) == ERROR_SUCCESS)) {
      // Found driver(s)
      fFound = TRUE;
   }

   if (hkIBM)
      RegCloseKey(hkIBM);

   return fFound;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrDisableIBMDrivers
//
//  Purpose:    Disable IBM APM drivers which will not work under NT 5.0.
//
//  Arguments:
//
//  Returns:    S_OK if disable was successful
//              S_FALSE if unsuccessful -- must ABORT SETUP!
//
//  Author:     t-sdey    13 July 98
//
//  Notes:
//
HRESULT HrDisableIBMDrivers()
{
   HRESULT hrStatus = S_OK;

   HKEY hkIBM = NULL;
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		    TEXT("SYSTEM\\CurrentControlSet\\Services"),
		    0,
		    KEY_WRITE,
		    &hkIBM) == ERROR_SUCCESS) {
      DeleteRegKeyAndSubkeys(hkIBM, TEXT("TpChrSrv"));
      DeleteRegKeyAndSubkeys(hkIBM, TEXT("TpPmPort"));
      RegCloseKey(hkIBM);
   } else {
      hrStatus = S_FALSE;
   }

   return hrStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\apmupgrd\apmutils.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       apmutils.cpp
//
//  Contents:   Private utility functions for use during APM driver upgrade
//
//  Notes:
//
//  Author:     t-sdey     10 July 98
//
//----------------------------------------------------------------------------

#include <winnt32.h>


//+---------------------------------------------------------------------------
//
//  Function:   RemoveSubString
//
//  Purpose:    Remove (the first occurrence of) a specified substring
//              from a string
//
//  Arguments:  szString    [in]    Complete string
//              szSubString [in]    Substring to find and remove
//              pszRemoved  [out]   New string is placed here
//
//  Returns:    TRUE if a string was subtracted
//              FALSE if szString is NULL, if szSubString is NULL, or
//                if szSubString is not in szString.  When FALSE is returned,
//                pszRemoved will be NULL.
//
//  Author:     t-sdey    10 July 98
//
//  Notes:      Assumes szString and szSubString are null-terminated.
//              Pass in NULL for pszRemoved because it will be overwritten.
//
BOOL RemoveSubString(IN  TCHAR* szString,
		     IN  TCHAR* szSubString,
		     OUT TCHAR** pszRemoved)
{
   *pszRemoved = NULL;

   if ((!szString) || (!szSubString))
      return FALSE;

   // Get the string lengths
   int lenString = lstrlen(szString);
   int lenSubString = lstrlen(szSubString);
   int lenNew = lenString - lenSubString;

   // Search the string to find our substring and construct a new
   // one with the substring removed
   TCHAR* szNew = NULL;
   TCHAR* szStart = _tcsstr(szString, szSubString);
   if (szStart) {
      // Allocate space for the new string
      szNew = new TCHAR[lenNew + 1];
      if (!szNew) {
	 // Out of memory!
	 return FALSE;
      }
	
      // Construct the new string
      TCHAR* szCur = NULL;
      int i = 0;
      for (szCur = szString;
	   (szCur != szStart) && (i < lenNew) && (szCur[0] != '\0');
	   szCur++) {
	 szNew[i] = szCur[0];
	 i++;
      }
      for (szCur = szCur + lenSubString;
	   (szCur[0] != '\0') && (i < lenNew);
	   szCur++) {
	 szNew[i] = szCur[0];
	 i++;
      }
      szNew[i] = '\0';

      *pszRemoved = szNew;
   } else {
      return FALSE;
   }

   return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   DeleteRegKeyAndSubkeys
//
//  Purpose:    (Recursively) Remove a registry key and all of its subkeys
//
//  Arguments:  hKey        [in]    Handle to an open registry key
//              lpszSubKey  [in]    Name of a subkey to be deleted along with all
//                                    of its subkeys
//
//  Returns:    ERROR_SUCCESS if entire subtree was successfully deleted.
//              ERROR_ACCESS_DENIED if given subkey could not be deleted.
//
//  Author:     t-sdey    15 July 98
//
//  Notes:      Snitched from regedit.
//              This specifically does not attempt to deal rationally with the
//              case where the caller may not have access to some of the subkeys
//              of the key to be deleted.  In this case, all the subkeys which
//              the caller can delete will be deleted, but the api will still
//              return ERROR_ACCESS_DENIED.
//
LONG DeleteRegKeyAndSubkeys(IN HKEY hKey,
			    IN LPTSTR lpszSubKey)
{
    DWORD i;
    HKEY Key;
    LONG Status;
    DWORD ClassLength=0;
    DWORD SubKeys;
    DWORD MaxSubKey;
    DWORD MaxClass;
    DWORD Values;
    DWORD MaxValueName;
    DWORD MaxValueData;
    DWORD SecurityLength;
    FILETIME LastWriteTime;
    LPTSTR NameBuffer;

    //
    // First open the given key so we can enumerate its subkeys
    //
    Status = RegOpenKeyEx(hKey,
                          lpszSubKey,
                          0,
                          KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                          &Key);
    if (Status != ERROR_SUCCESS) {
        //
        // possibly we have delete access, but not enumerate/query.
        // So go ahead and try the delete call, but don't worry about
        // any subkeys.  If we have any, the delete will fail anyway.
        //
	return(RegDeleteKey(hKey,lpszSubKey));
    }

    //
    // Use RegQueryInfoKey to determine how big to allocate the buffer
    // for the subkey names.
    //
    Status = RegQueryInfoKey(Key,
                             NULL,
                             &ClassLength,
                             0,
                             &SubKeys,
                             &MaxSubKey,
                             &MaxClass,
                             &Values,
                             &MaxValueName,
                             &MaxValueData,
                             &SecurityLength,
                             &LastWriteTime);
    if ((Status != ERROR_SUCCESS) &&
        (Status != ERROR_MORE_DATA) &&
        (Status != ERROR_INSUFFICIENT_BUFFER)) {
        RegCloseKey(Key);
        return(Status);
    }

    NameBuffer = (LPTSTR) LocalAlloc(LPTR, (MaxSubKey + 1)*sizeof(TCHAR));
    if (NameBuffer == NULL) {
        RegCloseKey(Key);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Enumerate subkeys and apply ourselves to each one.
    //
    i=0;
    do {
        Status = RegEnumKey(Key,
                            i,
                            NameBuffer,
                            MaxSubKey+1);
        if (Status == ERROR_SUCCESS) {
	    Status = DeleteRegKeyAndSubkeys(Key, NameBuffer);
        }

        if (Status != ERROR_SUCCESS) {
            //
            // Failed to delete the key at the specified index.  Increment
            // the index and keep going.  We could probably bail out here,
            // since the api is going to fail, but we might as well keep
            // going and delete everything we can.
            //
            ++i;
        }

    } while ( (Status != ERROR_NO_MORE_ITEMS) &&
              (i < SubKeys) );

    LocalFree((HLOCAL) NameBuffer);
    RegCloseKey(Key);
    return(RegDeleteKey(hKey,lpszSubKey));

}

//+---------------------------------------------------------------------------
//
//  Function:   CallUninstallFunction
//
//  Purpose:    Call the uninstall function found in the registry for a
//              software product.
//
//  Arguments:  szRegKey      [in]    Location of uninstall key in the registry
//                                     (ex: HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\Softex APM Drivers)
//              szSilentFlag  [in]    String which will be appended to the 
//				       command to force quiet uninstall
//
//  Returns:    S_OK if call to uninstall function was successful
//              S_FALSE if call was unsuccessful or function could not be found
//
//  Author:     t-sdey    29 July 98
//
//  Notes:      Send in szSilentFlag=NULL for no flag
//
HRESULT CallUninstallFunction(IN LPTSTR szRegKey,
			      IN LPTSTR szSilentFlag)
{
   HKEY hkey = NULL;
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		    szRegKey,
		    0,
		    KEY_ALL_ACCESS,
		    &hkey) == ERROR_SUCCESS) {
      // Found uninstall utility
      
      // Get the uninstall command from the registry
      long lMax = (65535 / sizeof(TCHAR)) + 1;
      if (szSilentFlag != NULL)
	 lMax += lstrlen(szSilentFlag);
      DWORD dwValType = REG_SZ;
      TCHAR* pszVal = new TCHAR[lMax];
      DWORD dwValSz = lMax;
      if (!pszVal) {
	 // Out of memory
	 if (hkey)
	    RegCloseKey(hkey);
	 return S_FALSE;
      }
      if (RegQueryValueEx(hkey,
			  TEXT("UninstallString"),
			  NULL,
			  &dwValType,
			  (LPBYTE) pszVal,
			  &dwValSz) != ERROR_SUCCESS) {
	 // Some error occurred
	 if (hkey)
	    RegCloseKey(hkey);
	 return S_FALSE;
      }

      // Append " -a" to the string to make it uninstall quietly
      if (szSilentFlag != NULL)
	 _tcscat(pszVal, szSilentFlag);
      
      // Now run the uninstall command  
      STARTUPINFO si = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
      si.cb = sizeof(si);

      PROCESS_INFORMATION pi;
      if (CreateProcess(NULL, pszVal, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS,
			NULL, NULL, &si, &pi) == FALSE) {
	 // An error occurred
	 if (pszVal)
	    delete[] pszVal;
	 if (hkey)
	    RegCloseKey(hkey);
	 return S_FALSE;
      } else {
	 // The process was started successfully.  Wait for it to finish.
	 // This is necessary because we loop in DetectAndDisable to make
	 // sure the drivers really were removed.
	 WaitForSingleObject(pi.hProcess, INFINITE);
	 CloseHandle(pi.hProcess);
	 CloseHandle(pi.hThread);
      }

      if (pszVal)
	 delete[] pszVal;
   } else {
      // Could not find uninstall command
      if (hkey)
         RegCloseKey(hkey);
      return S_FALSE;
   }

   if (hkey)
      RegCloseKey(hkey);
   
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\arc.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    arc.c

Abstract:

    ARC/NV-RAM manipulation routines for 32-bit winnt setup.

Author:

    Ted Miller (tedm) 19-December-1993

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "initguid.h"
#include "diskguid.h"


#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade

#if defined(_X86_)
LOGICAL IsArcChecked = FALSE;
LOGICAL IsArcMachine;
#endif

#if defined(EFI_NVRAM_ENABLED)

#include <ntosp.h> // for ALIGN_UP

LOGICAL IsEfiChecked = FALSE;
LOGICAL IsEfiMachine;

DWORD
InitializeEfiStuff(
    IN HWND Parent
    );

NTSTATUS
(*AddBootEntry) (
    IN PBOOT_ENTRY BootEntry,
    OUT PULONG Id OPTIONAL
    );

NTSTATUS
(*DeleteBootEntry) (
    IN ULONG Id
    );

NTSTATUS
(*EnumerateBootEntries) (
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );

NTSTATUS
(*QueryBootEntryOrder) (
    OUT PULONG Ids,
    IN OUT PULONG Count
    );

NTSTATUS
(*SetBootEntryOrder) (
    IN PULONG Ids,
    IN ULONG Count
    );

NTSTATUS
(*QueryBootOptions) (
    OUT PBOOT_OPTIONS BootOptions,
    IN OUT PULONG BootOptionsLength
    );

NTSTATUS
(*SetBootOptions) (
    IN PBOOT_OPTIONS BootOptions,
    IN ULONG FieldsToChange
    );

PBOOT_OPTIONS BootOptions = NULL;
PBOOT_OPTIONS OriginalBootOptions = NULL;
PULONG OriginalBootEntryOrder = NULL;
ULONG OriginalBootEntryOrderCount;
PBOOT_ENTRY_LIST BootEntries = NULL;

//
// MY_BOOT_ENTRY is the internal representation of an EFI NVRAM boot item.
// The NtBootEntry item is the structure passed to/from the NT boot entry APIs.
//
typedef struct _MY_BOOT_ENTRY {
    struct _MY_BOOT_ENTRY *Next;
    PUCHAR AllocationEnd;
    ULONG Status;
    PWSTR FriendlyName;
    ULONG FriendlyNameLength;
    PWSTR OsLoadOptions;
    ULONG OsLoadOptionsLength;
    PFILE_PATH BootFilePath;
    PFILE_PATH OsFilePath;
    BOOT_ENTRY NtBootEntry;
} MY_BOOT_ENTRY, *PMY_BOOT_ENTRY;

#define MBE_STATUS_ORDERED          0x00000001
#define MBE_STATUS_NEW              0x00000002
#define MBE_STATUS_DELETED          0x00000004
#define MBE_STATUS_COMMITTED        0x00000008

#define IS_BOOT_ENTRY_ACTIVE(_be) \
            (((_be)->NtBootEntry.Attributes & BOOT_ENTRY_ATTRIBUTE_ACTIVE) != 0)
#define IS_BOOT_ENTRY_WINDOWS(_be) \
            (((_be)->NtBootEntry.Attributes & BOOT_ENTRY_ATTRIBUTE_WINDOWS) != 0)
#define IS_BOOT_ENTRY_REMOVABLE_MEDIA(_be) \
            (((_be)->NtBootEntry.Attributes & BOOT_ENTRY_ATTRIBUTE_REMOVABLE_MEDIA) != 0)

#define IS_BOOT_ENTRY_ORDERED(_be) \
            (((_be)->Status & MBE_STATUS_ORDERED) != 0)
#define IS_BOOT_ENTRY_NEW(_be) \
            (((_be)->Status & MBE_STATUS_NEW) != 0)
#define IS_BOOT_ENTRY_DELETED(_be) \
            (((_be)->Status & MBE_STATUS_DELETED) != 0)
#define IS_BOOT_ENTRY_COMMITTED(_be) \
            (((_be)->Status & MBE_STATUS_COMMITTED) != 0)

PMY_BOOT_ENTRY MyBootEntries = NULL;

NTSTATUS
ConvertBootEntries(
    VOID
    );

BOOL
CreateBootEntry(
    PWSTR BootFileDevice,
    PWSTR BootFilePath,
    PWSTR OsLoadDevice,
    PWSTR OsLoadPath,
    PWSTR OsLoadOptions,
    PWSTR FriendlyName
    );

#define ADD_OFFSET(_p,_o) (PVOID)((PUCHAR)(_p) + (_p)->_o)

#endif // defined(EFI_NVRAM_ENABLED)

UINT SystemPartitionCount;
PWSTR* SystemPartitionNtNames;
PWSTR SystemPartitionNtName;
PWSTR SystemPartitionVolumeGuid;

typedef enum {
    BootVarSystemPartition,
    BootVarOsLoader,
    BootVarOsLoadPartition,
    BootVarOsLoadFilename,
    BootVarLoadIdentifier,
    BootVarOsLoadOptions,
    BootVarMax
} BootVars;

LPCWSTR BootVarNames[BootVarMax] = { L"SYSTEMPARTITION",
                                     L"OSLOADER",
                                     L"OSLOADPARTITION",
                                     L"OSLOADFILENAME",
                                     L"LOADIDENTIFIER",
                                     L"OSLOADOPTIONS"
                                   };

LPCWSTR szAUTOLOAD  = L"AUTOLOAD";
LPCWSTR szCOUNTDOWN = L"COUNTDOWN";

LPWSTR BootVarValues[BootVarMax];

LPCWSTR OriginalBootVarValues[BootVarMax];

LPCWSTR OriginalCountdown;
LPCWSTR OriginalAutoload;


DWORD BootVarComponentCount[BootVarMax];
LPWSTR *BootVarComponents[BootVarMax];
DWORD LargestComponentCount;

LPWSTR DosDeviceTargets[26];

//
// Flag indicating whether we messed with NV-RAM and thus need to
// try to restore it in case the user cancels.
//
BOOL CleanUpNvRam;

//
// Leave as array because some code uses sizeof(ArcNameDirectory)
//
WCHAR ArcNameDirectory[] = L"\\ArcName";

#define GLOBAL_ROOT L"\\\\?\\GLOBALROOT"

#define MAX_COMPONENTS  20

WCHAR ForcedSystemPartition;

//
// Helper macro to make object attribute initialization a little cleaner.
//
#define INIT_OBJA(Obja,UnicodeString,UnicodeText)           \
                                                            \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));    \
                                                            \
    InitializeObjectAttributes(                             \
        (Obja),                                             \
        (UnicodeString),                                    \
        OBJ_CASE_INSENSITIVE,                               \
        NULL,                                               \
        NULL                                                \
        )

UINT
NormalizeArcPath(
    IN  PCWSTR  Path,
    OUT LPWSTR *NormalizedPath
    )

/*++

Routine Description:

    Transform an ARC path into one with no sets of empty parenthesis
    (ie, transforom all instances of () to (0).).

Arguments:

    Path - ARC path to be normalized.

    NormalizedPath - if successful, receives a pointer to the
        normalized arc path. The caller must free with FREE().

Return Value:

    Win32 error code indicating outcome.

--*/

{
    LPWSTR r;
    LPCWSTR p,q;
    LPWSTR normalizedPath;

    if(normalizedPath = MALLOC((lstrlen(Path)+100)*sizeof(WCHAR))) {
        ZeroMemory(normalizedPath,(lstrlen(Path)+100)*sizeof(WCHAR));
    } else {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    for(p=Path; q=wcsstr(p,L"()"); p=q+2) {

        r = normalizedPath + lstrlen(normalizedPath);
        lstrcpyn(r,p,(int)(q-p)+1);
        lstrcat(normalizedPath,L"(0)");
    }
    lstrcat(normalizedPath,p);

    if(r = REALLOC(normalizedPath,(lstrlen(normalizedPath)+1)*sizeof(WCHAR))) {
        *NormalizedPath = r;
        return(NO_ERROR);
    } else {
        FREE(normalizedPath);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
}


DWORD
GetVarComponents(
    IN  PCWSTR   VarValue,
    OUT LPWSTR **Components,
    OUT PDWORD   ComponentCount
    )

/*++

Routine Description:

    Split a semi-colon delineated list of arc paths up into
    a set of individual strings. For each component
    leading and trailing spaces are stripped out.

Arguments:

    VarValue - supplies string with list of arc paths to be split apart.

    Components - receives array of pointers to individual components
        on the variable specified in VarValue.

    ComponentCount - receives number of separate arc paths in the
        Components array.

Return Value:

    Win32 error indicating outcome. If NO_ERROR then the caller
    must free the Components array and the strings pointed to by its elements.

--*/

{
    LPWSTR *components;
    LPWSTR *temp;
    DWORD componentCount;
    LPCWSTR p;
    LPCWSTR Var;
    LPWSTR comp;
    DWORD len;
    UINT ec;

    components = MALLOC(MAX_COMPONENTS * sizeof(LPWSTR));
    if(!components) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    ZeroMemory(components,MAX_COMPONENTS * sizeof(LPWSTR));

    ec = NO_ERROR;

    for(Var=VarValue,componentCount=0; *Var; ) {

        //
        // Skip leading spaces.
        //
        while((*Var == L' ') || (*Var == L'\t')) {
            Var++;
        }

        if(*Var == 0) {
            break;
        }

        p = Var;

        while(*p && (*p != L';')) {
            p++;
        }

        len = (DWORD)((PUCHAR)p - (PUCHAR)Var);

        comp = MALLOC(len + sizeof(WCHAR));
        if(!comp) {
            ec = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        len /= sizeof(WCHAR);

        lstrcpynW(comp,Var,len+1);

        ec = NormalizeArcPath(comp,&components[componentCount]);
        FREE(comp);
        if(ec != NO_ERROR) {
            break;
        }

        componentCount++;

        if(componentCount == MAX_COMPONENTS) {
            break;
        }

        Var = p;
        if(*Var) {
            Var++;      // skip ;
        }
    }

    if(ec == NO_ERROR) {
        if(componentCount) {
            temp = REALLOC(components,componentCount*sizeof(LPWSTR));
            if(!temp) {
                ec = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else {
            temp = NULL;
        }
    }

    if(ec == NO_ERROR) {
        *Components = temp;
        *ComponentCount = componentCount;
    } else {
        for(len=0; components[len] && (len<MAX_COMPONENTS); len++) {
            FREE(components[len]);
        }
        FREE(components);
    }

    return(ec);
}


NTSTATUS
QueryCanonicalName(
    IN  PWSTR   Name,
    IN  ULONG   MaxDepth,
    OUT PWSTR   CanonicalName,
    IN  ULONG   SizeOfBufferInBytes
    )
/*++

Routine Description:

    Resolves the symbolic name to the specified depth. To resolve
    a symbolic name completely specify the MaxDepth as -1

Arguments:

    Name        -   Symbolic name to be resolved

    MaxDepth    -   The depth till which the resolution needs to
                    be carried out

    CanonicalName   -   The fully resolved name

    SizeOfBufferInBytes -   The size of the CanonicalName buffer in
                            bytes

Return Value:

    Appropriate NT status code

--*/
{
    UNICODE_STRING      name, canonName;
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status;
    HANDLE              handle;
    ULONG               CurrentDepth;

    RtlInitUnicodeString(&name, Name);

    canonName.MaximumLength = (USHORT) (SizeOfBufferInBytes - sizeof(WCHAR));
    canonName.Length = 0;
    canonName.Buffer = CanonicalName;

    if (name.Length >= canonName.MaximumLength) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    RtlCopyMemory(canonName.Buffer, name.Buffer, name.Length);
    canonName.Length = name.Length;
    canonName.Buffer[canonName.Length/sizeof(WCHAR)] = 0;

    for (CurrentDepth = 0; CurrentDepth < MaxDepth; CurrentDepth++) {

        InitializeObjectAttributes(&oa, &canonName, OBJ_CASE_INSENSITIVE, 0, 0);

        status = NtOpenSymbolicLinkObject(&handle,
                                          READ_CONTROL | SYMBOLIC_LINK_QUERY,
                                          &oa);
        if (!NT_SUCCESS(status)) {
            break;
        }

        status = NtQuerySymbolicLinkObject(handle, &canonName, NULL);
        NtClose(handle);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        canonName.Buffer[canonName.Length/sizeof(WCHAR)] = 0;
    }

    return STATUS_SUCCESS;
}


//
// Structure to map from old NT partition names like
// \device\harddisk0\partition1 to new NT partition names
// like \device\harddiskvolume1
//
typedef struct _NAME_TRANSLATIONS {
    WCHAR   OldNtName[MAX_PATH];
    WCHAR   NewNtName[MAX_PATH];
} NT_NAME_TRANSLATION, * PNT_NAME_TRANSLATION;


//
// Map of old style NT partition names to new style NT
// partition names
//
NT_NAME_TRANSLATION    OldNewNtNames[256] = {0};


PWSTR
OldNtNameToNewNtName(
    IN PCWSTR    OldNtName
    )
/*++

Routine Description:

    Given a old format NT name tries to lookup at new format
    NT name in the global map

Arguments:

    OldNtName   -   The partition name specified in the old
                    format

Return Value:

    The new NT name if there exists one, otherwise NULL.

--*/

{
    ULONG   Index = 0;
    ULONG   MaxEntries = sizeof(OldNewNtNames)/sizeof(NT_NAME_TRANSLATION);
    PWSTR   NewNtName = NULL;

    for (Index = 0; (Index < MaxEntries); Index++) {
        if (OldNewNtNames[Index].OldNtName[0] &&
            !_wcsicmp(OldNewNtNames[Index].OldNtName, OldNtName)) {
            NewNtName = OldNewNtNames[Index].NewNtName;
        }
    }

    return NewNtName;
}


PWSTR
NewNtNameToOldNtName(
    IN  PCWSTR   NewNtName
    )
/*++

Routine Description:

    Given a new format NT name tries to lookup at old format
    NT name in the global map

Arguments:

    NewNtName   -   The partition name specified in the new
                    format

Return Value:

    The old NT name if there exists one, otherwise NULL.

--*/
{
    ULONG   Index = 0;
    ULONG   MaxEntries = sizeof(OldNewNtNames)/sizeof(NT_NAME_TRANSLATION);
    PWSTR   OldNtName = NULL;

    for (Index=0; (Index < MaxEntries); Index++) {
        if (OldNewNtNames[Index].NewNtName[0] &&
            !_wcsicmp(OldNewNtNames[Index].NewNtName, NewNtName)) {
            OldNtName = OldNewNtNames[Index].OldNtName;
        }
    }

    return OldNtName;
}

DWORD
InitOldToNewNtNameTranslations(
    VOID
    )
/*++

Routine Description:

    Initializes the global old NT partition names to
    new NT partition names mapping.

Arguments:

    None.

Return Value:

    The number of valid entries in the map

--*/

{
    DWORD                       MappingCount = 0;
    SYSTEM_DEVICE_INFORMATION   SysDevInfo = {0};
    NTSTATUS                    Status;
    OBJECT_ATTRIBUTES           ObjAttrs;
    UNICODE_STRING              ObjName;

    Status = NtQuerySystemInformation(SystemDeviceInformation,
                &SysDevInfo,
                sizeof(SYSTEM_DEVICE_INFORMATION),
                NULL);

    if (NT_SUCCESS(Status)) {
        ULONG   Index;
        WCHAR   OldNtPath[MAX_PATH];
        DWORD   ErrorCode = 0;
        ULONG   SlotIndex = 0;
        ULONG   MaxSlots = sizeof(OldNewNtNames)/sizeof(NT_NAME_TRANSLATION);

        for (Index=0;
            (!ErrorCode) && (Index < SysDevInfo.NumberOfDisks) &&
            (SlotIndex < MaxSlots);
            Index++) {

            HANDLE  DirectoryHandle;

            swprintf(OldNtPath,
                L"\\device\\Harddisk%d",
                Index);

            //
            // Open the disk directory.
            //
            INIT_OBJA(&ObjAttrs, &ObjName, OldNtPath);

            Status = NtOpenDirectoryObject(&DirectoryHandle,
                            DIRECTORY_QUERY,
                            &ObjAttrs);

            if(NT_SUCCESS(Status)) {
                BOOLEAN     RestartScan = TRUE;
                ULONG       Context = 0;
                BOOLEAN     MoreEntries = TRUE;
                WCHAR       Buffer[MAX_PATH * 2] = {0};
                POBJECT_DIRECTORY_INFORMATION DirInfo = (POBJECT_DIRECTORY_INFORMATION)Buffer;

                do {
                    Status = NtQueryDirectoryObject(
                                DirectoryHandle,
                                Buffer,
                                sizeof(Buffer),
                                TRUE,           // return single entry
                                RestartScan,
                                &Context,
                                NULL            // return length
                                );

                    if(NT_SUCCESS(Status)) {
                        //
                        // Make sure this name is a symbolic link.
                        //
                        if(DirInfo->Name.Length &&
                           (DirInfo->TypeName.Length >= 24) &&
                           CharUpperBuff((LPWSTR)DirInfo->TypeName.Buffer,12) &&
                           !memcmp(DirInfo->TypeName.Buffer,L"SYMBOLICLINK",24)) {
                            WCHAR    EntryName[MAX_PATH];

                            lstrcpy(EntryName, OldNtPath);

                            ConcatenatePaths(EntryName,
                                DirInfo->Name.Buffer,
                                (DWORD)(-1));

                            Status = QueryCanonicalName(EntryName, -1, Buffer, sizeof(Buffer));

                            if (NT_SUCCESS(Status)) {
                                wcscpy(OldNewNtNames[SlotIndex].OldNtName, EntryName);
                                wcscpy(OldNewNtNames[SlotIndex].NewNtName, Buffer);
                                SlotIndex++;
                            }
                        }
                    } else {
                        MoreEntries = FALSE;

                        if(Status == STATUS_NO_MORE_ENTRIES) {
                            Status = STATUS_SUCCESS;
                        }

                        ErrorCode = RtlNtStatusToDosError(Status);
                    }

                    RestartScan = FALSE;

                } while(MoreEntries && (SlotIndex < MaxSlots));

                NtClose(DirectoryHandle);
            } else {
                ErrorCode = RtlNtStatusToDosError(Status);
            }
        }

        if (!ErrorCode && NT_SUCCESS(Status)) {
            MappingCount = SlotIndex;
        }
    }

    return MappingCount;
}


DWORD
NtNameToArcPath (
    IN  PCWSTR  NtName,
    OUT LPWSTR *ArcPath
    )

/*++

Routine Description:

    Convert an NT volume name to an ARC path.

Arguments:

    NtName - supplies name of drive to be converted.

    ArcPath - receives pointer to buffer containing arc path
        if the routine is successful. Caller must free with FREE().

Return Value:

    Win32 error code indicating outcome.

--*/

{
    UNICODE_STRING UnicodeString;
    HANDLE DirectoryHandle;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    BOOLEAN RestartScan;
    DWORD Context;
    BOOL MoreEntries;
    LPWSTR  ArcName = NULL;
    WCHAR   Buffer[512];
    WCHAR   ArcDiskName[MAX_PATH] = {0};
    WCHAR   NtDiskName[MAX_PATH] = {0};
    WCHAR   ArcPartitionName[MAX_PATH] = {0};
    PWSTR   PartitionName = NULL;
    PWSTR   PartitionNumStr = NULL;
    POBJECT_DIRECTORY_INFORMATION DirInfo = (POBJECT_DIRECTORY_INFORMATION)Buffer;
    DWORD ErrorCode;

    ErrorCode = NO_ERROR;
    *ArcPath = NULL;

    //
    // Get hold of the NT disk name
    //
    PartitionName = NewNtNameToOldNtName(NtName);

    if (PartitionName) {
        PWSTR   PartitionNameStart = PartitionName;

        PartitionName = wcsrchr(PartitionName, L'\\');

        if (PartitionName && wcsstr(PartitionName, L"Partition")) {
            wcsncpy(NtDiskName, PartitionNameStart, PartitionName - PartitionNameStart);
            wcscat(NtDiskName, L"\\Partition0");
            PartitionNumStr = PartitionName + wcslen(L"\\Partition");
        }
    }

    //
    // Open the \ArcName directory.
    //
    INIT_OBJA(&Obja,&UnicodeString,ArcNameDirectory);

    Status = NtOpenDirectoryObject(&DirectoryHandle,DIRECTORY_QUERY,&Obja);

    if(NT_SUCCESS(Status)) {

        RestartScan = TRUE;
        Context = 0;
        MoreEntries = TRUE;

        do {

            Status = NtQueryDirectoryObject(
                        DirectoryHandle,
                        Buffer,
                        sizeof(Buffer),
                        TRUE,           // return single entry
                        RestartScan,
                        &Context,
                        NULL            // return length
                        );

            if(NT_SUCCESS(Status)) {

                CharLower(DirInfo->Name.Buffer);

                //
                // Make sure this name is a symbolic link.
                //
                if(DirInfo->Name.Length
                && (DirInfo->TypeName.Length >= 24)
                && CharUpperBuff((LPWSTR)DirInfo->TypeName.Buffer,12)
                && !memcmp(DirInfo->TypeName.Buffer,L"SYMBOLICLINK",24))
                {
                    WCHAR   OldNtName[MAX_PATH] = {0};

                    ArcName = MALLOC(DirInfo->Name.Length + sizeof(ArcNameDirectory) + sizeof(WCHAR));

                    if(!ArcName) {
                        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;

                        break;
                    }

                    lstrcpy(ArcName,ArcNameDirectory);
                    ConcatenatePaths(ArcName,DirInfo->Name.Buffer,(DWORD)(-1));

                    //
                    // We have the entire arc name in ArcName. Now open the first
                    // level symbolic link.
                    //
                    Status = QueryCanonicalName(ArcName, 1, Buffer, sizeof(Buffer));

                    if (NT_SUCCESS(Status)) {
                        wcscpy(OldNtName, Buffer);

                        //
                        // Now resolve the complete symbolic link
                        //
                        Status = QueryCanonicalName(ArcName, -1, Buffer, sizeof(Buffer));

                        if (NT_SUCCESS(Status)) {
                            if(!lstrcmpi(Buffer, NtName)) {
                                *ArcPath = ArcName + (sizeof(ArcNameDirectory)/sizeof(WCHAR));
                            } else {
                                if (!lstrcmpi(OldNtName, NtDiskName)) {
                                    wcscpy(ArcDiskName,
                                        ArcName + (sizeof(ArcNameDirectory)/sizeof(WCHAR)));
                                }
                            }
                        } else {
                            if(!lstrcmpi(OldNtName, NtName)) {
                                *ArcPath = ArcName + (sizeof(ArcNameDirectory)/sizeof(WCHAR));
                            }
                        }
                    }

                    if(!(*ArcPath)) {
                        FREE(ArcName);
                        ArcName = NULL;
                    }
                }
            } else {

                MoreEntries = FALSE;

                if(Status == STATUS_NO_MORE_ENTRIES) {
                    Status = STATUS_SUCCESS;
                }

                ErrorCode = RtlNtStatusToDosError(Status);
            }

            RestartScan = FALSE;

        } while(MoreEntries && !(*ArcPath));

        NtClose(DirectoryHandle);
    } else {
        ErrorCode = RtlNtStatusToDosError(Status);
    }

    //
    // If we found a match for the disk but not for the actual
    // partition specified then guess thepartition number
    // (based on the current nt partition number )
    //
    if ((!*ArcPath) && ArcDiskName[0] && PartitionName && PartitionNumStr) {
        PWSTR   EndPtr = NULL;
        ULONG   PartitionNumber = wcstoul(PartitionNumStr, &EndPtr, 10);

        if (PartitionNumber) {
            swprintf(ArcPartitionName,
                L"%wspartition(%d)",
                ArcDiskName,
                PartitionNumber);

            *ArcPath = DupString(ArcPartitionName);
            ErrorCode = NO_ERROR;

            DebugLog( Winnt32LogInformation,
                TEXT("\nCould not find arcname mapping for %1 partition.\r\n")
                TEXT("Guessing the arcname to be %2"),
                0,
                NtName,
                ArcPartitionName);
        }
    }

    if (ErrorCode == NO_ERROR) {
        if(*ArcPath) {
            //
            // ArcPath points into the middle of a buffer.
            // The caller needs to be able to free it, so place it in its
            // own buffer here.
            //
            *ArcPath = DupString(*ArcPath);

            if (ArcName) {
                FREE(ArcName);
            }

            if(*ArcPath == NULL) {
                ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else {
            //
            // No matching drive.
            //
            ErrorCode = ERROR_INVALID_DRIVE;
        }
    }

    return  ErrorCode;
}


DWORD
DriveLetterToArcPath(
    IN  WCHAR   DriveLetter,
    OUT LPWSTR *ArcPath
    )

/*++

Routine Description:

    Convert a drive letter to an ARC path.

    This routine relies on the DosDeviceTargets array being set up
    beforehand.

Arguments:

    DriveLetter - supplies letter of drive to be converted.

    ArcPath - receives pointer to buffer containing arc path
        if the routine is successful. Caller must free with FREE().

Return Value:

    Win32 error code indicating outcome.

--*/

{
    LPWSTR NtPath;

    NtPath = DosDeviceTargets[(WCHAR)CharUpper((PWCHAR)DriveLetter)-L'A'];
    if(!NtPath) {
        return(ERROR_INVALID_DRIVE);
    }

    return NtNameToArcPath (NtPath, ArcPath);
}


DWORD
ArcPathToDriveLetterAndNtName (
    IN      PCWSTR ArcPath,
    OUT     PWCHAR DriveLetter,
    OUT     PWSTR NtName,
    IN      DWORD BufferSizeInBytes
    )

/*++

Routine Description:

    Convert an arc path to a drive letter.

    This routine relies on the DosDeviceTargets array being set up
    beforehand.

Arguments:

    ArcPath - specifies arc path to be converted.

    DriveLetter - if successful, receives letter of drive.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    NTSTATUS Status;
    WCHAR drive;
    LPWSTR arcPath;
    DWORD ec;

    //
    // Assume failure
    //
    *DriveLetter = 0;

    arcPath = MALLOC(((lstrlen(ArcPath)+1)*sizeof(WCHAR)) + sizeof(ArcNameDirectory));
    if(!arcPath) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    lstrcpy(arcPath,ArcNameDirectory);
    lstrcat(arcPath,L"\\");
    lstrcat(arcPath,ArcPath);

    Status = QueryCanonicalName(arcPath, -1, NtName, BufferSizeInBytes);
    if (NT_SUCCESS(Status)) {

        ec = ERROR_INVALID_DRIVE;

        for(drive=L'A'; drive<=L'Z'; drive++) {

            if(DosDeviceTargets[drive-L'A']
            && !lstrcmpi(NtName,DosDeviceTargets[drive-L'A']))
            {
                *DriveLetter = drive;
                ec = NO_ERROR;
                break;
            }
        }

    } else {
        ec = RtlNtStatusToDosError(Status);
    }

    FREE(arcPath);

    return(ec);
}


DWORD
InitDriveNameTranslations(
    VOID
    )
{
    WCHAR DriveName[15];
    WCHAR Drive;
    WCHAR Buffer[512];
    NTSTATUS status;

    swprintf(DriveName, L"\\DosDevices\\c:");

    //
    // Calculate NT names for all local hard disks C-Z.
    //
    for(Drive=L'A'; Drive<=L'Z'; Drive++) {

        DosDeviceTargets[Drive-L'A'] = NULL;

        if(MyGetDriveType(Drive) == DRIVE_FIXED) {

            DriveName[12] = Drive;

            status = QueryCanonicalName(DriveName, -1, Buffer, sizeof(Buffer));

            if (NT_SUCCESS(status)) {
                DosDeviceTargets[Drive-L'A'] = DupString(Buffer);
                if(!DosDeviceTargets[Drive-L'A']) {
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }
            }
        }
    }

    //
    // Initialize old Nt Parition names to new partition name
    // mapping
    //
    InitOldToNewNtNameTranslations();

    return(NO_ERROR);
}


DWORD
DetermineSystemPartitions(
    VOID
    )
{
    LPWSTR *SyspartComponents;
    DWORD NumSyspartComponents;
    DWORD d;
    DWORD rc;
    UINT u;
    WCHAR drive;
    WCHAR DeviceNtName[512];

    SyspartComponents = BootVarComponents[BootVarSystemPartition];
    NumSyspartComponents = BootVarComponentCount[BootVarSystemPartition];

    SystemPartitionNtNames = MALLOC ((NumSyspartComponents + 1) * sizeof (PWSTR));
    if (!SystemPartitionNtNames) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory(SystemPartitionNtNames, (NumSyspartComponents + 1) * sizeof (PWSTR));

    ZeroMemory(SystemPartitionDriveLetters,27*sizeof(WCHAR));

    //
    // Convert each system partition to a drive letter.
    //
    for(d=0; d<NumSyspartComponents; d++) {
        //
        // check for duplicates
        //
        if (SystemPartitionCount > 0) {
            for (u = 0; u < SystemPartitionCount; u++) {
                if (lstrcmpi (SyspartComponents[d], SystemPartitionNtNames[u]) == 0) {
                    break;
                }
            }
            if (u < SystemPartitionCount) {
                continue;
            }
        }

        rc = ArcPathToDriveLetterAndNtName (
                SyspartComponents[d],
                &drive,
                DeviceNtName,
                (DWORD) sizeof (DeviceNtName)
                );
        if(rc == ERROR_NOT_ENOUGH_MEMORY) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        if (rc == ERROR_SUCCESS) {
            SystemPartitionDriveLetters[SystemPartitionCount] = drive;
        }

        SystemPartitionNtNames[SystemPartitionCount++] = DupString (DeviceNtName);
    }

    return(NO_ERROR);
}

DWORD
DoInitializeArcStuff(
    VOID
    )
{
    DWORD ec;
    DWORD var;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    WCHAR Buffer[4096];

    ec = InitDriveNameTranslations();
    if(ec != NO_ERROR) {
        goto c0;
    }

    //
    // Get relevent boot vars.
    //
    // Enable privilege -- since we check this privilege up front
    // in main() this should not fail.
    //
    if(!EnablePrivilege(SE_SYSTEM_ENVIRONMENT_NAME,TRUE)) {
        ec = ERROR_ACCESS_DENIED;
        goto c0;
    }

    for(var=0; var<BootVarMax; var++) {

        RtlInitUnicodeString(&UnicodeString,BootVarNames[var]);

        Status = NtQuerySystemEnvironmentValue(
                    &UnicodeString,
                    Buffer,
                    sizeof(Buffer) / sizeof(WCHAR),
                    NULL
                    );

        if(NT_SUCCESS(Status)) {
            BootVarValues[var] = DupString(Buffer);
            OriginalBootVarValues[var] = DupString(Buffer);
        } else {
            //
            // We may get back failure if the variable is empty.
            //
            BootVarValues[var] = DupString(L"");
            OriginalBootVarValues[var] = DupString(L"");
        }

        if(!BootVarValues[var] || !OriginalBootVarValues[var]) {
            ec = ERROR_NOT_ENOUGH_MEMORY;
            goto c2;
        }

        ec = GetVarComponents(
                BootVarValues[var],
                &BootVarComponents[var],
                &BootVarComponentCount[var]
                );

        if(ec != NO_ERROR) {
            goto c2;
        }

        //
        // Track the variable with the most number of components.
        //
        if(BootVarComponentCount[var] > LargestComponentCount) {
            LargestComponentCount = BootVarComponentCount[var];
        }
    }

    //
    // Get original countdown and autoload values.
    // If not successful, oh well, we won't be able to restore them
    // if the user cancels.
    //
    RtlInitUnicodeString(&UnicodeString,szCOUNTDOWN);
    Status = NtQuerySystemEnvironmentValue(
                &UnicodeString,
                Buffer,
                sizeof(Buffer) / sizeof(WCHAR),
                NULL
                );
    if(NT_SUCCESS(Status)) {
        OriginalCountdown = DupString(Buffer);
    } else {
        OriginalCountdown = DupString(L"");
    }

    RtlInitUnicodeString(&UnicodeString,szAUTOLOAD);
    Status = NtQuerySystemEnvironmentValue(
                &UnicodeString,
                Buffer,
                sizeof(Buffer) / sizeof(WCHAR),
                NULL
                );
    if(NT_SUCCESS(Status)) {
        OriginalAutoload = DupString(Buffer);
    } else {
        OriginalAutoload = DupString(L"NO");
    }

    ec = DetermineSystemPartitions();
    if(ec != NO_ERROR) {
        goto c2;
    }
    return(NO_ERROR);

c2:
c0:
    return(ec);
}


BOOL
ArcInitializeArcStuff(
    IN HWND Parent
    )
{
    DWORD ec;
    BOOL b;
    HKEY key;
    DWORD type;
    DWORD size;
    PBYTE buffer = NULL;
    DWORD i;

#if defined(EFI_NVRAM_ENABLED)
    //
    // Try to initialize as an EFI machine. If we're on an EFI machine,
    // this will succeed. Otherwise it will fail, in which case we try
    // to initialize as an ARC machine.
    //
    ec = InitializeEfiStuff(Parent);
    if (!IsEfi())
#endif
    {
        //
        // Try to initialize as an ARC machine. This is expect to
        // always succeed.
        //
        ec = DoInitializeArcStuff();
    }

    switch(ec) {

    case NO_ERROR:

#if defined(EFI_NVRAM_ENABLED)
        //
        // On an EFI machine, the rest of this code (determining system
        // partitions) is not necessary.
        //
        if (IsEfi()) {
            b = TRUE;
        } else
#endif
        {
            //
            // Make sure there is at least one valid system partition.
            //
            if(!SystemPartitionCount) {

                MessageBoxFromMessage(
                    Parent,
                    MSG_SYSTEM_PARTITION_INVALID,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL
                    );

                b = FALSE;
            } else {
                i = 0;
                //
                // On ARC machines we set up a local boot directory that is
                // placed in the root of the system partition.
                //
                //
                // read the SystemPartition value from registry
                //
                ec = RegOpenKey (HKEY_LOCAL_MACHINE, TEXT("System\\Setup"), &key);
                if (ec == ERROR_SUCCESS) {
                    ec = RegQueryValueEx (key, TEXT("SystemPartition"), NULL, &type, NULL, &size);
                    if (ec == ERROR_SUCCESS && type == REG_SZ) {
                        buffer = MALLOC (size);
                        if (buffer) {
                            ec = RegQueryValueEx (key, TEXT("SystemPartition"), NULL, &type, buffer, &size);
                            if (ec != ERROR_SUCCESS) {
                                FREE (buffer);
                                buffer = NULL;
                            }
                        }
                    }

                    RegCloseKey (key);
                }

#if defined(EFI_NVRAM_ENABLED)
                //
                // we just trust the value that comes from the regkey -- EFI
                // systems only have one system partition, so it doesn't make
                // sense to try to match this up against a list of potential
                // system partitions.
                //
                SystemPartitionNtName = (PWSTR) buffer;
#else
                //
                // look for this system partition to make sure things are OK
                //
                if (buffer) {
                    while (i < SystemPartitionCount) {
                        if (lstrcmpi (SystemPartitionNtNames[i], (PCTSTR)buffer) == 0) {
                            SystemPartitionNtName = SystemPartitionNtNames[i];
                            break;
                        }
                        i++;
                    }
                    FREE (buffer);
                }
#endif
                if(!SystemPartitionNtName) {

                    MessageBoxFromMessage(
                        Parent,
                        MSG_SYSTEM_PARTITION_INVALID,
                        FALSE,
                        AppTitleStringId,
                        MB_OK | MB_ICONERROR | MB_TASKMODAL
                        );

                    b = FALSE;

                    break;
                }

#if !defined(EFI_NVRAM_ENABLED)
                if (SystemPartitionDriveLetters[i]) {
                    SystemPartitionDriveLetter = ForcedSystemPartition
                                               ? ForcedSystemPartition
                                               : SystemPartitionDriveLetters[i];
                    LocalBootDirectory[0] = SystemPartitionDriveLetter;
                    LocalBootDirectory[1] = TEXT(':');
                    LocalBootDirectory[2] = TEXT('\\');
                    LocalBootDirectory[3] = 0;
                } else
#endif
                {


                    // SystemPartitionNtNtname is valid at this point thanks to
                    // the check above.

                    size = sizeof(GLOBAL_ROOT) +
                           lstrlen(SystemPartitionNtName)*sizeof(WCHAR) +
                           sizeof(WCHAR) + sizeof(WCHAR);
                    SystemPartitionVolumeGuid = MALLOC (size);


                    if(!SystemPartitionVolumeGuid) {
                        goto MemoryError;
                    }

                    lstrcpy (SystemPartitionVolumeGuid, GLOBAL_ROOT);
                    lstrcat (SystemPartitionVolumeGuid, SystemPartitionNtName);
                    lstrcat (SystemPartitionVolumeGuid, L"\\");
                    lstrcpy (LocalBootDirectory, SystemPartitionVolumeGuid);
                }

                b = TRUE;
            }
        }

        break;

    case ERROR_NOT_ENOUGH_MEMORY:

MemoryError:

        MessageBoxFromMessage(
            Parent,
            MSG_OUT_OF_MEMORY,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

        b = FALSE;
        break;

    default:
        //
        // Some other unknown error.
        //
        MessageBoxFromMessage(
           Parent,
           MSG_COULDNT_READ_NVRAM,
           FALSE,
           AppTitleStringId,
           MB_OK | MB_ICONERROR | MB_TASKMODAL
           );

        b = FALSE;
        break;
    }

#if defined(EFI_NVRAM_ENABLED)
    //
    // make sure the system partition is on a GPT disk.
    //
    if (b) {
        HANDLE hDisk;
        PARTITION_INFORMATION_EX partitionEx;
        DWORD sizePartitionEx = 0;
        UNICODE_STRING uString;
        OBJECT_ATTRIBUTES ObjectAttributes;
        IO_STATUS_BLOCK IoStatus;
        NTSTATUS Status;
        PWSTR p,q;

        b = FALSE;

        MYASSERT( SystemPartitionVolumeGuid != NULL );

        //
        // SystemPartitionVolumeGuid may have a '\' at the end of it.
        // delete this character or we won't open the partition properly
        //
        p = DupString( SystemPartitionVolumeGuid + wcslen(GLOBAL_ROOT) );

        if (p) {
            if (*(p+wcslen(p)-1) == L'\\') {
                *(p+wcslen(p)-1) = L'\0';
            }

            INIT_OBJA( &ObjectAttributes, &uString, p );

            Status = NtCreateFile(&hDisk,
                          (ACCESS_MASK)FILE_GENERIC_READ,
                          &ObjectAttributes,
                          &IoStatus,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ|FILE_SHARE_WRITE,
                          FILE_OPEN,
                          FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0
                         );

            if (NT_SUCCESS(Status)) {
                Status = NtDeviceIoControlFile(
                                        hDisk,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &IoStatus,
                                        IOCTL_DISK_GET_PARTITION_INFO_EX,
                                        NULL,
                                        0,
                                        &partitionEx,
                                        sizeof(PARTITION_INFORMATION_EX) );

                if (NT_SUCCESS(Status)) {
                    if (partitionEx.PartitionStyle == PARTITION_STYLE_GPT) {
                        b = TRUE;
                    }
                } else if (Status == STATUS_INVALID_DEVICE_REQUEST) {
                    //
                    // we must be running on an older build where the IOCTL
                    // code is different
                    //
                    Status = NtDeviceIoControlFile(
                                        hDisk,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &IoStatus,
                                        CTL_CODE(IOCTL_DISK_BASE, 0x0012, METHOD_BUFFERED, FILE_READ_ACCESS),
                                        NULL,
                                        0,
                                        &partitionEx,
                                        sizeof(PARTITION_INFORMATION_EX) );

                    if (NT_SUCCESS(Status)) {
                        if (partitionEx.PartitionStyle == PARTITION_STYLE_GPT) {
                            b = TRUE;
                        }
                    }
                }

                NtClose(hDisk);

            }

            FREE( p );
        }

        if (!b) {
            MessageBoxFromMessage(
               Parent,
               MSG_SYSTEM_PARTITIONTYPE_INVALID,
               FALSE,
               AppTitleStringId,
               MB_OK | MB_ICONERROR | MB_TASKMODAL
               );
        }

    }

#endif

    return(b);
}

#if defined(EFI_NVRAM_ENABLED)

DWORD
LocateEfiSystemPartition(
    OUT PWSTR   SystemPartitionName
    )
/*++

Routine Description:

    Locates the EFI system partition on a GPT disk
    by scanning all the available hard disks.

Arguments:

    SystemPartitionName : Buffer to receive system partition
                          name, if one is present

Return Value:

    Win32 error code indicating outcome.

--*/

{
    DWORD   ErrorCode = ERROR_BAD_ARGUMENTS;

    if (SystemPartitionName) {
        SYSTEM_DEVICE_INFORMATION SysDevInfo;
        NTSTATUS Status;

        *SystemPartitionName = UNICODE_NULL;

        //
        // Get hold of number of hard disks on the system
        //
        ZeroMemory(&SysDevInfo, sizeof(SYSTEM_DEVICE_INFORMATION));

        Status = NtQuerySystemInformation(SystemDeviceInformation,
                        &SysDevInfo,
                        sizeof(SYSTEM_DEVICE_INFORMATION),
                        NULL);

        if (NT_SUCCESS(Status)) {
            ULONG   HardDiskCount = SysDevInfo.NumberOfDisks;
            ULONG   CurrentDisk;
            ULONG   BufferSize = sizeof(DRIVE_LAYOUT_INFORMATION_EX) +
                                 (sizeof(PARTITION_INFORMATION_EX) * 128);
            PCHAR   Buffer = MALLOC(BufferSize);
            BOOL    Found = FALSE;

            if (Buffer) {
                //
                // Go through each disk and find out its partition
                // layout
                //
                for (CurrentDisk = 0;
                    (!Found && (CurrentDisk < HardDiskCount));
                    CurrentDisk++) {

                    WCHAR DiskName[MAX_PATH];
                    HANDLE DiskHandle;

                    swprintf(DiskName,
                        L"\\\\.\\PHYSICALDRIVE%d",
                        CurrentDisk);

                    DiskHandle = CreateFile(DiskName,
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);

                    if ((DiskHandle) &&
                        (DiskHandle != INVALID_HANDLE_VALUE)) {
                        DWORD   ReturnSize = 0;

                        ZeroMemory(Buffer, BufferSize);

                        if (DeviceIoControl(DiskHandle,
                                IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                NULL,
                                0,
                                Buffer,
                                BufferSize,
                                &ReturnSize,
                                NULL)) {
                            //
                            // Only search in GPT disks on IA64
                            //
                            PDRIVE_LAYOUT_INFORMATION_EX  DriveLayout;

                            DriveLayout = (PDRIVE_LAYOUT_INFORMATION_EX)Buffer;

                            if (DriveLayout->PartitionStyle == PARTITION_STYLE_GPT) {
                                ULONG   PartitionIndex;

                                for (PartitionIndex = 0;
                                    (PartitionIndex < DriveLayout->PartitionCount);
                                    PartitionIndex++) {
                                    PPARTITION_INFORMATION_EX Partition;
                                    GUID *PartitionType;

                                    Partition = DriveLayout->PartitionEntry + PartitionIndex;
                                    PartitionType = &(Partition->Gpt.PartitionType);

                                    if (IsEqualGUID(PartitionType, &PARTITION_SYSTEM_GUID)) {
                                        swprintf(SystemPartitionName,
                                            L"\\Device\\Harddisk%d\\Partition%d",
                                            CurrentDisk,
                                            Partition->PartitionNumber
                                            );

                                        Found = TRUE;

                                        break;
                                    }
                                }
                            }
                        }

                        CloseHandle(DiskHandle);
                    }
                }

                FREE(Buffer);
            } else {
                ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            }

            if (!Found) {
                ErrorCode = ERROR_FILE_NOT_FOUND;
            } else {
                ErrorCode = ERROR_SUCCESS;
            }
        }
    }

    return ErrorCode;
}


DWORD
InitializeEfiStuff(
    IN HWND Parent
    )
{
    DWORD ec;
    NTSTATUS status;
    HMODULE h;
    WCHAR dllName[MAX_PATH];
    ULONG length;
    HKEY key;
    DWORD type;
    LONG i;
    PMY_BOOT_ENTRY bootEntry;
    PMY_BOOT_ENTRY previousBootEntry;

    MYASSERT(!IsEfiChecked);

    //
    // IsEfi() uses IsEfiMachine to determine its return value. Assume that
    // we're not on an EFI machine.
    //

    IsEfiChecked = TRUE;
    IsEfiMachine = FALSE;

    //
    // Enable the privilege that is necessary to query/set NVRAM.
    //
    if(!EnablePrivilege(SE_SYSTEM_ENVIRONMENT_NAME,TRUE)) {
        ec = GetLastError();
        return ec;
    }

    //
    // Load ntdll.dll from the system directory.
    //
    GetSystemDirectory(dllName, MAX_PATH);
    ConcatenatePaths(dllName, TEXT("ntdll.dll"), MAX_PATH);
    h = LoadLibrary(dllName);
    if (h == NULL) {
        ec = GetLastError();
        return ec;
    }

    //
    // Get the addresses of the NVRAM APIs that we need to use. If any of
    // these APIs are not available, this must be a pre-EFI NVRAM build.
    //
    (FARPROC)AddBootEntry = GetProcAddress(h, "NtAddBootEntry");
    (FARPROC)DeleteBootEntry = GetProcAddress(h, "NtDeleteBootEntry");
    (FARPROC)EnumerateBootEntries = GetProcAddress(h, "NtEnumerateBootEntries");
    (FARPROC)QueryBootEntryOrder = GetProcAddress(h, "NtQueryBootEntryOrder");
    (FARPROC)SetBootEntryOrder = GetProcAddress(h, "NtSetBootEntryOrder");
    (FARPROC)QueryBootOptions = GetProcAddress(h, "NtQueryBootOptions");
    (FARPROC)SetBootOptions = GetProcAddress(h, "NtSetBootOptions");

    if ((AddBootEntry == NULL) ||
        (DeleteBootEntry == NULL) ||
        (EnumerateBootEntries == NULL) ||
        (QueryBootEntryOrder == NULL) ||
        (SetBootEntryOrder == NULL) ||
        (QueryBootOptions == NULL) ||
        (SetBootOptions == NULL)) {
        return ERROR_OLD_WIN_VERSION;
    }

    //
    // Get the global system boot options. If the call fails with
    // STATUS_NOT_IMPLEMENTED, this is not an EFI machine.
    //
    length = 0;
    status = QueryBootOptions(NULL, &length);
    if (status != STATUS_NOT_IMPLEMENTED) {
        IsEfiMachine = TRUE;
    }
    if (status != STATUS_BUFFER_TOO_SMALL) {
        if (status == STATUS_SUCCESS) {
            status = STATUS_UNSUCCESSFUL;
        }
        return RtlNtStatusToDosError(status);
    }
    BootOptions = MALLOC(length);
    OriginalBootOptions = MALLOC(length);
    if ((BootOptions == NULL) || (OriginalBootOptions == NULL)) {
        return RtlNtStatusToDosError(ERROR_NOT_ENOUGH_MEMORY);
    }
    status = QueryBootOptions(BootOptions, &length);
    if (status != STATUS_SUCCESS) {
        FREE(BootOptions);
        FREE(OriginalBootOptions);
        BootOptions = NULL;
        OriginalBootOptions = NULL;
        return RtlNtStatusToDosError(status);
    }
    memcpy(OriginalBootOptions, BootOptions, length);

    //
    // Get the system boot order list.
    //
    length = 0;
    status = QueryBootEntryOrder(NULL, &length);
    if (status != STATUS_BUFFER_TOO_SMALL) {
        if (status == STATUS_SUCCESS) {
            status = STATUS_UNSUCCESSFUL;
        }
        return RtlNtStatusToDosError(status);
    }
    OriginalBootEntryOrder = MALLOC(length * sizeof(ULONG));
    if (OriginalBootEntryOrder == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    status = QueryBootEntryOrder(OriginalBootEntryOrder, &length);
    if (status != STATUS_SUCCESS) {
        FREE(OriginalBootEntryOrder);
        OriginalBootEntryOrder = NULL;
        return RtlNtStatusToDosError(status);
    }
    OriginalBootEntryOrderCount = length;

    //
    // Get all existing boot entries.
    //
    length = 0;
    status = EnumerateBootEntries(NULL, &length);
    if (status != STATUS_BUFFER_TOO_SMALL) {
        if (status == STATUS_SUCCESS) {
            status = STATUS_UNSUCCESSFUL;
        }
        return RtlNtStatusToDosError(status);
    }
    BootEntries = MALLOC(length);
    if (BootEntries == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    status = EnumerateBootEntries(BootEntries, &length);
    if (status != STATUS_SUCCESS) {
        FREE(BootEntries);
        BootEntries = NULL;
        return RtlNtStatusToDosError(status);
    }

    //
    // Initialize drive name translations, which are needed for converting
    // the boot entries into their internal representations.
    //
    ec = InitDriveNameTranslations();
    if(ec != NO_ERROR) {
        return ec;
    }

    //
    // Convert the boot entries into an internal representation.
    //
    status = ConvertBootEntries();
    if (!NT_SUCCESS(status)) {
        return RtlNtStatusToDosError(status);
    }

    //
    // Free the enumeration buffer.
    //
    FREE(BootEntries);
    BootEntries = NULL;

    //
    // Boot entries are returned in an unspecified order. They are currently
    // in the MyBootEntries list in the order in which they were returned.
    // Sort the boot entry list based on the boot order. Do this by walking
    // the boot order array backwards, reinserting the entry corresponding to
    // each element of the array at the head of the list.
    //

    for (i = (LONG)OriginalBootEntryOrderCount - 1; i >= 0; i--) {

        for (previousBootEntry = NULL, bootEntry = MyBootEntries;
             bootEntry != NULL;
             previousBootEntry = bootEntry, bootEntry = bootEntry->Next) {

            if (bootEntry->NtBootEntry.Id == OriginalBootEntryOrder[i] ) {

                //
                // We found the boot entry with this ID. If it's not already
                // at the front of the list, move it there.
                //

                bootEntry->Status |= MBE_STATUS_ORDERED;

                if (previousBootEntry != NULL) {
                    previousBootEntry->Next = bootEntry->Next;
                    bootEntry->Next = MyBootEntries;
                    MyBootEntries = bootEntry;
                } else {
                    ASSERT(MyBootEntries == bootEntry);
                }

                break;
            }
        }
    }

    //
    // Get the NT name of the system partition from the registry.
    //
    ec = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("System\\Setup"), &key);

    if (ec == ERROR_SUCCESS) {
        ec = RegQueryValueEx(key, TEXT("SystemPartition"), NULL, &type, NULL, &length);

        if (ec == ERROR_SUCCESS) {
            if (type == REG_SZ) {
                SystemPartitionNtName = MALLOC(length);
                if (SystemPartitionNtName != NULL) {
                    ec = RegQueryValueEx(
                            key,
                            TEXT("SystemPartition"),
                            NULL,
                            &type,
                            (PBYTE)SystemPartitionNtName,
                            &length);
                    if (ec != ERROR_SUCCESS) {
                        FREE(SystemPartitionNtName);
                    }
                } else {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
            } else {
                return ERROR_INVALID_PARAMETER;
            }
        }

        RegCloseKey (key);
    }

    if (ec != NO_ERROR) {
        if (IsWinPEMode()) {
            WCHAR   OldSysPartName[MAX_PATH] = {0};
            WCHAR   NewSysPartName[MAX_PATH] = {0};

            ec = LocateEfiSystemPartition(OldSysPartName);

            if ((ec == NO_ERROR) && OldSysPartName[0]) {
                NTSTATUS Status = QueryCanonicalName(OldSysPartName,
                                        -1,
                                        NewSysPartName,
                                        sizeof(NewSysPartName));

                if (NT_SUCCESS(Status) && NewSysPartName[0]) {
                    SystemPartitionNtName = DupString(NewSysPartName);
                } else {
                    ec = ERROR_FILE_NOT_FOUND;
                }
            }

            if ((ec == NO_ERROR) && (NewSysPartName[0] == UNICODE_NULL)) {
                ec = ERROR_FILE_NOT_FOUND;
            }
        }

        if (ec != NO_ERROR) {
            return ec;
        }
    }

    //
    // Get the volume name for the NT name.
    //
    length = sizeof(GLOBAL_ROOT) +
           lstrlen(SystemPartitionNtName)*sizeof(WCHAR) +
           sizeof(WCHAR) + sizeof(WCHAR);

    SystemPartitionVolumeGuid = MALLOC (length);

    if(!SystemPartitionVolumeGuid) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    lstrcpy (SystemPartitionVolumeGuid, GLOBAL_ROOT);
    lstrcat (SystemPartitionVolumeGuid, SystemPartitionNtName);
    lstrcat (SystemPartitionVolumeGuid, L"\\");
    lstrcpy (LocalBootDirectory, SystemPartitionVolumeGuid);

    return NO_ERROR;

} // InitializeEfiStuff

#endif // defined(EFI_NVRAM_ENABLED)

/////////////////////////////////////////////////////////////////////
//
// Everything above this line is concerned with reading NV-RAM.
// Everything below this line is concerned with setting NV-RAM.
//
/////////////////////////////////////////////////////////////////////

BOOL
DoSetNvRamVar(
    IN LPCWSTR VarName,
    IN LPCWSTR VarValue
    )
{
    UNICODE_STRING U1,U2;

    RtlInitUnicodeString(&U1,VarName);
    RtlInitUnicodeString(&U2,VarValue);

    return(NT_SUCCESS(NtSetSystemEnvironmentValue(&U1,&U2)));
}


BOOL
WriteNewBootSetVar(
    IN DWORD var,
    IN PTSTR NewPart
    )
{
    WCHAR Buffer[2048];
    DWORD i;

    //
    // Write the new part first.
    //
    lstrcpy(Buffer,NewPart);

    //
    // Append all components that were not deleted.
    //
    for(i=0; i<BootVarComponentCount[var]; i++) {

        if(BootVarComponents[var][i]) {

            lstrcat(Buffer,L";");
            lstrcat(Buffer,BootVarComponents[var][i]);
        }
    }

    //
    // Remember new value for this var.
    //
    if(BootVarValues[var]) {
        FREE(BootVarValues[var]);
    }

    BootVarValues[var] = DupString(Buffer);

    //
    // Write the var into nvram and return.
    //
    return(DoSetNvRamVar(BootVarNames[var],BootVarValues[var]));
}


BOOL
WriteBootSet(
    VOID
    )
{
    DWORD set;
    DWORD var;
    LPWSTR SystemPartition;
    WCHAR Buffer[2048];
    LPWSTR LocalSourceArc;
    LPWSTR OsLoader;
    WCHAR LoadId[128];
    BOOL b;

    CleanUpNvRam = TRUE;

    //
    // Find and remove any remnants of previously attempted
    // winnt32 runs. Such runs are identified by 'winnt32'
    // in their osloadoptions.
    //

#if defined(EFI_NVRAM_ENABLED)

    if (IsEfi()) {

        NTSTATUS status;
        PMY_BOOT_ENTRY bootEntry;
        PWSTR NtPath;

        //
        // EFI machine. Walk the boot entry list.
        //
        for (bootEntry = MyBootEntries; bootEntry != NULL; bootEntry = bootEntry->Next) {

            if (IS_BOOT_ENTRY_WINDOWS(bootEntry)) {

                if (!lstrcmpi(bootEntry->OsLoadOptions, L"WINNT32")) {

                    //
                    // Delete this boot entry. Note that we don't update the
                    // boot entry order list at this point. CreateBootEntry()
                    // will do that.
                    //
                    status = DeleteBootEntry(bootEntry->NtBootEntry.Id);

                    bootEntry->Status |= MBE_STATUS_DELETED;
                }
            }
        }

        //
        // Now create a new boot entry for textmode setup.
        //

        MYASSERT(LocalSourceDrive);
        NtPath = DosDeviceTargets[(WCHAR)CharUpper((PWCHAR)LocalSourceDrive)-L'A'];

        LoadString(hInst,IDS_RISCBootString,LoadId,sizeof(LoadId)/sizeof(TCHAR));

        b = CreateBootEntry(
                SystemPartitionNtName,
                L"\\" SETUPLDR_FILENAME,
                NtPath,
                LocalSourceWithPlatform + 2,
                L"WINNT32",
                LoadId
                );

        if (b) {

            //
            // Set up for automatic startup, 10 second countdown. We don't
            // care if this fails.
            //
            // Set the boot entry we added to be booted automatically on
            // the next boot, without waiting for a timeout at the boot menu.
            //
            // NB: CreateBootEntry() sets BootOptions->NextBootEntryId.
            //
            BootOptions->Timeout = 10;
            status = SetBootOptions(
                        BootOptions,
                        BOOT_OPTIONS_FIELD_TIMEOUT | BOOT_OPTIONS_FIELD_NEXT_BOOT_ENTRY_ID
                        );
        }

        return b;
    }

#endif // defined(EFI_NVRAM_ENABLED)

    //
    // We get here if we're NOT on an EFI machine.
    //
    // Find and remove any remnants of previously attempted
    // winnt32 runs. Such runs are identified by 'winnt32'
    // in their osloadoptions.
    //

    for(set=0; set<min(LargestComponentCount,BootVarComponentCount[BootVarOsLoadOptions]); set++) {

        //
        // See if the os load options indicate that this is a winnt32 set.
        //
        if(!lstrcmpi(BootVarComponents[BootVarOsLoadOptions][set],L"WINNT32")) {

            //
            // Delete this boot set.
            //
            for(var=0; var<BootVarMax; var++) {

                if(set < BootVarComponentCount[var]) {

                    FREE(BootVarComponents[var][set]);
                    BootVarComponents[var][set] = NULL;
                }
            }
        }
    }

    //
    // Now we want to write out each variable with the appropriate
    // part of the new boot set added to the front.
    //
    if (SystemPartitionDriveLetter) {
        if(DriveLetterToArcPath(SystemPartitionDriveLetter,&SystemPartition) != NO_ERROR) {
            return(FALSE);
        }
    } else {
        if(NtNameToArcPath (SystemPartitionNtName, &SystemPartition) != NO_ERROR) {
            return(FALSE);
        }
    }
    MYASSERT (LocalSourceDrive);
    if(DriveLetterToArcPath(LocalSourceDrive,&LocalSourceArc) != NO_ERROR) {
        FREE(SystemPartition);
        return(FALSE);
    }

    LoadString(hInst,IDS_RISCBootString,LoadId,sizeof(LoadId)/sizeof(TCHAR));

    lstrcpy(Buffer,SystemPartition);
    lstrcat(Buffer,L"\\" SETUPLDR_FILENAME);
    OsLoader = DupString(Buffer);

    //
    // System partition: use the selected system partition as the
    // new system partition component.
    //
    if(WriteNewBootSetVar(BootVarSystemPartition,SystemPartition)

    //
    // Os Loader: use the system partition + setupldr as the
    // new os loader component.
    //
    && WriteNewBootSetVar(BootVarOsLoader,OsLoader)

    //
    // Os Load Partition: use the local source drive as the
    // new os load partition component.
    //
    && WriteNewBootSetVar(BootVarOsLoadPartition,LocalSourceArc)

    //
    // Os Load Filename: use the platform-specific local source directory
    // as the new os load filename component (do not include the drive letter).
    //
    && WriteNewBootSetVar(BootVarOsLoadFilename,LocalSourceWithPlatform+2)

    //
    // Os Load Options: use WINNT32 as the new os load options component.
    //
    && WriteNewBootSetVar(BootVarOsLoadOptions,L"WINNT32")

    //
    // Load Identifier: use a string we get from the resources as the
    // new load identifier component.
    //
    && WriteNewBootSetVar(BootVarLoadIdentifier,LoadId))
    {
        //
        // Set up for automatic startup, 10 second countdown.
        // Note the order so that if setting countdown fails we don't
        // set of for autoload.  Also note that we don't really care
        // if this fails.
        //
        if(DoSetNvRamVar(szCOUNTDOWN,L"10")) {
            DoSetNvRamVar(szAUTOLOAD,L"YES");
        }

        b = TRUE;

    } else {
        //
        // Setting nv-ram failed. Code in cleanup.c will come along and
        // restore to original state later.
        //
        b = FALSE;
    }

    FREE(SystemPartition);
    FREE(LocalSourceArc);
    FREE(OsLoader);

    return(b);
}


BOOL
SetUpNvRam(
    IN HWND ParentWindow
    )
{
    if(!WriteBootSet()) {

        MessageBoxFromMessage(
            ParentWindow,
            MSG_COULDNT_WRITE_NVRAM,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

        return(FALSE);
    }

    return(TRUE);
}


BOOL
RestoreNvRam(
    VOID
    )
{
    UINT var;
    BOOL b;

    b = TRUE;

    if(CleanUpNvRam) {

#if defined(EFI_NVRAM_ENABLED)

        if (IsEfi()) {

            NTSTATUS status;
            PMY_BOOT_ENTRY bootEntry;

            //
            // EFI machine. Walk the boot entry list. For any boot entry that
            // was added, delete it.
            //
            for (bootEntry = MyBootEntries; bootEntry != NULL; bootEntry = bootEntry->Next) {
                if (IS_BOOT_ENTRY_COMMITTED(bootEntry)) {
                    MYASSERT(IS_BOOT_ENTRY_NEW(bootEntry));
                    status = DeleteBootEntry(bootEntry->NtBootEntry.Id);
                    if (!NT_SUCCESS(status)) {
                        b = FALSE;
                    }
                }
            }

            //
            // Restore the original boot order list and the original timeout.
            //
            status = SetBootEntryOrder(OriginalBootEntryOrder, OriginalBootEntryOrderCount);
            if (!NT_SUCCESS(status)) {
                b = FALSE;
            }

            status = SetBootOptions(OriginalBootOptions, BOOT_OPTIONS_FIELD_TIMEOUT);
            if (!NT_SUCCESS(status)) {
                b = FALSE;
            }
        }

    } else  {

#endif // defined(EFI_NVRAM_ENABLED)


        for(var=0; var<BootVarMax; var++) {
            if(!DoSetNvRamVar(BootVarNames[var],OriginalBootVarValues[var])) {
                b = FALSE;
            }
        }

        if(OriginalAutoload) {
            if(!DoSetNvRamVar(szAUTOLOAD,OriginalAutoload)) {
                b = FALSE;
            }
        }
        if(OriginalCountdown) {
            if(!DoSetNvRamVar(szCOUNTDOWN,OriginalCountdown)) {
                b = FALSE;
            }
        }
    }

    return(b);
}

VOID
MigrateBootVarData(
    VOID
    )
/*++

Routine Description:

    This routine retreives any boot data we want to migrate into a global
    variable so that it can be written into winnt.sif.

    Currently we only retreive the countdown

Arguments:

    None

Return Value:

    None.  updates the Timeout global variable

--*/
{
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    WCHAR Buffer[4096];

    MYASSERT(IsArc());

    //
    // If this is an EFI machine, use the cached BootOptions to get the timeout.
    // (See IsEfi().) Otherwise, use the old version of the system service to
    // query the "COUNTDOWN" variable.
    //
#if defined(EFI_NVRAM_ENABLED)

    if (IsEfi()) {

        MYASSERT(BootOptions != NULL);

        swprintf( Timeout, L"%d", BootOptions->Timeout );

    } else

#endif // defined(EFI_NVRAM_ENABLED)

    {
        RtlInitUnicodeString(&UnicodeString,szCOUNTDOWN);
        Status = NtQuerySystemEnvironmentValue(
                                    &UnicodeString,
                                    Buffer,
                                    sizeof(Buffer) / sizeof(WCHAR),
                                    NULL
                                    );
        if(NT_SUCCESS(Status)) {
            lstrcpy(Timeout,Buffer);
        }
    }


}


#if defined(_X86_)

BOOL
IsArc(
    VOID
    )

/*++

Routine Description:

    Run time check to determine if this is an Arc system. We attempt to read an
    Arc variable using the Hal. This will fail for Bios based systems.

Arguments:

    None

Return Value:

    True = This is an Arc system.

--*/

{
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    WCHAR Buffer[4096];

    //
    // If we've already done the check once, don't bother doing it again.
    //
    if (IsArcChecked) {
        return IsArcMachine;
    }

    IsArcChecked = TRUE;
    IsArcMachine = FALSE;

    if(!EnablePrivilege(SE_SYSTEM_ENVIRONMENT_NAME,TRUE)) {
        return FALSE; // need better error handling?
    }

    //
    // Get the env var into the temp buffer.
    //
    RtlInitUnicodeString(&UnicodeString,BootVarNames[BootVarOsLoader]);

    Status = NtQuerySystemEnvironmentValue(
                        &UnicodeString,
                        Buffer,
                        sizeof(Buffer)/sizeof(WCHAR),
                        NULL
                        );


    if (NT_SUCCESS(Status)) {
        IsArcMachine = TRUE;
    }

    return IsArcMachine;
}

#endif // defined(_X86_)

#if defined(EFI_NVRAM_ENABLED)

BOOL
IsEfi(
    VOID
    )

/*++

Routine Description:

    Run time check to determine if this is an EFI system.

Arguments:

    None

Return Value:

    True = This is an EFI system.

--*/

{
    //
    // InitializeEfiStuff() must be called first to do the actual check.
    //
    MYASSERT(IsEfiChecked);

    return IsEfiMachine;

} // IsEfi

NTSTATUS
ConvertBootEntries(
    VOID
    )

/*++

Routine Description:

    Convert boot entries read from EFI NVRAM into our internal format.

Arguments:

    None.

Return Value:

    NTSTATUS - Not STATUS_SUCCESS if an unexpected error occurred.

--*/

{
    PBOOT_ENTRY_LIST bootEntryList;
    PBOOT_ENTRY bootEntry;
    PBOOT_ENTRY bootEntryCopy;
    PMY_BOOT_ENTRY myBootEntry;
    PMY_BOOT_ENTRY previousEntry;
    PWINDOWS_OS_OPTIONS osOptions;
    ULONG length;

    bootEntryList = BootEntries;
    previousEntry = NULL;

    while (TRUE) {

        bootEntry = &bootEntryList->BootEntry;

        //
        // Calculate the length of our internal structure. This includes
        // the base part of MY_BOOT_ENTRY plus the NT BOOT_ENTRY.
        //
        length = FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry) + bootEntry->Length;

        myBootEntry = MALLOC(length);
        if (myBootEntry == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(myBootEntry, length);

        //
        // Link the new entry into the list.
        //
        if (previousEntry != NULL) {
            previousEntry->Next = myBootEntry;
        } else {
            MyBootEntries = myBootEntry;
        }
        previousEntry = myBootEntry;

        //
        // Copy the NT BOOT_ENTRY into the allocated buffer.
        //
        bootEntryCopy = &myBootEntry->NtBootEntry;

        //
        // work around till bootentry has the correct length specified
        //
        __try {
            memcpy(bootEntryCopy, bootEntry, bootEntry->Length);
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            if (bootEntry->Length > sizeof(ULONG)) {
                bootEntry->Length -= sizeof(ULONG);
                memcpy(bootEntryCopy, bootEntry, bootEntry->Length);
            } else {
                //
                // Lets atleast AV rather than having invalid
                // in memory data structures
                //
                memcpy(bootEntryCopy, bootEntry, bootEntry->Length);
            }
        }


        //
        // Fill in the base part of the structure.
        //
        myBootEntry->Next = NULL;
        myBootEntry->AllocationEnd = (PUCHAR)myBootEntry + length - 1;
        myBootEntry->FriendlyName = ADD_OFFSET(bootEntryCopy, FriendlyNameOffset);
        myBootEntry->FriendlyNameLength = (wcslen(myBootEntry->FriendlyName) + 1) * sizeof(WCHAR);
        myBootEntry->BootFilePath = ADD_OFFSET(bootEntryCopy, BootFilePathOffset);

        //
        // If this is an NT boot entry, capture the NT-specific information in
        // the OsOptions.
        //
        osOptions = (PWINDOWS_OS_OPTIONS)bootEntryCopy->OsOptions;

        if (!IS_BOOT_ENTRY_WINDOWS(myBootEntry)) {

            //
            // The original implementation of NtEnumerateBootEntries() didn't
            // set BOOT_ENTRY_ATTRIBUTE_WINDOWS, so we need to check for that
            // here.
            //

            if ((bootEntryCopy->OsOptionsLength >= FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions)) &&
                (strcmp(osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE) == 0)) {
                myBootEntry->NtBootEntry.Attributes |= BOOT_ENTRY_ATTRIBUTE_WINDOWS;
            }
        }

        if (IS_BOOT_ENTRY_WINDOWS(myBootEntry)) {

            myBootEntry->OsLoadOptions = osOptions->OsLoadOptions;
            myBootEntry->OsLoadOptionsLength = (wcslen(myBootEntry->OsLoadOptions) + 1) * sizeof(WCHAR);
            myBootEntry->OsFilePath = ADD_OFFSET(osOptions, OsLoadPathOffset);

        } else {

            //
            // It's not an NT entry. Check to see if it represents a removable
            // media device. We want to know this so that we don't put our
            // boot entry ahead of the floppy or the CD, if they're already
            // at the front of the list. A boot entry represents a
        }

        //
        // Move to the next entry in the enumeration list, if any.
        //
        if (bootEntryList->NextEntryOffset == 0) {
            break;
        }

        bootEntryList = ADD_OFFSET(bootEntryList, NextEntryOffset);
    }

    return STATUS_SUCCESS;

} // ConvertBootEntries

BOOL
CreateBootEntry(
    PWSTR BootFileDevice,
    PWSTR BootFilePath,
    PWSTR OsLoadDevice,
    PWSTR OsLoadPath,
    PWSTR OsLoadOptions,
    PWSTR FriendlyName
    )

/*++

Routine Description:

    Create an internal-format boot entry.

Arguments:

    BootFileDevice - The NT name of the device on which the OS loader resides.

    BootFilePath - The volume-relative path to the OS loader. Must start with
        a backslash.

    OsLoadDevice - The NT name ofthe device on which the OS resides.

    OsLoadPath - The volume-relative path to the OS root directory (\WINDOWS).
        Must start with a backslash.

    OsLoadOptions - Boot options for the OS. Can be an empty string.

    FriendlyName - The user-visible name for the boot entry. (This is ARC's
        LOADIDENTIFIER.)

Return Value:

    BOOLEAN - FALSE if an unexpected error occurred.

--*/

{
    NTSTATUS status;
    ULONG requiredLength;
    ULONG osOptionsOffset;
    ULONG osLoadOptionsLength;
    ULONG osLoadPathOffset;
    ULONG osLoadPathLength;
    ULONG osOptionsLength;
    ULONG friendlyNameOffset;
    ULONG friendlyNameLength;
    ULONG bootPathOffset;
    ULONG bootPathLength;
    PMY_BOOT_ENTRY myBootEntry;
    PMY_BOOT_ENTRY previousBootEntry;
    PMY_BOOT_ENTRY nextBootEntry;
    PBOOT_ENTRY ntBootEntry;
    PWINDOWS_OS_OPTIONS osOptions;
    PFILE_PATH osLoadPath;
    PWSTR friendlyName;
    PFILE_PATH bootPath;
    PWSTR p;
    PULONG order;
    ULONG count;
    ULONG savedAttributes;

    //
    // Calculate how long the internal boot entry needs to be. This includes
    // our internal structure, plus the BOOT_ENTRY structure that the NT APIs
    // use.
    //
    // Our structure:
    //
    requiredLength = FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry);

    //
    // Base part of NT structure:
    //
    requiredLength += FIELD_OFFSET(BOOT_ENTRY, OsOptions);

    //
    // Save offset to BOOT_ENTRY.OsOptions. Add in base part of
    // WINDOWS_OS_OPTIONS. Calculate length in bytes of OsLoadOptions
    // and add that in.
    //
    osOptionsOffset = requiredLength;
    requiredLength += FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions);
    osLoadOptionsLength = (wcslen(OsLoadOptions) + 1) * sizeof(WCHAR);
    requiredLength += osLoadOptionsLength;

    //
    // Round up to a ULONG boundary for the OS FILE_PATH in the
    // WINDOWS_OS_OPTIONS. Save offset to OS FILE_PATH. Add in base part
    // of FILE_PATH. Add in length in bytes of OS device NT name and OS
    // directory. Calculate total length of OS FILE_PATH and of
    // WINDOWS_OS_OPTIONS.
    //
    requiredLength = ALIGN_UP(requiredLength, ULONG);
    osLoadPathOffset = requiredLength;
    requiredLength += FIELD_OFFSET(FILE_PATH, FilePath);
    requiredLength += (wcslen(OsLoadDevice) + 1 + wcslen(OsLoadPath) + 1) * sizeof(WCHAR);
    osLoadPathLength = requiredLength - osLoadPathOffset;
    osOptionsLength = requiredLength - osOptionsOffset;

    //
    // Round up to a ULONG boundary for the friendly name in the BOOT_ENTRY.
    // Save offset to friendly name. Calculate length in bytes of friendly name
    // and add that in.
    //
    requiredLength = ALIGN_UP(requiredLength, ULONG);
    friendlyNameOffset = requiredLength;
    friendlyNameLength = (wcslen(FriendlyName) + 1) * sizeof(WCHAR);
    requiredLength += friendlyNameLength;

    //
    // Round up to a ULONG boundary for the boot FILE_PATH in the BOOT_ENTRY.
    // Save offset to boot FILE_PATH. Add in base part of FILE_PATH. Add in
    // length in bytes of boot device NT name and boot file. Calculate total
    // length of boot FILE_PATH.
    //
    requiredLength = ALIGN_UP(requiredLength, ULONG);
    bootPathOffset = requiredLength;
    requiredLength += FIELD_OFFSET(FILE_PATH, FilePath);
    requiredLength += (wcslen(BootFileDevice) + 1 + wcslen(BootFilePath) + 1) * sizeof(WCHAR);
    bootPathLength = requiredLength - bootPathOffset;

    //
    // Allocate memory for the boot entry.
    //
    myBootEntry = MALLOC(requiredLength);
    if (myBootEntry == NULL) {
        return FALSE;
    }

    RtlZeroMemory(myBootEntry, requiredLength);

    //
    // Calculate addresses of various substructures using the saved offsets.
    //
    ntBootEntry = &myBootEntry->NtBootEntry;
    osOptions = (PWINDOWS_OS_OPTIONS)ntBootEntry->OsOptions;
    osLoadPath = (PFILE_PATH)((PUCHAR)myBootEntry + osLoadPathOffset);
    friendlyName = (PWSTR)((PUCHAR)myBootEntry + friendlyNameOffset);
    bootPath = (PFILE_PATH)((PUCHAR)myBootEntry + bootPathOffset);

    //
    // Fill in the internal-format structure.
    //
    myBootEntry->AllocationEnd = (PUCHAR)myBootEntry + requiredLength;
    myBootEntry->Status = MBE_STATUS_NEW | MBE_STATUS_ORDERED;
    myBootEntry->FriendlyName = friendlyName;
    myBootEntry->FriendlyNameLength = friendlyNameLength;
    myBootEntry->OsLoadOptions = osOptions->OsLoadOptions;
    myBootEntry->OsLoadOptionsLength = osLoadOptionsLength;
    myBootEntry->BootFilePath = bootPath;
    myBootEntry->OsFilePath = osLoadPath;

    //
    // Fill in the base part of the NT boot entry.
    //
    ntBootEntry->Version = BOOT_ENTRY_VERSION;
    ntBootEntry->Length = requiredLength - FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry);
    ntBootEntry->Attributes = BOOT_ENTRY_ATTRIBUTE_ACTIVE | BOOT_ENTRY_ATTRIBUTE_WINDOWS;
    ntBootEntry->FriendlyNameOffset = (ULONG)((PUCHAR)friendlyName - (PUCHAR)ntBootEntry);
    ntBootEntry->BootFilePathOffset = (ULONG)((PUCHAR)bootPath - (PUCHAR)ntBootEntry);
    ntBootEntry->OsOptionsLength = osOptionsLength;

    //
    // Fill in the base part of the WINDOWS_OS_OPTIONS, including the
    // OsLoadOptions.
    //
    strcpy(osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE);
    osOptions->Version = WINDOWS_OS_OPTIONS_VERSION;
    osOptions->Length = osOptionsLength;
    osOptions->OsLoadPathOffset = (ULONG)((PUCHAR)osLoadPath - (PUCHAR)osOptions);
    wcscpy(osOptions->OsLoadOptions, OsLoadOptions);

    //
    // Fill in the OS FILE_PATH.
    //
    osLoadPath->Version = FILE_PATH_VERSION;
    osLoadPath->Length = osLoadPathLength;
    osLoadPath->Type = FILE_PATH_TYPE_NT;
    p = (PWSTR)osLoadPath->FilePath;
    wcscpy(p, OsLoadDevice);
    p += wcslen(p) + 1;
    wcscpy(p, OsLoadPath);

    //
    // Copy the friendly name.
    //
    wcscpy(friendlyName, FriendlyName);

    //
    // Fill in the boot FILE_PATH.
    //
    bootPath->Version = FILE_PATH_VERSION;
    bootPath->Length = bootPathLength;
    bootPath->Type = FILE_PATH_TYPE_NT;
    p = (PWSTR)bootPath->FilePath;
    wcscpy(p, BootFileDevice);
    p += wcslen(p) + 1;
    wcscpy(p, BootFilePath);

    //
    // Add the new boot entry.
    //
    // NB: The original implementation of NtAddBootEntry didn't like it
    // when attribute bits other than _ACTIVE and _DEFAULT were set, so
    // we need to mask the other bits off here.
    //
    savedAttributes = ntBootEntry->Attributes;
    ntBootEntry->Attributes &= (BOOT_ENTRY_ATTRIBUTE_DEFAULT | BOOT_ENTRY_ATTRIBUTE_ACTIVE);
    status = AddBootEntry(ntBootEntry, &ntBootEntry->Id);
    ntBootEntry->Attributes = savedAttributes;
    if (!NT_SUCCESS(status)) {
        FREE(myBootEntry);
        return FALSE;
    }
    myBootEntry->Status |= MBE_STATUS_COMMITTED;

    //
    // Remember the ID of the new boot entry as the entry to be booted
    // immediately on the next boot.
    //
    BootOptions->NextBootEntryId = ntBootEntry->Id;

    //
    // Link the new boot entry into the list, after any removable media
    // entries that are at the front of the list.
    //

    previousBootEntry = NULL;
    nextBootEntry = MyBootEntries;
    while ((nextBootEntry != NULL) &&
           IS_BOOT_ENTRY_REMOVABLE_MEDIA(nextBootEntry)) {
        previousBootEntry = nextBootEntry;
        nextBootEntry = nextBootEntry->Next;
    }
    myBootEntry->Next = nextBootEntry;
    if (previousBootEntry == NULL) {
        MyBootEntries = myBootEntry;
    } else {
        previousBootEntry->Next = myBootEntry;
    }

    //
    // Build the new boot order list. Insert all boot entries with
    // MBE_STATUS_ORDERED into the list. (Don't insert deleted entries.)
    //
    count = 0;
    nextBootEntry = MyBootEntries;
    while (nextBootEntry != NULL) {
        if (IS_BOOT_ENTRY_ORDERED(nextBootEntry) && !IS_BOOT_ENTRY_DELETED(nextBootEntry)) {
            count++;
        }
        nextBootEntry = nextBootEntry->Next;
    }
    order = MALLOC(count * sizeof(ULONG));
    if (order == NULL) {
        return FALSE;
    }
    count = 0;
    nextBootEntry = MyBootEntries;
    while (nextBootEntry != NULL) {
        if (IS_BOOT_ENTRY_ORDERED(nextBootEntry) && !IS_BOOT_ENTRY_DELETED(nextBootEntry)) {
            order[count++] = nextBootEntry->NtBootEntry.Id;
        }
        nextBootEntry = nextBootEntry->Next;
    }

    //
    // Write the new boot entry order list.
    //
    status = SetBootEntryOrder(order, count);
    FREE(order);
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    return TRUE;

} // CreateBootEntry

#endif // defined(EFI_NVRAM_ENABLED)

#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\apmupgrd\apmupgrd.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       apmupgrd.cpp
//
//  Contents:   DllMain
//
//  Notes:      copied from net\config\upgrade\netupgrd\netupgrd.cpp by kumarp
//
//  Author:     t-sdey   19 June 98
//
//----------------------------------------------------------------------------

#include <winnt32.h>
#include "apmupgrd.h"
#include "apmrsrc.h"


// ----------------------------------------------------------------------
// variables

HINSTANCE g_hinst;
TCHAR g_APM_ERROR_HTML_FILE[] = TEXT("compdata\\apmerror.htm");
TCHAR g_APM_ERROR_TEXT_FILE[] = TEXT("compdata\\apmerror.txt");

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Purpose:    constructor
//
//  Arguments:  Standard DLL entry point arguments
//
//  Author:     t-sdey     19 June 98
//
//  Notes:      from kumarp    12 April 97
//
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance,
                    DWORD dwReasonForCall,
                    LPVOID lpReserved)
{
    BOOL status = TRUE;

    switch( dwReasonForCall )
    {
    case DLL_PROCESS_ATTACH:
        {
	   g_hinst = hInstance;
	   DisableThreadLibraryCalls(hInstance);
        }
    break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;
    }

    return status;
}


//+----------------------------------------------------------------------
//
//  Function:  ApmUpgradeCompatibilityCheck
//
//  Purpose:   This function is called by winnt32.exe so that we
//             can scan the system to find any potential upgrade problems.
//
//             NOTE: we do not call CompatibilityCallback to report
//             conflicts to winnt32 unless there was a problem removing them
//	       or the user cancels removal. 
//
//  Arguments: 
//     CompatibilityCallback [in]  pointer to COMPATIBILITYCALLBACK fn
//     Context               [in]  pointer to compatibility context
//
//  Returns:   FALSE if successful (no conflicts remaining)
//             TRUE if unsuccessful (conflicts still exist -- cancel setup)
//
//  Author:    t-sdey     1 July 98
//
//  Notes: 
//
BOOL WINAPI ApmUpgradeCompatibilityCheck(
    IN PCOMPAIBILITYCALLBACK CompatibilityCallback,
    IN LPVOID Context)
{
   if (HrDetectAPMConflicts() == S_OK)
      return FALSE;

   // Signal to the user that there was a problem.

   // Prepare the warning message
   TCHAR szDescription[5000];
   if(!LoadString(g_hinst, APM_STR_CONFLICT_DESCRIPTION, szDescription, 5000)) {
      szDescription[0] = 0;
   }
   
   // Use the callback function to send the signal
   COMPATIBILITY_ENTRY ce;

   ZeroMemory((PVOID)&ce, sizeof(COMPATIBILITY_ENTRY));
   ce.Description = szDescription;
   ce.HtmlName = g_APM_ERROR_HTML_FILE; // defined above
   ce.TextName = g_APM_ERROR_TEXT_FILE; // defined above
   ce.RegKeyName = NULL;
   ce.RegValName = NULL;
   ce.RegValDataSize = 0;
   ce.RegValData = NULL;
   ce.SaveValue = NULL;
   ce.Flags = 0;
   CompatibilityCallback(&ce, Context);

   return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:  ApmUpgradeHandleHaveDisk
//
//  Purpose:   This callback function is called by winnt32.exe
//             if user clicks HaveDisk button on the compatibility
//             report page.  However, that situation *should* never
//             arise, so this function does nothing.
//
//  Arguments: 
//     hwndParent [in]  handle of parent window
//     SaveValue  [in]  pointer to private data
//                      (we store CNetComponent* in this pointer)
//
//  Returns:   ERROR_SUCCESS
//
//  Author:    t-sdey    1 July 98
//
//  Notes: 
//
DWORD WINAPI ApmUpgradeHandleHaveDisk(IN HWND hwndParent,
				      IN LPVOID SaveValue)
{
   return ERROR_SUCCESS;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrDetectAPMConflicts
//
//  Purpose:    Detect and disable any APM drivers which will not work under
//              NT 5.0.
//
//  Arguments:  
//
//  Returns:    S_OK if conflict detect/disable was successful
//              S_FALSE if unsuccessful/cancelled -- must ABORT SETUP!
//
//  Author:     t-sdey    29 June 98
//
//  Notes:
//
HRESULT HrDetectAPMConflicts()
{
   HRESULT hrStatus = S_OK;

   // Check each company's drivers individually
   hrStatus = HrDetectAndDisableSystemSoftAPMDrivers();
   if (hrStatus == S_OK)
      hrStatus = HrDetectAndDisableAwardAPMDrivers();
   if (hrStatus == S_OK)
      hrStatus = HrDetectAndDisableSoftexAPMDrivers();
   if (hrStatus == S_OK)
      hrStatus = HrDetectAndDisableIBMAPMDrivers();
   
   return hrStatus;
}


//+---------------------------------------------------------------------------
//
//  Function:   DisplayAPMDisableWarningDialog
//
//  Purpose:    Display a popup informing the user of APM services about to be
//              disabled.
//
//  Arguments:  dwCaptionID  [in]    the ID of the caption for the window
//              dwMessageID  [in]    the ID of the message to display
//
//  Returns:    integer flag - IDOK if the user clicked "OK"
//                             IDCANCEL if the user clicked "Cancel" or some other
//                                error occurred -- Must exit setup
//
//  Author:     t-sdey    29 June 98
//
//  Notes:
//
int DisplayAPMDisableWarningDialog(IN DWORD dwCaptionID,
				   IN DWORD dwMessageID)
{
   // Prepare the strings
   TCHAR szCaption[512];
   TCHAR szMessage[5000];
   if(!LoadString(g_hinst, dwCaptionID, szCaption, 512)) {
      szCaption[0] = 0;
   }
   if(!LoadString(g_hinst, dwMessageID, szMessage, 5000)) {
      szMessage[0] = 0;
   }

   // Create the dialog box
   int button = MessageBox(NULL, szMessage, szCaption, MB_OKCANCEL);
   
   // Check which button the user pushed
   if (button == IDOK) // The user clicked "OK"
      return (IDOK);
   else // The user clicked "Cancel" or an error occurred
      return (IDCANCEL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\boscomp\boscomp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       boscomp.cpp
//
//  Contents:   DllMain
//
//  Notes:      modified from windows\setup\winnt32\apmupgrd.cpp by wnelson
//
//  Author:     wnelson		2 Apr 99
//              
//              ShaoYin     9 Sep 99 revised, add support for Exchange Server
//
//----------------------------------------------------------------------------

#include <winnt32.h>
#include "boscomp.h"
#include "resource.h"

HINSTANCE g_hinst;

// help text files
TCHAR szErrorHTM[] = TEXT("compdata\\boserror.htm");
TCHAR szErrorTXT[] = TEXT("compdata\\boserror.txt");

// help text files (Exchange Server)
TCHAR szExchangeHTM[] = TEXT("compdata\\exchange.htm");
TCHAR szExchangeTXT[] = TEXT("compdata\\exchange.txt");


// bos/sbs 4.5 reg keys, value names, and possible values
const TCHAR szBosKey[] = TEXT("Software\\Microsoft\\Backoffice");
const TCHAR szFamilyIdKey[] = TEXT("FamilyID");
const TCHAR szBosFamilyId[] = TEXT("8D4BCD88-3236-11d2-AB4E-00C04FB1799F");
const TCHAR szSbsFamilyId[] = TEXT("EE2D3727-33C0-11d2-AB50-00C04FB1799F");
const TCHAR szSuiteVersionKey[] = TEXT("SuiteVersion");
const TCHAR szSuiteNameKey[] = TEXT("SuiteName");
const TCHAR sz45Version[] = TEXT("4.5");
const TCHAR szBosName[] = TEXT("BackOffice Server");
const TCHAR szSbsName[] = TEXT("Small Business Server");

// sbs 4.0x reg keys, value names, and values
const TCHAR szSbsKey[] = TEXT("Software\\Microsoft\\Small Business");
const TCHAR szSbsVersionKey[] = TEXT("Version");
const TCHAR szSbs40AVersion[] = TEXT("4.0a");
const TCHAR szProductOptionsKey[] = TEXT("System\\CurrentControlSet\\Control\\ProductOptions");
//const TCHAR szProductOptionsKey[] = TEXT("software\\test");
const TCHAR szProductSuiteKey[] = TEXT("ProductSuite");
const TCHAR szSbsProductSuiteValue[] = TEXT("Small Business");
const TCHAR szSbsRestrictedProductSuiteValue[] = TEXT("Small Business(Restricted)");

// bos 4.0 version 
TCHAR szBos40VersionKey[] = TEXT("Version");
TCHAR szBos40Version[] = TEXT("4.0");

// bos 2.5 key
TCHAR  szBos25Key[] = TEXT("2.5"); 



// Exchange 5.5 reg keys, value names. 
const TCHAR szExchangeKey[] = TEXT("Software\\Microsoft\\Exchange\\Setup");
const TCHAR szExchangeVerKey[] = TEXT("NewestBuild");
const DWORD dwExchangeVer55 = 0x7a8;

// Exchange 5.5 Server Pack reg key and value name.
const TCHAR szExchangeSvcPackKey[] = TEXT("ServicePackBuild");
const DWORD dwExchangeSvcPack3 = 0xa5a;


//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Purpose:    constructor
//
//  Arguments:  Standard DLL entry point arguments
//
//  Author:     wnelson     2 Apr 99
//
//  Notes:      from kumarp    12 April 97
//
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance,
                    DWORD dwReasonForCall,
                    LPVOID lpReserved)
{
    BOOL status = TRUE;

    switch( dwReasonForCall )
    {
    case DLL_PROCESS_ATTACH:
        {
	   g_hinst = hInstance;
	   DisableThreadLibraryCalls(hInstance);
        }
    break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;
    }

    return status;
}


//+----------------------------------------------------------------------
//
//  Function:  BosHardBlockCheck
//
//  Purpose:   This function is called by winnt32.exe so that we
//             can check for installed bos/sbs suites that cannot be upgraded to Win2k.
//
//             
//
//  Arguments: 
//     CompatibilityCallback [in]  pointer to COMPATIBILITYCALLBACK fn
//     Context               [in]  pointer to compatibility context
//
//  FALSE if Win2k setup can continue.
//  TRUE if Win2k cannot upgrade the installed suite.
// 
//  Author:    wnelson     2 Apr 99
//
//  Notes: 
//  TRUE is returned in the following cases: BOS 2.5; SBS 4.0,4.0a; BOS 4.0
//	For SBS, it does not matter if they've upgraded to full NT Server; they still have to
//	upgrade their suite to BackOffice 4.5 in order to continue.
//

BOOL WINAPI BosHardBlockCheck(IN PCOMPAIBILITYCALLBACK CompatibilityCallback,IN LPVOID Context)
{
	SuiteVersion eVersion=DetermineInstalledSuite();
	if (eVersion==VER_NONE || eVersion==VER_BOS45 || eVersion==VER_POST45) return FALSE;
	TCHAR szMsg[1024];
	GetSuiteMessage(eVersion,szMsg,1024);
   
	// Use the callback function to send the signal
	COMPATIBILITY_ENTRY ce;
	ZeroMemory(&ce,sizeof(COMPATIBILITY_ENTRY));
	ce.Description = szMsg;
	ce.HtmlName = szErrorHTM; // defined above
	ce.TextName = szErrorTXT; // defined above
	ce.RegKeyName = NULL;
	ce.RegValName = NULL;
	ce.RegValDataSize = 0;
	ce.RegValData = NULL;
	ce.SaveValue = NULL;
	ce.Flags = 0;
	CompatibilityCallback(&ce, Context);

   return TRUE;
}
//+----------------------------------------------------------------------
//
//  Function:  BosSoftBlockCheck
//
//  Purpose:   This function is called by winnt32.exe so that we
//             can check for an installed sbs/bos suite with possible upgrade problems.
//
//             
//
//  Arguments: 
//     CompatibilityCallback [in]  pointer to COMPATIBILITYCALLBACK fn
//     Context               [in]  pointer to compatibility context
//
//  FALSE if Win2k setup can continue.
//  TRUE if Win2k setup needs to warn the user that upgrade may impair functionality of installed suite.
// 
//  Author:    wnelson     2 Apr 99
//
//             ShaoYin     9 Sep 99, add support for Exchange Server
//
//  Notes: 
//  TRUE is returned in the following cases: BOS 4.5
//
BOOL WINAPI BosSoftBlockCheck(IN PCOMPAIBILITYCALLBACK CompatibilityCallback,IN LPVOID Context)
{

    BOOL result = FALSE;
    
	SuiteVersion eVersion=DetermineInstalledSuite();
	if (eVersion==VER_BOS45)
	{
		TCHAR szMsg[1024];
		GetSuiteMessage(eVersion,szMsg,1024);
	
		// Use the callback function to send the signal
		COMPATIBILITY_ENTRY ce;
		ZeroMemory(&ce,sizeof(COMPATIBILITY_ENTRY));
		ce.Description = szMsg;
		ce.HtmlName = szErrorHTM; // defined above
		ce.TextName = szErrorTXT; // defined above
		ce.RegKeyName = NULL;
		ce.RegValName = NULL;
		ce.RegValDataSize = 0;
		ce.RegValData = NULL;
		ce.SaveValue = NULL;
		ce.Flags = 0;
		CompatibilityCallback(&ce, Context);

        result = TRUE;
	}

    ExchangeVersion exVersion = DetermineExchangeVersion();
    if (exVersion == EXCHANGE_VER_PRE55SP3)
    {
        TCHAR szMsgExchange[1024];
        COMPATIBILITY_ENTRY cExchange;

        LoadResString(IDS_Exchange, szMsgExchange, 1024);
        ZeroMemory(&cExchange, sizeof(COMPATIBILITY_ENTRY));
        cExchange.Description = szMsgExchange;
        cExchange.HtmlName = szExchangeHTM;
        cExchange.TextName = szExchangeTXT;
        cExchange.RegKeyName = NULL;
        cExchange.RegValName = NULL;
        cExchange.RegValData = NULL;
        cExchange.RegValDataSize = 0;
        cExchange.SaveValue = NULL;
        cExchange.Flags = 0;
        CompatibilityCallback(&cExchange, Context);

        result = TRUE;
    }

   return( result );
}


SuiteVersion DetermineInstalledSuite()
{
	SuiteVersion eVersion=VER_NONE;
	HKEY hKey,hKey25;
	TCHAR szFamilyId[256], szVersion[256], szSuiteName[256];
	DWORD dwVerLen1=256, dwVerLen2=256, dwNameLen=256, dwIdLen=256;
	DWORD dwDataType=REG_SZ;
	
	//
	// First look for versions using the bos key (i.e., all bos versions and sbs 4.5 or later)
	//
	if (ERROR_SUCCESS==RegOpenKey(HKEY_LOCAL_MACHINE,szBosKey,&hKey))
	{
		if(ERROR_SUCCESS==RegQueryValueEx(hKey,szSuiteVersionKey,0,&dwDataType,(LPBYTE)szVersion,&dwVerLen1))
		{
			if(0==_tcsicmp(szVersion,sz45Version))
			{
				// Some 4.5 version is on the box.
				if (ERROR_SUCCESS==RegQueryValueEx(hKey,szFamilyIdKey,0,&dwDataType,(LPBYTE)szFamilyId,&dwIdLen))
				{
					if (0==_tcsicmp(szFamilyId,szBosFamilyId) )
					{
						eVersion=VER_BOS45;
					}
					else if (0==_tcsicmp(szFamilyId,szSbsFamilyId) )
					{
						eVersion=VER_SBS45;
					}
				}
				else
				{
					// The guid just checked is the official version marker; however, 4.5 beta 1 did
					// not use the guids. This version is timebombed and should be dead, but just in case
					// we'll check the suite name string also.
					if (ERROR_SUCCESS==RegQueryValueEx(hKey,szSuiteNameKey,0,&dwDataType, (LPBYTE)szSuiteName,&dwNameLen))
					{
						if (0==_tcsicmp(szSuiteName,szBosName))
						{
							eVersion=VER_BOS45;
						}
						else if (0==_tcsicmp(szSuiteName,szSbsName))
						{
							eVersion=VER_SBS45;
						}
					}
				}
			}
			else
			{
				// A later version is on the box
				eVersion=VER_POST45;
			}
		}
		// look for bos 4.0
		else if (ERROR_SUCCESS==RegQueryValueEx(hKey,szBos40VersionKey,0,&dwDataType,(LPBYTE)szVersion,&dwVerLen2) && 0==_tcsicmp(szBos40Version,szVersion))
		{
			eVersion=VER_BOS40;
		}
		// look for bos 2.5
		else if (ERROR_SUCCESS==RegOpenKey(hKey,szBos25Key,&hKey25))
		{
			eVersion=VER_BOS25;
			RegCloseKey(hKey25);
		}
		RegCloseKey(hKey);
		
	}
	//
	// Look for SBS versions 4.0a, and 4.0.
	//
	else if (ProductSuiteContains(szSbsProductSuiteValue))
	{
		//	
		// If we get here, SBS 4.0 or 4.0a is on the box.
		//
		if (ERROR_SUCCESS==RegOpenKey(HKEY_LOCAL_MACHINE,szSbsKey,&hKey))
		{
			TCHAR szVersion[256];
			DWORD dwVerLen=256;
			DWORD dwDataType=REG_SZ;
			if (ERROR_SUCCESS==RegQueryValueEx(hKey,szSbsVersionKey,0,&dwDataType,(LPBYTE)szVersion,&dwVerLen) &&
				0==_tcsicmp(szVersion,szSbs40AVersion))
			{
				eVersion=VER_SBS40A;	
			}
			else
			{
				eVersion=VER_SBS40;
			}
			RegCloseKey(hKey);
		}
	}
	// We have to make sure the user isn't tricking us into allowing Win2k to upgrade
	// restricted sbs nt. 
	if (eVersion==VER_NONE || eVersion==VER_BOS45 || eVersion==VER_POST45)
	{
		if (ProductSuiteContains(szSbsRestrictedProductSuiteValue))
		{
			// User tried to fool us by altering version info. 
			eVersion=VER_SBSREST;
		}
	}
	return eVersion;
}

// return the display string for the version in question.
void GetSuiteMessage(SuiteVersion eSV, TCHAR* szMsg, UINT nLen)
{
	szMsg[0]=0;
	switch (eSV)
	{
		case VER_NONE:
			break;
		case VER_BOS45:
			LoadResString(IDS_Bos45Msg,szMsg,nLen);
			break;	
		case VER_BOS40:
			LoadResString(IDS_Bos40Msg,szMsg,nLen);
			break;	
		case VER_BOS25:
			LoadResString(IDS_Bos25Msg,szMsg,nLen);
			break;	
		case VER_SBS45:
			LoadResString(IDS_Sbs45Msg,szMsg,nLen);
			break;	
		case VER_SBS40:
			LoadResString(IDS_Sbs40Msg,szMsg,nLen);
			break;	
		case VER_SBS40A:
			LoadResString(IDS_Sbs40AMsg,szMsg,nLen);
			break;
		case VER_SBSREST:	
			LoadResString(IDS_SbsRestMsg,szMsg,nLen);
			break;
	}		
}
void LoadResString(UINT nRes, TCHAR* szString, UINT nLen)
{
	if(!LoadString(g_hinst, nRes, szString, nLen)) 
	{
		szString[0] = 0;
	}
}

// Check the ProductOptions\ProductSuite multi-sz value for the string szTest.
bool ProductSuiteContains(const TCHAR* szTest)
{
	bool bRet=false;
	HKEY hKey;
	unsigned char* Value=NULL;
	TCHAR* szValue;
	DWORD dwDataLen=0;
	DWORD dwDataType=REG_MULTI_SZ;

	if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,szProductOptionsKey,&hKey) )
	{
		// see how big the data will be
		if (ERROR_SUCCESS ==  RegQueryValueEx(hKey,szProductSuiteKey,0,&dwDataType,NULL,&dwDataLen))
		{
			Value=new unsigned char[dwDataLen]; 
			if (Value != NULL && dwDataLen != 1) // if the multi-sz is empty, we get back dataLen=1 and don't need to go further
			{
				if (RegQueryValueEx(hKey,szProductSuiteKey,0,&dwDataType,Value,&dwDataLen) == ERROR_SUCCESS)
				{
					szValue=(TCHAR*)Value;

					for (UINT n = 1 ; *szValue != 0 ; szValue += _tcslen(szValue) + 1) 
					{
						if ( _tcsstr(szValue, szTest) != 0)
						{
							bRet=true;
							break;
						}
					}

				}
			}
			if (Value != NULL)	delete[] Value;
		}
		RegCloseKey(hKey);
	}
	return bRet;
}




ExchangeVersion DetermineExchangeVersion()
{
    ExchangeVersion eVersion=EXCHANGE_VER_NONE;
    HKEY hExchangeKey;
    DWORD dwCurrentVer, dwCurrentSvcPackVer;
    DWORD dwVerLen=sizeof(DWORD);
    DWORD dwDataType=REG_DWORD;
	
    //
    // First look for versions using the Exchange key
    //
    if (ERROR_SUCCESS==RegOpenKey(HKEY_LOCAL_MACHINE,szExchangeKey,&hExchangeKey))
    {
        if(ERROR_SUCCESS==RegQueryValueEx(hExchangeKey,szExchangeVerKey,0,&dwDataType,(LPBYTE)&dwCurrentVer,&dwVerLen))
        {
            if (dwCurrentVer < dwExchangeVer55)
            {
                // prior Exchange 5.5
                eVersion=EXCHANGE_VER_PRE55SP3;
            }
            else if (dwCurrentVer == dwExchangeVer55)
            {
                // Exchange 5.5 version is on the box.
                if (ERROR_SUCCESS==RegQueryValueEx(hExchangeKey,szExchangeSvcPackKey,0,&dwDataType,(LPBYTE)&dwCurrentSvcPackVer,&dwVerLen))
                {
                    if (dwCurrentSvcPackVer >= dwExchangeSvcPack3)
                    {
                        // has Service Pack 3 installed
                        eVersion=EXCHANGE_VER_POST55SP3;
                    }
                    else
                    {
                        // no Service Pack 3
                        eVersion=EXCHANGE_VER_PRE55SP3;
                    }
                }
                else
                {
                    // no Servie Pack 3
                    eVersion=EXCHANGE_VER_PRE55SP3;
                }
            }
        }
        RegCloseKey(hExchangeKey);
    }

    return eVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\argvw.c ===
/***
*argvw.c - create Unicode version of argv arguments
*
*       Copyright (c) 1989-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       processes program command line
*
*Revision History:
*
*******************************************************************************/

#include "precomp.h"
#pragma  hdrstop

/***
*void Parse_Cmdline(cmdstart, argv, lpstr, numargs, numbytes)
*
*Purpose:
*       Parses the command line and sets up the Unicode argv[] array.
*       On entry, cmdstart should point to the command line,
*       argv should point to memory for the argv array, lpstr
*       points to memory to place the text of the arguments.
*       If these are NULL, then no storing (only counting)
*       is done.  On exit, *numargs has the number of
*       arguments (plus one for a final NULL argument),
*       and *numbytes has the number of bytes used in the buffer
*       pointed to by args.
*
*Entry:
*       LPWSTR cmdstart - pointer to command line of the form
*           <progname><nul><args><nul>
*       TCHAR **argv - where to build argv array; NULL means don't
*                      build array
*       LPWSTR lpstr - where to place argument text; NULL means don't
*                      store text
*
*Exit:
*       no return value
*       INT *numargs - returns number of argv entries created
*       INT *numbytes - number of bytes used in args buffer
*
*Exceptions:
*
*******************************************************************************/

void Parse_Cmdline (
    LPTSTR cmdstart,
    LPTSTR*argv,
    LPTSTR lpstr,
    INT *numargs,
    INT *numbytes
    )
{
    LPTSTR p;
    TCHAR c;
    INT inquote;                    /* 1 = inside quotes */
    INT copychar;                   /* 1 = copy char to *args */
    WORD numslash;                  /* num of backslashes seen */

    *numbytes = 0;
    *numargs = 1;                   /* the program name at least */

    /* first scan the program name, copy it, and count the bytes */
    p = cmdstart;
    if (argv)
        *argv++ = lpstr;

    /* A quoted program name is handled here. The handling is much
       simpler than for other arguments. Basically, whatever lies
       between the leading double-quote and next one, or a terminal null
       character is simply accepted. Fancier handling is not required
       because the program name must be a legal NTFS/HPFS file name.
       Note that the double-quote characters are not copied, nor do they
       contribute to numbytes. */
    if (*p == TEXT('\"'))
    {
        /* scan from just past the first double-quote through the next
           double-quote, or up to a null, whichever comes first */
        while ((*(++p) != TEXT('\"')) && (*p != TEXT('\0')))
        {
            *numbytes += sizeof(WCHAR);
            if (lpstr)
                *lpstr++ = *p;
        }
        /* append the terminating null */
        *numbytes += sizeof(WCHAR);
        if (lpstr)
            *lpstr++ = TEXT('\0');

        /* if we stopped on a double-quote (usual case), skip over it */
        if (*p == TEXT('\"'))
            p++;
    }
    else
    {
        /* Not a quoted program name */
        do {
            *numbytes += sizeof(WCHAR);
            if (lpstr)
                *lpstr++ = *p;

            c = *p++;

        } while (c > TEXT(' '));

        if (c == TEXT('\0'))
        {
            p--;
        }
        else
        {
            if (lpstr)
                *(lpstr - 1) = TEXT('\0');
        }
    }

    inquote = 0;

    /* loop on each argument */
    for ( ; ; )
    {
        if (*p)
        {
            while (*p == TEXT(' ') || *p == TEXT('\t'))
                ++p;
        }

        if (*p == TEXT('\0'))
            break;                  /* end of args */

        /* scan an argument */
        if (argv)
            *argv++ = lpstr;         /* store ptr to arg */
        ++*numargs;

        /* loop through scanning one argument */
        for ( ; ; )
        {
            copychar = 1;
            /* Rules: 2N backslashes + " ==> N backslashes and begin/end quote
                      2N+1 backslashes + " ==> N backslashes + literal "
                      N backslashes ==> N backslashes */
            numslash = 0;
            while (*p == TEXT('\\'))
            {
                /* count number of backslashes for use below */
                ++p;
                ++numslash;
            }
            if (*p == TEXT('\"'))
            {
                /* if 2N backslashes before, start/end quote, otherwise
                   copy literally */
                if (numslash % 2 == 0)
                {
                    if (inquote)
                        if (p[1] == TEXT('\"'))
                            p++;    /* Double quote inside quoted string */
                        else        /* skip first quote char and copy second */
                            copychar = 0;
                    else
                        copychar = 0;       /* don't copy quote */

                    inquote = !inquote;
                }
                numslash /= 2;          /* divide numslash by two */
            }

            /* copy slashes */
            while (numslash--)
            {
                if (lpstr)
                    *lpstr++ = TEXT('\\');
                *numbytes += sizeof(WCHAR);
            }

            /* if at end of arg, break loop */
            if (*p == TEXT('\0') || (!inquote && (*p == TEXT(' ') || *p == TEXT('\t'))))
                break;

            /* copy character into argument */
            if (copychar)
            {
                if (lpstr)
                        *lpstr++ = *p;
                *numbytes += sizeof(WCHAR);
            }
            ++p;
        }

        /* null-terminate the argument */

        if (lpstr)
            *lpstr++ = TEXT('\0');         /* terminate string */
        *numbytes += sizeof(WCHAR);
    }

}


LPTSTR *
CommandLineToArgv(
    OUT int *NumArgs
    )
{
    LPTSTR CommandLine;
    TCHAR  ModuleName[MAX_PATH];
    LPTSTR Start;
    INT    Size;
    LPTSTR *Args;

    CommandLine = GetCommandLine();
    GetModuleFileName(NULL,ModuleName,MAX_PATH);

    //
    // If there's no command line at all (won't happen from cmd.exe, but
    // possibly another program), then we use pgmname as the command line
    // to parse, so that argv[0] is initialized to the program name
    //
    Start = *CommandLine ? CommandLine : ModuleName;

    //
    // Find out how much space is needed to store args,
    // allocate space for argv[] vector and strings,
    // and store args and argv ptrs in block we allocate
    //

    Parse_Cmdline(Start,NULL,NULL,NumArgs,&Size);

    Args = (LPTSTR *)LocalAlloc(LMEM_ZEROINIT,((*NumArgs+1) * sizeof(LPTSTR)) + Size);
    if(!Args) {
        return(NULL);
    }

    Parse_Cmdline(Start,Args,(LPTSTR)(Args + *NumArgs),NumArgs,&Size);

    return(Args);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\comp.c ===
#include "precomp.h"
#pragma hdrstop

#define ARRAYSIZE(x)    (sizeof((x))/sizeof((x)[0]))

#include <oleauto.h>
#include <stdio.h>

//
// use the same name as the Win9x upgrade report
//
#define S_APPCOMPAT_DATABASE_FILE   TEXT("compdata\\drvmain.chm")
#define S_APPCOMPAT_TEXT_FILE       TEXT("compdata\\drvmain.inf")
#define DRVCOMPAT_FIELD_IDENTIFIER    TEXT('*')



typedef struct {
    PVOID Text;
    BOOL Unicode;
} COMPAT_TEXT_PARAMS, *PCOMPAT_TEXT_PARAMS;


LIST_ENTRY CompatibilityData;
DWORD CompatibilityCount;
DWORD IncompatibilityStopsInstallation = FALSE;
DWORD GlobalCompFlags;
BOOL g_DeleteRunOnceFlag;

//
// we use poor global variable instead of changing the COMPATIBILITY_CONTEXT
// structure, which would require a recompile of all the compatibility dlls.
// eventually this should move into that structure (and the structure should also have
// a Size member so we can version it in the future.)
//
//
DWORD PerCompatDllFlags;

BOOL AnyNt5CompatDlls = FALSE;

BOOL
SaveCompatibilityData(
    IN  LPCTSTR FileName,
    IN  BOOL IncludeHiddenItems
    );

BOOL
ProcessLine (
    IN  DWORD CompatFlags
    );

WNDPROC OldEditProc;

LRESULT
CALLBACK
TextEditSubProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    //
    // For setsel messages, make start and end the same.
    //
    if ((msg == EM_SETSEL) && ((LPARAM)wParam != lParam)) {
        lParam = wParam;
    }

    return CallWindowProc( OldEditProc, hwnd, msg, wParam, lParam );
}


BOOL
SetTextInDialog(
    HWND hwnd,
    PCOMPAT_TEXT_PARAMS Params
    )
{
    OldEditProc = (WNDPROC) GetWindowLongPtr( hwnd, GWLP_WNDPROC );
    SetWindowLongPtr( hwnd, GWLP_WNDPROC, (LONG_PTR)TextEditSubProc );

#ifdef UNICODE

    if (Params->Unicode) {
        SendMessageW (hwnd, WM_SETTEXT, 0, (LPARAM)Params->Text);
    } else {
        SendMessageA (hwnd, WM_SETTEXT, 0, (LPARAM)Params->Text);
    }

#else

    MYASSERT (!Params->Unicode);
    if (Params->Unicode) {
        return FALSE;
    }
    SendMessageA (hwnd, WM_SETTEXT, 0, (LPARAM)Params->Text);

#endif

    return TRUE;
}

INT_PTR
CALLBACK
CompatibilityTextDlgProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
   )
{
    switch(uMsg) {
        case WM_INITDIALOG:
            SetTextInDialog( GetDlgItem( hwndDlg, IDC_TEXT ), (PCOMPAT_TEXT_PARAMS) lParam );
            break;

        case WM_COMMAND:
            if (wParam == IDOK) {
                EndDialog( hwndDlg, IDOK );
            }
            break;

        case WM_CTLCOLOREDIT:
            SetBkColor( (HDC)wParam, GetSysColor(COLOR_BTNFACE));
            return (INT_PTR)GetSysColorBrush(COLOR_WINDOW);
            break;

        case WM_CLOSE:
            EndDialog (hwndDlg, IDOK);
            break;
    }

    return 0;
}

BOOL
LaunchIE4Instance(
    LPWSTR szResourceURL
    );

BOOL
LaunchIE3Instance(
    LPWSTR szResourceURL
    );

BOOL
pGetDisplayInfo (
    IN      PCTSTR Source,
    OUT     PTSTR UrlName,
    IN      DWORD UrlChars
    )
{
    TCHAR filePath[MAX_PATH];
    BOOL b = TRUE;

    if (!Source || !*Source) {
        return FALSE;
    }

    if (*Source == DRVCOMPAT_FIELD_IDENTIFIER) {
        if (FindPathToWinnt32File (S_APPCOMPAT_DATABASE_FILE, filePath, MAX_PATH)) {
            _sntprintf (UrlName, UrlChars, TEXT("mk:@msitstore:%s::/%s"), filePath, Source + 1);
        } else {
            DebugLog (Winnt32LogError,
                      TEXT("Compatibility data file \"%1\" not found"),
                      0,
                      S_APPCOMPAT_DATABASE_FILE
                      );
            b = FALSE;
        }
    } else {
        if (FindPathToWinnt32File (Source, filePath, MAX_PATH)) {
            _sntprintf (UrlName, UrlChars, TEXT("file://%s"), filePath);
        } else {
            DebugLog (Winnt32LogError,
                      TEXT("Compatibility data file \"%1\" not found"),
                      0,
                      Source
                      );
            b = FALSE;
        }
    }

    return b;
}


BOOL
pGetText (
    IN      PCTSTR TextSource,
    OUT     PVOID* Text,
    OUT     PBOOL Unicode
    )
{
    TCHAR filePath[MAX_PATH];
    DWORD FileSize;
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PVOID BaseAddress;
    HINF infAppCompat;
    INFCONTEXT ic;
    BOOL bValid;
    DWORD totalSize, size;
    PTSTR data, current;
    PSTR text;
    BOOL b = FALSE;

    if (!TextSource || !*TextSource) {
        return FALSE;
    }

    if (*TextSource == DRVCOMPAT_FIELD_IDENTIFIER) {
        if (FindPathToWinnt32File (S_APPCOMPAT_TEXT_FILE, filePath, MAX_PATH)) {
            infAppCompat = SetupapiOpenInfFile (filePath, NULL, INF_STYLE_WIN4, NULL);
            if (infAppCompat != INVALID_HANDLE_VALUE) {
                bValid = TRUE;
                totalSize = 0;
                data = NULL;
                if (SetupapiFindFirstLine (infAppCompat, TextSource + 1, NULL, &ic)) {
                    do {
                        if (!SetupapiGetStringField (&ic, 1, NULL, 0, &FileSize)) {
                            bValid = FALSE;
                            break;
                        }
                        totalSize += FileSize + 2 - 1;
                    } while (SetupapiFindNextLine (&ic, &ic));
                }
                if (bValid && totalSize > 0) {
                    totalSize++;
                    data = (PTSTR) MALLOC (totalSize * sizeof (TCHAR));
                    if (data) {
                        current = data;
                        size = totalSize;
                        if (SetupapiFindFirstLine (infAppCompat, TextSource + 1, NULL, &ic)) {
                            do {
                                if (!SetupapiGetStringField (&ic, 1, current, size, NULL)) {
                                    bValid = FALSE;
                                    break;
                                }
                                lstrcat (current, TEXT("\r\n"));
                                size -= lstrlen (current);
                                current = _tcschr (current, 0);
                            } while (SetupapiFindNextLine (&ic, &ic));
                        }
                    }
                }

                SetupapiCloseInfFile (infAppCompat);

                if (bValid) {
                    if (data) {
                        *Text = data;
#ifdef UNICODE
                        *Unicode = TRUE;
#else
                        *Unicode = FALSE;
#endif
                        b = TRUE;
                    }
                } else {
                    FREE (data);
                }
            }
            if (!b) {
                DebugLog (
                    Winnt32LogError,
                    TEXT("Unable to read section [%1] from \"%2\""),
                    0,
                    TextSource + 1,
                    filePath
                    );
            }
        } else {
            DebugLog (Winnt32LogError,
                      TEXT("Compatibility data file \"%1\" not found"),
                      0,
                      S_APPCOMPAT_DATABASE_FILE
                      );
        }
    } else {
        if (FindPathToWinnt32File (TextSource, filePath, MAX_PATH)) {
            if (MapFileForRead (filePath, &FileSize, &FileHandle, &MappingHandle, &BaseAddress) == ERROR_SUCCESS) {
                text = (PSTR) MALLOC (FileSize + 1);
                if (text) {
                    CopyMemory (text, BaseAddress, FileSize);
                    text[FileSize] = '\0';
                    *Text = text;
                    *Unicode = FALSE;
                    b = TRUE;
                }
                UnmapFile (MappingHandle, BaseAddress);
                CloseHandle (FileHandle);
            }
        } else {
            DebugLog (Winnt32LogError,
                      TEXT("Compatibility data file \"%1\" not found"),
                      0,
                      TextSource
                      );
        }
    }

    return b;
}


VOID
pShowDetails (
    IN      HWND Hdlg,
    IN      PCOMPATIBILITY_DATA CompData
    )
{
    TCHAR urlName[2 * MAX_PATH];
    PWSTR Url;
    INT i;
    PVOID textDescription;
    BOOL bUnicode;
    BOOL UseText = FALSE;

    //
    // We check to see if the pointer as well as its contents are valid. If the contents are Null then we try
    // the txt file before we decide to not do anything.
    //

    if (pGetDisplayInfo (CompData->HtmlName, urlName, 2 * MAX_PATH)) {

        i = _tcslen( urlName );
        Url = (LPWSTR)SysAllocStringLen( NULL, i );

        if( Url ) {
#ifdef UNICODE
            wcscpy( Url, urlName );
#else
            MultiByteToWideChar( CP_ACP, 0, urlName, -1, Url, i);
#endif

            if (!LaunchIE4Instance(Url)) {
                // If we don't have IE4 or better, display text
                UseText = TRUE;
            }

            SysFreeString( Url );
        }
    } else if( CheckUpgradeOnly ) {

        TCHAR Caption[512];

        //
        // If we don't have a URL, and we're only checking
        // the ability to upgrade, then this is probably
        // an item from a message box that's been redirected
        // to the compability list.  Just display a message
        // box with the full text.
        //
        if(!LoadString(hInst,AppTitleStringId,Caption,sizeof(Caption)/sizeof(TCHAR))) {
            Caption[0] = 0;
        }


        MessageBox( Hdlg,
                    CompData->Description,
                    Caption,
                    MB_OK | MB_ICONWARNING );

    } else {
        UseText = TRUE;
    }

    if (UseText) {
        if (pGetText (CompData->TextName, &textDescription, &bUnicode)) {

            COMPAT_TEXT_PARAMS params;

            params.Text = textDescription;
            params.Unicode = bUnicode;

            DialogBoxParam(
                hInst,
                MAKEINTRESOURCE(IDD_COMPATIBILITY_TEXT),
                NULL,
                CompatibilityTextDlgProc,
                (LPARAM)&params
                );

            FREE (textDescription);

        } else {

            TCHAR Heading[512];
            PTSTR Message;

            //
            // When there is no txt name present, as last resort we put up this message
            //
            if(!LoadString(hInst,AppTitleStringId,Heading,sizeof(Heading)/sizeof(TCHAR))) {
                Heading[0] = 0;
            }

            if (FormatMessage (
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
                    hInst,
                    MSG_NO_DETAILS,
                    0,
                    (LPTSTR)&Message,
                    0,
                    NULL
                    )) {
                MessageBox (Hdlg, Message, Heading, MB_OK | MB_ICONWARNING);
                LocalFree ((HLOCAL)Message);
            }
        }
    }
}


BOOL
CompatibilityWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TCHAR           FullPath[MAX_PATH+8], *t;
    LPWSTR          Url;
    BOOL            b = FALSE;
    DWORD           i;
    PCOMPATIBILITY_DATA CompData;
    DWORD           Index;
    static int CurrentSelectionIndex=0;
    static DWORD    Count = 0;
    LV_ITEM         lvi = {0};
    HWND            TmpHwnd;
    static BOOL     WarningsPresent = FALSE;
    static BOOL     ErrorsPresent = FALSE;
    static BOOL     CheckUpgradeNoItems = TRUE;
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    TCHAR           Buffer1[MAX_PATH] = {0};

    switch(msg) {

        case WM_INITDIALOG:
            if( ISNT() && CheckUpgradeOnly ) {

                TCHAR Desc_String[512];
                PLIST_ENTRY     Next;
                PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);

                //
                // Fix up the subtitle and buttons for Checkupgradeonly.
                //
                SetDlgItemText(hdlg,IDT_SUBTITLE,(PTSTR)TEXT("") );


                //
                // If we're doing a CheckUpgradeOnly, then
                // we've been sending error popups to the compatibility
                // list.  It doesn't look like there were any problems or
                // incompatibilities.  We'll put in an "everything's okay"
                // message.
                //

                Next = CompatibilityData.Flink;
                if (Next) {
                    while ((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData) {
                        CompData = CONTAINING_RECORD( Next, COMPATIBILITY_DATA, ListEntry );
                        Next = CompData->ListEntry.Flink;
                        if( (!(CompData->Flags & COMPFLAG_HIDE)) && ProcessLine( CompData->Flags)) {
                            CheckUpgradeNoItems = FALSE;
                        }
                    }

                }
                if( CheckUpgradeNoItems ){

                    if (!CompatibilityData.Flink) {
                        InitializeListHead (&CompatibilityData);
                    }

                    CompData = (PCOMPATIBILITY_DATA) MALLOC( sizeof(COMPATIBILITY_DATA) );
                    if (CompData == NULL) {
                        return 0;
                    }

                    ZeroMemory(CompData,sizeof(COMPATIBILITY_DATA));

                    if(!LoadString(hInst,IDS_COMPAT_NOPROBLEMS,Desc_String,(sizeof(Desc_String)/sizeof(TCHAR))))
                            CompData->Description = 0;
                    else
                            CompData->Description = DupString(Desc_String);

                    CompData->Flags = 0;
                    InsertTailList( &CompatibilityData, &CompData->ListEntry );
                    CompatibilityCount++;
                }
            }

            if (CompatibilityCount) {

                HWND hList =    GetDlgItem( hdlg, IDC_ROOT_LIST );
                PLIST_ENTRY     Next;
                HIMAGELIST      himl;
                HICON           hIcon;
                LV_COLUMN       lvc = {0};
                RECT            rc;

                GetClientRect( hList, &rc );
                lvc.mask = LVCF_WIDTH;
                lvc.cx = rc.right - rc.left - 16;
                ListView_InsertColumn( hList, 0, &lvc );

                Next = CompatibilityData.Flink;
                if (Next) {
                    himl = ImageList_Create( GetSystemMetrics(SM_CXSMICON),
                                             GetSystemMetrics(SM_CXSMICON),
                                             ILC_COLOR,
                                             2,
                                             0 );
                    ListView_SetImageList( hList, himl, LVSIL_SMALL );
                    hIcon = LoadIcon( NULL, IDI_HAND );
                    ImageList_AddIcon( himl, hIcon );
                    hIcon = LoadIcon( NULL, IDI_EXCLAMATION );
                    ImageList_AddIcon( himl, hIcon );

                    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
                    lvi.state     = 0;
                    lvi.stateMask = 0;
                    lvi.iItem = 0;
                    while ((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData) {
                        CompData = CONTAINING_RECORD( Next, COMPATIBILITY_DATA, ListEntry );

                        Next = CompData->ListEntry.Flink;

                        if (ProcessLine( CompData->Flags)) {
                            AnyNt5CompatDlls = TRUE;
                        } else {
                            goto NextIteration;
                        }

                        if ((CompData->Flags & COMPFLAG_HIDE) == 0) {

                            //
                            // Add the icon.
                            //
                            if( himl ) {
                                if (ISNT() && CheckUpgradeOnly && CheckUpgradeNoItems) {
                                    lvi.iImage = -1;
                                    WarningsPresent = TRUE;
                                } else {
                                    if( CompData->Flags & COMPFLAG_STOPINSTALL ) {
                                        lvi.iImage = 0;
                                        ErrorsPresent = TRUE;
                                    } else {
                                        lvi.iImage = 1;
                                        WarningsPresent = TRUE;
                                    }
                                }
                            }

                            //
                            // And the text...
                            //
                            lvi.pszText   = (LPTSTR)CompData->Description;
                            lvi.lParam    = (LPARAM)CompData;
                            if (ListView_InsertItem( hList, &lvi ) != -1) {
                                lvi.iItem++;
                            }

                            Count += 1;
                        }

                        //
                        // Log the items...
                        //
                        DebugLog( Winnt32LogInformation,
                                  CompData->Description,
                                  0 );
                        DebugLog( Winnt32LogInformation,
                                  TEXT("\r\n"),
                                  0 );
NextIteration:
                    NOTHING;
                    }

                }

                // If we have an item then make it the default selection

                if( ErrorsPresent || WarningsPresent ){



                    SetFocus( hList );
                    ListView_SetItemState( hList,
                                           0,
                                           LVIS_SELECTED | LVIS_FOCUSED,
                                           LVIS_SELECTED | LVIS_FOCUSED);
                    CurrentSelectionIndex = 0;

                    lvi.mask = LVIF_PARAM;
                    lvi.iItem = 0;
                    lvi.iSubItem = 0;
                    ListView_GetItem( GetDlgItem( hdlg, IDC_ROOT_LIST ), &lvi );
                    CompData = (PCOMPATIBILITY_DATA)lvi.lParam;

                    TmpHwnd = GetDlgItem( hdlg, IDC_HAVE_DISK );
                    if (CompData->Flags & COMPFLAG_USE_HAVEDISK)
                        UnHideWindow( TmpHwnd );
                    else
                        HideWindow( TmpHwnd );

                }
            }
            break;

        case WM_NOTIFY:

            {
                LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam;


                if( (pnmv->hdr.code == LVN_ITEMCHANGED) ) {


                    Index = ListView_GetNextItem( GetDlgItem( hdlg, IDC_ROOT_LIST ),
                                                  (int)-1,
                                                  (UINT) (LVNI_ALL | LVNI_SELECTED | LVNI_FOCUSED) );



                    if( (Index != LB_ERR) && (pnmv->iItem != CurrentSelectionIndex)) {

                        CurrentSelectionIndex = Index;

                        //
                        // Select the item, and see if we need
                        // to display the "have disk" button.
                        //
                        lvi.mask = LVIF_PARAM;
                        lvi.iItem = Index;
                        lvi.iSubItem = 0;
                        ListView_GetItem( GetDlgItem( hdlg, IDC_ROOT_LIST ), &lvi );
                        CompData = (PCOMPATIBILITY_DATA)lvi.lParam;

                        TmpHwnd = GetDlgItem( hdlg, IDC_HAVE_DISK );
                        HideWindow( TmpHwnd );

                        // Always set the Details button
                        TmpHwnd = GetDlgItem( hdlg, IDC_DETAILS );
                        EnableWindow( TmpHwnd, TRUE );

                        if (CompData->Flags & COMPFLAG_USE_HAVEDISK) {
                            TmpHwnd = GetDlgItem( hdlg, IDC_HAVE_DISK );
                            UnHideWindow( TmpHwnd );
                        }
                        InvalidateRect( GetParent(hdlg), NULL, FALSE );

                    }else if((Index != LB_ERR) && (pnmv->uNewState == (LVIS_SELECTED|LVIS_FOCUSED))){

                        //Transition from nothing selected to previous selection

                        TmpHwnd = GetDlgItem( hdlg, IDC_DETAILS );
                        EnableWindow( TmpHwnd, TRUE );

                    }else if( Index == LB_ERR){

                        // Disable the "Details" button as nothing is selected

                        TmpHwnd = GetDlgItem( hdlg, IDC_DETAILS );
                        EnableWindow( TmpHwnd, FALSE );

                    }
                }
            }
            break;
        case WM_COMMAND:

            if ((LOWORD(wParam) == IDC_HAVE_DISK) && (HIWORD(wParam) == BN_CLICKED)) {
                Index = ListView_GetNextItem( GetDlgItem( hdlg, IDC_ROOT_LIST ),
                                              (int)-1,
                                              (UINT) (LVNI_ALL | LVNI_SELECTED) );
                if( Index != LB_ERR ) {
                    //
                    // Select the item, and see if we need
                    // to display the "have disk" button.
                    //
                    lvi.mask = LVIF_PARAM;
                    lvi.iItem = Index;
                    lvi.iSubItem = 0;
                    ListView_GetItem( GetDlgItem( hdlg, IDC_ROOT_LIST ), &lvi );
                    CompData = (PCOMPATIBILITY_DATA)lvi.lParam;

                    __try {
                        i = CompData->CompHaveDisk(hdlg,CompData->SaveValue);
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        i = GetExceptionCode();
                    }
                    if (i == 0) {
                        ListView_DeleteItem( GetDlgItem( hdlg, IDC_ROOT_LIST ), Index );
                        RemoveEntryList( &CompData->ListEntry );
                        CompatibilityCount -= 1;

                    } else {
                        MessageBoxFromMessageWithSystem(
                            hdlg,
                            i,
                            AppTitleStringId,
                            MB_OK | MB_ICONERROR | MB_TASKMODAL,
                            CompData->hModDll
                            );
                    }
                }
                break;
            }

            if ((LOWORD(wParam) == IDC_DETAILS) && (HIWORD(wParam) == BN_CLICKED)) {

                TCHAR filePath[MAX_PATH];

                Index = ListView_GetNextItem( GetDlgItem( hdlg, IDC_ROOT_LIST ),
                                              (int)-1,
                                              (UINT) (LVNI_ALL | LVNI_SELECTED) );
                if (Index == LB_ERR) {
                    return FALSE;
                }

                //
                // Select the item, and see if we need
                // to display the "have disk" button.
                //
                lvi.mask = LVIF_PARAM;
                lvi.iItem = Index;
                lvi.iSubItem = 0;
                if (!ListView_GetItem( GetDlgItem( hdlg, IDC_ROOT_LIST ), &lvi )) {
                    break;
                }
                CompData = (PCOMPATIBILITY_DATA)lvi.lParam;
                pShowDetails (hdlg, CompData);
                SetFocus( GetDlgItem( hdlg, IDC_ROOT_LIST ) );
                ListView_SetItemState( GetDlgItem( hdlg, IDC_ROOT_LIST ),Index, LVIS_SELECTED, LVIS_SELECTED);
                break;
            }

            if ((LOWORD(wParam) == IDC_SAVE_AS) && (HIWORD(wParam) == BN_CLICKED)) {
            OPENFILENAME ofn;
            TCHAR        Buffer[MAX_PATH] = {0};
            TCHAR        File_Type[MAX_PATH];
            BOOL         SaveFlag;

                //
                // Initialize OPENFILENAME
                //
                ZeroMemory( &ofn, sizeof(OPENFILENAME));
                ofn.lStructSize = sizeof(OPENFILENAME);
                ofn.hwndOwner = hdlg;
                ofn.lpstrFile = Buffer;
                ofn.nMaxFile = MAX_PATH;

                LoadString(hInst,IDS_DEFAULT_COMPATIBILITY_REPORT_NAME,ofn.lpstrFile,(sizeof(Buffer)/sizeof(TCHAR)));


                if( LoadString(hInst, IDS_FILE_MASK_TYPES, File_Type, (sizeof(File_Type)/sizeof(TCHAR))) ){
                    lstrcpy((File_Type+lstrlen(File_Type)+1), TEXT("*.txt\0"));
                    File_Type[lstrlen(File_Type)+7]='\0'; //We need to terminate the pair of strings with double null termination
                    ofn.lpstrFilter = File_Type;
                }




                // Force to begin in %windir%
                MyGetWindowsDirectory( Buffer1, MAX_PATH );
                ofn.lpstrInitialDir = Buffer1;
                ofn.Flags = OFN_NOCHANGEDIR |       // leave the CWD unchanged
                            OFN_EXPLORER |
                            OFN_OVERWRITEPROMPT |
                            OFN_HIDEREADONLY;

                // Let user select disk or directory
                SaveFlag = GetSaveFileName( &ofn );
                if( SaveFlag ) {
                    //
                    // Save it...
                    //
                    PTSTR p;

                    p=_tcsrchr(ofn.lpstrFile,'.');
                    if( !p || (p && lstrcmpi(p, TEXT(".txt"))))
                        lstrcat(ofn.lpstrFile,TEXT(".txt"));

                    SaveCompatibilityData( ofn.lpstrFile, FALSE);
                } else {
                    i = CommDlgExtendedError();
                }
                break;
            }
            break;

        case WMX_ACTIVATEPAGE:

            if (wParam) {
                if (ISNT ()) {
                    MyGetWindowsDirectory (Buffer1, MAX_PATH);
                    wsprintf (FullPath, TEXT("%s\\%s"), Buffer1, S_DEFAULT_NT_COMPAT_FILENAME);
                    SaveCompatibilityData (FullPath, TRUE);
                }

                CHECKUPGRADEONLY_Q();

                if( CheckUpgradeOnly ) {
                    //
                    // Fix up the buttons for Checkupgradeonly.
                    //
                    PropSheet_SetWizButtons( GetParent(hdlg), (WizPage->CommonData.Buttons | PSWIZB_FINISH) );
                    EnableWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),FALSE);
                    ShowWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),SW_HIDE);
                }

                if(ISNT() && OsVersion.dwMajorVersion == 5 ){

                    if (!AnyNt5CompatDlls) {
                        //
                        // sanity check
                        //
                        MYASSERT (!IncompatibilityStopsInstallation);
                        return FALSE;
                    }

                }

                if (Count) {
                    //
                    // only need this page if there are incompatibities
                    //

                    if( (!CheckUpgradeOnly) && (UnattendedOperation) && (ErrorsPresent == FALSE) ) {
                        //
                        // We're doing an unattended upgrade, and there are
                        // only warnings.  Blow past the page.
                        //
                        b = FALSE;

                    } else {
                         TCHAR Text[512];

                        //
                        // Customize the look of the page, depending on
                        // what we have to display.  3 cases are possible:
                        // 1. Warnings only (services we'll stop).
                        // 2. Errors only (items that will prevent installation).
                        // 3. combination of 1. and 2.
                        //
                        if( (CheckUpgradeOnly == TRUE) && (CheckUpgradeNoItems == TRUE) ) {
                             LoadString(hInst,IDS_COMPAT_CHECKUPGRADE,Text,sizeof(Text)/sizeof(TCHAR));
                        } else if( (WarningsPresent == TRUE) && (ErrorsPresent == TRUE) ) {
                             LoadString(hInst,IDS_COMPAT_ERR_WRN,Text,sizeof(Text)/sizeof(TCHAR));
                        } else if( WarningsPresent == TRUE ) {
                             LoadString(hInst,IDS_COMPAT_WRN,Text,sizeof(Text)/sizeof(TCHAR));
                        } else if( ErrorsPresent == TRUE ) {
                             LoadString(hInst,IDS_COMPAT_ERR,Text,sizeof(Text)/sizeof(TCHAR));
                        }
                        SetDlgItemText(hdlg,IDC_INTRO_TEXT,Text);

                        b = TRUE;

                        if (BatchMode || (CheckUpgradeOnly && UnattendSwitchSpecified)) {
                            //
                            // don't stop on this page in batch mode
                            //
                            UNATTENDED(PSBTN_NEXT);
                        }
                        else
                        {
                            // Stop the bill board and show the wizard again.
                            SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
                        }
                    }
                }

                if (!b) {
                    //
                    // sanity check
                    //
                    MYASSERT (!IncompatibilityStopsInstallation);
                }

            } else {
                b = TRUE;
            }
            break;

        case WMX_NEXTBUTTON:

            if (IncompatibilityStopsInstallation) {
                SaveMessageForSMS( MSG_INCOMPATIBILITIES );
                // Send the ID of the page we wish to advance to
                *((LONG *)lParam) = IDD_CLEANING;

            }
            break;

        default:
            break;
    }

    return(b);
}



BOOL
ProcessLine (
    IN      DWORD CompatFlags
    )
{
    DWORD currentVersion;
    //return (OsVersion.dwMajorVersion < 5) || (CompatFlags & COMPFLAG_ALLOWNT5COMPAT);
    switch (OsVersionNumber) {
        case 400:
            return ( !(CompatFlags & COMPFLAG_SKIPNT40CHECK));
        case 500:
            return ( !(CompatFlags & COMPFLAG_SKIPNT50CHECK));
        case 501:  // version 5.1
            return ( !(CompatFlags & COMPFLAG_SKIPNT51CHECK));
        default:
            return TRUE;
    }
    return TRUE;
}


DWORD
ProcessRegistryLine(
    LPVOID InfHandle,
    LPTSTR SectionName,
    DWORD Index
    )
{
    LONG Error;
    HKEY hKey;
    DWORD Size, Reg_Type;
    LPBYTE Buffer;
    PCOMPATIBILITY_DATA CompData;
    LPCTSTR RegKey;
    LPCTSTR RegValue;
    LPCTSTR RegValueExpect;
    LPCTSTR Flags;
    TCHAR Value[20];
    PCTSTR Data;
    DWORD compatFlags = 0;
    BOOL bFail;


    //
    // first check if this line should be processed on NT5
    //
    Flags = InfGetFieldByIndex( InfHandle, SectionName, Index, 9 );
    if( Flags ){
        StringToInt ( Flags, &compatFlags);
    }
    if (!ProcessLine (compatFlags)) {
        return 0;
    }

    RegKey         = InfGetFieldByIndex( InfHandle, SectionName, Index, 1 );
    RegValue       = InfGetFieldByIndex( InfHandle, SectionName, Index, 2 );
    RegValueExpect = InfGetFieldByIndex( InfHandle, SectionName, Index, 3 );


    //
    // open the reg key
    //

    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        RegKey,
        0,
        KEY_READ,
        &hKey
        );
    if( Error != ERROR_SUCCESS ) {
        //
        // bogus reg key
        //
        return 0;
    }


    //
    // find out how much data there is
    //

    Error = RegQueryValueEx(
        hKey,
        RegValue,
        NULL,
        &Reg_Type,
        NULL,
        &Size
        );
    if( Error == ERROR_SUCCESS ) {

        //
        // allocate the buffer
        //

        Buffer = (LPBYTE) MALLOC( Size );
        if (Buffer == NULL) {
            RegCloseKey( hKey );
            return 0;
        }

        //
        // read the data
        //

        Error = RegQueryValueEx(
            hKey,
            RegValue,
            NULL,
            NULL,
            Buffer,
            &Size
            );

        RegCloseKey( hKey );

        if( Error != ERROR_SUCCESS ) {
            FREE( Buffer );
            return 0;
        }

        if( Reg_Type == REG_DWORD ){
            _itot( *(DWORD*)Buffer, Value, 10 );
            Data = Value;
        } else {
            Data = (PCTSTR)Buffer;
        }

        bFail = RegValueExpect && *RegValueExpect && (lstrcmp( RegValueExpect, Data ) != 0);

        FREE( Buffer );

        if (bFail) {
            return 0;
        }

    } else {

        RegCloseKey( hKey );

        if (RegValue && *RegValue) {
            return 0;
        }
        if (Error != ERROR_FILE_NOT_FOUND) {
            return 0;
        }
        if (RegValueExpect && *RegValueExpect) {
            return 0;
        }
    }

    CompData = (PCOMPATIBILITY_DATA) MALLOC( sizeof(COMPATIBILITY_DATA) );
    if (CompData == NULL) {
        return 0;
    }

    ZeroMemory(CompData,sizeof(COMPATIBILITY_DATA));

    CompData->Type = TEXT('r');
    CompData->RegKey         = InfGetFieldByIndex( InfHandle, SectionName, Index, 1 );
    CompData->RegValue       = InfGetFieldByIndex( InfHandle, SectionName, Index, 2 );
    CompData->RegValueExpect = InfGetFieldByIndex( InfHandle, SectionName, Index, 3 );
    CompData->HtmlName       = InfGetFieldByIndex( InfHandle, SectionName, Index, 4 );
    CompData->TextName       = InfGetFieldByIndex( InfHandle, SectionName, Index, 5 );
    if (!(CompData->TextName && *CompData->TextName)) {
        CompData->TextName = CompData->HtmlName;
    }
    CompData->Description    = InfGetFieldByIndex( InfHandle, SectionName, Index, 6 );
    CompData->InfName        = InfGetFieldByIndex( InfHandle, SectionName, Index, 7 );
    CompData->InfSection     = InfGetFieldByIndex( InfHandle, SectionName, Index, 8 );
    CompData->Flags          = compatFlags | GlobalCompFlags;


    InsertTailList( &CompatibilityData, &CompData->ListEntry );

    return 1;
}



DWORD
ProcessServiceLine(
    LPVOID InfHandle,
    LPTSTR SectionName,
    DWORD Index,
    BOOL SetCheckedFlag
    )
{
    TCHAR KeyName[MAX_PATH];
    LONG Error;
    HKEY hKey;
    PCOMPATIBILITY_DATA CompData;
    LPCTSTR ServiceName;
    LPDWORD RegData;
    DWORD Value;
    DWORD ValueSize;
    LPCTSTR FileName, FileVer, Flags;
    LPCTSTR linkDateStr, binProdVerStr;
    DWORD compatFlags = 0;


    Flags = InfGetFieldByIndex( InfHandle, SectionName, Index, 7 );
    if( Flags ){
        StringToInt ( Flags, &compatFlags);
    }

    //
    // first check if this line should be processed on NT5
    //
    if (!ProcessLine (compatFlags)) {
        return 0;
    }


    ServiceName = InfGetFieldByIndex( InfHandle, SectionName, Index, 1 );
    BuildPath (KeyName, TEXT("SYSTEM\\CurrentControlSet\\Services"), ServiceName);
    //
    // get an open key to the services database
    //

    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        KeyName,
        0,
        KEY_READ | KEY_WRITE,
        &hKey
        );
    if( Error != ERROR_SUCCESS ) {
        return 0;
    }

    //
    // We'll ceate a key here so that others will know that we've
    // already checked this service.  We'll remove it later.  We
    // don't care about error codes here because this is only used
    // as a safety net for checks that may come after us.
    //
    if( SetCheckedFlag ) {
        Value = 1;
        RegSetValueEx( hKey,
                       TEXT("SetupChecked"),
                       0,
                       REG_DWORD,
                       (CONST BYTE *)&Value,
                       sizeof(DWORD) );
    } else {
        //
        // The user has asked us to simply remove these 'checked' flags
        // from the services that we've examined.
        //
        RegDeleteValue( hKey,
                        TEXT("SetupChecked") );
        RegCloseKey( hKey );
        return 0;
    }

    //
    // Check the start value of our target service.
    //
    ValueSize = sizeof(Value);

    Error = RegQueryValueEx(
        hKey,
        TEXT("Start"),
        NULL,
        NULL,
        (LPBYTE)&Value,
        &ValueSize
        );

    if( Error != ERROR_SUCCESS){
        Value = (DWORD)-1;
    }

    RegCloseKey( hKey );

    // Have to check for the contents being NULL as InfGetFieldByIndex returns
    // a valid pointer holding NULL if the field is blank. Also we need to go on in that case
    // to look for Flags.
    FileName = InfGetFieldByIndex( InfHandle, SectionName, Index, 5 );
    FileVer = InfGetFieldByIndex( InfHandle, SectionName, Index, 6 );

    if( FileName && *FileName) {

        linkDateStr = InfGetFieldByIndex( InfHandle, SectionName, Index, 10);
        binProdVerStr = InfGetFieldByIndex( InfHandle, SectionName, Index, 11);

        if (!CheckForFileVersionEx ( FileName, FileVer, binProdVerStr, linkDateStr))
            return 0;
    }

    RegData = (LPDWORD)MALLOC( sizeof(DWORD) );
    if (RegData == NULL) {
        return 0;
    }

    CompData = (PCOMPATIBILITY_DATA) MALLOC( sizeof(COMPATIBILITY_DATA) );
    if (CompData == NULL) {
        FREE(RegData);
        return 0;
    }

    ZeroMemory(CompData,sizeof(COMPATIBILITY_DATA));

    CompData->Type = TEXT('s');
    CompData->Flags = compatFlags;

    CompData->ServiceName           = InfGetFieldByIndex( InfHandle, SectionName, Index, 1 );
    CompData->HtmlName              = InfGetFieldByIndex( InfHandle, SectionName, Index, 2 );
    CompData->TextName              = InfGetFieldByIndex( InfHandle, SectionName, Index, 3 );
    if (!(CompData->TextName && *CompData->TextName)) {
        CompData->TextName = CompData->HtmlName;
    }
    CompData->Description           = InfGetFieldByIndex( InfHandle, SectionName, Index, 4 );
    CompData->RegKeyName            = DupString( KeyName );
    CompData->RegValName            = DupString( TEXT("Start") );
    RegData[0]                      = SERVICE_DISABLED;
    CompData->RegValData            = RegData;
    CompData->RegValDataSize        = sizeof(DWORD);
    CompData->Flags                |= GlobalCompFlags;
    CompData->InfName               = InfGetFieldByIndex( InfHandle, SectionName, Index, 8 );
    CompData->InfSection            = InfGetFieldByIndex( InfHandle, SectionName, Index, 9 );


    if( Value == SERVICE_DISABLED) {
        // Let's not block installation since we didn't before and doesn't need to be now either.
        CompData->Flags &= ~COMPFLAG_STOPINSTALL;
        // Don't display any warnings since they can't do anything about it.
        CompData->Flags |= COMPFLAG_HIDE;
    }
    InsertTailList( &CompatibilityData, &CompData->ListEntry );

    return 1;
}


DWORD
ProcessTextModeLine(
    LPVOID InfHandle,
    LPTSTR SectionName,
    DWORD Index
    )
{
    //
    // Format of line:
    // 0, 1        , 2             , 3    , 4    , 5        , 6   , 7      , 8
    // t,"fullpath","version.minor","html","text",%stringid%,flags,linkdate,binprodversion
    //
    PCOMPATIBILITY_DATA     CompData;
    LPCTSTR                 FileName;
    LPCTSTR                 Flags;
    LPCTSTR                 FileVer;
    DWORD                   CompatFlags = 0;

    //
    // The only thing we need to start is the file name.
    //
    FileName = InfGetFieldByIndex(InfHandle, SectionName, Index, 1);

    //
    // If there was a filename, then see if its version and whatnot actually
    // match
    //
    if ( FileName && *FileName )
    {
        LPCTSTR linkDateStr, binProdVerStr;

        FileVer = InfGetFieldByIndex(InfHandle, SectionName, Index, 2);
        linkDateStr = InfGetFieldByIndex(InfHandle, SectionName, Index, 7);
        binProdVerStr = InfGetFieldByIndex(InfHandle, SectionName, Index, 8);

        if ( !CheckForFileVersionEx( FileName, FileVer, binProdVerStr, linkDateStr ) )
            return 0;
    }
    else
    {
        return 0;
    }   

    Flags = InfGetFieldByIndex(InfHandle, SectionName, Index, 6);

    if ( Flags != NULL ){
        StringToInt(Flags, &CompatFlags);
    }

    CompData = (PCOMPATIBILITY_DATA)MALLOC(sizeof(COMPATIBILITY_DATA));
    if ( CompData == NULL )
        return 0;

    //
    // Now fill out the compdata structure
    //
    ZeroMemory(CompData, sizeof(*CompData));
    CompData->FileName      = FileName;
    CompData->FileVer       = FileVer;
    CompData->HtmlName      = InfGetFieldByIndex(InfHandle, SectionName, Index, 3);
    CompData->TextName      = InfGetFieldByIndex(InfHandle, SectionName, Index, 4);
    if ( ( CompData->TextName == NULL ) || !CompData->TextName[0] )
        CompData->TextName = CompData->HtmlName;
    CompData->Description   = InfGetFieldByIndex(InfHandle, SectionName, Index, 5);

    //
    CompData->Flags = CompatFlags | GlobalCompFlags | COMPFLAG_HIDE;
    CompData->Type = TEXT('t');
    
    InsertTailList(&CompatibilityData, &CompData->ListEntry);

    return 1;
    
}

DWORD
ProcessFileLine(
    LPVOID InfHandle,
    LPTSTR SectionName,
    DWORD Index
    )
{

    PCOMPATIBILITY_DATA CompData;
    LPCTSTR FileName;
    LPCTSTR FileVer;
    LPCTSTR Flags;
    LPCTSTR linkDateStr, binProdVerStr;
    DWORD compatFlags = 0;


    //
    // first check if this line should be processed on NT5
    //
    Flags = InfGetFieldByIndex( InfHandle, SectionName, Index, 8);
    if( Flags ){
        StringToInt ( Flags, &compatFlags);
    }
    if (!ProcessLine (compatFlags)) {
        return 0;
    }

    FileName  = InfGetFieldByIndex( InfHandle, SectionName, Index, 1 );
    FileVer   = InfGetFieldByIndex( InfHandle, SectionName, Index, 2 );


    if( FileName && *FileName ){

        linkDateStr = InfGetFieldByIndex( InfHandle, SectionName, Index, 9);
        binProdVerStr = InfGetFieldByIndex( InfHandle, SectionName, Index, 10);

        if (!CheckForFileVersionEx ( FileName, FileVer, binProdVerStr, linkDateStr)) {
            return 0;
        }
    }else{
        return 0;
    }


    CompData = (PCOMPATIBILITY_DATA) MALLOC( sizeof(COMPATIBILITY_DATA) );
    if (CompData == NULL) {
        return 0;
    }

    ZeroMemory(CompData,sizeof(COMPATIBILITY_DATA));

    CompData->Type = TEXT('f');
    CompData->FileName       = InfGetFieldByIndex( InfHandle, SectionName, Index, 1 );
    CompData->FileVer        = InfGetFieldByIndex( InfHandle, SectionName, Index, 2 );
    CompData->HtmlName       = InfGetFieldByIndex( InfHandle, SectionName, Index, 3 );
    CompData->TextName       = InfGetFieldByIndex( InfHandle, SectionName, Index, 4 );
    if (!(CompData->TextName && *CompData->TextName)) {
        CompData->TextName = CompData->HtmlName;
    }
    CompData->Description    = InfGetFieldByIndex( InfHandle, SectionName, Index, 5 );
    CompData->InfName        = InfGetFieldByIndex( InfHandle, SectionName, Index, 6 );
    CompData->InfSection     = InfGetFieldByIndex( InfHandle, SectionName, Index, 7 );
    CompData->Flags          = compatFlags | GlobalCompFlags;

    InsertTailList( &CompatibilityData, &CompData->ListEntry );

    return 1;
}

BOOL
CompatibilityCallback(
    PCOMPATIBILITY_ENTRY CompEntry,
    PCOMPATIBILITY_CONTEXT CompContext
    )
{
    PCOMPATIBILITY_DATA CompData;

    //
    // parameter validation
    //

    if (CompEntry->Description == NULL || CompEntry->Description[0] == 0) {
        //
        // who did this?
        //
        MYASSERT (FALSE);
        SetLastError( COMP_ERR_DESC_MISSING );
        return FALSE;
    }

    if (CompEntry->TextName == NULL || CompEntry->TextName[0] ==0) {
        //
        // who did this?
        //
        MYASSERT (FALSE);
        SetLastError( COMP_ERR_TEXTNAME_MISSING );
        return FALSE;
    }

    if (CompEntry->RegKeyName) {
        if (CompEntry->RegValName == NULL) {
            //
            // who did this?
            //
            MYASSERT (FALSE);
            SetLastError( COMP_ERR_REGVALNAME_MISSING );
            return FALSE;
        }
        if (CompEntry->RegValData == NULL) {
            //
            // who did this?
            //
            MYASSERT (FALSE);
            SetLastError( COMP_ERR_REGVALDATA_MISSING );
            return FALSE;
        }
    }


    if (CompEntry->InfName) {
        if (CompEntry->InfSection == NULL) {
            //
            // who did this?
            //
            MYASSERT (FALSE);
            SetLastError( COMP_ERR_INFSECTION_MISSING );
            return FALSE;
        }
    }


#ifdef UNICODE
    if (IsTextUnicode( CompEntry->Description, wcslen(CompEntry->Description)*sizeof(WCHAR), NULL ) == 0) {
        //
        // who did this?
        //
        MYASSERT (FALSE);
        SetLastError( COMP_ERR_DESC_NOT_UNICODE );
        return FALSE;
    }
    if (IsTextUnicode( CompEntry->TextName, wcslen(CompEntry->TextName)*sizeof(WCHAR), NULL ) == 0) {
        //
        // who did this?
        //
        MYASSERT (FALSE);
        SetLastError( COMP_ERR_TEXTNAME_NOT_UNICODE );
        return FALSE;
    }
    if (CompEntry->HtmlName) {
        if (IsTextUnicode( CompEntry->HtmlName, wcslen(CompEntry->HtmlName)*sizeof(WCHAR), NULL ) == 0) {
            SetLastError( COMP_ERR_HTMLNAME_NOT_UNICODE );
            return FALSE;
        }
    }
    if (CompEntry->RegKeyName) {
        if (IsTextUnicode( CompEntry->RegKeyName, wcslen(CompEntry->RegKeyName)*sizeof(WCHAR), NULL ) == 0) {
            //
            // who did this?
            //
            MYASSERT (FALSE);
            SetLastError( COMP_ERR_REGKEYNAME_NOT_UNICODE );
            return FALSE;
        }
        if (IsTextUnicode( CompEntry->RegValName, wcslen(CompEntry->RegValName)*sizeof(WCHAR), NULL ) == 0) {
            //
            // who did this?
            //
            MYASSERT (FALSE);
            SetLastError( COMP_ERR_REGVALNAME_NOT_UNICODE );
            return FALSE;
        }
    }
    if (CompEntry->InfName) {
        if (IsTextUnicode( CompEntry->InfName, wcslen(CompEntry->InfName)*sizeof(WCHAR), NULL ) == 0) {
            //
            // who did this?
            //
            MYASSERT (FALSE);
            SetLastError( COMP_ERR_INFNAME_NOT_UNICODE );
            return FALSE;
        }
        if (IsTextUnicode( CompEntry->InfSection, wcslen(CompEntry->InfSection)*sizeof(WCHAR), NULL ) == 0) {
            //
            // who did this?
            //
            MYASSERT (FALSE);
            SetLastError( COMP_ERR_INFSECTION_NOT_UNICODE );
            return FALSE;
        }
    }



#endif

    //
    // allocate the compatibility structure
    //

    CompData = (PCOMPATIBILITY_DATA) MALLOC( sizeof(COMPATIBILITY_DATA) );
    if (CompData == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    ZeroMemory(CompData, sizeof(COMPATIBILITY_DATA));

    //
    // save the sata
    //

    CompData->Description     = DupString( CompEntry->Description );
    CompData->HtmlName        = CompEntry->HtmlName ? DupString( CompEntry->HtmlName ) : NULL;
    CompData->TextName        = DupString( CompEntry->TextName );
    CompData->SaveValue       = CompEntry->SaveValue;
    CompData->Flags           = CompEntry->Flags;
    CompData->Flags          |= PerCompatDllFlags;
    CompData->Flags          |= GlobalCompFlags;
    CompData->CompHaveDisk    = CompContext->CompHaveDisk;
    CompData->hModDll         = CompContext->hModDll;
    if (CompEntry->RegKeyName) {
        CompData->RegKeyName      = DupString( CompEntry->RegKeyName );
        CompData->RegValName      = DupString( CompEntry->RegValName );
        CompData->RegValDataSize  = CompEntry->RegValDataSize;
        CompData->RegValData      = MALLOC(CompEntry->RegValDataSize);
        if (CompData->RegValData) {
            CopyMemory( CompData->RegValData, CompEntry->RegValData, CompEntry->RegValDataSize );
        }
    }
    if (CompEntry->InfName){
        CompData->InfName         = DupString( CompEntry->InfName );
        CompData->InfSection      = DupString( CompEntry->InfSection );

    }

    InsertTailList( &CompatibilityData, &CompData->ListEntry );

    CompContext->Count += 1;

    return TRUE;

}
    


DWORD
ProcessDLLLine(
    LPVOID InfHandle,
    LPTSTR SectionName,
    DWORD Index
    )
{
    TCHAR Buffer[MAX_PATH];
    TCHAR FullPath[MAX_PATH];
    HMODULE hMod;
    CHAR CompCheckEntryPoint[MAX_PATH];
    CHAR HaveDiskEntryPoint[MAX_PATH];
    PCOMPAIBILITYCHECK CompCheck;
    PCOMPAIBILITYHAVEDISK CompHaveDisk;
    LPTSTR DllName;
    LPTSTR CompCheckEntryPointW;
    LPTSTR HaveDiskEntryPointW;
    LPTSTR ProcessOnCleanInstall;
    LPTSTR Flags;
    COMPATIBILITY_CONTEXT CompContext;
    BOOL Rslt;
    DWORD Status;
    DWORD compatFlags = 0;

    PerCompatDllFlags = 0;
    DllName = (LPTSTR)InfGetFieldByIndex( InfHandle, SectionName, Index, 1 );
    if (!DllName)
        return 0;
    CompCheckEntryPointW = (LPTSTR)InfGetFieldByIndex( InfHandle, SectionName, Index, 2 );
    HaveDiskEntryPointW = (LPTSTR)InfGetFieldByIndex( InfHandle, SectionName, Index, 3 );
    if((HaveDiskEntryPointW != NULL) && (lstrlen(HaveDiskEntryPointW) == 0)) {
        //
        //  If HaveDiskEntryPointW points to an empty string, then make it NULL.
        //  This is necessary because since this field is optional, the user may have specified
        //  it in dosnet.inf as ,, and in this case the winnt32 parser will translate the info in
        //  filed as an empty string.
        //
        HaveDiskEntryPointW = NULL;
    }
    ProcessOnCleanInstall = (LPTSTR)InfGetFieldByIndex( InfHandle, SectionName, Index, 4 );

    if( !Upgrade &&
        ((ProcessOnCleanInstall == NULL) ||
         (lstrlen( ProcessOnCleanInstall ) == 0) ||
         (_ttoi(ProcessOnCleanInstall) == 0))
      ) {
        //
        //  On clean install, we don't process the dll if 'ProcessOnCleanInstall' was not
        //  specified, or if it was specified as 0.
        //
        return 0;
    }

    Flags = (LPTSTR)InfGetFieldByIndex( InfHandle, SectionName, Index, 5 );
    if( Flags ){
        //check return value
        StringToInt ( Flags, &compatFlags);
    }
    PerCompatDllFlags = compatFlags;


    if (!ExpandEnvironmentStrings( DllName, Buffer, sizeof(Buffer)/sizeof(TCHAR) )) {
        return 0;
    }

    if (!FindPathToWinnt32File (Buffer, FullPath, MAX_PATH) ||
        !(hMod = LoadLibrary (FullPath))) {
        return 0;
    }

#ifdef UNICODE
    WideCharToMultiByte(
        CP_ACP,
        0,
        CompCheckEntryPointW,
        -1,
        CompCheckEntryPoint,
        sizeof(CompCheckEntryPoint),
        NULL,
        NULL
        );
    if (HaveDiskEntryPointW) {
        WideCharToMultiByte(
            CP_ACP,
            0,
            HaveDiskEntryPointW,
            -1,
            HaveDiskEntryPoint,
            sizeof(HaveDiskEntryPoint),
            NULL,
            NULL
            );
    }
#else
    lstrcpy( CompCheckEntryPoint, CompCheckEntryPointW );
    if (HaveDiskEntryPointW) {
        lstrcpy( HaveDiskEntryPoint, HaveDiskEntryPointW );
    }
#endif

    CompCheck = (PCOMPAIBILITYCHECK) GetProcAddress( hMod, CompCheckEntryPoint );
    if (CompCheck == NULL) {
        FreeLibrary( hMod );
        return 0;
    }

    if (HaveDiskEntryPointW) {
        CompHaveDisk = (PCOMPAIBILITYHAVEDISK) GetProcAddress( hMod, HaveDiskEntryPoint );
        if (CompHaveDisk == NULL) {
            FreeLibrary( hMod );
            return 0;
        }
    }

    CompContext.Count = 0;
    CompContext.CompHaveDisk = CompHaveDisk;
    CompContext.hModDll = hMod;

    if ( !ProcessLine( compatFlags )) {
        Rslt = FALSE;
    } else {
        __try {
            Rslt = CompCheck( (PCOMPAIBILITYCALLBACK)CompatibilityCallback, (LPVOID)&CompContext );
        } except(EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
            Rslt = FALSE;
        }
    }

    PerCompatDllFlags = 0;

    if (!Rslt) {
        FreeLibrary( hMod );
        return 0;
    }

    if (CompContext.Count == 0) {
        FreeLibrary( hMod );
    }

    return CompContext.Count;
}


DWORD
ProcessCompatibilitySection(
    LPVOID InfHandle,
    LPTSTR SectionName
    )
{
    DWORD LineCount;
    DWORD Count;
    DWORD i;
    LPCTSTR Type;
    DWORD Good;


    //
    // get the section count, zero means bail out
    //

    LineCount = InfGetSectionLineCount( InfHandle, SectionName );
    if (LineCount == 0 || LineCount == 0xffffffff) {
        return 0;
    }

    for (i=0,Count=0; i<LineCount; i++) {

        Type = InfGetFieldByIndex( InfHandle, SectionName, i, 0 );
        if (Type == NULL) {
            continue;
        }

        //
        //  On clean install we only process dll line.
        //  (We need to process the line that checks for unsupported architectures)
        //
        if( !Upgrade && ( _totlower(Type[0]) != TEXT('d') ) ) {
            continue;
        }
        switch (_totlower(Type[0])) {
            case TEXT('r'):
                //
                // registry value
                //
                Count += ProcessRegistryLine( InfHandle, SectionName, i );
                break;

            case TEXT('s'):
                //
                // service or driver
                //
                Count += ProcessServiceLine( InfHandle, SectionName, i, TRUE );
                break;

            case TEXT('f'):
                //
                // presence of a file
                //
                Count += ProcessFileLine( InfHandle, SectionName, i );
                break;

            case TEXT('d'):
                //
                // run an external dll
                //
                Count += ProcessDLLLine( InfHandle, SectionName, i );
                break;

            case TEXT('t'):
                //
                // Textmode should know to overwrite this file
                //
                Count += ProcessTextModeLine( InfHandle, SectionName, i );
                break;

            default:
                break;
        }
    }

    return Count;
}


VOID
RemoveCompatibilityServiceEntries(
    LPVOID InfHandle,
    LPTSTR SectionName
    )
{
    DWORD LineCount;
    DWORD Count;
    DWORD i;
    LPCTSTR Type;
    DWORD Good;


    //
    // get the section count, zero means bail out
    //

    LineCount = InfGetSectionLineCount( InfHandle, SectionName );
    if (LineCount == 0 || LineCount == 0xffffffff) {
        return;
    }

    for (i=0,Count=0; i<LineCount; i++) {

        Type = InfGetFieldByIndex( InfHandle, SectionName, i, 0 );
        if (Type == NULL) {
            continue;
        }

        //
        //  On clean install we only process dll line.
        //  (We need to process the line that checks for unsupported architectures)
        //
        if( !Upgrade && ( _totlower(Type[0]) != TEXT('d') ) ) {
            continue;
        }
        switch (_totlower(Type[0])) {
            case TEXT('s'):
                //
                // service or driver
                //
                Count += ProcessServiceLine( InfHandle, SectionName, i, FALSE );
                break;

            default:
                break;
        }
    }
}


//
// HACKHACK - NT4's explorer.exe will fail to properly process runonce values
//            whose value name is > 31 characters. We call this function to
//            workaround this NT4 bug. It basically truncates any value names
//            so that explorer will process and delete them.
//
void FixRunOnceForNT4(DWORD dwNumValues)
{
    HKEY hkRunOnce;
    int iValueNumber = 20; // start this at 20 to minimize chance of name collision.

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce"),
                     0,
                     MAXIMUM_ALLOWED,
                     &hkRunOnce) == ERROR_SUCCESS)
    {
        TCHAR szValueName[MAX_PATH];
        TCHAR szValueContents[MAX_PATH * 3];    // big enough to hold a large regsvr32 command
        DWORD dwValueIndex = 0;
        DWORD dwSanityCheck = 0;
        DWORD dwNameSize = MAX_PATH;
        DWORD dwValueSize = sizeof(szValueContents);
        DWORD dwType;

        while (RegEnumValue(hkRunOnce,
                            dwValueIndex,
                            szValueName,
                            &dwNameSize,
                            NULL,
                            &dwType,
                            (LPBYTE)szValueContents,
                            &dwValueSize) == ERROR_SUCCESS)
        {
            // increment our counters
            dwValueIndex++;
            dwSanityCheck++;

            // reset these for the next RegEnumValue call
            dwNameSize = MAX_PATH;
            dwValueSize = sizeof(szValueContents);

            if ((dwType == REG_SZ) && (lstrlen(szValueName) > 31))
            {
                TCHAR szNewValueName[32];
                TCHAR szTemp[32];

                // we have a value name that is too big for NT4's explorer.exe,
                // so we need to truncate to 10 characters and add a number on the
                // end to insure that it is unique.
                lstrcpyn(szTemp, szValueName, 10);
                wsprintf(szNewValueName, TEXT("%s%d"), szTemp, iValueNumber++);

                RegDeleteValue(hkRunOnce, szValueName);

                RegSetValueEx(hkRunOnce,
                              szNewValueName,
                              0,
                              REG_SZ,
                              (LPBYTE)szValueContents,
                              (lstrlen(szValueContents) + 1) * sizeof(TCHAR));

                // backup our regenum index to be sure we don't miss a value (since we are adding/deleteing
                // values during the enumeration, its kinda messy)
                dwValueIndex--;
            }

            if (dwSanityCheck > (2 * dwNumValues))
            {
                // something has gone terribly wrong, we have looped in RegEnumValue *way* to
                // many times!
                break;
            }
        }

        RegCloseKey(hkRunOnce);
    }
}

BOOL
pCheckForPendingRunOnce (
    VOID
    )
{
    LONG Error;
    HKEY hKey = NULL;
    PCOMPATIBILITY_DATA CompData;
    HKEY setupKey = NULL;
    DWORD dataSize;
    BOOL result = FALSE;
    TCHAR textBuffer[512];
    TCHAR exeBuffer[512];
    DWORD exeBufferSize;
    DWORD type;
    DWORD valueNumber;
    BOOL foundValues = FALSE;
    INF_ENUM e;
    BOOL warningIssued = FALSE;
    BOOL ignore;

    __try {
        //
        // Open regisry keys.
        //
        // ISSUE: Should this be expanded to include HKCU?
        //

        Error = RegOpenKeyEx (
                    HKEY_LOCAL_MACHINE,
                    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce"),
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );

        if (Error != ERROR_SUCCESS) {
            //
            // no RunOnce key [this should exist in all cases]
            //
            __leave;
        }

        Error = RegOpenKeyEx (
                    HKEY_LOCAL_MACHINE,
                    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup"),
                    0,
                    KEY_ALL_ACCESS,
                    &setupKey
                    );

        //
        // Did we already provide a warning?
        //

        if (setupKey) {
            dataSize = sizeof (textBuffer);

            Error = RegQueryValueEx (
                        setupKey,
                        S_WINNT32_WARNING,
                        NULL,
                        NULL,
                        (PBYTE) textBuffer,
                        &dataSize
                        );

            if (Error == ERROR_SUCCESS) {
                //
                // Warning was issued. Did user reboot as instructed? If they
                // did, then the RunOnce entry should be gone. Otherwise, we
                // will not provide the warning again if someone keeps
                // putting junk in RunOnce.
                //

                dataSize = sizeof (textBuffer);

                Error = RegQueryValueEx (
                            hKey,
                            S_WINNT32_WARNING,
                            NULL,
                            NULL,
                            (PBYTE) textBuffer,
                            &dataSize
                            );

                if (Error == ERROR_SUCCESS) {
                    foundValues = TRUE;
                } else {
                    __leave;
                }
            }
        }

        //
        // The warning has never been issued. Check if there are any RunOnce
        // entries present. Skip excluded entries.
        //
        // NOTE: We restrict the loop to 10000, in line with existing code that
        //       is protecting itself from enumerations that never end on NT
        //       4. It is not clear this is needed, but 10000 should be high
        //       enough to take care of this risk without introducing other
        //       problems.
        //

        if (!foundValues) {

            for (valueNumber = 0 ; valueNumber < 10000 ; valueNumber++) {

                dataSize = sizeof (textBuffer) / sizeof (TCHAR);
                exeBufferSize = sizeof (exeBuffer);

                Error = RegEnumValue (
                            hKey,
                            valueNumber,
                            textBuffer,
                            &dataSize,
                            NULL,
                            &type,
                            (PBYTE) exeBuffer,
                            &exeBufferSize
                            );

                if (Error == ERROR_NO_MORE_ITEMS) {
                    break;
                }

                if (Error == ERROR_SUCCESS) {
                    //
                    // Test registry value against pattern list
                    //

                    ignore = FALSE;
                    if (EnumFirstInfLine (&e, MainInf, TEXT("RunOnceExclusions.Value"))) {
                        do {
                            if (IsPatternMatch (e.FieldZeroData, textBuffer)) {
                                AbortInfLineEnum (&e);
                                ignore = TRUE;
                                break;
                            }
                        } while (EnumNextInfLine (&e));
                    }

                    if (ignore) {
                        continue;
                    }

                    //
                    // Test command line against pattern list
                    //

                    if (EnumFirstInfLine (&e, MainInf, TEXT("RunOnceExclusions.ValueData"))) {
                        do {
                            if (IsPatternMatch (e.FieldZeroData, exeBuffer)) {
                                AbortInfLineEnum (&e);
                                ignore = TRUE;
                                break;
                            }
                        } while (EnumNextInfLine (&e));
                    }

                    if (ignore) {
                        continue;
                    }

                    //
                    // Found a RunOnce entry that should be executed before upgrading
                    //

                    foundValues = TRUE;
                    break;
                }
            }

            //
            // If no RunOnce values found, don't provide the warning.
            //

            if (!foundValues) {
                __leave;
            }
        }

        //
        // Otherwise, provide the warning, and write Winnt32Warning to the Setup
        // key and RunOnce key.
        //

        CompData = (PCOMPATIBILITY_DATA) MALLOC( sizeof(COMPATIBILITY_DATA) );
        if (CompData == NULL) {
            __leave;
        }

        ZeroMemory(CompData,sizeof(COMPATIBILITY_DATA));

        if(!LoadString(hInst,IDS_COMPAT_PENDING_REBOOT,textBuffer,sizeof(textBuffer)/sizeof(TCHAR))) {
            CompData->Description = 0;
        } else {
            CompData->Description = DupString(textBuffer);
        }

        CompData->Flags |= GlobalCompFlags;
        CompData->HtmlName = DupString( TEXT("compdata\\runonce.htm") );
        CompData->TextName = DupString( TEXT("compdata\\runonce.txt") );

        InsertTailList( &CompatibilityData, &CompData->ListEntry );

        if (ISNT() && BuildNumber <= 1381) {
            //
            // Get the number of values for the worker fn, so it
            // can protect itself against a runaway enumeration.
            //

            Error = RegQueryInfoKey (
                        hKey,
                        NULL,           // class
                        NULL,           // class size
                        NULL,           // reserved
                        NULL,           // subkey count
                        NULL,           // max subkeys
                        NULL,           // max class
                        &valueNumber,   // value count
                        NULL,           // max value name len
                        NULL,           // max value data len
                        NULL,           // security desc
                        NULL            // last write time
                        );

            if (Error != ERROR_SUCCESS) {
                valueNumber = 100;          // some random count, doesn't really matter because failure case is impracticle
            }

            FixRunOnceForNT4 (valueNumber);
        }

        RegSetValueEx (
            setupKey,
            S_WINNT32_WARNING,
            0,
            REG_SZ,
            (PBYTE) TEXT(""),                   // value is all that matters, data is irrelevant
            sizeof (TCHAR)
            );

        RegSetValueEx (
            hKey,
            S_WINNT32_WARNING,
            0,
            REG_SZ,
            (PBYTE) TEXT("user.exe"),           // this EXE exists on all machines, terminates right away
                                                // and produces no UI
            sizeof (TEXT("user.exe"))
            );

        result = TRUE;
    }
    __finally {
        if (!result && setupKey) {
            //
            // Clean up warning flag at the end of WINNT32
            //

            g_DeleteRunOnceFlag = TRUE;
        }

        if (hKey) {
            RegCloseKey (hKey);
        }

        if (setupKey) {
            RegCloseKey (setupKey);
        }
    }

    return result;
}



BOOL
ProcessCompatibilityData(
    HWND hDlg
    )
{
    DWORD Count;


    if( !CompatibilityData.Flink ) {
        InitializeListHead( &CompatibilityData );
    }

    //
    //  On clean install we have to process [ServicesToStopInstallation].
    //  This section will contain at least the check for unsupported architectures that has to be
    //  executed onb clean install.
    //
    GlobalCompFlags = COMPFLAG_STOPINSTALL;
    //
    // please don't reset this variable; it may be > 0 intentionally!
    //
    // CompatibilityCount = 0;
    //
    // check for "RunOnce" Stuff
    //
    if( (Upgrade) && !(CheckUpgradeOnly) ) {
        if (pCheckForPendingRunOnce()) {
            CompatibilityCount++;
            IncompatibilityStopsInstallation = TRUE;
        }
    }

    if (ISNT()) {

        CompatibilityCount += ProcessCompatibilitySection( NtcompatInf, TEXT("ServicesToStopInstallation") );
        if (CompatibilityCount) {
            IncompatibilityStopsInstallation = TRUE;
        }

        GlobalCompFlags = 0;
        CompatibilityCount += ProcessCompatibilitySection( NtcompatInf, TEXT("ServicesToDisable") );

        //
        // Now cleanup any turds we left in the registry on the services we checked.
        //
        RemoveCompatibilityServiceEntries( NtcompatInf, TEXT("ServicesToStopInstallation") );
        RemoveCompatibilityServiceEntries( NtcompatInf, TEXT("ServicesToDisable") );
    }

    if( CompatibilityCount ) {
        return TRUE;
    } else {
        return FALSE;
    }
}


BOOL
WriteTextmodeReplaceData(
    IN HANDLE hTargetFile
    )
{
    CHAR                Buffer[MAX_PATH*2];
    PLIST_ENTRY         Next;
    PCOMPATIBILITY_DATA CompData;
    BOOL                Result = FALSE;
    DWORD               Bytes;
    
    //
    // For textmode "overwriting" files, write them out to the
    // WINNT_OVERWRITE_EXISTING (IncompatibleFilesToOverWrite) section
    // of this compatibility data file.
    //
    // Textmode just needs to know the name of the file.
    //
    SetFilePointer(hTargetFile, 0, 0, FILE_END);
    sprintf(Buffer, "\r\n[%s]\r\n", WINNT_OVERWRITE_EXISTING_A);
    WriteFile(hTargetFile, (LPBYTE)Buffer, strlen(Buffer), &Bytes, NULL);

    //
    // Loop down the list of items
    //
    if ( ( Next = CompatibilityData.Flink ) != NULL ) 
    {
        while ((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData)
        {
            CompData = CONTAINING_RECORD(Next, COMPATIBILITY_DATA, ListEntry);
            Next = CompData->ListEntry.Flink;

            if (!ProcessLine(CompData->Flags))
                continue;

            //
            // The set string is:
            //
            // "shortfilename" = "fullpathname","version.string"
            //
            // ExpandEnvironmentStrings to ensure that the full path for any
            // 't' line is expanded properly
            //
            if ((CompData->Type == TEXT('t')) && CompData->FileName)
            {
                static TCHAR tchLocalExpandedPath[MAX_PATH*2];
                PTSTR ptszFileNameBit = NULL;
                DWORD dwResult = 0;

                dwResult = ExpandEnvironmentStrings(
                    CompData->FileName,
                    tchLocalExpandedPath,
                    MAX_PATH );

                //
                // Did we run out of characters expanding the path?  Wierd...
                //
                if ( dwResult > MAX_PATH*2 )
                    goto Exit;

                //
                // Find the actual file name by looking backwards from the end of
                // the string.
                //
                ptszFileNameBit = _tcsrchr( tchLocalExpandedPath, TEXT('\\') );
                if ( ptszFileNameBit == NULL )
                    ptszFileNameBit = _tcsrchr( tchLocalExpandedPath, TEXT('/') );

                //
                // Form up this buffer containing the details Texmode will want.
                // If there's no filenamebit, use the full path name.  Textmode
                // will likely fail to find the file, but Nothing Bad will happen.
                // If the version is missing (strange....) then use a blank string
                // to avoid upsetting textmode.
                //
                wsprintfA(
                    Buffer, 
#ifdef UNICODE
                    "\"%ls\" = \"%ls\",\"%ls\"\r\n", 
#else
                    "\"%s\" = \"%s\",\"%s\"\r\n", 
#endif
                    ptszFileNameBit ? ptszFileNameBit + 1 : tchLocalExpandedPath,
                    CompData->FileVer ? CompData->FileVer : TEXT(""),
                    tchLocalExpandedPath );

                //
                // Spit the buffer (in ansi chars, no less) into the file.
                //
                if (!WriteFile(hTargetFile, Buffer, strlen(Buffer), &Bytes, NULL ))
                    goto Exit;

            }
        }
    }

    Result = TRUE;
Exit:
    return Result;

}

#ifdef UNICODE

BOOL
pIsOEMService (
    IN  PCTSTR  ServiceKeyName,
    OUT PTSTR OemInfPath,           OPTIONAL
    IN  INT BufferSize              OPTIONAL
    );
//This function is defined in unsupdrv.c
#endif


BOOL
WriteCompatibilityData(
    IN LPCTSTR FileName
    )
{
    TCHAR Text[MAX_PATH*2];
    PLIST_ENTRY Next;
    PCOMPATIBILITY_DATA CompData;
    HANDLE hFile;
    CHAR Buffer[MAX_PATH*2];
    DWORD Bytes;
    PSTRINGLIST listServices = NULL, p;
    PCTSTR serviceName;
    BOOL b = FALSE;

    if (CompatibilityCount == 0) {
        return FALSE;
    }

    hFile = CreateFile(
        FileName,
        GENERIC_WRITE,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if(hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    __try {
        SetFilePointer( hFile, 0, 0, FILE_END );

        sprintf( Buffer, "\r\n[%s]\r\n", WINNT_COMPATIBILITY_A );
        WriteFile( hFile, (LPBYTE)Buffer, strlen(Buffer), &Bytes, NULL );

        Next = CompatibilityData.Flink;
        if (Next) {
            while ((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData) {
                CompData = CONTAINING_RECORD( Next, COMPATIBILITY_DATA, ListEntry );
                Next = CompData->ListEntry.Flink;

                if( !( ProcessLine( CompData->Flags) ))
                    continue;


                if (CompData->RegKeyName) {
                    if (CompData->RegValDataSize == sizeof(DWORD)) {
                        wsprintf( Text, TEXT("HKLM,\"%s\",\"%s\",0x%08x,%d\r\n"),
                            CompData->RegKeyName, CompData->RegValName, FLG_ADDREG_TYPE_DWORD, *(LPDWORD)CompData->RegValData );
                        if (*(LPDWORD)CompData->RegValData == SERVICE_DISABLED) {
                            //
                            // also record this as a service to be disabled
                            // for additional service-specific processing during textmode setup
                            //
                            serviceName = _tcsrchr (CompData->RegKeyName, TEXT('\\'));
                            if (!serviceName) {
                                SetLastError (ERROR_INVALID_DATA);
                                __leave;
                            }
                            if (!InsertList (
                                    (PGENERIC_LIST*)&listServices,
                                    (PGENERIC_LIST)CreateStringCell (serviceName + 1)
                                    )) {
                                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                                __leave;
                            }
                        }
                    } else {
                        wsprintf( Text, TEXT("HKLM,\"%s\",\"%s\",0x%08x,\"%s\"\r\n"),
                            CompData->RegKeyName, CompData->RegValName, FLG_ADDREG_TYPE_SZ, (LPTSTR)CompData->RegValData );
                    }
#ifdef UNICODE
                    WideCharToMultiByte(
                        CP_ACP,
                        0,
                        Text,
                        -1,
                        Buffer,
                        sizeof(Buffer),
                        NULL,
                        NULL
                        );
                    if (!WriteFile( hFile, Buffer, strlen(Buffer), &Bytes, NULL )) {
                        __leave;
                    }
#else
                    if (!WriteFile( hFile, Text, strlen(Text), &Bytes, NULL )) {
                        __leave;
                    }
#endif
                }
            }
        }

        if (listServices) {
            sprintf (Buffer, "\r\n[%s]\r\n", WINNT_SERVICESTODISABLE_A);
            if (!WriteFile (hFile, (LPBYTE)Buffer, strlen(Buffer), &Bytes, NULL)) {
                __leave;
            }
            for (p = listServices; p; p = p->Next) {
#ifdef UNICODE
                wsprintfA (Buffer, "\"%ls\"\r\n", p->String);
#else
                wsprintfA (Buffer, "\"%s\"\r\n", p->String);
#endif
                if (!WriteFile (hFile, (LPBYTE)Buffer, strlen(Buffer), &Bytes, NULL)) {
                    __leave;
                }
            }
        }

#ifdef UNICODE
        //////////////////////////////////////////////////
        Next = CompatibilityData.Flink;
        if (Next) {
            while ((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData) {
                CompData = CONTAINING_RECORD( Next, COMPATIBILITY_DATA, ListEntry );
                Next = CompData->ListEntry.Flink;

                if( !( ProcessLine( CompData->Flags) ))
                    continue;

                if (CompData->ServiceName
                    && (CompData->Flags & COMPFLAG_DELETE_INF))
                {
                    TCHAR oemInfFileName[MAX_PATH];

                    if (pIsOEMService(CompData->ServiceName, oemInfFileName, ARRAYSIZE(oemInfFileName)))
                    {

                        //
                        //  Write the following in the answer file
                        //
                        //  note that 17 is the code for %windir%\INF
                        //
                        /*

                        [DelInf.serv]
                        Delfiles=DelInfFiles.serv

                        [DelInfFiles.serv]
                        "oem0.inf"

                        [DestinationDirs]
                        DelInfFiles.serv= 17
                        
                        */
                        if(_snprintf(Buffer, ARRAYSIZE(Buffer), 
                                     "\r\n[DelInf.%ls]\r\n"
                                     "Delfiles=DelInfFiles.%ls\r\n"
                                     "\r\n[DelInfFiles.%ls]\r\n", 
                                     CompData->ServiceName,
                                     CompData->ServiceName,
                                     CompData->ServiceName) < 0)
                        {
                            Buffer[ARRAYSIZE(Buffer) - 1] = '\0';
                            MYASSERT(FALSE);
                            continue;
                        }

                        if (!WriteFile (hFile, (LPBYTE)Buffer, strlen(Buffer), &Bytes, NULL)) {
                            __leave;
                        }                                                            


                        if(_snprintf(Buffer, ARRAYSIZE(Buffer), 
                                     "\"%ls\"\r\n"
                                     "\r\n[DestinationDirs]\r\n"
                                     "DelInfFiles.%ls= 17\r\n", 
                                     oemInfFileName,
                                     CompData->ServiceName) < 0)
                        {
                            Buffer[ARRAYSIZE(Buffer) - 1] = '\0';
                            MYASSERT(FALSE);
                            continue;
                        }

                        if (!WriteFile (hFile, (LPBYTE)Buffer, strlen(Buffer), &Bytes, NULL)) {
                            __leave;
                        }    
                    }
                }
            }
        }
        //////////////////////////////////////////////////
#endif

        if ( !WriteTextmodeReplaceData(hFile) )
            __leave;
        
        b = TRUE;
    }
    __finally {
        DWORD rc = GetLastError ();
        CloseHandle( hFile );
        if (listServices) {
            DeleteStringList (listServices);
        }
        SetLastError (rc);
    }

    return b;
}

BOOL
pIsValidService (
    IN      PCTSTR ServiceName
    )
{
    TCHAR KeyName[MAX_PATH];
    HKEY key;
    DWORD rc;
    BOOL b = FALSE;

    BuildPath (KeyName, TEXT("SYSTEM\\CurrentControlSet\\Services"), ServiceName);
    //
    // get an open key to the services database
    //
    rc = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                KeyName,
                0,
                KEY_READ,
                &key
                );

    if (rc == ERROR_SUCCESS) {
        b = TRUE;
        RegCloseKey (key);
    }

    return b;
}


BOOL
WriteTextmodeClobberData (
    IN LPCTSTR  FileName
    )
{
    HANDLE hFile;
    CHAR Buffer[50];
    DWORD LineCount, Bytes;
    TCHAR keyGuid[200];
    PCTSTR guidClass;
    PSTRINGLIST listServices = NULL, listLines = NULL, e;
    PCTSTR service;
    PTSTR upperFilters = NULL, upperFiltersNew = NULL, lowerFilters = NULL, lowerFiltersNew = NULL, line;
    HKEY key;
    INT i, j;
    PTSTR p, q;
    PSTR ansi = NULL;
    DWORD rc, size, type;
    BOOL modified, found;
    BOOL b = FALSE;

#define S_SECTION_CHECKCLASSFILTERS         TEXT("CheckClassFilters")

    MYASSERT (NtcompatInf);

    LineCount = InfGetSectionLineCount (NtcompatInf, S_SECTION_CHECKCLASSFILTERS);
    if (LineCount == 0 || LineCount == 0xffffffff) {
        return TRUE;
    }

    __try {
        //
        // first check if any data needs to be written
        //
        for (i = 0; i < (INT)LineCount; i++) {
            guidClass = InfGetFieldByIndex (NtcompatInf, S_SECTION_CHECKCLASSFILTERS, i, 0);
            if (guidClass == NULL) {
                MYASSERT (FALSE);
                continue;
            }
            BuildPath (keyGuid, TEXT("SYSTEM\\CurrentControlSet\\Control\\Class"), guidClass);
            rc = RegOpenKeyEx (HKEY_LOCAL_MACHINE, keyGuid, 0, KEY_READ, &key);
            if (rc != ERROR_SUCCESS) {
                continue;
            }
            upperFilters = NULL;
            rc = RegQueryValueEx (key, TEXT("UpperFilters"), NULL, &type, NULL, &size);
            if (rc == ERROR_SUCCESS && type == REG_MULTI_SZ) {
                MYASSERT (size >= 2);
                upperFilters = MALLOC (size);
                upperFiltersNew = MALLOC (size * 2);
                if (!upperFilters || !upperFiltersNew) {
                    SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                    __leave;
                }
                rc = RegQueryValueEx (key, TEXT("UpperFilters"), NULL, NULL, (LPBYTE)upperFilters, &size);
                if (rc != ERROR_SUCCESS) {
                    FREE (upperFilters);
                    upperFilters = NULL;
                    FREE (upperFiltersNew);
                    upperFiltersNew = NULL;
                }
            }
            lowerFilters = NULL;
            rc = RegQueryValueEx (key, TEXT("LowerFilters"), NULL, &type, NULL, &size);
            if (rc == ERROR_SUCCESS && type == REG_MULTI_SZ) {
                MYASSERT (size >= 2);
                lowerFilters = MALLOC (size);
                lowerFiltersNew = MALLOC (size * 2);
                if (!lowerFilters || !lowerFiltersNew) {
                    SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                    __leave;
                }
                rc = RegQueryValueEx (key, TEXT("LowerFilters"), NULL, NULL, (LPBYTE)lowerFilters, &size);
                if (rc != ERROR_SUCCESS) {
                    FREE (lowerFilters);
                    lowerFilters = NULL;
                    FREE (lowerFiltersNew);
                    lowerFiltersNew = NULL;
                }
            }

            RegCloseKey (key);

            if (!(upperFilters || lowerFilters)) {
                continue;
            }

            j = 1;
            do {
                service = InfGetFieldByIndex (NtcompatInf, S_SECTION_CHECKCLASSFILTERS, i, j++);
                if (service && *service) {
                    if (!InsertList (
                            (PGENERIC_LIST*)&listServices,
                            (PGENERIC_LIST)CreateStringCell (service)
                            )) {
                        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                        __leave;
                    }
                }
            } while (service);

            if (upperFilters) {
                modified = FALSE;
                *upperFiltersNew = 0;
                for (p = upperFilters, q = upperFiltersNew; *p; p = _tcschr (p, 0) + 1) {
                    if (listServices) {
                        found = FindStringCell (listServices, p, FALSE);
                    } else {
                        found = !pIsValidService (p);
                    }
                    if (found) {
                        DebugLog (
                            Winnt32LogInformation,
                            TEXT("NTCOMPAT: Removing \"%1\" from %2 of %3"),
                            0,
                            p,
                            TEXT("UpperFilters"),
                            guidClass
                            );
                        modified = TRUE;
                    } else {
                        q = q + wsprintf (q, TEXT(",\"%s\""), p);
                    }
                }
                if (modified) {
                    //
                    // tell textmode setup to overwrite this value
                    //
                    line = MALLOC (
                            sizeof (TCHAR) *
                            (1 +
                                sizeof("HKLM,\"%s\",\"%s\",0x%08x%s\r\n") - 1 +
                                lstrlen (keyGuid) +
                                sizeof ("UpperFilters") - 1 +
                                2 + 8 +
                                lstrlen (upperFiltersNew)
                            ));
                    if (!line) {
                        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                        __leave;
                    }
                    wsprintf (
                            line,
                            TEXT("HKLM,\"%s\",\"%s\",0x%08x%s\r\n"),
                            keyGuid,
                            TEXT("UpperFilters"),
                            FLG_ADDREG_TYPE_MULTI_SZ,
                            upperFiltersNew
                            );
                    if (!InsertList (
                            (PGENERIC_LIST*)&listLines,
                            (PGENERIC_LIST)CreateStringCell (line)
                            )) {
                        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                        __leave;
                    }
                    FREE (line);
                    line = NULL;
                }
            }

            if (lowerFilters) {
                modified = FALSE;
                *lowerFiltersNew = 0;
                for (p = lowerFilters, q = lowerFiltersNew; *p; p = _tcschr (p, 0) + 1) {
                    if (listServices) {
                        found = FindStringCell (listServices, p, FALSE);
                    } else {
                        found = !pIsValidService (p);
                    }
                    if (found) {
                        DebugLog (
                            Winnt32LogInformation,
                            TEXT("NTCOMPAT: Removing \"%1\" from %2 of %3"),
                            0,
                            p,
                            TEXT("LowerFilters"),
                            guidClass
                            );
                        modified = TRUE;
                    } else {
                        q = q + wsprintf (q, TEXT(",\"%s\""), p);
                    }
                }
                if (modified) {
                    //
                    // tell textmode setup to overwrite this value
                    //
                    line = MALLOC (
                            sizeof (TCHAR) *
                            (1 +
                                sizeof("HKLM,\"%s\",\"%s\",0x%08x%s\r\n") - 1 +
                                lstrlen (keyGuid) +
                                sizeof ("LowerFilters") - 1 +
                                2 + 8 +
                                lstrlen (lowerFiltersNew)
                            ));
                    if (!line) {
                        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                        __leave;
                    }
                    wsprintf (
                        line,
                        TEXT("HKLM,\"%s\",\"%s\",0x%08x%s\r\n"),
                        keyGuid,
                        TEXT("LowerFilters"),
                        FLG_ADDREG_TYPE_MULTI_SZ,
                        lowerFiltersNew
                        );
                    if (!InsertList (
                            (PGENERIC_LIST*)&listLines,
                            (PGENERIC_LIST)CreateStringCell (line)
                            )) {
                        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                        __leave;
                    }
                    FREE (line);
                    line = NULL;
                }
            }
            if (listServices) {
                DeleteStringList (listServices);
                listServices = NULL;
            }
            if (upperFilters) {
                FREE (upperFilters);
                upperFilters = NULL;
            }
            if (upperFiltersNew) {
                FREE (upperFiltersNew);
                upperFiltersNew = NULL;
            }
            if (lowerFilters) {
                FREE (lowerFilters);
                lowerFilters = NULL;
            }
            if (lowerFiltersNew) {
                FREE (lowerFiltersNew);
                lowerFiltersNew = NULL;
            }
        }

        b = TRUE;
    }
    __finally {
        rc = GetLastError ();
        if (listServices) {
            DeleteStringList (listServices);
        }
        if (upperFilters) {
            FREE (upperFilters);
        }
        if (upperFiltersNew) {
            FREE (upperFiltersNew);
        }
        if (lowerFilters) {
            FREE (lowerFilters);
        }
        if (lowerFiltersNew) {
            FREE (lowerFiltersNew);
        }
        if (!b) {
            if (listLines) {
                DeleteStringList (listLines);
                listLines = NULL;
            }
        }
        SetLastError (rc);
    }

    if (listLines) {

        b = FALSE;

        __try {

            hFile = CreateFile(
                        FileName,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
            if (hFile == INVALID_HANDLE_VALUE) {
                __leave;
            }

            SetFilePointer (hFile, 0, 0, FILE_END);

            sprintf (Buffer, "\r\n[%s]\r\n", WINNT_COMPATIBILITY_A);
            if (!WriteFile (hFile, (LPBYTE)Buffer, strlen(Buffer), &Bytes, NULL)) {
                __leave;
            }

            for (e = listLines; e; e = e->Next) {
#ifdef UNICODE
                ansi = MALLOC ((lstrlen (e->String) + 1) * 2);
                if (!ansi) {
                    SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                    __leave;
                }
                if (!WideCharToMultiByte (
                        CP_ACP,
                        0,
                        e->String,
                        -1,
                        ansi,
                        lstrlen (e->String) + 1,
                        NULL,
                        NULL
                        )) {
                    __leave;
                }
                if (!WriteFile (hFile, (LPBYTE)ansi, strlen(ansi), &Bytes, NULL)) {
                    __leave;
                }
                FREE (ansi);
                ansi = NULL;
#else
                if (!WriteFile (hFile, (LPBYTE)e->String, strlen(e->String), &Bytes, NULL)) {
                    __leave;
                }
#endif
            }

            b = TRUE;
        }
        __finally {
            DWORD rc = GetLastError ();
            if (hFile != INVALID_HANDLE_VALUE) {
                CloseHandle (hFile);
            }
            if (ansi) {
                FREE (ansi);
            }
            DeleteStringList (listLines);
            SetLastError (rc);
        }
    }

    return b;
}

BOOL
SaveCompatibilityData(
    IN  LPCTSTR FileName,
    IN  BOOL IncludeHiddenItems
    )
/*++

Routine Description:

    We call this function when the user has asked us to save the
    contents of the Compatibility page to a file.

Arguments:

    FileName - supplies filename of file to be used for our output.
    IncludeHiddenItems - if set, hidden items are also saved

Return Value:

    Boolean value indicating whether we succeeded.

--*/

{
#define WRITE_TEXT( s ) { strcpy( AnsiMessage, s ); \
                          WriteFile( hFile, AnsiMessage, lstrlenA(AnsiMessage), &Written, NULL ); }

    HANDLE  hFile;
    CHAR    AnsiMessage[5000];
    DWORD   Written;
    PLIST_ENTRY Next;
    PCOMPATIBILITY_DATA CompData;
    DWORD   i;
    TCHAR FullPath[MAX_PATH+8], *t;
    PVOID textDescription;
    BOOL bUnicode;
    BOOL bEmpty = TRUE;

    //
    // Open the file.  NOTE THAT WE DON'T APPEND.
    //
    hFile = CreateFile( FileName,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL );
    if(hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // Header...
    //

    WRITE_TEXT( "\r\n********************************************************************\r\n\r\n" );

    LoadStringA(hInst,IDS_COMPAT_REPORTHEADER,AnsiMessage,(sizeof(AnsiMessage)/sizeof(CHAR)));
    WRITE_TEXT( AnsiMessage );

    WRITE_TEXT( "\r\n\r\n********************************************************************\r\n\r\n" );

    //
    // Body...
    //
    Next = CompatibilityData.Flink;
    if (Next) {
        while ((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData) {
            CompData = CONTAINING_RECORD( Next, COMPATIBILITY_DATA, ListEntry );
            Next = CompData->ListEntry.Flink;


            if( CompData->Flags & COMPFLAG_HIDE )
                continue;

            if( !ProcessLine(CompData->Flags))
                continue;


            //
            // Convert the description to ANSI and write it.
            //
#ifdef UNICODE
            WideCharToMultiByte( CP_ACP,
                                 0,
                                 CompData->Description,
                                 -1,
                                 AnsiMessage,
                                 sizeof(AnsiMessage),
                                 NULL,
                                 NULL );
#else
            lstrcpyn(AnsiMessage,CompData->Description, 5000);
#endif
            strcat( AnsiMessage, "\r\n" );
            WriteFile( hFile, AnsiMessage, lstrlenA(AnsiMessage), &Written, NULL );

            //
            // Underline the description.
            //
            Written = strlen( AnsiMessage );
            AnsiMessage[0] = 0;
            for( i = 0; i < (Written-2); i++ ) {
                strcat( AnsiMessage, "=" );
            }
            strcat( AnsiMessage, "\r\n\r\n" );
            WriteFile( hFile, AnsiMessage, lstrlenA(AnsiMessage), &Written, NULL );

            //
            // Append the text file that this entry points to.
            //
            if (pGetText (CompData->TextName, &textDescription, &bUnicode)) {
                if (bUnicode) {
#ifdef UNICODE
                    WideCharToMultiByte( CP_ACP,
                                         0,
                                         textDescription,
                                         -1,
                                         AnsiMessage,
                                         sizeof(AnsiMessage),
                                         NULL,
                                         NULL );
#else
                    lstrcpyn(AnsiMessage, textDescription, 5000);
#endif
                    WriteFile (hFile, AnsiMessage, lstrlenA (AnsiMessage), &Written, NULL );

                } else {
                    WriteFile (hFile, textDescription, lstrlenA (textDescription), &Written, NULL );
                }

                FREE (textDescription);
            }

            //
            // Buffer space...
            //
            WRITE_TEXT( "\r\n\r\n\r\n" );

            bEmpty = FALSE;
        }
    }

    if (IncludeHiddenItems) {
        //
        // Hidden Items Header...
        //


        //
        // Body...
        //
        Next = CompatibilityData.Flink;
        if (Next) {
            BOOL bFirst = TRUE;
            while ((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData) {
                CompData = CONTAINING_RECORD( Next, COMPATIBILITY_DATA, ListEntry );
                Next = CompData->ListEntry.Flink;

                if (!(CompData->Flags & COMPFLAG_HIDE ))
                    continue;

                if( !ProcessLine(CompData->Flags))
                    continue;

                if (bFirst) {
                    WRITE_TEXT( "\r\n--------------------------------------------------------------------\r\n\r\n" );
                    bFirst = FALSE;
                }

                //
                // Convert the description to ANSI and write it.
                //
#ifdef UNICODE
                WideCharToMultiByte( CP_ACP,
                                     0,
                                     CompData->Description,
                                     -1,
                                     AnsiMessage,
                                     sizeof(AnsiMessage),
                                     NULL,
                                     NULL );
#else
                lstrcpy(AnsiMessage,CompData->Description);
#endif
                strcat( AnsiMessage, "\r\n" );
                WriteFile( hFile, AnsiMessage, lstrlenA(AnsiMessage), &Written, NULL );

                //
                // Underline the description.
                //
                Written = strlen( AnsiMessage );
                AnsiMessage[0] = 0;
                for( i = 0; i < (Written-2); i++ ) {
                    strcat( AnsiMessage, "=" );
                }
                strcat( AnsiMessage, "\r\n\r\n" );
                WriteFile( hFile, AnsiMessage, lstrlenA(AnsiMessage), &Written, NULL );

                //
                // Append the text file that this entry points to.
                //
                if( (CompData->TextName) && *(CompData->TextName) ) {
                    if (FindPathToWinnt32File (CompData->TextName, FullPath, MAX_PATH)) {
                        ConcatenateFile( hFile, FullPath );
                    } else {
                        DebugLog (Winnt32LogError,
                                  TEXT("Compatibility data file \"%1\" not found"),
                                  0,
                                  CompData->TextName
                                  );
                    }
                }

                //
                // Buffer space...
                //
                WRITE_TEXT( "\r\n\r\n\r\n" );

                bEmpty = FALSE;
            }
        }

    }

    if (bEmpty) {
        if (LoadStringA (hInst, IDS_COMPAT_NOPROBLEMS, AnsiMessage, (sizeof(AnsiMessage)))) {
            strcat (AnsiMessage, "\r\n");
            WriteFile (hFile, AnsiMessage, lstrlenA(AnsiMessage), &Written, NULL);
        }
    }

    CloseHandle( hFile );
    return TRUE;
}


VOID
WriteGUIModeInfOperations(
    IN LPCTSTR FileName
    )
{
    PLIST_ENTRY     Next_Link;
    PCOMPATIBILITY_DATA CompData;
    BOOLEAN FirstTime = TRUE;
    TCHAR Text[MAX_PATH*2], Temp[MAX_PATH];
    CHAR Buffer[MAX_PATH*2];
    DWORD Bytes;
    HANDLE hFile;
    PCTSTR p;


    hFile = CreateFile(
        FileName,
        GENERIC_WRITE,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if(hFile == INVALID_HANDLE_VALUE) {
        return;
    }

    SetFilePointer( hFile, 0, 0, FILE_END );


    Next_Link = CompatibilityData.Flink;

    if( Next_Link ){

        while ((ULONG_PTR)Next_Link != (ULONG_PTR)&CompatibilityData) {

            CompData = CONTAINING_RECORD( Next_Link, COMPATIBILITY_DATA, ListEntry );
            Next_Link = CompData->ListEntry.Flink;

            if( FirstTime ){
                sprintf( Buffer, "[%s]\r\n", WINNT_COMPATIBILITYINFSECTION_A );
                WriteFile( hFile, (LPBYTE)Buffer, strlen(Buffer), &Bytes, NULL );
                FirstTime = FALSE;
            }

            if(CompData->InfName && CompData->InfSection && *CompData->InfName && *CompData->InfSection){


                //Add the information for GUI setup.

#ifdef _X86_
                lstrcpy( Temp, LocalBootDirectory );
#else
                lstrcpy( Temp, LocalSourceWithPlatform );
#endif
                p = _tcsrchr (CompData->InfName, TEXT('\\'));
                if (p) {
                    p++;
                } else {
                    p = CompData->InfName;
                }
                ConcatenatePaths( Temp, p, MAX_PATH );

                wsprintf( Text, TEXT("%s,%s\r\n"), Temp, CompData->InfSection );

#ifdef UNICODE
                WideCharToMultiByte(
                    CP_ACP,
                    0,
                    Text,
                    -1,
                    Buffer,
                    sizeof(Buffer),
                    NULL,
                    NULL
                    );
                WriteFile( hFile, Buffer, strlen(Buffer), &Bytes, NULL );
#else
                WriteFile( hFile, Text, strlen(Text), &Bytes, NULL );
#endif


            }

#ifdef UNICODE
            if (CompData->ServiceName
                    && (CompData->Flags & COMPFLAG_DELETE_INF))
                {
                    TCHAR oemInfFileName[MAX_PATH];

                    if (pIsOEMService(CompData->ServiceName, oemInfFileName, ARRAYSIZE(oemInfFileName)))
                    {
                        if(_snprintf(Buffer, ARRAYSIZE(Buffer), 
                                     "%ls, DelInf.%ls\r\n",
                                     WINNT_GUI_FILE_W,                                     
                                     CompData->ServiceName) < 0)
                        {
                            Buffer[ARRAYSIZE(Buffer) - 1] = '\0';
                            MYASSERT(FALSE);
                            continue;
                        }

                        if (!WriteFile (hFile, (LPBYTE)Buffer, strlen(Buffer), &Bytes, NULL)) {
                            MYASSERT(FALSE);
                            continue;
                        }
                    }
                }
#endif

        }
    }

    CloseHandle( hFile );

    return;

}



BOOL
IsIE4Installed(
    VOID
    );

BOOL
IsIE3Installed(
    VOID
    );

BOOL
ServerWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
/*++

Routine Description:

    This routine notifies the user about the existance of the
    ever-so-official-sounding "Directory of Applications for Windows 2000".

    Note that we'll only run this page on server installs/upgrades.

Arguments:



--*/

TCHAR       FullPath[1024];
LPWSTR      Url;
DWORD       i;
BOOL        b;


    switch(msg) {




        case WM_INITDIALOG:
            //
            // Nothing to do here.
            //
            b = FALSE;
            break;




        case WMX_ACTIVATEPAGE:

            if (Winnt32Restarted ()) {
                return FALSE;
            }

            //
            // We're going to skip this page if we're installing
            // a PROFESSIONAL product.
            //
            if( !Server ) {
                return FALSE;
            }


            //
            // Don't do this if we're on OSR2 because it
            // will AV sometimes when we fire IE3 w/o an internet
            // connection.
            //
            if( !ISNT() ) {
                return FALSE;
            }

            //
            // If we don't have IE, skip this page.
            //
            b = (IsIE4Installed() || IsIE3Installed());
            SetForegroundWindow(hdlg);
            if( !b ) {
                return FALSE;
            }
            b = TRUE;

            //
            // If we're unattended, skip this page.
            //
            if( UnattendedOperation ) {
                return FALSE;
            }


            if(wParam) {
            }
            b = TRUE;
            // Stop the bill board and show the wizard again.
            SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);

            break;




        case WM_COMMAND:

            if ((LOWORD(wParam) == IDC_DIRECTORY) && (HIWORD(wParam) == BN_CLICKED)) {

                //
                // The user wants to go look at the directory.
                // Fire IE.
                //

                //
                // Depending on which flavor we're upgrading to, we need
                // to go to a different page.
                //

	        b = TRUE; // silence PREfix.  Not relevant, but presumably,
		          // if the directory is being opened, it must exist.
		          // So we return TRUE.
                if( Server ) {
                    if( !LoadString(hInst,IDS_SRV_APP_DIRECTORY,FullPath,sizeof(FullPath)/sizeof(TCHAR)))
                        break;
                } else {
                    if( !LoadString(hInst,IDS_PRO_APP_DIRECTORY,FullPath,sizeof(FullPath)/sizeof(TCHAR)))
                        break;
                }


                i = _tcslen( FullPath );
                Url = (LPWSTR)SysAllocStringLen( NULL, i );

                if(Url) {
#ifdef UNICODE
                    wcscpy( Url, FullPath );
#else
                    MultiByteToWideChar( CP_ACP, 0, FullPath, -1, Url, i );
#endif

                    if (!LaunchIE4Instance(Url)) {
                        if (!LaunchIE3Instance(Url)) {
                            //
                            // Sniff... the user doesn't have IE
                            // on his machine.  Quietly move on.
                            //
                        }
                    }

                    SysFreeString( Url );
                }
            }
            else
	        b = FALSE;
            break;

        case WMX_I_AM_VISIBLE:

            b = TRUE;
            break;


        default:
            b = FALSE;
            break;

    }

    return b;

}


BOOL
AnyBlockingCompatibilityItems (
    VOID
    )
{
    PLIST_ENTRY Next = CompatibilityData.Flink;

    if (Next) {
        while ((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData) {
            PCOMPATIBILITY_DATA CompData = CONTAINING_RECORD( Next, COMPATIBILITY_DATA, ListEntry );
            Next = CompData->ListEntry.Flink;
            if ((!(CompData->Flags & COMPFLAG_HIDE)) && ProcessLine( CompData->Flags)) {
                if( CompData->Flags & COMPFLAG_STOPINSTALL ) {
                    return TRUE;
                }
            }
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\cmdcons.c ===
#include "precomp.h"

#pragma hdrstop

// cmdcons boot dir
#ifndef CMDCONS_BOOT_DIR_A
#define CMDCONS_BOOT_DIR_A "CMDCONS"
#endif

#ifndef CMDCONS_BOOT_DIR_W
#define CMDCONS_BOOT_DIR_W L"CMDCONS"
#endif

#ifndef AUX_BOOT_SECTOR_NAME_A
#define AUX_BOOT_SECTOR_NAME_A    "BOOTSECT.DAT"
#endif

#ifndef AUX_BOOT_SECTOR_NAME_W
#define AUX_BOOT_SECTOR_NAME_W    L"BOOTSECT.DAT"
#endif


#define FLEXBOOT_SECTION1       "[flexboot]"
#define FLEXBOOT_SECTION2       "[boot loader]"
#define FLEXBOOT_SECTION3       "[multiboot]"
#define BOOTINI_OS_SECTION      "[operating systems]"
#define TIMEOUT                 "timeout"
#define DEFAULT                 "default"
#define CRLF                    "\r\n"
#define EQUALS                  "="

//
// NOTE : Use a single string which can take care of XP and Whistler branding
//
#define BOOTINI_RECOVERY_CONSOLE_STR	"Microsoft Windows Recovery Console"


#define BOOTINI_WINPE_DESCRIPTION   "\"Microsoft XP Preinstall Environment\" /cmdcons"
#define BOOTINI_WINPE_ENTRY         "c:\\cmdcons\\bootsect.dat"
#define BOOTINI_WINPE_TIMEOUT       "5"

// prototypes

#ifdef _X86_

VOID
PatchBootIni(
    VOID
    );

VOID
PatchBootSectDat(
    VOID
    );

#endif

#define BOOTFONTBIN_SIGNATURE 0x5465644d

typedef struct _st_BOOTFONT_LANG {
  ULONG Signature;
  ULONG LangId;
} BOOTFONT_LANG, * PBOOTFONT_LANG;

BOOL
LoadBootIniString(
  IN HINSTANCE ModuleHandle,
  IN DWORD MsgId,
  OUT PSTR Buffer,
  IN DWORD Size
  )
/*++

Routine Description:

  Loads the appropriate string needed for writing into boot.ini
  file. Does so, by looking for bootfont.bin file. If bootfont.bin
  file is present a simple LoadStringA(...) should give us the
  appropriate string (in most of the cases).

Arguments:

  ModuleHandle - The module handle where resources are present
  MsgId - String resource identifier
  Buffer - Buffer to copy the string into
  Size - Size of the buffer (in characters)

Return Value:

  TRUE, if localized string was loaded using LoadStringA(...)
  otherwise FALSE. FALSE indicates that english version of the string 
  resource needs to be written into boot.ini

--*/  
{
    BOOL    Result = FALSE;
    static BOOL BootFontPresent = FALSE;
    static BOOL Initialized = FALSE;

    if (!Initialized) {
        TCHAR   BootFontFile[MAX_PATH];
        HANDLE  BootFontHandle;

        Initialized = TRUE;

        //
        // Open the bootfont.bin file
        //
        wsprintf(BootFontFile, TEXT("%s"), NativeSourcePaths[0]);  
        
        ConcatenatePaths(BootFontFile, 
            TEXT("bootfont.bin"), 
            sizeof(BootFontFile)/sizeof(TCHAR));

        BootFontHandle = CreateFile(BootFontFile, 
                            GENERIC_READ, 
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            0, 
                            OPEN_EXISTING, 
                            FILE_ATTRIBUTE_NORMAL, 
                            0);

        if (BootFontHandle != INVALID_HANDLE_VALUE) {
            BOOTFONT_LANG  BootFontHdr;
            DWORD BytesRead = 0;

            //
            // Verify the bootfont.bin file header
            //
            ZeroMemory(&BootFontHdr, sizeof(BOOTFONT_LANG));

            if (ReadFile(BootFontHandle, &BootFontHdr, sizeof(BOOTFONT_LANG),
                  &BytesRead, NULL)) {
                if ((BytesRead == sizeof(BOOTFONT_LANG)) && 
                    (BootFontHdr.Signature == BOOTFONTBIN_SIGNATURE)) {
                    BootFontPresent = TRUE;
                }
            }

            CloseHandle(BootFontHandle);
        }
    }

    //
    // Load the message if bootfont is present
    //
    if (BootFontPresent) {
        Result = (LoadStringA(ModuleHandle, MsgId, Buffer, Size) != 0);
    }
              
    return Result;
}

DWORD
MapFileForReadWrite(
    IN  LPCTSTR  FileName,
    OUT PDWORD   FileSize,
    OUT PHANDLE  FileHandle,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    );

//
// routine that builds the cmdcons installation
//

VOID
DoBuildCmdcons(
    VOID
    )
{
    DWORD       rc;
    TCHAR       buffer[MAX_PATH];
    TCHAR       buffer2[MAX_PATH];
    BOOLEAN     bSilentInstall = (BOOLEAN) UnattendedOperation;

    //
    //	NT5 ntdetect.com is not compatible NT4's on NEC98 system.
    //  We need check setup OS Version if Command console is
    //  setuped on NEC98.
    //

#ifdef _X86_ //NEC98
    if (IsNEC98() && (!ISNT() || OsVersion.dwMajorVersion < 5)){
        return;
    }
#endif

    //
    // Don't popup the confirmation dialog box if install
    // is running in silent mode
    //
    if (!bSilentInstall) {
        rc = MessageBoxFromMessage(
                NULL,
                MSG_CMDCONS_ASK,
                FALSE,
                AppTitleStringId,
                MB_YESNO | MB_ICONWARNING
                );

        if( rc == IDNO ) {
            return;
        }
    }

    //
    // we don't want a local source
    //

    UserSpecifiedLocalSourceDrive = FALSE;

    //
    // use unattended to force winnt32 to build a ~bt
    //

    UnattendedOperation = TRUE;
    if( UnattendedScriptFile ) {
        FREE( UnattendedScriptFile );
        UnattendedScriptFile = NULL;
    }

    //
    // make sure we're not upgrading
    //

    Upgrade = FALSE;

    //
    // We don't want a local source.
    //

    MakeLocalSource = FALSE;

    //
    // do it.
    //

    Wizard();

    if(GlobalResult) {
        //
        // delete the current CMDCONS directory
        //
        BuildSystemPartitionPathToFile (TEXT("cmdcons"), buffer, MAX_PATH);
        MyDelnode( buffer );

        //
        // delete the current CMLDR
        //

        BuildSystemPartitionPathToFile (TEXT("cmldr"), buffer, MAX_PATH);
        SetFileAttributes( buffer, FILE_ATTRIBUTE_NORMAL );
        DeleteFile( buffer );

#ifdef _X86_

        //
        // delete the new boot.ini
        //

        BuildSystemPartitionPathToFile (TEXT("boot.ini"), buffer, MAX_PATH);
        SetFileAttributes( buffer, FILE_ATTRIBUTE_NORMAL );
        DeleteFile( buffer );

        //
        // restore the old boot.ini and patch it
        //

        BuildSystemPartitionPathToFile (TEXT("boot.bak"), buffer2, MAX_PATH);

        CopyFile( buffer2, buffer, FALSE );

        PatchBootIni();

#endif

        //
        // rename $LDR$ to CMLDR
        //

        BuildSystemPartitionPathToFile (TEXT("$LDR$"), buffer, MAX_PATH);
        BuildSystemPartitionPathToFile (TEXT("cmldr"), buffer2, MAX_PATH);

        MoveFile( buffer, buffer2 );

        //
        // flag CMLDR +r +s +h
        //

        SetFileAttributes( buffer2,
                           FILE_ATTRIBUTE_HIDDEN |
                           FILE_ATTRIBUTE_SYSTEM |
                           FILE_ATTRIBUTE_READONLY );

        //
        // rename \$WIN_NT$.~BT to \CMDCONS
        //

        BuildSystemPartitionPathToFile (TEXT("$WIN_NT$.~BT"), buffer, MAX_PATH);
        BuildSystemPartitionPathToFile (TEXT("cmdcons"), buffer2, MAX_PATH);

        MoveFile( buffer, buffer2 );

#ifdef _X86_

        //
        // fix \cmdcons\bootsect.dat
        //

        PatchBootSectDat();

#endif

        // flag \CMDCONS +r +s +h

        SetFileAttributes( buffer2,
                           FILE_ATTRIBUTE_HIDDEN |
                           FILE_ATTRIBUTE_SYSTEM |
                           FILE_ATTRIBUTE_READONLY );

        //
        // delete TXTSETUP.SIF
        //

        BuildSystemPartitionPathToFile (TEXT("TXTSETUP.SIF"), buffer, MAX_PATH);
        SetFileAttributes( buffer, FILE_ATTRIBUTE_NORMAL );
        DeleteFile( buffer );
    }

    //
    // popup completion status only if not a silent install
    //
    if (!bSilentInstall) {
        if(GlobalResult) {
            //
            // popup success dialog box
            //
            rc = MessageBoxFromMessage(
                NULL,
                MSG_CMDCONS_DONE,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONINFORMATION
                );
        } else {
            //
            // popup failure dialog box
            //
            rc = MessageBoxFromMessage(
                NULL,
                MSG_CMDCONS_DID_NOT_FINISH,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR
                );
        }
    }

    //
    // make sure the machine does not reboot automatically.
    //

    AutomaticallyShutDown = FALSE;

    return;
}

BOOL
__inline
WriteToBootIni(
    IN HANDLE Handle,
    IN PCHAR  Line
    )
{
    DWORD bw,l;

    l = lstrlenA(Line);

    return(WriteFile(Handle,Line,l,&bw,NULL) && (bw == l));
}


#ifdef _X86_

DWORD
InitBootIni(
    IN PCTSTR BootIniName,
    IN PCSTR DefaultEntry,
    IN PCSTR DefaultEntryDescription,
    IN PCSTR Timeout
    )
/*++

Routine Description:

    Initializes a boot.ini file for e.g. while installing
    WinPE on to harddisk a dummy boot.ini is created for WinPE.

Arguments:

    BootIniName - Fully qualified boot.ini file name

    DefaultEntry - The default entry string that points
        to an installation.

    DefaultEntryDescription - The description for the default
        boot entry.

    Timeout - The timeout value (in secs)        

Return Value:

    Appropriate Win32 error code.

--*/
{
    DWORD ErrorCode = ERROR_INVALID_PARAMETER;

    if (BootIniName && DefaultEntry && DefaultEntryDescription) {
        HANDLE BootIniHandle = CreateFile(BootIniName,
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    CREATE_ALWAYS,
                                    0,
                                    NULL);

        if (BootIniHandle != INVALID_HANDLE_VALUE) {
            //
            // write the [boot loader section]
            //
            BOOL Result = WriteToBootIni(BootIniHandle,
                                    FLEXBOOT_SECTION2);

            Result = Result && WriteToBootIni(BootIniHandle,
                                    CRLF);

            //
            // write the timeout value
            //
            if (Timeout) {
                Result = Result && WriteToBootIni(BootIniHandle,
                                        TIMEOUT);

                Result = Result && WriteToBootIni(BootIniHandle,
                                        EQUALS);

                Result = Result && WriteToBootIni(BootIniHandle,
                                        (PSTR)Timeout);
                                                    
                Result = Result && WriteToBootIni(BootIniHandle,
                                        CRLF);
            }                                        


            //
            // write the default installation
            //
            Result = Result && WriteToBootIni(BootIniHandle,
                                    DEFAULT);

            Result = Result && WriteToBootIni(BootIniHandle,
                                    EQUALS);

            Result = Result && WriteToBootIni(BootIniHandle,
                                    (PSTR)DefaultEntry);

            Result = Result && WriteToBootIni(BootIniHandle,
                                    CRLF);
            
            //
            // write the [operating systems] section
            //
            Result = Result && WriteToBootIni(BootIniHandle,
                                    BOOTINI_OS_SECTION);

            Result = Result && WriteToBootIni(BootIniHandle,
                                    CRLF);

            //
            // write the cmdcons entry
            //
            Result = Result && WriteToBootIni(BootIniHandle,
                                    (PSTR)DefaultEntry);

            Result = Result && WriteToBootIni(BootIniHandle,
                                    EQUALS);

            Result = Result && WriteToBootIni(BootIniHandle,
                                    (PSTR)DefaultEntryDescription);
            
            Result = Result && WriteToBootIni(BootIniHandle,
                                    CRLF);

            if (!Result) {
                ErrorCode = GetLastError();
            } else {
                ErrorCode = NO_ERROR;
            }                

            CloseHandle(BootIniHandle);
        } else {
            ErrorCode = GetLastError();
        }            
    }

    return ErrorCode;
}

VOID
PatchBootIni(
    VOID
    )
{
    CHAR c;
    CHAR Text[256];

    TCHAR BootIniName[MAX_PATH];
    TCHAR BootIniBackup[MAX_PATH];

    UCHAR temp;
    UCHAR BootSectorImageSpec[29];

    PUCHAR Buffer;
    PUCHAR pszBLoader = NULL;
    PUCHAR p,next;
    PUCHAR DefSwitches;
    PUCHAR DefSwEnd;

    HANDLE h;

    DWORD BootIniSize;
    DWORD BytesRead;
    DWORD OldAttributes;
    DWORD d;
    BOOL b;
    BOOL InOsSection;
    CHAR HeadlessRedirectSwitches[160] = {0};

    //
    // Determine the size of boot.ini, allocate a buffer,
    // and read it in. If it isn't there then it will be created.
    //
    BuildSystemPartitionPathToFile (TEXT("BOOT.INI"), BootIniName, MAX_PATH);
    BuildSystemPartitionPathToFile (TEXT("BOOT.BAK"), BootIniBackup, MAX_PATH);

    h = CreateFile(BootIniName,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,0,NULL);
    
    if(h == INVALID_HANDLE_VALUE) {
        //
        // If the file doesn't exist -- create one in WinPE
        //
        if (IsWinPEMode()) {
            CHAR    Buffer[MAX_PATH] = {0};
            PSTR    WinPEDescription = Buffer;

            if (!LoadBootIniString(hInst, 
                    IDS_WINPE_INSTALLATION,
                    Buffer,
                    sizeof(Buffer))) {
                WinPEDescription = BOOTINI_WINPE_DESCRIPTION;
            }                                    
            
            if (InitBootIni(BootIniName,
                    BOOTINI_WINPE_ENTRY,
                    WinPEDescription,
                    BOOTINI_WINPE_TIMEOUT) == NO_ERROR) {
                return;                    
            }
        }            
        
        //
        // Yikes. Setup should have already created one of these for us.
        //
        d = GetLastError();
        b = FALSE;
        goto c0;

    } else {
        //
        // Figure out how big the file is.
        // Allocate 3 extra characters for final NUL we'll add to make
        // parsing easier, and a cr/lf in case the last line is incomplete.
        //
        BootIniSize = GetFileSize(h,NULL);
        if(BootIniSize == (DWORD)(-1)) {
            d = GetLastError();
            CloseHandle(h);
            b = FALSE;
            goto c0;
        }

        OldAttributes = GetFileAttributes( BootIniName );

        Buffer = MALLOC(BootIniSize+3);
        if(!Buffer) {
            CloseHandle(h);
            b = FALSE;
            d = ERROR_NOT_ENOUGH_MEMORY;
            goto c0;
        }

        b = ReadFile(h,Buffer,BootIniSize,&BytesRead,NULL);
        d = GetLastError();
        CloseHandle(h);
        if(!b) {
            goto c1;
        }
    }

    //
    // Make sure the last line is properly terminated, and add a terminating nul
    // to make parsing a little easier.
    //
    if(BootIniSize && (Buffer[BootIniSize-1] != '\n') && (Buffer[BootIniSize-1] != '\r')) {
        Buffer[BootIniSize++] = '\r';
        Buffer[BootIniSize++] = '\n';
    }
    Buffer[BootIniSize] = 0;

    //
    // Truncate at control-z if any.
    //
    if(p = strchr(Buffer,26)) {
        if((p > Buffer) && (*(p - 1) != '\n') && (*(p - 1) != '\r')) {
            *(p++) = '\r';
            *(p++) = '\n';
        }
        *p = 0;
        BootIniSize = p - Buffer;
    }

    //
    // Make sure we can write boot.ini.
    //

    SetFileAttributes(BootIniName,FILE_ATTRIBUTE_NORMAL);
    h = CreateFile(
            BootIniName,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        d = GetLastError();
        b = FALSE;
        goto c2;
    }
    //
    // Regardless of the actual drive letter of the system partition,
    // the spec in boot.ini is always C:\...
    //
    wsprintfA(BootSectorImageSpec,"C:\\%hs\\%hs",CMDCONS_BOOT_DIR_A,AUX_BOOT_SECTOR_NAME_A);

    // write out the first section unchanged

    for(p=Buffer; *p && (p < Buffer+BootIniSize - (sizeof("[operating systems]")-1)); p++) {
        if(!_strnicmp(p,"[operating systems]",sizeof("[operating systems]")-1)) {
            break;
        }
    }

    pszBLoader = MALLOC( (UINT_PTR)p - (UINT_PTR)Buffer + 1 );
    pszBLoader[(UINT_PTR)p - (UINT_PTR)Buffer ] = 0;

    if( pszBLoader ) {
        strncpy( pszBLoader, Buffer, (UINT_PTR)p - (UINT_PTR)Buffer );
        if(!WriteToBootIni(h,pszBLoader)) {
            d = GetLastError();
            b = FALSE;
            goto c3;
        }
        FREE( pszBLoader );
    } else {
        d = GetLastError();
        b = FALSE;
        goto c3;
    }




    //
    // Do headless stuff.  We want to set the "redirect=comX"
    // entry in boot.ini.  Make sure the user really asked
    // us to add this in though.
    //
    if( HeadlessSelection[0] != TEXT('\0') ) {

        CHAR    tmp[80];
        BOOLEAN PreviousRedirectLine = FALSE;


        //
        // They told winnt32.exe some specific headless settings.
        // Use these.
        //


        //
        // Convert the user's request into ASCII.
        //
#ifdef UNICODE
        WideCharToMultiByte( CP_ACP,
                             0,
                             HeadlessSelection,
                             -1,
                             tmp,
                             sizeof(tmp),
                             NULL,
                             NULL );

        wsprintfA( HeadlessRedirectSwitches,
                   "redirect=%s\r\n",
                   tmp );
#else
        wsprintfA( HeadlessRedirectSwitches,
                   "redirect=%s\r\n",
                   HeadlessSelection );
#endif

    } else {

        //
        // They didn't give us any settings, so see if we can pick
        // something up from boot.ini
        //
        for( p = Buffer; *p && (p < Buffer+BootIniSize - (sizeof("redirect=")-1)); p++ ) {

            if(!_strnicmp(p,"[Operat",sizeof("[Operat")-1)) {

                //
                // We're past the [Boot Loader] section.  Stop looking.
                //
                break;
            }

            if(!_strnicmp(p,"redirect=",sizeof("redirect=")-1)) {

                PUCHAR      q = p;
                UCHAR       temp;

                while (*p) {
                    p++;
                }
                temp = *p;
                *p = '\0';
                strcpy(HeadlessRedirectSwitches, q);
                *p = temp;
                break;
            }
        }
    }


    if( HeadlessRedirectSwitches[0] != '\0' ) {

        //
        // We got some 'redirect' setting, either from a command-line parameter
        // or from boot.ini.  Write it out, and go dig up a baudrate setting.
        //
        if(!WriteToBootIni(h,HeadlessRedirectSwitches)) {
            d = GetLastError();
            b = FALSE;
            goto c3;
        }


        //
        // Now do the "redirectbaudrate=..." line.
        //
        HeadlessRedirectSwitches[0] = '\0';
        if( HeadlessBaudRate != 0 ) {


            //
            // Convert the user's request into ASCII.
            //
            wsprintfA( HeadlessRedirectSwitches,
                       "redirectbaudrate=%d\r\n",
                       HeadlessBaudRate );
        } else {

            //
            // They didn't give us any settings, so see if we can pick
            // something up from boot.ini
            //
            for( p = Buffer; *p && (p < Buffer+BootIniSize - (sizeof("redirectbaudrate=")-1)); p++ ) {

                if(!_strnicmp(p,"[Operat",sizeof("[Operat")-1)) {

                    //
                    // We're past the [Boot Loader] section.  Stop looking.
                    //
                    break;
                }

                if(!_strnicmp(p,"redirectbaudrate=",sizeof("redirectbaudrate=")-1)) {

                    PUCHAR      q = p;
                    UCHAR       temp;

                    while (*p) {
                        p++;
                    }
                    temp = *p;
                    *p = '\0';
                    strcat(HeadlessRedirectSwitches, q);
                    *p = temp;
                }
            }
        }


        if( HeadlessRedirectSwitches[0] != '\0' ) {
            if(!WriteToBootIni(h,HeadlessRedirectSwitches)) {
                d = GetLastError();
                b = FALSE;
                goto c3;
            }

        }
        
    }





    //
    // Now write out the [Operating Systems] section name.
    //
    if(!WriteToBootIni(h,"[operating systems]\r\n")) {
        d = GetLastError();
        b = FALSE;
        goto c3;
    }
    



    //
    // Process each line in boot.ini.
    // If it's the setup boot sector line, we'll throw it out.
    // For comparison with lines in boot.ini, the drive letter
    // is always C even if the system partition is not actually C:.
    //

    InOsSection = FALSE;
    b = TRUE;

    for(p=Buffer; *p && b; p=next) {

        while((*p==' ') || (*p=='\t')) {
            p++;
        }

        if(*p) {

            //
            // Find first byte of next line.
            //
            for(next=p; *next && (*next++ != '\n'); );

            //
            // Look for start of [operating systems] section
            // or at each line in that section.
            //
            if(InOsSection) {

                switch(*p) {

                case '[':   // end of section.
                    *p=0;   // force break out of loop
                    break;

                case 'C':
                case 'c':   // potential start of c:\ line

                    //
                    // See if it's a line for setup boot.
                    // If so, ignore it.
                    //
                    if(!_strnicmp(p,BootSectorImageSpec,lstrlenA(BootSectorImageSpec))) {
                        break;
                    }

                    //
                    // Not a special line, FALL THROUGH to write it out as-is.
                    //

                default:

                    //
                    // Random line. write it out.
                    //

                    c = *next;
                    *next = 0;
                    b = WriteToBootIni(h,p);
                    *next = c;

                    break;

                }

            } else {
                if(!_strnicmp(p,"[operating systems]",19)) {
                    InOsSection = TRUE;
                }
            }
        }
    }

    //
    // Write out our line.
    //

    if(b) {
        //
        // NOTE : This is intentional. If we have a boot font then we convert the unicode 
        // string we got from message resoure to DBCS using LoadStringA(...) else we just 
        // write English string out in boot.ini for recovery console.
        //
        if (!LoadBootIniString(hInst, IDS_RECOVERY_CONSOLE, Text, sizeof(Text))) {
            strcpy(Text, BOOTINI_RECOVERY_CONSOLE_STR);
        }			
			        
        if((b=WriteToBootIni(h,BootSectorImageSpec))
        && (b=WriteToBootIni(h,"=\"")) 
        && (b=WriteToBootIni(h,Text))        
        && (b=WriteToBootIni(h,"\" /cmdcons" ))) {

            b = WriteToBootIni(h,"\r\n");
        }
    }

#if 0
    //
    // Write out previous OS line if directed to do so.
    //
    if(b && SetPreviousOs) {
        if(b = WriteToBootIni(h,"C:\\=\"")) {
            LoadStringA(hInst,IDS_MICROSOFT_WINDOWS,Text,sizeof(Text));
            if(b = WriteToBootIni(h,Text)) {
                b = WriteToBootIni(h,"\"\r\n");
            }
        }
    }
#endif
    if(!b) {
        d = GetLastError();
        goto c3;
    }

    d = NO_ERROR;

c3:
    CloseHandle(h);
c2:
    //
    // Restore boot.ini.
    //
    if(!b && (OldAttributes != (DWORD)(-1))) {
        SetFileAttributes(BootIniName,FILE_ATTRIBUTE_NORMAL);
        CopyFile(BootIniBackup,BootIniName,FALSE);
        SetFileAttributes(BootIniName,OldAttributes);
        SetFileAttributes(BootIniBackup,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(BootIniBackup);
    }
c1:
    FREE(Buffer);
c0:
    if(!b) {
        MessageBoxFromMessageAndSystemError(
            NULL,
            MSG_BOOT_FILE_ERROR,
            d,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            BootIniName
            );
        GlobalResult = FALSE;
    }

}

VOID
PatchBootSectDat(
    VOID
    )
{
    TCHAR buffer[MAX_PATH];
    DWORD rc;
    DWORD fileSize;
    DWORD curpos;
    HANDLE fileHandle;
    HANDLE mappingHandle;
    LPBYTE bootSectDat;
    TCHAR DrivePath[MAX_PATH];
    DWORD DontCare;
    TCHAR NameBuffer[100];
    BOOL Ntfs = FALSE;


    //
    //  find out what the file system is
    //

    BuildSystemPartitionPathToFile (TEXT(""), DrivePath, MAX_PATH);
    //BUGBUG
    rc = GetVolumeInformation(
            DrivePath,
            NULL,
            0,
            NULL,
            &DontCare,
            &DontCare,
            NameBuffer,
            sizeof(NameBuffer)/sizeof(TCHAR)
            );
    if (rc == 0) {
        return;
    }

    if (!lstrcmpi(NameBuffer,TEXT("NTFS"))) {
        Ntfs = TRUE;
    }

    //
    // form the path
    //

    BuildSystemPartitionPathToFile (TEXT("CMDCONS\\BOOTSECT.DAT"), buffer, MAX_PATH);

    //
    // map the file into RAM
    //

    rc = MapFileForReadWrite( buffer,
                              &fileSize,
                              &fileHandle,
                              &mappingHandle,
                              (PVOID*)&bootSectDat
                            );

    if( rc == NO_ERROR ) {
        __try {
            for (curpos = 0; curpos < fileSize; curpos++) {
                if (Ntfs) {
                    if( bootSectDat[curpos]   == '$' &&
                        bootSectDat[curpos+2] == 'L' &&
                        bootSectDat[curpos+4] == 'D' &&
                        bootSectDat[curpos+6] == 'R' &&
                        bootSectDat[curpos+8] == '$' ) {

                        // patch CMLDR
                        bootSectDat[curpos]   = 'C';
                        bootSectDat[curpos+2] = 'M';
                        bootSectDat[curpos+4] = 'L';
                        bootSectDat[curpos+6] = 'D';
                        bootSectDat[curpos+8] = 'R';

                        break;
                    }
                } else {
                    if( bootSectDat[curpos]   == '$' &&
                        bootSectDat[curpos+1] == 'L' &&
                        bootSectDat[curpos+2] == 'D' &&
                        bootSectDat[curpos+3] == 'R' &&
                        bootSectDat[curpos+4] == '$' ) {

                        // patch CMLDR
                        bootSectDat[curpos]   = 'C';
                        bootSectDat[curpos+1] = 'M';
                        bootSectDat[curpos+2] = 'L';
                        bootSectDat[curpos+3] = 'D';
                        bootSectDat[curpos+4] = 'R';

                        break;
                    }
                }
            }

        } except ( EXCEPTION_EXECUTE_HANDLER ) {

        }
    }

    FlushViewOfFile( (PVOID)bootSectDat, 0 );
    UnmapFile( mappingHandle, (PVOID)bootSectDat );
    CloseHandle( fileHandle );

}

#endif

DWORD
MapFileForReadWrite(
    IN  LPCTSTR  FileName,
    OUT PDWORD   FileSize,
    OUT PHANDLE  FileHandle,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    )

/*++

Routine Description:

    Open and map an entire file for read access. The file must
    not be 0-length or the routine fails.

Arguments:

    FileName - supplies pathname to file to be mapped.

    FileSize - receives the size in bytes of the file.

    FileHandle - receives the win32 file handle for the open file.
        The file will be opened for generic read access.

    MappingHandle - receives the win32 handle for the file mapping
        object.  This object will be for read access.  This value is
        undefined if the file being opened is 0 length.

    BaseAddress - receives the address where the file is mapped.  This
        value is undefined if the file being opened is 0 length.

Return Value:

    NO_ERROR if the file was opened and mapped successfully.
        The caller must unmap the file with UnmapFile when
        access to the file is no longer desired.

    Win32 error code if the file was not successfully mapped.

--*/

{
    DWORD rc;

    //
    // Open the file -- fail if it does not exist.
    //
    *FileHandle = CreateFile(
                    FileName,
                    GENERIC_READ | GENERIC_WRITE,
                    0,      // exclusive access
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

    if(*FileHandle == INVALID_HANDLE_VALUE) {

        rc = GetLastError();

    } else {
        //
        // Get the size of the file.
        //
        *FileSize = GetFileSize(*FileHandle,NULL);
        if(*FileSize == (DWORD)(-1)) {
            rc = GetLastError();
        } else {
            //
            // Create file mapping for the whole file.
            //
            *MappingHandle = CreateFileMapping(
                                *FileHandle,
                                NULL,
                                PAGE_READWRITE,
                                0,
                                *FileSize,
                                NULL
                                );

            if(*MappingHandle) {

                //
                // Map the whole file.
                //
                *BaseAddress = MapViewOfFile(
                                    *MappingHandle,
                                    FILE_MAP_ALL_ACCESS,
                                    0,
                                    0,
                                    *FileSize
                                    );

                if(*BaseAddress) {
                    return(NO_ERROR);
                }

                rc = GetLastError();
                CloseHandle(*MappingHandle);
            } else {
                rc = GetLastError();
            }
        }

        CloseHandle(*FileHandle);
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\cleanup.c ===
#include "precomp.h"
#pragma hdrstop

VOID CleanUpHardDriveTags (VOID);


DWORD
StartCleanup(
    IN PVOID ThreadParameter
    )
    //
    // BUGBUG - this routine NEVER gets executed in a /checkupgradeonly case
    //
{
    TCHAR Buffer[MAX_PATH];
    HKEY setupKey;
    DWORD error;

    //
    // Make sure the copy threads are really gone so we're not
    // trying to clean up files at the same time as files are
    // getting copied.
    //
    CancelledMakeSureCopyThreadsAreDead();

    error = RegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup"),
                0,
                KEY_ALL_ACCESS,
                &setupKey
                );

    if (error == ERROR_SUCCESS) {

        //
        // If g_DeleteRunOnceFlag is set and the user did not cancel setup, then
        // remove the Winnt32RunOnce flag from the Setup key.
        //

        if (g_DeleteRunOnceFlag && !Cancelled) {
            RegDeleteValue (setupKey, S_WINNT32_WARNING);
            g_DeleteRunOnceFlag = FALSE;
        }

#ifdef _X86_
        //
        // If canceled, remove last report time, so that the report
        // will be displayed on the next run of setup.
        //

        if (!ISNT()) {
            if (!CheckUpgradeOnly) {
                RegDeleteValue (setupKey, TEXT("LastReportTime"));
            }
        }

#endif

        RegCloseKey (setupKey);
    }

    //
    // Let upgrade code do its cleanup.
    //
    if(UpgradeSupport.CleanupRoutine) {
        UpgradeSupport.CleanupRoutine();
    }

    if (g_DynUpdtStatus->ForceRemoveWorkingDir || !g_DynUpdtStatus->PreserveWorkingDir) {
        if (g_DynUpdtStatus->WorkingDir[0] && !g_DynUpdtStatus->RestartWinnt32) {
            MyDelnode (g_DynUpdtStatus->WorkingDir);
        }

        GetCurrentWinnt32RegKey (Buffer, MAX_PATH);
        ConcatenatePaths (Buffer, WINNT_U_DYNAMICUPDATESHARE, MAX_PATH);
        RegDeleteKey (HKEY_LOCAL_MACHINE, Buffer);
    }

#if 0
    //
    // Remove registry entries
    //
    if (GetCurrentWinnt32RegKey (Buffer, MAX_PATH)) {
        RegDeleteKey (HKEY_LOCAL_MACHINE, Buffer);
    }
#endif

    //
    // Always do this, since the system might not boot otherwise.
    //
    ForceBootFilesUncompressed(ThreadParameter,FALSE);

    //
    // The first thing to do is to wipe out the local source drive.
    //
    if(LocalSourceDirectory[0]) {
        MyDelnode(LocalSourceDirectory);
    }

    if (!IsArc()) {
#ifdef _X86_
        //
        // Blow away the local boot dir.
        //
        if(LocalBootDirectory[0]) {
            MyDelnode(LocalBootDirectory);
        }
        BuildSystemPartitionPathToFile (AUX_BS_NAME, Buffer, MAX_PATH);
        SetFileAttributes(Buffer,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(Buffer);

        BuildSystemPartitionPathToFile(TEXTMODE_INF, Buffer, MAX_PATH);
        SetFileAttributes(Buffer,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(Buffer);

        RestoreBootSector();
        RestoreBootIni();

        //
        // restore backed up files and clean up backup directory
        //
        if(IsNEC98() && LocalBackupDirectory[0]) {
            SaveRestoreBootFiles_NEC98(NEC98RESTOREBOOTFILES);
            MyDelnode(LocalBackupDirectory);
        }

        //
        // Clean up any ~_~ files from drvlettr migration.
        //
        if (!ISNT()) {
            CleanUpHardDriveTags ();
        }
#endif // _X86_
    } else {  // We're on an ARC machine.
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
        //
        // Blow away setupldr off the root of the system partition.
        //
        BuildSystemPartitionPathToFile (SETUPLDR_FILENAME, Buffer, MAX_PATH);
        SetFileAttributes(Buffer,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(Buffer);

        RestoreNvRam();
#endif // UNICODE
    } // if (!IsArc())

    PostMessage(ThreadParameter,WMX_I_AM_DONE,0,0);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\copylist.c ===
#include "precomp.h"
#include "SetupSxs.h"
#include "sputils.h"
#pragma hdrstop
//
// Structure used to contain data about each directory
// containing files we will copy from the source(s).
//
typedef struct _DIR {

    struct _DIR *Next;
#ifndef SLOWER_WAY
    struct _DIR *Prev;
#endif

    //
    // Symbol in main inf [Directories] section.
    // May be NULL.
    //
    LPCTSTR InfSymbol;

    //
    // Flags.
    //
    UINT Flags;

    //
    // In some cases files come from one directory on the source
    // but go to a different directory on the target.
    //
    LPCTSTR SourceName;
    LPCTSTR TargetName;

} DIR, *PDIR;

#define WINDOWS_DEFAULT_PFDOC_SIZE   81112

#define DIR_NEED_TO_FREE_SOURCENAME 0x00000001
#define DIR_ABSOLUTE_PATH           0x00000002
#define DIR_USE_SUBDIR              0x00000004
// If DIR_IS_PLATFORM_INDEPEND is passed to AddDirectory, then
// all the files it enumerates will have their FILE_IN_PLATFORM_INDEPEND_DIR
// flag set and then they will get copied to c:\$win_nt$.~ls instead of
// c:\$win_nt$.~ls\<processor>
#define DIR_IS_PLATFORM_INDEPEND    0x00000008

#define DIR_SUPPORT_DYNAMIC_UPDATE  0x00000010
#define DIR_DOESNT_SUPPORT_PRIVATES 0x00000020

//
// Dummy directory id we use for sections in the in (like [RootBootFiles])
// that don't have a directory specifier in the inf
//
#define DUMMY_DIRID     TEXT("**")

typedef struct _FIL {
    //
    // Size of file.
    //
    ULONGLONG Size;

    struct _FIL *Next;
#ifndef SLOWER_WAY
    struct _FIL *Prev;
#endif

    //
    // Directory information for the file.
    //
    PDIR Directory;

    //
    // Name of file on source.
    //
    LPCTSTR SourceName;

    //
    // Name of file on target.
    //
    LPCTSTR TargetName;

    UINT Flags;

    //
    // Bitmap used to track which threads have had a crack at
    // copying this file.
    //
    UINT ThreadBitmap;

} FIL, *PFIL;

#define FILE_NEED_TO_FREE_SOURCENAME    0x00000002
#define FILE_ON_SYSTEM_PARTITION_ROOT   0x00000004
#define FILE_IN_PLATFORM_INDEPEND_DIR   0x00000008
#define FILE_PRESERVE_COMPRESSED_NAME   0x00000010
#define FILE_DECOMPRESS                 0x00000020
#define FILE_IGNORE_COPY_ERROR          0x00000040
#define FILE_DO_NOT_COPY                0x00000080
#if defined(REMOTE_BOOT)
#define FILE_ON_MACHINE_DIRECTORY_ROOT  0x00000100  // for remote boot
#endif // defined(REMOTE_BOOT)


//
// This flag is really only meaningful on x86. It means that the file
// is in the \$win_nt$.~bt directory on the system partition and not in
// \$win_nt$.~ls.
//
#define FILE_IN_LOCAL_BOOT              0x80000000


//
//  This flag indicates that the file is not part of the product,
//  and should be migrated from the current NT system. When this flag is
//  set, the file should be moved to the $win_nt$.~bt directory (x86), or
//  to the $win_nt$.~ls\alpha directory (alpha).
//  This flag is not valid on Win95.
//
#define FILE_NT_MIGRATE                 0x40000000


typedef struct _COPY_LIST {
    PDIR Directories;
    PFIL Files;
    UINT DirectoryCount;
    UINT FileCount;

    //
    // These members aren't initialized until we actually start
    // the copying.
    //
    CRITICAL_SECTION CriticalSection;
    BOOL ActiveCS;
    HANDLE StopCopyingEvent;
    HANDLE ListReadyEvent[MAX_SOURCE_COUNT];
    HANDLE Threads[MAX_SOURCE_COUNT];
    ULONGLONG SpaceOccupied[MAX_SOURCE_COUNT];
    HWND hdlg;

} COPY_LIST, *PCOPY_LIST;

typedef struct _BUILD_LIST_THREAD_PARAMS {
    //
    // Copy list that gets built up by the thread.
    // It's a private list; the main thread merges all of these together
    // into the master list later.
    //
    COPY_LIST CopyList;

    TCHAR SourceRoot[MAX_PATH];
    TCHAR CurrentDirectory[MAX_PATH];
    TCHAR DestinationDirectory[MAX_PATH];
    WIN32_FIND_DATA FindData;

    DWORD OptionalDirFlags;

} BUILD_LIST_THREAD_PARAMS, *PBUILD_LIST_THREAD_PARAMS;


//
// Define structure used with the file copy error dialog.
//
typedef struct _COPY_ERR_DLG_PARAMS {
    LPCTSTR SourceFilename;
    LPCTSTR TargetFilename;
    UINT Win32Error;
} COPY_ERR_DLG_PARAMS,*PCOPY_ERR_DLG_PARAMS;

typedef struct _NAME_AND_SIZE_CAB {
    LPCTSTR Name;
    ULONGLONG Size;
} NAME_AND_SIZE_CAB, *PNAME_AND_SIZE_CAB;

COPY_LIST MasterCopyList;
BOOL MainCopyStarted;

//
// Names of relevent inf sections.
//
LPCTSTR szDirectories = TEXT("Directories");
LPCTSTR szFiles       = TEXT("Files");
LPCTSTR szDiskSpaceReq    = TEXT("DiskSpaceRequirements");
LPCTSTR szPFDocSpaceReq    = TEXT("PFDocSpace");

//
// Amount of space we need when scanning all the
// drives for a place to put the temporary files.
//
ULONGLONG MinDiskSpaceRequired;
ULONGLONG MaxDiskSpaceRequired;
TCHAR   DiskDiagMessage[5000];

//
// Amount of space occupied by the files in the master copy list,
// on the local source drive.
//
DWORD     LocalSourceDriveClusterSize;

ULONGLONG TotalDataCopied = 0;

DWORD
BuildCopyListForOptionalDirThread(
    IN PVOID ThreadParam
    );

DWORD
AddFilesInDirToCopyList(
    IN OUT PBUILD_LIST_THREAD_PARAMS Params
    );

PDIR
AddDirectory(
    IN     LPCTSTR    InfSymbol,    OPTIONAL
    IN OUT PCOPY_LIST CopyList,
    IN     LPCTSTR    SourceName,
    IN     LPCTSTR    TargetName,   OPTIONAL
    IN     UINT       Flags
    );

PFIL
AddFile(
    IN OUT PCOPY_LIST CopyList,
    IN     LPCTSTR    SourceFilename,
    IN     LPCTSTR    TargetFilename,   OPTIONAL
    IN     PDIR       Directory,
    IN     UINT       Flags,
    IN     ULONGLONG  FileSize          OPTIONAL
    );

DWORD
AddSection(
    IN     PVOID      Inf,
    IN OUT PCOPY_LIST CopyList,
    IN     LPCTSTR    SectionName,
    OUT    UINT      *ErrorLine,
    IN     UINT       FileFlags,
    IN     BOOL       SimpleList,
    IN     BOOL       DoDriverCabPruning
    );

PDIR
LookUpDirectory(
    IN PCOPY_LIST CopyList,
    IN LPCTSTR    DirSymbol
    );

VOID
TearDownCopyList(
    IN OUT PCOPY_LIST CopyList
    );

DWORD
CopyOneFile(
    IN  PFIL   File,
    IN  UINT   SourceOrdinal,
    OUT TCHAR  TargetFilename[MAX_PATH],
    OUT ULONGLONG *SpaceOccupied
    );

INT_PTR
CopyErrDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

UINT
DiamondCallback(
    IN PVOID Context,
    IN UINT  Code,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );

LRESULT
DiskDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

BOOL
BuildCopyListWorker(
    IN HWND hdlg
    )
/*++

Routine Description:

    Worker routine to build the queue of file to be copied.

Arguments:

    hdlg - window handle for any UI updates.

Return Value:

    TRUE/FALSE.  If the call succeeds, TRUE is returned and the global MasterCopyList structure
    is ready to be copied.

--*/
{
    BOOL b;
    UINT u;
    UINT source;
    UINT thread;
    DWORD d = NO_ERROR;
    DWORD TempError;
    BUILD_LIST_THREAD_PARAMS BuildParams[MAX_OPTIONALDIRS];
    BUILD_LIST_THREAD_PARAMS bltp;
    HANDLE BuildThreads[MAX_OPTIONALDIRS];
    DWORD ThreadId;
    LPCTSTR Id,DirectoryName;
    PDIR DirectoryStruct;
    PFIL FileStruct;
    UINT ErrorLine;
    UINT i;
    TCHAR c;
    BOOL AllSourcesLocal;
    TCHAR floppynum[40],temps[4];
    LPCTSTR DummyDirectoryName;
    TCHAR buffer[MAX_PATH];
    PTSTR p;
    TCHAR SourceDirectory[MAX_PATH];
    WIN32_FIND_DATA fd;
#ifdef PRERELEASE
    LONG lines1, lines2, l;    
    TCHAR* dirNames;
    PDIR* dirStructs;
    PCTSTR src, dst;
    TCHAR tmp[MAX_PATH];
#endif

    TearDownCopyList(&MasterCopyList);



    DebugLog (Winnt32LogDetailedInformation, TEXT("Building Copy list."), 0);
    //
    // If NOLs was specified on the command line, and the user
    // did not specify to make a local source, and we have
    // exactly one source that is a hdd, then turn of ls and
    // use that drive.
    //
    if (MakeLocalSource && NoLs && !UserSpecifiedMakeLocalSource) {


       if (SourceCount == 1 && MyGetDriveType (*SourcePaths[0]) == DRIVE_FIXED) {

            MakeLocalSource = FALSE;

            DebugLog (Winnt32LogDetailedInformation, TEXT("Not making local source."), 0);
        }
    }

#ifdef PRERELEASE

    if( !BuildCmdcons) {
        DebugLog (Winnt32LogDetailedInformation, TEXT("Adding SymbolDirs to copylist"), 0);
        //
        // for internal debugging, also copy all the .pdb files listed
        // in dosnet.inf
        //
        lines1 = InfGetSectionLineCount (MainInf, TEXT("SymbolDirs"));
        lines2 = InfGetSectionLineCount (MainInf, TEXT("SymbolFiles"));
        if (lines1 > 0 && lines2 > 0) {
            dirNames = (TCHAR*) MALLOC (lines1 * MAX_PATH * sizeof (TCHAR));
            dirStructs = (PDIR*) MALLOC (lines1 * sizeof (PDIR));
            if (dirNames && dirStructs) {
                u = 0;
                for (l = 0; l < lines1; l++) {
                    lstrcpy (tmp, SourcePaths[0]);
                    src = InfGetFieldByIndex (MainInf, TEXT("SymbolDirs"), l, 0);
                    if (!src) {
                        continue;
                    }
                    ConcatenatePaths (tmp, src, MAX_PATH);
                    if (!GetFullPathName (tmp, MAX_PATH, SourceDirectory, NULL)) {
                        continue;
                    }
                    if (!FileExists (SourceDirectory, &fd) || !(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                        continue;
                    }
                    dst = InfGetFieldByIndex (MainInf, TEXT("SymbolDirs"), l, 1);
                    if (!dst) {
                        dst = TEXT("symbols");
                    }
                    dirStructs[u] = AddDirectory (
                                        NULL,
                                        &MasterCopyList,
                                        SourceDirectory,
                                        dst,
                                        DIR_ABSOLUTE_PATH | DIR_NEED_TO_FREE_SOURCENAME
                                        );
                    lstrcpyn (&dirNames[u * MAX_PATH], SourceDirectory, MAX_PATH);
                    u++;
                }

                for (l = 0; l < lines2; l++) {
                    src = InfGetFieldByIndex (MainInf, TEXT("SymbolFiles"), l, 0);
                    if (!src) {
                        continue;
                    }
                    for (i = 0; i < u; i++) {
                        BuildPath (tmp, &dirNames[i * MAX_PATH], src);
                        if (!FileExists (tmp, &fd) || (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                            continue;
                        }
                        if (dirStructs[i]) {
                            AddFile (&MasterCopyList, src, NULL, dirStructs[i], FILE_IGNORE_COPY_ERROR, fd.nFileSizeLow);
                            break;
                        }
                    }
                }
            }
        }
    }

#endif

    //
    // copy any downloaded drivers under the local boot directory,
    // together with updates.cab/.sif if they are present
    //
    if (DynamicUpdateSuccessful ()) {

        if (g_DynUpdtStatus->UpdatesCabSource[0]) {
            lstrcpy (buffer, g_DynUpdtStatus->UpdatesCabSource);
            p = _tcsrchr (buffer, TEXT('\\'));
            if (!p) {
                d = ERROR_INVALID_PARAMETER;
                goto c1;
            }
            *p++ = 0;

            DirectoryStruct = AddDirectory (
                                    NULL,
                                    &MasterCopyList,
                                    buffer,
                                    NULL,
                                    DIR_ABSOLUTE_PATH | DIR_NEED_TO_FREE_SOURCENAME | DIR_DOESNT_SUPPORT_PRIVATES
                                    );
            if (!DirectoryStruct) {
                d = ERROR_NOT_ENOUGH_MEMORY;
                goto c1;
            }

            FileStruct = AddFile (
                            &MasterCopyList,
                            p,
                            NULL,
                            DirectoryStruct,
                            FILE_IN_LOCAL_BOOT | FILE_NEED_TO_FREE_SOURCENAME,
                            0
                            );
            if (!FileStruct) {
                d = ERROR_NOT_ENOUGH_MEMORY;
                goto c1;
            }
            //
            // now copy the SIF file
            //
            BuildSifName (g_DynUpdtStatus->UpdatesCabSource, buffer);
            p = _tcsrchr (buffer, TEXT('\\'));
            if (!p) {
                d = ERROR_INVALID_PARAMETER;
                goto c1;
            }
            *p++ = 0;
            //
            // the directory is the same as before
            //
            FileStruct = AddFile (
                            &MasterCopyList,
                            p,
                            NULL,
                            DirectoryStruct,
                            FILE_IN_LOCAL_BOOT | FILE_NEED_TO_FREE_SOURCENAME,
                            0
                            );
            if (!FileStruct) {
                d = ERROR_NOT_ENOUGH_MEMORY;
                goto c1;
            }
        }

        if (g_DynUpdtStatus->DuasmsSource[0]) {
            ZeroMemory (&bltp, sizeof(bltp));
            lstrcpy (bltp.CurrentDirectory, g_DynUpdtStatus->DuasmsSource);
            lstrcpy (bltp.DestinationDirectory, S_SUBDIRNAME_DUASMS);
            bltp.OptionalDirFlags = OPTDIR_TEMPONLY | OPTDIR_ABSOLUTE | OPTDIR_IN_LOCAL_BOOT | OPTDIR_DOESNT_SUPPORT_PRIVATES;
            d = AddFilesInDirToCopyList (&bltp);
            if(d != NO_ERROR) {
                goto c1;
            }
            //
            // Merge the copy list into the master copy list.
            //
            MasterCopyList.FileCount += bltp.CopyList.FileCount;
            MasterCopyList.DirectoryCount += bltp.CopyList.DirectoryCount;

            if(MasterCopyList.Directories) {

#ifndef SLOWER_WAY

                if (bltp.CopyList.Directories) {
                    PVOID p;
                    p = bltp.CopyList.Directories->Prev;
                    bltp.CopyList.Directories->Prev = MasterCopyList.Directories->Prev;
                    MasterCopyList.Directories->Prev->Next = bltp.CopyList.Directories;
                    MasterCopyList.Directories->Prev = p;
                }
#else
                for(DirectoryStruct=MasterCopyList.Directories;
                    DirectoryStruct->Next;
                    DirectoryStruct=DirectoryStruct->Next) {

                    ;
                }

                DirectoryStruct->Next = bltp.CopyList.Directories;

#endif
            } else {
                MasterCopyList.Directories = bltp.CopyList.Directories;
            }

            if(MasterCopyList.Files) {
#ifndef SLOWER_WAY
                if (bltp.CopyList.Files) {
                    PVOID p;
                    p = bltp.CopyList.Files->Prev;
                    bltp.CopyList.Files->Prev = MasterCopyList.Files->Prev;
                    MasterCopyList.Files->Prev->Next = bltp.CopyList.Files;
                    MasterCopyList.Files->Prev = p ;
                }
#else
                for(FileStruct=MasterCopyList.Files;
                    FileStruct->Next;
                    FileStruct=FileStruct->Next) {

                    ;
                }

                FileStruct->Next = bltp.CopyList.Files;
#endif
            } else {
                MasterCopyList.Files = bltp.CopyList.Files;
            }
        }

        if (g_DynUpdtStatus->NewDriversList) {

            ZeroMemory(&bltp,sizeof(bltp));
            lstrcpy (bltp.CurrentDirectory, g_DynUpdtStatus->SelectedDrivers);
            lstrcpy (bltp.DestinationDirectory, S_SUBDIRNAME_DRIVERS);
            bltp.OptionalDirFlags = OPTDIR_TEMPONLY | OPTDIR_ABSOLUTE | OPTDIR_IN_LOCAL_BOOT | OPTDIR_DOESNT_SUPPORT_PRIVATES;
            d = AddFilesInDirToCopyList (&bltp);
            if(d != NO_ERROR) {
                goto c1;
            }
            //
            // Merge the copy list into the master copy list.
            //
            MasterCopyList.FileCount += bltp.CopyList.FileCount;
            MasterCopyList.DirectoryCount += bltp.CopyList.DirectoryCount;

            if(MasterCopyList.Directories) {

#ifndef SLOWER_WAY

                if (bltp.CopyList.Directories) {
                    PVOID p;
                    p = bltp.CopyList.Directories->Prev;
                    bltp.CopyList.Directories->Prev = MasterCopyList.Directories->Prev;
                    MasterCopyList.Directories->Prev->Next = bltp.CopyList.Directories;
                    MasterCopyList.Directories->Prev = p;
                }
#else
                for(DirectoryStruct=MasterCopyList.Directories;
                    DirectoryStruct->Next;
                    DirectoryStruct=DirectoryStruct->Next) {

                    ;
                }

                DirectoryStruct->Next = bltp.CopyList.Directories;

#endif
            } else {
                MasterCopyList.Directories = bltp.CopyList.Directories;
            }

            if(MasterCopyList.Files) {
#ifndef SLOWER_WAY
                if (bltp.CopyList.Files) {
                    PVOID p;
                    p = bltp.CopyList.Files->Prev;
                    bltp.CopyList.Files->Prev = MasterCopyList.Files->Prev;
                    MasterCopyList.Files->Prev->Next = bltp.CopyList.Files;
                    MasterCopyList.Files->Prev = p ;
                }
#else
                for(FileStruct=MasterCopyList.Files;
                    FileStruct->Next;
                    FileStruct=FileStruct->Next) {

                    ;
                }

                FileStruct->Next = bltp.CopyList.Files;
#endif
            } else {
                MasterCopyList.Files = bltp.CopyList.Files;
            }
        }
    }

    //
    // Add the mandatory optional dirs to the list of optional dirs.
    // These are specified in txtsetup.sif.
    //
    DebugLog (Winnt32LogDetailedInformation, TEXT("Adding OptionalSrcDirs to optional dirs."), 0);
    u = 0;
    while(DirectoryName = InfGetFieldByIndex(MainInf,TEXT("OptionalSrcDirs"),u++,0)) {
        TCHAR TempString[MAX_PATH];


        RememberOptionalDir(DirectoryName,OPTDIR_TEMPONLY |OPTDIR_ADDSRCARCH | OPTDIR_SUPPORT_DYNAMIC_UPDATE);

#ifdef _IA64_

        lstrcpy( TempString, TEXT("..\\I386\\"));
        ConcatenatePaths(TempString, DirectoryName, MAX_PATH);

        //Also check if an I386 equivalent WOW directory exists

        AddCopydirIfExists( TempString, OPTDIR_TEMPONLY | OPTDIR_PLATFORM_INDEP );


#endif

    }

    //
    // and Fusion side by side assemblies, driven by syssetup.inf, if the directories exists
    DebugLog (Winnt32LogDetailedInformation, TEXT("Adding AssemblyDirectories to optional dirs."), 0);
    //
    {
        TCHAR  SideBySideInstallShareDirectory[MAX_PATH]; // source
        DWORD  FileAttributes = 0;
        PCTSTR DirectoryName = NULL;

        u = 0;
        while (DirectoryName = InfGetFieldByIndex(MainInf, SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME, u++, 0)) {
            //
            // convention introduced specifically for side by side, so that
            // x86 files on ia64 might come from \i386\asms instead of \ia64\asms\i386,
            // depending on what dosnet.inf and syssetup.inf say:
            //   a path that does not start with a slash is appended to \$win_nt$.~ls\processor
            //                                                      and \installShare\processor
            //                                                  (or cdromDriveLetter:\processor)
            //   a path that does     start with a slash is appended to \$win_nt$.~ls
            //                                                      and \installShare
            //                                                 (or cdromDriveLetter:\)
            BOOL StartsWithSlash = (DirectoryName[0] == '\\' || DirectoryName[0] == '/');
            lstrcpyn(SideBySideInstallShareDirectory, SourcePaths[0], MAX_PATH);
            if (StartsWithSlash) {
                DirectoryName += 1; // skip slash
            } else {
                ConcatenatePaths(SideBySideInstallShareDirectory, InfGetFieldByKey(MainInf, TEXT("Miscellaneous"), TEXT("DestinationPlatform"),0), MAX_PATH);
            }
            ConcatenatePaths(SideBySideInstallShareDirectory, DirectoryName, MAX_PATH );
            //
            // For now, while "staging", we allow the directory to not exist, and to be
            // empty (emptiness is silently handled elsewhere by common code), but
            // comctl32 will be in an assembly, so assemblies will be mandatory
            // for the system to boot to Explorer.exe.
            //
            // 14-Nov-2000 (jonwis): No more optionality.  We're now an essential part of
            //      this complete setup path.  In the future, we might want to consider
            //      moving out to a .inf file.  For now, mark ourselves as an 'optional'
            //      directory that should get copied along.
            //
            RememberOptionalDir(DirectoryName, OPTDIR_SIDE_BY_SIDE | OPTDIR_TEMPONLY | (StartsWithSlash ? OPTDIR_PLATFORM_INDEP : OPTDIR_ADDSRCARCH));
        }
    }

    thread = 0;
    if(MakeLocalSource && OptionalDirectoryCount) {
        //
        // Start optional directory threads going.
        // There will thus be as many threads as there are
        // optional source dirs.
        //
        DebugLog (Winnt32LogDetailedInformation, TEXT("Starting optional directory thread going..."), 0);
        ZeroMemory(BuildParams,sizeof(BuildParams));
        source = 0;
        for(u=0; u<OptionalDirectoryCount; u++) {
            PTSTR s,t;
            BOOL DoSource = FALSE;

            lstrcpy(BuildParams[u].SourceRoot,SourcePaths[source]);
            //
            // support ".." syntax
            //
            t = s = OptionalDirectories[u];
            while (s = _tcsstr(s,TEXT("..\\"))) {
                DoSource = TRUE;
                p = _tcsrchr(BuildParams[u].SourceRoot,TEXT('\\'));
                if (p) {
                    //
                    // note that if we could end up with a source root with no
                    // '\' char in it, but this is not a problem since the
                    // subroutines which use the source root handle the lack
                    // of '\' correctly
                    //
                    *p = 0;
                }
                t = s += 3;
            }

            if (OptionalDirectoryFlags[u] & OPTDIR_ADDSRCARCH) {
                PCTSTR DirectoryRoot;
                DirectoryRoot = InfGetFieldByKey(MainInf, TEXT("Miscellaneous"), TEXT("DestinationPlatform"),0);
                lstrcpyn(SourceDirectory,DirectoryRoot,MAX_PATH);
                ConcatenatePaths( SourceDirectory, t, MAX_PATH );
            } else {
                lstrcpyn(SourceDirectory,t,MAX_PATH);
            }

            if (DoSource) {
                BuildParams[u].OptionalDirFlags = OPTDIR_ABSOLUTE;
                lstrcpyn(BuildParams[u].CurrentDirectory,BuildParams[u].SourceRoot,MAX_PATH);
                ConcatenatePaths(BuildParams[u].CurrentDirectory, SourceDirectory ,MAX_PATH);
            } else {
                lstrcpyn(BuildParams[u].CurrentDirectory,SourceDirectory,MAX_PATH);
            }

            if (OptionalDirectoryFlags[u] & OPTDIR_DEBUGGEREXT) {
                lstrcpyn(BuildParams[u].DestinationDirectory,TEXT("system32\\pri"),MAX_PATH);
            }
            else if (!(OptionalDirectoryFlags[u] & OPTDIR_OVERLAY)) {
                if (OptionalDirectoryFlags[u] & OPTDIR_PLATFORM_SPECIFIC_FIRST) {
                    PCTSTR arch = InfGetFieldByKey(MainInf, TEXT("Miscellaneous"), TEXT("DestinationPlatform"), 0);
                    if (arch) {
                        lstrcpyn (buffer, BuildParams[u].SourceRoot, MAX_PATH);
                        ConcatenatePaths (buffer, arch, MAX_PATH);
                        ConcatenatePaths (buffer, SourceDirectory, MAX_PATH);
                        if (FileExists (buffer, &fd) && (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                            //
                            // use this platform-specific source instead
                            //
                            lstrcpyn (BuildParams[u].CurrentDirectory, arch, MAX_PATH);
                            ConcatenatePaths (BuildParams[u].CurrentDirectory, SourceDirectory, MAX_PATH);
                        }
                    }
                }
                if (OptionalDirectoryFlags[u] & OPTDIR_USE_TAIL_FOLDER_NAME) {
                    //
                    // move this directory in a subdirectory directly under target %windir%
                    //
                    p = _tcsrchr (t, TEXT('\\'));
                    if (p) {
                        p++;
                    } else {
                        p = t;
                    }
                } else {
                    p = t;
                }
                lstrcpyn(BuildParams[u].DestinationDirectory,p,MAX_PATH);
            }

            BuildParams[u].OptionalDirFlags |= OptionalDirectoryFlags[u];

            source = (source+1) % SourceCount;

            BuildThreads[thread] = CreateThread(
                                        NULL,
                                        0,
                                        BuildCopyListForOptionalDirThread,
                                        &BuildParams[u],
                                        0,
                                        &ThreadId
                                        );

            if(BuildThreads[thread]) {
                thread++;
            } else {
                d = GetLastError();
                DebugLog (Winnt32LogError, TEXT("ERROR: Problem with creating thread for optional directory."), 0);
                goto c0;
            }
        }
    }

    //
    // Add the directories listed in the inf to the main copy list.
    // Also add a dummy directory that we use for simple file list sections
    // that have no directory specifier in the inf.
    //
    DebugLog (Winnt32LogDetailedInformation, TEXT("Adding miscellaneous..."), 0);
    DummyDirectoryName = InfGetFieldByKey(MainInf, TEXT("Miscellaneous"), TEXT("DestinationPlatform"), 0);
    if (!DummyDirectoryName) {
        DummyDirectoryName = TEXT("\\");
    }
    DirectoryStruct = AddDirectory(
                               DUMMY_DIRID,
                               &MasterCopyList,
                               DummyDirectoryName,
                               NULL,
                               DIR_SUPPORT_DYNAMIC_UPDATE
                               );

    if(!DirectoryStruct) {
        d = ERROR_NOT_ENOUGH_MEMORY;
        DebugLog (Winnt32LogError, TEXT("ERROR: Could not add miscellaneous"), 0);
        goto c1;
    }

    u = 0;
    while((Id = InfGetLineKeyName(MainInf,szDirectories,u))
       && (DirectoryName = InfGetFieldByKey(MainInf,szDirectories,Id,0))) {

        DirectoryStruct = AddDirectory(
                            Id,
                            &MasterCopyList,
                            DirectoryName,
                            NULL,
                            DIR_SUPPORT_DYNAMIC_UPDATE
                            );

        if(!DirectoryStruct) {
            d = ERROR_NOT_ENOUGH_MEMORY;
            DebugLog (Winnt32LogError, TEXT("ERROR: Could not add directory %1"), 0, DirectoryName);
            goto c1;
        }

        u++;
    }

    //
    // Add files in the [Files] section.
    //
    DebugLog (Winnt32LogDetailedInformation, TEXT("Adding files from [Files] section..."), 0);
    if(MakeLocalSource) {

        d = AddSection(
                MainInf,
                &MasterCopyList,
                szFiles,
                &ErrorLine,
                FILE_PRESERVE_COMPRESSED_NAME | FILE_IN_PLATFORM_INDEPEND_DIR,
                FALSE,
                TRUE
                );

        if(d != NO_ERROR) {
            DebugLog (Winnt32LogError, TEXT("ERROR: Could not add files!"), 0);
            goto c1;
        }
    }

#if defined(REMOTE_BOOT)
    if(RemoteBoot) {

        //
        // Remote boot client upgrade. Add the two special sections
        // RootRemoteBootFiles (ntldr and ntdetect.com in c:\) and
        // MachineRootRemoteBootFiles (setupldr.exe and startrom.com in
        // \\server\imirror\clients\client).
        //
        d = AddSection(
                MainInf,
                &MasterCopyList,
                TEXT("RootRemoteBootFiles"),
                &ErrorLine,
                FILE_ON_SYSTEM_PARTITION_ROOT | FILE_PRESERVE_COMPRESSED_NAME,
                TRUE,
                FALSE
                );

        d = AddSection(
                MainInf,
                &MasterCopyList,
                TEXT("MachineRootRemoteBootFiles"),
                &ErrorLine,
                FILE_ON_MACHINE_DIRECTORY_ROOT | FILE_PRESERVE_COMPRESSED_NAME,
                TRUE,
                FALSE
                );

    } else
#endif // defined(REMOTE_BOOT)
    {

        if (!IsArc()) {
#ifdef _X86_
            //
            // In the floppyless case add each of [FloppyFiles.0], [FloppyFiles.1],
            // [FloppyFiles.2], and [RootBootFiles].
            //
            if(MakeBootMedia && Floppyless) {


                for ( u=0;u<FLOPPY_COUNT;u++ ){

                    lstrcpy(floppynum, TEXT("FloppyFiles."));
                    _ultot( u, temps, 10);
                    lstrcat(floppynum, temps);
                    d = AddSection(
                            MainInf,
                            &MasterCopyList,
                            floppynum,
                            &ErrorLine,
                            FILE_IN_LOCAL_BOOT | FILE_PRESERVE_COMPRESSED_NAME,
                            FALSE,
                            FALSE
                            );
                    if( d != NO_ERROR )
                    {
                        DebugLog (Winnt32LogError, TEXT("ERROR: Adding section %1, entry = %2!u!"), 0, floppynum, d);
                        break;
                    }


                }// for


                if(d == NO_ERROR) {

                    d = AddSection(
                            MainInf,
                            &MasterCopyList,
                            TEXT("RootBootFiles"),
                            &ErrorLine,
                            FILE_ON_SYSTEM_PARTITION_ROOT | FILE_PRESERVE_COMPRESSED_NAME,
                            TRUE,
                            FALSE
                            );
                    DebugLog (Winnt32LogDetailedInformation, TEXT("Added RootBootFiles, return = %2!u!"), 0, d);

                    if (d == NO_ERROR && BuildCmdcons) {
                        d = AddSection(
                                MainInf,
                                &MasterCopyList,
                                TEXT("CmdConsFiles"),
                                &ErrorLine,
                                FILE_IN_LOCAL_BOOT | FILE_PRESERVE_COMPRESSED_NAME,
                                TRUE,
                                FALSE
                                );
                        DebugLog (Winnt32LogDetailedInformation, TEXT("Added CmdConsFiles, return = %2!u!"), 0, d);
                    }

                }
            }

            if((d == NO_ERROR) && OemPreinstall && MakeBootMedia) {
                //
                // Add a special directory entry for oem boot files.
                // The oem boot files come from $OEM$\TEXTMODE on the source
                // and go to localboot\$OEM$ on the target.
                //

                //
                // It's possible that the user has given us a network share for
                // the $OEM$ directory in the unattend file.  If so, we need to
                // use that as the source instead of WINNT_OEM_TEXTMODE_DIR.
                //
                if( UserSpecifiedOEMShare ) {

                    lstrcpy( buffer, UserSpecifiedOEMShare );
                    ConcatenatePaths(buffer, TEXT("TEXTMODE"),MAX_PATH);

                    DirectoryStruct = AddDirectory(
                                        NULL,
                                        &MasterCopyList,
                                        buffer,
                                        WINNT_OEM_DIR,
                                        DIR_NEED_TO_FREE_SOURCENAME | DIR_ABSOLUTE_PATH | DIR_USE_SUBDIR
                                        );
                } else {
                    PCTSTR arch;
                    buffer[0] = 0;
                    arch = InfGetFieldByKey(MainInf, TEXT("Miscellaneous"), TEXT("DestinationPlatform"), 0);
                    if (arch) {
                        lstrcpy (buffer, arch);
                    }
                    ConcatenatePaths (buffer, WINNT_OEM_TEXTMODE_DIR, MAX_PATH);
                    DirectoryStruct = AddDirectory(
                                        NULL,
                                        &MasterCopyList,
                                        buffer,
                                        WINNT_OEM_DIR,
                                        DIR_NEED_TO_FREE_SOURCENAME | DIR_USE_SUBDIR
                                        );
                }

                if(DirectoryStruct) {

                    POEM_BOOT_FILE p;

                    for(p=OemBootFiles; (d==NO_ERROR) && p; p=p->Next) {
                        //
                        // we're not fetching the file size, so in the oem preinstall case
                        // when there are oem boot files, the size check is not accurate.
                        //
                        if(!AddFile(&MasterCopyList,p->Filename,NULL,DirectoryStruct,FILE_IN_LOCAL_BOOT,0)) {
                            d = ERROR_NOT_ENOUGH_MEMORY;
                            break;
                        }
                    }
                } else {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
#endif // _X86_
        } else {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
            //
            // ARC case. Add setupldr.
            //
            FileStruct = AddFile(
                            &MasterCopyList,
                            SETUPLDR_FILENAME,
                            NULL,
                            LookUpDirectory(&MasterCopyList,DUMMY_DIRID),
                            FILE_ON_SYSTEM_PARTITION_ROOT,
                            0
                            );

            d = FileStruct ? NO_ERROR : ERROR_NOT_ENOUGH_MEMORY;
#endif // UNICODE
        } // if (!IsArc())

    }

    if(d != NO_ERROR) {
        goto c1;
    }

    if (AsrQuickTest) {
        //
        // Add asr.sif
        //
        FileStruct = AddFile(
                    &MasterCopyList,
                    TEXT("asr.sif"),
                    NULL,
                    DirectoryStruct,
                    FILE_IN_LOCAL_BOOT,
                    0
                    );

        d = FileStruct ? NO_ERROR : ERROR_NOT_ENOUGH_MEMORY;

        if(d != NO_ERROR) {
            DebugLog (Winnt32LogError, TEXT("ERROR: AsrQuitTest - could not add asr.sif!"), 0);
            goto c1;
        }
    }

    //
    // If there were any threads created to build the file lists for
    // optional directories, wait for them to terminate now.
    // If they were all successful then add the lists they created
    // to the master list.
    //
    if(thread) {

        WaitForMultipleObjects(thread,BuildThreads,TRUE,INFINITE);

        TempError = NO_ERROR;
        for(u=0; u<thread; u++) {

            if(!GetExitCodeThread(BuildThreads[u],&TempError)) {
                TempError = GetLastError();
            }

            //
            // Preserve first error.
            //
            if((TempError != NO_ERROR) && (d == NO_ERROR)) {
                d = TempError;
            }

            if (d != NO_ERROR) {
                break;
            }


            CloseHandle(BuildThreads[u]);
            BuildThreads[u] = NULL;

            //
            // Merge the copy list into the master copy list.
            // When we've done that, clean out the per-thread copy list
            // structure to avoid problems later if we have a failure and
            // have to clean up.
            //
            MasterCopyList.FileCount += BuildParams[u].CopyList.FileCount;
            MasterCopyList.DirectoryCount += BuildParams[u].CopyList.DirectoryCount;

            if(MasterCopyList.Directories) {

#ifndef SLOWER_WAY

                if (BuildParams[u].CopyList.Directories) {
                    PVOID p;
                    p = BuildParams[u].CopyList.Directories->Prev;
                    BuildParams[u].CopyList.Directories->Prev = MasterCopyList.Directories->Prev;
                    MasterCopyList.Directories->Prev->Next = BuildParams[u].CopyList.Directories;
                    MasterCopyList.Directories->Prev = p;
                }
#else
                for(DirectoryStruct=MasterCopyList.Directories;
                    DirectoryStruct->Next;
                    DirectoryStruct=DirectoryStruct->Next) {

                    ;
                }

                DirectoryStruct->Next = BuildParams[u].CopyList.Directories;

#endif
            } else {
                MasterCopyList.Directories = BuildParams[u].CopyList.Directories;
            }

            if(MasterCopyList.Files) {
#ifndef SLOWER_WAY
                if (BuildParams[u].CopyList.Files) {
                    PVOID p;
                    p = BuildParams[u].CopyList.Files->Prev;
                    BuildParams[u].CopyList.Files->Prev = MasterCopyList.Files->Prev;
                    MasterCopyList.Files->Prev->Next = BuildParams[u].CopyList.Files;
                    MasterCopyList.Files->Prev = p ;
                }
#else
                for(FileStruct=MasterCopyList.Files;
                    FileStruct->Next;
                    FileStruct=FileStruct->Next) {

                    ;
                }

                FileStruct->Next = BuildParams[u].CopyList.Files;
#endif
            } else {
                MasterCopyList.Files = BuildParams[u].CopyList.Files;
            }

            ZeroMemory(&BuildParams[u].CopyList,sizeof(COPY_LIST));

        }

        if(d != NO_ERROR) {
            goto c1;
        }
    }

    //
    // Success.
    //
    return(TRUE);

c1:
    //
    // Clean up the copy list.
    //
    TearDownCopyList(&MasterCopyList);
c0:
    //
    // Close thread handles and free per-thread copy lists that may still
    // be unmerged into the master list.
    //
    for(u=0; u<thread; u++) {
        if(BuildThreads[u]) {
            WaitForSingleObject(BuildThreads[u], INFINITE);
            CloseHandle(BuildThreads[u]);
        }
        TearDownCopyList(&BuildParams[u].CopyList);
    }

    //
    // Tell the user what went wrong.
    //

    SendMessage(hdlg,WMX_ERRORMESSAGEUP,TRUE,0);

    MessageBoxFromMessageAndSystemError(
        hdlg,
        MSG_CANT_BUILD_SOURCE_LIST,
        d,
        AppTitleStringId,
        MB_OK | MB_ICONWARNING
        );

    SendMessage(hdlg,WMX_ERRORMESSAGEUP,FALSE,0);

    return(FALSE);
}


DWORD
BuildCopyListForOptionalDirThread(
    IN PVOID ThreadParam
    )
{
    //
    // Just call the recursive worker routine.
    //
    return(AddFilesInDirToCopyList(ThreadParam));
}


DWORD
AddFilesInDirToCopyList(
    IN OUT PBUILD_LIST_THREAD_PARAMS Params
    )

/*++

Routine Description:

    Recursively adds directories and their contents to the copy list.

    The function takes care to overlay OEM-specified files so that they
    are copied to proper location in the local source.

Arguments:

    Params - pointer to BUILD_LIST_THREAD_PARAMS structure indicating
             the files to be copied.

Return Value:

    Win32 error code indicating outcome.

--*/
{
    HANDLE FindHandle;
    LPTSTR pchSrcLim;
    LPTSTR pchDstLim;
    DWORD d;
    PDIR DirectoryDescriptor;
    PFIL FileDescriptor;
    UINT Flags;
    LPTSTR PatternMatch;
    TCHAR *DestinationDirectory;
    TCHAR tmp[MAX_PATH];

    Flags = DIR_NEED_TO_FREE_SOURCENAME;
    if (Params->OptionalDirFlags & OPTDIR_PLATFORM_INDEP) {
        Flags |= DIR_IS_PLATFORM_INDEPEND;
    }

    if (Params->OptionalDirFlags & OPTDIR_IN_LOCAL_BOOT) {
        Flags |= DIR_USE_SUBDIR;
    }

    if (Params->OptionalDirFlags & OPTDIR_SUPPORT_DYNAMIC_UPDATE) {
        Flags |= DIR_SUPPORT_DYNAMIC_UPDATE;
    }

    if (Params->OptionalDirFlags & OPTDIR_DOESNT_SUPPORT_PRIVATES) {
        Flags |= DIR_DOESNT_SUPPORT_PRIVATES;
    }

    //
    // Add the directory to the directory list.
    // Note that the directory is added in a form relative to the
    // source root.
    //

    //
    // Check for a floating $OEM$ directory
    //
    if( (DestinationDirectory=_tcsstr( Params->CurrentDirectory, WINNT_OEM_DIR )) &&
        UserSpecifiedOEMShare ) {


        //
        // We need to manually specify the Target directory
        // name because it's not the same as the source.  We
        // want the destination directory to look exactly like
        // the source from "$OEM$" down.
        //

        DirectoryDescriptor = AddDirectory(
                                NULL,
                                &Params->CopyList,
                                Params->CurrentDirectory,
                                DupString( DestinationDirectory ),
                                Flags | DIR_ABSOLUTE_PATH
                                );
    } else if( Params->OptionalDirFlags & (OPTDIR_OVERLAY) ) {

        DirectoryDescriptor = AddDirectory(
                                NULL,
                                &Params->CopyList,
                                TEXT("\\"),
                                NULL,
                                Flags | DIR_ABSOLUTE_PATH
                                );
    } else {

        DirectoryDescriptor = AddDirectory(
                                NULL,
                                &Params->CopyList,
                                Params->CurrentDirectory,
                                DupString( Params->DestinationDirectory ),
                                ((Params->OptionalDirFlags & OPTDIR_ABSOLUTE)? DIR_ABSOLUTE_PATH : 0)
                                | Flags
                                );
    }

    if(!DirectoryDescriptor) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Windows 95 has a bug in some IDE CD-ROM drivers that causes FindFirstFile to fail
    // if used with a pattern of "*". It needs to use "*.*" instead. Appease its brokenness.
    //
    if (!ISNT()) {

        PatternMatch = TEXT("*.*");
    }
    else {

        PatternMatch = TEXT("*");
    }

    //
    // Form the search spec. We overload the SourceRoot member of
    // the parameters structure for this to avoid a stack-sucking
    // large local variable.
    //

    //
    // Go look at the absolute path given in CurrentDirectory if we're
    // processing a floating $OEM$ directory.
    //
    if (AlternateSourcePath[0]) {
        _tcscpy( tmp, AlternateSourcePath );
        pchSrcLim = tmp + lstrlen(tmp);
        ConcatenatePaths( tmp, Params->CurrentDirectory, MAX_PATH );
        ConcatenatePaths( tmp, PatternMatch, MAX_PATH );
        FindHandle = FindFirstFile( tmp, &Params->FindData );
        if (FindHandle != INVALID_HANDLE_VALUE) {
            *pchSrcLim = 0;
            _tcscpy( Params->SourceRoot, tmp );
        }
    } else {
        FindHandle = INVALID_HANDLE_VALUE;
    }

    if (FindHandle == INVALID_HANDLE_VALUE) {
        if( DirectoryDescriptor->Flags & DIR_ABSOLUTE_PATH ) {
            pchSrcLim = Params->CurrentDirectory + lstrlen(Params->CurrentDirectory);
            ConcatenatePaths(Params->CurrentDirectory,PatternMatch,MAX_PATH);
            FindHandle = FindFirstFile(Params->CurrentDirectory,&Params->FindData);
        } else {
            pchSrcLim = Params->SourceRoot + lstrlen(Params->SourceRoot);
            ConcatenatePaths(Params->SourceRoot,Params->CurrentDirectory,MAX_PATH);
            ConcatenatePaths(Params->SourceRoot,PatternMatch,MAX_PATH);
            FindHandle = FindFirstFile(Params->SourceRoot,&Params->FindData);
        }
        *pchSrcLim = 0;
    }

    if(!FindHandle || (FindHandle == INVALID_HANDLE_VALUE)) {
        //
        // We might be failing on the $OEM$ directory.  He's optional
        // so let's not fail for him.
        //
        if (Params->OptionalDirFlags & (OPTDIR_OEMSYS)
            && !UserSpecifiedOEMShare) {
            return(NO_ERROR);
        }
        else {
            DebugLog (
                Winnt32LogError,
                TEXT("Unable to copy dir %1"),
                0,
                Params->CurrentDirectory
                );
            return(GetLastError());
        }
    }

    pchSrcLim = Params->CurrentDirectory + lstrlen(Params->CurrentDirectory);
    pchDstLim = Params->DestinationDirectory + lstrlen(Params->DestinationDirectory);

    Flags = FILE_NEED_TO_FREE_SOURCENAME;
    if( !(Params->OptionalDirFlags & (OPTDIR_OVERLAY)) &&
        (!(Params->OptionalDirFlags & OPTDIR_TEMPONLY) ||
          (Params->OptionalDirFlags & (OPTDIR_OEMSYS))) ) {
        Flags |= FILE_IN_PLATFORM_INDEPEND_DIR;
    }
    if (Params->OptionalDirFlags & OPTDIR_PLATFORM_INDEP) {
        Flags |= FILE_IN_PLATFORM_INDEPEND_DIR;
    }
    if (Params->OptionalDirFlags & OPTDIR_IN_LOCAL_BOOT) {
        Flags |= FILE_IN_LOCAL_BOOT;
    }

    d = NO_ERROR;
    do {
        if(Params->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            //
            // Directory. Ignore . and .. entries.
            //
            if( lstrcmp(Params->FindData.cFileName,TEXT("."))  &&
                lstrcmp(Params->FindData.cFileName,TEXT("..")) &&
                !(Params->OptionalDirFlags & (OPTDIR_OVERLAY)) ) {

                //
                // Restore the current directory name and then form
                // the name of the subdirectory and recurse into it.
                //
                *pchSrcLim = 0;
                ConcatenatePaths(Params->CurrentDirectory,Params->FindData.cFileName,MAX_PATH);
                *pchDstLim = 0;
                ConcatenatePaths(Params->DestinationDirectory,Params->FindData.cFileName,MAX_PATH);

                d = AddFilesInDirToCopyList(Params);
            }
        } else {
            FileDescriptor = AddFile(
                                &Params->CopyList,
                                Params->FindData.cFileName,
                                NULL,
                                DirectoryDescriptor,
                                Flags,
                                MAKEULONGLONG(Params->FindData.nFileSizeLow,Params->FindData.nFileSizeHigh)
                                );

            if(!FileDescriptor) {
                d = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    } while((d == NO_ERROR) && FindNextFile(FindHandle,&Params->FindData));

    //
    // Check loop termination condition. If d is NO_ERROR, then FindNextFile
    // failed. We want to make sure it failed because it ran out of files
    // and not for some other reason. If we don't check this, the list of
    // files in the directory could wind up truncated without any indication
    // that something went wrong.
    //
    if(d == NO_ERROR) {
        d = GetLastError();
        if(d == ERROR_NO_MORE_FILES) {
            d = NO_ERROR;
        }
    }

    FindClose(FindHandle);
    return(d);
}


PVOID
PopulateDriverCacheStringTable(
    VOID
    )
/*
    This function populates a string table (hashing table) with the files listed in the
    driver cab (drvindex.inf). It assosciates a Boolean ExtraData with each element of
    value TRUE. Once done with that it goest through the [ForceCopyDriverCabFiles]
    section in dosnet.inf and marks those files as FALSE in the string table. Hence we now
    have a hash table that has TRUE marked for all files that don't need to be copied.

        The function FileToBeCopied can be used to query the string table. The caller is responsible
    for destroying the string table.

    Return values:

        Pointer to string table.

*/
{

#define MAX_SECTION_NAME 256

    TCHAR DriverInfName[MAX_PATH], Section[MAX_SECTION_NAME], FileName[MAX_PATH];
    HINF InfHandle, DosnetInfHandle;
    DWORD i, Count = 0;
    PVOID StringTable = NULL;
    INFCONTEXT InfContext;
    INFCONTEXT LineContext;
    BOOL Err = FALSE, Present = TRUE, Absent = FALSE;
    LONG Hash = 0;


    InfHandle = NULL;
    DosnetInfHandle = NULL;


    FindPathToInstallationFile( DRVINDEX_INF, DriverInfName, MAX_PATH );

    InfHandle = SetupapiOpenInfFile( DriverInfName, NULL, INF_STYLE_WIN4, NULL );
    if (!InfHandle) {
        DebugLog (Winnt32LogError, TEXT("Unable to open INF file %1"), 0, DriverInfName);
        Err = TRUE;
        return(NULL);
    }


    if( (StringTable = pSetupStringTableInitializeEx(sizeof(BOOL), 0)) == NULL ){
        DebugLog (Winnt32LogError, TEXT("Unable to create string table for %1"), 0, DriverInfName);
        Err = TRUE;
        goto cleanup;
    }

    // Populate the string table


    //
    // Now get the section names that we have to search.
    //

    if( SetupapiFindFirstLine( InfHandle, TEXT("Version"), TEXT("CabFiles"), &InfContext)){


        Count = SetupapiGetFieldCount( &InfContext );

        for( i=1; i<=Count; i++ ){

            if(SetupapiGetStringField( &InfContext, i, Section, MAX_SECTION_NAME, 0)){


                if( SetupapiFindFirstLine( InfHandle, Section, NULL, &LineContext )){

                    do{

                        if( SetupapiGetStringField( &LineContext, 0, FileName, MAX_PATH, 0)){

                            if( (-1 ==  pSetupStringTableAddStringEx( StringTable, FileName, (STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE), &Present, sizeof(BOOL)))){
                                DebugLog (Winnt32LogError, TEXT("Out of memory adding string %1 to DriverCache INF string table"), 0, FileName);
                                Err = TRUE;
                                goto cleanup;
                            }
                        }

                    }while( SetupapiFindNextLine( &LineContext, &LineContext ));

                }


            }else{
                DebugLog (Winnt32LogError, TEXT("Unable to get section name in INF %1"), 0, DriverInfName);
                Err = TRUE;
                goto cleanup;
            }

        }

    }


    // Remove entries pertaining to [ForceCopyDriverCabFiles]

    DosnetInfHandle = SetupapiOpenInfFile( FullInfName, NULL, INF_STYLE_WIN4, NULL );
    if (!DosnetInfHandle) {
        DebugLog (Winnt32LogError, TEXT("Unable to open INF file %1"), 0, FullInfName);
        Err = TRUE;
        goto cleanup;
    }

    if( SetupapiFindFirstLine( DosnetInfHandle, TEXT("ForceCopyDriverCabFiles"), NULL, &LineContext )){

        do{

            if( SetupapiGetStringField( &LineContext, 0, FileName, MAX_PATH, 0)){

                Hash = pSetupStringTableLookUpString( StringTable, FileName, STRTAB_CASE_INSENSITIVE);
                if (-1 != Hash ) {
                    pSetupStringTableSetExtraData( StringTable, Hash, &Absent, sizeof(BOOL));
                }
            }



        }while( SetupapiFindNextLine( &LineContext, &LineContext ));

    }




cleanup:

    if( InfHandle != INVALID_HANDLE_VALUE){
        SetupapiCloseInfFile( InfHandle );
    }

    if( DosnetInfHandle != INVALID_HANDLE_VALUE){
        SetupapiCloseInfFile( DosnetInfHandle );
    }


    if( Err ){
        if(StringTable)
            pSetupStringTableDestroy( StringTable );
        StringTable = NULL;
    }

    return( StringTable );



}


BOOL
FileToBeCopied(
    IN      PVOID StringTable,
    IN      PTSTR FileName
    )
/*
    Function to check presence of a driver cab file in the string table.

    Arguments:
        StringTable - Pointer to initialized stringtable
        FileName - Name of file to look for


    Return value;
        TRUE - If the file is in the driver cab and not one of the files that are listed in
               [ForceCopyDriverCabFiles]
        else it returns FALSE.

*/
{
    BOOL Present = FALSE;

    if( (-1 != pSetupStringTableLookUpStringEx( StringTable, FileName, STRTAB_CASE_INSENSITIVE, &Present, sizeof(BOOL)))){

        if( Present == TRUE ){
            return( TRUE );
        }

    }

    //
    // If we get here, we didn't find a match.
    //
    return( FALSE );




}



DWORD
AddSection(
    IN     PVOID      Inf,
    IN OUT PCOPY_LIST CopyList,
    IN     LPCTSTR    SectionName,
       OUT UINT      *ErrorLine,
    IN     UINT       FileFlags,
    IN     BOOL       SimpleList,
    IN     BOOL       DoDriverCabPruning
    )
{
    LPCTSTR DirSymbol, TargetName;
    LPTSTR SourceName;
    unsigned Count;
    BOOL b;
    PDIR Directory;
    PVOID p;
    DWORD Err = NO_ERROR;
    PVOID DriverCacheStringTable = NULL;

    Count = 0;
    *ErrorLine = (UINT)(-1);

    // Open up drvindex.inf if we have to do driver cab pruning

    if( DoDriverCabPruning){

        //Initialize sptils

        if(pSetupInitializeUtils()) {
            //POpulate our Driver Cab list string table for fast lookup later
            if( (DriverCacheStringTable = PopulateDriverCacheStringTable( )) == NULL){
                return(ERROR_NOT_ENOUGH_MEMORY);
            }
        }else
            return(ERROR_NOT_ENOUGH_MEMORY);


    }



    if(SimpleList) {
        while((LPCTSTR)SourceName = InfGetFieldByIndex(Inf,SectionName,Count,0)) {

            if( Cancelled == TRUE ) {
                //
                // The user is trying to exit, and the clean up code
                // is waiting for us to finish.  Break out.
                //
                break;
            }

            // If the file is present in drvindex.inf and not in the
            // [ForceCopyDriverCabFiles] section then don't add it to the copylist


            //
            // This is the section in dosnet.inf that we cross check against when making the filelists.
            // Files in this section are in the driver cab and also should reside in the local source
            // The idea here is that these files are once that are not in the FloppyFiles.x sections and yet
            // need to remain outside the driver cab.
            //


            if( DoDriverCabPruning){

                if (FileToBeCopied( DriverCacheStringTable, SourceName )){
                    Count++;
                    continue;
                }

            }


            TargetName = InfGetFieldByIndex(Inf,SectionName,Count,1);

            Directory = LookUpDirectory(CopyList,DUMMY_DIRID);

            Count++;

            if(!AddFile(CopyList,SourceName,TargetName,Directory,FileFlags,0)) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
        }

    } else {
#ifdef _X86_
        TCHAR diskID[4];
        wsprintf (diskID, TEXT("d%u"), MLSDiskID);
#endif
        while((DirSymbol = InfGetFieldByIndex(Inf,SectionName,Count,0))
           && ((LPCTSTR)SourceName = InfGetFieldByIndex(Inf,SectionName,Count,1))) {

            if( Cancelled == TRUE ) {
                //
                // The user is trying to exit, and the clean up code
                // is waiting for us to finish.  Break out.
                //
                break;
            }
#ifdef _X86_
            if (MLSDiskID) {
                //
                //restrict copy to files on this disk only
                //
                if (_tcsicmp (diskID, DirSymbol) != 0) {
                    Count++;
                    continue;
                }
            }
#endif
            // If the file is present in drvindex.inf and not in the
            // [ForceCopyDriverCabFiles] section then don't add it to the copylist


            //
            // This is the section in dosnet.inf that we cross check against when making the filelists.
            // Files in this section are in the driver cab and also should reside in the local source
            // The idea here is that these files are once that are not in the FloppyFiles.x sections and yet
            // need to remain outside the driver cab.
            //


            if( DoDriverCabPruning){

                if (FileToBeCopied( DriverCacheStringTable, SourceName )){
                    Count++;
                    continue;
                }

            }


            TargetName = InfGetFieldByIndex(Inf,SectionName,Count,2);

            Directory = LookUpDirectory(CopyList,DirSymbol);
            if(!Directory) {
                *ErrorLine = Count;
                Err = ERROR_INVALID_DATA;
                DebugLog (Winnt32LogError, TEXT("ERROR: Could not look up directory errorline = %1!u!"), 0, Count);
                goto cleanup;
            }

            Count++;

            if(NumberOfLicensedProcessors
            && !(FileFlags & FILE_NEED_TO_FREE_SOURCENAME)
            && !TargetName
            && !lstrcmpi(SourceName,TEXT("SETUPREG.HIV"))) {

                b = TRUE;
                TargetName = MALLOC(20*sizeof(TCHAR));
                if(!TargetName) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto cleanup;
                }
                wsprintf((PVOID)TargetName,TEXT("IDW\\SETUP\\SETUP%uP.HIV"),NumberOfLicensedProcessors);

                p = AddFile(
                        CopyList,
                        TargetName,
                        SourceName,
                        Directory,
                        FileFlags | FILE_NEED_TO_FREE_SOURCENAME,
                        0
                        );
            } else {
                p = AddFile(
                        CopyList,
                        SourceName,
                        TargetName,
                        Directory,
                        FileFlags,
                        0
                        );
            }

            if(!p) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
        }
    }

cleanup:

    if( DriverCacheStringTable )
        pSetupStringTableDestroy( DriverCacheStringTable );

    if( DoDriverCabPruning){
        pSetupUninitializeUtils();
    }

    return(Err);
}


PDIR
AddDirectory(
    IN     LPCTSTR    InfSymbol,    OPTIONAL
    IN OUT PCOPY_LIST CopyList,
    IN     LPCTSTR    SourceName,
    IN     LPCTSTR    TargetName,   OPTIONAL
    IN     UINT       Flags
    )

/*++

Routine Description:

    Add a directory to a copy list.

    No attempt is made to eliminate duplicates.

    Directories will be listed in the copy list in the order in which they
    were added.

Arguments:

    InfSymbol - if specified, supplies the symbol from the [Directories]
        section of the master inf that identifies the directory. This pointer
        is used as-is; no copy of the string is made.

    CopyList - supplies the copy list to which the directory is added.

    SourceName - supplies name of directory on the source. If the
        DIR_NEED_TO_FREE_SOURCENAME flag is set in the Flags parameter then
        a copy is made of this string, otherwise this pointer is used as-is
        in the copy list.

    TargetName - if specified, supplies the name for the directory on the
        target. This name is used as-is (no copy is made). If not specified
        then the target name is the same as the source name.

    Flags - supplies flags that control the directory's entry in
        the copy list.

Return Value:

    If successful,  returns a pointer to the new FIL structure for the file.
    Otherwise returns NULL (the caller can assume out of memory).

--*/

{
    PDIR dir;
    PDIR x;
    PDIR p;

    //
    // We assume the directory isn't already in the list.
    // Make a copy of the directory string and stick it in a DIR struct.
    //
    dir = MALLOC(sizeof(DIR));
    if(!dir) {
        return(NULL);
    }
    ZeroMemory(dir,sizeof(DIR));

    if(Flags & DIR_NEED_TO_FREE_SOURCENAME) {
        dir->SourceName = DupString(SourceName);
        if(!dir->SourceName) {
            FREE(dir);
            return(NULL);
        }
    } else {
        dir->SourceName = SourceName;
    }

    dir->InfSymbol = InfSymbol;
    dir->TargetName = TargetName ? TargetName : dir->SourceName;
    dir->Flags = Flags;

    DebugLog(
        Winnt32LogDetailedInformation,
        NULL,
        MSG_LOG_ADDED_DIR_TO_COPY_LIST,
        dir->SourceName,
        dir->TargetName,
        dir->InfSymbol ? dir->InfSymbol : TEXT("-")
        );
#ifndef SLOWER_WAY
    p = CopyList->Directories;

    if (p) {

        dir->Prev = p->Prev;
        dir->Next = NULL;
        p->Prev->Next = dir;
        p->Prev = dir;

    } else {
        CopyList->Directories = dir;
        dir->Prev = dir;
        dir->Next = NULL;
    }
#else
    if(CopyList->Directories) {
        //
        // Preserve order.
        //
        for(p=CopyList->Directories; p->Next; p=p->Next) {
            ;
        }
        p->Next = dir;
    } else {
        CopyList->Directories = dir;
    }
#endif

    CopyList->DirectoryCount++;
    return(dir);
}


PFIL
AddFile(
    IN OUT PCOPY_LIST CopyList,
    IN     LPCTSTR    SourceFilename,
    IN     LPCTSTR    TargetFilename,   OPTIONAL
    IN     PDIR       Directory,
    IN     UINT       Flags,
    IN     ULONGLONG  FileSize          OPTIONAL
    )

/*++

Routine Description:

    Add a single file to a copy list, noting which directory the file
    is in as well as any flags, etc.

    No attempt is made to eliminate duplicates.

    Files will be listed in the copy list in the order in which they
    were added.

Arguments:

    CopyList - supplies the copy list to which the file is added.

    SourceFilename - supplies the name of the file to be added. If the
        FILE_NEED_TO_FREE_SOURCENAME argument is specified, then this
        string is duplicated. Otherwise it is not duplicated and this
        pointer is stored directly in the copy list node.

   TargetFilename - if specified, then the file has a different name on
        the target than on the source and this is its name on the target.
        This pointer is stored as-is in the copy list node; no copy is made.

    Directory - supplies a pointer to the directory structure for the
        directory in which the file lives.

    Flags - supplies FILE_xxx flags to control the file's entry in the list.

    FileSize - if specified, supplies the size of the file.

Return Value:

    If successful,  returns a pointer to the new FIL structure for the file.
    Otherwise returns NULL (the caller can assume out of memory).

--*/

{
    PFIL fil;
    PFIL p;
    TCHAR FlagsText[500];
    TCHAR SizeText[256];

    //
    // Make a new FIL struct.
    //
    fil = MALLOC(sizeof(FIL));
    if(!fil) {
        return(NULL);
    }
    ZeroMemory(fil,sizeof(FIL));

    if(Flags & FILE_NEED_TO_FREE_SOURCENAME) {
        fil->SourceName = DupString(SourceFilename);
        if(!fil->SourceName) {
            FREE(fil);
            return(NULL);
        }
    } else {
        fil->SourceName = SourceFilename;
    }

    fil->TargetName = TargetFilename ? TargetFilename : fil->SourceName;
    fil->Directory = Directory;
    fil->Flags = Flags;
    fil->Size = FileSize;

    if (Winnt32LogDetailedInformation < DebugLevel) {
        wsprintf(FlagsText,TEXT("0x%x"),Flags);
        if(Flags & FILE_ON_SYSTEM_PARTITION_ROOT) {
            lstrcat(FlagsText,TEXT(" FILE_ON_SYSTEM_PARTITION_ROOT"));
        }
#if defined(REMOTE_BOOT)
        if(Flags & FILE_ON_MACHINE_DIRECTORY_ROOT) {
            lstrcat(FlagsText,TEXT(" FILE_ON_MACHINE_DIRECTORY_ROOT"));
        }
#endif // defined(REMOTE_BOOT)
        if(Flags & FILE_IN_LOCAL_BOOT) {
            lstrcat(FlagsText,TEXT(" FILE_IN_LOCAL_BOOT"));
        }
        if(Flags & FILE_PRESERVE_COMPRESSED_NAME) {
            lstrcat(FlagsText,TEXT(" FILE_PRESERVE_COMPRESSED_NAME"));
        }
        if(Flags & FILE_DECOMPRESS) {
            lstrcat(FlagsText,TEXT(" FILE_DECOMPRESS"));
        }
        if (Flags & FILE_IGNORE_COPY_ERROR) {
            lstrcat (FlagsText, TEXT("FILE_IGNORE_COPY_ERROR"));
        }

        if (!GetUserPrintableFileSizeString(
                            fil->Size,
                            SizeText,
                            sizeof(SizeText)/sizeof(TCHAR))) {
            lstrcpy( SizeText, TEXT("0"));
        }


        DebugLog(
            Winnt32LogDetailedInformation,
            NULL,
            MSG_LOG_ADDED_FILE_TO_COPY_LIST,
            fil->SourceName,
            Directory->SourceName,
            SizeText,
            fil->TargetName,
            FlagsText
            );
    }

#ifndef SLOWER_WAY
    p = CopyList->Files;

    if (p) {

        fil->Prev = p->Prev;
        fil->Next = NULL;
        p->Prev->Next = fil;
        p->Prev = fil;

    } else {
        CopyList->Files = fil;
        fil->Prev = fil;
        fil->Next = NULL;
    }

#else
    //
    // Hook into copy list. Preserve order.
    //
    if(CopyList->Files) {
        for(p=CopyList->Files; p->Next; p=p->Next) {
            ;
        }
        p->Next = fil;
    } else {
        CopyList->Files = fil;
    }
#endif
    CopyList->FileCount++;
    return(fil);
}


BOOL
RemoveFile (
    IN OUT  PCOPY_LIST CopyList,
    IN      LPCTSTR SourceName,
    IN      PDIR Directory,             OPTIONAL
    IN      DWORD SetFlags              OPTIONAL
    )

/*++

Routine Description:

    Add a single file to a copy list, noting which directory the file
    is in as well as any flags, etc.

    No attempt is made to eliminate duplicates.

    Files will be listed in the copy list in the order in which they
    were added.

Arguments:

    CopyList - supplies the copy list to which the file is added.

    SourceFilename - supplies the name of the file to be added. If the
        FILE_NEED_TO_FREE_SOURCENAME argument is specified, then this
        string is duplicated. Otherwise it is not duplicated and this
        pointer is stored directly in the copy list node.

   TargetFilename - if specified, then the file has a different name on
        the target than on the source and this is its name on the target.
        This pointer is stored as-is in the copy list node; no copy is made.

    Directory - supplies a pointer to the directory structure for the
        directory in which the file lives.

    Flags - supplies FILE_xxx flags to control the file's entry in the list.

    FileSize - if specified, supplies the size of the file.

Return Value:

    If successful,  returns a pointer to the new FIL structure for the file.
    Otherwise returns NULL (the caller can assume out of memory).

--*/

{
    PFIL p;

    for (p = CopyList->Files; p; p = p->Next) {

        if (_tcsicmp (p->SourceName, SourceName) == 0 &&
            (!Directory || Directory == p->Directory) &&
            ((p->Flags & SetFlags) == SetFlags)
            ) {
            p->Flags |= FILE_DO_NOT_COPY;
            return TRUE;
        }
    }

    return FALSE;
}

PDIR
LookUpDirectory(
    IN PCOPY_LIST CopyList,
    IN LPCTSTR    DirSymbol
    )

/*++

Routine Description:

    Looks for an entry for a directory in a copy list that matches
    a given INF symbol.

Arguments:

    CopyList - supplies the copy list in which the directory is to be
        searched for.

    DirSymbol - supplies the symbol that is expected to match an entry in
        the main inf's [Directories] section.

Return Value:

    If the dir is found then the return value is a pointer to the
    directory node in the copy list. Otherwise NULL is returned.

--*/

{
    PDIR dir;

    for(dir=CopyList->Directories; dir; dir=dir->Next) {

        if(dir->InfSymbol && !lstrcmpi(dir->InfSymbol,DirSymbol)) {
            return(dir);
        }
    }

    return(NULL);
}


VOID
TearDownCopyList(
    IN OUT PCOPY_LIST CopyList
    )

/*++

Routine Description:

    Deletes a copy list and frees all associated memory.

Arguments:

    CopyList - supplies a pointer to the copy list structure for the
        copy list to be freed. The COPY_LIST struct itself is NOT freed
        but all fields in it are zeroed out.

Return Value:

    None.

--*/

{
    PDIR dir;
    PFIL fil;
    PVOID p;

    dir = CopyList->Directories;
    while(dir) {
        p = dir->Next;

        //
        // Free the source if necessary; the target never needs
        // to be freed since the AddDirectory routine never makes
        // a copy of the target name.
        //
        if(dir->SourceName && (dir->Flags & DIR_NEED_TO_FREE_SOURCENAME)) {
            FREE((PVOID)dir->SourceName);
        }

        FREE(dir);
        dir = p;
    }

    fil = CopyList->Files;
    while(fil) {
        p = fil->Next;

        //
        // Free the source if necessary; the target never needs
        // to be freed since the AddFile routine never makes
        // a copy of the target name.
        //
        if(fil->SourceName && (fil->Flags & FILE_NEED_TO_FREE_SOURCENAME)) {
            FREE((PVOID)fil->SourceName);
        }

        FREE(fil);
        fil = p;
    }

    ZeroMemory(CopyList,sizeof(COPY_LIST));
}


BOOL
GetMainInfValue (
    IN      PCTSTR Section,
    IN      PCTSTR Key,
    IN      DWORD FieldNumber,
    OUT     PTSTR Buffer,
    IN      DWORD BufChars
    )
{
    PCTSTR p;
    PTSTR end;

    if (MainInf) {
        p = InfGetFieldByKey (MainInf, Section, Key, FieldNumber);
        if (p) {
            lstrcpyn (Buffer, p, BufChars);
        }
        return p != NULL;
    }
    if (!FullInfName[0]) {
        if (!FindPathToWinnt32File (InfName, FullInfName, MAX_PATH)) {
            return FALSE;
        }
    }
    if (!GetPrivateProfileString (
                    Section,
                    Key,
                    TEXT(""),
                    Buffer,
                    BufChars,
                    FullInfName
                    )) {
        return FALSE;
    }

    MYASSERT (FieldNumber <= 1);

    end = _tcschr (Buffer, TEXT(','));
    if (FieldNumber == 1) {
        if (!end) {
            return FALSE;
        }
        lstrcpy (Buffer, end + 1);
    } else {
        if (end) {
            *end = 0 ;
        }
    }

    return TRUE;
}


BOOL
CheckCopyListSpace(
    IN  TCHAR     DriveLetter,
    IN  DWORD     BytesPerCluster,
    IN  LONGLONG  FreeSpace,
    OUT DWORD    *RequiredMB,
    IN  BOOL      CheckBootFiles,
    IN  BOOL      CheckLocalSource,
    IN  BOOL      CheckWinntDirectorySpace,
    IN  BOOL      QuickTest,
    IN  LONGLONG  AdditionalPadding
    )

/*++

Routine Description:

    This routine scans the master copy list and determines, based on cluster
    size, whether the drive contains enough space to hold the files in
    that list.

    Note that the check is not exact because we can't predict exactly how
    much space the directories themselves might occupy, and we assume that
    none of the files already exist on the target, which is not always true
    (for example ntldr, ntdetect.com, etc, which are already on C:\ in the
    x86 case). We fudge by adding a meg to the requirements.

Arguments:

    DriveLetter - supplies the drive letter of the drive being checked.
        The FILE_ON_SYSTEM_PARTITION_ROOT and FILE_IN_LOCAL_BOOT flags
        for nodes in the copy list require special handling based on the
        drive letter of the drive being scanned.

    BytesPerCluster - specifies the number of bytes per cluster
        on the drive.

    FreeSpace - supplies the number of free bytes on the drive.

    RequiredMB - receives the amount of space required on this drive, in MB.

    CheckLocalSource - Do we need to check for space on this drive for
                       copying all the source local?

    CheckBootFiles - Do we need to check for space on this drive for
                     copying all the boot files?

    CheckWinntDirectorySpace - Do we need to add in the space required
                               for the final winnt directory?

Return Value:

    If TRUE then the drive has enough space on it to hold the files
    listed in the copy list. If FALSE then it does not.

--*/

{
    PFIL File;
    LONGLONG SpaceRequired = 0;
    LONGLONG SpaceLocalSource = 0;
    LONGLONG SpaceBootFiles = 0;
    LONGLONG SpacePadding = 0;
    LONGLONG SpaceWinDir = 0;
    LONGLONG RoundedSize;
    TCHAR ClusterSizeString[64];
    TCHAR buffer[64];
    PTSTR p;


    if( BytesPerCluster <= 512 ) {
        lstrcpy( ClusterSizeString,TEXT("TempDirSpace512") );
    } else if( BytesPerCluster > (256 * 1024) ) {
        lstrcpy( ClusterSizeString, TEXT("TempDirSpace32K") );
    } else {
        wsprintf(ClusterSizeString,TEXT("TempDirSpace%uK"),BytesPerCluster/1024);
    }

    //
    // ====================================================
    // If appropriate, add in space needs for the ~LS directory.
    // ====================================================
    //
    if( CheckLocalSource ) {

    BOOL WantThisFile;

        //
        // If we're checking local source, there are so many files that
        // we're going to add in a small fudge factor.
        //
        SpacePadding = AdditionalPadding;
        SpaceLocalSource = 1000000 + AdditionalPadding;


        //
        // Dosnet.inf has sizing info for each possible cluster size.
        // That info tells us how much the files in the [Files] section
        // take up on a drive with that cluster size. That's really
        // handy because then we don't have to hit the sources to actually
        // fetch each file's size.
        //
        // But the inf doesn't include optional directories, so we need to
        // traverse the copy list and add up all the (rounded) sizes, and
        // then add the total to the value from the inf.
        //
        // When we built the copy list, the files in the [Files] section
        // wound up with a Size of 0 since we don't go out to the source
        // to get the size. The files that were in optional dirs have their
        // actual sizes filled in. This allows us to do something a little
        // funky: we traverse the entire list without regard for whether a
        // file was in the [Files] section or was in an optional dir, since
        // the "0-size" files don't hose up the calculation. Then we add
        // that value to the relevent value from the inf.
        //
        for(File=MasterCopyList.Files; File; File=File->Next) {

            if(File->Flags & (FILE_IN_LOCAL_BOOT | FILE_ON_SYSTEM_PARTITION_ROOT
#if defined(REMOTE_BOOT)
                                | FILE_ON_MACHINE_DIRECTORY_ROOT
#endif // defined(REMOTE_BOOT)
                             )) {
                //
                // Special handling based on the system partition.
                //
                WantThisFile = CheckBootFiles;
            } else {
                WantThisFile = CheckLocalSource;
            }

            if(WantThisFile) {

                if(File->Size % BytesPerCluster) {
                    RoundedSize = File->Size + (BytesPerCluster - (DWORD)(File->Size % BytesPerCluster));
                } else {
                    RoundedSize = File->Size;
                }

                SpaceLocalSource += RoundedSize;
            }
        }

        //
        // If appropriate, add in space needs for the ~LS directory.
        // Note that we go ahead an calculate LocalSourceSpace because
        // we may need that later on.
        //
        if (GetMainInfValue (szDiskSpaceReq, ClusterSizeString, 0, buffer, 64) ||
            //
            // Strange cluster size or inf is broken. Try to use a default of 512
            // since that most closely approximates the actual size of the files.
            //
            GetMainInfValue (szDiskSpaceReq, TEXT("TempDirSpace512"), 0, buffer, 64)
            ) {
            SpaceLocalSource += _tcstoul(buffer,NULL,10);
        } else {
            //
            //
        }
    }

    //
    // ====================================================
    // If appropriate, add in space needs for the ~BT directory.
    // ====================================================
    //
    if( CheckBootFiles ) {

        if( !IsArc() ) {
            //
            // Go get the space requirements for the boot files
            // from dosnet.inf.
            //
            if (GetMainInfValue (szDiskSpaceReq, ClusterSizeString, 1, buffer, 64)) {
                SpaceBootFiles += _tcstoul(buffer,NULL,10);
            } else {
                //
                // Guess about 5Mb for x86 because we need the entire
                // ~BT directory.
                //
                SpaceBootFiles += (5*1024*1024);
            }
        } else {
            //
            // Guess that we'll need about 1.5Mb for ARC.
            // We can't assume that this will go to 0x0 just
            // because we're doing an upgrade because we might
            // be going from 4.0 to 5.0 (for example).  In this
            // case we will create a new directory under the
            // \os tree to hold the hal, osloader, ...
            //
            SpaceBootFiles += (3*512*1024);
        }

    }

    //
    // ====================================================
    // If appropriate, add in space needs for the install directory.
    // ====================================================
    //
    // Note: This is for upgrade.
    //       We also need to take in account the space requirements for Program Files, Documents and Settings

    if( CheckWinntDirectorySpace ) {

        if( BytesPerCluster <= 512 ) {
            lstrcpy( ClusterSizeString,TEXT("WinDirSpace512") );
        } else if( BytesPerCluster > (256 * 1024) ) {
            lstrcpy( ClusterSizeString, TEXT("WinDirSpace32K") );
        } else {
            wsprintf(ClusterSizeString,TEXT("WinDirSpace%uK"),BytesPerCluster/1024);
        }

        //
        // First we figure out how much a fresh install might take.
        //
        if (GetMainInfValue (szDiskSpaceReq, ClusterSizeString, 0, buffer, 64)) {
            //
            // Multiply him by 1024 because the values in
            // txtsetup.sif are in Kb instead of bytes.
            //
            SpaceWinDir += (_tcstoul(buffer,NULL,10) * 1024);
        } else {
            // guess...
            SpaceWinDir += (924 * (1024 * 1024));
        }

        // Lets take into account Program Files
        if (GetMainInfValue (szDiskSpaceReq, szPFDocSpaceReq, 0, buffer, 64)) {
            //
            // Multiply him by 1024 because the values are in Kb instead of bytes.
            //
            SpaceWinDir += (_tcstoul(buffer,NULL,10) * 1024);
        } else {
            // guess...
            SpaceWinDir += (WINDOWS_DEFAULT_PFDOC_SIZE * 1024);
        }


        WinDirSpaceFor9x = SpaceWinDir;

        if( Upgrade ) {

        LPCTSTR q = 0;

            //
            // We're upgrading, so we need to figure out which
            // build we're running, then subtract off how much
            // a clean install of that build would have taken.
            // This will give us an idea of how much the %windir%
            // will grow.
            //

            if( ISNT() ) {
                BOOL b;
                //
                // NT case.
                //

                if( BuildNumber <= NT351 ) {
                    b = GetMainInfValue (szDiskSpaceReq, TEXT("351WinDirSpace"), 0, buffer, 64);
                } else if( BuildNumber <= NT40 ) {
                    b = GetMainInfValue (szDiskSpaceReq, TEXT("40WinDirSpace"), 0, buffer, 64);
                } else if( BuildNumber <= NT50 ) {
                    b = GetMainInfValue (szDiskSpaceReq, TEXT("50WinDirSpace"), 0, buffer, 64);
                } else {
                    b = GetMainInfValue (szDiskSpaceReq, TEXT("51WinDirSpace"), 0, buffer, 64);
                }

                if( b ) {
                    //
                    // Multiply him by 1024 because the values in
                    // dosnet.inf are in Kb instead of bytes.
                    //
                    SpaceWinDir -= (_tcstoul(buffer,NULL,10) * 1024);
                }


                if( BuildNumber <= NT351 ) {
                    b = GetMainInfValue (szDiskSpaceReq, TEXT("351PFDocSpace"), 0, buffer, 64);
                } else if( BuildNumber <= NT40 ) {
                    b = GetMainInfValue (szDiskSpaceReq, TEXT("40PFDocSpace"), 0, buffer, 64);
                } else if( BuildNumber <= NT50 ) {
                    b = GetMainInfValue (szDiskSpaceReq, TEXT("50PFDocSpace"), 0, buffer, 64);
                } else {
                    b = GetMainInfValue (szDiskSpaceReq, TEXT("51PFDocSpace"), 0, buffer, 64);
                }
                if( b ) {
                    //
                    // Multiply him by 1024 because the values are in Kb instead of bytes.
                    //
                    SpaceWinDir -= (_tcstoul(buffer,NULL,10) * 1024);
                }
                //
                // Make sure we don't look bad...
                // At 85 MB, we are near the border line of gui-mode having enough space to run.
                // note:during gui-mode, there is 41MB pagefile
                //
                //
                if( SpaceWinDir < 0 ) {
                    SpaceWinDir = (90 * (1024*024));
                }

            } else {
                //
                // Win9X case.
                //

                //
                // Note that the Win9X upgrade DLL can do a much better job of
                // determining disk space requirements for the %windir% than
                // I can.  We'll bypass this check if we're not on NT.
                // But, we need about 50MB disk space to run Win9x upgrage.
                //
                SpaceWinDir = 50<<20; //50MB
            }

        } // Upgrade

    } // CheckWinntDirectorySpace

    SpaceRequired = SpaceLocalSource + SpaceBootFiles + SpaceWinDir;
    if( CheckLocalSource ) {
        //
        // We need to remember how much space will be
        // required on the drive where we place the ~LS
        // directory because we send that to the upgrade
        // dll.
        //
        LocalSourceSpaceRequired = SpaceRequired;
    }

    *RequiredMB = (DWORD)((SpaceRequired+1048575) / (1024*1024));
    DebugLog( QuickTest ? Winnt32LogDetailedInformation : Winnt32LogError, NULL, MSG_LOG_DISKSPACE_CHECK,
              DriveLetter,
              (ULONG)BytesPerCluster,
              (ULONG)(FreeSpace / (1024*1024)),
              (ULONG)((SpaceLocalSource+1048575) / (1024*1024)),
              (ULONG)(SpacePadding / (1024*1024)),
              (ULONG)((SpaceBootFiles+1048575) / (1024*1024)),
              (ULONG)((SpaceWinDir+1048575) / (1024*1024)),
              (ULONG)*RequiredMB

              );



    return(SpaceRequired <= FreeSpace);
}

#define VALID_DRIVE (32)
#define INVALID_DRIVE (64)
#define NOT_ENOUGH_SPACE (128)

ULONG
CheckASingleDrive(
    IN  TCHAR     DriveLetter,               OPTIONAL
    IN  PCTSTR    NtVolumeName,              OPTIONAL
    OUT DWORD     *ClusterSize,
    OUT DWORD     *RequiredMb,
    OUT DWORD     *AvailableMb,
    IN  BOOL      CheckBootFiles,
    IN  BOOL      CheckLocalSource,
    IN  BOOL      CheckFinalInstallDir,
    IN  BOOL      QuickTest,
    IN  LONGLONG  AdditionalPadding
    )

/*++

Routine Description:

    This routine examines a specific drive for its potential to hold
    some or all of the install files.

    First he runs through a series of checks to make sure the drive
    is appropriate.  If we get through all of those, we go check for
    drive space requirements.

Arguments:

    DriveLetter - supplies the drive letter of the drive being checked;
                  may be 0 only if NtVolumeName is specified instead

    NtVolumeName - supplies the NT device name of the drive being checked;
                  only used if DriveLetter is not specified

    ClusterSize - the clustersize on the we'll check.

    RequiredSpace - receives the amount of space required on this drive.

    AvailableSpace - receives the number of free bytes on the drive.

    CheckBootFiles - Do we need to check for space on this drive for
                     copying all the boot files?

    CheckLocalSource - Do we need to check for space on this drive for
                       copying all the source local?

    CheckFinalInstallDir - Do we need to add in the space required
                           for the final winnt directory?

Return Value:

    NOT_ENOUGH_SPACE - RequiredSpace > AvailableSpace

    INVALID_DRIVE - The drive is inappropriate for holding install
                    source.  E.g. it's a floppy, ...

    VALID_DRIVE - The drive is appropriate for holding install source
                  AND RequiredSpace < AvailableSpace

--*/

{
    TCHAR       DriveName[MAX_PATH];
    TCHAR       Filesystem[256];
    TCHAR       VolumeName[MAX_PATH];
    DWORD       SerialNumber;
    DWORD       MaxComponent;
    DWORD       Flags;
    DWORD       SectorsPerCluster;
    DWORD       BytesPerSector;
    ULARGE_INTEGER FreeClusters = {0, 0};
    ULARGE_INTEGER TotalClusters = {0, 0};
    BOOL        b;
    LONGLONG    AvailableBytes;
    DWORD       DriveType;

    MYASSERT (DriveLetter || ISNT());
    if (!(DriveLetter || ISNT())) {
        return DRIVE_UNKNOWN;
    }

    if (DriveLetter) {
        DriveName[0] = DriveLetter;
        DriveName[1] = TEXT(':');
        DriveName[2] = TEXT('\\');
        DriveName[3] = 0;
    } else {
#ifdef UNICODE
        MYASSERT (NtVolumeName);
#else
        MYASSERT (FALSE);
        return ( DRIVE_UNKNOWN );
#endif
    }

    //
    // ====================================================
    // Check for appropriate drive.
    // ====================================================
    //

    //
    // Disallow a set of drives...
    //
    if (DriveLetter) {
        DriveType = MyGetDriveType(DriveLetter);
        if(DriveType == DRIVE_UNKNOWN ||
           DriveType == DRIVE_RAMDISK ||
           DriveType == DRIVE_NO_ROOT_DIR
           ) {
            return( DRIVE_UNKNOWN );
        }
    } else {
#ifdef UNICODE
        DriveType = MyGetDriveType2(NtVolumeName);
        if(DriveType == DRIVE_UNKNOWN ||
           DriveType == DRIVE_RAMDISK ||
           DriveType == DRIVE_NO_ROOT_DIR
           ) {
            return( DRIVE_UNKNOWN );
        }
#endif
    }

    //
    // Check drive type. Skip anything but hard drives.
    //
    if( CheckLocalSource) {
        if (DriveLetter) {
            if (MyGetDriveType(DriveLetter) != DRIVE_FIXED) {
                if (!QuickTest) {
                    DebugLog(
                        Winnt32LogInformation,
                        NULL,
                        MSG_LOG_DRIVE_NOT_HARD,
                        DriveLetter
                        );
                }
                return( INVALID_DRIVE );
            }
        } else {
#ifdef UNICODE
            if (MyGetDriveType2(NtVolumeName) != DRIVE_FIXED) {
                if (!QuickTest) {
                    DebugLog(
                        Winnt32LogInformation,
                        NULL,
                        MSG_LOG_DRIVE_NOT_HARD2,
                        NtVolumeName
                        );
                }
                return( INVALID_DRIVE );
            }
#endif
        }
    }

    //
    // Get filesystem. HPFS is disallowed. We make this check because
    // HPFS was still supported in NT3.51 and we have to upgrade NT 3.51.
    // Strictly speaking this check is not required on win95 but there's
    // no reason not to execute it either, so we avoid the #ifdef's.
    //
    if (DriveLetter) {
        b = GetVolumeInformation(
                DriveName,
                VolumeName,MAX_PATH,
                &SerialNumber,
                &MaxComponent,
                &Flags,
                Filesystem,
                sizeof(Filesystem)/sizeof(TCHAR)
                );

        if(!b || !lstrcmpi(Filesystem,TEXT("HPFS"))) {
            DebugLog(
                Winnt32LogInformation,
                NULL,
                MSG_LOG_DRIVE_NO_VOL_INFO,
                DriveLetter
                );
            return( INVALID_DRIVE );
        }
    }

    //
    // Check for FT and firmware accessibility. We rely on the underlying
    // routines to do the right thing on Win95.
    //
    // In the upgrade case, we can put the local source on an NTFT drive.
    //
    // Note that we can't do this for Alpha / ARC.
    //

    if( ( IsArc() || !Upgrade ) && IsDriveNTFT(DriveLetter, NtVolumeName) ) {
        if (!QuickTest) {
            DebugLog(Winnt32LogInformation,NULL,MSG_LOG_DRIVE_NTFT,DriveLetter);
        }
        return( INVALID_DRIVE );
    }

    //  Don't allow $win_nt$.~ls to go on a soft partition, because the
    //  loader/textmode won't be able to find such partitions.
    //
    if(IsSoftPartition(DriveLetter, NtVolumeName)) {
        if (!QuickTest) {
            DebugLog(Winnt32LogInformation,NULL,MSG_LOG_DRIVE_VERITAS,DriveLetter);
        }
        return( INVALID_DRIVE );
    } // if (IsArc() ...)

#ifdef  _X86_
    if( !ISNT() ) {
        //
        // If we're running on win95, then make sure we skip
        // any compressed volumes.
        //
        if( Flags & FS_VOL_IS_COMPRESSED) {
            return( INVALID_DRIVE );
        }
    }
#endif

    if (IsArc() && DriveLetter) {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
        LPWSTR ArcPath;

        if(DriveLetterToArcPath (DriveLetter,&ArcPath) != NO_ERROR) {
            if (!QuickTest) {
                DebugLog(Winnt32LogInformation,NULL,MSG_LOG_DRIVE_NO_ARC,DriveLetter);
            }
            return( INVALID_DRIVE );
        }
        FREE(ArcPath);
#endif // UNICODE
    }

    //
    // Finally, get cluster size on the drive and free space stats.
    // Then go through the copy list and figure out whether the drive
    // has enough space.
    //
    if (DriveLetter) {
        b = GetDiskFreeSpaceNew(
                DriveName,
                &SectorsPerCluster,
                &BytesPerSector,
                &FreeClusters,
                &TotalClusters
                );
    } else {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
        b = MyGetDiskFreeSpace (
                NtVolumeName,
                &SectorsPerCluster,
                &BytesPerSector,
                &FreeClusters.LowPart,
                &TotalClusters.LowPart
                );
#endif // UNICODE
    }

    if(!b) {
        if (!QuickTest) {
            DebugLog(Winnt32LogWarning,NULL,MSG_LOG_DRIVE_CANT_GET_SPACE,DriveLetter,GetLastError());
        }
        return( INVALID_DRIVE );
    }

    //
    // Fill in some return parameters that are also helpful for the
    // next function call.
    //
    *ClusterSize = BytesPerSector * SectorsPerCluster;
    AvailableBytes = (LONGLONG)(*ClusterSize) * FreeClusters.QuadPart;
    *AvailableMb = (ULONG)(AvailableBytes / (1024 * 1024));

    if( CheckCopyListSpace( DriveLetter,
                            *ClusterSize,
                            AvailableBytes,
                            RequiredMb,
                            CheckBootFiles,
                            CheckLocalSource,
                            CheckFinalInstallDir,
                            QuickTest,
                            AdditionalPadding) ) {
        return( VALID_DRIVE );
    } else {
        return( NOT_ENOUGH_SPACE );
    }

}


BOOL
FindLocalSourceAndCheckSpaceWorker(
    IN HWND hdlg,
    IN BOOL QuickTest,
    IN LONGLONG  AdditionalPadding
    )

/*++

Routine Description:

    Based on the master copy list, determine which drive has enough space
    to contain the local source. The check is sensitive to the cluster
    size on each drive.

    The alphabetically lowest local drive that is accessible from the firmware,
    not HPFS, not FT, and has enough space gets the local source.

Arguments:

    hdlg - supplies the window handle of the window which will own
        any UI displayed by this routine.

Return Value:

    Boolean value indicating outcome. If FALSE, the user will have been
    informed about why. If TRUE, global variables are set up:

        LocalSourceDrive
        LocalSourceDirectory
        LocalSourceWithPlatform

    If the global flag BlockOnNotEnoughSpace is set to FALSE, this routine
    will return TRUE regardless of wether or not a suitable drive was found.
    It is up to whoever sets this flag to ensure that this is the correct behavior.

--*/

{
TCHAR       DriveLetter = 0;
TCHAR       WinntDriveLetter = 0;
TCHAR       MyLocalSourceDrive = 0;
BOOL        MakeBootSource = FALSE;
ULONG       CheckResult;
ULONG       ClusterSize;
ULONG       RequiredMb;
ULONG       AvailableMb;
LPCTSTR     q = 0;
TCHAR       platform[MAX_PATH];


    //
    // ====================================================
    // Check the system partition and make sure we can place any
    // boot files we need.
    // ====================================================
    //

    //
    // Will we be creating a $WIN_NT$.~BT directory?
    // On ARC we still check for this space even if we don't need it, just in case.
    // there should always be at least 5M free on the system partition...
    //
    if( IsArc() || ((MakeBootMedia) && (Floppyless)) )
    //
    // RISC always requires a small amount of space on the system
    // partition because we put the loader, hal, and (in the case
    // of ALPHA) the pal code.
    //
    {
        if (!QuickTest) {
            DebugLog( Winnt32LogInformation,
                      TEXT( "\r\n\r\nExamining system partition for adequate space for temporary boot files.\r\n"),
                      0 );
        }

        MakeBootSource = TRUE;

        //
        // use the drive letter
        //
        CheckResult = CheckASingleDrive (
            SystemPartitionDriveLetter,
#ifdef UNICODE
            SystemPartitionNtName,
#else
            NULL,
#endif
            &ClusterSize,
            &RequiredMb,
            &AvailableMb,
            TRUE,     // Check boot files space
            FALSE,    // Check local source space
            FALSE,    // Check final install directory space
            QuickTest,
            AdditionalPadding
            );

        if( CheckResult == NOT_ENOUGH_SPACE ) {

            if (SystemPartitionDriveLetter) {
                if (!QuickTest) {
                    DebugLog(
                        Winnt32LogInformation,
                        NULL,
                        MSG_LOG_SYSTEM_PARTITION_TOO_SMALL,
                        SystemPartitionDriveLetter,
                        AvailableMb,
                        RequiredMb
                        );
                }
            } else {
#ifdef UNICODE
                if (!QuickTest) {
                    DebugLog(
                        Winnt32LogInformation,
                        NULL,
                        MSG_LOG_SYSTEM_PARTITION_TOO_SMALL2,
                        SystemPartitionNtName,
                        AvailableMb,
                        RequiredMb
                        );
                }
#endif
            }

            if( BlockOnNotEnoughSpace) {
                if (!QuickTest) {
                    //
                    // We're dead and the user asked us to stop if we
                    // can't fit, so put up a dialog telling him that
                    // he needs more room on the system partition.
                    //

                    SendMessage(hdlg,WMX_ERRORMESSAGEUP,TRUE,0);

                    if (SystemPartitionDriveLetter) {
                        MessageBoxFromMessage(
                            hdlg,
                            MSG_SYSTEM_PARTITION_TOO_SMALL,
                            FALSE,
                            AppTitleStringId,
                            MB_OK | MB_ICONWARNING,
                            SystemPartitionDriveLetter,
                            RequiredMb
                            );
                    } else {
#ifdef UNICODE
                        MessageBoxFromMessage(
                            hdlg,
                            MSG_SYSTEM_PARTITION_TOO_SMALL2,
                            FALSE,
                            AppTitleStringId,
                            MB_OK | MB_ICONWARNING,
                            SystemPartitionNtName,
                            RequiredMb
                            );
#endif
                    }

                    SendMessage(hdlg,WMX_ERRORMESSAGEUP,FALSE,0);
                }
                return( FALSE );
            }

        } else if( (CheckResult == INVALID_DRIVE) || (CheckResult == DRIVE_UNKNOWN) ) {

            if (!QuickTest) {
                if (SystemPartitionDriveLetter) {
                        DebugLog(
                            Winnt32LogInformation,
                            NULL,
                            MSG_LOG_SYSTEM_PARTITION_INVALID,
                            SystemPartitionDriveLetter
                            );
                } else {
#ifdef UNICODE
                    DebugLog(
                        Winnt32LogInformation,
                        NULL,
                        MSG_LOG_SYSTEM_PARTITION_INVALID2,
                        SystemPartitionNtName
                        );
#endif
                }

                SendMessage(hdlg,WMX_ERRORMESSAGEUP,TRUE,0);

                MessageBoxFromMessage(
                    hdlg,
                    MSG_SYSTEM_PARTITION_INVALID,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL
                    );

                SendMessage(hdlg,WMX_ERRORMESSAGEUP,FALSE,0);
            }

            return( FALSE );

        } else if( CheckResult == VALID_DRIVE ) {

            if (!QuickTest) {
                if (SystemPartitionDriveLetter) {
                    DebugLog(
                        Winnt32LogInformation,
                        NULL,
                        MSG_LOG_SYSTEM_PARTITION_VALID,
                        SystemPartitionDriveLetter
                        );
                } else {
#ifdef UNICODE
                    DebugLog(
                        Winnt32LogInformation,
                        NULL,
                        MSG_LOG_SYSTEM_PARTITION_VALID2,
                        SystemPartitionNtName
                        );
#endif
                }
            }

        }
    }

    //
    // ====================================================
    // Check space for the final installation directory.
    // ====================================================
    //
    if( Upgrade ) {
    TCHAR       Text[MAX_PATH];

        MinDiskSpaceRequired = 0x7FFFFFFF,
        MaxDiskSpaceRequired = 0;

        if (!QuickTest) {
            DebugLog( Winnt32LogInformation,
                      TEXT( "\r\n\r\nExamining disk for adequate space expand the WinDir.\r\n"),
                      0 );
        }

        //
        // Just check the drive where the current installation is.
        //
        MyGetWindowsDirectory( Text, MAX_PATH );
        WinntDriveLetter = Text[0];

        CheckResult = CheckASingleDrive(
                            WinntDriveLetter,
                            NULL,
                            &ClusterSize,
                            &RequiredMb,
                            &AvailableMb,
                            ((WinntDriveLetter == SystemPartitionDriveLetter) && MakeBootSource),
                            FALSE,
                            TRUE,
                            QuickTest,
                            AdditionalPadding
                            );

        if( CheckResult == NOT_ENOUGH_SPACE ) {

            if (!QuickTest) {
                DebugLog( Winnt32LogInformation,
                          NULL,
                          MSG_LOG_INSTALL_DRIVE_TOO_SMALL,
                          WinntDriveLetter,
                          AvailableMb,
                          RequiredMb );
            }

            //
            // If the BlockOnNotEnoughSpace flag is set, then we
            // will throw up a message box and exit setup.
            //
            if (BlockOnNotEnoughSpace) {

                if (!QuickTest) {
                    SendMessage(hdlg,WMX_ERRORMESSAGEUP,TRUE,0);

                    MessageBoxFromMessage(
                        hdlg,
                        MSG_INSTALL_DRIVE_TOO_SMALL,
                        FALSE,
                        AppTitleStringId,
                        MB_OK | MB_ICONWARNING,
                        RequiredMb
                        );

                    SendMessage(hdlg,WMX_ERRORMESSAGEUP,FALSE,0);
                }

                return( FALSE );
            }
        } else if( (CheckResult == INVALID_DRIVE) || (CheckResult == DRIVE_UNKNOWN) ) {

            if (!QuickTest) {
                DebugLog( Winnt32LogInformation,
                          NULL,
                          MSG_LOG_INSTALL_DRIVE_INVALID,
                          WinntDriveLetter );

                SendMessage(hdlg,WMX_ERRORMESSAGEUP,TRUE,0);

                MessageBoxFromMessage(
                    hdlg,
                    MSG_INSTALL_DRIVE_INVALID,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONWARNING,
                    RequiredMb
                    );

                SendMessage(hdlg,WMX_ERRORMESSAGEUP,FALSE,0);
            }

            return( FALSE );
        } else if( CheckResult == VALID_DRIVE ) {


            //
            // We need to make one more check here.  If the user
            // is upgrading a Domain Controller, then he'll likely
            // need another 250Mb of disk space for DCPROMO to run
            // post gui-mode setup.  We need to check for that space
            // here.  If we don't have it, we need to warn the user.
            // Note that we're only going to warn.
            //
            // Also note that we're only going to do this *IF* we
            // would have and enough disk space w/o this check.
            //

            if( (ISDC()) &&
                ((RequiredMb + 250) > AvailableMb) &&
                !QuickTest) {
            int     i;

                i = MessageBoxFromMessage(
                        hdlg,
                        MSG_DCPROMO_DISKSPACE,
                        FALSE,
                        AppTitleStringId,
                        MB_OKCANCEL | MB_ICONEXCLAMATION,
                        ((RequiredMb + 250) - AvailableMb) + 1 );

                if( i == IDCANCEL ) {
                    return( FALSE );
                }

            }

            if (!QuickTest) {
                //
                // Log that we a drive suitable for the install directory.
                //
                DebugLog( Winnt32LogInformation,
                          NULL,
                          MSG_LOG_INSTALL_DRIVE_OK,
                          WinntDriveLetter );
            }
        }
    }

    //
    // ====================================================
    // Check space for the local source (i.e. the ~LS directory).
    // ====================================================
    //
    if( MakeLocalSource ) {

        MinDiskSpaceRequired = 0x7FFFFFFF,
        MaxDiskSpaceRequired = 0;

        if (!QuickTest) {
            DebugLog( Winnt32LogInformation,
                      TEXT( "\r\n\r\nExamining Disks for adequate space for temporary setup files.\r\n"),
                      0 );
        }

        if( UserSpecifiedLocalSourceDrive ) {

            //
            // Just check the drive that the user chose.
            //
            CheckResult = CheckASingleDrive(
                                UserSpecifiedLocalSourceDrive,
                                NULL,
                                &ClusterSize,
                                &RequiredMb,
                                &AvailableMb,
                                ((UserSpecifiedLocalSourceDrive == SystemPartitionDriveLetter) && MakeBootSource),
                                TRUE,     // Check local source space
                                (UserSpecifiedLocalSourceDrive == WinntDriveLetter),  // Check final install directory space.
                                QuickTest,
                                AdditionalPadding
                                );

            if( CheckResult == NOT_ENOUGH_SPACE ) {

                MinDiskSpaceRequired = RequiredMb - 1;
                MaxDiskSpaceRequired = RequiredMb + 1;

                if (!QuickTest) {
                    DebugLog( Winnt32LogInformation,
                              NULL,
                              MSG_LOG_LOCAL_SOURCE_TOO_SMALL,
                              UserSpecifiedLocalSourceDrive,
                              AvailableMb,
                              RequiredMb );

                }
                if( BlockOnNotEnoughSpace) {
                    //
                    // We're dead and the user asked us to stop if we
                    // can't fit, so put up a dialog telling him that
                    // he needs more room.
                    //

                    if (!QuickTest) {
                        SendMessage(hdlg,WMX_ERRORMESSAGEUP,TRUE,0);

                        MessageBoxFromMessage(
                            hdlg,
                            MSG_USER_LOCAL_SOURCE_TOO_SMALL,
                            FALSE,
                            AppTitleStringId,
                            MB_OK | MB_ICONWARNING,
                            UserSpecifiedLocalSourceDrive,
                            (DWORD)MaxDiskSpaceRequired );

                        SendMessage(hdlg,WMX_ERRORMESSAGEUP,FALSE,0);
                    }

                    return( FALSE );
                } else {
                    MyLocalSourceDrive = UserSpecifiedLocalSourceDrive;
                }

            } else if( (CheckResult == INVALID_DRIVE) || (CheckResult == DRIVE_UNKNOWN) ) {

                if (!QuickTest) {
                    DebugLog( Winnt32LogInformation,
                              NULL,
                              MSG_LOG_LOCAL_SOURCE_INVALID,
                              UserSpecifiedLocalSourceDrive );

                    SendMessage(hdlg,WMX_ERRORMESSAGEUP,TRUE,0);

                        MessageBoxFromMessage(
                            hdlg,
                            MSG_USER_LOCAL_SOURCE_INVALID,
                            FALSE,
                            AppTitleStringId,
                            MB_OK | MB_ICONWARNING,
                            UserSpecifiedLocalSourceDrive
                            );

                    SendMessage(hdlg,WMX_ERRORMESSAGEUP,FALSE,0);
                }

                return( FALSE );

            } else if( CheckResult == VALID_DRIVE ) {

                if (!QuickTest) {
                    DebugLog( Winnt32LogInformation,
                              NULL,
                              MSG_LOG_LOCAL_SOURCE_VALID,
                              UserSpecifiedLocalSourceDrive );
                }
                MyLocalSourceDrive = UserSpecifiedLocalSourceDrive;
            }

        } else {

            //
            // Check all drives.
            //
            for( DriveLetter = TEXT('A'); DriveLetter <= TEXT('Z'); DriveLetter++ ) {

                CheckResult = CheckASingleDrive(
                                    DriveLetter,
                                    NULL,
                                    &ClusterSize,
                                    &RequiredMb,
                                    &AvailableMb,
                                    ((DriveLetter == SystemPartitionDriveLetter) && MakeBootSource),
                                    TRUE,     // Check local source space
                                    (DriveLetter == WinntDriveLetter),  // Check final install directory space.
                                    QuickTest,
                                    AdditionalPadding
                                    );

                if( CheckResult == NOT_ENOUGH_SPACE ) {
                DWORD       Size;
                DWORD_PTR   my_args[3];
                TCHAR       Text0[2048];

                    if( MinDiskSpaceRequired > RequiredMb )
                        MinDiskSpaceRequired = RequiredMb;
                    if( MaxDiskSpaceRequired < RequiredMb )
                        MaxDiskSpaceRequired = RequiredMb;

                    if (!QuickTest) {
                        //
                        // Log that we failed the check of this
                        // drive for the local source files.
                        //
                        DebugLog( Winnt32LogInformation,
                                  NULL,
                                  MSG_LOG_LOCAL_SOURCE_TOO_SMALL,
                                  DriveLetter,
                                  AvailableMb,
                                  RequiredMb );

                        //
                        // Log it to a buffer too.
                        //
                        my_args[0] = DriveLetter;
                        my_args[1] = AvailableMb;
                        my_args[2] = RequiredMb;
                        Size = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                              hInst,
                                              MSG_LOG_LOCAL_SOURCE_TOO_SMALL,
                                              0,
                                              Text0,
                                              sizeof(Text0)/sizeof(TCHAR),
                                              (va_list *)my_args );
                        lstrcat( DiskDiagMessage, Text0 );
                    }
                } else if( CheckResult == INVALID_DRIVE ) {
                    if (!QuickTest) {
                    DWORD       Size;
                    DWORD_PTR   my_args[1];
                    TCHAR       Text0[2048];

                        DebugLog( Winnt32LogInformation,
                                  NULL,
                                  MSG_LOG_LOCAL_SOURCE_INVALID,
                                  DriveLetter );

                        //
                        // Log it to a buffer too.
                        //
                        my_args[0] = DriveLetter;
                        Size = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                              hInst,
                                              MSG_LOG_LOCAL_SOURCE_INVALID,
                                              0,
                                              Text0,
                                              sizeof(Text0)/sizeof(TCHAR),
                                              (va_list *)my_args );
                        lstrcat( DiskDiagMessage, Text0 );
                    }

                } else if( CheckResult == VALID_DRIVE ) {

                    if (!QuickTest) {
                        DebugLog( Winnt32LogInformation,
                                  NULL,
                                  MSG_LOG_LOCAL_SOURCE_VALID,
                                  DriveLetter );
                    }
                    MyLocalSourceDrive = DriveLetter;
                    break;
                }
            }

            //
            // See if we got it.  We can't bypass this failure even
            // if the user has cleared BlockOnNotEnoughSpace because
            // we absolutely have to have a place to put local files.
            // The user can always get around this by either installing
            // from CD, or using /tempdrive and clearing BlockOnNotEnoughSpace.
            //
            if( MyLocalSourceDrive == 0 ) {
                //
                // We failed.  Error-out.
                //

                //
                // Just so we don't look bad...
                //
                if( MinDiskSpaceRequired == MaxDiskSpaceRequired ) {
                    MaxDiskSpaceRequired += 10;
                }
                if( MinDiskSpaceRequired > MaxDiskSpaceRequired ) {
                    MinDiskSpaceRequired = 300;
                    MaxDiskSpaceRequired = 500;
                }

                if (!QuickTest) {
                    if( CheckUpgradeOnly ) {
                        //
                        // Just catch the message for the compatibility list.
                        //
                        SendMessage(hdlg,WMX_ERRORMESSAGEUP,TRUE,0);

                        MessageBoxFromMessage(
                            hdlg,
                            MSG_NO_VALID_LOCAL_SOURCE,
                            FALSE,
                            AppTitleStringId,
                            MB_OK | MB_ICONWARNING,
                            (DWORD)MinDiskSpaceRequired,
                            (DWORD)MaxDiskSpaceRequired );

                        SendMessage(hdlg,WMX_ERRORMESSAGEUP,FALSE,0);
                    } else {
                        //
                        // Put up a detailed dialog.
                        //
                        DialogBox( hInst,
                                   MAKEINTRESOURCE(IDD_DISKSPACE),
                                   hdlg,
                                   DiskDlgProc );

                    }
                }

                return( FALSE );
            }
        }

        //
        // If we get here, then we found room for all our
        // needs.  Set up some globals.
        //

        LocalSourceDrive = MyLocalSourceDrive;
        LocalSourceDriveOffset = MyLocalSourceDrive - TEXT('A');
        LocalSourceDirectory[0] = MyLocalSourceDrive;
        LocalSourceDirectory[1] = TEXT(':');
        LocalSourceDirectory[2] = TEXT('\\');
        LocalSourceDirectory[3] = 0;
        ConcatenatePaths(LocalSourceDirectory,LOCAL_SOURCE_DIR,MAX_PATH);

        lstrcpy(LocalSourceWithPlatform,LocalSourceDirectory);


        if (!GetMainInfValue (TEXT("Miscellaneous"), TEXT("DestinationPlatform"), 0, platform, MAX_PATH)) {

            if (!QuickTest) {
                DebugLog( Winnt32LogSevereError,
                          NULL,
                          MSG_NO_PLATFORM,
                          NULL );

                SendMessage(hdlg,WMX_ERRORMESSAGEUP,TRUE,0);

                MessageBoxFromMessage(
                    hdlg,
                    MSG_NO_PLATFORM,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL
                    );

                SendMessage(hdlg,WMX_ERRORMESSAGEUP,FALSE,0);
            }

            return( FALSE );
        }

        ConcatenatePaths(
            LocalSourceWithPlatform,
            platform,
            MAX_PATH
            );

        LocalSourceDriveClusterSize = ClusterSize;
    }

    return( TRUE );
}

DWORD
CopyWorkerThread(
    IN PVOID ThreadParameter
    )
/*++

Routine Description:

    Thread routine to copy files.  There may be up to MAX_SOURCE_COUNT of
    these threads running simultaneously.

    Access to shared global data is controlled via a critical section, per-
    thread global data is accessed by using the threads "ordinal number" to
    access the appropriate member of the global data array.

    The copy thread treats the copy list as a LIFO queue.  Each time the thread
    is ready to copy a file, it dequeues a file from the list.  It then tries
    to copy the file.  If this fails, a per-thread vector bit is set so that
    this thread doesn't attempt to copy the file again.  It then puts the file
    back into the list (at the head) to allow another thread to attempt to copy
    the file.

Arguments:

    ThreadParameter - this is actually an ordinal number to indicate which
                      thread in the "array" of SourceCount threads is currently
                      running

Return Value:

    Ignored.

--*/
{
    UINT SourceOrdinal;
    PFIL CopyEntry,Previous;
    HANDLE Events[2];
    DWORD d;
    UINT ThreadBit;
    BOOL Requeue;
    TCHAR TargetFilename[MAX_PATH];
    ULONGLONG SpaceOccupied;
    TCHAR SizeStr[25];
    BOOL bDone = FALSE;

    SourceOrdinal = (UINT)((ULONG_PTR)ThreadParameter);
    ThreadBit = 1 << SourceOrdinal;

    //
    // Both of these are "manual reset" events, so they will remain signalled
    // until we reset them.
    //
    Events[0] = MasterCopyList.ListReadyEvent[SourceOrdinal];
    Events[1] = MasterCopyList.StopCopyingEvent;

    //
    // Wait for user to cancel, for copying to be done, or the file list
    // to become ready/non-empty.
    //
    while(!Cancelled && (WaitForMultipleObjects(2,Events,FALSE,INFINITE) == WAIT_OBJECT_0)) {
        if(Cancelled) {
            break;
        }

        EnterCriticalSection(&MasterCopyList.CriticalSection);

        //
        // Locate the next file that this thread has not yet
        // tried to copy, if any. If the list is completely
        // empty then reset the list ready event.
        //
        for(Previous=NULL, CopyEntry=MasterCopyList.Files;
            CopyEntry && (CopyEntry->ThreadBitmap & ThreadBit);
            Previous=CopyEntry, CopyEntry=CopyEntry->Next) {

            ;
        }

        //
        // If we found an entry unlink it from the list.
        //
        if(CopyEntry) {
            if(Previous) {
                Previous->Next = CopyEntry->Next;
            } else {
                MasterCopyList.Files = CopyEntry->Next;
            }
        } else {
            //
            // No entry for this thread. Enter a state where we're waiting
            // for an entry to be requeued or for copying to be finished.
            //
            ResetEvent(Events[0]);
        }

        LeaveCriticalSection(&MasterCopyList.CriticalSection);

        if(Cancelled) {
            break;
        }

        //
        // If we got a file entry, go ahead and try to copy the file.
        //
        if(CopyEntry) {

            d = CopyOneFile(CopyEntry,SourceOrdinal,TargetFilename,&SpaceOccupied);

            if(Cancelled) {
                break;
            }
#ifdef TEST_EXCEPTION
            DoException( 3);
#endif

            Requeue = FALSE;
            if(d == NO_ERROR) {
                MasterCopyList.SpaceOccupied[SourceOrdinal] += SpaceOccupied;
                TotalDataCopied += SpaceOccupied;
            } else {
                if (!(CopyEntry->Flags & FILE_IGNORE_COPY_ERROR)) {
                    //
                    // Error. If this is the last thread to try to copy the file,
                    // then we want to ask the user what to do. Otherwise requeue
                    // the file so other copy threads can try to copy it.
                    //
                    if((CopyEntry->ThreadBitmap | ThreadBit) == (UINT)((1 << SourceCount)-1)) {

                        MYASSERT (d != NO_ERROR);
                        switch(FileCopyError(MasterCopyList.hdlg,CopyEntry->SourceName,TargetFilename,d,TRUE)) {

                        case COPYERR_EXIT:
                            //
                            // FileCopyError() already set thhe stop-copying event
                            // and set Cancelled to TRUE. We do something a little funky now,
                            // namely we simulate a press of the cancel button on the wizard
                            // so all abnormal terminations go through the same codepath.
                            //
                            PropSheet_PressButton(GetParent(MasterCopyList.hdlg),PSBTN_CANCEL);
                            break;

                        case COPYERR_SKIP:
                            //
                            // Requeue is aready set to FALSE, which will cause code
                            // below to tell the main thread that another file is done.
                            // Nothing more to do for this case.
                            //
                            break;

                        case COPYERR_RETRY:
                            //
                            // Wipe the list of threads that have tried to copy the file
                            // so all will take another crack at it.
                            //
                            CopyEntry->ThreadBitmap = 0;
                            Requeue = TRUE;
                            break;
                        }
                    } else {
                        //
                        // Tell ourselves that we've already tried to copy this file
                        // and requeue it at the head of the list.
                        //
                        CopyEntry->ThreadBitmap |= ThreadBit;
                        Requeue = TRUE;
                    }
                } else {
                    DebugLog (
                        Winnt32LogWarning,
                        TEXT("Error %1!u! copying %2 to %3 - ignored"),
                        0,
                        d,
                        CopyEntry->SourceName,
                        CopyEntry->TargetName
                        );
                }
            }

            if(Requeue) {
                EnterCriticalSection(&MasterCopyList.CriticalSection);
                CopyEntry->Next = MasterCopyList.Files;
                MasterCopyList.Files = CopyEntry;

                //
                // Want to set the event for every thread that might be
                // called on to copy this file.
                //
                for(d=0; d<SourceCount; d++) {
                    if(!(CopyEntry->ThreadBitmap & (1 << d))) {
                        SetEvent(MasterCopyList.ListReadyEvent[d]);
                    }
                }

                LeaveCriticalSection(&MasterCopyList.CriticalSection);
                if(Cancelled) {
                    break;
                }
            } else {
                //
                // Inform the UI thread that another file is done.
                // Free the copy list entry and decrement the count
                // of files that have been processed. When that number
                // goes to 0, we are done.
                //
                if(Cancelled) {
                    break;
                } else {
                    PostMessage(MasterCopyList.hdlg,WMX_COPYPROGRESS,0,0);

                    if(CopyEntry->SourceName
                    && (CopyEntry->Flags & FILE_NEED_TO_FREE_SOURCENAME)) {

                        FREE((PVOID)CopyEntry->SourceName);
                    }
                    FREE(CopyEntry);
                    if(!InterlockedDecrement(&MasterCopyList.FileCount)) {
                        SetEvent(MasterCopyList.StopCopyingEvent);

                        //
                        // Sum up the total space occupied and write it into
                        // size.sif in the local source.
                        //
                        if(MakeLocalSource) {
                            SpaceOccupied = 0;
                            for(d=0; d<SourceCount; d++) {
                                SpaceOccupied += MasterCopyList.SpaceOccupied[d];
                            }

                            MYASSERT (LocalSourceDirectory[0]);

                            lstrcpy(TargetFilename,LocalSourceDirectory);
                            ConcatenatePaths(TargetFilename,TEXT("SIZE.SIF"),MAX_PATH);

                            wsprintf(SizeStr,TEXT("%u"),SpaceOccupied);

                            WritePrivateProfileString(TEXT("Data"),TEXT("Size"),SizeStr,TargetFilename);
                            WritePrivateProfileString(NULL,NULL,NULL,TargetFilename);
                        }

                        PostMessage(MasterCopyList.hdlg,WMX_COPYPROGRESS,0,1);
                        bDone = TRUE;
                    }
                }
            }
        }

        SetDlgItemText(MasterCopyList.hdlg,IDT_SOURCE1+SourceOrdinal,TEXT(""));
    }

    //
    // StopCopyingEvent was set or the user cancelled
    //

    if (bDone && MasterCopyList.ActiveCS) {
        DeleteCriticalSection(&MasterCopyList.CriticalSection);
        MasterCopyList.ActiveCS = FALSE;
    }

    return(0);
}


DWORD
StartCopyingThread(
    IN PVOID ThreadParameter
    )
/*++

Routine Description:

    Starts the actual copying of the files in the file list.

    The multi-thread copy works by creating the appropriate synchronization
    events and worker threads, then signals the worker threads to start
    copying.  Control returns to the caller, which will receive UI notifications
    from the worker threads.

Arguments:

    ThreadParameter - Thread context parameter.

Return Value:

    TRUE\FALSE failure code.

--*/
{
    UINT Source;
    DWORD ThreadId;
    HWND hdlg = ThreadParameter;

    MainCopyStarted = FALSE;


#ifdef _X86_

    if (!ISNT()) {

        if (MakeLocalSource) {
            //
            // Win9xupg may want to relocate the local source. If so, we need to update the
            // necessary Localsource directories.
            //
            if ((UINT) (LocalSourceDrive - TEXT('A')) != LocalSourceDriveOffset) {

                MYASSERT (LocalSourceDirectory[0]);

                LocalSourceDrive = (TCHAR) (TEXT('A') + LocalSourceDriveOffset);
                LocalSourceDirectory[0] = LocalSourceDrive;
                LocalSourceWithPlatform[0] = LocalSourceDrive;

            }
        }
    }

#endif

    InitializeCriticalSection(&MasterCopyList.CriticalSection);
    MasterCopyList.ActiveCS = TRUE;

    //
    // Create a manual reset event that will be used to tell the
    // worker threads to terminate.
    //
    MasterCopyList.StopCopyingEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    if(!MasterCopyList.StopCopyingEvent) {
        MessageBoxFromMessageAndSystemError(
            hdlg,
            MSG_CANT_START_COPYING,
            GetLastError(),
            AppTitleStringId,
            MB_OK | MB_ICONWARNING
            );

        goto c1;
    }

    //
    // Create one thread for each source.
    //
    ZeroMemory(MasterCopyList.ListReadyEvent,sizeof(MasterCopyList.ListReadyEvent));
    ZeroMemory(MasterCopyList.Threads,sizeof(MasterCopyList.Threads));

    if( OemPreinstall ) {

        TCHAR   TargetFilename[MAX_PATH];

        //
        // Create $win_nt$.~ls\$OEM$
        //

        MYASSERT (LocalSourceDrive);

        TargetFilename[0] = LocalSourceDrive;
        TargetFilename[1] = TEXT(':');
        TargetFilename[2] = TEXT('\\');
        TargetFilename[3] = 0;
        lstrcpy(TargetFilename+3, LOCAL_SOURCE_DIR);
        ConcatenatePaths(TargetFilename, WINNT_OEM_DIR,MAX_PATH);
        CreateMultiLevelDirectory( TargetFilename );

#ifdef _X86_
        //
        // Create $win_nt$.~bt\$OEM$
        //
        if( !IsArc() && MakeBootMedia ) {
            MYASSERT (SystemPartitionDriveLetter);
            TargetFilename[0] = SystemPartitionDriveLetter;
            lstrcpy(TargetFilename+3, LOCAL_BOOT_DIR);
            ConcatenatePaths(TargetFilename, WINNT_OEM_DIR,MAX_PATH);
            CreateMultiLevelDirectory( TargetFilename );
        }
#endif
    }

    for(Source=0; Source<SourceCount; Source++) {


        MasterCopyList.ListReadyEvent[Source] = CreateEvent(NULL,TRUE,FALSE,NULL);
        if(!MasterCopyList.ListReadyEvent[Source]) {
            MessageBoxFromMessageAndSystemError(
                hdlg,
                MSG_CANT_START_COPYING,
                GetLastError(),
                AppTitleStringId,
                MB_OK | MB_ICONWARNING
                );

            goto c2;
        }

        MasterCopyList.hdlg = hdlg;
        MasterCopyList.SpaceOccupied[Source] = 0;

        MasterCopyList.Threads[Source] = CreateThread(
                                            NULL,
                                            0,
                                            CopyWorkerThread,
                                            UIntToPtr( Source ),
                                            0,
                                            &ThreadId
                                            );

        if(!MasterCopyList.Threads[Source]) {
            MessageBoxFromMessageAndSystemError(
                hdlg,
                MSG_CANT_START_COPYING,
                GetLastError(),
                AppTitleStringId,
                MB_OK | MB_ICONWARNING
                );

            goto c2;
        }
    }

    //
    // OK, now signal all the copy threads -- when we tell them that
    // there's something in their lists they will start copying.
    //
    MainCopyStarted = TRUE;
    for(Source=0; Source<SourceCount; Source++) {
        SetEvent(MasterCopyList.ListReadyEvent[Source]);
    }
    return(TRUE);

c2:
    //
    // Signal threads and wait for them to terminate.
    // This should be real quick since none of them have started copying yet.
    //
    SetEvent(MasterCopyList.StopCopyingEvent);
    WaitForMultipleObjects(Source,MasterCopyList.Threads,TRUE,INFINITE);

    for(Source=0; Source<SourceCount; Source++) {

        if(MasterCopyList.Threads[Source]) {
            CloseHandle(MasterCopyList.Threads[Source]);
        }

        if(MasterCopyList.ListReadyEvent[Source]) {
            CloseHandle(MasterCopyList.ListReadyEvent[Source]);
        }
    }
    CloseHandle(MasterCopyList.StopCopyingEvent);
c1:
    if (MasterCopyList.ActiveCS) {
        DeleteCriticalSection(&MasterCopyList.CriticalSection);
    }
    ZeroMemory(&MasterCopyList,sizeof(COPY_LIST));
    return(FALSE);
}


VOID
CancelledMakeSureCopyThreadsAreDead(
    VOID
    )

/*++

Routine Description:

    This routine can be called after the user cancels setup (which can happen
    via the main cancel button on the wizard, or at a file copy error) to
    ensure that file copy threads have exited.

    It is assumed that whoever handled the cancel request has already set
    the Cancelled flag, and set the StopCopying event. In other words,
    this routine should only be called after the caller has ensured that
    the threads have actually been requested to exit.

    The purpose of this routine is to ensure that the cleanup code is not
    cleaning up files in the local source directory at the same time
    a lingering copy thread is copying its last file.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if(MainCopyStarted) {
        MainCopyStarted = FALSE;
        WaitForMultipleObjects(SourceCount,MasterCopyList.Threads,TRUE,INFINITE);
        if (MasterCopyList.ActiveCS) {
            //
            // delete the critical section used
            //
            DeleteCriticalSection(&MasterCopyList.CriticalSection);
        }
        ZeroMemory(&MasterCopyList,sizeof(COPY_LIST));
    }
}


BOOL
OurCopyFile (
    IN      PCTSTR ActualSource,
    IN      PCTSTR TargetFilename,
    IN      BOOL FailIfExist
    )
{
    BOOL b = FALSE;
    DWORD bytes, bw;
    DWORD rc;
    BY_HANDLE_FILE_INFORMATION fi;
    BOOL fiValid = FALSE;
    PVOID buffer = NULL;
    HANDLE hRead = INVALID_HANDLE_VALUE;
    HANDLE hWrite = INVALID_HANDLE_VALUE;
    DWORD attrib = GetFileAttributes (TargetFilename);
    DWORD readSize;

    if (attrib != (DWORD)-1) {
        if (FailIfExist) {
            SetLastError (ERROR_ALREADY_EXISTS);
            return FALSE;
        }
        SetFileAttributes (TargetFilename, FILE_ATTRIBUTE_NORMAL);
    }

    attrib = GetFileAttributes (ActualSource);
    if (attrib == (DWORD)-1) {
        return FALSE;
    }

    hWrite = CreateFile (
                TargetFilename,
                GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                attrib | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
                );
    if (hWrite == INVALID_HANDLE_VALUE) {
        goto exit;
    }
    hRead = CreateFile (
                ActualSource,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
                );
    if (hRead == INVALID_HANDLE_VALUE) {
        goto exit;
    }

    readSize = LocalSourceDriveClusterSize;
    if (!readSize) {
        readSize = 8192;
    }

    buffer = MALLOC (readSize);
    if (!buffer) {
        goto exit;
    }

    if (GetFileInformationByHandle (hRead, &fi)) {
        fiValid = TRUE;
    }

    do {
        if (!ReadFile (hRead, buffer, readSize, &bytes, NULL)) {
            goto exit;
        }
        if (bytes) {
            if (!WriteFile (hWrite, buffer, bytes, &bw, NULL) || bytes != bw) {
                goto exit;
            }
        }
    } while (bytes);

    //
    // apply source file attributes and file time stamps
    //
    if (fiValid) {
        SetFileTime (hWrite, &fi.ftCreationTime, &fi.ftLastAccessTime, &fi.ftLastWriteTime);
    }

    b = TRUE;

exit:

    rc = GetLastError ();

    if (buffer) {
        FREE (buffer);
    }
    if (hWrite != INVALID_HANDLE_VALUE) {
        CloseHandle (hWrite);
    }
    if (hRead != INVALID_HANDLE_VALUE) {
        CloseHandle (hRead);
    }

    SetLastError (rc);
    return b;
}


DWORD
CopyOneFile(
    IN  PFIL   File,
    IN  UINT   SourceOrdinal,
    OUT TCHAR  TargetFilename[MAX_PATH],
    OUT ULONGLONG *SpaceOccupied
    )
/*++

Routine Description:

    Routine attempts to copy an individual file in the copy queue.

    The routine builds a full source and destination path.  After locating
    the source file (we try to optimize the search by remembering if the last
    file was compressed, guessing that if the last file was compressed, the
    current file will be compressed), the file is either decompressed or
    copied.

Arguments:

    File - pointer to a FIL structure descibing the file to be copied
    SourceOrdinal  - specifies the copy thread ordinal
    TargetFilename - receives the file name of the file that was copied.
    SpaceOccupied  - receives the file size of the file

Return Value:

    Win32 error code indicating outcome.  If the call succeeds, NO_ERROR is
    returned and SpaceOccupied will be updated with the size of the copied
    file.

--*/
{
    TCHAR SourceFilename[MAX_PATH];
    TCHAR ActualSource[MAX_PATH];
    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;
    BOOL TryCompressedFirst;
    PTCHAR p;
    DWORD d;
    DWORD OldAttributes;
    NAME_AND_SIZE_CAB NameAndSize;
    BOOL UsedAlternate = FALSE;
    BOOL UsedUpdated = FALSE;

    if (File->Flags & FILE_DO_NOT_COPY) {
        DebugLog (
            Winnt32LogInformation,
            TEXT("Not copying %1"),
            0,
            File->SourceName
            );
        return NO_ERROR;
    }

    //
    // Form the full source and target names for this file, based on
    // information in the copy list entry and the source we're supposed to
    // be using for this file.
    //
    // Check to see if this directory's path has been tagged
    // as being an absolute path.  If so, then we shouldn't
    // tack him onto the end of the SourcePath.  Rather, we
    // can just take as he is.
    //
    if( !(File->Flags & FILE_NT_MIGRATE) ) {
        //
        // Generate a path to copy from (source path).
        //
        if (AlternateSourcePath[0] && !(File->Directory->Flags & DIR_DOESNT_SUPPORT_PRIVATES)) {
            lstrcpy(SourceFilename,AlternateSourcePath);
            //ConcatenatePaths(SourceFilename,File->Directory->SourceName,MAX_PATH);
            ConcatenatePaths(SourceFilename,File->SourceName,MAX_PATH);
            UsedAlternate = TRUE;
        } else if (DynamicUpdateSuccessful () &&
                   g_DynUpdtStatus->UpdatesPath[0] &&
                   (File->Directory->Flags & DIR_SUPPORT_DYNAMIC_UPDATE)
                   ) {
            //
            // Files in this directory support Dynamic Update
            //
            WIN32_FIND_DATA fd;

            lstrcpy (SourceFilename, g_DynUpdtStatus->UpdatesPath);
            ConcatenatePaths (SourceFilename, File->Directory->SourceName, MAX_PATH);
            ConcatenatePaths (SourceFilename, File->SourceName, MAX_PATH);
            if (FileExists (SourceFilename, &fd) && !(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                UsedUpdated = TRUE;
                DebugLog (
                    Winnt32LogInformation,
                    NULL,
                    MSG_LOG_USE_UPDATED,
                    SourceFilename,
                    File->SourceName,
                    SourceOrdinal
                    );
            }
        }

        if (!(UsedAlternate || UsedUpdated)) {
            if( File->Directory->Flags & DIR_ABSOLUTE_PATH ) {
                lstrcpy( SourceFilename, File->Directory->SourceName );
                ConcatenatePaths(SourceFilename,File->SourceName,MAX_PATH);
            } else {
                lstrcpy(SourceFilename,SourcePaths[SourceOrdinal]);
                ConcatenatePaths(SourceFilename,File->Directory->SourceName,MAX_PATH);
                ConcatenatePaths(SourceFilename,File->SourceName,MAX_PATH);
            }
        }
    } else {
        MyGetWindowsDirectory(SourceFilename,MAX_PATH);
        ConcatenatePaths(SourceFilename,File->Directory->SourceName,MAX_PATH);
        ConcatenatePaths(SourceFilename,File->SourceName,MAX_PATH);
    }

    //
    // generate a target path
    //
    if( !(File->Flags & FILE_NT_MIGRATE) ) {

#if defined(REMOTE_BOOT)
        if(File->Flags & FILE_ON_MACHINE_DIRECTORY_ROOT) {
            MYASSERT(RemoteBoot);
            lstrcpy(TargetFilename,MachineDirectory);
        } else
#endif // defined(REMOTE_BOOT)

        if(File->Flags & FILE_ON_SYSTEM_PARTITION_ROOT) {
#if defined(REMOTE_BOOT)
            if (RemoteBoot) {
                MyGetWindowsDirectory(TargetFilename,MAX_PATH);
                TargetFilename[3] = 0;
            } else
#endif // defined(REMOTE_BOOT)
            {
                BuildSystemPartitionPathToFile (TEXT(""), TargetFilename, MAX_PATH);
            }
        } else {
            if(File->Flags & FILE_IN_LOCAL_BOOT) {
                lstrcpy(TargetFilename, IsArc() ? LocalSourceWithPlatform : LocalBootDirectory);
                if (File->Directory->Flags & DIR_USE_SUBDIR) {
                    ConcatenatePaths(TargetFilename,File->Directory->TargetName,MAX_PATH);
                }
            } else {

                MYASSERT (LocalSourceDirectory[0]);

                if(File->Flags & FILE_IN_PLATFORM_INDEPEND_DIR) {
                    lstrcpy(TargetFilename,LocalSourceDirectory);
                } else {
                    lstrcpy(TargetFilename,LocalSourceWithPlatform);
                }

                ConcatenatePaths(TargetFilename,File->Directory->TargetName,MAX_PATH);
            }
        }
    } else {
        lstrcpy(TargetFilename, IsArc() ? LocalSourceWithPlatform : LocalBootDirectory);
    }
    ConcatenatePaths(TargetFilename,File->TargetName,MAX_PATH);

    //
    // We have the full source and destination paths.  Try to do the actual copy.
    //
try_again:
    SetDlgItemText(
        MasterCopyList.hdlg,
        IDT_SOURCE1+SourceOrdinal,
        _tcsrchr(TargetFilename,TEXT('\\')) + 1
        );

    //
    // Now see if the file can be located on the server with the compressed
    // form of the name or the name itself, depending on which was successful
    // last time.
    //
    TryCompressedFirst = (File->Flags & FILE_NT_MIGRATE) || UsedUpdated ? FALSE : (TlsGetValue(TlsIndex) != 0);
    if(TryCompressedFirst) {
        GenerateCompressedName(SourceFilename,ActualSource);
        FindHandle = FindFirstFile(ActualSource,&FindData);
        if(FindHandle && (FindHandle != INVALID_HANDLE_VALUE)) {
            //
            // Got the file, leave the name in ActualSource.
            //
            FindClose(FindHandle);
        } else {
            //
            // Don't have the file, try the actual filename.
            // If that works then remember the name in ActualSource.
            //
            FindHandle = FindFirstFile(SourceFilename,&FindData);
            if(FindHandle && (FindHandle != INVALID_HANDLE_VALUE)) {
                FindClose(FindHandle);
                lstrcpy(ActualSource,SourceFilename);
                TryCompressedFirst = FALSE;
            } else {
                ActualSource[0] = 0;
            }
        }
    } else {
        FindHandle = FindFirstFile(SourceFilename,&FindData);
        if(FindHandle != INVALID_HANDLE_VALUE) {
            //
            // Found it -- remember the name in ActualSource.
            //
            FindClose(FindHandle);
            lstrcpy(ActualSource,SourceFilename);
        } else {
            //
            // Try the compressed-form name.
            //
            GenerateCompressedName(SourceFilename,ActualSource);
            FindHandle = FindFirstFile(ActualSource,&FindData);
            if(FindHandle != INVALID_HANDLE_VALUE) {
                TryCompressedFirst = TRUE;
                FindClose(FindHandle);
            } else {
                //
                // Couldn't find the compressed form name either.
                // Indicate failure.
                //
                ActualSource[0] = 0;
            }
        }
    }

    //
    // At this point ActualSource[0] is 0 if we couldn't find the file.
    //
    if(!ActualSource[0]) {
        if (UsedAlternate) {
            if( File->Directory->Flags & DIR_ABSOLUTE_PATH ) {
                lstrcpy( SourceFilename, File->Directory->SourceName );
                ConcatenatePaths(SourceFilename,File->SourceName,MAX_PATH);
            } else {
                lstrcpy(SourceFilename,SourcePaths[SourceOrdinal]);
                ConcatenatePaths(SourceFilename,File->Directory->SourceName,MAX_PATH);
                ConcatenatePaths(SourceFilename,File->SourceName,MAX_PATH);
            }

            UsedAlternate = FALSE;
            goto try_again;
        }
        return(ERROR_FILE_NOT_FOUND);
    }

    if( !(File->Flags & FILE_NT_MIGRATE) && !UsedUpdated ) {
        TlsSetValue(TlsIndex, UIntToPtr( TryCompressedFirst ) );
    }
    if(TryCompressedFirst && (File->Flags & FILE_PRESERVE_COMPRESSED_NAME)) {
        //
        // Opened the compressed form of the source name, so use
        // a compressed form of the target name. Note that we're not
        // using the SourceFilename buffer anymore, so we use it
        // as temporary storage.
        //
        GenerateCompressedName(TargetFilename,SourceFilename);
        lstrcpy(TargetFilename,SourceFilename);
    }

    //
    // Now go ahead and try to actually *copy* the file (gasp!)
    // To overcome net glitches, we retry once automatically.
    //
    // As a small touch, we try to preserve file attributes for files
    // that already exist on the system partition root. In other words
    // for a file like ntldr, if the user removed say RHS attribs
    // we try to leave it that way.
    //
    *(p = _tcsrchr(TargetFilename,TEXT('\\'))) = 0;
    d = CreateMultiLevelDirectory(TargetFilename);
    *p = TEXT('\\');
    if(d != NO_ERROR) {
        DebugLog(Winnt32LogError,NULL,MSG_LOG_COPY_ERR,ActualSource,TargetFilename,SourceOrdinal,d);
        return(d);
    }

    OldAttributes = (File->Flags & FILE_ON_SYSTEM_PARTITION_ROOT)
                  ? GetFileAttributes(TargetFilename)
                  : (DWORD)(-1);

    SetFileAttributes(TargetFilename,FILE_ATTRIBUTE_NORMAL);

    if(TryCompressedFirst && (File->Flags & FILE_DECOMPRESS)) {
        //
        // File existed with its compressed-form name and
        // we want to decompress it. Do that now, bypassing the usual
        // filecopy logic below.
        //
        NameAndSize.Name = TargetFilename;
        NameAndSize.Size = 0;

        if(!SetupapiCabinetRoutine(ActualSource,0,DiamondCallback,&NameAndSize)) {
            d = GetLastError();
            DebugLog(Winnt32LogError,NULL,MSG_LOG_DECOMP_ERR,ActualSource,TargetFilename,SourceOrdinal,d);
            return(d);
        }
        //
        // Adjust file size so disk space checks are accurate
        //
        FindData.nFileSizeLow =  LOULONG(NameAndSize.Size);
        FindData.nFileSizeHigh = HIULONG(NameAndSize.Size);
    } else {
        if(!CopyFile(ActualSource,TargetFilename,FALSE)) {
            Sleep(500);
            if(!CopyFile(ActualSource,TargetFilename,FALSE)) {
                //
                // workaround for Win9x system bug: sometimes it fails to copy some files
                // use our own copy routine
                //
                if (!OurCopyFile (ActualSource,TargetFilename,FALSE)) {
                    d = GetLastError();
                    DebugLog(Winnt32LogError,NULL,MSG_LOG_COPY_ERR,ActualSource,TargetFilename,SourceOrdinal,d);
                    return(d);
                } else {
#ifdef PRERELEASE
                    //
                    // log this info; at least we can track it and maybe we can find what's causing this
                    //
                    DebugLog(Winnt32LogWarning,TEXT("File %1 was successfully copied to %2 using OurCopyFile"),0,ActualSource,TargetFilename);
#endif
                }
            }
        }
    }

    if(OldAttributes != (DWORD)(-1)) {
        //
        // API does nothing with the compression flag; strip it out.
        //
        SetFileAttributes(TargetFilename,OldAttributes & ~FILE_ATTRIBUTE_COMPRESSED);
    }

    DebugLog(Winnt32LogInformation,NULL,MSG_LOG_COPY_OK,ActualSource,TargetFilename,SourceOrdinal);

    //
    // Track size occupied on local source drive.
    //
    if( (LocalSourceDrive) &&
        (MakeLocalSource) &&
        ( (SystemPartitionDriveLetter == LocalSourceDrive) ||
         !(File->Flags & (FILE_ON_SYSTEM_PARTITION_ROOT | FILE_IN_LOCAL_BOOT))) ) {

        DWORD Adjuster;
        ULONGLONG Value;

        Value = MAKEULONGLONG(0,FindData.nFileSizeHigh);
        Adjuster = ((FindData.nFileSizeLow % LocalSourceDriveClusterSize) != 0);
        Value += LocalSourceDriveClusterSize * ((FindData.nFileSizeLow/LocalSourceDriveClusterSize)+Adjuster);

        *SpaceOccupied = Value;
    }

    return(NO_ERROR);
}


UINT
GetTotalFileCount(
    VOID
    )
{
    return(MasterCopyList.FileCount);
}


UINT
FileCopyError(
    IN HWND    ParentWindow,
    IN LPCTSTR SourceFilename,
    IN LPCTSTR TargetFilename,
    IN UINT    Win32Error,
    IN BOOL    MasterList
    )

/*++

Routine Description:

    This routine handles file copy errors, presenting them to the user
    for dispensation (skip, retry, exit).

Arguments:

    ParentWindow - supplies window handle of window to be used as parent
        for the dialog that this routine displays.

    SourceFilename - supplies name of file that could not be copied.
        Only the final component of this name is used.

    TargetFilename - supplies the target filename for the file. This should
        be a fully qualified win32 path.

    Win32Error - supplies win32 error code that indicated reason for failure.

    MasterList - supplies a flag indicating whether the file being copied
        was on the master list or was just an individual file. If TRUE,
        copy errors are serialized and the master copy list stop copying event
        is set if the user chooses to cancel.

Return Value:

    One of COPYERR_SKIP, COPYERR_EXIT, or COPYERR_RETRY.

--*/

{
    UINT u;
    HANDLE Events[2];
    COPY_ERR_DLG_PARAMS CopyErrDlgParams;
    LPCTSTR p;

    if(AutoSkipMissingFiles) {

        if(p = _tcsrchr(SourceFilename,TEXT('\\'))) {
            p++;
        } else {
            p = SourceFilename;
        }

        DebugLog(Winnt32LogWarning,NULL,MSG_LOG_SKIPPED_FILE,p);
        return(COPYERR_SKIP);
    }

    //
    // Multiple threads can potentially enter this routine simultaneously
    // but we only want a single error dialog up at once. Because each copy
    // thread is independent of the main thread running the wizard/ui,
    // we can block here. But we also need to wake up if the user cancels
    // copying from another thread, so we want on the stop copying event also.
    //
    if(MasterList) {
        Events[0] = UiMutex;
        Events[1] = MasterCopyList.StopCopyingEvent;

        u = WaitForMultipleObjects(2,Events,FALSE,INFINITE);
        if(Cancelled || (u != WAIT_OBJECT_0)) {
            //
            // Stop copying event. This means that some other thread is cancelling
            // setup. We just return skip since we don't need an extra guy running
            // around processing an exit request.
            //
            return(COPYERR_SKIP);
        }
    }

    //
    // OK, put up the actual UI.
    //
    CopyErrDlgParams.Win32Error = Win32Error;
    CopyErrDlgParams.SourceFilename = SourceFilename;
    CopyErrDlgParams.TargetFilename = TargetFilename;

    u = (UINT)DialogBoxParam(
                  hInst,
                  MAKEINTRESOURCE(IDD_COPYERROR),
                  ParentWindow,
                  CopyErrDlgProc,
                  (LPARAM)&CopyErrDlgParams
                 );

    if(u == COPYERR_EXIT) {
        //
        // Set the cancelled flag before releasing the mutex.
        // This guarantees that if any other threads are waiting to stick up
        // a copy error, they'll hit the case above and return COPYERR_SKIP.
        //
        Cancelled = TRUE;
        if(MasterList) {
            SetEvent(MasterCopyList.StopCopyingEvent);
        }
    }

    if(MasterList) {
        ReleaseMutex(UiMutex);
    }
    return(u);
}


INT_PTR
CopyErrDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    int i;
    static WarnedSkip;

    b = FALSE;

    switch(msg) {

    case WM_INITDIALOG:
        //
        // File not found and disk full get special treatment.
        // Others get the standard system message.
        //
        {
            TCHAR text1[500];
            TCHAR text2[1000];
            TCHAR text3[5000];
            PCOPY_ERR_DLG_PARAMS Params;
            DWORD Flags;
            UINT Id;
            LPCTSTR Args[4];
            LPCTSTR source;

            Params = (PCOPY_ERR_DLG_PARAMS)lParam;
            switch(Params->Win32Error) {

            case ERROR_FILE_NOT_FOUND:
                Flags = FORMAT_MESSAGE_FROM_HMODULE;
                Id = MSG_COPY_ERROR_NOSRC;
                break;

            case ERROR_HANDLE_DISK_FULL:
            case ERROR_DISK_FULL:
                Flags = FORMAT_MESSAGE_FROM_HMODULE;
                Id = MSG_COPY_ERROR_DISKFULL;
                break;

            default:
                Flags = FORMAT_MESSAGE_FROM_SYSTEM;
                Id = Params->Win32Error;
                break;
            }

            FormatMessage(
                Flags | FORMAT_MESSAGE_IGNORE_INSERTS,
                hInst,
                Id,
                0,
                text1,
                sizeof(text1)/sizeof(TCHAR),
                NULL
                );

            FormatMessage(
                FORMAT_MESSAGE_FROM_HMODULE,
                hInst,
                MSG_COPY_ERROR_OPTIONS,
                0,
                text2,
                sizeof(text2)/sizeof(TCHAR),
                NULL
                );

            if(source = _tcsrchr(Params->SourceFilename,TEXT('\\'))) {
                source++;
            } else {
                source = Params->SourceFilename;
            }

            Args[0] = source;
            Args[1] = Params->TargetFilename;
            Args[2] = text1;
            Args[3] = text2;

            FormatMessage(
                FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                hInst,
                MSG_COPY_ERROR_TEMPLATE,
                0,
                text3,
                sizeof(text3)/sizeof(TCHAR),
                (va_list *)Args
                );

            if (BatchMode) {
                //
                // Don't show the UI.  Save the error message and pretend the
                // user hit Abort.
                //
                SaveTextForSMS(text3);
                EndDialog(hdlg,COPYERR_EXIT);
            }

            SetDlgItemText(hdlg,IDT_ERROR_TEXT,text3);
        }

        SetFocus(GetDlgItem(hdlg,IDRETRY));
        break;

    case WM_COMMAND:

        switch(LOWORD(wParam)) {

        case IDRETRY:

            if(HIWORD(wParam) == BN_CLICKED) {
                EndDialog(hdlg,COPYERR_RETRY);
                b = TRUE;
            }
            break;

        case IDIGNORE:

            if(HIWORD(wParam) == BN_CLICKED) {

                if(WarnedSkip) {
                    i = IDYES;
                } else {
                    i = MessageBoxFromMessage(
                            hdlg,
                            MSG_REALLY_SKIP,
                            FALSE,
                            AppTitleStringId,
                            MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2
                            );

                    WarnedSkip = TRUE;
                }

                if(i == IDYES) {
                    EndDialog(hdlg,COPYERR_SKIP);
                }
                b = TRUE;
            }
            break;

        case IDABORT:

            if(HIWORD(wParam) == BN_CLICKED) {

                i = MessageBoxFromMessage(
                        hdlg,
                        MSG_SURE_EXIT,
                        FALSE,
                        AppTitleStringId,
                        MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2
                        );

                if(i == IDYES) {
                    EndDialog(hdlg,COPYERR_EXIT);
                }

                b = TRUE;
            }
            break;
        }

        break;
    }

    return(b);
}


UINT
DiamondCallback(
    IN PVOID Context,
    IN UINT  Code,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    UINT u;
    PFILE_IN_CABINET_INFO_A FileInCabInfo;
    PNAME_AND_SIZE_CAB NameAndSize;

    if(Code == SPFILENOTIFY_FILEINCABINET) {
        //
        // Give setupapi the full target path of the file.
        //
        NameAndSize = Context;
        FileInCabInfo = (PFILE_IN_CABINET_INFO_A)Param1;

#ifdef UNICODE
        u = WideCharToMultiByte(
                CP_ACP,
                0,
                NameAndSize->Name,
                -1,
                FileInCabInfo->FullTargetName,
                MAX_PATH,
                NULL,
                NULL
                );

        if(!u) {
            FileInCabInfo->Win32Error = GetLastError();
            return(FILEOP_ABORT);
        }
#else
        lstrcpy(FileInCabInfo->FullTargetName,NameAndSize->Name);
#endif

        //
        // BugBug: cabinet only returns a DWORD file size
        //
        NameAndSize->Size = (ULONGLONG)FileInCabInfo->FileSize;

        u = FILEOP_DOIT;
    } else {
        u = NO_ERROR;
    }

    return(u);
}


BOOL
AddUnsupportedFilesToCopyList(
    IN HWND ParentWindow,
    IN PUNSUPORTED_DRIVER_INFO DriverList
    )

/*++

Routine Description:

    Adds unsupported, required drivers to be used during textmode setup.
    This would include 3rd party mass storage drivers, for instance.

    The files are simply appended to the master copy list.

Arguments:

    ParentWindow - ParentWindow used for UI.

    DriverList - supplies the list of drivers to be added to the copy list.

Return Value:

    If successful,  returns a pointer to the new FIL structure for the file.
    Otherwise returns NULL (the caller can assume out of memory).

--*/
{
    PUNSUPORTED_DRIVER_INFO      p;
    ULONG                        Error;
    PUNSUPORTED_DRIVER_FILE_INFO q;
    PDIR                         r;

    UNREFERENCED_PARAMETER(ParentWindow);

    for( p = DriverList; p != NULL; p = p->Next ) {
        for( q = p->FileList; q != NULL; q = q->Next ) {
            r = MALLOC( sizeof( DIR ) );
            if( r == NULL ) {
                return( FALSE );
            }
            r->Next = NULL;
            r->InfSymbol = NULL;
            r->Flags = 0;
            r->TargetName = NULL;
            r->SourceName = DupString( q->TargetDirectory );
            if( r->SourceName == NULL) {
                FREE( r );
                return( FALSE );
            }

            if( !AddFile( &MasterCopyList,
                          q->FileName,
                          NULL,
                          r,
                          FILE_NT_MIGRATE | FILE_NEED_TO_FREE_SOURCENAME,
                          0 ) ) {

                FREE( (LPTSTR)(r->SourceName) );
                FREE( r );
                return( FALSE );
            }
            //
            // now make sure the referenced file is not overwritten with an inbox driver
            // with the same name
            //
            RemoveFile (&MasterCopyList, q->FileName, NULL, FILE_IN_LOCAL_BOOT);
        }

    }

    return(TRUE);
}

BOOL
AddGUIModeCompatibilityInfsToCopyList(
    VOID
    )
/*++

Routine Description:

    Adds the compatibility INF to the copy queue.  The compatibility
    inf is used during GUI-setup to remove incompatible drivers.

Arguments:

    None.

Return Value:

    If successful,  returns TRUE.

--*/
{

    PDIR CompDir;
    PLIST_ENTRY     Next_Link;
    PCOMPATIBILITY_DATA CompData;
    TCHAR InfLocation[MAX_PATH], *t;
    TCHAR relPath[MAX_PATH];
    WIN32_FIND_DATA fd;

    Next_Link = CompatibilityData.Flink;

    if( Next_Link ){

        while ((ULONG_PTR)Next_Link != (ULONG_PTR)&CompatibilityData) {

            CompData = CONTAINING_RECORD( Next_Link, COMPATIBILITY_DATA, ListEntry );
            Next_Link = CompData->ListEntry.Flink;

            if(CompData->InfName && CompData->InfSection && *CompData->InfName && *CompData->InfSection) {

                BOOL b = FALSE;

                if (FileExists (CompData->InfName, &fd) && !(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                    lstrcpy (InfLocation, CompData->InfName);
                    DebugLog(
                        Winnt32LogInformation,
                        TEXT("Using private compatibility inf %1"),
                        0,
                        InfLocation
                        );
                    b = TRUE;
                } else {
                    BuildPath (relPath, TEXT("compdata"), CompData->InfName);
                    b = FindPathToWinnt32File (relPath, InfLocation, MAX_PATH);
                }
                if (b) {

                    b = FALSE;

                    t = _tcsrchr (InfLocation, TEXT('\\'));
                    if (t) {
                        *t = 0;
                        CompDir = AddDirectory(
                                            NULL,
                                            &MasterCopyList,
                                            InfLocation,
                                            TEXT("\\"),
                                            DIR_NEED_TO_FREE_SOURCENAME | DIR_ABSOLUTE_PATH
                                            );
                        if (CompDir && AddFile (
                                            &MasterCopyList,
                                            t + 1,
                                            NULL,
                                            CompDir,
                                            (IsArc() ? 0 : FILE_IN_LOCAL_BOOT) | FILE_NEED_TO_FREE_SOURCENAME,
                                            0
                                            )) {
                            b = TRUE;
                        }
                    }
                }

                if (!b) {
                    DebugLog( Winnt32LogError,
                        TEXT( "\r\n\r\nError encountered while trying to copy compatibility infs\r\n"),
                        0 );
                    return(FALSE);
                }
            }
        }
    }

    return( TRUE );

}








LRESULT
DiskDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{

    switch(msg) {
    case WM_INITDIALOG:

        //
        // Fill in the diagnostic list...
        //
        SetDlgItemText( hdlg,
                        IDC_DISKDIAG,
                        DiskDiagMessage );

        return( TRUE );

    case WM_COMMAND:

        if( (LOWORD(wParam) == IDOK) && (HIWORD(wParam) == BN_CLICKED)) {
            EndDialog(hdlg,TRUE);
        }
        return( TRUE );

    case WM_CTLCOLOREDIT:
            SetBkColor( (HDC)wParam, GetSysColor(COLOR_BTNFACE));
            return (INT_PTR)GetSysColorBrush(COLOR_WINDOW);
            break;


    default:
        break;
    }

    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\delnode.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    delnode.c

Abstract:

    Delnode routine for Setup.

    WARNING: the delnode routine in here is not multi-thread safe!

Author:

    Ted Miller (tedm) August 1992

--*/

#include "precomp.h"
#pragma hdrstop

//
// Put these out here so we don't consume huge stack space as we recurse.
//
TCHAR DelnodePattern[MAX_PATH];
WIN32_FIND_DATA DelnodeFindData;

VOID
DelnodeRoutine(
    VOID
    )
{
    LPTSTR PatternEnd;
    HANDLE FindHandle;

    //
    // Delete each file in the directory, then remove the directory itself.
    // If any directories are encountered along the way recurse to delete
    // them as they are encountered.
    //
    PatternEnd = DelnodePattern+lstrlen(DelnodePattern);

    lstrcat(DelnodePattern,TEXT("\\*"));
    FindHandle = FindFirstFile(DelnodePattern,&DelnodeFindData);

    if(FindHandle != INVALID_HANDLE_VALUE) {

        do {

            //
            // Form the full name of the file we just found.
            //
            lstrcpy(PatternEnd+1,DelnodeFindData.cFileName);

            if(DelnodeFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                //
                // The current match is a directory.  Recurse into it unless
                // it's . or ...
                //
                if(lstrcmp(DelnodeFindData.cFileName,TEXT("." ))
                && lstrcmp(DelnodeFindData.cFileName,TEXT("..")))
                {
                    DelnodeRoutine();
                }

            } else {

                //
                // The current match is not a directory -- so delete it.
                //
                SetFileAttributes(DelnodePattern,FILE_ATTRIBUTE_NORMAL);
                DeleteFile(DelnodePattern);
            }

            *(PatternEnd+1) = 0;

        } while(FindNextFile(FindHandle,&DelnodeFindData));

        FindClose(FindHandle);
    }

    //
    // Remove the directory we just emptied out.
    //
    *PatternEnd = 0;
    SetFileAttributes(DelnodePattern,FILE_ATTRIBUTE_NORMAL);
    RemoveDirectory(DelnodePattern);

    //
    // Note that the 'directory' might actually be a file.
    // Catch that case here.
    //
    DeleteFile(DelnodePattern);
}


VOID
MyDelnode(
    IN LPCTSTR Directory
    )
{
    lstrcpy(DelnodePattern,Directory);

    DelnodeRoutine();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\debug.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

Abstract:

Author:

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

HANDLE hDebugLog;
Winnt32DebugLevel DebugLevel;


BOOL
StartDebugLog(
    IN LPCTSTR           DebugFileLog,
    IN Winnt32DebugLevel Level
    )

/*++

Routine Description:

    Create a file to be used for logging debugging information.
    Note: There can be only one debug log. Second and subsequent
    calls to this routine return TRUE if a debug log is already in use.

Arguments:

    DebugFileLog - supplies filename of file to be used for debugging log.

    Level - supplies logging level desired.

Return Value:

    Boolean value indicating whether the file log was successfully started.

--*/

{
    DWORD Written;
    TCHAR Text[512];

    if(hDebugLog) {
        return(TRUE);
    }

    if(Level > Winnt32LogMax) {
        Level = Winnt32LogMax;
    }

    DebugLevel = Level;

    hDebugLog = CreateFile(
                    DebugFileLog,
                    GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    Winnt32Restarted () ? OPEN_ALWAYS : CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );

    if(hDebugLog == INVALID_HANDLE_VALUE) {
        hDebugLog = NULL;
        return(FALSE);
    }

    if(GetLastError() == ERROR_ALREADY_EXISTS) {
        //
        // Appending to existing file
        //
        SetFilePointer(hDebugLog,0,NULL,FILE_END);

        LoadString( hInst, IDS_COMPAT_DIVIDER, Text, sizeof(Text)/sizeof(TCHAR) );
        DebugLog(
            Winnt32LogMax,
            Text,
            0
            );
    }

    if( CheckUpgradeOnly ) {
        LoadString( hInst, IDS_COMPAT_DIVIDER, Text, sizeof(Text)/sizeof(TCHAR) );
        DebugLog( Winnt32LogInformation,
                  Text,
                  0 );

        LoadString( hInst, IDS_APPTITLE_CHECKUPGRADE, Text, sizeof(Text)/sizeof(TCHAR) );
        DebugLog( Winnt32LogInformation,
                  Text,
                  0 );

        LoadString( hInst, IDS_COMPAT_DIVIDER, Text, sizeof(Text)/sizeof(TCHAR) );
        DebugLog( Winnt32LogInformation,
                  Text,
                  0 );
    }

    return(TRUE);
}


VOID
CloseDebugLog(
    VOID
    )

/*++

Routine Description:

    Close the logging file.

Arguments:

Return Value:

--*/

{
    if( hDebugLog ) {
        CloseHandle( hDebugLog );
    }
}

BOOL
DebugLog(
    IN Winnt32DebugLevel Level,
    IN LPCTSTR           Text,        OPTIONAL
    IN UINT              MessageId,
    ...
    )

/*++

Routine Description:

    Write some text into the debug log file, if there is one.

Arguments:

    Level - supplies the logging level for this log event. Only items
        with a level greater than or equal to the one specified by the user
        are actually logged.

    Text - if specified, supplies the format string for the text message
        to go into the log file. If not specified, MessageId must be.

    MessageId - if Text is not specified, supplies the message id for the
        item in the message table that has the text of the item to be
        written into the log file.

    Additional arguments supply insertion values for the message.

Return Value:

--*/

{
    va_list arglist;
    BOOL b;

    va_start(arglist,MessageId);

    b = DebugLog2 (Level, Text, MessageId, arglist);

    va_end(arglist);

    return b;
}


BOOL
DebugLog2(
    IN Winnt32DebugLevel Level,
    IN LPCTSTR           Text,        OPTIONAL
    IN UINT              MessageId,
    IN va_list           ArgList
    )

/*++

Routine Description:

    Write some text into the debug log file, if there is one.

Arguments:

    Level - supplies the logging level for this log event. Only items
        with a level greater than or equal to the one specified by the user
        are actually logged.

    Text - if specified, supplies the format string for the text message
        to go into the log file. If not specified, MessageId must be.

    MessageId - if Text is not specified, supplies the message id for the
        item in the message table that has the text of the item to be
        written into the log file.

    Additional arguments supply insertion values for the message.

Return Value:

--*/

{
    CHAR AnsiMessage[5000];
    DWORD Size;
    DWORD Written;
    LPCTSTR Message;
    BOOL b;
    DWORD rc;

    if(!hDebugLog) {
        return(FALSE);
    }

    if((Level & ~WINNT32_HARDWARE_LOG) > DebugLevel) {
        return(TRUE);
    }

    rc = GetLastError ();

    if(Text) {
        Size = FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                    Text,
                    0,0,
                    (LPTSTR)&Message,
                    0,
                    &ArgList
                    );
    } else {
        Size = FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
                    hInst,
                    MessageId,
                    0,
                    (LPTSTR)&Message,
                    0,
                    &ArgList
                    );
    }

    if(Size) {
#ifdef UNICODE
        WideCharToMultiByte(
             CP_ACP,
             0,
             Message,
             -1,
             AnsiMessage,
             sizeof(AnsiMessage),
             NULL,
             NULL
             );
#else
        lstrcpyn(AnsiMessage,Message,sizeof(AnsiMessage));
#endif

        b = WriteFile(hDebugLog,AnsiMessage,lstrlenA(AnsiMessage),&Written,NULL);
        if ((Level & WINNT32_HARDWARE_LOG) == 0) {
            if (Text && b) {
                if (Level <= Winnt32LogError && rc) {
                    CHAR buffer[50];
                    b = WriteFile(
                            hDebugLog,
                            buffer,
                            wsprintfA (buffer, " (rc=%u[0x%X])\r\n", rc, rc),
                            &Written,
                            NULL
                            );
                } else {
                    b = WriteFile(hDebugLog,"\r\n", 2, &Written,NULL);
                }
            }
        }

        LocalFree((HLOCAL)Message);
    } else {
        b = FALSE;
    }

    SetLastError (rc);
    return(b);
}

#if ASSERTS_ON

VOID
AssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    )
{
    int i;
    CHAR Name[MAX_PATH];
    PCHAR p;
    CHAR Msg[4096];

    //
    // Use dll name as caption
    //
    GetModuleFileNameA(hInst,Name,MAX_PATH);
    if(p = strrchr(Name,'\\')) {
        p++;
    } else {
        p = Name;
    }

    wsprintfA(
        Msg,
        "Assertion failure at line %u in file %s: %s\n\nCall DebugBreak()?",
        LineNumber,
        FileName,
        Condition
        );

    i = MessageBoxA(
            NULL,
            Msg,
            p,
            MB_YESNO | MB_TASKMODAL | MB_ICONSTOP | MB_SETFOREGROUND
            );

    if(i == IDYES) {
        DebugBreak();
    }
}


#endif


VOID
MyEnumerateDirectory(
    LPTSTR      DirectoryName,
    DWORD       Index,
    BOOL        Recordable
    )

/*++

Routine Description:

    This routine will enumerate all files in a directory structure.
    It then prints those filenames into the debug logfile.

Arguments:

    DirectoryName   Name of the directory we're currently examining.

    Index           Indicates our recurse-level.  Used for formatting
                    the output.

    Recordable      This determines if we will be logging this item
                    or not.  Some items we don't care about.

Return Value:

--*/

{
TCHAR       TmpDirectoryString[MAX_PATH];
TCHAR       TmpName[MAX_PATH];
HANDLE      FindHandle;
WIN32_FIND_DATA FoundData;
DWORD       i;

    //
    // Fix our path so we know where we're looking...
    //
    if( DirectoryName[0] ) {
        lstrcpy( TmpDirectoryString, DirectoryName );
        if( ISNT() ) {
            ConcatenatePaths( TmpDirectoryString, TEXT("*"), MAX_PATH );
        } else {
            ConcatenatePaths( TmpDirectoryString, TEXT("*.*"), MAX_PATH );
        }
    } else {
        if( ISNT() ) {
            lstrcpy( TmpDirectoryString, TEXT("*") );
        } else {
            lstrcpy( TmpDirectoryString, TEXT("*.*") );
        }
    }

    //
    // Get the first item.
    //
    FindHandle = FindFirstFile( TmpDirectoryString, &FoundData );
    if( !FindHandle || (FindHandle == INVALID_HANDLE_VALUE) ) {
        //
        // The directory is empty.
        //
        return;
    }

    //
    // Now look at every item in the directory.
    //
    do {

        TmpName[0] = 0;
        for( i = 0; i < Index; i++ ) {
            lstrcat( TmpName, TEXT("  ") );
        }
 
        if( FoundData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
            //
            // Directory.  Ignore . and .. entries.
            //
            if(lstrcmp(FoundData.cFileName,TEXT("."))
            && lstrcmp(FoundData.cFileName,TEXT(".."))) {

                //
                // Print the entry.
                //
                lstrcat( TmpName, TEXT("\\") );
                lstrcat( TmpName, FoundData.cFileName );
                lstrcat( TmpName, TEXT("\n") );
                if( ( !lstrcmpi( FoundData.cFileName, TEXT("Start Menu"))) ||
                    ( Recordable ) ) {

                    Recordable = TRUE;

                    if( !_tcsrchr( TmpName, TEXT('%') ) ) {
                        DebugLog( Winnt32LogInformation,
                                  TmpName,
                                  0 );
                    }
                }

                //
                // Call ourselves on this directory.
                //
                lstrcpy( TmpName, DirectoryName );
                ConcatenatePaths( TmpName, FoundData.cFileName, MAX_PATH );
                MyEnumerateDirectory( TmpName, Index+1, Recordable );

                //
                // If we just recursed into a Start Menu directory,
                // we need to turn off recordability.
                //
                if( !lstrcmpi( FoundData.cFileName, TEXT("Start Menu"))) {
                    Recordable = FALSE;
                }
            }
        } else {
            //
            // File.  Just print it.
            //
            if( Recordable ) {
                lstrcat( TmpName, FoundData.cFileName );
                lstrcat( TmpName, TEXT("\n") );
                if( !_tcsrchr( TmpName, TEXT('%') ) ) {
                    DebugLog( Winnt32LogInformation,
                              TmpName,
                              0 );
                }
            }
        }
    } while( FindNextFile( FindHandle, &FoundData ) );
}



VOID
GatherOtherLogFiles(
    VOID
    )

/*++

Routine Description:

    This routine will launch winmsd in a batch-mode, then
    copy it's output onto the backend of our debug log.

Arguments:

Return Value:

--*/

{
STARTUPINFO         StartupInfo;
PROCESS_INFORMATION ProcessInfo;
DWORD               dw,
                    ExitCode;
BOOL                Done;
TCHAR               FileName[MAX_PATH];
TCHAR               ComputerName[MAX_PATH];
MSG                 msg;
TCHAR               Text[512];


    //
    // If we're on Win9X, we will also want %windir%\upgrade.txt.
    //
    if( !ISNT() ) {
        //
        // %windir%\upgrade.txt
        //
        FileName[0] = TEXT('\0');
        MyGetWindowsDirectory( FileName, MAX_PATH );
        ConcatenatePaths( FileName, TEXT("upgrade.txt"), MAX_PATH );
        if( !ConcatenateFile( hDebugLog, FileName ) ) {
            DebugLog( Winnt32LogInformation,
                      TEXT("\r\nFailed to append upgrade.txt!\r\n"),
                      0 );
        }

        //
        // %windir%\beta-upg.log
        //
        FileName[0] = TEXT('\0');
        MyGetWindowsDirectory( FileName, MAX_PATH );
        ConcatenatePaths( FileName, TEXT("beta-upg.log"), MAX_PATH );
        if( !ConcatenateFile( hDebugLog, FileName ) ) {
            DebugLog( Winnt32LogInformation,
                      TEXT("\r\nFailed to append beta-upg.log!\r\n"),
                      0 );
        }


        //
        // %windir%\config.dmp
        //
        FileName[0] = TEXT('\0');
        MyGetWindowsDirectory( FileName, MAX_PATH );
        ConcatenatePaths( FileName, TEXT("config.dmp"), MAX_PATH );
        if( !ConcatenateFile( hDebugLog, FileName ) ) {
            DebugLog( Winnt32LogInformation,
                      TEXT("\r\nFailed to append config.dmp!\r\n"),
                      0 );
        }

    }

#if 0
//
// remove winmsd call for now.
//

    if( ISNT() && (BuildNumber > NT351) ) {
        //
        // If we're on NT, run winmsd and capture his
        // output.
        //

        ZeroMemory(&StartupInfo,sizeof(StartupInfo));
        StartupInfo.cb = sizeof(StartupInfo);
        lstrcpy( FileName, TEXT( "winmsd.exe /a" ) );
        if( CreateProcess( NULL,
                           FileName,
                           NULL,
                           NULL,
                           FALSE,
                           0,
                           NULL,
                           NULL,
                           &StartupInfo,
                           &ProcessInfo ) ) {

            //
            // Wait for him.
            //

            //
            // Process any messages that may already be in the queue.
            //
            while(PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
                DispatchMessage(&msg);
            }

            //
            // Wait for process to terminate or more messages in the queue.
            //
            Done = FALSE;
            do {
                switch(MsgWaitForMultipleObjects(1,&ProcessInfo.hProcess,FALSE,INFINITE,QS_ALLINPUT)) {

                case WAIT_OBJECT_0:
                    //
                    // Process has terminated.
                    //
                    dw = GetExitCodeProcess(ProcessInfo.hProcess,&ExitCode) ? NO_ERROR : GetLastError();
                    Done = TRUE;
                    break;

                case WAIT_OBJECT_0+1:
                    //
                    // Messages in the queue.
                    //
                    while(PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
                        DispatchMessage(&msg);
                    }
                    break;

                default:
                    //
                    // Error.
                    //
                    dw = GetLastError();
                    Done = TRUE;
                    break;
                }
            } while(!Done);
        }

        CloseHandle( ProcessInfo.hThread );
        CloseHandle( ProcessInfo.hProcess );

        if( dw == NO_ERROR ) {

            //
            // Concatenate him onto the end of our logfile.  His
            // logfile will be <computer_name>.txt and will be
            // located in our directory.  Map the file...
            //

            DebugLog( Winnt32LogInformation,
                      TEXT("\r\n\r\n********************************************************************\r\n\r\n"),
                      0 );
            DebugLog( Winnt32LogInformation,
                      TEXT("\t\tWinMSD Log\n"),
                      0 );
            DebugLog( Winnt32LogInformation,
                      TEXT("\r\n********************************************************************\r\n\r\n"),
                      0 );

            GetCurrentDirectory( MAX_PATH, FileName );
            dw = MAX_PATH;
            GetComputerName( ComputerName, &dw );
            ConcatenatePaths( FileName, ComputerName, MAX_PATH );
            lstrcat( FileName, TEXT(".txt") );

            ConcatenateFile( hDebugLog, FileName );

        } else {
            //
            // Should we log our failure to be sneaky??
            //
        }
    }
#endif


    //
    // Go enumerate the Start Menu
    // for all users...  Don't do this for NT 3.51.
    //
    if( !(ISNT() && (BuildNumber <= NT351)) ){

        LoadString( hInst, IDS_COMPAT_DIVIDER, Text, sizeof(Text)/sizeof(TCHAR) );
        DebugLog( Winnt32LogInformation,
                  Text,
                  0 );

        LoadString( hInst, IDS_COMPAT_STRT_MENU, Text, sizeof(Text)/sizeof(TCHAR) );
        DebugLog( Winnt32LogInformation,
                  Text,
                  0 );

        LoadString( hInst, IDS_COMPAT_DIVIDER, Text, sizeof(Text)/sizeof(TCHAR) );
        DebugLog( Winnt32LogInformation,
                  Text,
                  0 );


        if( !ISNT() ) {
            //
            // On Win9X, we can find Start Menu items in
            // two places!
            //
            MyGetWindowsDirectory( FileName, MAX_PATH );
            ConcatenatePaths( FileName, TEXT("Start Menu"), MAX_PATH );
            MyEnumerateDirectory( FileName, 0, TRUE );
        } else {
            if( BuildNumber >= 1890 ) {
                //
                // Starting on build 1890, we moved/renamed the Profiles
                // directory.  Of course, that only happens on clean installs
                // of these new builds.  We need to see if there's anything
                // in the new directory structure.
                //
                MyGetWindowsDirectory( FileName, MAX_PATH );
                FileName[3] = 0;
                ConcatenatePaths( FileName, TEXT("Documents and Settings"), MAX_PATH );
                MyEnumerateDirectory( FileName, 0, FALSE );
            }
        }

        MyGetWindowsDirectory( FileName, MAX_PATH );
        ConcatenatePaths( FileName, TEXT("Profiles"), MAX_PATH );
        MyEnumerateDirectory( FileName, 0, FALSE );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\diamond.c ===
/*++

Module Name:

    diamond.c

Abstract:

    Diamond compression routines.

    This module contains functions to create a cabinet with
    files compressed using the mszip compression library.

Author:

    Ovidiu Temereanca (ovidiut) 26-Oct-2000

--*/

#include "precomp.h"
#include <fci.h>
#include <io.h>
#include <fcntl.h>

static DWORD g_DiamondLastError;
static PCSTR g_TempDir = NULL;

HFCI
(DIAMONDAPI* g_FCICreate) (
    PERF              perf,
    PFNFCIFILEPLACED  pfnfcifp,
    PFNFCIALLOC       pfna,
    PFNFCIFREE        pfnf,
    PFNFCIOPEN        pfnopen,
    PFNFCIREAD        pfnread,
    PFNFCIWRITE       pfnwrite,
    PFNFCICLOSE       pfnclose,
    PFNFCISEEK        pfnseek,
    PFNFCIDELETE      pfndelete,
    PFNFCIGETTEMPFILE pfnfcigtf,
    PCCAB             pccab,
    void FAR *        pv
    );

BOOL
(DIAMONDAPI* g_FCIAddFile) (
    HFCI                  hfci,
    char                 *pszSourceFile,
    char                 *pszFileName,
    BOOL                  fExecute,
    PFNFCIGETNEXTCABINET  pfnfcignc,
    PFNFCISTATUS          pfnfcis,
    PFNFCIGETOPENINFO     pfnfcigoi,
    TCOMP                 typeCompress
    );
/*
BOOL
(DIAMONDAPI* g_FCIFlushFolder) (
    HFCI                  hfci,
    PFNFCIGETNEXTCABINET  pfnfcignc,
    PFNFCISTATUS          pfnfcis
    );
*/
BOOL
(DIAMONDAPI* g_FCIFlushCabinet) (
    HFCI                  hfci,
    BOOL                  fGetNextCab,
    PFNFCIGETNEXTCABINET  pfnfcignc,
    PFNFCISTATUS          pfnfcis
    );

BOOL
(DIAMONDAPI* g_FCIDestroy) (
    HFCI hfci
    );

//
// Callback functions to perform memory allocation, io, etc.
// We pass addresses of these functions to diamond.
//
int
DIAMONDAPI
fciFilePlacedCB(
    OUT PCCAB Cabinet,
    IN  PSTR  FileName,
    IN  LONG  FileSize,
    IN  BOOL  Continuation,
    IN  PVOID Context
    )

/*++

Routine Description:

    Callback used by diamond to indicate that a file has been
    comitted to a cabinet.

    No action is taken and success is returned.

Arguments:

    Cabinet - cabinet structure to fill in.

    FileName - name of file in cabinet

    FileSize - size of file in cabinet

    Continuation - TRUE if this is a partial file, continuation
        of compression begun in a different cabinet.

    Context - supplies context information.

Return Value:

    0 (success).

--*/

{
    return(0);
}



PVOID
DIAMONDAPI
fciAllocCB(
    IN ULONG NumberOfBytes
    )

/*++

Routine Description:

    Callback used by diamond to allocate memory.

Arguments:

    NumberOfBytes - supplies desired size of block.

Return Value:

    Returns pointer to a block of memory or NULL
    if memory cannot be allocated.

--*/

{
    return((PVOID)LocalAlloc(LMEM_FIXED,NumberOfBytes));
}


VOID
DIAMONDAPI
fciFreeCB(
    IN PVOID Block
    )

/*++

Routine Description:

    Callback used by diamond to free a memory block.
    The block must have been allocated with fciAlloc().

Arguments:

    Block - supplies pointer to block of memory to be freed.

Return Value:

    None.

--*/

{
    LocalFree((HLOCAL)Block);
}



FNFCIGETTEMPFILE(fciTempFileCB)
{
    if (!GetTempFileNameA (g_TempDir ? g_TempDir : ".", "dc" ,0 , pszTempName)) {
        return FALSE;
    }

    DeleteFileA(pszTempName);
    return(TRUE);
}


BOOL
DIAMONDAPI
fciNextCabinetCB(
    OUT PCCAB Cabinet,
    IN  DWORD CabinetSizeEstimate,
    IN  PVOID Context
    )

/*++

Routine Description:

    Callback used by diamond to request a new cabinet file.
    This functionality is not used in our implementation.

Arguments:

    Cabinet - cabinet structure to be filled in.

    CabinetSizeEstimate - estimated size of cabinet.

    Context - supplies context information.

Return Value:

    FALSE (failure).

--*/

{
    return(FALSE);
}


BOOL
DIAMONDAPI
fciStatusCB(
    IN UINT  StatusType,
    IN DWORD Count1,
    IN DWORD Count2,
    IN PVOID Context
    )

/*++

Routine Description:

    Callback used by diamond to give status on file compression
    and cabinet operations, etc.

    This routine has no effect.

Arguments:

    Status Type - supplies status type.

        0 = statusFile   - compressing block into a folder.
                              Count1 = compressed size
                              Count2 = uncompressed size

        1 = statusFolder - performing AddFilder.
                              Count1 = bytes done
                              Count2 = total bytes

    Context - supplies context info.

Return Value:

    TRUE (success).

--*/

{
    return(TRUE);
}



FNFCIGETOPENINFO(fciOpenInfoCB)

/*++

Routine Description:

    Callback used by diamond to open a file and retreive information
    about it.

Arguments:

    pszName - supplies filename of file about which information
        is desired.

    pdate - receives last write date of the file if the file exists.

    ptime - receives last write time of the file if the file exists.

    pattribs - receives file attributes if the file exists.

    pv - supplies context information.

Return Value:

    C runtime handle to open file if success; -1 if file could
    not be located or opened.

--*/

{
    int h;
    WIN32_FIND_DATAA FindData;
    HANDLE FindHandle;

    FindHandle = FindFirstFileA(pszName,&FindData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        g_DiamondLastError = GetLastError();
        return(-1);
    }
    FindClose(FindHandle);

    FileTimeToDosDateTime(&FindData.ftLastWriteTime,pdate,ptime);
    *pattribs = (WORD)FindData.dwFileAttributes;

    h = _open(pszName,_O_RDONLY | _O_BINARY);
    if(h == -1) {
        g_DiamondLastError = GetLastError();
        return(-1);
    }

    return(h);
}

FNFCIOPEN(fciOpen)
{
    int result;

    result = _open(pszFile, oflag, pmode);

    if (result == -1) {
        *err = errno;
    }

    return(result);
}

FNFCIREAD(fciRead)
{
    UINT result;

    result = (UINT) _read((int)hf, memory, cb);

    if (result != cb) {
        *err = errno;
    }

    return(result);
}

FNFCIWRITE(fciWrite)
{
    UINT result;

    result = (UINT) _write((int)hf, memory, cb);

    if (result != cb) {
        *err = errno;
    }

    return(result);
}

FNFCICLOSE(fciClose)
{
    int result;

    result = _close((int)hf);

    if (result == -1) {
        *err = errno;
    }

    return(result);
}

FNFCISEEK(fciSeek)
{
    long result;

    result = _lseek((int)hf, dist, seektype);

    if (result == -1) {
        *err = errno;
    }

    return(result);

}

FNFCIDELETE(fciDelete)
{
    int result;

    result = _unlink(pszFile);

    if (result == -1) {
        *err = errno;
    }

    return(result);
}


HANDLE
DiamondInitialize (
    IN      PCTSTR TempDir
    )
{
    HMODULE hCabinetDll;

    hCabinetDll = LoadLibrary (TEXT("cabinet.dll"));
    if (!hCabinetDll) {
        return FALSE;
    }

    (FARPROC)g_FCICreate = GetProcAddress (hCabinetDll, "FCICreate");
    (FARPROC)g_FCIAddFile = GetProcAddress (hCabinetDll, "FCIAddFile");
    (FARPROC)g_FCIFlushCabinet = GetProcAddress (hCabinetDll, "FCIFlushCabinet");
    (FARPROC)g_FCIDestroy = GetProcAddress (hCabinetDll, "FCIDestroy");

    if (!g_FCICreate || !g_FCIAddFile || !g_FCIFlushCabinet || !g_FCIDestroy) {
        DiamondTerminate (hCabinetDll);
        return NULL;
    }

    if (TempDir && !g_TempDir) {
#ifdef UNICODE
        g_TempDir = UnicodeToAnsi (TempDir);
#else
        g_TempDir = DupString (TempDir);
#endif
    }

    return hCabinetDll;
}

VOID
DiamondTerminate (
    IN      HANDLE Handle
    )
{
    FreeLibrary (Handle);
    g_FCICreate = NULL;
    g_FCIAddFile = NULL;
    g_FCIFlushCabinet = NULL;
    g_FCIDestroy = NULL;
    if (g_TempDir) {
        FREE ((PVOID)g_TempDir);
        g_TempDir = NULL;
    }
}


HANDLE
DiamondStartNewCabinet (
    IN      PCTSTR CabinetFilePath
    )
{
    CCAB ccab;
    ERF FciError;
    HFCI FciContext;
    PSTR p;
    //
    // Fill in the cabinet structure.
    //
    ZeroMemory (&ccab, sizeof(ccab));

#ifdef UNICODE
    if (!WideCharToMultiByte (
            CP_ACP,
            0,
            CabinetFilePath,
            -1,
            ccab.szCabPath,
            sizeof (ccab.szCabPath) / sizeof (ccab.szCabPath[0]),
            NULL,
            NULL
            )) {
        return NULL;
    }
#else
    lstrcpyA (ccab.szCabPath, CabinetFilePath);
#endif

    p = strrchr (ccab.szCabPath, '\\');
    if(!p) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return NULL;
    }

    lstrcpyA (ccab.szCab, ++p);
    *p = 0;

    g_DiamondLastError = NO_ERROR;

    FciContext = g_FCICreate(
                    &FciError,
                    fciFilePlacedCB,
                    fciAllocCB,
                    fciFreeCB,
                    fciOpen,
                    fciRead,
                    fciWrite,
                    fciClose,
                    fciSeek,
                    fciDelete,
                    fciTempFileCB,
                    &ccab,
                    NULL
                    );

    return (HANDLE)FciContext;
}

BOOL
DiamondAddFileToCabinet (
    IN      HANDLE CabinetContext,
    IN      PCTSTR SourceFile,
    IN      PCTSTR NameInCabinet
    )
{
    HFCI FciContext = (HFCI)CabinetContext;
    BOOL b;
    CHAR AnsiSourceFile[MAX_PATH];
    CHAR AnsiNameInCabinet[MAX_PATH];

#ifdef UNICODE
    if (!WideCharToMultiByte (
            CP_ACP,
            0,
            SourceFile,
            -1,
            AnsiSourceFile,
            sizeof (AnsiSourceFile) / sizeof (AnsiSourceFile[0]),
            NULL,
            NULL
            ) ||
        !WideCharToMultiByte (
            CP_ACP,
            0,
            NameInCabinet,
            -1,
            AnsiNameInCabinet,
            sizeof (AnsiNameInCabinet) / sizeof (AnsiNameInCabinet[0]),
            NULL,
            NULL
            )) {
        return FALSE;
    }
#else
    lstrcpyA (AnsiSourceFile, SourceFile);
    lstrcpyA (AnsiNameInCabinet, NameInCabinet);
#endif

    b = g_FCIAddFile (
            FciContext,
            AnsiSourceFile,     // file to add to cabinet.
            AnsiNameInCabinet,  // filename part, name to store in cabinet.
            FALSE,              // fExecute on extract
            fciNextCabinetCB,   // routine for next cabinet (always fails)
            fciStatusCB,
            fciOpenInfoCB,
            tcompTYPE_MSZIP
            );

    if (!b) {
        SetLastError (g_DiamondLastError == NO_ERROR ? ERROR_INVALID_FUNCTION : g_DiamondLastError);
    }

    return b;
}


BOOL
DiamondTerminateCabinet (
    IN      HANDLE CabinetContext
    )
{
    HFCI FciContext = (HFCI)CabinetContext;
    BOOL b;

    b = g_FCIFlushCabinet (
            FciContext,
            FALSE,
            fciNextCabinetCB,
            fciStatusCB
            );

    g_FCIDestroy (FciContext);

    if (!b) {
        SetLastError (g_DiamondLastError == NO_ERROR ? ERROR_INVALID_FUNCTION : g_DiamondLastError);
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\dll.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    dll.c

Abstract:

    Routines that interface this dll to the system, such as
    the dll entry point.

Author:

    Ted Miller (tedm) 4 December 1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop



BOOL
WINAPI
DllMain(
    HINSTANCE ModuleHandle,
    DWORD     Reason,
    PVOID     Reserved
    )

/*++

Routine Description:

    Dll entry point.

Arguments:

Return Value:

--*/

{
    switch(Reason) {

    case DLL_PROCESS_ATTACH:
        hInst = ModuleHandle;
        TlsIndex = TlsAlloc();
        break;

    case DLL_PROCESS_DETACH:
        TlsFree(TlsIndex);
        break;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\dscheck.c ===
#include "precomp.h"
#pragma hdrstop

#include <stdlib.h>
#include <stdio.h>


// Define registry section and value
#define DSA_CONFIG_SECTION TEXT("System\\CurrentControlSet\\Services\\NTDS\\Parameters")
#define SCHEMAVERSION TEXT("Schema Version")


BOOL 
IsNT5DC()

/*++

Routine Descrtiption:
    Checks if a machine is a NT5 DC. Uses a call to RtlGetProductType that
    requires ntdll.dll. Since ntdll.dll is not loaded for x86 versions of
    setup (since they have to run on Windows95 too), loads ntdll.dll
    dynamically (for alphas, ntdll.dll.is already loaded and LoadLibrary
    returns a handle to it). So this function should be called only after
    checking that the current system is NT

    Currently, this function is called only for NT5 upgrades

Arguments:
    None

Return Value:
    TRUE if the machine is a NT5 DC, FALSE otherwise 

--*/
    
{
    NT_PRODUCT_TYPE Type = NtProductWinNt;
    HMODULE h;
    TCHAR DllName[MAX_PATH]; 
    VOID (*GetPrType)(NT_PRODUCT_TYPE *Typ);

    if (OsVersion.dwMajorVersion != 5) {
       // not NT5
       return FALSE;
    }

     // Load ntdll.dll  from the system directory
    GetSystemDirectory(DllName, MAX_PATH); 
    ConcatenatePaths(DllName, TEXT("ntdll.dll"), MAX_PATH);
    if (h = LoadLibrary(DllName)) {
        if((FARPROC) GetPrType = GetProcAddress(h, "RtlGetNtProductType")) {
             GetPrType(&Type);
         }
         FreeLibrary(h);
     }

    if ( Type == NtProductLanManNt ) {
       return TRUE;
    }
    else {
      return FALSE;
    }
}

BOOL 
ISDC()

/*++

Routine Descrtiption:
    Checks if a machine is a DC. Uses a call to RtlGetProductType that
    requires ntdll.dll. Since ntdll.dll is not loaded for x86 versions of
    setup (since they have to run on Windows95 too), loads ntdll.dll
    dynamically (for alphas, ntdll.dll.is already loaded and LoadLibrary
    returns a handle to it).

Arguments:
    None

Return Value:
    TRUE if the machine is a DC, FALSE otherwise 

--*/
    
{
    NT_PRODUCT_TYPE Type = NtProductWinNt;
    HMODULE h;
    TCHAR DllName[MAX_PATH]; 
    VOID (*GetPrType)(NT_PRODUCT_TYPE *Typ);

    if (!ISNT()) {
       // not NT
       return FALSE;
    }

    // Load ntdll.dll  from the system directory
    GetSystemDirectory(DllName, MAX_PATH); 
    ConcatenatePaths(DllName, TEXT("ntdll.dll"), MAX_PATH);
    if (h = LoadLibrary(DllName)) {
        if((FARPROC) GetPrType = GetProcAddress(h, "RtlGetNtProductType")) {
             GetPrType(&Type);
         }
         FreeLibrary(h);
     }

    if ( Type == NtProductLanManNt ) {
       return TRUE;
    }
    else {
      return FALSE;
    }
}


int 
GetObjVersionInIniFile(
    IN  TCHAR *IniFileName, 
    OUT DWORD *Version
    )

/*++

Routine Decsription:
    Reads the Object-Version key in the SCHEMA section of the
    given ini file and returns the value in *Version. If the 
    key cannot be read, 0 is returned in *Version

Arguments:
    IniFileName - Pointer to null-terminated inifile name
    Version - Pointer to DWORD to return version in

Return Value:
    0

--*/
   
{
    TCHAR Buffer[32];
    BOOL fFound = FALSE;

    LPCTSTR SCHEMASECTION = TEXT("SCHEMA");
    LPCTSTR OBJECTVER = TEXT("objectVersion");
    LPCTSTR DEFAULT = TEXT("NOT_FOUND");


    *Version = 0;

    GetPrivateProfileString(
        SCHEMASECTION,
        OBJECTVER,
        DEFAULT,
        Buffer,
        sizeof(Buffer)/sizeof(TCHAR),
        IniFileName
        );

    if ( lstrcmpi(Buffer, DEFAULT) ) {
         // Not the default string, so got a value
         *Version = _ttoi(Buffer);
         fFound = TRUE;
    }

    return 0;
}


BOOL 
NtdsCheckSchemaVersion(
    IN  TCHAR *IniFileName, 
    OUT DWORD *DCVersion, 
    OUT DWORD *IniVersion
    )

/*++

Routine Description:
    Reads a particular registry key, a key value from a given inifile
    and compares them. 

Arguments:
    IniFileName - Pointer to null-terminated inifile name to read key from
    DCVersion - Pointer to DWORD to return the registry key value in DC
    IniVersion - Pointer to DWORD to return the key value read from inifile

Return:
    TRUE if the two values match, FALSE otherwise

--*/

{
    DWORD regVersion = 0, objVersion = 0;
    DWORD herr, err, dwType, dwSize;
    HKEY  hk;

    // Read the "Schema Version" value from NTDS config section in registry
    // Value is assumed to be 0 if not found
    dwSize = sizeof(regVersion);
    if ( (herr = RegOpenKey(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hk)) ||
           (err = RegQueryValueEx(hk, SCHEMAVERSION, NULL, &dwType, (LPBYTE) &regVersion, &dwSize)) ) {
       // Error getting the key. We assume it is not there
        regVersion = 0;
    }
 
    if (!herr) RegCloseKey(hk);

    // Get key value in inifile
    GetObjVersionInIniFile( IniFileName, &objVersion );

    // Return the two values, and compare and return appropriate boolean
    *DCVersion = regVersion;
    *IniVersion = objVersion;

    if (regVersion != objVersion) {
       return FALSE;
    }

    return TRUE;
}

int 
MyCopyFile(
    IN HWND ParentWnd,
    IN TCHAR *FileName
    )

/*++
    
Routine Description:
    Copies the file specified by filename from the first source 
    (NativeSourcePaths[0]). Files are copied to the system directory, except
    schema.ini, which is copied into windows directory since we do not
    want to overwrite the current schema.ini in the system directory of
    the DC

Arguments:
    ParentWnd - Handle to parent window to raise appropriate error popups
    FileName - Pointer to null-terminated string containg name of file to copy

Return Value:
    DSCHECK_ERR_FILE_NOT_FOUND if file is not found on source
    DSCHECK_ERR_FILE_COPY if error copying file
    DSCHECK_ERR_SUCCESS otherwise

    Also raises appropriate error popups too inform users

--*/

{
    TCHAR SourceName[MAX_PATH], ActualSourceName[MAX_PATH];
    TCHAR TargetName[MAX_PATH];
#if 0
    TCHAR SourceA[MAX_PATH], TargetA[MAX_PATH]; 
#endif
    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;       
    DWORD d = 0;
    int err = 0;
    
    // Create the source file name 
    lstrcpy(SourceName, NativeSourcePaths[0]);

    // First check if the uncompressed file is there
    ConcatenatePaths(SourceName, FileName, MAX_PATH);

    FindHandle = FindFirstFile(SourceName, &FindData);

    if(FindHandle && (FindHandle != INVALID_HANDLE_VALUE)) {
         //
         // Got the file, copy name in ActualSourceName
         //
         FindClose(FindHandle);
         lstrcpy( ActualSourceName, SourceName);
     } else {
         //
         // Don't have the file, try the compressed file name
         //
         GenerateCompressedName(SourceName,ActualSourceName);
         FindHandle = FindFirstFile(ActualSourceName, &FindData);
         if(FindHandle && (FindHandle != INVALID_HANDLE_VALUE)) {
               // Got the file. Name is already in ActualSourceName
               FindClose(FindHandle);
         }
         else {
             ActualSourceName[0] = 0;
         }
    }

    if ( !ActualSourceName[0] ) {
        // file is not found. Error
         MessageBoxFromMessage(
             ParentWnd,
             MSG_DSCHECK_REQD_FILE_MISSING,
             FALSE,
             AppTitleStringId,
             MB_OK | MB_ICONWARNING | MB_TASKMODAL,
             FileName,
             NativeSourcePaths[0]
             );
         return DSCHECK_ERR_FILE_NOT_FOUND;
    }
    // Ok, the file is there. Copy it to system32, except if it is 
    // schema.ini, in which case copy it to windows directory 
    if (lstrcmpi(FileName, TEXT("schema.ini")) == 0) {
       MyGetWindowsDirectory(TargetName, MAX_PATH) ;
    } 
    else {
       GetSystemDirectory(TargetName, MAX_PATH);
    }
    ConcatenatePaths(TargetName, FileName, MAX_PATH);
   
    // Delete any existing file of the same name
    DeleteFile(TargetName);

#if 0    
    // Ok, the names are ready. Create the ANSI versions in SourceA
    // and TargetA, since we will be calling the setupapi routine
    // SetupDecompressOrCopyFileA which is only Ansi
#ifdef UNICODE
    d = WideCharToMultiByte(
                CP_ACP,
                0,
                ActualSourceName,
                -1,
                (LPSTR) SourceA,
                MAX_PATH,
                NULL,
                NULL
                );    
    if (d) {
       d = WideCharToMultiByte(
                   CP_ACP,
                   0,
                   TargetName,
                   -1,
                   (LPSTR) TargetA,
                   MAX_PATH,
                   NULL,
                   NULL
                   );
    }
    if (!d) {
        err = 1;
    }
#else
    lstrcpy(SourceA, ActualSourceName);
    lstrcpy(TargetA, TargetName);
#endif

    if (!err) {
      err = SetupapiDecompressOrCopyFile((LPCSTR) SourceA, (LPCSTR) TargetA, NULL);
    }
#endif
    
    if (!err) {
      err = SetupapiDecompressOrCopyFile (ActualSourceName, TargetName, 0);
    }
    if (err) {
       // some error copying file. Raise message box
         MessageBoxFromMessage(
             ParentWnd,
             MSG_DSCHECK_COPY_ERROR,
             FALSE,
             AppTitleStringId,
             MB_OK | MB_ICONWARNING | MB_TASKMODAL,
             FileName,
             NativeSourcePaths[0]
             );
          return DSCHECK_ERR_FILE_COPY;
    }

    // successfully copied file
    return DSCHECK_ERR_SUCCESS;
    
}


int 
CheckSchemaVersionForNT5DCs(
    IN HWND ParentWnd
    )

/*++
 
Routine Description:
    Main routine called from Options wizard page to initiate schema version
    check

Arguments:
    ParentWnd - Handle to parent window to raise errors

Return Value:
    DSCHECK_ERR_FILE_NOT_FOUND if a required file is not found
    DSCHECK_ERR_FILE_COPY if error copying a required file
    DSCHECK_ERR_SCHEMA_MISMATCH if schema versions do not match
    DSCHECK_ERR_SUCCESS otherwise

    Also pops up appropriate error windows on DSCHECK_ERR_SCHEMA_MISMATCH.
    Error Windows for the other errors are opened by downlevel routines 

--*/
{
    TCHAR FileName[MAX_PATH];
    TCHAR IniFilePath[MAX_PATH];
    TCHAR IniVerStr[32], RegVerStr[32], TempStr[32];
    DWORD RegVer, IniVer, i;
    int err;
    int err1=0;
   
    if (!IsNT5DC()) {
      // Not an NT5 DC, nothing to do
      return DSCHECK_ERR_SUCCESS;
    }
 
    // copy the schema.ini to the local windows directory

    lstrcpy(FileName, TEXT("schema.ini"));
    err = MyCopyFile(ParentWnd, FileName);
    if (err) {
        // return DSCHECK error returned by MyCopyFile
        return err;
    }


    // The schema.ini is now copied to windows directory. 
    // Do schema version check

    MyGetWindowsDirectory(IniFilePath, MAX_PATH);
    ConcatenatePaths(IniFilePath, TEXT("schema.ini"), MAX_PATH);
    if ( NtdsCheckSchemaVersion( IniFilePath, &RegVer, &IniVer) ) {
        // The schema versions match. Nothing to do
        return DSCHECK_ERR_SUCCESS;
    }

    // We are here means schema versions do not match. 
    // Copy all necesary files for schema upgrades. 

    _itot(IniVer, IniVerStr, 10); 
    _itot(RegVer, RegVerStr, 10); 

    if ( (RegVer < 10) && (IniVer >= 10) ) {
      // Trying to upgrade from before B3-RC1 to B3-RC1 or above.
      // B3-RC1 or above requires a clean install due to incompatible
      // DS checkins. No upgrades are possible. Pop up the clean install
      // message and leave

      MessageBoxFromMessage(
             ParentWnd,
             MSG_DSCHECK_SCHEMA_CLEAN_INSTALL_NEEDED,
             FALSE,
             AppTitleStringId,
             MB_OK | MB_ICONERROR | MB_TASKMODAL,
             RegVerStr,
             IniVerStr
             );

      return DSCHECK_ERR_VERSION_MISMATCH;
    }

    if (RegVer == 16) {
        // trying to upgrade a machine in an enterprise with schema
        // version of 16 (Whistler-Beta1)
        // possibly, there are beta1 machines lying around
        // so we have to tell them to demote them before they continue

        i = MessageBoxFromMessage(
               ParentWnd,
               MSG_DSCHECK_SCHEMA_WHISTLER_BETA1_DETECTED,
               FALSE,
               AppTitleStringId,
               MB_OKCANCEL | MB_ICONWARNING | MB_TASKMODAL,
               NULL
               );

        if(i == IDCANCEL) {
            return DSCHECK_ERR_VERSION_MISMATCH;
        }
    }



    if ( RegVer > IniVer ) {
      // The schema version in the enterprise is already greater than 
      // the schema version of the build you are trying to upgrade to. 
      //
      // This is okay. Imagine upgrading a 5.0 DC to the next service
      // pack even though the 5.0 DC is in a domain of mixed 5.0 and
      // 5.1 DCs. The schema version for the 5.0 DC is the same as the
      // schema version for the 5.1 DCs because schema upgrades replicate
      // to all DCs in an enterprise. There is no reason to disallow
      // upgrading the 5.0 DC to the next service pack even though
      // the schema version of the service pack (IniVer) is less than
      // the schema version of the 5.0 DC (RegVer).
      return DSCHECK_ERR_SUCCESS;
    }



    // Else, upgrade is possible, so copy all necessary files

     // copy all files from version on DC to latest version
     for ( i=RegVer+1; i<=IniVer; i++ ) {
        _itot(i, TempStr, 10);
        lstrcpy(FileName, TEXT("sch"));
        lstrcat(FileName, TempStr);
        lstrcat(FileName, TEXT(".ldf"));
        err1 = MyCopyFile(ParentWnd, FileName);
        if (err1 != DSCHECK_ERR_SUCCESS) {
           // error copying file. Return if file not found,
           // else just break out of loop.
           if (err1 == DSCHECK_ERR_FILE_NOT_FOUND) {
               return err1;
           }
           else {
             break;
           }
        }
      }

      if (err1) {
          // error copying at least one file, and not a file not 
          // found error. raise appropriate message and return
          MessageBoxFromMessage(
                 ParentWnd,
                 MSG_DSCHECK_SCHEMA_UPGRADE_COPY_ERROR,
                 FALSE,
                 AppTitleStringId,
                 MB_OK | MB_ICONERROR | MB_TASKMODAL,
                 RegVerStr,
                 IniVerStr
                 );
          return DSCHECK_ERR_FILE_COPY;
      }

      // Files copied successfully
      MessageBoxFromMessage(
             ParentWnd,
             MSG_DSCHECK_SCHEMA_UPGRADE_NEEDED,
             FALSE,
             AppTitleStringId,
             MB_OK | MB_ICONERROR | MB_TASKMODAL,
             RegVerStr,
             IniVerStr
             );

      return DSCHECK_ERR_VERSION_MISMATCH;
   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\diamond.h ===
/*++

Module Name:

    diamond.h

Abstract:

    Diamond compression interface.

    This module contains functions to create a cabinet with
    files compressed using the mszip compression library.

Author:

    Ovidiu Temereanca (ovidiut) 26-Oct-2000

--*/

HANDLE
DiamondInitialize (
    IN      PCTSTR TempDir
    );

VOID
DiamondTerminate (
    IN      HANDLE Handle
    );

HANDLE
DiamondStartNewCabinet (
    IN      PCTSTR CabinetFilePath
    );

BOOL
DiamondAddFileToCabinet (
    IN      HANDLE CabinetContext,
    IN      PCTSTR SourceFile,
    IN      PCTSTR NameInCabinet
    );

BOOL
DiamondTerminateCabinet (
    IN      HANDLE CabinetContext
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\dynupdt.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dynupdt.h

Abstract:

    Interface for code that implements the Dynamic Update feature of Winnt32.

Author:

    Ovidiu Temereanca (ovidiut) 06-Jul-2000

Revision History:

    <alias>  <date>      <comment>

--*/


#define DynUpdtLogLevel     Winnt32LogInformation


#ifdef PRERELEASE
#define TRY
#define EXCEPT(e)   goto __skip;
#define _exception_code() 0
#define END_EXCEPT  __skip:;
#else
#define TRY         __try
#define EXCEPT(e)   __except (e)
#define END_EXCEPT
#endif


#define S_DUCTRL_DLL                    TEXT("wsdu.dll")
#define S_HWDB_DLL                      TEXT("hwdb.dll")

#define S_REGKEY_MIGRATION_DLLS_WIN9X   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\Migration DLLs")
#define S_REGVALUE_DYNUPDT              TEXT("DynUpdt")


typedef
BOOL
(CALLBACK* PWIN9XGETINCOMPDRVS) (
    OUT     PSTR** IncompatibleDrivers
    );

typedef
VOID
(CALLBACK* PWIN9XRELEASEINCOMPDRVS) (
    IN      PSTR* IncompatibleDrivers
    );

typedef enum {
    DUS_INITIAL = 0,
    DUS_SKIP,
    DUS_PREPARING,
    DUS_PREPARING_CONNECTIONUNAVAILABLE,
    DUS_PREPARING_INVALIDURL,
    DUS_DOWNLOADING,
    DUS_DOWNLOADING_ERROR,
    DUS_PROCESSING,
    DUS_SUCCESSFUL,
    DUS_CANCELLED,
    DUS_ERROR,
    DUS_FATALERROR,
} DUS_STATUS;

typedef struct {
    DUS_STATUS DUStatus;
    BOOL Disabled;
    BOOL SupportQueried;
    BOOL SupportPresent;
    BOOL RestartWinnt32;
    BOOL PrepareWinnt32;
    BOOL Winnt32Restarted;
    BOOL Cancelled;
    BOOL PreserveWorkingDir;
    BOOL ForceRemoveWorkingDir;
    PTSTR RestartCmdLine;
    TCHAR RestartAnswerFile[MAX_PATH];
    TCHAR DynamicUpdatesSource[MAX_PATH];
    TCHAR UpdatesPath[MAX_PATH];
    TCHAR UpdatesCabSource[MAX_PATH];
    TCHAR UpdatesCabTarget[MAX_PATH];
    TCHAR DuasmsSource[MAX_PATH];
    TCHAR DuasmsTarget[MAX_PATH];
    TCHAR WorkingDir[MAX_PATH];
    TCHAR DriversSource[MAX_PATH];
    TCHAR SelectedDrivers[MAX_PATH];
    TCHAR GuidrvsInfSource[MAX_PATH];
    BOOL UserSpecifiedUpdates;
    TCHAR Winnt32Path[MAX_PATH];
    TCHAR TempDir[MAX_PATH];
    PSDLIST NewDriversList;
    PSTRINGLIST BootDriverPathList;
    DWORD IncompatibleDriversCount;
    //
    // target OS information
    //
    OSVERSIONINFOEX TargetOsVersion;
    TCHAR TargetPlatform[32];               // "i386", "ia64"
    LCID TargetLCID;

    //
    // Support libraries stuff
    //
    HWND ProgressWindow;

    HANDLE DuLib;
    HANDLE Connection;

    PDUISSUPPORTED DuIsSupported;
    PDUINITIALIZE DuInitialize;
    PDUDODETECTION DuDoDetection;
    PDUQUERYUNSUPDRVS DuQueryUnsupDrvs;
    PDUBEGINDOWNLOAD DuBeginDownload;
    PDUABORTDOWNLOAD DuAbortDownload;
    PDUUNINITIALIZE DuUninitialize;


    HANDLE HwdbLib;
    HANDLE HwdbDatabase;

    PHWDBINITIALIZE HwdbInitialize;
    PHWDBTERMINATE HwdbTerminate;
    PHWDBOPEN HwdbOpen;
    PHWDBCLOSE HwdbClose;
    PHWDBAPPENDINFS HwdbAppendInfs;
    PHWDBFLUSH HwdbFlush;
    PHWDBHASDRIVER HwdbHasDriver;
    PHWDBHASANYDRIVER HwdbHasAnyDriver;
#ifndef UNICODE
    PWIN9XGETINCOMPDRVS Win9xGetIncompDrvs;
    PWIN9XRELEASEINCOMPDRVS Win9xReleaseIncompDrvs;
#endif

} DYNUPDT_STATUS, *PDYNUPDT_STATUS;

extern PDYNUPDT_STATUS g_DynUpdtStatus;



typedef struct {
    PCTSTR DownloadRoot;
    POSVERSIONINFOEX TargetOsVersion;
    PCTSTR TargetPlatform;                  // "i386", "ia64"
    LCID TargetLCID;
    BOOL Upgrade;
    PCTSTR* SourceDirs;
    DWORD SourceDirsCount;
    BOOL Unattend;
    PCTSTR AnswerFile;
    HWND ProgressWindow;
    PTSTR TempDir;
} DYNUPDT_INIT, *PDYNUPDT_INIT;


typedef struct {
    TCHAR BaseDir[MAX_PATH];
} DYNUPDTSTATUS_INFO, *PDYNUPDTSTATUS_INFO;


typedef struct {
    BOOL ExpressUpgrade;        // WelcomeWizPage
    TCHAR OemPid[30];           // OemPid30WizPage
    TCHAR CdPid[30];            // CdPid30WizPage
} RESTART_DATA, *PRESTART_DATA;

extern RESTART_DATA g_RestartData;

#define S_DOWNLOAD_ROOT         TEXT("setupupd")
#define S_CABNAME_UPDATES       TEXT("updates.cab")
#define S_CABNAME_UPGINFS       TEXT("upginfs.cab")
#define S_CABNAME_MIGDLLS       TEXT("migdlls.cab")
#define S_CABNAME_WINNT32       TEXT("winnt32.cab")
#define S_CABNAME_IDENT         TEXT("ident.cab")
#define S_CABNAME_WSDUENG       TEXT("wsdueng.cab")
#define S_CABNAME_DUASMS        TEXT("duasms.cab")
#define S_SUBDIRNAME_UPDATES    TEXT("updates")
#define S_SUBDIRNAME_UPGINFS    TEXT("upginfs")
#define S_SUBDIRNAME_MIGDLLS    TEXT("migdlls")
#define S_SUBDIRNAME_WINNT32    TEXT("winnt32")
#define S_SUBDIRNAME_DUASMS     TEXT("duasms")
#define S_SUBDIRNAME_TEMP       TEXT("temp")
#define S_SUBDIRNAME_DRIVERS    TEXT("dudrvs")
#define S_SECTIONNAME_UPDATES   TEXT("updates")
#define S_RESTART_TXT           TEXT("restart.txt")
#define S_PATCH_FILE_EXT        TEXT("*._p1")
#define S_HWCOMP_DAT            TEXT("hwcomp.dat")
#define S_GUI_DRIVERS_INF       TEXT("guidrvs.inf")
#define S_SECTION_VERSION       TEXT("Version")
#define S_SECTION_DRIVERS       TEXT("Drivers")
#define S_SECTION_EXCLUDED_DRVS TEXT("ExcludedDrivers")
#define S_DRIVER_TYPE_KEY       TEXT("DriversAreGuiApproved")
#define S_DU_SYNC_EVENT_NAME    TEXT("_WINNT32_DU_")
//
// if this file is present in winnt32.cab, Setup will restart unconditionally
//
#define S_RESTART_FILENAME      TEXT("winnt32.rst")
//
// if this file is present in updates.cab, Setup will create a local source directory
//
#define S_MAKE_LS_FILENAME      TEXT("updates.~ls")

#define DYN_DISKSPACE_PADDING   10000000

BOOL
DynamicUpdateInitialize (
    VOID
    );

VOID
DynamicUpdateUninitialize (
    VOID
    );

BOOL
DynamicUpdateBuildDefaultPaths (
    VOID
    );

BOOL
DynamicUpdateIsSupported (
    IN      HWND ParentWnd
    );

BOOL
__inline
DynamicUpdateSuccessful (
    VOID
    )
{
    return g_DynUpdtStatus && g_DynUpdtStatus->DUStatus == DUS_SUCCESSFUL;
}

DWORD
WINAPI
DoDynamicUpdate (
    LPVOID Parameter
    );

BOOL
DynamicUpdateInitDownload (
    IN      HWND hNotifyWnd
    );

BOOL
DynamicUpdateStart (
    OUT     PDWORD TotalEstimatedTime,
    OUT     PDWORD TotalEstimatedSize
    );

VOID
DynamicUpdateCancel (
    VOID
    );

BOOL
DynamicUpdateProcessFiles (
    OUT     PBOOL StopSetup
    );

BOOL
DynamicUpdateWriteParams (
    IN      PCTSTR ParamsFile
    );

BOOL
DynamicUpdatePrepareRestart (
    VOID
    );

BOOL
Winnt32Restarted (
    VOID
    );

BOOL
Winnt32RestartedWithAF (
    VOID
    );

BOOL
WINAPI
Winnt32DuIsSupported (
    VOID
    );

typedef
BOOL
(WINAPI* PWINNT32DUISSUPPORTED) (
    IN      PCTSTR* SourceDirs,
    IN      DWORD Count
    );


BOOL
WINAPI
Winnt32DuInitialize (
    IN      PDYNUPDT_INIT InitData
    );

typedef
BOOL
(WINAPI* PWINNT32DUINITIALIZE) (
    IN      PDYNUPDT_INIT InitData
    );


BOOL
WINAPI
Winnt32DuInitiateGetUpdates (
    OUT     PDWORD TotalEstimatedTime,
    OUT     PDWORD TotalEstimatedSize
	);

typedef
BOOL
(WINAPI* PWINNT32DUINITIATEGETUPDATES) (
    OUT     PDWORD TotalEstimatedTime,
    OUT     PDWORD TotalEstimatedSize
	);


VOID
WINAPI
Winnt32DuCancel (
    VOID
    );

typedef
VOID
(WINAPI* PWINNT32DUCANCEL) (
    VOID
    );


BOOL
WINAPI
Winnt32DuProcessFiles (
    OUT     PBOOL StopSetup
    );

typedef
BOOL
(WINAPI* PWINNT32DUPROCESSFILES) (
    );


BOOL
WINAPI
Winnt32DuWriteParams (
    IN      PCTSTR ParamsFile
    );

typedef
BOOL
(WINAPI* PWINNT32DUWRITEPARAMS) (
    IN      PCTSTR ParamsFile
    );


VOID
WINAPI
Winnt32DuUninitialize (
    VOID
    );

typedef
VOID
(WINAPI* PWINNT32DUUNINITIALIZE) (
    VOID
    );

VOID
BuildSifName (
    IN      PCTSTR CabName,
    OUT     PTSTR SifName
    );

BOOL
ProcessDownloadedFiles (
    OUT     PBOOL StopSetup
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\dynsetup.c ===
#include "precomp.h"
#pragma hdrstop

#define SETNEXTPAGE(x) *((LONG*)lParam) = x


extern HWND BackgroundWnd;
extern HWND BackgroundWnd2;

static HANDLE g_Thread = NULL;
static HANDLE g_Event = NULL;


//
// Prototypes
//
INT_PTR DynSetup_ManualDialog( IN HWND hdlg, IN UINT msg, IN WPARAM wParam, IN LPARAM lParam );

HANDLE
pInitializeOnlineSeconds (
    VOID
    );

DWORD
pGetOnlineRemainingSeconds (
    IN      HANDLE Handle,
    IN      DWORD DownloadedBytes,
    IN      DWORD TotalBytesToDownload,
    OUT     PDWORD KbPerSec                 OPTIONAL
    );


VOID
pCheckRadioButtons (
    IN      HWND Hdlg,
    IN      UINT ButtonToSelect,
    ...
    )
{
    va_list args;
    UINT u;

    va_start (args, ButtonToSelect);
    while (u = va_arg (args, UINT)) {
        CheckDlgButton (Hdlg, u, u == ButtonToSelect ? BST_CHECKED : BST_UNCHECKED);
    }
    va_end (args);
}


BOOL
DynSetupWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    Dynamic Setup page 1 (choose to use dynamic updates) or just skip it
    if this happens after a restart

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/
{
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    BOOL fRetVal = FALSE;

    switch(msg) {

    case WM_INITDIALOG:
        pCheckRadioButtons (hdlg, g_DynUpdtStatus->DUStatus == DUS_INITIAL ? IDOK : IDCANCEL, IDOK, IDCANCEL);
        SetFocus(GetDlgItem(hdlg,IDOK));
        break;

    case WM_COMMAND:
        if(HIWORD(wParam) == BN_CLICKED) {
            if (LOWORD(wParam) == IDOK) {
                g_DynUpdtStatus->DUStatus = DUS_INITIAL;
            } else if (LOWORD(wParam) == IDCANCEL) {
                g_DynUpdtStatus->DUStatus = DUS_SKIP;
            }
        }
        fRetVal = TRUE;
        break;

    case WMX_ACTIVATEPAGE:
        fRetVal = TRUE;
        if (wParam) {
            //
            // don't activate the page in restart mode
            //
            if (Winnt32Restarted ()) {
                if (Winnt32RestartedWithAF ()) {
                    GetPrivateProfileString(
                        WINNT_UNATTENDED,
                        WINNT_U_DYNAMICUPDATESHARE,
                        TEXT(""),
                        g_DynUpdtStatus->DynamicUpdatesSource,
                        SIZEOFARRAY(g_DynUpdtStatus->DynamicUpdatesSource),
                        g_DynUpdtStatus->RestartAnswerFile
                        );
                }
                return FALSE;
            }

            //
            // skip this step if already successfully performed
            //
            if (g_DynUpdtStatus->DUStatus == DUS_SUCCESSFUL) {
                return FALSE;
            }

            if (g_DynUpdtStatus->UserSpecifiedUpdates) {
                MYASSERT (!g_DynUpdtStatus->Disabled);
                //
                // go to the next page to start processing files
                //
                PropSheet_PressButton (GetParent (hdlg), PSBTN_NEXT);
            } else {
                if (g_DynUpdtStatus->Disabled ||
                    //
                    // skip if support is not available
                    //
                    !DynamicUpdateIsSupported (hdlg)
                    ) {
                    //
                    // skip page(s)
                    //
                    g_DynUpdtStatus->DUStatus = DUS_SKIP;
                    pCheckRadioButtons (hdlg, IDCANCEL, IDOK, IDCANCEL);
                    // Don't do press button next, This would cause the page to paint.
                    return( FALSE );
                }

                //
                // in CheckUpgradeOnly mode, ask user if they want to connect to WU
                //
                if (UpgradeAdvisorMode || !CheckUpgradeOnly || UnattendSwitchSpecified) {
                    if ((UpgradeAdvisorMode || UnattendedOperation) && !CancelPending) {
                        PropSheet_PressButton (GetParent (hdlg), PSBTN_NEXT);
                        break;
                    }
                }
                if (CheckUpgradeOnly) {
                    //
                    // disable the Back button in this case
                    //
                    PropSheet_SetWizButtons (GetParent(hdlg), WizPage->CommonData.Buttons & ~PSWIZB_BACK);
                }
            }
        }

        Animate_Open(GetDlgItem(hdlg, IDC_ANIMATE), wParam ? MAKEINTRESOURCE(IDA_COMPGLOB) : NULL);
        break;

    default:

        break;
    }

    return fRetVal;
}


VOID
pUpdateInfoText (
    IN      UINT InfoId
    )
{
#define MAX_TEXT 256
    TCHAR text[MAX_TEXT];

    if (!LoadString (hInst, InfoId, text, MAX_TEXT)) {
        text[0] = 0;
    }
    BB_SetInfoText (text);
}


VOID
pUpdateProgressText (
    IN      HWND Hdlg,
    IN      UINT ProgressId,
    IN      PCTSTR AppendText,      OPTIONAL
    IN      BOOL InsertNewLine
    )
{
#define MAX_TEXT 256
    TCHAR text[MAX_TEXT] = TEXT("");

    if (Hdlg) {
        if (!GetDlgItemText (Hdlg, ProgressId, text, MAX_TEXT)) {
            text[0] = 0;
        }
    } else {
        if (!LoadString (hInst, ProgressId, text, MAX_TEXT)) {
            text[0] = 0;
        }
    }
    if (AppendText) {
        DWORD len = lstrlen (AppendText) + 1;
        if (len < MAX_TEXT) {
            if (InsertNewLine) {
                if (len + 2 < MAX_TEXT) {
                    len += 2;
                    _tcsncat (text, TEXT("\r\n"), MAX_TEXT - len);
                }
            }
            _tcsncat (text, AppendText, MAX_TEXT - len);
        }
    }
    BB_SetProgressText (text);
    UpdateWindow (GetBBMainHwnd ());
}


VOID
SetDlgItemTextBold (
    IN      HWND Hdlg,
    IN      INT DlgItemID,
    IN      BOOL Bold
    )
{
    HFONT font;
    LOGFONT logFont;
    LONG weight;
    DWORD id = 0;

    font = (HFONT) SendDlgItemMessage (Hdlg, DlgItemID, WM_GETFONT, 0, 0);
    if (font && GetObject (font, sizeof(LOGFONT), &logFont)) {
        weight = Bold ? FW_BOLD : FW_NORMAL;
        if (weight != logFont.lfWeight) {
            logFont.lfWeight = weight;
            font = CreateFontIndirect (&logFont);
            if (font) {
                SendDlgItemMessage (Hdlg, DlgItemID, WM_SETFONT, (WPARAM)font, MAKELPARAM(TRUE,0));
            }
        }
    }
}


BOOL
DynSetup2WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    Dynamic Setup page 2

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/
{
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    BOOL fRetVal = FALSE;
    PTSTR message;
    DWORD onlineRemainingSeconds;
    DWORD onlineRemainingMinutes;
    DWORD kbps;
    TCHAR buf[200];
    DWORD estTime, estSize;
    HCURSOR hc;
    BOOL b;
    HANDLE hBitmap, hOld;
    DWORD tid;
#ifdef DOWNLOAD_DETAILS
    TCHAR buf2[200];
#endif
    static BOOL DownloadPageActive = FALSE;
    static PTSTR msgToFormat = NULL;
    static HANDLE hComp = NULL;
    static BOOL CancelDownloadPending = FALSE;
    static BOOL ResumeWorkerThread = FALSE;
    static DWORD PrevOnlineRemainingMinutes;
    static UINT_PTR timer = 0;

#define DOWNLOAD_TIMEOUT_TIMER      5
#define DOWNLOAD_NOTIFY_TIMEOUT     60000

    switch(msg) {

    case WM_INITDIALOG:

        if (GetDlgItemText (hdlg, IDT_DYNSETUP_TIME, buf, 100)) {
            msgToFormat = DupString (buf);
        }
        SetDlgItemText (hdlg, IDT_DYNSETUP_TIME, TEXT(""));

        break;

    case WMX_ACTIVATEPAGE:
        fRetVal = TRUE;

        if (wParam) {
            if (g_DynUpdtStatus->DUStatus == DUS_SKIP ||
                g_DynUpdtStatus->DUStatus == DUS_SUCCESSFUL
                ) {
                if (g_Thread) {
                    MYASSERT (g_Event);
                    g_Thread = NULL;
                    CloseHandle (g_Event);
                    g_Event = NULL;
                }
                if (g_DynUpdtStatus->DUStatus == DUS_SKIP) {
                    if (!g_DynUpdtStatus->Disabled) {
                        DynUpdtDebugLog (
                            Winnt32LogInformation,
                            TEXT("DynamicUpdate is skipped"),
                            0
                            );
                    }
                }
                return FALSE;
            }
            //
            // prepare the UI
            //
            if (Winnt32Restarted () || g_DynUpdtStatus->UserSpecifiedUpdates) {
                hBitmap = LoadImage (hInst, MAKEINTRESOURCE(IDB_CHECK), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);
                hOld = (HANDLE) SendDlgItemMessage (hdlg, IDC_COPY_BMP, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);
                hOld = (HANDLE) SendDlgItemMessage (hdlg, IDC_COPY_BMP2, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);
                hBitmap = LoadImage (hInst, MAKEINTRESOURCE(IDB_ARROW), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);
                hOld = (HANDLE) SendDlgItemMessage (hdlg, IDC_COPY_BMP3, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);
            } else {
                pUpdateInfoText (IDS_ESC_TOCANCEL_DOWNLOAD);
                hBitmap = LoadImage (hInst, MAKEINTRESOURCE(IDB_ARROW), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);
                hOld = (HANDLE) SendDlgItemMessage (hdlg, IDC_COPY_BMP, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);
                hOld = (HANDLE) SendDlgItemMessage (hdlg, IDC_COPY_BMP2, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);
                hOld = (HANDLE) SendDlgItemMessage (hdlg, IDC_COPY_BMP3, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);
            }
            if (!g_Event) {
                g_Event = CreateEvent (NULL, FALSE, FALSE, S_DU_SYNC_EVENT_NAME);
                if (!g_Event) {
                    DynUpdtDebugLog (
                        Winnt32LogError,
                        TEXT("CreateEvent(%1) failed"),
                        0,
                        S_DU_SYNC_EVENT_NAME
                        );
                    g_DynUpdtStatus->DUStatus = DUS_ERROR;
                    return FALSE;
                }
            }
            if (!g_Thread) {
                g_Thread = CreateThread (NULL, 0, DoDynamicUpdate, (LPVOID)hdlg, 0, &tid);
                if (!g_Thread) {
                    DynUpdtDebugLog (
                        Winnt32LogError,
                        TEXT("CreateThread(DoDynamicUpdate) failed"),
                        0
                        );
                    g_DynUpdtStatus->DUStatus = DUS_ERROR;
                    CloseHandle (g_Event);
                    g_Event = NULL;
                    return FALSE;
                }
                //
                // the handle is no longer needed
                //
                CloseHandle (g_Thread);
            } else {
                b = FALSE;
                if (g_DynUpdtStatus->DUStatus == DUS_PREPARING_CONNECTIONUNAVAILABLE ||
                    g_DynUpdtStatus->DUStatus == DUS_PREPARING_INVALIDURL) {
                    g_DynUpdtStatus->DUStatus = DUS_PREPARING;
                    b = TRUE;
                }
                if (g_DynUpdtStatus->DUStatus == DUS_DOWNLOADING_ERROR) {
                    g_DynUpdtStatus->DUStatus = DUS_DOWNLOADING;
                    b = TRUE;
                }
                if (b) {
                    //
                    // page was actually reentered after some previous failure
                    // resume the working thread
                    //
                    MYASSERT (g_Event);
                    SetEvent (g_Event);
                }
            }

            DownloadPageActive = TRUE;
            //
            // hide the wizard page
            //
            SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)TRUE, 0);
        } else {
            if (timer) {
                KillTimer (hdlg, timer);
                timer = 0;
            }

            DownloadPageActive = FALSE;
        }
        Animate_Open(GetDlgItem(hdlg, IDC_ANIMATE), wParam ? MAKEINTRESOURCE(IDA_COMPGLOB) : NULL);
        break;

    case WMX_SETUPUPDATE_PROGRESS_NOTIFY:
        //
        // reset the timer
        //
        timer = SetTimer (hdlg, DOWNLOAD_TIMEOUT_TIMER, DOWNLOAD_NOTIFY_TIMEOUT, NULL);
        //
        // update UI
        //
        if (!hComp) {
            hComp = pInitializeOnlineSeconds ();
            PrevOnlineRemainingMinutes = -1;
        }
        onlineRemainingSeconds = pGetOnlineRemainingSeconds (hComp, (DWORD)lParam, (DWORD)wParam, &kbps);
        if (onlineRemainingSeconds) {
            onlineRemainingMinutes = onlineRemainingSeconds / 60 + 1;
            if (msgToFormat && onlineRemainingMinutes < PrevOnlineRemainingMinutes) {
                PrevOnlineRemainingMinutes = onlineRemainingMinutes;
                wsprintf (buf, msgToFormat, onlineRemainingMinutes);

#ifdef DOWNLOAD_DETAILS
                //
                // also display kbps and remaining time in seconds
                //
                wsprintf (buf2, TEXT(" (%u sec. at %u kbps)"), onlineRemainingSeconds, kbps);
                lstrcat (buf, buf2);
#endif

                SetDlgItemText (hdlg, IDT_DYNSETUP_TIME, buf);
                pUpdateProgressText (hdlg, IDT_DYNSETUP_DOWNLOADING, buf, TRUE);
            }
        }
        break;

    case WMX_SETUPUPDATE_RESULT:
        if (timer) {
            KillTimer (hdlg, timer);
            timer = 0;
        }
        if (g_DynUpdtStatus->DUStatus == DUS_DOWNLOADING) {
            Animate_Stop (GetDlgItem (hdlg, IDC_ANIMATE));
            if (g_DynUpdtStatus->Cancelled) {
                g_DynUpdtStatus->DUStatus = DUS_CANCELLED;
            } else {
                if (wParam == DU_STATUS_SUCCESS) {
                    g_DynUpdtStatus->DUStatus = DUS_PROCESSING;
                } else if (wParam == DU_STATUS_FAILED) {
                    g_DynUpdtStatus->DUStatus = DUS_DOWNLOADING_ERROR;
                } else {
                    g_DynUpdtStatus->DUStatus = DUS_ERROR;
                    MYASSERT (FALSE);
                }
            }
            if (!CancelDownloadPending) {
                //
                // let the worker thread continue
                //
                if (g_DynUpdtStatus->DUStatus != DUS_DOWNLOADING_ERROR) {
                    MYASSERT (g_Event);
                    SetEvent (g_Event);
                } else {
                    //
                    // go to the error page
                    //
                    if (DownloadPageActive) {
                        PropSheet_SetWizButtons (GetParent(hdlg), WizPage->CommonData.Buttons | PSWIZB_NEXT);
                        PropSheet_PressButton (GetParent (hdlg), PSBTN_NEXT);
                        DownloadPageActive = FALSE;
                    }
                }
            } else {
                ResumeWorkerThread = TRUE;
            }
        } else {
            MYASSERT (FALSE);
            g_DynUpdtStatus->DUStatus = DUS_ERROR;
            if (g_Event) {
                SetEvent (g_Event);
            }
        }
        break;

    case WMX_SETUPUPDATE_PREPARING:
        SetDlgItemTextBold (hdlg, IDT_DYNSETUP_DIALING, TRUE);
        pUpdateProgressText (hdlg, IDT_DYNSETUP_DIALING, NULL, FALSE);
        Animate_Play (GetDlgItem (hdlg, IDC_ANIMATE), 0, -1, -1);
        break;

    case WMX_SETUPUPDATE_DOWNLOADING:
        //
        // wParam holds the estimated download time
        // lParam holds the estimated download size
        //
        SetDlgItemTextBold (hdlg, IDT_DYNSETUP_DIALING, FALSE);
        hBitmap = LoadImage (hInst, MAKEINTRESOURCE(IDB_CHECK), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);
        hOld = (HANDLE) SendDlgItemMessage (hdlg, IDC_COPY_BMP, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);

        SetDlgItemTextBold (hdlg, IDT_DYNSETUP_DOWNLOADING, TRUE);
        pUpdateProgressText (hdlg, IDT_DYNSETUP_DOWNLOADING, NULL, FALSE);
        ShowWindow (GetDlgItem (hdlg, IDT_DYNSETUP_TIME), SW_SHOW);

        //
        // set a timeout interval, just in case the control "forgets" to send messages
        //
        timer = SetTimer (hdlg, DOWNLOAD_TIMEOUT_TIMER, DOWNLOAD_NOTIFY_TIMEOUT, NULL);
        if (!timer) {
            DynUpdtDebugLog (
                Winnt32LogWarning,
                TEXT("SetTimer failed - unable to automatically abort if the control doesn't respond timely"),
                0
                );
        }
        break;

    case WMX_SETUPUPDATE_PROCESSING:
        g_DynUpdtStatus->DUStatus = DUS_PROCESSING;
        SetDlgItemTextBold (hdlg, IDT_DYNSETUP_DOWNLOADING, FALSE);
        ShowWindow (GetDlgItem (hdlg, IDT_DYNSETUP_TIME), SW_HIDE);
        hBitmap = LoadImage (hInst, MAKEINTRESOURCE(IDB_CHECK), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);
        hOld = (HANDLE) SendDlgItemMessage (hdlg, IDC_COPY_BMP2, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);

        SetDlgItemTextBold (hdlg, IDT_DYNSETUP_PROCESSING, TRUE);
        pUpdateProgressText (hdlg, IDT_DYNSETUP_PROCESSING, NULL, FALSE);
        pUpdateInfoText (IDS_ESC_TOCANCEL);
        break;

    case WMX_SETUPUPDATE_THREAD_DONE:

        pUpdateProgressText (NULL, 0, NULL, FALSE);

        g_Thread = NULL;
        if (g_Event) {
            CloseHandle (g_Event);
            g_Event = NULL;
        }

        if (g_DynUpdtStatus->DUStatus == DUS_SUCCESSFUL) {

            if (!g_DynUpdtStatus->RestartWinnt32) {
                DynUpdtDebugLog (
                    Winnt32LogInformation,
                    TEXT("DynamicUpdate was completed successfully"),
                    0
                    );
            }

            SetDlgItemTextBold (hdlg, IDT_DYNSETUP_PROCESSING, FALSE);
            hBitmap = LoadImage (hInst, MAKEINTRESOURCE(IDB_CHECK), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);
            hOld = (HANDLE) SendDlgItemMessage (hdlg, IDC_COPY_BMP3, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);
            UpdateWindow (GetDlgItem (hdlg, IDC_COPY_BMP3));
            UpdateWindow (hdlg);

        } else if (g_DynUpdtStatus->DUStatus == DUS_ERROR) {

            if (UnattendedScriptFile) {
                //
                // in the unattended case, read the answer to decide if to stop or not
                //
                GetPrivateProfileString (
                    WINNT_UNATTENDED,
                    WINNT_U_DYNAMICUPDATESTOPONERROR,
                    WINNT_A_NO,
                    buf,
                    200,
                    UnattendedScriptFile
                    );
                if (!lstrcmpi (buf, WINNT_A_YES)) {
                    DynUpdtDebugLog (
                        Winnt32LogSevereError,
                        TEXT("Setup encountered an error during DynamicUpdate and failed as instructed in the unattend file"),
                        0
                        );
                    g_DynUpdtStatus->RestartWinnt32 = FALSE;
                    Cancelled = TRUE;
                    PropSheet_PressButton (GetParent (hdlg), PSBTN_CANCEL);
                    break;
                }
            }
        } else if (g_DynUpdtStatus->DUStatus == DUS_FATALERROR) {
            DynUpdtDebugLog (
                Winnt32LogSevereError,
                TEXT("Setup encountered a fatal error during DynamicUpdate and stopped"),
                0
                );
            g_DynUpdtStatus->RestartWinnt32 = FALSE;
            Cancelled = TRUE;
            PropSheet_PressButton (GetParent (hdlg), PSBTN_CANCEL);
            break;
        }

        //
        // continue setup (this may actually restart winnt32)
        //
        if (DownloadPageActive) {
            PropSheet_SetWizButtons (GetParent(hdlg), WizPage->CommonData.Buttons | PSWIZB_NEXT);
            PropSheet_PressButton (GetParent (hdlg), PSBTN_NEXT);
            DownloadPageActive = FALSE;
        }

        break;

    case WMX_SETUPUPDATE_INIT_RETRY:
        //
        // go to the retry page
        //
        if (DownloadPageActive) {
            PropSheet_SetWizButtons (GetParent(hdlg), WizPage->CommonData.Buttons | PSWIZB_NEXT);
            PropSheet_PressButton (GetParent (hdlg), PSBTN_NEXT);
            PropSheet_SetWizButtons (GetParent(hdlg), WizPage->CommonData.Buttons & ~PSWIZB_NEXT);
            DownloadPageActive = FALSE;
        }
        break;

    case WMX_QUERYCANCEL:
        //
        // on this page, CANCEL means "cancel download", not cancel Setup,
        // but only while connecting or downloading
        //
        if (g_DynUpdtStatus->DUStatus != DUS_DOWNLOADING && g_DynUpdtStatus->DUStatus != DUS_PREPARING) {
            break;
        }

        fRetVal = TRUE;
        if (lParam) {
            //
            // don't cancel setup
            //
            *(BOOL*)lParam = FALSE;
        }
        if (!g_DynUpdtStatus->Cancelled) {
            //
            // ask user if they really want to cancel DU
            //
            DWORD rc = IDYES;
            CancelDownloadPending = TRUE;
            Animate_Stop (GetDlgItem (hdlg, IDC_ANIMATE));
            if (!CheckUpgradeOnly) {
                rc = MessageBoxFromMessage (
                        hdlg,
                        g_DynUpdtStatus->IncompatibleDriversCount ?
                            MSG_SURE_CANCEL_DOWNLOAD_DRIVERS : MSG_SURE_CANCEL_DOWNLOAD,
                        FALSE,
                        AppTitleStringId,
                        MB_YESNO | MB_ICONQUESTION | MB_TASKMODAL | MB_DEFBUTTON2,
                        g_DynUpdtStatus->IncompatibleDriversCount
                        );
            }
            if (rc == IDYES) {
                g_DynUpdtStatus->Cancelled = TRUE;
                DynamicUpdateCancel ();
            } else {
                Animate_Play (GetDlgItem (hdlg, IDC_ANIMATE), 0, -1, -1);
            }
            if (ResumeWorkerThread) {
                ResumeWorkerThread = FALSE;
                if (g_DynUpdtStatus->DUStatus != DUS_DOWNLOADING_ERROR) {
                    MYASSERT (g_Event);
                    SetEvent (g_Event);
                }
            }
            CancelDownloadPending = FALSE;
        }
        break;

    case WM_TIMER:
        if (timer && (wParam == timer)) {
            if (g_DynUpdtStatus->DUStatus == DUS_DOWNLOADING) {
                //
                // oops, the control didn't send any message in a long time now...
                // abort download and continue
                //
                DynUpdtDebugLog (
                    Winnt32LogError,
                    TEXT("The timeout for control feedback expired (%1!u! seconds); operation will be aborted"),
                    0,
                    DOWNLOAD_NOTIFY_TIMEOUT / 1000
                    );
                KillTimer (hdlg, timer);
                timer = 0;

                DynamicUpdateCancel ();
                SendMessage (hdlg, WMX_SETUPUPDATE_RESULT, DU_STATUS_FAILED, ERROR_TIMEOUT);
            }
        }
        break;
    }

    return fRetVal;
}


BOOL
RestartWizPage (
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    Dynamic Setup Restart page

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/
{

#define REBOOT_TIMEOUT_SECONDS  5
#define ID_REBOOT_TIMER         1
#define TICKS_PER_SECOND        10

    static UINT Countdown;
    PCTSTR RestartText;
    BOOL fRetVal = FALSE;

    switch(msg) {

    case WM_TIMER:
        if (--Countdown) {
            SendDlgItemMessage (hdlg, IDC_PROGRESS1, PBM_STEPIT, 0, 0);
        } else {
            PropSheet_PressButton (GetParent (hdlg), PSBTN_FINISH);
        }

        fRetVal = TRUE;
        break;

    case WMX_ACTIVATEPAGE:
        if (wParam) {
            pUpdateInfoText (IDS_ESC_TOCANCEL);
            if (Winnt32Restarted () ||
                g_DynUpdtStatus->DUStatus != DUS_SUCCESSFUL ||
                !g_DynUpdtStatus->RestartWinnt32
                ) {
                return FALSE;
            }
            //
            // Setup needs to restart with option /Restart:<path to restart file>
            //
            if (!DynamicUpdatePrepareRestart ()) {
                DynUpdtDebugLog (
                    Winnt32LogError,
                    TEXT("DynamicUpdatePrepareRestart failed"),
                    0
                    );
                g_DynUpdtStatus->DUStatus = DUS_ERROR;
                return FALSE;
            }

            pUpdateProgressText (NULL, IDS_RESTART_SETUP, NULL, FALSE);
            pUpdateInfoText (0);

            EnableWindow (GetDlgItem(GetParent(hdlg), IDCANCEL), FALSE);
            PropSheet_SetWizButtons (GetParent(hdlg), PSWIZB_FINISH);
            RestartText = GetStringResource (MSG_RESTART);
            if (RestartText) {
                PropSheet_SetFinishText (GetParent (hdlg), RestartText);
                FreeStringResource (RestartText);
            }

            Countdown = REBOOT_TIMEOUT_SECONDS * TICKS_PER_SECOND;

            SendDlgItemMessage (hdlg, IDC_PROGRESS1, PBM_SETRANGE, 0, MAKELONG(0,Countdown));
            SendDlgItemMessage (hdlg, IDC_PROGRESS1, PBM_SETSTEP, 1, 0);
            SendDlgItemMessage (hdlg, IDC_PROGRESS1, PBM_SETPOS, 0, 0);

            SetTimer (hdlg, ID_REBOOT_TIMER, 1000 / TICKS_PER_SECOND, NULL);
        }

        //
        // Accept activation/deactivation.
        //
        fRetVal = TRUE;
        break;

    case WMX_FINISHBUTTON:
        //
        // Clean up the timer.
        //
        KillTimer (hdlg, ID_REBOOT_TIMER);
        //
        // Let upgrade code do its cleanup.
        //
        if (UpgradeSupport.CleanupRoutine) {
            UpgradeSupport.CleanupRoutine ();
        }
        fRetVal = TRUE;

        break;

    }

    return fRetVal;
}


BOOL
DynSetup3WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    Dynamic Setup page 3 (retrying connection establish)

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/
{
    TCHAR buffer[100];
    BOOL cancel;
    static INT iSelected = IDR_DYNSETUP_MANUAL;
    static BOOL bFirstTime = TRUE;
    BOOL fRetVal = FALSE;
    switch(msg) {

    case WM_INITDIALOG:
        //
        // Set radio buttons.
        //
        pCheckRadioButtons (hdlg, iSelected, IDR_DYNSETUP_MANUAL, IDR_DYNSETUP_SKIP);
        //
        // Set focus to radio buttons
        //
        SetFocus (GetDlgItem (hdlg, IDR_DYNSETUP_MANUAL));
        break;

    case WM_COMMAND:
        if(HIWORD(wParam) == BN_CLICKED) {
            switch (LOWORD (wParam)) {
            case IDR_DYNSETUP_MANUAL:
            case IDR_DYNSETUP_SKIP:
                iSelected = LOWORD (wParam);
                fRetVal = TRUE;
                break;
            }
        }
        break;

    case WMX_ACTIVATEPAGE:
        if (wParam) {
            if (g_DynUpdtStatus->DUStatus != DUS_PREPARING_CONNECTIONUNAVAILABLE) {
                return FALSE;
            }

            if (UnattendSwitchSpecified) {
                //
                // skip DU by default
                //
                iSelected = IDR_DYNSETUP_SKIP;
                //
                // now read the answer, if provided
                //
                if (UnattendedScriptFile) {
                    GetPrivateProfileString (
                        WINNT_UNATTENDED,
                        WINNT_U_DYNAMICUPDATESTOPONERROR,
                        WINNT_A_NO,
                        buffer,
                        100,
                        UnattendedScriptFile
                        );
                    if (!lstrcmpi (buffer, WINNT_A_YES)) {
                        DynUpdtDebugLog (
                            Winnt32LogSevereError,
                            TEXT("Setup encountered an error during DynamicUpdate and failed as instructed in the unattend file"),
                            0
                            );
                        g_DynUpdtStatus->RestartWinnt32 = FALSE;
                        Cancelled = TRUE;
                        PropSheet_PressButton (GetParent (hdlg), PSBTN_CANCEL);
                        break;
                    }
                }
                UNATTENDED(PSBTN_NEXT);
            } else {
                iSelected = bFirstTime ? IDR_DYNSETUP_MANUAL : IDR_DYNSETUP_SKIP;
                bFirstTime = FALSE;
            }
            pCheckRadioButtons (hdlg, iSelected, IDR_DYNSETUP_MANUAL, IDR_DYNSETUP_SKIP);
            SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
        } else {
            if (Cancelled) {
                g_DynUpdtStatus->Cancelled = TRUE;
            }
            //
            // let the worker thread continue
            //
            MYASSERT (g_Thread && g_Event);
            SetEvent (g_Event);
        }

        fRetVal = TRUE;

        break;

    case WMX_BACKBUTTON:
        MYASSERT (FALSE);

    case WMX_NEXTBUTTON:
        switch (iSelected) {
        case IDR_DYNSETUP_MANUAL:
            // do magical stuff to hide everything
            ShowWindow(BackgroundWnd2, SW_MINIMIZE);

            if (DialogBox(hInst, MAKEINTRESOURCE(IDD_DYNAMICSETUP_MANUAL), hdlg, DynSetup_ManualDialog)) {
                DynUpdtDebugLog (
                    Winnt32LogInformation,
                    TEXT("Manual connect page: user connected manually"),
                    0
                    );
                g_DynUpdtStatus->DUStatus = DUS_PREPARING;
                SETNEXTPAGE(IDD_DYNAMICSETUP2);
            }

            // do magical stuff to unhide everything
            ShowWindow(BackgroundWnd2, SW_SHOWMAXIMIZED);
            break;

        case IDR_DYNSETUP_SKIP:
            DynUpdtDebugLog (
                Winnt32LogInformation,
                TEXT("Manual connect page: operation was skipped"),
                0
                );
            g_DynUpdtStatus->DUStatus = DUS_SKIP;
            break;
        }
        fRetVal = TRUE;
        break;
    }

    return fRetVal;
}

BOOL
DynSetup4WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    Dynamic Setup page 4 (web site inaccessible)

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/
{
    TCHAR buffer[100];
    BOOL cancel;
    static INT iSelected = IDR_DYNSETUP_RETRY;
    static BOOL bFirstTime = TRUE;
    BOOL fRetVal = FALSE;
    switch(msg) {

    case WM_INITDIALOG:
        //
        // Set radio buttons.
        //
        pCheckRadioButtons (hdlg, iSelected, IDR_DYNSETUP_RETRY, IDR_DYNSETUP_SKIP);
        //
        // Set focus to radio buttons
        //
        SetFocus (GetDlgItem (hdlg, IDR_DYNSETUP_RETRY));
        break;

    case WM_COMMAND:
        if(HIWORD(wParam) == BN_CLICKED) {
            switch (LOWORD (wParam)) {
            case IDR_DYNSETUP_RETRY:
            case IDR_DYNSETUP_SKIP:
                iSelected = LOWORD (wParam);
                fRetVal = TRUE;
                break;
            }
        }
        break;

    case WMX_ACTIVATEPAGE:
        if (wParam) {
            if (g_DynUpdtStatus->DUStatus != DUS_PREPARING_INVALIDURL) {
                return FALSE;
            }

            if (UnattendSwitchSpecified) {
                //
                // skip DU by default
                //
                iSelected = IDR_DYNSETUP_SKIP;
                //
                // now read the answer, if provided
                //
                if (UnattendedScriptFile) {
                    GetPrivateProfileString (
                        WINNT_UNATTENDED,
                        WINNT_U_DYNAMICUPDATESTOPONERROR,
                        WINNT_A_NO,
                        buffer,
                        100,
                        UnattendedScriptFile
                        );
                    if (!lstrcmpi (buffer, WINNT_A_YES)) {
                        DynUpdtDebugLog (
                            Winnt32LogSevereError,
                            TEXT("Setup encountered an error during DynamicUpdate and failed as instructed in the unattend file"),
                            0
                            );
                        g_DynUpdtStatus->RestartWinnt32 = FALSE;
                        Cancelled = TRUE;
                        PropSheet_PressButton (GetParent (hdlg), PSBTN_CANCEL);
                        break;
                    }
                }
                UNATTENDED(PSBTN_NEXT);
            } else {
                iSelected = bFirstTime ? IDR_DYNSETUP_RETRY : IDR_DYNSETUP_SKIP;
                bFirstTime = FALSE;
            }
            pCheckRadioButtons (hdlg, iSelected, IDR_DYNSETUP_RETRY, IDR_DYNSETUP_SKIP);
            SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
        } else {
            if (Cancelled) {
                g_DynUpdtStatus->Cancelled = TRUE;
            }
            //
            // let the worker thread continue
            //
            MYASSERT (g_Thread && g_Event);
            SetEvent (g_Event);
        }

        fRetVal = TRUE;

        break;

    case WMX_BACKBUTTON:
        MYASSERT (FALSE);

    case WMX_NEXTBUTTON:
        switch (iSelected) {
        case IDR_DYNSETUP_RETRY:
            DynUpdtDebugLog (
                Winnt32LogInformation,
                TEXT("Retry connection page: user chose to retry"),
                0
                );
            g_DynUpdtStatus->DUStatus = DUS_PREPARING;
            SETNEXTPAGE(IDD_DYNAMICSETUP2);
            break;

        case IDR_DYNSETUP_SKIP:
            DynUpdtDebugLog (
                Winnt32LogInformation,
                TEXT("Retry connection page: operation was skipped"),
                0
                );
            g_DynUpdtStatus->DUStatus = DUS_SKIP;
            break;
        }
        fRetVal = TRUE;
        break;
    }

    return fRetVal;
}


BOOL
DynSetup5WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    Dynamic Setup page 5 (error while downloading)

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/
{
    TCHAR buffer[100];
    BOOL cancel;
    static INT iSelected = IDR_DYNSETUP_RETRY;
    static BOOL bFirstTime = TRUE;
    BOOL fRetVal = FALSE;
    switch(msg) {

    case WM_INITDIALOG:
        //
        // Set radio buttons.
        //
        pCheckRadioButtons (hdlg, iSelected, IDR_DYNSETUP_RETRY, IDR_DYNSETUP_SKIP);
        //
        // Set focus to radio buttons
        //
        SetFocus (GetDlgItem (hdlg, IDR_DYNSETUP_RETRY));
        break;

    case WM_COMMAND:
        if(HIWORD(wParam) == BN_CLICKED) {
            switch (LOWORD (wParam)) {
            case IDR_DYNSETUP_RETRY:
            case IDR_DYNSETUP_SKIP:
                iSelected = LOWORD (wParam);
                fRetVal = TRUE;
                break;
            }
        }
        break;

    case WMX_ACTIVATEPAGE:
        if (wParam) {
            if (g_DynUpdtStatus->DUStatus != DUS_DOWNLOADING_ERROR) {
                SendMessage (hdlg, WMX_DYNAMIC_UPDATE_COMPLETE, 0, 0);
                return FALSE;
            }

            if (UnattendSwitchSpecified) {
                //
                // skip DU by default
                //
                iSelected = IDR_DYNSETUP_SKIP;
                //
                // now read the answer, if provided
                //
                if (UnattendedScriptFile) {
                    //
                    // Read answer
                    //
                    GetPrivateProfileString (
                        WINNT_UNATTENDED,
                        WINNT_U_DYNAMICUPDATESTOPONERROR,
                        WINNT_A_NO,
                        buffer,
                        100,
                        UnattendedScriptFile
                        );
                    if (!lstrcmpi (buffer, WINNT_A_YES)) {
                        DynUpdtDebugLog (
                            Winnt32LogSevereError,
                            TEXT("Setup encountered an error during DynamicUpdate and failed as instructed in the unattend file"),
                            0
                            );
                        g_DynUpdtStatus->RestartWinnt32 = FALSE;
                        Cancelled = TRUE;
                        PropSheet_PressButton (GetParent (hdlg), PSBTN_CANCEL);
                        break;
                    }
                }
                UNATTENDED(PSBTN_NEXT);
            } else {
                iSelected = bFirstTime ? IDR_DYNSETUP_RETRY : IDR_DYNSETUP_SKIP;
                bFirstTime = FALSE;
            }
            pCheckRadioButtons (hdlg, iSelected, IDR_DYNSETUP_RETRY, IDR_DYNSETUP_SKIP);
            SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
        } else {
            if (Cancelled) {
                g_DynUpdtStatus->Cancelled = TRUE;
            }
            //
            // let the worker thread continue
            //
            MYASSERT (g_Thread && g_Event);
            SetEvent (g_Event);
        }

        SendMessage (hdlg, WMX_DYNAMIC_UPDATE_COMPLETE, 0, 0);
        fRetVal = TRUE;

        break;

    case WMX_DYNAMIC_UPDATE_COMPLETE:
#ifdef _X86_
        //
        // Send upgrade report option to module. DU is
        // now out of the picture.
        //

        switch (g_UpgradeReportMode) {

        case IDC_CRITICAL_ISSUES:
            AppendUpgradeOption (TEXT("ShowReport=Auto"));
            break;

        case IDC_ALL_ISSUES:
            AppendUpgradeOption (TEXT("ShowReport=Yes"));
            break;

        case IDC_NO_REPORT:
            AppendUpgradeOption (TEXT("ShowReport=No"));
            break;
        }
#endif

        break;

    case WMX_BACKBUTTON:
        MYASSERT (FALSE);

    case WMX_NEXTBUTTON:
        switch (iSelected) {
        case IDR_DYNSETUP_RETRY:
            DynUpdtDebugLog (
                Winnt32LogInformation,
                TEXT("Retry download page: user chose to retry"),
                0
                );
            g_DynUpdtStatus->DUStatus = DUS_DOWNLOADING;
            SETNEXTPAGE(IDD_DYNAMICSETUP2);
            break;

        case IDR_DYNSETUP_SKIP:
            DynUpdtDebugLog (
                Winnt32LogInformation,
                TEXT("Retry download page: operation was skipped"),
                0
                );
            g_DynUpdtStatus->DUStatus = DUS_SKIP;
            break;
        }
        fRetVal = TRUE;
        break;
    }

    return fRetVal;
}



INT_PTR
DynSetup_ManualDialog(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    Dynamic Setup manual dialog

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/
{
    BOOL fRetVal = FALSE;

    switch(msg)
    {
    case WM_INITDIALOG:
        fRetVal = TRUE;
        break;
    case WM_COMMAND:
        if(HIWORD(wParam) == BN_CLICKED) {
            if (LOWORD (wParam) == IDOK)
            {
                EndDialog(hdlg, 1);
                fRetVal = TRUE;
            }
            else
            {
                EndDialog(hdlg, 0);
                fRetVal = TRUE;
            }
        }
    }

    return fRetVal;
}


//
// Time estimate stuff
//

#define MAX_INDEX   100

typedef struct {
    DWORD D;
    DWORD T;
    ULONGLONG DT;
    ULONGLONG TT;
} STDDEV_ELEM, *PSTDDEV_ELEM;

typedef struct {
    STDDEV_ELEM Array[MAX_INDEX];
    STDDEV_ELEM Sums;
    UINT Index;
    UINT Count;
    DWORD T0;
} STDDEV_COMPUTATION, *PSTDDEV_COMPUTATION;

HANDLE
pInitializeOnlineSeconds (
    VOID
    )
{
    PSTDDEV_COMPUTATION p = MALLOC (sizeof (STDDEV_COMPUTATION));
    if (p) {
        ZeroMemory (p, sizeof (STDDEV_COMPUTATION));

#ifdef DOWNLOAD_DETAILS
        //
        // table header
        //
        DynUpdtDebugLog (
            Winnt32LogDetailedInformation,
            TEXT("Count|  MiliSec|    Bytes|     Baud|EstRemSec|\r\n")
            TEXT("-----|---------|---------|---------|---------|"),
            0
            );
#endif

    }
    return (HANDLE)p;
}


DWORD
pGetOnlineRemainingSeconds (
    IN      HANDLE Handle,
    IN      DWORD DownloadedBytes,
    IN      DWORD TotalBytesToDownload,
    OUT     PDWORD KbPerSec                 OPTIONAL
    )
{
    PSTDDEV_COMPUTATION p = (PSTDDEV_COMPUTATION)Handle;
    PSTDDEV_ELEM e;
    DWORD r = 0;
    DWORD remTimeSec;
    ULONGLONG div;

    if (!p) {
        return 0;
    }

    e = &p->Array[p->Index];
    if (p->Count == 0) {
        //
        // add the first pair
        //
        e->D = DownloadedBytes;                             // bytes
        e->T = 0;                                           // miliseconds
        e->DT = 0;
        e->TT = 0;
        p->Sums.D = DownloadedBytes;
        p->Count++;
        p->Index++;
        //
        // initialize timer
        //
        p->T0 = GetTickCount ();
        //
        // no time estimate at this point (not enough data)
        //
        return 0;
    }
    //
    // compute sum of prev pairs
    //
    p->Sums.D -= e->D;
    p->Sums.T -= e->T;
    p->Sums.DT -= e->DT;
    p->Sums.TT -= e->TT;
    //
    // compute new values
    //
    e->D = DownloadedBytes;                             // bytes
    e->T = GetTickCount () - p->T0;                     // miliseconds
    e->DT = (ULONGLONG)e->D * (ULONGLONG)e->T;
    e->TT = (ULONGLONG)e->T * (ULONGLONG)e->T;
    //
    // compute new sums
    //
    p->Sums.D += e->D;
    p->Sums.T += e->T;
    p->Sums.DT += e->DT;
    p->Sums.TT += e->TT;
    //
    // adjust count and index
    //
    if (p->Count < MAX_INDEX) {
        p->Count++;
    }
    p->Index++;
    if (p->Index == MAX_INDEX) {
        p->Index = 0;
    }
    //
    // compute new download rate, in bytes/milisec
    //
    div = p->Sums.TT * (ULONGLONG)p->Count - (ULONGLONG)p->Sums.T * (ULONGLONG)p->Sums.T;
    if (div) {
        r = (DWORD)
            ((p->Sums.DT * (ULONGLONG)p->Count - (ULONGLONG)p->Sums.D * (ULONGLONG)p->Sums.T) *
             1000 / div / 1024);
    }

    //
    // now estimate remaining time based on the difference and this rate
    // assume there's always something more to download (never 0)
    //
    remTimeSec = 1;
    if (r) {
        remTimeSec += (TotalBytesToDownload - DownloadedBytes) / r / 1000;
    }

#ifdef DOWNLOAD_DETAILS
    //
    // log this for debug purposes
    //
    DynUpdtDebugLog (
        Winnt32LogDetailedInformation,
        TEXT("%1!5u!%2!10u!%3!10u!%4!10u!%5!10u!"),
        0,
        p->Count,
        e->T,
        e->D,
        r * 8,
        remTimeSec
        );
#endif

    if (KbPerSec) {
        *KbPerSec = r;
    }
    return remTimeSec;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\dynupdt.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dynupdt.c

Abstract:

    The Dynamic Update feature of WINNT32.

Author:

    Ovidiu Temereanca (ovidiut) 02-Jul-2000

Revision History:

    <alias>  <date>      <comment>

--*/

#include "precomp.h"

//
// BUGBUG - comment functions
//

#define GUIDRVS_FIELD_CABNAME       1
#define GUIDRVS_FIELD_INFNAME       2
#define GUIDRVS_FIELD_DRIVERVER     3
#define GUIDRVS_FIELD_HARDWAREID    4

#define MAX_UPGCHK_ELAPSED_SECONDS  (30 * 60)

PDYNUPDT_STATUS g_DynUpdtStatus;

static WORD g_MapProductTypeToSuite[] = {
    0,                              // pro
    VER_SUITE_SMALLBUSINESS,        // srv
    VER_SUITE_ENTERPRISE,           // ads
    VER_SUITE_DATACENTER,           // dtc
    VER_SUITE_PERSONAL,             // per
    VER_SUITE_BLADE,                // bla
};

static BYTE g_MapProductTypeToPT[] = {
    VER_NT_WORKSTATION,
    VER_NT_SERVER,
    VER_NT_SERVER,
    VER_NT_SERVER,
    VER_NT_WORKSTATION,
    VER_NT_SERVER,
};

typedef
BOOL
(*PCOMPLOADFN) (
    IN      PCTSTR LibraryPath
    );

BOOL
DynUpdtDebugLog(
    IN Winnt32DebugLevel Level,
    IN LPCTSTR           Text,
    IN UINT              MessageId,
    ...
    )
{
    va_list arglist;
    BOOL b;
    TCHAR bigBuffer[1024];
    PCTSTR prefix;
    DWORD rc = GetLastError ();

    //
    // this param is never used momentarily
    //
    MYASSERT (Text);
    if (!Text) {
        return FALSE;
    }
    MYASSERT (!MessageId);

    if (Level <= Winnt32LogError) {
        prefix = TEXT("DUError: ");
    } else if (Level == Winnt32LogWarning) {
        prefix = TEXT("DUWarning: ");
    } else {
        prefix = TEXT("DUInfo: ");
    }

    _sntprintf (bigBuffer, sizeof (bigBuffer) / sizeof (TCHAR), TEXT("%s%s"), prefix, Text);

    va_start(arglist,MessageId);

    b = DebugLog2 (Level, bigBuffer, MessageId, arglist);

    va_end(arglist);

    SetLastError (rc);
    return b;
}


BOOL
pDoesFileExist (
    IN      PCTSTR FilePath
    )
{
    WIN32_FIND_DATA fd;

    return FileExists (FilePath, &fd) && !(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
}


BOOL
pDoesDirectoryExist (
    IN      PCTSTR DirPath
    )
{
    WIN32_FIND_DATA fd;

    return FileExists (DirPath, &fd) && (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
}


BOOL
pNonemptyFilePresent (
    IN      PCTSTR FilePath
    )
{
    WIN32_FIND_DATA fd;

    return FileExists (FilePath, &fd) &&
        fd.nFileSizeLow > 0 &&
        !(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
}


BOOL
pGetTargetInfo (
    OUT     POSVERSIONINFOEX TargetVersion,     OPTIONAL
    OUT     PTSTR TargetPlatform,               OPTIONAL
    IN      DWORD TargetPlatformChars,          OPTIONAL
    OUT     PLCID LocaleID                      OPTIONAL
    )
{
    TCHAR buffer[256];
    UINT productType;

    //
    // get some data from the main inf
    //
    if (!FullInfName[0]) {
        if (!FindPathToWinnt32File (InfName, FullInfName, MAX_PATH)) {
            DynUpdtDebugLog (
                Winnt32LogError,
                TEXT("pGetTargetInfo: FindPathToWinnt32File failed"),
                0
                );
            return FALSE;
        }
    }

    if (TargetVersion) {
        if (!GetPrivateProfileString (
                TEXT("Miscellaneous"),
                TEXT("ProductType"),
                TEXT(""),
                buffer,
                256,
                FullInfName
                )) {
            DynUpdtDebugLog (
                Winnt32LogError,
                TEXT("%1 key in [%2] section is missing from %3; aborting operation"),
                0,
                TEXT("ProductType"),
                TEXT("Miscellaneous"),
                FullInfName
                );
            return FALSE;
        }
        if (buffer[0] < TEXT('0') || buffer[0] > TEXT('5') || buffer[1]) {
            DynUpdtDebugLog (
                Winnt32LogError,
                TEXT("Invalid %1 value (%2) in %3"),
                0,
                TEXT("ProductType"),
                buffer,
                FullInfName
                );
            return FALSE;
        }

        productType = buffer[0] - TEXT('0');

        if (!GetPrivateProfileString (
                TEXT("Miscellaneous"),
                TEXT("ServicePack"),
                TEXT(""),
                buffer,
                256,
                FullInfName
                )) {
            DynUpdtDebugLog (
                Winnt32LogError,
                TEXT("%1 key in [%2] section is missing from %3; aborting operation"),
                0,
                TEXT("ServicePack"),
                TEXT("Miscellaneous"),
                FullInfName
                );
            return FALSE;
        }

        if (_stscanf (
                buffer,
                TEXT("%hu.%hu"),
                &TargetVersion->wServicePackMajor,
                &TargetVersion->wServicePackMinor
                ) != 2) {
            DynUpdtDebugLog (
                Winnt32LogError,
                TEXT("Invalid %1 value (%2) in %3"),
                0,
                TEXT("ServicePack"),
                buffer,
                FullInfName
                );
            return FALSE;
        }
        TargetVersion->dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        TargetVersion->dwMajorVersion = VER_PRODUCTMAJORVERSION;
        TargetVersion->dwMinorVersion = VER_PRODUCTMINORVERSION;
        TargetVersion->dwBuildNumber = VER_PRODUCTBUILD;
        TargetVersion->dwPlatformId = VER_PLATFORM_WIN32_NT;
        TargetVersion->wSuiteMask = g_MapProductTypeToSuite[productType];
        TargetVersion->wProductType = g_MapProductTypeToPT[productType];
    }

    if (TargetPlatform) {
        if (!GetPrivateProfileString (
                TEXT("Miscellaneous"),
                TEXT("DestinationPlatform"),
                TEXT(""),
                TargetPlatform,
                TargetPlatformChars,
                FullInfName
                )) {
            DynUpdtDebugLog (
                Winnt32LogError,
                TEXT("%1 key in [%2] section is missing from %3; aborting operation"),
                0,
                TEXT("DestinationPlatform"),
                TEXT("Miscellaneous"),
                FullInfName
                );
            return FALSE;
        }
    }

    if (LocaleID) {
        MYASSERT (SourceNativeLangID);
        *LocaleID = SourceNativeLangID;
    }

    return TRUE;
}


BOOL
pInitializeSupport (
    IN      PCTSTR ComponentName,
    IN      PCOMPLOADFN LoadFn,
    IN      BOOL UseRegistryReplacement
    )
{
    TCHAR pathSupportLib[MAX_PATH];

    if (UseRegistryReplacement) {
        HKEY key;
        DWORD rc;
        BOOL b = FALSE;

        rc = RegOpenKey (
                HKEY_LOCAL_MACHINE,
                TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\Winnt32\\5.1"),
                &key
                );
        if (rc == ERROR_SUCCESS) {
            DWORD size = 0;
            rc = RegQueryValueEx (key, ComponentName, NULL, NULL, NULL, &size);
            if (rc == ERROR_SUCCESS && size > 0) {
                PTSTR buf = MALLOC (size);
                if (buf) {
                    rc = RegQueryValueEx (key, ComponentName, NULL, NULL, (LPBYTE)buf, &size);
                    if (rc == ERROR_SUCCESS && (*LoadFn) (buf)) {
                        DynUpdtDebugLog (
                            Winnt32LogInformation,
                            TEXT("pInitializeSupport: using registry specified replacement file <%1>"),
                            0,
                            buf
                            );
                        b = TRUE;
                    }
                    FREE (buf);
                }
            }
            RegCloseKey (key);
        }

        if (b) {
            return TRUE;
        }
    }

    if (FindPathToWinnt32File (ComponentName, pathSupportLib, MAX_PATH)) {
        if ((*LoadFn) (pathSupportLib)) {
            return TRUE;
        }
    }
    DynUpdtDebugLog (
        Winnt32LogError,
        TEXT("pInitializeSupport: %1 could not be loaded or is corrupt"),
        0,
        ComponentName
        );
    return FALSE;
}

BOOL
pLoadHwdbLib (
    IN      PCTSTR LibraryPath
    )
{
    DWORD rc;

    //
    // Use WinVerifyTrust first?
    //

    g_DynUpdtStatus->HwdbLib = LoadLibraryEx (LibraryPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    if (!g_DynUpdtStatus->HwdbLib) {
        return FALSE;
    }
    g_DynUpdtStatus->HwdbInitialize = (PHWDBINITIALIZE) GetProcAddress (g_DynUpdtStatus->HwdbLib, S_HWDBAPI_HWDBINITIALIZE);
    g_DynUpdtStatus->HwdbTerminate = (PHWDBTERMINATE) GetProcAddress (g_DynUpdtStatus->HwdbLib, S_HWDBAPI_HWDBTERMINATE);
    g_DynUpdtStatus->HwdbOpen = (PHWDBOPEN) GetProcAddress (g_DynUpdtStatus->HwdbLib, S_HWDBAPI_HWDBOPEN);
    g_DynUpdtStatus->HwdbClose = (PHWDBCLOSE) GetProcAddress (g_DynUpdtStatus->HwdbLib, S_HWDBAPI_HWDBCLOSE);
    g_DynUpdtStatus->HwdbAppendInfs = (PHWDBAPPENDINFS) GetProcAddress (g_DynUpdtStatus->HwdbLib, S_HWDBAPI_HWDBAPPENDINFS);
    g_DynUpdtStatus->HwdbFlush = (PHWDBFLUSH) GetProcAddress (g_DynUpdtStatus->HwdbLib, S_HWDBAPI_HWDBFLUSH);
    g_DynUpdtStatus->HwdbHasDriver = (PHWDBHASDRIVER) GetProcAddress (g_DynUpdtStatus->HwdbLib, S_HWDBAPI_HWDBHASDRIVER);
    g_DynUpdtStatus->HwdbHasAnyDriver = (PHWDBHASANYDRIVER) GetProcAddress (g_DynUpdtStatus->HwdbLib, S_HWDBAPI_HWDBHASANYDRIVER);

    if (!g_DynUpdtStatus->HwdbInitialize ||
        !g_DynUpdtStatus->HwdbTerminate ||
        !g_DynUpdtStatus->HwdbOpen ||
        !g_DynUpdtStatus->HwdbClose ||
        !g_DynUpdtStatus->HwdbAppendInfs ||
        !g_DynUpdtStatus->HwdbFlush ||
        !g_DynUpdtStatus->HwdbHasDriver ||
        !g_DynUpdtStatus->HwdbHasAnyDriver
        ) {
        g_DynUpdtStatus->HwdbInitialize = NULL;
        g_DynUpdtStatus->HwdbTerminate = NULL;
        g_DynUpdtStatus->HwdbOpen = NULL;
        g_DynUpdtStatus->HwdbClose = NULL;
        g_DynUpdtStatus->HwdbAppendInfs = NULL;
        g_DynUpdtStatus->HwdbFlush = NULL;
        g_DynUpdtStatus->HwdbHasDriver = NULL;
        g_DynUpdtStatus->HwdbHasAnyDriver = NULL;
        rc = GetLastError ();
        FreeLibrary (g_DynUpdtStatus->HwdbLib);
        g_DynUpdtStatus->HwdbLib = NULL;
        SetLastError (rc);
        return FALSE;
    }

    return TRUE;
}

BOOL
pLoadDuLib (
    IN      PCTSTR LibraryPath
    )
{
    DWORD rc;

    //
    // BUGBUG - Use WinVerifyTrust first?
    //

    g_DynUpdtStatus->DuLib = LoadLibraryEx (LibraryPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    if (!g_DynUpdtStatus->DuLib) {
        return FALSE;
    }
    g_DynUpdtStatus->DuIsSupported = (PDUISSUPPORTED) GetProcAddress (g_DynUpdtStatus->DuLib, API_DU_ISSUPPORTED);
    g_DynUpdtStatus->DuInitialize = (PDUINITIALIZE) GetProcAddress (g_DynUpdtStatus->DuLib, API_DU_INITIALIZE);
    g_DynUpdtStatus->DuDoDetection = (PDUDODETECTION) GetProcAddress (g_DynUpdtStatus->DuLib, API_DU_DODETECTION);
    g_DynUpdtStatus->DuQueryUnsupDrvs = (PDUQUERYUNSUPDRVS) GetProcAddress (g_DynUpdtStatus->DuLib, API_DU_QUERYUNSUPDRVS);
    g_DynUpdtStatus->DuBeginDownload = (PDUBEGINDOWNLOAD) GetProcAddress (g_DynUpdtStatus->DuLib, API_DU_BEGINDOWNLOAD);
    g_DynUpdtStatus->DuAbortDownload = (PDUABORTDOWNLOAD) GetProcAddress (g_DynUpdtStatus->DuLib, API_DU_ABORTDOWNLOAD);
    g_DynUpdtStatus->DuUninitialize = (PDUUNINITIALIZE) GetProcAddress (g_DynUpdtStatus->DuLib, API_DU_UNINITIALIZE);

    if (!g_DynUpdtStatus->DuIsSupported ||
        !g_DynUpdtStatus->DuInitialize ||
        !g_DynUpdtStatus->DuDoDetection ||
        !g_DynUpdtStatus->DuQueryUnsupDrvs ||
        !g_DynUpdtStatus->DuBeginDownload ||
        !g_DynUpdtStatus->DuAbortDownload ||
        !g_DynUpdtStatus->DuUninitialize
        ) {
        DynUpdtDebugLog (
            Winnt32LogError,
            TEXT("pLoadDuLib: %1 is missing one or more required entry points"),
            0,
            LibraryPath
            );
        g_DynUpdtStatus->DuIsSupported = NULL;
        g_DynUpdtStatus->DuInitialize = NULL;
        g_DynUpdtStatus->DuDoDetection = NULL;
        g_DynUpdtStatus->DuQueryUnsupDrvs = NULL;
        g_DynUpdtStatus->DuBeginDownload = NULL;
        g_DynUpdtStatus->DuAbortDownload = NULL;
        g_DynUpdtStatus->DuUninitialize = NULL;
        rc = GetLastError ();
        FreeLibrary (g_DynUpdtStatus->DuLib);
        g_DynUpdtStatus->DuLib = NULL;
        SetLastError (rc);
        return FALSE;
    }

    return TRUE;
}



#ifndef UNICODE

BOOL
pLoadWin9xDuSupport (
    VOID
    )
{
    if (!UpgradeSupport.DllModuleHandle) {
        return FALSE;
    }

    g_DynUpdtStatus->Win9xGetIncompDrvs = (PWIN9XGETINCOMPDRVS)
            GetProcAddress (UpgradeSupport.DllModuleHandle, "Win9xGetIncompDrvs");
    g_DynUpdtStatus->Win9xReleaseIncompDrvs = (PWIN9XRELEASEINCOMPDRVS)
            GetProcAddress (UpgradeSupport.DllModuleHandle, "Win9xReleaseIncompDrvs");
    if (!g_DynUpdtStatus->Win9xGetIncompDrvs) {
        DynUpdtDebugLog (
            Winnt32LogError,
            TEXT("Winnt32DuIsSupported: %1 is missing in the upgrade support module"),
            0,
            "Win9xGetIncompDrvs"
            );
        return FALSE;
    }

    return TRUE;
}

#endif


BOOL
pInitSupportLibs (
    VOID
    )
{
    return (Winnt32Restarted () || pInitializeSupport (S_DUCTRL_DLL, pLoadDuLib, TRUE)) &&
           pInitializeSupport (S_HWDB_DLL, pLoadHwdbLib, FALSE) &&
           g_DynUpdtStatus->HwdbInitialize (g_DynUpdtStatus->TempDir);
}


BOOL
pInitNtPnpDb (
    IN      BOOL AllowRebuild
    )
{
    TCHAR hwdbPath[MAX_PATH];
    BOOL b = TRUE;

    if (!FindPathToWinnt32File (S_HWCOMP_DAT, hwdbPath, MAX_PATH)) {
        DynUpdtDebugLog (Winnt32LogError, TEXT("pInitNtPnpDb: %1 not found"), 0, S_HWCOMP_DAT);
        b = FALSE;
    }
    MYASSERT (g_DynUpdtStatus->HwdbInitialize);
    if (b && !g_DynUpdtStatus->HwdbInitialize (g_DynUpdtStatus->TempDir)) {
        DynUpdtDebugLog (Winnt32LogError, TEXT("pInitNtPnpDb: HwdbInitialize(%1) FAILED"), 0, g_DynUpdtStatus->TempDir);
        b = FALSE;
    }
    MYASSERT (g_DynUpdtStatus->HwdbOpen);
    if (b) {
        g_DynUpdtStatus->HwdbDatabase = g_DynUpdtStatus->HwdbOpen (hwdbPath);
        if (!g_DynUpdtStatus->HwdbDatabase) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("pInitNtPnpDb: HwdbOpen(%1) FAILED"), 0, hwdbPath);
            b = FALSE;
        }
    }
    if (!b && AllowRebuild) {
        //
        // just rebuild the database in memory
        //
        g_DynUpdtStatus->HwdbDatabase = g_DynUpdtStatus->HwdbOpen (NULL);
        if (g_DynUpdtStatus->HwdbDatabase) {
            b = g_DynUpdtStatus->HwdbAppendInfs (g_DynUpdtStatus->HwdbDatabase, NativeSourcePaths[0], NULL, NULL);
            if (b) {
                DynUpdtDebugLog (Winnt32LogWarning, TEXT("pInitNtPnpDb: PnP database was successfully rebuilt"), 0);
                //
                // also try to save the database
                //
                if (g_DynUpdtStatus->HwdbFlush) {
                    BuildPath (hwdbPath, NativeSourcePaths[0], S_HWCOMP_DAT);
                    g_DynUpdtStatus->HwdbFlush (g_DynUpdtStatus->HwdbDatabase, hwdbPath);
                }
            }
        }
    }

    return b;
}


BOOL
IsNetConnectivityAvailable (
    VOID
    )
{
#ifdef UNICODE
    return TRUE;
#else
    BOOL (*pfnWin9xAnyNetDevicePresent) (VOID);

    if (UpgradeSupport.DllModuleHandle) {
        (FARPROC)pfnWin9xAnyNetDevicePresent = GetProcAddress (UpgradeSupport.DllModuleHandle, "Win9xAnyNetDevicePresent");
        if (pfnWin9xAnyNetDevicePresent) {
            return pfnWin9xAnyNetDevicePresent();
        }
    }
    return TRUE;
#endif
}


BOOL
DynamicUpdateIsSupported (
    IN      HWND ParentWnd
    )
{
    DWORD rc;

    if (g_DynUpdtStatus->Disabled) {
        return FALSE;
    }

    //
    // disable this for DTC
    //
    if (ProductFlavor == DATACENTER_PRODUCTTYPE) {
        return FALSE;
    }

    if (AnyBlockingCompatibilityItems ()) {
        //
        // no point in supporting DU; setup will stop anyway
        //
        return FALSE;
    }

    CleanUpOldLocalSources (ParentWnd);
    if (!InspectFilesystems (ParentWnd)) {
        DynUpdtDebugLog (Winnt32LogWarning, TEXT("InspectFilesystems blocks DU"), 0);
        return FALSE;
    }
    if (!EnoughMemory (ParentWnd, TRUE)) {
        return FALSE;
    }
    if (!FindLocalSourceAndCheckSpace (ParentWnd, TRUE, DYN_DISKSPACE_PADDING)) {
        DynUpdtDebugLog (Winnt32LogWarning, TEXT("Not enough disk space blocks DU"), 0);
        return FALSE;
    }

    if (!g_DynUpdtStatus->SupportQueried) {
        g_DynUpdtStatus->SupportQueried = TRUE;

        if (g_DynUpdtStatus->DynamicUpdatesSource[0]) {
            g_DynUpdtStatus->SupportPresent = TRUE;
        } else {
            g_DynUpdtStatus->SupportPresent =
                Winnt32DuIsSupported () &&
                IsNetConnectivityAvailable ();

            if (!g_DynUpdtStatus->SupportPresent) {
                rc = GetLastError ();
                DynamicUpdateUninitialize ();
                SetLastError (rc);
            }
        }
    }

    return g_DynUpdtStatus->SupportPresent;
}


BOOL
DynamicUpdateInitDownload (
    IN      HWND hNotifyWnd
    )
{
    DYNUPDT_INIT dynUpdtInit;

    MYASSERT (!g_DynUpdtStatus->Disabled);
    MYASSERT (!Winnt32Restarted ());

    MyDelnode (g_DynUpdtStatus->WorkingDir);
    BuildPath (g_DynUpdtStatus->TempDir, g_DynUpdtStatus->WorkingDir, S_SUBDIRNAME_TEMP);
    if (CreateMultiLevelDirectory (g_DynUpdtStatus->TempDir) != ERROR_SUCCESS) {
        DynUpdtDebugLog (
            Winnt32LogError,
            TEXT("DynamicUpdateInitDownload: CreateMultiLevelDirectory failed"),
            0
            );
        return FALSE;
    }
    if (!pGetTargetInfo (
            &g_DynUpdtStatus->TargetOsVersion,
            NULL,
            0,
            &g_DynUpdtStatus->TargetLCID
            )) {
        return FALSE;
    }
    dynUpdtInit.TargetOsVersion = &g_DynUpdtStatus->TargetOsVersion;
    dynUpdtInit.TargetPlatform = g_DynUpdtStatus->TargetPlatform;
    dynUpdtInit.TargetLCID = g_DynUpdtStatus->TargetLCID;
    dynUpdtInit.Upgrade = Upgrade;
    dynUpdtInit.SourceDirs = info.SourceDirectories;
    dynUpdtInit.SourceDirsCount = SourceCount;
    dynUpdtInit.Unattend = UnattendSwitchSpecified;
    dynUpdtInit.AnswerFile = UnattendedScriptFile;
    dynUpdtInit.ProgressWindow = hNotifyWnd;
    dynUpdtInit.DownloadRoot = g_DynUpdtStatus->WorkingDir;
    dynUpdtInit.TempDir = g_DynUpdtStatus->TempDir;
    return Winnt32DuInitialize (&dynUpdtInit);
}


BOOL
DynamicUpdateStart (
    OUT     PDWORD TotalEstimatedTime,
    OUT     PDWORD TotalEstimatedSize
    )
{
    if (g_DynUpdtStatus->Disabled) {
        return FALSE;
    }

    return Winnt32DuInitiateGetUpdates (TotalEstimatedTime, TotalEstimatedSize);
}

VOID
DynamicUpdateCancel (
    VOID
    )
{
    if (g_DynUpdtStatus->Disabled) {
        return;
    }

    Winnt32DuCancel ();
}


BOOL
DynamicUpdateProcessFiles (
    OUT     PBOOL StopSetup
    )
{
    if (g_DynUpdtStatus->Disabled) {
        return TRUE;
    }

    return Winnt32DuProcessFiles (StopSetup);
}

BOOL
DynamicUpdateWriteParams (
    IN      PCTSTR ParamsFile
    )
{
    return Winnt32DuWriteParams (ParamsFile);
}

VOID
DynamicUpdateUninitialize (
    VOID
    )
{
    if (g_DynUpdtStatus->Disabled) {
        return;
    }

    Winnt32DuUninitialize ();
}


BOOL
DynamicUpdatePrepareRestart (
    VOID
    )
{
    PCTSTR prevCmdLine;
    DWORD size;
#ifdef _X86_
    TCHAR reportNum[16];
#endif

    if (g_DynUpdtStatus->Disabled) {
        return FALSE;
    }

#define S_ARG_RESTART        TEXT("Restart")

    if (!UnattendedOperation) {
        //
        // build the restart answer file
        //
        BuildPath (g_DynUpdtStatus->RestartAnswerFile, g_DynUpdtStatus->WorkingDir, S_RESTART_TXT);

    #ifdef _X86_
        wsprintf (reportNum, TEXT("%u"), g_UpgradeReportMode);
    #endif

        //
        // write data to the restart answer file
        //
        if (!WritePrivateProfileString (
                WINNT_UNATTENDED,
                ISNT() ? WINNT_D_NTUPGRADE : WINNT_D_WIN95UPGRADE,
                Upgrade ? WINNT_A_YES : WINNT_A_NO,
                g_DynUpdtStatus->RestartAnswerFile
                ) ||
            ProductId[0] && !WritePrivateProfileString (
                WINNT_USERDATA,
                WINNT_US_PRODUCTKEY,
                ProductId,
                g_DynUpdtStatus->RestartAnswerFile
                ) ||
            !WritePrivateProfileString (
                WINNT_UNATTENDED,
                WINNT_U_DYNAMICUPDATESHARE,
                g_DynUpdtStatus->DynamicUpdatesSource,
                g_DynUpdtStatus->RestartAnswerFile
                ) ||
    #ifdef _X86_
            !WritePrivateProfileString (
                WINNT_UNATTENDED,
                WINNT_D_REPORTMODE,
                reportNum,
                g_DynUpdtStatus->RestartAnswerFile
                ) ||
    #endif
            (ForceNTFSConversion &&
            !WritePrivateProfileString (
                WINNT_UNATTENDED,
                TEXT("ForceNTFSConversion"),
                WINNT_A_YES,
                g_DynUpdtStatus->RestartAnswerFile
                )) ||
            !SaveAdvancedOptions (
                g_DynUpdtStatus->RestartAnswerFile
                ) ||
            !SaveLanguageOptions (
                g_DynUpdtStatus->RestartAnswerFile
                ) ||
            !SaveAccessibilityOptions (
                g_DynUpdtStatus->RestartAnswerFile
                )
                ) {
            return FALSE;
        }
    }

    prevCmdLine = GetCommandLine ();
    size = (lstrlen (prevCmdLine) + 1 + 1) * sizeof (TCHAR) + sizeof (S_ARG_RESTART) +
        (UnattendedOperation ? 0 : (1 + lstrlen (g_DynUpdtStatus->RestartAnswerFile)) * sizeof (TCHAR));
    g_DynUpdtStatus->RestartCmdLine = HeapAlloc (GetProcessHeap (), 0, size);
    if (!g_DynUpdtStatus->RestartCmdLine) {
        return FALSE;
    }
    wsprintf (
        g_DynUpdtStatus->RestartCmdLine,
        UnattendedOperation ? TEXT("%s /%s") : TEXT("%s /%s:%s"),
        prevCmdLine,
        S_ARG_RESTART,
        g_DynUpdtStatus->RestartAnswerFile
        );

    return TRUE;
}


BOOL
pComputeChecksum (
    IN      PCTSTR FileName,
    OUT     PDWORD Chksum
    )
{
    DWORD chksum, size, dwords, bytes;
    HANDLE hFile, hMap;
    PVOID viewBase;
    PDWORD base, limit;
    PBYTE base2;
    DWORD rc;

    rc = MapFileForRead (FileName, &size, &hFile, &hMap, &viewBase);
    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }

    dwords = size / sizeof (DWORD);
    base = (PDWORD)viewBase;
    limit = base + dwords;
    chksum = 0;
    while (base < limit) {
        chksum += *base;
        base++;
    }
    bytes = size % sizeof (DWORD);
    base2 = (PBYTE)base;
    while (bytes) {
        chksum += *base2;
        base2++;
        bytes--;
    }

    UnmapFile (hMap, viewBase);
    CloseHandle (hFile);

    *Chksum = chksum;
    return TRUE;
}


BOOL
pGetFiletimeStamps (
    IN      PCTSTR FileName,
    OUT     PFILETIME CreationTime,
    OUT     PFILETIME LastWriteTime
    )
{
    WIN32_FIND_DATA fd;
    HANDLE h;

    h = FindFirstFile (FileName, &fd);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    FindClose (h);
    *CreationTime = fd.ftCreationTime;
    *LastWriteTime = fd.ftLastWriteTime;
    return TRUE;
}

BOOL
pSaveLastDownloadInfo (
    VOID
    )
{
    SYSTEMTIME currentTime;
    DWORD chksum;
    FILETIME ftCreationTime;
    FILETIME ftLastWriteTime;
    ULONGLONG data[2];
    DWORD rc;
    HKEY key;
    TCHAR keyName[MAX_PATH];
    TCHAR filePath[MAX_PATH];
    PTSTR p;

    //
    // we always want to get to the CD dosnet.inf (in the same directory as winnt32.exe)
    //
    if (!GetModuleFileName (NULL, filePath, MAX_PATH)) {
        return FALSE;
    }
    p = _tcsrchr (filePath, TEXT('\\'));
    if (!p) {
        return FALSE;
    }
    lstrcpy (p + 1, InfName);

    GetCurrentWinnt32RegKey (keyName, MAX_PATH);
    ConcatenatePaths (keyName, WINNT_U_DYNAMICUPDATESHARE, MAX_PATH);

    rc = RegCreateKey (HKEY_LOCAL_MACHINE, keyName, &key);
    if (rc == ERROR_SUCCESS) {
        GetSystemTime (&currentTime);
        rc = RegSetValueEx (
                key,
                TEXT("LastDownloadTime"),
                0,
                REG_BINARY,
                (CONST BYTE *) (&currentTime),
                sizeof (currentTime)
                );

        if (rc == ERROR_SUCCESS) {
            rc = RegSetValueEx (
                    key,
                    TEXT(""),
                    0,
                    REG_SZ,
                    (CONST BYTE *) g_DynUpdtStatus->DynamicUpdatesSource,
                    (lstrlen (g_DynUpdtStatus->DynamicUpdatesSource) + 1) * sizeof (TCHAR)
                    );
        }

        if (rc == ERROR_SUCCESS) {

            if (pComputeChecksum (filePath, &chksum)) {
                rc = RegSetValueEx (
                        key,
                        TEXT("Checksum"),
                        0,
                        REG_DWORD,
                        (CONST BYTE *) (&chksum),
                        sizeof (chksum)
                        );
            }
        }

        if (rc == ERROR_SUCCESS) {
            if (pGetFiletimeStamps (filePath, &ftCreationTime, &ftLastWriteTime)) {
                data[0] = ((ULONGLONG)ftCreationTime.dwHighDateTime << 32) | (ULONGLONG)ftCreationTime.dwLowDateTime;
                data[1] = ((ULONGLONG)ftLastWriteTime.dwHighDateTime << 32 ) | (ULONGLONG)ftLastWriteTime.dwLowDateTime;
                rc = RegSetValueEx (
                        key,
                        TEXT("TimeStamp"),
                        0,
                        REG_BINARY,
                        (CONST BYTE *)data,
                        sizeof (data)
                        );
            }
        }

        RegCloseKey (key);
    }

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
    }
    return rc == ERROR_SUCCESS;
}

BOOL
pGetRecentDUShare (
    IN      DWORD MaxElapsedSeconds
    )
{
    SYSTEMTIME lastDownload, currentTime;
    ULONGLONG lastDownloadIn100Ns, currentTimeIn100Ns;
    ULONGLONG difference;
    DWORD rc, size, type;
    HKEY key = NULL;
    BOOL b = FALSE;
    PTSTR duShare = NULL;
    TCHAR keyName[MAX_PATH];
    FILETIME ftCreationTime;
    FILETIME ftLastWriteTime;
    ULONGLONG data[2], storedData[2];
    DWORD chksum, storedChksum;
    TCHAR filePath[MAX_PATH];
    PTSTR p;

    if (!GetModuleFileName (NULL, filePath, MAX_PATH)) {
        return FALSE;
    }
    p = _tcsrchr (filePath, TEXT('\\'));
    if (!p) {
        return FALSE;
    }
    lstrcpy (p + 1, InfName);

    GetCurrentWinnt32RegKey (keyName, MAX_PATH);
    ConcatenatePaths (keyName, WINNT_U_DYNAMICUPDATESHARE, MAX_PATH);

    rc = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            keyName,
            0,
            KEY_READ,
            &key
            );

    if (rc == ERROR_SUCCESS) {
        size = sizeof (lastDownload);
        rc = RegQueryValueEx (
                key,
                TEXT("LastDownloadTime"),
                NULL,
                &type,
                (PBYTE) (&lastDownload),
                &size
                );
    }

    if (rc == ERROR_SUCCESS && type == REG_BINARY && size == sizeof (lastDownload)) {
        //
        // Compare current time to report time
        //

        GetSystemTime (&currentTime);

        lastDownloadIn100Ns = SystemTimeToFileTime64 (&lastDownload);
        currentTimeIn100Ns = SystemTimeToFileTime64 (&currentTime);

        if (currentTimeIn100Ns > lastDownloadIn100Ns) {
            //
            // Compute difference in seconds
            //
            difference = currentTimeIn100Ns - lastDownloadIn100Ns;
            difference /= (10 * 1000 * 1000);

            if (difference < MaxElapsedSeconds) {
                b = TRUE;
            }
        }
    }

    if (b) {
        b = FALSE;
        rc = RegQueryValueEx (
                key,
                TEXT(""),
                NULL,
                &type,
                NULL,
                &size
                );
        if (rc == ERROR_SUCCESS && type == REG_SZ && size > 0 && size <= sizeof (g_DynUpdtStatus->DynamicUpdatesSource)) {
            duShare = MALLOC (size);
            if (duShare) {
                rc = RegQueryValueEx (
                        key,
                        TEXT(""),
                        NULL,
                        NULL,
                        (LPBYTE)duShare,
                        &size
                        );
                if (rc == ERROR_SUCCESS && pDoesDirectoryExist (duShare)) {
                    b = TRUE;
                } else {
                    FREE (duShare);
                    duShare = NULL;
                }
            }
        }
    }

    if (b) {
        b = FALSE;
        if (pGetFiletimeStamps (filePath, &ftCreationTime, &ftLastWriteTime)) {
            rc = RegQueryValueEx (
                        key,
                        TEXT("TimeStamp"),
                        0,
                        &type,
                        (LPBYTE)storedData,
                        &size
                        );
            if (rc == ERROR_SUCCESS && type == REG_BINARY) {
                data[0] = ((ULONGLONG)ftCreationTime.dwHighDateTime << 32) | (ULONGLONG)ftCreationTime.dwLowDateTime;
                data[1] = ((ULONGLONG)ftLastWriteTime.dwHighDateTime << 32 ) | (ULONGLONG)ftLastWriteTime.dwLowDateTime;
                if (data[0] == storedData[0] && data[1] == storedData[1]) {
                    b = TRUE;
                }
            }
        }
    }

    if (b) {
        b = FALSE;
        if (pComputeChecksum (filePath, &chksum)) {
            rc = RegQueryValueEx (
                    key,
                    TEXT("Checksum"),
                    NULL,
                    &type,
                    (LPBYTE)&storedChksum,
                    &size
                    );
            if (rc == ERROR_SUCCESS && type == REG_DWORD && storedChksum == chksum) {
                b = TRUE;
            }
        }
    }

    if (!b && duShare) {
        FREE (duShare);
        duShare = NULL;
    }

    if (duShare) {
        MYASSERT (b);
        MYASSERT (!g_DynUpdtStatus->DynamicUpdatesSource[0]);
        lstrcpy (g_DynUpdtStatus->DynamicUpdatesSource, duShare);
        RemoveTrailingWack (g_DynUpdtStatus->DynamicUpdatesSource);
        g_DynUpdtStatus->UserSpecifiedUpdates = TRUE;
    }

    if (key) {
        RegCloseKey (key);
    }

    return b;
}


BOOL
DynamicUpdateInitialize (
    VOID
    )
{
    if (g_DynUpdtStatus->Disabled) {
        return TRUE;
    }

    if (!MyGetWindowsDirectory (g_DynUpdtStatus->WorkingDir, MAX_PATH)) {
        return FALSE;
    }
    ConcatenatePaths (g_DynUpdtStatus->WorkingDir, S_DOWNLOAD_ROOT, MAX_PATH);
    BuildPath (g_DynUpdtStatus->TempDir, g_DynUpdtStatus->WorkingDir, S_SUBDIRNAME_TEMP);

    if (!CheckUpgradeOnly && !g_DynUpdtStatus->UserSpecifiedUpdates) {
        if (pGetRecentDUShare (MAX_UPGCHK_ELAPSED_SECONDS)) {
            g_DynUpdtStatus->PreserveWorkingDir = TRUE;
            DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Using recent share %1"), 0, g_DynUpdtStatus->DynamicUpdatesSource);
        }
    }

    if (!g_DynUpdtStatus->PreserveWorkingDir && !Winnt32Restarted ()) {
        MyDelnode (g_DynUpdtStatus->WorkingDir);
    }

    if (g_DynUpdtStatus->UserSpecifiedUpdates) {
        BuildPath (g_DynUpdtStatus->DriversSource, g_DynUpdtStatus->DynamicUpdatesSource, S_SUBDIRNAME_DRIVERS);
    } else {
        BuildPath (g_DynUpdtStatus->DriversSource, g_DynUpdtStatus->WorkingDir, S_SUBDIRNAME_DRIVERS);
    }
    BuildPath (g_DynUpdtStatus->SelectedDrivers, g_DynUpdtStatus->WorkingDir, S_SUBDIRNAME_DRIVERS);
    if (Winnt32Restarted ()) {
        BuildPath (g_DynUpdtStatus->Winnt32Path, g_DynUpdtStatus->WorkingDir, S_SUBDIRNAME_WINNT32);
    } else {
        BuildPath (
            g_DynUpdtStatus->Winnt32Path,
            g_DynUpdtStatus->UserSpecifiedUpdates ?
                g_DynUpdtStatus->DynamicUpdatesSource :
                g_DynUpdtStatus->WorkingDir,
            S_SUBDIRNAME_WINNT32
            );
    }
    if (!pGetTargetInfo (
            NULL,
            g_DynUpdtStatus->TargetPlatform,
            sizeof (g_DynUpdtStatus->TargetPlatform) / sizeof (TCHAR),
            NULL
            )) {
        return FALSE;
    }
    return TRUE;
}


PTSTR
GetFileExtension (
    IN      PCTSTR FileSpec
    )
{
    PTSTR p;

    p = _tcsrchr (FileSpec, TEXT('.'));
    if (p && _tcschr (p, TEXT('\\'))) {
        p = NULL;
    }
    return p;
}


VOID
BuildSifName (
    IN      PCTSTR CabName,
    OUT     PTSTR SifName
    )
{
    PTSTR p;

    lstrcpy (SifName, CabName);
    p = GetFileExtension (SifName);
    if (!p) {
        p = _tcschr (SifName, 0);
    }
    lstrcpy (p, TEXT(".sif"));
}


BOOL
WINAPI
Winnt32QueryCallback (
    IN      DWORD SetupQueryId,
    IN      PVOID InData,
    IN      DWORD InDataSize,
    IN OUT  PVOID OutData,          OPTIONAL
    IN OUT  PDWORD OutDataSize
    )
{
    BOOL b = FALSE;
    BOOL bException = FALSE;

    switch (SetupQueryId) {
    case SETUPQUERYID_PNPID:
        {
            PPNPID_INFO p;
            PTSTR listPnpIds = NULL;

            if (!OutData ||
                !OutDataSize ||
                *OutDataSize < sizeof (PNPID_INFO)
                ) {
                SetLastError (ERROR_INVALID_PARAMETER);
                break;
            }
            if (!g_DynUpdtStatus->HwdbHasAnyDriver) {
                SetLastError (ERROR_INVALID_FUNCTION);
                break;
            }
            __try {
                p = (PPNPID_INFO)OutData;
                if (g_DynUpdtStatus->HwdbDatabase) {
#ifdef UNICODE
                    listPnpIds = MultiSzAnsiToUnicode ((PCSTR)InData);
#else
                    listPnpIds = (PSTR)InData;
#endif
                    p->Handled = (*g_DynUpdtStatus->HwdbHasAnyDriver) (
                                        g_DynUpdtStatus->HwdbDatabase,
                                        listPnpIds,
                                        &p->Unsupported
                                        );
                } else {
                    //
                    // disable all driver downloads by doing this
                    //
                    p->Handled = TRUE;
                }
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                SetLastError (GetExceptionCode());
                DynUpdtDebugLog (Winnt32LogError, TEXT("Winnt32QueryCallback: HwdbHasAnyDriver threw an exception"), 0);
                bException = TRUE;
                p->Handled = TRUE;
            }

            if (bException) {
                __try {
                    //
                    // bad string passed back, or some internal error
                    // try to print the string
                    //
                    if (listPnpIds) {
                        PTSTR multisz = CreatePrintableString (listPnpIds);
                        DynUpdtDebugLog (Winnt32LogError, TEXT(" - The string was %1"), 0, multisz);
                        FREE (multisz);
                    }
                }
                __except (EXCEPTION_EXECUTE_HANDLER) {
                    DynUpdtDebugLog (Winnt32LogError, TEXT(" - Bad string"), 0);
                }
            }

#ifdef UNICODE
            if (listPnpIds) {
                FREE (listPnpIds);
            }
#endif

            b = TRUE;
        }
        break;

    case SETUPQUERYID_DOWNLOADDRIVER:
        {
            if (!OutData ||
                !OutDataSize ||
                *OutDataSize < sizeof (BOOL)
                ) {
                SetLastError (ERROR_INVALID_PARAMETER);
                break;
            }
            b = TRUE;
        }
        break;

    }

    return b;
}



BOOL
WINAPI
Winnt32DuIsSupported (
    VOID
    )
{
    BOOL b;

    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Enter Winnt32DuIsSupported"), 0);

#ifndef UNICODE
    if (!pLoadWin9xDuSupport ()) {
        DynUpdtDebugLog (
            Winnt32LogWarning,
            TEXT("Winnt32DuIsSupported: %1 support module not loaded; no drivers will be downloaded"),
            0,
            "w95upg.dll"
            );
    }
#endif

    TRY {
        b = pInitSupportLibs () &&
            (Winnt32Restarted () || g_DynUpdtStatus->DuIsSupported ());
    }
    EXCEPT (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError (_exception_code ());
        DynUpdtDebugLog (Winnt32LogError, TEXT("Winnt32DuIsSupported: an exception occured"), 0);
    }
    END_EXCEPT

#ifndef UNICODE
    if (!b) {
        g_DynUpdtStatus->Win9xGetIncompDrvs = NULL;
        g_DynUpdtStatus->Win9xReleaseIncompDrvs = NULL;
    }
#endif

    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Leave Winnt32DuIsSupported (%1!d!)"), 0, b);

    return b;
}


BOOL
WINAPI
Winnt32DuInitialize (
    IN      PDYNUPDT_INIT InitData
    )
{
    DWORD rc;
    BOOL b = FALSE;

    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Enter Winnt32DuInitialize"), 0);

    __try {
        MYASSERT (InitData);
        MYASSERT (InitData->TempDir);
        MYASSERT (g_DynUpdtStatus->DuInitialize);
        MYASSERT (!Winnt32Restarted ());

        if (CreateMultiLevelDirectory (InitData->TempDir) != ERROR_SUCCESS) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("Winnt32DuInitialize: CreateDirectory(%1) FAILED"), 0, InitData->TempDir);
            __leave;
        }

        //
        // initialize the Whistler PNP database
        //
        if (!g_DynUpdtStatus->HwdbDatabase) {
            //
            // ignore db load error
            //
            pInitNtPnpDb (FALSE);
        }

        TRY {
            //
            // if a download source already exists, no need to initialize the control
            // since no download will be really necessary
            //
            MYASSERT (!g_DynUpdtStatus->DynamicUpdatesSource[0]);
            g_DynUpdtStatus->Connection = (*g_DynUpdtStatus->DuInitialize) (
                                                InitData->DownloadRoot,
                                                InitData->TempDir,
                                                InitData->TargetOsVersion,
                                                InitData->TargetPlatform,
                                                InitData->TargetLCID,
                                                InitData->Unattend,
                                                InitData->Upgrade,
                                                Winnt32QueryCallback
                                                );
            if (g_DynUpdtStatus->Connection == INVALID_HANDLE_VALUE) {
                DynUpdtDebugLog (
                    Winnt32LogError,
                    TEXT("DuInitialize FAILED"),
                    0
                    );
                __leave;
            }
            g_DynUpdtStatus->ProgressWindow = InitData->ProgressWindow;
            b = TRUE;
        }
        EXCEPT (EXCEPTION_EXECUTE_HANDLER) {
            SetLastError (_exception_code ());
            DynUpdtDebugLog (Winnt32LogError, TEXT("Winnt32DuInitialize: an exception occured"), 0);
        }
        END_EXCEPT

    }
    __finally {
        if (!b) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("Winnt32DuInitialize FAILED"), 0);
        }
    }

    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Leave Winnt32DuInitialize (%1!d!)"), 0, b);

    return b;
}


BOOL
WINAPI
Winnt32DuInitiateGetUpdates (
    OUT     PDWORD TotalEstimatedTime,
    OUT     PDWORD TotalEstimatedSize
	)
{
    BOOL b = FALSE;
#ifndef UNICODE
    PSTR* incompWin9xDrivers;
    PSTRINGLIST listEntry;
    PCSTR* q;
#endif

    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Enter Winnt32DuInitiateGetUpdates"), 0);

    if (g_DynUpdtStatus->Connection != INVALID_HANDLE_VALUE &&
        g_DynUpdtStatus->DuDoDetection &&
        g_DynUpdtStatus->DuBeginDownload
        ) {

        TRY {

#ifdef UNICODE
            b = (*g_DynUpdtStatus->DuDoDetection) (g_DynUpdtStatus->Connection, TotalEstimatedTime, TotalEstimatedSize);
            if (!b) {
                DynUpdtDebugLog (
                    DynUpdtLogLevel,
                    TEXT("DuDoDetection returned FALSE; no files will be downloaded"),
                    0
                    );
            }
#else
            b = TRUE;
            g_DynUpdtStatus->IncompatibleDriversCount = 0;
            if (g_DynUpdtStatus->Win9xGetIncompDrvs) {
                //
                // let the upgrade module do detection on Win95
                //
                b = (*g_DynUpdtStatus->Win9xGetIncompDrvs) (&incompWin9xDrivers);
                if (b) {
                    b = (*g_DynUpdtStatus->DuQueryUnsupDrvs) (
                                                g_DynUpdtStatus->Connection,
                                                incompWin9xDrivers,
                                                TotalEstimatedTime,
                                                TotalEstimatedSize
                                                );
                    if (incompWin9xDrivers) {
                        for (q = incompWin9xDrivers; *q; q++) {
                            g_DynUpdtStatus->IncompatibleDriversCount++;
                        }
                    }
                    if (g_DynUpdtStatus->Win9xReleaseIncompDrvs) {
                        (*g_DynUpdtStatus->Win9xReleaseIncompDrvs) (incompWin9xDrivers);
                    }
                    if (!b) {
                        DynUpdtDebugLog (
                            DynUpdtLogLevel,
                            TEXT("DuQueryUnsupportedDrivers returned FALSE; no files will be downloaded"),
                            0
                            );
                    }
                } else {
                    DynUpdtDebugLog (
                        DynUpdtLogLevel,
                        TEXT("Win9xGetIncompDrvs returned FALSE; no files will be downloaded"),
                        0
                        );
                }
            }
#endif

            if (b) {
                b = (*g_DynUpdtStatus->DuBeginDownload) (g_DynUpdtStatus->Connection, g_DynUpdtStatus->ProgressWindow);
                if (!b) {
                    DynUpdtDebugLog (
                        DynUpdtLogLevel,
                        TEXT("DuBeginDownload returned FALSE; no files will be downloaded"),
                        0
                        );
                }
            }
        }
        EXCEPT (EXCEPTION_EXECUTE_HANDLER) {
            SetLastError (_exception_code ());
            DynUpdtDebugLog (
                Winnt32LogError,
                TEXT("Winnt32DuInitiateGetUpdates: an exception occured; no files will be downloaded"),
                0
                );
        }
        END_EXCEPT
    } else {
        SetLastError (ERROR_INVALID_FUNCTION);
    }

    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Leave Winnt32DuInitiateGetUpdates (%1!d!)"), 0, b);

    return b;
}


VOID
WINAPI
Winnt32DuCancel (
    VOID
    )
{
    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Enter Winnt32DuCancel"), 0);

    TRY {
        if (g_DynUpdtStatus->Connection != INVALID_HANDLE_VALUE &&
            g_DynUpdtStatus->DuAbortDownload
            ) {
            (*g_DynUpdtStatus->DuAbortDownload) (g_DynUpdtStatus->Connection);
        }
        //
        // BUGBUG - is this definitive?
        //
    }
    EXCEPT (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError (_exception_code ());
        DynUpdtDebugLog (Winnt32LogError, TEXT("Winnt32DuCancel: an exception occured"), 0);
    }
    END_EXCEPT

    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Leave Winnt32DuCancel"), 0);
}


BOOL
WINAPI
Winnt32DuProcessFiles (
    OUT     PBOOL StopSetup
    )
{
    BOOL b;

    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Enter Winnt32DuProcessFiles"), 0);

    b = ProcessDownloadedFiles (StopSetup);

    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Leave Winnt32DuProcessFiles (%1!d!)"), 0, b);

    return b;
}


BOOL
WINAPI
Winnt32DuWriteParams (
    IN      PCTSTR ParamsFile
    )
{
    PSDLIST p;
    PSTRINGLIST q;
    DWORD len1, len2;
    PTSTR pathList1 = NULL, pathList2 = NULL;
    PTSTR append1, append2;
    BOOL b = TRUE;

    if (!DynamicUpdateSuccessful ()) {
        DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Winnt32DuWriteParams: disabled because DU did not succeed"), 0);
        return TRUE;
    }

    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Enter Winnt32DuWriteParams"), 0);

    //
    // store paths to all downloaded drivers in a key in the answer file,
    // so later on Textmode Setup (or GUI setup) will append this list to the OemPnPDriversPath
    //
    if (g_DynUpdtStatus->NewDriversList) {

        len1 = len2 = 0;
        for (p = g_DynUpdtStatus->NewDriversList; p; p = p->Next) {
            if (p->Data) {
                len1 += lstrlen (p->String) + 1;
            } else {
                len2 += lstrlen (p->String) + 1;
            }
        }

        if (len1) {
            pathList1 = (PTSTR) MALLOC (len1 * sizeof (TCHAR));
            if (!pathList1) {
                b = FALSE;
                goto exit;
            }
            *pathList1 = 0;
            append1 = pathList1;
        }
        if (len2) {
            pathList2 = (PTSTR) MALLOC (len2 * sizeof (TCHAR));
            if (!pathList2) {
                FREE (pathList1);
                b = FALSE;
                goto exit;
            }
            *pathList2 = 0;
            append2 = pathList2;
        }

        for (p = g_DynUpdtStatus->NewDriversList; p; p = p->Next) {
            if (p->Data) {
                if (append1 != pathList1) {
                    *append1++ = TEXT(',');
                }
                lstrcpy (append1, p->String);
                append1 = _tcschr (append1, 0);
            } else {
                if (append2 != pathList2) {
                    *append2++ = TEXT(',');
                }
                lstrcpy (append2, p->String);
                append2 = _tcschr (append2, 0);
            }
        }

        if (len1) {
            if (!WritePrivateProfileString (
                    WINNT_SETUPPARAMS,
                    WINNT_SP_DYNUPDTADDITIONALGUIDRIVERS,
                    pathList1,
                    ParamsFile
                    )) {
                b = FALSE;
            }
        }
        if (b && len2) {
            if (!WritePrivateProfileString (
                    WINNT_SETUPPARAMS,
                    WINNT_SP_DYNUPDTADDITIONALPOSTGUIDRIVERS,
                    pathList2,
                    ParamsFile
                    )) {
                b = FALSE;
            }
        }

        if (pathList1) {
            FREE (pathList1);
        }
        if (pathList2) {
            FREE (pathList2);
        }

        if (b && g_DynUpdtStatus->GuidrvsInfSource[0]) {
            if (!WritePrivateProfileString (
                    WINNT_SETUPPARAMS,
                    WINNT_SP_DYNUPDTDRIVERINFOFILE,
                    g_DynUpdtStatus->GuidrvsInfSource,
                    ParamsFile
                    )) {
                b = FALSE;
            }
        }
    }

    //
    // store paths to all downloaded BOOT drivers in a key in the answer file,
    // so later on Textmode Setup will append this to the boot drivers list
    //
    if (b && g_DynUpdtStatus->BootDriverPathList) {

        len1 = 0;
        for (q = g_DynUpdtStatus->BootDriverPathList; q; q = q->Next) {
            len1 += lstrlen (q->String) + 1;
        }

        pathList1 = (PTSTR) MALLOC (len1 * sizeof (TCHAR));
        if (!pathList1) {
            b = FALSE;
            goto exit;
        }

        *pathList1 = 0;
        append1 = pathList1;

        for (q = g_DynUpdtStatus->BootDriverPathList; q; q = q->Next) {
            if (append1 != pathList1) {
                *append1++ = TEXT(',');
            }
            lstrcpy (append1, q->String);
            append1 = _tcschr (append1, 0);
        }

        if (!WritePrivateProfileString (
                WINNT_SETUPPARAMS,
                WINNT_SP_DYNUPDTBOOTDRIVERPRESENT,
                WINNT_A_YES,
                ParamsFile
                ) ||
            !WritePrivateProfileString (
                WINNT_SETUPPARAMS,
                WINNT_SP_DYNUPDTBOOTDRIVERROOT,
                S_SUBDIRNAME_DRIVERS,
                ParamsFile
                ) ||
            !WritePrivateProfileString (
                WINNT_SETUPPARAMS,
                WINNT_SP_DYNUPDTBOOTDRIVERS,
                pathList1,
                ParamsFile
                )) {
            b = FALSE;
        }

        FREE (pathList1);
    }

    if (b && g_DynUpdtStatus->UpdatesCabTarget[0]) {
        TCHAR buffer[4*MAX_PATH];
        wsprintf (
            buffer,
            TEXT("\"%s\""),
            g_DynUpdtStatus->UpdatesCabTarget
            );
        b = WritePrivateProfileString (
                WINNT_SETUPPARAMS,
                WINNT_SP_UPDATEDSOURCES,
                buffer,
                ParamsFile
                );
    }

    //
    // new assemblies to be installed during GUI setup
    //
    if (b && g_DynUpdtStatus->DuasmsTarget[0]) {
        b = WritePrivateProfileString (
                WINNT_SETUPPARAMS,
                WINNT_SP_UPDATEDDUASMS,
                g_DynUpdtStatus->DuasmsTarget,
                ParamsFile
                );
    }

#ifdef _X86_

    //
    // last but not least, replace the Win9xupg NT side migration dll (w95upgnt.dll)
    // if a new one is available
    //
    if (b && Upgrade && !ISNT() && g_DynUpdtStatus->Winnt32Path[0]) {
        TCHAR source[MAX_PATH];
        TCHAR target[MAX_PATH];

        BuildPath (target, g_DynUpdtStatus->Winnt32Path, TEXT("w95upgnt.dll"));
        if (pDoesFileExist (target)) {
            //
            // check file versions first
            //
            BuildPath (source, NativeSourcePaths[0], TEXT("w95upgnt.dll"));
            if (!IsFileVersionLesser (target, source)) {
                if (_tcsnicmp (
                        g_DynUpdtStatus->Winnt32Path,
                        g_DynUpdtStatus->WorkingDir,
                        lstrlen (g_DynUpdtStatus->WorkingDir)
                        )) {
                    //
                    // copy the file in a local directory first
                    //
                    BuildPath (source, g_DynUpdtStatus->WorkingDir, TEXT("w95upgnt.dll"));
                    if (CopyFile (target, source, FALSE)) {
                        lstrcpy (target, source);
                    } else {
                        //
                        // failed to copy the NT-side upgrade module!
                        // fail the upgrade
                        //
                        DynUpdtDebugLog (
                            Winnt32LogSevereError,
                            TEXT("Failed to copy replacement %1 to %2; upgrade aborted"),
                            0,
                            target,
                            source
                            );
                        b = FALSE;
                    }
                }
                if (b) {
                    b = WritePrivateProfileString (
                            WINNT_WIN95UPG_95_DIR,
                            WINNT_WIN95UPG_NTKEY,
                            target,
                            ParamsFile
                            );
                    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Will use replacement %1 on the NT side of migration"), 0, target);
                }
            }
        }
    }

#endif

    if (b) {
        if (g_DynUpdtStatus->WorkingDir[0]) {
            b = WritePrivateProfileString (
                    WINNT_SETUPPARAMS,
                    WINNT_SP_DYNUPDTWORKINGDIR,
                    g_DynUpdtStatus->WorkingDir,
                    ParamsFile
                    );
        }
    }

    if (b) {
        //
        // flush it to disk
        //
        WritePrivateProfileString (NULL, NULL, NULL, ParamsFile);
    }

exit:
    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Leave Winnt32DuWriteParams (%1!d!)"), 0, b);

    return b;
}


VOID
WINAPI
Winnt32DuUninitialize (
    VOID
    )
{
    DWORD i;
    TCHAR pathPss[MAX_PATH];
    PTSTR p;

    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Enter Winnt32DuUninitialize"), 0);

    TRY {
        if (g_DynUpdtStatus->Connection != INVALID_HANDLE_VALUE) {
            if (g_DynUpdtStatus->DuUninitialize) {
                (*g_DynUpdtStatus->DuUninitialize) (g_DynUpdtStatus->Connection);
            }
            g_DynUpdtStatus->Connection = INVALID_HANDLE_VALUE;
        }

        g_DynUpdtStatus->DuIsSupported = NULL;
        g_DynUpdtStatus->ProgressWindow = NULL;
        g_DynUpdtStatus->DuInitialize = NULL;
        g_DynUpdtStatus->DuDoDetection = NULL;
        g_DynUpdtStatus->DuQueryUnsupDrvs = NULL;
        g_DynUpdtStatus->DuBeginDownload = NULL;
        g_DynUpdtStatus->DuAbortDownload = NULL;
        g_DynUpdtStatus->DuUninitialize = NULL;

        if (g_DynUpdtStatus->DuLib) {
            FreeLibrary (g_DynUpdtStatus->DuLib);
            g_DynUpdtStatus->DuLib = NULL;
        }

        if (g_DynUpdtStatus->HwdbDatabase) {
            g_DynUpdtStatus->HwdbClose (g_DynUpdtStatus->HwdbDatabase);
            g_DynUpdtStatus->HwdbDatabase = NULL;
        }

        if (g_DynUpdtStatus->HwdbTerminate) {
            (*g_DynUpdtStatus->HwdbTerminate) ();
        }

        g_DynUpdtStatus->HwdbInitialize = NULL;
        g_DynUpdtStatus->HwdbTerminate = NULL;
        g_DynUpdtStatus->HwdbOpen = NULL;
        g_DynUpdtStatus->HwdbClose = NULL;
        g_DynUpdtStatus->HwdbAppendInfs = NULL;
        g_DynUpdtStatus->HwdbFlush = NULL;
        g_DynUpdtStatus->HwdbHasDriver = NULL;
        g_DynUpdtStatus->HwdbHasAnyDriver = NULL;

        if (g_DynUpdtStatus->HwdbLib) {
            FreeLibrary (g_DynUpdtStatus->HwdbLib);
            g_DynUpdtStatus->HwdbLib = NULL;
        }

#ifndef UNICODE
        g_DynUpdtStatus->Win9xGetIncompDrvs = NULL;
        g_DynUpdtStatus->Win9xReleaseIncompDrvs = NULL;
#endif

        if (g_DynUpdtStatus->WorkingDir[0]) {
            p = _tcsrchr (g_DynUpdtStatus->WorkingDir, TEXT('\\'));
            if (!p) {
                p = g_DynUpdtStatus->WorkingDir;
            }
            lstrcpyn (pathPss, g_DynUpdtStatus->WorkingDir, (INT)(p - g_DynUpdtStatus->WorkingDir + 2));
            lstrcat (pathPss, TEXT("setup.pss"));
            CreateMultiLevelDirectory (pathPss);
            lstrcat (pathPss, p);
            MyDelnode (pathPss);
        }

        if (!DynamicUpdateSuccessful ()) {
            if (g_DynUpdtStatus->WorkingDir[0]) {
                //
                // rename this directory to make sure no module uses any DU files
                //
                MYASSERT (pathPss[0]);
                if (!MoveFile (g_DynUpdtStatus->WorkingDir, pathPss)) {
                    DynUpdtDebugLog (
                        Winnt32LogError,
                        TEXT("Winnt32DuUninitialize: MoveFile %1 -> %2 failed"),
                        0,
                        g_DynUpdtStatus->WorkingDir,
                        pathPss
                        );
                    MyDelnode (g_DynUpdtStatus->WorkingDir);
                }
            }
        }

    }
    EXCEPT (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError (_exception_code ());
        DynUpdtDebugLog (Winnt32LogError, TEXT("Winnt32DuUninitialize: an exception occured"), 0);
    }
    END_EXCEPT

    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Leave Winnt32DuUninitialize"), 0);
}


BOOL
pAddMissingPrinterDrivers (
    IN  OUT PSTRINGLIST* List
    )
{
    DWORD nBytesNeeded = 0;
    DWORD nDriverRetrieved = 0;
    DWORD rc;
    PDRIVER_INFO_6 buffer = NULL;
    DWORD index;
    PCTSTR printerPnpId;
    PSTRINGLIST p;
    BOOL unsupported;
    BOOL b = FALSE;

    if (!EnumPrinterDrivers (
            NULL,
            NULL,
            6,
            NULL,
            0,
            &nBytesNeeded,
            &nDriverRetrieved
            )) {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto exit;
        }
    }

    if (nBytesNeeded) {
        buffer = (PDRIVER_INFO_6) MALLOC (nBytesNeeded);
        if (!buffer) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto exit;
        }
        //
        // get printer driver information
        //
        if (!EnumPrinterDrivers (
                NULL,
                NULL,
                6,
                (LPBYTE)buffer,
                nBytesNeeded,
                &nBytesNeeded,
                &nDriverRetrieved
                )) {
            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
                goto exit;
            }
        }
        for (index = 0; index < nDriverRetrieved; index++) {
            printerPnpId = buffer[index].pszHardwareID;
            if (!printerPnpId) {
                continue;
            }
            if (g_DynUpdtStatus->HwdbHasDriver (
                    g_DynUpdtStatus->HwdbDatabase,
                    printerPnpId,
                    &unsupported
                    )) {
                continue;
            }
            //
            // not an in-box driver
            //
            p = (PSTRINGLIST) MALLOC (sizeof (STRINGLIST));
            if (!p) {
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                goto exit;
            }
            p->String = MALLOC ((lstrlen (printerPnpId) + 2) * sizeof (TCHAR));
            if (!p->String) {
                FREE (p);
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                goto exit;
            }
            wsprintf (p->String, TEXT("%s%c"), printerPnpId, TEXT('\0'));
            p->Next = NULL;
            if (!InsertList ((PGENERIC_LIST*)List, (PGENERIC_LIST)p)) {
                DeleteStringCell (p);
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                goto exit;
            }
        }
    }
    b = TRUE;

exit:
    rc = GetLastError();
    if (buffer) {
        FREE (buffer);
    }
    SetLastError(rc);

    return b;
}

HDEVINFO
(WINAPI* SetupapiDiGetClassDevs) (
    IN CONST GUID *ClassGuid,  OPTIONAL
    IN PCWSTR      Enumerator, OPTIONAL
    IN HWND        hwndParent, OPTIONAL
    IN DWORD       Flags
    );

BOOL
(WINAPI* SetupapiDiGetDeviceRegistryProperty) (
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize         OPTIONAL
    );

BOOL
(WINAPI* SetupapiDiEnumDeviceInfo) (
    IN  HDEVINFO         DeviceInfoSet,
    IN  DWORD            MemberIndex,
    OUT PSP_DEVINFO_DATA DeviceInfoData
    );

BOOL
(WINAPI* SetupapiDiDestroyDeviceInfoList) (
    IN HDEVINFO DeviceInfoSet
    );


#ifdef UNICODE

PSTRINGLIST
BuildMissingPnpIdList (
    VOID
    )
{
    HDEVINFO hDeviceInfoSet;
    INT nIndex = 0;
    SP_DEVINFO_DATA DeviceInfoData;
    PTSTR buffer = NULL;
    ULONG uHwidSize, uCompatidSize;
    DWORD rc;
    BOOL unsupported;
    PSTRINGLIST p;
    PSTRINGLIST list = NULL;
    HMODULE hSetupapi;
    BOOL b;
    BOOL bException;

    if (OsVersion.dwMajorVersion <= 4) {
        return list;
    }

    hSetupapi = LoadLibrary (TEXT("setupapi.dll"));
    if (!hSetupapi) {
        return list;
    }
    //
    // get the entry points
    //
    (FARPROC)SetupapiDiEnumDeviceInfo = GetProcAddress (hSetupapi, "SetupDiEnumDeviceInfo");
    (FARPROC)SetupapiDiDestroyDeviceInfoList = GetProcAddress (hSetupapi, "SetupDiDestroyDeviceInfoList");
    (FARPROC)SetupapiDiGetClassDevs = GetProcAddress (hSetupapi, "SetupDiGetClassDevsW");
    (FARPROC)SetupapiDiGetDeviceRegistryProperty = GetProcAddress (hSetupapi, "SetupDiGetDeviceRegistryPropertyW");

    if (!SetupapiDiEnumDeviceInfo ||
        !SetupapiDiDestroyDeviceInfoList ||
        !SetupapiDiGetClassDevs ||
        !SetupapiDiGetDeviceRegistryProperty
        ) {
        FreeLibrary (hSetupapi);
        return list;
    }

    hDeviceInfoSet = SetupapiDiGetClassDevs (NULL, NULL, NULL, DIGCF_ALLCLASSES);
    if (hDeviceInfoSet == INVALID_HANDLE_VALUE) {
        return list;
    }

    DeviceInfoData.cbSize = sizeof (SP_DEVINFO_DATA);
    while (SetupapiDiEnumDeviceInfo (hDeviceInfoSet, nIndex++, &DeviceInfoData)) {
        uHwidSize = uCompatidSize = 0;

        if (!SetupapiDiGetDeviceRegistryProperty (
                hDeviceInfoSet,
                &DeviceInfoData,
                SPDRP_HARDWAREID,
                NULL,
                NULL,
                0,
                &uHwidSize
                )) {
            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER &&
                GetLastError() != ERROR_INVALID_DATA
                ) {
                goto exit;
            }
        }
        if (!SetupapiDiGetDeviceRegistryProperty (
                hDeviceInfoSet,
                &DeviceInfoData,
                SPDRP_COMPATIBLEIDS,
                NULL,
                NULL,
                0,
                &uCompatidSize
                )) {
            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER &&
                GetLastError() != ERROR_INVALID_DATA
                ) {
                goto exit;
            }
        }
        //
        // allocate memory for the multi-sz buffer
        //
        if (!uHwidSize && !uCompatidSize) {
            continue;
        }
        buffer = (PTSTR) MALLOC ((uHwidSize + uCompatidSize) * sizeof (TCHAR));
        if (!buffer) {
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto exit;
        }
        //
        // get the hardware id and compatible id
        //
        if (uHwidSize) {
            if (!SetupapiDiGetDeviceRegistryProperty(
                    hDeviceInfoSet,
                    &DeviceInfoData,
                    SPDRP_HARDWAREID,
                    NULL,
                    (PBYTE)buffer,
                    uHwidSize,
                    NULL
                    )) {
                goto exit;
            }
        }		
        if (uCompatidSize) {
            if (!SetupapiDiGetDeviceRegistryProperty(
                    hDeviceInfoSet,
                    &DeviceInfoData,
                    SPDRP_COMPATIBLEIDS,
                    NULL,
                    (PBYTE)&buffer[uHwidSize / sizeof (TCHAR) - 1],
                    uCompatidSize,
                    NULL
                    )) {
                goto exit;
            }
        }
        //
        // check if there is an inbox driver for this device
        //
        bException = FALSE;
        __try {
            b = g_DynUpdtStatus->HwdbHasAnyDriver (
                    g_DynUpdtStatus->HwdbDatabase,
                    buffer,
                    &unsupported
                    );
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            SetLastError (GetExceptionCode());
            DynUpdtDebugLog (Winnt32LogError, TEXT("BuildMissingPnpIdList: HwdbHasAnyDriver threw an exception"), 0);
            bException = TRUE;
            b = TRUE;
        }

        if (bException) {
            __try {
                //
                // bad string passed back, or some internal error
                // try to print the string
                //
                PTSTR multisz = CreatePrintableString (buffer);
                DynUpdtDebugLog (Winnt32LogError, TEXT(" - The string was %1"), 0, multisz);
                FREE (multisz);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                DynUpdtDebugLog (Winnt32LogError, TEXT(" - Bad string"), 0);
            }
        }

        if (b) {
            FREE (buffer);
            buffer = NULL;
            continue;
        }
        //
        // no inbox driver - add it to the list
        //
        p = (PSTRINGLIST) MALLOC (sizeof (STRINGLIST));
        if (!p) {
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto exit;
        }
        p->String = buffer;
        p->Next = NULL;
        buffer = NULL;
        if (!InsertList ((PGENERIC_LIST*)&list, (PGENERIC_LIST)p)) {
            DeleteStringCell (p);
            DeleteStringList (list);
            list = NULL;
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto exit;
        }
    }

    if (GetLastError() == ERROR_NO_MORE_ITEMS) {
        SetLastError (ERROR_SUCCESS);
    }

exit:
    rc = GetLastError();
    SetupapiDiDestroyDeviceInfoList(hDeviceInfoSet);
    FreeLibrary (hSetupapi);
    if (buffer) {
        FREE (buffer);
    }
    if (rc == ERROR_SUCCESS) {
        //
        // get printer drivers
        //
        if (ISNT()) {
            if (!pAddMissingPrinterDrivers (&list)) {
                rc = GetLastError();
                DeleteStringList (list);
                list = NULL;
            }
        }
    }

    SetLastError(rc);

    return list;
}

#endif

BOOL
pHwdbHasAnyMissingDrivers (
    IN      HANDLE Hwdb,
    IN      PSTRINGLIST MissingPnpIds
    )
{
    PSTRINGLIST p;
    BOOL unsupported;
    BOOL b = FALSE;

    for (p = MissingPnpIds; p; p = p->Next) {

        BOOL bException = FALSE;

        __try {
            if (g_DynUpdtStatus->HwdbHasAnyDriver (Hwdb, p->String, &unsupported)) {
                b = TRUE;
                break;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            SetLastError (GetExceptionCode());
            DynUpdtDebugLog (
                Winnt32LogError,
                TEXT("pHwdbHasAnyMissingDrivers: HwdbHasAnyDriver threw an exception"),
                0
                );
            bException = TRUE;
        }
        if (bException) {
            __try {
                //
                // bad string passed back, or some internal error
                // try to print the string
                //
                PTSTR multisz = CreatePrintableString (p->String);
                DynUpdtDebugLog (Winnt32LogError, TEXT(" - The string was %1"), 0, multisz);
                FREE (multisz);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                DynUpdtDebugLog (Winnt32LogError, TEXT(" - Bad string"), 0);
            }
        }
    }

    return b;
}


typedef struct {
    PCTSTR BaseDir;
    PCTSTR Filename;
} CONTEXT_EXTRACTFILEINDIR, *PCONTEXT_EXTRACTFILEINDIR;

UINT
pExtractFileInDir (
    IN PVOID Context,
    IN UINT  Code,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    if (g_DynUpdtStatus->Cancelled) {
        return ERROR_CANCELLED;
    }

    switch (Code) {
    case SPFILENOTIFY_FILEINCABINET:
        {
            PFILE_IN_CABINET_INFO FileInCabInfo = (PFILE_IN_CABINET_INFO)Param1;
            PCONTEXT_EXTRACTFILEINDIR ctx = (PCONTEXT_EXTRACTFILEINDIR)Context;
            PTSTR p;

            if (lstrcmpi (FileInCabInfo->NameInCabinet, ctx->Filename)) {
                return FILEOP_SKIP;
            }
            BuildPath (FileInCabInfo->FullTargetName, ctx->BaseDir, FileInCabInfo->NameInCabinet);
            if (_tcschr (FileInCabInfo->NameInCabinet, TEXT('\\'))) {
                //
                // target file is in a subdir; first create it
                //
                p = _tcsrchr (FileInCabInfo->FullTargetName, TEXT('\\'));
                if (p) {
                    *p = 0;
                }
                if (CreateMultiLevelDirectory (FileInCabInfo->FullTargetName) != ERROR_SUCCESS) {
                    return FILEOP_ABORT;
                }
                if (p) {
                    *p = TEXT('\\');
                }
            }
            return FILEOP_DOIT;
        }
    case SPFILENOTIFY_NEEDNEWCABINET:
        {
            PCABINET_INFO CabInfo = (PCABINET_INFO)Param1;
            DynUpdtDebugLog (
                Winnt32LogError,
                TEXT("pExtractFileInDir: NeedNewCabinet %1\\%2 on %3 (SetId=%4!u!;CabinetNumber=%5!u!)"),
                0,
                CabInfo->CabinetPath,
                CabInfo->CabinetFile,
                CabInfo->DiskName,
                CabInfo->SetId,
                CabInfo->CabinetNumber
                );
            return ERROR_FILE_NOT_FOUND;
        }
    }

    return NO_ERROR;
}


UINT
pExpandCabInDir (
    IN PVOID Context,
    IN UINT  Code,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    if (g_DynUpdtStatus->Cancelled) {
        return ERROR_CANCELLED;
    }

    switch (Code) {
    case SPFILENOTIFY_FILEINCABINET:
        {
            PFILE_IN_CABINET_INFO FileInCabInfo = (PFILE_IN_CABINET_INFO)Param1;
            PTSTR p;

            BuildPath (FileInCabInfo->FullTargetName, (PCTSTR)Context, FileInCabInfo->NameInCabinet);
            if (_tcschr (FileInCabInfo->NameInCabinet, TEXT('\\'))) {
                //
                // target file is in a subdir; first create it
                //
                p = _tcsrchr (FileInCabInfo->FullTargetName, TEXT('\\'));
                if (p) {
                    *p = 0;
                }
                if (CreateMultiLevelDirectory (FileInCabInfo->FullTargetName) != ERROR_SUCCESS) {
                    return FILEOP_ABORT;
                }
                if (p) {
                    *p = TEXT('\\');
                }
            }
            return FILEOP_DOIT;
        }
    case SPFILENOTIFY_NEEDNEWCABINET:
        {
            PCABINET_INFO CabInfo = (PCABINET_INFO)Param1;
            DynUpdtDebugLog (
                Winnt32LogError,
                TEXT("pExpandCabInDir: NeedNewCabinet %1\\%2 on %3 (SetId=%4!u!;CabinetNumber=%5!u!)"),
                0,
                CabInfo->CabinetPath,
                CabInfo->CabinetFile,
                CabInfo->DiskName,
                CabInfo->SetId,
                CabInfo->CabinetNumber
                );
            return ERROR_FILE_NOT_FOUND;
        }
    }

    return NO_ERROR;
}


BOOL
pGetAutoSubdirName (
    IN      PCTSTR FilePath,
    OUT     PTSTR DirName
    )
{
    PTSTR p, q;

    lstrcpy (DirName, FilePath);
    p = _tcsrchr (DirName, TEXT('.'));
    q = _tcsrchr (DirName, TEXT('\\'));
    if (!p || (q && p < q)) {
        return FALSE;
    }
    *p = 0;
    return TRUE;
}

BOOL
pAddLibrariesForCompToCopyQueue (
    IN      PCTSTR ModuleName,
    IN      PCTSTR Subdir,
    IN      PCTSTR BaseDir,
    IN      HSPFILEQ SetupQueue
    )
{
    static struct {
        PCTSTR SubDir;
        PCTSTR LibsMultiSz;
    } g_SubdirReqLibs [] = {
        TEXT("win9xupg"), TEXT("setupapi.dll\0cfgmgr32.dll\0msvcrt.dll\0cabinet.dll\0imagehlp.dll\0"),
        TEXT("winntupg"), TEXT("setupapi.dll\0cfgmgr32.dll\0msvcrt.dll\0"),
    };

    INT i;
    TCHAR dst[MAX_PATH];
    TCHAR src[MAX_PATH];
    TCHAR sourceFile[MAX_PATH];
    PTSTR p, q;
    PCTSTR fileName;

    for (i = 0; i < SIZEOFARRAY (g_SubdirReqLibs); i++) {
        if (Subdir == g_SubdirReqLibs[i].SubDir ||
            Subdir && !lstrcmpi (Subdir, g_SubdirReqLibs[i].SubDir)
            ) {
            break;
        }
    }
    if (i >= SIZEOFARRAY (g_SubdirReqLibs)) {
        return TRUE;
    }

    //
    // prepare src and dest path
    //
    if (!GetModuleFileName (NULL, src, MAX_PATH)) {
        return FALSE;
    }
    p = _tcsrchr (src, TEXT('\\'));
    if (!p) {
        return FALSE;
    }
    *p = 0;
    q = dst + wsprintf (dst, TEXT("%s"), BaseDir);
    if (Subdir) {
        p = p + wsprintf (p, TEXT("\\%s"), Subdir);
        q = q + wsprintf (q, TEXT("\\%s"), Subdir);
    }
    //
    // copy each source file
    //
    for (fileName = g_SubdirReqLibs[i].LibsMultiSz;
         *fileName;
         fileName = _tcschr (fileName, 0) + 1) {
        wsprintf (q, TEXT("\\%s"), fileName);
        //
        // check if file already exists at dest
        //
        if (!pDoesFileExist (dst)) {
            //
            // check if the source file actually exists
            //
            BuildPath (sourceFile, src, fileName);
            if (!pDoesFileExist (sourceFile)) {
                DynUpdtDebugLog (Winnt32LogError, TEXT("Source file %1 not found"), 0, sourceFile);
                return FALSE;
            }
            //
            // prepare source path and copy file
            //
            *q = 0;
            if (!SetupapiQueueCopy (
                    SetupQueue,
                    src,
                    NULL,
                    fileName,
                    NULL,
                    NULL,
                    dst,
                    NULL,
                    SP_COPY_SOURCEPATH_ABSOLUTE
                    )) {
                return FALSE;
            }
        }
    }

    return TRUE;
}


BOOL
pIsBootDriver (
    IN      PCTSTR DriverFilesDir
    )
{
    FILEPATTERN_ENUM e;
    BOOL b = FALSE;

    if (EnumFirstFilePattern (&e, DriverFilesDir, TEXT("txtsetup.oem"))) {
        b = !(e.FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
        AbortEnumFilePattern (&e);
    }
    return b;
}


BOOL
pIsExcluded (
    IN      HINF GuiDrvsInf,
    IN      PCTSTR PnPId,
    IN      PCTSTR ActualInfFilename,
    IN      PCTSTR SourceDir,
    IN      PCTSTR FullInfPath
    )
{
    TCHAR buffer[MAX_PATH];
    PTSTR packageName;
    INFCONTEXT ic;
    TCHAR field[MAX_PATH];
    TCHAR driverVer[MAX_PATH];

    if (!((GuiDrvsInf != INVALID_HANDLE_VALUE && PnPId && ActualInfFilename && SourceDir && FullInfPath))) {
        MYASSERT (FALSE);
        return FALSE;
    }

    lstrcpy (buffer, SourceDir);
    packageName = _tcsrchr (buffer, TEXT('\\'));
    if (!packageName) {
        return FALSE;
    }
    packageName++;

    if (SetupapiFindFirstLine (GuiDrvsInf, TEXT("ExcludedDrivers"), NULL, &ic)) {
        do {
            if (!SetupapiGetStringField (&ic, GUIDRVS_FIELD_CABNAME, field, MAX_PATH, NULL)) {
                continue;
            }
            if (lstrcmpi (field, packageName)) {
                continue;
            }
            if (!SetupapiGetStringField (&ic, GUIDRVS_FIELD_INFNAME, field, MAX_PATH, NULL)) {
                return TRUE;
            }
            if (lstrcmpi (field, ActualInfFilename)) {
                continue;
            }
            if (SetupapiGetStringField (&ic, GUIDRVS_FIELD_DRIVERVER, field, MAX_PATH, NULL)) {
                if (field[0] != TEXT('*')) {
                    //
                    // read the DriverVer value out of this INF
                    //
                    GetPrivateProfileString (
                            TEXT("Version"),
                            TEXT("DriverVer"),
                            TEXT(""),
                            driverVer,
                            MAX_PATH,
                            FullInfPath
                            );
                    if (lstrcmpi (field, driverVer)) {
                        continue;
                    }
                }
            }
            if (SetupapiGetStringField (&ic, GUIDRVS_FIELD_HARDWAREID, field, MAX_PATH, NULL) &&
                lstrcmpi (field, PnPId)
                ) {
                continue;
            }
            return TRUE;
        } while (SetupapiFindNextLine (&ic, &ic));
    }

    return FALSE;
}


BOOL
Winnt32HwdbAppendInfsCallback (
    IN      PVOID Context,
    IN      PCTSTR PnpId,
    IN      PCTSTR ActualInfFilename,
    IN      PCTSTR SourceDir,
    IN      PCTSTR FullInfPath
    )
{
    HINF hGuiDrvs = (HINF)Context;
    MYASSERT (hGuiDrvs != INVALID_HANDLE_VALUE);
    return !pIsExcluded (hGuiDrvs, PnpId, ActualInfFilename, SourceDir, FullInfPath);
}


BOOL
pBuildHwcompDat (
    IN      PCTSTR DriverDir,
    IN      HINF GuidrvsInf,            OPTIONAL
    IN      BOOL AlwaysRebuild,
    IN      BOOL AllowUI
    )
{
    HANDLE hDB;
    TCHAR datFile[MAX_PATH];
    BOOL b = TRUE;

    BuildPath (datFile, DriverDir, S_HWCOMP_DAT);

    if (AlwaysRebuild) {
        SetFileAttributes (datFile, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (datFile);
    }

    if (pDoesFileExist (datFile)) {
        return TRUE;
    }

    hDB = g_DynUpdtStatus->HwdbOpen (NULL);
    if (!hDB) {
        return FALSE;
    }

    if (g_DynUpdtStatus->HwdbAppendInfs (
                            hDB,
                            DriverDir,
                            GuidrvsInf != INVALID_HANDLE_VALUE ? Winnt32HwdbAppendInfsCallback : NULL,
                            (PVOID)GuidrvsInf
                            )) {

        if (g_DynUpdtStatus->HwdbFlush (hDB, datFile)) {
            DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Successfully built precompiled hardware database %1"), 0, datFile);
        } else {
            if (AllowUI) {
                MessageBoxFromMessage (
                    g_DynUpdtStatus->ProgressWindow,
                    MSG_ERROR_WRITING_FILE,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL,
                    GetLastError (),
                    datFile
                    );
            }
            b = FALSE;
        }
    } else {
        if (AllowUI) {
            MessageBoxFromMessage (
                g_DynUpdtStatus->ProgressWindow,
                MSG_ERROR_PROCESSING_DRIVER,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                DriverDir
                );
        }
        b = FALSE;
    }

    g_DynUpdtStatus->HwdbClose (hDB);

    return b;
}


UINT
pWriteAnsiFilelistToFile (
    IN PVOID Context,
    IN UINT  Code,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    if (g_DynUpdtStatus->Cancelled) {
        return ERROR_CANCELLED;
    }

    switch (Code) {
    case SPFILENOTIFY_FILEINCABINET:
        {
            PFILE_IN_CABINET_INFO FileInCabInfo = (PFILE_IN_CABINET_INFO)Param1;
            CHAR ansi[MAX_PATH];
            DWORD size;
            DWORD bytes;
            PCTSTR p;

            MYASSERT (!_tcschr (FileInCabInfo->NameInCabinet, TEXT('\\')));
#ifdef UNICODE
            size = wsprintfA (ansi, "%ls\r\n", FileInCabInfo->NameInCabinet);
#else
            size = wsprintfA (ansi, "%s\r\n", FileInCabInfo->NameInCabinet);
#endif
            if (!WriteFile ((HANDLE)Context, ansi, size, &bytes, NULL) || bytes != size) {
                return FILEOP_ABORT;
            }
            return FILEOP_SKIP;
        }
    }
    return NO_ERROR;
}

BOOL
CreateFileListSif (
    IN      PCTSTR SifPath,
    IN      PCTSTR SectionName,
    IN      PCTSTR CabinetToScan
    )
{
    HANDLE sif;
    CHAR ansi[MAX_PATH];
    DWORD size;
    DWORD bytes;
    BOOL b = TRUE;

    sif = CreateFile (
                SifPath,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
                );

    if (sif == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

#ifdef UNICODE
    size = wsprintfA (ansi, "[%ls]\r\n", SectionName);
#else
    size = wsprintfA (ansi, "[%s]\r\n", SectionName);
#endif
    if (!WriteFile (sif, ansi, size, &bytes, NULL) || bytes != size) {
        b = FALSE;
        goto exit;
    }

    b = SetupapiCabinetRoutine (CabinetToScan, 0, pWriteAnsiFilelistToFile, (PVOID)sif);

exit:
    CloseHandle (sif);
    if (!b) {
        DeleteFile (SifPath);
    }

    return b;
}

BOOL
pIsExecutableModule (
    IN      PCTSTR ModulePath
    )
{
    PCTSTR p;

    p = GetFileExtension (ModulePath);
    return p && !lstrcmpi (p, TEXT(".dll"));
}

UINT
pCopyFilesCallback (
    IN      PVOID Context,      //context used by the callback routine
    IN      UINT Notification,  //notification sent to callback routine
    IN      UINT_PTR Param1,        //additional notification information
    IN      UINT_PTR Param2         //additional notification information
    )
{
    switch (Notification) {
    case SPFILENOTIFY_COPYERROR:
        return FILEOP_ABORT;

    case SPFILENOTIFY_STARTCOPY:
        //
        // try to avoid unnecessary setupapi warnings that the files are not signed
        // or even blocked because of this; try to copy the file ourselves first
        //
        {
            PFILEPATHS paths = (PFILEPATHS)Param1;

            if (CopyFile (paths->Source, paths->Target, FALSE)) {
                return FILEOP_SKIP;
            }
        }
        break;

    case SPFILENOTIFY_STARTQUEUE:
    case SPFILENOTIFY_STARTSUBQUEUE:
    case SPFILENOTIFY_ENDSUBQUEUE:
    case SPFILENOTIFY_ENDQUEUE:
        return !g_DynUpdtStatus->Cancelled;
    }
    return SetupapiDefaultQueueCallback (Context, Notification, Param1, Param2);
}


BOOL
pProcessWinnt32Files (
    IN      PCTSTR Winnt32Cab,
    IN      BOOL ClientInstall,
    OUT     PBOOL StopSetup
    )
{
    FILEPATTERNREC_ENUM e;
    TCHAR winnt32WorkingDir[MAX_PATH];
    TCHAR dst[MAX_PATH];
    PTSTR p, subdir;
    HSPFILEQ hq;
    BOOL bLoaded;
    BOOL bRestartRequired;
    BOOL bReloadMainInf = FALSE;
    TCHAR buffer[MAX_PATH];
    TCHAR origSubPath[MAX_PATH];
    TCHAR origSubPathCompressed[MAX_PATH];
    TCHAR origFileName[MAX_PATH];
    TCHAR origFilePath[MAX_PATH];
    TCHAR destFilePath[MAX_PATH];
    TCHAR version[100];
    DWORD i;
    DWORD attr;
    BOOL b = TRUE;

    *StopSetup = FALSE;
    if (!pNonemptyFilePresent (Winnt32Cab)) {
        if (!ClientInstall) {
            DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Package %1 is not present"), 0, Winnt32Cab);
        }
        return TRUE;
    } else {
        //
        // don't process the cabinet in client installation mode; just warn about that
        //
        if (ClientInstall) {
            //
            // user specified updates location, but they didn't run winnt32 /prepare now or before
            //
            MessageBoxFromMessage (
               g_DynUpdtStatus->ProgressWindow,
               MSG_MUST_PREPARE_SHARE,
               FALSE,
               AppTitleStringId,
               MB_OK | MB_ICONSTOP | MB_TASKMODAL,
               g_DynUpdtStatus->DynamicUpdatesSource
               );
            *StopSetup = TRUE;
            return FALSE;
        }
    }

    DynUpdtDebugLog (
        DynUpdtLogLevel,
        TEXT("Analyzing package %1..."),
        0,
        Winnt32Cab
        );

    //
    // expand it in the corresponding subdir
    //
    BuildPath (
        winnt32WorkingDir,
        g_DynUpdtStatus->PrepareWinnt32 ?
            g_DynUpdtStatus->DynamicUpdatesSource :
            g_DynUpdtStatus->WorkingDir,
        S_SUBDIRNAME_WINNT32
        );

    //
    // expand CAB in this dir
    //
    if (CreateMultiLevelDirectory (winnt32WorkingDir) != ERROR_SUCCESS) {
        DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to create dir %1"), 0, winnt32WorkingDir);
        return FALSE;
    }
    if (!(*SetupapiCabinetRoutine) (Winnt32Cab, 0, pExpandCabInDir, (PVOID)winnt32WorkingDir)) {
        DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to expand cabinet %1"), 0, Winnt32Cab);
        return FALSE;
    }

    //
    // ISSUE: the patching support is currently not available for platforms other than x86
    //
#ifdef _X86_
    //
    // now let's look for any patches
    //
    if (EnumFirstFilePatternRecursive (&e, winnt32WorkingDir, S_PATCH_FILE_EXT, 0)) {

        do {
            BOOL bDeleteTempFile = FALSE;

            if (g_DynUpdtStatus->Cancelled) {
                SetLastError (ERROR_CANCELLED);
                b = FALSE;
                break;
            }

            if (e.FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                continue;
            }
            DynUpdtDebugLog (
                DynUpdtLogLevel,
                TEXT("pProcessWinnt32Files: found patch %1"),
                0,
                e.FullPath
                );
            //
            // get the original file from the sources location
            // the filename is obtained cutting the ._p1 extension
            //
            lstrcpy (origFileName, e.FileName);
            p = GetFileExtension (origFileName);
            if (!p) {
                MYASSERT (FALSE);
                continue;
            }
            *p = 0;
            lstrcpy (origSubPath, e.SubPath);
            p = GetFileExtension (origSubPath);
            if (!p) {
                MYASSERT (FALSE);
                continue;
            }
            *p = 0;
            if (!GetModuleFileName (NULL, origFilePath, MAX_PATH) ||
                !(p = _tcsrchr (origFilePath, TEXT('\\')))) {
                b = FALSE;
                break;
            }
            *p = 0;
            ConcatenatePaths (origFilePath, origSubPath, MAX_PATH);
            //
            // now check if this file (in it's compressed form or not) actually exists
            //
            if (!pDoesFileExist (origFilePath)) {
                //
                // try the compressed form
                //
                p = _tcschr (origFilePath, 0);
                MYASSERT (p);
                if (!p) {
                    continue;
                }
                p = _tcsdec (origFilePath, p);
                MYASSERT (p);
                if (!p) {
                    continue;
                }
                *p = TEXT('_');
                if (!pDoesFileExist (origFilePath)) {
                    //
                    // the file might exist on the original installation share (like w95upgnt.dll etc)
                    // generate compressed form of the file
                    //
                    lstrcpy (origSubPathCompressed, origSubPath);
                    p = _tcschr (origSubPathCompressed, 0);
                    MYASSERT (p);
                    if (!p) {
                        continue;
                    }
                    p = _tcsdec (origSubPathCompressed, p);
                    MYASSERT (p);
                    if (!p) {
                        continue;
                    }
                    *p = TEXT('_');
                    //
                    // now search for it
                    //
                    b = FALSE;
                    for (i = 0; i < SourceCount; i++) {
                        lstrcpyn (origFilePath, NativeSourcePaths[i], SIZEOFARRAY(origFilePath));
                        ConcatenatePaths (origFilePath, origSubPathCompressed, SIZEOFARRAY(origFilePath));
                        attr = GetFileAttributes (origFilePath);
                        if (attr != (DWORD)-1 && !(attr & FILE_ATTRIBUTE_DIRECTORY)) {
                            b = TRUE;
                            break;
                        }
                    }
                    if (!b) {
                        DynUpdtDebugLog (
                            Winnt32LogError,
                            TEXT("pProcessWinnt32Files: Unable to find original file %1 to apply the patch"),
                            0,
                            origSubPath
                            );
                        break;
                    }
                }
                //
                // expand the file to the temp dir
                //
                BuildPath (buffer, g_DynUpdtStatus->TempDir, origSubPath);
                p = _tcsrchr (buffer, TEXT('\\'));
                MYASSERT (p);
                if (!p) {
                    continue;
                }
                *p = 0;
                if (CreateMultiLevelDirectory (buffer) != ERROR_SUCCESS) {
                    DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessWinnt32Files: Unable to create dir %1"), 0, buffer);
                    b = FALSE;
                    break;
                }
                if (!(*SetupapiCabinetRoutine) (origFilePath, 0, pExpandCabInDir, buffer)) {
                    DynUpdtDebugLog (
                        Winnt32LogError,
                        TEXT("pProcessWinnt32Files: Unable to expand original file %1 to dir %2"),
                        0,
                        origFilePath,
                        buffer
                        );
                    b = FALSE;
                    break;
                }
                *p = TEXT('\\');
                lstrcpy (origFilePath, buffer);
                bDeleteTempFile = TRUE;
            }
            BuildPath (destFilePath, winnt32WorkingDir, TEXT("$$temp$$.~~~"));
            //
            // now really apply the patch
            //
            if (!ApplyPatchToFile (e.FullPath, origFilePath, destFilePath, 0)) {
                DynUpdtDebugLog (
                    Winnt32LogError,
                    TEXT("pProcessWinnt32Files: ApplyPatchToFile failed to apply patch %1 to file %2"),
                    0,
                    e.FullPath,
                    origFilePath
                    );
                b = FALSE;
                break;
            }
            //
            // success! now move the file to the real destination
            //
            BuildPath (buffer, winnt32WorkingDir, origSubPath);
            p = _tcsrchr (buffer, TEXT('\\'));
            MYASSERT (p);
            if (!p) {
                continue;
            }
            *p = 0;
            if (CreateMultiLevelDirectory (buffer) != ERROR_SUCCESS) {
                DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessWinnt32Files: Unable to create dir %1"), 0, buffer);
                b = FALSE;
                break;
            }
            *p = TEXT('\\');
            SetFileAttributes (buffer, FILE_ATTRIBUTE_NORMAL);
            DeleteFile (buffer);
            if (!MoveFile (destFilePath, buffer)) {
                DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessWinnt32Files: Unable to move file %1 to final dest %2"), 0, destFilePath, buffer);
                b = FALSE;
                break;
            }
            if (!GetFileVersion (buffer, version)) {
                lstrcpy (version, TEXT("<unknown>"));
            }
            DynUpdtDebugLog (
                DynUpdtLogLevel,
                TEXT("pProcessWinnt32Files: successfully applied patch %1 to file %2; the new file %3 has version %4"),
                0,
                e.FullPath,
                origFilePath,
                buffer,
                version
                );
            //
            // now remove the patch file
            //
            SetFileAttributes (e.FullPath, FILE_ATTRIBUTE_NORMAL);
            DeleteFile (e.FullPath);
            if (bDeleteTempFile) {
                SetFileAttributes (origFilePath, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (origFilePath);
            }
        } while (EnumNextFilePatternRecursive (&e));
        AbortEnumFilePatternRecursive (&e);

    }

#endif

    if (!b) {
        goto exit;
    }

    //
    // process new Winnt32 components
    //
    hq = SetupapiOpenFileQueue ();
    if (hq == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    if (EnumFirstFilePatternRecursive (&e, winnt32WorkingDir, TEXT("*"), 0)) {

        do {
            if (g_DynUpdtStatus->Cancelled) {
                SetLastError (ERROR_CANCELLED);
                b = FALSE;
                break;
            }

            if (e.FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                continue;
            }

            if (!GetModuleFileName (NULL, dst, MAX_PATH) ||
                !(p = _tcsrchr (dst, TEXT('\\')))) {
                b = FALSE;
                break;
            }
            *p = 0;
            ConcatenatePaths (dst, e.SubPath, MAX_PATH);

            //
            // check file versions first
            //
            if (IsFileVersionLesser (e.FullPath, dst)) {
                continue;
            }

            //
            // if there's a file named winnt32.rst, force restart
            //
            if (!lstrcmpi (e.FileName, S_RESTART_FILENAME)) {
                if (!g_DynUpdtStatus->PrepareWinnt32) {
                    g_DynUpdtStatus->RestartWinnt32 = TRUE;
                    DynUpdtDebugLog (
                        DynUpdtLogLevel,
                        TEXT("File %1 present; winnt32 will restart"),
                        0,
                        e.FileName
                        );
                }
            } else {
                //
                // check if dosnet.inf is present; if it is, reset the global variables
                //
                if (!lstrcmpi (e.FileName, InfName) && FullInfName[0]) {
                    FullInfName[0] = 0;
                    bReloadMainInf = TRUE;
                }

                bLoaded = FALSE;
                bRestartRequired = Upgrade || !_tcschr (e.SubPath, TEXT('\\'));
                if (GetModuleHandle (e.FileName) != NULL) {
                    bLoaded = TRUE;
                    if (!g_DynUpdtStatus->PrepareWinnt32) {
                        //
                        // do NOT restart if it's NOT an upgrade and this is one of the upgrade modules
                        //
                        if (bRestartRequired) {
                            //
                            // need to restart winnt32 so the newly registered component can be used instead
                            //
                            g_DynUpdtStatus->RestartWinnt32 = TRUE;
                            DynUpdtDebugLog (
                                DynUpdtLogLevel,
                                TEXT("A newer version is available for %1; winnt32 will restart"),
                                0,
                                e.SubPath
                                );
                        }
                    }
                }
                if ((bLoaded || pIsExecutableModule (e.FullPath)) &&
                    (bRestartRequired || g_DynUpdtStatus->PrepareWinnt32)
                    ) {
                    //
                    // make all required libraries available for this module
                    //
                    p = _tcsrchr (e.SubPath, TEXT('\\'));
                    if (p) {
                        *p = 0;
                        subdir = e.SubPath;
                    } else {
                        subdir = NULL;
                    }
                    if (!pAddLibrariesForCompToCopyQueue (e.FileName, subdir, winnt32WorkingDir, hq)) {
                        b = FALSE;
                        break;
                    }
                    if (p) {
                        *p = TEXT('\\');
                    }
                }
            }
        } while (EnumNextFilePatternRecursive (&e));
        AbortEnumFilePatternRecursive (&e);

        if (b) {
            PVOID ctx;

            ctx = SetupapiInitDefaultQueueCallback (NULL);
            b = SetupapiCommitFileQueue (NULL, hq, pCopyFilesCallback, ctx);
            SetupapiTermDefaultQueueCallback (ctx);
            if (!b) {
                DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessWinnt32Files: SetupapiCommitFileQueue failed"), 0);
            }
        }
    }

    SetupapiCloseFileQueue (hq);

    if (b) {
        SetFileAttributes (Winnt32Cab, FILE_ATTRIBUTE_NORMAL);
        if (!DeleteFile (Winnt32Cab)) {
            DynUpdtDebugLog (Winnt32LogSevereError, TEXT("pProcessWinnt32Files: unable to delete file %1"), 0, Winnt32Cab);
            b = FALSE;
        }
    }

    if (b && bReloadMainInf) {
        b = FindPathToWinnt32File (InfName, FullInfName, MAX_PATH);
        MYASSERT (b);
        if (MainInf) {
            UnloadInfFile (MainInf);
            MainInf = NULL;
            b = LoadInfFile (FullInfName, TRUE, &MainInf) == NO_ERROR;
        }
    }

exit:

    return b;
}


BOOL
pProcessUpdates (
    IN      PCTSTR UpdatesCab,
    IN      BOOL ClientInstall,
    OUT     PBOOL StopSetup
    )
{
    TCHAR updatesSourceDir[MAX_PATH];
    TCHAR buffer[MAX_PATH];
    FILEPATTERNREC_ENUM e;
    TCHAR origSubPath[MAX_PATH];
    TCHAR origFileName[MAX_PATH];
    TCHAR origFilePath[MAX_PATH];
    TCHAR destFilePath[MAX_PATH];
    TCHAR version[100];
    PTSTR p;
    TCHAR updatesCabPath[MAX_PATH];
    HANDLE hCabContext;
    BOOL result;
    BOOL bPatchApplied = FALSE;
    HANDLE hCab;
    PSTRINGLIST listUpdatesFiles = NULL;
    PCTSTR cabPath;
    BOOL bCatalogFileFound;
    HANDLE hDiamond = NULL;
    BOOL b = TRUE;

    *StopSetup = FALSE;
    if (!pNonemptyFilePresent (UpdatesCab)) {
        if (!ClientInstall) {
            DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Package %1 is not present"), 0, UpdatesCab);
        }
        return TRUE;
    }

    DynUpdtDebugLog (
        DynUpdtLogLevel,
        TEXT("Analyzing package %1..."),
        0,
        UpdatesCab
        );

    if (ClientInstall) {
        BOOL bMustPrepare = FALSE;
        BuildSifName (UpdatesCab, destFilePath);
        if (!pDoesFileExist (destFilePath)) {
            bMustPrepare = TRUE;
        } else {
            BuildPath (updatesSourceDir, g_DynUpdtStatus->DynamicUpdatesSource, S_SUBDIRNAME_UPDATES);
            if (!DoesDirectoryExist (updatesSourceDir)) {
                bMustPrepare = TRUE;
            }
        }
        if (bMustPrepare) {

            //
            // user specified updates location, but they didn't run winnt32 /prepare now or before
            //
            MessageBoxFromMessage (
               g_DynUpdtStatus->ProgressWindow,
               MSG_MUST_PREPARE_SHARE,
               FALSE,
               AppTitleStringId,
               MB_OK | MB_ICONSTOP | MB_TASKMODAL,
               g_DynUpdtStatus->DynamicUpdatesSource
               );
            *StopSetup = TRUE;
            return FALSE;
        }
    } else {

        if (g_DynUpdtStatus->PrepareWinnt32) {
            BuildPath (updatesSourceDir, g_DynUpdtStatus->DynamicUpdatesSource, S_SUBDIRNAME_UPDATES);
        } else {
            BuildPath (updatesSourceDir, g_DynUpdtStatus->WorkingDir, S_SUBDIRNAME_UPDATES);
        }

        //
        // expand CAB in this dir
        // make sure dir is initially empty
        //
        MyDelnode (updatesSourceDir);
        if (CreateMultiLevelDirectory (updatesSourceDir) != ERROR_SUCCESS) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to create dir %1"), 0, updatesSourceDir);
            return FALSE;
        }
        if (!(*SetupapiCabinetRoutine) (UpdatesCab, 0, pExpandCabInDir, (PVOID)updatesSourceDir)) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to expand cabinet %1"), 0, UpdatesCab);
            return FALSE;
        }

        hDiamond = DiamondInitialize (g_DynUpdtStatus->TempDir);
        if (!hDiamond) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to initialize compression/decompression engine"), 0);
            return FALSE;
        }

        //
        // ISSUE: the patching support is currently not available for platforms other than x86
        //
#ifdef _X86_
        //
        // now let's look for any patches
        //
        if (EnumFirstFilePatternRecursive (&e, updatesSourceDir, S_PATCH_FILE_EXT, 0)) {
            //
            // load drvindex.inf in advance
            //
            TCHAR driverInfName[MAX_PATH];
            PVOID driverInfHandle;
            TCHAR driverCabName[MAX_PATH];
            TCHAR driverCabPath[MAX_PATH];

            if (!FindPathToInstallationFile (DRVINDEX_INF, driverInfName, MAX_PATH)) {
                DynUpdtDebugLog (
                    Winnt32LogError,
                    TEXT("pProcessUpdates: Unable to find %1"),
                    0,
                    DRVINDEX_INF
                    );
                AbortEnumFilePatternRecursive (&e);
                b = FALSE;
                goto exit;
            }
            if (LoadInfFile (driverInfName, FALSE, &driverInfHandle) != NO_ERROR) {
                DynUpdtDebugLog (
                    Winnt32LogError,
                    TEXT("pProcessUpdates: Unable to load %1"),
                    0,
                    driverInfName
                    );
                AbortEnumFilePatternRecursive (&e);
                b = FALSE;
                goto exit;
            }

            do {
                BOOL bDeleteTempFile = FALSE;

                if (g_DynUpdtStatus->Cancelled) {
                    SetLastError (ERROR_CANCELLED);
                    b = FALSE;
                    break;
                }

                if (e.FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    continue;
                }
                DynUpdtDebugLog (
                    DynUpdtLogLevel,
                    TEXT("pProcessUpdates: found patch %1"),
                    0,
                    e.FullPath
                    );
                //
                // get the original file from the sources location
                // the filename is obtained cutting the ._p1 extension
                //
                lstrcpy (origFileName, e.FileName);
                p = GetFileExtension (origFileName);
                if (!p) {
                    MYASSERT (FALSE);
                    continue;
                }
                *p = 0;
                lstrcpy (origSubPath, e.SubPath);
                p = GetFileExtension (origSubPath);
                if (!p) {
                    MYASSERT (FALSE);
                    continue;
                }
                *p = 0;
                BuildPath (origFilePath, SourcePaths[0], origSubPath);
                //
                // now check if this file (in it's compressed form or not) actually exists
                // note that the file may exist in driver.cab
                //
                if (InDriverCacheInf (driverInfHandle, origFileName, driverCabName, MAX_PATH)) {
                    CONTEXT_EXTRACTFILEINDIR ctx;
                    //
                    // extract the file to the temp dir
                    //
                    if (!driverCabName[0]) {
                        DynUpdtDebugLog (
                            Winnt32LogError,
                            TEXT("pProcessUpdates: cab name not found for %1 in %2"),
                            0,
                            origFileName,
                            driverInfName
                            );
                        b = FALSE;
                        break;
                    }
                    BuildPath (buffer, g_DynUpdtStatus->TempDir, origSubPath);
                    p = _tcsrchr (buffer, TEXT('\\'));
                    MYASSERT (p);
                    if (!p) {
                        continue;
                    }
                    *p = 0;
                    if (CreateMultiLevelDirectory (buffer) != ERROR_SUCCESS) {
                        DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpdates: Unable to create dir %1"), 0, buffer);
                        b = FALSE;
                        break;
                    }
                    ctx.BaseDir = buffer;
                    ctx.Filename = origFileName;
                    if (!FindPathToInstallationFile (driverCabName, driverCabPath, MAX_PATH)) {

                        DynUpdtDebugLog (
                            Winnt32LogError,
                            TEXT("pProcessUpdates: Unable to find cabinet %1"),
                            0,
                            driverCabName
                            );
                        b = FALSE;
                        break;
                    }
                    if (!(*SetupapiCabinetRoutine) (driverCabPath, 0, pExtractFileInDir, &ctx)) {
                        DynUpdtDebugLog (
                            Winnt32LogError,
                            TEXT("pProcessUpdates: Unable to extract file %1 from %2 to %3"),
                            0,
                            origFileName,
                            driverCabName,
                            buffer
                            );
                        b = FALSE;
                        break;
                    }
                    *p = TEXT('\\');
                    lstrcpy (origFilePath, buffer);
                    bDeleteTempFile = TRUE;
                } else {
                    if (!pDoesFileExist (origFilePath)) {
                        //
                        // try the compressed form
                        //
                        p = _tcschr (origFilePath, 0);
                        MYASSERT (p);
                        if (!p) {
                            continue;
                        }
                        p = _tcsdec (origFilePath, p);
                        MYASSERT (p);
                        if (!p) {
                            continue;
                        }
                        *p = TEXT('_');
                        if (!pDoesFileExist (origFilePath)) {
                            DynUpdtDebugLog (
                                Winnt32LogError,
                                TEXT("pProcessUpdates: Unable to find original file %1 to apply the patch"),
                                0,
                                origSubPath
                                );
                            b = FALSE;
                            break;
                        }
                        //
                        // expand the file to the temp dir
                        //
                        BuildPath (buffer, g_DynUpdtStatus->TempDir, origSubPath);
                        p = _tcsrchr (buffer, TEXT('\\'));
                        MYASSERT (p);
                        if (!p) {
                            continue;
                        }
                        *p = 0;
                        if (CreateMultiLevelDirectory (buffer) != ERROR_SUCCESS) {
                            DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpdates: Unable to create dir %1"), 0, buffer);
                            b = FALSE;
                            break;
                        }
                        if (!(*SetupapiCabinetRoutine) (origFilePath, 0, pExpandCabInDir, buffer)) {
                            DynUpdtDebugLog (
                                Winnt32LogError,
                                TEXT("pProcessUpdates: Unable to expand original file %1 to dir %2"),
                                0,
                                origFilePath,
                                buffer
                                );
                            b = FALSE;
                            break;
                        }
                        *p = TEXT('\\');
                        lstrcpy (origFilePath, buffer);
                        bDeleteTempFile = TRUE;
                    }
                }
                BuildPath (destFilePath, updatesSourceDir, TEXT("$$temp$$.~~~"));
                //
                // now really apply the patch
                //
                if (!ApplyPatchToFile (e.FullPath, origFilePath, destFilePath, 0)) {
                    DynUpdtDebugLog (
                        Winnt32LogError,
                        TEXT("pProcessUpdates: ApplyPatchToFile failed to apply patch %1 to file %2"),
                        0,
                        e.FullPath,
                        origFilePath
                        );
                    b = FALSE;
                    break;
                }
                //
                // success! now move the file to the real destination
                //
                BuildPath (buffer, updatesSourceDir, origSubPath);
                p = _tcsrchr (buffer, TEXT('\\'));
                MYASSERT (p);
                if (!p) {
                    continue;
                }
                *p = 0;
                if (CreateMultiLevelDirectory (buffer) != ERROR_SUCCESS) {
                    DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpdates: Unable to create dir %1"), 0, buffer);
                    b = FALSE;
                    break;
                }
                *p = TEXT('\\');
                SetFileAttributes (buffer, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (buffer);
                if (!MoveFile (destFilePath, buffer)) {
                    DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpdates: Unable to move file %1 to final dest %2"), 0, destFilePath, buffer);
                    b = FALSE;
                    break;
                }
                if (!GetFileVersion (buffer, version)) {
                    lstrcpy (version, TEXT("<unknown>"));
                }
                DynUpdtDebugLog (
                    DynUpdtLogLevel,
                    TEXT("pProcessUpdates: successfully applied patch %1 to file %2; the new file %3 has version %4"),
                    0,
                    e.FullPath,
                    origFilePath,
                    buffer,
                    version
                    );
                //
                // now remove the patch file
                //
                SetFileAttributes (e.FullPath, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (e.FullPath);
                bPatchApplied = TRUE;
                if (bDeleteTempFile) {
                    SetFileAttributes (origFilePath, FILE_ATTRIBUTE_NORMAL);
                    DeleteFile (origFilePath);
                }
            } while (EnumNextFilePatternRecursive (&e));
            AbortEnumFilePatternRecursive (&e);

            UnloadInfFile (driverInfHandle);

            if (!b) {
                goto exit;
            }
        }
#endif

        //
        // build a new updates.cab that will contain the patched versions of files
        // and no relative paths
        //

        BuildPath (updatesCabPath, g_DynUpdtStatus->TempDir, S_CABNAME_UPDATES);
        SetFileAttributes (updatesCabPath, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (updatesCabPath);

        hCabContext = DiamondStartNewCabinet (updatesCabPath);
        if (!hCabContext) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpdates: DiamondStartNewCabinet failed"), 0);
            b = FALSE;
            goto exit;
        }
        bCatalogFileFound = FALSE;
        if (EnumFirstFilePatternRecursive (&e, updatesSourceDir, TEXT("*"), 0)) {
            do {
                if (e.FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    continue;
                }
                hCab = hCabContext;
                cabPath = updatesCabPath;
                //
                // search for a previous file with the same name
                //
                if (FindStringCell (listUpdatesFiles, e.FileName, FALSE)) {
                    DynUpdtDebugLog (
                        Winnt32LogError,
                        TEXT("pProcessUpdates: found duplicate filename %1; aborting operation"),
                        0,
                        updatesCabPath
                        );
                    b = FALSE;
                    break;
                }
                if (!InsertList (
                        (PGENERIC_LIST*)&listUpdatesFiles,
                        (PGENERIC_LIST)CreateStringCell (e.FileName))
                        ) {
                    b = FALSE;
                    break;
                }
                b = DiamondAddFileToCabinet (hCab, e.FullPath, e.FileName);
                if (!b) {
                    DynUpdtDebugLog (
                        Winnt32LogError,
                        TEXT("pProcessUpdates: DiamondAddFileToCabinet(%1,%2) failed"),
                        0,
                        e.FullPath,
                        cabPath
                        );
                    break;
                }
                DynUpdtDebugLog (
                    DynUpdtLogLevel,
                    TEXT(" ... successfully added file %1 to %2"),
                    0,
                    e.FullPath,
                    cabPath
                    );

                p = GetFileExtension (e.FileName);
                if (p && !lstrcmpi (p, TEXT(".cat"))) {
                    bCatalogFileFound = TRUE;
                }

            } while (EnumNextFilePatternRecursive (&e));
            AbortEnumFilePatternRecursive (&e);
            if (!b) {
                goto exit;
            }
        }
        result = DiamondTerminateCabinet (hCabContext);
        if (!b) {
            DiamondTerminateCabinet (hCabContext);
            goto exit;
        }
        if (!result) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpdates: DiamondTerminateCabinet(%1) failed"), 0, updatesCabPath);
            b = FALSE;
            goto exit;
        }
        DynUpdtDebugLog (DynUpdtLogLevel, TEXT(" ... done"), 0);

        if (!bCatalogFileFound) {
            DynUpdtDebugLog (Winnt32LogWarning, TEXT("pProcessUpdates: no catalog found in package %1"), 0, UpdatesCab);
        }

        BuildPath (
            buffer,
            g_DynUpdtStatus->PrepareWinnt32 ? g_DynUpdtStatus->DynamicUpdatesSource : g_DynUpdtStatus->WorkingDir,
            S_CABNAME_UPDATES
            );
        if (!SetFileAttributes (buffer, FILE_ATTRIBUTE_NORMAL) ||
            !DeleteFile (buffer)) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpdates: Unable to remove file %1 in order to replace it"), 0, buffer);
            b = FALSE;
            goto exit;
        }
        SetFileAttributes (buffer, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (buffer);
        if (!MoveFile (updatesCabPath, buffer)) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpdates: Unable to move file %1 to %2"), 0, updatesCabPath, buffer);
            b = FALSE;
            goto exit;
        }
        DynUpdtDebugLog (DynUpdtLogLevel, TEXT("pProcessUpdates: moved file %1 to %2"), 0, updatesCabPath, buffer);
        lstrcpy (updatesCabPath, buffer);

        BuildSifName (updatesCabPath, destFilePath);
        if (!CreateFileListSif (destFilePath, S_SECTIONNAME_UPDATES, updatesCabPath)) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to build file %1"), 0, destFilePath);
            b = FALSE;
            goto exit;
        }
        DynUpdtDebugLog (
            DynUpdtLogLevel,
            TEXT("pProcessUpdates: created %1 containing the list of files in %2"),
            0,
            destFilePath,
            updatesCabPath
            );
    }

    if (!g_DynUpdtStatus->PrepareWinnt32) {
        //
        // build the default path to updates.cab used by the rest of setup
        //
        MYASSERT (IsArc() ? LocalSourceWithPlatform[0] : LocalBootDirectory[0]);
        BuildPath (
            g_DynUpdtStatus->UpdatesCabTarget,
            IsArc() ? LocalSourceWithPlatform : LocalBootDirectory,
            S_CABNAME_UPDATES
            );
        //
        // remember current location of updates.cab
        //
        lstrcpy (g_DynUpdtStatus->UpdatesCabSource, UpdatesCab);
        //
        // the location of updated files for replacement
        //
        lstrcpy (g_DynUpdtStatus->UpdatesPath, updatesSourceDir);
        //
        // also check for the presence of a file that will cause winnt32 to build the ~LS directory
        //
        BuildPath (destFilePath, updatesSourceDir, S_MAKE_LS_FILENAME);
        if (pDoesFileExist (destFilePath)) {
            MakeLocalSource = TRUE;
        }
    }

exit:
    if (hDiamond) {
        DiamondTerminate (hDiamond);
    }
    if (listUpdatesFiles) {
        DeleteStringList (listUpdatesFiles);
    }

    if (!b && UpgradeAdvisorMode) {
        //
        // in UpgradeAdvisor mode we expect failures
        //
        DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Unable to process %1 in UpgradeAdvisor mode; ignoring error"), 0, UpdatesCab);
        g_DynUpdtStatus->ForceRemoveWorkingDir = TRUE;
        b = TRUE;
    }

    return b;
}


BOOL
pProcessDuasms (
    IN      PCTSTR DuasmsCab,
    IN      BOOL ClientInstall
    )
{
    FILEPATTERN_ENUM e;
    TCHAR duasmsLocalDir[MAX_PATH];
    TCHAR dirName[MAX_PATH];
    DWORD rc;
    HKEY key;
    PCTSTR strDuasmsRegKey;
    BOOL duasms = FALSE;
    BOOL b = TRUE;

    if (!pNonemptyFilePresent (DuasmsCab)) {
        if (!ClientInstall) {
            DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Package %1 is not present"), 0, DuasmsCab);
        }
        return TRUE;
    }

    if (g_DynUpdtStatus->PrepareWinnt32) {
        DynUpdtDebugLog (DynUpdtLogLevel, TEXT("pProcessDuasms: Skipping it due to /%1 switch"), 0, WINNT_U_DYNAMICUPDATESPREPARE);
        return TRUE;
    }

    DynUpdtDebugLog (
        DynUpdtLogLevel,
        TEXT("Analyzing package %1..."),
        0,
        DuasmsCab
        );

    BuildPath (duasmsLocalDir, g_DynUpdtStatus->WorkingDir, S_SUBDIRNAME_DUASMS);

    //
    // expand CAB in this dir
    //
    MyDelnode (duasmsLocalDir);
    if (CreateMultiLevelDirectory (duasmsLocalDir) != ERROR_SUCCESS) {
        DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to create dir %1"), 0, duasmsLocalDir);
        return FALSE;
    }
    if (!(*SetupapiCabinetRoutine) (DuasmsCab, 0, pExpandCabInDir, (PVOID)duasmsLocalDir)) {
        DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to expand cabinet %1"), 0, DuasmsCab);
        return FALSE;
    }

    MYASSERT (IsArc() ? LocalSourceWithPlatform[0] : LocalBootDirectory[0]);
    BuildPath (
        g_DynUpdtStatus->DuasmsTarget,
        IsArc() ? LocalSourceWithPlatform : LocalBootDirectory,
        S_SUBDIRNAME_DUASMS
        );
    //
    // remember current location of duasms folder
    //
    lstrcpy (g_DynUpdtStatus->DuasmsSource, duasmsLocalDir);

    return TRUE;
}


BOOL
pFindPackage (
    IN      HINF InfHandle,
    IN      PCTSTR Section,
    IN      PCTSTR CabName,
    OUT     PBOOL Partial
    )
{
    INFCONTEXT ic;
    TCHAR value[MAX_PATH];

    if (SetupapiFindFirstLine (InfHandle, Section, NULL, &ic)) {
        do {
            if (SetupapiGetStringField (&ic, GUIDRVS_FIELD_CABNAME, value, MAX_PATH, NULL) &&
                !lstrcmpi (value, CabName)
                ) {
                if (Partial) {
                    *Partial = SetupapiGetStringField (&ic, GUIDRVS_FIELD_INFNAME, value, MAX_PATH, NULL);
                }
                return TRUE;
            }
        } while (SetupapiFindNextLine (&ic, &ic));
    }
    return FALSE;
}

VOID
pSanitizeDriverCabName (
    IN      PTSTR CabName
    )
{
#define CRC_SUFFIX_LENGTH       40

    PTSTR p, q;
    DWORD len;
    //
    // cut an extension like _B842485F4D3B024E675653929B247BE9C685BBD7 from the cab name
    //
    p = GetFileExtension (CabName);
    if (p) {
        MYASSERT (*p == TEXT('.'));
        *p = 0;
        q = _tcsrchr (CabName, TEXT('_'));
        if (q) {
            q++;
            len = lstrlen (q);
            if (len == CRC_SUFFIX_LENGTH) {
                PTSTR s = q;
                TCHAR ch;
                while (ch = (TCHAR)_totlower (*s++)) {
                    if (!((ch >= TEXT('0') && ch <= TEXT('9')) ||
                          (ch >= TEXT('a') && ch <= TEXT('f')))
                        ) {
                        break;
                    }
                }
                if (!ch) {
                    //
                    // we found what we expect
                    //
                    *(q - 1) = TEXT('.');
                    lstrcpy (q, p + 1);
                    p = NULL;
                }
            }
        }
        if (p) {
            *p = TEXT('.');
        }
    }
}


BOOL
pIsDriverExcluded (
    IN      HINF InfHandle,
    IN      PCTSTR CabName
    )
{
    BOOL bPartial;

    if (!pFindPackage (InfHandle, S_SECTION_EXCLUDED_DRVS, CabName, &bPartial)) {
        return FALSE;
    }
    return !bPartial;
}


BOOL
pIsPrivateCabinet (
    IN      PCTSTR Filename
    )
{
    static PCTSTR privateCabNames[] = {
        S_CABNAME_IDENT,
        S_CABNAME_WSDUENG,
        S_CABNAME_UPDATES,
        S_CABNAME_UPGINFS,
        S_CABNAME_WINNT32,
        S_CABNAME_MIGDLLS,
        S_CABNAME_DUASMS,
    };

    INT i;

    for (i = 0; i < sizeof (privateCabNames) / sizeof (privateCabNames[0]); i++) {
        if (!lstrcmpi (Filename, privateCabNames[i])) {
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
pIsPrivateSubdir (
    IN      PCTSTR Subdir
    )
{
    static PCTSTR privateSubDirNames[] = {
        S_SUBDIRNAME_TEMP,
        S_SUBDIRNAME_DRIVERS,
        S_SUBDIRNAME_WINNT32,
        S_SUBDIRNAME_UPDATES,
        S_SUBDIRNAME_UPGINFS,
        S_SUBDIRNAME_MIGDLLS,
        S_SUBDIRNAME_DUASMS,
    };

    INT i;

    for (i = 0; i < sizeof (privateSubDirNames) / sizeof (privateSubDirNames[0]); i++) {
        if (!lstrcmpi (Subdir, privateSubDirNames[i])) {
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
pFindValueInSectionAtFieldIndex (
    IN      HINF InfHandle,
    IN      PCTSTR Section,
    IN      DWORD FieldIndex,
    IN      PCTSTR FieldValue
    )
{
    INFCONTEXT ic;
    TCHAR value[MAX_PATH];

    if (SetupapiFindFirstLine (InfHandle, Section, NULL, &ic)) {
        do {
            if (SetupapiGetStringField (&ic, FieldIndex, value, MAX_PATH, NULL)) {
                if (lstrcmpi (FieldValue, value) == 0) {
                    return TRUE;
                }
            }
        } while (SetupapiFindNextLine (&ic, &ic));
    }
    return FALSE;
}


BOOL
pProcessNewdrvs (
    IN      PCTSTR NewdrvDir,
    IN      BOOL ClientInstall
    )

/*++

   All CABs in this dir except pIsPrivateCabinet() files are considered
   as containing new drivers. Each cab will be expanded in its own subdir (derived from cab filename)

--*/

{
    FILEPATTERN_ENUM e;
    FILEPATTERNREC_ENUM er;
    TCHAR dirName[MAX_PATH];
    TCHAR datFile[MAX_PATH];
    TCHAR relocDriverPath[MAX_PATH];
    PTSTR p;
    PSDLIST entry;
    HANDLE hDB;
    BOOL bCreateHwdb;
    BOOL bDriverNeeded;
    HINF infHandle;
    enum {
        CT_UNKNOWN,
        CT_GUI_APPROVED,
        CT_GUI_NOT_APPROVED
    } eContentType;
    BOOL bDriverIsGuiApproved;
    PSTRINGLIST missingPnpIds = NULL;
    PSTRINGLIST listEntry;
    BOOL bEntryFound;
    INFCONTEXT ic;
    TCHAR value[MAX_PATH];
    TCHAR sanitizedName[MAX_PATH];
    BOOL b = TRUE;

    __try {
        //
        // first open guidrvs.inf
        //
        BuildPath (datFile, g_DynUpdtStatus->DynamicUpdatesSource, S_GUI_DRIVERS_INF);
        infHandle = SetupapiOpenInfFile (datFile, NULL, INF_STYLE_WIN4, NULL);
        if (infHandle != INVALID_HANDLE_VALUE) {
            //
            // copy this file together with the drivers packages (if any)
            //
            lstrcpy (g_DynUpdtStatus->GuidrvsInfSource, datFile);
        } else {
            DynUpdtDebugLog (
                Winnt32LogWarning,
                TEXT("Could not open INF file %1 (rc=%2!u!)"),
                0,
                datFile,
                GetLastError ()
                );
        }
        //
        // look for CAB files and expand each one in its own subdir
        //
        if (!ClientInstall) {
            if (EnumFirstFilePatternRecursive (&er, NewdrvDir, TEXT("*.cab"), ECF_ENUM_SUBDIRS)) {
                do {
                    if (g_DynUpdtStatus->Cancelled) {
                        SetLastError (ERROR_CANCELLED);
                        b = FALSE;
                        break;
                    }

                    if (er.FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                        if (pIsPrivateSubdir (er.SubPath)) {
                            er.ControlFlags |= ECF_ABORT_ENUM_DIR;
                        }
                        continue;
                    }
                    if (!er.FindData->nFileSizeLow) {
                        DynUpdtDebugLog (Winnt32LogWarning, TEXT("File %1 has size 0 and will be ignored"), 0, er.FullPath);
                        continue;
                    }

                    lstrcpy (sanitizedName, er.FileName);
                    pSanitizeDriverCabName (sanitizedName);
                    if (pIsPrivateCabinet (sanitizedName)) {
                        continue;
                    }

                    BuildPath (dirName, g_DynUpdtStatus->DriversSource, sanitizedName);
                    p = GetFileExtension (dirName);
                    if (!p) {
                        MYASSERT (FALSE);
                        continue;
                    }
                    *p = 0;
                    //
                    // is this an excluded driver?
                    //
                    lstrcpy (datFile, sanitizedName);
                    p = GetFileExtension (datFile);
                    if (!p) {
                        MYASSERT (FALSE);
                        continue;
                    }
                    *p = 0;
                    if (pIsDriverExcluded (infHandle, datFile)) {
                        DynUpdtDebugLog (
                            Winnt32LogWarning,
                            TEXT("Driver %1 is excluded from processing via %2"),
                            0,
                            sanitizedName,
                            g_DynUpdtStatus->GuidrvsInfSource
                            );
                        if (DoesDirectoryExist (dirName)) {
                            //
                            // make sure there's no hwcomp.dat in this folder
                            //
                            BuildPath (datFile, dirName, S_HWCOMP_DAT);
                            if (pDoesFileExist (datFile)) {
                                SetFileAttributes (datFile, FILE_ATTRIBUTE_NORMAL);
                                DeleteFile (datFile);
                            }
                        }
                        continue;
                    }

                    DynUpdtDebugLog (
                        DynUpdtLogLevel,
                        TEXT("Analyzing driver package %1..."),
                        0,
                        er.FullPath
                        );

                    if (DoesDirectoryExist (dirName)) {
                        DynUpdtDebugLog (
                            Winnt32LogWarning,
                            TEXT("Recreating existing driver %1"),
                            0,
                            dirName
                            );
                        MyDelnode (dirName);
                    }
                    if (CreateMultiLevelDirectory (dirName) != ERROR_SUCCESS) {
                        DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to create dir %1"), 0, dirName);
                        continue;
                    }
                    //
                    // expand CAB in this dir
                    //
                    if (!(*SetupapiCabinetRoutine) (er.FullPath, 0, pExpandCabInDir, dirName)) {
                        DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to expand cabinet %1"), 0, er.FullPath);
                        if (GetLastError () == ERROR_DISK_FULL) {
                            DynUpdtDebugLog (Winnt32LogSevereError, TEXT("Disk is full; aborting operation"), 0);
                            b = FALSE;
                            break;
                        }
                        continue;
                    }
                    if (g_DynUpdtStatus->PrepareWinnt32) {
                        //
                        // just rebuild the hardware database
                        //
                        if (!pBuildHwcompDat (dirName, infHandle, TRUE, TRUE)) {
                            DynUpdtDebugLog (
                                Winnt32LogError,
                                TEXT("Unable to build %1 (pBuildHwcompDat failed)"),
                                0,
                                dirName
                                );
                            continue;
                        }
                    }

                } while (EnumNextFilePatternRecursive (&er));
                AbortEnumFilePatternRecursive (&er);
            }
        }

        if (!b) {
            __leave;
        }

        if (!g_DynUpdtStatus->PrepareWinnt32 &&
            (!ISNT() || OsVersion.dwMajorVersion > 4)
            ) {
            //
            // look for driver dirs and analyze them
            //
            if (infHandle != INVALID_HANDLE_VALUE) {
                //
                // read the value of "DriversAreGuiApproved" key
                // 1. if set to "Yes" that means all drivers listed in the [Drivers] section are approved
                //    for installation in GUI setup; any other driver is not approved for installation in GUI setup
                // 2. if set to "No" all drivers listed are NOT good for installation in GUI setup; their install
                //    will be deferred post setup; any driver not listed in that section is good for GUI
                // 3. if not present or set to any other value, it is ignored and the section [Drivers] is ignored;
                //    all drivers will be installed post GUI setup
                //
                eContentType = CT_UNKNOWN;
                if (SetupapiFindFirstLine (infHandle, S_SECTION_VERSION, S_DRIVER_TYPE_KEY, &ic) &&
                    SetupapiGetStringField (&ic, 1, value, MAX_PATH, NULL)
                    ) {
                    if (!lstrcmpi (value, WINNT_A_YES)) {
                        eContentType = CT_GUI_APPROVED;
                    } else if (!lstrcmpi (value, WINNT_A_NO)) {
                        eContentType = CT_GUI_NOT_APPROVED;
                    }
                }
                if (eContentType != CT_UNKNOWN) {
                    DynUpdtDebugLog (
                        Winnt32LogInformation,
                        TEXT("Entries in section [%1] of %2 will be treated as drivers to %3 be installed during GUI setup"),
                        0,
                        S_SECTION_DRIVERS,
                        g_DynUpdtStatus->GuidrvsInfSource,
                        eContentType == CT_GUI_APPROVED ? TEXT("") : TEXT("NOT")
                        );
                } else {
                    DynUpdtDebugLog (
                        Winnt32LogWarning,
                        TEXT("Key %1 %5 in file %2 section [%3];")
                        TEXT(" entries in section [%4] will be ignored and all drivers will be installed post setup"),
                        0,
                        S_DRIVER_TYPE_KEY,
                        g_DynUpdtStatus->GuidrvsInfSource,
                        S_SECTION_VERSION,
                        S_SECTION_DRIVERS,
                        value ? TEXT("has an invalid value") : TEXT("is not present")
                        );
                }
            }

            if (EnumFirstFilePattern (&e, g_DynUpdtStatus->DriversSource, TEXT("*"))) {

                //
                // initialize the Whistler PNP database
                //
                if (!g_DynUpdtStatus->HwdbDatabase) {
                    //
                    // ignore db load error
                    //
                    pInitNtPnpDb (TRUE);
                }

                do {
                    if (g_DynUpdtStatus->Cancelled) {
                        SetLastError (ERROR_CANCELLED);
                        b = FALSE;
                        break;
                    }

                    if (!(e.FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                        DynUpdtDebugLog (DynUpdtLogLevel, TEXT("File %1 is NOT a directory and will be ignored"), 0, e.FullPath);
                        continue;
                    }

                    //
                    // is this a needed driver?
                    //
                    bDriverNeeded = TRUE;
                    if (g_DynUpdtStatus->UserSpecifiedUpdates) {
                        //
                        // first build the list of missing drivers
                        //
                        if (!missingPnpIds) {
#ifdef UNICODE
                            missingPnpIds = BuildMissingPnpIdList ();
                            if (!missingPnpIds) {
                                DynUpdtDebugLog (
                                    Winnt32LogInformation,
                                    TEXT("No PNP device drivers are needed"),
                                    0
                                    );
                            }
#else
                            //
                            // let the upgrade module do driver detection on Win9x
                            //
                            if (pLoadWin9xDuSupport ()) {
                                PSTR* incompWin9xDrivers;
                                PCSTR* q;
                                if (g_DynUpdtStatus->Win9xGetIncompDrvs (&incompWin9xDrivers)) {
                                    //
                                    // convert the array returned by this function to a list style
                                    //
                                    g_DynUpdtStatus->IncompatibleDriversCount = 0;
                                    if (incompWin9xDrivers) {
                                        for (q = incompWin9xDrivers; *q; q++) {
                                            listEntry = (PSTRINGLIST) MALLOC (sizeof (STRINGLIST));
                                            if (listEntry) {
                                                listEntry->String = DupMultiSz (*q);
                                                if (!listEntry->String) {
                                                    break;
                                                }
                                                listEntry->Next = NULL;
                                                if (!InsertList ((PGENERIC_LIST*)&missingPnpIds, (PGENERIC_LIST)listEntry)) {
                                                    DeleteStringCell (listEntry);
                                                    break;
                                                }
                                                g_DynUpdtStatus->IncompatibleDriversCount++;
                                            }
                                        }
                                    }
                                    if (g_DynUpdtStatus->Win9xReleaseIncompDrvs) {
                                        g_DynUpdtStatus->Win9xReleaseIncompDrvs (incompWin9xDrivers);
                                    }
                                } else {
                                    DynUpdtDebugLog (
                                        DynUpdtLogLevel,
                                        TEXT("Win9xGetIncompDrvs returned FALSE; no drivers will be analyzed"),
                                        0
                                        );
                                }
                            }
#endif
                            if (!missingPnpIds) {
                                break;
                            }
                        }

                        bCreateHwdb = FALSE;
                        //
                        // use the existing hardware database
                        //
                        BuildPath (datFile, e.FullPath, S_HWCOMP_DAT);
                        if (!pDoesFileExist (datFile)) {
                            bCreateHwdb = TRUE;
                        }
                        hDB = g_DynUpdtStatus->HwdbOpen (bCreateHwdb ? NULL : datFile);
                        if (!hDB) {
                            if (bCreateHwdb) {
                                b = FALSE;
                                break;
                            }
                            DynUpdtDebugLog (
                                Winnt32LogError,
                                TEXT("Hardware database %1 is corrupt; contact your system administrator"),
                                0,
                                datFile
                                );
                            continue;
                        }

                        if (bCreateHwdb) {
                            if (!g_DynUpdtStatus->HwdbAppendInfs (
                                    hDB,
                                    e.FullPath,
                                    infHandle != INVALID_HANDLE_VALUE ? Winnt32HwdbAppendInfsCallback : NULL,
                                    (PVOID)infHandle
                                    )) {
                                DynUpdtDebugLog (
                                    Winnt32LogError,
                                    TEXT("Unable to build %1; contact your system administrator"),
                                    0,
                                    datFile
                                    );
                                g_DynUpdtStatus->HwdbClose (hDB);
                                continue;
                            }
                            //
                            // rebuild the default HW precompiled database
                            //
                            BuildPath (datFile, e.FullPath, S_HWCOMP_DAT);
                            SetFileAttributes (datFile, FILE_ATTRIBUTE_NORMAL);
                            DeleteFile (datFile);
                            if (!g_DynUpdtStatus->HwdbFlush (hDB, datFile)) {
                                DynUpdtDebugLog (
                                    Winnt32LogError,
                                    TEXT("Unable to build %1; contact your system administrator"),
                                    0,
                                    datFile
                                    );
                                g_DynUpdtStatus->HwdbClose (hDB);
                                continue;
                            }
                            DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Successfully built precompiled hardware database %1"), 0, datFile);
                        }

                        //
                        // check if this particular driver is among the ones that are needed
                        //
                        if (!pHwdbHasAnyMissingDrivers (hDB, missingPnpIds)) {
                            //
                            // this driver is not needed
                            //
                            bDriverNeeded = FALSE;
                        }

                        g_DynUpdtStatus->HwdbClose (hDB);
                    }

                    if (!bDriverNeeded) {
                        DynUpdtDebugLog (DynUpdtLogLevel, TEXT("No needed drivers found in package %1"), 0, e.FullPath);
                        continue;
                    }

                    //
                    // is this a boot driver or a regular one?
                    //
                    if (pIsBootDriver (e.FullPath)) {
                        //
                        // add this driver to the list of boot drivers
                        //
                        if (!InsertList (
                                (PGENERIC_LIST*)&g_DynUpdtStatus->BootDriverPathList,
                                (PGENERIC_LIST)CreateStringCell (e.FileName))
                                ) {
                            b = FALSE;
                            break;
                        }
                        DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Added driver %1 to the list of BOOT drivers"), 0, e.FullPath);
                    }
                    //
                    // all needed drivers will be copied under LocalBootDir to be protected
                    // from being deleted if user decides to remove the current OS partition
                    //
                    BuildPath (relocDriverPath, IsArc() ? LocalSourceWithPlatform : LocalBootDirectory, S_SUBDIRNAME_DRIVERS);
                    ConcatenatePaths (relocDriverPath, e.FileName, MAX_PATH);

                    //
                    // is this a GUI driver or not?
                    //
                    if (eContentType == CT_UNKNOWN) {
                        bDriverIsGuiApproved = FALSE;
                    } else {
                        if (pFindValueInSectionAtFieldIndex (infHandle, S_SECTION_EXCLUDED_DRVS, GUIDRVS_FIELD_CABNAME, e.FileName)) {
                            //
                            // we don't support "partially excluded" packages for the device install
                            // phase of GUI setup
                            //
                            DynUpdtDebugLog (
                                DynUpdtLogLevel,
                                TEXT("Driver %1 is partially excluded; it will be installed at the end of GUI setup"),
                                0,
                                e.FullPath
                                );
                            bDriverIsGuiApproved = FALSE;
                        } else {
                            BOOL bPartial;
                            bEntryFound = pFindPackage (infHandle, S_SECTION_DRIVERS, e.FileName, &bPartial);
                            bDriverIsGuiApproved = eContentType == CT_GUI_APPROVED && bEntryFound && !bPartial ||
                                                   eContentType == CT_GUI_NOT_APPROVED && !bEntryFound;
                        }
                    }

                    //
                    // always make sure there's a precompiled database hwcomp.dat
                    // to be used at the time setup will install these additional drivers
                    //
                    if (!pBuildHwcompDat (e.FullPath, infHandle, FALSE, FALSE)) {
                        DynUpdtDebugLog (
                            Winnt32LogError,
                            TEXT("Unable to build %1 (pBuildHwcompDat failed)"),
                            0,
                            datFile
                            );
                        continue;
                    }

                    entry = MALLOC (sizeof (SDLIST));
                    if (!entry) {
                        b = FALSE;
                        break;
                    }
                    entry->String = DupString (relocDriverPath);
                    if (!entry->String) {
                        FREE (entry);
                        b = FALSE;
                        break;
                    }
                    entry->Data = (DWORD_PTR)bDriverIsGuiApproved;
                    entry->Next = NULL;
                    if (!InsertList (
                            (PGENERIC_LIST*)&g_DynUpdtStatus->NewDriversList,
                            (PGENERIC_LIST)entry
                            )) {
                        FREE (entry);
                        b = FALSE;
                        break;
                    }

                    DynUpdtDebugLog (
                        DynUpdtLogLevel,
                        bDriverIsGuiApproved ?
                            TEXT("Driver %1 is approved for installation during GUI setup") :
                            TEXT("Driver %1 is NOT approved for installation during GUI setup; installation will be deferred post-setup"),
                        0,
                        e.FullPath
                        );

                    //
                    // copy locally this driver package (if from a share)
                    //
                    BuildPath (relocDriverPath, g_DynUpdtStatus->SelectedDrivers, e.FileName);
                    if (lstrcmpi (e.FullPath, relocDriverPath)) {
                        if (!CopyTree (e.FullPath, relocDriverPath)) {
                            DynUpdtDebugLog (
                                Winnt32LogError,
                                TEXT("Unable to copy driver %1 to %2"),
                                0,
                                e.FullPath,
                                relocDriverPath
                                );
                            b = FALSE;
                            break;
                        }
                        DynUpdtDebugLog (
                            Winnt32LogInformation,
                            TEXT("Driver %1 successfully copied to %2"),
                            0,
                            e.FullPath,
                            relocDriverPath
                            );
                    }

                } while (EnumNextFilePattern (&e));
                AbortEnumFilePattern (&e);
            } else {
                DynUpdtDebugLog (
                    DynUpdtLogLevel,
                    TEXT("No drivers found in %1"),
                    0,
                    g_DynUpdtStatus->DriversSource
                    );
            }

            if (!b) {
                __leave;
            }

            //
            // copy guidrvs.inf if present and any driver package that will be migrated over
            //
            if (g_DynUpdtStatus->GuidrvsInfSource[0] && g_DynUpdtStatus->NewDriversList) {
                BuildPath (datFile, g_DynUpdtStatus->SelectedDrivers, S_GUI_DRIVERS_INF);
                if (lstrcmpi (g_DynUpdtStatus->GuidrvsInfSource, datFile)) {
                    if (!CopyFile (g_DynUpdtStatus->GuidrvsInfSource, datFile, FALSE)) {
                        DynUpdtDebugLog (
                            Winnt32LogError,
                            TEXT("Failed to copy %1 to %2"),
                            0,
                            g_DynUpdtStatus->GuidrvsInfSource,
                            datFile
                            );
                        b = FALSE;
                    }
                }
                if (b) {
                    //
                    // update the location of guidrvs.inf after file copy will have been done
                    //
                    BuildPath (
                        g_DynUpdtStatus->GuidrvsInfSource,
                        IsArc() ? LocalSourceWithPlatform : LocalBootDirectory,
                        S_SUBDIRNAME_DRIVERS
                        );
                    ConcatenatePaths (g_DynUpdtStatus->GuidrvsInfSource, S_GUI_DRIVERS_INF, MAX_PATH);
                }
            }
        }
    }
    __finally {
        if (missingPnpIds) {
            DeleteStringList (missingPnpIds);
        }

        if (infHandle != INVALID_HANDLE_VALUE) {
            SetupapiCloseInfFile (infHandle);
        }
    }

    return b;
}


BOOL
pProcessUpginfs (
    IN      PCTSTR UpginfsCab,
    IN      BOOL ClientInstall
    )
{
    FILEPATTERNREC_ENUM e;
    TCHAR upginfsSourceDir[MAX_PATH];
    TCHAR upginfsDir[MAX_PATH];
    TCHAR upginfsFile[MAX_PATH];
    TCHAR origSubPath[MAX_PATH];
    TCHAR origFileName[MAX_PATH];
    TCHAR origFilePath[MAX_PATH];
    TCHAR destFilePath[MAX_PATH];
    TCHAR buffer[MAX_PATH];
    PTSTR p;
    BOOL b = TRUE;

    BuildPath (upginfsSourceDir, g_DynUpdtStatus->DynamicUpdatesSource, S_SUBDIRNAME_UPGINFS);
    if (ClientInstall) {
        if (!DoesDirectoryExist (upginfsSourceDir)) {
            return TRUE;
        }
    } else {

        //
        // expand it in the corresponding subdir
        //
        if (!pNonemptyFilePresent (UpginfsCab)) {
            DynUpdtDebugLog (DynUpdtLogLevel, TEXT("Package %1 is not present"), 0, UpginfsCab);
            return TRUE;
        }

        DynUpdtDebugLog (
            DynUpdtLogLevel,
            TEXT("Analyzing package %1..."),
            0,
            UpginfsCab
            );

        //
        // expand CAB in this dir
        // make sure dir is initially empty
        //
        MyDelnode (upginfsSourceDir);
        if (CreateMultiLevelDirectory (upginfsSourceDir) != ERROR_SUCCESS) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to create dir %1"), 0, upginfsSourceDir);
            return FALSE;
        }
        if (!(*SetupapiCabinetRoutine) (UpginfsCab, 0, pExpandCabInDir, (PVOID)upginfsSourceDir)) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to expand cabinet %1"), 0, UpginfsCab);
            return FALSE;
        }

        //
        // ISSUE: the patching support is currently not available for platforms other than x86
        //
#ifdef _X86_
        //
        // now let's look for any patches
        //
        if (EnumFirstFilePatternRecursive (&e, upginfsSourceDir, S_PATCH_FILE_EXT, 0)) {

            do {
                BOOL bDeleteTempFile = FALSE;

                if (g_DynUpdtStatus->Cancelled) {
                    SetLastError (ERROR_CANCELLED);
                    b = FALSE;
                    break;
                }

                if (e.FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    continue;
                }
                DynUpdtDebugLog (
                    DynUpdtLogLevel,
                    TEXT("pProcessUpginfs: found patch %1"),
                    0,
                    e.FullPath
                    );
                //
                // get the original file from the sources location
                // the filename is obtained cutting the ._p1 extension
                //
                lstrcpy (origFileName, e.FileName);
                p = GetFileExtension (origFileName);
                if (!p) {
                    MYASSERT (FALSE);
                    continue;
                }
                *p = 0;
                lstrcpy (origSubPath, e.SubPath);
                p = GetFileExtension (origSubPath);
                if (!p) {
                    MYASSERT (FALSE);
                    continue;
                }
                *p = 0;
                BuildPath (origFilePath, NativeSourcePaths[0], origSubPath);
                //
                // now check if this file (in it's compressed form or not) actually exists
                //
                if (!pDoesFileExist (origFilePath)) {
                    //
                    // try the compressed form
                    //
                    p = _tcschr (origFilePath, 0);
                    MYASSERT (p);
                    if (!p) {
                        continue;
                    }
                    p = _tcsdec (origFilePath, p);
                    MYASSERT (p);
                    if (!p) {
                        continue;
                    }
                    *p = TEXT('_');
                    if (!pDoesFileExist (origFilePath)) {
                        DynUpdtDebugLog (
                            Winnt32LogError,
                            TEXT("pProcessUpginfs: Unable to find original file %1 to apply the patch"),
                            0,
                            origSubPath
                            );
                        b = FALSE;
                        break;
                    }
                    //
                    // expand the file to the temp dir
                    //
                    BuildPath (buffer, g_DynUpdtStatus->TempDir, origSubPath);
                    p = _tcsrchr (buffer, TEXT('\\'));
                    MYASSERT (p);
                    if (!p) {
                        continue;
                    }
                    *p = 0;
                    if (CreateMultiLevelDirectory (buffer) != ERROR_SUCCESS) {
                        DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpginfs: Unable to create dir %1"), 0, buffer);
                        b = FALSE;
                        break;
                    }
                    if (!(*SetupapiCabinetRoutine) (origFilePath, 0, pExpandCabInDir, buffer)) {
                        DynUpdtDebugLog (
                            Winnt32LogError,
                            TEXT("pProcessUpginfs: Unable to expand original file %1 to dir %2"),
                            0,
                            origFilePath,
                            buffer
                            );
                        b = FALSE;
                        break;
                    }
                    *p = TEXT('\\');
                    lstrcpy (origFilePath, buffer);
                    bDeleteTempFile = TRUE;
                }
                BuildPath (destFilePath, upginfsSourceDir, TEXT("$$temp$$.~~~"));
                //
                // now really apply the patch
                //
                if (!ApplyPatchToFile (e.FullPath, origFilePath, destFilePath, 0)) {
                    DynUpdtDebugLog (
                        Winnt32LogError,
                        TEXT("pProcessUpginfs: ApplyPatchToFile failed to apply patch %1 to file %2"),
                        0,
                        e.FullPath,
                        origFilePath
                        );
                    b = FALSE;
                    break;
                }
                //
                // success! now move the file to the real destination
                //
                BuildPath (buffer, upginfsSourceDir, origFileName);
                if (pDoesFileExist (buffer)) {
                    DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpginfs: duplicate file found %1"), 0, origFileName);
                    b = FALSE;
                    break;
                }
                //
                // all patches MUST be .rep files; change extension from .inf to .rep
                //
                p = GetFileExtension (buffer);
                if (!p || lstrcmpi (p, TEXT(".inf"))) {
                    DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpginfs: Unexpected file extension in %1"), 0, buffer);
                    b = FALSE;
                    break;
                }
                lstrcpy (p, TEXT(".rep"));

                SetFileAttributes (buffer, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (buffer);
                if (!MoveFile (destFilePath, buffer)) {
                    DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpginfs: Unable to move file %1 to final dest %2"), 0, destFilePath, buffer);
                    b = FALSE;
                    break;
                }
                DynUpdtDebugLog (
                    DynUpdtLogLevel,
                    TEXT("pProcessUpginfs: successfully applied patch %1 to file %2; the new file was renamed %3"),
                    0,
                    e.FullPath,
                    origFilePath,
                    buffer
                    );
                //
                // now remove the patch file
                //
                SetFileAttributes (e.FullPath, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (e.FullPath);
                if (bDeleteTempFile) {
                    SetFileAttributes (origFilePath, FILE_ATTRIBUTE_NORMAL);
                    DeleteFile (origFilePath);
                }
            } while (EnumNextFilePatternRecursive (&e));
            AbortEnumFilePatternRecursive (&e);

            if (!b) {
                goto exit;
            }
        }

        SetFileAttributes (UpginfsCab, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (UpginfsCab);
#endif

    }

    if (!b) {
        goto exit;
    }
    if (!g_DynUpdtStatus->PrepareWinnt32) {
        //
        // only do file installation on Win9x platforms
        //
        OSVERSIONINFO vi;
        vi.dwOSVersionInfoSize = sizeof (vi);
        GetVersionEx (&vi);
        if (vi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS) {
            DynUpdtDebugLog (
                DynUpdtLogLevel,
                TEXT("Package %1 ignored on NT platforms"),
                0,
                UpginfsCab
                );
            return TRUE;
        }

        //
        // prepare the target directory (%windir%\upginfs)
        //
        if (!MyGetWindowsDirectory (upginfsDir, MAX_PATH)) {
            return FALSE;
        }
        ConcatenatePaths (upginfsDir, S_SUBDIRNAME_UPGINFS, MAX_PATH);
        if (!CreateDir (upginfsDir)) {
            return FALSE;
        }

        //
        // copy relevant files to %windir%\Upginfs
        //
        if (EnumFirstFilePatternRecursive (&e, upginfsSourceDir, TEXT("*.add"), 0)) {
            do {
                if (g_DynUpdtStatus->Cancelled) {
                    SetLastError (ERROR_CANCELLED);
                    b = FALSE;
                    break;
                }

                if (e.FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    continue;
                }
                if (!e.FindData->nFileSizeLow) {
                    DynUpdtDebugLog (Winnt32LogWarning, TEXT("File %1 has size 0 and will be ignored"), 0, e.FullPath);
                    continue;
                }

                BuildPath (upginfsFile, upginfsDir, e.FileName);
                SetFileAttributes (upginfsFile, FILE_ATTRIBUTE_NORMAL);
                if (!CopyFile (e.FullPath, upginfsFile, FALSE)) {
                    DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpginfs: Error copying %1 to %2"), 0, e.FullPath, upginfsFile);
                    b = FALSE;
                    break;
                }
                //
                // let w95upg.dll know about the new files
                //
                UpginfsUpdated = TRUE;
                DynUpdtDebugLog (DynUpdtLogLevel, TEXT("pProcessUpginfs: INF %1 successfully copied to %2"), 0, e.FullPath, upginfsFile);
            } while (EnumNextFilePatternRecursive (&e));
            AbortEnumFilePatternRecursive (&e);
        }

        if (b) {
            if (EnumFirstFilePatternRecursive (&e, upginfsSourceDir, TEXT("*.rep"), 0)) {
                do {
                    if (g_DynUpdtStatus->Cancelled) {
                        SetLastError (ERROR_CANCELLED);
                        b = FALSE;
                        break;
                    }

                    if (e.FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                        continue;
                    }
                    if (!e.FindData->nFileSizeLow) {
                        DynUpdtDebugLog (Winnt32LogWarning, TEXT("File %1 has size 0 and will be ignored"), 0, e.FullPath);
                        continue;
                    }

                    BuildPath (upginfsFile, upginfsDir, e.FileName);
                    SetFileAttributes (upginfsFile, FILE_ATTRIBUTE_NORMAL);
                    if (!CopyFile (e.FullPath, upginfsFile, FALSE)) {
                        DynUpdtDebugLog (Winnt32LogError, TEXT("pProcessUpginfs: Error copying %1 to %2"), 0, e.FullPath, upginfsFile);
                        b = FALSE;
                        break;
                    }
                    //
                    // let w95upg.dll know about the new files
                    //
                    UpginfsUpdated = TRUE;
                    DynUpdtDebugLog (DynUpdtLogLevel, TEXT("pProcessUpginfs: INF %1 successfully copied to %2"), 0, e.FullPath, upginfsFile);
                } while (EnumNextFilePatternRecursive (&e));
                AbortEnumFilePatternRecursive (&e);
            }
        }
    }

exit:

    return b;
}


#ifdef _X86_

BOOL
pProcessMigdlls (
    IN      PCTSTR MigdllsCab,
    IN      BOOL ClientInstall
    )
{
    FILEPATTERN_ENUM e;
    TCHAR migdllsLocalDir[MAX_PATH];
    TCHAR dirName[MAX_PATH];
    DWORD rc;
    HKEY key;
    PCTSTR strMigdllsRegKey;
    BOOL migdlls = FALSE;
    BOOL b = TRUE;

    if (!pNonemptyFilePresent (MigdllsCab)) {
        return TRUE;
    }

    if (g_DynUpdtStatus->PrepareWinnt32) {
        DynUpdtDebugLog (DynUpdtLogLevel, TEXT("pProcessMigdlls: Skipping it due to /%1 switch"), 0, WINNT_U_DYNAMICUPDATESPREPARE);
        return TRUE;
    }

    DynUpdtDebugLog (
        DynUpdtLogLevel,
        TEXT("Analyzing package %1..."),
        0,
        MigdllsCab
        );

    BuildPath (migdllsLocalDir, g_DynUpdtStatus->WorkingDir, S_SUBDIRNAME_MIGDLLS);

    //
    // expand CAB in this dir
    //
    MyDelnode (migdllsLocalDir);
    if (CreateMultiLevelDirectory (migdllsLocalDir) != ERROR_SUCCESS) {
        DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to create dir %1"), 0, migdllsLocalDir);
        return FALSE;
    }
    if (!(*SetupapiCabinetRoutine) (MigdllsCab, 0, pExpandCabInDir, (PVOID)migdllsLocalDir)) {
        DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to expand cabinet %1"), 0, MigdllsCab);
        return FALSE;
    }

    //
    // look for CAB files and expand each one in its own subdir
    //
    if (EnumFirstFilePattern (&e, migdllsLocalDir, TEXT("*.cab"))) {
        do {
            if (g_DynUpdtStatus->Cancelled) {
                SetLastError (ERROR_CANCELLED);
                b = FALSE;
                break;
            }

            if (e.FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                continue;
            }
            if (!e.FindData.nFileSizeLow) {
                DynUpdtDebugLog (Winnt32LogWarning, TEXT("File %1 has size 0 and will be ignored"), 0, e.FullPath);
                continue;
            }

            pGetAutoSubdirName (e.FullPath, dirName);
            if (CreateMultiLevelDirectory (dirName) != ERROR_SUCCESS) {
                DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to create dir %1; skipping it"), 0, dirName);
                continue;
            }
            //
            // expand CAB in this dir
            //
            if (!(*SetupapiCabinetRoutine) (e.FullPath, 0, pExpandCabInDir, (PVOID)dirName)) {
                DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to expand cabinet %1; skipping it"), 0, e.FullPath);
                continue;
            }

            migdlls = TRUE;

        } while (EnumNextFilePattern (&e));
    }

    if (b && migdlls) {
        //
        // register them
        //
        strMigdllsRegKey = ISNT () ? S_REGKEY_MIGRATION_DLLS_WINNT : S_REGKEY_MIGRATION_DLLS_WIN9X;
        rc = RegCreateKey (HKEY_LOCAL_MACHINE, strMigdllsRegKey, &key);
        if (rc == ERROR_SUCCESS) {
            rc = RegSetValueEx (key, S_REGVALUE_DYNUPDT, 0, REG_SZ, (CONST BYTE*)migdllsLocalDir, (lstrlen (migdllsLocalDir) + 1) * sizeof (TCHAR));
        }
        if (rc != ERROR_SUCCESS) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("Unable to register downloaded migdlls (rc=%1!u!)"), 0, rc);
            b = FALSE;
        }
    }

    return b;
}

#endif


BOOL
ProcessDownloadedFiles (
    OUT     PBOOL StopSetup
    )
{
    TCHAR cabName[MAX_PATH];
    BOOL bClientInstall = FALSE;

    if (g_DynUpdtStatus->UserSpecifiedUpdates && !g_DynUpdtStatus->PrepareWinnt32) {
        bClientInstall = TRUE;
    }

    DynUpdtDebugLog (
        DynUpdtLogLevel,
        TEXT("Source=%1"),
        0,
        g_DynUpdtStatus->UserSpecifiedUpdates ? g_DynUpdtStatus->DynamicUpdatesSource : TEXT("Windows Update")
        );

    if (!g_DynUpdtStatus->HwdbInitialize) {
        if (CreateMultiLevelDirectory (g_DynUpdtStatus->TempDir) != ERROR_SUCCESS ||
            !pInitializeSupport (S_HWDB_DLL, pLoadHwdbLib, FALSE) ||
            !g_DynUpdtStatus->HwdbInitialize (g_DynUpdtStatus->TempDir)
            ) {
            return FALSE;
        }
    }

    if (!Winnt32Restarted ()) {
        BuildPath (cabName, g_DynUpdtStatus->DynamicUpdatesSource, S_CABNAME_WINNT32);
        if (!pProcessWinnt32Files (cabName, bClientInstall, StopSetup)) {
            return FALSE;
        }
        if (g_DynUpdtStatus->RestartWinnt32) {
            MYASSERT (!g_DynUpdtStatus->PrepareWinnt32);
            return TRUE;
        }
    }

    BuildPath (cabName, g_DynUpdtStatus->DynamicUpdatesSource, S_CABNAME_UPDATES);
    if (!pProcessUpdates (cabName, bClientInstall, StopSetup)) {
        if (g_DynUpdtStatus->PrepareWinnt32) {
            MessageBoxFromMessage (
                g_DynUpdtStatus->ProgressWindow,
                MSG_ERROR_PROCESSING_UPDATES,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                GetLastError (),
                cabName
                );
        }

        return FALSE;
    }

    //
    // process New Assemblies on WU
    //
    BuildPath (cabName, g_DynUpdtStatus->DynamicUpdatesSource, S_CABNAME_DUASMS);
    if (!pProcessDuasms (cabName, bClientInstall)) {
        //
        // don't fail DU if we didn't install them
        //
    }

    BuildPath (cabName, g_DynUpdtStatus->DynamicUpdatesSource, S_CABNAME_UPGINFS);
    if (!pProcessUpginfs (cabName, bClientInstall)) {
        return FALSE;
    }

#ifdef _X86_

    BuildPath (cabName, g_DynUpdtStatus->DynamicUpdatesSource, S_CABNAME_MIGDLLS);
    if (!pProcessMigdlls (cabName, bClientInstall)) {
        return FALSE;
    }

#endif

    if (!pProcessNewdrvs (g_DynUpdtStatus->DynamicUpdatesSource, bClientInstall)) {
        return FALSE;
    }

    return TRUE;
}


BOOL
Winnt32Restarted (
    VOID
    )
{
    return g_DynUpdtStatus->Winnt32Restarted;
}

BOOL
Winnt32RestartedWithAF (
    VOID
    )
{
    return g_DynUpdtStatus->RestartAnswerFile[0];
}

VOID
pLogWininetError (
    IN      DWORD Error
    )
{
    HMODULE hWinInet = LoadLibrary (TEXT("wininet.dll"));
    if (hWinInet) {
        HLOCAL msg = NULL;
        FormatMessage (
                FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                hWinInet,
                Error,
                0,
                (LPTSTR)&msg,
                0,
                NULL
                );
        if (msg) {
            DynUpdtDebugLog (Winnt32LogError, TEXT("Failure with wininet error code %1!u!: \"%2\""), 0, Error, msg);
            LocalFree (msg);
        }
        FreeLibrary (hWinInet);
    }
}

VOID
pLogStandardError (
    IN      DWORD Error
    )
{
    HLOCAL msg = NULL;
    FormatMessage (
            FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_ALLOCATE_BUFFER,
            NULL,
            Error,
            0,
            (LPTSTR)&msg,
            0,
            NULL
            );
    if (msg) {
        DynUpdtDebugLog (Winnt32LogError, TEXT("Failure with standard error code %1!u!:\r\n%2"), 0, Error, msg);
        LocalFree (msg);
    }
}

VOID
pUpdateDUStatus (
    IN      DWORD Error
    )
{
    MYASSERT (Error != ERROR_SUCCESS);
    if (Error == ERROR_SUCCESS) {
        g_DynUpdtStatus->DUStatus = DUS_ERROR;
        return;
    }
    switch (Error) {
    case ERROR_CONNECTION_UNAVAIL:
        //
        // ask for manual connection
        //
        MYASSERT (g_DynUpdtStatus->DUStatus == DUS_PREPARING);
        g_DynUpdtStatus->DUStatus = DUS_PREPARING_CONNECTIONUNAVAILABLE;
        break;
    case ERROR_INTERNET_INVALID_URL:
    case ERROR_INTERNET_NAME_NOT_RESOLVED:
        //
        // site not available; ask user if they want to retry
        //
        MYASSERT (g_DynUpdtStatus->DUStatus == DUS_PREPARING);
        g_DynUpdtStatus->DUStatus = DUS_PREPARING_INVALIDURL;
        break;
    case ERROR_INVALID_PARAMETER:
    case ERROR_NOT_ENOUGH_MEMORY:
    case ERROR_OLD_WIN_VERSION:
    case ERROR_OUTOFMEMORY:
    case ERROR_NO_MORE_ITEMS:
    case ERROR_FILE_NOT_FOUND:
    case ERROR_INVALID_DATA:
    case ERROR_UNSUPPORTED_TYPE:
    case ERROR_INVALID_HANDLE:
        pLogStandardError (Error);
        g_DynUpdtStatus->DUStatus = DUS_ERROR;
        break;
    case DU_ERROR_MISSING_DLL:
    case DU_NOT_INITIALIZED:
        DynUpdtDebugLog (Winnt32LogError, TEXT("Failure with custom error code %1!u!"), 0, Error);
        g_DynUpdtStatus->DUStatus = DUS_ERROR;
        break;
    case ERROR_INTERNET_NO_CONTEXT:
        pLogWininetError (Error);
        g_DynUpdtStatus->DUStatus = DUS_ERROR;
        break;
    default:
        if (Error > INTERNET_ERROR_BASE) {
            pLogWininetError (Error);
        } else {
            pLogStandardError (Error);
        }
    }
}

DWORD
WINAPI
DoDynamicUpdate (
    LPVOID Parameter
    )
{

#define MIN_INTERVAL_BETWEEN_TASKS 3000

    HWND hUIWindow = (HWND)Parameter;
    DWORD rc = ERROR_SUCCESS;
    LONG ticks;
    LONG sleep;
    DWORD estTime, estSize;
    TCHAR drive[4];
    DWORD sectorsPerCluster;
    DWORD bytesPerSector;
    ULARGE_INTEGER freeClusters = {0, 0};
    ULARGE_INTEGER totalClusters = {0, 0};
    DWORD clusterSize;
    ULONGLONG availableBytes;
    HANDLE hEvent;
    BOOL bStopSetup;
    BOOL bContinue = TRUE;

    hEvent = OpenEvent (EVENT_ALL_ACCESS, FALSE, S_DU_SYNC_EVENT_NAME);
    if (!hEvent) {
        DynUpdtDebugLog (
            Winnt32LogError,
            TEXT("OpenEvent(%1) failed"),
            0,
            S_DU_SYNC_EVENT_NAME
            );
        g_DynUpdtStatus->DUStatus = DUS_ERROR;
        goto exit;
    }

    while (bContinue) {

        if (g_DynUpdtStatus->Cancelled) {
            g_DynUpdtStatus->DUStatus = DUS_CANCELLED;
            rc = ERROR_CANCELLED;
            DynamicUpdateUninitialize ();
            break;
        }

        switch (g_DynUpdtStatus->DUStatus) {

        case DUS_INITIAL:
            if (Winnt32Restarted () || g_DynUpdtStatus->UserSpecifiedUpdates) {
                g_DynUpdtStatus->DUStatus = DUS_PROCESSING;
                break;
            }
            g_DynUpdtStatus->DUStatus = DUS_PREPARING;
            SendMessage (hUIWindow, WMX_SETUPUPDATE_PREPARING, 0, 0);
            break;

        case DUS_PREPARING:
            ticks = GetTickCount ();
            if (!DynamicUpdateInitDownload (hUIWindow)) {
                DynUpdtDebugLog (
                    Winnt32LogError,
                    TEXT("DynamicUpdateInitDownload failed"),
                    0
                    );
                pUpdateDUStatus (GetLastError ());
                if (g_DynUpdtStatus->DUStatus != DUS_SKIP &&
                    g_DynUpdtStatus->DUStatus != DUS_ERROR) {
                    //
                    // the UI thread will decide what the next state will be
                    // based on user's selection
                    //
                    PostMessage (hUIWindow, WMX_SETUPUPDATE_INIT_RETRY, 0, 0);
                    rc = WaitForSingleObject (hEvent, INFINITE);
                    if (rc != WAIT_OBJECT_0) {
                        DynUpdtDebugLog (
                            Winnt32LogError,
                            TEXT("WaitForSingleObject failed (%1!u!)"),
                            0,
                            rc
                            );
                        g_DynUpdtStatus->DUStatus = DUS_ERROR;
                        break;
                    }
                }
                break;
            }
            sleep = ticks + MIN_INTERVAL_BETWEEN_TASKS - (LONG)GetTickCount ();
            if (sleep > 0 && sleep <= MIN_INTERVAL_BETWEEN_TASKS) {
                Sleep (sleep);
            }
            g_DynUpdtStatus->DUStatus = DUS_DOWNLOADING;
            break;

        case DUS_DOWNLOADING:
            ticks = GetTickCount ();
            estSize = estTime = 0;
            if (!DynamicUpdateStart (&estTime, &estSize)) {
                g_DynUpdtStatus->DUStatus = DUS_ERROR;
                break;
            }
            //
            // check if there is enough disk space available for this operation
            //
            lstrcpyn (drive, g_DynUpdtStatus->WorkingDir, 3);
            if (GetDiskFreeSpaceNew (
                    drive,
                    &sectorsPerCluster,
                    &bytesPerSector,
                    &freeClusters,
                    &totalClusters
                    )) {
                clusterSize = bytesPerSector * sectorsPerCluster;
                availableBytes = (ULONGLONG)clusterSize * freeClusters.QuadPart;
                //
                // assume the average-worst case where each file occupies 1/2 cluster
                // then the space required is the double of estimated space
                //
                if (availableBytes < (ULONGLONG)estSize * 2) {
                    DynUpdtDebugLog (
                        Winnt32LogError,
                        TEXT("DoDynamicUpdate: not enough free space on drive %1 to perform download (available=%2!u! MB, needed=%3!u! MB)"),
                        0,
                        drive,
                        (DWORD)(availableBytes >> 20),
                        (DWORD)(estSize >> 20)
                        );
                    g_DynUpdtStatus->DUStatus = DUS_ERROR;
                    DynamicUpdateCancel ();
                    //
                    // wait for the UI thread to signal the event, no more than about a minute
                    //
                    rc = WaitForSingleObject (hEvent, 66000);
                    if (rc == WAIT_TIMEOUT) {
                        //
                        // why?
                        //
                        MYASSERT (FALSE);
                    } else if (rc != WAIT_OBJECT_0) {
                        DynUpdtDebugLog (
                            Winnt32LogError,
                            TEXT("WaitForSingleObject failed (%1!u!)"),
                            0,
                            rc
                            );
                    }
                    break;
                }
            }

            SendMessage (hUIWindow, WMX_SETUPUPDATE_DOWNLOADING, estTime, estSize);

            rc = WaitForSingleObject (hEvent, INFINITE);
            if (rc != WAIT_OBJECT_0) {
                DynUpdtDebugLog (
                    Winnt32LogError,
                    TEXT("WaitForSingleObject failed (%1!u!)"),
                    0,
                    rc
                    );
                g_DynUpdtStatus->DUStatus = DUS_ERROR;
                break;
            }
            sleep = ticks + MIN_INTERVAL_BETWEEN_TASKS - (LONG)GetTickCount ();
            if (sleep > 0 && sleep <= MIN_INTERVAL_BETWEEN_TASKS) {
                Sleep (sleep);
            }
            //
            // the UI thread has already set the next state,
            // based on the result of download
            //
            break;

        case DUS_PROCESSING:
            ticks = GetTickCount ();
            SendMessage (hUIWindow, WMX_SETUPUPDATE_PROCESSING, 0, 0);
            if (!g_DynUpdtStatus->UserSpecifiedUpdates) {
                lstrcpy (g_DynUpdtStatus->DynamicUpdatesSource, g_DynUpdtStatus->WorkingDir);
            }
            bStopSetup = FALSE;
            if (!DynamicUpdateProcessFiles (&bStopSetup)) {
                g_DynUpdtStatus->DUStatus = bStopSetup ? DUS_FATALERROR : DUS_ERROR;
                break;
            }
            sleep = ticks + MIN_INTERVAL_BETWEEN_TASKS - (LONG)GetTickCount ();
            if (sleep > 0 && sleep <= MIN_INTERVAL_BETWEEN_TASKS) {
                Sleep (sleep);
            }
            g_DynUpdtStatus->DUStatus = DUS_SUCCESSFUL;
            break;

        case DUS_SUCCESSFUL:
            if (CheckUpgradeOnly && !g_DynUpdtStatus->RestartWinnt32 && !g_DynUpdtStatus->UserSpecifiedUpdates) {
                if (pSaveLastDownloadInfo ()) {
                    g_DynUpdtStatus->PreserveWorkingDir = TRUE;
                }
            }
            //
            // fall through
            //
        case DUS_ERROR:
        case DUS_FATALERROR:
        case DUS_SKIP:
            //
            // always make sure to uninitialize DU
            // if the user had a modem connection active, this should close
            // the connection
            // DynamicUpdateUninitialize () will not reset any DU data
            // in case the processing was successful
            //
            DynamicUpdateUninitialize ();
            bContinue = FALSE;
            break;

        default:
            MYASSERT (FALSE);
        }
    }

    CloseHandle (hEvent);

exit:
    //
    // always notify the UI thread before exiting
    //
    PostMessage (hUIWindow, WMX_SETUPUPDATE_THREAD_DONE, 0, 0);
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\helpids.h ===
#define IDH_USAGE                   400
#define IDH_MAKELOCALSOURCEFROMCD   401
#define IDH_USEFLOPPIES             402
#define IDH_SYSPARTDRIVE            403
#define IDH_CHOOSE_INSTALLPART      404
#define IDH_INSTALL_DIR             405
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\eula.c ===
#include "precomp.h"
#pragma hdrstop

#include <spidgen.h>
#include <pencrypt.h>
#include "digpid.h"


#define SETUP_TYPE_BUFFER_LEN                8
#define MAX_PID30_SITE                       3
#define MAX_PID30_RPC                        5

TCHAR Pid30Rpc[7] = TEXT("00000");
TCHAR Pid30Site[4];

LONG SourceInstallType = RetailInstall;
BOOL EulaComplete = TRUE;

#ifdef PRERELEASE
BOOL NoPid = FALSE;
#endif

//
// global variable used for subclassing.
//
WNDPROC OldPidEditProc[5];
WNDPROC OldEulaEditProc;

static BOOL PidMatchesMedia;

BOOL
ValidatePid30(
    LPTSTR Edit1,
    LPTSTR Edit2,
    LPTSTR Edit3,
    LPTSTR Edit4,
    LPTSTR Edit5
    );

void GetPID();

VOID ShowPidBox();

VOID
GetSourceInstallType(
    OUT OPTIONAL LPDWORD InstallVariation
    )
/*++

Routine Description:

    Determines the installation type (by looking in setupp.ini in the source directory)

Arguments:

    Installvaration - one of the install variations defined in compliance.h

Returns:

    none.  sets SourceInstallType global variable.

--*/
{
    TCHAR TypeBuffer[256];
    TCHAR FilePath[MAX_PATH];
    DWORD    InstallVar = COMPLIANCE_INSTALLVAR_UNKNOWN;
    TCHAR    MPCode[6] = { -1 };

    //
    // SourcePaths is guaranteed to be valid at this point, so just use it
    //
    lstrcpy(FilePath,NativeSourcePaths[0]);

    ConcatenatePaths (FilePath, SETUPP_INI, MAX_PATH );

    GetPrivateProfileString(PID_SECTION,
                            PID_KEY,
                            TEXT(""),
                            TypeBuffer,
                            sizeof(TypeBuffer)/sizeof(TCHAR),
                            FilePath);

    if (lstrlen(TypeBuffer)==SETUP_TYPE_BUFFER_LEN) {
        if (lstrcmp(&TypeBuffer[5], OEM_INSTALL_RPC) ==  0) {
            SourceInstallType = OEMInstall;
            InstallVar = COMPLIANCE_INSTALLVAR_OEM;
        } else if (lstrcmp(&TypeBuffer[5], SELECT_INSTALL_RPC) == 0) {
            SourceInstallType = SelectInstall;
            InstallVar = COMPLIANCE_INSTALLVAR_SELECT;
            // Since Select also requires a PID, don't zero the PID and call.
/*	        // get/set the pid.
	        {
	            TCHAR Temp[5][ MAX_PID30_EDIT + 1 ];
                Temp[0][0] = TEXT('\0');
	            ValidatePid30(Temp[0],Temp[1],Temp[2],Temp[3],Temp[4]);
	        }*/
        } else if (lstrcmp(&TypeBuffer[5], MSDN_INSTALL_RPC) == 0) {
            SourceInstallType = RetailInstall;
            InstallVar = COMPLIANCE_INSTALLVAR_MSDN;         
        } else {
            // defaulting
            SourceInstallType = RetailInstall;
            InstallVar = COMPLIANCE_INSTALLVAR_CDRETAIL;
        }

        lstrcpy(Pid30Site,&TypeBuffer[5]);
        lstrcpyn(Pid30Rpc, TypeBuffer, 6 );
        Pid30Rpc[MAX_PID30_RPC] = (TCHAR)0;
    } else {
        //
        // the retail install doesn't have an RPC code in the PID, so it's shorter in length
        //
        SourceInstallType = RetailInstall;
        InstallVar = COMPLIANCE_INSTALLVAR_CDRETAIL;
    }

    if (lstrlen(TypeBuffer) >= 5) {
        lstrcpyn(MPCode, TypeBuffer, 6);

        if (lstrcmp(MPCode, EVAL_MPC) == 0) {
            InstallVar = COMPLIANCE_INSTALLVAR_EVAL;
        } else if ((lstrcmp(MPCode, SRV_NFR_MPC) == 0) ||
                (lstrcmp(MPCode, ASRV_NFR_MPC) == 0)) {
            InstallVar = COMPLIANCE_INSTALLVAR_NFR;
        }
    }


    if (InstallVariation){
        *InstallVariation = InstallVar;
    }

}

BOOL
SetPid30(
    HWND hdlg,
    LONG ExpectedPidType,
    LPTSTR pProductId
    )
/*++

Routine Description:

    sets the pid in the wizard page to the data specified in the answer file.

Arguments:

    hdlg - window handle to pid dialog
    ExpectedPidType - InstallType enum identifying what sort of pid we're looking for.
    pProductId - string passed in from unattend file

Returns:

    true on successfully setting the data, false means the data was missing or invalid.
     may set some the dialog text in the specified dialog

--*/
{
   TCHAR *ptr;
   TCHAR Temp[5][ MAX_PID30_EDIT + 1 ];
   UINT i;


   //
   // make sure we were provided with a product ID
   //
   if (!pProductId || !*pProductId) {
      return(FALSE);
   }

   if ( (ExpectedPidType != RetailInstall) &&
        (ExpectedPidType != OEMInstall) &&
        (ExpectedPidType != SelectInstall)
        ){
       return(FALSE);
   }

   //
   // OEM and cd retail are the same case
   // Check that the string specified on the unattended script file
   // represents a valid 25 digit product id:
   //
   //      1 2 3 4 5 - 1 2 3 4 5 - 1 2 3 4 5 - 1 2 3 4 5 - 1 2 3 4 5
   //      0 1 2 3 4 5 6 7 8 9 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2
   //                          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8
   //
   // As a first validation test, we verify that the length is correct,
   // then we check if the "-" characters are in the correct place
   //
   //
   if(   ( lstrlen( pProductId ) !=  (4+ MAX_PID30_EDIT*5)) ||
         ( pProductId[5]  != (TCHAR)TEXT('-') ) ||
         ( pProductId[11] != (TCHAR)TEXT('-') ) ||
         ( pProductId[17] != (TCHAR)TEXT('-') ) ||
         ( pProductId[23] != (TCHAR)TEXT('-') )
     ) {
         //
         // The Pid in the unattended script file is invalid.
         //
         return(FALSE);
   }


   for (i = 0;i<5;i++) {
       //
       // quintet i
       //
       ptr = &pProductId[i*(MAX_PID30_EDIT+1)];
       lstrcpyn(Temp[i], ptr, MAX_PID30_EDIT+1 );
       Temp[i][MAX_PID30_EDIT] = (TCHAR)'\0';

   }

   //
   // check with pid30 to make sure it's valid
   //
   if (!ValidatePid30(Temp[0],Temp[1],Temp[2],Temp[3],Temp[4])) {
       return(FALSE);
   }

   //
   // all of the specified pid items are valid, set the dialog text and return.
   //
   SetDlgItemText( hdlg,IDT_EDIT_PID1, Temp[0] );
   SetDlgItemText( hdlg,IDT_EDIT_PID2, Temp[1] );
   SetDlgItemText( hdlg,IDT_EDIT_PID3, Temp[2] );
   SetDlgItemText( hdlg,IDT_EDIT_PID4, Temp[3] );
   SetDlgItemText( hdlg,IDT_EDIT_PID5, Temp[4] );

   return(TRUE);

}



BOOL
pGetCdKey (
    OUT     PBYTE CdKey
    )
{
    DIGITALPID dpid;
    DWORD type;
    DWORD rc;
    HKEY key;
    DWORD size = sizeof (dpid);
    BOOL b = FALSE;

    rc = RegOpenKey (HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"), &key);
    if (rc == ERROR_SUCCESS) {
        rc = RegQueryValueEx (key, TEXT("DigitalProductId"), NULL, &type, (LPBYTE)&dpid, &size);
        if (rc == ERROR_SUCCESS && type == REG_BINARY) {
            CopyMemory (CdKey, &dpid.abCdKey, sizeof (dpid.abCdKey));
            b = TRUE;
        }

        RegCloseKey (key);
    }

    return b;
}

const unsigned int iBase = 24;

//
//	obtained from Jim Harkins 11/27/2000
//
void EncodePid3g(
    TCHAR *pchCDKey3Chars,   // [OUT] pointer to 29+1 character Secure Product key
    LPBYTE pbCDKey3)        // [IN] pointer to 15-byte binary Secure Product Key
{
    // Given the binary PID 3.0 we need to encode
    // it into ASCII characters.  We're only allowed to
    // use 24 characters so we need to do a base 2 to
    // base 24 conversion.  It's just like any other
    // base conversion execpt the numbers are bigger
    // so we have to do the long division ourselves.

    const TCHAR achDigits[] = TEXT("BCDFGHJKMPQRTVWXY2346789");
    int iCDKey3Chars = 29;
    int cGroup = 0;

    pchCDKey3Chars[iCDKey3Chars--] = TEXT('\0');

    while (0 <= iCDKey3Chars)
    {
        unsigned int i = 0;    // accumulator
        int iCDKey3;

        for (iCDKey3 = 15-1; 0 <= iCDKey3; --iCDKey3)
        {
            i = (i * 256) + pbCDKey3[iCDKey3];
            pbCDKey3[iCDKey3] = (BYTE)(i / iBase);
            i %= iBase;
        }

        // i now contains the remainder, which is the current digit
        pchCDKey3Chars[iCDKey3Chars--] = achDigits[i];

        // add '-' between groups of 5 chars
        if (++cGroup % 5 == 0 && iCDKey3Chars > 0)
        {
	        pchCDKey3Chars[iCDKey3Chars--] = TEXT('-');
        }
    }

    return;
}


LRESULT
CALLBACK
PidEditSubProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Edit control subclass routine, sets the focus to the correct edit box when the user enters text.
    This routine assumes that the pid controls ids are in sequential order.

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/

{
    DWORD len, id;

    //
    // eat spaces
    //
    if ((msg == WM_CHAR) && (wParam == VK_SPACE)) {
        return(0);
    }

    if ((msg == WM_CHAR)) {
        //
        // First override: if we have the max characters in the current edit
        // box, let's post the character to the next box and set focus to that
        // control.
        //
        if ( ( (len = (DWORD)SendMessage(hwnd, WM_GETTEXTLENGTH, 0, 0)) == MAX_PID30_EDIT) &&
             ((wParam != VK_DELETE) && (wParam != VK_BACK)) ) {
            //
            // set the focus to the next edit control and post the character
            // to that edit control
            //
            if ((id = GetDlgCtrlID(hwnd)) < IDT_EDIT_PID5 ) {
                DWORD start, end;
                SendMessage(hwnd, EM_GETSEL, (WPARAM)&start,(LPARAM)&end);
                if (start == end) {
                    HWND hNext = GetDlgItem(GetParent(hwnd),id+1);
                    SetFocus(hNext);
                    SendMessage(hNext, EM_SETSEL, (WPARAM)-1,(LPARAM)-1);
                    PostMessage( GetDlgItem(GetParent(hwnd),id+1), WM_CHAR, wParam, lParam );
                    return(0);
                }
                
            }
        //
        // Second override: if the user hit's a delete key and they are at the
        // the start of an edit box, then post the delete to the previous edit
        // box.
        //
        } else if ( (len == 0) &&
                    ((id = GetDlgCtrlID(hwnd)) > IDT_EDIT_PID1) &&
                    ((wParam == VK_DELETE) || (wParam == VK_BACK) )) {
            //
            // set the focus to the previous edit control and post the command
            // to that edit control
            //
            HWND hPrev = GetDlgItem(GetParent(hwnd),id-1);
            SetFocus(hPrev);
            SendMessage(hPrev, EM_SETSEL, (WPARAM)MAX_PID30_EDIT-1,(LPARAM)MAX_PID30_EDIT);
            PostMessage( hPrev, WM_CHAR, wParam, lParam );
            return(0);
        //
        // Third override: if posting this message will give us the maximum
        // characters in our in the current edit box, let's post the character
        // to the next box and set focus to that control.
        //
        } else if (   (len == MAX_PID30_EDIT-1) &&
                      ((wParam != VK_DELETE) && (wParam != VK_BACK)) &&
                      ((id = GetDlgCtrlID(hwnd)) < IDT_EDIT_PID5) ) {
            DWORD start, end;
            SendMessage(hwnd, EM_GETSEL, (WPARAM)&start,(LPARAM)&end);
            if (start == end) {
                HWND hNext = GetDlgItem(GetParent(hwnd),id+1);
                //
                // post the message to the edit box
                //
                CallWindowProc(OldPidEditProc[GetDlgCtrlID(hwnd)-IDT_EDIT_PID1],hwnd,msg,wParam,lParam);
                //
                // now set the focus to the next edit control
                //
                SetFocus(hNext);
                SendMessage(hNext, EM_SETSEL, (WPARAM)-1,(LPARAM)-1);
                return(0);            
            }
        }
        
    }

    return(CallWindowProc(OldPidEditProc[GetDlgCtrlID(hwnd)-IDT_EDIT_PID1],hwnd,msg,wParam,lParam));
}

LRESULT
CALLBACK
EulaEditSubProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Edit control subclass routine, to avoid highlighting text when user
    tabs to the edit control.

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/

{
    static BOOL firstTime = TRUE;
    //
    // For setsel messages, make start and end the same.
    //
    if((msg == EM_SETSEL) && ((LPARAM)wParam != lParam)) {
        lParam = wParam;
    }

    //
    // also, if the user hits tab, set focus to the correct radio button
    // after the first time, the tab starts working like we want it to
    //
    if ((msg == WM_KEYDOWN) && (wParam == VK_TAB) && firstTime) {
        firstTime = FALSE;
        if (! ((IsDlgButtonChecked(GetParent(hwnd), IDYES) == BST_CHECKED) ||
               (IsDlgButtonChecked(GetParent(hwnd), IDNO ) == BST_CHECKED))) {
            CheckDlgButton( GetParent(hwnd),IDYES, BST_CHECKED );
            PostMessage(GetParent(hwnd),WM_COMMAND,IDYES,0);
            SetFocus(GetDlgItem(GetParent(hwnd),IDYES));
        }
    }

    return(CallWindowProc(OldEulaEditProc,hwnd,msg,wParam,lParam));
}


LPTSTR
DoInitializeEulaText(
   HWND EditControl,
   PBOOL TranslationProblem
    )
/*++

Routine Description:

    retrieves the text out of eula.txt, and sets up the eula subclass routine

Arguments:

    EditControl - window handle for edit control
    TranslationProblem - if we fail, was is because we couldn't translate the
                        text?

Returns:

    pointer to eula text so that it can be freed, NULL on failure

--*/
{
    TCHAR   EulaPath[MAX_PATH];
    DWORD err;
    HANDLE  hFile, hFileMapping;
    DWORD   FileSize;
    BYTE    *pbFile;
    LPTSTR   EulaText = NULL;
    int     i;
//    HFONT   hFont;
    // accoding to MSDN LOCALE_IDEFAULTANSICODEPAGE and LOCALE_IDEFAULTCODEPAGE
    // are a max of 6 characters.  Unsure of whether or not this includes ending
    // null character, and we need a leading _T('.') 
    TCHAR cpName[8];

    if (TranslationProblem) {
        *TranslationProblem = FALSE;
    }

    //
    // Map the file containing the licensing agreement.
    //
    lstrcpy(EulaPath, NativeSourcePaths[0]);
    ConcatenatePaths (EulaPath, TEXT("eula.txt"), MAX_PATH );


    //
    // Open and map the inf file.
    //
    err = MapFileForRead(EulaPath,&FileSize,&hFile,&hFileMapping,&pbFile);
    if(err != NO_ERROR) {
        goto c0;
    }

    if(FileSize == 0xFFFFFFFF) {
        goto c1;
    }

    EulaText = MALLOC((FileSize+1) * sizeof(TCHAR));
    if(EulaText == NULL) {
        goto c1;
    }

#ifdef UNICODE
    // the Eula will be in the language of the build, so we should set out locale
    // to use the codepage that the source wants.
    if(!GetLocaleInfo(SourceNativeLangID,LOCALE_IDEFAULTANSICODEPAGE,&cpName[1],sizeof(cpName)/sizeof(TCHAR))){
    	if(!GetLocaleInfo(SourceNativeLangID,LOCALE_IDEFAULTCODEPAGE,&cpName[1],sizeof(cpName)/sizeof(TCHAR))){
	    FREE(EulaText);
	    EulaText = NULL;
	    if (TranslationProblem){
	        *TranslationProblem = TRUE;
	    }
	    goto c1;
	}
    }
    cpName[0] = _T('.');
    _tsetlocale(LC_ALL,cpName);

    //
    // Translate the text from ANSI to Unicode.
    //
    if(!mbstowcs(EulaText,pbFile,FileSize)){
    	FREE(EulaText);
	EulaText = NULL;
	if (TranslationProblem) {
	    *TranslationProblem = TRUE;
	}
	goto c1;
    }
    _tsetlocale(LC_ALL,_T(""));
    /*
    // we use mbstowcs instead of MultiByteToWideChar because mbstowcs will 
    // take into account the code page of the locale, which we've just set
    // to be in relation to the language of the build
    if (!MultiByteToWideChar (
                    CP_ACP,
                    MB_ERR_INVALID_CHARS,
                    pbFile,
                    FileSize,
                    EulaText,
                    (FileSize+1) * sizeof(WCHAR)
                    ) ) {
        FREE( EulaText );
        EulaText = NULL;
        if (TranslationProblem) {
            *TranslationProblem = TRUE;
        }
        goto c1;
    }
    */
#else
   CopyMemory(EulaText, pbFile, FileSize);
#endif

    //
    // add the trailing NULL character
    //
    EulaText[FileSize] = 0;

    //
    // setup the eula subclass
    //
    OldEulaEditProc = (WNDPROC)GetWindowLongPtr(EditControl,GWLP_WNDPROC);
    SetWindowLongPtr(EditControl,GWLP_WNDPROC,(LONG_PTR)EulaEditSubProc);

#if 0
    //
    // need a fixed width font for the EULA so it's formatted correctly for all resolutions
    //
    hFont = GetStockObject(SYSTEM_FIXED_FONT);
    if (hFont) {
        SendMessage( EditControl, WM_SETFONT, hFont, TRUE );
    }
#endif

    //
    // set the actual text
    //
    SetWindowText(EditControl,(LPCTSTR)EulaText);

c1:
    UnmapFile( hFileMapping, pbFile );
    CloseHandle( hFile );
c0:
    return EulaText;
}



BOOL
EulaWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    Eula wizard page.

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/
{
    BOOL b;
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    static LPTSTR EulaText = NULL;
    static BOOL ShowEula = TRUE;
    BOOL TranslationProblem;

    CHECKUPGRADEONLY();

    switch(msg) {

    case WM_INITDIALOG:

        //
        // check if the current language and target language match
        //
        ShowEula = IsLanguageMatched;

        //
        // Set eula radio buttons.
        //
        CheckDlgButton( hdlg,IDYES, BST_UNCHECKED );
        CheckDlgButton( hdlg,IDNO,  BST_UNCHECKED );


        //
        // setup the eula
        //
        EulaText = DoInitializeEulaText(
                                    GetDlgItem( hdlg, IDT_EULA_LIC_TEXT ),
                                    &TranslationProblem );

        //
        // if we couldn't read the eula, check if it was because of a translation problem,
        // in which case we defer to textmode setup
        //
        if (!EulaText && TranslationProblem == TRUE) {
            ShowEula = FALSE;
        }

        //
        // if this fails, only bail out if we were going to show the EULA in the first place.
        //
        if (!EulaText && ShowEula) {
           MessageBoxFromMessage(
                        hdlg,
                        MSG_EULA_FAILED,
                        FALSE,
                        AppTitleStringId,
                        MB_OK | MB_ICONERROR | MB_TASKMODAL
                        );

                Cancelled = TRUE;
                PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);

                b = FALSE;
        }

        PropSheet_SetWizButtons( GetParent(hdlg),
                                 WizPage->CommonData.Buttons & (~PSWIZB_NEXT)
                                 );

        //
        // Set focus to radio button
        //
        SetFocus(GetDlgItem(hdlg,IDYES));
        b = FALSE;
        break;

    case WM_COMMAND:
        if (wParam == IDYES) {
           PropSheet_SetWizButtons( GetParent(hdlg),
                                    WizPage->CommonData.Buttons | PSWIZB_NEXT
                                    );
           b = TRUE;
        } else if (wParam == IDNO) {
           PropSheet_SetWizButtons( GetParent(hdlg),
                                    WizPage->CommonData.Buttons | PSWIZB_NEXT
                                    );
           b = TRUE;
        }
        else
	   b = FALSE;

        break;
    case WMX_ACTIVATEPAGE:

        b = TRUE;
        if(wParam) {
            //
            // don't activate the page in restart mode
            //
            if (Winnt32RestartedWithAF ()) {
                EulaComplete = TRUE;
                return FALSE;
            }
            //
            // activation
            //
            if (!ShowEula) {
                    //
                    // the target install language and the source language do not match up
                    // since this means that we might not have fonts installed for the current
                    // language, we'll just defer this to textmode setup where we know we have
                    // the correct fonts
                    //
                    EulaComplete = FALSE;
                    if (IsDlgButtonChecked(hdlg, IDYES) == BST_CHECKED) {
                        PropSheet_PressButton(GetParent(hdlg),
                                              (lParam == PSN_WIZBACK) ? PSBTN_BACK : PSBTN_NEXT);
                    } else {
                        CheckDlgButton( hdlg,IDYES, BST_CHECKED );
                        PropSheet_PressButton(GetParent(hdlg),PSBTN_NEXT);
                    }
                    return(b);
            }

            //
            // set state of next button if user has backed up and reentered this dialog
            //
            if ( (IsDlgButtonChecked(hdlg, IDYES) == BST_CHECKED) ||
                 (IsDlgButtonChecked(hdlg, IDNO ) == BST_CHECKED) ) {
                PropSheet_SetWizButtons( GetParent(hdlg),
                                         WizPage->CommonData.Buttons | PSWIZB_NEXT
                                       );
            } else {
                SendMessage(GetParent(hdlg),
                            PSM_SETWIZBUTTONS, 
                            0, (LPARAM)WizPage->CommonData.Buttons & (~PSWIZB_NEXT));                
            }

            //
            // Advance page in unattended case.
            //
            UNATTENDED(PSBTN_NEXT);

        } else {
            //
            // deactivation
            //
            if (EulaText) FREE( EulaText );
            EulaText = NULL;

            if (IsDlgButtonChecked(hdlg, IDNO ) == BST_CHECKED) {
                Cancelled = TRUE;
                PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
            }

        }

        break;

    case WMX_UNATTENDED:

        //
        // necessary?
        //
        if (EulaText) FREE( EulaText );
        EulaText = NULL;
        b = FALSE;
        break;

    case WMX_I_AM_VISIBLE:

        //
        // Force repainting first to make sure the page is visible.
        //
        InvalidateRect(hdlg,NULL,FALSE);
        UpdateWindow(hdlg);
        b = TRUE;
        break;

    default:
        b = FALSE;
        break;
    }

    return(b);
}

BOOL
SelectPid30WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    OEM Pid wizard page. depends on SourceInstallType being set correctly.

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/

{
    BOOL b;
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    static BOOL bUnattendPid = FALSE;
    DWORD i;

    switch(msg) {

    case WM_INITDIALOG:
        GetPID();

        // Disable the IME on the PID edit controls
        for (i = 0; i < 5;i++) 
        {
            ImmAssociateContext(GetDlgItem(hdlg, IDT_EDIT_PID1+i), (HIMC)NULL);
        }

        //
        // subclass the edit controls and limit the number of characters
        //
        for (i = 0; i < 5;i++) {
            SendDlgItemMessage(hdlg,IDT_EDIT_PID1+i,EM_LIMITTEXT,MAX_PID30_EDIT,0);
            OldPidEditProc[i] = (WNDPROC)GetWindowLongPtr(GetDlgItem(hdlg, IDT_EDIT_PID1+i),GWLP_WNDPROC);
            SetWindowLongPtr(GetDlgItem(hdlg, IDT_EDIT_PID1+i),GWLP_WNDPROC,(LONG_PTR)PidEditSubProc);
        }

        //
        // set focus to first pid entry
        //
        SetFocus(GetDlgItem(hdlg,IDT_EDIT_PID1));

        b = FALSE;
        break;

    case WMX_ACTIVATEPAGE:

        CHECKUPGRADEONLY();
        if (BuildCmdcons) {
            return(FALSE);
        }

        // If we have an ecrypted PID and don't have the right crypto installed
        // defer the PID validation until GUI mode
        if (g_bDeferPIDValidation)
        {
            return FALSE;
        }

         b = TRUE;
         if(wParam) {
            //
            // activation
            //
#ifdef PRERELEASE
            if (NoPid) {
                //
                // don't show the page in this case
                //
               b = FALSE;
               break;
            }
#endif
            if (SourceInstallType != SelectInstall) {
               //
               // don't show the page in this case
               //
               b = FALSE;
               break;
            }
            //
            // don't activate the page in restart mode
            //
            if (Winnt32RestartedWithAF ()) {
                if (GetPrivateProfileString (
                        WINNT_USERDATA,
                        WINNT_US_PRODUCTKEY,
                        TEXT(""),
                        ProductId,
                        sizeof (ProductId) / sizeof (ProductId[0]),
                        g_DynUpdtStatus->RestartAnswerFile
                        )) {
                    return FALSE;
                }
            }
            if (UnattendedOperation) {
               //
               // make sure the pid is specified in the unattend file else we should stop
               //
               ShowPidBox(hdlg, SW_HIDE);
               if (SetPid30(hdlg,SourceInstallType, (LPTSTR)&ProductId) ) {
                      UNATTENDED(PSBTN_NEXT);
               } else {
                   //
                   // a hack so that the correct wizard page is active when we put up our message box
                   //
                   bUnattendPid = TRUE;
                   ShowPidBox(hdlg, SW_SHOW);
                   PostMessage(hdlg,WMX_I_AM_VISIBLE,0,0);

               }
            }

         } else {
            //
            // deactivation.  don't verify anything if they are backing up
            //

            if (!Cancelled && lParam != PSN_WIZBACK) {
               TCHAR tmpBuffer1[6];
               TCHAR tmpBuffer2[6];
               TCHAR tmpBuffer3[6];
               TCHAR tmpBuffer4[6];
               TCHAR tmpBuffer5[6];
               GetDlgItemText(hdlg,IDT_EDIT_PID1,tmpBuffer1,sizeof(tmpBuffer1)/sizeof(TCHAR));
               GetDlgItemText(hdlg,IDT_EDIT_PID2,tmpBuffer2,sizeof(tmpBuffer2)/sizeof(TCHAR));
               GetDlgItemText(hdlg,IDT_EDIT_PID3,tmpBuffer3,sizeof(tmpBuffer3)/sizeof(TCHAR));
               GetDlgItemText(hdlg,IDT_EDIT_PID4,tmpBuffer4,sizeof(tmpBuffer4)/sizeof(TCHAR));
               GetDlgItemText(hdlg,IDT_EDIT_PID5,tmpBuffer5,sizeof(tmpBuffer5)/sizeof(TCHAR));


               b = ValidatePid30( tmpBuffer1,
                                  tmpBuffer2,
                                  tmpBuffer3,
                                  tmpBuffer4,
                                  tmpBuffer5
                               );


               if (!b) {

                    if (UnattendedOperation) {
                        // We should not fail ValidatePid30 if we succeeded
                        // in the SetPid30 above. If we failed in SetPid30 above
                        // we should already be showing the pid boxes.
                        ShowPidBox(hdlg, SW_SHOW);
                    }
                    
                    MessageBoxFromMessage(hdlg,
                                          bUnattendPid ? MSG_UNATTEND_OEM_PID_IS_INVALID : MSG_OEM_PID_IS_INVALID,
                                          FALSE,AppTitleStringId,MB_OK|MB_ICONSTOP);
                    SetFocus(GetDlgItem(hdlg,IDT_EDIT_PID1));
                    b = FALSE;
               } else  {
                   //
                   // user entered a valid PID, save it for later on.
                   //

                   wsprintf( ProductId,
                             TEXT("%s-%s-%s-%s-%s"),
                             tmpBuffer1,
                             tmpBuffer2,
                             tmpBuffer3,
                             tmpBuffer4,
                             tmpBuffer5
                             );

               }
            }

         }

         break;

    case WMX_I_AM_VISIBLE:

        //
        // Force repainting first to make sure the page is visible.
        //
        InvalidateRect(hdlg,NULL,FALSE);
        UpdateWindow(hdlg);

        if (bUnattendPid) {
           MessageBoxFromMessage(hdlg,MSG_UNATTEND_OEM_PID_IS_INVALID,FALSE,AppTitleStringId,MB_OK|MB_ICONSTOP);
           bUnattendPid = FALSE;
        }
        b = TRUE;
        break;

    default:
        b = FALSE;
        break;
    }

    return(b);
}

BOOL
OemPid30WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    OEM Pid wizard page. depends on SourceInstallType being set correctly.

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/

{
    BOOL b;
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    static BOOL bUnattendPid = FALSE;
    DWORD i;
//    HFONT hFont;

    switch(msg) {

    case WM_INITDIALOG:
        GetPID();

//        hFont = GetStockObject(SYSTEM_FIXED_FONT);

        // Disable the IME on the PID edit controls
        for (i = 0; i < 5;i++) 
        {
            ImmAssociateContext(GetDlgItem(hdlg, IDT_EDIT_PID1+i), (HIMC)NULL);
        }

        //
        // subclass the edit controls and limit the number of characters
        //
        for (i = 0; i < 5;i++) {
            SendDlgItemMessage(hdlg,IDT_EDIT_PID1+i,EM_LIMITTEXT,MAX_PID30_EDIT,0);
//            SendDlgItemMessage(hdlg, IDT_EDIT_PID1+i, WM_SETFONT, hFont, TRUE );
            OldPidEditProc[i] = (WNDPROC)GetWindowLongPtr(GetDlgItem(hdlg, IDT_EDIT_PID1+i),GWLP_WNDPROC);
            SetWindowLongPtr(GetDlgItem(hdlg, IDT_EDIT_PID1+i),GWLP_WNDPROC,(LONG_PTR)PidEditSubProc);
        }

        //
        // set focus to first pid entry
        //
        SetFocus(GetDlgItem(hdlg,IDT_EDIT_PID1));

        b = FALSE;
        break;

    case WM_COMMAND:
        b = FALSE;
        break;

    case WMX_ACTIVATEPAGE:

        CHECKUPGRADEONLY();
        if (BuildCmdcons) {
            return(FALSE);
        }

        // If we have an ecrypted PID and don't have the right crypto installed
        // defer the PID validation until GUI mode
        if (g_bDeferPIDValidation)
        {
            return FALSE;
        }
         b = TRUE;
         if(wParam) {
            //
            // activation
            //
#ifdef PRERELEASE
            if (NoPid) {
                //
                // don't show the page in this case
                //
               b = FALSE;
               break;
            }
#endif
            if (SourceInstallType != OEMInstall) {
               //
               // don't show the page in this case
               //
               b = FALSE;
               break;
            }
            //
            // don't activate the page in restart mode
            //
            if (Winnt32RestartedWithAF ()) {
                if (GetPrivateProfileString (
                        WINNT_USERDATA,
                        WINNT_US_PRODUCTKEY,
                        TEXT(""),
                        ProductId,
                        sizeof (ProductId) / sizeof (ProductId[0]),
                        g_DynUpdtStatus->RestartAnswerFile
                        )) {
                    return FALSE;
                }
            }
            if (UnattendedOperation) {
               //
               // make sure the pid is specified in the unattend file else we should stop
               //
               if (SetPid30(hdlg,SourceInstallType, (LPTSTR)&ProductId) ) {
                      UNATTENDED(PSBTN_NEXT);
               } else {
                   //
                   // a hack so that the correct wizard page is active when we put up our message box
                   //
                   bUnattendPid = TRUE;
                   PostMessage(hdlg,WMX_I_AM_VISIBLE,0,0);

               }
            }

#if 0
            if (!Upgrade || (SourceInstallType != OEMInstall)) {
               //
               // don't show the page in this case
               //
               b = FALSE;
               break;
            } else {
               NOTHING;
            }
#endif

         } else {
            //
            // deactivation.  don't verify anything if they are backing up
            //

            if (!Cancelled && lParam != PSN_WIZBACK) {
               TCHAR tmpBuffer1[6];
               TCHAR tmpBuffer2[6];
               TCHAR tmpBuffer3[6];
               TCHAR tmpBuffer4[6];
               TCHAR tmpBuffer5[6];
               GetDlgItemText(hdlg,IDT_EDIT_PID1,tmpBuffer1,sizeof(tmpBuffer1)/sizeof(TCHAR));
               GetDlgItemText(hdlg,IDT_EDIT_PID2,tmpBuffer2,sizeof(tmpBuffer2)/sizeof(TCHAR));
               GetDlgItemText(hdlg,IDT_EDIT_PID3,tmpBuffer3,sizeof(tmpBuffer3)/sizeof(TCHAR));
               GetDlgItemText(hdlg,IDT_EDIT_PID4,tmpBuffer4,sizeof(tmpBuffer4)/sizeof(TCHAR));
               GetDlgItemText(hdlg,IDT_EDIT_PID5,tmpBuffer5,sizeof(tmpBuffer5)/sizeof(TCHAR));


               b = ValidatePid30( tmpBuffer1,
                                  tmpBuffer2,
                                  tmpBuffer3,
                                  tmpBuffer4,
                                  tmpBuffer5
                               );


               if (!b) {
                    MessageBoxFromMessage(hdlg,
                                          bUnattendPid ? MSG_UNATTEND_OEM_PID_IS_INVALID : MSG_OEM_PID_IS_INVALID,
                                          FALSE,AppTitleStringId,MB_OK|MB_ICONSTOP);
                    SetFocus(GetDlgItem(hdlg,IDT_EDIT_PID1));
                    b = FALSE;
               } else  {
                   //
                   // user entered a valid PID, save it for later on.
                   //

                   wsprintf( ProductId,
                             TEXT("%s-%s-%s-%s-%s"),
                             tmpBuffer1,
                             tmpBuffer2,
                             tmpBuffer3,
                             tmpBuffer4,
                             tmpBuffer5
                             );

               }
            }

         }

         break;

    case WMX_I_AM_VISIBLE:

        //
        // Force repainting first to make sure the page is visible.
        //
        InvalidateRect(hdlg,NULL,FALSE);
        UpdateWindow(hdlg);

        if (bUnattendPid) {
           MessageBoxFromMessage(hdlg,MSG_UNATTEND_OEM_PID_IS_INVALID,FALSE,AppTitleStringId,MB_OK|MB_ICONSTOP);
           bUnattendPid = FALSE;
        }
        b = TRUE;
        break;

    default:
        b = FALSE;
        break;
    }

    return(b);
}


BOOL
CdPid30WizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    CD Retail pid wizard page. depends on SourceInstallType being set correctly.

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/
{
    BOOL b;
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    static BOOL bUnattendPid = FALSE;
    DWORD i;
//    HFONT hFont;

    switch(msg) {

    case WM_INITDIALOG:
        GetPID();

//        hFont = GetStockObject(SYSTEM_FIXED_FONT);

        // Disable the IME on the PID edit controls
        for (i = 0; i < 5;i++) 
        {
            ImmAssociateContext(GetDlgItem(hdlg, IDT_EDIT_PID1+i), (HIMC)NULL);
        }

        //
        // subclass the edit controls and limit the number of characters
        //
        for (i = 0; i < 5;i++) {
            SendDlgItemMessage(hdlg,IDT_EDIT_PID1+i,EM_LIMITTEXT,MAX_PID30_EDIT,0);
//            SendDlgItemMessage(hdlg, IDT_EDIT_PID1+i, WM_SETFONT, hFont, TRUE );
            OldPidEditProc[i] = (WNDPROC)GetWindowLongPtr(GetDlgItem(hdlg, IDT_EDIT_PID1+i),GWLP_WNDPROC);
            SetWindowLongPtr(GetDlgItem(hdlg, IDT_EDIT_PID1+i),GWLP_WNDPROC,(LONG_PTR)PidEditSubProc);
        }

        //
        // set focus to first pid entry
        //
        SetFocus(GetDlgItem(hdlg,IDT_EDIT_PID1));

        b = FALSE;
        break;

    case WM_COMMAND:
        //
        // nothing to do here
        //
        b = FALSE;

        break;

    case WMX_ACTIVATEPAGE:

        CHECKUPGRADEONLY();
        if (BuildCmdcons) {
            return(FALSE);
        }

        // If we have an ecrypted PID and don't have the right crypto installed
        // defer the PID validation until GUI mode
        if (g_bDeferPIDValidation)
        {
            return FALSE;
        }
        b = TRUE;
        if(wParam) {
            //
            // activation
            //
#ifdef PRERELEASE
            if (NoPid) {
                //
                // don't show the page in this case
                //
               b = FALSE;
               break;
            }
#endif
            if (SourceInstallType != RetailInstall) {
               //
               // don't show the page in this case
               //
               b = FALSE;
               break;
            }

            //
            // don't activate the page in restart mode
            //
            if (Winnt32RestartedWithAF ()) {
                if (GetPrivateProfileString (
                        WINNT_USERDATA,
                        WINNT_US_PRODUCTKEY,
                        TEXT(""),
                        ProductId,
                        sizeof (ProductId) / sizeof (ProductId[0]),
                        g_DynUpdtStatus->RestartAnswerFile
                        )) {
                    return FALSE;
                }
            }

            if (UnattendedOperation) {
               //
               // make sure the pid is specified in the unattend file else we should stop
               //
               if (SetPid30(hdlg,SourceInstallType, (LPTSTR)&ProductId)) {
                  UNATTENDED(PSBTN_NEXT);
               } else {
                  //
                  // a hack so that the correct wizard page is active when we put up our message box
                  //
                  bUnattendPid = TRUE;
                  PostMessage(hdlg,WMX_I_AM_VISIBLE,0,0);
               }
            }


        } else {
            //
            // deactivation.  don't verify anything if they are backing up
            //
            if ( !Cancelled && lParam != PSN_WIZBACK ) {
               TCHAR tmpBuffer1[6];
               TCHAR tmpBuffer2[6];
               TCHAR tmpBuffer3[6];
               TCHAR tmpBuffer4[6];
               TCHAR tmpBuffer5[6];
               GetDlgItemText(hdlg,IDT_EDIT_PID1,tmpBuffer1,sizeof(tmpBuffer1)/sizeof(TCHAR));
               GetDlgItemText(hdlg,IDT_EDIT_PID2,tmpBuffer2,sizeof(tmpBuffer2)/sizeof(TCHAR));
               GetDlgItemText(hdlg,IDT_EDIT_PID3,tmpBuffer3,sizeof(tmpBuffer3)/sizeof(TCHAR));
               GetDlgItemText(hdlg,IDT_EDIT_PID4,tmpBuffer4,sizeof(tmpBuffer4)/sizeof(TCHAR));
               GetDlgItemText(hdlg,IDT_EDIT_PID5,tmpBuffer5,sizeof(tmpBuffer5)/sizeof(TCHAR));


               b = ValidatePid30( tmpBuffer1,
                                  tmpBuffer2,
                                  tmpBuffer3,
                                  tmpBuffer4,
                                  tmpBuffer5
                               );

               if (!b) {
		    if (PidMatchesMedia){
			MessageBoxFromMessage(hdlg,
                                              bUnattendPid ? MSG_UNATTEND_CD_PID_IS_INVALID :MSG_CD_PID_IS_INVALID,
                                              FALSE,AppTitleStringId,MB_OK|MB_ICONSTOP);
		    } else {
			MessageBoxFromMessage(hdlg,
					      UpgradeOnly ? MSG_CCP_MEDIA_FPP_PID : MSG_FPP_MEDIA_CCP_PID,
					      FALSE,AppTitleStringId,MB_OK|MB_ICONSTOP);
		    }

                    SetFocus(GetDlgItem(hdlg,IDT_EDIT_PID1));
                    b = FALSE;
               } else  {
                   //
                   // user entered a valid PID, save it for later on.
                   //
                   wsprintf( ProductId,
                             TEXT("%s-%s-%s-%s-%s"),
                             tmpBuffer1,
                             tmpBuffer2,
                             tmpBuffer3,
                             tmpBuffer4,
                             tmpBuffer5
                             );
               }
            }
        }

        break;

    case WMX_I_AM_VISIBLE:

        //
        // Force repainting first to make sure the page is visible.
        //
        InvalidateRect(hdlg,NULL,FALSE);
        UpdateWindow(hdlg);

        if (bUnattendPid) {
           MessageBoxFromMessage(hdlg,MSG_UNATTEND_CD_PID_IS_INVALID,FALSE,AppTitleStringId,MB_OK|MB_ICONSTOP);
           bUnattendPid = FALSE;
        }

        b = TRUE;
        break;

    default:
        b = FALSE;
        break;
    }

    return(b);
}

LPTSTR pSelectGpID[] = { TEXT("23"),
                         TEXT("26"),
                         NULL };
LPTSTR pSelectChID[] = { TEXT("080"),
                         TEXT("041"),
                         NULL };
BOOL IsSelect(LPTSTR Pid20)
{
    LPTSTR pTmp;
    BOOL bSelect = FALSE;
#if defined(UNICODE)
    pTmp = wcsrchr(Pid20, L'-');
#else
    pTmp = strrchr(Pid20, '-');
#endif
    if (pTmp)
    {
        int i = 0;
        TCHAR GpID[3];
        pTmp++;
        lstrcpyn(GpID, pTmp, 3);
        while (!bSelect && pSelectGpID[i])
        {
            bSelect = (lstrcmp(GpID, pSelectGpID[i]) == 0);
            i++;
        }
    }
    if (!bSelect)
    {
        // If we did not determine that we are select. This could be beta VL key
#if defined(UNICODE)
        pTmp = wcschr(Pid20, L'-');
#else
        pTmp = strchr(Pid20, '-');
#endif
        if (pTmp)
        {
            int i = 0;
            // The channel ID is 3 character + termination
            TCHAR ChID[4];
            pTmp++;
            lstrcpyn(ChID, pTmp, 4);    // Copy 4 characters, includingt he NULL termination.
            while (!bSelect && pSelectChID[i])
            {
                bSelect = (lstrcmp(ChID, pSelectChID[i]) == 0);
                i++;
            }
        }
    }
    return bSelect;
}

BOOL
ValidatePidEx(LPTSTR PID, BOOL *pbStepup, BOOL *bSelect)
{
    TCHAR Pid20Id[MAX_PATH];
    BYTE Pid30[1024]={0};
    TCHAR pszSkuCode[10];
    BOOL fStepUp;
    // it seems that sku code really doesn't matter in winnt32, only syssetup
    lstrcpy(pszSkuCode,TEXT("1797XYZZY"));


#if 0
wsprintf(DebugBuffer,
         TEXT("cd-key: %s\nRPC: %s\nOEM Key: %d"),
         PID,
         Pid30Rpc,
         (SourceInstallType == OEMInstall)
         );
OutputDebugString(DebugBuffer);
#endif

    *(LPDWORD)Pid30 = sizeof(Pid30);


    if (!SetupPIDGen(
                PID,                   // [IN] 25-character Secure CD-Key (gets U-Cased)
                Pid30Rpc,                       // [IN] 5-character Release Product Code
		// note sku code is not kept around in winnt32, only syssetup.
                pszSkuCode,              // [IN] Stock Keeping Unit (formatted like 123-12345)
                (SourceInstallType == OEMInstall),    // [IN] is this an OEM install?
                Pid20Id,                        // [OUT] PID 2.0, pass in ptr to 24 character array
                Pid30,                          // [OUT] pointer to binary PID3 buffer. First DWORD is the length
                pbStepup                           // [OUT] optional ptr to Compliance Checking flag (can be NULL)
               )) {
        if (g_EncryptedPID)
        {
            GlobalFree(g_EncryptedPID);
            g_EncryptedPID = NULL;
        }
        return(FALSE);
    }
    // PID is valid,
    // if the caller wants, return if this is a Volume License PID
    if(bSelect)
    {
        *bSelect = IsSelect(Pid20Id);
    }
    return TRUE;
}

BOOL
ValidatePid30(
    LPTSTR Edit1,
    LPTSTR Edit2,
    LPTSTR Edit3,
    LPTSTR Edit4,
    LPTSTR Edit5
    )
{
    TCHAR tmpProductId[MAX_PATH]={0};
    TCHAR Pid20Id[MAX_PATH];
    BYTE Pid30[1024]={0};
    TCHAR pszSkuCode[10];
    BOOL fStepUp;
//TCHAR DebugBuffer[1024];

    // until we know better, assume the Pid matches the media type
    PidMatchesMedia = TRUE;

    if (!Edit1 || !Edit2 || !Edit3 || !Edit4 || !Edit5) {
        return(FALSE);
    }

    // Since we now need a PID in the select case too, fill in the string.
/*
    if (SourceInstallType == SelectInstall){
        tmpProductId[0] = TEXT('\0');
    } 
    else 
*/
    {
        wsprintf( tmpProductId,
                  TEXT("%s-%s-%s-%s-%s"),
                  Edit1,
                  Edit2,
                  Edit3,
                  Edit4,
                  Edit5 );
    }

    if (!ValidatePidEx(tmpProductId, &fStepUp, NULL))
    {
        return(FALSE);
    }
    if (SourceInstallType != OEMInstall){
	    // we want OEM FPP and CCP keys to be accepted by either media.  It seems like
	    // there will be OEM CCP media, but only FPP keys, which is why we aren't 
	    // checking to make sure they match, as it's broken by design.
	    if (UpgradeOnly != fStepUp){
                // user is trying to do a clean install with upgrade only media.  Bad user, bad.
	        PidMatchesMedia = FALSE;
	        return FALSE;
	    }
    }
    return(TRUE);
}

void GetPID()
{
    if (!ProductId[0] && UnattendedOperation && !g_bDeferPIDValidation){
        //
        // On Whistler upgrades, reuse existing DPID
        //
        BYTE abCdKey[16];
        BOOL bDontCare, bSelect;
        if (Upgrade &&
            ISNT() &&
            OsVersion.dwMajorVersion == 5 && OsVersion.dwMinorVersion == 1 &&
            pGetCdKey (abCdKey)
            ) {
            EncodePid3g (ProductId, abCdKey);
            if (ValidatePidEx(ProductId, &bDontCare, &bSelect) && bSelect)
            {
                HRESULT hr;
                if (g_EncryptedPID)
                {
                    GlobalFree(g_EncryptedPID);
                    g_EncryptedPID = NULL;
                }
                // Prepare the encrypted PID so that we can write it to winnt.sif
                hr = PrepareEncryptedPID(ProductId, 1, &g_EncryptedPID);
                if (hr != S_OK)
                {
                    DebugLog (Winnt32LogInformation, TEXT("PrepareEncryptedPID failed: <hr=0x%1!lX!>"), 0, hr);
                }
            }
        } 
    }
}

VOID ShowPidBox(
    IN HWND hdlg,
    IN int  nCmdShow
    )
/*++

Routine Description:

    shows or hide the pid boxes in the wizard page

Arguments:

    hdlg - window handle to pid dialog
    nCmdShow - SW_SHOW or SW_HIDE

--*/
{

    int i;
    
    for (i = 0; i<5; i++) {
        ShowWindow(GetDlgItem(hdlg,IDT_EDIT_PID1+i), nCmdShow);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\incompat.c ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Module Name:
//    incompat.cpp
//
// Abstract:
//    This file implements compatibility checking for various components.
//    The functions get executed by winnt32. It's purpose is to alert the user to possible
//    incompatibilities that may be encountered after performing an upgrade.
//
//
// Author:
//    matt thomlinson (mattt)
//
// Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#pragma hdrstop

HRESULT CertSrv_TestForIllegalUpgrade(BOOL *pfComplain);
extern HINSTANCE hInst;






/////////////////////////////////////////////////////////////////////////////
//++
//
// CertificateServerUpgradeCompatibilityCheck
//
// Routine Description:
//    This is the exported function, called to check for incompatibilities when
//    upgrading the machine. 
// 
//    Behavior: If Certificate server is installed on NT4, we wish to warn the user.
//
// Arguments:
//    pfnCompatibilityCallback - points to the callback function used to supply
//                               compatibility information to winnt32.exe.
//    pvContext - points to a context buffer supplied by winnt32.exe.
//    
//
// Return Value:
//    TRUE - either indicates that no incompatibility was detected or that
//           *pfnComaptibilityCallback() returned TRUE.
//    FALSE - *pfnCompatibilityCallback() returned FALSE
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CertificateServerUpgradeCompatibilityCheck( PCOMPAIBILITYCALLBACK pfnCompatibilityCallback,
                                       LPVOID pvContext )
{
     BOOL  fReturnValue = (BOOL) TRUE;
     BOOL fComplain;

     // Is this an illegal upgrade?
     if ((S_OK == CertSrv_TestForIllegalUpgrade(&fComplain)) &&
		fComplain)
     {
        // It is necessary to display a compatibility warning.
        
        TCHAR tszDescription[MAX_PATH];       // size is arbitrary
        TCHAR tszHtmlName[MAX_PATH];
        TCHAR tszTextName[MAX_PATH];

        COMPATIBILITY_ENTRY  CompatibilityEntry;
        ZeroMemory( &CompatibilityEntry, sizeof( CompatibilityEntry ) );
        
        // Set the Description string.
        
        *tszDescription = TEXT( '\0' );

        LoadString( hInst,
                    IDS_CERTSRV_UPGRADE_WARNING,
                    tszDescription,
                    sizeof(tszDescription)/sizeof(tszDescription[0]) );

        // Set the HTML file name.             
        _tcscpy( tszHtmlName, TEXT( "CompData\\certsrv.htm" ) );

        // Set the TEXT file name.             
        _tcscpy( tszTextName, TEXT( "CompData\\certsrv.txt" ) );

        // Build the COMPATIBILITY_ENTRY structure to pass to *pfnCompatibilityCallback().
        CompatibilityEntry.Description = tszDescription;
        CompatibilityEntry.HtmlName = tszHtmlName;
        CompatibilityEntry.TextName = tszTextName;

        // Execute the callback function.
        fReturnValue = pfnCompatibilityCallback( (PCOMPATIBILITY_ENTRY) &CompatibilityEntry,
                                                 pvContext );
     }
     else
     {
        // It is not necessary to display a compatibility warning.

        fReturnValue = (BOOL) TRUE;
     } // Is it necessary to display a compatibility warning?
  
   return ( fReturnValue );
}



HRESULT CertSrv_TestForIllegalUpgrade(BOOL *pfComplain)
{
    HRESULT hr = S_OK;
    SC_HANDLE hSC=NULL, hSvc=NULL;
    OSVERSIONINFO osVer;

    // only complain about NT4 certsvr upgrades

    *pfComplain = FALSE;
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if(! GetVersionEx(&osVer) )
    {   
	// error getting version, can't be NT4
        hr = GetLastError(); 
        goto error;
    }

    if ((osVer.dwPlatformId != VER_PLATFORM_WIN32_NT) ||
        (osVer.dwMajorVersion != 4))
    {
        goto NoComplaint;
	// not NT4, must be ok
    }

    // now the hard part -- open the service to see if it exists
    hSC = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT);
    if (hSC == NULL)
    {
        hr = GetLastError();
        goto error;
    }

    hSvc = OpenService(hSC, TEXT("CertSvc"), SERVICE_QUERY_CONFIG);
    if (hSvc == NULL)
    {
       hr = GetLastError();
       if (ERROR_SERVICE_DOES_NOT_EXIST == hr)
            goto NoComplaint;
       goto error;
    }

    // failed version check and service is installed 
    *pfComplain = TRUE;
            
NoComplaint:
    hr = S_OK;

error:

    if (NULL != hSC)
        CloseServiceHandle(hSC);

    if (NULL != hSvc)
        CloseServiceHandle(hSvc);

    return hr;
}

BOOL
IsStandardServerSKU(
    PBOOL pIsServer
    )
/////////////////////////////////////////////////////////////////////////////
//++
//
// IsStandardServerSKU
//
// Routine Description:
//    This routine determines if the user is running the standard server
//    SKU
// 
//
// Arguments:
//    pIsServer - indicates if the server is the standard server SKU
//                or not.
//
// Return Value:
//    Indicates success of the check
//
//--
/////////////////////////////////////////////////////////////////////////////
{
    BOOL  fReturnValue = (BOOL) FALSE;
    OSVERSIONINFOEX  VersionInfo;
    BOOL  IsServer = FALSE;

     //
     // get the current SKU.
     //
     VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);
     if (GetVersionEx((OSVERSIONINFO *)&VersionInfo)) {
         fReturnValue = TRUE; 
         //
         // is it some sort of server SKU?
         //
         if (VersionInfo.wProductType != VER_NT_WORKSTATION) {
    
             //
             // standard server or a server variant?
             //
             if ((VersionInfo.wSuiteMask & (VER_SUITE_ENTERPRISE | VER_SUITE_DATACENTER)) == 0) {
                 //
                 // it's standard server
                 //
                 IsServer = TRUE;
             }
    
         }

         *pIsServer = IsServer;

     }

     return(fReturnValue);

}



/////////////////////////////////////////////////////////////////////////////
//++
//
// ProcessorUpgradeCompatibilityCheck
//
// Routine Description:
//    This is the exported function, called to check for incompatibilities when
//    upgrading the machine. 
// 
//    Behavior: If the current processor count is > that allowed after upgrade,
//              a warning is generated.
//
// Arguments:
//    pfnCompatibilityCallback - points to the callback function used to supply
//                               compatibility information to winnt32.exe.
//    pvContext - points to a context buffer supplied by winnt32.exe.
//    
//
// Return Value:
//    TRUE - either indicates that no incompatibility was detected or that
//           *pfnComaptibilityCallback() returned TRUE.
//    FALSE - *pfnCompatibilityCallback() returned FALSE
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL ProcessorUpgradeCompatibilityCheck( PCOMPAIBILITYCALLBACK pfnCompatibilityCallback,
                                       LPVOID pvContext )
{
     BOOL  fReturnValue = (BOOL) TRUE;
     BOOL fComplain = FALSE;
     BOOL IsServer = FALSE;
     SYSTEM_INFO SysInfo;
     ULONG SourceSkuId;
     ULONG DontCare;

     
     //
     // we only care about standard server SKU.
     //
     SourceSkuId = DetermineSourceProduct(&DontCare,NULL);

     if ( SourceSkuId == COMPLIANCE_SKU_NTSFULL || SourceSkuId == COMPLIANCE_SKU_NTSU) {
         //
         // we only allow 2 processors on standard server.
         //
         DWORD AllowedCount = 2;

         GetSystemInfo(&SysInfo);
         if (SysInfo.dwNumberOfProcessors > AllowedCount) {
             fComplain = TRUE;
         }                      
     }

     // Is this an illegal upgrade?
     if (fComplain)
     {
        // It is necessary to display a compatibility warning.
        
        TCHAR tszDescription[MAX_PATH];       // size is arbitrary
        TCHAR tszHtmlName[MAX_PATH];
        TCHAR tszTextName[MAX_PATH];

        COMPATIBILITY_ENTRY  CompatibilityEntry;
        ZeroMemory( &CompatibilityEntry, sizeof( CompatibilityEntry ) );
        
        // Set the Description string.
        
        *tszDescription = TEXT( '\0' );

        LoadString( hInst,
                    IDS_PROCESSOR_UPGRADE_WARNING,
                    tszDescription,
                    sizeof(tszDescription)/sizeof(tszDescription[0]) );

        // Set the HTML file name.             
        _tcscpy( tszHtmlName, TEXT( "CompData\\proccnt.htm" ) );

        // Set the TEXT file name.             
        _tcscpy( tszTextName, TEXT( "CompData\\proccnt.txt" ) );

        // Build the COMPATIBILITY_ENTRY structure to pass to *pfnCompatibilityCallback().
        CompatibilityEntry.Description = tszDescription;
        CompatibilityEntry.HtmlName = tszHtmlName;
        CompatibilityEntry.TextName = tszTextName;

        // Execute the callback function.
        fReturnValue = pfnCompatibilityCallback( (PCOMPATIBILITY_ENTRY) &CompatibilityEntry,
                                                 pvContext );
     }
     else
     {
        // It is not necessary to display a compatibility warning.

        fReturnValue = (BOOL) TRUE;
     } // Is it necessary to display a compatibility warning?
  
   return ( fReturnValue );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\inf.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    inf.c

Abstract:

    This module implements functions to access the parsed INF.

Author:

    Sunil Pai    (sunilp) 13-Nov-1991

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <string.h>
#include <ctype.h>

#define ISSPACE(x)          (((x) == TEXT(' ')) || ((x) == TEXT('\t')) || ((x) == TEXT('\r')))
#define STRNCPY(s1,s2,n)    CopyMemory((s1),(s2),(n)*sizeof(WCHAR))


// what follows was alpar.h

//
//   EXPORTED BY THE PARSER AND USED BY BOTH THE PARSER AND
//   THE INF HANDLING COMPONENTS
//

// typedefs exported
//

typedef struct _value {
    struct _value *pNext;
    PTSTR  pName;
    BOOL   IsStringId;
} XVALUE, *PXVALUE;

typedef struct _line {
    struct _line *pNext;
    PTSTR   pName;
    PXVALUE  pValue;
} LINE, *PLINE;

typedef struct _section {
    struct _section *pNext;
    PTSTR    pName;
    PLINE    pLine;
} SECTION, *PSECTION;

typedef struct _inf {
    PSECTION pSection;
} INF, *PINF;


DWORD
ParseInfBuffer(
    PTSTR Buffer,
    DWORD Size,
    PVOID *Handle
    );

//
// DEFINES USED FOR THE PARSER INTERNALLY
//
//
// typedefs used
//

typedef enum _tokentype {
    TOK_EOF,
    TOK_EOL,
    TOK_LBRACE,
    TOK_RBRACE,
    TOK_STRING,
    TOK_STRING_ID,
    TOK_EQUAL,
    TOK_COMMA,
    TOK_ERRPARSE,
    TOK_ERRNOMEM
    } TOKENTYPE, *PTOKENTTYPE;


typedef struct _token {
    TOKENTYPE Type;
    PTSTR     pValue;
    } TOKEN, *PTOKEN;


//
// Routine defines
//

DWORD
DnAppendSection(
    IN PTSTR pSectionName
    );

DWORD
DnAppendLine(
    IN PTSTR pLineKey
    );

DWORD
DnAppendValue(
    IN PTSTR pValueString,
    IN BOOL IsStringId
    );

TOKEN
DnGetToken(
    IN OUT PTSTR *Stream,
    IN PTSTR     MaxStream
    );

BOOL
IsStringTerminator(
   IN TCHAR ch
   );

BOOL
IsQStringTerminator(
   IN TCHAR ch,
   IN TCHAR term
   );

// what follows was alinf.c

//
// Internal Routine Declarations for freeing inf structure members
//

VOID
FreeSectionList (
   IN PSECTION pSection
   );

VOID
FreeLineList (
   IN PLINE pLine
   );

VOID
FreeValueList (
   IN PXVALUE pValue
   );


//
// Internal Routine declarations for searching in the INF structures
//


PXVALUE
SearchValueInLine(
   IN PLINE pLine,
   IN unsigned ValueIndex
   );

PLINE
SearchLineInSectionByKey(
   IN PSECTION pSection,
   IN LPCTSTR  Key
   );

PLINE
SearchLineInSectionByIndex(
   IN PSECTION pSection,
   IN unsigned    LineIndex
   );

PSECTION
SearchSectionByName(
   IN PINF    pINF,
   IN LPCTSTR SectionName
   );

BOOL
ProcessStringSection(
    PINF pINF
    );



DWORD
LoadInfFile(
   IN  LPCTSTR Filename,
   IN  BOOL    OemCodepage,
   OUT PVOID  *InfHandle
   )

/*++

Routine Description:

Arguments:

    Filename - supplies win32 filename of inf file to be loaded.

    OemCodepage - if TRUE amd the file named by Filename is not
        Unicode text, then the file is assumed to be in the OEM
        codepage (otherwise it's in the ANSI codepage).

    InfHandle - if successful, receives a handle to be used with
        subsequent inf operations.

Return Value:

    ERROR_FILE_NOT_FOUND - file does not exist or error opening it.
    ERROR_INVALID_DATA - syntax error in inf file.
    ERROR_READ_FAULT - unable to read file.
    ERROR_NOT_ENOUGH_MEMORY - mem alloc failed
    NO_ERROR - file read and parsed.

--*/

{
    DWORD err;
    DWORD FileSize;
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PVOID BaseAddress;
    BOOL IsUnicode;

    DWORD ParseCount;
    PVOID ParseBuffer;

    //
    // Open and map the inf file.
    //
    err = MapFileForRead(Filename,&FileSize,&FileHandle,&MappingHandle,&BaseAddress);
    if(err != NO_ERROR) {
        err = ERROR_FILE_NOT_FOUND;
        goto c0;
    }

    //
    // Determine whether the file is unicode. If it's got the byte order mark
    // then it's unicode, otherwise call the IsTextUnicode API. We do it this way
    // because IsTextUnicode always returns FALSE on Win95 so we need to break out
    // the BOM to detect Unicode files on Win95.
    //
    if((FileSize >= sizeof(WCHAR)) && (*(PWCHAR)BaseAddress == 0xfeff)) {
        IsUnicode = 2;
    } else {
        IsUnicode = IsTextUnicode(BaseAddress,FileSize,NULL) ? 1 : 0;
    }

#ifdef UNICODE
    if(IsUnicode) {
        //
        // Copy into local buffer, skipping BOM if necessary.
        //
        ParseBuffer = MALLOC(FileSize);
        if(!ParseBuffer) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto c1;
        }

        try {

            CopyMemory(
                ParseBuffer,
                (PUCHAR)BaseAddress + ((IsUnicode == 2) ? sizeof(WCHAR) : 0),
                FileSize - ((IsUnicode == 2) ? sizeof(WCHAR) : 0)
                );

        } except(EXCEPTION_EXECUTE_HANDLER) {
            err = ERROR_READ_FAULT;
        }

        ParseCount = (FileSize / sizeof(WCHAR)) - ((IsUnicode == 2) ? 1 : 0);

    } else {
        //
        // Convert to Unicode.
        //
        // Allocate a buffer large enough to hold the maximum sized unicode
        // equivalent of the multibyte text.  This size occurs when all chars
        // in the file are single-byte and thus double in size when converted.
        //
        ParseBuffer = MALLOC(FileSize * sizeof(WCHAR));
        if(!ParseBuffer) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto c1;
        }

        try {
            ParseCount = MultiByteToWideChar(
                            OemCodepage ? CP_OEMCP : CP_ACP,
                            MB_PRECOMPOSED,
                            BaseAddress,
                            FileSize,
                            ParseBuffer,
                            FileSize
                            );

            if(!ParseCount) {
                //
                // Assume inpage i/o error
                //
                err = ERROR_READ_FAULT;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            err = ERROR_READ_FAULT;
        }
    }
#else
    if(IsUnicode) {
        //
        // Text is unicode but internal routines want ansi. Convert here.
        //
        // Maximum required buffer is when each unicode char ends up as
        // a double-byte char.
        //
        ParseBuffer = MALLOC(FileSize);
        if(!ParseBuffer) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto c1;
        }

        try {
            ParseCount = WideCharToMultiByte(
                            CP_ACP,
                            0,
                            (PWCHAR)BaseAddress + ((IsUnicode == 2) ? 1 : 0),
                            (FileSize / sizeof(WCHAR)) - ((IsUnicode == 2) ? 1 : 0),
                            ParseBuffer,
                            FileSize,
                            NULL,
                            NULL
                            );

            if(!ParseCount) {
                //
                // Assume inpage i/o error
                //
                err = ERROR_READ_FAULT;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            err = ERROR_READ_FAULT;
        }
    } else {
        //
        // Text is not unicode. It might be OEM though and could thus still
        // require translation.
        //
        ParseCount = FileSize;
        ParseBuffer = MALLOC(FileSize);
        if(!ParseBuffer) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto c1;
        }

        try {
            CopyMemory(ParseBuffer,BaseAddress,FileSize);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            err = ERROR_READ_FAULT;
        }

        if(err != NO_ERROR) {
            goto c2;
        }

        if(OemCodepage && (GetOEMCP() != GetACP())) {
            OemToCharBuff(ParseBuffer,ParseBuffer,ParseCount);
        }
    }
#endif

    if(err != NO_ERROR) {
        goto c2;
    }

    err = ParseInfBuffer(ParseBuffer,ParseCount,InfHandle);

c2:
    FREE(ParseBuffer);
c1:
    UnmapFile(MappingHandle,BaseAddress);
    CloseHandle(FileHandle);
c0:
    return(err);
}


VOID
UnloadInfFile(
   IN PVOID InfHandle
   )

/*++

Routine Description:

    Unload a file previously loaded by LoadInfFile().

Arguments:

    InfHandle - supplies a habdle previously returned by a successful
        call to LoadInfFile().

Return Value:

    None.

--*/

{
   PINF pINF;

   pINF = InfHandle;

   FreeSectionList(pINF->pSection);
   FREE(pINF);
}


VOID
FreeSectionList (
   IN PSECTION pSection
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PSECTION Next;

    while(pSection) {
        Next = pSection->pNext;
        FreeLineList(pSection->pLine);
        if(pSection->pName) {
            FREE(pSection->pName);
        }
        FREE(pSection);
        pSection = Next;
    }
}


VOID
FreeLineList(
   IN PLINE pLine
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PLINE Next;

    while(pLine) {
        Next = pLine->pNext;
        FreeValueList(pLine->pValue);
        if(pLine->pName) {
            FREE(pLine->pName);
        }
        FREE(pLine);
        pLine = Next;
    }
}

VOID
FreeValueList (
   IN PXVALUE pValue
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PXVALUE Next;

    while(pValue) {
        Next = pValue->pNext;
        if(pValue->pName) {
            FREE(pValue->pName);
        }
        FREE(pValue);
        pValue = Next;
    }
}


//
// searches for the existance of a particular section,
// returns line count (-1 if not found)
//
LONG
InfGetSectionLineCount(
   IN PVOID INFHandle,
   IN PTSTR SectionName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;
   PLINE pLine;
   LONG count;

   //
   // if search for section fails return failure
   //
   if ((pSection = SearchSectionByName(INFHandle,SectionName)) == NULL) {
       return(-1);
   }

   for(count=0,pLine=pSection->pLine; pLine; pLine=pLine->pNext) {
       count++;
   }

   return(count);
}




//
// given section name, line number and index return the value.
//
LPCTSTR
InfGetFieldByIndex(
   IN PVOID    INFHandle,
   IN LPCTSTR  SectionName,
   IN unsigned LineIndex,
   IN unsigned ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;
   PLINE    pLine;
   PXVALUE   pValue;

   if((pSection = SearchSectionByName(
                    (PINF)INFHandle,
                    SectionName
                    ))
                == NULL)
        return(NULL);

   if((pLine = SearchLineInSectionByIndex(
                    pSection,
                    LineIndex
                    ))
                == NULL)
        return(NULL);

   if((pValue = SearchValueInLine(
                    pLine,
                    ValueIndex
                    ))
                == NULL)
        return(NULL);

   return (pValue->pName);
}


BOOL
InfDoesLineExistInSection(
   IN PVOID   INFHandle,
   IN LPCTSTR SectionName,
   IN LPCTSTR Key
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;

   if((pSection = SearchSectionByName(
              (PINF)INFHandle,
              SectionName
              ))
              == NULL) {
       return( FALSE );
   }

   if (SearchLineInSectionByKey(pSection, Key) == NULL) {
       return( FALSE );
   }

   return( TRUE );
}


BOOL
InfDoesEntryExistInSection (
   IN PVOID   INFHandle,
   IN LPCTSTR SectionName,
   IN LPCTSTR Entry
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;
   PLINE pLine;
   PXVALUE pValue;
   PCTSTR pEntryName;

   if((pSection = SearchSectionByName(
              (PINF)INFHandle,
              SectionName
              ))
              == NULL) {
       return( FALSE );
   }

   pLine = pSection->pLine;
   while (pLine) {
       pEntryName = pLine->pName ?
                        pLine->pName :
                        pLine->pValue ?
                            pLine->pValue->pName :
                            NULL;
       if (pEntryName && !lstrcmpi (pEntryName, Entry)) {
            return TRUE;
       }
       pLine = pLine->pNext;
   }

   return FALSE;
}


LPCTSTR
InfGetLineKeyName(
    IN PVOID    INFHandle,
    IN LPCTSTR  SectionName,
    IN unsigned LineIndex
    )
{
    PSECTION pSection;
    PLINE    pLine;

    pSection = SearchSectionByName((PINF)INFHandle,SectionName);
    if(pSection == NULL) {
        return(NULL);
    }

    pLine = SearchLineInSectionByIndex(pSection,LineIndex);
    if(pLine == NULL) {
        return(NULL);
    }

    return(pLine->pName);
}



//
// given section name, key and index return the value
//
LPCTSTR
InfGetFieldByKey(
   IN PVOID    INFHandle,
   IN LPCTSTR  SectionName,
   IN LPCTSTR  Key,
   IN unsigned ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;
   PLINE    pLine;
   PXVALUE   pValue;

   if((pSection = SearchSectionByName(
              (PINF)INFHandle,
              SectionName
              ))
              == NULL)
       return(NULL);

   if((pLine = SearchLineInSectionByKey(
              pSection,
              Key
              ))
              == NULL)
       return(NULL);

   if((pValue = SearchValueInLine(
              pLine,
              ValueIndex
              ))
              == NULL)
       return(NULL);

   return (pValue->pName);

}




PXVALUE
SearchValueInLine(
   IN PLINE pLine,
   IN unsigned ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PXVALUE pValue;
   unsigned  i;

   if (pLine == NULL)
       return (NULL);

   pValue = pLine->pValue;
   for (i = 0; (i < ValueIndex) && (pValue = pValue->pNext); i++)
      ;

   return pValue;

}

PLINE
SearchLineInSectionByKey(
   IN PSECTION pSection,
   IN LPCTSTR  Key
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PLINE pLine;

   if (pSection == NULL || Key == NULL) {
       return (NULL);
   }

   pLine = pSection->pLine;
   while(pLine && ((pLine->pName == NULL) || lstrcmpi(pLine->pName, Key))) {
       pLine = pLine->pNext;
   }

   return pLine;

}


PLINE
SearchLineInSectionByIndex(
   IN PSECTION pSection,
   IN unsigned    LineIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PLINE pLine;
   unsigned  i;

   //
   // Validate the parameters passed in
   //

   if(pSection == NULL) {
       return (NULL);
   }

   //
   // find the start of the line list in the section passed in
   //

   pLine = pSection->pLine;

   //
   // traverse down the current line list to the LineIndex th line
   //

   for (i = 0; (i < LineIndex) && (pLine = pLine->pNext); i++) {
      ;
   }

   //
   // return the Line found
   //

   return pLine;

}


PSECTION
SearchSectionByName(
   IN PINF    pINF,
   IN LPCTSTR SectionName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSECTION pSection;

   //
   // validate the parameters passed in
   //

   if (pINF == NULL || SectionName == NULL) {
       return (NULL);
   }

   //
   // find the section list
   //
   pSection = pINF->pSection;

   //
   // traverse down the section list searching each section for the section
   // name mentioned
   //

   while (pSection && lstrcmpi(pSection->pName, SectionName)) {
       pSection = pSection->pNext;
   }

   //
   // return the section at which we stopped (either NULL or the section
   // which was found
   //

   return pSection;

}


// what follows was alparse.c


//
//  Globals used to make building the lists easier
//

PINF     pINF;
PSECTION pSectionRecord;
PLINE    pLineRecord;
PXVALUE  pValueRecord;


//
// Globals used by the token parser
//

// string terminators are the whitespace characters (isspace: space, tab,
// linefeed, formfeed, vertical tab, carriage return) or the chars given below

TCHAR  StringTerminators[] = {  TEXT('['),
                                TEXT(']'),
                                TEXT('='),
                                TEXT(','),
                                TEXT('\"'),
                                TEXT(' '),
                                TEXT('\t'),
                                TEXT('\n'),
                                TEXT('\f'),
                                TEXT('\v'),
                                TEXT('\r'),
                                TEXT('\032')
                             };

unsigned NumberOfTerminators = sizeof(StringTerminators)/sizeof(TCHAR);

//
// quoted string terminators allow some of the regular terminators to
// appear as characters

TCHAR  QStringTerminators[] = { TEXT('\n'),
                                TEXT('\f'),
                                TEXT('\v'),
                                TEXT('\r'),
                                TEXT('\032')
                              };

unsigned QNumberOfTerminators = sizeof(QStringTerminators)/sizeof(TCHAR);


//
// Main parser routine
//

DWORD
ParseInfBuffer(
    PTSTR Buffer,
    DWORD Size,
    PVOID *Handle
    )

/*++

Routine Description:

   Given a character buffer containing the INF file, this routine parses
   the INF into an internal form with Section records, Line records and
   Value records.

   If this module is compiler for unicode, the input is assumed to be
   a bufferful of unicode characters.

Arguments:

   Buffer - contains to ptr to a buffer containing the INF file

   Size - contains the size of the buffer in characters.

   Handle - receives INF handle ptr to be used in subsequent INF calls.

Return Value:

   Win32 error code indicating outcome. One of NO_ERROR, ERROR_INVALID_DATA,
   or ERROR_NOT_ENOUGH_MEMORY.

--*/

{
    LPTSTR Stream, MaxStream, pchSectionName, pchValue;
    unsigned State, InfLine;
    TOKEN Token;
    BOOL Done;
    BOOL Error;
    DWORD ErrorCode;
    BOOL IsStringId;

    //
    // Initialise the globals
    //
    pINF            = NULL;
    pSectionRecord  = NULL;
    pLineRecord     = NULL;
    pValueRecord    = NULL;

    //
    // Get INF record
    //
    pINF = MALLOC(sizeof(INF));
    if(!pINF) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    pINF->pSection = NULL;

    //
    // Set initial state
    //
    State      = 1;
    InfLine    = 1;
    Stream     = Buffer;
    MaxStream  = Buffer + Size;
    Done       = FALSE;
    Error      = FALSE;
    ErrorCode  = NO_ERROR;
    IsStringId = FALSE;

    pchSectionName = NULL;
    pchValue = NULL;

    //
    // Enter token processing loop
    //

    if (Size == 0)
       return ERROR_INVALID_DATA;
    while (!Done)       {

       Token = DnGetToken(&Stream, MaxStream);

       if(Token.Type == TOK_ERRNOMEM){
            Error = Done = TRUE;
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
       }

       switch (State) {
       //
       // STATE1: Start of file, this state remains till first
       //         section is found
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_LBRACE
       case 1:
           switch (Token.Type) {
              case TOK_EOL:
                  break;
              case TOK_EOF:
                  Done = TRUE;
                  break;
              case TOK_LBRACE:
                  State = 2;
                  break;
              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  break;
           }
           break;

       //
       // STATE 2: Section LBRACE has been received, expecting STRING
       //
       // Valid Tokens: TOK_STRING
       //
       case 2:
           switch (Token.Type) {
              case TOK_STRING:
                  State = 3;
                  pchSectionName = Token.pValue;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  break;

           }
           break;

       //
       // STATE 3: Section Name received, expecting RBRACE
       //
       // Valid Tokens: TOK_RBRACE
       //
       case 3:
           switch (Token.Type) {
              case TOK_RBRACE:
                State = 4;
                break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  break;
           }
           break;
       //
       // STATE 4: Section Definition Complete, expecting EOL
       //
       // Valid Tokens: TOK_EOL, TOK_EOF
       //
       case 4:
           switch (Token.Type) {
              case TOK_EOL:
                  if ((ErrorCode = DnAppendSection(pchSectionName)) != NO_ERROR)
                    Error = Done = TRUE;
                  else {
                    pchSectionName = NULL;
                    State = 5;
                  }
                  break;

              case TOK_EOF:
                  if ((ErrorCode = DnAppendSection(pchSectionName)) != NO_ERROR)
                    Error = Done = TRUE;
                  else {
                    pchSectionName = NULL;
                    Done = TRUE;
                  }
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  break;
           }
           break;

       //
       // STATE 5: Expecting Section Lines
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_STRING, TOK_LBRACE
       //
       case 5:
           switch (Token.Type) {
              case TOK_EOL:
                  break;
              case TOK_EOF:
                  Done = TRUE;
                  break;
              case TOK_STRING_ID:
                  IsStringId = TRUE;
              case TOK_STRING:
                  pchValue = Token.pValue;
                  State = 6;
                  break;
              case TOK_LBRACE:
                  State = 2;
                  break;
              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  break;
           }
           break;

       //
       // STATE 6: String returned, not sure whether it is key or value
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA, TOK_EQUAL
       //
       case 6:
           switch (Token.Type) {
              case TOK_EOL:
                  if ( (ErrorCode = DnAppendLine(NULL)) != NO_ERROR ||
                       (ErrorCode = DnAppendValue(pchValue,IsStringId)) !=NO_ERROR ) {
                      Error = Done = TRUE;
                  } else {
                      pchValue = NULL;
                      State = 5;
                  }
                  break;

              case TOK_EOF:
                  if ( (ErrorCode = DnAppendLine(NULL)) != NO_ERROR ||
                       (ErrorCode = DnAppendValue(pchValue,IsStringId)) !=NO_ERROR ) {
                      Error = Done = TRUE;
                  } else {
                      pchValue = NULL;
                      Done = TRUE;
                  }
                  break;

              case TOK_COMMA:
                  if ( (ErrorCode = DnAppendLine(NULL)) != NO_ERROR ||
                       (ErrorCode = DnAppendValue(pchValue,IsStringId)) !=NO_ERROR ) {
                      Error = Done = TRUE;
                  } else {
                      pchValue = NULL;
                      State = 7;
                  }
                  break;

              case TOK_EQUAL:
                  if ( (ErrorCode = DnAppendLine(pchValue)) !=NO_ERROR)
                      Error = Done = TRUE;
                  else {
                      pchValue = NULL;
                      State = 8;
                  }
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  break;
           }
           IsStringId = FALSE;
           break;

       //
       // STATE 7: Comma received, Expecting another string
       //
       // Valid Tokens: TOK_STRING, TOK_EOL, TOK_COMMA
       //
       case 7:
           switch (Token.Type) {
              case TOK_EOL:
                  //
                  // this is the end of the line, after a comma
                  //
                  State = 5;
                  //
                  // fall through
                  //
              case TOK_COMMA:
                  Token.pValue = DupString(TEXT(""));
                  if(!Token.pValue) {
                    Error = Done = TRUE;
                    ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                  } else {
                    ErrorCode = DnAppendValue(Token.pValue,FALSE);
                    if(ErrorCode != NO_ERROR) {
                      Error = Done = TRUE;
                    }
                  }
                  break;

              case TOK_STRING_ID:
                  IsStringId = TRUE;
              case TOK_STRING:
                  if ((ErrorCode = DnAppendValue(Token.pValue,IsStringId)) != NO_ERROR) {
                      Error = Done = TRUE;
                  } else {
                     State = 9;
                  }
                  IsStringId = FALSE;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  break;
           }
           break;
       //
       // STATE 8: Equal received, Expecting another string
       //
       // Valid Tokens: TOK_STRING TOK_EOL, TOK_EOF
       //
       case 8:
           switch (Token.Type) {
              case TOK_STRING_ID:
                  IsStringId = TRUE;
              case TOK_STRING:
                  if ((ErrorCode = DnAppendValue(Token.pValue,IsStringId)) != NO_ERROR) {
                      Error = Done = TRUE;
                  } else {
                      State = 9;
                  }
                  IsStringId = FALSE;
                  break;

              case TOK_EOL:
              case TOK_EOF:
                  Token.pValue = DupString(TEXT(""));
                  if(!Token.pValue) {
                    Error = Done = TRUE;
                    ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                  } else {
                    if ((ErrorCode = DnAppendValue(Token.pValue,FALSE)) != NO_ERROR) {
                      Error = Done = TRUE;
                    } else {
                      State = 5;
                    }
                  }

                  IsStringId = FALSE;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  break;
           }
           break;
       //
       // STATE 9: String received after equal, value string
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
       //
       case 9:
           switch (Token.Type) {
              case TOK_EOL:
                  State = 5;
                  break;

              case TOK_EOF:
                  Done = TRUE;
                  break;

              case TOK_COMMA:
                  State = 7;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  break;
           }
           break;
       //
       // STATE 10: Value string definitely received
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
       //
       case 10:
           switch (Token.Type) {
              case TOK_EOL:
                  State =5;
                  break;

              case TOK_EOF:
                  Done = TRUE;
                  break;

              case TOK_COMMA:
                  State = 7;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = ERROR_INVALID_DATA;
                  break;
           }
           break;

       default:
           Error = Done = TRUE;
           ErrorCode = ERROR_INVALID_DATA;
           break;

       } // end switch(State)


       if (Error) {

           UnloadInfFile(pINF);
           if(pchSectionName) {
               FREE(pchSectionName);
           }

           if(pchValue) {
               FREE(pchValue);
           }

           pINF = NULL;
       }
       else {

          //
          // Keep track of line numbers so that we can display Errors
          //

          if (Token.Type == TOK_EOL)
              InfLine++;
       }

    } // End while

    if(!Error) {
        ProcessStringSection( pINF );
        *Handle = pINF;
    }
    return(Error ? ErrorCode : NO_ERROR);
}



DWORD
DnAppendSection(
    IN PTSTR pSectionName
    )

/*++

Routine Description:

    This appends a new section to the section list in the current INF.
    All further lines and values pertain to this new section, so it resets
    the line list and value lists too.

Arguments:

    pSectionName - Name of the new section. ( [SectionName] )

Return Value:

    NO_ERROR - if successful.
    ERROR_INVALID_DATA   - if invalid parameters passed in or the INF buffer not
               initialised

--*/

{
    PSECTION pNewSection;

    //
    // See if we already have a section by this name. If so we want
    // to merge sections.
    //
    for(pNewSection=pINF->pSection; pNewSection; pNewSection=pNewSection->pNext) {
        if(pNewSection->pName && !lstrcmpi(pNewSection->pName,pSectionName)) {
            break;
        }
    }
    if(pNewSection) {
        //
        // Set pLineRecord to point to the list line currently in the section.
        //
        for(pLineRecord = pNewSection->pLine;
            pLineRecord && pLineRecord->pNext;
            pLineRecord = pLineRecord->pNext)
            ;
    } else {

        //
        // Allocate memory for the new section
        //

        pNewSection = MALLOC(sizeof(SECTION));
        if(!pNewSection) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // initialise the new section
        //
        pNewSection->pNext = NULL;
        pNewSection->pLine = NULL;
        pNewSection->pName = pSectionName;

        //
        // link it in
        //
        pNewSection->pNext = pINF->pSection;
        pINF->pSection = pNewSection;

        //
        // reset the current line record
        //
        pLineRecord = NULL;
    }

    pSectionRecord = pNewSection;
    pValueRecord   = NULL;

    return NO_ERROR;

}


DWORD
DnAppendLine(
    IN PTSTR pLineKey
    )

/*++

Routine Description:

    This appends a new line to the line list in the current section.
    All further values pertain to this new line, so it resets
    the value list too.

Arguments:

    pLineKey - Key to be used for the current line, this could be NULL.

Return Value:

    NO_ERROR - if successful.
    ERROR_INVALID_DATA   - if invalid parameters passed in or current section not
               initialised


--*/


{
    PLINE pNewLine;

    //
    // Allocate memory for the new Line
    //
    pNewLine = MALLOC(sizeof(LINE));
    if(!pNewLine) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Link it in
    //
    pNewLine->pNext  = NULL;
    pNewLine->pValue = NULL;
    pNewLine->pName  = pLineKey;

    if (pLineRecord == NULL) {
        pSectionRecord->pLine = pNewLine;
    }
    else {
        pLineRecord->pNext = pNewLine;
    }

    pLineRecord  = pNewLine;

    //
    // Reset the current value record
    //

    pValueRecord = NULL;

    return NO_ERROR;
}



DWORD
DnAppendValue(
    IN PTSTR pValueString,
    IN BOOL IsStringId
    )

/*++

Routine Description:

    This appends a new value to the value list in the current line.

Arguments:

    pValueString - The value string to be added.

Return Value:

    NO_ERROR - if successful.
    ERROR_INVALID_DATA   - if invalid parameters passed in or current line not
               initialised.

--*/

{
    PXVALUE pNewValue;

    //
    // Allocate memory for the new value record
    //
    pNewValue = MALLOC(sizeof(XVALUE));
    if(!pNewValue) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Link it in.
    //

    pNewValue->pNext       = NULL;
    pNewValue->pName       = pValueString;
    pNewValue->IsStringId  = IsStringId;

    if (pValueRecord == NULL)
        pLineRecord->pValue = pNewValue;
    else
        pValueRecord->pNext = pNewValue;

    pValueRecord = pNewValue;
    return NO_ERROR;
}

TOKEN
DnGetToken(
    IN OUT PTSTR *Stream,
    IN PTSTR      MaxStream
    )

/*++

Routine Description:

    This function returns the Next token from the configuration stream.

Arguments:

    Stream - Supplies the address of the configuration stream.  Returns
        the address of where to start looking for tokens within the
        stream.

    MaxStream - Supplies the address of the last character in the stream.


Return Value:

    TOKEN - Returns the next token

--*/

{

    PTSTR pch, pchStart, pchNew;
    unsigned  Length;
    TOKEN Token;

    //
    //  Skip whitespace (except for eol)
    //

    pch = *Stream;
    while (pch < MaxStream && *pch != TEXT('\n') && (ISSPACE(*pch) || (*pch == TEXT('\032'))))
        pch++;


    //
    // Check for comments and remove them
    //

    if (pch < MaxStream &&
        ((*pch == TEXT(';')) || (*pch == TEXT('#'))
            || (*pch == TEXT('/') && pch+1 < MaxStream && *(pch+1) == TEXT('/'))))
        while (pch < MaxStream && *pch != TEXT('\n'))
            pch++;

    //
    // Check to see if EOF has been reached, set the token to the right
    // value
    //

    if ( pch >= MaxStream ) {
        *Stream = pch;
        Token.Type  = TOK_EOF;
        Token.pValue = NULL;
        return Token;
    }


    switch (*pch) {

    case TEXT('[') :
        pch++;
        Token.Type  = TOK_LBRACE;
        Token.pValue = NULL;
        break;

    case TEXT(']') :
        pch++;
        Token.Type  = TOK_RBRACE;
        Token.pValue = NULL;
        break;

    case TEXT('=') :
        pch++;
        Token.Type  = TOK_EQUAL;
        Token.pValue = NULL;
        break;

    case TEXT(',') :
        pch++;
        Token.Type  = TOK_COMMA;
        Token.pValue = NULL;
        break;

    case TEXT('\n') :
        pch++;
        Token.Type  = TOK_EOL;
        Token.pValue = NULL;
        break;

    case TEXT('%'):
        pch++;
        //
        // determine percented string
        //
        pchStart = pch;
        while (pch < MaxStream && !IsQStringTerminator(*pch,TEXT('%'))) {
            pch++;
        }

        if (pch >=MaxStream || *pch != TEXT('%')) {
            Token.Type   = TOK_ERRPARSE;
            Token.pValue = NULL;
        }
        else {
            Length = (unsigned)((PUCHAR)pch - (PUCHAR)pchStart);
            if(pchNew = MALLOC(Length + sizeof(TCHAR))){
                Length /= sizeof(TCHAR);
                lstrcpyn(pchNew,pchStart,Length+1);
                pchNew[Length] = 0;
                Token.Type = TOK_STRING_ID;
                Token.pValue = pchNew;
                pch++;   // advance past the percent
            }else{
                Token.Type   = TOK_ERRNOMEM;
                Token.pValue = NULL;
            }



        }
        break;

    case TEXT('\"'):
        pch++;
        //
        // determine quoted string
        //
        pchStart = pch;
        while (pch < MaxStream && !IsQStringTerminator(*pch,TEXT('\"'))) {
            pch++;
        }

        if (pch >=MaxStream || *pch != TEXT('\"')) {
            Token.Type   = TOK_ERRPARSE;
            Token.pValue = NULL;
        }
        else {
            Length = (unsigned)((PUCHAR)pch - (PUCHAR)pchStart);
            if( pchNew = MALLOC(Length + sizeof(TCHAR))){
                Length /= sizeof(TCHAR);
                lstrcpyn(pchNew,pchStart,Length+1);
                pchNew[Length] = 0;
                Token.Type = TOK_STRING;
                Token.pValue = pchNew;
                pch++;   // advance past the quote
            }else{
                Token.Type   = TOK_ERRNOMEM;
                Token.pValue = NULL;
            }


        }
        break;

    default:
        //
        // determine regular string
        //
        pchStart = pch;
        while (pch < MaxStream && !IsStringTerminator(*pch))
            pch++;

        if (pch == pchStart) {
            pch++;
            Token.Type  = TOK_ERRPARSE;
            Token.pValue = NULL;
        }
        else {
            Length = (unsigned)((PUCHAR)pch - (PUCHAR)pchStart);
            if( pchNew = MALLOC(Length + sizeof(TCHAR)) ){
                Length /= sizeof(TCHAR);
                lstrcpyn(pchNew,pchStart,Length+1);
                pchNew[Length] = 0;
                Token.Type = TOK_STRING;
                Token.pValue = pchNew;
            }else{
                Token.Type   = TOK_ERRNOMEM;
                Token.pValue = NULL;
            }

        }
        break;
    }

    *Stream = pch;
    return (Token);
}



BOOL
IsStringTerminator(
    TCHAR ch
    )
/*++

Routine Description:

    This routine tests whether the given character terminates a quoted
    string.

Arguments:

    ch - The current character.

Return Value:

    TRUE if the character is a quoted string terminator, FALSE otherwise.

--*/

{
    unsigned i;

    //
    // one of the string terminator array
    //

    for (i = 0; i < NumberOfTerminators; i++) {
        if (ch == StringTerminators[i]) {
            return (TRUE);
        }
    }

    return FALSE;
}



BOOL
IsQStringTerminator(
    TCHAR ch,
    TCHAR term
    )

/*++

Routine Description:

    This routine tests whether the given character terminates a quoted
    string.

Arguments:

    ch - The current character.


Return Value:

    TRUE if the character is a quoted string terminator, FALSE otherwise.


--*/


{
    unsigned i;
    //
    // one of quoted string terminators array
    //
    for (i = 0; i < QNumberOfTerminators; i++) {

        if (ch == QStringTerminators[i] || ch == term) {
            return (TRUE);
        }
    }

    return FALSE;
}


typedef struct _STRING_ENTRY {
    LPCTSTR     StringId;
    LPCTSTR     StringValue;
} STRING_ENTRY, *PSTRING_ENTRY;

BOOL
ProcessStringSection(
    PINF pINF
    )

/*++

Routine Description:

    This routine processes the strings sections on the
    specified inf file.  The processing scans all values
    in the inf and replaces any string ids that are
    referenced.

Arguments:

    pINF - pointer to the specified inf structure

Return Value:

    TRUE if the strings section is processed properly

--*/

{
    PSTRING_ENTRY StringTable;
    DWORD StringTableCount;
    DWORD LineCount;
    DWORD i;
    LPCTSTR StringId;
    LPCTSTR StringValue;
    PSECTION pSection;
    PLINE pLine;
    PXVALUE pValue;


    LineCount = InfGetSectionLineCount( pINF, TEXT("Strings") );
    if (LineCount == 0 || LineCount == 0xffffffff) {
        return FALSE;
    }

    StringTable = (PSTRING_ENTRY) MALLOC( LineCount * sizeof(STRING_ENTRY) );
    if (StringTable == NULL) {
        return FALSE;
    }

    StringTableCount = 0;

    for (i=0; i<LineCount; i++) {
        StringId = InfGetLineKeyName( pINF, TEXT("Strings"), i );
        StringValue = InfGetFieldByIndex( pINF, TEXT("Strings"), i, 0 );
        if (StringId && StringValue) {
            StringTable[i].StringId = StringId;
            StringTable[i].StringValue = StringValue;
            StringTableCount += 1;
        }
    }

    pSection = pINF->pSection;
    while(pSection) {
        pLine = pSection->pLine;
        while(pLine) {
            pValue = pLine->pValue;
            while(pValue) {
                if (pValue->IsStringId) {
                    for (i=0; i<StringTableCount; i++) {
                        if (_tcsicmp( StringTable[i].StringId, pValue->pName ) == 0) {
                            FREE(pValue->pName);
                            pValue->pName = DupString( (PTSTR)StringTable[i].StringValue );
                            break;
                        }
                    }
                }
                pValue = pValue->pNext;
            }
            pLine = pLine->pNext;
        }
        pSection = pSection->pNext;
    }

    FREE( StringTable );

    return TRUE;
}


BOOL
EnumFirstInfLine (
    OUT     PINF_ENUM InfEnum,
    IN      PVOID InfHandle,
    IN      PCTSTR InfSection
    )
{
    ZeroMemory (InfEnum, sizeof (INF_ENUM));
    InfEnum->SectionName = DupString (InfSection);
    InfEnum->InfHandle = InfHandle;
    InfEnum->LineIndex = (unsigned) -1;

    return EnumNextInfLine (InfEnum);
}


BOOL
EnumNextInfLine (
    IN OUT  PINF_ENUM InfEnum
    )
{
    if (!InfEnum->InfHandle) {
        return FALSE;
    }

    if (!InfEnum->SectionName) {
        return FALSE;
    }

    InfEnum->LineIndex++;

    InfEnum->FieldZeroData = InfGetFieldByIndex (
                                InfEnum->InfHandle,
                                InfEnum->SectionName,
                                InfEnum->LineIndex,
                                0
                                );

    if (!InfEnum->FieldZeroData) {
        AbortInfLineEnum (InfEnum);
        return FALSE;
    }

    return TRUE;
}


VOID
AbortInfLineEnum (
    IN      PINF_ENUM InfEnum           // ZEROED
    )
{
    if (InfEnum->SectionName) {
        FREE ((PVOID) InfEnum->SectionName);
    }

    ZeroMemory (InfEnum, sizeof (INF_ENUM));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\inspect.c ===
#include "precomp.h"
#pragma hdrstop

#include <stdio.h>


BOOL
LoadInfs(
    IN HWND hdlg
    );

BOOL
BuildCopyList(
    IN HWND hdlg
    );



BOOL
LoadAndRunMigrationDlls (
    HWND hDlg
    );


BOOL
ProcessCompatibilityData(
    HWND hDlg
    );

DWORD
ProcessCompatibilitySection(
    LPVOID InfHandle,
    LPTSTR SectionName
    );


DWORD
InspectAndLoadThread(
    IN PVOID ThreadParam
    )
{
    HWND hdlg;
    BOOL b;

    //
    // Thread parameter is the handle of the page in the wizard.
    //
    hdlg = ThreadParam;
    b = FALSE;

    //
    // If we're running the upgrade checker, fixup the title
    // right away.
    //
    if (CheckUpgradeOnly) {
        FixUpWizardTitle(GetParent(hdlg));
        PropSheet_SetTitle(GetParent(hdlg),0,UIntToPtr( IDS_APPTITLE_CHECKUPGRADE ));
    }

    //
    // Step 1: delete existing local sources.
    //
    CleanUpOldLocalSources(hdlg);

#ifdef _X86_ //NEC98
    //
    // If NEC98, Backup NT4 files
    // boot.ini, NTLDR, NTDETECT
    //
    if (IsNEC98() && Floppyless)
    {
        SaveRestoreBootFiles_NEC98(NEC98SAVEBOOTFILES);
    }
#endif //NEC98

    //
    // Step 2: inspect for HPFS, etc.
    //
    if(!InspectFilesystems(hdlg)) {
        Cancelled = TRUE;
    } else {

        //
        // Step 3: load inf(s).
        //
        if(LoadInfs(hdlg)) {

            //
            // Put in an "|| CheckUpgradeOnly" on these
            // function calls because if we're really only
            // checking the ability to upgrade, we want
            // to continue even if one of these guys fails.
            //

            //
            // Step 4: Check memory resources.
            //
            if( EnoughMemory( hdlg, FALSE ) || CheckUpgradeOnly ) {

                //
                // check for services to disable
                //
                ProcessCompatibilityData(hdlg);

#if defined(UNICODE) && defined(_X86_)

                //
                // Run Migration DLLs.
                //
                LoadAndRunMigrationDlls (hdlg);


#endif

                //
                // migrate any important data in boot.ini (like the countdown)
                //
                if (Upgrade) {
                    if (IsArc()) {
                        MigrateBootVarData();
                    } else {
#ifdef _X86_
                        MigrateBootIniData();
#endif
                    }
                }

                //
                // Step 5: build the master file copy list.
                //
                if(CheckUpgradeOnly || BuildCopyList(hdlg)) {

                    //
                    // Step 6: look for a valid local source and check disk space.
                    //
                    if(FindLocalSourceAndCheckSpace(hdlg, FALSE, 0) || CheckUpgradeOnly) {

                        //
                        // Step 7:
                        //
                        // At this point we actually know everything we need to know
                        // in order to pass parameters to text mode setup.
                        //
                        if( CheckUpgradeOnly ) {
                            b = TRUE;
                        } else {
                            b = WriteParametersFile(hdlg);

                            if (IsArc()) {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
                                if(b) {
                                    TCHAR Text[128];

                                    LoadString(hInst,IDS_SETTING_NVRAM,Text,sizeof(Text)/sizeof(TCHAR));
                                    SendMessage(hdlg,WMX_SETPROGRESSTEXT,0,(LPARAM)Text);

                                    b = SetUpNvRam(hdlg);
                                }
#endif // UNICODE
                            } // if (IsArc())
                        }

#ifdef UNICODE

                        if( b && Upgrade
#ifdef _X86_
                            && Floppyless
#endif
                          ) {
                            //
                            //  Do the migration of unsupported NT drivers.
                            //  We can ignore the return code, since the fuction will inform the user if
                            //  migration could not be done.
                            //
                            MigrateUnsupportedNTDrivers( hdlg, TxtsetupSif );
                        }
#endif // UNICODE
                    }
                }

                if(!b) {
                    UnloadInfFile(MainInf);
                    MainInf = NULL;
                    if(TxtsetupSif) {
                        UnloadInfFile(TxtsetupSif);
                        TxtsetupSif = NULL;
                    }
                }
            }
        }
    }

    PostMessage(hdlg,WMX_INSPECTRESULT,(CheckUpgradeOnly ? TRUE : b),0);
    return(0);
}

#if defined(UNICODE) && defined(_X86_)

LIST_ENTRY g_HandledData;
TCHAR g_MigDllAnswerFilePath[MAX_PATH];
DWORD GlobalCompFlags;
UINT g_MigDllIndex = 0;


#define HANDLED_REGISTRY  1
#define HANDLED_FILE  2
#define HANDLED_SERVICE  3

typedef struct {

    LIST_ENTRY ListEntry;

    LONG Type;

    PCTSTR RegKey;
    PCTSTR RegValue;
    PCTSTR File;
    PCTSTR Service;

} HANDLED_DATA, *PHANDLED_DATA;


BOOL
ResolveHandledIncompatibilities (
    VOID
    )
{
    //
    // At this point, all incompatibilities that will exist in the list are in place.
    // we can now compare this with our list of handled data and remove
    // anything a migration dll is taking care of.
    //
    PLIST_ENTRY     nextHandled;
    PLIST_ENTRY     nextCompData;
    PHANDLED_DATA   handledData;
    PCOMPATIBILITY_DATA compData;
    BOOL remove;

    nextHandled = g_HandledData.Flink;

    if (!nextHandled) {
        return TRUE;
    }

    while ((ULONG_PTR)nextHandled != (ULONG_PTR)&g_HandledData) {

        handledData = CONTAINING_RECORD (nextHandled, HANDLED_DATA, ListEntry);
        nextHandled = handledData->ListEntry.Flink;

        nextCompData = CompatibilityData.Flink;
        if (!nextCompData) {
            return TRUE;
        }

        while ((ULONG_PTR)nextCompData != (ULONG_PTR)&CompatibilityData) {

            compData = CONTAINING_RECORD (nextCompData, COMPATIBILITY_DATA, ListEntry);
            nextCompData = compData->ListEntry.Flink;
            remove = FALSE;

            if (handledData->Type == HANDLED_REGISTRY && compData->RegKey && *compData->RegKey) {

                if (!lstrcmpi (compData->RegKey, handledData->RegKey)) {

                    if (!handledData->RegValue || !lstrcmpi (compData->RegValue, handledData->RegValue)) {
                        remove = TRUE;

                    }
                }
            }

            if (handledData->Type == HANDLED_SERVICE && compData->ServiceName && *compData->ServiceName) {

                if (!lstrcmpi (compData->ServiceName, handledData->Service)) {
                    remove = TRUE;

                }
            }

            if (handledData->Type == HANDLED_FILE && compData->FileName && *compData->FileName) {

                if (!lstrcmpi (compData->FileName, handledData->File)) {
                    remove = TRUE;
                }
            }

            //
            // Migration dll has handled something. Remove it from the compatibility list.
            //
            if (remove) {

                RemoveEntryList (&compData->ListEntry);
            }
        }
    }

    return TRUE;
}


BOOL
CallMigDllEntryPoints (
    PMIGDLLENUM Enum
    )
{
    MIGRATIONDLL dll;
    LONG rc;

    if (!MigDllOpen (&dll, Enum->Properties->DllPath, GATHERMODE, FALSE, SOURCEOS_WINNT)) {
        return FALSE;
    }


    __try {

        rc = ERROR_SUCCESS;
        if (!MigDllInitializeSrc (
            &dll,
            Enum->Properties->WorkingDirectory,
            NativeSourcePaths[0],
            Enum->Properties->SourceMedia,
            NULL,
            0
            )) {

            rc = GetLastError ();
        }

        if (rc != ERROR_SUCCESS) {
            return FALSE;
        }

        if (!MigDllGatherSystemSettings (
            &dll,
            g_MigDllAnswerFilePath,
            NULL,
            0
            )) {

            rc = GetLastError ();
        }

        if (rc != ERROR_SUCCESS) {
            return FALSE;
        }

    }
    __finally {
        MigDllClose (&dll);
    }


    return TRUE;
}



BOOL
ParseMigrateInf (
    PCWSTR MigInfPath
    )
{

    PVOID migInf = NULL;
    LONG lineCount;
    LONG i;
    PCTSTR type;
    PHANDLED_DATA data;
    PCTSTR regKey;
    PCTSTR regValue;
    PCTSTR file;
    PCTSTR service;


    if (LoadInfFile (MigInfPath, FALSE, &migInf) != ERROR_SUCCESS) {
        return FALSE;
    }




    __try {

        //
        // Add any compatibility items to the list.
        //
        if( !CompatibilityData.Flink ) {
            InitializeListHead( &CompatibilityData );
        }

        GlobalCompFlags = COMPFLAG_STOPINSTALL;
        CompatibilityCount += ProcessCompatibilitySection (migInf, TEXT("ServicesToStopInstallation") );
        if (CompatibilityCount) {
            IncompatibilityStopsInstallation = TRUE;
        }

        GlobalCompFlags = 0;
        CompatibilityCount += ProcessCompatibilitySection (migInf, TEXT("ServicesToDisable") );

        //
        // Add Handled compatibility items to the list.
        //

        lineCount = InfGetSectionLineCount (migInf, TEXT("Handled"));

        if (lineCount && lineCount != -1) {

            for (i=0; i < lineCount; i++) {

                type = InfGetFieldByIndex (migInf, TEXT("Handled"), i, 0);
                if (!type) {
                    continue;
                }

                if (!lstrcmpi (type, TEXT("Registry"))) {

                    regKey = InfGetFieldByIndex (migInf, TEXT("Handled"), i, 1);
                    regValue = InfGetFieldByIndex (migInf, TEXT("Handled"), i, 2);

                    if (regKey && *regKey) {

                        data = (PHANDLED_DATA) MALLOC (sizeof(HANDLED_DATA));
                        if (data == NULL) {
                            return FALSE;
                        }

                        ZeroMemory (data, sizeof (HANDLED_DATA));

                        data->Type = HANDLED_REGISTRY;
                        data->RegKey = regKey;
                        data->RegValue = regValue;

                        InsertTailList (&g_HandledData, &data->ListEntry);
                    }
                }
                else if (!lstrcmpi (type, TEXT("File"))) {

                    file = InfGetFieldByIndex (migInf, TEXT("Handled"), i, 1);
                    if (file && *file) {

                        data = (PHANDLED_DATA) MALLOC (sizeof(HANDLED_DATA));
                        if (data == NULL) {
                            return FALSE;
                        }

                        ZeroMemory (data, sizeof (HANDLED_DATA));

                        data->Type = HANDLED_FILE;
                        data->File = file;

                        InsertTailList (&g_HandledData, &data->ListEntry);
                    }
                }
                else if (!lstrcmpi (type, TEXT("Service"))) {

                    service = InfGetFieldByIndex (migInf, TEXT("Handled"), i, 1);
                    if (service && *service) {

                        data = (PHANDLED_DATA) MALLOC (sizeof(HANDLED_DATA));
                        if (data == NULL) {
                            return FALSE;
                        }

                        ZeroMemory (data, sizeof (HANDLED_DATA));

                        data->Type = HANDLED_SERVICE;
                        data->Service = service;

                        InsertTailList (&g_HandledData, &data->ListEntry);
                    }
                }
            }
        }
    }
    __finally {

        UnloadInfFile (migInf);

    }

    return TRUE;
}

VOID
SearchDirForMigDlls (
    PCTSTR SearchDir,
    PCTSTR BaseDir,
    DLLLIST List

    )
{
    HANDLE findHandle;
    WIN32_FIND_DATA findData;
    MIGRATIONDLL dll;
    WCHAR path[MAX_PATH];
    PWSTR p;
    WCHAR searchPath[MAX_PATH];
    PMIGRATIONINFO migInfo;
    PMIGDLLPROPERTIES dllProps = NULL;
    WCHAR workingDir[MAX_PATH];

    lstrcpy (searchPath, SearchDir);
    ConcatenatePaths (searchPath, TEXT("*"), MAX_PATH);

    findHandle = FindFirstFile (searchPath, &findData);
    if (findHandle != INVALID_HANDLE_VALUE) {

        lstrcpy (path, SearchDir);
        p = _tcschr (path, 0);
        if (p) {

            do {

                if (!lstrcmpi (findData.cFileName, TEXT("migrate.dll"))) {

                    *p = 0;
                    ConcatenatePaths (path, findData.cFileName, MAX_PATH);


                    if (!MigDllOpen (&dll, path, GATHERMODE, FALSE, SOURCEOS_WINNT)) {
                        continue;
                    }

                    if (!MigDllQueryMigrationInfo (&dll, TEXT("c:\\"), &migInfo)) {
                        MigDllClose (&dll);
                        continue;
                    }

                    if (migInfo->SourceOs == OS_WINDOWS9X || migInfo->TargetOs != OS_WINDOWSWHISTLER) {
                        continue;
                    }

                    //
                    // Do we already have a version of this migration dll?
                    //
                    dllProps = MigDllFindDllInList (List, migInfo->StaticProductIdentifier);

                    if (dllProps && dllProps->Info.DllVersion >= migInfo->DllVersion) {
                        MigDllClose (&dll);
                        continue;
                    }
                    else if (dllProps) {

                        MigDllRemoveDllFromList (List, migInfo->StaticProductIdentifier);
                    }

                    //
                    // Move dll locally.
                    //
                    wsprintf (workingDir, TEXT("%s\\mig%u"), BaseDir, g_MigDllIndex);
                    g_MigDllIndex++;

                    MigDllMoveDllLocally (&dll, workingDir);



                    //
                    // Add the dll to the list.
                    //
                    MigDllAddDllToList (List, &dll);
                    MigDllClose (&dll);
                }
                else if ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && *findData.cFileName != TEXT('.')) {

                    *p = 0;
                    ConcatenatePaths (path, findData.cFileName, MAX_PATH);
                    SearchDirForMigDlls (path, BaseDir, List);
                }

            } while (FindNextFile (findHandle, &findData));
        }

        FindClose (findHandle);
    }
}

#endif // UNICODE

#if defined(UNICODE) && defined(_X86_)

BOOL
LoadAndRunMigrationDlls (
    HWND hDlg
    )
{
    HKEY regKey = NULL;
    DWORD index;
    DWORD nameSize;
    DWORD valueSize;
    DWORD type;
    TCHAR valueName[MAX_PATH];
    TCHAR value[MAX_PATH];
    TCHAR baseDir[MAX_PATH];
    TCHAR workingDir[MAX_PATH];
    PTSTR p;
    LONG rc;
    DLLLIST list = NULL;
    MIGRATIONDLL dll;
    PMIGDLLPROPERTIES dllProps = NULL;
    MIGDLLENUM e;
    PMIGRATIONINFO migInfo;
    TCHAR migInfPath[MAX_PATH];
    HANDLE migInf;
    TCHAR searchDir[MAX_PATH];
    TCHAR tempDir[MAX_PATH];

    *g_MigDllAnswerFilePath = 0;

    //
    // NT Upgrades only.
    //
    if (!ISNT() || !Upgrade) {
        return TRUE;
    }

/*NTBUG9:394164
    //
    // Win2k > Upgrades only.
    //
    if (BuildNumber <= NT40) {
        return TRUE;
    }
*/
    __try {

        if (!MigDllInit ()) {
            return TRUE;
        }

        list = MigDllCreateList ();
        if (!list) {
            return TRUE;
        }

        InitializeListHead (&g_HandledData);

        MyGetWindowsDirectory (baseDir, MAX_PATH);
        ConcatenatePaths (baseDir, TEXT("Setup"), MAX_PATH);
        lstrcpy (g_MigDllAnswerFilePath, baseDir);
        lstrcpy (tempDir, baseDir);
        ConcatenatePaths (g_MigDllAnswerFilePath, TEXT("migdll.txt"), MAX_PATH);
        if(ActualParamFile[0]){
            CopyFile(ActualParamFile, g_MigDllAnswerFilePath, FALSE);
        }

        //
        // Scan registry for migration dlls and load them.
        //
        if (RegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                S_REGKEY_MIGRATION_DLLS_WINNT,
                0,
                KEY_READ | KEY_WRITE,
                &regKey
                ) == ERROR_SUCCESS) {
            //
            // Enumerate Values.
            //
            index = 0;
            do {

                nameSize = MAX_PATH;
                valueSize = MAX_PATH * sizeof (TCHAR);

                rc = RegEnumValue (
                            regKey,
                            index,
                            valueName,
                            &nameSize,
                            NULL,
                            &type,
                            (PBYTE) value,
                            &valueSize
                            );

                index++;

                if (rc == ERROR_MORE_DATA) {
                    continue;
                }

                if (rc == ERROR_NO_MORE_ITEMS) {
                    break;
                }

                if (rc != ERROR_SUCCESS) {
                    return TRUE;
                }

                if (!MigDllOpen (&dll, value, GATHERMODE, FALSE, SOURCEOS_WINNT)) {
                    continue;
                }

                if (!MigDllQueryMigrationInfo (&dll, tempDir, &migInfo)) {
                    MigDllClose (&dll);
                    continue;
                }

                if (migInfo->SourceOs == OS_WINDOWS9X || migInfo->TargetOs != OS_WINDOWSWHISTLER) {
                    continue;
                }

                //
                // Do we already have a version of this migration dll?
                //
                dllProps = MigDllFindDllInList (list, migInfo->StaticProductIdentifier);

                if (dllProps && dllProps->Info.DllVersion >= migInfo->DllVersion) {
                    MigDllClose (&dll);
                    continue;
                }
                else {

                    MigDllRemoveDllFromList (list, migInfo->StaticProductIdentifier);
                }

                //
                // Move dll locally.
                //
                wsprintf (workingDir, TEXT("%s\\mig%u"), baseDir, g_MigDllIndex);
                g_MigDllIndex++;

                MigDllMoveDllLocally (&dll, workingDir);
                //
                // Add the dll to the list.
                //
                MigDllAddDllToList (list, &dll);
                MigDllClose (&dll);

            } while (1);
        }

        //
        // Now, look for dlls shipped with the source.
        //
        GetModuleFileName (NULL, searchDir, MAX_PATH);
        p = _tcsrchr (searchDir, TEXT('\\'));
        if (p) {
            p++;
            lstrcpy (p, TEXT("WINNTMIG"));
        }

        SearchDirForMigDlls (searchDir, baseDir, list);

        //
        // All dlls are now in the list. Lets run them.
        //
        ConcatenatePaths (baseDir, TEXT("dlls.inf"), MAX_PATH);
        if (MigDllEnumFirst (&e, list)) {

            WritePrivateProfileString (
                TEXT("Version"),
                TEXT("Signature"),
                TEXT("\"$Windows NT$\""),
                baseDir
                );

            do {

                wsprintf (migInfPath, TEXT("%s\\migrate.inf"), e.Properties->WorkingDirectory);
                migInf = CreateFile (
                            migInfPath,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );

                if (migInf == INVALID_HANDLE_VALUE) {
                    continue;
                }

                CloseHandle (migInf);

                WritePrivateProfileString (
                    TEXT("Version"),
                    TEXT("Signature"),
                    TEXT("\"$Windows NT$\""),
                    migInfPath
                    );


                if (!CallMigDllEntryPoints (&e)) {
                    MigDllRemoveDllInEnumFromList (list, &e);
                }
                else {

                    ParseMigrateInf (migInfPath);

                    WritePrivateProfileString (
                        TEXT("DllsToLoad"),
                        e.Properties->Info.StaticProductIdentifier,
                        e.Properties->DllPath,
                        baseDir
                        );
                }

            } while (MigDllEnumNext (&e));

            WritePrivateProfileString (NULL, NULL, NULL, baseDir);


            //
            // Get rid of compatibility messages handled by migration dlls.
            //
            ResolveHandledIncompatibilities ();
        }
    }
    __finally {

        if (regKey) {
            RegCloseKey (regKey);
        }

        if (list) {
            MigDllFreeList (list);
        }


    }

    return TRUE;
}

#endif


VOID
CleanUpOldLocalSources(
    IN HWND hdlg
    )

/*++

Routine Description:

    Locate and delete old local source trees. All local fixed drives
    are scanned for \$win_nt$.~ls, and if present, delnoded.
    On x86, we also check the system partition for \$win_nt$.~bt
    and give it the same treatment.

Arguments:

Return Value:

--*/

{
    TCHAR Drive;
    TCHAR Text[250];
    TCHAR Filename[128];

    LoadString(hInst,IDS_INSPECTING,Text,sizeof(Text)/sizeof(TCHAR));
    SendMessage(hdlg,WMX_SETPROGRESSTEXT,0,(LPARAM)Text);

    for(Drive=TEXT('A'); Drive<=TEXT('Z'); Drive++) {
        if(MyGetDriveType(Drive) != DRIVE_FIXED) {
            continue;
        }

        Filename[0] = Drive;
        Filename[1] = TEXT(':');
        Filename[2] = 0;
        ConcatenatePaths(Filename,LOCAL_SOURCE_DIR,sizeof(Filename)/sizeof(TCHAR));

        if(FileExists(Filename, NULL)) {

            LoadString(hInst,IDS_REMOVING_OLD_TEMPFILES,Text,sizeof(Text)/sizeof(TCHAR));
            SendMessage(hdlg,WMX_SETPROGRESSTEXT,0,(LPARAM)Text);

            MyDelnode(Filename);

            LoadString(hInst,IDS_INSPECTING,Text,sizeof(Text)/sizeof(TCHAR));
            SendMessage(hdlg,WMX_SETPROGRESSTEXT,0,(LPARAM)Text);
        }
    }

    if (!IsArc()) {
#ifdef _X86_
        MYASSERT (SystemPartitionDriveLetter);
        Filename[0] = SystemPartitionDriveLetter;
        Filename[1] = TEXT(':');
        Filename[2] = TEXT('\\');
        lstrcpy(Filename+3,LOCAL_BOOT_DIR);

        LoadString(hInst,IDS_REMOVING_OLD_TEMPFILES,Text,sizeof(Text)/sizeof(TCHAR));
        SendMessage(hdlg,WMX_SETPROGRESSTEXT,0,(LPARAM)Text);

        MyDelnode(Filename);

        //
        // Clean up backup directory, if it exists.
        //
        if(IsNEC98() && Floppyless) {

            Filename[0] = SystemPartitionDriveLetter;
            Filename[1] = TEXT(':');
            Filename[2] = TEXT('\\');
            lstrcpy(Filename+3,LOCAL_BACKUP_DIR);

            MyDelnode(Filename);
        }
#endif // _X86_
    } // if (!IsArc())
}


BOOL
InspectSources(
    HWND ParentWnd
    )

/*++

Routine Description:

    Check all sources given to ensure that they contain a valid
    windows NT distribution. We do this simply by looking for
    DOSNET.INF on each source.

Arguments:

    ParentWnd - Specifies the handle of the parent window for any
                error messages.

Return Value:

    None.

--*/

{
    UINT i,j;
    TCHAR Filename[MAX_PATH];
    TCHAR Text[512];
    UINT OriginalCount;
    HCURSOR OldCursor;
    BOOL b = TRUE;

    OldCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));

    OriginalCount = SourceCount;

    //
    // if we have a good alternate path then there
    // is no need to verify the source paths
    //

    if (AlternateSourcePath[0]) {
        lstrcpy(Filename,AlternateSourcePath);
        ConcatenatePaths(Filename,InfName,MAX_PATH);
        if(FileExists (Filename, NULL)) {
            SetCursor (OldCursor);
            return TRUE;
        }
    }

    //
    // verify each path
    //

    for (i=0; i<SourceCount; ) {

        lstrcpy(Filename,NativeSourcePaths[i]);
        ConcatenatePaths(Filename,InfName,MAX_PATH);

        if(!FileExists (Filename, NULL)) {
            //
            // Source doesn't exist or isn't valid.
            // Adjust the list.
            //
            for(j=i+1; j<SourceCount; j++) {
                lstrcpy(NativeSourcePaths[j-1],NativeSourcePaths[j]);
                lstrcpy(SourcePaths[j-1],SourcePaths[j]);
            }
            SourceCount--;
        } else {
            i++;
        }
    }

    if (!SourceCount) {

        //
        // No sources are valid.
        //

        MessageBoxFromMessage(
            ParentWnd,
            (OriginalCount == 1) ? MSG_INVALID_SOURCE : MSG_INVALID_SOURCES,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONWARNING | MB_TASKMODAL,
            NativeSourcePaths[0]
            );

        //
        // Set it to look like one source that is the empty string,
        // so logic elsewhere will work correctly without special casing.
        //
        SourceCount = 1;
        NativeSourcePaths[0][0] = 0;
        SourcePaths[0][0] = 0;
        b = FALSE;
    }

    SetCursor (OldCursor);

    return b;
}


BOOL
LoadInfs(
    IN HWND hdlg
    )

/*++

Routine Description:

    Load dosnet.inf from source 0. If upgrading and we're running
    on NT then also load txtsetup.sif. If running on NT, load ntcompat.inf

Arguments:

    hdlg - supplies handle of dialog to which progress messages
        should be directed.

Return Value:

    Boolean value indicating outcome. If FALSE then the user
    will have been informed.

--*/

{
    BOOL b;
    LPCTSTR p;
    TCHAR szPath[MAX_PATH];

    if (!MainInf) {
        b = LoadInfWorker(hdlg,InfName,&MainInf, TRUE);
        if(!b) {
            MessageBoxFromMessage(
                NULL,
                MSG_INVALID_INF_FILE,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONINFORMATION | MB_TASKMODAL,
                InfName
                );
            DebugLog( Winnt32LogError, TEXT("ERROR: Could not load dosnet.inf!"), 0);
            goto c0;
        }
    } else {
        b = TRUE;
    }

    if(p = InfGetFieldByKey(MainInf,TEXT("Miscellaneous"),TEXT("ProductType"),0)) {
        ProductFlavor = _tcstoul(p,NULL,10);

        Server = (ProductFlavor != PROFESSIONAL_PRODUCTTYPE && ProductFlavor != PERSONAL_PRODUCTTYPE);
        UpgradeProductType = Server ? NT_SERVER : NT_WORKSTATION;

        if( CheckUpgradeOnly ) {
            AppTitleStringId = IDS_APPTITLE_CHECKUPGRADE;
        } else if( ProductFlavor == PROFESSIONAL_PRODUCTTYPE ) {
            AppTitleStringId = IDS_APPTITLE_WKS;
        } else if( ProductFlavor == SERVER_PRODUCTTYPE ) {
            AppTitleStringId = IDS_APPTITLE_SRV;
        } else if( ProductFlavor == ADVANCEDSERVER_PRODUCTTYPE ) {
            AppTitleStringId = IDS_APPTITLE_ASRV;
        } else if( ProductFlavor == DATACENTER_PRODUCTTYPE ) {
            AppTitleStringId = IDS_APPTITLE_DAT;
        } else if( ProductFlavor == BLADESERVER_PRODUCTTYPE ) {
            AppTitleStringId = IDS_APPTITLE_BLADE;
        }

//            AppTitleStringId = Server ? IDS_APPTITLE_SRV : IDS_APPTITLE_WKS;

        FixUpWizardTitle(GetParent(hdlg));
        PropSheet_SetTitle(GetParent(hdlg),0,UIntToPtr( AppTitleStringId ));
    }

    if(Upgrade && ISNT()) {
        //
        // If upgrading NT, pull in txtsetup.sif.
        //
        b = LoadInfWorker(hdlg,TEXTMODE_INF,&TxtsetupSif, FALSE);
        
        if(!b) {
            MessageBoxFromMessage(
                NULL,
                MSG_INVALID_INF_FILE,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONINFORMATION | MB_TASKMODAL,
                TEXTMODE_INF
                );
            TxtsetupSif = NULL;
            DebugLog( Winnt32LogError, TEXT("ERROR: Could not load txtsetup.sif!"), 0);
            goto c1;
        }
    }
    if( ISNT()) {
        b = FindPathToWinnt32File(NTCOMPAT_INF, szPath, MAX_PATH);
        if(!b) {
            NtcompatInf = NULL;
            DebugLog( Winnt32LogError, TEXT("ERROR: Could not find ntcompat.inf!"), 0);
            goto c2;
        }
        if(LoadInfFile( szPath,TRUE, &NtcompatInf) != NO_ERROR) {
            MessageBoxFromMessage(
                NULL,
                MSG_INVALID_INF_FILE,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONINFORMATION | MB_TASKMODAL,
                szPath
                );
            b = FALSE;
            NtcompatInf = NULL;
            DebugLog( Winnt32LogError, TEXT("ERROR: Could not load ntcompat.inf!"), 0);
            goto c2;
        }
        DebugLog (Winnt32LogInformation, TEXT("NTCOMPAT: Using %1"), 0, szPath);
    }
    return(b);

c2:
    if( TxtsetupSif) {
        UnloadInfFile(TxtsetupSif);
        TxtsetupSif = NULL;
    }
c1:
    UnloadInfFile(MainInf);
    MainInf = NULL;
c0:
    return(b);
}


BOOL
BuildCopyList(
    IN HWND hdlg
    )
{
    TCHAR Text[256];

    LoadString(hInst,IDS_BUILDING_COPY_LIST,Text,sizeof(Text)/sizeof(TCHAR));
    SendMessage(hdlg,WMX_SETPROGRESSTEXT,0,(LPARAM)Text);
    SaveLanguageDirs();

    return(BuildCopyListWorker(hdlg));
}


BOOL
FindLocalSourceAndCheckSpace(
    IN HWND hdlg,
    IN BOOL QuickTest,
    IN LONGLONG  AdditionalPadding
    )
{
    TCHAR Text[256];

    if (!QuickTest) {
        LoadString(hInst,IDS_CHECKING_SPACE,Text,sizeof(Text)/sizeof(TCHAR));
        SendMessage(hdlg,WMX_SETPROGRESSTEXT,0,(LPARAM)Text);
    }

    return FindLocalSourceAndCheckSpaceWorker(hdlg, QuickTest, AdditionalPadding);
}


BOOL
EnoughMemory(
    IN HWND hdlg,
    IN BOOL QuickTest
    )
{
LPCTSTR         p;
MEMORYSTATUS    MemoryStatus;
DWORD           RequiredMemory;
SIZE_T          RequiredMB, AvailableMB;
    TCHAR buffer[64];

    UpgRequiredMb = 0;
    UpgAvailableMb = 0;


    //
    // Load the minimum memory requirements from the inf
    //
    if(GetMainInfValue (TEXT("Miscellaneous"),TEXT("MinimumMemory"), 0, buffer, 64)) {
        RequiredMemory = _tcstoul(buffer,NULL,10);
        //
        // Got it.  Now figure out how much we've got.
        //
        GlobalMemoryStatus( &MemoryStatus );

        //
        // Convert to MB, rounding up to nearest 4MB boundary...
        //
        RequiredMB = ((RequiredMemory + ((4*1024*1024)-1)) >> 22) << 2;
        AvailableMB = ((MemoryStatus.dwTotalPhys + ((4*1024*1024)-1)) >> 22) << 2;

        //
        // Allow for UMA machine which may reservce 8MB for video
        //
        if( AvailableMB < (RequiredMB-8) ) {

            if (!QuickTest) {
                UpgRequiredMb = (DWORD)RequiredMB;
                UpgAvailableMb = (DWORD)AvailableMB;
                //
                // Fail.
                //
                DebugLog( Winnt32LogInformation,
                          NULL,
                          MSG_NOT_ENOUGH_MEMORY,
                          AvailableMB,
                          RequiredMB );

                SendMessage(hdlg,WMX_ERRORMESSAGEUP,TRUE,0);

                MessageBoxFromMessage(
                    hdlg,
                    MSG_NOT_ENOUGH_MEMORY,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONWARNING,
                    AvailableMB,
                    RequiredMB );

                SendMessage(hdlg,WMX_ERRORMESSAGEUP,FALSE,0);
            }

            return( FALSE );
        } else {
            if (!QuickTest) {
                TCHAR   Buffer[MAX_PATH];
                _stprintf( Buffer, TEXT("Detected %dMB of RAM.\n"), AvailableMB );
                DebugLog( Winnt32LogInformation,
                          Buffer,
                          0 );
            }
        }
    }

    return( TRUE );
}


BOOL
LoadInfWorker(
    IN  HWND     hdlg,
    IN  LPCTSTR  FilenamePart,
    OUT PVOID   *InfHandle,
    IN  BOOL     Winnt32File
    )
{
    DWORD d;
    UINT u;
    UINT Id;
    TCHAR infPath[MAX_PATH];
    TCHAR FormatString[128];
    TCHAR Text[MAX_PATH+128];
    BOOL b;

    LoadString(hInst,IDS_LOADINGINF,Text,sizeof(Text)/sizeof(TCHAR));
    SendMessage(hdlg,WMX_SETPROGRESSTEXT,0,(LPARAM)Text);

    //
    // use standard searching algorithm to get to the right INF
    //
    if (Winnt32File) {
        b = FindPathToWinnt32File (FilenamePart, infPath, MAX_PATH);
    } else {
        b = FindPathToInstallationFile (FilenamePart, infPath, MAX_PATH);
    }

    if (b) {
        d = LoadInfFile(infPath,TRUE,InfHandle);
        if (d == NO_ERROR) {
            return TRUE;
        }
    } else {
        d = ERROR_FILE_NOT_FOUND;
    }

    switch(d) {

    case NO_ERROR:

        Id = 0;
        break;

    case ERROR_NOT_ENOUGH_MEMORY:

        Id = MSG_OUT_OF_MEMORY;
        break;

    case ERROR_READ_FAULT:
        //
        // I/O error.
        //
        Id = MSG_CANT_LOAD_INF_IO;
        break;

    case ERROR_INVALID_DATA:

        Id = MSG_CANT_LOAD_INF_SYNTAXERR;
        break;

    default:

        Id = MSG_CANT_LOAD_INF_GENERIC;
        break;
    }

    if(Id) {
        SendMessage(hdlg,WMX_ERRORMESSAGEUP,TRUE,0);

        MessageBoxFromMessage(
            hdlg,
            Id,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            infPath
            );

        SendMessage(hdlg,WMX_ERRORMESSAGEUP,FALSE,0);

        return(FALSE);
    }

    return(TRUE);
}

BOOL
WriteFileToLog( 
    const PTCHAR pszFileMetaName,
    const PTCHAR pszActualFileName
    )
{
    HANDLE hActualFile = INVALID_HANDLE_VALUE;
    BOOL fResult = FALSE;
    DWORD cbBootIniSize, cbReadBootIniSize;
    PUCHAR pszBuffer = NULL;
    PTCHAR pszActualBuffer = NULL;

    //
    // Open the boot.ini file, get its size, convert it to the proper
    // string type internally, and then log it out.
    //
    hActualFile = CreateFile( 
        pszActualFileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if ( hActualFile == INVALID_HANDLE_VALUE )
        goto Exit;

    cbBootIniSize = GetFileSize( hActualFile, NULL );

    //
    // Buffer we'll be reading the boot.ini into
    //
    if ((pszBuffer = MALLOC(cbBootIniSize)) == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Exit;
    }
    if ( !ReadFile( hActualFile, pszBuffer, cbBootIniSize, &cbReadBootIniSize, NULL ) )
        goto Exit;

    //
    // Ensure that we read as much as we really wanted.
    //
    if ( cbBootIniSize != cbReadBootIniSize ) {
        DebugLog( Winnt32LogError, 
            TEXT("Error: %1 unable to be read entirely.\n"),
            0,
            pszFileMetaName);
        goto Exit;
    }


#ifdef UNICODE
    pszActualBuffer = MALLOC( (cbBootIniSize + 3) * sizeof(TCHAR) );

    MultiByteToWideChar( 
        CP_ACP, 
        0, 
        pszBuffer, 
        cbBootIniSize, 
        pszActualBuffer,
        cbBootIniSize );
#else
    pszActualBuffer = pszBuffer;
#endif    

    pszActualBuffer[cbBootIniSize] = 0;

    //
    // And write it out
    //
    DebugLog( 
        Winnt32LogInformation, 
        TEXT("%1 ----\n%2\n---- (from %3)\n"), 
        0, 
        pszFileMetaName, 
        pszActualBuffer,
        pszActualFileName);

    fResult = TRUE;
    SetLastError(ERROR_SUCCESS);
Exit:
    if ( hActualFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hActualFile );
        hActualFile = INVALID_HANDLE_VALUE;
    }
    
#ifdef UNICODE
    if ( pszActualBuffer != NULL )
#else
    if ( ( pszActualBuffer != pszBuffer ) && ( pszActualBuffer != NULL ) )
#endif
    {
    
        FREE(pszActualBuffer);
        pszActualBuffer = NULL;
    }
    
    if ( pszBuffer != NULL ) {
        FREE(pszBuffer);
        pszBuffer = NULL;
    }
    return fResult;
}



BOOL
InspectFilesystems(
    IN HWND hdlg
    )
{
    TCHAR DriveRoot[4];
    BOOL b;
    TCHAR VolumeName[MAX_PATH];
    DWORD SerialNumber;
    DWORD MaxComponent;
    BOOL Bogus[26];
    TCHAR Filesystem[100];
    TCHAR Drive;
    DWORD Flags;
    int i;

    DriveRoot[1] = TEXT(':');
    DriveRoot[2] = TEXT('\\');
    DriveRoot[3] = 0;

    ZeroMemory(Bogus,sizeof(Bogus));

    for(Drive=TEXT('A'); Drive<=TEXT('Z'); Drive++) {

        if(MyGetDriveType(Drive) != DRIVE_FIXED) {
            continue;
        }


        DriveRoot[0] = Drive;

        b = GetVolumeInformation(
                DriveRoot,
                VolumeName,MAX_PATH,
                &SerialNumber,
                &MaxComponent,
                &Flags,
                Filesystem,
                sizeof(Filesystem)/sizeof(TCHAR)
                );

        if(b) {
            //
            // On NT, we want to warn about HPFS.
            // On Win9x, we want to warn about doublespace/drivespace.
            //
            if(ISNT()) {
                if(!lstrcmpi(Filesystem,TEXT("HPFS"))) {
                    Bogus[Drive-TEXT('A')] = TRUE;
                }
            } else {
                if(Flags & FS_VOL_IS_COMPRESSED) {
                    Bogus[Drive-TEXT('A')] = TRUE;
                }
            }
        }
    }

#ifdef _X86_
    if(ISNT()) {
        TCHAR BootIniName[16];
        DWORD dwAttributes;

        //
        // Disallow HPFS system partition. If someone figured out how
        // to get an HPFS system partition on an ARC machine, more power
        // to 'em.
        //
        MYASSERT (SystemPartitionDriveLetter);
        if(SystemPartitionDriveLetter && Bogus[SystemPartitionDriveLetter-TEXT('A')]) {

            MessageBoxFromMessage(
                hdlg,
                MSG_SYSPART_IS_HPFS,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                SystemPartitionDriveLetter
                );

            return(FALSE);
        }

        /*
            If we're upgrading NT, then log the existing boot.ini to the
            logfiles for this pass.  However, if that failed, then there
            was something wrong - a missing boot.ini during an upgrade
            is really a bad thing that should be snipped in the bud before
            we go much further and copy files down, change system state,
            etc.
        */
#ifdef PRERELEASE
        if (Upgrade) 
        {
            _stprintf(BootIniName, TEXT("%c:\\BOOT.INI"), SystemPartitionDriveLetter);
            if ( !WriteFileToLog( TEXT("Boot configuration file while inspecting filesystems"), BootIniName ) )
            {
                MessageBoxFromMessage(
                    hdlg,
                    MSG_UPGRADE_INSPECTION_MISSING_BOOT_INI,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL,
                    BootIniName );
                return FALSE;
            }
        }
#endif
    }
#endif

    //
    // User cannot upgrade a system on an HPFS/DriveSpace drive
    //
    MyGetWindowsDirectory(VolumeName,MAX_PATH);
    if(Upgrade && Bogus[VolumeName[0]-TEXT('A')]) {

        MessageBoxFromMessage(
            hdlg,
            ISNT() ? MSG_SYSTEM_ON_HPFS : MSG_SYSTEM_ON_CVF,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

        return(FALSE);
    }


    //
    // General case, HPFS data partition/compressed drive.
    //
    for(b=FALSE,Drive=0; !b && (Drive<26); Drive++) {
        if(Bogus[Drive]) {
            b = TRUE;
        }
    }
    if(b) {
        i = MessageBoxFromMessage(
                hdlg,
                ISNT() ? MSG_HPFS_DRIVES_EXIST : MSG_CVFS_EXIST,
                FALSE,
                AppTitleStringId,
                MB_YESNO | MB_ICONQUESTION | MB_TASKMODAL
                );

        if(i == IDNO) {
            return(FALSE);
        }
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\options.c ===
#include "precomp.h"
#pragma hdrstop


DWORD OptionsDlgContextHelp[] = { IDC_MAKELOCALSOURCEFROMCD, IDH_MAKELOCALSOURCEFROMCD,
                                  IDC_USEFLOPPIES          , IDH_USEFLOPPIES,
                                  IDC_SYSPARTDRIVE         , IDH_SYSPARTDRIVE,
                                  IDT_SYSPARTTEXT          , IDH_SYSPARTDRIVE,
                                  IDC_CHOOSE_INSTALLPART   , IDH_CHOOSE_INSTALLPART,
                                  IDC_INSTALL_DIR          , IDH_INSTALL_DIR,
                                  0                        , 0
                                };

typedef struct _LOCALE_ENTRY {
    LPTSTR Lcid;
    LPTSTR Description;
    LPTSTR LanguageGroup1;
    LPTSTR LanguageGroup2;
} LOCALE_ENTRY, *PLOCALE_ENTRY;

typedef struct _LANGUAGE_GROUP_ENTRY {
    LPTSTR Id;
    LPTSTR Description;
    LPTSTR Directory;
    BOOL    Selected;
} LANGUAGE_GROUP_ENTRY, *PLANGUAGE_GROUP_ENTRY;

BOOL    IntlInfProcessed = FALSE;
DWORD   LocaleCount = 0;
PLOCALE_ENTRY LocaleList;
DWORD   PrimaryLocale;
DWORD   LanguageGroupsCount = 0;
PLANGUAGE_GROUP_ENTRY   LanguageGroups;
BOOL    NTFSConversionChanged;

//
// Headless settings.
//
TCHAR   HeadlessSelection[MAX_PATH];
ULONG   HeadlessBaudRate = 0;
#define DEFAULT_HEADLESS_SETTING TEXT("COM1")

BOOL
(*Kernel32IsValidLanguageGroup)(
    IN LGRPID  LanguageGroup,
    IN DWORD   dwFlags);

// Only used for X86 case.
BOOL ForceFloppyless = FALSE;
UINT g_Boot16 = BOOT16_NO;


INT_PTR
OptionsDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    TCHAR Text[MAX_PATH];

    switch(msg) {

    case WM_INITDIALOG:

#if defined(REMOTE_BOOT)
        if (RemoteBoot) {

            //
            // For remote boot client upgrade, uncheck and disable the
            // "copy files from CD-ROM to hard drive" checkbox.
            //
            CheckDlgButton(hdlg,IDC_MAKELOCALSOURCEFROMCD,BST_UNCHECKED);
            EnableWindow(GetDlgItem(hdlg,IDC_MAKELOCALSOURCEFROMCD),FALSE);
            ShowWindow(GetDlgItem(hdlg, IDC_MAKELOCALSOURCEFROMCD), SW_HIDE);

        } else
#endif // defined(REMOTE_BOOT)
        {

            if (!IsArc()) {
                //
                // Set initial state of "copy files from CD-ROM to hard drive"
                // checkbox. Note that that control might be disabled.
                //
                CheckDlgButton(hdlg,
                    IDC_MAKELOCALSOURCEFROMCD,
                    MakeLocalSource ? BST_CHECKED : BST_UNCHECKED);

                if(!RunFromCD) {
                    //
                    // Not run from CD, disable the control. The box won't be checked.
                    // But MakeLocalSource is probably TRUE.
                    //
                    EnableWindow(GetDlgItem(hdlg,IDC_MAKELOCALSOURCEFROMCD),FALSE);
                }
            } else {
                //
                //  On ARC machines the files are always copied to the hard drive
                //
                ShowWindow(GetDlgItem(hdlg, IDC_MAKELOCALSOURCEFROMCD), SW_HIDE);
            } // if (!IsArc())
        }



        //
        // Disable system partition controls?
        //
#if defined _IA64_
        EnableWindow(GetDlgItem(hdlg,IDC_SYSPARTDRIVE),FALSE);
        ShowWindow(GetDlgItem(hdlg,IDC_SYSPARTDRIVE),SW_HIDE);
        ShowWindow(GetDlgItem(hdlg,IDT_SYSPARTTEXT),SW_HIDE);
#else
        if( !IsArc()) {
            EnableWindow(GetDlgItem(hdlg,IDC_SYSPARTDRIVE),FALSE);
            ShowWindow(GetDlgItem(hdlg,IDC_SYSPARTDRIVE),SW_HIDE);
            ShowWindow(GetDlgItem(hdlg,IDT_SYSPARTTEXT),SW_HIDE);
        } else {
            EnableWindow(GetDlgItem(hdlg,IDC_SYSPARTDRIVE),SystemPartitionDriveLetter != 0);
            ShowWindow(GetDlgItem(hdlg,IDC_SYSPARTDRIVE),SystemPartitionDriveLetter ? SW_SHOW : SW_HIDE);
            ShowWindow(GetDlgItem(hdlg,IDT_SYSPARTTEXT),SystemPartitionDriveLetter ? SW_SHOW : SW_HIDE);
        }
#endif



        if (!IsArc()) {
#ifdef _X86_
            if (Upgrade && !ISNT()) {
                //
                // Populate the Boot16 value.
                //
                SendDlgItemMessage(hdlg,IDC_BOOT16_1,BM_SETCHECK, (g_Boot16 == BOOT16_AUTOMATIC) ? BST_CHECKED : BST_UNCHECKED, 0);
                SendDlgItemMessage(hdlg,IDC_BOOT16_2,BM_SETCHECK, (g_Boot16 == BOOT16_YES      ) ? BST_CHECKED : BST_UNCHECKED, 0);
                SendDlgItemMessage(hdlg,IDC_BOOT16_3,BM_SETCHECK, (g_Boot16 == BOOT16_NO       ) ? BST_CHECKED : BST_UNCHECKED, 0);
            }

            //
            // Set floppyless control.
            //
#if defined(REMOTE_BOOT)
            if (RemoteBoot) {
                //
                // For remote boot client upgrade, this is always unchecked and disabled.
                //
                CheckDlgButton(hdlg,IDC_USEFLOPPIES,BST_UNCHECKED);
                EnableWindow(GetDlgItem(hdlg,IDC_USEFLOPPIES),FALSE);
                ShowWindow(GetDlgItem(hdlg,IDC_USEFLOPPIES),SW_HIDE);
            } else
#endif // defined(REMOTE_BOOT)
            {
                CheckDlgButton(hdlg,IDC_USEFLOPPIES,Floppyless ? BST_UNCHECKED : BST_CHECKED);
                if(ForceFloppyless) {
                    EnableWindow(GetDlgItem(hdlg,IDC_USEFLOPPIES),FALSE);
                }
            }
#endif // _X86_
        } else {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
            //
            // Get rid of floppy-related controls.
            //
            EnableWindow(GetDlgItem(hdlg,IDC_USEFLOPPIES),FALSE);
            ShowWindow(GetDlgItem(hdlg,IDC_USEFLOPPIES),SW_HIDE);

            //
            // Populate the system partition combobox.
            //
            if (SystemPartitionDriveLetter)
            {
                PWCHAR p;
                WCHAR x[3];

                x[1] = L':';
                x[2] = 0;

                for(p=SystemPartitionDriveLetters; *p; p++) {

                    x[0] = *p;

                    SendDlgItemMessage(hdlg,IDC_SYSPARTDRIVE,CB_ADDSTRING,0,(LPARAM)x);
                }

                x[0] = SystemPartitionDriveLetter;
                SendDlgItemMessage(hdlg,IDC_SYSPARTDRIVE,CB_SELECTSTRING,(WPARAM)(-1),(LPARAM)x);
            }
#endif // UNICODE
        } // if (!IsArc())

        //
        // Set text in edit controls, and configure the control a little.
        //
        SetDlgItemText(hdlg,IDC_SOURCE,InfName);
        SendDlgItemMessage(hdlg,IDC_SOURCE,EM_LIMITTEXT,MAX_PATH,0);

        if(SourceCount == 1) {
            EnableWindow(GetDlgItem(hdlg,IDC_SOURCE2),TRUE);
            SetDlgItemText(hdlg,IDC_SOURCE2,NativeSourcePaths[0]);
        } else {
            LoadString(hInst,IDS_MULTIPLE,Text,sizeof(Text)/sizeof(TCHAR));
            SetDlgItemText(hdlg,IDC_SOURCE2,Text);
            EnableWindow(GetDlgItem(hdlg,IDC_SOURCE2),FALSE);
        }
        SendDlgItemMessage(hdlg,IDC_SOURCE2,EM_LIMITTEXT,MAX_PATH-1,0);

        SetDlgItemText(hdlg,IDC_INSTALL_DIR,InstallDir);
        SendDlgItemMessage(hdlg,IDC_INSTALL_DIR,EM_LIMITTEXT,MAX_PATH,0);

        CheckDlgButton(hdlg,IDC_CHOOSE_INSTALLPART,ChoosePartition ? BST_CHECKED : BST_UNCHECKED);

        if (Upgrade) {
            TCHAR Text[MAX_PATH];

            //
            // Set the installation directory to the current Windows directory,
            // then disable the user's ability to edit it.
            //
            MyGetWindowsDirectory(Text,MAX_PATH);
            SetDlgItemText(hdlg,IDC_INSTALL_DIR,Text+3);
            SendDlgItemMessage(hdlg,IDC_INSTALL_DIR,EM_LIMITTEXT,MAX_PATH,0);

            EnableWindow(GetDlgItem(hdlg,IDC_INSTALL_DIR),FALSE);
            EnableWindow(GetDlgItem(hdlg,IDC_CHOOSE_INSTALLPART),FALSE);
        }

        //
        // On server installs, don't all the user to modify the
        // install partition selection state
        //
        if (Server) {
            EnableWindow( GetDlgItem(hdlg,IDC_CHOOSE_INSTALLPART), FALSE );
        }

        //
        // Set focus to Cancel button.
        //
        SetFocus(GetDlgItem(hdlg,IDCANCEL));
        b = FALSE;
        break;

    case WM_COMMAND:

        b = FALSE;

        switch(LOWORD(wParam)) {

        case IDOK:

            if(HIWORD(wParam) == BN_CLICKED) {
#if defined(REMOTE_BOOT)
                if (RemoteBoot) {
                    MakeLocalSource = FALSE;
                } else
#endif // defined(REMOTE_BOOT)
                if(RunFromCD) {
                    if (!IsArc()) {
#ifdef _X86_
                        MakeLocalSource = (IsDlgButtonChecked(hdlg,IDC_MAKELOCALSOURCEFROMCD) == BST_CHECKED);
                        UserSpecifiedMakeLocalSource = (IsDlgButtonChecked(hdlg,IDC_MAKELOCALSOURCEFROMCD) == BST_CHECKED);
#endif // _X86_
                    } else {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
                        MakeLocalSource = TRUE;
                        UserSpecifiedMakeLocalSource = TRUE;
#endif // UNICODE
                    } // if (!IsArc())
                }

                if (!IsArc()) {
#ifdef _X86_
#if defined(REMOTE_BOOT)
                    if (RemoteBoot) {
                        MakeBootMedia = FALSE;
                        Floppyless = TRUE;
                    } else
#endif // defined(REMOTE_BOOT)
                    {
                        Floppyless = (IsDlgButtonChecked(hdlg,IDC_USEFLOPPIES) == BST_UNCHECKED);
                    }
#endif // _X86_
                } else {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
                        WCHAR x[3];

                        GetDlgItemText(hdlg,IDC_SYSPARTDRIVE,x,3);
                        SystemPartitionDriveLetter = x[0];
                        LocalBootDirectory[0] = x[0];
#endif // UNICODE
                } // if (!IsArc())

                GetDlgItemText(hdlg,IDC_SOURCE,InfName,MAX_PATH);

                if(SourceCount == 1) {
                    GetDlgItemText(hdlg,IDC_SOURCE2,NativeSourcePaths[0],MAX_PATH);
                }


                {
                    TCHAR tmp[MAX_PATH];
                    BOOL bSelectedChoosePartition;

                    bSelectedChoosePartition = (IsDlgButtonChecked(hdlg, IDC_CHOOSE_INSTALLPART) == BST_CHECKED);
                    
                    GetDlgItemText(hdlg,IDC_INSTALL_DIR,tmp,MAX_PATH);
                    if (tmp[0] == 0) {
                        InstallDir[0] = 0;
                    } else if (tmp[1] == L':' && tmp[2] == L'\\') 
                    {
                        // User included a drive letter.
                        // remove it and assume they selected to choose the installation
                        // partition in textmode.
                        lstrcpy( InstallDir, &tmp[2] );
                        bSelectedChoosePartition = TRUE;
                    } else {
                        if (tmp[0] == L'\\') {
                            lstrcpy( InstallDir, tmp );
                        } else {
                            InstallDir[0] = L'\\';
                            lstrcpy( &InstallDir[1], tmp );
                        }
                    }
                    //
                    // if user selected any of the accessibility options, warn about choosing the partition installation
                    //
                    if(bSelectedChoosePartition && 
                        (AccessibleMagnifier || AccessibleKeyboard || AccessibleVoice || AccessibleReader) &&
                        IDYES != MessageBoxFromMessage(hdlg, MSG_WARNING_ACCESSIBILITY, FALSE, AppTitleStringId, MB_YESNO | MB_ICONEXCLAMATION)) {
                        b = TRUE;
                        break;
                    }

                    ChoosePartition = bSelectedChoosePartition;
                }

                //
                // warn the user if their install dir is > 8 characters, since it will be truncated
                //
                if (!IsValid8Dot3(InstallDir) && IsWindowEnabled(GetDlgItem(hdlg,IDC_INSTALL_DIR ))) {
                    InstallDir[0] = 0;
                    MessageBoxFromMessage(
                        hdlg,
                        MSG_WRN_TRUNC_WINDIR,
                        FALSE,
                        AppTitleStringId,
                        MB_OK | MB_ICONEXCLAMATION
                        );
                    SetFocus(GetDlgItem(hdlg,IDC_INSTALL_DIR));
                    b = FALSE;

                } else {

                   EndDialog(hdlg,TRUE);
                   b = TRUE;
                }


#ifdef _X86_
                {
                    if ((SendDlgItemMessage (hdlg, IDC_BOOT16_1, BM_GETSTATE, 0, 0) & 0x0003) == BST_CHECKED) {
                        g_Boot16 = BOOT16_AUTOMATIC;
                    }
                    else
                    if ((SendDlgItemMessage (hdlg, IDC_BOOT16_2, BM_GETSTATE, 0, 0) & 0x0003) == BST_CHECKED) {
                        g_Boot16 = BOOT16_YES;
                    }
                    else
                    if ((SendDlgItemMessage (hdlg, IDC_BOOT16_3, BM_GETSTATE, 0, 0) & 0x0003) == BST_CHECKED) {
                        g_Boot16 = BOOT16_NO;
                    }
                    else {
                        g_Boot16 = BOOT16_AUTOMATIC;
                    }
                }
#endif


                //
                // Now take care of the headless settings.
                //
                if( IsDlgButtonChecked( hdlg, IDC_ENABLE_HEADLESS) == BST_CHECKED ) {

                    //
                    // He wants to run setup, and the resulting installation
                    // through a headless port.  Got figure out which headless
                    // port he wants to use.
                    //
                    GetDlgItemText( hdlg,
                                    IDC_HEADLESS_PORT,
                                    HeadlessSelection,
                                    MAX_PATH );

                    if( (HeadlessSelection[0] == 0) ||
                        (lstrcmpi( HeadlessSelection, TEXT("usebiossettings"))) ||
                        (_tcsnicmp( HeadlessSelection, TEXT("com"), 3)) ) {

                        //
                        // He gave us something that's invalid.
                        //
                        MessageBoxFromMessage( hdlg,
                                               MSG_INVALID_HEADLESS_SETTING,
                                               FALSE,
                                               AppTitleStringId,
                                               MB_OK | MB_ICONEXCLAMATION );

                        _tcscpy( HeadlessSelection, DEFAULT_HEADLESS_SETTING );
                        SetDlgItemText( hdlg,
                                        IDC_HEADLESS_PORT,
                                        HeadlessSelection );

                        SetFocus(GetDlgItem(hdlg,IDC_HEADLESS_PORT));
                        b = FALSE;

                    }
                }
            }
            break;

        case IDCANCEL:

            if(HIWORD(wParam) == BN_CLICKED) {
                EndDialog(hdlg,FALSE);
                b = TRUE;
            }
            break;

        case IDC_ENABLE_HEADLESS:

            if( HIWORD(wParam) == BN_CLICKED ) {

                if( IsDlgButtonChecked(hdlg, IDC_ENABLE_HEADLESS) ) {

                    //
                    // Make sure the headless settings box is enabled.
                    //
                    EnableWindow( GetDlgItem(hdlg, IDC_HEADLESS_PORT), TRUE );
                    ShowWindow( GetDlgItem(hdlg, IDC_HEADLESS_PORT), SW_SHOW );
                    if( HeadlessSelection[0] == TEXT('\0') ) {

                        //
                        // This is the first time the user has asked
                        // us to enable Headless.  Suggest the use of
                        // se the default COM port.
                        //
                        _tcscpy( HeadlessSelection, DEFAULT_HEADLESS_SETTING );

                    }
                    SetDlgItemText( hdlg,
                                    IDC_HEADLESS_PORT,
                                    HeadlessSelection );

                    SetFocus(GetDlgItem(hdlg,IDC_HEADLESS_PORT));

                } else {

                    //
                    // Disable the headless settings box since the
                    // user has chosen not to use headless.
                    //
                    HeadlessSelection[0] = TEXT('\0');
                    EnableWindow( GetDlgItem(hdlg, IDC_HEADLESS_PORT), FALSE );
                    ShowWindow( GetDlgItem(hdlg, IDC_HEADLESS_PORT), SW_HIDE );
                }
            }
            break;

        case IDC_HEADLESS_PORT:

            if( HIWORD(wParam) == EN_CHANGE) {

                EnableWindow( GetDlgItem(hdlg, IDOK),
                              SendDlgItemMessage(hdlg, IDC_HEADLESS_PORT,WM_GETTEXTLENGTH,0,0) ? TRUE : FALSE );
            }
            break;

        case IDC_SOURCE:

            if(HIWORD(wParam) == EN_CHANGE) {

                EnableWindow(
                    GetDlgItem(hdlg,IDOK),
                    SendDlgItemMessage(hdlg,IDC_SOURCE,WM_GETTEXTLENGTH,0,0) ? TRUE : FALSE
                    );
            }
            break;

        case IDC_SOURCE2:

            if(HIWORD(wParam) == EN_CHANGE) {

                EnableWindow(
                    GetDlgItem(hdlg,IDOK),
                    SendDlgItemMessage(hdlg,IDC_SOURCE2,WM_GETTEXTLENGTH,0,0) ? TRUE : FALSE
                    );
            }
            break;

        case IDB_BROWSE:

            if(HIWORD(wParam) == BN_CLICKED) {
                TCHAR InitialPath[MAX_PATH];
                TCHAR NewPath[MAX_PATH];

                GetDlgItemText(hdlg,IDC_SOURCE2,InitialPath,MAX_PATH);
                if(BrowseForDosnetInf(hdlg,InitialPath,NewPath)) {
                    SetDlgItemText(hdlg,IDC_SOURCE2,NewPath);
                }
                b = TRUE;
            }
            break;

#ifdef _X86_
        case IDC_USEFLOPPIES:

            b = FALSE;
            if(HIWORD(wParam) == BN_CLICKED) {

                MEDIA_TYPE MediaType;

//              switch(MediaType = GetMediaType(TEXT('A'), NULL)) {
                switch(MediaType = GetMediaType(FirstFloppyDriveLetter, NULL)) {

                case Unknown:
                case F5_1Pt2_512:
                case F3_720_512:
                case F5_360_512:
                case F5_320_512:
                case F5_320_1024:
                case F5_180_512:
                case F5_160_512:
                case RemovableMedia:
                case FixedMedia:
                    //
                    // None of these are acceptable.
                    //
                    MessageBoxFromMessage(
                        hdlg,
                        MSG_EVIL_FLOPPY_DRIVE,
                        FALSE,
                        AppTitleStringId,
                        MB_OK | MB_ICONERROR
                        );

                    CheckDlgButton(hdlg,IDC_USEFLOPPIES,BST_UNCHECKED);
                    EnableWindow(GetDlgItem(hdlg,IDC_USEFLOPPIES),FALSE);
                    Floppyless = TRUE;
                    ForceFloppyless = TRUE;
                    b = TRUE;
                    break;

                case F3_1Pt44_512:
                case F3_2Pt88_512:
                case F3_20Pt8_512:
                case F3_120M_512:
                default:
                    //
                    // Allow these -- nothing to do here.
                    // Note that this includes types we don't know about,
                    // since new types could appear after we ship and we assume
                    // they'll be big enough.
                    //
                    break;
                }
                // } -to match commented out switch above.
            }
            break;
#endif
        }

        break;

    case WM_HELP:

        MyWinHelp(((HELPINFO *)lParam)->hItemHandle,HELP_WM_HELP,(ULONG_PTR)OptionsDlgContextHelp);
        b = TRUE;
        break;

    case WM_CONTEXTMENU:

        MyWinHelp((HWND)wParam,HELP_CONTEXTMENU,(ULONG_PTR)OptionsDlgContextHelp);
        b = TRUE;
        break;

    default:
        b = FALSE;
        break;
    }

    return(b);
}


VOID
DoOptions(
    IN HWND Parent
    )
{
    INT_PTR i;

    if (Upgrade && !ISNT()) {
        i = DialogBox(hInst,MAKEINTRESOURCE(IDD_ADVANCED3),Parent,OptionsDlgProc);
    }
    else {
        i = DialogBox(hInst,MAKEINTRESOURCE(IDD_ADVANCED),Parent,OptionsDlgProc);
    }

    if(i == -1) {
        MessageBoxFromMessage(
            Parent,
            MSG_OUT_OF_MEMORY,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR
            );
    }
}

VOID
SaveLanguageDirs(
    )
{
    DWORD   ItemNo;
    HMODULE hKernel32 = NULL;
    LGRPID  LangGroupId;
    PTSTR   p;

    p = NULL;
    Kernel32IsValidLanguageGroup = NULL;

    //
    // Get IsValidLanguageGroup if we can
    //
    if (Upgrade && ISNT() && (BuildNumber >= NT50B3)) {

        hKernel32 = LoadLibrary(TEXT("KERNEL32"));
        if (hKernel32) {
            (FARPROC)Kernel32IsValidLanguageGroup =
                GetProcAddress( hKernel32, "IsValidLanguageGroup" );
        }
    }

    for( ItemNo=0; ItemNo<LanguageGroupsCount; ItemNo++ ) {

        //
        // When upgrading from NT 5, select any languages which are already
        // installed, to make sure they get upgraded.
        //
        LangGroupId = _tcstoul( LanguageGroups[ItemNo].Id, NULL, 10 );
        if (Kernel32IsValidLanguageGroup && LangGroupId &&
            Kernel32IsValidLanguageGroup( LangGroupId, LGRPID_INSTALLED )
            ) {

            LanguageGroups[ItemNo].Selected = TRUE;
        }

        //
        // Install any languages required by the primary locale.
        //
        if (!lstrcmp( LanguageGroups[ItemNo].Id, LocaleList[PrimaryLocale].LanguageGroup1 ) ||
            !lstrcmp( LanguageGroups[ItemNo].Id, LocaleList[PrimaryLocale].LanguageGroup2 )
            ) {

            LanguageGroups[ItemNo].Selected = TRUE;
        }


        //
        // Make sure the necessary optional directories get copied for all
        // selected language groups.
        //
        if( LanguageGroups[ItemNo].Selected ) {

            TCHAR TempString[MAX_PATH];

            if( LanguageGroups[ItemNo].Directory &&
                LanguageGroups[ItemNo].Directory[0]
                ) {
                RememberOptionalDir(
                    LanguageGroups[ItemNo].Directory,
                    OPTDIR_TEMPONLY | OPTDIR_ADDSRCARCH
                    );
#ifdef _IA64_

        //Add the i386\lang folder if needed

                lstrcpy( TempString, TEXT("\\I386\\"));
                lstrcat( TempString, LanguageGroups[ItemNo].Directory );
                
                
                RememberOptionalDir(
                    TempString,
                    OPTDIR_TEMPONLY | OPTDIR_PLATFORM_INDEP
                    );


#endif


            }
        }
    }

#ifdef _X86_


    //
    // If this is a win9xupg, we need to get any optional directories they need for installed languages.
    //
    if (Upgrade && !ISNT()) {

        p = UpgradeSupport.OptionalDirsRoutine ();

        while (p && *p) {

            RememberOptionalDir (p, OPTDIR_TEMPONLY | OPTDIR_ADDSRCARCH);
            p = _tcschr (p, 0) + 1;
        }
    }

#endif
}


BOOL
SaveLanguageParams(
    IN LPCTSTR FileName
    )
{
    BOOL    b;
    DWORD   ItemNo;
    LPCTSTR WinntLangSection = WINNT_REGIONALSETTINGS;
    PTSTR   LanguageString = NULL;
    UINT    LanguageLength = 0;
    LPTSTR  p;


    if( !IntlInfProcessed ) {
        return TRUE;
    }


    //
    // If this is a win9x upgrade, let the upgrade .dll take care
    // of writing these parameters.
    //
    if (Upgrade && !ISNT()) {
        return TRUE;
    }

    b = WritePrivateProfileString(
        WinntLangSection,
        WINNT_D_LANGUAGE,
        LocaleList[PrimaryLocale].Lcid,
        FileName
        );

    for( ItemNo=0; ItemNo<LanguageGroupsCount; ItemNo++ ) {

        if( LanguageGroups[ItemNo].Selected ) {

            if(LanguageString) {
                p = REALLOC(
                    LanguageString,
                    (lstrlen( LanguageGroups[ItemNo].Id) + 2 + LanguageLength ) * sizeof(TCHAR)
                    );
            } else {
                p = MALLOC((lstrlen(LanguageGroups[ItemNo].Id)+2)*sizeof(TCHAR));
            }

            if(!p) {
                if( LanguageString ) {
                    FREE( LanguageString );
                }
                return FALSE;
            }

            LanguageString = p;

            if( LanguageLength ) {
                lstrcat( LanguageString, LanguageGroups[ItemNo].Id );
            } else {
                lstrcpy( LanguageString, LanguageGroups[ItemNo].Id );
            }

            lstrcat( LanguageString, TEXT(",") );
            LanguageLength = lstrlen( LanguageString );
        }
    }

    if( LanguageString ) {
        //
        // Remove trailing "," if any
        //
        if( LanguageLength && (LanguageString[LanguageLength-1] == TEXT(','))) {
            LanguageString[LanguageLength-1] = 0;
        }

        b = b && WritePrivateProfileString(
            WinntLangSection,
            WINNT_D_LANGUAGE_GROUP,
            LanguageString,
            FileName
            );

        FREE( LanguageString );
    }

    return b;
}


VOID
FreeLanguageData(
    )
{
    DWORD   ItemNo;


    //
    // Free all the data allocated for the language options data
    //
    for( ItemNo=0; ItemNo<LocaleCount; ItemNo++ ) {
        FREE( LocaleList[ItemNo].Lcid );
        FREE( LocaleList[ItemNo].Description );
        FREE( LocaleList[ItemNo].LanguageGroup1 );
        FREE( LocaleList[ItemNo].LanguageGroup2 );
    }
    LocaleCount = 0;
    for( ItemNo=0; ItemNo<LanguageGroupsCount; ItemNo++ ) {
        FREE( LanguageGroups[ItemNo].Id );
        FREE( LanguageGroups[ItemNo].Description );
        FREE( LanguageGroups[ItemNo].Directory );
    }
    LanguageGroupsCount = 0;
    if( LocaleList ) {
        FREE( LocaleList );
    }
    if( LanguageGroups ) {
        FREE( LanguageGroups );
    }
    IntlInfProcessed = FALSE;
}


int
__cdecl
LocaleCompare(
    const void *arg1,
    const void *arg2
    )
{
   return lstrcmp(
       ((PLOCALE_ENTRY)arg1)->Description,
       ((PLOCALE_ENTRY)arg2)->Description
       );
}


int
__cdecl
LangGroupCompare(
    const void *arg1,
    const void *arg2
    )
{
   return lstrcmp(
       ((PLANGUAGE_GROUP_ENTRY)arg1)->Description,
       ((PLANGUAGE_GROUP_ENTRY)arg2)->Description
       );
}


BOOL
ReadIntlInf(
    IN HWND   hdlg
    )
{
    HINF    IntlInf;
    TCHAR   IntlInfName[MAX_PATH];
    DWORD   LineCount;
    DWORD   ItemNo, NeededSize = 0;
    LPCTSTR SectionName;
    INFCONTEXT InfContext;
    LPCTSTR Language;
    TCHAR   CurrentLcid[9] = TEXT("\0");
    TCHAR   CurrentLcidEx[9] = TEXT("\0");  // for AUTO_LANGPACK

    //
    // For AUTO_LANGPACK - BEGIN
    //
    // The pieces that are enclosed with AUTO_LANGPACK are for easy
    // installation of other LangPack rather than English.
    //
    // This is originally for globalization testing. You can erase it by
    // deleting lines surrounded or marked by the keyword AUTO_LANGPACK.
    //
    // Contact: YuhongLi
    //

    //
    // read "Locale" from an extra file INTLEX.INF to install
    // the locale rather than English (United States) by default.
    //
    // Here is a sample of INTLEX.INF which specifies Japanese
    // as the default. The file INTLEX.INF should be in Unicode.
    //
    // --- cut here ---
    //  [Version]
    //  Signature = $Chicago$
    //
    //  [DefaultValues]
    //  Locale = "00000411"
    // --- end of cut ---
    //
    // For German (Germany), Locale will be 00000407.
    //
    
    FindPathToInstallationFile( TEXT("intlex.inf"), IntlInfName, MAX_PATH);
    IntlInf = SetupapiOpenInfFile( IntlInfName, NULL, INF_STYLE_WIN4, NULL );
    if( IntlInf != INVALID_HANDLE_VALUE ) {
        if( SetupapiFindFirstLine( IntlInf, TEXT("DefaultValues"), TEXT("Locale"), &InfContext ) ) {
            SetupapiGetStringField( &InfContext, 1, CurrentLcidEx, (sizeof(CurrentLcidEx)/sizeof(TCHAR)), NULL );
        }
        SetupapiCloseInfFile( IntlInf );
    }
    //
    // For AUTO_LANGPACK -- END
    //

    //
    // Open the INF
    //
    
    FindPathToInstallationFile( TEXT("intl.inf"), IntlInfName, MAX_PATH);
    IntlInf = SetupapiOpenInfFile( IntlInfName, NULL, INF_STYLE_WIN4, NULL );
    if(IntlInf == INVALID_HANDLE_VALUE && hdlg) {
        MessageBoxFromMessageAndSystemError(
            hdlg,
            MSG_INTLINF_NOT_FOUND,
            GetLastError(),
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );
        return FALSE;
    }

    //
    // Figure out what the default locale should be.
    //
    if( Upgrade ) {
        wsprintf( CurrentLcid, TEXT("%08x"), GetSystemDefaultLCID());
    } else if ( CurrentLcidEx[0] ) {            // for AUTO_LANGPACK
        lstrcpy( CurrentLcid, CurrentLcidEx);   // for AUTO_LANGPACK
    } else if( SetupapiFindFirstLine( IntlInf, TEXT("DefaultValues"), TEXT("Locale"), &InfContext )) {
        SetupapiGetStringField( &InfContext, 1, CurrentLcid, (sizeof(CurrentLcid)/sizeof(TCHAR)), NULL );
    } else {
        if (hdlg) {
            MessageBoxFromMessage(
                hdlg,
                MSG_INTLINF_NOT_FOUND,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL
                );
        }
        return FALSE;
    }

    //
    // Read the [Locales] section, sort it, and find the default value in the list.
    //
    SectionName = TEXT("Locales");
    LocaleCount = SetupapiGetLineCount( IntlInf, SectionName );
    LocaleList = MALLOC( LocaleCount*sizeof( LOCALE_ENTRY ) );
    if(!LocaleList){
        SetupapiCloseInfFile( IntlInf );
        return FALSE;
    }
    memset(LocaleList, 0, LocaleCount*sizeof( LOCALE_ENTRY ) );

    for( ItemNo=0; ItemNo<LocaleCount; ItemNo++ ) {
        if( SetupapiGetLineByIndex( IntlInf, SectionName, ItemNo, &InfContext )) {


            if( SetupapiGetStringField( &InfContext, 0, NULL, 0, &NeededSize )){
                if( NeededSize && (LocaleList[ItemNo].Lcid = MALLOC( NeededSize*sizeof(TCHAR) ))){
                    SetupapiGetStringField( &InfContext, 0, LocaleList[ItemNo].Lcid, NeededSize, NULL );
                }
            }

            if( SetupapiGetStringField( &InfContext, 1, NULL, 0, &NeededSize )){
                if( NeededSize && (LocaleList[ItemNo].Description = MALLOC( NeededSize*sizeof(TCHAR) ))){
                    SetupapiGetStringField( &InfContext, 1, LocaleList[ItemNo].Description, NeededSize, NULL );
                }

            }

            if( SetupapiGetStringField( &InfContext, 3, NULL, 0, &NeededSize )){
                if( NeededSize && (LocaleList[ItemNo].LanguageGroup1 = MALLOC( NeededSize*sizeof(TCHAR) ))){
                    SetupapiGetStringField( &InfContext, 3, LocaleList[ItemNo].LanguageGroup1, NeededSize, NULL );
                }
            }

            if( SetupapiGetStringField( &InfContext, 4, NULL, 0, &NeededSize )){
                if( NeededSize && (LocaleList[ItemNo].LanguageGroup2 = MALLOC( NeededSize*sizeof(TCHAR) ))){
                    SetupapiGetStringField( &InfContext, 4, LocaleList[ItemNo].LanguageGroup2, NeededSize, NULL );
                }
            }
            
        }
        else {
	    SetupapiCloseInfFile( IntlInf );
            free( LocaleList );
	    return FALSE;
	}
    }

    qsort(
        LocaleList,
        LocaleCount,
        sizeof(LOCALE_ENTRY),
        LocaleCompare
        );

    for( ItemNo=0; ItemNo<LocaleCount; ItemNo++ ) {
        if( LocaleList[ItemNo].Lcid && !lstrcmpi( CurrentLcid, LocaleList[ItemNo].Lcid)) {
            PrimaryLocale = ItemNo;
            break;
        }
    }

    //
    // Read the [LanguageGroups] section and sort it
    //
    SectionName = TEXT("LanguageGroups");
    LanguageGroupsCount = SetupapiGetLineCount( IntlInf, SectionName );
    LanguageGroups = MALLOC( LanguageGroupsCount*sizeof( LANGUAGE_GROUP_ENTRY ) );
    if(!LanguageGroups){
        SetupapiCloseInfFile( IntlInf );
        return FALSE;
    }
    memset(LanguageGroups, 0, LanguageGroupsCount*sizeof( LANGUAGE_GROUP_ENTRY ) );

    for( ItemNo=0; ItemNo<LanguageGroupsCount; ItemNo++ ) {
        if( SetupapiGetLineByIndex( IntlInf, SectionName, ItemNo, &InfContext )) {

            if( SetupapiGetStringField( &InfContext, 0, NULL, 0, &NeededSize )){
                if( NeededSize && (LanguageGroups[ItemNo].Id = MALLOC( NeededSize*sizeof(TCHAR) ))){
                    SetupapiGetStringField( &InfContext, 0, LanguageGroups[ItemNo].Id, NeededSize, NULL );
                }

            }

            if( SetupapiGetStringField( &InfContext, 1, NULL, 0, &NeededSize )){
                if( NeededSize && (LanguageGroups[ItemNo].Description = MALLOC( NeededSize*sizeof(TCHAR) ))){
                    SetupapiGetStringField( &InfContext, 1, LanguageGroups[ItemNo].Description, NeededSize, NULL );
                }

            }

            if( SetupapiGetStringField( &InfContext, 2, NULL, 0, &NeededSize )){
                if( NeededSize && (LanguageGroups[ItemNo].Directory = MALLOC( NeededSize*sizeof(TCHAR) ))){
                    SetupapiGetStringField( &InfContext, 2, LanguageGroups[ItemNo].Directory, NeededSize, NULL );
                }

            }

            LanguageGroups[ItemNo].Selected = FALSE;
            //
            // Handle Hong Kong upgrades as a special case: always install Language
            // Groups 9 and 10.
            //

            if( (TargetNativeLangID == 0xc04) && Upgrade &&
                (!lstrcmpi( LanguageGroups[ItemNo].Id, TEXT("9")) ||
                 !lstrcmpi( LanguageGroups[ItemNo].Id, TEXT("10"))) ) {

                LanguageGroups[ItemNo].Selected = TRUE;
            }
        }
        else {
	    SetupapiCloseInfFile( IntlInf );
            free( LocaleList );
            free( LanguageGroups );
            return FALSE;
        }
    }

    qsort(
        LanguageGroups,
        LanguageGroupsCount,
        sizeof(LANGUAGE_GROUP_ENTRY),
        LangGroupCompare
        );

    // If the primary language is a Far East one, don't show the check box.
    if (IsFarEastLanguage(PrimaryLocale))
    {
        ShowWindow(GetDlgItem(hdlg, IDC_FAREAST_LANG), SW_HIDE);
    }
    //
    // Clean up
    //
    SetupapiCloseInfFile( IntlInf );
    IntlInfProcessed = TRUE;
    return TRUE;
}

BOOL InitLangControl(HWND hdlg, BOOL bFarEast)
{
    DWORD   ItemNo;
    //
    // Init primary language combo box
    //
    for( ItemNo=0; ItemNo<LocaleCount; ItemNo++ ) {
        SendDlgItemMessage( hdlg, IDC_COMBO1, CB_ADDSTRING, 0, (LPARAM)LocaleList[ItemNo].Description );
    }
    SendDlgItemMessage( hdlg, IDC_COMBO1, CB_SETCURSEL, PrimaryLocale, 0 );

    // if the running language or the to be installed language is a FarEast 
    // language, this check box is not visible, because we install the language folder anyway.
    if (IsWindowVisible(GetDlgItem(hdlg,IDC_FAREAST_LANG)))
    {
        if (bFarEast || IsFarEastLanguage(PrimaryLocale))
        {
            CheckDlgButton(hdlg,IDC_FAREAST_LANG,BST_CHECKED);
        }
        else
        {
            CheckDlgButton(hdlg,IDC_FAREAST_LANG,BST_UNCHECKED);
        }
    }
    return TRUE;
}


INT_PTR
LanguageDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    DWORD   ItemNo;


    switch(msg) {

    case WM_INITDIALOG:

        if( !IntlInfProcessed ) {
            EndDialog( hdlg, FALSE );
        }

        //
        // Init locales
        //
        for( ItemNo=0; ItemNo<LocaleCount; ItemNo++ ) {
            SendDlgItemMessage( hdlg, IDC_COMBO1, CB_ADDSTRING, 0, (LPARAM)LocaleList[ItemNo].Description );
        }
        SendDlgItemMessage( hdlg, IDC_COMBO1, CB_SETCURSEL, PrimaryLocale, 0 );

        //
        // Init language groups
        //
        for( ItemNo=0; ItemNo<LanguageGroupsCount; ItemNo++ ) {
            SendDlgItemMessage( hdlg, IDC_LIST, LB_ADDSTRING, 0, (LPARAM)LanguageGroups[ItemNo].Description );
            SendDlgItemMessage( hdlg, IDC_LIST, LB_SETSEL, LanguageGroups[ItemNo].Selected, ItemNo );
        }
        for( ItemNo=0; ItemNo<LanguageGroupsCount; ItemNo++ ) {
            LanguageGroups[ItemNo].Selected = (int)SendDlgItemMessage( hdlg, IDC_LIST, LB_GETSEL, ItemNo, 0 );
        }

        //
        // Set focus to Cancel button.
        //
        SetFocus(GetDlgItem(hdlg,IDCANCEL));
        b = FALSE;
        break;

    case WM_COMMAND:

        b = FALSE;

        switch(LOWORD(wParam)) {

        case IDOK:

            if(HIWORD(wParam) == BN_CLICKED) {
                PrimaryLocale = (DWORD)SendDlgItemMessage( hdlg, IDC_COMBO1, CB_GETCURSEL, 0, 0 );
                for( ItemNo=0; ItemNo<LanguageGroupsCount; ItemNo++ ) {
                    LanguageGroups[ItemNo].Selected = (int)SendDlgItemMessage( hdlg, IDC_LIST, LB_GETSEL, ItemNo, 0 );
                }

                EndDialog(hdlg,TRUE);
                b = TRUE;
            }
            break;

        case IDCANCEL:

            if(HIWORD(wParam) == BN_CLICKED) {
                EndDialog(hdlg,FALSE);
                b = TRUE;
            }
            break;
        }

        break;

    default:
        b = FALSE;
        break;
    }

    return(b);
}


VOID
DoLanguage(
    IN HWND Parent
    )
{
    INT_PTR i;

    i = DialogBox(hInst,MAKEINTRESOURCE(IDD_LANGUAGE),Parent,LanguageDlgProc);

    if(i == -1) {
        MessageBoxFromMessage(
            Parent,
            MSG_OUT_OF_MEMORY,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR
            );
    }
}


INT_PTR
AccessibilityDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    TCHAR VisibleNarrator[2];


    switch(msg) {

    case WM_INITDIALOG:
        //
        // Disable the narrator in locales that don't support it.
        //

        if (!LoadString(hInst,IDS_VISIBLE_NARRATOR_CONTROL,VisibleNarrator,sizeof(VisibleNarrator)/sizeof(TCHAR)) ||
            lstrcmp(VisibleNarrator,TEXT("1"))) {

            EnableWindow(GetDlgItem( hdlg, IDC_READER ), FALSE);
            ShowWindow(GetDlgItem( hdlg, IDC_READER ), SW_HIDE);
            EnableWindow(GetDlgItem( hdlg, IDC_READER_TEXT ), FALSE);
            ShowWindow(GetDlgItem( hdlg, IDC_READER_TEXT ), SW_HIDE);
        }

        //
        // check the target LCID and disable it for non-English locales
        //
        if (SourceNativeLangID) {
            if (!(SourceNativeLangID == 0x0409 || SourceNativeLangID == 0x0809)) {
                EnableWindow(GetDlgItem( hdlg, IDC_READER ), FALSE);
                ShowWindow(GetDlgItem( hdlg, IDC_READER ), SW_HIDE);
                EnableWindow(GetDlgItem( hdlg, IDC_READER_TEXT ), FALSE);
                ShowWindow(GetDlgItem( hdlg, IDC_READER_TEXT ), SW_HIDE);
            }
        }
        //
        // Set the initial state of the check boxes.
        //
        CheckDlgButton(hdlg,IDC_MAGNIFIER,AccessibleMagnifier ?
            BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hdlg,IDC_KEYBOARD,AccessibleKeyboard ?
            BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hdlg,IDC_VOICE,AccessibleVoice ?
            BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(hdlg,IDC_READER,AccessibleReader ?
            BST_CHECKED : BST_UNCHECKED);

        //
        // Set focus to Cancel button.
        //
        SetFocus(GetDlgItem(hdlg,IDCANCEL));
        b = FALSE;
        break;

    case WM_COMMAND:

        b = FALSE;

        switch(LOWORD(wParam)) {

        case IDOK:

            if(HIWORD(wParam) == BN_CLICKED) {
                BOOL bSelectedAccessibleMagnifier;
                BOOL bSelectedAccessibleKeyboard;
                BOOL bSelectedAccessibleVoice;
                BOOL bSelectedAccessibleReader;

                b = TRUE;
                bSelectedAccessibleMagnifier = (IsDlgButtonChecked(hdlg,IDC_MAGNIFIER) == BST_CHECKED);
                bSelectedAccessibleKeyboard = (IsDlgButtonChecked(hdlg,IDC_KEYBOARD) == BST_CHECKED);
                bSelectedAccessibleVoice = (IsDlgButtonChecked(hdlg,IDC_VOICE) == BST_CHECKED);
                bSelectedAccessibleReader = (IsDlgButtonChecked(hdlg,IDC_READER) == BST_CHECKED);
                //
                // if user selected any of the accessibility options, warn about choosing the partition installation
                //
                if(ChoosePartition && 
                    (bSelectedAccessibleMagnifier || bSelectedAccessibleKeyboard || bSelectedAccessibleVoice || bSelectedAccessibleReader) && 
                    IDYES != MessageBoxFromMessage(hdlg, MSG_WARNING_ACCESSIBILITY, FALSE, AppTitleStringId, MB_YESNO | MB_ICONEXCLAMATION)) {
                    break;
                }

                AccessibleMagnifier = bSelectedAccessibleMagnifier;
                AccessibleKeyboard = bSelectedAccessibleKeyboard;
                AccessibleVoice = bSelectedAccessibleVoice;
                AccessibleReader = bSelectedAccessibleReader;
                EndDialog(hdlg,TRUE);
            }

            break;

        case IDCANCEL:

            if(HIWORD(wParam) == BN_CLICKED) {
                EndDialog(hdlg,FALSE);
                b = TRUE;
            }
            break;
        }

        break;

    default:
        b = FALSE;
        break;
    }

    return(b);
}


VOID
DoAccessibility(
    IN HWND Parent
    )
{
    INT_PTR i;

    i = DialogBox(hInst,MAKEINTRESOURCE(IDD_ACCESSIBILITY),Parent,AccessibilityDlgProc);

    if(i == -1) {
        MessageBoxFromMessage(
            Parent,
            MSG_OUT_OF_MEMORY,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR
            );
    }
}


VOID
InitVariousOptions(
    VOID
    )

/*++

Routine Description:

    Initialize options for program operation, including

    - determining whether we were run from a CD

    - whether we should create a local source

    If we are being run from CD then there's no need to create
    a local source since we assume we can get to the CD from NT.

Arguments:

    None.

Return Value:

    None.

    Global variables RunFromCD, MakeLocalSource filled in.

--*/

{
    TCHAR Path[MAX_PATH];


    //
    // Assume not run from CD. In that case we need to create
    // a local source.  This is a global, and should be FALSE
    // unless the user has sent us a /#R to force the RunFromCD.
    //
//    RunFromCD = FALSE;

#if defined(REMOTE_BOOT)
    //
    // If this is a remote boot client, MakeLocalSource is always false.
    //
    if (RemoteBoot) {

        MakeLocalSource = FALSE;
        MakeBootMedia = FALSE;
        Floppyless = TRUE;

    } else
#endif // defined(REMOTE_BOOT)
    {
        //
        // Determine if we were run from CD.
        //
        if(GetModuleFileName(NULL,Path,MAX_PATH)) {
            //
            // For UNC paths this will do something bogus, but certainly
            // won't return DRIVE_CDROM, so we don't care.
            //
            Path[3] = 0;
            if(GetDriveType(Path) == DRIVE_CDROM) {
                RunFromCD = TRUE;
            }
        }

        //
        // Now determine if we should MakeLocalSource.
        //
        if (!IsArc()) {
#ifdef _X86_
            //
            // MakeLocalSource is a global, so he
            // will be FALSE by default, unless the
            // user has sent winnt32.exe the /MakeLocalSource flag,
            // in which case, the flag will already be set to true.
            //
            MakeLocalSource = (MakeLocalSource || (!RunFromCD));
#endif // _X86_
        } else {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
            //
            // on ARC, always make local source.
            //
            MakeLocalSource = TRUE;
#endif // UNICODE
        } // if (!IsArc())

    }
}


BOOL
BrowseForDosnetInf(
    IN  HWND    hdlg,
    IN  LPCTSTR InitialPath,
    OUT TCHAR   NewPath[MAX_PATH]
    )

/*++

Routine Description:

    This routine invokes the standard win32 find file dialog for
    dosnet.inf or whatever inf is currently selected to substitute for
    dosnet.inf.

Arguments:

    hdlg - supplies window handle of dialog to use as parent for
        find file common dialog.

Return Value:

    Boolean value indicating whether the user browsed and successfully
    located dosnet.inf (or substitute).

--*/

{
    BOOL b;
    OPENFILENAME Info;
    TCHAR Filter[2*MAX_PATH];
    TCHAR File[MAX_PATH];
    TCHAR Path[MAX_PATH];
    DWORD d;
    TCHAR Title[150];
    PVOID p;

    ZeroMemory(Filter,sizeof(Filter));

    p = InfName;

    d = FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
            hInst,
            MSG_DOSNET_INF_DESC,
            0,
            Filter,
            MAX_PATH,
            (va_list *)&p
            );

    lstrcpy(Filter+d+1,InfName);

    lstrcpy(File,InfName);
    lstrcpy(Path,InitialPath);

    LoadString(hInst,IDS_FIND_NT_FILES,Title,sizeof(Title)/sizeof(TCHAR));

    Info.lStructSize = sizeof(OPENFILENAME);
    Info.hwndOwner = hdlg;
    Info.hInstance = NULL;              // unused because not using a template
    Info.lpstrFilter = Filter;
    Info.lpstrCustomFilter = NULL;
    Info.nMaxCustFilter = 0;            // unused because lpstrCustomFilter is NULL
    Info.nFilterIndex = 1;
    Info.lpstrFile = File;
    Info.nMaxFile = MAX_PATH;
    Info.lpstrFileTitle = NULL;
    Info.nMaxFileTitle = 0;             // unused because lpstrFileTitle is NULL
    Info.lpstrInitialDir = Path;
    Info.lpstrTitle = Title;
    Info.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_NODEREFERENCELINKS | OFN_PATHMUSTEXIST;
    Info.nFileOffset = 0;
    Info.nFileExtension = 0;
    Info.lpstrDefExt = NULL;
    Info.lCustData = 0;                 // unused because no hook is used
    Info.lpfnHook = NULL;               // unused because no hook is used
    Info.lpTemplateName = NULL;         // unused because no template is used

    b = GetOpenFileName(&Info);

    if(b) {
        lstrcpy(NewPath,File);
        *_tcsrchr(NewPath,TEXT('\\')) = 0;
    }

    return(b);
}

BOOL
IsValid8Dot3(
    IN LPCTSTR Path
    )

/*++

Routine Description:

    Check whether a path is valid 8.3.  The path may or may not start with
    a backslash.  Only backslashes are recognized as path separators.
    Individual characters are not checked for validity (ie, * would not
    invalidate the path).  The path may or may not terminate with a backslash.
    A component may have a dot without characters in the extension
    (ie, a\b.\c is valid).

    \ and "" are explicitly disallowed even though they fit the rules.

    Stolen from textmode\kernel sptarget.c

Arguments:

    Path - pointer to path to check.

Return Value:

    TRUE if valid 8.3, FALSE otherwise.

--*/

{
    UINT Count;
    BOOLEAN DotSeen,FirstChar;
    static LPCTSTR UsableChars = TEXT("_-ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");

    if((*Path == 0) || ((Path[0] == TEXT('\\')) && (Path[1] == 0))) {
        return(FALSE);
    }

    DotSeen = FALSE;
    FirstChar = TRUE;
    Count = 0;

    while(*Path) {

        //
        // Path points to start of current component (1 past the slash)
        //

        switch(*Path) {

        case TEXT('.'):
            if(FirstChar) {
                return(FALSE);
            }
            if(DotSeen) {
                return(FALSE);
            }

            Count = 0;
            DotSeen = TRUE;
            break;

        case TEXT('\\'):

            DotSeen = FALSE;
            FirstChar = TRUE;
            Count = 0;

            if(*(++Path) == TEXT('\\')) {

                // 2 slashes in a row
                return(FALSE);
            }

            continue;

        default:

            Count++;
            FirstChar = FALSE;

            if((Count == 4) && DotSeen) {
                return(FALSE);
            }

            if(Count == 9) {
                return(FALSE);
            }

            //
            // Make sure it's a printable, US character.
            //
            if( !_tcschr( UsableChars, *Path ) ) {
                return( FALSE );
            }

        }

        Path++;
    }

    return(TRUE);
}


BOOL
SaveLanguageOptions (
    IN      PCTSTR AnswerFile
    )
{
    UINT u;
    UINT rem;
    PTSTR list;
    TCHAR buf[32];
    LPTSTR  p;
    DWORD len;
    DWORD size;

    if (IntlInfProcessed) {

        if (!WritePrivateProfileString (
                WINNT_REGIONALSETTINGS,
                TEXT("LangInf"),
                WINNT_A_YES,
                AnswerFile
                )) {
            return FALSE;
        }

        wsprintf (buf, TEXT("%u"), PrimaryLocale);
        if (!WritePrivateProfileString(
                WINNT_REGIONALSETTINGS,
                TEXT("PrimaryLocaleIndex"),
                buf,
                AnswerFile
                )) {
            return FALSE;
        }

        size = rem = 32;
        list = MALLOC (size);
        if (!list) {
            return FALSE;
        }
        *list = 0;
        for (u = 0; u < LanguageGroupsCount; u++) {
            if (LanguageGroups[u].Selected) {
                len = wsprintf (buf, TEXT("%u"), u);
                while (len + 1 > rem) {
                    size *= 2;
                    list = REALLOC (list, size);
                    if (!list) {
                        return FALSE;
                    }
                    rem = size;
                }
                if (*list) {
                    lstrcat (list, TEXT(","));
                    rem--;
                }
                lstrcat (list, buf);
                rem -= len;
            }
        }

        if (*list) {
            if (!WritePrivateProfileString(
                    WINNT_REGIONALSETTINGS,
                    TEXT("Selected"),
                    list,
                    AnswerFile
                    )) {
                return FALSE;
            }
        }
        FREE( list );
    }

    return TRUE;
}

BOOL
LoadLanguageOptions (
    IN      PCTSTR AnswerFile
    )
{
    PTSTR optDirs;
    TCHAR buf[MAX_PATH];
    PTSTR list = NULL;
    PTSTR p, q;
    DWORD size;
    DWORD u;

    if (!IntlInfProcessed) {
        return FALSE;
    }

    GetPrivateProfileString (
            WINNT_REGIONALSETTINGS,
            TEXT("LangInf"),
            WINNT_A_NO,
            buf,
            MAX_PATH,
            AnswerFile
            );
    IntlInfProcessed = !lstrcmpi (buf, WINNT_A_YES);

    if (!IntlInfProcessed) {
        return FALSE;
    }

    if (!GetPrivateProfileString(
            WINNT_REGIONALSETTINGS,
            TEXT("PrimaryLocaleIndex"),
            TEXT(""),
            buf,
            MAX_PATH,
            AnswerFile
            )) {
        return FALSE;
    }
    PrimaryLocale = (DWORD) _ttol (buf);

    size = 16;
    do {
        if (!list) {
            list = MALLOC (size);
        } else {
            size *= 2;
            list = REALLOC (list, size);
        }
        if (!list) {
            return FALSE;
        }
        if (GetPrivateProfileString (
                WINNT_REGIONALSETTINGS,
                TEXT("Selected"),
                TEXT(""),
                list,
                size,
                AnswerFile
                ) < size - 1) {
            break;
        }
    } while (TRUE);

    p = list;
    do {
        q = _tcschr (p, TEXT(','));
        if (q) {
            *q = 0;
        }
        u = _ttol (p);
        if (u >= LanguageGroupsCount) {
            FREE (list);
            return FALSE;
        }
        LanguageGroups[u].Selected = TRUE;
        if (q) {
            p = q + 1;
        }
    } while (q);

    FREE (list);
    return TRUE;
}


BOOL
SaveAdvancedOptions (
    IN      PCTSTR AnswerFile
    )
{
    TCHAR buf[32];

    return
        (!MakeLocalSource ||
        WritePrivateProfileString (
            TEXT("AdvancedOptions"),
            TEXT("MakeLS"),
            WINNT_A_YES,
            AnswerFile
            )) &&
        (!UserSpecifiedMakeLocalSource ||
        WritePrivateProfileString (
            TEXT("AdvancedOptions"),
            TEXT("UserMakeLS"),
            WINNT_A_YES,
            AnswerFile
            )) &&
        (!Floppyless ||
        WritePrivateProfileString (
            TEXT("AdvancedOptions"),
            TEXT("Floppyless"),
            WINNT_A_YES,
            AnswerFile
            )) &&
        (!SystemPartitionDriveLetter ||
        WritePrivateProfileString (
            TEXT("AdvancedOptions"),
            TEXT("SysPartDriveLetter"),
            _ltot (SystemPartitionDriveLetter, buf, 10),
            AnswerFile
            )) &&
        (!ChoosePartition ||
        WritePrivateProfileString (
            TEXT("AdvancedOptions"),
            TEXT("ChoosePartition"),
            WINNT_A_YES,
            AnswerFile
            )) &&
        (!InstallDir[0] ||
        WritePrivateProfileString (
            TEXT("AdvancedOptions"),
            TEXT("InstallDir"),
            InstallDir,
            AnswerFile
            ));
}

BOOL
LoadAdvancedOptions (
    IN      PCTSTR AnswerFile
    )
{
    TCHAR buf[MAX_PATH];

    GetPrivateProfileString (
            TEXT("AdvancedOptions"),
            TEXT("MakeLS"),
            WINNT_A_NO,
            buf,
            MAX_PATH,
            AnswerFile
            );
    MakeLocalSource = !lstrcmpi (buf, WINNT_A_YES);

    GetPrivateProfileString (
            TEXT("AdvancedOptions"),
            TEXT("UserMakeLS"),
            WINNT_A_NO,
            buf,
            MAX_PATH,
            AnswerFile
            );
    UserSpecifiedMakeLocalSource = !lstrcmpi (buf, WINNT_A_YES);

    GetPrivateProfileString (
            TEXT("AdvancedOptions"),
            TEXT("Floppyless"),
            WINNT_A_NO,
            buf,
            MAX_PATH,
            AnswerFile
            );
    Floppyless = !lstrcmpi (buf, WINNT_A_YES);

    if (GetPrivateProfileString (
            TEXT("AdvancedOptions"),
            TEXT("SysPartDriveLetter"),
            TEXT(""),
            buf,
            MAX_PATH,
            AnswerFile
            )) {
        SystemPartitionDriveLetter = (TCHAR) _ttol (buf);
    }

    GetPrivateProfileString (
            TEXT("AdvancedOptions"),
            TEXT("ChoosePartition"),
            WINNT_A_NO,
            buf,
            MAX_PATH,
            AnswerFile
            );
    ChoosePartition = !lstrcmpi (buf, WINNT_A_YES);

    GetPrivateProfileString (
            TEXT("AdvancedOptions"),
            TEXT("InstallDir"),
            TEXT(""),
            InstallDir,
            sizeof (InstallDir) / sizeof (TCHAR),
            AnswerFile
            );

    return TRUE;
}

BOOL
SaveAccessibilityOptions (
    IN      PCTSTR AnswerFile
    )
{
    return
        (!AccessibleMagnifier ||
        WritePrivateProfileString (
            TEXT("AccessibilityOptions"),
            TEXT("AccessibleMagnifier"),
            WINNT_A_YES,
            AnswerFile
            )) &&
        (!AccessibleKeyboard ||
        WritePrivateProfileString (
            TEXT("AccessibilityOptions"),
            TEXT("AccessibleKeyboard"),
            WINNT_A_YES,
            AnswerFile
            )) &&
        (!AccessibleVoice ||
        WritePrivateProfileString (
            TEXT("AccessibilityOptions"),
            TEXT("AccessibleVoice"),
            WINNT_A_YES,
            AnswerFile
            )) &&
        (!AccessibleReader ||
        WritePrivateProfileString (
            TEXT("AccessibilityOptions"),
            TEXT("AccessibleReader"),
            WINNT_A_YES,
            AnswerFile
            ));
}

BOOL
LoadAccessibilityOptions (
    IN      PCTSTR AnswerFile
    )
{
    TCHAR buf[MAX_PATH];

    if (!AccessibleMagnifier)
    {
        GetPrivateProfileString (
                TEXT("AccessibilityOptions"),
                TEXT("AccessibleMagnifier"),
                WINNT_A_NO,
                buf,
                MAX_PATH,
                AnswerFile
                );
        AccessibleMagnifier = !lstrcmpi (buf, WINNT_A_YES);
    }

    GetPrivateProfileString (
            TEXT("AccessibilityOptions"),
            TEXT("AccessibleKeyboard"),
            WINNT_A_NO,
            buf,
            MAX_PATH,
            AnswerFile
            );
    AccessibleKeyboard = !lstrcmpi (buf, WINNT_A_YES);

    GetPrivateProfileString (
            TEXT("AccessibilityOptions"),
            TEXT("AccessibleVoice"),
            WINNT_A_NO,
            buf,
            MAX_PATH,
            AnswerFile
            );
    AccessibleVoice = !lstrcmpi (buf, WINNT_A_YES);

    GetPrivateProfileString (
            TEXT("AccessibilityOptions"),
            TEXT("AccessibleReader"),
            WINNT_A_NO,
            buf,
            MAX_PATH,
            AnswerFile
            );
    AccessibleReader = !lstrcmpi (buf, WINNT_A_YES);

    return TRUE;
}

BOOL IsFarEastLanguage(DWORD LangIdx)
{
    BOOL FarEastLang = FALSE;
    DWORD LangGroup;

    LangGroup = (DWORD) _ttol (LocaleList[LangIdx].LanguageGroup1);
    if ((LangGroup >= 7) && (LangGroup <= 10))
    {
        FarEastLang = TRUE;
    }
    else
    {
        if (LocaleList[LangIdx].LanguageGroup2)
        {
            LangGroup = (DWORD) _ttol (LocaleList[LangIdx].LanguageGroup2);
            if ((LangGroup >= 7) && (LangGroup <= 10))
            {
                FarEastLang = TRUE;
            }
        }
    }

    return FarEastLang;
}

BOOL SelectFarEastLangGroup (BOOL bSelect)
{
    DWORD LangIdx;

    for (LangIdx = 0; LangIdx < LanguageGroupsCount; LangIdx++)
    {
        // NOTE: Only FarEast Language should have a directory
        // If this ever changes, this code need to change too.
        if (LanguageGroups[LangIdx].Directory && 
            LanguageGroups[LangIdx].Directory[0] )
        {
            LanguageGroups[LangIdx].Selected = bSelect;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\lang.c ===
#include "precomp.h"
#pragma hdrstop


//
// Global variables defined here
//

//
// TargetNativeLangID : this is native language ID of running system
//
LANGID TargetNativeLangID;

//
// SourceNativeLangID : this is native language ID of new NT you want to install
//
LANGID SourceNativeLangID;

//
// IsLanguageMatched : if source and target language are matched (or compatible)
//
//                     1. if SourceNativeLangID == TargetNativeLangID
//
//                     2. if SourceNativeLangID's alternative ID == TargetNativeLangID
//
BOOL IsLanguageMatched;

typedef struct _tagLANGINFO {
    LANGID LangID;
    INT    Count;
} LANGINFO,*PLANGINFO;

BOOL 
TrustedDefaultUserLocale(
    HINF Inf,
    LANGID LangID);

BOOL
MySetupapiGetIntField(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PINT        IntegerValue,
    IN  int Base
    );


BOOL
CALLBACK
EnumLangProc(
    HANDLE hModule,     // resource-module handle
    LPCTSTR lpszType,   // pointer to resource type
    LPCTSTR lpszName,   // pointer to resource name
    WORD wIDLanguage,   // resource language identifier
    LONG_PTR lParam     // application-defined parameter
   )
/*++

Routine Description:

    Callback that counts versions stamps.

Arguments:

    Details of version enumerated version stamp. (Ignore.)

Return Value:

    Indirectly thru lParam: count, langID

--*/
{
    PLANGINFO LangInfo;

    LangInfo = (PLANGINFO) lParam;

    LangInfo->Count++;

    //
    // for localized build contains multiple resource, 
    // it usually contains 0409 as backup lang.
    //
    // if LangInfo->LangID != 0 means we already assigned an ID to it
    //
    // so when wIDLanguage == 0x409, we keep the one we got from last time 
    //
    if ((wIDLanguage == 0x409) && (LangInfo->LangID != 0)) {
        return TRUE;
    }

    LangInfo->LangID  = wIDLanguage;

    return TRUE;        // continue enumeration
}

LANGID 
GetNTDLLNativeLangID()
/*++

Routine Description:

    This function is designed specifically for getting native lang of ntdll.dll
    
    This is not a generic function to get other module's language
    
    the assumption is:
    
    1. if only one language in resource then return this lang
    
    2. if two languages in resource then return non-US language
    
    3. if more than two languages, it's invalid in our case, but returns the last one.

Arguments:

    None

Return Value:

    Native lang ID in ntdll.dll

--*/
{
    LPCTSTR Type = (LPCTSTR) RT_VERSION;
    LPCTSTR Name = (LPCTSTR) 1;

    LANGINFO LangInfo;

    ZeroMemory(&LangInfo,sizeof(LangInfo));

    EnumResourceLanguages(
            GetModuleHandle(TEXT("ntdll.dll")),
            Type,
            Name,
            EnumLangProc,
            (LONG_PTR) &LangInfo
            );

    if ((LangInfo.Count > 2) || (LangInfo.Count < 1) ) {
        //
        // put error log here
        //
        // so far, for NT 3.51, only JPN has two language resources
    }

    return LangInfo.LangID;
}

BOOL IsHongKongVersion()
/*++

Routine Description:

    Try to identify HongKong NT 4.0
    
    It based on:
    
    NTDLL's language is English and build is 1381 and
    pImmReleaseContext return TRUE
    
Arguments:
    

Return Value:

   Language ID of running system

--*/
{
    HMODULE hMod;
    BOOL bRet=FALSE;
    typedef BOOL (*IMMRELEASECONTEXT) (HWND,HANDLE);
    IMMRELEASECONTEXT pImmReleaseContext;

    LANGID TmpID = GetNTDLLNativeLangID();

    if ((OsVersion.dwBuildNumber == 1381) &&
        (TmpID == 0x0409)){

        hMod = LoadLibrary(TEXT("imm32.dll"));

        if (hMod) {

            pImmReleaseContext = (IMMRELEASECONTEXT) GetProcAddress(hMod,"ImmReleaseContext");

            if (pImmReleaseContext) {
                bRet = pImmReleaseContext(NULL,NULL);
            }

            FreeLibrary(hMod);
        }
    }
    return (bRet);
}

LANGID GetDefaultUserLangID()
{
    LONG            dwErr;
    HKEY            hkey;
    DWORD           dwSize;
    CHAR            buffer[512];
    LANGID          langid = 0;

    dwErr = RegOpenKeyEx( HKEY_USERS,
                          TEXT(".DEFAULT\\Control Panel\\International"),
                          0,
                          KEY_READ,
                          &hkey );

    if( dwErr == ERROR_SUCCESS ) {

        dwSize = sizeof(buffer);
        dwErr = RegQueryValueExA(hkey,
                                 "Locale",
                                 NULL,  //reserved
                                 NULL,  //type
                                 buffer,
                                 &dwSize );

        if(dwErr == ERROR_SUCCESS) {
            langid = LANGIDFROMLCID(strtoul(buffer,NULL,16));

        }
        RegCloseKey(hkey);
    }
    return langid;
}

LANGID 
GetTargetNativeLangID(
    HINF Inf)
/*++

Routine Description:

    Applies different rules to different platforms
    
    NT
        build number <= 1840           : check ntdll's language, 
                                         we scaned all 3.51's ntdll on boneyard\intl,
                                         it looks like we can trust them.
        build number > 1840            : user MUI language  
        
    Win9x                                                           
        use default user's resource language
    
Arguments:
    

Return Value:

   Language ID of running system

--*/
{
    LONG            dwErr;
    HKEY            hkey;
    DWORD           dwSize;
    CHAR            buffer[512];
    LANGID          rcLang;
    LANGID          langid = 0;


    // Find out if we are running on NT or WIN9X

    if( ISNT() ) {

        //
        // We're on NT, but which version?  GetSystemDefaultUILanguage() was broke until 1840...
        //
        if( OsVersion.dwBuildNumber > 1840 ) {
        FARPROC     NT5API;

            //
            // Use the API to find out our locale.
            //

            if( NT5API = GetProcAddress( GetModuleHandle(TEXT("kernel32.dll")), "GetSystemDefaultUILanguage") ) {

                rcLang = (LANGID)NT5API();
                //
                // need to convert decimal to hex, LANGID to chr.
                //
                langid = rcLang;
            }
        } else {

                //
                // by looking into \\boneyard\intl, almost every ntdll.dll marked correct lang ID
                // so get langID from ntdll.dll
                //

                langid = GetNTDLLNativeLangID();

                if (langid == 0x0409) {

                    if (IsHongKongVersion()) {

                        langid = 0x0C04;

                    } else {
                        //
                        // if default user's locale is in [TrustedDefaultUserLocale] in intl.inf
                        //
                        // then this is a backdoor for some localized build that its ntdll.dll marked
                        //
                        // as English but can't be upgrade by US version.
                        //
                        LANGID DefaultUserLangID = GetDefaultUserLangID();

                        if (DefaultUserLangID  && 
                            TrustedDefaultUserLocale(Inf,DefaultUserLangID)) {

                            langid = DefaultUserLangID;
                        }
                    }
                }

        }
    } else {

        //
        // We're on Win9x.
        //
        dwErr = RegOpenKeyEx( HKEY_USERS,
                              TEXT(".Default\\Control Panel\\desktop\\ResourceLocale"),
                              0,
                              KEY_READ,
                              &hkey );

        if (dwErr == ERROR_SUCCESS) {

            dwSize = sizeof(buffer);
            dwErr = RegQueryValueExA( hkey,
                                     "",
                                     NULL,  //reserved
                                     NULL,  //type
                                     buffer,
                                     &dwSize );

            if(dwErr == ERROR_SUCCESS) {
                langid = LANGIDFROMLCID(strtoul(buffer,NULL,16));
            }
            RegCloseKey(hkey);
        }

        if ( dwErr != ERROR_SUCCESS ) {
           // Check HKLM\System\CurrentControlSet\Control\Nls\Locale

           dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                TEXT("System\\CurrentControlSet\\Control\\Nls\\Locale"),
                                0,
                                KEY_READ,
                                &hkey );

           if (dwErr == ERROR_SUCCESS) {

              dwSize = sizeof(buffer);
              dwErr = RegQueryValueExA( hkey,
                                        "",
                                        NULL,  //reserved
                                        NULL,  //type
                                        buffer,
                                        &dwSize );

              if (dwErr == ERROR_SUCCESS) {
                  langid = LANGIDFROMLCID(strtoul(buffer,NULL,16));
              }
              RegCloseKey(hkey);
           }
        }
    }

    return (langid);
}


LANGID 
GetSourceNativeLangID(
    HINF Inf)
/*++

Routine Description:

    [DefaultValues]
    Locale = xxxx
    
    every localized build has it's own Locale in intl.inf, 
    
    so we use this value to identify source languag
        
Arguments:
    
Return Value:

   Language ID of source

--*/
{
    INFCONTEXT InfContext;
    LANGID langid = 0;
    INT i=0;

    if (SetupapiFindFirstLine( Inf, 
                               TEXT("DefaultValues"), 
                               TEXT("Locale"), 
                               &InfContext )) {


        if (MySetupapiGetIntField( &InfContext, 1, &i, 16 )) {
            langid = (LANGID)i;
        }
    }

    return langid;
}


DWORD 
GetOSMajorID(
    HINF Inf)
{
    INFCONTEXT InfContext;
    DWORD MajorId;
    INT i=0;

    MajorId = 0;

    if (SetupapiFindFirstLine( Inf, 
                               TEXT("OSVersionMajorID"), 
                               NULL, 
                               &InfContext )) {

        do {
            if (MySetupapiGetIntField( &InfContext, 2, &i, 10 )) {
                if (((ULONG)i) != OsVersion.dwPlatformId) {
                    continue;
                }
            }

            if (MySetupapiGetIntField( &InfContext, 3, &i, 10 )) {
                if (((ULONG)i) != OsVersion.dwMajorVersion) {
                    continue;
                }
            }

            if (MySetupapiGetIntField( &InfContext, 4, &i, 10 )) {
                if (((ULONG)i) != OsVersion.dwMinorVersion) {
                    continue;
                }
            }

            if (MySetupapiGetIntField( &InfContext, 1, &i, 16 )) {
                MajorId = (DWORD)i;
                break;
            }
        } while ( SetupapiFindNextLine(&InfContext,&InfContext));
    }

    return MajorId;
}

DWORD 
GetOSMinorID(
    HINF Inf)
{
    TCHAR Field[128];
    INFCONTEXT InfContext;
    DWORD MinorId;
    INT i = 0;

    MinorId = 0;

    if (SetupapiFindFirstLine( Inf, 
                               TEXT("OSVVersionMinorID"), 
                               NULL, 
                               &InfContext )) {

        do {
            if (MySetupapiGetIntField( &InfContext, 2, &i, 10 )) {
                if (((ULONG)i) != OsVersion.dwPlatformId) {
                    continue;
                }
            }

            if (MySetupapiGetIntField( &InfContext, 3, &i, 10 )) {
                if (((ULONG)i) != OsVersion.dwMajorVersion) {
                    continue;
                }
            }

            if (MySetupapiGetIntField( &InfContext, 4, &i, 10 )) {
                if (((ULONG)i) != OsVersion.dwMinorVersion) {
                    continue;
                }
            }

            if (MySetupapiGetIntField( &InfContext, 5, &i, 10 )) {
                if (((ULONG)i) != OsVersion.dwBuildNumber) {
                    continue;
                }
            }
            if (SetupapiGetStringField( &InfContext, 6, Field, (sizeof(Field)/sizeof(TCHAR)), NULL )) {

                if (lstrcmpi(Field,OsVersion.szCSDVersion) != 0) {
                    continue;
                }
            }

            if (MySetupapiGetIntField( &InfContext, 1, &i, 16 )) {
                MinorId = (DWORD)i;
                break;
            }

        } while ( SetupapiFindNextLine(&InfContext,&InfContext));
    }

    return MinorId;
}

BOOL 
TrustedDefaultUserLocale(
    HINF Inf,
    LANGID LangID)
{
    TCHAR LangIDStr[9];
    LPCTSTR Field;
    INFCONTEXT InfContext;
    INT i = 0;

    wsprintf(LangIDStr,TEXT("0000%04X"),LangID);
    if (SetupapiFindFirstLine( Inf, 
                               TEXT("TrustedDefaultUserLocale"), 
                               LangIDStr, 
                               &InfContext )) {
        do {
            //
            // if in excluded field, this is not what we want
            //
            if (MySetupapiGetIntField( &InfContext, 3, &i, 16 )) {    
                if (((ULONG)i) & GetOSMinorID(Inf)) {
                    continue;
                }
            }

            //
            // if it is in minor version list, we got what we want
            //
            if (MySetupapiGetIntField( &InfContext, 2, &i, 16 )) {    

                if (((ULONG)i) & GetOSMinorID(Inf)) {
                    return TRUE;
                }
            } 

            //
            // or if it is in major version list, we also got what we want
            //
            if (MySetupapiGetIntField( &InfContext, 1, &i, 16 )) {    
                if (((ULONG)i) & GetOSMajorID(Inf)) {
                    return TRUE;
                }
            }

        } while ( SetupapiFindNextLine(&InfContext,&InfContext));
    }
    return FALSE;
}

BOOL 
IsInExcludeList(
    HINF Inf,
    LANGID LangID)
{
    TCHAR LangIDStr[9];
    LPCTSTR Field;
    INFCONTEXT InfContext;
    INT i = 0;

    wsprintf(LangIDStr,TEXT("0000%04X"),LangID);
    if (SetupapiFindFirstLine( Inf, 
                               TEXT("ExcludeSourceLocale"), 
                               LangIDStr, 
                               &InfContext )) {
        do {
            //
            // if in excluded field, this is not what we want
            //
            if (MySetupapiGetIntField( &InfContext, 3, &i, 16 )) {    
                if (((ULONG)i) & GetOSMinorID(Inf)) {
                    continue;
                }
            }

            //
            // if it is in minor version list, we got what we want
            //
            if (MySetupapiGetIntField( &InfContext, 2, &i, 16 )) {    

                if (((ULONG)i) & GetOSMinorID(Inf)) {
                    return TRUE;
                }
            } 

            //
            // or if it is in major version list, we also got what we want
            //
            if (MySetupapiGetIntField( &InfContext, 1, &i, 16 )) {    
                if (((ULONG)i) & GetOSMajorID(Inf)) {
                    return TRUE;
                }
            }

        } while ( SetupapiFindNextLine(&InfContext,&InfContext));
    }
    return FALSE;
}

BOOL 
CheckLanguageVersion(
    HINF Inf,
    LANGID SourceLangID,
    LANGID TargetLangID)
/*++

Routine Description:

    Check if the language of source NT is same as target NT or ,at least, 
    
    compatibile
    
Arguments:

    Inf    handle of intl.inf

Return Value:

   TRUE  They are same or compatibile
   FALSE They are different
   
--*/
{
    TCHAR TargetLangIDStr[9];

    LANGID SrcLANGID;
    LANGID DstLANGID;

    LPCTSTR Field;
    INFCONTEXT InfContext;
    INT i = 0;

    //
    // If either one is 0, allow the upgrade. This is Windows 2000 Beta3 behavior.
    //
    if (SourceLangID == 0 || TargetLangID == 0) {
        return TRUE;
    }

    if (SourceLangID == TargetLangID) {
        //
        // special case, for Middle East version, NT5 is localized build but NT4 is not
        //
        // they don't allow NT5 localized build to upgrade NT4, although they are same language
        //
        // so we need to exclude these
        //
        return ((IsInExcludeList(Inf, SourceLangID) == FALSE));
    }

    //
    // if Src != Dst, then we need to look up inf file to see
    //
    // if we can open a backdoor for Target language
    //

    //
    // use TargetLangID as key to find alternative SourceLangID
    //

    wsprintf(TargetLangIDStr,TEXT("0000%04X"),TargetLangID);

    if (SetupapiFindFirstLine( Inf, 
                               TEXT("AlternativeSourceLocale"), 
                               TargetLangIDStr, 
                               &InfContext )) {
        
        do {
            //
            // Check if we found alternative locale
            //
            if (MySetupapiGetIntField(&InfContext, 1, &i, 16)) {

                LANGID AltSourceLangID = LANGIDFROMLCID(i);
    
                if (SourceLangID != AltSourceLangID) {
                    continue;
                }

            }

            //
            // We are here if we found alternative source lang, 
            //
            // now check the version criteria
            //

            //
            // if in excluded list, this is not what we want
            //
            if (MySetupapiGetIntField( &InfContext, 4, &i, 16 )) {    
                if (((ULONG)i) & GetOSMinorID(Inf)) {
                    continue;
                }
            }

            //
            // if it is in minor version list, we got what we want
            //
            if (MySetupapiGetIntField( &InfContext, 3, &i, 16 )) {    

                if (((ULONG)i) & GetOSMinorID(Inf)) {
                    return TRUE;
                }
            } 

            //
            // or if it is in major version list, we also got what we want
            //
            if (MySetupapiGetIntField( &InfContext, 2, &i, 16 )) {    
                if (((ULONG)i) & GetOSMajorID(Inf)) {
                    return TRUE;
                }
            }

        } while ( SetupapiFindNextMatchLine (&InfContext,TargetLangIDStr,&InfContext));
    }
    return FALSE;
}


BOOL InitLanguageDetection(LPCTSTR SourcePath,LPCTSTR InfFile)
/*++

Routine Description:

    Initialize language detection and put the result in 3 global variables
    
    SourceNativeLangID  - LANGID of Source (NT is going to be installed)
    
    TargetNativeLangID  - LANGID of Target (OS system which is running)
    
    IsLanguageMatched - If language is not matched, then blocks upgrade
    
Arguments:

    SourcePath    directory path of INF file
    
    InfFile       INF file name   

Return Value:

   TRUE  init correctly
   FALSE init failed

--*/
{
    HINF    Inf;
    TCHAR   InfName[MAX_PATH];

    FindPathToInstallationFile( InfFile, InfName, MAX_PATH );

    Inf = SetupapiOpenInfFile( InfName, NULL, INF_STYLE_WIN4, NULL );

    if (Inf == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // Init Global Variables
    //
  
    SourceNativeLangID  = GetSourceNativeLangID(Inf);

    TargetNativeLangID  = GetTargetNativeLangID(Inf);

    IsLanguageMatched = CheckLanguageVersion(Inf,SourceNativeLangID,TargetNativeLangID);

    SetupapiCloseInfFile(Inf);

    return TRUE;
}

BOOL
MySetupapiGetIntField(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PINT        IntegerValue,
    IN  int Base
    )
/*
    Routine to get a field from an INF file and convert to an integer. The reason
    we have this and don't use Setupapi!SetupGetIntField is because intl.inf mixes and matches 
    numeric conventions. It may use Hex values without a 0x notation and this is an attempt
    to clean that up without modifying the INF. With this change we also won't link to internal Setupapi routines 
    like pSetupGetField.
    
    Arguments:
    
        PINFCONTEXT : - Pointer to setupapi INFCONTEXT structure
        FieldIndex  : - 1-based index for fields, 0 for key itself.
        IntegerValue : - Converted Integer value that is returned by the function
        Base : - Base used for string to integer conversion.
        
    Return Value:
    
        TRUE - If we could convert the returned string to an integer else,
        FALSE
                

*/
{
    DWORD Size = 0;
    PTSTR Field = NULL;
    BOOL Ret = FALSE;

    if( IntegerValue == NULL )
        return FALSE;

    if (Context) {

        if( SetupapiGetStringField( Context, FieldIndex, NULL, 0, &Size )){

            if (Field = MALLOC( Size * sizeof( TCHAR))){

                if( SetupapiGetStringField( Context, FieldIndex, Field, Size, NULL )){

                    *IntegerValue = _tcstoul( Field, NULL, Base );
                    Ret = TRUE;

                }
            }
        }
    }

    if( Field )
        FREE( Field );

    return Ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\misc.c ===
#include "precomp.h"
#pragma hdrstop
#include "sxs.h"

BOOL ForceNTFSConversion;

ULONG
CheckRegKeyVolatility (
    IN HKEY     Root,
    IN LPCTSTR  KeyPath
    )

{
    HKEY    Key;
    HKEY    TestKey;
    ULONG   Error;
    PTSTR   TestKeyName = TEXT( "$winnt32$_test" );
    DWORD   Disposition;

    Error = RegOpenKeyEx( Root,
                          KeyPath,
                          0,
                          MAXIMUM_ALLOWED,
                          &Key );

    if( Error != ERROR_SUCCESS ) {
        return ( Error );

    }

    Error = RegCreateKeyEx( Key,
                            TestKeyName,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            MAXIMUM_ALLOWED,
                            NULL,
                            &TestKey,
                            &Disposition );

    if( Error == ERROR_SUCCESS ) {
        RegCloseKey( TestKey );
        RegDeleteKey( Key, TestKeyName );
    }
    RegCloseKey( Key );
    return( Error );
}


ULONG
DumpRegKeyToInf(
    IN  PINFFILEGEN InfContext,
    IN  HKEY        PredefinedKey,
    IN  LPCTSTR     FullKeyPath,
    IN  BOOL        DumpIfEmpty,
    IN  BOOL        DumpSubKeys,
    IN  BOOL        SetNoClobberFlag,
    IN  BOOL        DumpIfVolatileKey
    )
{
    HKEY    Key;
    ULONG   Error;
    TCHAR   SubKeyName[ MAX_PATH + 1 ];
    ULONG   SubKeyNameLength;
    ULONG   cSubKeys;
    ULONG   cValues;
    ULONG   MaxValueNameLength;
    ULONG   MaxValueLength;
    LPTSTR  ValueName;
    PBYTE   ValueData;
    ULONG   i;
    LPTSTR  SubKeyFullPath;
    ULONG   MaxSubKeyNameLength;

    //
    //  Open the key for read access
    //
    Error = RegOpenKeyEx( PredefinedKey,
                          FullKeyPath,
                          0,
                          KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                          &Key );

    if( Error != ERROR_SUCCESS ) {
        //
        //  If the key doesn't exist, than assume it got dumped.
        //
        return( ( Error == ERROR_PATH_NOT_FOUND )? ERROR_SUCCESS : Error );
    }

    //
    //  Find out if the key is empty (has no subkeys, and no values)
    //
    Error = RegQueryInfoKey( Key,
                             NULL,
                             NULL,
                             NULL,
                             &cSubKeys,
                             &MaxSubKeyNameLength,
                             NULL,
                             &cValues,
                             &MaxValueNameLength,
                             &MaxValueLength,
                             NULL,
                             NULL );

    if( Error != ERROR_SUCCESS ) {
        RegCloseKey( Key );
        return( Error );
    }

    if( !DumpIfEmpty && (cSubKeys == 0) && (cValues == 0) ) {
        RegCloseKey( Key );
        return( ERROR_SUCCESS );
    }

    if( !DumpIfVolatileKey ) {
        //
        //  If we are not supposed to dump volatile keys, then check if the key is volatile.
        //
        Error = CheckRegKeyVolatility ( PredefinedKey,
                                        FullKeyPath );
        if( Error == ERROR_CHILD_MUST_BE_VOLATILE ) {
            //
            //  The key is volatile, so skip it.
            //
            RegCloseKey( Key );
            return( ERROR_SUCCESS );
        } else if( Error != ERROR_SUCCESS ) {
            //
            //  We don't knlw if the key is volatile or non-volatile.
            RegCloseKey( Key );
            return( Error );
        }
    }


    Error = InfRecordAddReg( InfContext,
                             PredefinedKey,
                             FullKeyPath,
                             NULL,
                             REG_NONE,
                             NULL,
                             0,
                             SetNoClobberFlag );

    if( Error != ERROR_SUCCESS ) {
        RegCloseKey( Key );
        return( Error );
    }


    if( cValues != 0 ) {
        ValueName = (LPTSTR)MALLOC( (MaxValueNameLength + 1)*sizeof(TCHAR) );
        if( !ValueName ) {
	    return ERROR_OUTOFMEMORY;
        }
        ValueData = (PBYTE)MALLOC( MaxValueLength );
        if( !ValueData ) {
	    FREE( ValueName );
            return ERROR_OUTOFMEMORY;
        }

        //
        //  Dump the value entries
        //
        for( i = 0; i < cValues; i++ ) {
            ULONG   ValueNameLength;
            ULONG   ValueType;
            ULONG   DataSize;

            ValueNameLength = MaxValueNameLength + 1;
            DataSize = MaxValueLength;
            Error = RegEnumValue( Key,  // handle of key to query
                                  i,
                                  ValueName,
                                  &ValueNameLength,
                                  NULL,
                                  &ValueType,
                                  ValueData,
                                  &DataSize );

            if( Error != ERROR_SUCCESS ) {
                break;
            }

            Error = InfRecordAddReg( InfContext,
                                     PredefinedKey,
                                     FullKeyPath,
                                     ValueName,
                                     ValueType,
                                     ValueData,
                                     DataSize,
                                     SetNoClobberFlag );

            if( Error != ERROR_SUCCESS ) {
                break;
            }
        }

        FREE( ValueName );
        FREE( ValueData );
        if( Error != ERROR_SUCCESS ) {
            RegCloseKey( Key );
            return( Error );
        }
    }

    //
    //  Check if subkeys neeed to be dumped
    //
    if( !DumpSubKeys || (cSubKeys == 0) ) {
        RegCloseKey( Key );
        return( ERROR_SUCCESS );
    }
    //
    //  Dump the subkeys
    //
    SubKeyFullPath = (LPTSTR)MALLOC( (lstrlen(FullKeyPath) + 1 + MaxSubKeyNameLength + 1)*sizeof(TCHAR) );
    if( SubKeyFullPath == NULL ) {
        RegCloseKey( Key );
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    for( i = 0; i < cSubKeys; i++ ) {
        SubKeyNameLength = sizeof( SubKeyName )/sizeof( TCHAR );

        Error = RegEnumKeyEx( Key,
                              i,
                              SubKeyName,
                              &SubKeyNameLength,
                              NULL,
                              NULL,
                              NULL,
                              NULL );
        if( Error != ERROR_SUCCESS ) {
            break;
        }

        lstrcpy( SubKeyFullPath, FullKeyPath );
        lstrcat( SubKeyFullPath, TEXT("\\") );
        lstrcat( SubKeyFullPath, SubKeyName );
        Error = DumpRegKeyToInf( InfContext,
                                 PredefinedKey,
                                 SubKeyFullPath,
                                 DumpIfEmpty,
                                 DumpSubKeys,
                                 SetNoClobberFlag,
                                 DumpIfVolatileKey);
        if( Error != ERROR_SUCCESS ) {
            break;
        }
    }
    FREE( SubKeyFullPath );
    RegCloseKey( Key );
    return( Error );
}



BOOL
GetAndSaveNTFTInfo(
    IN HWND ParentWindow
    )
{
    static BOOL Done = FALSE;
    HKEY Key;
    DWORD d;
    LONG l;
    TCHAR HiveName[MAX_PATH];
    PINFFILEGEN   InfContext;

    LONG    i;
    LPTSTR  KeysToMigrate[] = {
                              TEXT("SYSTEM\\DISK"),
                              TEXT("SYSTEM\\MountedDevices")
                              };


    if(Done) {
        return(TRUE);
    }

    Done = TRUE;

    //
    //  Before we migrate the disk information, make the drive letters sticky.
    //  This will ensure that the drive letters assigned during textmode setup
    //  are consistent with the drive letters in the current system.
    //
    ForceStickyDriveLetters();

    //
    // Load up the setupreg.hiv hive.
    //
    if (!IsArc()) {
#ifdef _X86_
        if(Floppyless) {
            lstrcpy(HiveName,LocalBootDirectory);
        } else {
            HiveName[0] = FirstFloppyDriveLetter;
            HiveName[1] = TEXT(':');
            HiveName[2] = 0;
        }
#endif
    } else {
        lstrcpy(HiveName,LocalSourceWithPlatform);
    }

    l = InfStart( WINNT_MIGRATE_INF_FILE,
                  HiveName,
                  &InfContext);

    if(l != NO_ERROR) {

        MessageBoxFromMessageAndSystemError(
            ParentWindow,
            MSG_CANT_SAVE_FT_INFO,
            l,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

        return(FALSE);
    }

    l = InfCreateSection( TEXT("Addreg"), &InfContext );
    if(l != NO_ERROR) {

        MessageBoxFromMessageAndSystemError(
            ParentWindow,
            MSG_CANT_SAVE_FT_INFO,
            l,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

        return(FALSE);
    }

    //
    //  Dump each key to MIGRATE.INF.
    //
    for( i = 0; i < sizeof(KeysToMigrate)/sizeof(LPTSTR); i++ ) {
        //
        //  Check if the key exists
        //
        l = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                KeysToMigrate[i],
                0,
                KEY_QUERY_VALUE,
                &Key
                );

        if(l != NO_ERROR) {
            if( l == ERROR_FILE_NOT_FOUND ) {
                //
                // The key does not exist.
                // This is OK, just continue the migration of other keys
                //
                continue;
            } else {
                //
                //  The key exists but we cannot read it
                //
                MessageBoxFromMessageAndSystemError(
                    ParentWindow,
                    MSG_CANT_SAVE_FT_INFO,
                    l,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL
                    );
                InfEnd( &InfContext );
                return(FALSE);
            }
        }
        RegCloseKey( Key );
        //
        //  The key exists, so go ahead and dump it.
        //
        l = DumpRegKeyToInf( InfContext,
                             HKEY_LOCAL_MACHINE,
                             KeysToMigrate[i],
                             FALSE,
                             FALSE,
                             FALSE,
                             TRUE );

        if(l != NO_ERROR) {
                MessageBoxFromMessageAndSystemError(
                    ParentWindow,
                    MSG_CANT_SAVE_FT_INFO,
                    l,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL
                    );

                InfEnd( &InfContext );
                return(FALSE);
        }
    }
    InfEnd( &InfContext );
    return(TRUE);
}


BOOL
ForceBootFilesUncompressed(
    IN HWND ParentWindow,
    IN BOOL TellUserAboutError
    )

/*++

Routine Description:

    This routine ensures that critical boot files (ntldr and $ldr$ on x86)
    are uncompressed. On ARC we also make sure setupldr is uncompressed,
    even though this is not strictly necessary since the system partition
    is always supposed to be FAT, just in case.

Arguments:

    ParentWindow - supplies window handle for window to act as parent/owner of
        any ui windows this routine may display

    TellUserAboutError - if TRUE and and an error occurs, the user will get
        an error message. Otherwise the routine does not tell the user
        about errors.

Return Value:

    Boolean value indicating whether relevent files were processed
    successfully.

--*/

{
    TCHAR Filename[MAX_PATH];


#if defined(REMOTE_BOOT)
    //
    // For remote boot, the loader is on the server, so we don't need to
    // worry about whether it's compressed.
    //
    if (RemoteBoot) {
        return(TRUE);
    }
#endif // defined(REMOTE_BOOT)

    if (!IsArc()) {
#ifdef _X86_
        //
        // File is NTLDR on BIOS, but don't do this unless we're
        // dealing with the floppyless case.
        //
        if(!MakeBootMedia || !Floppyless) {
            return(TRUE);
        }
        BuildSystemPartitionPathToFile (TEXT("NTLDR"), Filename, MAX_PATH);
#endif // _X86_
    } else {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
        BuildSystemPartitionPathToFile (SETUPLDR_FILENAME, Filename, MAX_PATH);
#endif // UNICODE
    } // if (!IsArc())

    if(!ForceFileNoCompress(Filename)) {
        if(TellUserAboutError) {
            MessageBoxFromMessageAndSystemError(
                ParentWindow,
                MSG_BOOT_FILE_ERROR,
                GetLastError(),
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                Filename
                );
        }
        return(FALSE);
    }

    //
    // Also do $LDR$
    //
    if (!IsArc()) {
#ifdef _X86_
        BuildSystemPartitionPathToFile (AUX_BS_NAME, Filename, MAX_PATH);
        if(!ForceFileNoCompress(Filename)) {
            if(TellUserAboutError) {
                MessageBoxFromMessageAndSystemError(
                    ParentWindow,
                    MSG_BOOT_FILE_ERROR,
                    GetLastError(),
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL,
                    Filename
                    );
            }
            return(FALSE);
        }
#endif // _X86_
    } // if (!IsArc())

    return(TRUE);
}

BOOL
InDriverCacheInf( 
    IN      PVOID InfHandle, 
    IN      PCTSTR FileName,
    OUT     PTSTR DriverCabName,        OPTIONAL
    IN      DWORD BufferChars           OPTIONAL
    )
{
    PCTSTR     SectionName;
    UINT       i;
    

    if( !InfHandle ) {
        return( FALSE );
    }

    //
    // Now get the section names that we have to search.
    //
    i = 0;
    SectionName = InfGetFieldByKey ( 
                            InfHandle, 
                            TEXT("Version"), 
                            TEXT("CabFiles"),
                            i);


    if (SectionName) {
    
    
        //
        // Search the sections for our entry.
        //
        do {                   
            
            if( InfDoesEntryExistInSection(InfHandle, SectionName, FileName)){
                if (DriverCabName) {
                    //
                    // fill out the parameter
                    //
                    PCTSTR p = InfGetFieldByKey ( 
                                    InfHandle, 
                                    TEXT("Cabs"), 
                                    SectionName,
                                    0
                                    );
                    if (p) {
                        lstrcpyn (DriverCabName, p, BufferChars);
                    } else {
                        *DriverCabName = 0;
                    }
                }
                //
                // we found a match
                //
                return(TRUE);    
            }
            
            i++;
            SectionName = InfGetFieldByKey ( 
                            InfHandle, 
                            TEXT("Version"), 
                            TEXT("CabFiles"),
                            i);


        } while ( SectionName);

    }

    //
    // If we get here, we didn't find a match.
    //
    return( FALSE );




}



BOOL
CreatePrivateFilesInf(
    IN PCTSTR PrivatesDirectory,
    IN PCTSTR InfName)
{
    
    TCHAR infPath[MAX_PATH];
    TCHAR DriverInfName[MAX_PATH];
    TCHAR Search[MAX_PATH];
    WIN32_FIND_DATA CurrentFileInfo;
    HANDLE CurrentFile;
    PVOID InfHandle;
    BOOL retval = FALSE;
    DWORD d;
    HANDLE hPrivateInfFile;
    DWORD dontcare = 0;
    PCSTR privates = "[Privates]\r\n";

    lstrcpy(infPath,LocalSourceWithPlatform);
    ConcatenatePaths( infPath, InfName, MAX_PATH);

    lstrcpy(Search, PrivatesDirectory);
    ConcatenatePaths( Search, TEXT("*"), MAX_PATH);

    lstrcpy(DriverInfName, NativeSourcePaths[0]);
    ConcatenatePaths( DriverInfName, DRVINDEX_INF, MAX_PATH);

    CurrentFile = FindFirstFile(Search,&CurrentFileInfo);
    
    if (CurrentFile == INVALID_HANDLE_VALUE) {
        goto e0;
    }

    d = LoadInfFile( DriverInfName, FALSE, &InfHandle );
    
    if (d != NO_ERROR) {
        goto e1;
    }

    WritePrivateProfileString(TEXT("Version"),
                              TEXT("Signature"),
                              TEXT("\"$Windows NT$\""), 
                              infPath);    

#ifdef _X86_
	WritePrivateProfileString(
                    TEXT("DestinationDirs"),
				    TEXT("Privates"),
                    IsNEC98() ?
                        TEXT("10,\"Driver Cache\\nec98\"") :
				        TEXT("10,\"Driver Cache\\i386\""),
				    infPath
                    );
#else
	WritePrivateProfileString(
                    TEXT("DestinationDirs"),
				    TEXT("Privates"),
				    TEXT("10,\"Driver Cache\\ia64\""),
				    infPath
                    );
#endif

    WritePrivateProfileString(TEXT("InstallSection"),
                              TEXT("CopyFiles"),
                              TEXT("Privates"), 
                              infPath);

#ifndef UNICODE
    WritePrivateProfileString (NULL, NULL, NULL, infPath);
#endif

    //
    // writeprivateprofilestring works for the above, but doesnt work for 
    // adding files to the section, so we have to do it manually...yuck!
    //
    hPrivateInfFile = CreateFile(
                            infPath,
                            GENERIC_WRITE,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL
                            );

    if (hPrivateInfFile == INVALID_HANDLE_VALUE) {
        goto e2;
    }

    //
    // seek to the end of the file so we don't overwrite everything we already
    // put in there
    //
    SetFilePointer(hPrivateInfFile,0,0,FILE_END);
    
    WriteFile(hPrivateInfFile,(LPCVOID)privates,lstrlenA(privates),&dontcare,NULL);    
    
    do {
        if (InDriverCacheInf( InfHandle, CurrentFileInfo.cFileName, NULL, 0 )) {
            CHAR AnsiFile[MAX_PATH];
            DWORD Size;
            DWORD Written;
              
#ifdef UNICODE
        WideCharToMultiByte(
             CP_ACP,
             0,
             CurrentFileInfo.cFileName,
             -1,
             AnsiFile,
             sizeof(AnsiFile),
             NULL,
             NULL
             );
#else
        lstrcpyn(AnsiFile,CurrentFileInfo.cFileName,sizeof(AnsiFile));
#endif

        strcat(AnsiFile,"\r\n");
        WriteFile(hPrivateInfFile,AnsiFile,lstrlenA(AnsiFile),&Written,NULL);        

        }

    } while ( FindNextFile(CurrentFile,&CurrentFileInfo) );

    CloseHandle(hPrivateInfFile);

    retval = TRUE;

e2:
    UnloadInfFile( InfHandle );
e1:
    FindClose( CurrentFile );
e0:
    return(retval);
}


DWORD
DoPostCopyingStuff(
    IN PVOID ThreadParam
    )

/*++

Routine Description:

    This routine performs actions that are done after copying has been
    finished. This includes

    - X86 boot stuff (boot.ini, boot code, etc)
    - Saving NTFT information into the setup hive
    - Forcing ntldr or setupldr to be uncompressed

Arguments:

Return Value:

--*/

{
    HANDLE ThreadHandle;
    DWORD ThreadId;
    BOOL b;

    //
    //  Check to see if delta.cat was processed as a result of 
    //  /m so that we can write the "includecatalog = delta.cat"
    //  to winnt.sif
    //

    if ((AlternateSourcePath[0] != UNICODE_NULL) && MakeLocalSource) {
        TCHAR Buff[MAX_PATH];
        LPCTSTR WinntSetupSection = WINNT_SETUPPARAMS;

        lstrcpy( Buff, LocalSourceWithPlatform );
        ConcatenatePaths( Buff, TEXT("delta.cat"), MAX_PATH);


        if( FileExists(Buff,NULL) ){

            // Write out entry into winnt.sif

            WritePrivateProfileString(WinntSetupSection,WINNT_S_INCLUDECATALOG,TEXT("delta.cat"),ActualParamFile);
            
        }

        //
        // also create an inf file for the files that were changed and copy it to the local source as well
        //
        CreatePrivateFilesInf(AlternateSourcePath, TEXT("delta.inf"));

    }

#ifdef TEST_EXCEPTION
    DoException( 4);
#endif


    //
    // ALWAYS do this, since the system might not boot otherwise.
    //
    if(b = ForceBootFilesUncompressed(ThreadParam,TRUE)) {

        //
        // In the BIOS case, lay boot code, munge boot.ini, etc.
        //
        if (!IsArc()) {
#ifdef _X86_
            if(MakeBootMedia && Floppyless) {
                b = DoX86BootStuff(ThreadParam);
            }
#endif // _X86_
        } // if (!IsArc())

        //
        // In the NT case, also save off disk information into
        // the tiny setup system hive. This is done on both clean
        // install and upgrade case, so that drive letters can be
        // preserved.
        // Drive letters should not be migrated on OEM preinstall case
        //
        if(ISNT() && !OemPreinstall
#ifdef _X86_
           && MakeBootMedia
#endif
        ) {
            if( !GetAndSaveNTFTInfo(ThreadParam) ) {
                b = FALSE;
            }
        }
    }

    {
        SXS_CHECK_LOCAL_SOURCE SxsCheckLocalSourceParameters = { 0 };

        SxsCheckLocalSourceParameters.ParentWindow = ThreadParam;
        if (!SxsCheckLocalSource(&SxsCheckLocalSourceParameters))
        {
            b = FALSE;
        }
    }

    PostMessage(ThreadParam,WMX_I_AM_DONE,b,0);
    return(b);
}


BOOL
IsNTFSConversionRecommended(
    void
    )
{
    if (UnattendedOperation) {
        return FALSE;
    }

    if (TYPICAL() || !ISNT()) {
        //
        // NTFS conversion is not recommended
        // for win9x upgrades or if the user chooses typical
        //
        return FALSE;
    }

    if (NTFSConversionChanged) {
        return ForceNTFSConversion;
    }

    return TRUE;
}


BOOL
NTFSConvertWizPage(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    PPAGE_RUNTIME_DATA WizPage = (PPAGE_RUNTIME_DATA)GetWindowLongPtr(hdlg,DWLP_USER);
    static BOOL bPainted = FALSE;


    switch(msg) {
        case WM_INITDIALOG:
            if (!UnattendedOperation) {
                CheckRadioButton( hdlg, IDOK, IDCANCEL, IsNTFSConversionRecommended() ? IDOK : IDCANCEL );
                if (TYPICAL())
                {
                    ForceNTFSConversion = FALSE;
                }
            }
            break;

	case WM_CTLCOLORDLG:
	    bPainted = TRUE;
	    return FALSE;

        case WMX_ACTIVATEPAGE:

            if(wParam) {
                HCURSOR OldCursor;
                MSG msgTemp;
                TCHAR buf[MAX_PATH];

                //
                // don't activate the page in restart mode
                //
                if (Winnt32RestartedWithAF ()) {
                    if (GetPrivateProfileString(
                            WINNT_UNATTENDED,
                            TEXT("ForceNTFSConversion"),
                            TEXT(""),
                            buf,
                            sizeof(buf) / sizeof(TCHAR),
                            g_DynUpdtStatus->RestartAnswerFile
                            )) {
                        ForceNTFSConversion = !lstrcmpi (buf, WINNT_A_YES);
                    }
                    return FALSE;
                }

		        // Scanning for drives can take a bit of time, so we lets change
		        // the cursor to let the user know this should take a while
                OldCursor = SetCursor(LoadCursor (NULL, IDC_WAIT));


#ifdef _X86_

                //
                // Skip if this is a clean install from Win95 so that dual boot is safe
                //
                if( !Upgrade && !ISNT() ){
                    SetCursor(OldCursor);
                    return( FALSE );
                }


                //
                // We will skip this wizard page if in Win9x upgrade and Boot16 option is ON.
                //
                if (Upgrade && !ISNT() && (g_Boot16 == BOOT16_YES)) {
                    SetCursor(OldCursor);
                    return FALSE;
                }
#endif


                //
                // We may not want to display this page under
                // certain circumstances.
                //
                if( ISNT() && Upgrade ) {
                    TCHAR   Text[MAX_PATH];
                    //
                    // We're on NT and we know where the %windir%
                    // will be since we're doing an upgrade.  Is
                    // it on a partition that's already NTFS?  If so,
                    // don't bother with this page.
                    //
                    MyGetWindowsDirectory( Text, MAX_PATH );
                    if( IsDriveNTFS( Text[0] ) ) {
                        SetCursor(OldCursor);
                        return FALSE;
                    }

                    if (IsArc()) {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
                        //
                        // Let's also make sure we're not asking to
                        // upgrade the system partition on ARC (which
                        // must remain FAT).
                        //
                        MyGetWindowsDirectory( Text, MAX_PATH );
                        if( SystemPartitionDriveLetter == Text[0] ) {
                            SetCursor(OldCursor);
                            return FALSE;
                        }
#endif // UNICODE
                    } // if (IsArc())
                }


                //
                // Last, but not least, disallow the page if all partitions
                // are already NTFS...
                //
                if( ISNT() ) {
                BOOL AllNTFS = TRUE;
                TCHAR DriveLetter;
                    for( DriveLetter = TEXT('A'); DriveLetter <= TEXT('Z'); DriveLetter++ ) {

                        //
                        // Skip the system partition drive on ARC
                        //
                        if( (IsArc() && (DriveLetter != SystemPartitionDriveLetter)) || !IsArc() ) {

                            AllNTFS &= (
                                         //
                                         // Is the drive NTFS?
                                         //
                                         (IsDriveNTFS(DriveLetter)) ||

                                         //
                                         // If it's removable, don't even
                                         // consider it because we can't
                                         // install there anyway.  This gets
                                         // around the problem where the
                                         // user has a CD in his CDROM drive
                                         // or has a floppy in his floppy drive
                                         // while we're doing this check.
                                         //
                                         (MyGetDriveType(DriveLetter) != DRIVE_FIXED) );

                        }
                    }

                    if( AllNTFS ) {
			SetCursor(OldCursor);
                        return FALSE;
                    }
                }

                //
                // Activation.
                //

                //
                // WMX_VALIDATE will return TRUE if the page should be skipped,
                // that is if we are in unattended mode and the parameters are OK.
                //

                if (CallWindowProc ((WNDPROC)NTFSConvertWizPage, hdlg, WMX_VALIDATE, 0, 0)) {
		    SetCursor(OldCursor);
                    return FALSE;
                }

		// if we get this far, we want to empty the message cue, to make sure
		// that people will see this page, and not accidentally agree to
		// converting their drives because they were antsy
		
		while (PeekMessage(&msgTemp,NULL,WM_MOUSEFIRST,WM_MOUSELAST,PM_REMOVE));
		while (PeekMessage(&msgTemp,NULL,WM_KEYFIRST,WM_KEYLAST,PM_REMOVE));

		SetCursor(OldCursor);
            }
            return TRUE;

        case WMX_VALIDATE:
            //
            // In the unattended case, this page might get reactivated because of an error,
            // in which case we don't want to automatically continue because we could
            // get into an infinite loop.
            //
            if(!WizPage->PerPageData) {
                WizPage->PerPageData = 1;
                if (((UnattendedOperation) && (!CancelPending)) || 
                     (NTFSConversionChanged && (!CancelPending)) ||
                     (TYPICAL() && (!CancelPending)) ) {
                    return TRUE;
                }
            }
            else if (TYPICAL() && (!CancelPending)) 
            {
                // If WizPage->PerPageData == 1 we already ran through the above check.
                // and in the typical case we don't show the NTFS conversion page.
                // Anything wrong with the unattend value for NTFS would have been 
                // cought the first time.
                return TRUE;
            }
            return FALSE;

        case WMX_NEXTBUTTON:
	    // don't let the user choose next until we know the screen has been painted.
	    if (!bPainted){
	        // while we're here, empty the queue of mouse/key presses so we might not
		// have to follow this path again.
		MSG m;
		while (PeekMessage(&m,NULL,WM_MOUSEFIRST,WM_MOUSELAST,PM_REMOVE));
		while (PeekMessage(&m,NULL,WM_KEYFIRST,WM_KEYLAST,PM_REMOVE));
	        return FALSE;
	    }
            if (IsDlgButtonChecked( hdlg, IDOK ) == BST_CHECKED) {
                ForceNTFSConversion = TRUE;
            } else {
                ForceNTFSConversion = FALSE;
            }
            return TRUE;

        default:
            break;
    }

    return FALSE;
}

UINT
MyGetWindowsDirectory(
    LPTSTR  MyBuffer,
    UINT    Size
    )
/*++

Routine Description:

    Get the windows directory in a terminal-server-aware fashion.

       
Arguments:

    MyBuffer    - Holds the return string.

    Size        - How big is the buffer?

Return Value:

    length of the string we copied.

--*/
{
HMODULE     hModuleKernel32;
FARPROC     MyProc;
UINT        ReturnVal = 0;

#if defined(UNICODE)
    if( ISNT() ) {

        //
        // We can't trust GetWindowsDirectory because Terminal Server may be
        // installed, so use GetSystemWindowsDirectory.
        //
        if( hModuleKernel32 = LoadLibrary( TEXT("kernel32") ) ) {
            if( MyProc = GetProcAddress(hModuleKernel32,"GetSystemWindowsDirectoryW")) {
                ReturnVal = (UINT)MyProc( MyBuffer, Size );
            }
            FreeLibrary(hModuleKernel32);
        }
    }
#endif

    if( ReturnVal == 0 ) {
        ReturnVal = GetWindowsDirectory( MyBuffer, Size );
    }

    return ReturnVal;
}

//
// Calc how fast setup can coyp files
//
#define BUFFER_SIZE 0x1000
DWORD dwThroughPutSrcToDest;
DWORD dwThroughPutHDToHD;

DWORD GetThroughput(LPTSTR Source, LPTSTR Dest)
{
    BYTE buffer[BUFFER_SIZE];
    HANDLE hFile = NULL;
    HANDLE hFileOut = NULL;
    DWORD bytes;
    DWORD written;
    DWORD size;
    DWORD ticks;
    ticks = GetTickCount();

    hFile = CreateFile(Source, 
                GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    hFileOut = CreateFile(Dest, 
                GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    size = 0;
    if ((hFile != INVALID_HANDLE_VALUE) && (hFileOut != INVALID_HANDLE_VALUE))

    {
        do
        {
            ReadFile(hFile, buffer, BUFFER_SIZE, &bytes, NULL);
            if (hFileOut)
                WriteFile(hFileOut, buffer, bytes, &written, NULL);
            size += bytes;
        } while (bytes == BUFFER_SIZE);
        CloseHandle(hFile);
        if (hFileOut)
        {
            FlushFileBuffers(hFileOut);
            CloseHandle(hFileOut);
        }
        ticks = (GetTickCount() - ticks);
        // If less then a second, assume 1 second.
        if (ticks == 0)
        {
            ticks = 1;
        }

        ticks = (size/ticks);
    }
    else
    {
        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);
        if (hFileOut != INVALID_HANDLE_VALUE)
            CloseHandle(hFileOut);
        // Failed to open/create one of the files. Assume a through put of 5KB/msec
        ticks = DEFAULT_IO_THROUGHPUT;
    }
    return ticks;
}

// Copy txtsetup.sif from the sources to %windir%\$win_nt$.~ls
// and determine the throughput for this.
// Then copy txtsetup.sif in the local folder to testfile.000 and
// calc the throughput for that.
// Remove the folder.
void CalcThroughput()
{
    TCHAR SrcFolder[MAX_PATH];
    TCHAR DestFolder[MAX_PATH];
    TCHAR Folder[MAX_PATH];

    MyGetWindowsDirectory(Folder, sizeof(DestFolder)/sizeof(TCHAR));
    // Only use the driver
    Folder[3] = TEXT('\0');
    ConcatenatePaths( Folder, LOCAL_SOURCE_DIR, MAX_PATH);
    if (CreateMultiLevelDirectory(Folder) == NO_ERROR)
    {
        lstrcpy(DestFolder, Folder);
        ConcatenatePaths( DestFolder, TEXTMODE_INF, MAX_PATH);
        lstrcpy(SrcFolder, NativeSourcePaths[0]);
        ConcatenatePaths( SrcFolder, TEXTMODE_INF, MAX_PATH);
        dwThroughPutSrcToDest = GetThroughput(SrcFolder, DestFolder);
        // 
        lstrcpy(SrcFolder, DestFolder);
        lstrcpy(DestFolder, Folder);
        ConcatenatePaths( DestFolder, TEXT("testfile.000"), MAX_PATH);
        dwThroughPutHDToHD = GetThroughput(SrcFolder, DestFolder);
        MyDelnode(Folder);
        wsprintf(Folder, TEXT("SrcToDest: %d bytes/msec HDtoHD: %d bytes/msec"),dwThroughPutSrcToDest, dwThroughPutHDToHD);
        DebugLog(Winnt32LogInformation,Folder,0 );
    }
}

#ifdef UNICODE

#define NB10_SIG        ((DWORD)'01BN')
#define RSDS_SIG        ((DWORD)'SDSR')

typedef struct _NB10I              // NB10 debug info
{
    DWORD   dwSig;                 // NB10
    DWORD   dwOffset;              // offset, always 0
    ULONG   sig;
    ULONG   age;
    char    szPdb[_MAX_PATH];
} NB10I, *PNB10I;

typedef struct _NB10I_HEADER       // NB10 debug info
{
    DWORD   dwSig;                 // NB10
    DWORD   dwOffset;              // offset, always 0
    ULONG   sig;
    ULONG   age;
} NB10IH, *PNB10IH;

typedef struct _RSDSI              // RSDS debug info
{
    DWORD   dwSig;                 // RSDS
    GUID    guidSig;
    DWORD   age;
    char    szPdb[_MAX_PATH * 3];
} RSDSI, *PRSDSI;

typedef struct _RSDSI_HEADER       // RSDS debug info
{
    DWORD   dwSig;                 // RSDS
    GUID    guidSig;
    DWORD   age;
} RSDSIH, *PRSDSIH;

typedef union _CVDD
{
    DWORD   dwSig;
    NB10I   nb10i;
    RSDSI   rsdsi;
    NB10IH  nb10ih;
    RSDSIH  rsdsih;
} CVDD, *PCVDD;

BOOL
ExtractFileName(PCHAR pName, PCHAR pFileName)
{
    // Extract the name part of the filename.
    PCHAR pStartName, pEndName;
    pEndName = pName + strlen(pName);
    while ((*pEndName != '.') && (pEndName != pName)) {
        pEndName--;
    }

    if (pEndName == pName) {
        return FALSE;
    }

    // String consist of just '.' or no periods at all?
    if ((pEndName == pName) || 
        ((pEndName-1) == pName))
    {
        return FALSE;
    }

    pStartName = pEndName-1;

    while ((*pStartName != '\\') && (pStartName != pName)) {
        pStartName--;
    }

    // Found either the start of the string (filename.pdb) or the first backslash
    // path\filename.pdb.

    if (*pStartName == '\\')
        pStartName++;

    // Someone pass us \\.?
    if (pStartName == pEndName) {
        return FALSE;
    }

    CopyMemory(pFileName, pStartName, pEndName - pStartName);
    return TRUE;
}

CHAR HalName[_MAX_FNAME];

PCHAR
FindRealHalName(TCHAR *pHalFileName)
{
    HINSTANCE hHal = NULL;
    PIMAGE_DEBUG_DIRECTORY pDebugData;
    DWORD DebugSize, i;
    BOOL NameFound = FALSE;

    __try {
        hHal = LoadLibraryEx(pHalFileName, NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (!hHal) {
            __leave;
        }
    
        pDebugData = RtlImageDirectoryEntryToData(hHal, FALSE, IMAGE_DIRECTORY_ENTRY_DEBUG, &DebugSize);
    
        // verify we have debug data and it's a reasonable size.
        if (!pDebugData || 
            (DebugSize < sizeof(IMAGE_DEBUG_DIRECTORY)) ||
            (DebugSize % sizeof(IMAGE_DEBUG_DIRECTORY)))
        {
            __leave;
        }
    
        ZeroMemory(HalName, sizeof(HalName));
    
        // See if we have CV or MISC debug data.
        for (i = 0; i < DebugSize/sizeof(IMAGE_DEBUG_DIRECTORY); i++) {
            if (pDebugData->Type == IMAGE_DEBUG_TYPE_MISC) {
                // Misc data.
                PIMAGE_DEBUG_MISC pMisc = (PIMAGE_DEBUG_MISC)((PCHAR)(hHal) - 1 + pDebugData->AddressOfRawData);
                PCHAR pName = pMisc->Data;
                NameFound = ExtractFileName(pName, HalName);
                __leave;
            }
    
            if (pDebugData->Type == IMAGE_DEBUG_TYPE_CODEVIEW) {
                // got cv, see if it's nb10 (pdb) or rsds (v7 pdb)
                PCVDD pCodeView = (PCVDD)((PCHAR)(hHal) - 1 + pDebugData->AddressOfRawData);
                if (pCodeView->dwSig == NB10_SIG) {
                    NameFound = ExtractFileName(pCodeView->nb10i.szPdb, HalName);
                    __leave;
                }

                if (pCodeView->dwSig == RSDS_SIG) {
                    NameFound = ExtractFileName(pCodeView->rsdsi.szPdb, HalName);
                    __leave;
                }
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    if (hHal) {
        FreeLibrary(hHal);
    }

    if (NameFound) {
        return HalName;
    } else {
        return NULL;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by res.rc
//
#define IDS_APPTITLE                    1
#define IDS_LARGEFONTSIZE               2
#define IDS_LARGEFONTNAME               3
#define IDS_MULTIPLE                    4
#define IDS_EXAMINE_SOURCE              5
#define IDS_LOADINGINF                  6
#define IDS_BUILDING_COPY_LIST          7
#define IDS_CHECKING_SPACE              8
#define IDS_FIND_NT_FILES               9
#define IDS_INSPECTING                  10
#define IDS_REMOVING_OLD_TEMPFILES      11
#define IDS_MICROSOFT_WINDOWS           12
#define IDS_REBOOT_MESSAGE              13
#define IDS_APPTITLE_ASRV               14
#define IDS_APPTITLE_DAT                15
#define IDS_APPTITLE_SRV                16
#define IDS_APPTITLE_WKS                17
#define IDS_BOOTFLOP_WKS                18
#define IDS_BOOTFLOP_SRV                19
#define IDS_FLOPPY_N_WKS                20
#define IDS_FLOPPY_N_SRV                21
#define IDS_SETTING_NVRAM               22
#define IDS_BOOTMSG_FAT_NTLDR_MISSING   23
#define IDS_BOOTMSG_FAT_DISKERROR       24
#define IDS_BOOTMSG_FAT_PRESSKEY        25
#define IDS_COMMENT                     26
#define IDS_VISIBLE_NARRATOR_CONTROL    27
#define IDS_RECOVERY_CONSOLE            28
#define IDS_APPTITLE_BLADE              29
#define IDS_CANCEL_SETUP                30
#define IDS_WINPE_INSTALLATION          31
#define IDS_APPTITLE_SBS                32
#define IDB_WELCOME                     101
#define IDD_UPGRADE                     102
#define IDB_ARROW                       102
#define IDD_DONE0                       103
#define IDB_CHECK                       103
#define IDD_OPTIONS                     104
#define IDB_WIZARD1                     105
#define IDB_OEM                         105
#define IDD_ADVANCED                    106
#define IDB_CDKEY                       106
#define IDD_WORKING1                    107
#define IDB_HEADER                      108
#define IDA_COMP_MAGNIFY                109
#define IDD_COPYING                     110
#define IDA_FILECOPY                    111
#define IDD_DONE                        112
#define IDD_COPYERROR                   113
#define IDD_CLEANING                    114
#define IDD_NOTDONE                     115
#define IDB_WATERMARK                   116
#define IDB_TEST                        117
#define IDD_FLOPPY                      118
#define IDB_WATERMARK16                 119
#define IDB_WATERMARK256                120
#define IDI_ACCESS                      121
#define IDI_GLOBE                       122
#define IDI_SETUP                       123
#define IDD_ADVANCED2                   124
#define IDD_CLEANING2                   125
#define IDD_COPYING2                    126
#define IDD_DONE2                       127
#define IDD_FLOPPY2                     128
#define IDD_NOTDONE2                    129
#define IDD_OPTIONS2                    130
#define IDD_WELCOME2                    131
#define IDD_WORKING12                   132
#define IDD_LANGUAGE                    133
#define IDD_WELCOME                     134
#define IDD_ACCESSIBILITY               135
#define IDD_COMPATIBILITY               136
#define IDD_COMPATIBILITY_TEXT          137
#define IDI_WATCH_OUT                   138
#define IDI_ERROR_ICON                  139
#define IDI_FLAGS                       140
#define IDR_SHUTDOWN                    140
#define IDI_ADVANCED                    141
#define IDR_NOSHUTDOWN                  141
#define IDD_EULA                        143
#define IDD_PID_CD                      144
#define IDD_PID_OEM                     145
#define IDD_NTFS_CONVERT                146
#define IDI_HDISK                       147
#define IDD_ADVANCED3                   148
#define IDI_INSTALL                     148
#define IDD_DISKSPACE                   149
#define IDD_SRVCOMP                     150
#define IDB_HEARDER2                    151
#define IDA_COMPGLOB                    152
#define IDD_DYNAMICSETUP                153
#define IDD_DYNAMICSETUP2               154
#define IDD_DYNAMICSETUP3               155
#define IDD_DYNAMICSETUP_MANUAL         156
#define IDD_EMPTY                       157
#define IDD_PID_SELECT                  158
#define IDI_NOTE                        159
#define IDT_TITLE                       1000
#define IDC_ANIMATE                     1000
#define IDC_CHECK1                      1001
#define IDC_USEFLOPPIES                 1001
#define IDC_FAREAST_LANG                1001
#define IDC_EDIT1                       1002
#define IDC_INSTALL_DIR                 1002
#define IDC_DISKDIAG                    1002
#define IDC_SOURCE                      1003
#define IDB_ADVANCED                    1004
#define IDC_CONVERT                     1004
#define IDC_HEADLESS_PORT               1004
#define IDC_NOUPGRADE                   1005
#define IDC_UPGRADE                     1005
#define IDB_BROWSE                      1005
#define IDB_ACCESSIBILITY               1006
#define IDC_MAKELOCALSOURCEFROMCD       1007
#define IDC_SYSPARTDRIVE                1008
#define IDC_KEYBOARD                    1008
#define IDT_SYSPARTTEXT                 1009
#define IDC_VOICE                       1009
#define IDT_WORKING                     1010
#define IDC_READER                      1010
#define IDC_CHOOSE_INSTALLPART          1010
#define IDC_SOURCE2                     1011
#define IDB_BROWSE2                     1012
#define IDT_EDIT1                       1012
#define IDT_EULA_LIC_TEXT               1012
#define IDC_BOOT16                      1012
#define IDC_ENABLE_HEADLESS             1012
#define IDC_PROGRESS                    1013
#define IDT_BOOT16TEXT                  1013
#define IDT_HEADLESS_PORT               1013
#define IDT_SOURCE1                     1014
#define IDT_SOURCE2                     1015
#define IDT_SOURCE3                     1016
#define IDT_SOURCE4                     1017
#define IDT_SOURCE5                     1018
#define IDT_SOURCE6                     1019
#define IDT_SOURCE7                     1020
#define IDT_SOURCE8                     1021
#define IDT_SOURCE9                     1022
#define IDT_SIZE2                       1022
#define IDS_DETAILS                     1023
#define IDT_ERROR_TEXT                  1024
#define IDT_ELAPSED_TIME2               1024
#define IDC_HEADER_BOTTOM               1025
#define IDC_MAGNIFIER                   1027
#define IDT_SUPERTITLE                  1028
#define IDT_SUBTITLE                    1029
#define IDC_BUTTON1                     1030
#define IDB_LANGUAGE                    1030
#define IDT_EDIT_PID1                   1030
#define IDT_DETAIL_TEXT                 1030
#define IDC_LIST1                       1031
#define IDC_LIST                        1031
#define IDT_EDIT_PID2                   1031
#define IDC_ROOT_LIST                   1032
#define IDT_EDIT_PID3                   1032
#define IDC_DETAILS                     1033
#define IDT_EDIT_PID4                   1033
#define IDC_TEXT                        1034
#define IDT_EDIT_PID5                   1034
#define IDC_DIALOG_ICON                 1035
#define IDC_NOSHUTDOWN                  1035
#define IDC_RADIO1                      1035
#define IDC_BOOT16_1                    1035
#define IDC_INTRO_TEXT                  1036
#define IDC_BOOT16_2                    1036
#define IDC_HAVE_DISK                   1037
#define IDC_CHECK2                      1037
#define IDC_BOOT16_3                    1037
#define IDS_SERVICE_STOP                1038
#define IDC_RADIO2                      1038
#define IDS_COMPAT_ERR                  1038
#define IDS_SERVICE_DISABLE             1039
#define IDC_COMBO1                      1039
#define IDS_COMPAT_WRN                  1039
#define IDC_ACCESS_ICON                 1040
#define IDS_NO_REBOOT                   1040
#define IDC_SAVE_AS                     1041
#define IDC_PROGRESS1                   1041
#define IDS_COMPAT_ERR_WRN              1041
#define IDS_RISCBootString              1042
#define IDC_SCROLLBAR1                  1043
#define IDS_COMPAT_NOPROBLEMS           1043
#define IDT_DISKMSG0                    1044
#define IDS_COMPAT_PENDING_REBOOT       1044
#define IDT_DISKMSG1                    1045
#define IDS_COMPAT_REPORTHEADER         1045
#define IDT_DISKMSG2                    1046
#define IDNORESTART                     1047
#define IDC_READER_TEXT                 1048
#define IDS_SRV_APP_DIRECTORY           1049
#define IDS_PRO_APP_DIRECTORY           1050
#define IDC_DIRECTORY                   1051
#define IDS_FILE_MASK_TYPES             1051
#define IDS_DEFAULT_COMPATIBILITY_REPORT_NAME 1052
#define IDT_DYNSETUP_DIALING            1052
#define IDT_INSTALLTYPE                 1052
#define IDT_DYNSETUP_TIME               1053
#define IDS_APPTITLE_CHECKUPGRADE       1053
#define IDC_IF_EXPRESS                  1053
#define IDC_INSTALLCOMBO                1053
#define IDS_COMPAT_CHECKUPGRADE         1054
#define IDR_DYNSETUP_RETRY              1054
#define IDT_DYNSETUP_DOWNLOADING        1054
#define IDR_DYNSETUP_MANUAL             1055
#define IDS_SIZE_GBYTES                 1055
#define IDC_EXPRESS                     1055
#define IDT_DYNSETUP_PROCESSING         1055
#define IDS_SIZE_MBYTES                 1056
#define IDR_DYNSETUP_SKIP               1056
#define IDC_ADVANCED                    1056
#define IDS_SIZE_KBYTES                 1057
#define IDC_IF_ADVANCED                 1057
#define IDC_NOTE_TEXT_CLEAN             1057
#define IDS_SIZE_BYTES                  1058
#define IDC_COPY_BMP                    1058
#define IDC_NOTE_CLEAN                  1058
#define IDS_COMPAT_DIVIDER              1059
#define IDC_COPY_BMP2                   1059
#define IDS_COMPAT_STRT_MENU            1060
#define IDC_COPY_BMP3                   1060
#define IDS_BB_COPYING                  1061
#define IDS_TIMEESTIMATE_UNKNOWN        1062
#define IDS_ESC_TOCANCEL                1063
#define IDS_TIMEESTIMATE_MINUTES        1064
#define IDS_TIMEESTIMATE_LESSTHENONEMINUTE 1065
#define IDS_ESC_TOCANCEL_DOWNLOAD       1066
#define IDS_RESTART_SETUP               1067
#define IDB_HEADER2                     1090
#define IDT_LABEL1                      2000
#define IDT_LABEL2                      2001
#define IDT_LABEL3                      2002
#define IDT_LABEL4                      2003
#define IDT_LABEL5                      2004
#define IDT_LABEL6                      2005
#define IDT_LABEL7                      2006
#define IDT_LABEL8                      2007
#define IDT_LABEL9                      2008
#define IDT_SIZE                        2008
#define IDC_UPGRADE_OR_INSTALL          2009
#define IDT_ELAPSED_TIME                2009
#define IDC_IF_UPGRADE                  2010
#define IDC_IF_NEW_COPY                 2011
#define IDC_WHAT_TO_DO                  2012
#define IDS_CERTSRV_UPGRADE_WARNING     2013
#define IDS_INSTALLTYPE_EXPRESS         2014
#define IDS_INSTALLTYPE_CUSTOM          2015
#define IDS_INSTALL_EXPRESS             2016
#define IDS_INSTALL_CUSTOM              2017
#define IDS_PROCESSOR_UPGRADE_WARNING   2018
#define IDS_BB_REBOOT_TXT               2019
#define IDB_SYSPARSE                    2020
#define IDD_SYSPARSE                    2021
#define IDC_BITMAP                      2022
#define IDD_RESTART                     2022
#define IDD_DYNAMICSETUP4               2023
#define IDD_DYNAMICSETUP5               2024
#define IDS_SHUTDOWN_REMOTE             2711
#define IDS_SHUTDOWN_REMOTE_OTHERUSERS  2712
#define IDS_SHUTDOWN_OTHERUSERS         2713
#define IDS_RESTART_OTHERUSERS          2714
#define IDC_NOTE_TEXT_UPG               2715
#define IDC_NOTE_UPG                    2716
#define IDS_ESC_TOCANCEL_REBOOT         2717
#define IDS_DRWATSON_LCID               2718
#define IDS_DRWATSON_ERRORTEXT          2719
#define IDD_REPORT_HELP                 3000
#define IDI_CHECKMARK                   3001
#define IDC_CATEGORY                    3002
#define IDC_TEXT1                       3003
#define IDC_CRITICAL_ISSUES             3004
#define IDC_ALL_ISSUES                  3005
#define IDC_NO_REPORT                   3006
#define IDC_NAMES                       3007
#define IDC_TEXT2                       3007
#define IDC_TEXT3                       3008
#define IDC_STATIC                      -1
#define ID_RETRY_MESSAGE                65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        160
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1059
#define _APS_NEXT_SYMED_VALUE           142
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\internal.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    internal.c

Abstract:

    Routines to support hidden or internal-only functionlity.

Author:

    Ted Miller (tedm) 4 Nov 1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// Value used internally to automatically fetch
// alternate setup hives for differing # of processors.
//
UINT NumberOfLicensedProcessors;

//
// internal value used to turn off processing of "exception packages"
//
BOOL IgnoreExceptionPackages;

//
// Where to get missing files.
//

TCHAR AlternateSourcePath[MAX_PATH];


BOOL
AddCopydirIfExists(
    IN LPTSTR pszPathToCopy,
    IN UINT Flags
    )
/*++

Routine Description:

    If pszPathToCopy exists, then act like "/copydir:pszPathToCopy" was passed
    on the cmd line.

Arguments:

    pszPathToCopy - path that we want to additionally copy if it exists.

    Flags - one of the OPTDIR_xxx flags to specify how to treat this optional directory

Return Value:

    TRUE  - pszPathToCopy existed and we added this to list of extra dirs to copy.
    FALSE - pszPathToCopy did not exist or we failed to add it to our list of extra dirs

--*/
{
    TCHAR szFullPath[MAX_PATH], szRealPath[MAX_PATH];
    PTSTR p;
    
    if( !pszPathToCopy )
        return FALSE;

    if (NativeSourcePaths[0][0]) {
        lstrcpy(szFullPath, NativeSourcePaths[0]);
    } else {
        if (!GetModuleFileName(NULL, szFullPath, MAX_PATH) ||
            !(p = _tcsrchr(szFullPath, TEXT('\\')))
            ) {
            return FALSE;
        }
        // remove "\winnt32.exe" part
        *p = TEXT('\0');
    }
    ConcatenatePaths(szFullPath, pszPathToCopy, MAX_PATH);

    if(GetFullPathName( szFullPath, MAX_PATH, szRealPath, NULL )){
        if (FileExists (szRealPath, NULL))
        {
            DebugLog (Winnt32LogInformation, TEXT("AddCopyDirIfExists for <%1> <%2>"), 0, szRealPath, pszPathToCopy);
            return RememberOptionalDir(pszPathToCopy, Flags);
        }else{
            
            DebugLog (Winnt32LogInformation, TEXT("AddCopyDirIfExists FileExists failed for <%1>"), 0, szRealPath);
        }
    }else{
        DebugLog (Winnt32LogInformation, TEXT("AddCopyDirIfExists GetFullPathName failed for <%1>"), 0, szFullPath );
    }

    
    
    return FALSE;
}



VOID
CopyExtraBVTDirs(
                 )
/*++

Routine Description:
    Copies the extra dirs that are good to have when running bvt's:
    symbols.pri, idw, mstools, and debugger extensions.

Arguments:

    None.

Return Value:

    None.

--*/
{
    LPTSTR psz;

    if (CopySymbols)
    {
        // copy symbols.pri\retail
        if (AddCopydirIfExists(TEXT("..\\..\\sym\\retail"), 0)  ||
            AddCopydirIfExists(TEXT("..\\..\\symbols.pri\\retail"), 0) || // for dev postbuild installs
            AddCopydirIfExists(TEXT("..\\..\\sym\\netfx"), 0)  ||
            AddCopydirIfExists(TEXT("..\\..\\symbols.pri\\netfx"), 0)) // for dev postbuild installs
        {}
    }

    // copy idw
    if (AddCopydirIfExists(TEXT("..\\..\\bin\\idw"), 0) ||
        AddCopydirIfExists(TEXT("..\\..\\idw"), 0)) // for dev postbuild installs
    {}

    // copy mstools
    if (AddCopydirIfExists(TEXT("..\\..\\bin\\mstools"), 0) ||
        AddCopydirIfExists(TEXT("..\\..\\mstools"), 0)) // for dev postbuild installs
    {}

    // copy bldtools
    if (AddCopydirIfExists(TEXT("..\\..\\bin\\bldtools"), 0) ||
        AddCopydirIfExists(TEXT("..\\..\\bldtools"), 0))    // for dev postbuild installs
    {}

    // copy private debugger extensions
    if (AddCopydirIfExists(TEXT("..\\..\\bin\\dbg\\files\\bin\\pri"), OPTDIR_DEBUGGEREXT)   ||
        AddCopydirIfExists(TEXT("..\\..\\dbg\\files\\bin\\pri"), OPTDIR_DEBUGGEREXT))   // for dev postbuild installs
    {}

    // copy public debugger extensions
    if (AddCopydirIfExists(TEXT("..\\..\\bin\\dbg\\files\\bin\\winxp"), OPTDIR_DEBUGGEREXT) ||
        AddCopydirIfExists(TEXT("..\\..\\dbg\\files\\bin\\winxp"), OPTDIR_DEBUGGEREXT)) // for dev postbuild installs
    {}
}


BOOL
AppendUpgradeOption (
    IN      PCTSTR String
    )
{
    BOOL result = FALSE;
    UINT lengthInBytes;
    UINT lengthPlusTerminator;

    __try {
        //
        // Ensure there is enough room.
        //
        lengthInBytes = UpgradeOptionsLength + ((_tcslen(String) + 1) * sizeof (TCHAR));
        lengthPlusTerminator = lengthInBytes + sizeof (TCHAR);

        if (lengthPlusTerminator > UpgradeOptionsSize) {
            //
            // Allocate more space, aligned to 256 bytes.
            //
            UpgradeOptionsSize = ((lengthPlusTerminator / 256) + 1) * 256;
            UpgradeOptions = REALLOC(UpgradeOptions,UpgradeOptionsSize);
        }

        if (UpgradeOptions) {

            //
            // Ok, memory was successfully allocated. Save the new option onto the end
            // of the list.
            //
            wsprintf (
                (PTSTR) ((PBYTE) UpgradeOptions + UpgradeOptionsLength),
                TEXT("%s%c"),
                String,
                0
                );

            UpgradeOptionsLength = lengthInBytes;
        } else {
            //
            // This is bad. realloc failed.
            //
            __leave;
        }

        result = TRUE;
    }
    __finally {
    }

    return result;
}



VOID
InternalProcessCmdLineArg(
    IN LPCTSTR Arg
    )

/*++

Routine Description:

    Parse a command line arg that is thought to be internal-only.

    The caller should call this routine only if the switch arg char
    is # (ie something like /#x:foo).

    /#[n]:sharename             internal distribution
                                n can be a digit from 1-9 to indicate source
                                count, default is 3 n win9x and 5 on nt.

    /#L:number                  number of licensed processors

    /#N                         auto skip missing files

    /#U:[Option]                Upgrade option. All upgrade options are packed together
                                into a multisz and passed to the plugin-dll.

    /#bvt:[Option]:[Option]     Setup machine for running bvt's. Options include :nosymbols,
                                :baudrate=XXXX, and :debugport=X

    /#asr[{t|f}:[AsrSifPath]]   Setup machine for running ASR coverage tests, using the
                                asr.sif specified.  This includes adding /DEBUG
                                /BAUDRATE=115200  (on IA64 use 19200 and /DEBUGPORT=COM1),
                                in addition to setting setupcmdlineprepend="ntsd -odgGx",
                                and adding other options as appropriate.
Arguments:

    Arg - supplies comment line argument, starting with the switch
        character itself (ie, - or /). This routine assumes that
        the interesting part of the argument starts at Arg[2].

Return Value:

    None.

--*/

{
    UINT NumSources;
    UINT u;
    UINT length;
    LPTSTR src;

    if(!Arg[0] || !Arg[1]) {
        return;
    }

    NumSources = ISNT() ? 5 : 3;

    switch(_totupper(Arg[2])) {

    case TEXT('1'): case ('2'): case ('3'):
    case TEXT('4'): case ('5'): case ('6'):
    case TEXT('7'): case ('8'): case ('9'):
        if(Arg[3] != TEXT(':')) {
            break;
        }

        NumSources = Arg[2] - TEXT('0');
        Arg++;
        //
        // Fall through
        //
    case TEXT(':'):
        //
        // Internal distribution stuff
        //

        //
        // handle cases where
        //  -they put a "\" before path
        //  -they map a net drive and put "f:" first
        //  -they map a net driver and put "f:\" first
        //
        src = (LPTSTR)(Arg+3);

        for(u=0; u<NumSources; u++) {
            if(SourceCount < MAX_SOURCE_COUNT) {

                if (GetFullPathName (
                        src,
                        sizeof(NativeSourcePaths[SourceCount])/sizeof(TCHAR),
                        NativeSourcePaths[SourceCount],
                        NULL
                        )) {
                    SourceCount++;
                }
            }
        }
        break;

    case TEXT('A'):

        if (_tcsnicmp(Arg+2,TEXT("asr"),3) == 0) {
            //
            // Setup machine for running ASR tests
            //
            AsrQuickTest = 3;   // Assume default is full

            if (Arg[5] == TEXT('t') || Arg[5] == TEXT('T')) {
                AsrQuickTest = 2;   // Text mode only
            }

            if (Arg[5] == TEXT('f') || Arg[5] == TEXT('F')) {
                AsrQuickTest = 3;   // Full mode
            }

            if(Arg[6] == TEXT(':')) {
                //
                // User specified asr.sif to use
                //
                _tcscpy(AlternateSourcePath, Arg+7);
            }
            else {
                //
                // Use default asr.sif (%systemroot%\repair\asr.sif)
                //
                ExpandEnvironmentStrings(
                    TEXT("%systemroot%\\repair"),
                    AlternateSourcePath,
                    MAX_PATH
                    );
            }

            RememberOptionalDir(AlternateSourcePath,OPTDIR_OVERLAY);

            //
            // Don't block if we can't find enough disk space.
            //
            BlockOnNotEnoughSpace = FALSE;

            //
            // Run in unattended mode
            //
            UnattendedOperation = TRUE;

            //
            // Pretend we're running from CD
            //
            RunFromCD = TRUE;

            //
            // Make sure we're not upgrading
            //
            Upgrade = FALSE;

            //
            // Skip EULA
            //
            EulaComplete = TRUE;

        }

        break;

    case TEXT('B'):
        if (_tcsnicmp(Arg+2,TEXT("bvt"),3) == 0)
        {
            TCHAR* pszTemp = (TCHAR*)Arg;

            // setup for running BVT's
            RunningBVTs = TRUE;

            // replace all ":"'s with spaces so that _ttol will work properly
            while (*pszTemp)
            {
                if (*pszTemp == TEXT(':'))
                {
                    *pszTemp = TEXT(' ');
                }
                pszTemp++;
            }

            // check for other #bvt switches (eg "/#bvt:nosymbols:baudrate=19200:debugport=1")
            if (_tcsstr(Arg, TEXT("nosymbols")))
            {
                CopySymbols = FALSE;
            }

            pszTemp = _tcsstr(Arg, TEXT("baudrate="));
            if (pszTemp)
            {
                pszTemp = pszTemp + ((sizeof(TEXT("baudrate=")) - sizeof(TCHAR))/sizeof(TCHAR));
                lDebugBaudRate = _ttol(pszTemp);
            }

            pszTemp = _tcsstr(Arg, TEXT("debugport="));
            if (pszTemp)
            {
                if ( _tcsstr(pszTemp, TEXT("com")) ) {
                    pszTemp = pszTemp + ((sizeof(TEXT("debugport=com")) - sizeof(TCHAR))/sizeof(TCHAR));
                    lDebugComPort = _ttol(pszTemp);
                }
                else {
                    pszTemp = pszTemp + ((sizeof(TEXT("debugport=")) - sizeof(TCHAR))/sizeof(TCHAR));
                    lDebugComPort = _ttol(pszTemp);
                }
            }

            break;
        }

        //
        // Don't block if we can't find enough disk space.
        //
        BlockOnNotEnoughSpace = FALSE;
        break;

    case TEXT('C'):
        //
        // Don't block if we can't find enough disk space.
        //
        UseBIOSToBoot = TRUE;
        break;

#ifdef _X86_
    case TEXT('F'):
        //
        // temp variable to allow compliance checking
        //
        Floppyless = FALSE;
        break;
#endif

    case TEXT('L'):
        //
        // Licensed processors
        //
        if(Arg[3] == TEXT(':')) {
            NumberOfLicensedProcessors = _tcstoul(Arg+4,NULL,10);
        }
        break;

    case TEXT('M'):
        //
        // Alternate source for missing files
        //
        if(Arg[3] == TEXT(':')) {
            _tcscpy(AlternateSourcePath, Arg+4);
            RememberOptionalDir(AlternateSourcePath,OPTDIR_OVERLAY);  //behave like /m:
        }
        break;

    case TEXT('I'):
        if (!_tcsicmp(Arg+2,TEXT("IgnoreExceptionPackages"))) {
            IgnoreExceptionPackages = TRUE;
        }
        break;

    case TEXT('N'):
#ifdef PRERELEASE
        if (!_tcsicmp(Arg+2,TEXT("NODEBUGBOOT"))) {
            AppendDebugDataToBoot = FALSE;
        } else
        //
        // this is PRERELEASE code only, intended to help testing of winnt32
        // the use of this switch is not supported in any way!
        //
        if (!_tcsicmp (Arg+2, TEXT("nopid"))) {
            extern BOOL NoPid;
            NoPid = TRUE;
        }
        else
#endif
        {

        //
        // Skip missing files mode
        //
        AutoSkipMissingFiles = TRUE;

        }

        break;

    case TEXT('H'):
        //
        // Hide windows dir
        //
        HideWinDir = TRUE;
        break;

    case TEXT('P'):
        //
        // allow the user to select a partition during textmode setup
        //
        ChoosePartition = TRUE;
        break;

    case TEXT('R'):
        //
        // Pretending to run from CD.
        //
        RunFromCD = TRUE;
        break;

    case TEXT('Q'):
       //
       // Denote running from MSI file.
       //
       RunFromMSI = TRUE;
       break;

    case TEXT('S'):
        //
        // use signature based arc paths
        //
        UseSignatures = !UseSignatures;
        break;

    case TEXT('D'):
        //
        // specify the directory to install into
        //
        if(Arg[3] == TEXT(':')) {
            _tcscpy(InstallDir, Arg+4);
        }
        break;

    case TEXT('T'):
        //
        // Give the user detailed timing info during file copy.
        //
        DetailedCopyProgress = TRUE;
        break;

    case TEXT('U'):
        //
        // Plugin option. Add it to the multisz that will be passed to the plugin.
        //
        if (Arg[3] == TEXT(':')) {

            if (!AppendUpgradeOption (Arg+4)) {
                break;
            }

            //
            // winnt32 uses the anylocale and virusscanersok switches itself.
            //
            if (!_tcsicmp(Arg+4,TEXT("ANYLOCALE"))) {
                SkipLocaleCheck = TRUE;
            } else if (!_tcsicmp(Arg+4,TEXT("VIRUSSCANNERSOK"))) {
                SkipVirusScannerCheck = TRUE;
            } else if (!_tcsicmp(Arg+4,TEXT("NOLS"))) {
                NoLs = TRUE;
            } else if (!_tcsicmp(Arg+4,TEXT("NOBUILDCHECK"))) {
                CCDisableBuildCheck();
            }

#ifdef PRERELEASE
            if (!_tcsicmp(Arg+4,TEXT("NOCOMPLIANCE"))) {
                NoCompliance = TRUE;
            }
#endif

        }
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\params.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    Params.c

Abstract:

    Routines to write parameters file for use by text mode setup.

Author:

    Ted Miller (tedm) 4 Nov 1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))
#define DEF_INF_BUFFER_SIZE (1<<15) //32KB
#define EMPTY_STRING TEXT("")

// Global used in WriteParamsFile and AddExternalParams
TCHAR ActualParamFile[MAX_PATH] = {'\0'};

//
// boot loader timeout value, in string form
//
TCHAR Timeout[32];

#ifdef PRERELEASE
//
// if we're in PRERELEASE mode, we will make a /debug entry
// in the OSLOADOPTIONSVARAPPEND entry.
//
BOOL AppendDebugDataToBoot = TRUE;
#endif

#if defined(UNICODE) && defined(_X86_)
extern TCHAR g_MigDllAnswerFilePath[MAX_PATH];
#endif

DWORD
PatchWinntSifFile(
    IN LPCTSTR Filename
    );

BOOL
AppendParamsFile(
    IN HWND    ParentWindow,
    IN LPCTSTR ParametersFileIn,
    IN LPCTSTR ParametersFileOut
    );

BOOL
WriteCompatibilityData(
    IN LPCTSTR FileName
    );

VOID
WriteGUIModeInfOperations(
    IN LPCTSTR FileName
    );

BOOL
AddGUIModeCompatibilityInfsToCopyList();

BOOL
WriteTextmodeClobberData (
    IN LPCTSTR FileName
    );

VOID
SaveProxyForOobe(
    IN LPCTSTR FileName
    );

#ifdef _X86_

VOID
SaveDriveLetterInformation (
    IN LPCTSTR FileName
    );


#endif


PCTSTR
pGetPfPath (
    IN      HKEY hKey,
    IN      PCTSTR ValueName
    )
{
    DWORD Size;
    LONG rc;
    PBYTE Data;
    DWORD Type;
    UINT DriveType;
    TCHAR RootPath[] = TEXT("?:\\");
    PTSTR QuotedData;

    rc = RegQueryValueEx (
            hKey,
            ValueName,
            NULL,           // lpReserved
            &Type,
            NULL,
            &Size
            );

    if (rc != ERROR_SUCCESS) {
        return NULL;
    }

    if (Type != REG_SZ && Type != REG_EXPAND_SZ) {
        return NULL;
    }

    Data = MALLOC(Size + sizeof (TCHAR));
    if (!Data) {
        return NULL;
    }

    rc = RegQueryValueEx (
            hKey,
            ValueName,
            NULL,           // lpReserved
            NULL,           // type
            Data,
            &Size
            );

    if (rc != ERROR_SUCCESS) {
        FREE(Data);
        return NULL;
    }

    *((PTSTR) (Data + Size)) = 0;

    //
    // Verify data is to a local path
    //

    RootPath[0] = *((PCTSTR) Data);
    if (RootPath[0] == TEXT('\\')) {
        DriveType = DRIVE_NO_ROOT_DIR;
    } else {
        DriveType = GetDriveType (RootPath);
    }

    if (DriveType != DRIVE_FIXED) {
        FREE(Data);
        return NULL;
    }

    QuotedData = (PTSTR) MALLOC(Size + sizeof (TCHAR) * 3);
    if (!QuotedData) {
        FREE(Data);
        return NULL;
    }

    *QuotedData = TEXT('\"');
    lstrcpy (QuotedData + 1, (PCTSTR) Data);
    lstrcat (QuotedData, TEXT("\""));

    FREE(Data);

    return (PCTSTR) QuotedData;
}


BOOL
WriteHeadlessParameters(
    IN LPCTSTR FileName
    )


/*++

Routine Description:

    This routine writes the headless-specific parameters into the file
    that is used to pass information to text mode setup.

Arguments:

    FileName - specifies the full Win32 filename to use for the file.

Return Value:

    Boolean value indicating whether the file was written successfully.
    If not, the user will have been informed about why.

--*/

{
BOOL    ReturnVal = TRUE;
TCHAR Text[MAX_PATH*2];

    //
    // Check the global and see if anyone has set any headless parameters.
    //
    if( HeadlessSelection[0] != TEXT('\0') ) {

        //
        // Write the settings into the unattend file so textmode will
        // fire up through up a headless port.
        //
        if( !WritePrivateProfileString(WINNT_DATA,WINNT_U_HEADLESS_REDIRECT,HeadlessSelection,FileName)) {
            ReturnVal = FALSE;
        }

        if( HeadlessBaudRate == 0 ) {
            wsprintf( Text, TEXT("%d"), 9600 );
        } else {
            wsprintf( Text, TEXT("%d"), HeadlessBaudRate );
        }

        if( !WritePrivateProfileString(WINNT_DATA,WINNT_U_HEADLESS_REDIRECTBAUDRATE,Text,FileName)) {
            ReturnVal = FALSE;
        }

    }





    return( ReturnVal );

}

BOOL WritePidToParametersFile(LPCTSTR Section, LPCTSTR Key, LPCTSTR FileName)
{
    BOOL b = FALSE;
    LPTSTR Line = NULL;
    LPTSTR pid;
    if (g_EncryptedPID)
    {
        pid = g_EncryptedPID;
    }
    else
    {
        pid = ProductId;
    }
    Line = GlobalAlloc(GPTR, (lstrlen(pid) + 3) * sizeof(TCHAR));
    if (Line)
    {
        *Line = TEXT('\"');
        lstrcpy(&Line[1], pid);
        lstrcat(Line,TEXT("\""));
        b = WritePrivateProfileString(Section,Key,Line,FileName);
        GlobalFree(Line);
    }
    return b;
}

BOOL
DoWriteParametersFile(
    IN HWND    ParentWindow,
    IN LPCTSTR FileName
    )

/*++

Routine Description:

    This routine generates a parameters file that is used to pass information
    to text mode setup.

Arguments:

    ParentWindow - supplies window handle of window to be used as the
        parent/owner in case this routine puts up UI.

    FileName - specifies the full Win32 filename to use for the file.

Return Value:

    Boolean value indicating whether the file was written successfully.
    If not, the user will have been informed about why.

--*/

{
    TCHAR FullPath[MAX_PATH], *t;
    TCHAR Text[MAX_PATH*2];
    LPTSTR OptionalDirString,OptDir;
    UINT OptionalDirLength;
    DWORD d=NO_ERROR;
    PVOID p;
    BOOL b;
    LONG l;
    HKEY hKey;
    PCTSTR PfPath;
    LONG rc;

    LPCTSTR WinntDataSection = WINNT_DATA;
    LPCTSTR WinntSetupSection = WINNT_SETUPPARAMS;
    LPCTSTR WinntAccessSection = WINNT_ACCESSIBILITY;
    LPCTSTR WinntSetupDataSection = TEXT("SetupData");
#if defined(REMOTE_BOOT)
    LPCTSTR WinntUserDataSection = TEXT("UserData");
#endif // defined(REMOTE_BOOT)
    LPCTSTR WinntUniqueId = WINNT_D_UNIQUEID;
    LPCTSTR WinntNull = WINNT_A_NULL;
    LPCTSTR WinntUserSection = WINNT_USERDATA;

    if( !FileName )
        d=ERROR_INVALID_PARAMETER;

    //
    // Make sure path for file is present, and form its fully qualified name.
    //
    if(d == NO_ERROR){
        lstrcpy(FullPath,FileName);
        if((t=_tcsrchr(FullPath,TEXT('\\')))) {
            *t= 0;
            d = CreateMultiLevelDirectory(FullPath);
        }else
            d=ERROR_INVALID_PARAMETER;

    }
    if(d != NO_ERROR) {

        MessageBoxFromMessageAndSystemError(
            ParentWindow,
            MSG_DIR_CREATE_FAILED,
            d,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            FullPath
            );

        return(FALSE);
    }

    //
    // Get rid of any existing parameters file.
    //
    DeleteFile(FileName);

#ifdef _X86_

    if (!ISNT()) {

        //
        // If this is a 9x machine, we need to preserve the drive letters, even
        // if it is an NT clean install.
        //

        SaveDriveLetterInformation (FileName);

    }

#endif

    //
    // Value indicating that this is winnt/winnt32-based installation,
    // and on x86, value to indicate that this is a floppyless operation
    // as apropriate.
    //
    b = WritePrivateProfileString(WinntDataSection,WINNT_D_MSDOS,TEXT("1"),FileName);
    if (b && HideWinDir) {
        b = WritePrivateProfileString(WinntDataSection,TEXT("HideWinDir"),TEXT("1"),FileName);
    }

    if (!IsArc()) {
#ifdef _X86_
        if(b && Floppyless) {
            b = WritePrivateProfileString(WinntDataSection,WINNT_D_FLOPPY,TEXT("1"),FileName);
        }

        if (b && BuildCmdcons) {
            b = WritePrivateProfileString(WinntDataSection,WINNT_D_CMDCONS,TEXT("1"),FileName);
        }
#endif // _X86_
    } // if (!IsArc())

    if(b && RunFromCD && !MakeLocalSource) {
        b = WritePrivateProfileString(WinntDataSection,WINNT_D_LOCALSRC_CD,TEXT("1"),FileName);
    }

    if (b) {
        b = WritePrivateProfileString(WinntDataSection,WINNT_D_AUTO_PART,ChoosePartition?TEXT("0"):TEXT("1"),FileName);
    }

    if (b && UseSignatures) {
        b = WritePrivateProfileString(WinntDataSection,TEXT("UseSignatures"),WINNT_A_YES,FileName);
    }
    if (b && InstallDir[0] && (ISNT() || !Upgrade)) {
        b = WritePrivateProfileString(WinntDataSection,WINNT_D_INSTALLDIR,InstallDir,FileName);
    }
    if (b  && EulaComplete) {
        b = WritePrivateProfileString(WinntDataSection,WINNT_D_EULADONE,TEXT("1"),FileName);
    }
    if (b  && NoLs && !MakeLocalSource) {
        b = WritePrivateProfileString(WinntDataSection,WINNT_D_NOLS,TEXT("1"),FileName);
    }
    if (b  && UseBIOSToBoot) {
        b = WritePrivateProfileString(WinntDataSection,TEXT("UseBIOSToBoot"),TEXT("1"),FileName);
    }
    if (b && WriteAcpiHalValue && Upgrade) {
        if (AcpiHalValue) {
            b = WritePrivateProfileString(WinntDataSection,TEXT("AcpiHAL"),TEXT("1"),FileName);
        } else {
            b = WritePrivateProfileString(WinntDataSection,TEXT("AcpiHAL"),TEXT("0"),FileName);
        }
    }
    if (b  && IgnoreExceptionPackages) {
        b = WritePrivateProfileString(WinntDataSection,TEXT("IgnoreExceptionPackages"),TEXT("1"),FileName);
    }

#ifdef PRERELEASE
    if (b && AppendDebugDataToBoot) {
        if (!AsrQuickTest) {
            b = WritePrivateProfileString(WinntSetupDataSection,TEXT("OsLoadOptionsVarAppend"),TEXT("/Debug"),FileName);
        }
        else {
            b = WritePrivateProfileString(WinntSetupDataSection,TEXT("OsLoadOptionsVarAppend"),TEXT("/Debug /Baudrate=115200"),FileName);
        }
    }
#endif

    if (b && AsrQuickTest) {
        wsprintf(Text, TEXT("%d"), AsrQuickTest);
        b = WritePrivateProfileString(WinntDataSection,TEXT("AsrMode"),Text,FileName);
    }

    if (b && (RunningBVTs || AsrQuickTest)) {
        if (lDebugBaudRate == 1394) {
            // kd via 1394
            lstrcpy(Text, TEXT("/debug /debugport=1394"));
        } else if (lDebugComPort == 0) {
            wsprintf(Text, TEXT("/debug /baudrate=%d"), lDebugBaudRate);
        } else {
            wsprintf(Text, TEXT("/debug /baudrate=%d /debugport=com%d"), lDebugBaudRate, lDebugComPort);
        }

        // write the string to OsLoadOptions so "textmode" setup to run under the debugger
        b = WritePrivateProfileString(WinntSetupDataSection,TEXT("OsLoadOptions"),Text,FileName);

        if (b) {
            // write the string to OsLoadOptionsVar so guimode setup to run under the debugger
            b = WritePrivateProfileString(WinntSetupDataSection,TEXT("OsLoadOptionsVar"),Text,FileName);

            if (b) {
                // also run guimode's setup.exe under NTSD
                b = WritePrivateProfileString(WinntSetupDataSection,TEXT("SetupCmdlinePrepend"),TEXT("ntsd -odgGx"),FileName);
            }
        }
    }

    if (b && Timeout[0]) {

        b = WritePrivateProfileString(WinntSetupDataSection,WINNT_S_OSLOADTIMEOUT,Timeout,FileName);
    }

    if(b) {
        //
        // Write upgrade stuff. WinntUpgrade and Win95Upgrade will both be set,
        // and at most one of them will be set to yes.
        //
        if(b = WritePrivateProfileString(WinntDataSection,WINNT_D_NTUPGRADE,WINNT_A_NO,FileName)) {
            b = WritePrivateProfileString(WinntDataSection,WINNT_D_WIN95UPGRADE,WINNT_A_NO,FileName);
        }
        if(b) {
            wsprintf(Text,TEXT("%x"),GetVersion());
            b = WritePrivateProfileString(WinntDataSection,WINNT_D_WIN32_VER,Text,FileName);
            if(b && Upgrade) {
                b = WritePrivateProfileString(
                        WinntDataSection,
                        ISNT() ? WINNT_D_NTUPGRADE : WINNT_D_WIN95UPGRADE,
                        WINNT_A_YES,
                        FileName
                        );


                MyGetWindowsDirectory(Text,MAX_PATH);
                Text[2] = 0;

                b = WritePrivateProfileString(WinntDataSection,WINNT_D_WIN32_DRIVE,Text,FileName);
                if(b) {
                    Text[2] = TEXT('\\');
                    b = WritePrivateProfileString(WinntDataSection,WINNT_D_WIN32_PATH,Text+2,FileName);
                }
            }
        }
    }

    //
    // Flags for Accessible Setup
    //
    AccessibleSetup = FALSE;

    if(!Upgrade) {
        if(b && AccessibleMagnifier) {
            b = WritePrivateProfileString(WinntAccessSection,WINNT_D_ACC_MAGNIFIER,
                TEXT("1"),FileName);
            AccessibleSetup = TRUE;
        }
        if(b && AccessibleReader) {
            b = WritePrivateProfileString(WinntAccessSection,WINNT_D_ACC_READER,
                TEXT("1"),FileName);
            AccessibleSetup = TRUE;
        }
        if(b && AccessibleKeyboard) {
            b = WritePrivateProfileString(WinntAccessSection,WINNT_D_ACC_KEYBOARD,
                TEXT("1"),FileName);
            AccessibleSetup = TRUE;
        }
    }

    if(b && AccessibleSetup && !UnattendedOperation) {
        UnattendedOperation = TRUE;
        UnattendedShutdownTimeout = 0;
        UnattendedScriptFile = MALLOC(MAX_PATH * sizeof(TCHAR));
        b = (UnattendedScriptFile != NULL);
        if(b) {
            lstrcpy(UnattendedScriptFile,NativeSourcePaths[0]);
            ConcatenatePaths(UnattendedScriptFile,AccessibleScriptFile,MAX_PATH);
        }
    }

    if(!b) {
        goto c1;
    }

    //
    // Value indicating we're automatically and quietly skipping missing files.
    //
    if(AutoSkipMissingFiles) {
        b = WritePrivateProfileString(WinntSetupSection,WINNT_S_SKIPMISSING,TEXT("1"),FileName);
        if(!b) {
            goto c1;
        }
    }

    //
    // Command to be executed at end of GUI setup, if any.
    //
    if(CmdToExecuteAtEndOfGui) {

        b = WritePrivateProfileString(
                WinntSetupSection,
                WINNT_S_USEREXECUTE,
                CmdToExecuteAtEndOfGui,
                FileName
                );


        if(!b) {
            goto c1;
        }
    }

    //
    // Ensure that Plug and Play state in upgraded os will be the same as the
    // original.  Enables per-device settings to be preserved in the NT5+
    // upgrade scenario.
    //
    if (ISNT() && (BuildNumber > NT40) && Upgrade) {
        LPTSTR buffer = NULL;

        if (MigrateDeviceInstanceData(&buffer)) {
            WritePrivateProfileSection(WINNT_DEVICEINSTANCES,
                                       buffer,
                                       FileName);
            //
            // Free the allocated buffer that was returned
            //
            LocalFree(buffer);
            buffer = NULL;
        }

        if (MigrateClassKeys(&buffer)) {
            WritePrivateProfileSection(WINNT_CLASSKEYS,
                                       buffer,
                                       FileName);
            //
            // Free the allocated buffer that was returned
            //
            LocalFree(buffer);
            buffer = NULL;
        }

        if (MigrateHashValues(&buffer)) {
            WritePrivateProfileSection(WINNT_DEVICEHASHVALUES,
                                       buffer,
                                       FileName);
            //
            // Free the allocated buffer that was returned
            //
            LocalFree(buffer);
            buffer = NULL;
        }
    }

    //
    // Remember udf info. If there's a database file, stick a * on the end
    // of the ID before writing it.
    //
    if(UniquenessId) {

        d = lstrlen(UniquenessId);
        if(d >= (MAX_PATH-1)) {
            d--;
        }
        lstrcpyn(Text,UniquenessId,MAX_PATH-1);
        if(UniquenessDatabaseFile) {
            Text[d] = TEXT('*');
            Text[d+1] = 0;
        }

        b = WritePrivateProfileString(WinntDataSection,WINNT_D_UNIQUENESS,Text,FileName);
        if(!b) {
            goto c1;
        }
        if(UniquenessDatabaseFile) {

            if ('\0' == LocalSourceDirectory[0]) {
                MessageBoxFromMessage(
                            ParentWindow,
                            MSG_UDF_INVALID_USAGE,
                            FALSE,
                            AppTitleStringId,
                            MB_OK | MB_ICONERROR | MB_TASKMODAL,
                            UniquenessDatabaseFile
                            );
                goto c0;
            }

            lstrcpyn(Text,LocalSourceDirectory,MAX_PATH);
            ConcatenatePaths(Text,WINNT_UNIQUENESS_DB,MAX_PATH);

            CreateMultiLevelDirectory(LocalSourceDirectory);
            b = CopyFile(UniquenessDatabaseFile,Text,FALSE);
            if(!b) {
                MessageBoxFromMessageAndSystemError(
                    ParentWindow,
                    MSG_UDF_FILE_INVALID,
                    GetLastError(),
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL,
                    UniquenessDatabaseFile
                    );

                goto c0;
            }
        }
    }

    //
    // If any optional dirs are present then we want to generate
    // an entry in the sif file that contains a line that specifies them
    // in the form dir1*dir2*...*dirn
    //
    OptionalDirLength = 0;
    OptionalDirString = NULL;

    for(d=0; d<OptionalDirectoryCount; d++) {
        //
        // Ignore temp-only and oem directories here.
        //
        if(OptionalDirectoryFlags[d] & (OPTDIR_OEMSYS | OPTDIR_TEMPONLY | OPTDIR_OVERLAY)) {
            continue;
        }

        if (OptionalDirectoryFlags[d] & (OPTDIR_DEBUGGEREXT)) {
            // hardcode the dest dir to "system32\pri"
            OptDir = TEXT("system32\\pri");
        } else {
            if (OptionalDirectoryFlags[d] & OPTDIR_USE_TAIL_FOLDER_NAME) {
                //
                // create all copydir: directories in a subdirectory under target %windir%
                //
                OptDir = _tcsrchr (OptionalDirectories[d], TEXT('\\'));
                if (OptDir) {
                    OptDir++;
                } else {
                    OptDir = OptionalDirectories[d];
                }
            } else {
                OptDir = OptionalDirectories[d];
            }
        }

        //
        // support ".." syntax
        //
        while (_tcsstr(OptDir,TEXT("..\\"))) {
            OptDir += 3;
        }

        if(OptionalDirString) {

            p = REALLOC(
                    OptionalDirString,
                    (lstrlen(OptDir) + 2 + OptionalDirLength) * sizeof(TCHAR)
                    );
        } else {
            p = MALLOC((lstrlen(OptDir)+2)*sizeof(TCHAR));
        }

        if(!p) {
            if(OptionalDirString) {
                FREE(OptionalDirString);
            }
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto c1;
        }

        OptionalDirString = p;

        if(OptionalDirLength) {
            lstrcat(OptionalDirString,OptDir);
        } else {
            lstrcpy(OptionalDirString,OptDir);
        }

        lstrcat(OptionalDirString,TEXT("*"));
        OptionalDirLength = lstrlen(OptionalDirString);
    }

    if(OptionalDirString) {
        //
        // Remove trailing * if any
        //
        d = lstrlen(OptionalDirString);
        if(d && (OptionalDirString[d-1] == TEXT('*'))) {
            OptionalDirString[d-1] = 0;
        }

        b = WritePrivateProfileString(
                WinntSetupSection,
                WINNT_S_OPTIONALDIRS,
                OptionalDirString,
                FileName
                );

        d = GetLastError();

        FREE(OptionalDirString);

        if(!b) {
            SetLastError(d);
            goto c1;
        }
    }

    //
    // Slap a unique identifier into the registry.
    // We'll use this in unattended upgrade during text mode
    // to find this build.
    //
    // Pretty simple: we'll use a string that derives
    // from the sysroot, and some unique value based on
    // the current tick count.
    //
    l = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("SYSTEM\\Setup"),
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_SET_VALUE,
            NULL,
            &hKey,
            &d
            );

    if(l != NO_ERROR) {
        SetLastError(l);
        goto c2;
    }

    d = MyGetWindowsDirectory(Text,MAX_PATH);
    if((d + 5) > MAX_PATH) {
        d = MAX_PATH - 5;
    }

    Text[d++] = TEXT('\\');
    Text[d++] = (TCHAR)(((GetTickCount() & 0x00f) >> 0) + 'A');
    Text[d++] = (TCHAR)(((GetTickCount() & 0x0f0) >> 4) + 'A');
    Text[d++] = (TCHAR)(((GetTickCount() & 0xf00) >> 8) + 'A');
    Text[d++] = 0;

    //
    // Set the value in the registry.
    //
    l = RegSetValueEx(hKey,WinntUniqueId,0,REG_SZ,(CONST BYTE *)Text,d*sizeof(TCHAR));
    RegCloseKey(hKey);
    if(l != NO_ERROR) {
        SetLastError(l);
        goto c2;
    }

    //
    // Stick the value in winnt.sif so we can correlate
    // later when we go to upgrade.
    //
    b = WritePrivateProfileString(WinntDataSection,WinntUniqueId,Text,FileName);
    if(!b) {
        goto c1;
    }

    //
    // Now write information about the source path(s) we used.
    // Use SourcePath[0].
    //
    // If the name starts with \\ then we assume it's UNC and
    // just use it directly. Otherwise we call MyGetDriveType on it
    // and if it's a network drive we get the UNC path.
    // Otherwise we just go ahead and save as-is.
    // Also save the type.
    //
    if((SourcePaths[0][0] == TEXT('\\')) && (SourcePaths[0][1] == TEXT('\\'))) {

        d = DRIVE_REMOTE;
        lstrcpy(Text,SourcePaths[0]);

    } else {
        if(GetFullPathName(SourcePaths[0],MAX_PATH,FullPath,(LPTSTR *)&p)) {
            if(FullPath[0] == TEXT('\\')) {
                //
                // Assume UNC, since a full path should normally start
                // with a drive letter.
                //
                d = DRIVE_REMOTE;
                lstrcpy(Text,FullPath);
            } else {
                d = MyGetDriveType(FullPath[0]);
                if((d == DRIVE_REMOTE) && (FullPath[1] == TEXT(':')) && (FullPath[2] == TEXT('\\'))) {
                    //
                    // Get actual UNC path.
                    //
                    FullPath[2] = 0;
                    l = MAX_PATH;

                    if(WNetGetConnection(FullPath,Text,(LPDWORD)&l) == NO_ERROR) {

                        l = lstrlen(Text);
                        if(l && (Text[l-1] != TEXT('\\')) && FullPath[3]) {
                            Text[l] = TEXT('\\');
                            Text[l+1] = 0;
                        }
                        lstrcat(Text,FullPath+3);
                    } else {
                        //
                        // Strange case.
                        //
                        FullPath[2] = TEXT('\\');
                        lstrcpy(Text,FullPath);
                        d = DRIVE_UNKNOWN;
                    }

                } else {
                    //
                    // Use as-is.
                    //
                    if(d == DRIVE_REMOTE) {
                        d = DRIVE_UNKNOWN;
                    }
                    lstrcpy(Text,FullPath);
                }
            }
        } else {
            //
            // Type is unknown. Just use as-is.
            //
            d = DRIVE_UNKNOWN;
            lstrcpy(Text,SourcePaths[0]);
        }
    }

    //
    // In the preinstall case ignore all the above and
    // force gui setup to search for a CD.
    // This particular combination of values will do it.
    //
    if(OemPreinstall) {

    //
    // marcw (7-22-97) - Changed to fix alpha build break.
    //                   FirstFloppyDriveLetter is defined on X86s only.
    //
        if (!IsArc()) {
#ifdef _X86_
            Text[0] = FirstFloppyDriveLetter;
            Text[1] = TEXT(':');
            Text[2] = TEXT('\\');
            Text[3] = 0;
#endif // _X86_
        } else {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
            lstrcpy(Text,TEXT("A:\\"));
#endif // UNICODE
        } // if (!IsArc())

        MYASSERT (LocalSourceWithPlatform[0]);

        ConcatenatePaths(
            Text,
            &LocalSourceWithPlatform[lstrlen(LocalSourceDirectory)],
            MAX_PATH
            );

        d = DRIVE_CDROM;
    }

    b = WritePrivateProfileString(WinntDataSection,WINNT_D_ORI_SRCPATH,Text,FileName);
    if(!b) {
        goto c1;
    }

#if defined(REMOTE_BOOT)
    //
    // If this is a remote boot upgrade, write the source path to SetupSourceDevice
    // under [SetupData]. We do NOT want the platform path here. Also write the
    // path to the machine directory to TargetNtPartition under [SetupData]. This
    // is just whatever \DosDevices\C: translates to. Finally, write the computer
    // name to ComputerName under [UserData].
    //
    if (RemoteBoot) {

        DWORD len;

        MYASSERT(d == DRIVE_REMOTE);
        MYASSERT((*Text == TEXT('\\')) && (*(Text + 1) == TEXT('\\')));

        lstrcpy(FullPath, TEXT("\\Device\\LanmanRedirector"));
        ConcatenatePaths(FullPath, Text+1, MAX_PATH);

        p = _tcsrchr(FullPath,TEXT('\\'));
        MYASSERT(p != NULL);
        *(LPTSTR)p = 0;

        b = WritePrivateProfileString(
                WinntSetupDataSection,
                TEXT("SetupSourceDevice"),
                FullPath,
                FileName);
        if(!b) {
            goto c1;
        }

        MyGetWindowsDirectory(Text, MAX_PATH);
        Text[2] = 0;
        len = QueryDosDevice(Text, Text, MAX_PATH);
        if (len == 0) {
            goto c1;
        }
        b = WritePrivateProfileString(
                WinntSetupDataSection,
                TEXT("TargetNtPartition"),
                Text,
                FileName);
        if(!b) {
            goto c1;
        }

        len = MAX_PATH;
        b = GetComputerName(Text, &len);
        if(!b) {
            goto c1;
        }
        b = WritePrivateProfileString(
                WinntUserDataSection,
                WINNT_US_COMPNAME,
                Text,
                FileName);
        if(!b) {
            goto c1;
        }
    }
#endif // defined(REMOTE_BOOT)

    wsprintf(Text,TEXT("%u"),d);
    WritePrivateProfileString(WinntDataSection,WINNT_D_ORI_SRCTYPE,Text,FileName);
    if(!b) {
        goto c1;
    }
#ifdef _X86_
    //
    // NT 4 and Win95 for NEC98 have 2 types Drive assing.
    //  - NEC DOS Type(A: HD, B:HD,...X:FD)
    //  - PC-AT Type(A:FD, B:FD, C:HD, D:HD, ....)
    //
    // Upgrade setup should be keep above drive assign and All setup should
    // be keep FT information.
    // Because some Applications have drive letter in own data file or registry.
    // NT5 setup for NEC98 have Drive assign type in winnt.sif section[data].
    // And this key is "DriveAssign_Nec98".
    // Value is "yes", It means NEC DOS Type assign.
    // Value is "no", It means PC-AT Type.
    // Now, This Key defined this place, but near future, this key move into
    // \nt\public\sdk\inc\setupbat.h, I hope.
    //
    // \textmode\kernel\spsetup.c has same defines.
    //

#define WINNT_D_DRIVEASSIGN_NEC98_W L"DriveAssign_Nec98"
#define WINNT_D_DRIVEASSIGN_NEC98_A "DriveAssign_Nec98"

#ifdef UNICODE
#define WINNT_D_DRIVEASSIGN_NEC98 WINNT_D_DRIVEASSIGN_NEC98_W
#else
#define WINNT_D_DRIVEASSIGN_NEC98 WINNT_D_DRIVEASSIGN_NEC98_A
#endif

    if (IsNEC98()){
        if (IsDriveAssignNEC98() == TRUE){
            WritePrivateProfileString(WinntDataSection, WINNT_D_DRIVEASSIGN_NEC98, WINNT_A_YES, FileName);
        } else {
            WritePrivateProfileString(WinntDataSection, WINNT_D_DRIVEASSIGN_NEC98, WINNT_A_NO, FileName);

        }
    }
#endif
    //
    // At this point we process the file, and surround all values with
    // double-quotes. This gets around certain problems in the various
    // inf parsers used in later stages of setup. Do this BEFORE appending
    // the unattend stript file, because some of the stuff in there expects
    // to be treated as multiple values, which double quotes ruin.
    //
    WritePrivateProfileString(NULL,NULL,NULL,FileName);
    d = PatchWinntSifFile(FileName);
    if(d != NO_ERROR) {
        SetLastError(d);
        goto c1;
    }

    //
    // Language options
    // Note: we don't want these values surrounded by double-quotes.
    //
    if( SaveLanguageParams( FileName ) ) {
        FreeLanguageData();
    } else {
        goto c1;
    }

    //
    // Append unattend script file if necessary.
    //
    if(UnattendedOperation && UnattendedScriptFile) {
        if(!AppendParamsFile(ParentWindow,UnattendedScriptFile,FileName)) {
           return(FALSE);
        }
    }

#if defined(UNICODE) && defined(_X86_)
    //
    // Append any migdll info.
    //
    if (Upgrade && ISNT() && *g_MigDllAnswerFilePath && FileExists (g_MigDllAnswerFilePath, NULL)) {
        AppendParamsFile (ParentWindow, g_MigDllAnswerFilePath, FileName);
    }


#endif

    //
    // append DynamicUpdate data
    //
    if (!DynamicUpdateWriteParams (FileName)) {
        goto c1;
    }

    //
    // If we're explicitly in unattended mode then it's possible that
    // there is no [Unattended] section in winnt.sif yet, such as if
    // the user used the /unattend switch without specifying a file,
    // or if the file he did specify didn't have an [Unattended] section
    // for some reason.
    //
    // Also, make all upgrades unattended.
    //
    // Text mode setup kicks into unattended mode based on the presence
    // of the [Unattended] section.
    //
    if(UnattendedOperation || Upgrade) {
        if(!WritePrivateProfileString(WINNT_UNATTENDED,TEXT("unused"),TEXT("unused"),FileName)) {
            goto c1;
        }
    }

    //
    // Since several conditions can turn on UnattendedOperation, we keep track
    // of whether the user actually specified the "/unattend" switch separately.
    //
    if( UnattendSwitchSpecified ) {
        if(!WritePrivateProfileString(WinntDataSection,WINNT_D_UNATTEND_SWITCH,WINNT_A_YES,FileName)) {
            goto c1;
        }
    }

    //
    // set the NTFS conversion flag
    //
    GetPrivateProfileString(WINNT_UNATTENDED,TEXT("FileSystem"),TEXT(""),Text,sizeof(Text)/sizeof(TCHAR),FileName);
    if (_tcslen(Text) == 0) {
        if (ForceNTFSConversion) {
            if(!WritePrivateProfileString(WinntDataSection,TEXT("FileSystem"),TEXT("ConvertNTFS"),FileName)) {
                goto c1;
            }
        }
    }




    //
    // Headless Stuff.
    //
    if( !WriteHeadlessParameters( FileName ) ) {
        goto c1;
    }



    if ( (Upgrade) &&
         !(ISNT() && (BuildNumber <= NT351)) ) {

        //
        // Save current Program Files directory
        //

        rc = RegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"),
                0,        //ulOptions (reserved)
                KEY_READ,
                &hKey
                );

        if (rc != ERROR_SUCCESS) {
            goto c1;
        }

        PfPath = pGetPfPath (hKey, TEXT("ProgramFilesDir"));
        if (PfPath) {
            if (!WritePrivateProfileString (
                    WINNT_UNATTENDED,
                    WINNT_U_PROGRAMFILESDIR,
                    PfPath,
                    FileName
                    )) {
                goto c3;
            }

            FREE((PVOID) PfPath);
        }

        PfPath = pGetPfPath (hKey, TEXT("CommonFilesDir"));
        if (PfPath) {
            if (!WritePrivateProfileString (
                    WINNT_UNATTENDED,
                    WINNT_U_COMMONPROGRAMFILESDIR,
                    PfPath,
                    FileName
                    )) {
                goto c3;
            }

            FREE((PVOID) PfPath);
        }

#ifdef WX86

        PfPath = pGetPfPath (hKey, TEXT("ProgramFilesDir (x86)"));
        if (PfPath) {
            if (!WritePrivateProfileString (
                    WINNT_UNATTENDED,
                    WINNT_U_PROGRAMFILESDIR_X86,
                    PfPath,
                    FileName
                    )) {
                goto c3;
            }

            FREE((PVOID) PfPath);
        }

        PfPath = pGetPfPath (hKey, TEXT("CommonFilesDir (x86)"));
        if (PfPath) {
            if (!WritePrivateProfileString (
                    WINNT_UNATTENDED,
                    WINNT_U_COMMONPROGRAMFILESDIR_X86,
                    PfPath,
                    FileName
                    )) {
                goto c3;
            }

            FREE((PVOID) PfPath);
        }

#endif

        RegCloseKey(hKey);
    }

    //
    // value indicating the product ID
    //  we need to write this in after appending the unattend file data, since the
    //  product ID in the unattend file may have been incorrect, but this product ID
    //  has already been verified as valid. we need to make sure we surround the product ID with quotes
    //
    if (b ) {
        // This will overwrite any existing "ProductID" entry. Which may have been added
        // by merging the unattend file.
        // If we don't do this. GUI mode overwrites the "ProductKey" with the entry
        // under "ProductID".
       b = WritePidToParametersFile(WinntUserSection,WINNT_US_PRODUCTID,FileName);
       if (!b) {
          goto c1;
       }

       b = WritePidToParametersFile(WinntUserSection,WINNT_US_PRODUCTKEY,FileName);
       if (!b) {
          goto c1;
       }
    }

    //
    // Do not save the proxy settings if we are running under WINPE.
    // 
    if (!IsWinPEMode()){
        SaveProxyForOobe(FileName);
    }

    return(TRUE);


c3:
    FREE((PVOID) PfPath);
    RegCloseKey(hKey);

c2:
    MessageBoxFromMessageAndSystemError(
        ParentWindow,
        MSG_REGISTRY_ACCESS_ERROR,
        GetLastError(),
        AppTitleStringId,
        MB_OK | MB_ICONERROR | MB_TASKMODAL,
        NULL
        );
    goto c0;

c1:
    MessageBoxFromMessageAndSystemError(
        ParentWindow,
        MSG_BOOT_FILE_ERROR,
        GetLastError(),
        AppTitleStringId,
        MB_OK | MB_ICONERROR | MB_TASKMODAL,
        FileName
        );
c0:
    return(FALSE);
}


DWORD
PatchWinntSifFile(
    IN LPCTSTR Filename
    )

/*++

Routine Description:

    This function works around the problems in the setupldr parser,
    which cannot handle unquoted strings. Each line in the given file
    is enclosed within quotation marks.

Arguments:

    Filename - Name of the WINNT.SIF file

Return Value:

    Boolean value indicating outcome. If FALSE the user is NOT
    informed about why; the caller must do that.

--*/

{
    PVOID Base;
    HANDLE hMap,hFile;
    DWORD Size;
    DWORD d;
    PCHAR End;
    PCHAR p,q;
    PCHAR o,a;
    PCHAR Buffer;
    int l1,l2;
    int tryagain=0;

    //
    // Open the file.
    //

    d = MapFileForRead(Filename,&Size,&hFile,&hMap,&Base);
    if(d != NO_ERROR) {
        return(FALSE);
    }

    //
    // Allocate the output buffer; the original size + extra space for quotes
    //
    Buffer = MALLOC(Size + Size / 4);
    if(!Buffer) {
        UnmapFile(hMap,Base);
        CloseHandle(hFile);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    o = Buffer;
    p = Base;
    End = p+Size;

    while(p < End) {
        //
        // Find end of line.
        //
        for(q=p; (q < End) && (*q != '\n'); q++) {
            NOTHING;
        }

        //
        // Find equals sign, if present
        //
        for(a=p; a<q; a++) {
            if(*a == '=') {
                break;
            }
        }
        if(a >= q) {
            a = NULL;
        }

        if(a) {

            a++;

            l1 = (int)(a - p);
            l2 = (int)(q - a);

            CopyMemory(o,p,l1);
            o += l1;
            *o++ = '\"';
            CopyMemory(o,a,l2);
            o += l2;
            if(*(o-1) == '\r') {
                o--;
            }
            *o++ = '\"';
            *o++ = '\r';
            *o++ = '\n';

        } else {

            l1 = (int)(q-p);
            CopyMemory(o,p,l1);
            o += l1;
            *o++ = '\n';
        }

        //
        // Skip to start of next line
        //
        p=q+1;
    }

    UnmapFile(hMap,Base);
    CloseHandle(hFile);

    SetFileAttributes(Filename,FILE_ATTRIBUTE_NORMAL);
    //
    // We try opening the file thrice to get around the problem of anti-virus software
    // that monitor files on the root of the system partition. The problem is that usually these
    // s/w examine the files we touch and in somecases open it with exclusive access.
    // We just need to wait for them to be done.
    //


    while( tryagain++ < 3 ){
        hFile = CreateFile(
                Filename,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );
        if(hFile != INVALID_HANDLE_VALUE)
            break;
        Sleep(500);

    }


    if(hFile == INVALID_HANDLE_VALUE) {
        d = GetLastError();
        FREE(Buffer);
        return(d);
    }

    d = WriteFile(hFile,Buffer,(DWORD)(o-Buffer),&Size,NULL) ? NO_ERROR : GetLastError();

    CloseHandle(hFile);
    FREE(Buffer);

    return(d);
}


BOOL
AppendParamsFile(
    IN HWND    ParentWindow,
    IN LPCTSTR ParametersFileIn,
    IN LPCTSTR ParametersFileOut
    )

/*++

Routine Description:

    Read an external file (such as an unattended script file)
    and copy it section by section into the winnt.sif parameters
    file. (The [Data] and [OemBootFiles] sections of the unattend file
    are ignored.)

Arguments:

    ParentWindow - supplies window handle of window to act as owner/parent
        if this routine has to put up ui, such as when the script file
        is bogus.

    ParametersFileIn - supplies win32 filename of the file, such as
        unattend.txt, being appended to winnt.sif.

    ParametersFileOut - supplies win32 filename of the winnt.sif file
        being generated.

Return Value:

    Boolean value indicating outcome. If FALSE, the user will have been
    informed of why.

--*/

{
    TCHAR *SectionNames;
    TCHAR *SectionData;
    TCHAR *SectionName;
    DWORD SectionNamesSize;
    DWORD SectionDataSize;
    DWORD d;
    TCHAR TempFile[MAX_PATH] = TEXT("");
    PCTSTR RealInputFile = NULL;
    BOOL b;
    PVOID p;



    #define PROFILE_BUFSIZE 16384
    #define PROFILE_BUFGROW 4096

    //
    // Allocate some memory for the required buffers
    //
    SectionNames = MALLOC(PROFILE_BUFSIZE * sizeof(TCHAR));
    SectionData  = MALLOC(PROFILE_BUFSIZE * sizeof(TCHAR));

    if(!SectionNames || !SectionData) {
        MessageBoxFromMessage(
            ParentWindow,
            MSG_OUT_OF_MEMORY,
            FALSE,
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL
            );

        b = FALSE;
        goto c0;
    }

    *TempFile = 0;
    RealInputFile = ParametersFileIn;


    //
    // There is a bug in Win9x's GetPrivateProfileSection() Such that if the file
    // being queried exists on a read only share, it will not return the section strings.
    // This is bad.
    //
    // To work around this, on win9x, we are going to make a temporary copy of the inf
    // merge it in and then delete it.
    //
#ifdef _X86_
    if (!ISNT() && ParametersFileIn && FileExists (ParametersFileIn, NULL)) {

        GetSystemDirectory (TempFile, MAX_PATH);
        GetTempFileName (TempFile, TEXT("USF"), 0, TempFile);
        CopyFile (ParametersFileIn, TempFile, FALSE);
        RealInputFile = TempFile;
    }
#endif


    SectionNamesSize = PROFILE_BUFSIZE;
    SectionDataSize  = PROFILE_BUFSIZE;

    //
    // Retreive a list of section names in the unattend script file.
    //
    do {
        d = GetPrivateProfileString(
            NULL,
            NULL,
            TEXT(""),
            SectionNames,
            SectionNamesSize,
            RealInputFile
            );

        if(!d) {
            //
            // No section names. Bogus file.
            //
            MessageBoxFromMessage(
                ParentWindow,
                MSG_UNATTEND_FILE_INVALID,
                FALSE,
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                ParametersFileIn
                );

            b = FALSE;
            goto c0;
        }

        if(d == (SectionNamesSize-2)) {
            //
            // Buffer was too small. Reallocate it and try again.
            //
            p = REALLOC(
                    SectionNames,
                    (SectionNamesSize+PROFILE_BUFGROW)*sizeof(TCHAR)
                    );

            if(!p) {
                MessageBoxFromMessage(
                    ParentWindow,
                    MSG_OUT_OF_MEMORY,
                    FALSE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL
                    );

                b = FALSE;
                goto c0;
            }

            SectionNames = p;
            SectionNamesSize += PROFILE_BUFGROW;
        }
    } while(d == (SectionNamesSize-2));

    for(SectionName=SectionNames; *SectionName; SectionName+=lstrlen(SectionName)+1) {
        //
        // Ignore the [data] section in the source, as we do not
        // want copy it into the target, because this would overwrite
        // our internal settings.
        // Ignore also [OemBootFiles]
        //
        if(lstrcmpi(SectionName,WINNT_DATA) && lstrcmpi(SectionName,WINNT_OEMBOOTFILES)) {
            //
            // Fetch the entire section and write it to the target file.
            // Note that the section-based API call will leave double-quotes
            // intact when we retrieve the data, which is what we want.
            // Key-based API calls will strip quotes, which screws us.
            //
            while(GetPrivateProfileSection(
                    SectionName,
                    SectionData,
                    SectionDataSize,
                    RealInputFile
                    )                       == (SectionDataSize-2)) {

                //
                // Reallocate the buffer and try again.
                //
                p = REALLOC(
                        SectionData,
                        (SectionDataSize+PROFILE_BUFGROW)*sizeof(TCHAR)
                        );

                if(!p) {
                    MessageBoxFromMessage(
                        ParentWindow,
                        MSG_OUT_OF_MEMORY,
                        FALSE,
                        AppTitleStringId,
                        MB_OK | MB_ICONERROR | MB_TASKMODAL
                        );

                    b = FALSE;
                    goto c0;
                }

                SectionData = 0;
                SectionDataSize += PROFILE_BUFGROW;
            }

            //
            // Write the entire section to the output file.
            //
            if(!WritePrivateProfileSection(SectionName,SectionData,ParametersFileOut)) {

                MessageBoxFromMessageAndSystemError(
                    ParentWindow,
                    MSG_BOOT_FILE_ERROR,
                    GetLastError(),
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL,
                    ParametersFileOut
                    );

                b = FALSE;
                goto c0;
            }
        }
    }

    b = TRUE;

c0:
    if(SectionNames) {
        FREE(SectionNames);
    }
    if(SectionData) {
        FREE(SectionData);
    }

    if (*TempFile) {

        DeleteFile (TempFile);
    }

    return(b);
}


BOOL
WriteParametersFile(
    IN HWND ParentWindow
    )
{
    TCHAR SysPartFile[MAX_PATH];
    DWORD d;
    BOOL  b;

    //
    // Write the file out onto the root of the system partition drive
    // and then move the file into place where it actually belongs.
    //
#if defined(REMOTE_BOOT)
    if (RemoteBoot) {
        //
        // For remote boot, put the file in the root of the machine directory
        // and leave it there.
        //
        lstrcpy(SysPartFile, MachineDirectory);
        lstrcat(SysPartFile, TEXT("\\"));
        lstrcat(SysPartFile,WINNT_SIF_FILE);
        lstrcpy(ActualParamFile,SysPartFile);
    } else
#endif // defined(REMOTE_BOOT)
    {
        if (!BuildSystemPartitionPathToFile (WINNT_SIF_FILE, SysPartFile, MAX_PATH)) {
            return(FALSE); // this should never happen.
        }
    }

    if(!DoWriteParametersFile(ParentWindow,SysPartFile)) {
        return(FALSE);
    }

#if defined(REMOTE_BOOT)
    //
    // For remote boot, leave the file in the root of the machine directory.
    //

    if (!RemoteBoot)
#endif // defined(REMOTE_BOOT)
    {

        if (!IsArc()) {
#ifdef _X86_
            //
            // In the x86 case this file belongs on the boot media
            // somewhere. If we're generating floppyless boot media
            // then move the file into place. Otherwise there's no point.
            //
            // In the non-floppyless case we keep the file around until later
            // when the floppy-generation code gets to run.
            //
            if(MakeBootMedia) {

                if(Floppyless) {

                    BuildSystemPartitionPathToFile (LOCAL_BOOT_DIR, ActualParamFile, MAX_PATH);

                    d = CreateMultiLevelDirectory(ActualParamFile);
                    if(d != NO_ERROR) {

                        MessageBoxFromMessageAndSystemError(
                            ParentWindow,
                            MSG_DIR_CREATE_FAILED,
                            d,
                            AppTitleStringId,
                            MB_OK | MB_ICONERROR | MB_TASKMODAL,
                            ActualParamFile
                            );

                        DeleteFile(SysPartFile);
                        return(FALSE);
                    }

                    ConcatenatePaths(ActualParamFile,WINNT_SIF_FILE,MAX_PATH);

                    //
                    // Move the file into its real location.
                    //
                    DeleteFile(ActualParamFile);

                    //
                    // On Windows 95, MoveFile fails in strange ways
                    // when the profile APIs have the file open (for instance,
                    // it will leave the src file and the dest file will be
                    // filled with garbage).
                    //
                    // Flush that bastard
                    //
                    WritePrivateProfileString(NULL,NULL,NULL,SysPartFile);

                    if (SysPartFile[0] == ActualParamFile[0]) {
                        b = MoveFile(SysPartFile,ActualParamFile);
                    } else {
                        b = CopyFile (SysPartFile, ActualParamFile, FALSE);
                        if (b) {
                            DeleteFile (SysPartFile);
                        }
                    }

                    if (!b) {
                        MessageBoxFromMessageAndSystemError(
                            ParentWindow,
                            MSG_BOOT_FILE_ERROR,
                            GetLastError(),
                            AppTitleStringId,
                            MB_OK | MB_ICONERROR | MB_TASKMODAL,
                            ActualParamFile
                            );

                        DeleteFile(SysPartFile);

                        return(FALSE);
                    }

                }
            } else {
                DeleteFile(SysPartFile);
            }
#endif // _X86_
        } else {
#ifdef UNICODE // Always true for ARC, never true for Win9x upgrade
            //
            // If we're making a local source, move the file there.
            // Otherwise just leave it on the root of the system partition.
            //
            if(MakeLocalSource) {

                d = CreateMultiLevelDirectory(LocalSourceWithPlatform);
                if(d != NO_ERROR) {

                    MessageBoxFromMessageAndSystemError(
                        ParentWindow,
                        MSG_DIR_CREATE_FAILED,
                        d,
                        AppTitleStringId,
                        MB_OK | MB_ICONERROR | MB_TASKMODAL,
                        LocalSourceWithPlatform
                        );

                    DeleteFile(SysPartFile);
                    return(FALSE);
                }

                //
                // Move the file into its real location.
                //
                wsprintf(ActualParamFile,TEXT("%s\\%s"),LocalSourceWithPlatform,WINNT_SIF_FILE);
                DeleteFile(ActualParamFile);
                if(!MoveFile(SysPartFile,ActualParamFile)) {

                    MessageBoxFromMessageAndSystemError(
                        ParentWindow,
                        MSG_BOOT_FILE_ERROR,
                        GetLastError(),
                        AppTitleStringId,
                        MB_OK | MB_ICONERROR | MB_TASKMODAL,
                        ActualParamFile
                        );

                    DeleteFile(SysPartFile);
                    return(FALSE);
                }
            }
#endif // UNICODE
        } // if (!IsArc())
    }

    return(TRUE);
}


//#ifdef _X86_

#define MULTI_SZ_NEXT_STRING(x) ((x) + _tcslen(x) + 1)

BOOL
MergeINFFiles(
    IN      PCTSTR SourceFileName,
    IN      PCTSTR DestFileName
    )
{
    DWORD dwAttributes;
    PTSTR pSectionsBuffer = NULL;
    PTSTR pKeysBuffer = NULL;
    PTSTR pString = NULL;
    PTSTR pSection;
    PTSTR pKey;
    UINT sizeOfBuffer;
    UINT sizeOfSectionBuffer;
    BOOL bResult = FALSE;

    MYASSERT (SourceFileName && DestFileName);

    if(-1 == GetFileAttributes(SourceFileName)){
        return TRUE;
    }

    __try{
        //
        // Allocate buffer for sections names.
        //
        sizeOfBuffer = 0;
        do{
            if(pSectionsBuffer){
                FREE(pSectionsBuffer);
            }
            sizeOfBuffer += DEF_INF_BUFFER_SIZE;
            pSectionsBuffer = (PTSTR)MALLOC(sizeOfBuffer * sizeof (TCHAR));
            if(!pSectionsBuffer){
                __leave;
            }
        }while((sizeOfBuffer - 2) ==
               GetPrivateProfileSectionNames(pSectionsBuffer,
                                             sizeOfBuffer,
                                             SourceFileName));

        sizeOfSectionBuffer = DEF_INF_BUFFER_SIZE;
        pKeysBuffer = (PTSTR)MALLOC(sizeOfSectionBuffer * sizeof (TCHAR));
        if(!pKeysBuffer){
            __leave;
        }

        sizeOfBuffer = DEF_INF_BUFFER_SIZE;
        pString = (PTSTR)MALLOC(sizeOfBuffer * sizeof (TCHAR));
        if(!pString){
            __leave;
        }

        for(pSection = pSectionsBuffer; pSection[0]; pSection = MULTI_SZ_NEXT_STRING(pSection)){
            //
            // Allocate buffer for entries names;
            //
            while((sizeOfSectionBuffer - 2) ==
                   GetPrivateProfileString(pSection,
                                           NULL,
                                           EMPTY_STRING,
                                           pKeysBuffer,
                                           sizeOfSectionBuffer,
                                           SourceFileName)){
                if(pKeysBuffer){
                    FREE(pKeysBuffer);
                }
                sizeOfSectionBuffer += DEF_INF_BUFFER_SIZE;
                pKeysBuffer = (PTSTR)MALLOC(sizeOfSectionBuffer * sizeof (TCHAR));
                if(!pKeysBuffer){
                    __leave;
                }
            };


            for(pKey = pKeysBuffer; pKey[0]; pKey = MULTI_SZ_NEXT_STRING(pKey))
            {
                //
                // Allocate buffer for value string;
                //
                GetPrivateProfileString(pSection,
                                        pKey,
                                        EMPTY_STRING,
                                        pString,
                                        sizeOfBuffer,
                                        SourceFileName);

                if (!WritePrivateProfileString(pSection, pKey, pString, DestFileName)) {
                    __leave;
                }
            }
        }
        bResult = TRUE;
    }
    __finally{
        DWORD rc = GetLastError ();
        if(pSectionsBuffer){
            FREE(pSectionsBuffer);
        }
        if(pKeysBuffer){
            FREE(pKeysBuffer);
        }
        if(pString){
            FREE(pString);
        }
        SetLastError (rc);
    }

    return bResult;
}

BOOL
AddExternalParams (
    IN HWND ParentWindow
    )
{
    DWORD rc = ERROR_SUCCESS;
    static BOOL Done = FALSE;

    if(Done) {
        return(TRUE);
    }

    //
    // Append external parameters if necessary.
    //

    if(Upgrade && UpgradeSupport.WriteParamsRoutine) {
        rc = UpgradeSupport.WriteParamsRoutine(ActualParamFile);

        if (rc != ERROR_SUCCESS) {
            MessageBoxFromMessageAndSystemError(
                ParentWindow,
                MSG_BOOT_FILE_ERROR,
                GetLastError(),
                AppTitleStringId,
                MB_OK | MB_ICONERROR | MB_TASKMODAL,
                ActualParamFile
                );
        }
    }

#if defined(UNICODE) && defined(_X86_)
    //
    // Merge NT migration unattented inf file with winnt.sif
    //
    if(Upgrade && !MergeINFFiles(g_MigDllAnswerFilePath, ActualParamFile)){
        MessageBoxFromMessageAndSystemError(
            ParentWindow,
            MSG_BOOT_FILE_ERROR,
            GetLastError(),
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            g_MigDllAnswerFilePath
            );
    }
#endif

    //
    // write the compatibility stuff in these cases
    //
    // 1. upgrade from downlevel NT platform
    // 2. clean install
    // 3. upgrade from current NT platform and we have NT5 compatibility items
    //
    // note that win9x has it's own upgrade code path.
    //
    if( (ISNT() && (BuildNumber <= NT40) && Upgrade)
        || !Upgrade
        || (ISNT() && Upgrade && AnyNt5CompatDlls) ){

        //
        // Disable stuff for <= NT4 case, clean install (unsupported arch. etc.)
        // and NT5 upgrade with NT5 upgrade components set
        //

        WriteCompatibilityData( ActualParamFile );
        WriteGUIModeInfOperations( ActualParamFile );
        AddGUIModeCompatibilityInfsToCopyList();
    }

    if (ISNT() && Upgrade) {
        if (!WriteTextmodeClobberData (ActualParamFile)) {
            rc = GetLastError ();
        }
    }

    Done = TRUE;
    return rc == ERROR_SUCCESS;
}

//#endif "




BOOL
MyWritePrivateProfileString(
    LPCTSTR lpAppName,  // pointer to section name
    LPCTSTR lpKeyName,  // pointer to key name
    LPCTSTR lpString,   // pointer to string to add
    LPCTSTR lpFileName  // pointer to initialization filename
    )
/*
  Wrapper for WritePrivateProfileString to try more than once on instances
  where we can't write to the winnt.sif file. This commonly occurs when
  virus software monitors the root of C drive.

  The problem is that usually these s/w examine the files we touch and in somecases open it
  with exclusive access. We just need to wait for them to be done.

*/
{

    int i = 0;
    BOOL ret = FALSE;
    DWORD Err;

    while(i++ < 3){
#ifdef UNICODE
    #ifdef WritePrivateProfileStringW
        #undef WritePrivateProfileStringW

        if( !lpAppName && !lpKeyName && !lpString ){
            WritePrivateProfileStringW( lpAppName, lpKeyName, lpString, lpFileName);
            return FALSE;
        }

        if( ret = WritePrivateProfileStringW( lpAppName, lpKeyName, lpString, lpFileName) )
            break;
    #endif
#else
    #ifdef WritePrivateProfileStringA
        #undef WritePrivateProfileStringA

        if( !lpAppName && !lpKeyName && !lpString ){
            WritePrivateProfileStringA( lpAppName, lpKeyName, lpString, lpFileName);
            return FALSE;
        }

        if( ret = WritePrivateProfileStringA( lpAppName, lpKeyName, lpString, lpFileName) )
            break;
    #endif
#endif
    Sleep( 500 );

    }

    return ret;
}


VOID
FixWininetList(
    LPTSTR List
    )
{
    PTCHAR t = List;

    if (t != NULL)
    {
        while (*t)
        {
            if (*t == (TCHAR)' ')
            {
                *t = (TCHAR)';';
            }
            t++;
        }
    }

}

#ifdef UNICODE

LPWSTR
AnsiToText(
    LPCSTR Ansi
    )
{
    int    Length;
    LPWSTR Unicode = NULL;

    if (Ansi == NULL)
    {
        return NULL;
    }

    Length = MultiByteToWideChar(
        CP_ACP,
        0,
        Ansi,
        -1,
        NULL,
        0
        );

    if (Length > 0)
    {
        int i;

        Unicode = (LPWSTR) GlobalAlloc(GPTR, Length * sizeof(WCHAR));
        if (!Unicode) {
            return NULL;
        }

        i = MultiByteToWideChar(
            CP_ACP,
            0,
            Ansi,
            -1,
            Unicode,
            Length);

        if (i == 0)
        {
            GlobalFree(Unicode);
            Unicode = NULL;
        }
    }

    return Unicode;
}


#else

LPSTR AnsiToText(
    LPCSTR Ansi
    )

/*++

Note:

    Can't use DupString because the caller assume memory obtained from
    GlobalAlloc.

--*/

{
    LPSTR CopyOfAnsi = NULL;

    if (Ansi != NULL)
    {
        CopyOfAnsi = GlobalAlloc(GPTR, (strlen(Ansi)+1) * sizeof(CHAR));
        if (CopyOfAnsi)
        {
            strcpy(CopyOfAnsi, Ansi);
        }
    }

    return CopyOfAnsi;
}

#endif

BOOL
QuoteString(
    IN OUT LPTSTR* StringPointer
    )

/*++

Routine Description:

    Replace the input string with a double quoted one.

Arguments:

    StringPointer - pointer to a string allocated by GlobalAlloc. The input
    string is always free. If it is successful the new string, allocated
    by GlobalAlloc, is returned; otherwise, NULL is returned.

Return:

   TRUE - successfully quote a string

   FALSE - otherwise

--*/

{
    LPTSTR StringValue = *StringPointer;
    LPTSTR QuotedString;

    QuotedString = GlobalAlloc(GPTR, (lstrlen(StringValue) + 3) * sizeof(TCHAR));
    if (QuotedString)
    {
        wsprintf(QuotedString, TEXT("\"%s\""), StringValue);
        *StringPointer = QuotedString;
    }
    else
    {
        *StringPointer = NULL;
    }

    GlobalFree(StringValue);

    return (*StringPointer != NULL);

}


VOID
SaveProxyForOobe(
    IN LPCTSTR FileName
    )

/*++

Routine Description:

    Save the LAN http and https proxy settings, if any, for OOBE to use while
    it is running in 'SYSTEM' context.

Arguments:

    FileName - specifies the full Win32 filename for saving Setup settings.

--*/

{
    typedef BOOL (WINAPI* PINTERNETQUERYOPTION)(
        IN HINTERNET hInternet OPTIONAL,
        IN DWORD dwOption,
        OUT LPVOID lpBuffer OPTIONAL,
        IN OUT LPDWORD lpdwBufferLength
        );

    HMODULE WinInetLib;
    LPTSTR  ProxyList = NULL;
    LPTSTR  ProxyOverride = NULL;
    LPTSTR  AutoConfigUrl = NULL;
    LPTSTR  AutoConfigUrl2 = NULL;
    DWORD   ProxyFlags = 0;
    DWORD   AutoDiscoveryFlags = 0;
    TCHAR   NumberStr[25];
    BOOL    Captured = FALSE;

    WinInetLib = LoadLibrary(TEXT("WININET.DLL"));

    //
    // We prefer the INTERNET_OPTION_PER_CONNECTION_OPTION because we just
    // want to save the LAN proxy settings and we want to know the auto proxy
    // setting, but this option is not supported until IE 5.0
    //
    if (WinInetLib != NULL)
    {
        PINTERNETQUERYOPTION pInternetQueryOption;

        pInternetQueryOption = (PINTERNETQUERYOPTION) GetProcAddress(
            WinInetLib,
#ifdef UNICODE
            "InternetQueryOptionW"
#else
            "InternetQueryOptionA"
#endif
            );

        if (pInternetQueryOption)
        {
            INTERNET_PER_CONN_OPTION_LIST OptionList;
            INTERNET_PER_CONN_OPTION      Option[6];
            DWORD                         BufferLength = sizeof(OptionList);

            OptionList.dwSize = sizeof(OptionList);
            OptionList.pszConnection = NULL;
            OptionList.dwOptionCount = 6;

            ZeroMemory(&Option, sizeof(Option));

            Option[0].dwOption = INTERNET_PER_CONN_FLAGS;
            Option[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
            Option[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
            Option[3].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;
            Option[4].dwOption = INTERNET_PER_CONN_AUTODISCOVERY_FLAGS;
            Option[5].dwOption = INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL;

            OptionList.pOptions = Option;

            if (pInternetQueryOption(
                    NULL,
                    INTERNET_OPTION_PER_CONNECTION_OPTION,
                    &OptionList,
                    &BufferLength
                    ) == TRUE)
            {
                ProxyFlags = Option[0].Value.dwValue;
                ProxyList = Option[1].Value.pszValue;
                ProxyOverride = Option[2].Value.pszValue;
                AutoConfigUrl = Option[3].Value.pszValue;
                AutoDiscoveryFlags = Option[4].Value.dwValue;
                AutoConfigUrl2 = Option[5].Value.pszValue;
                Captured = TRUE;
            }
            else
            {

                INTERNET_PROXY_INFO* ProxyInfo = NULL;
                DWORD                BufferLength = 0;

                //
                // We obtain the ANSI string for INTERNET_OPTION_PROXY,
                // even if we call InternetQueryOptionW.
                //
                // Proxy list returned from INTERNET_OPTION_PER_CONNECTION are
                // delimited by ';', while that returned from INTERNET_OPTION_PROXY
                // are delimited by ' '.
                //
                if (pInternetQueryOption(
                    NULL,
                    INTERNET_OPTION_PROXY,
                    ProxyInfo,
                    &BufferLength
                    ) == FALSE
                    &&
                    GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                {

                    ProxyInfo = (INTERNET_PROXY_INFO*) GlobalAlloc(GPTR, BufferLength);

                    if (ProxyInfo)
                    {
                        if (pInternetQueryOption(
                                NULL,
                                INTERNET_OPTION_PROXY,
                                ProxyInfo,
                                &BufferLength
                                ) == TRUE)
                        {
                            //
                            // Map the values to INTERNET_OPTION_PER_CONN_OPTION
                            // We enable the auto proxy settings even though
                            // INTERNET_OPTION_PROXY doesn't have value relevant
                            // to auto proxy, because IE5 default to use auto proxy.
                            //
                            // PROXY_TYPE_DIRECT is always set because wininet
                            // return this flags whether inetcpl.cpl is set
                            // to use proxy or not.
                            //
                            ProxyFlags = PROXY_TYPE_DIRECT | PROXY_TYPE_AUTO_DETECT;
                            if (ProxyInfo->dwAccessType != INTERNET_OPEN_TYPE_DIRECT)
                            {
                                ProxyFlags |= PROXY_TYPE_PROXY;
                            }

                            ProxyList = AnsiToText((LPCSTR)ProxyInfo->lpszProxy);
                            FixWininetList(ProxyList);
                            ProxyOverride = AnsiToText((LPCSTR)ProxyInfo->lpszProxyBypass);
                            FixWininetList(ProxyOverride);
                            AutoDiscoveryFlags = 0;
                            Captured = TRUE;
                        }

                        GlobalFree(ProxyInfo);

                    }

                }

            }

        }

        FreeLibrary(WinInetLib);

    }

    if (Captured)
    {
        WritePrivateProfileString(
            WINNT_OOBEPROXY,
            WINNT_O_ENABLE_OOBEPROXY,
            TEXT("1"),
            FileName
            );

        if (ProxyList && QuoteString(&ProxyList))
        {
            WritePrivateProfileString(
                WINNT_OOBEPROXY,
                WINNT_O_PROXY_SERVER,
                ProxyList,
                FileName
                );

            GlobalFree(ProxyList);
        }


        //
        // Fix the ProxyOverride to not have any "\r\n"s
        //
        if (ProxyOverride) {
            ReplaceSubStr(ProxyOverride, TEXT("\r\n"), TEXT(";"));
        }

        if (ProxyOverride && QuoteString(&ProxyOverride))
        {
            WritePrivateProfileString(
                WINNT_OOBEPROXY,
                WINNT_O_PROXY_BYPASS,
                ProxyOverride,
                FileName
                );
            GlobalFree(ProxyOverride);
        }

        if (AutoConfigUrl && QuoteString(&AutoConfigUrl))
        {
            WritePrivateProfileString(
                WINNT_OOBEPROXY,
                WINNT_O_AUTOCONFIG_URL,
                AutoConfigUrl,
                FileName
                );
            GlobalFree(AutoConfigUrl);
        }

        if (AutoConfigUrl2 && QuoteString(&AutoConfigUrl2))
        {
            WritePrivateProfileString(
                WINNT_OOBEPROXY,
                WINNT_O_AUTOCONFIG_SECONDARY_URL,
                AutoConfigUrl2,
                FileName
                );
            GlobalFree(AutoConfigUrl2);
        }

        wsprintf(NumberStr, TEXT("%u"), ProxyFlags);
        WritePrivateProfileString(
            WINNT_OOBEPROXY,
            WINNT_O_FLAGS,
            NumberStr,
            FileName
            );

        wsprintf(NumberStr, TEXT("%u"), AutoDiscoveryFlags);
        WritePrivateProfileString(
            WINNT_OOBEPROXY,
            WINNT_O_AUTODISCOVERY_FLAGS,
            NumberStr,
            FileName
            );
    }
    else
    {
        WritePrivateProfileString(
            WINNT_OOBEPROXY,
            WINNT_O_ENABLE_OOBEPROXY,
            TEXT("0"),
            FileName
            );
    }

}





#ifdef _X86_
BOOL
IsDriveAssignNEC98(
    VOID
    )
{
    TCHAR  sz95KeyName[] = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion");
    TCHAR  sz95ValueName[] = TEXT("ATboot");
    TCHAR  szNTKeyName[] = TEXT("System\\setup");
    TCHAR  szNTValueName[] = TEXT("DriveLetter");
    HKEY   hKey;
    DWORD  type95 = REG_BINARY;
    DWORD  typeNT = REG_SZ;
    TCHAR  szData[5];
    DWORD  dwSize = 5;
    DWORD  rc;

    if(ISNT()){
        rc = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                  szNTKeyName,
                                  0,            //ulOptions (reserved)
                                  KEY_READ,
                                  &hKey);

        if (ERROR_SUCCESS != rc) {
            return TRUE;
        }
        //
        // Query key to get the subkey count and max string lengths
        //
        rc = RegQueryValueEx (hKey,
                              szNTValueName,
                              NULL,         // lpReserved
                              &typeNT,
                              (LPBYTE) szData,
                              &dwSize);

        if (ERROR_SUCCESS != rc) {
            RegCloseKey(hKey);
            return TRUE;
        }
        RegCloseKey(hKey);

        if (szData[0] != L'C'){
            // NEC DOS Type.
            return TRUE;
        }
    } else { // It will be Win9x
        rc = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                  sz95KeyName,
                                  0,        //ulOptions (reserved)
                                  KEY_READ,
                                  &hKey);

        if (ERROR_SUCCESS != rc) {
            return TRUE;
        }
        //
        // Query key to get the subkey count and max string lengths
        //
        rc = RegQueryValueEx (hKey,
                              sz95ValueName,
                              NULL,         // lpReserved
                              &type95,
                              (LPBYTE) szData,
                              &dwSize);

        if (ERROR_SUCCESS != rc) {
            RegCloseKey(hKey);
            return TRUE;
        }
        RegCloseKey(hKey);
        if (szData[0] == 0){
            // NEC DOS Type.
            return TRUE;
        }
    }
    return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\regmigrt.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    regmigrt.c

Abstract:

    Registry migration routines

Author:

    Ted Miller (tedm) 12-Apr-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

typedef enum {
    AddQuotesNone,
    AddQuotesNormal,
    AddQuotesOpenNoClose,
    AddQuotesNoOpenOrClose,
} AddQuotesOp;


BOOL
RetrieveMessageIntoBufferV(
    IN  UINT     MessageId,
    OUT PTSTR    Buffer,
    IN  UINT     BufferSizeChars,
    IN  va_list *arglist
    )
{
    DWORD d;

    d = FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_FROM_SYSTEM,
            hInst,
            MessageId,
            0,
            Buffer,
            BufferSizeChars,
            arglist
            );

    if(!d) {

        d = FormatMessage(
                FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                hInst,
                MSG_NOT_FOUND,
                0,
                Buffer,
                BufferSizeChars,
                (va_list *)&MessageId
                );

        if(!d) {

            return FALSE;
        }
    }
    return TRUE;
}


DWORD
WriteText(
    IN HANDLE FileHandle,
    IN UINT   MessageId,
    ...
    )
{
    TCHAR Message[2048];
    CHAR message[4096];
    va_list arglist;
    DWORD Written;
    BOOL b;

    

    va_start(arglist,MessageId);

    b = RetrieveMessageIntoBufferV(
            MessageId,
            Message,
            sizeof(Message)/sizeof(Message[0]),
            &arglist
            );

    va_end(arglist);

    if(!b)
        return ERROR_INVALID_PARAMETER;

#ifdef UNICODE
    Written = (DWORD)WideCharToMultiByte(
                        CP_ACP,
                        0,
                        Message,
                        lstrlen(Message),
                        message,
                        sizeof(message),
                        NULL,
                        NULL
                        );
#else
    lstrcpyn(message,Message,sizeof(message));
    Written = lstrlen(message);
#endif
    b = WriteFile(FileHandle,message,Written,&Written,NULL);

    return(b ? NO_ERROR : GetLastError());
}





DWORD
FlushGenInfLineBuf(
    IN OUT PINFFILEGEN Context,
    IN     HANDLE      File
    )
{
    CHAR TransBuf[INFLINEBUFLEN*2];
    DWORD rc;
    PVOID Buffer;
    DWORD Size;
    BOOL b;

    Buffer = TransBuf;

#ifdef UNICODE
    Size = WideCharToMultiByte(
                CP_ACP,
                0,
                Context->LineBuf,
                Context->LineBufUsed,
                TransBuf,
                sizeof(TransBuf),
                NULL,
                NULL
                );
#else
    lstrcpyn(TransBuf,Context->LineBuf,sizeof(TransBuf));
    Size = Context->LineBufUsed;
#endif

    if(WriteFile(File,Buffer,Size,&rc,NULL)) {
        rc = NO_ERROR;
        Context->LineBufUsed = 0;
    } else {
        rc = GetLastError();
    }

    return(rc);
}


DWORD
__inline
GenInfWriteChar(
    IN OUT PINFFILEGEN Context,
    IN     HANDLE      File,
    IN     TCHAR       Char
    )
{
    DWORD rc;
    PVOID Buffer;

    Context->LineBuf[Context->LineBufUsed++] = Char;

    rc = (Context->LineBufUsed == INFLINEBUFLEN)
       ? FlushGenInfLineBuf(Context,File)
       : NO_ERROR;

    return(rc);
}


DWORD
GenInfWriteString(
    IN OUT PINFFILEGEN Context,
    IN     HANDLE      File,
    IN     LPCTSTR     String,
    IN     AddQuotesOp AddQuotes
    )
{
    DWORD rc;
    TCHAR CONST *p;

    if((AddQuotes == AddQuotesNormal) || (AddQuotes == AddQuotesOpenNoClose)) {
        rc = GenInfWriteChar(Context,File,TEXT('\"'));
        if(rc != NO_ERROR) {
            return(rc);
        }
    }

    for(p=String; *p; p++) {
        rc = GenInfWriteChar(Context,File,*p);
        if(rc != NO_ERROR) {
            return(rc);
        }

        if((*p == TEXT('\"')) && (AddQuotes != AddQuotesNone)) {
            rc = GenInfWriteChar(Context,File,TEXT('\"'));
            if(rc != NO_ERROR) {
                return(rc);
            }
        }
    }

    if(AddQuotes == AddQuotesNormal) {
        rc = GenInfWriteChar(Context,File,TEXT('\"'));
        if(rc != NO_ERROR) {
            return(rc);
        }
    }

    return(NO_ERROR);
}



DWORD
CreateAndOpenTempFile(
    IN  LPCTSTR  Path,
    IN  LPCTSTR  HeaderLine, OPTIONAL
    OUT HANDLE   *Handle,
    OUT PTSTR    Filename
    )
{
    HANDLE h;
    DWORD rc;

    //
    // Note that this creates the file.
    //
    if(!GetTempFileName(Path,TEXT("$IF"),0,Filename)) {
        rc = GetLastError();
        goto c0;
    }

    h = CreateFile(
            Filename,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

    if(h == INVALID_HANDLE_VALUE) {
        rc = GetLastError();
        goto c1;
    }

    if(HeaderLine) {
        rc = WriteText(h,MSG_INF_SINGLELINE,HeaderLine);
        if(rc != NO_ERROR) {
            goto c2;
        }
    }

    *Handle = h;
    return(NO_ERROR);

c2:
    CloseHandle(h);
c1:
    DeleteFile(Filename);
c0:
    return(rc);
}


DWORD
InfCreateSection(
    IN     LPCTSTR      SectionName,
    IN OUT PINFFILEGEN  *Context
    )
{
    PTSTR Buffer;
    DWORD rc;

    Buffer = MALLOC( (lstrlen(SectionName) + 3)*sizeof(TCHAR) );
    if( !Buffer ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    lstrcpy( Buffer, TEXT("[") );
    lstrcat( Buffer, SectionName );
    lstrcat( Buffer, TEXT("]") );

    rc = WriteText((*Context)->FileHandle,MSG_INF_SINGLELINE,Buffer);
    FREE( Buffer );

    return(rc);
}

DWORD
InfStart(
    IN  LPCTSTR       InfName,
    IN  LPCTSTR       Directory,
    OUT PINFFILEGEN   *Context
    )
{
    TCHAR InfFileName[MAX_PATH];
    DWORD d;
    DWORD rc;
    PINFFILEGEN context;
    UCHAR UnicodeMark[2];
    PTSTR p;
    DWORD   BytesWritten = 0;

    //
    // Allocate some context.
    //
    context = MALLOC(sizeof(INFFILEGEN));

    if(!context) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto c0;
    }

    ZeroMemory(context,sizeof(INFFILEGEN));

    //
    // We'll create a unique inf name in the given directory
    // to use as the output inf. The directory itself will
    // become the oem file root.
    //
    if(!GetFullPathName(Directory,MAX_PATH,context->FileName,&p)) {
        rc = GetLastError();
        goto c1;
    }

    ConcatenatePaths(context->FileName,InfName,MAX_PATH);
    SetFileAttributes(context->FileName, FILE_ATTRIBUTE_NORMAL);
    DeleteFile(context->FileName);

    //
    // Create the output file.
    //
    context->FileHandle = CreateFile(
                            context->FileName,
                            GENERIC_WRITE,
                            FILE_SHARE_READ,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );

    if(context->FileHandle == INVALID_HANDLE_VALUE) {
        rc = GetLastError();
        goto c1;
    }

    //
    // Write out header for inf file.
    //    
    WriteFile(context->FileHandle, 
        INF_FILE_HEADER, 
        strlen(INF_FILE_HEADER), 
        &BytesWritten,
        NULL);

    rc = GetLastError();            
            
    if(rc != NO_ERROR) {
        goto c5;
    }

    *Context = context;
    return(NO_ERROR);

c5:
    CloseHandle(context->FileHandle);
    DeleteFile(context->FileName);
c1:
    FREE(context);
c0:
    return(rc);
}


DWORD
InfEnd(
    IN OUT PINFFILEGEN *Context
    )
{
    PINFFILEGEN context;
    DWORD rc;
    HANDLE h;
    DWORD Size;

    context = *Context;
    *Context = NULL;

    h = context->FileHandle;

    rc = NO_ERROR;

    CloseHandle(h);
    if(rc != NO_ERROR) {
        DeleteFile(context->FileName);
    }
    FREE(context);
    return(rc);
}



DWORD
pInfRegLineCommon(
    IN OUT PINFFILEGEN Context,
    IN     HANDLE      OutputFile,
    IN     HKEY        Key,
    IN     LPCTSTR      Subkey,
    IN     LPCTSTR      Value    OPTIONAL
    )
{
    LPCTSTR RootSpec;
    LPCTSTR SubkeySpec;
    DWORD rc;

    if(Subkey[0] == TEXT('\\')) {
        Subkey++;
    }

    //
    // Figure out the root key spec.
    //
    switch((ULONG_PTR)Key) {

    case (ULONG_PTR)HKEY_LOCAL_MACHINE:

        //
        // Check for HKEY_CLASSES_ROOT
        //
        if(_tcsnicmp(Subkey,TEXT("SOFTWARE\\Classes"),16)) {
            RootSpec = TEXT("HKLM");
            SubkeySpec = Subkey;
        } else {
            RootSpec = TEXT("HKCR");
            SubkeySpec = Subkey+16;
            if(*SubkeySpec == TEXT('\\')) {
                SubkeySpec++;
            }
        }
        break;

    case (ULONG_PTR)HKEY_CURRENT_USER:

        RootSpec = TEXT("HKCU");
        SubkeySpec = Subkey;
        break;

    case (ULONG_PTR)HKEY_CLASSES_ROOT:

        RootSpec = TEXT("HKCR");
        SubkeySpec = Subkey;
        break;

    default:
        //
        // Value we can't express via inf.
        // Use HKEY_ROOT but also write out a comment incidating
        // that there's a problem
        //
        RootSpec = TEXT("HKR");
        SubkeySpec = Subkey;

        Context->SawBogusOp = TRUE;
        rc = FlushGenInfLineBuf(Context,OutputFile);
        if(rc != NO_ERROR) {
            return(rc);
        }

        rc = WriteText(OutputFile,MSG_INF_BAD_REGSPEC_1);
        if(rc != NO_ERROR) {
            return(rc);
        }
        break;
    }

    rc = GenInfWriteString(Context,OutputFile,RootSpec,AddQuotesNone);
    if(rc == NO_ERROR) {
        rc = GenInfWriteChar(Context,OutputFile,TEXT(','));
        if(rc == NO_ERROR) {
            rc = GenInfWriteString(Context,OutputFile,SubkeySpec,AddQuotesNormal);
            if((rc == NO_ERROR) && Value) {
                rc = GenInfWriteChar(Context,OutputFile,TEXT(','));
                if(rc == NO_ERROR) {
                    rc = GenInfWriteString(Context,OutputFile,Value,AddQuotesNormal);
                }
            }
        }
    }

    return(rc);
}


DWORD
InfRecordAddReg(
    IN OUT PINFFILEGEN Context,
    IN     HKEY        Key,
    IN     LPCTSTR     Subkey,
    IN     LPCTSTR     Value,       OPTIONAL
    IN     DWORD       DataType,
    IN     PVOID       Data,
    IN     DWORD       DataLength,
    IN     BOOL        SetNoClobberFlag
    )
{
    DWORD rc;
    DWORD Flags;
    PTSTR p;
    DWORD d;
    int LineLen;
    TCHAR NumStr[24];

    //
    // Figure out flags based on data type.
    // The flags dword is built as two halves depending on whether
    // data is string or binary in nature.
    //
    // We do this before we write out the actual line
    // since that routine might also write a warning if a bogus root key
    // is specified.
    //
    switch(DataType) {

    case REG_SZ:
        Flags = FLG_ADDREG_TYPE_SZ;
        break;

    case REG_EXPAND_SZ:
        Flags = FLG_ADDREG_TYPE_EXPAND_SZ;
        break;

    case REG_MULTI_SZ:
        Flags = FLG_ADDREG_TYPE_MULTI_SZ;
        break;

    case REG_DWORD:
        Flags = FLG_ADDREG_TYPE_DWORD;
        break;

    //case REG_NONE:
    //    Flags = FLG_ADDREG_TYPE_NONE;
    //    break;

    case REG_NONE:
        Flags = FLG_ADDREG_KEYONLY;
        break;

    default:
        //
        // Arbitrary binary data. Better hope the data type doesn't overflow
        // 16 bits.
        //
        if(DataType > 0xffff) {
            Context->SawBogusOp = TRUE;
            rc = FlushGenInfLineBuf(Context,Context->FileHandle);
            if(rc != NO_ERROR) {
                return(rc);
            }
            rc = WriteText(Context->FileHandle,MSG_INF_BAD_REGSPEC_2);
            if(rc != NO_ERROR) {
                return(rc);
            }
            DataType = REG_BINARY;
        }
        Flags = FLG_ADDREG_BINVALUETYPE | (DataType << 16);
        break;
    }

    rc = pInfRegLineCommon(Context,Context->FileHandle,Key,Subkey,Value);
    if(rc != NO_ERROR) {
        return(rc);
    }
    if(Flags ==  FLG_ADDREG_KEYONLY) {
        rc = GenInfWriteChar(Context,Context->FileHandle,TEXT(','));
        if(rc != NO_ERROR) {
            return(rc);
        }
    }

    //
    // _stprintf(NumStr,TEXT(",%0#10lx"),Flags | 0x00000002); // Force NO_CLOBBER
    //
    // _stprintf(NumStr,TEXT(",%0#10lx"),Flags);
    wsprintf(NumStr,
             TEXT(",%#08lx"),
             SetNoClobberFlag? (Flags | 0x00000002) : Flags);

    rc = GenInfWriteString(Context,Context->FileHandle,NumStr,AddQuotesNone);
    if(rc != NO_ERROR) {
        return(rc);
    }

    //
    // Now we need to write out the data itself.
    // How we do this is dependent on the data type.
    //
    switch(DataType) {

    case REG_SZ:
    case REG_EXPAND_SZ:
        //
        // Single string. Ignore data length.
        //
        rc = GenInfWriteChar(Context,Context->FileHandle,TEXT(','));
        if(rc == NO_ERROR) {
            rc = GenInfWriteString(Context,Context->FileHandle,Data,AddQuotesNormal);
        }
        break;

    case REG_DWORD:
        //
        // Write out as a dword.
        //
        wsprintf(NumStr,TEXT(",%u"),*(DWORD UNALIGNED *)Data);
        rc = GenInfWriteString(Context,Context->FileHandle,NumStr,AddQuotesNone);
        break;

    case REG_MULTI_SZ:
        //
        // Write out each string.
        //
        for(p=Data; (rc==NO_ERROR) && *p; p+=lstrlen(p)+1) {
            rc = GenInfWriteChar(Context,Context->FileHandle,TEXT(','));
            if(rc == NO_ERROR) {
                rc = GenInfWriteString(Context,Context->FileHandle,p,AddQuotesNormal);
            }
        }

        break;

    case REG_NONE:
        //
        //  Don't create a value entry
        //
        break;

    default:
        //
        // Treat as binary. If we have any data at all start a new line.
        //
        if(DataLength) {
            rc = GenInfWriteString(Context,Context->FileHandle,TEXT(",\\\r\n     "),AddQuotesNone);
        }

        LineLen = 0;
        for(d=0; (rc==NO_ERROR) && (d<DataLength); d++) {

            if(LineLen == 25) {
                rc = GenInfWriteString(Context,Context->FileHandle,TEXT(",\\\r\n     "),AddQuotesNone);
                LineLen = 0;
            }

            if(rc == NO_ERROR) {
                if(LineLen) {
                    rc = GenInfWriteChar(Context,Context->FileHandle,TEXT(','));
                }
                if(rc == NO_ERROR) {
                    wsprintf(NumStr,TEXT("%02x"),((PBYTE)Data)[d]);
                    rc = GenInfWriteString(Context,Context->FileHandle,NumStr,AddQuotesNone);
                    LineLen++;
                }
            }
        }

        break;
    }

    if(rc == NO_ERROR) {
        rc = GenInfWriteString(Context,Context->FileHandle,TEXT("\r\n"),AddQuotesNone);
        if(rc == NO_ERROR) {
            rc = FlushGenInfLineBuf(Context,Context->FileHandle);
        }
    }

    return(rc);
}


#if 0
DWORD
InfRecordDelReg(
    IN OUT PINFFILEGEN Context,
    IN     HKEY        Key,
    IN     LPCTSTR      Subkey,
    IN     LPCTSTR      Value    OPTIONAL
    )
{
    DWORD rc;

    rc = pInfRegLineCommon(Context,Context->DelRegFile,Key,Subkey,Value);
    if(rc == NO_ERROR) {
        rc = GenInfWriteString(Context,Context->DelRegFile,TEXT("\r\n"),AddQuotesNone);
        if(rc == NO_ERROR) {
            rc = FlushGenInfLineBuf(Context,Context->DelRegFile);
        }
    }

    return(rc);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\security.c ===
#include "precomp.h"
#pragma hdrstop


BOOL
IsUserAdmin(
    VOID
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process is a
    member of the Administrators local group.

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrators local group.

    FALSE - Caller does not have Administrators local group.

--*/

{
    HANDLE Token;
    DWORD BytesRequired;
    PTOKEN_GROUPS Groups;
    BOOL b;
    DWORD i;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;

    //
    // On non-NT platforms the user is administrator.
    //
    if(!ISNT()) {
        return(TRUE);
    }

    //
    // Open the process token.
    //
    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&Token)) {
        return(FALSE);
    }

    b = FALSE;
    Groups = NULL;

    //
    // Get group information.
    //
    if(!GetTokenInformation(Token,TokenGroups,NULL,0,&BytesRequired)
    && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    && (Groups = (PTOKEN_GROUPS)LocalAlloc(LPTR,BytesRequired))
    && GetTokenInformation(Token,TokenGroups,Groups,BytesRequired,&BytesRequired)) {

        b = AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                &AdministratorsGroup
                );

        if(b) {

            //
            // See if the user has the administrator group.
            //
            b = FALSE;
            for(i=0; i<Groups->GroupCount; i++) {
                if(EqualSid(Groups->Groups[i].Sid,AdministratorsGroup)) {
                    b = TRUE;
                    break;
                }
            }

            FreeSid(AdministratorsGroup);
        }
    }

    //
    // Clean up and return.
    //

    if(Groups) {
        LocalFree((HLOCAL)Groups);
    }

    CloseHandle(Token);

    return(b);
}



BOOL
DoesUserHavePrivilege(
    PTSTR PrivilegeName
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process has
    the specified privilege.  The privilege does not have
    to be currently enabled.  This routine is used to indicate
    whether the caller has the potential to enable the privilege.

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

Arguments:

    Privilege - the name form of privilege ID (such as
        SE_SECURITY_NAME).

Return Value:

    TRUE - Caller has the specified privilege.

    FALSE - Caller does not have the specified privilege.

--*/

{
    HANDLE Token;
    ULONG BytesRequired;
    PTOKEN_PRIVILEGES Privileges;
    BOOL b;
    DWORD i;
    LUID Luid;

    //
    // On non-NT platforms the user has all privileges
    //
    if(!ISNT()) {
        return(TRUE);
    }

    //
    // Open the process token.
    //
    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&Token)) {
        return(FALSE);
    }

    b = FALSE;
    Privileges = NULL;

    //
    // Get privilege information.
    //
    if(!GetTokenInformation(Token,TokenPrivileges,NULL,0,&BytesRequired)
    && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    && (Privileges = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR,BytesRequired))
    && GetTokenInformation(Token,TokenPrivileges,Privileges,BytesRequired,&BytesRequired)
    && LookupPrivilegeValue(NULL,PrivilegeName,&Luid)) {

        //
        // See if we have the requested privilege
        //
        for(i=0; i<Privileges->PrivilegeCount; i++) {

            if(!memcmp(&Luid,&Privileges->Privileges[i].Luid,sizeof(LUID))) {

                b = TRUE;
                break;
            }
        }
    }

    //
    // Clean up and return.
    //

    if(Privileges) {
        LocalFree((HLOCAL)Privileges);
    }

    CloseHandle(Token);

    return(b);
}


BOOL
EnablePrivilege(
    IN PTSTR PrivilegeName,
    IN BOOL  Enable
    )
{
    HANDLE Token;
    BOOL b;
    TOKEN_PRIVILEGES NewPrivileges;
    LUID Luid;

    //
    // On non-NT platforms the user already has all privileges
    //
    if(!ISNT()) {
        return(TRUE);
    }

    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token)) {
        return(FALSE);
    }

    if(!LookupPrivilegeValue(NULL,PrivilegeName,&Luid)) {
        CloseHandle(Token);
        return(FALSE);
    }

    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Luid = Luid;
    NewPrivileges.Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;

    b = AdjustTokenPrivileges(
            Token,
            FALSE,
            &NewPrivileges,
            0,
            NULL,
            NULL
            );

    CloseHandle(Token);

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\rsrcutil.c ===
#include "precomp.h"
#pragma hdrstop


//
// the following is not in the SDK
//
#include <pshpack2.h>
#include <poppack.h>
#include <winuserp.h>


//
// When Winnt32.exe is launched over a network, these two parameters have valid
// values and need to be taken into consideration before displaying any dialog box
//

extern HWND Winnt32Dlg;
extern HANDLE WinNT32StubEvent;


PCTSTR
GetStringResource (
    IN UINT Id
    )
{
    LONG rc;
    PCTSTR MsgBuf;

    if (HIWORD (Id)) {
        // From string
        rc = FormatMessage (
                FORMAT_MESSAGE_ALLOCATE_BUFFER|
                    FORMAT_MESSAGE_ARGUMENT_ARRAY|
                    FORMAT_MESSAGE_FROM_STRING,
                UIntToPtr( Id ),
                0,
                0,
                (PVOID) &MsgBuf,
                0,
                NULL
                );
    }
    else {
        // From resource
        rc = FormatMessage (
                FORMAT_MESSAGE_ALLOCATE_BUFFER|
                    FORMAT_MESSAGE_ARGUMENT_ARRAY|
                    FORMAT_MESSAGE_FROM_HMODULE,
                (PVOID) hInst,
                (DWORD) Id,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPVOID) &MsgBuf,
                0,
                NULL
                );
    }

    if (rc == 0) {
        return NULL;
    }

    return MsgBuf;
}


VOID
FreeStringResource (
    IN PCTSTR String
    )
{
    if (String) {
        LocalFree ((HLOCAL) String);
    }
}


VOID
SaveTextForSMS(
    IN PCTSTR Buffer
    )
{
    CHAR    AnsiBuffer[5000];


    if(LastMessage) {
        FREE( LastMessage );
    }

#ifdef UNICODE
    WideCharToMultiByte(
        CP_ACP,
        0,
        Buffer,
        -1,
        AnsiBuffer,
        sizeof(AnsiBuffer),
        NULL,
        NULL
        );
    if(LastMessage = MALLOC(strlen(AnsiBuffer)+1)) {
        strcpy( LastMessage, AnsiBuffer);
    }
#else
    LastMessage = DupString( Buffer );
#endif
}


VOID
SaveMessageForSMS(
    IN DWORD MessageId,
    ...
    )
{
    va_list arglist;
    TCHAR   Buffer[5000];


    va_start(arglist,MessageId);

    FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE,
        hInst,
        MessageId,
        0,
        Buffer,
        sizeof(Buffer) / sizeof(TCHAR),
        &arglist
        );

    SaveTextForSMS(Buffer);

    va_end(arglist);
}


int
MessageBoxFromMessageV(
    IN HWND     Window,
    IN DWORD    MessageId,
    IN BOOL     SystemMessage,
    IN DWORD    CaptionStringId,
    IN UINT     Style,
    IN va_list *Args
    )
{
    TCHAR   Caption[512];
    TCHAR   Buffer[5000];
    HWND    Parent;


    if(!LoadString(hInst,CaptionStringId,Caption,sizeof(Caption)/sizeof(TCHAR))) {
        Caption[0] = 0;
    }

    FormatMessage(
        SystemMessage ? FORMAT_MESSAGE_FROM_SYSTEM : FORMAT_MESSAGE_FROM_HMODULE,
        hInst,
        MessageId,
        0,
        Buffer,
        sizeof(Buffer) / sizeof(TCHAR),
        Args
        );

    SaveTextForSMS(Buffer);

    //
    // In batch mode, we don't want to wait on the user.
    //
    if(BatchMode) {
        if( Style & MB_YESNO ) {
            return( IDYES );
        } else {
            return( IDOK );
        }
    }

    //
    // Force ourselves into the foreground manually to guarantee that we get
    // a chance to set our palette. Otherwise the message box gets the
    // palette messages and color in our background bitmap can get hosed.
    // We assume the parent is a wizard page.
    //
    if(Window && IsWindow(Window)) {
        Parent = GetParent(Window);
        if(!Parent) {
            Parent = Window;
        }
    } else {
        Parent = NULL;
    }

    SetForegroundWindow(Parent);

    //
    // If we're just checking upgrades, and we're on NT,
    // then throw this message into the compatibility list.
    //
    if( CheckUpgradeOnly && ISNT() ) {
    PCOMPATIBILITY_DATA CompData;

        CompData = (PCOMPATIBILITY_DATA) MALLOC( sizeof(COMPATIBILITY_DATA) );
        if (CompData == NULL) {
            return 0;
        }

        ZeroMemory( CompData, sizeof(COMPATIBILITY_DATA) );

        CompData->Description = DupString( Buffer );
        CompData->Flags = COMPFLAG_STOPINSTALL;
        if( !CompatibilityData.Flink ) {
            InitializeListHead( &CompatibilityData );
        }

        InsertTailList( &CompatibilityData, &CompData->ListEntry );
        CompatibilityCount++;

        if( Style & MB_YESNO ) {
            return( IDYES );
        } else {
            return( IDOK );
        }
    }

    //
    // always make sure the window is visible
    //
    if (Window && !IsWindowVisible (Window)) {
        //
        // if this window is the wizard handle or one of its pages
        // then use a special message to restore it
        //
        if (WizardHandle && 
            (WizardHandle == Window || IsChild (WizardHandle, Window))
            ) {
            SendMessage(WizardHandle, WMX_BBTEXT, (WPARAM)FALSE, 0);
        } else {
            //
            // the window is one of the billboard windows;
            // just leave it alone or weird things may happen
            //
        }
    }
    return(MessageBox(Window,Buffer,Caption,Style));
}


int
MessageBoxFromMessage(
    IN HWND  Window,
    IN DWORD MessageId,
    IN BOOL  SystemMessage,
    IN DWORD CaptionStringId,
    IN UINT  Style,
    ...
    )
{
    va_list arglist;
    int i;

    //
    // before displaying any dialog, make sure Winnt32.exe wait dialog is gone
    //
    if (Winnt32Dlg) {
        DestroyWindow (Winnt32Dlg);
        Winnt32Dlg = NULL;
    }
    if (WinNT32StubEvent) {
        SetEvent (WinNT32StubEvent);
        WinNT32StubEvent = NULL;
    }

    va_start(arglist,Style);

    i = MessageBoxFromMessageV(Window,MessageId,SystemMessage,CaptionStringId,Style,&arglist);

    va_end(arglist);

    return(i);
}


int
MessageBoxFromMessageWithSystem(
    IN HWND     Window,
    IN DWORD    MessageId,
    IN DWORD    CaptionStringId,
    IN UINT     Style,
    IN HMODULE  hMod
    )
{
    TCHAR Caption[512];
    TCHAR Buffer[5000];
    HWND Parent;
    DWORD i;


    if(!LoadString(hInst,CaptionStringId,Caption,sizeof(Caption)/sizeof(TCHAR))) {
        Caption[0] = 0;
    }

    i = FormatMessage(
        FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_FROM_HMODULE,
        hMod,
        MessageId,
        0,
        Buffer,
        sizeof(Buffer) / sizeof(TCHAR),
        NULL
        );

    if (i == 0) {
        return -1;
    }

    SaveTextForSMS(Buffer);

    //
    // In batch mode, we don't want to wait on the user.
    //
    if(BatchMode) {
        if( Style & MB_YESNO ) {
            return( IDYES );
        } else {
            return( IDOK );
        }
    }

    //
    // Force ourselves into the foreground manually to guarantee that we get
    // a chance to set our palette. Otherwise the message box gets the
    // palette messages and color in our background bitmap can get hosed.
    // We assume the parent is a wizard page.
    //
    if(Window && IsWindow(Window)) {
        Parent = GetParent(Window);
        if(!Parent) {
            Parent = Window;
        }
    } else {
        Parent = NULL;
    }

    SetForegroundWindow(Parent);

    return(MessageBox(Window,Buffer,Caption,Style));
}


int
MessageBoxFromMessageAndSystemError(
    IN HWND  Window,
    IN DWORD MessageId,
    IN DWORD SystemMessageId,
    IN DWORD CaptionStringId,
    IN UINT  Style,
    ...
    )
{
    va_list arglist;
    TCHAR Caption[500];
    TCHAR Buffer1[2000];
    TCHAR Buffer2[1000];
    int i;

    //
    // Fetch the non-system part. The arguments are for that part of the
    // message -- the system part has no inserts.
    //
    va_start(arglist,Style);

    FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE,
        hInst,
        MessageId,
        0,
        Buffer1,
        sizeof(Buffer1) / sizeof(TCHAR),
        &arglist
        );

    va_end(arglist);

    //
    // Now fetch the system part.
    //
    i = (int)FormatMessage(
                FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                SystemMessageId,
                0,
                Buffer2,
                sizeof(Buffer2) / sizeof(TCHAR),
                NULL
                );

    if(!i) {
        FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
            hInst,
            MSG_UNKNOWN_SYSTEM_ERROR,
            0,
            Buffer2,
            sizeof(Buffer2) / sizeof(TCHAR),
            (va_list *)&SystemMessageId
            );
    }

    //
    // Now display the message, which is made up of two parts that get
    // inserted into MSG_ERROR_WITH_SYSTEM_ERROR.
    //
    i = MessageBoxFromMessage(
            Window,
            MSG_ERROR_WITH_SYSTEM_ERROR,
            FALSE,
            CaptionStringId,
            Style,
            Buffer1,
            Buffer2
            );

    return(i);
}


HPALETTE
CreateDIBPalette(
    IN  LPBITMAPINFO  BitmapInfo,
    OUT int          *ColorCount
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    LPBITMAPINFOHEADER BitmapInfoHeader;
    LPLOGPALETTE LogicalPalette;
    HPALETTE Palette;
    int i;
    DWORD d;

    BitmapInfoHeader = (LPBITMAPINFOHEADER)BitmapInfo;

    //
    // No palette needed for >= 16 bpp
    //
    *ColorCount = (BitmapInfoHeader->biBitCount <= 8)
                ? (1 << BitmapInfoHeader->biBitCount)
                : 0;

    if(*ColorCount) {
        LogicalPalette = MALLOC(sizeof(LOGPALETTE) + (sizeof(PALETTEENTRY) * (*ColorCount)));
        if(!LogicalPalette) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(NULL);
        }

        LogicalPalette->palVersion = 0x300;
        LogicalPalette->palNumEntries = (WORD)*ColorCount;

        for(i=0; i<*ColorCount; i++) {
            LogicalPalette->palPalEntry[i].peRed   = BitmapInfo->bmiColors[i].rgbRed;
            LogicalPalette->palPalEntry[i].peGreen = BitmapInfo->bmiColors[i].rgbGreen;
            LogicalPalette->palPalEntry[i].peBlue  = BitmapInfo->bmiColors[i].rgbBlue;
            LogicalPalette->palPalEntry[i].peFlags = 0;
        }

        Palette = CreatePalette(LogicalPalette);
        d = GetLastError();
        FREE(LogicalPalette);
        SetLastError(d);
    } else {
        Palette = NULL;
    }

    return(Palette);
}


HBITMAP
LoadResourceBitmap(
    IN  HINSTANCE hInst,
    IN  LPCTSTR   Id,
    OUT HPALETTE *Palette
    )

/*++

Routine Description:

    Bitmaps in resources are stored as DIBs. When fetched via LoadBitmap()
    they are converted to DDBs and a color conversion takes place based on
    whatever logical palette happens to be currently selected into whatever
    DC gets used internally for the conversion.

    This routine fetches the color data from the DIB in the resources and
    ensures that the DIB is converted into a DDB using accurate color data.
    It is essentially a color-accurate replacement for LoadBitmap().

Arguments:

    hInst - supplies instance handle for module containing the bitmap resource.

    Id - supplies the id of the bitmap resource.

    Palette - if successful, receives a handle to a palette for the bitmap.

Return Value:

    If successful, handle to the loaded bitmap (DIB).
    If not, NULL is returned. Check GetLastError().

--*/

{
    DWORD d;
    BOOL b;
    HRSRC BlockHandle;
    HGLOBAL MemoryHandle;
    BITMAPINFOHEADER *BitmapInfoHeader;
    HDC hdc;
    int ColorCount;
    HBITMAP Bitmap;
    HPALETTE PreviousPalette;

    Bitmap = NULL;

    BlockHandle = FindResource(hInst,Id,RT_BITMAP);
    if(!BlockHandle) {
        d = GetLastError();
        goto c0;
    }

    MemoryHandle = LoadResource(hInst,BlockHandle);
    if(!MemoryHandle) {
        d = GetLastError();
        goto c0;
    }

    BitmapInfoHeader = LockResource(MemoryHandle);
    if(!BitmapInfoHeader) {
        d = GetLastError();
        goto c1;
    }

    hdc = GetDC(NULL);
    if(!hdc) {
        d = GetLastError();
        goto c2;
    }

#if 0 // steveow - fix palette problem
    if(*Palette = CreateDIBPalette((BITMAPINFO *)BitmapInfoHeader,&ColorCount)) {
        PreviousPalette = SelectPalette(hdc,*Palette,FALSE);
        RealizePalette(hdc);
    } else {
        PreviousPalette = NULL;
    }
#else
    ColorCount = 16;
    PreviousPalette = NULL;
#endif
    //
    // This routine creates a DDB from the DIB (the name is confusing).
    //
    Bitmap = CreateDIBitmap(
                hdc,
                BitmapInfoHeader,
                CBM_INIT,
                (LPBYTE)BitmapInfoHeader + BitmapInfoHeader->biSize + (ColorCount * sizeof(RGBQUAD)),
                (BITMAPINFO *)BitmapInfoHeader,
                DIB_RGB_COLORS
                );

    if(!Bitmap) {
        d = GetLastError();
        goto c3;
    }

c3:
    if(PreviousPalette) {
        SelectObject(hdc,PreviousPalette);
    }
    if(!Bitmap) {
        DeleteObject(*Palette);
        *Palette = NULL;
    }
    ReleaseDC(NULL,hdc);
c2:
    UnlockResource(MemoryHandle);
c1:
    FreeResource(MemoryHandle);
c0:
    if(!Bitmap) {
        SetLastError(d);
    }
    return(Bitmap);
}


BOOL
GetBitmapDataAndPalette(
    IN  HINSTANCE                hInst,
    IN  LPCTSTR                  Id,
    OUT HPALETTE                *Palette,
    OUT PUINT                    ColorCount,
    OUT CONST BITMAPINFOHEADER **BitmapData
    )

/*++

Routine Description:

    Retreives device-independent bitmap data and a color table from a
    bitmap in a resource.

Arguments:

    hInst - supplies instance handle for module containing the bitmap resource.

    Id - supplies the id of the bitmap resource.

    Palette - if successful, receives a handle to a palette for the bitmap.

    ColorCount - if successful, receives the number of entries in the
        palette for the bitmap.

    BitmapData - if successful, receives a pointer to the bitmap info
        header structure in the resources. This is in read-only memory
        so the caller should not try to modify it.

Return Value:

    If successful, handle to the loaded bitmap (DIB).
    If not, NULL is returned. Check GetLastError().

--*/

{
    HRSRC BlockHandle;
    HGLOBAL MemoryHandle;

    //
    // None of FindResource(), LoadResource(), or LockResource()
    // need to have cleanup routines called in Win32.
    //
    BlockHandle = FindResource(hInst,Id,RT_BITMAP);
    if(!BlockHandle) {
        return(FALSE);
    }

    MemoryHandle = LoadResource(hInst,BlockHandle);
    if(!MemoryHandle) {
        return(FALSE);
    }

    *BitmapData = LockResource(MemoryHandle);
    if(*BitmapData == NULL) {
        return(FALSE);
    }

    *Palette = CreateDIBPalette((LPBITMAPINFO)*BitmapData,ColorCount);
    return(TRUE);
}


PVOID
FindControlInDialog(
    IN PVOID Template,
    IN UINT  ControlId
    )
{
    PVOID p;
    DLGTEMPLATE *pTemplate;
    DLGTEMPLATE2 *pTemplate2;
    DLGITEMTEMPLATE *pItem;
    DLGITEMTEMPLATE2 *pItem2;
    WORD ItemCount;
    DWORD Style;
    WORD i;
    BOOL bDialogEx;

    if (!Template) // validate
        return NULL;
    p = Template;

    //
    // Skip fixed part of template
    //
    if(((DLGTEMPLATE2 *)p)->wSignature == 0xffff) {

        pTemplate2 = p;

        ItemCount = pTemplate2->cDlgItems;
        Style = pTemplate2->style;

        p = pTemplate2 + 1;
        bDialogEx = TRUE;

    } else {

        pTemplate = p;

        ItemCount = pTemplate->cdit;
        Style = pTemplate->style;

        p = pTemplate + 1;
        bDialogEx = FALSE;
    }

    //
    // Skip menu. First word=0 means no menu
    // First word=0xffff means one more word follows
    // Else it's a nul-terminated string
    //
    switch(*(WORD *)p) {

    case 0xffff:
        p = (WORD *)p + 2;
        break;

    case 0:
        p = (WORD *)p + 1;
        break;

    default:
        p = (PWCHAR)p + lstrlenW(p) + 1;
        break;
    }

    //
    // Skip class, similar to menu
    //
    switch(*(WORD *)p) {

    case 0xffff:
        p = (WORD *)p + 2;
        break;

    case 0:
        p = (WORD *)p + 1;
        break;

    default:
        p = (PWCHAR)p + lstrlenW(p) + 1;
        break;
    }

    //
    // Skip title
    //
    p = (PWCHAR)p + lstrlenW(p) + 1;

    if(Style & DS_SETFONT) {
        //
        // Skip point size and typeface name
        //
        p = (WORD *)p + 1;
        if (bDialogEx)
        {
            // Skip weight, italic, and charset.
            p = (WORD *)p + 1;
            p = (BYTE *)p + 1;
            p = (BYTE *)p + 1;
        }
        p = (PWCHAR)p + lstrlenW(p) + 1;
    }

    //
    // Now we have a pointer to the first item in the dialog
    //
    for(i=0; i<ItemCount; i++) {

        //
        // Align to next DWORD boundary
        //
        p = (PVOID)(((ULONG_PTR)p + sizeof(DWORD) - 1) & (~((ULONG_PTR)sizeof(DWORD) - 1)));
        if (bDialogEx)
        {
            pItem2 = p;

            if(pItem2->dwID == (WORD)ControlId) {
                break;
            }

            //
            // Skip to next item in dialog.
            // First is class, which is either 0xffff plus one more word,
            // or a unicode string. After that is text/title.
            //
            p = pItem2 + 1;
        }
        else
        {
            pItem = p;

            if(pItem->id == (WORD)ControlId) {
                break;
            }

            //
            // Skip to next item in dialog.
            // First is class, which is either 0xffff plus one more word,
            // or a unicode string. After that is text/title.
            //
            p = pItem + 1;
        }
        if(*(WORD *)p == 0xffff) {
            p = (WORD *)p + 2;
        } else {
            p = (PWCHAR)p + lstrlenW(p) + 1;
        }

        if(*(WORD *)p == 0xffff) {
            p = (WORD *)p + 2;
        } else {
            p = (PWCHAR)p + lstrlenW(p) + 1;
        }

        //
        // Skip creation data.
        //
        p = (PUCHAR)p + *(WORD *)p;
        p = (WORD *)p + 1;
    }

    if(i == ItemCount) {
        p = NULL;
    }

    return(p);
}


UINT
GetYPositionOfDialogItem(
    IN LPCTSTR Dialog,
    IN UINT    ControlId
    )
{
    HRSRC hRsrc;
    PVOID p;
    HGLOBAL hGlobal;
    PVOID pItem;
    UINT i;

    i = 0;

    if(hRsrc = FindResource(hInst,Dialog,RT_DIALOG)) {
        if(hGlobal = LoadResource(hInst,hRsrc)) {
            if(p = LockResource(hGlobal)) {


                if(pItem = FindControlInDialog(p,ControlId)) {
                    if(((DLGTEMPLATE2 *)p)->wSignature == 0xffff) {
                        i = ((DLGITEMTEMPLATE2*)pItem)->y;
                    }
                    else
                    {
                        i = ((DLGITEMTEMPLATE*)pItem)->y;
                    }
                }

                UnlockResource(hGlobal);
            }
            FreeResource(hGlobal);
        }
    }

    return(i);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\sticky.c ===
#include "precomp.h"
#pragma hdrstop

typedef LONG NTSTATUS;
#include <ntdskreg.h>
#include <ntddft.h>


UCHAR
QueryDriveLetter(
    IN  ULONG       Signature,
    IN  LONGLONG    Offset
    )

{
    PDRIVE_LAYOUT_INFORMATION   layout;
    UCHAR                       c;
    TCHAR                       name[80], result[80], num[10];
    DWORD                       i, j;
    HANDLE                      h;
    BOOL                        b;
    DWORD                       bytes;
    PARTITION_INFORMATION       partInfo;
    DWORD                       em;

    layout = MALLOC(4096);
    if (!layout) {
        return 0;
    }

    em = SetErrorMode(0);
    SetErrorMode( em | SEM_FAILCRITICALERRORS );

    for (c = 'C'; c <= 'Z'; c++) {

        name[0] = (TCHAR)c;
        name[1] = (TCHAR)':';
        name[2] = (TCHAR)'\0';

        if (QueryDosDevice(name, result, sizeof(result)/sizeof(TCHAR)) < 17) {
            continue;
        }

        j = 0;
        for (i = 16; result[i]; i++) {
            if (result[i] == (TCHAR)'\\') {
                break;
            }
            num[j++] = result[i];
        }
        num[j] = (TCHAR)'\0';

        wsprintf(name, TEXT("\\\\.\\PhysicalDrive%s"), num);

        h = CreateFile(name, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                       INVALID_HANDLE_VALUE);
        if (h == INVALID_HANDLE_VALUE) {
            continue;
        }

        b = DeviceIoControl(h, IOCTL_DISK_GET_DRIVE_LAYOUT, NULL, 0, layout,
                            4096, &bytes, NULL);
        CloseHandle(h);
        if (!b) {
            continue;
        }

        if (layout->Signature != Signature) {
            continue;
        }

        wsprintf(name, TEXT("\\\\.\\%c:"), c);

        h = CreateFile(name, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                       INVALID_HANDLE_VALUE);
        if (h == INVALID_HANDLE_VALUE) {
            continue;
        }

        b = DeviceIoControl(h, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0,
                            &partInfo, sizeof(partInfo), &bytes, NULL);
        CloseHandle(h);
        if (!b) {
            continue;
        }

        if (partInfo.StartingOffset.QuadPart == Offset) {
            break;
        }
    }

    FREE(layout);

    SetErrorMode( em );

    return (c <= 'Z') ? c : 0;
}


VOID
ForceStickyDriveLetters(
    )

{
    LONG                error;
    HKEY                key;
    TCHAR               name[10];
    UCHAR               driveLetter;
    UINT                driveType;
    TCHAR               targetPath[MAX_PATH];
    DWORD               type;
    DWORD               size;
    PBYTE               registryValue;
    PDISK_CONFIG_HEADER header;
    PDISK_REGISTRY      diskRegistry;
    PDISK_DESCRIPTION   diskDescription;
    ULONG               i, j;
    PDISK_PARTITION     diskPartition;
    DWORD d;

    error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\DISK"), 0,
                         KEY_QUERY_VALUE | KEY_SET_VALUE, &key);
    if (error != ERROR_SUCCESS) {
#ifdef _X86_ 
	if (IsNEC98() && Upgrade){
	    error = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
				   TEXT("SYSTEM\\DISK"),
				   0,
				   NULL,
				   REG_OPTION_NON_VOLATILE,
				   KEY_QUERY_VALUE | KEY_SET_VALUE,
				   NULL,
				   &key,
				   &d
		);
	    if (error != ERROR_SUCCESS) {
		return;
	    }
	}else{
	    return;
	}
#else
        return;
#endif
    }

    name[1] = (TCHAR)':';
    name[2] = (TCHAR)'\\';
    name[3] = (TCHAR)'\0';
    for (driveLetter = 'C'; driveLetter <= 'Z'; driveLetter++) {
        name[0] = (TCHAR)driveLetter;
        name[2] = (TCHAR)'\\';
        driveType = GetDriveType(name);
        if (driveType != DRIVE_REMOVABLE && driveType != DRIVE_CDROM) {
            continue;
        }

        name[2] = (TCHAR)'\0';
        if (!QueryDosDevice(name, targetPath, MAX_PATH)) {
            continue;
        }

        RegSetValueEx(key, targetPath, 0, REG_SZ, (PBYTE)name, 3*sizeof(TCHAR));
    }

    error = RegQueryValueEx(key, TEXT("Information"), NULL, &type, NULL,
                            &size);
    if (error != ERROR_SUCCESS) {
        RegCloseKey(key);
        return;
    }

    registryValue = MALLOC(size);
    if (!registryValue) {
        RegCloseKey(key);
        return;
    }

    error = RegQueryValueEx(key, TEXT("Information"), NULL, &type,
                            registryValue, &size);
    if (error != ERROR_SUCCESS) {
        FREE(registryValue);
        RegCloseKey(key);
        return;
    }

    header = (PDISK_CONFIG_HEADER) registryValue;
    diskRegistry = (PDISK_REGISTRY) ((PCHAR) header +
                                     header->DiskInformationOffset);

    diskDescription = &diskRegistry->Disks[0];
    for (i = 0; i < diskRegistry->NumberOfDisks; i++) {

        for (j = 0; j < diskDescription->NumberOfPartitions; j++) {

            diskPartition = &diskDescription->Partitions[j];

            if (diskPartition->AssignDriveLetter &&
                !diskPartition->DriveLetter) {

                driveLetter = QueryDriveLetter(diskDescription->Signature,
                                               diskPartition->StartingOffset.QuadPart);
                if (driveLetter) {
                    diskPartition->DriveLetter = driveLetter;
                }
            }
        }

        diskDescription = (PDISK_DESCRIPTION) &diskDescription->
                          Partitions[diskDescription->NumberOfPartitions];
    }

    RegSetValueEx(key, TEXT("Information"), 0, type, registryValue, size);

    FREE(registryValue);
    RegCloseKey(key);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\unsupdrv.c ===
#include "precomp.h"

#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

#pragma hdrstop

#ifdef UNICODE

#define DRIVER_VALUE_ENTRY  TEXT("Driver");


BOOL
IsServiceToBeDisabled(
    IN  PVOID   NtCompatInfHandle,
    IN  LPTSTR  ServiceName
    )
{
    PLIST_ENTRY Next;
    PCOMPATIBILITY_DATA CompData;
    BOOL serviceDisabled = FALSE;

    //
    // iterate through all compdata structures
    //
    Next = CompatibilityData.Flink;
    if (Next) {
        while ((ULONG_PTR)Next != (ULONG_PTR)&CompatibilityData) {
            CompData = CONTAINING_RECORD(Next, COMPATIBILITY_DATA, ListEntry);
            Next = CompData->ListEntry.Flink;
            //
            // now look for services that match our service name
            //
            if (CompData->Type == TEXT('s') && lstrcmpi (CompData->ServiceName, ServiceName) == 0) {
                //
                // make sure the service is marked to be disabled
                //
                if ((CompData->RegValDataSize == sizeof (DWORD)) &&
                    (*(PDWORD)CompData->RegValData == SERVICE_DISABLED)
                    ) {
                    //
                    // we found it!
                    //
                    serviceDisabled = TRUE;
                    break;
                }
            }
        }
    }

    return serviceDisabled;
}


BOOL
IsDriverCopyToBeSkipped(
    IN  PVOID   NtCompatInfHandle,
    IN  LPTSTR  ServiceName,
    IN  LPTSTR  FilePath
    )
{
    LONG    LineCount;
    LONG    i;
    LPTSTR  SectionName = TEXT("DriversToSkipCopy");
    LPTSTR  FileName;
    BOOL    DisableCopy;

    if ((!NtCompatInfHandle) || (!FilePath)) {
        MYASSERT(FALSE);
        return TRUE;
    }

    FileName = _tcsrchr( FilePath, TEXT('\\') );
    if (!FileName) {
        FileName = FilePath;
    }
    else {
        FileName++;
    }
    
    //
    //  Check if the driver is listed under [DriversToSkipCopy] in ntcompat.inf.
    //

    if( (LineCount = InfGetSectionLineCount( NtCompatInfHandle,
                                             SectionName )) == -1 ) {
        //
        //  section doesn't exist.
        //
        return( FALSE );
    }

    DisableCopy = FALSE;
    for( i = 0; i < LineCount; i++ ) {
        LPTSTR  p;

        p = (LPTSTR)InfGetFieldByIndex( NtCompatInfHandle,
                                        SectionName,
                                        i,
                                        0 );

        if( p && !lstrcmpi( p, FileName ) ) {

            DisableCopy = TRUE;
            break;
        }
    }
    
    return( DisableCopy );
}


BOOL
LoadHwdbLib (
    OUT     HMODULE* HwdbLib,
    OUT     PHWDB_ENTRY_POINTS HwdbEntries
    )
{
    TCHAR pathSupportLib[MAX_PATH];
    HMODULE hwdbLib;
    DWORD rc;

    if (!FindPathToWinnt32File (S_HWDB_DLL, pathSupportLib, MAX_PATH)) {
        return FALSE;
    }

    hwdbLib = LoadLibraryEx (pathSupportLib, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    if (!hwdbLib) {
        return FALSE;
    }
    HwdbEntries->HwdbInitialize = (PHWDBINITIALIZE) GetProcAddress (hwdbLib, S_HWDBAPI_HWDBINITIALIZE);
    HwdbEntries->HwdbTerminate = (PHWDBTERMINATE) GetProcAddress (hwdbLib, S_HWDBAPI_HWDBTERMINATE);
    HwdbEntries->HwdbOpen = (PHWDBOPEN) GetProcAddress (hwdbLib, S_HWDBAPI_HWDBOPEN);
    HwdbEntries->HwdbClose = (PHWDBCLOSE) GetProcAddress (hwdbLib, S_HWDBAPI_HWDBCLOSE);
    HwdbEntries->HwdbHasAnyDriver = (PHWDBHASANYDRIVER) GetProcAddress (hwdbLib, S_HWDBAPI_HWDBHASANYDRIVER);

    if (!HwdbEntries->HwdbInitialize ||
        !HwdbEntries->HwdbTerminate ||
        !HwdbEntries->HwdbOpen ||
        !HwdbEntries->HwdbClose ||
        !HwdbEntries->HwdbHasAnyDriver
        ) {
        ZeroMemory (HwdbEntries, sizeof (*HwdbEntries));
        rc = GetLastError ();
        FreeLibrary (hwdbLib);
        SetLastError (rc);
        return FALSE;
    }

    *HwdbLib = hwdbLib;
    return TRUE;
}

BOOL
pAnyPnpIdSupported (
    IN      PCTSTR PnpIDs
    )
{
    HMODULE hwdbLib;
    HANDLE hwdbDatabase;
    HWDB_ENTRY_POINTS hwdbEntries;
    TCHAR hwdbPath[MAX_PATH];
    BOOL unsupported;
    BOOL b = TRUE;

    if (!FindPathToWinnt32File (S_HWCOMP_DAT, hwdbPath, MAX_PATH)) {
        DynUpdtDebugLog (Winnt32LogWarning, TEXT("%1 not found"), 0, S_HWCOMP_DAT);
        return b;
    }

    if (!LoadHwdbLib (&hwdbLib, &hwdbEntries)) {
        DebugLog (
            Winnt32LogWarning,
            TEXT("LoadHwdbLib failed (rc=%u)"),
            0,
            GetLastError ()
            );
        return b;
    }

    if (hwdbEntries.HwdbInitialize (NULL)) {
        hwdbDatabase = hwdbEntries.HwdbOpen (hwdbPath);
        if (hwdbDatabase) {
            b = hwdbEntries.HwdbHasAnyDriver (hwdbDatabase, PnpIDs, &unsupported);
            hwdbEntries.HwdbClose (hwdbDatabase);
        }
        hwdbEntries.HwdbTerminate ();
    }

    FreeLibrary (hwdbLib);

    return b;
}


PTSTR
pGetDevicePnpIDs (
    IN      PCTSTR DeviceRegKey
    )
{
    LONG rc;
    HKEY deviceKey;
    DWORD type;
    DWORD size1, size2;
    PTSTR pnpIds;
    PTSTR p = NULL;

    rc = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            DeviceRegKey,
            0,
            KEY_QUERY_VALUE,
            &deviceKey
            );
    if (rc != ERROR_SUCCESS) {
        DebugLog (
            Winnt32LogWarning,
            TEXT("Failed to open device key %s (rc=%u)"),
            0,
            DeviceRegKey,
            rc
            );
        return p;
    }

    __try {
        size1 = 0;
        rc = RegQueryValueEx (
                deviceKey,
                TEXT("HardwareID"),
                NULL,
                &type,
                NULL,
                &size1
                );
        if (rc == ERROR_SUCCESS) {
            if (type != REG_MULTI_SZ) {
                size1 = 0;
                DebugLog (
                    Winnt32LogWarning,
                    TEXT("Unexpected type of %s of %s (type=%u)"),
                    0,
                    TEXT("HardwareID"),
                    DeviceRegKey,
                    type
                    );
            }
        } else {
            DebugLog (
                Winnt32LogWarning,
                TEXT("Couldn't find value %s of %s (rc=%u)"),
                0,
                TEXT("HardwareID"),
                DeviceRegKey,
                rc
                );
        }
        size2 = 0;
        rc = RegQueryValueEx (
                deviceKey,
                TEXT("CompatibleIDs"),
                NULL,
                &type,
                NULL,
                &size2
                );
        if (rc == ERROR_SUCCESS) {
            if (type != REG_MULTI_SZ) {
                size2 = 0;
                DebugLog (
                    Winnt32LogWarning,
                    TEXT("Unexpected type of %s of %s (type=%u)"),
                    0,
                    TEXT("CompatibleIDs"),
                    DeviceRegKey,
                    type
                    );
            }
        } else {
            DebugLog (
                Winnt32LogWarning,
                TEXT("Couldn't find value %s of %s (rc=%u)"),
                0,
                TEXT("CompatibleIDs"),
                DeviceRegKey,
                rc
                );
        }
        if (size1 + size2 < sizeof (TCHAR)) {
            DebugLog (
                Winnt32LogWarning,
                TEXT("Couldn't get list of PnpIDs for %s"),
                0,
                DeviceRegKey
                );
            __leave;
        }
        pnpIds = MALLOC (size1 + size2);
        if (!pnpIds) {
            __leave;
        }
        pnpIds[0] = 0;
        p = pnpIds;

        if (size1 >= sizeof (TCHAR)) {
            rc = RegQueryValueEx (
                    deviceKey,
                    TEXT("HardwareID"),
                    NULL,
                    NULL,
                    (LPBYTE)pnpIds,
                    &size1
                    );
            if (rc == ERROR_SUCCESS) {
                pnpIds += size1 / sizeof (TCHAR) - 1;
            }
        }
        if (size2 >= sizeof (TCHAR)) {
            rc = RegQueryValueEx (
                    deviceKey,
                    TEXT("CompatibleIDs"),
                    NULL,
                    NULL,
                    (LPBYTE)pnpIds,
                    &size2
                    );
        }
    }
    __finally {
        RegCloseKey (deviceKey);
    }

    return p;
}


BOOL
pAllServicedDevicesSupported (
    IN  HKEY    ServiceKey
    )
{
    LONG rc;
    HKEY enumSubKey;
    DWORD nextInstance;
    DWORD instance;
    TCHAR buf[20];
    DWORD type;
    DWORD size;
    PTSTR enumSuffixStr;
    HKEY deviceKey;
    PTSTR deviceKeyStr;
    PTSTR pnpIds;
    BOOL unsupported;
    BOOL b = TRUE;

    rc = RegOpenKeyEx (
            ServiceKey,
            TEXT("Enum"),
            0,
            KEY_QUERY_VALUE,
            &enumSubKey
            );
    if (rc != ERROR_SUCCESS) {
        DebugLog (
            Winnt32LogWarning,
            TEXT("Failed to open Enum subkey (rc=%u)"),
            0,
            rc
            );
        return b;
    }

    __try {
        size = sizeof (nextInstance);
        rc = RegQueryValueEx (
                enumSubKey,
                TEXT("NextInstance"),
                NULL,
                &type,
                (LPBYTE)&nextInstance,
                &size
                );
        if (rc != ERROR_SUCCESS) {
            DebugLog (
                Winnt32LogWarning,
                TEXT("Failed to open %s value (rc=%u)"),
                0,
                TEXT("NextInstance"),
                rc
                );
            __leave;
        }
        if (type != REG_DWORD) {
            DebugLog (
                Winnt32LogWarning,
                TEXT("Unexpected value type for %s (type=%u)"),
                0,
                TEXT("NextInstance"),
                type
                );
            __leave;
        }

        for (instance = 0; b && instance < nextInstance; instance++) {
            wsprintf (buf, TEXT("%lu"), instance);
            rc = RegQueryValueEx (
                    enumSubKey,
                    buf,
                    NULL,
                    &type,
                    NULL,
                    &size
                    );
            if (rc != ERROR_SUCCESS || type != REG_SZ) {
                continue;
            }
            enumSuffixStr = MALLOC (size);
            if (!enumSuffixStr) {
                __leave;
            }
            rc = RegQueryValueEx (
                    enumSubKey,
                    buf,
                    NULL,
                    NULL,
                    (LPBYTE)enumSuffixStr,
                    &size
                    );
            if (rc == ERROR_SUCCESS) {

                size = sizeof ("SYSTEM\\CurrentControlSet\\Enum") + lstrlen (enumSuffixStr) + 1;
                deviceKeyStr = MALLOC (size * sizeof (TCHAR));
                if (!deviceKeyStr) {
                    __leave;
                }

                BuildPath2 (deviceKeyStr, size, TEXT("SYSTEM\\CurrentControlSet\\Enum"), enumSuffixStr);

                pnpIds = pGetDevicePnpIDs (deviceKeyStr);

                FREE (deviceKeyStr);

                if (!pAnyPnpIdSupported (pnpIds)) {
                    b = FALSE;
                }

                FREE (pnpIds);
            }

            FREE (enumSuffixStr);
        }
    }
    __finally {
        RegCloseKey (enumSubKey);
    }

    return b;
}

BOOL
IsInfInLayoutInf(
    IN PCTSTR InfPath
    )

/*++

Routine Description:

    Determine if an INF file is shiped in-box with the operating system.
    This is acomplished by looking up the INF name in the [SourceDisksFiles]
    section of layout.inf

Arguments:

    InfPath - supplies name (may include path) of INF.  No checking is done
        to ensure INF lives in %windir%\Inf--this is caller's responsibility.

Return Value:

    If TRUE, this is an in-box INF.  If FALSE, it's not an in-box INF, this
    could be an OEM<n>.INF or an inf illegaly copied into the INF directory.

--*/

{
    BOOL bInBoxInf = FALSE;
    HINF hInf = INVALID_HANDLE_VALUE;
    UINT SourceId;
    PCTSTR infFileName;

    if (SetupapiGetSourceFileLocation) {

        hInf = SetupapiOpenInfFile(TEXT("layout.inf"), NULL, INF_STYLE_WIN4, NULL);

        if (hInf != INVALID_HANDLE_VALUE) {

            infFileName = _tcsrchr(InfPath, TEXT('\\') );
            if (infFileName) {
                infFileName++;
            } else {
                infFileName = InfPath;
            }

            if(SetupapiGetSourceFileLocation(hInf,
                                          NULL,
                                          infFileName,
                                          &SourceId,
                                          NULL,
                                          0,
                                          NULL)) {
                bInBoxInf = TRUE;
            }

            SetupapiCloseInfFile(hInf);
        }
    }

    return bInBoxInf;
}

BOOL
pIsOEMService (
    IN  PCTSTR  ServiceKeyName,
    OUT PTSTR OemInfPath,           OPTIONAL
    IN  INT BufferSize              OPTIONAL
    )
{
    ULONG BufferLen = 0;
    PTSTR Buffer = NULL;
    PTSTR p;
    DEVNODE DevNode;
    CONFIGRET cr;
    HKEY hKey;
    TCHAR InfPath[MAX_PATH];
    DWORD dwType, dwSize;
    BOOL IsOemService = FALSE;

    //
    // See how larger of a buffer we need to hold the list of device
    // instance Ids for this service.
    //
    cr = CM_Get_Device_ID_List_Size(&BufferLen,
                                    ServiceKeyName,
                                    CM_GETIDLIST_FILTER_SERVICE);

    if (cr != CR_SUCCESS) {
        //
        // Encountered an error so just bail out.
        //
        goto clean0;
    }

    if (BufferLen == 0) {
        //
        // No devices are using this service, so just bail out.
        //
        goto clean0;
    }

    Buffer = MALLOC(BufferLen*sizeof(TCHAR));

    if (Buffer == NULL) {
        goto clean0;
    }

    //
    // Get the list of device instance Ids for this service.
    //
    cr = CM_Get_Device_ID_List(ServiceKeyName,
                               Buffer,
                               BufferLen,
                               CM_GETIDLIST_FILTER_SERVICE | CM_GETIDLIST_DONOTGENERATE);

    if (cr != CR_SUCCESS) {
        //
        // failed to get the list of devices for this service.
        //
        goto clean0;
    }

    //
    // Enumerate through the list of devices using this service.
    //
    for (p = Buffer; !IsOemService && *p; p += (lstrlen(p) + 1)) {

        //
        // Get a DevNode from the device instance Id.
        //
        cr = CM_Locate_DevNode(&DevNode, p, 0);

        if (cr != CR_SUCCESS) {
            continue;
        }
        
        //
        // Open the device's SOFTWARE key so we can get it's INF path.
        //
        cr = CM_Open_DevNode_Key(DevNode,
                                 KEY_READ,
                                 0,
                                 RegDisposition_OpenExisting,
                                 &hKey,
                                 CM_REGISTRY_SOFTWARE);

        if (cr != CR_SUCCESS) {
            //
            // Software key doesn't exist?  
            //
            continue;
        }

        dwType = REG_SZ;
        dwSize = sizeof(InfPath);
        if (RegQueryValueEx(hKey,
                            REGSTR_VAL_INFPATH,
                            NULL,
                            &dwType,
                            (LPBYTE)InfPath,
                            &dwSize) != ERROR_SUCCESS) {
            //
            // If there is no InfPath in the SOFTWARE key then we don't know
            // what INF this device is using.
            //
            RegCloseKey(hKey);
            continue;
        }

        if (!IsInfInLayoutInf(InfPath)) {

            IsOemService = TRUE;

            if (OemInfPath) {
                StringCchCopy (OemInfPath, BufferSize, InfPath);
            }
        }

        RegCloseKey(hKey);
    }

clean0:
    if (Buffer) {
        FREE(Buffer);
    }

    return IsOemService;
}


BOOL
IsDeviceSupported(
    IN  PVOID   TxtsetupSifHandle,
    IN  HKEY    ServiceKey,
    IN  LPTSTR  ServiceKeyName,
    OUT LPTSTR  FileName
    )
{
    ULONG   Error;
    ULONG   Type;
    BYTE    Buffer[ (MAX_PATH + 1)*sizeof(TCHAR) ];
    PBYTE   Data;
    ULONG   cbData;
    BOOL    b = TRUE;
    LPTSTR  DriverPath;
    LPTSTR  DriverName;
    LONG    LineCount;
    LONG    i;
    BOOL    DeviceSupported;

    Data = Buffer;
    cbData = sizeof( Buffer );
    Error = RegQueryValueEx( ServiceKey,
                             TEXT("ImagePath"),
                             NULL,
                             &Type,
                             Data,
                             &cbData );

    if( (Error == ERROR_PATH_NOT_FOUND) ||
        (Error == ERROR_FILE_NOT_FOUND) ) {
        //
        //  ImagePath does not exist.
        //  In this case the driver name is <service name>.sys
        //
        lstrcpy( (LPTSTR)( Data ), ServiceKeyName );
        lstrcat( (LPTSTR)( Data ), TEXT(".sys") );
        Error = ERROR_SUCCESS;
    }

    if( Error == ERROR_MORE_DATA ) {
        Data = (PBYTE)MALLOC( cbData );
        if( Data == NULL ) {
            //
            // We failed the malloc.  Just assume the device
            // isn't supported.
            //
            return( FALSE );
        }

        Error = RegQueryValueEx( ServiceKey,
                                 TEXT("ImagePath"),
                                 NULL,
                                 &Type,
                                 Data,
                                 &cbData );
    }

    if( Error != ERROR_SUCCESS ) {
        //
        //  We can' retrieve the drivers information.
        //  Assume that the device is supported
        //
        if( Data != Buffer ) {
            FREE( Data );
        }
        return( TRUE );
    }

    DriverPath = (LPTSTR)Data;

    DriverName = _tcsrchr( DriverPath, TEXT('\\') );
    if( DriverName != NULL ) {
        DriverName++;
    } else {
        DriverName = DriverPath;
    }

    //
    //  Search for the driver name on the following sections of txtsetup.sif:
    //          [SCSI.load]
    //

    if( (LineCount = InfGetSectionLineCount( TxtsetupSifHandle,
                                             TEXT("SCSI.load") )) == -1 ) {
        //
        //  We can't retrieve the drivers information.
        //  Assume that the device is supported
        //
        if( Data != Buffer ) {
            FREE( Data );
        }
        return( TRUE );
    }

    DeviceSupported = FALSE;
    for( i = 0; i < LineCount; i++ ) {
        LPTSTR  p;

        p = (LPTSTR)InfGetFieldByIndex( TxtsetupSifHandle,
                                        TEXT("SCSI.load"),
                                        i,
                                        0 );
        if( p == NULL ) {
            continue;
        }
        if( !lstrcmpi( p, DriverName ) ) {
            DeviceSupported = TRUE;
            break;
        }
    }

    //
    // NTBUG9: 603644
    // OnW2K+, verify if there is inbox support for ALL devices
    // currently supported by this driver
    // If there's any that doesn't have support,
    // then the OEM driver must be migrated
    //
    if (ISNT() && BuildNumber >= NT50 && DeviceSupported) {

        if (pIsOEMService (ServiceKeyName, NULL, 0)) {

            if (!pAllServicedDevicesSupported (ServiceKey)) {
                DeviceSupported = FALSE;
            }
        }
    }

#ifdef _X86_

    //
    // one more thing: check if this device is supplied by OEMs via answer file (NTBUG9: 306041)
    //
    if (!DeviceSupported) {
        POEM_BOOT_FILE p;
        for (p = OemBootFiles; p; p = p->Next) {
            if (!lstrcmpi (p->Filename, DriverName)) {
                DeviceSupported = TRUE;
                break;
            }
        }
    }
#endif

    if( !DeviceSupported ) {
        LPTSTR  q;

        CharLower( DriverPath );
        q = _tcsstr( DriverPath, TEXT("system32") );
        if( q == NULL ) {
            lstrcpy( FileName, TEXT("system32\\drivers\\") );
            lstrcat( FileName, DriverName );
        } else {
            lstrcpy( FileName, q );
        }
    }
    if( Data != Buffer ) {
        FREE( Data );
    }
    return( DeviceSupported );
}

VOID
FreeHardwareIdList(
    IN PUNSUPORTED_PNP_HARDWARE_ID HardwareIdList
    )
{
    PUNSUPORTED_PNP_HARDWARE_ID p, q;

    p = HardwareIdList;
    while( p != NULL ) {
        FREE( p->Id );
        FREE( p->Service );
        FREE( p->ClassGuid );
        q = p->Next;
        FREE( p );
        p = q;
    }
}

VOID
FreeFileInfoList(
    IN PUNSUPORTED_DRIVER_FILE_INFO FileInfoList
    )
{
    PUNSUPORTED_DRIVER_FILE_INFO p, q;

    p = FileInfoList;
    while( p != NULL ) {
        FREE( p->FileName );
        FREE( p->TargetDirectory );
        q = p->Next;
        FREE( p );
        p = q;
    }
}

VOID
FreeRegistryInfoList(
    IN PUNSUPORTED_DRIVER_REGKEY_INFO RegistryInfoList
    )
{
    PUNSUPORTED_DRIVER_REGKEY_INFO p, q;

    p = RegistryInfoList;
    while( p != NULL ) {
        FREE( p->KeyPath );
        q = p->Next;
        FREE( p );
        p = q;
    }
}


BOOL
BuildHardwareIdInfo(
    IN  LPTSTR                       ServiceName,
    OUT PUNSUPORTED_PNP_HARDWARE_ID* HardwareIdList
    )
{
    ULONG BufferLen;
    DEVNODE DevNode;
    PTSTR Buffer, Service, Id, HwId, DevId;
    PBYTE  Value;
    ULONG ValueSize;
    PUNSUPORTED_PNP_HARDWARE_ID TempList, Entry;
    BOOL Result;
    DWORD Type;

    if (CM_Get_Device_ID_List_Size(&BufferLen,
                                          ServiceName,
                                          CM_GETIDLIST_FILTER_SERVICE
                                          ) != CR_SUCCESS ||
        (BufferLen == 0)) {

        return ( FALSE );
    }

    Result = TRUE;
    Value = NULL;
    TempList = NULL;
    Buffer = MALLOC(BufferLen * sizeof(TCHAR));
    if (Buffer == NULL) {

        Result = FALSE;
        goto Clean;
    }
    ValueSize = REGSTR_VAL_MAX_HCID_LEN * sizeof(TCHAR);
    Value = MALLOC(ValueSize);
    if (Value == NULL) {

        Result = FALSE;
        goto Clean;
    }
    if (CM_Get_Device_ID_List(ServiceName,
                              Buffer,
                              BufferLen,
                              CM_GETIDLIST_FILTER_SERVICE | CM_GETIDLIST_DONOTGENERATE
                              ) != CR_SUCCESS) {

        Result = FALSE;
        goto Clean;
    }

    for (DevId = Buffer; *DevId; DevId += lstrlen(DevId) + 1) {

        if (CM_Locate_DevNode(&DevNode, DevId, 0) == CR_SUCCESS) {

            ValueSize = REGSTR_VAL_MAX_HCID_LEN * sizeof(TCHAR);
            if (CM_Get_DevNode_Registry_Property(DevNode, CM_DRP_HARDWAREID, &Type, Value, &ValueSize, 0) == CR_SUCCESS &&
                Type == REG_MULTI_SZ) {

                for( HwId = (PTSTR)Value;
                     ( (ULONG_PTR)HwId < (ULONG_PTR)(Value + ValueSize) ) && ( lstrlen( HwId ) );
                     HwId += lstrlen( HwId ) + 1 ) {

                    Entry = MALLOC( sizeof( UNSUPORTED_PNP_HARDWARE_ID ) );
                    Id = DupString( HwId );
                    Service = DupString( ServiceName );

                    if( (Entry == NULL) || (Id == NULL) || (Service == NULL) ) {

                        if( Entry != NULL ) {
                            FREE( Entry );
                        }
                        if( Id != NULL ) {
                            FREE( Id );
                        }
                        if( Service != NULL ) {
                            FREE( Service );
                        }
                        Result = FALSE;
                        goto Clean;
                    }
                    //
                    // Add the new entry to the front of the list.
                    // 
                    Entry->Id = Id;
                    Entry->Service = Service;
                    Entry->ClassGuid = NULL;
                    Entry->Next = TempList;
                    TempList = Entry;
                }
            }
        }
    }

Clean:

    if ( Buffer ) {
    
        FREE( Buffer );
    }
    if ( Value ) {

        FREE( Value );
    }
    if (Result == TRUE) {

        *HardwareIdList = TempList;
    } else if ( TempList ) {

        FreeHardwareIdList( TempList );
    }

    return ( Result );
}


BOOL
BuildDriverFileInformation(
    IN  LPTSTR                        FilePath,
    OUT PUNSUPORTED_DRIVER_FILE_INFO* FileInfo
    )

{
    TCHAR   FullPath[ MAX_PATH + 1 ];
    LPTSTR  p, q, r;
    PUNSUPORTED_DRIVER_FILE_INFO TempFileInfo = NULL;

    *FileInfo = NULL;
    lstrcpy( FullPath, FilePath );
    p = _tcsrchr( FullPath, TEXT('\\') );
    if(!p)
        return FALSE;
    *p = TEXT('\0');
    p++;
    q = DupString( FullPath );
    r = DupString( p );
    TempFileInfo = MALLOC( sizeof( UNSUPORTED_DRIVER_FILE_INFO ) );

    if( ( q == NULL ) || ( r == NULL ) || ( TempFileInfo == NULL ) ) {
        goto clean0;
    }

    TempFileInfo->Next = NULL;
    TempFileInfo->FileName = r;
    TempFileInfo->TargetDirectory = q;
    *FileInfo = TempFileInfo;
    return( TRUE );

clean0:
    if( q != NULL ) {
        FREE( q );
    }
    if( r != NULL ) {
        FREE( r );
    }
    if( TempFileInfo != NULL ) {
        FREE( TempFileInfo );
    }
    return( FALSE );
}

BOOL
BuildDriverRegistryInformation(
    IN  LPTSTR                          ServiceName,
    OUT PUNSUPORTED_DRIVER_REGKEY_INFO* RegInfo
    )

{
    TCHAR   KeyPath[ MAX_PATH + 1 ];
    LPTSTR  p;
    PUNSUPORTED_DRIVER_REGKEY_INFO TempRegInfo = NULL;

    *RegInfo = NULL;
    lstrcpy( KeyPath, TEXT( "SYSTEM\\CurrentControlSet\\Services\\" ) );
    lstrcat( KeyPath, ServiceName );
    p = DupString( KeyPath );
    TempRegInfo = MALLOC( sizeof( UNSUPORTED_DRIVER_REGKEY_INFO ) );

    if( ( p == NULL ) || ( TempRegInfo == NULL ) ) {
        goto clean0;
    }

    TempRegInfo->Next = NULL;
    TempRegInfo->PredefinedKey = HKEY_LOCAL_MACHINE;
    TempRegInfo->KeyPath = p;
    TempRegInfo->MigrateVolatileKeys = FALSE;
    *RegInfo = TempRegInfo;
    return( TRUE );

clean0:
    if( p != NULL ) {
        FREE( p );
    }
    if( TempRegInfo != NULL ) {
        FREE( TempRegInfo );
    }
    return( FALSE );
}

VOID
FreeDriverInformationList(
    IN OUT  PUNSUPORTED_DRIVER_INFO* DriverInfo
    )
{
    while( *DriverInfo != NULL ) {
        PUNSUPORTED_DRIVER_INFO    p;

        p = *DriverInfo;
        *DriverInfo = p->Next;

        if( p->DriverId != NULL ) {
            FREE( p->DriverId );
        }

        if( p->KeyList != NULL ) {
            FreeRegistryInfoList( p->KeyList );
        }

        if( p->FileList != NULL ) {
            FreeFileInfoList( p->FileList );
        }

        if( p-> HardwareIdsList != NULL ) {
            FreeHardwareIdList( p-> HardwareIdsList );
        }
        FREE( p );
    }
    *DriverInfo = NULL;
}


BOOL
BuildDriverInformation(
    IN  HKEY                     ServiceKey,
    IN  LPTSTR                   ServiceName,
    IN  LPTSTR                   FilePath,
    OUT PUNSUPORTED_DRIVER_INFO* DriverInfo
    )
{
    ULONG   Error;
    BOOL    b1, b2, b3 = TRUE;

    PUNSUPORTED_PNP_HARDWARE_ID     TempIdInfo = NULL;
    PUNSUPORTED_DRIVER_INFO         TempFiltersInfo = NULL;
    PUNSUPORTED_DRIVER_FILE_INFO    TempFileInfo = NULL;
    PUNSUPORTED_DRIVER_REGKEY_INFO  TempRegInfo = NULL;
    PUNSUPORTED_DRIVER_INFO         TempDriverInfo = NULL;

    *DriverInfo = NULL;
    //
    //  Get hardware id info
    //
    b1 = BuildHardwareIdInfo( ServiceName,
                              &TempIdInfo );

    //
    //  Then get the file information
    //
    b2 = BuildDriverFileInformation( FilePath,
                                     &TempFileInfo );

    //
    //  Then get the registry information
    //
    b3 = BuildDriverRegistryInformation( ServiceName,
                                         &TempRegInfo );

    if( !b1 || !b2 || !b3 ) {
        goto cleanup1;
    }

    TempDriverInfo = MALLOC( sizeof( UNSUPORTED_DRIVER_INFO ) );
    if( TempDriverInfo == NULL ) {
        goto cleanup1;
    }

    TempDriverInfo->Next = NULL;
    TempDriverInfo->DriverId = DupString( ServiceName );
    TempDriverInfo->KeyList = TempRegInfo;
    TempDriverInfo->FileList = TempFileInfo;
    TempDriverInfo->HardwareIdsList = TempIdInfo;


    TempDriverInfo->Next = *DriverInfo;
    *DriverInfo = TempDriverInfo;
    return( TRUE );

cleanup1:

    if( TempIdInfo != NULL ) {
        FreeHardwareIdList( TempIdInfo );
    }

    if( TempFileInfo != NULL ) {
        FreeFileInfoList( TempFileInfo );
    }

    if( TempRegInfo != NULL ) {
        FreeRegistryInfoList( TempRegInfo );
    }

    return( FALSE );
}


BOOL
BuildUnsupportedDriverList(
    IN  PVOID                    TxtsetupSifHandle,
    OUT PUNSUPORTED_DRIVER_INFO* DriverList
    )

{
    ULONG   Error;
    HKEY    ScsiKey;
    ULONG   SubKeys;
    ULONG   i;
    LPTSTR  szScsiPath = TEXT("HARDWARE\\DEVICEMAP\\Scsi");


    *DriverList = NULL;

    //
    //  Find out if there is a SCSI miniport driver on this machine.
    //

    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          szScsiPath,
                          0,
                          KEY_READ,
                          &ScsiKey );
    if( Error != ERROR_SUCCESS ) {
        //
        //  Nothing to migrate
        //
        return( TRUE );
    }

    //
    //  Find out the number of subkeys under HKLM\HARDWARE\DEVICEMAP\Scsi.
    //

    Error = RegQueryInfoKey ( ScsiKey,
                              NULL,
                              NULL,
                              NULL,
                              &SubKeys,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL );

    if( (Error != ERROR_SUCCESS) || (SubKeys == 0) ) {
        //
        //  If we can't determine the number of subkeys, or if there is no
        //  subkey, then there is nothing to migrate, and we assume that all
        //  SCSI drivers are supported on NT.
        //
        RegCloseKey( ScsiKey );
        return( TRUE );
    }

    //
    //  Each subkey of HKLM\HARDWARE\DEVICEMAP\Scsi points to a service that controls
    //  a SCSI device. We check each one of them to find out the ones that are controlled
    //  by a driver that is not on the NT product.
    //
    for( i = 0; i < SubKeys; i++ ) {
        TCHAR       SubKeyName[ MAX_PATH + 1 ];
        TCHAR       ServiceKeyPath[ MAX_PATH + 1 ];
        ULONG       Length;
        FILETIME    LastWriteTime;
        HKEY        Key;
        BYTE        Data[ 512 ];
        ULONG       DataSize;
        ULONG       Type;
        PUNSUPORTED_DRIVER_INFO DriverInfo, p;
        BOOL        DeviceAlreadyFound;
        TCHAR       FilePath[ MAX_PATH + 1 ];

        Length = sizeof( SubKeyName ) / sizeof( TCHAR );
        Error = RegEnumKeyEx( ScsiKey,
                              i,
                              SubKeyName,
                              &Length,
                              NULL,
                              NULL,
                              NULL,
                              &LastWriteTime );

        if( Error != ERROR_SUCCESS ) {
            //
            //  Ignore this device and assume it is supported.
            //
            continue;
        }

        Error = RegOpenKeyEx( ScsiKey,
                              SubKeyName,
                              0,
                              KEY_READ,
                              &Key );
        if( Error != ERROR_SUCCESS ) {
            //
            //  Ignore this device and assume it is supported.
            //
            continue;
        }

        DataSize = sizeof( Data );
        Error = RegQueryValueEx( Key,
                                 TEXT("Driver"),
                                 NULL,
                                 &Type,
                                 Data,
                                 &DataSize );

        if( Error != ERROR_SUCCESS ) {
            //
            //  Ignore this device and assume it is supported.
            //
            RegCloseKey( Key );
            continue;
        }
        RegCloseKey( Key );

        //
        //  Find out if this device is supported on NT 5.0
        //
        lstrcpy( ServiceKeyPath, TEXT("SYSTEM\\CurrentControlSet\\Services\\" ) );
        lstrcat( ServiceKeyPath, (LPTSTR)Data );
        Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              ServiceKeyPath,
                              0,
                              KEY_READ,
                              &Key );

        if( Error != ERROR_SUCCESS ) {
            //
            //  Assume it is supported, since there is nothing else we can do here.
            //
            continue;
        }

        if( IsDeviceSupported( TxtsetupSifHandle,
                               Key,
                               (LPTSTR)Data,
                               FilePath
                             ) ) {
            RegCloseKey( Key );
            continue;
        }

        //
        //  Find out if this device  is already in our list
        //
        DeviceAlreadyFound = FALSE;
        for( p = (PUNSUPORTED_DRIVER_INFO)*DriverList; p && !DeviceAlreadyFound; p = p->Next ) {
            if( !lstrcmpi( p->DriverId, (LPTSTR)Data ) ) {
                DeviceAlreadyFound = TRUE;
            }
        }
        if( DeviceAlreadyFound ) {
            RegCloseKey( Key );
            continue;
        }

        //
        //  Find out if the device is listed in the section [ServicesToDisable] in dosnet.inf
        //
        if( IsServiceToBeDisabled( NtcompatInf,
                                   (LPTSTR)Data ) ) {
            RegCloseKey( Key );
            continue;
        }

        //
        // Find out if the file is listed in the [DriversToSkipCopy] section in
        // ntcompat.inf.
        //
        if( IsDriverCopyToBeSkipped( NtcompatInf,
                                     (LPTSTR)Data,
                                     FilePath ) ) {
	    RegCloseKey( Key );
            continue;
        }


        //
        //  The driver for this device is not supported and needs to be migrated.
        //
        DriverInfo = NULL;

        if( !BuildDriverInformation( Key,
                                     (LPTSTR)Data,
                                     FilePath,
                                     &DriverInfo ) ) {
            //
            // If we cannot build the driver information for this device, then
            // we inform the user that we detected an unsupported device, but that
            // we cannot migrate it. The user will have to provide the OEM disk
            // for this device during setupldr or textmode setup phases.
            //
            RegCloseKey( Key );
            FreeDriverInformationList( DriverList );
            return( FALSE );
        }

        DriverInfo->Next = (PUNSUPORTED_DRIVER_INFO)*DriverList;
        (PUNSUPORTED_DRIVER_INFO)*DriverList = DriverInfo;
        RegCloseKey( Key );
    }
    RegCloseKey( ScsiKey );

    return( TRUE );
}


DWORD
DumpRegInfoToInf(
    IN PUNSUPORTED_DRIVER_REGKEY_INFO RegList,
    IN LPTSTR                         DriverId,
    IN PINFFILEGEN                    Context
    )

{
    LPTSTR  SectionName;
    DWORD   Error;
    LPTSTR  szAddReg = TEXT("AddReg.");
    PUNSUPORTED_DRIVER_REGKEY_INFO p;

    Error = ERROR_SUCCESS;
    SectionName = MALLOC( (lstrlen( szAddReg ) + lstrlen( DriverId ) + 1)*sizeof(TCHAR) );
    if( SectionName == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto c0;
    }
    lstrcpy( SectionName, szAddReg );
    lstrcat( SectionName, DriverId );
    Error = InfCreateSection( SectionName, &Context );

    for( p = RegList; p != NULL; p = p->Next ) {
#if 0
        Error = DumpRegInfoToInfWorker( p->PredefinedKey,
                                        p->KeyPath,
                                        Context );
#endif
        Error = DumpRegKeyToInf( Context,
                                 p->PredefinedKey,
                                 p->KeyPath,
                                 TRUE,
                                 TRUE,
                                 TRUE,
                                 p->MigrateVolatileKeys );

        if( Error != ERROR_SUCCESS ) {
            goto c0;
        }
    }

c0:
    if( SectionName != NULL ) {
        FREE( SectionName );
    }
    return( Error );
}


DWORD
DumpFileInfoToInf(
    IN PUNSUPORTED_DRIVER_FILE_INFO   FileList,
    IN LPTSTR                         DriverId,
    IN PINFFILEGEN                    Context
    )

{
    LPTSTR  SectionName;
    DWORD   Error;
    LPTSTR  szFiles = TEXT("Files.");
    PUNSUPORTED_DRIVER_FILE_INFO p;
    TCHAR   Line[ MAX_PATH ];

    Error = ERROR_SUCCESS;
    SectionName = MALLOC( (lstrlen( szFiles ) + lstrlen( DriverId ) + 1)*sizeof(TCHAR) );
    if( SectionName == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto c0;
    }
    lstrcpy( SectionName, szFiles );
    lstrcat( SectionName, DriverId );
    Error = InfCreateSection( SectionName, &Context );

    for( p = FileList; p != NULL; p = p->Next ) {
        lstrcpy( Line, p->FileName );
        lstrcat( Line, TEXT(",") );
        lstrcat( Line, p->TargetDirectory );
        Error = WriteText(Context->FileHandle,MSG_INF_SINGLELINE,Line);
        if( Error != ERROR_SUCCESS ) {
            goto c0;
        }
    }

c0:
    if( SectionName != NULL ) {
        FREE( SectionName );
    }
    return( Error );
}


DWORD
DumpHardwareIdsToInf(
    IN PUNSUPORTED_PNP_HARDWARE_ID    HwIdList,
    IN LPTSTR                         DriverId,
    IN PINFFILEGEN                    Context
    )

{
    LPTSTR  SectionName;
    DWORD   Error;
    LPTSTR  szHardwareIds = TEXT("HardwareIds.");
    PUNSUPORTED_PNP_HARDWARE_ID p;
    LPTSTR  Line;
    ULONG   Length;

    Error = ERROR_SUCCESS;
    SectionName = MALLOC( (lstrlen( szHardwareIds ) + lstrlen( DriverId ) + 1)*sizeof( TCHAR ) );
    if( SectionName == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto c0;
    }
    lstrcpy( SectionName, szHardwareIds );
    lstrcat( SectionName, DriverId );
    Error = InfCreateSection( SectionName, &Context );

    for( p = HwIdList; p != NULL; p = p->Next ) {
        Length = (lstrlen( p->Id ) + lstrlen( p->Service ) + 3)*sizeof(TCHAR);
        if( p->ClassGuid ) {
            Length += (lstrlen( p->ClassGuid) + 1 )*sizeof(TCHAR);
        }
        Line = MALLOC( Length );
        if( Line == NULL ) {
            goto c0;
        }
        lstrcpy( Line, p->Id );
        lstrcat( Line, TEXT("=") );
        lstrcat( Line, p->Service );
        if( p->ClassGuid ) {
            lstrcat( Line, TEXT(",") );
            lstrcat( Line, p->ClassGuid );
        }
        Error = WriteText(Context->FileHandle,MSG_INF_SINGLELINE,Line);
        FREE( Line );

        if( Error != ERROR_SUCCESS ) {
            goto c0;
        }
    }

c0:
    if( SectionName != NULL ) {
        FREE( SectionName );
    }
    return( Error );
}


BOOL
SaveUnsupportedDriverInfo(
    IN HWND ParentWindow,
    IN LPTSTR FileName,
    IN PUNSUPORTED_DRIVER_INFO DriverList
    )
{
    HKEY Key;
    DWORD d;
    LONG l = ERROR_SUCCESS;
    TCHAR Path[MAX_PATH];
    PINFFILEGEN   InfContext;
    TCHAR SectionName[MAX_PATH];
    PUNSUPORTED_DRIVER_INFO p;

#ifdef _X86_
    if(Floppyless) {
        lstrcpy(Path,LocalBootDirectory);
    } else {
        Path[0] = FirstFloppyDriveLetter;
        Path[1] = TEXT(':');
        Path[2] = 0;
    }
#else
    lstrcpy(Path,LocalSourceWithPlatform);
#endif

    l = InfStart( FileName,
                  Path,
                  &InfContext);

    if(l != ERROR_SUCCESS) {
        return(FALSE);
    }

    for( p = DriverList; p != NULL; p = p->Next ) {
        if( p->KeyList != NULL ) {
            l = DumpRegInfoToInf( p->KeyList,p->DriverId, InfContext );
            if(l != ERROR_SUCCESS) {
                goto c0;
            }
        }
        if( p->FileList ) {
            l = DumpFileInfoToInf( p->FileList, p->DriverId, InfContext );
            if(l != ERROR_SUCCESS) {
                goto c0;
            }
        }

        if( p->HardwareIdsList ) {
            l = DumpHardwareIdsToInf( p->HardwareIdsList, p->DriverId, InfContext );
            if(l != ERROR_SUCCESS) {
                goto c0;
            }
        }
    }
    if( DriverList != NULL ) {
        l = InfCreateSection( TEXT("Devices"), &InfContext );
        if(l != NO_ERROR) {
            goto c0;
        }
        for( p = DriverList; p != NULL; p = p->Next ) {
            l = WriteText(InfContext->FileHandle,MSG_INF_SINGLELINE,p->DriverId);
            if(l != ERROR_SUCCESS) {
                goto c0;
            }
        }
    }

c0:
    InfEnd( &InfContext );
    if( l != ERROR_SUCCESS ) {
        lstrcat( Path, TEXT("\\") );
        lstrcat( Path, FileName );
        DeleteFile( Path );
        return( FALSE );
    }
    return(TRUE);
}

BOOL
MigrateUnsupportedNTDrivers(
    IN HWND   ParentWindow,
    IN PVOID  TxtsetupSifHandle
    )

{
    BOOL    b;
    PUNSUPORTED_DRIVER_INFO UnsupportedDriverList = NULL;

    b = BuildUnsupportedDriverList( TxtsetupSif, &UnsupportedDriverList );
    if( !CheckUpgradeOnly && b ) {
        if( UnsupportedDriverList ) {
            b = SaveUnsupportedDriverInfo( ParentWindow, WINNT_UNSUPDRV_INF_FILE, UnsupportedDriverList );
            if( b ) {
                b = AddUnsupportedFilesToCopyList( ParentWindow, UnsupportedDriverList );
                if( !b ) {
                    TCHAR   Path[ MAX_PATH + 1 ];
                    //
                    //  If we failed to add the files to the copy list, then
                    //  delete unsupdrv.inf since there is no point in migrating
                    //  these drivers.
                    //
#ifdef _X86_
                    if(Floppyless) {
                        lstrcpy(Path,LocalBootDirectory);
                    } else {
                        Path[0] = FirstFloppyDriveLetter;
                        Path[1] = TEXT(':');
                        Path[2] = 0;
                    }
#else
                        lstrcpy(Path,LocalSourceWithPlatform);
#endif
                    lstrcat( Path, TEXT("\\") );
                    lstrcat( Path, WINNT_UNSUPDRV_INF_FILE );
                    DeleteFile( Path );
                }
            }
        }
        FreeDriverInformationList( &UnsupportedDriverList );
    }
    if( !b ) {
        //
        // Inform the user that unsupported drivers could not be migrated.
        //
        MessageBoxFromMessage( ParentWindow,
                               MSG_CANT_MIGRATE_UNSUP_DRIVERS,
                               FALSE,
                               AppTitleStringId,
                               MB_OK | MB_ICONINFORMATION | MB_TASKMODAL
                             );
    }
    return( b );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\sxs.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ntsetup\winnt32\dll\sxs.h

Abstract:

    SideBySide support in the winnt32 phase of ntsetup.

Author:

    Jay Krell (JayKrell) March 2001

Revision History:

--*/

#pragma once

struct _SXS_CHECK_LOCAL_SOURCE;
typedef struct _SXS_CHECK_LOCAL_SOURCE SXS_CHECK_LOCAL_SOURCE, *PSXS_CHECK_LOCAL_SOURCE;

struct _SXS_CHECK_LOCAL_SOURCE {
    // IN
    HWND            ParentWindow;
};

BOOL
SxsCheckLocalSource(
    PSXS_CHECK_LOCAL_SOURCE p
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\sources.inc ===
MAJORCOMP=setup

TARGETPATH=..\..\$(_OBJ_DIR)
TARGETTYPE=DYNLINK

DLLDEF=winnt32.def
DLLENTRY=_DllMainCRTStartup

PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)

INCLUDES= $(PASS0_HEADERDIR);   \
          $(PASS0_SOURCEDIR);   \
          ..;                   \
          ..\..\..\inc;         \
          ..\..\..\..\inc;      \
          ..\..\faulth;         \
          $(ADMIN_INC_PATH);    \
          $(BASE_INC_PATH);     \
          $(WINDOWS_INC_PATH);  \
          $(TERMSRV_INC_PATH);  \

#          $(SDK_INC_PATH);      \
#          $(SDK_INC_PATH)\crt;  \


#
# We use various NT APIs to do stuff like arc name translations and
# NV-RAM manipulation. The x86 version has to run on Win95, so we can't
# link to ntdll.dll (when running on NT x86 the code does loadlib/getprocaddr
# for the routines it needs). On non-x86 we want ntdll to come last
# in the link order so we don't get crt routines from it (the set of crt
# routines exported from it varies from release to release) so we play
# a little build trickery to get it right.
#
NO_NTDLL=1
USE_LIBCMT=1
UMTYPE=windows
LINKER_FLAGS=/SWAPRUN:CD /SWAPRUN:NET
!if $(386)
SUBSYSTEM_VERSION=4.00
!ENDIF

SOURCES=..\arc.c        \
        ..\argvw.c      \
        ..\cleanup.c    \
        ..\comp.c       \
        ..\copylist.c   \
        ..\debug.c      \
        ..\delnode.c    \
        ..\diamond.c    \
        ..\dll.c        \
        ..\dynsetup.c   \
        ..\dynupdt.c    \
        ..\eula.c       \
        ..\incompat.c   \
        ..\inf.c        \
        ..\inspect.c    \
        ..\internal.c   \
        ..\misc.c       \
        ..\msg.mc       \
        ..\options.c    \
        ..\params.c     \
        ..\regmigrt.c   \
        ..\rsrcutil.c   \
        ..\security.c   \
        ..\sticky.c     \
        ..\util.c       \
        ..\winnt32.c    \
        ..\winnt32.rc   \
        ..\dscheck.c    \
        ..\web.cpp      \
        ..\wizard.c     \
        ..\cmdcons.c    \
        ..\lang.c       \
        ..\sxs.c        \

TARGETLIBS=\
           $(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\user32.lib   \
           $(SDK_LIB_PATH)\gdi32.lib    \
           $(SDK_LIB_PATH)\uuid.lib     \
           $(SDK_LIB_PATH)\ole32.lib    \
           $(SDK_LIB_PATH)\oleaut32.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\cfgmgr32.lib \
           $(SDK_LIB_PATH)\comctl32.lib \
           $(SDK_LIB_PATH)\comdlg32.lib \
           $(BASE_LIB_PATH)\patchbc.lib             \
           $(PROJECT_LIB_PATH)\pnpsif.lib           \
           $(SDK_LIB_PATH)\mpr.lib      \
           $(SDK_LIB_PATH)\version.lib  \
           $(SDK_LIB_PATH)\winspool.lib \
           $(SDK_LIB_PATH)\imm32.lib \
           $(PROJECT_LIB_PATH)\pencrypt.lib \
           $(PROJECT_ROOT)\ntsetup\pidgen\lib\trial\$(O)\pidgen.lib   \
           $(PROJECT_ROOT)\mspatch\api\statica\$(O)\mspatchz.lib \

PRECOMPILED_INCLUDE=precomp.h


#
# Definition of DOWNLOAD_DETAILS
#
!ifdef DOWNLOAD_DETAILS
C_DEFINES=$(C_DEFINES) -DDOWNLOAD_DETAILS
!endif

#
# Definition of PRERELEASE
#

!include $(PROJECT_ROOT)\ntsetup\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\winnt32\dll\sxs.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ntsetup\winnt32\dll\sxs.h

Abstract:

    SideBySide support in the winnt32 phase of ntsetup.

Author:

    Jay Krell (JayKrell) March 2001

Revision History:

Environment:

    winnt32 -- Win9x ANSI (down to Win95gold) or NT Unicode
               libcmt statically linked in, _tcs* ok
--*/
#include "precomp.h"
#pragma hdrstop
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include "tchar.h"
#include "sxs.h"
#include "msg.h"
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))

#define CHECK_FOR_MINIMUM_ASSEMBLIES 0
#define CHECK_FOR_OBSOLETE_ASSEMBLIES 1
#define EMPTY_LEAF_DIRECTORIES_ARE_OK 1

const static TCHAR rgchPathSeperators[] = TEXT("\\/");

#define PRESERVE_LAST_ERROR(code) \
    do { DWORD PreserveLastError = Success ? NO_ERROR : GetLastError(); \
        do { code ; } while(0); \
        if (!Success) SetLastError(PreserveLastError); \
    } while(0)

#define StringLength    _tcslen
#define StringCopy      _tcscpy
#define StringAppend    _tcscat
#define FindLastChar    _tcsrchr

BOOL
SxspIsPathSeperator(
    TCHAR ch
    )
{
    return (_tcschr(rgchPathSeperators, ch) != NULL);
}

VOID
__cdecl
SxspDebugOut(
    LPCTSTR Format,
    ...
    )
{
    //
    // DebugLog directly doesn't quite work out, because
    // it wants %1 formatting, where we have GetLastError().
    // Unless we duplicate all of our messages..
    //
    TCHAR Buffer[2000];
    va_list args;
    const BOOL Success = TRUE; // PRESERVE_LAST_ERROR

    Buffer[0] = 0;

    va_start(args, Format);
    _vsntprintf(Buffer, NUMBER_OF(Buffer), Format, args);
    va_end(args);
    if (Buffer[0] != 0)
    {
        LPTSTR End;
        SIZE_T Length;

        Buffer[NUMBER_OF(Buffer) - 1] = 0;

        PRESERVE_LAST_ERROR(OutputDebugString(Buffer));

        Length = StringLength(Buffer);
        End = Buffer + Length - 1;
        while (*End == ' ' || *End == '\t' || *End == '\n' || *End == '\r')
            *End-- = 0;
        DebugLog(Winnt32LogError, TEXT("%1"), 0, Buffer);
    }
}

VOID
SxspRemoveTrailingPathSeperators(
    LPTSTR s
    )
{
    if (s != NULL && s[0] != 0)
    {
        LPTSTR t;
        //
        // This is inefficient, in order to be mbcs correct,
        // but there aren't likely to be more than one or two.
        //
        while ((t = _tcsrchr(s, rgchPathSeperators[0])) != NULL && *(t + 1) == 0)
        {
            *t = 0;
        }
    }
}

VOID
SxspGetPathBaseName(
    LPCTSTR Path,
    LPTSTR  Base
    )
{
    LPCTSTR Dot = FindLastChar(Path, '.');
    LPCTSTR Slash = FindLastChar(Path, rgchPathSeperators[0]);
    //
    // beware \foo.txt\bar
    // beware \bar
    // beware bar
    // beware .bar
    // beware \.bar
    //
    *Base = 0;
    if (Slash == NULL)
        Slash = Path;
    else
        Slash += 1;
    if (Dot == NULL || Dot < Slash)
        Dot = Path + StringLength(Path);
    CopyMemory(Base, Slash, (Dot - Slash) * sizeof(*Base));
    Base[Dot - Slash] = 0;
}

BOOL
SxspIsDotOrDotDot(
    PCTSTR s
    )
{
    return (s[0] == '.' && (s[1] == 0 || (s[1] == '.' && s[2] == 0)));
}

const static LPCTSTR DotManifestExtensions[] =
    { TEXT(".Man"), TEXT(".Dll"), TEXT(".Manifest"), TEXT(".Policy") };
const static LPCTSTR DotCatalogExtensions[] = { TEXT(".Cat"), TEXT(".Ca_") };

BOOL
SxspGetSameNamedFileWithExtensionFromList(
    PSXS_CHECK_LOCAL_SOURCE Context,
    LPCTSTR         Directory,
    CONST LPCTSTR   Extensions[],
    SIZE_T          NumberOfExtensions,
    LPTSTR          File
    )
{
    const static TCHAR T_FUNCTION[] = TEXT("SxspGetSameNamedFileWithExtensionFromList");
    LPTSTR FileEnd = NULL;
    PTSTR Base = NULL;
    DWORD FileAttributes = 0;
    SIZE_T i = 0;
    BOOL Success = FALSE;

    File[0] = 0;

    StringCopy(File, Directory);
    SxspRemoveTrailingPathSeperators(File);
    Base = File + StringLength(File) + 1;
    SxspGetPathBaseName(Directory, Base);
    Base[-1] = rgchPathSeperators[0];
    FileEnd = Base + StringLength(Base);

    for (i = 0 ; i != NumberOfExtensions ; ++i)
    {
        StringCopy(FileEnd, Extensions[i]);
        FileAttributes = GetFileAttributes(File);
        if (FileAttributes != INVALID_FILE_ATTRIBUTES)
        {
            if ((FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
            {
                return TRUE;
            }
        }
        else
        {
            const DWORD LastError = GetLastError();
            if (LastError != ERROR_FILE_NOT_FOUND
                && LastError != ERROR_PATH_NOT_FOUND
                )
            {
                SxspDebugOut(
                    TEXT("SXS: %s(%s):GetFileAttributes(%s):%lu\n"),
                    T_FUNCTION,
                    Directory,
                    File,
                    LastError
                    );
                MessageBoxFromMessage(
                    Context->ParentWindow,
                    LastError,
                    TRUE,
                    AppTitleStringId,
                    MB_OK | MB_ICONERROR | MB_TASKMODAL
                    );
                File[0] = 0;
                Success = FALSE;
                goto Exit;
            }
        }
    }
    File[0] = 0;
    Success = TRUE;
Exit:
    return Success;
}

BOOL
SxspCheckFile(
    PSXS_CHECK_LOCAL_SOURCE Context,
    LPCTSTR File
    )
{
    BYTE        Buffer[512];
    static BYTE Zeroes[sizeof(Buffer)];
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    DWORD BytesRead = 0;
    BOOL Success = FALSE;

    FileHandle = CreateFile(
        File,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (FileHandle == INVALID_HANDLE_VALUE)
    {
        CONST DWORD LastError = GetLastError();
        SxspDebugOut(TEXT("SXS: unable to open file %s, error %lu\n"), File, LastError);
        MessageBoxFromMessageAndSystemError(
            Context->ParentWindow,
            MSG_SXS_ERROR_FILE_OPEN_FAILED,
            GetLastError(),
            AppTitleStringId,
            MB_OK | MB_ICONERROR | MB_TASKMODAL,
            File
            );
        Success = FALSE;
        goto Exit;
    }
    if (!ReadFile(FileHandle, Buffer, sizeof(Buffer), &BytesRead, NULL))
    {
        CONST DWORD LastError = GetLastError();
        SxspDebugOut(TEXT("SXS: ReadFile(%s) failed %lu\n"), File, LastError);
        MessageBoxFromMessageAndSystemError(
            Context->ParentWindow,
            MSG_